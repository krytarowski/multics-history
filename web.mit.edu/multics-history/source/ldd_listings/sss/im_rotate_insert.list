	COMPILATION LISTING OF SEGMENT im_rotate_insert
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-17_1936.95_Mon_mdt
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION
        8*
        9*          This module attempts to make room in the node control interval in
       10*     which the new key is to be inserted by moving keys, one-at-a-time, from
       11*     the lower numbered slots of the new key's node into the previous node.
       12*     Keys are rotated until:
       13*          1) enough room is made in the new key's node to
       14*	   insert the new key;
       15*	2) there is no more room in the previous node to
       16*	   rotate keys into it; or,
       17*	3) all of the lower-slot keys have been rotated.
       18*     
       19*          The first case is a successful rotation, and this module is done.
       20*
       21*          The second case indicates that the  "rotate_previous" can not
       22*     (ultimately) succeed in finding room to insert the new key, and this
       23*     module has "failed", also indicating the module is done.
       24*
       25*          The third case requires further investigation.  Either the new key
       26*     will fit in the "previous" node or it won't.  In the former situation, it
       27*     is inserted in the previous node and this module has succeeded.  In the
       28*     latter case this module has failed.  In either event, it is done.
       29*
       30*     NOTE:
       31*          The target node (control interval) of the rotation, the previous
       32*     node, may be empty (i.e., contain no keys).  This requires some special
       33*     care in using/setting the key_range of the target node's header.  This
       34*     situation arises when a node is being split.  First a new node is set up
       35*     by im_general_insert/replace, using im_split, then keys are rotated out
       36*     of the "old" node into the "new" one, using this module.
       37*
       38**/
       39 
       40 /* HISTORY:
       41*Written by Lindsey Spratt, 04/07/82.
       42*Modified:
       43*06/07/82 by Lindsey Spratt:  Changed to set the "new" (target) node (from a
       44*	  split) to point to the "old" (source) node's old parent key as its
       45*	  parent key, rather than having the "new" and "old" nodes point to
       46*	  the same key as their parent key.
       47*06/16/82 by Matthew Pierret: Removed the beginning_offset argument from
       48*            calls to collection_manager_$put_element.
       49*07/20/82 by Lindsey Spratt:  Fixed branch node rotation.  The control interval
       50*	  pointed at by the low_branch_id was being "lost" when one or more
       51*	  keys was rotated and the target of the rotation was not empty
       52*	  (i.e., the rotation was not being done as part of a "split").
       53*	  Added rotation to the "next" node.  Changed name of procedure from
       54*	  im_rotate_previous_insert to im_rotate_insert.
       55*08/02/82 by Lindsey Spratt:  Fixed rotate "next" to correctly increment the
       56*	  key_range.last value in the target_ci.  Fixed setting of the
       57*	  key_string_ptr to set the correct string_ptr.
       58*08/05/82 by Lindsey Spratt:  Fixed the calls to general_insert to have the
       59*	  local_branch_ci_header filled in correctly in the case where the
       60*	  parent key is to be replaced.
       61*08/09/82 by Matthew Pierret:  Removed offset and length arguments in calls to
       62*            collection_manager_$get_element.  Changed new_ci to be aligned.
       63*09/02/82 by Lindsey Spratt:  Changed to use version 2 of the index_cursor
       64*	  structure.  Fixed "bad version" sub_err_ call (in check_version).
       65*09/11/82 by Lindsey Spratt:  Changed to set the branch_ci_header_ptr or 
       66*            leaf_ci_header_ptr equal to common_ci_header_ptr, according to the
       67*            value of common_ci_header.is_leaf.
       68*09/16/82 by Lindsey Spratt:  Completely re-structured the module from a single
       69*	  main execution path with many conditionals to 8 major cases based
       70*	  on: rotate previous or next, nodes are branches or leaves, target
       71*	  node is initially empty or non-empty.
       72*09/21/82 by Lindsey Spratt:  Added the internal_debug switch.  When on, the
       73*	  "rotate" internal procedure prints a description of what kind of
       74*	  rotation was done and how much was rotated.  The debug_on and
       75*	  debug_off entries set this switch.  Also, changed the rotation
       76*	  loop (labeled "ROTATE_KEY_LOOP") to terminate based on the
       77*	  amount_of_storage_to_be_moved, rather than the
       78*	  additional_storage_required.  The amount_of_storage_to_be_moved is
       79*	  set to the maximum of the additional_storage_required and half of
       80*	  the key_tail_space_used_since_last_prefix_compaction.
       81*09/22/82 by Lindsey Spratt:  All four of the branch rotation cases  now
       82*	  attempt to put/alloc the new key string in the low_branch_id, if
       83*	  possible.  It is only possible if the desired slot has been
       84*	  rotated down (or up, if it is a next rotation) to the "low_branch"
       85*	  location.  Added the "put_headers" and "convert_low_branch_to_key"
       86*	  internal procedures.  Changed the "empty branch" rotations to be
       87*	  prepared for a target with a non-zero low_branch_id.
       88*09/24/82 by Lindsey Spratt:  Removed the superfluous
       89*	  "there_is_more_room_in_target_ci" case from the branch rotations.
       90*	  Changed the next_branch rotations to compare the desired slot
       91*	  against the last source slot, instead of the last target slot,
       92*	  when deciding to insert or put at the low_branch_id.  Changed the
       93*	  nex_branch_rotations to update the source branches when the result
       94*	  of the rotation is to insert into the midst of the source node.
       95*11/02/82 by Lindsey Spratt:  Changed to use index_opening_info to get  the
       96*	  file_opening_id and the collection_id instead of the index_cursor.
       97*	  Changed to get the field_table_ptr out of the index_opening_info
       98*	  rather than passing it as a separate parameter.  Changed all
       99*	  internal procedure names to uppercase.  Changed the calling
      100*	  sequence to have p_index_opening_info_ptr instead of
      101*	  p_index_header_ptr, p_cursor_ptr, and p_field_table_ptr.  Changed
      102*	  to record the new root_id by calling im_update_opening_info$root_id
      103*	  rather than setting it directly.  Changed to use new calling
      104*	  sequences to im_update_branches and im_general_insert.
      105*01/17/83 by Matthew Pierret:  Changed to fully qualify references to
      106*            (common branch leaf)_ci_header. source_ci_header_ptr is used in 
      107*            those places that were previously unqualified.
      108*            Changed to use the buffered access method during rotation.
      109*            Added the internal subroutines ALLOCATE_ELEMENT and FREE_ELEMENT,
      110*            which, along with GET_ELEMENT and PUT_ELEMENT, access CIs in 
      111*            either buffered or unbuffered mode according to the value of the 
      112*            global flag use_soure_and_target_ci_buffers.
      113*01/19/83 by Matthew Pierret: Changed to correctly intitialize range.last in
      114*            the target ci when allocating the first key in the ci (in
      115*            ALLOCATE_KEY_IN_TARGET_CI).
      116*01/25/83 by Lindsey Spratt:  Changed SETUP_PARENT_KEY_FROM_LEAF to get
      117*	  the "high" key from key_range.first and the "low" key from
      118*	  key_range.last, using the source or target CI based on whether a
      119*	  rotate previous or next (respectively) is being done.  Changed
      120*	  ROTATE to set the (high low)_key_string_ptr's appropriately.
      121*	  Changed all of the rotation cases to return immediately upon
      122*	  discovering that nothing can be moved from the source CI into the
      123*	  target CI, and that the p_key_string cannot be put/allocated
      124*	  anywhere, rather than continuing through the "cleanup" code at the
      125*	  end of each case (which is pointless and potentially harmful).
      126*01/26/83 by Lindsey Spratt:  Changed the get,put, free and allocate primitives
      127*	  to check not only that use_source_and_target_ci_buffers is on
      128*	  before using the buffered constraint_idx cm_ entry, but also that
      129*	  the requested CI is either the source or the target CI.
      130*01/27/83 by Lindsey Spratt:  Fixed FREE_ELEMENT to not always call
      131*	  cm_$free_element, which it was doing regardless of whether it 
      132*	  call cm_$free_element_buffered or not.
      133*04/12/83 by Lindsey L. Spratt:  Changed ALLOCATE_KEY_IN_TARGET_CI to set the
      134*            one_or_more_keys_were_rotated flag on so that its callers will
      135*            know to fix the parent key.
      136*04/13/83 by Lindsey L. Spratt:  Fixed CONVERT_LOW_BRANCH_TO_KEY to set the
      137*            branch_key.branch_id before putting the new branch_key, rather
      138*            than after (when it no longer matters).  The branch_key was being
      139*            stored with a garbage branch_id.
      140*10/24/83 by Lindsey L. Spratt:  Fixed to invoke update_branches on the source
      141*            in the PREVIOUS_NONEMPTY_BRANCH rotation case after putting the
      142*            buffered ci's.
      143*10/28/83 by Lindsey L. Spratt:  Fixed to update the source branches in a
      144*            particular subcase of the PREVIOUS_ROTATION_INTO_NONEMPTY_BRANCH
      145*            case which was not being caught previously.
      146*10/31/83 by Lindsey L. Spratt:  Fixed next rotations to not move the target
      147*            slot out of the source ci when doing a replacement
      148*            (^p_insert_new_key) operation.
      149*11/08/83 by Lindsey L. Spratt:  Changed to use new im_update_branches calling
      150*            sequence, which requires a node_buffer_ptr.
      151*03/13/84 by Lindsey L. Spratt:  Fixed the PREVIOUS_ROTATION_INTO_EMPTY_BRANCH
      152*            procedure to set low_index to key_range.first + 1 instead of + 2.
      153*            This only caused a problem when the key_id.index = 3.
      154*03/14/84 by Lindsey L. Spratt:  Fixed the previous branch rotations to
      155*            decrement the addr(p_key_id_string) -> element_id.index when doing
      156*            a COMPRESS_LOW_BRANCH, since the p_key insertion point will move
      157*            down by one as a result of the compression.
      158*           Fixed previous_rotation_into_empty_branch to do a
      159*            im_update_branches$single when just the low_branch_id of the
      160*            source_ci was changed.
      161*05/10/84 by Matthew Pierret:  Changed to align buffers on even-word
      162*            boundaries.
      163*06/06/84 by Matthew Pierret:  Re-named cm_$free_element to cm_$delete,
      164*            cm_$free_element_buffered to cm_$delete_from_ci_buffer,
      165*            cm_$*buffered_ci to cm_$=ci_buffer, cm_$simple_get_element_buffered
      166*            to cm_$simple_get_from_ci_buffer, cm_$get_element to cm_$get,
      167*            cm_$put_element to cm_$modify, cm_$put_element_buffered to
      168*            cm_$modify_in_ci_buffer, PUT_ELEMENT to MODIFY_ELEMENT,
      169*            cm_$allocate_element to cm_$put, cm_$allocate_element_buffered to
      170*            cm_$put_in_ci_buffer, ALLOCATE_ELEMENT to PUT_ELEMENT.
      171*10/28/84 by Lindsey L. Spratt:  Changed to use version 2 index_opening_info.
      172*11/15/84 by Lindsey L. Spratt:  Changed the modularization of the program.
      173*02/08/84 by R. Michael Tague:  Changed so that ROTATE_(PREVIOUS NEXT)_BRANCH
      174*            will always correctly set the low branch id.
      175*03/07/85 by R. Michael Tague:  Changed opening info version to version 3.
      176*03/22/85 by Lindsey L. Spratt:  Fixed to always call im_update_branches on the
      177*            target_ci in ROTATE_PREVIOUS_BRANCH.
      178**/
      179 
      180 /* format: style2,ind3 */
      181 
      182 im_rotate_insert:
      183    proc (p_index_opening_info_ptr, p_common_ci_header_ptr, p_rotate_previous, p_insert_new_key, p_insert_parent_key,
      184         p_key_string, p_key_id_string, p_additional_storage_required, p_code);
      185 
      186 /* START OF DECLARATIONS */
      187 /* Parameter */
      188 
      189       dcl	    p_index_opening_info_ptr
      190 			       ptr parameter;
      191       dcl	    p_insert_new_key       bit (1) aligned parameter;
      192       dcl	    p_common_ci_header_ptr ptr parameter;
      193       dcl	    p_rotate_previous      bit (1) aligned parameter;
      194       dcl	    p_insert_parent_key    bit (1) aligned parameter;
      195       dcl	    p_key_string	       bit (*) parameter;
      196       dcl	    p_key_id_string	       bit (36) aligned parameter;
      197       dcl	    p_additional_storage_required
      198 			       fixed bin (35) parameter;
      199       dcl	    p_code	       fixed bin (35) parameter;
      200 
      201 /* Automatic */
      202 
      203       dcl	    1 local_branch_ci_header
      204 			       like branch_ci_header;
      205       dcl	    new_ci	       fixed bin (24) unsigned;
      206 
      207 
      208       dcl	    temp_key_string_length fixed bin (35);
      209 
      210       dcl	    (source_ci, target_ci) fixed bin (24) unsigned unaligned;
      211       dcl	    target_element_id_string
      212 			       bit (36) aligned;
      213       dcl	    source_key_index       fixed bin (12) unsigned unaligned;
      214       dcl	    (source_ci_header_ptr, target_ci_header_ptr, source_ci_ptr, target_ci_ptr)
      215 			       ptr;
      216       dcl	    temp_key_string_ptr    ptr;
      217       dcl	    old_temp_key_string_ptr
      218 			       ptr;
      219       dcl	    one_or_more_keys_were_rotated
      220 			       bit (1) aligned;
      221       dcl	    target_ci_was_empty    bit (1) aligned;
      222       dcl	    high_key_string_ptr    ptr;
      223       dcl	    low_key_string_ptr     ptr;
      224       dcl	    current_key_buffer_ptr ptr;
      225       dcl	    old_key_buffer_ptr     ptr;
      226 
      227       dcl	    (source_ci_header_has_changed, source_ci_has_changed, target_ci_header_has_changed, target_ci_has_changed,
      228 	    update_target_branches, update_source_branches, there_is_more_room_in_target_ci,
      229 	    use_source_and_target_ci_buffers)
      230 			       bit (1) aligned init ("0"b);
      231       dcl	    original_target_index  fixed bin (12) unsigned unaligned;
      232       dcl	    (low_index, high_index)
      233 			       fixed bin (35);
      234       dcl	    rotate_idx	       fixed bin (35);
      235 
      236       dcl	    (target_header_buffer, local_fsk_header_buffer)
      237 			       bit (max (LEAF_CI_HEADER_LENGTH_IN_BITS, BRANCH_CI_HEADER_LENGTH_IN_BITS)) aligned;
      238       dcl	    (local_key_buffer_1, local_key_buffer_2, local_key_buffer_3, local_parent_key_buffer,
      239 	    local_source_ci_buffer, local_target_ci_buffer)
      240 			       (DOUBLE_WORDS_PER_PAGE) fixed bin (71);
      241 
      242       dcl	    total_amount_of_storage_moved
      243 			       fixed bin (24);
      244       dcl	    additional_storage_required
      245 			       fixed bin (24);
      246       dcl	    total_storage_available
      247 			       fixed bin (35);
      248       dcl	    amount_of_storage_to_be_moved
      249 			       fixed bin (24);
      250 
      251 /* Based */
      252 
      253       dcl	    based_header_buffer    bit (max (LEAF_CI_HEADER_LENGTH_IN_BITS, BRANCH_CI_HEADER_LENGTH_IN_BITS))
      254 			       based aligned;
      255       dcl	    (
      256 	    key_buffer	       based,
      257 	    key_buffer_1	       based (addr (local_key_buffer_1)),
      258 	    key_buffer_2	       based (addr (local_key_buffer_2)),
      259 	    key_buffer_3	       based (addr (local_key_buffer_3)),
      260 	    parent_key_buffer      based (addr (local_parent_key_buffer)),
      261 	    source_ci_buffer       based (addr (local_source_ci_buffer)),
      262 	    target_ci_buffer       based (addr (local_target_ci_buffer))
      263 	    )		       bit (BITS_PER_PAGE) aligned;
      264       dcl	    1 target_element_id    like element_id based (addr (target_element_id_string));
      265       dcl	    1 p_key_id	       aligned like element_id based (addr (p_key_id_string));
      266       dcl	    1 source_parent_id     aligned like element_id
      267 			       based (addr (source_ci_header_ptr -> common_ci_header.parent_id_string));
      268       dcl	    source_parent_id_string
      269 			       aligned bit (36)
      270 			       based (addr (source_ci_header_ptr -> common_ci_header.parent_id_string));
      271       dcl	    1 target_parent_id     aligned like element_id
      272 			       based (addr (target_ci_header_ptr -> common_ci_header.parent_id_string));
      273       dcl	    target_parent_id_string
      274 			       aligned bit (36)
      275 			       based (addr (target_ci_header_ptr -> common_ci_header.parent_id_string));
      276 
      277 /* Builtin */
      278 
      279       dcl	    (addr, divide, length, max, null, unspec)
      280 			       builtin;
      281 
      282 /* Controlled */
      283 /* Constant */
      284 
      285       dcl	    ALL_FIELDS_PRESENT     init (-1) fixed bin (17) unal internal static options (constant);
      286 
      287       dcl	    (
      288 	    LEAF_NODE	       init ("1"b),
      289 	    BRANCH_NODE	       init ("0"b),
      290 	    REPLACE_KEY	       init ("0"b),
      291 	    INSERT_KEY	       init ("1"b),
      292 	    PREVIOUS_ROTATION      init ("1"b),
      293 	    NEXT_ROTATION	       init ("0"b),
      294 	    DONT_UPDATE_STORAGE_MOVED
      295 			       init ("0"b),
      296 	    UPDATE_STORAGE_MOVED   init ("1"b)
      297 	    )		       bit (1) aligned internal static options (constant);
      298 
      299       dcl	    (
      300 	    BITS_PER_PAGE	       init (36 * 1024),
      301 	    DOUBLE_WORDS_PER_PAGE  init (512)
      302 	    )		       fixed bin internal static options (constant);
      303 
      304       dcl	    myname	       init ("im_rotate_insert") char (16) internal static options (constant);
      305 
      306 /* Entry */
      307 
      308       dcl	    ioa_		       entry () options (variable);
      309       dcl	    sub_err_	       entry () options (variable);
      310       dcl	    im_general_insert      entry (ptr, ptr, bit (1) aligned, bit (*), bit (36) aligned, fixed bin (35));
      311       dcl	    im_init_branch_ci_header
      312 			       entry (ptr);
      313       dcl	    im_make_parent_key     entry (ptr, ptr, fixed bin unal, ptr, fixed bin unal, ptr, fixed bin (35), ptr, ptr,
      314 			       fixed bin (35), bit (1) aligned, fixed bin (35));
      315       dcl	    im_update_branches     entry (ptr, bit (36) aligned, bit (36) aligned, ptr, uns fixed bin (24) unal,
      316 			       uns fixed bin (12) unal, fixed bin (35));
      317       dcl	    im_update_branches$single
      318 			       entry (ptr, bit (36) aligned, bit (36) aligned, ptr, uns fixed bin (24) unal,
      319 			       uns fixed bin (12) unal, fixed bin (35));
      320       dcl	    im_update_opening_info$root_id
      321 			       entry (ptr, uns fixed bin (24), fixed bin (35));
      322 
      323 
      324 /* External */
      325 
      326       dcl	    error_table_$unimplemented_version
      327 			       fixed bin (35) ext;
      328       dcl	    dm_error_$long_element fixed bin (35) ext;
      329 
      330 /* Static */
      331 
      332       dcl	    internal_debug	       bit (1) aligned internal static init ("0"b);
      333 
      334 /* END OF DECLARATIONS */
      335 
      336       p_code = 0;
      337 
      338       call INITIALIZE (p_rotate_previous);
      339 
      340       if source_ci_header_ptr -> common_ci_header.is_leaf
      341       then if p_rotate_previous
      342 	 then if target_ci_was_empty
      343 	      then call PREVIOUS_ROTATION_INTO_EMPTY_LEAF;
      344 	      else call PREVIOUS_ROTATION_INTO_NONEMPTY_LEAF;
      345 	 else if target_ci_was_empty
      346 	 then call NEXT_ROTATION_INTO_EMPTY_LEAF;
      347 	 else call NEXT_ROTATION_INTO_NONEMPTY_LEAF;
      348       else if p_rotate_previous
      349       then if target_ci_was_empty
      350 	 then call PREVIOUS_ROTATION_INTO_EMPTY_BRANCH;
      351 	 else call PREVIOUS_ROTATION_INTO_NONEMPTY_BRANCH;
      352       else if target_ci_was_empty
      353       then call NEXT_ROTATION_INTO_EMPTY_BRANCH;
      354       else call NEXT_ROTATION_INTO_NONEMPTY_BRANCH;
      355 
      356       if p_additional_storage_required > 0
      357       then call ERROR_RETURN (dm_error_$long_element);
      358 
      359 MAIN_RETURN:
      360       return;
      361 
      362 
      363 ERROR_RETURN:
      364    proc (er_p_code);
      365       dcl	    er_p_code	       fixed bin (35);
      366       p_code = er_p_code;
      367       goto MAIN_RETURN;
      368    end ERROR_RETURN;
      369 
      370 
      371 debug_on:
      372    entry ();
      373       internal_debug = "1"b;
      374       return;
      375 
      376 debug_off:
      377    entry ();
      378       internal_debug = "0"b;
      379       return;
      380 
      381 
      382 /* This procedure is used to increment the target_element_id. */
      383 
      384 ADJUST_TARGET_ELEMENT_ID_FOR_PREVIOUS_INSERT:
      385    proc ();
      386       if target_element_id.index = 0
      387       then target_element_id.index = DEFAULT_INITIAL_KEY_SLOT;
      388       else target_element_id.index = target_element_id.index + 1;
      389    end ADJUST_TARGET_ELEMENT_ID_FOR_PREVIOUS_INSERT;
      390 
      391 
      392 /* This procedure is used to decrement the target_element_id. */
      393 
      394 ADJUST_TARGET_ELEMENT_ID_FOR_NEXT_INSERT:
      395    proc ();
      396       if target_element_id.index = 0
      397       then target_element_id.index = DEFAULT_INITIAL_KEY_SLOT;
      398    end ADJUST_TARGET_ELEMENT_ID_FOR_NEXT_INSERT;
      399 
      400 
      401 
      402 /* This procedure is used to attempt to place the new key in the target ci.
      403*If the key is being modified (^p_insert_key), then the old version of the key
      404*exists in the source ci, and must be deleted.
      405*
      406*The two parameters are both output parameters.  akitc_p_key_string_ptr only
      407*being set if the attempted insertion is successful, and akitc_p_key_doesnt_fit
      408*being set to "1"b if the insertion is unsuccessful.
      409**/
      410 
      411 ALLOCATE_KEY_IN_TARGET_CI:
      412    proc (akitc_p_key_string_ptr, akitc_p_key_doesnt_fit);
      413       dcl	    akitc_p_key_string_ptr ptr parameter;
      414       dcl	    akitc_p_key_doesnt_fit bit (1) aligned parameter;
      415 
      416       dcl	    akitc_element_allocated
      417 			       bit (1) aligned;
      418 
      419       call PUT_ELEMENT_TEST (target_element_id_string, length (p_key_string), addr (p_key_string),
      420 	 total_storage_available, akitc_element_allocated);
      421       if akitc_element_allocated
      422       then
      423          do;					/* Success !! */
      424 	  additional_storage_required = 0;
      425 	  one_or_more_keys_were_rotated = "1"b;
      426 	  if target_ci_header_ptr -> common_ci_header.key_range.first = 0
      427 	  then target_ci_header_ptr -> common_ci_header.key_range.first,
      428 		  target_ci_header_ptr -> common_ci_header.key_range.last = DEFAULT_INITIAL_KEY_SLOT;
      429 	  else target_ci_header_ptr -> common_ci_header.key_range.last =
      430 		  target_ci_header_ptr -> common_ci_header.key_range.last + 1;
      431 	  target_ci_header_ptr -> common_ci_header.key_tail_space_used_since_last_prefix_compaction =
      432 	       target_ci_header_ptr -> common_ci_header.key_tail_space_used_since_last_prefix_compaction
      433 	       + length (p_key_string);
      434 
      435 	  target_ci_header_has_changed = "1"b;
      436 	  call SET_STRING_PTR (source_ci_header_ptr -> common_ci_header.is_leaf, addr (p_key_string),
      437 	       akitc_p_key_string_ptr);
      438 
      439 /* The old version of the key being replaced must be freed from the source_ci,
      440*as the new version is now in the target_ci. */
      441 
      442 	  if ^p_insert_new_key
      443 	  then call DELETE_KEY (p_key_id.control_interval_id, p_key_id.index, source_ci_header_ptr,
      444 		  length (p_key_string), source_ci_header_has_changed, update_source_branches);
      445 						/* length(p_key_string) is an approximation of the length of the old version of the key. */
      446 
      447 	  p_key_id_string = target_element_id_string;
      448 
      449          end;
      450       akitc_p_key_doesnt_fit = ^akitc_element_allocated;
      451    end ALLOCATE_KEY_IN_TARGET_CI;
      452 
      453 /* This procedure is used to enforce a constraint on the structure of indexes,
      454*that only adjacent nodes **with the same parent node** may be used when
      455*rotating keys.
      456**/
      457 
      458 CHECK_NODES_HAVE_SAME_PARENT:
      459    proc;
      460       if target_parent_id.control_interval_id ^= source_parent_id.control_interval_id
      461       then call ERROR_RETURN (dm_error_$long_element);
      462 
      463    end CHECK_NODES_HAVE_SAME_PARENT;
      464 
      465 /* This procedure is invoked when the insertion of p_key_string has failed
      466*(presumably for lack of space in both the source and target CIs).  The
      467*csr_p_additional_storage_required parameter is an input/output parameter which
      468*is decremented  by the csr_p_total_amount_of_storage_moved.  If no storage was
      469*moved at all, then the error exit of im_rotate_insert is invoked.
      470**/
      471 
      472 CHECK_STORAGE_REQUIREMENTS:
      473    proc (csr_p_total_amount_of_storage_moved, csr_p_additional_storage_required);
      474       dcl	    csr_p_total_amount_of_storage_moved
      475 			       fixed bin (24) parameter;
      476       dcl	    csr_p_additional_storage_required
      477 			       fixed bin (24) parameter;
      478 
      479       if csr_p_total_amount_of_storage_moved = 0
      480       then call ERROR_RETURN (dm_error_$long_element);
      481 
      482       csr_p_additional_storage_required = csr_p_additional_storage_required - csr_p_total_amount_of_storage_moved;
      483 
      484    end CHECK_STORAGE_REQUIREMENTS;
      485 
      486 CHECK_VERSION:
      487    proc (cv_p_received_version, cv_p_expected_version, cv_p_structure_name);
      488       dcl	    cv_p_received_version  char (8) aligned parameter;
      489       dcl	    cv_p_expected_version  char (8) aligned parameter;
      490       dcl	    cv_p_structure_name    char (*);
      491 
      492       if cv_p_expected_version ^= cv_p_received_version
      493       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      494 	      "^/Expected version ^d of the ^a structure. Received version ^d instead.", cv_p_expected_version,
      495 	      cv_p_structure_name, cv_p_received_version);
      496 
      497    end CHECK_VERSION;
      498 
      499 /* This procedure takes a node which has no key in its low_branch_id slot and
      500*moves the first branch key branch id into the low_branch_id slot, deleting
      501*(freeing) the branch_key itself.
      502**/
      503 
      504 COMPRESS_LOW_BRANCH_ID:
      505    proc (clbi_p_update_storage_moved, clbi_p_control_interval_id, clbi_p_ci_header_ptr, clbi_p_ci_header_has_changed,
      506         clbi_p_update_branches);
      507       dcl	    clbi_p_update_storage_moved
      508 			       bit (1) aligned parameter;
      509       dcl	    clbi_p_control_interval_id
      510 			       fixed bin (24) unsigned unaligned parameter;
      511       dcl	    clbi_p_ci_header_ptr   ptr parameter;
      512       dcl	    clbi_p_ci_header_has_changed
      513 			       bit (1) aligned parameter;
      514       dcl	    clbi_p_update_branches bit (1) aligned parameter;
      515 
      516       dcl	    1 clbi_element_id      aligned like element_id;
      517       dcl	    clbi_temp_key_string_length
      518 			       fixed bin (35);
      519 
      520       clbi_element_id.control_interval_id = clbi_p_control_interval_id;
      521       clbi_element_id.index = clbi_p_ci_header_ptr -> common_ci_header.key_range.first;
      522 
      523       call GET_ELEMENT (clbi_element_id.control_interval_id, clbi_element_id.index, key_buffer_3,
      524 	 clbi_temp_key_string_length);
      525 
      526       bk_string_length = 0;
      527 
      528       clbi_p_ci_header_ptr -> branch_ci_header.low_branch_id = addr (key_buffer_3) -> branch_key.branch_id;
      529 
      530       call DELETE_KEY (clbi_element_id.control_interval_id, clbi_element_id.index, clbi_p_ci_header_ptr,
      531 	 clbi_temp_key_string_length, clbi_p_ci_header_has_changed, clbi_p_update_branches);
      532 
      533       if clbi_p_update_storage_moved = UPDATE_STORAGE_MOVED
      534       then total_amount_of_storage_moved = total_amount_of_storage_moved + clbi_temp_key_string_length;
      535 
      536    end COMPRESS_LOW_BRANCH_ID;
      537 
      538 /* This procedure takes the low_branch_id of a node and creates an
      539*appropriately valued branch_key with that branch id.  The newly created key is
      540*always inserted into the target_ci, although it can be created from either the
      541*source or target ci's low_branch_id.
      542**/
      543 
      544 CONVERT_LOW_BRANCH_TO_TARGET_KEY:
      545    proc (clbttk_p_target_element_id_adjustment_proc, clbttk_p_ci_header_ptr, clbttk_p_ci_header_has_changed);
      546       dcl	    clbttk_p_target_element_id_adjustment_proc
      547 			       entry () variable parameter;
      548       dcl	    clbttk_p_ci_header_ptr ptr parameter;
      549       dcl	    clbttk_p_ci_header_has_changed
      550 			       bit (1) aligned parameter;
      551 
      552       dcl	    clbttk_code	       fixed bin (35);
      553 
      554 
      555       call FIND_SPLIT_KEYS (clbttk_p_ci_header_ptr -> branch_ci_header.low_branch_id, key_buffer_1, key_buffer_2);
      556 
      557       call im_make_parent_key (index_opening_info.field_table_ptr, addr (key_buffer_1), ALL_FIELDS_PRESENT,
      558 	 addr (key_buffer_2), ALL_FIELDS_PRESENT, addr (parent_key_buffer), length (parent_key_buffer), null,
      559 	 branch_key_ptr, bk_string_length, "0"b, clbttk_code);
      560       if clbttk_code ^= 0
      561       then call ERROR_RETURN (clbttk_code);
      562 
      563       branch_key.branch_id = clbttk_p_ci_header_ptr -> branch_ci_header.low_branch_id;
      564 
      565       call clbttk_p_target_element_id_adjustment_proc ();
      566 
      567       call PUT_KEY (target_element_id.control_interval_id, target_element_id.index, length (unspec (branch_key)),
      568 	 branch_key_ptr, target_ci_header_ptr, target_ci_header_has_changed, update_target_branches,
      569 	 total_storage_available);
      570 
      571 
      572       clbttk_p_ci_header_has_changed = "1"b;
      573       clbttk_p_ci_header_ptr -> branch_ci_header.low_branch_id = 0;
      574 
      575    end CONVERT_LOW_BRANCH_TO_TARGET_KEY;
      576 
      577 /* This procedure deletes a key from the source ci. */
      578 
      579 DELETE_KEY:
      580    proc (dk_p_control_interval_id, dk_p_index, dk_p_ci_header_ptr, dk_p_key_length, dk_p_ci_header_has_changed,
      581         dk_p_update_branches);
      582       dcl	    dk_p_control_interval_id
      583 			       fixed bin (24) unsigned unaligned parameter;
      584       dcl	    dk_p_index	       fixed bin (12) unsigned unaligned parameter;
      585       dcl	    dk_p_ci_header_ptr     ptr parameter;
      586       dcl	    dk_p_key_length	       fixed bin (35) parameter;
      587       dcl	    dk_p_ci_header_has_changed
      588 			       bit (1) aligned parameter;
      589       dcl	    dk_p_update_branches   bit (1) aligned parameter;
      590 
      591       call DELETE_ELEMENT (dk_p_control_interval_id, dk_p_index);
      592 
      593       dk_p_ci_header_ptr -> common_ci_header.key_range.last = dk_p_ci_header_ptr -> common_ci_header.key_range.last - 1;
      594       dk_p_ci_header_ptr -> common_ci_header.key_tail_space_used_since_last_prefix_compaction =
      595 	 max (0,
      596 	 dk_p_ci_header_ptr -> common_ci_header.key_tail_space_used_since_last_prefix_compaction - dk_p_key_length);
      597 
      598       dk_p_ci_header_has_changed = "1"b;
      599 
      600 /* Set the dk_p_update_branches indicator only if it hasn't already been
      601*turned on.  Once on, leave it on.
      602**/
      603 
      604       if ^dk_p_update_branches
      605       then if (dk_p_index < dk_p_ci_header_ptr -> common_ci_header.key_range.last)
      606 	 then dk_p_update_branches = "1"b;
      607 
      608    end DELETE_KEY;
      609 
      610 /* This procedure finds the two leaf keys "split" by a branch key.  It does so
      611*by finding the least leaf key in the subtree identified by the branch_id of the
      612*branch key (fsk_p_origin_ci), and the key immediately preceding this least
      613*leaf key.
      614**/
      615 
      616 FIND_SPLIT_KEYS:
      617    proc (fsk_p_origin_ci, fsk_p_low_key_buffer, fsk_p_high_key_buffer);
      618       dcl	    fsk_p_origin_ci	       fixed bin (24) unsigned unaligned parameter;
      619       dcl	    fsk_p_low_key_buffer   bit (*) aligned parameter;
      620       dcl	    fsk_p_high_key_buffer  bit (*) aligned parameter;
      621       dcl	    fsk_current_ci	       fixed bin (24) unsigned unaligned;
      622 
      623       fsk_current_ci = fsk_p_origin_ci;
      624       call GET_ELEMENT (fsk_current_ci, (DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT),
      625 	 addr (local_fsk_header_buffer) -> based_header_buffer, 0);
      626 
      627       do while (^addr (local_fsk_header_buffer) -> common_ci_header.is_leaf);
      628          fsk_current_ci = addr (local_fsk_header_buffer) -> branch_ci_header.low_branch_id;
      629          call GET_ELEMENT (fsk_current_ci, (DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT),
      630 	    addr (local_fsk_header_buffer) -> based_header_buffer, 0);
      631       end;
      632 
      633       call GET_ELEMENT (fsk_current_ci, (addr (local_fsk_header_buffer) -> leaf_ci_header.key_range.first),
      634 	 fsk_p_high_key_buffer, 0);
      635       fsk_current_ci = addr (local_fsk_header_buffer) -> leaf_ci_header.previous_id;
      636       call GET_ELEMENT (fsk_current_ci, (DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT),
      637 	 addr (local_fsk_header_buffer) -> based_header_buffer, 0);
      638       call GET_ELEMENT (fsk_current_ci, (addr (local_fsk_header_buffer) -> leaf_ci_header.key_range.last),
      639 	 fsk_p_low_key_buffer, 0);
      640    end FIND_SPLIT_KEYS;
      641 
      642 /* This procedure deletes an element from a node. */
      643 
      644 DELETE_ELEMENT:
      645    proc (fe_p_ci, fe_p_index);
      646 
      647       dcl	    fe_p_ci	       fixed bin (24) unsigned unaligned parameter;
      648       dcl	    fe_p_index	       fixed bin (12) unsigned unaligned parameter;
      649       dcl	    fe_code	       fixed bin (35);
      650       dcl	    fe_ci_ptr	       ptr;
      651 
      652       dcl	    1 fe_element_id	       aligned like element_id based (addr (fe_element_id_string));
      653       dcl	    fe_element_id_string   bit (36) aligned;
      654 
      655       fe_element_id.control_interval_id = fe_p_ci;
      656       fe_element_id.index = fe_p_index;
      657 
      658       if use_source_and_target_ci_buffers & (fe_p_ci = source_ci | fe_p_ci = target_ci)
      659       then
      660          do;
      661 	  if fe_element_id.control_interval_id = source_ci
      662 	  then fe_ci_ptr = source_ci_ptr;
      663 	  else fe_ci_ptr = target_ci_ptr;
      664 
      665 	  call collection_manager_$delete_from_ci_buffer (fe_ci_ptr, index_opening_info.file_opening_id,
      666 	       index_opening_info.collection_id, fe_element_id_string, "0"b, fe_code);
      667          end;
      668       else call collection_manager_$delete (index_opening_info.file_opening_id, index_opening_info.collection_id,
      669 	      fe_element_id_string, "0"b, fe_code);
      670       if fe_code ^= 0
      671       then call ERROR_RETURN (fe_code);
      672 
      673    end DELETE_ELEMENT;
      674 
      675 /* This procedure copies an element from a node into the provided buffer. */
      676 
      677 GET_ELEMENT:
      678    proc (ge_p_ci, ge_p_index, ge_p_buffer, ge_p_length);
      679 
      680       dcl	    ge_p_ci	       fixed bin (24) unsigned unaligned;
      681       dcl	    ge_p_index	       fixed bin (12) unsigned unaligned;
      682       dcl	    ge_p_buffer	       bit (*) aligned parameter;
      683       dcl	    ge_p_length	       fixed bin (35);
      684       dcl	    ge_code	       fixed bin (35);
      685       dcl	    ge_ci_ptr	       ptr;
      686 
      687       dcl	    1 ge_element_id	       aligned like element_id based (addr (ge_element_id_string));
      688       dcl	    ge_element_id_string   bit (36) aligned;
      689 
      690       ge_element_id.control_interval_id = ge_p_ci;
      691       ge_element_id.index = ge_p_index;
      692 
      693       if use_source_and_target_ci_buffers & (ge_p_ci = source_ci | ge_p_ci = target_ci)
      694       then
      695          do;
      696 	  if ge_element_id.control_interval_id = source_ci
      697 	  then ge_ci_ptr = source_ci_ptr;
      698 	  else ge_ci_ptr = target_ci_ptr;
      699 
      700 	  call collection_manager_$simple_get_from_ci_buffer (ge_ci_ptr, index_opening_info.collection_id,
      701 	       ge_element_id_string, addr (ge_p_buffer), length (ge_p_buffer), ge_p_length, ge_code);
      702          end;
      703       else call collection_manager_$get (index_opening_info.file_opening_id, index_opening_info.collection_id,
      704 	      ge_element_id_string, 0, addr (ge_p_buffer), length (ge_p_buffer), null, "0"b, null, ge_p_length, ge_code)
      705 	      ;
      706       if ge_code ^= 0
      707       then call ERROR_RETURN (ge_code);
      708 
      709    end GET_ELEMENT;
      710 
      711 /* This procedure initializes the global variables for im_rotate_insert. */
      712 
      713 INITIALIZE:
      714    proc (i_p_rotate_previous);
      715       dcl	    i_p_rotate_previous    bit (1) aligned;
      716       dcl	    i_code	       fixed bin (35) init (0);
      717 
      718       index_opening_info_ptr = p_index_opening_info_ptr;
      719       call CHECK_VERSION (index_opening_info.version, INDEX_OPENING_INFO_VERSION_3, "index_opening_info");
      720 
      721       source_ci_header_ptr = p_common_ci_header_ptr;
      722 
      723       common_ci_header_ptr, leaf_ci_header_ptr, branch_ci_header_ptr = null;
      724 
      725       source_ci = p_key_id.control_interval_id;
      726       source_ci_ptr = addr (source_ci_buffer);
      727 
      728       call collection_manager_$setup_ci_buffer (index_opening_info.file_opening_id, index_opening_info.collection_id,
      729 	 (source_ci), source_ci_ptr, length (source_ci_buffer), i_code);
      730       if i_code ^= 0
      731       then call ERROR_RETURN (i_code);
      732 
      733       i_code = 0;
      734       use_source_and_target_ci_buffers = "1"b;
      735 
      736       if i_p_rotate_previous
      737       then target_element_id.control_interval_id = source_ci_header_ptr -> common_ci_header.previous_id;
      738       else target_element_id.control_interval_id = source_ci_header_ptr -> common_ci_header.next_id;
      739 
      740       target_ci = target_element_id.control_interval_id;
      741       if target_ci = 0
      742       then call ERROR_RETURN (dm_error_$long_element);
      743 
      744       target_ci_ptr = addr (target_ci_buffer);
      745 
      746       call collection_manager_$setup_ci_buffer (index_opening_info.file_opening_id, index_opening_info.collection_id,
      747 	 (target_ci), target_ci_ptr, length (target_ci_buffer), i_code);
      748       if i_code ^= 0
      749       then call ERROR_RETURN (i_code);
      750 
      751       call GET_ELEMENT (target_ci, 1, target_header_buffer, (0));
      752 
      753       target_ci_header_ptr = addr (target_header_buffer);
      754       if i_p_rotate_previous
      755       then target_element_id.index = target_ci_header_ptr -> common_ci_header.key_range.last;
      756       else target_element_id.index = target_ci_header_ptr -> common_ci_header.key_range.first;
      757 
      758       original_target_index = target_element_id.index;
      759       target_ci_was_empty = (original_target_index = 0);
      760 
      761       if i_p_rotate_previous
      762       then source_key_index = source_ci_header_ptr -> common_ci_header.key_range.first;
      763       else source_key_index = source_ci_header_ptr -> common_ci_header.key_range.last;
      764 
      765       temp_key_string_ptr = null;
      766       one_or_more_keys_were_rotated = "0"b;
      767       high_key_string_ptr = null;
      768       low_key_string_ptr = null;
      769 
      770       current_key_buffer_ptr = addr (key_buffer_1);
      771       old_key_buffer_ptr = addr (key_buffer_2);
      772       total_amount_of_storage_moved = 0;
      773 
      774       additional_storage_required = p_additional_storage_required;
      775       amount_of_storage_to_be_moved =
      776 	 max (additional_storage_required,
      777 	 divide (source_ci_header_ptr -> common_ci_header.key_tail_space_used_since_last_prefix_compaction, 2, 24, 0));
      778    end INITIALIZE;
      779 
      780 /* This procedure inserts a branch key into the source ci. */
      781 
      782 INSERT_BRANCH_KEY_IN_SOURCE:
      783    proc ();
      784 
      785       if ^p_insert_new_key
      786       then call MODIFY_ELEMENT (p_key_id.control_interval_id, p_key_id.index, p_key_string);
      787       else call PUT_KEY (p_key_id.control_interval_id, p_key_id.index, length (p_key_string), addr (p_key_string),
      788 	      source_ci_header_ptr, source_ci_header_has_changed, update_source_branches, total_storage_available);
      789 
      790       additional_storage_required = 0;
      791 
      792    end INSERT_BRANCH_KEY_IN_SOURCE;
      793 
      794 /* This procedure sets the low_branch_id of the given ci_header to be the
      795*branch_id of the branch_key in p_key_string.  This branch key is assumed to
      796*have already been inserted in the source_ci at the location specified by
      797*p_key_id_string, and therefore the key at p_key_id_string is deleted from the
      798*source ci.
      799**/
      800 
      801 INSERT_KEY_AS_LOW_BRANCH_ID:
      802    proc (ikalbi_p_ci_header_ptr, ikalbi_p_ci_header_has_changed);
      803       dcl	    ikalbi_p_ci_header_ptr ptr parameter;
      804       dcl	    ikalbi_p_ci_header_has_changed
      805 			       bit (1) aligned parameter;
      806 
      807       ikalbi_p_ci_header_ptr -> branch_ci_header.low_branch_id = addr (p_key_string) -> branch_key.branch_id;
      808       ikalbi_p_ci_header_has_changed = "1"b;
      809 
      810 /* If there is an old version of p_key_string, delete it. */
      811 
      812       if ^p_insert_new_key
      813       then call DELETE_KEY (p_key_id.control_interval_id, p_key_id.index, source_ci_header_ptr, length (p_key_string),
      814 	      source_ci_header_has_changed, update_source_branches);
      815 						/* length (p_key_string) is an approximation for the length of the old version of the key. */
      816 
      817       additional_storage_required = 0;
      818 
      819    end INSERT_KEY_AS_LOW_BRANCH_ID;
      820 
      821 /* This procedure inserts a leaf key into the source ci at the slot index
      822*given by ilkisc_p_key_index.  If ilkisc_p_key_index = p_key_id.index, then
      823*ilkisc_p_key_string_ptr is set to point at p_key_string.
      824**/
      825 
      826 INSERT_LEAF_KEY_IN_SOURCE_CI:
      827    proc (ilkisc_p_key_index, ilkisc_p_key_string_ptr);
      828       dcl	    ilkisc_p_key_index     fixed bin (18) unsigned unaligned parameter;
      829       dcl	    ilkisc_p_key_string_ptr
      830 			       ptr parameter;
      831 
      832       if ^p_insert_new_key
      833       then call MODIFY_ELEMENT (source_ci, p_key_id.index, p_key_string);
      834       else call PUT_KEY (p_key_id.control_interval_id, p_key_id.index, length (p_key_string), addr (p_key_string),
      835 	      source_ci_header_ptr, source_ci_header_has_changed, update_source_branches, total_storage_available);
      836 
      837       if p_key_id.index = ilkisc_p_key_index
      838       then call SET_STRING_PTR (source_ci_header_ptr -> common_ci_header.is_leaf, addr (p_key_string),
      839 	      ilkisc_p_key_string_ptr);
      840 
      841       additional_storage_required = 0;
      842 
      843    end INSERT_LEAF_KEY_IN_SOURCE_CI;
      844 
      845 /* This procedure inserts a leaf key into the targe ci. It is prepared for
      846*there to be insufficient room for the insertion.  If the insertion works,
      847*ilktc_p_key_string_ptr is set to point at p_key_string.
      848**/
      849 
      850 INSERT_LEAF_KEY_IN_TARGET_CI:
      851    proc (ilktc_p_target_element_id_adjustment_proc, ilktc_p_key_string_ptr);
      852       dcl	    ilktc_p_target_element_id_adjustment_proc
      853 			       entry () variable parameter;
      854       dcl	    ilktc_p_key_string_ptr ptr parameter;
      855 
      856       dcl	    ilktc_key_doesnt_fit   bit (1) aligned init ("0"b);
      857 
      858       call ilktc_p_target_element_id_adjustment_proc ();
      859 
      860       call ALLOCATE_KEY_IN_TARGET_CI (ilktc_p_key_string_ptr, ilktc_key_doesnt_fit);
      861       if ilktc_key_doesnt_fit
      862       then call CHECK_STORAGE_REQUIREMENTS (total_amount_of_storage_moved, additional_storage_required);
      863 
      864    end INSERT_LEAF_KEY_IN_TARGET_CI;
      865 
      866 /* This procedure modifies the value of an existing element. */
      867 
      868 MODIFY_ELEMENT:
      869    proc (me_p_ci, me_p_index, me_p_buffer);
      870 
      871       dcl	    me_p_ci	       fixed bin (24) unsigned unaligned;
      872       dcl	    me_p_index	       fixed bin (12) unsigned unaligned;
      873       dcl	    me_p_buffer	       bit (*);
      874       dcl	    me_code	       fixed bin (35);
      875       dcl	    me_ci_ptr	       ptr;
      876 
      877       dcl	    1 me_element_id	       aligned like element_id based (addr (me_element_id_string));
      878       dcl	    me_element_id_string   bit (36) aligned;
      879 
      880       me_element_id.control_interval_id = me_p_ci;
      881       me_element_id.index = me_p_index;
      882 
      883       if use_source_and_target_ci_buffers & (me_p_ci = source_ci | me_p_ci = target_ci)
      884       then
      885          do;
      886 	  if me_element_id.control_interval_id = source_ci
      887 	  then me_ci_ptr = source_ci_ptr;
      888 	  else me_ci_ptr = target_ci_ptr;
      889 
      890 	  call collection_manager_$modify_in_ci_buffer (me_ci_ptr, index_opening_info.file_opening_id,
      891 	       index_opening_info.collection_id, addr (me_p_buffer), length (me_p_buffer), me_element_id_string,
      892 	       total_storage_available, me_code);
      893          end;
      894       else call collection_manager_$modify (index_opening_info.file_opening_id, index_opening_info.collection_id,
      895 	      addr (me_p_buffer), length (me_p_buffer), me_element_id_string, total_storage_available, me_code);
      896       if me_code ^= 0
      897       then call ERROR_RETURN (me_code);
      898 
      899    end MODIFY_ELEMENT;
      900 
      901 /* This procedure attempts to insert p_key_string at
      902*p_key_id_string after first making room for the insertion by rotating keys
      903*from the p_key_id.control_interval_id node (the source_ci) into the
      904*common_ci_header.next_id node (the target_ci).  This
      905*procedure requires that the target_ci be empty, and that the nodes involved be
      906*branch (as opposed to leaf) nodes.
      907**/
      908 
      909 NEXT_ROTATION_INTO_EMPTY_BRANCH:
      910    proc;
      911       dcl	    nrieb_code	       fixed bin (35) init (0);
      912 
      913       if target_ci_header_ptr -> branch_ci_header.low_branch_id ^= 0
      914       then call CONVERT_LOW_BRANCH_TO_TARGET_KEY (ADJUST_TARGET_ELEMENT_ID_FOR_NEXT_INSERT, target_ci_header_ptr,
      915 	      target_ci_header_has_changed);
      916 
      917       call ROTATE_NEXT_BRANCH ();
      918 
      919 /* Update the parent key. */
      920 
      921       call SETUP_PARENT_KEY (target_ci_header_ptr, target_ci);
      922 
      923       if p_insert_parent_key
      924       then
      925          do;
      926 	  call SETUP_PARENT_NODE_FOR_INSERTION (NEXT_ROTATION);
      927 
      928 	  call MODIFY_HEADERS (BRANCH_NODE);
      929 
      930 	  call im_general_insert (index_opening_info_ptr, addr (local_branch_ci_header), INSERT_KEY,
      931 	       unspec (branch_key), source_parent_id_string, nrieb_code);
      932 	  if nrieb_code ^= 0
      933 	  then call ERROR_RETURN (nrieb_code);
      934          end;
      935       else call REPLACE_PARENT_KEY (target_ci_header_ptr);
      936 
      937       p_additional_storage_required = additional_storage_required;
      938    end NEXT_ROTATION_INTO_EMPTY_BRANCH;
      939 
      940 /* This procedure attempts to insert p_key_string at
      941*p_key_id_string after first making room for the insertion by rotating keys
      942*from the p_key_id.control_interval_id node (the source_ci) into the
      943*common_ci_header.next_id node (the target_ci).  This
      944*procedure requires that the target_ci be empty, and that the nodes involved be
      945*leaf (as opposed to branch) nodes.
      946**/
      947 
      948 NEXT_ROTATION_INTO_EMPTY_LEAF:
      949    proc;
      950       dcl	    nriel_code	       fixed bin (35) init (0);
      951 
      952       call ROTATE_NEXT_LEAF ();
      953 
      954 /* Update the parent key. */
      955 
      956       call SETUP_PARENT_KEY_FROM_LEAF_NODE (NEXT_ROTATION);
      957 
      958       if p_insert_parent_key
      959       then
      960          do;
      961 	  call SETUP_PARENT_NODE_FOR_INSERTION (NEXT_ROTATION);
      962 
      963 	  call MODIFY_HEADERS (LEAF_NODE);
      964 
      965 	  call im_general_insert (index_opening_info_ptr, addr (local_branch_ci_header), INSERT_KEY,
      966 	       unspec (branch_key), source_parent_id_string, nriel_code);
      967 	  if nriel_code ^= 0
      968 	  then call ERROR_RETURN (nriel_code);
      969          end;
      970       else call REPLACE_PARENT_KEY (target_ci_header_ptr);
      971 
      972       p_additional_storage_required = additional_storage_required;
      973 
      974    end NEXT_ROTATION_INTO_EMPTY_LEAF;
      975 
      976 /* This procedure attempts to insert p_key_string at
      977*p_key_id_string after first making room for the insertion by rotating keys
      978*from the p_key_id.control_interval_id node (the source_ci) into the
      979*common_ci_header.next_id node (the target_ci).  This
      980*procedure requires that the target_ci has a low_branch_id > 0 and that the
      981*nodes involved be branch (as opposed to leaf), i.e. is a
      982*nonempty branch node.
      983**/
      984 
      985 NEXT_ROTATION_INTO_NONEMPTY_BRANCH:
      986    proc;
      987 
      988       call CHECK_NODES_HAVE_SAME_PARENT;
      989 
      990 /* Convert the low_branch_id "across" which the rotation will be done */
      991 /* into a branch key. */
      992 
      993       call CONVERT_LOW_BRANCH_TO_TARGET_KEY (ADJUST_TARGET_ELEMENT_ID_FOR_NEXT_INSERT, target_ci_header_ptr,
      994 	 target_ci_header_has_changed);
      995 
      996       call ROTATE_NEXT_BRANCH ();
      997 
      998 /* Update the parent key. */
      999 
     1000       if additional_storage_required = 0 | one_or_more_keys_were_rotated
     1001       then
     1002          do;
     1003 	  call SETUP_PARENT_KEY (target_ci_header_ptr, target_ci);
     1004 	  call REPLACE_PARENT_KEY (target_ci_header_ptr);
     1005          end;
     1006 
     1007       p_additional_storage_required = additional_storage_required;
     1008    end NEXT_ROTATION_INTO_NONEMPTY_BRANCH;
     1009 
     1010 /* This procedure attempts to insert p_key_string at
     1011*p_key_id_string after first making room for the insertion by rotating keys
     1012*from the p_key_id.control_interval_id node (the source_ci) into the
     1013*common_ci_header.next_id node (the target_ci).  Thi.
     1014*procedure requires that the target_ci contain at least one key
     1015*and that the nodes involved be leaf (as opposed to branch) nodes.
     1016**/
     1017 
     1018 NEXT_ROTATION_INTO_NONEMPTY_LEAF:
     1019    proc;
     1020 
     1021       call CHECK_NODES_HAVE_SAME_PARENT;
     1022 
     1023       call ROTATE_NEXT_LEAF ();
     1024 
     1025 /* Update the parent key. */
     1026       if one_or_more_keys_were_rotated
     1027       then
     1028          do;
     1029 	  call SETUP_PARENT_KEY_FROM_LEAF_NODE (NEXT_ROTATION);
     1030 	  call REPLACE_PARENT_KEY (target_ci_header_ptr);
     1031          end;
     1032 
     1033       p_additional_storage_required = additional_storage_required;
     1034    end NEXT_ROTATION_INTO_NONEMPTY_LEAF;
     1035 
     1036 /* This procedure attempts to insert p_key_string at
     1037*p_key_id_string after first making room for the insertion by rotating keys
     1038*from the p_key_id.control_interval_id node (the source_ci) into the
     1039*common_ci_header.previous_id node (the target_ci).
     1040*This procedure requires that the target_ci be empty, and that the nodes
     1041*involved be branch (as opposed to leaf) nodes.
     1042**/
     1043 
     1044 PREVIOUS_ROTATION_INTO_EMPTY_BRANCH:
     1045    proc;
     1046       dcl	    prieb_code	       fixed bin (35) init (0);
     1047 
     1048       if target_ci_header_ptr -> branch_ci_header.low_branch_id = 0
     1049       then
     1050          do;
     1051 	  update_target_branches = "1"b;
     1052 	  target_ci_header_has_changed = "1"b;
     1053 	  target_ci_header_ptr -> branch_ci_header.low_branch_id =
     1054 	       source_ci_header_ptr -> branch_ci_header.low_branch_id;
     1055 	  source_ci_header_ptr -> branch_ci_header.low_branch_id = 0;
     1056          end;
     1057       else call CONVERT_LOW_BRANCH_TO_TARGET_KEY (ADJUST_TARGET_ELEMENT_ID_FOR_PREVIOUS_INSERT, source_ci_header_ptr,
     1058 	      source_ci_header_has_changed);
     1059 
     1060       call ROTATE_PREVIOUS_BRANCH ();
     1061 
     1062       if p_insert_parent_key
     1063       then
     1064          do;
     1065 	  call SETUP_PARENT_NODE_FOR_INSERTION (PREVIOUS_ROTATION);
     1066 
     1067 	  call MODIFY_HEADERS (BRANCH_NODE);
     1068 
     1069 	  call im_general_insert (index_opening_info_ptr, addr (local_branch_ci_header), INSERT_KEY,
     1070 	       unspec (branch_key), source_parent_id_string, prieb_code);
     1071 	  if prieb_code ^= 0
     1072 	  then call ERROR_RETURN (prieb_code);
     1073          end;
     1074       else call REPLACE_PARENT_KEY (source_ci_header_ptr);
     1075 
     1076       p_additional_storage_required = additional_storage_required;
     1077    end PREVIOUS_ROTATION_INTO_EMPTY_BRANCH;
     1078 
     1079 /* This procedure attempts to insert p_key_string at
     1080*p_key_id_string after first making room for the insertion by rotating keys
     1081*from the p_key_id.control_interval_id node (the source_ci) into the
     1082*common_ci_header.previous_id node (the target_ci).
     1083*This procedure requires that the target_ci be empty, and that the nodes
     1084*involved be leaf (as opposed to branch) nodes.
     1085**/
     1086 
     1087 PREVIOUS_ROTATION_INTO_EMPTY_LEAF:
     1088    proc;
     1089       dcl	    priel_code	       fixed bin (35) init (0);
     1090 
     1091       call ROTATE_PREVIOUS_LEAF ();
     1092 
     1093 /* Update the parent key. */
     1094 
     1095       call SETUP_PARENT_KEY_FROM_LEAF_NODE (PREVIOUS_ROTATION);
     1096 
     1097       if p_insert_parent_key
     1098       then
     1099          do;
     1100 	  call SETUP_PARENT_NODE_FOR_INSERTION (PREVIOUS_ROTATION);
     1101 
     1102 	  call MODIFY_HEADERS (LEAF_NODE);
     1103 
     1104 	  call im_general_insert (index_opening_info_ptr, addr (local_branch_ci_header), INSERT_KEY,
     1105 	       unspec (branch_key), source_parent_id_string, priel_code);
     1106 	  if priel_code ^= 0
     1107 	  then call ERROR_RETURN (priel_code);
     1108          end;
     1109       else call REPLACE_PARENT_KEY (source_ci_header_ptr);
     1110 
     1111       p_additional_storage_required = additional_storage_required;
     1112 
     1113    end PREVIOUS_ROTATION_INTO_EMPTY_LEAF;
     1114 
     1115 /* This procedure attempts to insert p_key_string at
     1116*p_key_id_string after first making room for the insertion by rotating keys
     1117*from the p_key_id.control_interval_id node (the source_ci) into the
     1118*common_ci_header.previous_id node (the target_ci).
     1119*This procedure requires that the target_ci has a low_branch_id > 0
     1120*and that the nodes involved be branch (as opposed to leaf) nodes, i.e. that
     1121*the target_ci be a non-empty branch node.
     1122**/
     1123 
     1124 PREVIOUS_ROTATION_INTO_NONEMPTY_BRANCH:
     1125    proc;
     1126       dcl	    prinb_code	       fixed bin (35) init (0);
     1127 
     1128       call CHECK_NODES_HAVE_SAME_PARENT;
     1129 
     1130 /* Convert the low_branch_id "across" which the rotation will be done */
     1131 /* into a branch key. */
     1132 
     1133       call CONVERT_LOW_BRANCH_TO_TARGET_KEY (ADJUST_TARGET_ELEMENT_ID_FOR_PREVIOUS_INSERT, source_ci_header_ptr,
     1134 	 source_ci_header_has_changed);
     1135 
     1136       call ROTATE_PREVIOUS_BRANCH ();
     1137 
     1138       call REPLACE_PARENT_KEY (source_ci_header_ptr);
     1139 
     1140       p_additional_storage_required = additional_storage_required;
     1141    end PREVIOUS_ROTATION_INTO_NONEMPTY_BRANCH;
     1142 
     1143 /* This procedure attempts to insert p_key_string at
     1144*p_key_id_string after first making room for the insertion by rotating keys
     1145*from the p_key_id.control_interval_id node (the source_ci) into the
     1146*common_ci_header.previous_id node (the target_ci).
     1147*This procedure requires that the target_ci has at least one key in it
     1148*and that the nodes involved be leaf (as opposed to branch) nodes.
     1149**/
     1150 
     1151 PREVIOUS_ROTATION_INTO_NONEMPTY_LEAF:
     1152    proc;
     1153 
     1154       call CHECK_NODES_HAVE_SAME_PARENT;
     1155 
     1156       call ROTATE_PREVIOUS_LEAF ();
     1157 
     1158 /* Update the parent key. */
     1159       if one_or_more_keys_were_rotated
     1160       then
     1161          do;
     1162 	  call SETUP_PARENT_KEY_FROM_LEAF_NODE (PREVIOUS_ROTATION);
     1163 	  call REPLACE_PARENT_KEY (source_ci_header_ptr);
     1164          end;
     1165 
     1166       p_additional_storage_required = additional_storage_required;
     1167 
     1168    end PREVIOUS_ROTATION_INTO_NONEMPTY_LEAF;
     1169 
     1170 /* This procedure replaces the buffered nodes, source_ci and target_ci, in the
     1171*index_collection.
     1172**/
     1173 
     1174 REPLACE_NODE_BUFFERS:
     1175    proc ();
     1176       dcl	    pcb_code	       fixed bin (35);
     1177 
     1178       if source_ci_has_changed
     1179       then
     1180          do;
     1181 	  call collection_manager_$replace_ci_buffer (index_opening_info.file_opening_id,
     1182 	       index_opening_info.collection_id, (source_ci), source_ci_ptr, length (source_ci_buffer), pcb_code);
     1183 	  if pcb_code ^= 0
     1184 	  then call ERROR_RETURN (pcb_code);
     1185          end;
     1186       if target_ci_has_changed
     1187       then
     1188          do;
     1189 	  call collection_manager_$replace_ci_buffer (index_opening_info.file_opening_id,
     1190 	       index_opening_info.collection_id, (target_ci), target_ci_ptr, length (target_ci_buffer), pcb_code);
     1191 	  if pcb_code ^= 0
     1192 	  then call ERROR_RETURN (pcb_code);
     1193          end;
     1194 
     1195       use_source_and_target_ci_buffers, target_ci_has_changed, source_ci_has_changed = "0"b;
     1196 
     1197    end REPLACE_NODE_BUFFERS;
     1198 
     1199 /* This procedure puts an element into a node. */
     1200 
     1201 PUT_ELEMENT:
     1202    proc (pe_p_element_id_string, pe_p_element_length, pe_p_element_ptr, pe_p_space_left);
     1203 
     1204       dcl	    pe_p_element_id_string bit (36) aligned;
     1205       dcl	    pe_p_element_length    fixed bin (35);
     1206       dcl	    pe_p_element_ptr       ptr;
     1207       dcl	    pe_p_space_left	       fixed bin (35);
     1208       dcl	    pe_p_element_was_allocated
     1209 			       bit (1) aligned;
     1210       dcl	    pe_code	       fixed bin (35);
     1211       dcl	    pe_ci_ptr	       ptr;
     1212       dcl	    1 pe_element_id	       aligned like element_id based (addr (pe_element_id_string));
     1213       dcl	    pe_element_id_string   bit (36) aligned;
     1214       dcl	    pe_report_allocated    bit (1) aligned;
     1215 
     1216       pe_report_allocated = "0"b;
     1217       goto PE_JOIN;
     1218 
     1219 PUT_ELEMENT_TEST:
     1220    entry (pe_p_element_id_string, pe_p_element_length, pe_p_element_ptr, pe_p_space_left, pe_p_element_was_allocated);
     1221       pe_report_allocated = "1"b;
     1222       pe_p_element_was_allocated = "1"b;
     1223 PE_JOIN:
     1224       pe_element_id_string = pe_p_element_id_string;
     1225 
     1226       if use_source_and_target_ci_buffers
     1227 	 & (pe_element_id.control_interval_id = source_ci | pe_element_id.control_interval_id = target_ci)
     1228       then
     1229          do;
     1230 	  if pe_element_id.control_interval_id = source_ci
     1231 	  then pe_ci_ptr = source_ci_ptr;
     1232 	  else pe_ci_ptr = target_ci_ptr;
     1233 
     1234 	  call collection_manager_$put_in_ci_buffer (pe_ci_ptr, index_opening_info.file_opening_id,
     1235 	       index_opening_info.collection_id, pe_p_element_ptr, pe_p_element_length, pe_element_id_string,
     1236 	       pe_p_space_left, pe_code);
     1237          end;
     1238       else call collection_manager_$put (index_opening_info.file_opening_id, index_opening_info.collection_id,
     1239 	      pe_p_element_ptr, pe_p_element_length, pe_element_id_string, pe_p_space_left, pe_code);
     1240       if pe_code ^= 0
     1241       then if (pe_report_allocated & pe_code = dm_error_$long_element)
     1242 	 then pe_p_element_was_allocated = "0"b;
     1243 	 else call ERROR_RETURN (pe_code);
     1244 
     1245    end PUT_ELEMENT;
     1246 
     1247 PUT_KEY:
     1248    proc (pk_p_control_interval_id, pk_p_index, pk_p_key_length, pk_p_key_ptr, pk_p_ci_header_ptr,
     1249         pk_p_ci_header_has_changed, pk_p_update_branches, pk_p_total_storage_available);
     1250 
     1251       dcl	    pk_p_control_interval_id
     1252 			       fixed bin (24) unsigned unaligned parameter;
     1253       dcl	    pk_p_index	       fixed bin (12) unsigned unaligned parameter;
     1254       dcl	    pk_p_key_length	       fixed bin (35) parameter;
     1255       dcl	    pk_p_key_ptr	       ptr parameter;
     1256       dcl	    pk_p_ci_header_ptr     ptr parameter;
     1257       dcl	    pk_p_ci_header_has_changed
     1258 			       bit (1) aligned parameter;
     1259       dcl	    pk_p_update_branches   bit (1) aligned parameter;
     1260       dcl	    pk_p_total_storage_available
     1261 			       fixed bin (35) parameter;
     1262 
     1263       dcl	    1 pk_p_ci_header       aligned like common_ci_header based (pk_p_ci_header_ptr);
     1264       dcl	    1 pk_element_id	       aligned like element_id based (addr (pk_element_id_string));
     1265       dcl	    pk_element_id_string   bit (36) aligned;
     1266 
     1267       pk_element_id.control_interval_id = pk_p_control_interval_id;
     1268       pk_element_id.index = pk_p_index;
     1269 
     1270       call PUT_ELEMENT (pk_element_id_string, pk_p_key_length, pk_p_key_ptr, pk_p_total_storage_available);
     1271 
     1272       pk_p_ci_header.key_range.last = pk_p_ci_header.key_range.last + 1;
     1273       pk_p_ci_header.key_tail_space_used_since_last_prefix_compaction =
     1274 	 pk_p_ci_header.key_tail_space_used_since_last_prefix_compaction + pk_p_key_length;
     1275 
     1276       pk_p_ci_header_has_changed = "1"b;
     1277 
     1278       if ^pk_p_update_branches
     1279       then if pk_p_ci_header.key_range.last > pk_p_index
     1280 	 then pk_p_update_branches = "1"b;
     1281 
     1282    end PUT_KEY;
     1283 
     1284 /* This procedure modifies the node headers in the nodes, using the global
     1285*header copies.
     1286**/
     1287 
     1288 MODIFY_HEADERS:
     1289    proc (ph_p_is_leaf);
     1290       dcl	    ph_p_is_leaf	       bit (1) aligned;
     1291 
     1292       if ph_p_is_leaf
     1293       then
     1294          do;
     1295 	  if source_ci_header_has_changed
     1296 	  then call MODIFY_ELEMENT (source_ci, 1, unspec (source_ci_header_ptr -> leaf_ci_header));
     1297 	  if target_ci_header_has_changed
     1298 	  then call MODIFY_ELEMENT (target_ci, 1, unspec (target_ci_header_ptr -> leaf_ci_header));
     1299          end;
     1300       else
     1301          do;
     1302 	  if source_ci_header_has_changed
     1303 	  then call MODIFY_ELEMENT (source_ci, 1, unspec (source_ci_header_ptr -> branch_ci_header));
     1304 	  if target_ci_header_has_changed
     1305 	  then call MODIFY_ELEMENT (target_ci, 1, unspec (target_ci_header_ptr -> branch_ci_header));
     1306          end;
     1307 
     1308       source_ci_has_changed = source_ci_header_has_changed;
     1309       target_ci_has_changed = target_ci_header_has_changed;
     1310 
     1311       target_ci_header_has_changed, source_ci_header_has_changed = "0"b;
     1312 
     1313    end MODIFY_HEADERS;
     1314 
     1315 /* This procedure replaces the old parent key splitting the target and source
     1316*nodes with a new parent key which has a value that correctly splits the
     1317*rotated contents of the target and source nodes.
     1318**/
     1319 
     1320 REPLACE_PARENT_KEY:
     1321    proc (rpk_p_ci_header_ptr);
     1322       dcl	    rpk_p_ci_header_ptr    ptr parameter;
     1323       dcl	    1 rpk_p_ci_header      aligned based (rpk_p_ci_header_ptr) like common_ci_header;
     1324       dcl	    1 rpk_p_parent_element_id
     1325 			       aligned like element_id based (addr (rpk_p_ci_header.parent_id_string));
     1326 
     1327       dcl	    rpk_code	       fixed bin (35);
     1328 
     1329       call GET_ELEMENT (rpk_p_parent_element_id.control_interval_id, (DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT),
     1330 	 addr (local_branch_ci_header) -> based_header_buffer, 0);
     1331       call im_general_insert (index_opening_info_ptr, addr (local_branch_ci_header), REPLACE_KEY, unspec (branch_key),
     1332 	 unspec (rpk_p_ci_header.parent_id_string), rpk_code);
     1333       if rpk_code ^= 0
     1334       then call ERROR_RETURN (rpk_code);
     1335    end REPLACE_PARENT_KEY;
     1336 
     1337 /* This procedure is the heart of the rotation algorithm.  It moves keys from
     1338*a source node into a target node.  The move is accomplished by copying the key
     1339*from source to target, then deleting the source copy.
     1340**/
     1341 
     1342 ROTATE:
     1343    proc (r_p_rotate_previous);
     1344       dcl	    r_p_rotate_previous    bit (1) aligned;
     1345       dcl	    r_element_allocated    bit (1) aligned;
     1346 
     1347       r_element_allocated = "1"b;
     1348 
     1349 ROTATE_KEY_LOOP:
     1350       do rotate_idx = high_index to low_index by -1
     1351 	 while (r_element_allocated & total_amount_of_storage_moved < amount_of_storage_to_be_moved);
     1352 
     1353          if ^r_p_rotate_previous
     1354          then source_key_index = rotate_idx;
     1355 
     1356          old_temp_key_string_ptr = temp_key_string_ptr;
     1357 
     1358          temp_key_string_ptr = current_key_buffer_ptr;
     1359 
     1360 /* temp_key_string_ptr is just a convenient holder during the switch of old and current. */
     1361 
     1362          current_key_buffer_ptr = old_key_buffer_ptr;
     1363          old_key_buffer_ptr = temp_key_string_ptr;
     1364 
     1365          call GET_ELEMENT (source_ci, source_key_index, current_key_buffer_ptr -> key_buffer, temp_key_string_length);
     1366 
     1367          temp_key_string_ptr = current_key_buffer_ptr;
     1368          if r_p_rotate_previous
     1369          then call SET_STRING_PTR (source_ci_header_ptr -> common_ci_header.is_leaf, temp_key_string_ptr,
     1370 	         high_key_string_ptr);
     1371          else call SET_STRING_PTR (source_ci_header_ptr -> common_ci_header.is_leaf, temp_key_string_ptr,
     1372 	         low_key_string_ptr);
     1373 
     1374 /* The target_element_id.index will be 0 if there were no keys already in the
     1375*target  node.  In this case, target_element_id.index must be set to the
     1376*default initial key slot value.
     1377**/
     1378          if target_element_id.index = 0
     1379          then target_element_id.index = DEFAULT_INITIAL_KEY_SLOT;
     1380          else if r_p_rotate_previous
     1381          then target_element_id.index = target_element_id.index + 1;
     1382 
     1383          call PUT_ELEMENT_TEST (target_element_id_string, temp_key_string_length, temp_key_string_ptr,
     1384 	    total_storage_available, r_element_allocated);
     1385          if r_element_allocated
     1386          then
     1387 	  do;
     1388 	     one_or_more_keys_were_rotated = "1"b;
     1389 
     1390 /* If the target node was empty of keys, prior to rotation from the source,
     1391*then the key_range.first = 0. It is necessary to initialize key_range.first, 
     1392*in this case.
     1393**/
     1394 
     1395 	     if target_ci_header_ptr -> common_ci_header.key_range.first = 0
     1396 	     then target_ci_header_ptr -> common_ci_header.key_range.first,
     1397 		     target_ci_header_ptr -> common_ci_header.key_range.last = DEFAULT_INITIAL_KEY_SLOT;
     1398 	     else target_ci_header_ptr -> common_ci_header.key_range.last =
     1399 		     target_ci_header_ptr -> common_ci_header.key_range.last + 1;
     1400 
     1401 	     target_ci_header_ptr -> common_ci_header.key_tail_space_used_since_last_prefix_compaction =
     1402 		target_ci_header_ptr -> common_ci_header.key_tail_space_used_since_last_prefix_compaction
     1403 		+ temp_key_string_length;
     1404 
     1405 	     target_ci_header_has_changed = "1"b;
     1406 	     source_ci_header_has_changed = "1"b;
     1407 	     if r_p_rotate_previous
     1408 	     then update_source_branches = "1"b;
     1409 	     update_target_branches = "1"b;
     1410 
     1411 	     total_amount_of_storage_moved = total_amount_of_storage_moved + temp_key_string_length;
     1412 
     1413 	     if r_p_rotate_previous
     1414 	     then
     1415 	        do;
     1416 		 high_key_string_ptr = null;
     1417 		 call SET_STRING_PTR (source_ci_header_ptr -> common_ci_header.is_leaf, temp_key_string_ptr,
     1418 		      low_key_string_ptr);
     1419 	        end;
     1420 	     else
     1421 	        do;
     1422 		 low_key_string_ptr = null;
     1423 		 call SET_STRING_PTR (source_ci_header_ptr -> common_ci_header.is_leaf, temp_key_string_ptr,
     1424 		      high_key_string_ptr);
     1425 	        end;
     1426 
     1427 	     call DELETE_KEY (source_ci, (source_key_index), source_ci_header_ptr, temp_key_string_length,
     1428 		source_ci_header_has_changed, update_source_branches);
     1429 	  end;
     1430 
     1431       end ROTATE_KEY_LOOP;
     1432 
     1433 
     1434       there_is_more_room_in_target_ci = r_element_allocated;
     1435       if r_p_rotate_previous
     1436       then if there_is_more_room_in_target_ci
     1437 	 then p_key_id.index = rotate_idx;
     1438 	 else p_key_id.index = rotate_idx + 1;
     1439 
     1440       if internal_debug
     1441       then
     1442          do;
     1443 	  if ^there_is_more_room_in_target_ci
     1444 	  then rotate_idx = rotate_idx + 1;
     1445 	  call ioa_ ("^[Previous^;Next^] rotation into ^[^;non^]empty ^[leaf^;branch^] node (from ^d to ^d):
     1446 ^10xKeys rotated - ^d out of ^d.
     1447 ^10xBits rotated - ^d out of ^d.", r_p_rotate_previous, target_ci_was_empty,
     1448 	       source_ci_header_ptr -> common_ci_header.is_leaf, source_ci, target_ci, high_index - rotate_idx,
     1449 	       source_ci_header_ptr -> common_ci_header.key_range.last
     1450 	       - source_ci_header_ptr -> common_ci_header.key_range.first + 1 + high_index - rotate_idx,
     1451 	       total_amount_of_storage_moved, amount_of_storage_to_be_moved * 2);
     1452          end;
     1453    end ROTATE;
     1454 
     1455 /* This procedure does the rotation of keys into the next branch node, then
     1456*attempts to insert p_key_string.
     1457**/
     1458 
     1459 ROTATE_NEXT_BRANCH:
     1460    proc ();
     1461       dcl	    rnb_code	       fixed bin (35);
     1462 
     1463       high_index = source_ci_header_ptr -> common_ci_header.key_range.last;
     1464       if p_insert_new_key
     1465       then low_index = p_key_id.index;
     1466       else low_index = p_key_id.index + 1;
     1467 
     1468 
     1469       call ROTATE (NEXT_ROTATION);
     1470 
     1471 
     1472       if (p_insert_new_key & p_key_id.index > source_ci_header_ptr -> common_ci_header.key_range.last)
     1473 	 | (^p_insert_new_key & p_key_id.index = source_ci_header_ptr -> common_ci_header.key_range.last)
     1474       then call INSERT_KEY_AS_LOW_BRANCH_ID (target_ci_header_ptr, target_ci_header_has_changed);
     1475       else
     1476          do;
     1477 	  if target_ci_header_ptr -> branch_ci_header.low_branch_id = 0
     1478 	  then call COMPRESS_LOW_BRANCH_ID (DONT_UPDATE_STORAGE_MOVED, target_ci, target_ci_header_ptr,
     1479 		  target_ci_header_has_changed, update_target_branches);
     1480 	  if total_amount_of_storage_moved >= additional_storage_required
     1481 	  then call INSERT_BRANCH_KEY_IN_SOURCE ();
     1482 	  else call CHECK_STORAGE_REQUIREMENTS (total_amount_of_storage_moved, additional_storage_required);
     1483          end;
     1484 
     1485 
     1486 /* Replace the modified headers. */
     1487 
     1488       call MODIFY_HEADERS (BRANCH_NODE);
     1489 
     1490 /* Update the "parent" threads of the children of the target and source CIs. */
     1491 
     1492       if update_source_branches
     1493       then
     1494          do;
     1495 	  call im_update_branches (source_ci_ptr, index_opening_info.file_opening_id, index_opening_info.collection_id,
     1496 	       source_ci_header_ptr, source_ci, (p_key_id.index), rnb_code);
     1497 	  if rnb_code ^= 0
     1498 	  then call ERROR_RETURN (rnb_code);
     1499          end;
     1500 
     1501       call im_update_branches (target_ci_ptr, index_opening_info.file_opening_id, index_opening_info.collection_id,
     1502 	 target_ci_header_ptr, target_ci, 0, rnb_code);
     1503       if rnb_code ^= 0
     1504       then call ERROR_RETURN (rnb_code);
     1505 
     1506 /* Replace the modified CI buffers. */
     1507 
     1508       call REPLACE_NODE_BUFFERS ();
     1509 
     1510    end ROTATE_NEXT_BRANCH;
     1511 
     1512 /* This procedure rotates keys into the next leaf node and attempts to insert
     1513*p_key_string.
     1514**/
     1515 
     1516 ROTATE_NEXT_LEAF:
     1517    proc ();
     1518 
     1519       high_index = source_ci_header_ptr -> common_ci_header.key_range.last;
     1520       if p_insert_new_key
     1521       then low_index = p_key_id.index;
     1522       else low_index = p_key_id.index + 1;
     1523 
     1524       call ROTATE (NEXT_ROTATION);
     1525 
     1526       if total_amount_of_storage_moved >= additional_storage_required
     1527       then call INSERT_LEAF_KEY_IN_SOURCE_CI (source_ci_header_ptr -> common_ci_header.key_range.last, low_key_string_ptr)
     1528 	      ;
     1529       else if there_is_more_room_in_target_ci		/* Didn't move enough storage to put the new key into the
     1530*original ci, but there may be enough room in the target (or previous) ci. */
     1531       then call INSERT_LEAF_KEY_IN_TARGET_CI (ADJUST_TARGET_ELEMENT_ID_FOR_NEXT_INSERT, high_key_string_ptr);
     1532       else call CHECK_STORAGE_REQUIREMENTS (total_amount_of_storage_moved, additional_storage_required);
     1533 
     1534 /* Replace the modified headers. */
     1535 
     1536       call MODIFY_HEADERS (LEAF_NODE);
     1537 
     1538 /* Replace the modified CI buffers. */
     1539 
     1540       call REPLACE_NODE_BUFFERS ();
     1541 
     1542    end ROTATE_NEXT_LEAF;
     1543 
     1544 /* This procedure rotates keys into the previous branch node and attempts to
     1545*insert p_key_string.
     1546**/
     1547 
     1548 ROTATE_PREVIOUS_BRANCH:
     1549    proc ();
     1550       dcl	    rpb_code	       fixed bin (35);
     1551 
     1552       high_index = p_key_id.index;
     1553       low_index = source_ci_header_ptr -> common_ci_header.key_range.first + 1;
     1554       call ROTATE (PREVIOUS_ROTATION);
     1555 
     1556 
     1557       if p_key_id.index = source_ci_header_ptr -> common_ci_header.key_range.first
     1558       then call INSERT_KEY_AS_LOW_BRANCH_ID (source_ci_header_ptr, source_ci_header_has_changed);
     1559       else
     1560          do;
     1561 	  if source_ci_header_ptr -> branch_ci_header.low_branch_id = 0
     1562 	  then
     1563 	     do;
     1564 	        call COMPRESS_LOW_BRANCH_ID (UPDATE_STORAGE_MOVED, source_ci, source_ci_header_ptr,
     1565 		   source_ci_header_has_changed, update_source_branches);
     1566 	        p_key_id.index = p_key_id.index - 1;
     1567 	     end;
     1568 	  if total_amount_of_storage_moved >= additional_storage_required
     1569 	  then call INSERT_BRANCH_KEY_IN_SOURCE ();
     1570 	  else call CHECK_STORAGE_REQUIREMENTS (total_amount_of_storage_moved, additional_storage_required);
     1571          end;
     1572 
     1573       call MODIFY_HEADERS (BRANCH_NODE);
     1574 
     1575 /* Update the parent threads of the children of the source and target CIs. */
     1576 
     1577       if update_source_branches
     1578       then call im_update_branches (source_ci_ptr, index_opening_info.file_opening_id, index_opening_info.collection_id,
     1579 	      source_ci_header_ptr, source_ci, 0, rpb_code);
     1580       else call im_update_branches$single (source_ci_ptr, index_opening_info.file_opening_id,
     1581 	      index_opening_info.collection_id, source_ci_header_ptr, source_ci, 0, rpb_code);
     1582       if rpb_code ^= 0
     1583       then call ERROR_RETURN (rpb_code);
     1584 
     1585       call im_update_branches (target_ci_ptr, index_opening_info.file_opening_id, index_opening_info.collection_id,
     1586 	 target_ci_header_ptr, target_ci, original_target_index, rpb_code);
     1587       if rpb_code ^= 0
     1588       then call ERROR_RETURN (rpb_code);
     1589 
     1590 /* Replace the modified CI buffers. */
     1591 
     1592       call REPLACE_NODE_BUFFERS ();
     1593 
     1594 /* Update the parent key. */
     1595 
     1596       call SETUP_PARENT_KEY (source_ci_header_ptr, source_ci);
     1597    end ROTATE_PREVIOUS_BRANCH;
     1598 
     1599 /* This procedure rotates keys into the previous leaf node and attempts to
     1600*insert the p_key_string.
     1601**/
     1602 
     1603 ROTATE_PREVIOUS_LEAF:
     1604    proc ();
     1605       high_index = p_key_id.index;
     1606       low_index = source_ci_header_ptr -> common_ci_header.key_range.first + 1;
     1607 
     1608       call ROTATE (PREVIOUS_ROTATION);
     1609 
     1610       if total_amount_of_storage_moved >= additional_storage_required
     1611       then call INSERT_LEAF_KEY_IN_SOURCE_CI (source_ci_header_ptr -> common_ci_header.key_range.first,
     1612 	      high_key_string_ptr);
     1613       else if there_is_more_room_in_target_ci
     1614       then call INSERT_LEAF_KEY_IN_TARGET_CI (ADJUST_TARGET_ELEMENT_ID_FOR_PREVIOUS_INSERT, low_key_string_ptr);
     1615       else call CHECK_STORAGE_REQUIREMENTS (total_amount_of_storage_moved, additional_storage_required);
     1616 
     1617 /* Replace the modified headers. */
     1618 
     1619       call MODIFY_HEADERS (LEAF_NODE);
     1620 
     1621 /* Replace the modified CI buffers. */
     1622 
     1623       call REPLACE_NODE_BUFFERS ();
     1624 
     1625    end ROTATE_PREVIOUS_LEAF;
     1626 
     1627 /* This procedure sets ssp_p_key_string_ptr to point at the key value portion
     1628*of the key at ssp_p_key_ptr.
     1629**/
     1630 
     1631 SET_STRING_PTR:
     1632    proc (ssp_p_is_leaf, ssp_p_key_ptr, ssp_p_key_string_ptr);
     1633       dcl	    ssp_p_is_leaf	       bit (1);
     1634       dcl	    ssp_p_key_ptr	       ptr;
     1635       dcl	    ssp_p_key_string_ptr   ptr;
     1636 
     1637       bk_string_length, lk_string_length = 0;
     1638       if ssp_p_is_leaf
     1639       then ssp_p_key_string_ptr = addr (ssp_p_key_ptr -> leaf_key.string);
     1640       else ssp_p_key_string_ptr = addr (ssp_p_key_ptr -> branch_key.string);
     1641 
  1     1 /* BEGIN INCLUDE FILE - dm_im_key.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*          There are two formats for keys, the leaf_key structure and the
  1     6*     branch_key structure. The branch_key has two more pieces of information
  1     7*     than the leaf_key. One is the control interval id of the
  1     8*     node for all keys greater than the value of the branch key.  The other is
  1     9*     the number of fields for which there are values in the "string" portion
  1    10*     of the key.  This allows for the storing of only as much data as is needed
  1    11*     to discriminate between the children being split by the branch key.
  1    12**/
  1    13 
  1    14 /* HISTORY:
  1    15*
  1    16*Written by Lindsey Spratt, 03/29/82.
  1    17*Modified:
  1    18*10/25/84 by Lindsey L. Spratt:  Added history and description sections.
  1    19**/
  1    20 
  1    21 /* format: style2,ind3 */
  1    22      dcl	   key_string	      bit (key_string_length) based (key_string_ptr);
  1    23      dcl	   key_string_length      fixed bin (35);
  1    24      dcl	   key_string_ptr	      ptr;
  1    25 
  1    26      dcl	   1 leaf_key	      based (leaf_key_ptr) unaligned,
  1    27 	     2 string	      bit (lk_string_length) unal;
  1    28 
  1    29      dcl	   lk_string_length	      fixed bin (35);
  1    30      dcl	   leaf_key_ptr	      ptr;
  1    31 
  1    32      dcl	   1 branch_key	      based (branch_key_ptr) unaligned,
  1    33 	     2 branch_id	      fixed bin (24) unsigned unaligned,
  1    34 	     2 last_field_idx     fixed bin (12) unaligned unsigned,
  1    35 	     2 string	      bit (bk_string_length) unal;
  1    36 
  1    37      dcl	   BRANCH_KEY_HEADER_LENGTH_IN_BITS
  1    38 			      init (36) fixed bin (35) internal static options (constant);
  1    39      dcl	   bk_string_length	      fixed bin (35);
  1    40      dcl	   branch_key_ptr	      ptr;
  1    41 
  1    42 /* END INCLUDE FILE - dm_im_key.incl.pl1 */
     1642 
     1643    end SET_STRING_PTR;
     1644 
     1645 /* This procedure creates a parent key from the source and target leaf nodes. */
     1646 
     1647 SETUP_PARENT_KEY_FROM_LEAF_NODE:
     1648    proc (spkfln_p_rotate_previous);
     1649       dcl	    spkfln_p_rotate_previous
     1650 			       bit (1) aligned;
     1651       dcl	    spkfln_code	       fixed bin (35);
     1652 
     1653       if high_key_string_ptr = null
     1654       then
     1655          do;
     1656 	  if spkfln_p_rotate_previous
     1657 	  then call GET_ELEMENT (source_ci, (source_ci_header_ptr -> common_ci_header.key_range.first), key_buffer_3,
     1658 		  (0));
     1659 	  else call GET_ELEMENT (target_ci, (target_ci_header_ptr -> common_ci_header.key_range.first), key_buffer_3,
     1660 		  (0));
     1661 	  call SET_STRING_PTR (source_ci_header_ptr -> common_ci_header.is_leaf, addr (key_buffer_3),
     1662 	       high_key_string_ptr);
     1663          end;
     1664       else if low_key_string_ptr = null
     1665       then
     1666          do;
     1667 	  if spkfln_p_rotate_previous
     1668 	  then call GET_ELEMENT (target_ci, (target_ci_header_ptr -> common_ci_header.key_range.last), key_buffer_3,
     1669 		  (0));
     1670 	  else call GET_ELEMENT (source_ci, (source_ci_header_ptr -> common_ci_header.key_range.last), key_buffer_3,
     1671 		  (0));
     1672 
     1673 	  call SET_STRING_PTR (source_ci_header_ptr -> common_ci_header.is_leaf, addr (key_buffer_3),
     1674 	       low_key_string_ptr);
     1675          end;
     1676       call im_make_parent_key (index_opening_info.field_table_ptr, low_key_string_ptr, ALL_FIELDS_PRESENT,
     1677 	 high_key_string_ptr, ALL_FIELDS_PRESENT, addr (parent_key_buffer), length (parent_key_buffer), null,
     1678 	 branch_key_ptr, bk_string_length, "0"b, spkfln_code);
     1679       if spkfln_code ^= 0
     1680       then call ERROR_RETURN (spkfln_code);
     1681 
     1682       if spkfln_p_rotate_previous
     1683       then branch_key.branch_id = source_ci;
     1684       else branch_key.branch_id = target_ci;
     1685 
     1686    end SETUP_PARENT_KEY_FROM_LEAF_NODE;
     1687 
     1688 /* This procedure prepares the parent node of the source and target nodes for
     1689*the insertion of the new value parent key.
     1690**/
     1691 
     1692 SETUP_PARENT_NODE_FOR_INSERTION:
     1693    proc (spnfi_p_rotate_previous);
     1694       dcl	    spnfi_p_rotate_previous
     1695 			       bit (1) aligned;
     1696       dcl	    spnfi_code	       fixed bin (35);
     1697       dcl	    1 spnfi_element_id     aligned like element_id based (addr (spnfi_element_id_string));
     1698       dcl	    spnfi_element_id_string
     1699 			       bit (36) aligned;
     1700 
     1701       if source_parent_id.control_interval_id > 0
     1702       then
     1703          do;
     1704 	  call GET_ELEMENT (source_parent_id.control_interval_id, (DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT),
     1705 	       addr (local_branch_ci_header) -> based_header_buffer, 0);
     1706 
     1707 	  if spnfi_p_rotate_previous
     1708 	  then
     1709 	     do;
     1710 	        source_ci_header_has_changed = "1"b;
     1711 	        target_ci_header_has_changed = "1"b;	/* The "new" (target) node (produced by the split) */
     1712 						/* has as its parent key the key which was */
     1713 						/* the parent of the "old" (source) node. */
     1714 	        target_parent_id_string = source_parent_id_string;
     1715 						/* The "old" (source) node's new parent key */
     1716 						/* going to be just 1 position greater than */
     1717 						/* its old parent key. */
     1718 	        if source_parent_id.index = 0
     1719 	        then source_parent_id.index = DEFAULT_INITIAL_KEY_SLOT;
     1720 	        else source_parent_id.index = source_parent_id.index + 1;
     1721 	     end;
     1722 	  else
     1723 	     do;
     1724 	        target_ci_header_has_changed = "1"b;
     1725 	        if source_parent_id.index = 0
     1726 	        then target_parent_id.index = DEFAULT_INITIAL_KEY_SLOT;
     1727 	        else target_parent_id.index = target_parent_id.index + 1;
     1728 	     end;
     1729          end;
     1730       else
     1731          do;
     1732 	  call im_init_branch_ci_header (addr (local_branch_ci_header));
     1733 	  call collection_manager_$allocate_control_interval (index_opening_info.file_opening_id,
     1734 	       index_opening_info.collection_id, new_ci, spnfi_code);
     1735 	  if spnfi_code ^= 0
     1736 	  then call ERROR_RETURN (spnfi_code);
     1737 
     1738 	  if spnfi_p_rotate_previous
     1739 	  then local_branch_ci_header.low_branch_id = target_ci;
     1740 	  else local_branch_ci_header.low_branch_id = source_ci;
     1741 
     1742 	  local_branch_ci_header.key_range = 0;
     1743 	  spnfi_element_id.control_interval_id = new_ci;
     1744 	  spnfi_element_id.index = DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT;
     1745 	  call PUT_ELEMENT (spnfi_element_id_string, length (unspec (local_branch_ci_header)),
     1746 	       addr (local_branch_ci_header), (0));
     1747 
     1748 /* Record the new root control interval's location in the header. */
     1749 
     1750 	  call im_update_opening_info$root_id (index_opening_info_ptr, new_ci, spnfi_code);
     1751 	  if spnfi_code ^= 0
     1752 	  then call ERROR_RETURN (spnfi_code);
     1753 
     1754 /* Fix the ci_headers of the target and source control intervals to
     1755*"point" at the new root ci as their parent. */
     1756 
     1757 	  spnfi_element_id.index = DEFAULT_INITIAL_KEY_SLOT;
     1758 
     1759 	  if spnfi_p_rotate_previous
     1760 	  then source_parent_id_string = spnfi_element_id_string;
     1761 	  else target_parent_id_string = spnfi_element_id_string;
     1762 
     1763 	  spnfi_element_id.index = 0;
     1764 
     1765 	  if spnfi_p_rotate_previous
     1766 	  then target_parent_id_string = spnfi_element_id_string;
     1767 	  else source_parent_id_string = spnfi_element_id_string;
     1768 	  source_ci_header_has_changed, target_ci_header_has_changed = "1"b;
     1769          end;
     1770    end SETUP_PARENT_NODE_FOR_INSERTION;
     1771 
     1772 /* This procedure builds a new parent key for splitting the rotated source and
     1773*target branch nodes.
     1774**/
     1775 
     1776 SETUP_PARENT_KEY:
     1777    proc (spk_p_ci_header_ptr, spk_p_ci_id);
     1778       dcl	    spk_p_ci_header_ptr    ptr parameter;
     1779       dcl	    spk_p_ci_id	       fixed bin (24) unsigned unaligned parameter;
     1780       dcl	    spk_code	       fixed bin (35);
     1781 
     1782       if addr (p_key_string) -> branch_key.branch_id = spk_p_ci_header_ptr -> branch_ci_header.low_branch_id
     1783       then
     1784          do;
     1785 	  branch_key_ptr = addr (p_key_string);
     1786 	  bk_string_length = length (p_key_string) - BRANCH_KEY_HEADER_LENGTH_IN_BITS;
     1787          end;
     1788       else
     1789          do;
     1790 	  call FIND_SPLIT_KEYS (spk_p_ci_header_ptr -> branch_ci_header.low_branch_id, key_buffer_1, key_buffer_2);
     1791 
     1792 	  call SET_STRING_PTR ("1"b, addr (key_buffer_1), low_key_string_ptr);
     1793 	  call SET_STRING_PTR ("1"b, addr (key_buffer_2), high_key_string_ptr);
     1794 	  call im_make_parent_key (index_opening_info.field_table_ptr, low_key_string_ptr, ALL_FIELDS_PRESENT,
     1795 	       high_key_string_ptr, ALL_FIELDS_PRESENT, addr (parent_key_buffer), length (parent_key_buffer), null,
     1796 	       branch_key_ptr, bk_string_length, "0"b, spk_code);
     1797 	  if spk_code ^= 0
     1798 	  then call ERROR_RETURN (spk_code);
     1799          end;
     1800       branch_key.branch_id = spk_p_ci_id;
     1801    end SETUP_PARENT_KEY;
     1802 
  2     1 /* BEGIN INCLUDE FILE - dm_im_key.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*          There are two formats for keys, the leaf_key structure and the
  2     6*     branch_key structure. The branch_key has two more pieces of information
  2     7*     than the leaf_key. One is the control interval id of the
  2     8*     node for all keys greater than the value of the branch key.  The other is
  2     9*     the number of fields for which there are values in the "string" portion
  2    10*     of the key.  This allows for the storing of only as much data as is needed
  2    11*     to discriminate between the children being split by the branch key.
  2    12**/
  2    13 
  2    14 /* HISTORY:
  2    15*
  2    16*Written by Lindsey Spratt, 03/29/82.
  2    17*Modified:
  2    18*10/25/84 by Lindsey L. Spratt:  Added history and description sections.
  2    19**/
  2    20 
  2    21 /* format: style2,ind3 */
  2    22      dcl	   key_string	      bit (key_string_length) based (key_string_ptr);
  2    23      dcl	   key_string_length      fixed bin (35);
  2    24      dcl	   key_string_ptr	      ptr;
  2    25 
  2    26      dcl	   1 leaf_key	      based (leaf_key_ptr) unaligned,
  2    27 	     2 string	      bit (lk_string_length) unal;
  2    28 
  2    29      dcl	   lk_string_length	      fixed bin (35);
  2    30      dcl	   leaf_key_ptr	      ptr;
  2    31 
  2    32      dcl	   1 branch_key	      based (branch_key_ptr) unaligned,
  2    33 	     2 branch_id	      fixed bin (24) unsigned unaligned,
  2    34 	     2 last_field_idx     fixed bin (12) unaligned unsigned,
  2    35 	     2 string	      bit (bk_string_length) unal;
  2    36 
  2    37      dcl	   BRANCH_KEY_HEADER_LENGTH_IN_BITS
  2    38 			      init (36) fixed bin (35) internal static options (constant);
  2    39      dcl	   bk_string_length	      fixed bin (35);
  2    40      dcl	   branch_key_ptr	      ptr;
  2    41 
  2    42 /* END INCLUDE FILE - dm_im_key.incl.pl1 */
     1803 
     1804 
  3     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*
  3     5*        Contains the declaration of an element identifier.  Element
  3     6*   identifiers consist of two parts, the id (number) of the control interval
  3     7*   in which the element resides, and the index into the slot table of
  3     8*   the element in the control interval.  The declaration of the element_id 
  3     9*   structure reflects this division of the element identifier.  The structure 
  3    10*   is based on the automatic bit string element_id_string because programs
  3    11*   generally pass bit strings (element_id_string) to each other, then 
  3    12*   interpret the bit string by overlaying the element_id structure ony if
  3    13*   it is necessary to access the parts of the id.  Basing element_id on
  3    14*   addr(element_id_string) instead of on a pointer removes the necessity
  3    15*   for always setting that pointer explicitly and guarantees that changes
  3    16*   made to the string or structure do not get inconsistent.
  3    17*
  3    18*   Changes made to element_id must also be made to datum_id, declared in 
  3    19*   dm_cm_datum.incl.pl1.
  3    20**/
  3    21 
  3    22 /* HISTORY:
  3    23*Written by Matthew Pierret, 04/01/82.
  3    24*Modified:
  3    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  3    26**/
  3    27 
  3    28 /* format: style2,ind3,ll79 */
  3    29 
  3    30      dcl	   element_id_string      bit (36) aligned;
  3    31 
  3    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  3    33 	     2 control_interval_id
  3    34 			      fixed bin (24) unal unsigned,
  3    35 	     2 index	      fixed bin (12) unal unsigned;
  3    36 
  3    37 
  3    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
     1805 
     1806 
  4     1 /* BEGIN INCLUDE FILE - dm_im_ci_header.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*          Each node (control interval) in the index has a header which
  4     6*     describes the contents of that node.  Although there are two different
  4     7*     kinds of headers, leaf and branch, they have a great deal in common, the
  4     8*     common_ci_header.  The common_ci_header states which slots are used by
  4     9*     the keys (leaf or branch) in the key_range substructure.  There is an
  4    10*     "upward pointer" to the node's parent branch key (parent_id_string).
  4    11*     There are pointers to the previous and next nodes (previous_id and
  4    12*     next_id) on the same level to facilitate rotation of keys, and sequential
  4    13*     searching.  There is also a count of how much space is in use by the keys.
  4    14*
  4    15**/
  4    16 
  4    17 /* HISTORY:
  4    18*
  4    19*Written by Lindsey Spratt, 03/29/82.
  4    20*Modified:
  4    21*10/25/84 by Lindsey L. Spratt:  Added a description and fixed the history
  4    22*            section format.
  4    23**/
  4    24 
  4    25 /* format: style2,ind3 */
  4    26      dcl	   1 common_ci_header     based (common_ci_header_ptr),
  4    27 	     2 flags	      unaligned,
  4    28 	       3 is_leaf	      bit (1) unaligned,	/* ON for leaf_ci, OFF for branch_ci. */
  4    29 	       3 pad	      bit (17) unaligned,	/* Must be zero. */
  4    30 	     2 key_tail_space_used_since_last_prefix_compaction
  4    31 			      fixed bin (18) unsigned unal,
  4    32 	     2 key_range	      unaligned,
  4    33 	       3 first	      fixed bin (18) unsigned,
  4    34 	       3 last	      fixed bin (18) unsigned,
  4    35 	     2 parent_id_string   bit (36) aligned,
  4    36 	     2 previous_id	      fixed bin (24) unsigned unaligned,
  4    37 	     2 next_id	      fixed bin (24) unsigned unaligned,
  4    38 	     2 pad	      bit (24) unaligned;
  4    39 
  4    40 
  4    41      dcl	   common_ci_header_ptr   ptr;
  4    42 
  4    43      dcl	   1 leaf_ci_header	      based (leaf_ci_header_ptr),
  4    44 	     2 common	      like common_ci_header;
  4    45 
  4    46      dcl	   leaf_ci_header_ptr     ptr;
  4    47 
  4    48      dcl	   1 branch_ci_header     based (branch_ci_header_ptr),
  4    49 	     2 common	      like common_ci_header,
  4    50 	     2 low_branch_id      fixed bin (24) unsigned unaligned,
  4    51 	     2 pad	      bit (12) unaligned;
  4    52 
  4    53      dcl	   branch_ci_header_ptr   ptr;
  4    54 
  4    55 
  4    56      dcl	   (
  4    57 	   DEFAULT_INITIAL_KEY_SLOT
  4    58 			      init (2),
  4    59 	   DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT
  4    60 			      init (1),
  4    61 	   LEAF_CI_HEADER_LENGTH_IN_BITS
  4    62 			      init (180),
  4    63 	   BRANCH_CI_HEADER_LENGTH_IN_BITS
  4    64 			      init (216)
  4    65 	   )		      internal static options (constant) fixed bin;
  4    66 
  4    67 /* END INCLUDE FILE - dm_im_ci_header.incl.pl1 */
     1807 
     1808 
  5     1 /* BEGIN INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*     This include file contains declarations of all collection_manager_ 
  5     5*     entrypoints.
  5     6**/
  5     7 
  5     8 /* HISTORY:
  5     9*Written by Matthew Pierret 
  5    10*Modified:
  5    11*04/14/82 by Lindsey Spratt: Changed the control_interval_id parameter of the
  5    12*	  allocate_control_interval operation to be unaligned, as well as
  5    13*	  unsigned.
  5    14*06/17/82 by Matthew Pierret: Added the put_element_portion opertion and
  5    15*            removed the beginning_location parameter from the put_element
  5    16*            operation. Added the create_page_file_operation.
  5    17*08/09/82 by Matthew Pierret: Changed "fixed bin (17)"s to "bit (36) aligned"s
  5    18*            wherever collection_id was required.
  5    19*            Also changed the control_interval_id parameter of the 
  5    20*            allocate_control_interval operation back to be aligned. So there.
  5    21*10/20/82 by Matthew Pierret: Changed $create_page_file to $create_file,
  5    22*            added the argument file_create_info_ptr to $create_file.
  5    23*12/13/82 by Lindsey Spratt:  Corrected $free_control_interval to
  5    24*	  include the zero_on_free bit.
  5    25*12/17/82 by Matthew Pierret: Added cm_$get_id.
  5    26*01/07/83 by Matthew Pierret: Added cm_$put_element_buffered, 
  5    27*            cm_$allocate_element_buffered, cm_$free_element_buffered.
  5    28*04/27/83 by Matthew Pierret: Added cm_$put_unprotected_element,
  5    29*            cm_$put_unprotected_header.
  5    30*11/07/83 by Matthew Pierret: Added $get_element_portion_buffered,
  5    31*             $simple_get_buffered_element.
  5    32*02/08/84 by Matthew Pierret:  Changed $get_id to have only one bit(1)aligned
  5    33*            parameter for specifying absolute/relative nature of search.
  5    34*03/16/84 by Matthew Pierret:  Added cm_$get_control_interval_ptr,
  5    35*            $get_element_ptr, $get_element_portion_ptr, $simple_get_element_ptr
  5    36*04/03/84 by Matthew Pierret:  Added cm_$compact_control_interval.
  5    37*06/06/84 by Matthew Pierret:  Re-named free_element* to delete and
  5    38*            delete_from_ci_buffer.
  5    39*            Re-named *_buffered_ci to =_ci_buffer.
  5    40*            get entries.
  5    41*            modify entries.
  5    42*            Changed calling sequence of modify entries to have a ptr/length
  5    43*            instead of length/ptr parameter pair.
  5    44*03/11/85 by R. Michael Tague:  Added $postcommit_increments.
  5    45**/
  5    46 
  5    47 /* This include file contains declarations of collection_manager_ entrypoints */
  5    48 
  5    49 /* format: style2,ind3 */
  5    50      dcl	   collection_manager_$allocate_control_interval
  5    51 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  5    52      dcl	   collection_manager_$compact_control_interval
  5    53 			      entry (bit (36) aligned, fixed bin (24) uns, fixed bin (35));
  5    54      dcl	   collection_manager_$create_collection
  5    55 			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  5    56      dcl	   collection_manager_$create_file
  5    57 			      entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
  5    58      dcl	   collection_manager_$destroy_collection
  5    59 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  5    60      dcl	   collection_manager_$free_control_interval
  5    61 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, bit (1) aligned,
  5    62 			      fixed bin (35));
  5    63 
  5    64      dcl	   collection_manager_$delete
  5    65 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  5    66 			      fixed bin (35));
  5    67      dcl	   collection_manager_$delete_from_ci_buffer
  5    68 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  5    69 			      fixed bin (35));
  5    70 
  5    71      dcl	   collection_manager_$get
  5    72 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  5    73 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  5    74      dcl	   collection_manager_$get_control_interval_ptr
  5    75 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, ptr,
  5    76 			      fixed bin (35));
  5    77      dcl	   collection_manager_$get_from_ci_buffer
  5    78 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  5    79 			      ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  5    80      dcl	   collection_manager_$get_by_ci_ptr
  5    81 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  5    82 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), ptr, fixed bin (35));
  5    83      dcl	   collection_manager_$get_header
  5    84 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (17), ptr, bit (1) aligned,
  5    85 			      ptr, fixed bin (35), fixed bin (35));
  5    86      dcl	   collection_manager_$get_id
  5    87 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17),
  5    88 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  5    89      dcl	   collection_manager_$get_portion
  5    90 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  5    91 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  5    92 			      fixed bin (35), fixed bin (35));
  5    93      dcl	   collection_manager_$get_portion_from_ci_buffer
  5    94 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  5    95 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  5    96 			      fixed bin (35));
  5    97      dcl	   collection_manager_$get_portion_by_ci_ptr
  5    98 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  5    99 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  5   100 			      fixed bin (35));
  5   101      dcl	   collection_manager_$modify
  5   102 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   103 			      fixed bin (35), fixed bin (35));
  5   104      dcl	   collection_manager_$modify_unprotected
  5   105 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   106 			      fixed bin (35), fixed bin (35));
  5   107      dcl	   collection_manager_$modify_in_ci_buffer
  5   108 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   109 			      fixed bin (35), fixed bin (35));
  5   110      dcl	   collection_manager_$modify_portion
  5   111 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35), ptr,
  5   112 			      fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  5   113      dcl	   collection_manager_$postcommit_increments
  5   114 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  5   115      dcl	   collection_manager_$put
  5   116 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   117 			      fixed bin (35), fixed bin (35));
  5   118      dcl	   collection_manager_$put_in_ci_buffer
  5   119 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   120 			      fixed bin (35), fixed bin (35));
  5   121      dcl	   collection_manager_$put_header
  5   122 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  5   123      dcl	   collection_manager_$put_unprotected_header
  5   124 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  5   125 
  5   126      dcl	   collection_manager_$replace_ci_buffer
  5   127 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  5   128 			      fixed bin (35));
  5   129      dcl	   collection_manager_$setup_ci_buffer
  5   130 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  5   131 			      fixed bin (35));
  5   132      dcl	   collection_manager_$simple_get_by_ci_ptr
  5   133 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  5   134 			      fixed bin (35));
  5   135      dcl	   collection_manager_$simple_get_from_ci_buffer
  5   136 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  5   137 			      fixed bin (35));
  5   138 
  5   139 /* END INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
     1809 
     1810 
  6     1 /* BEGIN INCLUDE FILE - dm_im_opening_info.incl.pl1 */
  6     2 
  6     3 /* DESRIPTION:
  6     4*
  6     5*          The index_opening_info is per-process information, stored in a
  6     6*     hash_table managed by the opening_manager_, which allows the
  6     7*     index_manager_ to quickly reference certain unchanging pieces of
  6     8*     information rapidly.
  6     9**/
  6    10 
  6    11 /* HISTORY:
  6    12*
  6    13*Written by Lindsey Spratt, 10/28/82.
  6    14*Modified:
  6    15*10/26/84 by Lindsey L. Spratt:  Changed version to char(8).  Added a
  6    16*            description.  Added the current_rollback_count.  Added the
  6    17*	  key_count_array_ptr.
  6    18*03/07/85 by R. Michael Tague:  Added key_count_increments_ptr and 
  6    19*	  key_counts_postcommit_written.  Changed to version 3.
  6    20*03/25/85 by R. Michael Tague:  Added key_count_unprotected_file.  This
  6    21*	  flag is used by im_update_opening_info to help it maintain the
  6    22*	  key count array info.
  6    23**/
  6    24 
  6    25 /* format: style2,ind3 */
  6    26      dcl	   1 index_opening_info   based (index_opening_info_ptr) aligned,
  6    27 	     2 version	      char (8) aligned,
  6    28 	     2 file_opening_id    bit (36) aligned,
  6    29 	     2 collection_id      bit (36) aligned,
  6    30 	     2 index_header_ptr   ptr init (null),
  6    31 	     2 field_table_ptr    ptr init (null),
  6    32 	     2 key_count_array_ptr
  6    33 			      ptr init (null),
  6    34 	     2 key_count_increments_ptr
  6    35 			      ptr init (null),
  6    36 	     2 flags,
  6    37 	       3 key_count_postcommit_written
  6    38 			      bit (1) unal init ("0"b),
  6    39 	       3 key_count_unprotected_file
  6    40 			      bit (1) unal init ("0"b),
  6    41 	       3 pad	      bit (34) unal init (""b),
  6    42 	     2 current_txn_id     fixed bin (35) init (0),
  6    43 	     2 current_rollback_count
  6    44 			      fixed bin (35) init (0);
  6    45 
  6    46      dcl	   index_opening_info_ptr ptr init (null);
  6    47      dcl	   INDEX_OPENING_INFO_VERSION_3
  6    48 			      init ("IdxOpn 3") char (8) aligned internal static options (constant);
  6    49 
  6    50 /* END INCLUDE FILE - dm_im_opening_info.incl.pl1 */
     1811 
     1812 
  7     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  7     2 /* format: style3 */
  7     3 
  7     4 /* These constants are to be used for the flags argument of sub_err_ */
  7     5 /* They are just "string (condition_info_header.action_flags)" */
  7     6 
  7     7 declare	(
  7     8 	ACTION_CAN_RESTART	init (""b),
  7     9 	ACTION_CANT_RESTART init ("1"b),
  7    10 	ACTION_DEFAULT_RESTART
  7    11 			init ("01"b),
  7    12 	ACTION_QUIET_RESTART
  7    13 			init ("001"b),
  7    14 	ACTION_SUPPORT_SIGNAL
  7    15 			init ("0001"b)
  7    16 	)		bit (36) aligned internal static options (constant);
  7    17 
  7    18 /* End include file */
     1813 
     1814    end im_rotate_insert;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/17/00  1936.9  im_rotate_insert.pl1              >udd>sm>ds>w>ml>im_rotate_insert.pl1
1642         1    01/07/85  0958.9  dm_im_key.incl.pl1                >ldd>incl>dm_im_key.incl.pl1
1803         2    01/07/85  0958.9  dm_im_key.incl.pl1                >ldd>incl>dm_im_key.incl.pl1
1805         3    01/07/85  0958.5  dm_element_id.incl.pl1            >ldd>incl>dm_element_id.incl.pl1
1807         4    01/07/85  0958.8  dm_im_ci_header.incl.pl1          >ldd>incl>dm_im_ci_header.incl.pl1
1809         5    04/05/85  1024.4  dm_collmgr_entry_dcls.incl.pl1    >ldd>incl>dm_collmgr_entry_dcls.incl.pl1
1811         6    04/05/85  1024.4  dm_im_opening_info.incl.pl1       >ldd>incl>dm_im_opening_info.incl.pl1
1813         7    04/16/82  1058.1  sub_err_flags.incl.pl1            >ldd>incl>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000033 constant        bit(36)                  initial dcl 7-7 set ref 492*
ALL_FIELDS_PRESENT              000006 constant        fixed bin(17,0)          initial packed unaligned dcl 285 set ref 557* 557*
                                                                                  1676* 1676* 1794* 1794*
BITS_PER_PAGE                          constant        fixed bin(17,0)          initial dcl 299 ref 523 523 528 555 555 555 555 557
                                                                                  557 557 557 557 557 557 557 726 728 728 744 746
                                                                                  746 770 771 1181 1181 1189 1189 1365 1365 1656
                                                                                  1656 1659 1659 1661 1661 1667 1667 1670 1670 1673
                                                                                  1673 1676 1676 1676 1676 1790 1790 1790 1790 1792
                                                                                  1792 1793 1793 1794 1794 1794 1794
BRANCH_CI_HEADER_LENGTH_IN_BITS        constant        fixed bin(17,0)          initial dcl 4-56 ref 236 236 624 624 629 629 636 636
                                                                                  1329 1329 1704 1704
BRANCH_KEY_HEADER_LENGTH_IN_BITS       constant        fixed bin(35,0)          initial dcl 2-37 ref 1786
BRANCH_NODE                            constant        bit(1)                   initial dcl 287 set ref 928* 1067* 1488* 1573*
DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT
                                       constant        fixed bin(17,0)          initial dcl 4-56 ref 624 629 636 1329 1704 1744
DEFAULT_INITIAL_KEY_SLOT               constant        fixed bin(17,0)          initial dcl 4-56 ref 386 396 426 1378 1395 1718 1725
                                                                                  1757
DONT_UPDATE_STORAGE_MOVED              constant        bit(1)                   initial dcl 287 set ref 1477*
DOUBLE_WORDS_PER_PAGE                  constant        fixed bin(17,0)          initial dcl 299 ref 238 238 238 238 238 238
INDEX_OPENING_INFO_VERSION_3    000000 constant        char(8)                  initial dcl 6-47 set ref 719*
INSERT_KEY                      000033 constant        bit(1)                   initial dcl 287 set ref 930* 965* 1069* 1104*
LEAF_CI_HEADER_LENGTH_IN_BITS          constant        fixed bin(17,0)          initial dcl 4-56 ref 236 236 624 624 629 629 636 636
                                                                                  1329 1329 1704 1704
LEAF_NODE                              constant        bit(1)                   initial dcl 287 set ref 963* 1102* 1536* 1619*
NEXT_ROTATION                          constant        bit(1)                   initial dcl 287 set ref 926* 956* 961* 1029* 1469*
                                                                                  1524*
PREVIOUS_ROTATION                      constant        bit(1)                   initial dcl 287 set ref 1065* 1095* 1100* 1162*
                                                                                  1554* 1608*
REPLACE_KEY                     000034 constant        bit(1)                   initial dcl 287 set ref 1331*
UPDATE_STORAGE_MOVED                   constant        bit(1)                   initial dcl 287 set ref 533 1564*
additional_storage_required     000157 automatic       fixed bin(24,0)          dcl 244 set ref 424* 774* 775 790* 817* 841* 861*
                                                                                  937 972 1000 1007 1033 1076 1111 1140 1166 1480
                                                                                  1482* 1526 1532* 1568 1570* 1610 1615*
addr                                                   builtin function         dcl 279 ref 386 386 388 388 396 396 419 419 436 436
                                                                                  442 442 460 460 523 528 528 555 555 557 557 557
                                                                                  557 557 557 557 557 557 557 557 557 557 557 567
                                                                                  567 624 627 628 629 633 635 636 638 655 656 661
                                                                                  690 691 696 700 700 703 703 725 726 726 728 728
                                                                                  736 738 740 744 744 746 746 753 754 756 758 770
                                                                                  770 771 771 785 785 787 787 787 787 807 812 812
                                                                                  832 834 834 834 834 837 837 837 880 881 886 890
                                                                                  890 894 894 930 930 930 965 965 965 1069 1069 1069
                                                                                  1104 1104 1104 1181 1181 1189 1189 1226 1226 1230
                                                                                  1267 1268 1329 1329 1331 1331 1378 1378 1380 1380
                                                                                  1435 1438 1464 1466 1472 1472 1495 1520 1522 1552
                                                                                  1557 1566 1566 1605 1638 1640 1656 1659 1661 1661
                                                                                  1661 1661 1667 1670 1673 1673 1673 1673 1676 1676
                                                                                  1676 1676 1676 1676 1701 1704 1704 1714 1714 1718
                                                                                  1718 1720 1720 1725 1725 1727 1727 1732 1732 1743
                                                                                  1744 1745 1745 1757 1759 1761 1763 1765 1767 1782
                                                                                  1785 1790 1790 1792 1792 1792 1792 1793 1793 1793
                                                                                  1793 1794 1794 1794 1794 1794 1794
akitc_element_allocated         000254 automatic       bit(1)                   dcl 416 set ref 419* 421 450
akitc_p_key_doesnt_fit                 parameter       bit(1)                   dcl 414 set ref 411 450*
akitc_p_key_string_ptr                 parameter       pointer                  dcl 413 set ref 411 436*
amount_of_storage_to_be_moved   000161 automatic       fixed bin(24,0)          dcl 248 set ref 775* 1349 1445
based_header_buffer                    based           bit                      dcl 253 set ref 624* 629* 636* 1329* 1704*
bk_string_length                000162 automatic       fixed bin(35,0)          dcl 2-39 in procedure "im_rotate_insert" set ref
                                                                                  526* 557* 567 567 930 930 965 965 1069 1069 1104
                                                                                  1104 1331 1331 1676* 1786* 1794*
bk_string_length                000663 automatic       fixed bin(35,0)          dcl 1-39 in procedure "SET_STRING_PTR" set ref 1637*
                                                                                  1640
branch_ci_header                       based           structure                level 1 unaligned dcl 4-48 set ref 1302 1302 1304
                                                                                  1304
branch_ci_header_ptr            000172 automatic       pointer                  dcl 4-53 set ref 723*
branch_id                              based           fixed bin(24,0)          level 2 packed packed unsigned unaligned dcl 2-32
                                                                                  set ref 528 563* 807 1682* 1684* 1782 1800*
branch_key                             based           structure                level 1 packed packed unaligned dcl 2-32
                                                                                  in procedure "im_rotate_insert" set ref 567 567
                                                                                  930 930 965 965 1069 1069 1104 1104 1331 1331
branch_key                             based           structure                level 1 packed packed unaligned dcl 1-32
                                                                                  in procedure "SET_STRING_PTR"
branch_key_ptr                  000164 automatic       pointer                  dcl 2-40 set ref 557* 563 567 567 567* 930 930 965
                                                                                  965 1069 1069 1104 1104 1331 1331 1676* 1682 1684
                                                                                  1785* 1794* 1800
clbi_element_id                 000306 automatic       structure                level 1 dcl 516
clbi_p_ci_header_has_changed           parameter       bit(1)                   dcl 512 set ref 504 530*
clbi_p_ci_header_ptr                   parameter       pointer                  dcl 511 set ref 504 521 528 530*
clbi_p_control_interval_id             parameter       fixed bin(24,0)          packed unsigned unaligned dcl 509 ref 504 520
clbi_p_update_branches                 parameter       bit(1)                   dcl 514 set ref 504 530*
clbi_p_update_storage_moved            parameter       bit(1)                   dcl 507 ref 504 533
clbi_temp_key_string_length     000307 automatic       fixed bin(35,0)          dcl 517 set ref 523* 530* 533
clbttk_code                     000316 automatic       fixed bin(35,0)          dcl 552 set ref 557* 560 560*
clbttk_p_ci_header_has_changed         parameter       bit(1)                   dcl 549 set ref 544 572*
clbttk_p_ci_header_ptr                 parameter       pointer                  dcl 548 ref 544 555 563 573
clbttk_p_target_element_id_adjustment_proc
                                       parameter       entry variable           dcl 546 ref 544 565
collection_id             3            based           bit(36)                  level 2 dcl 6-26 set ref 665* 668* 700* 703* 728*
                                                                                  746* 890* 894* 1181* 1189* 1234* 1238* 1495* 1501*
                                                                                  1577* 1580* 1585* 1733*
collection_manager_$allocate_control_interval
                                000036 constant        entry                    external dcl 5-50 ref 1733
collection_manager_$delete      000040 constant        entry                    external dcl 5-64 ref 668
collection_manager_$delete_from_ci_buffer
                                000042 constant        entry                    external dcl 5-67 ref 665
collection_manager_$get         000044 constant        entry                    external dcl 5-71 ref 703
collection_manager_$modify      000046 constant        entry                    external dcl 5-101 ref 894
collection_manager_$modify_in_ci_buffer
                                000050 constant        entry                    external dcl 5-107 ref 890
collection_manager_$put         000052 constant        entry                    external dcl 5-115 ref 1238
collection_manager_$put_in_ci_buffer
                                000054 constant        entry                    external dcl 5-118 ref 1234
collection_manager_$replace_ci_buffer
                                000056 constant        entry                    external dcl 5-126 ref 1181 1189
collection_manager_$setup_ci_buffer
                                000060 constant        entry                    external dcl 5-129 ref 728 746
collection_manager_$simple_get_from_ci_buffer
                                000062 constant        entry                    external dcl 5-135 ref 700
common                                 based           structure                level 2 in structure "leaf_ci_header" unaligned
                                                                                  dcl 4-43 in procedure "im_rotate_insert"
common                          000100 automatic       structure                level 2 in structure "local_branch_ci_header"
                                                                                  unaligned dcl 203 in procedure "im_rotate_insert"
common_ci_header                       based           structure                level 1 unaligned dcl 4-26
common_ci_header_ptr            000166 automatic       pointer                  dcl 4-41 set ref 723*
control_interval_id             000306 automatic       fixed bin(24,0)          level 2 in structure "clbi_element_id" packed packed
                                                                                  unsigned unaligned dcl 516 in procedure
                                                                                  "COMPRESS_LOW_BRANCH_ID" set ref 520* 523* 530*
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "source_parent_id" packed
                                                                                  packed unsigned unaligned dcl 266 in procedure
                                                                                  "im_rotate_insert" set ref 460 1701 1704*
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "target_parent_id" packed
                                                                                  packed unsigned unaligned dcl 271 in procedure
                                                                                  "im_rotate_insert" ref 460
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "pk_element_id" packed packed
                                                                                  unsigned unaligned dcl 1264 in procedure "PUT_KEY"
                                                                                  set ref 1267*
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "spnfi_element_id" packed
                                                                                  packed unsigned unaligned dcl 1697 in procedure
                                                                                  "SETUP_PARENT_NODE_FOR_INSERTION" set ref 1743*
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "rpk_p_parent_element_id"
                                                                                  packed packed unsigned unaligned dcl 1324
                                                                                  in procedure "REPLACE_PARENT_KEY" set ref 1329*
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "pe_element_id" packed packed
                                                                                  unsigned unaligned dcl 1212 in procedure
                                                                                  "PUT_ELEMENT" ref 1226 1226 1230
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "fe_element_id" packed packed
                                                                                  unsigned unaligned dcl 652 in procedure
                                                                                  "DELETE_ELEMENT" set ref 655* 661
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "target_element_id" packed
                                                                                  packed unsigned unaligned dcl 264 in procedure
                                                                                  "im_rotate_insert" set ref 567* 736* 738* 740
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "p_key_id" packed packed
                                                                                  unsigned unaligned dcl 265 in procedure
                                                                                  "im_rotate_insert" set ref 442* 725 785* 787* 812*
                                                                                  834*
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "ge_element_id" packed packed
                                                                                  unsigned unaligned dcl 687 in procedure
                                                                                  "GET_ELEMENT" set ref 690* 696
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "me_element_id" packed packed
                                                                                  unsigned unaligned dcl 877 in procedure
                                                                                  "MODIFY_ELEMENT" set ref 880* 886
csr_p_additional_storage_required      parameter       fixed bin(24,0)          dcl 476 set ref 472 482* 482
csr_p_total_amount_of_storage_moved    parameter       fixed bin(24,0)          dcl 474 ref 472 479 482
current_key_buffer_ptr          000136 automatic       pointer                  dcl 224 set ref 770* 1358 1362* 1365 1367
cv_p_expected_version                  parameter       char(8)                  dcl 489 set ref 486 492 492*
cv_p_received_version                  parameter       char(8)                  dcl 488 set ref 486 492 492*
cv_p_structure_name                    parameter       char                     packed unaligned dcl 490 set ref 486 492*
divide                                                 builtin function         dcl 279 ref 775
dk_p_ci_header_has_changed             parameter       bit(1)                   dcl 587 set ref 579 598*
dk_p_ci_header_ptr                     parameter       pointer                  dcl 585 ref 579 593 593 594 594 604
dk_p_control_interval_id               parameter       fixed bin(24,0)          packed unsigned unaligned dcl 582 set ref 579 591*
dk_p_index                             parameter       fixed bin(12,0)          packed unsigned unaligned dcl 584 set ref 579 591*
                                                                                  604
dk_p_key_length                        parameter       fixed bin(35,0)          dcl 586 ref 579 594
dk_p_update_branches                   parameter       bit(1)                   dcl 589 set ref 579 604 604*
dm_error_$long_element          000034 external static fixed bin(35,0)          dcl 328 set ref 356* 460* 479* 741* 1240
element_id                             based           structure                level 1 dcl 3-32
er_p_code                              parameter       fixed bin(35,0)          dcl 365 ref 363 366
error_table_$unimplemented_version
                                000032 external static fixed bin(35,0)          dcl 326 set ref 492*
fe_ci_ptr                       000346 automatic       pointer                  dcl 650 set ref 661* 663* 665*
fe_code                         000344 automatic       fixed bin(35,0)          dcl 649 set ref 665* 668* 670 670*
fe_element_id                          based           structure                level 1 dcl 652
fe_element_id_string            000350 automatic       bit(36)                  dcl 653 set ref 655 656 661 665* 668*
fe_p_ci                                parameter       fixed bin(24,0)          packed unsigned unaligned dcl 647 ref 644 655 658
                                                                                  658
fe_p_index                             parameter       fixed bin(12,0)          packed unsigned unaligned dcl 648 ref 644 656
field_table_ptr           6            based           pointer                  initial level 2 dcl 6-26 set ref 557* 1676* 1794*
file_opening_id           2            based           bit(36)                  level 2 dcl 6-26 set ref 665* 668* 703* 728* 746*
                                                                                  890* 894* 1181* 1189* 1234* 1238* 1495* 1501*
                                                                                  1577* 1580* 1585* 1733*
first                     1            based           fixed bin(18,0)          level 3 in structure "common_ci_header" packed
                                                                                  packed unsigned unaligned dcl 4-26 in procedure
                                                                                  "im_rotate_insert" set ref 426 426* 521 756 761
                                                                                  1395 1395* 1445 1553 1557 1606 1610* 1656 1659
first                     1            based           fixed bin(18,0)          level 4 in structure "leaf_ci_header" packed packed
                                                                                  unsigned unaligned dcl 4-43 in procedure
                                                                                  "im_rotate_insert" ref 633
flags                                  based           structure                level 2 packed packed unaligned dcl 4-26
fsk_current_ci                  000334 automatic       fixed bin(24,0)          packed unsigned unaligned dcl 621 set ref 623* 624*
                                                                                  628* 629* 633* 635* 636* 638*
fsk_p_high_key_buffer                  parameter       bit                      dcl 620 set ref 616 633*
fsk_p_low_key_buffer                   parameter       bit                      dcl 619 set ref 616 638*
fsk_p_origin_ci                        parameter       fixed bin(24,0)          packed unsigned unaligned dcl 618 ref 616 623
ge_ci_ptr                       000362 automatic       pointer                  dcl 685 set ref 696* 698* 700*
ge_code                         000360 automatic       fixed bin(35,0)          dcl 684 set ref 700* 703* 706 706*
ge_element_id                          based           structure                level 1 dcl 687
ge_element_id_string            000364 automatic       bit(36)                  dcl 688 set ref 690 691 696 700* 703*
ge_p_buffer                            parameter       bit                      dcl 682 set ref 677 700 700 700 700 703 703 703 703
ge_p_ci                                parameter       fixed bin(24,0)          packed unsigned unaligned dcl 680 ref 677 690 693
                                                                                  693
ge_p_index                             parameter       fixed bin(12,0)          packed unsigned unaligned dcl 681 ref 677 691
ge_p_length                            parameter       fixed bin(35,0)          dcl 683 set ref 677 700* 703*
high_index                      000154 automatic       fixed bin(35,0)          dcl 232 set ref 1349 1445 1445 1463* 1519* 1552*
                                                                                  1605*
high_key_string_ptr             000132 automatic       pointer                  dcl 222 set ref 767* 1368* 1416* 1423* 1529* 1610*
                                                                                  1653 1661* 1676* 1793* 1794*
i_code                          000374 automatic       fixed bin(35,0)          initial dcl 716 set ref 716* 728* 730 730* 733* 746*
                                                                                  748 748*
i_p_rotate_previous                    parameter       bit(1)                   dcl 715 ref 713 736 754 761
ikalbi_p_ci_header_has_changed         parameter       bit(1)                   dcl 804 set ref 801 808*
ikalbi_p_ci_header_ptr                 parameter       pointer                  dcl 803 ref 801 807
ilkisc_p_key_index                     parameter       fixed bin(18,0)          packed unsigned unaligned dcl 828 ref 826 837
ilkisc_p_key_string_ptr                parameter       pointer                  dcl 829 set ref 826 837*
ilktc_key_doesnt_fit            000426 automatic       bit(1)                   initial dcl 856 set ref 856* 860* 861
ilktc_p_key_string_ptr                 parameter       pointer                  dcl 854 set ref 850 860*
ilktc_p_target_element_id_adjustment_proc
                                       parameter       entry variable           dcl 852 ref 850 858
im_general_insert               000016 constant        entry                    external dcl 310 ref 930 965 1069 1104 1331
im_init_branch_ci_header        000020 constant        entry                    external dcl 311 ref 1732
im_make_parent_key              000022 constant        entry                    external dcl 313 ref 557 1676 1794
im_update_branches              000024 constant        entry                    external dcl 315 ref 1495 1501 1577 1585
im_update_branches$single       000026 constant        entry                    external dcl 317 ref 1580
im_update_opening_info$root_id  000030 constant        entry                    external dcl 320 ref 1750
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "pk_element_id" packed packed
                                                                                  unsigned unaligned dcl 1264 in procedure "PUT_KEY"
                                                                                  set ref 1268*
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "source_parent_id" packed
                                                                                  packed unsigned unaligned dcl 266 in procedure
                                                                                  "im_rotate_insert" set ref 1718 1718* 1720* 1720
                                                                                  1725
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "fe_element_id" packed packed
                                                                                  unsigned unaligned dcl 652 in procedure
                                                                                  "DELETE_ELEMENT" set ref 656*
index                     0(24) 000306 automatic       fixed bin(12,0)          level 2 in structure "clbi_element_id" packed packed
                                                                                  unsigned unaligned dcl 516 in procedure
                                                                                  "COMPRESS_LOW_BRANCH_ID" set ref 521* 523* 530*
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "target_element_id" packed
                                                                                  packed unsigned unaligned dcl 264 in procedure
                                                                                  "im_rotate_insert" set ref 386 386* 388* 388 396
                                                                                  396* 567* 754* 756* 758 1378 1378* 1380* 1380
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "p_key_id" packed packed
                                                                                  unsigned unaligned dcl 265 in procedure
                                                                                  "im_rotate_insert" set ref 442* 785* 787* 812*
                                                                                  832* 834* 837 1435* 1438* 1464 1466 1472 1472 1495
                                                                                  1520 1522 1552 1557 1566* 1566 1605
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "me_element_id" packed packed
                                                                                  unsigned unaligned dcl 877 in procedure
                                                                                  "MODIFY_ELEMENT" set ref 881*
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "spnfi_element_id" packed
                                                                                  packed unsigned unaligned dcl 1697 in procedure
                                                                                  "SETUP_PARENT_NODE_FOR_INSERTION" set ref 1744*
                                                                                  1757* 1763*
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "target_parent_id" packed
                                                                                  packed unsigned unaligned dcl 271 in procedure
                                                                                  "im_rotate_insert" set ref 1725* 1727* 1727
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "ge_element_id" packed packed
                                                                                  unsigned unaligned dcl 687 in procedure
                                                                                  "GET_ELEMENT" set ref 691*
index_opening_info                     based           structure                level 1 dcl 6-26
index_opening_info_ptr          000174 automatic       pointer                  initial dcl 6-46 set ref 6-46* 557 665 665 668 668
                                                                                  700 703 703 718* 719 728 728 746 746 890 890 894
                                                                                  894 930* 965* 1069* 1104* 1181 1181 1189 1189 1234
                                                                                  1234 1238 1238 1331* 1495 1495 1501 1501 1577 1577
                                                                                  1580 1580 1585 1585 1676 1733 1733 1750* 1794
internal_debug                  000010 internal static bit(1)                   initial dcl 332 set ref 373* 378* 1440
ioa_                            000012 constant        entry                    external dcl 308 ref 1445
is_leaf                                based           bit(1)                   level 3 packed packed unaligned dcl 4-26 set ref 340
                                                                                  436* 627 837* 1368* 1371* 1417* 1423* 1445* 1661*
                                                                                  1673*
key_buffer                             based           bit                      dcl 255 set ref 1365*
key_buffer_1                           based           bit                      dcl 255 set ref 555* 557 557 770 1790* 1792 1792
key_buffer_2                           based           bit                      dcl 255 set ref 555* 557 557 771 1790* 1793 1793
key_buffer_3                           based           bit                      dcl 255 set ref 523* 528 1656* 1659* 1661 1661 1667*
                                                                                  1670* 1673 1673
key_range                 1     000100 automatic       structure                level 3 in structure "local_branch_ci_header" packed
                                                                                  packed unaligned dcl 203 in procedure
                                                                                  "im_rotate_insert" set ref 1742*
key_range                 1            based           structure                level 2 in structure "common_ci_header" packed
                                                                                  packed unaligned dcl 4-26 in procedure
                                                                                  "im_rotate_insert"
key_range                 1            based           structure                level 2 in structure "pk_p_ci_header" packed packed
                                                                                  unaligned dcl 1263 in procedure "PUT_KEY"
key_range                 1            based           structure                level 3 in structure "leaf_ci_header" packed packed
                                                                                  unaligned dcl 4-43 in procedure "im_rotate_insert"
key_tail_space_used_since_last_prefix_compaction
                          0(18)        based           fixed bin(18,0)          level 2 in structure "pk_p_ci_header" packed packed
                                                                                  unsigned unaligned dcl 1263 in procedure "PUT_KEY"
                                                                                  set ref 1273* 1273
key_tail_space_used_since_last_prefix_compaction
                          0(18)        based           fixed bin(18,0)          level 2 in structure "common_ci_header" packed
                                                                                  packed unsigned unaligned dcl 4-26 in procedure
                                                                                  "im_rotate_insert" set ref 431* 431 594* 594 775
                                                                                  1401* 1401
last                      1(18)        based           fixed bin(18,0)          level 3 in structure "common_ci_header" packed
                                                                                  packed unsigned unaligned dcl 4-26 in procedure
                                                                                  "im_rotate_insert" set ref 426* 429* 429 593* 593
                                                                                  604 754 763 1395* 1398* 1398 1445 1463 1472 1472
                                                                                  1519 1526* 1667 1670
last                      1(18)        based           fixed bin(18,0)          level 3 in structure "pk_p_ci_header" packed packed
                                                                                  unsigned unaligned dcl 1263 in procedure "PUT_KEY"
                                                                                  set ref 1272* 1272 1278
last                      1(18)        based           fixed bin(18,0)          level 4 in structure "leaf_ci_header" packed packed
                                                                                  unsigned unaligned dcl 4-43 in procedure
                                                                                  "im_rotate_insert" ref 638
leaf_ci_header                         based           structure                level 1 unaligned dcl 4-43 ref 1295 1295 1297 1297
leaf_ci_header_ptr              000170 automatic       pointer                  dcl 4-46 set ref 723*
leaf_key                               based           structure                level 1 packed packed unaligned dcl 1-26
length                                                 builtin function         dcl 279 ref 419 419 431 442 442 557 557 567 567 700
                                                                                  700 703 703 728 728 746 746 787 787 812 812 834
                                                                                  834 890 890 894 894 1181 1181 1189 1189 1676 1676
                                                                                  1745 1745 1786 1794 1794
lk_string_length                000662 automatic       fixed bin(35,0)          dcl 1-29 set ref 1637* 1638
local_branch_ci_header          000100 automatic       structure                level 1 unaligned dcl 203 set ref 930 930 965 965
                                                                                  1069 1069 1104 1104 1329 1331 1331 1704 1732 1732
                                                                                  1745 1745 1745 1745
local_fsk_header_buffer         000156 automatic       bit                      dcl 236 set ref 624 627 628 629 633 635 636 638
local_key_buffer_1              000156 automatic       fixed bin(71,0)          array dcl 238 set ref 555 557 557 770 1790 1792 1792
local_key_buffer_2              000156 automatic       fixed bin(71,0)          array dcl 238 set ref 555 557 557 771 1790 1793 1793
local_key_buffer_3              000156 automatic       fixed bin(71,0)          array dcl 238 set ref 523 528 1656 1659 1661 1661
                                                                                  1667 1670 1673 1673
local_parent_key_buffer         000156 automatic       fixed bin(71,0)          array dcl 238 set ref 557 557 557 557 1676 1676 1676
                                                                                  1676 1794 1794 1794 1794
local_source_ci_buffer          000156 automatic       fixed bin(71,0)          array dcl 238 set ref 726 728 728 1181 1181
local_target_ci_buffer          000156 automatic       fixed bin(71,0)          array dcl 238 set ref 744 746 746 1189 1189
low_branch_id             5            based           fixed bin(24,0)          level 2 in structure "branch_ci_header" packed
                                                                                  packed unsigned unaligned dcl 4-48 in procedure
                                                                                  "im_rotate_insert" set ref 528* 555* 563 573* 628
                                                                                  807* 913 1048 1053* 1053 1055* 1477 1561 1782
                                                                                  1790*
low_branch_id             5     000100 automatic       fixed bin(24,0)          level 2 in structure "local_branch_ci_header" packed
                                                                                  packed unsigned unaligned dcl 203 in procedure
                                                                                  "im_rotate_insert" set ref 1738* 1740*
low_index                       000153 automatic       fixed bin(35,0)          dcl 232 set ref 1349 1464* 1466* 1520* 1522* 1553*
                                                                                  1606*
low_key_string_ptr              000134 automatic       pointer                  dcl 223 set ref 768* 1371* 1417* 1422* 1526* 1613*
                                                                                  1664 1673* 1676* 1792* 1794*
max                                                    builtin function         dcl 279 ref 236 236 594 624 624 629 629 636 636 775
                                                                                  1329 1329 1704 1704
me_ci_ptr                       000440 automatic       pointer                  dcl 875 set ref 886* 888* 890*
me_code                         000436 automatic       fixed bin(35,0)          dcl 874 set ref 890* 894* 896 896*
me_element_id                          based           structure                level 1 dcl 877
me_element_id_string            000442 automatic       bit(36)                  dcl 878 set ref 880 881 886 890* 894*
me_p_buffer                            parameter       bit                      packed unaligned dcl 873 set ref 868 890 890 890 890
                                                                                  894 894 894 894
me_p_ci                                parameter       fixed bin(24,0)          packed unsigned unaligned dcl 871 ref 868 880 883
                                                                                  883
me_p_index                             parameter       fixed bin(12,0)          packed unsigned unaligned dcl 872 ref 868 881
myname                          000002 constant        char(16)                 initial packed unaligned dcl 304 set ref 492*
new_ci                          000106 automatic       fixed bin(24,0)          unsigned dcl 205 set ref 1733* 1743 1750*
next_id                   3(24)        based           fixed bin(24,0)          level 2 packed packed unsigned unaligned dcl 4-26
                                                                                  ref 738
nrieb_code                      000452 automatic       fixed bin(35,0)          initial dcl 911 set ref 911* 930* 932 932*
nriel_code                      000462 automatic       fixed bin(35,0)          initial dcl 950 set ref 950* 965* 967 967*
null                                                   builtin function         dcl 279 ref 6-46 492 492 557 557 703 703 703 703 723
                                                                                  765 767 768 1416 1422 1653 1664 1676 1676 1794
                                                                                  1794
old_key_buffer_ptr              000140 automatic       pointer                  dcl 225 set ref 771* 1362 1363*
old_temp_key_string_ptr         000126 automatic       pointer                  dcl 217 set ref 1356*
one_or_more_keys_were_rotated   000130 automatic       bit(1)                   dcl 219 set ref 425* 766* 1000 1026 1159 1388*
original_target_index           000152 automatic       fixed bin(12,0)          packed unsigned unaligned dcl 231 set ref 758* 759
                                                                                  1585*
p_additional_storage_required          parameter       fixed bin(35,0)          dcl 197 set ref 182 356 774 937* 972* 1007* 1033*
                                                                                  1076* 1111* 1140* 1166*
p_code                                 parameter       fixed bin(35,0)          dcl 199 set ref 182 336* 366*
p_common_ci_header_ptr                 parameter       pointer                  dcl 192 ref 182 721
p_index_opening_info_ptr               parameter       pointer                  dcl 189 ref 182 718
p_insert_new_key                       parameter       bit(1)                   dcl 191 ref 182 442 785 812 832 1464 1472 1472 1520
p_insert_parent_key                    parameter       bit(1)                   dcl 194 ref 182 923 958 1062 1097
p_key_id                               based           structure                level 1 dcl 265
p_key_id_string                        parameter       bit(36)                  dcl 196 set ref 182 442 442 447* 725 785 785 787 787
                                                                                  812 812 832 834 834 837 1435 1438 1464 1466 1472
                                                                                  1472 1495 1520 1522 1552 1557 1566 1566 1605
p_key_string                           parameter       bit                      packed unaligned dcl 195 set ref 182 419 419 419 419
                                                                                  431 436 436 442 442 785* 787 787 787 787 807 812
                                                                                  812 832* 834 834 834 834 837 837 1782 1785 1786
p_rotate_previous                      parameter       bit(1)                   dcl 193 set ref 182 338* 340 348
parent_id_string          2            based           bit(36)                  level 2 in structure "common_ci_header" dcl 4-26
                                                                                  in procedure "im_rotate_insert" set ref 460 460
                                                                                  930 965 1069 1104 1701 1704 1714 1714 1718 1718
                                                                                  1720 1720 1725 1725 1727 1727 1759 1761 1765 1767
parent_id_string          2            based           bit(36)                  level 2 in structure "rpk_p_ci_header" dcl 1323
                                                                                  in procedure "REPLACE_PARENT_KEY" set ref 1329
                                                                                  1331 1331
parent_key_buffer                      based           bit                      dcl 255 set ref 557 557 557 557 1676 1676 1676 1676
                                                                                  1794 1794 1794 1794
pcb_code                        000544 automatic       fixed bin(35,0)          dcl 1176 set ref 1181* 1183 1183* 1189* 1191 1191*
pe_ci_ptr                       000556 automatic       pointer                  dcl 1211 set ref 1230* 1232* 1234*
pe_code                         000554 automatic       fixed bin(35,0)          dcl 1210 set ref 1234* 1238* 1240 1240 1243*
pe_element_id                          based           structure                level 1 dcl 1212
pe_element_id_string            000560 automatic       bit(36)                  dcl 1213 set ref 1223* 1226 1226 1230 1234* 1238*
pe_p_element_id_string                 parameter       bit(36)                  dcl 1204 ref 1201 1219 1223
pe_p_element_length                    parameter       fixed bin(35,0)          dcl 1205 set ref 1201 1219 1234* 1238*
pe_p_element_ptr                       parameter       pointer                  dcl 1206 set ref 1201 1219 1234* 1238*
pe_p_element_was_allocated             parameter       bit(1)                   dcl 1208 set ref 1219 1222* 1240*
pe_p_space_left                        parameter       fixed bin(35,0)          dcl 1207 set ref 1201 1219 1234* 1238*
pe_report_allocated             000561 automatic       bit(1)                   dcl 1214 set ref 1216* 1221* 1240
ph_p_is_leaf                           parameter       bit(1)                   dcl 1290 ref 1288 1292
pk_element_id                          based           structure                level 1 dcl 1264
pk_element_id_string            000570 automatic       bit(36)                  dcl 1265 set ref 1267 1268 1270*
pk_p_ci_header                         based           structure                level 1 dcl 1263
pk_p_ci_header_has_changed             parameter       bit(1)                   dcl 1257 set ref 1247 1276*
pk_p_ci_header_ptr                     parameter       pointer                  dcl 1256 ref 1247 1272 1272 1273 1273 1278
pk_p_control_interval_id               parameter       fixed bin(24,0)          packed unsigned unaligned dcl 1251 ref 1247 1267
pk_p_index                             parameter       fixed bin(12,0)          packed unsigned unaligned dcl 1253 ref 1247 1268
                                                                                  1278
pk_p_key_length                        parameter       fixed bin(35,0)          dcl 1254 set ref 1247 1270* 1273
pk_p_key_ptr                           parameter       pointer                  dcl 1255 set ref 1247 1270*
pk_p_total_storage_available           parameter       fixed bin(35,0)          dcl 1260 set ref 1247 1270*
pk_p_update_branches                   parameter       bit(1)                   dcl 1259 set ref 1247 1278 1278*
previous_id               3            based           fixed bin(24,0)          level 2 in structure "common_ci_header" packed
                                                                                  packed unsigned unaligned dcl 4-26 in procedure
                                                                                  "im_rotate_insert" ref 736
previous_id               3            based           fixed bin(24,0)          level 3 in structure "leaf_ci_header" packed packed
                                                                                  unsigned unaligned dcl 4-43 in procedure
                                                                                  "im_rotate_insert" ref 635
prieb_code                      000506 automatic       fixed bin(35,0)          initial dcl 1046 set ref 1046* 1069* 1071 1071*
priel_code                      000516 automatic       fixed bin(35,0)          initial dcl 1089 set ref 1089* 1104* 1106 1106*
prinb_code                      000526 automatic       fixed bin(35,0)          initial dcl 1126 set ref 1126*
r_element_allocated             000616 automatic       bit(1)                   dcl 1345 set ref 1347* 1349 1383* 1385 1434
r_p_rotate_previous                    parameter       bit(1)                   dcl 1344 set ref 1342 1353 1368 1380 1407 1413 1435
                                                                                  1445*
rnb_code                        000626 automatic       fixed bin(35,0)          dcl 1461 set ref 1495* 1497 1497* 1501* 1503 1503*
rotate_idx                      000155 automatic       fixed bin(35,0)          dcl 234 set ref 1349* 1353* 1435 1438 1443* 1443
                                                                                  1445 1445
rpb_code                        000644 automatic       fixed bin(35,0)          dcl 1550 set ref 1577* 1580* 1582 1582* 1585* 1587
                                                                                  1587*
rpk_code                        000606 automatic       fixed bin(35,0)          dcl 1327 set ref 1331* 1333 1333*
rpk_p_ci_header                        based           structure                level 1 dcl 1323
rpk_p_ci_header_ptr                    parameter       pointer                  dcl 1322 ref 1320 1329 1331 1331
rpk_p_parent_element_id                based           structure                level 1 dcl 1324
source_ci                       000110 automatic       fixed bin(24,0)          packed unsigned unaligned dcl 210 set ref 658 661
                                                                                  693 696 725* 728 832* 883 886 1181 1226 1230 1295*
                                                                                  1302* 1365* 1427* 1445* 1495* 1564* 1577* 1580*
                                                                                  1596* 1656* 1670* 1682 1740
source_ci_buffer                       based           bit                      dcl 255 set ref 726 728 728 1181 1181
source_ci_has_changed           000143 automatic       bit(1)                   initial dcl 227 set ref 227* 1178 1195* 1308*
source_ci_header_has_changed    000142 automatic       bit(1)                   initial dcl 227 set ref 227* 442* 787* 812* 834*
                                                                                  1057* 1133* 1295 1302 1308 1311* 1406* 1427* 1557*
                                                                                  1564* 1710* 1768*
source_ci_header_ptr            000114 automatic       pointer                  dcl 214 set ref 340 436 442* 460 721* 736 738 761
                                                                                  763 775 787* 812* 834* 837 930 965 1053 1055 1057*
                                                                                  1069 1074* 1104 1109* 1133* 1138* 1163* 1295 1295
                                                                                  1302 1302 1368 1371 1417 1423 1427* 1445 1445 1445
                                                                                  1463 1472 1472 1495* 1519 1526 1553 1557 1557*
                                                                                  1561 1564* 1577* 1580* 1596* 1606 1610 1656 1661
                                                                                  1670 1673 1701 1704 1714 1718 1718 1720 1720 1725
                                                                                  1759 1767
source_ci_ptr                   000120 automatic       pointer                  dcl 214 set ref 661 696 726* 728* 886 1181* 1230
                                                                                  1495* 1577* 1580*
source_key_index                000113 automatic       fixed bin(12,0)          packed unsigned unaligned dcl 213 set ref 761* 763*
                                                                                  1353* 1365* 1427
source_parent_id                       based           structure                level 1 dcl 266
source_parent_id_string                based           bit(36)                  dcl 268 set ref 930* 965* 1069* 1104* 1714 1759*
                                                                                  1767*
spk_code                        000712 automatic       fixed bin(35,0)          dcl 1780 set ref 1794* 1797 1797*
spk_p_ci_header_ptr                    parameter       pointer                  dcl 1778 ref 1776 1782 1790
spk_p_ci_id                            parameter       fixed bin(24,0)          packed unsigned unaligned dcl 1779 ref 1776 1800
spkfln_code                     000672 automatic       fixed bin(35,0)          dcl 1651 set ref 1676* 1679 1679*
spkfln_p_rotate_previous               parameter       bit(1)                   dcl 1649 ref 1647 1656 1667 1682
spnfi_code                      000702 automatic       fixed bin(35,0)          dcl 1696 set ref 1733* 1735 1735* 1750* 1751 1751*
spnfi_element_id                       based           structure                level 1 dcl 1697
spnfi_element_id_string         000703 automatic       bit(36)                  dcl 1698 set ref 1743 1744 1745* 1757 1759 1761 1763
                                                                                  1765 1767
spnfi_p_rotate_previous                parameter       bit(1)                   dcl 1694 ref 1692 1707 1738 1759 1765
ssp_p_is_leaf                          parameter       bit(1)                   packed unaligned dcl 1633 ref 1631 1638
ssp_p_key_ptr                          parameter       pointer                  dcl 1634 ref 1631 1638 1640
ssp_p_key_string_ptr                   parameter       pointer                  dcl 1635 set ref 1631 1638* 1640*
string                    1            based           bit                      level 2 in structure "branch_key" packed packed
                                                                                  unaligned dcl 1-32 in procedure "SET_STRING_PTR"
                                                                                  set ref 1640
string                                 based           bit                      level 2 in structure "leaf_key" packed packed
                                                                                  unaligned dcl 1-26 in procedure "SET_STRING_PTR"
                                                                                  set ref 1638
sub_err_                        000014 constant        entry                    external dcl 309 ref 492
target_ci                       000111 automatic       fixed bin(24,0)          packed unsigned unaligned dcl 210 set ref 658 693
                                                                                  740* 741 746 751* 883 921* 1003* 1189 1226 1297*
                                                                                  1304* 1445* 1477* 1501* 1585* 1659* 1667* 1684
                                                                                  1738
target_ci_buffer                       based           bit                      dcl 255 set ref 744 746 746 1189 1189
target_ci_has_changed           000145 automatic       bit(1)                   initial dcl 227 set ref 227* 1186 1195* 1309*
target_ci_header_has_changed    000144 automatic       bit(1)                   initial dcl 227 set ref 227* 435* 567* 913* 993*
                                                                                  1052* 1297 1304 1309 1311* 1405* 1472* 1477* 1711*
                                                                                  1724* 1768*
target_ci_header_ptr            000116 automatic       pointer                  dcl 214 set ref 426 426 426 429 429 431 431 460 567*
                                                                                  753* 754 756 913 913* 921* 935* 970* 993* 1003*
                                                                                  1004* 1030* 1048 1053 1297 1297 1304 1304 1395
                                                                                  1395 1395 1398 1398 1401 1401 1472* 1477 1477*
                                                                                  1501* 1585* 1659 1667 1714 1725 1727 1727 1761
                                                                                  1765
target_ci_ptr                   000122 automatic       pointer                  dcl 214 set ref 663 698 744* 746* 888 1189* 1232
                                                                                  1501* 1585*
target_ci_was_empty             000131 automatic       bit(1)                   dcl 221 set ref 340 345 348 352 759* 1445*
target_element_id                      based           structure                level 1 packed packed unaligned dcl 264
target_element_id_string        000112 automatic       bit(36)                  dcl 211 set ref 386 386 388 388 396 396 419* 447 567
                                                                                  567 736 738 740 754 756 758 1378 1378 1380 1380
                                                                                  1383*
target_header_buffer            000156 automatic       bit                      dcl 236 set ref 751* 753
target_parent_id                       based           structure                level 1 dcl 271
target_parent_id_string                based           bit(36)                  dcl 273 set ref 1714* 1761* 1765*
temp_key_string_length          000107 automatic       fixed bin(35,0)          dcl 208 set ref 1365* 1383* 1401 1411 1427*
temp_key_string_ptr             000124 automatic       pointer                  dcl 216 set ref 765* 1356 1358* 1363 1367* 1368*
                                                                                  1371* 1383* 1417* 1423*
there_is_more_room_in_target_ci 000150 automatic       bit(1)                   initial dcl 227 set ref 227* 1434* 1435 1443 1529
                                                                                  1613
total_amount_of_storage_moved   000156 automatic       fixed bin(24,0)          dcl 242 set ref 533* 533 772* 861* 1349 1411* 1411
                                                                                  1445* 1480 1482* 1526 1532* 1568 1570* 1610 1615*
total_storage_available         000160 automatic       fixed bin(35,0)          dcl 246 set ref 419* 567* 787* 834* 890* 894* 1383*
unspec                                                 builtin function         dcl 279 ref 567 567 930 930 965 965 1069 1069 1104
                                                                                  1104 1295 1295 1297 1297 1302 1302 1304 1304 1331
                                                                                  1331 1331 1331 1745 1745
update_source_branches          000147 automatic       bit(1)                   initial dcl 227 set ref 227* 442* 787* 812* 834*
                                                                                  1407* 1427* 1492 1564* 1577
update_target_branches          000146 automatic       bit(1)                   initial dcl 227 set ref 227* 567* 1051* 1409* 1477*
use_source_and_target_ci_buffers
                                000151 automatic       bit(1)                   initial dcl 227 set ref 227* 658 693 734* 883 1195*
                                                                                  1226
version                                based           char(8)                  level 2 dcl 6-26 set ref 719*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 7-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 7-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 7-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 7-7
BRANCH_KEY_HEADER_LENGTH_IN_BITS       internal static fixed bin(35,0)          initial dcl 1-37
branch_key_ptr                         automatic       pointer                  dcl 1-40
collection_manager_$compact_control_interval
                                000000 constant        entry                    external dcl 5-52
collection_manager_$create_collection
                                000000 constant        entry                    external dcl 5-54
collection_manager_$create_file 000000 constant        entry                    external dcl 5-56
collection_manager_$destroy_collection
                                000000 constant        entry                    external dcl 5-58
collection_manager_$free_control_interval
                                000000 constant        entry                    external dcl 5-60
collection_manager_$get_by_ci_ptr
                                000000 constant        entry                    external dcl 5-80
collection_manager_$get_control_interval_ptr
                                000000 constant        entry                    external dcl 5-74
collection_manager_$get_from_ci_buffer
                                000000 constant        entry                    external dcl 5-77
collection_manager_$get_header  000000 constant        entry                    external dcl 5-83
collection_manager_$get_id      000000 constant        entry                    external dcl 5-86
collection_manager_$get_portion 000000 constant        entry                    external dcl 5-89
collection_manager_$get_portion_by_ci_ptr
                                000000 constant        entry                    external dcl 5-97
collection_manager_$get_portion_from_ci_buffer
                                000000 constant        entry                    external dcl 5-93
collection_manager_$modify_portion
                                000000 constant        entry                    external dcl 5-110
collection_manager_$modify_unprotected
                                000000 constant        entry                    external dcl 5-104
collection_manager_$postcommit_increments
                                000000 constant        entry                    external dcl 5-113
collection_manager_$put_header  000000 constant        entry                    external dcl 5-121
collection_manager_$put_unprotected_header
                                000000 constant        entry                    external dcl 5-123
collection_manager_$simple_get_by_ci_ptr
                                000000 constant        entry                    external dcl 5-132
element_id_string                      automatic       bit(36)                  dcl 3-30
key_string                             based           bit                      packed unaligned dcl 1-22 in procedure
                                                                                  "SET_STRING_PTR"
key_string                             based           bit                      packed unaligned dcl 2-22 in procedure
                                                                                  "im_rotate_insert"
key_string_length                      automatic       fixed bin(35,0)          dcl 2-23 in procedure "im_rotate_insert"
key_string_length                      automatic       fixed bin(35,0)          dcl 1-23 in procedure "SET_STRING_PTR"
key_string_ptr                         automatic       pointer                  dcl 1-24 in procedure "SET_STRING_PTR"
key_string_ptr                         automatic       pointer                  dcl 2-24 in procedure "im_rotate_insert"
leaf_key                               based           structure                level 1 packed packed unaligned dcl 2-26
leaf_key_ptr                           automatic       pointer                  dcl 1-30 in procedure "SET_STRING_PTR"
leaf_key_ptr                           automatic       pointer                  dcl 2-30 in procedure "im_rotate_insert"
lk_string_length                       automatic       fixed bin(35,0)          dcl 2-29

NAMES DECLARED BY EXPLICIT CONTEXT.
ADJUST_TARGET_ELEMENT_ID_FOR_NEXT_INSERT
                                000442 constant        entry                    internal dcl 394 ref 913 913 993 993 1529 1529
ADJUST_TARGET_ELEMENT_ID_FOR_PREVIOUS_INSERT
                                000417 constant        entry                    internal dcl 384 ref 1057 1057 1133 1133 1613 1613
ALLOCATE_KEY_IN_TARGET_CI       000460 constant        entry                    internal dcl 411 ref 860
CHECK_NODES_HAVE_SAME_PARENT    000603 constant        entry                    internal dcl 458 ref 988 1021 1128 1154
CHECK_STORAGE_REQUIREMENTS      000625 constant        entry                    internal dcl 472 ref 861 1482 1532 1570 1615
CHECK_VERSION                   000644 constant        entry                    internal dcl 486 ref 719
COMPRESS_LOW_BRANCH_ID          000746 constant        entry                    internal dcl 504 ref 1477 1564
CONVERT_LOW_BRANCH_TO_TARGET_KEY
                                001054 constant        entry                    internal dcl 544 ref 913 993 1057 1133
DELETE_ELEMENT                  001603 constant        entry                    internal dcl 644 ref 591
DELETE_KEY                      001240 constant        entry                    internal dcl 579 ref 442 530 812 1427
ERROR_RETURN                    000410 constant        entry                    internal dcl 363 ref 356 460 479 560 670 706 730 741
                                                                                  748 896 932 967 1071 1106 1183 1191 1243 1333 1497
                                                                                  1503 1582 1587 1679 1735 1751 1797
FIND_SPLIT_KEYS                 001324 constant        entry                    internal dcl 616 ref 555 1790
GET_ELEMENT                     001725 constant        entry                    internal dcl 677 ref 523 624 629 633 636 638 751
                                                                                  1329 1365 1656 1659 1667 1670 1704
INITIALIZE                      002107 constant        entry                    internal dcl 713 ref 338
INSERT_BRANCH_KEY_IN_SOURCE     002417 constant        entry                    internal dcl 782 ref 1480 1568
INSERT_KEY_AS_LOW_BRANCH_ID     002504 constant        entry                    internal dcl 801 ref 1472 1557
INSERT_LEAF_KEY_IN_SOURCE_CI    002550 constant        entry                    internal dcl 826 ref 1526 1610
INSERT_LEAF_KEY_IN_TARGET_CI    002667 constant        entry                    internal dcl 850 ref 1529 1613
MAIN_RETURN                     000362 constant        label                    dcl 359 ref 367
MODIFY_ELEMENT                  002715 constant        entry                    internal dcl 868 ref 785 832 1295 1297 1302 1304
MODIFY_HEADERS                  004142 constant        entry                    internal dcl 1288 ref 928 963 1067 1102 1488 1536
                                                                                  1573 1619
NEXT_ROTATION_INTO_EMPTY_BRANCH 003063 constant        entry                    internal dcl 909 ref 352
NEXT_ROTATION_INTO_EMPTY_LEAF   003176 constant        entry                    internal dcl 948 ref 345
NEXT_ROTATION_INTO_NONEMPTY_BRANCH
                                003300 constant        entry                    internal dcl 985 ref 354
NEXT_ROTATION_INTO_NONEMPTY_LEAF
                                003324 constant        entry                    internal dcl 1018 ref 347
PE_JOIN                         003732 constant        label                    dcl 1223 ref 1217
PREVIOUS_ROTATION_INTO_EMPTY_BRANCH
                                003341 constant        entry                    internal dcl 1044 ref 348
PREVIOUS_ROTATION_INTO_EMPTY_LEAF
                                003463 constant        entry                    internal dcl 1087 ref 340
PREVIOUS_ROTATION_INTO_NONEMPTY_BRANCH
                                003565 constant        entry                    internal dcl 1124 ref 351
PREVIOUS_ROTATION_INTO_NONEMPTY_LEAF
                                003604 constant        entry                    internal dcl 1151 ref 344
PUT_ELEMENT                     003720 constant        entry                    internal dcl 1201 ref 1270 1745
PUT_ELEMENT_TEST                003724 constant        entry                    internal dcl 1219 ref 419 1383
PUT_KEY                         004053 constant        entry                    internal dcl 1247 ref 567 787 834
REPLACE_NODE_BUFFERS            003621 constant        entry                    internal dcl 1174 ref 1508 1540 1592 1623
REPLACE_PARENT_KEY              004241 constant        entry                    internal dcl 1320 ref 935 970 1004 1030 1074 1109
                                                                                  1138 1163
ROTATE                          004366 constant        entry                    internal dcl 1342 ref 1469 1524 1554 1608
ROTATE_KEY_LOOP                 004372 constant        label                    dcl 1349
ROTATE_NEXT_BRANCH              005012 constant        entry                    internal dcl 1459 ref 917 996
ROTATE_NEXT_LEAF                005175 constant        entry                    internal dcl 1516 ref 952 1023
ROTATE_PREVIOUS_BRANCH          005255 constant        entry                    internal dcl 1548 ref 1060 1136
ROTATE_PREVIOUS_LEAF            005451 constant        entry                    internal dcl 1603 ref 1091 1156
SETUP_PARENT_KEY                006344 constant        entry                    internal dcl 1776 ref 921 1003 1596
SETUP_PARENT_KEY_FROM_LEAF_NODE 005544 constant        entry                    internal dcl 1647 ref 956 1029 1095 1162
SETUP_PARENT_NODE_FOR_INSERTION 006067 constant        entry                    internal dcl 1692 ref 926 961 1065 1100
SET_STRING_PTR                  005520 constant        entry                    internal dcl 1631 ref 436 837 1368 1371 1417 1423
                                                                                  1661 1673 1792 1793
debug_off                       000377 constant        entry                    external dcl 376
debug_on                        000364 constant        entry                    external dcl 371
im_rotate_insert                000256 constant        entry                    external dcl 182

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      7546        7632    7177        7556
Length     10214    7177        64         345     346           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
im_rotate_insert                   1474 external procedure  is an external procedure.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure im_rotate_insert.  
ADJUST_TARGET_ELEMENT_ID_FOR_PREVIOUS_INSERT
                                     67 internal procedure  is assigned to an entry variable.  
ADJUST_TARGET_ELEMENT_ID_FOR_NEXT_INSERT
                                     66 internal procedure  is assigned to an entry variable.  
ALLOCATE_KEY_IN_TARGET_CI               internal procedure  shares stack frame of external procedure im_rotate_insert.  
CHECK_NODES_HAVE_SAME_PARENT            internal procedure  shares stack frame of external procedure im_rotate_insert.  
CHECK_STORAGE_REQUIREMENTS              internal procedure  shares stack frame of external procedure im_rotate_insert.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure im_rotate_insert.  
COMPRESS_LOW_BRANCH_ID                  internal procedure  shares stack frame of external procedure im_rotate_insert.  
CONVERT_LOW_BRANCH_TO_TARGET_KEY
                                        internal procedure  shares stack frame of external procedure im_rotate_insert.  
DELETE_KEY                              internal procedure  shares stack frame of external procedure im_rotate_insert.  
FIND_SPLIT_KEYS                         internal procedure  shares stack frame of external procedure im_rotate_insert.  
DELETE_ELEMENT                          internal procedure  shares stack frame of external procedure im_rotate_insert.  
GET_ELEMENT                             internal procedure  shares stack frame of external procedure im_rotate_insert.  
INITIALIZE                              internal procedure  shares stack frame of external procedure im_rotate_insert.  
INSERT_BRANCH_KEY_IN_SOURCE             internal procedure  shares stack frame of external procedure im_rotate_insert.  
INSERT_KEY_AS_LOW_BRANCH_ID             internal procedure  shares stack frame of external procedure im_rotate_insert.  
INSERT_LEAF_KEY_IN_SOURCE_CI            internal procedure  shares stack frame of external procedure im_rotate_insert.  
INSERT_LEAF_KEY_IN_TARGET_CI            internal procedure  shares stack frame of external procedure im_rotate_insert.  
MODIFY_ELEMENT                          internal procedure  shares stack frame of external procedure im_rotate_insert.  
NEXT_ROTATION_INTO_EMPTY_BRANCH
                                        internal procedure  shares stack frame of external procedure im_rotate_insert.  
NEXT_ROTATION_INTO_EMPTY_LEAF           internal procedure  shares stack frame of external procedure im_rotate_insert.  
NEXT_ROTATION_INTO_NONEMPTY_BRANCH
                                        internal procedure  shares stack frame of external procedure im_rotate_insert.  
NEXT_ROTATION_INTO_NONEMPTY_LEAF
                                        internal procedure  shares stack frame of external procedure im_rotate_insert.  
PREVIOUS_ROTATION_INTO_EMPTY_BRANCH
                                        internal procedure  shares stack frame of external procedure im_rotate_insert.  
PREVIOUS_ROTATION_INTO_EMPTY_LEAF
                                        internal procedure  shares stack frame of external procedure im_rotate_insert.  
PREVIOUS_ROTATION_INTO_NONEMPTY_BRANCH
                                        internal procedure  shares stack frame of external procedure im_rotate_insert.  
PREVIOUS_ROTATION_INTO_NONEMPTY_LEAF
                                        internal procedure  shares stack frame of external procedure im_rotate_insert.  
REPLACE_NODE_BUFFERS                    internal procedure  shares stack frame of external procedure im_rotate_insert.  
PUT_ELEMENT                             internal procedure  shares stack frame of external procedure im_rotate_insert.  
PUT_KEY                                 internal procedure  shares stack frame of external procedure im_rotate_insert.  
MODIFY_HEADERS                          internal procedure  shares stack frame of external procedure im_rotate_insert.  
REPLACE_PARENT_KEY                      internal procedure  shares stack frame of external procedure im_rotate_insert.  
ROTATE                                  internal procedure  shares stack frame of external procedure im_rotate_insert.  
ROTATE_NEXT_BRANCH                      internal procedure  shares stack frame of external procedure im_rotate_insert.  
ROTATE_NEXT_LEAF                        internal procedure  shares stack frame of external procedure im_rotate_insert.  
ROTATE_PREVIOUS_BRANCH                  internal procedure  shares stack frame of external procedure im_rotate_insert.  
ROTATE_PREVIOUS_LEAF                    internal procedure  shares stack frame of external procedure im_rotate_insert.  
SET_STRING_PTR                          internal procedure  shares stack frame of external procedure im_rotate_insert.  
SETUP_PARENT_KEY_FROM_LEAF_NODE
                                        internal procedure  shares stack frame of external procedure im_rotate_insert.  
SETUP_PARENT_NODE_FOR_INSERTION
                                        internal procedure  shares stack frame of external procedure im_rotate_insert.  
SETUP_PARENT_KEY                        internal procedure  shares stack frame of external procedure im_rotate_insert.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 internal_debug              im_rotate_insert

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
im_rotate_insert         000100 local_branch_ci_header      im_rotate_insert
                         000106 new_ci                      im_rotate_insert
                         000107 temp_key_string_length      im_rotate_insert
                         000110 source_ci                   im_rotate_insert
                         000111 target_ci                   im_rotate_insert
                         000112 target_element_id_string    im_rotate_insert
                         000113 source_key_index            im_rotate_insert
                         000114 source_ci_header_ptr        im_rotate_insert
                         000116 target_ci_header_ptr        im_rotate_insert
                         000120 source_ci_ptr               im_rotate_insert
                         000122 target_ci_ptr               im_rotate_insert
                         000124 temp_key_string_ptr         im_rotate_insert
                         000126 old_temp_key_string_ptr     im_rotate_insert
                         000130 one_or_more_keys_were_rotated
                                                            im_rotate_insert
                         000131 target_ci_was_empty         im_rotate_insert
                         000132 high_key_string_ptr         im_rotate_insert
                         000134 low_key_string_ptr          im_rotate_insert
                         000136 current_key_buffer_ptr      im_rotate_insert
                         000140 old_key_buffer_ptr          im_rotate_insert
                         000142 source_ci_header_has_changed
                                                            im_rotate_insert
                         000143 source_ci_has_changed       im_rotate_insert
                         000144 target_ci_header_has_changed
                                                            im_rotate_insert
                         000145 target_ci_has_changed       im_rotate_insert
                         000146 update_target_branches      im_rotate_insert
                         000147 update_source_branches      im_rotate_insert
                         000150 there_is_more_room_in_target_ci
                                                            im_rotate_insert
                         000151 use_source_and_target_ci_buffers
                                                            im_rotate_insert
                         000152 original_target_index       im_rotate_insert
                         000153 low_index                   im_rotate_insert
                         000154 high_index                  im_rotate_insert
                         000155 rotate_idx                  im_rotate_insert
                         000156 local_target_ci_buffer      im_rotate_insert
                         000156 total_amount_of_storage_moved
                                                            im_rotate_insert
                         000156 local_key_buffer_1          im_rotate_insert
                         000156 target_header_buffer        im_rotate_insert
                         000156 local_source_ci_buffer      im_rotate_insert
                         000156 local_fsk_header_buffer     im_rotate_insert
                         000156 local_key_buffer_3          im_rotate_insert
                         000156 local_key_buffer_2          im_rotate_insert
                         000156 local_parent_key_buffer     im_rotate_insert
                         000157 additional_storage_required im_rotate_insert
                         000160 total_storage_available     im_rotate_insert
                         000161 amount_of_storage_to_be_moved
                                                            im_rotate_insert
                         000162 bk_string_length            im_rotate_insert
                         000164 branch_key_ptr              im_rotate_insert
                         000166 common_ci_header_ptr        im_rotate_insert
                         000170 leaf_ci_header_ptr          im_rotate_insert
                         000172 branch_ci_header_ptr        im_rotate_insert
                         000174 index_opening_info_ptr      im_rotate_insert
                         000254 akitc_element_allocated     ALLOCATE_KEY_IN_TARGET_CI
                         000306 clbi_element_id             COMPRESS_LOW_BRANCH_ID
                         000307 clbi_temp_key_string_length COMPRESS_LOW_BRANCH_ID
                         000316 clbttk_code                 CONVERT_LOW_BRANCH_TO_TARGET_KEY
                         000334 fsk_current_ci              FIND_SPLIT_KEYS
                         000344 fe_code                     DELETE_ELEMENT
                         000346 fe_ci_ptr                   DELETE_ELEMENT
                         000350 fe_element_id_string        DELETE_ELEMENT
                         000360 ge_code                     GET_ELEMENT
                         000362 ge_ci_ptr                   GET_ELEMENT
                         000364 ge_element_id_string        GET_ELEMENT
                         000374 i_code                      INITIALIZE
                         000426 ilktc_key_doesnt_fit        INSERT_LEAF_KEY_IN_TARGET_CI
                         000436 me_code                     MODIFY_ELEMENT
                         000440 me_ci_ptr                   MODIFY_ELEMENT
                         000442 me_element_id_string        MODIFY_ELEMENT
                         000452 nrieb_code                  NEXT_ROTATION_INTO_EMPTY_BRANCH
                         000462 nriel_code                  NEXT_ROTATION_INTO_EMPTY_LEAF
                         000506 prieb_code                  PREVIOUS_ROTATION_INTO_EMPTY_BRANCH
                         000516 priel_code                  PREVIOUS_ROTATION_INTO_EMPTY_LEAF
                         000526 prinb_code                  PREVIOUS_ROTATION_INTO_NONEMPTY_BRANCH
                         000544 pcb_code                    REPLACE_NODE_BUFFERS
                         000554 pe_code                     PUT_ELEMENT
                         000556 pe_ci_ptr                   PUT_ELEMENT
                         000560 pe_element_id_string        PUT_ELEMENT
                         000561 pe_report_allocated         PUT_ELEMENT
                         000570 pk_element_id_string        PUT_KEY
                         000606 rpk_code                    REPLACE_PARENT_KEY
                         000616 r_element_allocated         ROTATE
                         000626 rnb_code                    ROTATE_NEXT_BRANCH
                         000644 rpb_code                    ROTATE_PREVIOUS_BRANCH
                         000662 lk_string_length            SET_STRING_PTR
                         000663 bk_string_length            SET_STRING_PTR
                         000672 spkfln_code                 SETUP_PARENT_KEY_FROM_LEAF_NODE
                         000702 spnfi_code                  SETUP_PARENT_NODE_FOR_INSERTION
                         000703 spnfi_element_id_string     SETUP_PARENT_NODE_FOR_INSERTION
                         000712 spk_code                    SETUP_PARENT_KEY

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_bit_temp      call_ent_var        call_ext_out_desc   call_ext_out        return_mac
alloc_auto_adj      shorten_stack       ext_entry           ext_entry_desc      int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
collection_manager_$allocate_control_interval               collection_manager_$delete
collection_manager_$delete_from_ci_buffer                   collection_manager_$get       collection_manager_$modify
collection_manager_$modify_in_ci_buffer                     collection_manager_$put
collection_manager_$put_in_ci_buffer                        collection_manager_$replace_ci_buffer
collection_manager_$setup_ci_buffer                         collection_manager_$simple_get_from_ci_buffer
im_general_insert             im_init_branch_ci_header      im_make_parent_key            im_update_branches
im_update_branches$single     im_update_opening_info$root_id                              ioa_
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$long_element        error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    227 000142       236 000152       238 000174    6   46 000240       751 000242       182 000247       336 000272
    338 000274       340 000302       344 000316       345 000320       347 000325       348 000327       351 000340
    352 000342       354 000347       356 000350       359 000362       371 000363       373 000372       374 000375
    376 000376       378 000405       379 000407       363 000410       366 000412       367 000415       384 000416
    386 000424       388 000436       389 000440       394 000441       396 000447       398 000457       411 000460
    419 000462       421 000471       424 000474       425 000475       426 000477       429 000512       431 000516
    435 000522       436 000524       442 000542       447 000572       450 000575       451 000602       458 000603
    460 000604       463 000624       472 000625       479 000627       482 000640       484 000643       486 000644
    492 000655       497 000745       504 000746       520 000750       521 000754       523 000761       526 001012
    528 001013       530 001020       533 001042       536 001053       544 001054       555 001056       557 001106
    560 001160       563 001164       565 001173       567 001177       572 001230       573 001233       575 001237
    579 001240       591 001242       593 001253       594 001262       598 001301       604 001303       608 001323
    616 001324       623 001342       624 001347       627 001405       628 001413       629 001415       631 001453
    633 001454       635 001506       636 001511       638 001547       640 001602       644 001603       655 001605
    656 001611       658 001615       661 001635       663 001647       665 001651       667 001675       668 001676
    670 001720       673 001724       677 001725       690 001736       691 001743       693 001747       696 001767
    698 002001       700 002003       702 002033       703 002034       706 002102       709 002106       713 002107
    716 002111       718 002112       719 002116       721 002143       723 002147       725 002153       726 002155
    728 002157       730 002206       733 002212       734 002213       736 002215       738 002225       740 002232
    741 002234       744 002246       746 002250       748 002277       751 002303       753 002332       754 002334
    756 002343       758 002346       759 002351       761 002355       763 002366       765 002372       766 002374
    767 002375       768 002376       770 002377       771 002401       772 002403       774 002404       775 002407
    778 002416       782 002417       785 002420       787 002450       790 002502       792 002503       801 002504
    807 002506       808 002515       812 002517       817 002546       819 002547       826 002550       832 002552
    834 002602       837 002634       841 002665       843 002666       850 002667       856 002671       858 002672
    860 002676       861 002707       864 002714       868 002715       880 002726       881 002733       883 002737
    886 002757       888 002771       890 002773       893 003025       894 003026       896 003056       899 003062
    909 003063       911 003064       913 003065       917 003076       921 003077       923 003101       926 003105
    928 003107       930 003111       932 003162       934 003167       935 003170       937 003172       938 003175
    948 003176       950 003177       952 003200       956 003201       958 003203       961 003207       963 003211
    965 003213       967 003264       969 003271       970 003272       972 003274       974 003277       985 003300
    988 003301       993 003302       996 003307      1000 003310      1003 003314      1004 003316      1007 003320
   1008 003323      1018 003324      1021 003325      1023 003326      1026 003327      1029 003331      1030 003333
   1033 003335      1034 003340      1044 003341      1046 003342      1048 003343      1051 003347      1052 003351
   1053 003352      1055 003355      1056 003357      1057 003360      1060 003365      1062 003366      1065 003372
   1067 003374      1069 003376      1071 003447      1073 003454      1074 003455      1076 003457      1077 003462
   1087 003463      1089 003464      1091 003465      1095 003466      1097 003470      1100 003474      1102 003476
   1104 003500      1106 003551      1108 003556      1109 003557      1111 003561      1113 003564      1124 003565
   1126 003566      1128 003567      1133 003570      1136 003575      1138 003576      1140 003600      1141 003603
   1151 003604      1154 003605      1156 003606      1159 003607      1162 003611      1163 003613      1166 003615
   1168 003620      1174 003621      1178 003622      1181 003624      1183 003653      1186 003657      1189 003661
   1191 003710      1195 003714      1197 003717      1201 003720      1216 003722      1217 003723      1219 003724
   1221 003726      1222 003730      1223 003732      1226 003735      1230 003752      1232 003761      1234 003763
   1237 004011      1238 004012      1240 004036      1243 004050      1245 004052      1247 004053      1267 004055
   1268 004061      1270 004065      1272 004102      1273 004111      1276 004117      1278 004121      1282 004141
   1288 004142      1292 004144      1295 004147      1297 004163      1299 004177      1302 004200      1304 004214
   1308 004230      1309 004233      1311 004236      1313 004240      1320 004241      1329 004243      1331 004303
   1333 004360      1335 004365      1342 004366      1347 004370      1349 004372      1353 004407      1356 004416
   1358 004420      1362 004422      1363 004424      1365 004426      1367 004455      1368 004457      1371 004476
   1378 004510      1380 004521      1383 004527      1385 004531      1388 004534      1395 004536      1398 004551
   1401 004555      1405 004563      1406 004565      1407 004566      1409 004574      1411 004576      1413 004602
   1416 004605      1417 004607      1419 004621      1422 004622      1423 004624      1427 004636      1431 004642
   1434 004647      1435 004652      1438 004665      1440 004673      1443 004676      1445 004704      1453 005011
   1459 005012      1463 005013      1464 005017      1466 005027      1469 005033      1472 005035      1477 005063
   1480 005071      1482 005076      1488 005100      1492 005102      1495 005105      1497 005135      1501 005141
   1503 005167      1508 005173      1510 005174      1516 005175      1519 005176      1520 005202      1522 005212
   1524 005216      1526 005220      1529 005237      1532 005247      1536 005251      1540 005253      1542 005254
   1548 005255      1552 005256      1553 005262      1554 005267      1557 005271      1561 005305      1564 005310
   1566 005312      1568 005320      1570 005325      1573 005327      1577 005331      1580 005363      1582 005411
   1585 005415      1587 005441      1592 005445      1596 005446      1597 005450      1603 005451      1605 005452
   1606 005456      1608 005463      1610 005465      1613 005502      1615 005512      1619 005514      1623 005516
   1625 005517      1631 005520      1637 005522      1638 005524      1640 005536      1643 005543      1647 005544
   1653 005546      1656 005552      1659 005612      1661 005646      1663 005662      1664 005663      1667 005667
   1670 005727      1673 005763      1676 005777      1679 006045      1682 006051      1684 006062      1686 006066
   1692 006067      1701 006071      1704 006077      1707 006135      1710 006141      1711 006143      1714 006144
   1718 006150      1720 006161      1721 006163      1724 006164      1725 006166      1727 006176      1729 006203
   1732 006204      1733 006215      1735 006233      1738 006237      1740 006246      1742 006250      1743 006254
   1744 006257      1745 006261      1750 006270      1751 006303      1757 006307      1759 006311      1761 006321
   1763 006324      1765 006326      1767 006335      1768 006340      1770 006343      1776 006344      1782 006346
   1785 006364      1786 006366      1787 006374      1790 006375      1792 006423      1793 006431      1794 006437
   1797 006505      1800 006511      1801 006517


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
