	COMPILATION LISTING OF SEGMENT interpret_op_ptr_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/05/86  1031.3 mst Wed
	    Options: optimize map

        1 /* ******************************************************
        2*   *                                                    *
        3*   *                                                    *
        4*   * Copyright (c) 1972 by Massachusetts Institute of   *
        5*   * Technology and Honeywell Information Systems, Inc. *
        6*   *                                                    *
        7*   *                                                    *
        8*   ****************************************************** */
        9 
       10 /* format: style3,^indnoniterdo */
       11 interpret_op_ptr_:
       12      proc (mcptr, a_sp, callp, op_name, frame_flag);
       13 
       14 /* This procedure  checks to see if p points to pl1_operators_ or pl1_operators.
       15*   If it does, the procedure tries to obtain the location of the transfer to the
       16*   operator segment.  An effort is made to determine whether the given stack
       17*   frame was in use at the time of the transfer.
       18*   Coded by M. Weaver 26 June 1973 */
       19 /* modified by M. Weaver 6 October 1973  to make use of new operator segdefs */
       20 /* modified by M. Weaver 1/17/74  to handle operator call outs */
       21 /* modified by J.M. Broughton on 26 June 1975 to handle trace operators and calls through entry vars */
       22 /* modified by JMB on 8 July 1975 to handle basic operators */
       23 /* Modified by R.J.C. Kissel in June 1977 to handle COBOL operators. */
       24 /* Modified by S. Webber Oct 1977 to fix bugs in handling of cobol operators */
       25 /* Modified by P. Krupp November 1977 to handle the ALM entry operator used by trace */
       26 /* Modified by M. Weaver July 1981 to handle algol68_operators_ and remove code for pl1_operators (version 1) */
       27 /* Modified by M. Weaver January 1982 to not activate linkage sections of non-pl1 operators */
       28 /* Modified by M. Weaver October 1983 to handle pascal_operators_ and check for null condition pointer */
       29 /* Changed to view stack_frame.return_ptr through RETURN_PTR_MASK 03/07/84 S. Herbst */
       30 
       31 
       32 declare	(p, a_sp, mcptr, callp, rsp, return_ptr_copy)
       33 			ptr;
       34 declare	(p1, p2, p3, p4, p5)
       35 			ptr;
       36 declare	cobol_operators_ptr ptr;
       37 declare	algol68_operators_ptr
       38 			ptr;
       39 declare	basic_operators_ptr ptr;
       40 declare 	pascal_operators_ptr ptr;
       41 
       42 declare	op_name		char (32) aligned;
       43 
       44 
       45 declare	frame_flag	bit (1) aligned;
       46 declare	opsegno		bit (18) aligned;
       47 declare	sx		(0:7) bit (18) unaligned based;
       48 declare	have_made_basic_search
       49 			bit (1) aligned;
       50 declare	real_condition_segno
       51 			bit (18) aligned;
       52 
       53 declare	(addr, addrel, baseno, baseptr, bin, null, ptr, rel, unspec)
       54 			builtin;
       55 
       56 declare	1 tra_inst	aligned based,
       57 	  2 addr		bit (18) unaligned,
       58 	  2 opcode	bit (10) unaligned,
       59 	  2 junk		bit (8) unaligned;
       60 
       61 declare	hcs_$make_ptr	entry (ptr, char (*), char (*), ptr, fixed bin (35));
       62 
       63 declare	offset		fixed bin (18);
       64 declare	code		fixed bin (35);
       65 declare	(
       66 	pl1_operators_$entry_operators,
       67 	pl1_operators_$entry_operators_end,
       68 	pl1_operators_$trace_entry_operators,
       69 	pl1_operators_$trace_entry_operators_end,
       70 	pl1_operators_$math_routines_,
       71 	pl1_operators_$math_routines_end_,
       72 	pl1_operators_$alm_operators_begin,
       73 	pl1_operators_$alm_operators_end,
       74 	pl1_operators_$alm_call,
       75 	pl1_operators_$alm_push,
       76 	pl1_operators_$alm_return,
       77 	pl1_operators_$forward_call,
       78 	pl1_operators_$var_call,
       79 	pl1_operators_$alm_trace_operators_begin,
       80 	pl1_operators_$alm_trace_operators_end
       81 	)		fixed bin (35) external;
       82 
       83 declare	(
       84 	basic_operators_$end_basic_operators,
       85 	basic_operators_$enter_proc,
       86 	basic_operators_$end_entry_ops,
       87 	basic_operators_$call_op_begin,
       88 	basic_operators_$new_frame,
       89 	basic_operators_$call_op_end,
       90 	cobol_operators_$cobol_operators_,
       91 	cobol_operators_$cobol_operators_end,
       92 	algol68_operators_$algol68_operators_,
       93 	algol68_operators_$end_operators,
       94 	algol68_operators_$entry_operators_begin,
       95 	algol68_operators_$entry_operators_end,
       96 	pascal_operators_$pascal_operators_,
       97 	pascal_operators_$pascal_operators_end
       98 	)		fixed bin (35) external;
       99 
      100 dcl	1 cobol_stack_frame aligned based (sp),
      101 	  2 pad1		(1:64) bit (36),
      102 	  2 return_to_main_ptr
      103 			ptr;			/* actual cobol return pointer */
      104 
  1     1 /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
  1     2 
  1     3 /* format: off */
  1     4 
  1     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
  1     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
  1     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
  1     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
  1     9 
  1    10 
  1    11 /****^  HISTORY COMMENTS:
  1    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
  1    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
  1    14*     Modified to add constants for the translator_id field in the stack_frame
  1    15*     structure.
  1    16*                                                   END HISTORY COMMENTS */
  1    17 
  1    18 
  1    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
  1    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
  1    21 						/* with indicators (nonzero for Fortran hexfp caller) */
  1    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
  1    23 
  1    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
  1    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
  1    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
  1    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
  1    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
  1    29 
  1    30 
  1    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
  1    32 
  1    33 dcl  stack_frame_min_length fixed bin static init(48);
  1    34 
  1    35 
  1    36 dcl 1 stack_frame based(sp) aligned,
  1    37     2 pointer_registers(0 : 7) ptr,
  1    38     2 prev_sp pointer,
  1    39     2 next_sp pointer,
  1    40     2 return_ptr pointer,
  1    41     2 entry_ptr pointer,
  1    42     2 operator_and_lp_ptr ptr,			/* serves as both */
  1    43     2 arg_ptr pointer,
  1    44     2 static_ptr ptr unaligned,
  1    45     2 support_ptr ptr unal, /* only used by fortran I/O */
  1    46     2 on_unit_relp1 bit(18) unaligned,
  1    47     2 on_unit_relp2 bit(18) unaligned,
  1    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
  1    49*						   0 => PL/I version II
  1    50*						   1 => ALM
  1    51*						   2 => PL/I version I   
  1    52*						   3 => signal caller frame
  1    53*						   4 => signaller frame */
  1    54     2 operator_return_offset bit(18) unaligned,
  1    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
  1    56     2 a bit(36),					/* accumulator */
  1    57     2 q bit(36),					/* q-register */
  1    58     2 e bit(36),					/* exponent */
  1    59     2 timer bit(27) unaligned,				/* timer */
  1    60     2 pad bit(6) unaligned,
  1    61     2 ring_alarm_reg bit(3) unaligned;
  1    62 
  1    63 
  1    64 dcl 1 stack_frame_flags based(sp) aligned,
  1    65     2 pad(0 : 7) bit(72),				/* skip over prs */
  1    66     2 xx0 bit(22) unal,
  1    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
  1    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
  1    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
  1    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
  1    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
  1    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
  1    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
  1    74     2 condition bit(1) unal,				/* on if condition established in this frame */
  1    75     2 xx0a bit(6) unal,
  1    76     2 xx1 fixed bin,
  1    77     2 xx2 fixed bin,
  1    78     2 xx3 bit(25) unal,
  1    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
  1    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
  1    81     2 xx3a bit(9) unaligned,
  1    82     2 xx4(9) bit(72) aligned,
  1    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
  1    84*						*  operator puts a pointer to the base of
  1    85*						*  the calling procedure here. (text base ptr)  */
  1    86     2 xx5 bit(72) aligned,
  1    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
  1    88 
  1    89 /* format: on */
  1    90 
  1    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
      105 
      106 
      107 /*  */
  2     1 /*  */
  2     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
  2     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
  2     4 /* Modified 07/07/76 by Morris for fault register data */
  2     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
  2     6 /* Modified '82 to make values constant */
  2     7 
  2     8 /* words 0-15 pointer registers */
  2     9 
  2    10 dcl  mcp ptr;
  2    11 
  2    12 dcl 1 mc based (mcp) aligned,
  2    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
  2    14    (2 regs,					/* registers */
  2    15       3 x (0:7) bit (18),				/* index registers */
  2    16       3 a bit (36),					/* accumulator */
  2    17       3 q bit (36),					/* q-register */
  2    18       3 e bit (8),					/* exponent */
  2    19       3 pad1 bit (28),
  2    20       3 t bit (27),					/* timer register */
  2    21       3 pad2 bit (6),
  2    22       3 ralr bit (3),				/* ring alarm register */
  2    23 
  2    24     2 scu (0:7) bit (36),
  2    25 
  2    26     2 mask bit (72),				/* mem controller mask at time of fault */
  2    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
  2    28     2 errcode fixed bin (35),				/* fault handler's error code */
  2    29     2 fim_temp,
  2    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
  2    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
  2    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
  2    33     2 fault_reg bit (36),				/* fault register */
  2    34     2 pad2 bit (1),
  2    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
  2    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
  2    37     2 fault_time bit (54),				/* time of fault */
  2    38 
  2    39     2 eis_info (0:7) bit (36)) unaligned;
  2    40 
  2    41 
  2    42 dcl (apx fixed bin init (0),
  2    43      abx fixed bin init (1),
  2    44      bpx fixed bin init (2),
  2    45      bbx fixed bin init (3),
  2    46      lpx fixed bin init (4),
  2    47      lbx fixed bin init (5),
  2    48      spx fixed bin init (6),
  2    49      sbx fixed bin init (7)) internal static options (constant);
  2    50 
  2    51 
  2    52 
  2    53 
  2    54 dcl  scup ptr;
  2    55 
  2    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
  2    57 
  2    58 
  2    59 /*	WORD (0)		*/
  2    60 
  2    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
  2    62       3 prr bit (3),				/* procedure ring register */
  2    63       3 psr bit (15),				/* procedure segment register */
  2    64       3 p bit (1),					/* procedure privileged bit */
  2    65 
  2    66     2 apu,					/* APPENDING UNIT STATUS */
  2    67       3 xsf bit (1),				/* ext seg flag - IT modification */
  2    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
  2    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
  2    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
  2    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
  2    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
  2    73       3 dsptw bit (1),				/* Fetch of DSPTW */
  2    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
  2    75       3 sdwp bit (1),				/* Fetch of SDW paged */
  2    76       3 ptw bit (1),				/* Fetch of PTW */
  2    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
  2    78       3 fap bit (1),				/* Fetch of final address paged */
  2    79       3 fanp bit (1),				/* Fetch of final address non-paged */
  2    80       3 fabs bit (1),				/* Fetch of final address absolute */
  2    81 
  2    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
  2    83 
  2    84 
  2    85 /*	WORD (1)		*/
  2    86 
  2    87     2 fd,						/* FAULT  DATA */
  2    88       3 iro bit (1),				/* illegal ring order */
  2    89       3 oeb bit (1),				/* out of execute bracket */
  2    90       3 e_off bit (1),				/* no execute */
  2    91       3 orb bit (1),				/* out of read bracket */
  2    92       3 r_off bit (1),				/* no read */
  2    93       3 owb bit (1),				/* out of write bracket */
  2    94       3 w_off bit (1),				/* no write */
  2    95       3 no_ga bit (1),				/* not a gate */
  2    96       3 ocb bit (1),				/* out of call bracket */
  2    97       3 ocall bit (1),				/* outward call */
  2    98       3 boc bit (1),				/* bad outward call */
  2    99       3 inret bit (1),				/* inward return */
  2   100       3 crt bit (1),				/* cross ring transfer */
  2   101       3 ralr bit (1),				/* ring alarm register */
  2   102       3 am_er bit (1),				/* associative memory fault */
  2   103       3 oosb bit (1),				/* out of segment bounds */
  2   104       3 paru bit (1),				/* processor parity upper */
  2   105       3 parl bit (1),				/* processor parity lower */
  2   106       3 onc_1 bit (1),				/* op not complete type 1 */
  2   107       3 onc_2 bit (1),				/* op not complete type 2 */
  2   108 
  2   109     2 port_stat,					/* PORT  STATUS */
  2   110       3 ial bit (4),				/* illegal action lines */
  2   111       3 iac bit (3),				/* illegal action channel */
  2   112       3 con_chan bit (3),				/* connect channel */
  2   113 
  2   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
  2   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
  2   116 
  2   117 
  2   118 /*	WORD (2)		*/
  2   119 
  2   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
  2   121       3 trr bit (3),				/* temporary ring register */
  2   122       3 tsr bit (15),				/* temporary segment register */
  2   123 
  2   124     2 pad2 bit (9),
  2   125 
  2   126     2 cpu_no bit (3),				/* CPU number */
  2   127 
  2   128     2 delta bit (6),				/* tally modification DELTA */
  2   129 
  2   130 
  2   131 /*	WORD (3)		*/
  2   132 
  2   133     2 word3 bit (18),
  2   134 
  2   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
  2   136       3 tsna,					/* Word 1 status */
  2   137         4 prn bit (3),				/* Word 1  PR  number */
  2   138         4 prv bit (1),				/* Word 1  PR  valid bit */
  2   139       3 tsnb,					/* Word 2  status */
  2   140         4 prn bit (3),				/* Word 2  PR  number */
  2   141         4 prv bit (1),				/* Word 2  PR  valid bit */
  2   142       3 tsnc,					/* Word 3  status */
  2   143         4 prn bit (3),				/* Word 3  PR  number */
  2   144         4 prv bit (1),				/* Word 3  PR  valid bit */
  2   145 
  2   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
  2   147 
  2   148 
  2   149 /* 	WORD (4)		*/
  2   150 
  2   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
  2   152 
  2   153     2 ir,						/* INDICATOR  REGISTERS */
  2   154       3 zero bit (1),				/* zero indicator */
  2   155       3 neg bit (1),				/* negative indicator */
  2   156       3 carry bit (1),				/* carryry indicator */
  2   157       3 ovfl bit (1),				/* overflow indicator */
  2   158       3 eovf bit (1),				/* eponent overflow */
  2   159       3 eufl bit (1),				/* exponent underflow */
  2   160       3 oflm bit (1),				/* overflow mask */
  2   161       3 tro bit (1),				/* tally runout */
  2   162       3 par bit (1),				/* parity error */
  2   163       3 parm bit (1),				/* parity mask */
  2   164       3 bm bit (1),					/* ^bar mode */
  2   165       3 tru bit (1),				/* truncation mode */
  2   166       3 mif bit (1),				/* multi-word instruction mode */
  2   167       3 abs bit (1),				/* absolute mode */
  2   168       3 hex bit (1),				/* hexadecimal exponent mode */
  2   169       3 pad bit (3),
  2   170 
  2   171 
  2   172 /*	WORD (5)		*/
  2   173 
  2   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
  2   175 
  2   176     2 cu,						/* CONTROL UNIT STATUS */
  2   177       3 rf bit (1),					/* on first cycle of repeat instr */
  2   178       3 rpt bit (1),				/* repeat instruction */
  2   179       3 rd bit (1),					/* repeat double instruction */
  2   180       3 rl bit (1),					/* repeat link instruciton */
  2   181       3 pot bit (1),				/* IT  modification */
  2   182       3 pon bit (1),				/* return type instruction */
  2   183       3 xde bit (1),				/* XDE from Even location */
  2   184       3 xdo bit (1),				/* XDE from Odd  location */
  2   185       3 poa bit (1),				/* operation preparation */
  2   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
  2   187       3 its bit (1),				/* ITS modification */
  2   188       3 if bit (1),					/* fault occured during instruction fetch */
  2   189 
  2   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
  2   191 
  2   192 
  2   193 /*	WORDS (6,7)	*/
  2   194 
  2   195     2 even_inst bit (36),				/* even instruction of faulting pair */
  2   196 
  2   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
  2   198 
  2   199 
  2   200 
  2   201 
  2   202 
  2   203 
  2   204 /*	ALTERNATE   SCU  DECLARATION		*/
  2   205 
  2   206 
  2   207 dcl 1 scux based (scup) aligned,
  2   208 
  2   209    (2 pad0 bit (36),
  2   210 
  2   211     2 fd,						/* GROUP II  FAULT DATA */
  2   212       3 isn bit (1),				/* illegal segment number */
  2   213       3 ioc bit (1),				/* illegal op  code  */
  2   214       3 ia_am bit (1),				/* illegal address - modifier */
  2   215       3 isp bit (1),				/* illegal slave  procedure */
  2   216       3 ipr bit (1),				/* illegal procedure */
  2   217       3 nea bit (1),				/* non existent address */
  2   218       3 oobb bit (1),				/* out of bounds */
  2   219       3 pad bit (29),
  2   220 
  2   221     2 pad2 bit (36),
  2   222 
  2   223     2 pad3a bit (18),
  2   224 
  2   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
  2   226       3 prn bit (3),				/* PR  number */
  2   227       3 prv bit (1),				/* PR  valid bit */
  2   228 
  2   229     2 pad3b bit (6)) unaligned,
  2   230 
  2   231     2 pad45 (0:1) bit (36),
  2   232 
  2   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
  2   234 
  2   235 
  2   236 
  2   237 /*  END INCLUDE FILE   mc.incl.pl1 */
      108 
      109 
  3     1 dcl	1 basic_operators_frame	aligned based(bo_pt),
  3     2 	2 pr(0:7)			ptr,
  3     3 	2 prev_sp			ptr,
  3     4 	2 next_sp			ptr,
  3     5 	2 return_ptr		ptr,
  3     6 	2 entry_ptr		ptr,
  3     7 	2 operator_and_lp_ptr	ptr,
  3     8 	2 arglist_ptr		ptr,
  3     9 	2 reserved		bit(72),
  3    10 	2 on_unit_relp(2)		bit(18) unaligned,
  3    11 	2 translator_id		bit(18) unaligned,
  3    12 	2 operator_return_offset	bit(18) unaligned,
  3    13 	2 regs,
  3    14 	  3 xr(0:7)		bit(18) unaligned,
  3    15 	  3 (a_reg,q_reg)		fixed bin(35),
  3    16 	  3 rest_of_regs(2)		bit(36) aligned,
  3    17 	2 print_using_pt		ptr,		/* N.B. this holds return loc, pos in struc must be the same
  3    18*						   as for ep basic as debuggers depend on this */
  3    19 	2 abort_label		label,
  3    20 	2 conversion_label		label,
  3    21 	2 size_label		label,
  3    22 	2 on_units(2),
  3    23 	  3 name			ptr,
  3    24 	  3 body			ptr,
  3    25 	  3 size			fixed bin,
  3    26 	  3 next			fixed bin,
  3    27 	2 program_header		ptr,
  3    28 	2 text_base_ptr		ptr,
  3    29 	2 string_segment		ptr,
  3    30 	2 fcb_pt			ptr,
  3    31 	2 arglist1(2)		ptr,
  3    32 	2 runtime_arglist(2)	ptr,
  3    33 	2 cpu_start		fixed bin(71),
  3    34 	2 determinant		float bin(63),
  3    35 	2 fcb(0:16)		ptr unaligned,
  3    36 	2 precision_lng 		fixed bin(17) unaligned,
  3    37 	2 file_number		fixed bin(17) unaligned,
  3    38 	2 (error_number,pdl)	fixed bin,
  3    39 	2 program_header_offset	bit(18) aligned,
  3    40 	2 numeric_data		unaligned,
  3    41 	  3 (finish,start)		fixed bin(17),
  3    42 	2 string_data		unaligned,
  3    43 	  3 (finish,start)		fixed bin(17),
  3    44 	2 random			fixed bin,
  3    45 	2 first_frame		bit(18),
  3    46 	2 last_frame		bit(18),
  3    47 	2 next_frame		bit(18),
  3    48 	2 number_read		fixed bin,
  3    49 	2 (pu_pos,pu_length)	fixed bin,
  3    50 	2 definitions		ptr unal,
  3    51 	2 fn_temp1		fixed bin,
  3    52 	2 fn_temp2		fixed bin,
  3    53 	2 entryname		ptr unal,
  3    54 	2 flags			unaligned,
  3    55 	  3 non_basic_caller	bit(1),
  3    56 	  3 main_program		bit(1),
  3    57 	  3 quits_disabled		bit(1),
  3    58 	  3 had_quit		bit(1),
  3    59 	  3 ignore_handler		bit(1),
  3    60 	  3 filler		bit(13),
  3    61 	2 number_length		fixed bin(17) unaligned,
  3    62 	2 string_value		bit(36),
  3    63 	2 temporaries(3)		aligned,
  3    64 	  3 temp			float bin,
  3    65 	  3 tpad			bit(36),
  3    66 	2 arg(1)			ptr;
  3    67 
  3    68 dcl	1 d_basic_operators_frame	aligned based(bo_pt),
  3    69 	2 x_pr(0:7)			ptr,
  3    70 	2 x_prev_sp			ptr,
  3    71 	2 x_next_sp			ptr,
  3    72 	2 x_return_ptr		ptr,
  3    73 	2 x_entry_ptr		ptr,
  3    74 	2 x_operator_and_lp_ptr	ptr,
  3    75 	2 x_arglist_ptr		ptr,
  3    76 	2 x_reserved		bit(72),
  3    77 	2 x_on_unit_relp(2)		bit(18) unaligned,
  3    78 	2 x_translator_id		bit(18) unaligned,
  3    79 	2 x_operator_return_offset	bit(18) unaligned,
  3    80 	2 x_regs,
  3    81 	  3 x_xr(0:7)		bit(18) unaligned,
  3    82 	  3 (x_a_reg,x_q_reg)	fixed bin,
  3    83 	  3 x_rest_of_regs(2)		bit(36) aligned,
  3    84 	2 x_print_using_pt		ptr,
  3    85 	2 x_abort_label		label,
  3    86 	2 x_conversion_label		label,
  3    87 	2 x_size_label		label,
  3    88 	2 x_on_units(2),
  3    89 	  3 x_name			ptr,
  3    90 	  3 x_body			ptr,
  3    91 	  3 x_size			fixed bin,
  3    92 	  3 x_next			fixed bin,
  3    93 	2 x_program_header		ptr,
  3    94 	2 x_text_base_ptr		ptr,
  3    95 	2 x_string_segment		ptr,
  3    96 	2 x_fcb_pt			ptr,
  3    97 	2 x_arglist1(2)		ptr,
  3    98 	2 x_runtime_arglist(2)	ptr,
  3    99 	2 x_cpu_start		fixed bin(71),
  3   100 	2 x_determinant		float bin(63),
  3   101 	2 x_fcb(0:16)		ptr unaligned,
  3   102 	2 x_precision_lng 		fixed bin(17) unaligned,
  3   103 	2 x_file_number		fixed bin(17) unaligned,
  3   104 	2 x_error_number		fixed bin,
  3   105 	2 x_pdl			fixed bin,
  3   106 	2 x_program_header_offset	bit(18) aligned,
  3   107 	2 x_numeric_data		unaligned,
  3   108 	  3 (x_finish,x_start)	fixed bin(17),
  3   109 	2 x_string_data		unaligned,
  3   110 	  3 (x_finish,x_start)	fixed bin(17),
  3   111 	2 x_random			fixed bin,
  3   112 	2 x_first_frame		bit(18),
  3   113 	2 x_last_frame		bit(18),
  3   114 	2 x_next_frame		bit(18),
  3   115 	2 x_number_read		fixed bin,
  3   116 	2 (x_pu_pos,x_pu_length)	fixed bin,
  3   117 	2 x_definitions		ptr unal,
  3   118 	2 x_fn_temp1		fixed bin,
  3   119 	2 x_fn_temp2		fixed bin,
  3   120 	2 x_entryname		ptr unal,
  3   121 	2 x_flags			unaligned,
  3   122 	  3 x_non_basic_caller	bit(1),
  3   123 	  3 x_main_program		bit(1),
  3   124 	  3 x_quits_disabled		bit(1),
  3   125 	  3 x_had_quit		bit(1),
  3   126 	  3 x_filler		bit(14),
  3   127 	2 x_number_length		fixed bin(17) unaligned,
  3   128 	2 x_string_value		bit(36),
  3   129 	2 d_temp(3)		float bin(63),
  3   130 	2 x_arg(1)			ptr;
      110 
      111 
      112 declare	bo_pt		pointer;
      113 
      114 
      115 
      116 /*  */
      117 	sp = a_sp;				/* initialize */
      118 	callp = null;
      119 	op_name = " ";
      120 	frame_flag = "1"b;
      121 	have_made_basic_search = "0"b;
      122 
      123 /* be sure that given environment is usable */
      124 
      125 	if mcptr ^= null
      126 	then do;					/* had a fault */
      127 	     scup = addr (mcptr -> mc.scu (0));
      128 	     p = ptr (baseptr (bin (bin (scup -> scu.ppr.psr, 15), 18)), scup -> scu.ilc);
      129 	end;
      130 	else if sp ^= null
      131 	then unspec (p) = unspec (sp -> stack_frame.return_ptr) & RETURN_PTR_MASK;
      132 	else return;				/* have no environment to use */
      133 
      134 	real_condition_segno = baseno (p);
      135 	if real_condition_segno = baseno (null)		/* this is safer than p = null */
      136 	then return;				/* believe it or not, this does sometimes happen */
      137 
      138 /* see if we have pl1_operators_ */
      139 
      140 	if real_condition_segno = baseno (addr (pl1_operators_$entry_operators))
      141 	then do;
      142 
      143 /* Assume all ops are bound together either
      144*   with no other segs or at beginning
      145*   of bound segment */
      146 
      147 	     opsegno = baseno (addr (pl1_operators_$entry_operators));
      148 	     p1 = addr (pl1_operators_$math_routines_end_);
      149 						/* see if we can tell  where end of ops is */
      150 	     if bin (rel (p), 18) > bin (rel (p1), 18)
      151 	     then return;
      152 
      153 	     op_name = "pl1_operators_";
      154 
      155 	     if mcptr = null
      156 	     then do;				/* assume p is ret_ptr */
      157 		if sp -> stack_frame.entry_ptr ^= null	/* should be OK, but just in case.. */
      158 		then if baseno (sp -> stack_frame.entry_ptr) ^= opsegno
      159 		     then do;			/* see if frame belongs to an op */
      160 			if sp -> stack_frame.operator_return_offset ^= "0"b
      161 			then callp = ptr (sp -> stack_frame.entry_ptr, sp -> stack_frame.operator_return_offset);
      162 			else callp = ptr (sp -> stack_frame.entry_ptr, addrel (sp, 8) -> sx (0));
      163 			if rel (callp) ^= "0"b
      164 			then callp = addrel (callp, -1);
      165 						/* never return neg offset */
      166 		     end;
      167 		return;				/* in any case, that's all we can do */
      168 	     end;
      169 
      170 /* have machine conditions, assume p is ppr */
      171 
      172 	     offset = bin (rel (p), 18);		/* use to find out what kind of operator we're in */
      173 
      174 /* see if fault occurred in an entry operator */
      175 
      176 	     if offset >= bin (addr (pl1_operators_$entry_operators) -> tra_inst.addr, 18)
      177 	     then do;				/* have entry operator */
      178 		p1 = addr (pl1_operators_$entry_operators_end);
      179 		if offset <= bin (rel (p1), 18)
      180 		then do;
      181 		     callp = addrel (mcptr -> mc.prs (2), -1);
      182 						/* transfer was by tsp2 inst */
      183 		     frame_flag = "0"b;		/* we were creating new frame, probably not completed */
      184 		     return;
      185 		end;
      186 	     end;
      187 
      188 	     if offset >= bin (addr (pl1_operators_$trace_entry_operators) -> tra_inst.addr, 18)
      189 	     then do;
      190 		p1 = addr (pl1_operators_$trace_entry_operators_end);
      191 		if offset <= bin (rel (p1), 18)
      192 		then do;
      193 		     callp = addrel (mcptr -> mc.prs (2), -1);
      194 		     frame_flag = "0"b;
      195 		     return;
      196 		end;
      197 	     end;
      198 
      199 /* check to see if fault frame is same as given frame;
      200*   in any case, use fault frame */
      201 
      202 	     rsp = mcptr -> mc.prs (6);		/* pick up sp from mc */
      203 	     if sp ^= null
      204 	     then rsp = ptr (sp, rel (rsp));		/* in case we are working on dead stack */
      205 	     if rsp ^= sp
      206 	     then frame_flag = "0"b;			/* different frame */
      207 
      208 /* see if we were in an alm operator */
      209 
      210 	     p1 = addr (pl1_operators_$alm_operators_begin);
      211 	     p2 = addr (pl1_operators_$alm_operators_end);
      212 	     if (offset >= bin (rel (p1), 18)) & (offset <= bin (rel (p2), 18))
      213 	     then do;				/* find out which alm operator */
      214 		p3 = addr (pl1_operators_$alm_call);
      215 		p4 = addr (pl1_operators_$alm_push);
      216 		if (offset >= bin (rel (p3), 18)) & (offset < bin (rel (p4), 18))
      217 		then do;				/* alm call */
      218 		     callp = addrel (mcptr -> mc.prs (4), -1);
      219 		     return;
      220 		end;
      221 		p5 = addr (pl1_operators_$alm_return);
      222 		if (offset >= bin (rel (p4), 18)) & (offset < bin (rel (p5), 18))
      223 		then do;				/* alm push or entry */
      224 		     callp = addrel (mcptr -> mc.prs (2), -1);
      225 		     frame_flag = "0"b;		/* were working on new frame */
      226 		     return;
      227 		end;
      228 		else return;			/* must have been in a return op; can do nothing */
      229 	     end;
      230 
      231 /* see if we were in the alm trace entry operator */
      232 
      233 	     p1 = addr (pl1_operators_$alm_trace_operators_begin);
      234 	     p2 = addr (pl1_operators_$alm_trace_operators_end);
      235 	     if (offset >= bin (rel (p1), 18)) & (offset <= bin (rel (p2), 18))
      236 	     then do;
      237 		callp = addrel (mcptr -> mc.prs (2), -1);
      238 		frame_flag = "0"b;			/* were working on a new frame */
      239 		return;
      240 	     end;
      241 
      242 /* see if fault occurred in math routines */
      243 
      244 	     p1 = addr (pl1_operators_$math_routines_);
      245 	     if offset > bin (rel (p1), 18)
      246 	     then do;
      247 		callp = addrel (mcptr -> mc.prs (3), -1);
      248 		if baseno (callp) = basic_operators_segno ()
      249 		then do;				/* basic programs transfer to math operators from basic operators
      250*						   and store return_pt in temp3 when they do */
      251 
      252 		     unspec (p2) = unspec (sp -> d_basic_operators_frame.d_temp (3));
      253 		     callp = addrel (p2, -1);
      254 		end;
      255 		return;
      256 	     end;
      257 
      258 /* see if we were in process of making a call */
      259 
      260 
      261 check_call:
      262 	     unspec (return_ptr_copy) = unspec (rsp -> stack_frame.return_ptr) & RETURN_PTR_MASK;
      263 
      264 	     if p = addr (pl1_operators_$forward_call)
      265 	     then callp = addrel (return_ptr_copy, -1);
      266 						/* were making a call */
      267 
      268 	     else if p = addr (pl1_operators_$var_call)
      269 	     then callp = addrel (return_ptr_copy, -1);
      270 						/* calling int proc or entry variable */
      271 
      272 	     else if baseno (rsp -> stack_frame.entry_ptr) = opsegno
      273 	     then ;				/* op had own frame */
      274 
      275 /* call offset was stored either in x0 or at sp|37;
      276*   can assume entry_ptr is good */
      277 
      278 	     else if rsp -> stack_frame.operator_return_offset
      279 	     then callp = ptr (rsp -> stack_frame.entry_ptr, bin (rsp -> stack_frame.operator_return_offset, 18) - 1);
      280 
      281 	     else callp = ptr (rsp -> stack_frame.entry_ptr, bin (mcptr -> mc.regs.x (0), 18) - 1);
      282 
      283 	     return;
      284 
      285 	end;					/* done with pl1_operators_ */
      286 
      287 
      288 	else if real_condition_segno = cobol_operators_segno ()
      289 	then do;
      290 	     if (rel (p) >= rel (addr (cobol_operators_$cobol_operators_)))
      291 		& (rel (p) <= rel (addr (cobol_operators_$cobol_operators_end)))
      292 	     then do;
      293 
      294 /* Must be a cobol program.  Cobol always sets the return pointer to
      295*   point to a special return operator so we can no use this.  However,
      296*   in general cobol puts a return pointer to the main program in
      297*   the stack frame at location 64 ( called return_to_main_ptr), and
      298*   in the future this will always be valid;  so we will use it here.		*/
      299 
      300 		op_name = "cobol_operators_";
      301 		callp = cobol_stack_frame.return_to_main_ptr;
      302 
      303 		if rel (callp) > "0"b
      304 		then callp = addrel (callp, -1);	/* never return a neg offset */
      305 
      306 	     end;
      307 	end;
      308 
      309 /* check here for basic_operators_; assume that basic_operators_ is bound
      310*   first in bound_basic_runtime_ */
      311 
      312 	else if real_condition_segno = basic_operators_segno ()
      313 	then do;
      314 	     if rel (p) < rel (addr (basic_operators_$end_basic_operators))
      315 	     then do;
      316 		op_name = "basic_operators_";
      317 
      318 /* the offset of the operator return location is generally in x7;
      319*   first take care of some special cases:  here look for part of entry
      320*   sequence -- program has not yet been entered, but assume that
      321*   we were in entry sequence. */
      322 
      323 		p1 = addr (basic_operators_$enter_proc);
      324 		p2 = addr (basic_operators_$end_entry_ops);
      325 		if (rel (p1) <= rel (p)) & (rel (p) < rel (p2))
      326 		then do;
      327 		     if mcptr ^= null ()
      328 		     then do;
      329 			callp = addrel (mcptr -> mc.prs (2), 2);
      330 						/* pr2 probably -> eax7 in entry code */
      331 		     end;
      332 		     return;
      333 		end;
      334 
      335 /* now check for case where we are calling another program,
      336*   and before frame for program is created  -- cannot tell where we came
      337*   from as x7 has been smashed, so use entry pointer of caller */
      338 
      339 		p1 = addr (basic_operators_$call_op_begin);
      340 		p2 = addr (basic_operators_$new_frame);
      341 		if (rel (p1) <= rel (p)) & (rel (p) < rel (p2))
      342 		then do;
      343 		     if mcptr ^= null ()
      344 		     then callp = sp -> stack_frame.entry_ptr;
      345 		     return;
      346 		end;
      347 
      348 /* last special case: calling another basic program, and frame for the program
      349*   has been pushed, use entry pointer in pr2 as location.  In this section
      350*   pr2 -> location after tsp2, what addr of tsp2 */
      351 
      352 		p1 = addr (basic_operators_$call_op_end);
      353 		if (rel (p2) <= rel (p)) & (rel (p) < rel (p1))
      354 		then do;
      355 		     if mcptr ^= null ()
      356 		     then callp = addrel (mcptr -> mc.prs (2), -1);
      357 		     return;
      358 		end;
      359 
      360 /* try to get address from x7 */
      361 
      362 		if mcptr ^= null ()
      363 		then callp = addrel (ptr (sp -> stack_frame.entry_ptr, mcptr -> mc.regs.x (7)), -1);
      364 		else do;				/* no fault, assume called out */
      365 		     unspec (p1) = unspec (sp -> d_basic_operators_frame.d_temp (3));
      366 						/* return pt */
      367 		     do while (rel (p1) ^= (18)"0"b);	/* search for tsx7 to call op */
      368 			p1 = addrel (p1, -1);
      369 			if p1 -> tra_inst.opcode = "1110001110"b
      370 			then do;
      371 			     callp = p1;
      372 			     return;
      373 			end;
      374 		     end;
      375 		end;
      376 		return;
      377 	     end;
      378 
      379 	end;
      380 
      381 	else if real_condition_segno = algol68_operators_segno ()
      382 	then do;
      383 	     if (rel (p) >= rel (addr (algol68_operators_$algol68_operators_)))
      384 		& (rel (p) <= rel (addr (algol68_operators_$end_operators)))
      385 	     then do;
      386 		op_name = "algol68_operators_";
      387 
      388 /* first see if we are in an entry operator */
      389 
      390 		p1 = addr (algol68_operators_$entry_operators_begin);
      391 		p2 = addr (algol68_operators_$entry_operators_end);
      392 		if (rel (p1) <= rel (p)) & (rel (p) <= rel (p2))
      393 		then do;				/* in entry op; transferred by tsp2 */
      394 		     if mcptr ^= null ()
      395 		     then callp = addrel (mcptr -> mc.prs (2), -1);
      396 		     return;
      397 		end;
      398 
      399 /* otherwise assume that transfer was by tsx2 */
      400 
      401 		if mcptr ^= null ()
      402 		then callp = ptr (sp -> stack_frame.entry_ptr, bin (mcptr -> mc.regs.x (2), 18) - 1);
      403 	     end;
      404 	end;
      405 
      406 	else if real_condition_segno = pascal_operators_segno ()
      407 	then do;
      408 	     if (rel (p) >= rel (addr (pascal_operators_$pascal_operators_)))
      409 		& (rel (p) <= rel (addr (pascal_operators_$pascal_operators_end)))
      410 	     then do;
      411 		op_name = "pascal_operators_";
      412 		if mcptr ^= null ()			/* all xfers to pascal ops are by tsp3 */
      413 		then callp = addrel (mcptr -> mc.prs (3), -1);
      414 	     end;
      415 	end;
      416 
      417 
      418 	return;
      419 
      420 
      421 
      422 
      423 /* This procedure is used to get a pointer to the end of basic_operators_.  It calls hcs_$make_ptr
      424*   to avoid a linkage fault if basic is not at the current installation (it is unbundled).  This routine
      425*   should be called before any other references are made to basic operators.
      426*   This program will not cause basic_operators_' linkage section to be combined. */
      427 
      428 basic_operators_segno:
      429      procedure () returns (bit (18) aligned);
      430 
      431 	if ^have_made_basic_search
      432 	then do;
      433 	     call hcs_$make_ptr (null (), "basic_operators_", "", basic_operators_ptr, code);
      434 	     have_made_basic_search = "1"b;
      435 	end;
      436 
      437 	return (baseno (basic_operators_ptr));
      438 
      439      end basic_operators_segno;
      440 
      441 cobol_operators_segno:
      442      proc () returns (bit (18) aligned);
      443 
      444 	call hcs_$make_ptr (null (), "cobol_operators_", "", cobol_operators_ptr, code);
      445 
      446 
      447 	return (baseno (cobol_operators_ptr));
      448 
      449 
      450      end cobol_operators_segno;
      451 
      452 
      453 algol68_operators_segno:
      454      proc () returns (bit (18) aligned);
      455 
      456 
      457 	call hcs_$make_ptr (null (), "algol68_operators_", "", algol68_operators_ptr, code);
      458 
      459 	return (baseno (algol68_operators_ptr));
      460 
      461      end algol68_operators_segno;
      462 
      463 
      464 pascal_operators_segno:
      465      proc () returns (bit (18) aligned);
      466 
      467 	call hcs_$make_ptr (null (), "pascal_operators_", "", pascal_operators_ptr, code);
      468 
      469 	return (baseno (pascal_operators_ptr));
      470 
      471      end pascal_operators_segno;
      472 
      473 
      474      end interpret_op_ptr_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/86  1042.1  interpret_op_ptr_.pl1             >special_ldd>install>MR12.0-1206>interpret_op_ptr_.pl1
105          1    11/03/86  1114.7  stack_frame.incl.pl1              >special_ldd>install>MR12.0-1206>stack_frame.incl.pl1
108          2    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
110          3    03/27/82  0439.4  basic_operator_frame.incl.pl1     >ldd>include>basic_operator_frame.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
RETURN_PTR_MASK                 000000 constant        bit(72)                  initial unaligned dcl 1-19 ref 130 261
a_sp                                   parameter       pointer                  dcl 32 ref 11 117
addr                                                   builtin function         dcl 53 in procedure "interpret_op_ptr_" ref 127 140
                                                                                  147 148 176 178 188 190 210 211 214 215 221 233
                                                                                  234 244 264 268 290 290 314 323 324 339 340 352
                                                                                  383 383 390 391 408 408
addr                                   based           bit(18)                  level 2 in structure "tra_inst" packed unaligned
                                                                                  dcl 56 in procedure "interpret_op_ptr_" ref 176
                                                                                  188
addrel                                                 builtin function         dcl 53 ref 162 163 181 193 218 224 237 247 253 264
                                                                                  268 303 329 355 362 368 394 412
algol68_operators_$algol68_operators_
                                000070 external static fixed bin(35,0)          dcl 83 set ref 383
algol68_operators_$end_operators
                                000072 external static fixed bin(35,0)          dcl 83 set ref 383
algol68_operators_$entry_operators_begin
                                000074 external static fixed bin(35,0)          dcl 83 set ref 390
algol68_operators_$entry_operators_end
                                000076 external static fixed bin(35,0)          dcl 83 set ref 391
algol68_operators_ptr           000122 automatic       pointer                  dcl 37 set ref 457* 459
baseno                                                 builtin function         dcl 53 ref 134 135 140 147 157 248 272 437 447 459
                                                                                  469
baseptr                                                builtin function         dcl 53 ref 128
basic_operators_$call_op_begin  000056 external static fixed bin(35,0)          dcl 83 set ref 339
basic_operators_$call_op_end    000062 external static fixed bin(35,0)          dcl 83 set ref 352
basic_operators_$end_basic_operators
                                000050 external static fixed bin(35,0)          dcl 83 set ref 314
basic_operators_$end_entry_ops  000054 external static fixed bin(35,0)          dcl 83 set ref 324
basic_operators_$enter_proc     000052 external static fixed bin(35,0)          dcl 83 set ref 323
basic_operators_$new_frame      000060 external static fixed bin(35,0)          dcl 83 set ref 340
basic_operators_ptr             000124 automatic       pointer                  dcl 39 set ref 433* 437
bin                                                    builtin function         dcl 53 ref 128 128 150 150 172 176 179 188 191 212
                                                                                  212 216 216 222 222 235 235 245 278 281 401
callp                                  parameter       pointer                  dcl 32 set ref 11 118* 160* 162* 163 163* 163 181*
                                                                                  193* 218* 224* 237* 247* 248 253* 264* 268* 278*
                                                                                  281* 301* 303 303* 303 329* 343* 355* 362* 371*
                                                                                  394* 401* 412*
cobol_operators_$cobol_operators_
                                000064 external static fixed bin(35,0)          dcl 83 set ref 290
cobol_operators_$cobol_operators_end
                                000066 external static fixed bin(35,0)          dcl 83 set ref 290
cobol_operators_ptr             000120 automatic       pointer                  dcl 36 set ref 444* 447
cobol_stack_frame                      based           structure                level 1 dcl 100
code                            000134 automatic       fixed bin(35,0)          dcl 64 set ref 433* 444* 457* 467*
d_basic_operators_frame                based           structure                level 1 dcl 3-68
d_temp                  172            based           float bin(63)            array level 2 dcl 3-68 ref 252 365
entry_ptr                26            based           pointer                  level 2 dcl 1-36 ref 157 157 160 162 272 278 281 343
                                                                                  362 401
frame_flag                             parameter       bit(1)                   dcl 45 set ref 11 120* 183* 194* 205* 225* 238*
have_made_basic_search          000131 automatic       bit(1)                   dcl 48 set ref 121* 431 434*
hcs_$make_ptr                   000010 constant        entry                    external dcl 61 ref 433 444 457 467
ilc                       4            based           bit(18)                  level 2 packed unaligned dcl 2-56 ref 128
mc                                     based           structure                level 1 dcl 2-12
mcptr                                  parameter       pointer                  dcl 32 ref 11 125 127 155 181 193 202 218 224 237
                                                                                  247 281 327 329 343 355 355 362 362 394 394 401
                                                                                  401 412 412
null                                                   builtin function         dcl 53 ref 118 125 130 135 155 157 203 327 343 355
                                                                                  362 394 401 412 433 433 444 444 457 457 467 467
offset                          000133 automatic       fixed bin(18,0)          dcl 63 set ref 172* 176 179 188 191 212 212 216 216
                                                                                  222 222 235 235 245
op_name                                parameter       char(32)                 dcl 42 set ref 11 119* 153* 300* 316* 386* 411*
opcode                    0(18)        based           bit(10)                  level 2 packed unaligned dcl 56 ref 369
operator_return_offset
                         37(18)        based           bit(18)                  level 2 packed unaligned dcl 1-36 ref 160 160 278
                                                                                  278
opsegno                         000130 automatic       bit(18)                  dcl 46 set ref 147* 157 272
p                               000100 automatic       pointer                  dcl 32 set ref 128* 130* 134 150 172 264 268 290 290
                                                                                  314 325 325 341 341 353 353 383 383 392 392 408
                                                                                  408
p1                              000106 automatic       pointer                  dcl 34 set ref 148* 150 178* 179 190* 191 210* 212
                                                                                  233* 235 244* 245 323* 325 339* 341 352* 353 365*
                                                                                  367 368* 368 369 371 390* 392
p2                              000110 automatic       pointer                  dcl 34 set ref 211* 212 234* 235 252* 253 324* 325
                                                                                  340* 341 353 391* 392
p3                              000112 automatic       pointer                  dcl 34 set ref 214* 216
p4                              000114 automatic       pointer                  dcl 34 set ref 215* 216 222
p5                              000116 automatic       pointer                  dcl 34 set ref 221* 222
pascal_operators_$pascal_operators_
                                000100 external static fixed bin(35,0)          dcl 83 set ref 408
pascal_operators_$pascal_operators_end
                                000102 external static fixed bin(35,0)          dcl 83 set ref 408
pascal_operators_ptr            000126 automatic       pointer                  dcl 40 set ref 467* 469
pl1_operators_$alm_call         000032 external static fixed bin(35,0)          dcl 65 set ref 214
pl1_operators_$alm_operators_begin
                                000026 external static fixed bin(35,0)          dcl 65 set ref 210
pl1_operators_$alm_operators_end
                                000030 external static fixed bin(35,0)          dcl 65 set ref 211
pl1_operators_$alm_push         000034 external static fixed bin(35,0)          dcl 65 set ref 215
pl1_operators_$alm_return       000036 external static fixed bin(35,0)          dcl 65 set ref 221
pl1_operators_$alm_trace_operators_begin
                                000044 external static fixed bin(35,0)          dcl 65 set ref 233
pl1_operators_$alm_trace_operators_end
                                000046 external static fixed bin(35,0)          dcl 65 set ref 234
pl1_operators_$entry_operators  000012 external static fixed bin(35,0)          dcl 65 set ref 140 147 176
pl1_operators_$entry_operators_end
                                000014 external static fixed bin(35,0)          dcl 65 set ref 178
pl1_operators_$forward_call     000040 external static fixed bin(35,0)          dcl 65 set ref 264
pl1_operators_$math_routines_   000022 external static fixed bin(35,0)          dcl 65 set ref 244
pl1_operators_$math_routines_end_
                                000024 external static fixed bin(35,0)          dcl 65 set ref 148
pl1_operators_$trace_entry_operators
                                000016 external static fixed bin(35,0)          dcl 65 set ref 188
pl1_operators_$trace_entry_operators_end
                                000020 external static fixed bin(35,0)          dcl 65 set ref 190
pl1_operators_$var_call         000042 external static fixed bin(35,0)          dcl 65 set ref 268
ppr                                    based           structure                level 2 packed unaligned dcl 2-56
prs                                    based           pointer                  array level 2 dcl 2-12 ref 181 193 202 218 224 237
                                                                                  247 329 355 394 412
psr                       0(03)        based           bit(15)                  level 3 packed unaligned dcl 2-56 ref 128
ptr                                                    builtin function         dcl 53 ref 128 160 162 203 278 281 362 401
real_condition_segno            000132 automatic       bit(18)                  dcl 50 set ref 134* 135 140 288 312 381 406
regs                     20            based           structure                level 2 packed unaligned dcl 2-12
rel                                                    builtin function         dcl 53 ref 150 150 163 172 179 191 203 212 212 216
                                                                                  216 222 222 235 235 245 290 290 290 290 303 314
                                                                                  314 325 325 325 325 341 341 341 341 353 353 353
                                                                                  353 367 383 383 383 383 392 392 392 392 408 408
                                                                                  408 408
return_ptr               24            based           pointer                  level 2 dcl 1-36 ref 130 261
return_ptr_copy                 000104 automatic       pointer                  dcl 32 set ref 261* 264 268
return_to_main_ptr      100            based           pointer                  level 2 dcl 100 ref 301
rsp                             000102 automatic       pointer                  dcl 32 set ref 202* 203* 203 205 261 272 278 278 278
                                                                                  281
scu                      30            based           bit(36)                  array level 2 in structure "mc" packed unaligned
                                                                                  dcl 2-12 in procedure "interpret_op_ptr_" set ref
                                                                                  127
scu                                    based           structure                level 1 dcl 2-56 in procedure "interpret_op_ptr_"
scup                            000140 automatic       pointer                  dcl 2-54 set ref 127* 128 128
sp                              000136 automatic       pointer                  dcl 1-31 set ref 117* 130 130 157 157 160 160 160
                                                                                  162 162 203 203 205 252 301 343 362 365 401
stack_frame                            based           structure                level 1 dcl 1-36
sx                                     based           bit(18)                  array unaligned dcl 47 ref 162
tra_inst                               based           structure                level 1 dcl 56
unspec                                                 builtin function         dcl 53 set ref 130* 130 252* 252 261* 261 365* 365
x                        20            based           bit(18)                  array level 3 packed unaligned dcl 2-12 ref 281 362
                                                                                  401

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial unaligned dcl 1-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial unaligned dcl 1-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial unaligned dcl 1-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial unaligned dcl 1-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial unaligned dcl 1-27
abx                                    internal static fixed bin(17,0)          initial dcl 2-42
apx                                    internal static fixed bin(17,0)          initial dcl 2-42
basic_operators_frame                  based           structure                level 1 dcl 3-1
bbx                                    internal static fixed bin(17,0)          initial dcl 2-42
bo_pt                                  automatic       pointer                  dcl 112
bpx                                    internal static fixed bin(17,0)          initial dcl 2-42
lbx                                    internal static fixed bin(17,0)          initial dcl 2-42
lpx                                    internal static fixed bin(17,0)          initial dcl 2-42
mcp                                    automatic       pointer                  dcl 2-10
sbx                                    internal static fixed bin(17,0)          initial dcl 2-42
scux                                   based           structure                level 1 dcl 2-207
spx                                    internal static fixed bin(17,0)          initial dcl 2-42
stack_frame_flags                      based           structure                level 1 dcl 1-64
stack_frame_min_length                 internal static fixed bin(17,0)          initial dcl 1-33

NAMES DECLARED BY EXPLICIT CONTEXT.
algol68_operators_segno         001237 constant        entry                    internal dcl 453 ref 381
basic_operators_segno           001121 constant        entry                    internal dcl 428 ref 248 312
check_call                      000451 constant        label                    dcl 261
cobol_operators_segno           001172 constant        entry                    internal dcl 441 ref 288
interpret_op_ptr_               000051 constant        entry                    external dcl 11
pascal_operators_segno          001303 constant        entry                    internal dcl 464 ref 406

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1754        2060    1356        1764
Length      2362    1356       104         266     376           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
interpret_op_ptr_                   258 external procedure  is an external procedure.  
basic_operators_segno                   internal procedure  shares stack frame of external procedure interpret_op_ptr_.  
cobol_operators_segno                   internal procedure  shares stack frame of external procedure interpret_op_ptr_.  
algol68_operators_segno                 internal procedure  shares stack frame of external procedure interpret_op_ptr_.  
pascal_operators_segno                  internal procedure  shares stack frame of external procedure interpret_op_ptr_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
interpret_op_ptr_        000100 p                           interpret_op_ptr_
                         000102 rsp                         interpret_op_ptr_
                         000104 return_ptr_copy             interpret_op_ptr_
                         000106 p1                          interpret_op_ptr_
                         000110 p2                          interpret_op_ptr_
                         000112 p3                          interpret_op_ptr_
                         000114 p4                          interpret_op_ptr_
                         000116 p5                          interpret_op_ptr_
                         000120 cobol_operators_ptr         interpret_op_ptr_
                         000122 algol68_operators_ptr       interpret_op_ptr_
                         000124 basic_operators_ptr         interpret_op_ptr_
                         000126 pascal_operators_ptr        interpret_op_ptr_
                         000130 opsegno                     interpret_op_ptr_
                         000131 have_made_basic_search      interpret_op_ptr_
                         000132 real_condition_segno        interpret_op_ptr_
                         000133 offset                      interpret_op_ptr_
                         000134 code                        interpret_op_ptr_
                         000136 sp                          interpret_op_ptr_
                         000140 scup                        interpret_op_ptr_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
hcs_$make_ptr

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
algol68_operators_$algol68_operators_                       algol68_operators_$end_operators
algol68_operators_$entry_operators_begin                    algol68_operators_$entry_operators_end
basic_operators_$call_op_begin                              basic_operators_$call_op_end
basic_operators_$end_basic_operators                        basic_operators_$end_entry_ops
basic_operators_$enter_proc   basic_operators_$new_frame    cobol_operators_$cobol_operators_
cobol_operators_$cobol_operators_end                        pascal_operators_$pascal_operators_
pascal_operators_$pascal_operators_end                      pl1_operators_$alm_call
pl1_operators_$alm_operators_begin                          pl1_operators_$alm_operators_end
pl1_operators_$alm_push       pl1_operators_$alm_return     pl1_operators_$alm_trace_operators_begin
pl1_operators_$alm_trace_operators_end                      pl1_operators_$entry_operators
pl1_operators_$entry_operators_end                          pl1_operators_$forward_call   pl1_operators_$math_routines_
pl1_operators_$math_routines_end_                           pl1_operators_$trace_entry_operators
pl1_operators_$trace_entry_operators_end                    pl1_operators_$var_call




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000044       117 000056       118 000062       119 000064       120 000070       121 000072       125 000073
    127 000077       128 000103       129 000114       130 000115       132 000126       134 000127       135 000132
    140 000136       147 000144       148 000147       150 000151       153 000160       155 000163       157 000170
    160 000201       162 000211       163 000222       167 000230       172 000231       176 000233       178 000237
    179 000241       181 000245       183 000252       184 000253       188 000254       190 000260       191 000262
    193 000266       194 000273       195 000274       202 000275       203 000301       205 000311       210 000316
    211 000320       212 000322       214 000332       215 000334       216 000336       218 000350       219 000353
    221 000354       222 000356       224 000365       225 000370       226 000371       228 000372       233 000373
    234 000375       235 000377       237 000407       238 000412       239 000413       244 000414       245 000416
    247 000422       248 000425       252 000441       253 000445       255 000450       261 000451       264 000456
    268 000470       272 000502       278 000510       281 000523       283 000532       288 000533       290 000541
    300 000555       301 000562       303 000565       307 000573       312 000574       314 000602       316 000611
    323 000616       324 000620       325 000622       327 000634       329 000640       332 000645       339 000646
    340 000650       341 000652       343 000663       345 000672       352 000673       353 000675       355 000705
    357 000716       362 000717       365 000735       367 000741       368 000744       369 000747       371 000754
    372 000756       374 000757       376 000760       379 000761       381 000762       383 000770       386 001004
    390 001011       391 001013       392 001015       394 001026       396 001037       401 001040       404 001055
    406 001056       408 001064       411 001102       412 001107       418 001120       428 001121       431 001123
    433 001125       434 001163       437 001165       441 001172       444 001174       447 001232       453 001237
    457 001241       459 001276       464 001303       467 001305       469 001345


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
