	COMPILATION LISTING OF SEGMENT db_break
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/04/82  1821.1 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 db_break: proc;
       12 
       13 /*	This procedure is part of the  debug package.   All of the mechanism required to
       14*   *  handle break points is contained in this procedure.   This procedure alone,
       15*   *  maintains the user's  break segment  found in his home directory.   This
       16*   *  procedure, along with  db_break_map,  maintains the  break map  needed in each
       17*   *  segment which has breaks.  Note, what this procedure does NOT know about
       18*   *  is the semantics of the debug language.
       19*   *  Rewritten  Dec 72  for the  6180  by  Bill Silver.
       20*   *
       21*   *  db_break  has the following entry points:
       22*   *
       23*   *  check_break:	Returns info about a break, especially whether or not a
       24*   *  		condition has been met.
       25*   *
       26*   *  global:		Performs a specified action on all the breaks known to the
       27*   *  		user in all segments.
       28*   *
       29*   *  print_bseg:	Prints the number of breaks in all the segments which the user
       30*   *  		has breaks.  Cleans up this break segment.
       31*   *
       32*   *  print_default:	Prints the path name of the current default segment.
       33*   *
       34*   *  restart:		Restarts a break - executes the instruction replaced by
       35*   *  		the  mme2.
       36*   *
       37*   *  set_break:	Sets up a break.
       38*   *
       39*   *  set_default:	Establishes a segment as the default segment.
       40*   *
       41*   *  set_skips:	Sets a number of skips in a specified break.
       42*   *
       43*   *  single:		Performs a specified action on  ONE  specified break.
       44*   *
       45*   *  sub_global:	Performs a specified action on all the breaks in the
       46*   *  		default segment.
       47**/
       48 
       49 
       50 /*		PARAMETER  DATA		*/
       51 
       52 dcl  arg_action_code fixed bin,			/* (INPUT)  Implies action to perform on break.
       53*						   *  A_C_T_I_O_N_		C_O_D_E_
       54*						   *  list		  1
       55*						   *  reset		  2
       56*						   *  disable	  3
       57*						   *  enable		  4
       58*						   *  set command	  5
       59*						   *  set condition	  6  */
       60      arg_break_num fixed bin,				/* (INPUT)  The number of a break in the
       61*						   *  default segment.  */
       62      arg_break_ptr ptr,				/* (INPUT)  A pointer to the word where
       63*						   *  the break will be set.  */
       64      arg_cond_flag fixed bin,				/* (OUTPUT) A flag indicating whether or not the
       65*						   *  condition of a conditional break has been met.
       66*						   *  0  =>  No condition  or  condition not met.
       67*						   *  1  =>  Condition not met - skip break.  */
       68 
       69      arg_comd_len fixed bin,				/* (OUTPUT) The length of the command line
       70*						   *  found in a break.  0 => no command.  */
       71      arg_comd_ptr ptr,				/* (OUTPUT) A pointer to the command line
       72*						   *  found in a break.  */
       73      arg_line char (236),				/* (INPUT)  A string that can be either a
       74*						   *  command line or condition data.  */
       75      arg_line_len fixed bin,				/* (INPUT)  The length of the above string.  */
       76      arg_line_no fixed bin,				/* (OUTPUT) Source line number. */
       77      arg_num_skips fixed bin,				/* (INPUT/OUTPUT) The number of  skips
       78*						   *  ( to set/that are set )  in a break.  */
       79      arg_print_mode fixed bin,			/* (INPUT)  0 => SHORT, 1 => LONG. */
       80      arg_scu_ptr ptr,				/* (INPUT)  Points to the  SCU  data
       81*						   *  generated by a  mme2 fault.  */
       82      arg_seg_ptr ptr,				/* (INPUT)  Pointer to a segment that is
       83*						   *  to become the default segment.  */
       84      arg_snt_ptr ptr,				/* (INPUT)  Pointer to debug's arg_snt data.  */
       85      arg_type fixed bin;				/* (INPUT)  The type of break.
       86*						   *  0 => regular,
       87*						   *  1 => temporary,
       88*						   *  2 => disabled.  */
       89 
       90 
       91 /*		INTERNAL  STATIC  DATA	*/
       92 
       93 /*	Note, since the following variables must be preserved from one call to another
       94*   *  they are static.  Any procedures which need this information therefore must be
       95*   *  part of db_break or called by  db_break.  */
       96 
       97 
       98 /*	Pointer to the user's  break segment.  */
       99 
      100 dcl  break_seg_ptr ptr internal static init (null);
      101 
      102 
      103 
      104 /*	The following variables are used to define the  default segment.
      105*   *  def_seg  is the number of the break segment array entry which corresponds
      106*   *  to the default segment.    def_break_map_ptr  points to the break map in
      107*   *  the default segment.
      108**/
      109 dcl  def_segx fixed bin internal static init (0),
      110      def_break_map_ptr ptr internal static;
      111 
      112 /*	Below is the  mme2  instruction that is put into a break word.  */
      113 
      114 dcl 1 mme2 aligned internal static,
      115     2 break_num fixed bin (17) unaligned,
      116     2 op_code bit (36) unaligned init ("000000100000000000"b);
      117 
      118 /*	An array used to print the type of a break.  */
      119 
      120 dcl  break_type_name (0:3) char (24) internal static aligned
      121      init ("Break          ", "Temporary break", "Disabled  break",
      122      "Temporary disabled break");
      123 
      124 
  1     1 /*	BEGIN INCLUDE FILE . . .  db_ext_stat_.incl.pl1
  1     2*   *
  1     3*   *	This include file is used to reference the common data  that is passed from the
  1     4*   *	main debug procedure  "debug" to other debug procedures.  This data is in db_ext_stat_.alm
  1     5*   *
  1     6*   *	modified 7/75 by S.E. Barr for the break instructions
  1     7**/
  1     8 
  1     9 dcl 1 db_ext_stat_$db_ext_stat_ ext static aligned,
  1    10 
  1    11     2 debug_input char (32) aligned,			/* Input switch name.  Initially "user_input" */
  1    12     2 debug_output char (32) aligned,			/* output switch name.  Initially "user_output" */
  1    13     2 return_label label,				/* The label used to do a non local goto out of debug when
  1    14*						   it was entered via a fault.  It will go to debug in
  1    15*						   another frame.  */
  1    16 
  1    17     2 debug_io_ptr (2) ptr,				/* pointers to iocb for i/o
  1    18*						   1 = input switch iocb ptr
  1    19*						   2 = output switch iocb ptr      */
  1    20     2 flags aligned,
  1    21       3 debug_io_attach (2) bit (1) unaligned,		/* 1= debug made the attachment */
  1    22       3 debug_io_open (2) bit (1) unaligned,		/* 1 = debug opened the switch */
  1    23       3 in_debug bit (1) unaligned,			/* Switch for the any_other condition.  0 = send the
  1    24*						   condition on;  1 = use the debug condition handler */
  1    25       3 static_handler_call bit (1) unal,		/* ON if mme2 call from static handler */
  1    26       3 pad bit (30) unaligned;			/* Reserved for future use */
  1    27 dcl  db_ext_stat_$break_instructions (9) bit (36) ext static aligned;
  1    28 
  1    29 /*	END OF INCLUDE FILE  ... db_ext_stat_.incl.pl1  */
      125 
      126 
      127 /*		AUTOMATIC  DATA		*/
      128 
      129 dcl  action_code fixed bin,				/* These variables are used to copy arguments. */
      130      break_num fixed bin,
      131      break_ptr ptr,
      132      line_len fixed bin,
      133      print_mode fixed bin,
      134      snt_ptr ptr,
      135      type fixed bin;
      136 
      137 dcl  break_word_ptr ptr,				/* Pointer to the word where the break is. */
      138      break_offset fixed bin (18);			/* Word offset of the break word. */
      139 
      140 dcl  dir_name char (168),				/* Directory name of a segment. */
      141      ent_name char (32);				/* Entry name of a segment. */
      142 
      143 /*	This is the array of data returned by the calls to  hcs_$status_long.  */
      144 
      145 dcl 1 branch aligned,
      146     (2 type bit (2),
      147     2 nnames bit (16),
      148     2 nrp bit (18),
      149     2 dtm bit (36),
      150     2 dtu bit (36),
      151     2 mode bit (5),
      152     2 padding bit (13),
      153     2 records bit (18),
      154     2 dtd bit (36),
      155     2 dtem bit (36),
      156     2 acct bit (36),
      157     2 curlen bit (12),
      158     2 bitcnt bit (24),
      159     2 did bit (4),
      160     2 mdid bit (4),
      161     2 copysw bit (1),
      162     2 pad2 bit (9),
      163     2 rbs (0:2) bit (6),
      164     2 uid bit (36)) unaligned;
      165 
      166 dcl  action_flag bit (1),				/* Used to denote if an action has been
      167*						   *  performed for any breaks.  */
      168      cond_flag fixed bin,				/* Used to determine condition state. */
      169      delete_seg_entry_flag bit (1),			/* Denotes whether a segment entry in the break
      170*						   *  segment array has been deleted. */
      171      inst_ptr ptr,					/* Pointer to instruction after break. */
      172      new_bnum fixed bin,				/* Temporary break number. */
      173      seg_ptr ptr,					/* Temporary segment pointer. */
      174      segx fixed bin;				/* Index into break segment array. */
      175 
      176 dcl  print_num_breaks char (6),			/* A word string for printing, */
      177      source_string char (72) var;			/* Used to get  info back from other procs. */
      178 
      179 dcl  bit_count fixed bin (24),			/* Returned from  hcs_$initiate count. */
      180      code fixed bin (35),				/* Error return code. */
      181     (i, j) fixed bin;				/* Work variables. */
      182 
      183 
      184 /*		BASED  DATA		*/
      185 
      186 /*	This is a map of the user's  break segment.  */
      187 
      188 dcl 1 bseg based (break_seg_ptr) aligned,
      189     2 num_segs fixed bin,				/* Number of segments in seg array. */
      190     2 seg (1),					/* Array of segment entries.  Each entry
      191*						   *  corresponds to one segment which should
      192*						   *  have a break map.  */
      193       3 uid bit (36),				/* UID of segment.  This field remains
      194*						   *  constant for the life of the entry.  */
      195       3 dir_name char (168) unal,			/* Directory name of segment. */
      196       3 ent_name char (32) unal;			/* Entry name of the segment.  Note, these
      197*						   *  two fields may change since the segment
      198*						   *  may be moved, renamed, or referenced
      199*						   *  via a link.  */
      200 
      201 /*	This is an overlay  of the  break segment  used to move whole entries around.  */
      202 
      203 dcl 1 bseg_map based (break_seg_ptr) aligned,
      204     2 num_segs fixed bin,
      205     2 array (1),
      206       3 entry char (204);
      207 
      208 
      209 /*	This is a map of the  mme2  word that is moved into the break word.  */
      210 
      211 dcl 1 mme2_map based aligned,
      212     2 break_num fixed bin (17) unaligned,
      213     2 op_code bit (18) unaligned;
      214 
      215 /*	This is used to reference one word.  */
      216 
      217 dcl  based_word bit (36) based aligned;
      218 
      219 
      220 /*		EXTERNAL  ENTRIES		*/
      221 
      222 dcl (addr, addrel, divide, fixed, index, max, null, ptr, rel, size, substr) builtin;
      223 
      224 dcl  com_err_ external entry options (variable),
      225      db_break_map$check external entry (ptr, fixed bin (24), ptr),
      226      db_break_map$delete external entry (ptr),
      227      db_break_map$get_slots external entry (ptr),
      228      db_break_map$init external entry (ptr, fixed bin (24), ptr),
      229      db_line_no external entry (ptr, fixed bin (18),
      230      fixed bin, fixed bin, fixed bin),
      231      db_parse_condition$check external entry (ptr, ptr, ptr, fixed bin),
      232      db_parse_condition$print_line external entry (ptr, char (72) var),
      233      hcs_$fs_get_path_name external entry (ptr, char (*), fixed bin, char (*), fixed bin (35)),
      234      hcs_$initiate_count external entry (char (*), char (*), char (*), fixed bin (24),
      235      fixed bin (2), ptr, fixed bin (35)),
      236      hcs_$make_seg external entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35)),
      237      hcs_$set_bc_seg external entry (ptr, fixed bin (24), fixed bin (35)),
      238      hcs_$status_long external entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35)),
      239      hcs_$truncate_seg external entry (ptr, fixed bin (18), fixed bin (35)),
      240      ioa_$ioa_stream external entry options (variable),
      241      ioa_$rsnnl external entry options (variable),
      242      user_info_ external entry (char (*)),
      243      print_text_$real_offset external entry (ptr, char (*) var, fixed bin (18)),
      244      user_info_$homedir external entry (char (*));
      245 						/* 	*/
  2     1 /*	BEGIN INCLUDE FILE ...  db_break_map_map.incl.pl1
  2     2**	Written  Dec 72  for the  6180  by  Bill Silver.
  2     3**	Changed  Feb 73  for eis restart by Bill Silver.
  2     4**
  2     5**	This include file contains the declaration for the debug break map.
  2     6**/
  2     7 
  2     8 dcl	break_map_ptr	ptr,		/* Pointer to break map header. */
  2     9 	break_slot_ptr	ptr;		/* Pointer to individual break slot entry. */
  2    10 
  2    11 
  2    12 dcl     1	old_bmap  based(break_map_ptr)  aligned,/* Old version of break map header. */
  2    13 	2 pad(4)	bit(36),
  2    14 	2 breaks(1),
  2    15 	  3 slot (size(break_slot))  bit(36);
  2    16 
  2    17 dcl    1	bmap  based (break_map_ptr)  aligned,	/* Version 2 break map header. */
  2    18 	2 num_slots	fixed bin,	/* Number of break slots allocated. */
  2    19 	2 num_set		fixed bin,	/* Number of breaks actually set. */
  2    20 	2 bit_count	fixed bin(24),	/* Bit count of the whole segment. */
  2    21 	2 version		char(4),		/* Break map version number. */
  2    22 	2 eis,				/* Used to restart EIS instructions.. */
  2    23 	  3 tra		bit(36),		/* Replaces instruction after eis instr. */
  2    24 	  3 instructions(9)	bit(36),		/* Executed after eis inst restarted. */
  2    25 	  3 mme2_indw	bit(18),		/* Indirect word: offset -> loc of break. */
  2    26 	  3 inst_indw	bit(18),		/* Indirect word: offset -> inst after EIS inst. */
  2    27 	  3 save		bit(36),		/* Used to save A register. */
  2    28 	  3 mme2		bit(36),		/* Used to save mme2 instruction. */
  2    29 	  3 inst		bit(36),		/* Used to save inst after eis inst. */
  2    30 	2 reserved(13)	bit(36),		/* Reserved for future use. */
  2    31 	2 breaks(1),			/* Array of break slots. */
  2    32 	  3 slot (size(break_slot))  bit(36);
  2    33 
  2    34 
  2    35 dcl     1	break_slot  based(break_slot_ptr)  aligned,
  2    36 	  2 type		fixed bin,	/* -1 => slot is free, 
  2    37*					*   0 => regular break,     1 => temporary,
  2    38*					*   2 => regular disabled,  2 => temporary disabled */
  2    39 	  2 offset	fixed bin(18),	/* Offset of the break word. */
  2    40 	  2 old_word	bit(36),		/* Previous contents of break word. */
  2    41 	  2 skip_count	fixed bin,	/* Number of times to skip break. */
  2    42 	  2 line_no	fixed bin,	/* Source line corresponding to break. */
  2    43 	  2 num_words	fixed bin,	/* Number of words in instruction. */
  2    44 	  2 reserved(2)	fixed bin,	/* Reserved for possible future use. */
  2    45 	  2 comd_len	fixed bin,	/* Length of command line,  0 => no command */
  2    46 	  2 comd_line	char(128),	/* Command line to be executed at break time. */
  2    47 	  2 cond_len	fixed bin,	/* Length of condition data,  0 => no condition. */
  2    48 	  2 cond_data	char(236);	/* Contents of all the condition data.
  2    49*					*  Format of this data specified in procedures
  2    50*					*  which process semantics of condition data. */
  2    51 
  2    52 
  2    53 /*	END of INCLUDE FILE ...  db_break_map_map.incl.pl1    */
      246 
      247 /* 	*/
      248 dcl 1 op_mnemonic_$op_mnemonic (0:1023) ext static aligned,
      249 
      250     2 opcode char (6) unal,
      251     2 dtype fixed bin (2) unal,
      252     2 num_desc fixed bin (5) unal,
      253     2 num_words fixed bin (8) unal;
      254 
      255 /* 	*/
  3     1 /*	BEGIN INCLUDE FILE ... db_inst.incl.pl1  Last modified Nov 72 - WSS. */
  3     2 
  3     3 
  3     4 /*	PL/I  definitions of an instruction word.  There are two definitions.
  3     5**	One defines a full 18 bit offset field (now meaningful with 256K segments)
  3     6**	and the other defines an instruction with a pointer register field and a
  3     7**	15 bit offset field.
  3     8**/
  3     9 
  3    10 dcl	ilc_ptr	  ptr;			/* Pointer to the instruction word. */
  3    11 
  3    12 
  3    13 dcl     1	instr	  based (ilc_ptr)  	aligned,	
  3    14          (2  offset	  fixed bin (17),		/* Full 18 bit offset.  No pr field. */
  3    15 	2  opcode	  bit (10),		/* Instruction opcode. */
  3    16 	2  inhibit  bit (1),		/* ON => interrupts inhibitted. */
  3    17 	2  pr_bit	  bit (1),		/* ON => instruction has  pr  field. */
  3    18 	2  tag	  bit (6))  unaligned;	/* Tag field. */
  3    19 
  3    20 
  3    21 dcl     1	instr_pr	  based (ilc_ptr)  	aligned,	
  3    22          (2  pr	  bit (3),		/* Pointer register field. */
  3    23 	2  offset	  fixed bin (14),		/* 15 bit offset due to pr field. */
  3    24 	2  pad	  bit (18))  unaligned;
  3    25 
  3    26 
  3    27 /*	END OF INCLUDE FILE ... db_inst.incl.pl1	*/
      256 
      257 /* 	*/
  4     1 /*  */
  4     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
  4     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
  4     4 /* Modified 07/07/76 by Morris for fault register data */
  4     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
  4     6 
  4     7 
  4     8 /* words 0-15 pointer registers */
  4     9 
  4    10 dcl  mcp ptr;
  4    11 
  4    12 dcl 1 mc based (mcp) aligned,
  4    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
  4    14    (2 regs,					/* registers */
  4    15       3 x (0:7) bit (18),				/* index registers */
  4    16       3 a bit (36),					/* accumulator */
  4    17       3 q bit (36),					/* q-register */
  4    18       3 e bit (8),					/* exponent */
  4    19       3 pad1 bit (28),
  4    20       3 t bit (27),					/* timer register */
  4    21       3 pad2 bit (6),
  4    22       3 ralr bit (3),				/* ring alarm register */
  4    23 
  4    24     2 scu (0:7) bit (36),
  4    25 
  4    26     2 mask bit (72),				/* mem controller mask at time of fault */
  4    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
  4    28     2 errcode fixed bin (35),				/* fault handler's error code */
  4    29     2 fim_temp,
  4    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
  4    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
  4    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
  4    33     2 fault_reg bit (36),				/* fault register */
  4    34     2 pad2 bit (1),
  4    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
  4    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
  4    37     2 fault_time bit (54),				/* time of fault */
  4    38 
  4    39     2 eis_info (0:7) bit (36)) unaligned;
  4    40 
  4    41 
  4    42 dcl (apx fixed bin init (0),
  4    43      abx fixed bin init (1),
  4    44      bpx fixed bin init (2),
  4    45      bbx fixed bin init (3),
  4    46      lpx fixed bin init (4),
  4    47      lbx fixed bin init (5),
  4    48      spx fixed bin init (6),
  4    49      sbx fixed bin init (7)) internal static;
  4    50 
  4    51 
  4    52 
  4    53 
  4    54 dcl  scup ptr;
  4    55 
  4    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
  4    57 
  4    58 
  4    59 /*	WORD (0)		*/
  4    60 
  4    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
  4    62       3 prr bit (3),				/* procedure ring register */
  4    63       3 psr bit (15),				/* procedure segment register */
  4    64       3 p bit (1),					/* procedure privileged bit */
  4    65 
  4    66     2 apu,					/* APPENDING UNIT STATUS */
  4    67       3 xsf bit (1),				/* ext seg flag - IT modification */
  4    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
  4    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
  4    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
  4    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
  4    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
  4    73       3 dsptw bit (1),				/* Fetch of DSPTW */
  4    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
  4    75       3 sdwp bit (1),				/* Fetch of SDW paged */
  4    76       3 ptw bit (1),				/* Fetch of PTW */
  4    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
  4    78       3 fap bit (1),				/* Fetch of final address paged */
  4    79       3 fanp bit (1),				/* Fetch of final address non-paged */
  4    80       3 fabs bit (1),				/* Fetch of final address absolute */
  4    81 
  4    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
  4    83 
  4    84 
  4    85 /*	WORD (1)		*/
  4    86 
  4    87     2 fd,						/* FAULT  DATA */
  4    88       3 iro bit (1),				/* illegal ring order */
  4    89       3 oeb bit (1),				/* out of execute bracket */
  4    90       3 e_off bit (1),				/* no execute */
  4    91       3 orb bit (1),				/* out of read bracket */
  4    92       3 r_off bit (1),				/* no read */
  4    93       3 owb bit (1),				/* out of write bracket */
  4    94       3 w_off bit (1),				/* no write */
  4    95       3 no_ga bit (1),				/* not a gate */
  4    96       3 ocb bit (1),				/* out of call bracket */
  4    97       3 ocall bit (1),				/* outward call */
  4    98       3 boc bit (1),				/* bad outward call */
  4    99       3 inret bit (1),				/* inward return */
  4   100       3 crt bit (1),				/* cross ring transfer */
  4   101       3 ralr bit (1),				/* ring alarm register */
  4   102       3 am_er bit (1),				/* associative memory fault */
  4   103       3 oosb bit (1),				/* out of segment bounds */
  4   104       3 paru bit (1),				/* processor parity upper */
  4   105       3 parl bit (1),				/* processor parity lower */
  4   106       3 onc_1 bit (1),				/* op not complete type 1 */
  4   107       3 onc_2 bit (1),				/* op not complete type 2 */
  4   108 
  4   109     2 port_stat,					/* PORT  STATUS */
  4   110       3 ial bit (4),				/* illegal action lines */
  4   111       3 iac bit (3),				/* illegal action channel */
  4   112       3 con_chan bit (3),				/* connect channel */
  4   113 
  4   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
  4   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
  4   116 
  4   117 
  4   118 /*	WORD (2)		*/
  4   119 
  4   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
  4   121       3 trr bit (3),				/* temporary ring register */
  4   122       3 tsr bit (15),				/* temporary segment register */
  4   123 
  4   124     2 pad2 bit (9),
  4   125 
  4   126     2 cpu_no bit (3),				/* CPU number */
  4   127 
  4   128     2 delta bit (6),				/* tally modification DELTA */
  4   129 
  4   130 
  4   131 /*	WORD (3)		*/
  4   132 
  4   133     2 word3 bit (18),
  4   134 
  4   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
  4   136       3 tsna,					/* Word 1 status */
  4   137         4 prn bit (3),				/* Word 1  PR  number */
  4   138         4 prv bit (1),				/* Word 1  PR  valid bit */
  4   139       3 tsnb,					/* Word 2  status */
  4   140         4 prn bit (3),				/* Word 2  PR  number */
  4   141         4 prv bit (1),				/* Word 2  PR  valid bit */
  4   142       3 tsnc,					/* Word 3  status */
  4   143         4 prn bit (3),				/* Word 3  PR  number */
  4   144         4 prv bit (1),				/* Word 3  PR  valid bit */
  4   145 
  4   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
  4   147 
  4   148 
  4   149 /* 	WORD (4)		*/
  4   150 
  4   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
  4   152 
  4   153     2 ir,						/* INDICATOR  REGISTERS */
  4   154       3 zero bit (1),				/* zero indicator */
  4   155       3 neg bit (1),				/* negative indicator */
  4   156       3 carry bit (1),				/* carryry indicator */
  4   157       3 ovfl bit (1),				/* overflow indicator */
  4   158       3 eovf bit (1),				/* eponent overflow */
  4   159       3 eufl bit (1),				/* exponent underflow */
  4   160       3 oflm bit (1),				/* overflow mask */
  4   161       3 tro bit (1),				/* tally runout */
  4   162       3 par bit (1),				/* parity error */
  4   163       3 parm bit (1),				/* parity mask */
  4   164       3 bm bit (1),					/* ^bar mode */
  4   165       3 tru bit (1),				/* truncation mode */
  4   166       3 mif bit (1),				/* multi-word instruction mode */
  4   167       3 abs bit (1),				/* absolute mode */
  4   168       3 pad bit (4),
  4   169 
  4   170 
  4   171 /*	WORD (5)		*/
  4   172 
  4   173     2 ca bit (18),					/* COMPUTED  ADDRESS */
  4   174 
  4   175     2 cu,						/* CONTROL UNIT STATUS */
  4   176       3 rf bit (1),					/* on first cycle of repeat instr */
  4   177       3 rpt bit (1),				/* repeat instruction */
  4   178       3 rd bit (1),					/* repeat double instruction */
  4   179       3 rl bit (1),					/* repeat link instruciton */
  4   180       3 pot bit (1),				/* IT  modification */
  4   181       3 pon bit (1),				/* return type instruction */
  4   182       3 xde bit (1),				/* XDE from Even location */
  4   183       3 xdo bit (1),				/* XDE from Odd  location */
  4   184       3 poa bit (1),				/* operation preparation */
  4   185       3 rfi bit (1),				/* tells CPU to refetch instruction */
  4   186       3 its bit (1),				/* ITS modification */
  4   187       3 if bit (1),					/* fault occured during instruction fetch */
  4   188 
  4   189     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
  4   190 
  4   191 
  4   192 /*	WORDS (6,7)	*/
  4   193 
  4   194     2 even_inst bit (36),				/* even instruction of faulting pair */
  4   195 
  4   196     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
  4   197 
  4   198 
  4   199 
  4   200 
  4   201 
  4   202 
  4   203 /*	ALTERNATE   SCU  DECLARATION		*/
  4   204 
  4   205 
  4   206 dcl 1 scux based (scup) aligned,
  4   207 
  4   208    (2 pad0 bit (36),
  4   209 
  4   210     2 fd,						/* GROUP II  FAULT DATA */
  4   211       3 isn bit (1),				/* illegal segment number */
  4   212       3 ioc bit (1),				/* illegal op  code  */
  4   213       3 ia_am bit (1),				/* illegal address - modifier */
  4   214       3 isp bit (1),				/* illegal slave  procedure */
  4   215       3 ipr bit (1),				/* illegal procedure */
  4   216       3 nea bit (1),				/* non existent address */
  4   217       3 oobb bit (1),				/* out of bounds */
  4   218       3 pad bit (29),
  4   219 
  4   220     2 pad2 bit (36),
  4   221 
  4   222     2 pad3a bit (18),
  4   223 
  4   224     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
  4   225       3 prn bit (3),				/* PR  number */
  4   226       3 prv bit (1),				/* PR  valid bit */
  4   227 
  4   228     2 pad3b bit (6)) unaligned,
  4   229 
  4   230     2 pad45 (0:1) bit (36),
  4   231 
  4   232     2 instr (0:1) bit (36);				/* Instruction ARRAY */
  4   233 
  4   234 
  4   235 
  4   236 /*  END INCLUDE FILE   mc.incl.pl1 */
      258 
      259 /* 	*/
      260 print_bseg: entry (arg_print_mode);
      261 
      262 
      263 /*	This entry is called to print the contents of the users break segment.  It will
      264*   *  print the number of breaks that are set for each segment referenced in the break
      265*   *  segment.   It will also clean up the break segment.  This involves deleting any
      266*   *  entries which are no longer valid  or  whose segments have no breaks set.
      267**/
      268 
      269 	print_mode = arg_print_mode;			/* Copy argument. */
      270 
      271 	if break_seg_ptr = null ()			/* Make sure we have a break segment.  */
      272 	then call INIT_BREAK_SEG;
      273 
      274 	do segx = 1 to bseg.num_segs;			/* Process each entry in break segment. */
      275 	     call CHECK_SEGMENT;			/* This will return the segment's break
      276*						   *  map pointer if the segment entry was  OK
      277*						   *  and wasn't deleted.  */
      278 
      279 /*	Was the segment entry deleted.  If so, segx  now refers to the last segment entry.
      280*   *  It just replaced the one we were working on.  Thus segx  must be decremented
      281*   *  so it can reference this same entry again on the next iteration.   However,
      282*   *  if this is the last entry in the array, we must not decrement segx because we want
      283*   *  to get out of the loop since  bseg.num_segs was also decremented when the
      284*   *  segment entry was deleted.
      285**/
      286 	     if delete_seg_entry_flag			/* Was segment entry deleted?  */
      287 	     then do;				/* YES, thus there were no breaks.  */
      288 		if segx <= bseg.num_segs		/* But is it last entry. */
      289 		then segx = segx -1;		/* NO, decrement segment index.  */
      290 		else;				/* YES, lets get out of the loop.  */
      291 	     end;
      292 	     else do;				/* No, there are breaks. */
      293 		if bmap.num_set = 1
      294 		then print_num_breaks = "break ";
      295 		else print_num_breaks = "breaks";
      296 		call ioa_$ioa_stream (debug_output, "^d  ^a  set in  ^a>^a", bmap.num_set, print_num_breaks,
      297 		     bseg.seg (segx).dir_name, bseg.seg (segx).ent_name);
      298 	     end;
      299 	end;					/* We have just processed one segment entry.  */
      300 
      301 /*	The only segment entries left in the break segment array will be those of segments
      302*   *  which have breaks set.  If there are no entries left, then there were no breaks set.
      303**/
      304 	if bseg.num_segs = 0
      305 	then call ioa_$ioa_stream (debug_output, "No breaks set.");
      306 
      307 	return;
      308 						/* 	*/
      309 set_default: entry (arg_seg_ptr);
      310 
      311 
      312 /*	This entry will establish the specified segment as the default segment.  */
      313 
      314 	break_ptr = arg_seg_ptr;			/* Not really a break pointer. */
      315 	call SET_DEFAULTS;
      316 
      317 	return;
      318 
      319 
      320 
      321 
      322 
      323 
      324 print_default: entry;
      325 
      326 
      327 /*	This entry is called to print the name of the default segment.
      328**/
      329 
      330 	break_num = 1;				/* Set dummy break number. */
      331 	call CHECK_DEFAULT;
      332 
      333 	call ioa_$ioa_stream (debug_output, "Default segment is  ^a>^a",
      334 	     bseg.seg (segx).dir_name, bseg.seg (segx).ent_name);
      335 
      336 	return;
      337 						/* 	*/
      338 check_break: entry (arg_break_ptr, arg_break_num, arg_snt_ptr, arg_cond_flag, arg_num_skips,
      339 	     arg_comd_len, arg_comd_ptr, arg_line_no);
      340 
      341 
      342 /*	This entry returns data about the specified break.  Especially important is the
      343*   *  condition flag which tells whether or not a conditional break has been satisfied
      344*   *  0  => either this is not a conditional break or condition has been satisfied,
      345*   *  1  => conditional break and condition has not been satisfied.
      346**/
      347 
      348 	break_ptr = arg_break_ptr;			/* Copy arguments. */
      349 	break_num = arg_break_num;
      350 	snt_ptr = arg_snt_ptr;
      351 
      352 	call SET_DEFAULTS;				/* Establish this segment as the default segment. */
      353 
      354 	call CHECK_BREAK_NUM;			/* Validate the break number. */
      355 
      356 /*	Now set the condition flag.  If the length of the condition data is zero, then we
      357*   *  know that this is not a conditional break and we can set the condition flag to
      358*   *  zero.  If this is a conditional break, then we must call out to a procedure that
      359*   *  understands the condition data semantics so it can determaine if the condition
      360*   *  has been met.
      361**/
      362 	arg_num_skips = break_slot.skip_count;		/* no. of times to skip this break */
      363 
      364 	if arg_num_skips > 0
      365 	then do;
      366 	     cond_flag = 0;				/* Ignore condition because break will be skiped */
      367 	     break_slot.skip_count = break_slot.skip_count - 1;
      368 	end;
      369 
      370 	else if break_slot.cond_len = 0		/* Is this a conditional break? */
      371 	then cond_flag = 0;				/* NO. */
      372 	else call db_parse_condition$check (break_map_ptr, addr (break_slot.cond_data),
      373 	     snt_ptr, cond_flag);
      374 
      375 	arg_cond_flag = cond_flag;			/* Return info about break. */
      376 	arg_comd_len = break_slot.comd_len;
      377 	arg_comd_ptr = addr (break_slot.comd_line);
      378 	arg_line_no = break_slot.line_no;
      379 
      380 	return;					/* The end of the  check_break  entry.  */
      381 						/* 	*/
      382 set_break: entry (arg_break_ptr, arg_type, arg_snt_ptr, arg_print_mode);
      383 
      384 
      385 /*	This entry is called to set a break.  Unless it is a  disabled  break, the word
      386*   *  referenced by  break_ptr will be set up to take a fault when executed.
      387**/
      388 
      389 	break_ptr = arg_break_ptr;			/* Copy arguments. */
      390 	type = arg_type;
      391 	snt_ptr = arg_snt_ptr;
      392 	print_mode = arg_print_mode;
      393 
      394 	call SET_DEFAULTS;				/* Set up this segment as the default segment. */
      395 
      396 /*	Now we know that we have pointers to the break map of the default segment and
      397*   *  to the user's break segment.  Next, we will look for a free slot in the break map
      398*   *  where we can put this new break.  If no slots are available, we will try to allocate
      399*   *  some.
      400**/
      401 	break_offset = fixed (rel (break_ptr));		/* Get word offset of where the break is to go.
      402*						   *  This is used to identify the break. */
      403 
      404 	new_bnum = -1;				/* Initialize the new break number to indicate that
      405*						   *  we don't have a slot for the break yet. */
      406 
      407 	do break_num = 1 to bmap.num_slots;		/* Search through all the break slots in
      408*						   *  this break map.  */
      409 	     call GET_BREAK_SLOT_PTR;			/* Get pointer to this slot. */
      410 	     if break_slot.type = -1			/* Is this break slot free? */
      411 	     then if new_bnum = -1			/* YES, but is it the first free slot? */
      412 		then new_bnum = break_num;		/* YES, this is the slot we will use.  */
      413 		else;
      414 
      415 /*	NO, this slot is not free.  There is a break set in it.  See if it is the break
      416*   *  we are trying to set now.   If it is a temporary break, we still want to set it.
      417**/
      418 	     else if break_slot.offset = break_offset
      419 	     then do;				/* This is the break we are trying to set. */
      420 		if (break_slot.type ^= 1) &
      421 		(break_slot.type ^= 3)
      422 		then do;				/* This is not a temporary break. */
      423 		     call ioa_$ioa_stream (debug_output, "Break ^d already set at ^p", break_num, break_ptr);
      424 		     return;
      425 		end;
      426 		new_bnum = break_num;		/* Temp break. Use this slot. Restore inst. */
      427 		break_ptr -> based_word = break_slot.old_word;
      428 	     end;
      429 	end;					/* We have just checked one break slot in the map. */
      430 
      431 	if new_bnum = -1				/* Did we find a free break slot? */
      432 	then do;					/* No, try to allocate more slots. */
      433 	     call db_break_map$get_slots (break_map_ptr);
      434 	     if break_map_ptr = null ()		/* Did we get more slots? */
      435 	     then do;				/* NO. */
      436 		call ioa_$ioa_stream (debug_output, "Unable to allocate more break slots in  ^a>^a",
      437 		     bseg.seg (segx).dir_name, bseg.seg (segx).ent_name);
      438 		return;
      439 	     end;
      440 	     new_bnum = bmap.num_set + 1;		/* Get number of first new slot. */
      441 	end;
      442 
      443 /*	Now we have an index to the break slot we will use for this new break.   We
      444*   *  must increment the count of breaks that are set and we must initialize the
      445*   *  break itself.
      446**/
      447 	break_num = new_bnum;			/* Use new break number. */
      448 	bmap.num_set = bmap.num_set + 1;		/* One more break is being set. */
      449 	call GET_BREAK_SLOT_PTR;			/* Get pointer to new break slot. */
      450 
      451 	break_slot.type = type;			/* Now fill in the break slot. */
      452 	break_slot.offset = break_offset;
      453 	break_slot.old_word = break_ptr -> based_word;
      454 
      455 /*	Get the line number associated with the location (if possible). */
      456 
      457 	call db_line_no (snt_ptr, fixed (rel (break_ptr), 18), i, j, break_slot.line_no);
      458 
      459 /*	Get the number of words used by this instruction.  If there are more
      460*   *  than  one, this is an EIS instruction.
      461**/
      462 	break_slot.num_words = op_mnemonic_$op_mnemonic (fixed (break_ptr -> instr.opcode, 17)).num_words;
      463 
      464 /*	Initially there are no skips set, there is no command to execute, and there is
      465*   *  no condition set.
      466**/
      467 	break_slot.reserved (*),
      468 	     break_slot.skip_count,
      469 	     break_slot.comd_len,
      470 	     break_slot.cond_len = 0;
      471 
      472 	call LIST;				/* Tell user that break is set. */
      473 
      474 	if type < 2				/* Is break a disabled type? */
      475 	then do;					/* No, set break. */
      476 	     mme2.break_num = break_num;		/* Connect mme2 to break slot via break index. */
      477 	     break_ptr -> mme2_map = mme2;		/* Move mme2 into break location. */
      478 	end;
      479 
      480 	return;					/* This is the end of the  set_break  entry.  */
      481 						/* 	*/
      482 set_skips: entry (arg_break_num, arg_num_skips);
      483 
      484 
      485 /*	This entry is called to set the skip count in the specified break of the
      486*   *  default segment.
      487**/
      488 
      489 	break_num = arg_break_num;			/* Copy argument. */
      490 
      491 	call CHECK_DEFAULT;				/* Make sure default segment set up
      492*						   *  and break number valid.  */
      493 	break_slot.skip_count = arg_num_skips;
      494 
      495 	return;
      496 						/* 	*/
      497 restart:	entry (arg_break_ptr, arg_break_num, arg_num_skips, arg_scu_ptr, arg_print_mode);
      498 
      499 /*	This entry is called to restart a break.  To do this we must modify the SCU
      500*   *  data in the stack frame of the debug break handler.  When the break handler
      501*   *  returns, the instruction that was replaced by the  mme2  will be executed.
      502**/
      503 
      504 	break_ptr = arg_break_ptr;			/* Copy some arguments. */
      505 	break_num = arg_break_num;
      506 	scup = arg_scu_ptr;
      507 	print_mode = arg_print_mode;
      508 
      509 	if break_ptr -> mme2_map.op_code ^= mme2.op_code /* Break has alredy been reset */
      510 	then scup -> scu.even_inst = break_ptr -> based_word;
      511 
      512 	else do;					/* Break is still set. */
      513 	     call SET_DEFAULTS;
      514 	     call CHECK_BREAK_NUM;			/* Make sure it is still valid. */
      515 	     scup -> scu.even_inst = break_slot.old_word;
      516 
      517 	     if break_slot.type = 1			/* Is this a temporary break? */
      518 
      519 	     then call RESET;			/* Temporary break */
      520 	     else do;				/* Regular break */
      521 
      522 		if arg_num_skips >= 0 then break_slot.skip_count = arg_num_skips - 1;
      523 		if break_slot.num_words > 1		/* EIS instruction */
      524 		& bmap.version = "ver3"
      525 
      526 		then do;
      527 		     inst_ptr = addrel (break_ptr, break_slot.num_words);
      528 		     bmap.eis.mme2_indw = rel (break_ptr);
      529 		     bmap.eis.inst_indw = rel (inst_ptr);
      530 		     bmap.eis.mme2 = break_ptr -> based_word;
      531 		     bmap.eis.inst = inst_ptr -> based_word;
      532 		     break_ptr -> based_word = break_slot.old_word;
      533 		     inst_ptr -> based_word = bmap.eis.tra;
      534 		end;
      535 	     end;
      536 	end;
      537 
      538 	scup -> scu.apu.xsf = "0"b;			/* These fields must be zero. */
      539 	addr (scup -> scu.word3) -> based_word = "0"b;
      540 	scup -> scu.cu.its = "0"b;
      541 
      542 /*  If a break has just been set in the following word (.ct request or by the < request), the
      543*   odd instruction will have to be set since it has already been fetched.
      544**/
      545 
      546 	break_ptr = addrel (break_ptr, 1);
      547 	if break_ptr -> mme2_map.op_code = mme2.op_code
      548 	then scup -> scu.odd_inst = break_ptr -> based_word;
      549 
      550 	return;					/* This is the end of the  restart  entry.  */
      551 						/* 	*/
      552 single:	entry (arg_break_num, arg_action_code, arg_line_len, arg_line, arg_print_mode);
      553 
      554 
      555 /*	This entry is called to perform an action on ONE break that is assumed to
      556*   *  be in the default segment.
      557**/
      558 
      559 	break_num = arg_break_num;			/* Copy arguments. */
      560 	action_code = arg_action_code;
      561 	line_len = arg_line_len;
      562 	print_mode = arg_print_mode;
      563 
      564 	call CHECK_DEFAULT;				/* Make sure everything is OK.  */
      565 
      566 	if break_slot.type ^= -1			/* Is break really set? */
      567 	then call DO_ACTION;			/* YES, go perform action on this break. */
      568 	else call ioa_$ioa_stream (debug_output, "Break  ^d  not set.", break_num);
      569 
      570 	return;
      571 						/* 	*/
      572 sub_global: entry (arg_action_code, arg_line_len, arg_line, arg_print_mode);
      573 
      574 
      575 /*	This entry is called to perform an action on all of the breaks set in the
      576*   *  DEFAULT SEGMENT.
      577**/
      578 	action_flag = "0"b;				/* Initialize flag. */
      579 	action_code = arg_action_code;		/* Copy arguments. */
      580 	line_len = arg_line_len;
      581 	print_mode = arg_print_mode;
      582 	break_num = 1;				/* Set up dummy break number. */
      583 	call CHECK_DEFAULT;
      584 
      585 /*	If there are no breaks set in this segment, we will delete its break map.
      586*   *  This will also delete this segment's entry in the break segment array.
      587**/
      588 	if bmap.num_set = 0				/* Any breaks set? */
      589 	then do;					/* NO. */
      590 	     call DELETE_BMAP;
      591 	     call ioa_$ioa_stream (debug_output, "No breaks set.");
      592 	     return;
      593 	end;
      594 
      595 /*	There are breaks set in the default segment.  We have to look at all of the slots
      596*   *  in this segments break map.  We will perform the specified action on all of the
      597*   *  breaks that are found.
      598**/
      599 	do break_num = 1 to bmap.num_slots while (break_map_ptr ^= null ());
      600 	     call GET_BREAK_SLOT_PTR;
      601 	     if break_slot.type ^= -1			/* Is there a break in this slot? */
      602 	     then call DO_ACTION;			/* YES. */
      603 	end;
      604 
      605 	if ^action_flag
      606 	then call ioa_$ioa_stream (debug_output, "No breaks set.");
      607 
      608 	return;					/* End of  sub_global  entry.  */
      609 						/* 	*/
      610 global:	entry (arg_action_code, arg_line_len, arg_line, arg_print_mode);
      611 
      612 
      613 /*	This entry is called to perform a specified action an all of the breaks the user
      614*   *  has in  ALL  of the segments referenced by his break segment.
      615**/
      616 
      617 	action_flag = "0"b;				/* Initialize flag. */
      618 	action_code = arg_action_code;		/* Copy arguments. */
      619 	line_len = arg_line_len;
      620 	print_mode = arg_print_mode;
      621 
      622 	if break_seg_ptr = null ()			/* Make sure we have a break segment. */
      623 	then call INIT_BREAK_SEG;			/* We don't care about any default segment. */
      624 
      625 	if bseg.num_segs > 0 then do;			/* Breaks are set */
      626 	     segx = 1;
      627 	     do while (segx <= bseg.num_segs);		/* Process all segments in user's break segment.
      628*						   *  If not, the segment entry will be deleted
      629*						   *  and  delete_seg_entry_flag  will be ON.  */
      630 		call CHECK_SEGMENT;
      631 
      632 		if ^ delete_seg_entry_flag then do;	/*  Segment not deleted;  at least one break */
      633 
      634 		     do break_num = 1 to bmap.num_slots while (break_map_ptr ^= null ());
      635 			call GET_BREAK_SLOT_PTR;
      636 			if break_slot.type ^= -1 then call DO_ACTION;
      637 		     end;
      638 		     if ^delete_seg_entry_flag then segx = segx + 1;
      639 		end;
      640 	     end;
      641 	end;
      642 
      643 	if ^action_flag then call ioa_$ioa_stream (debug_output, "No breaks set.");
      644 
      645 	return;					/* The end of the  global  entry.  */
      646 						/* 	*/
      647 SET_DEFAULTS: procedure;
      648 
      649 
      650 /*	This procedure establishes the segment with the break as the default segment.
      651*   *  It also makes sure that we have a break segment to work with - it sets up  the
      652*   *  pointer to the break segment.  The default segment index references this segment's
      653*   *  entry in the user's break segment and the default break map pointer references the
      654*   *  break map in this segment.  The entry for this segment in the user's break segment
      655*   *  is initialized.  If none exists, one will be created.
      656**/
      657 
      658 	     if break_seg_ptr = null ()		/* Has the break segment been set up? */
      659 	     then call INIT_BREAK_SEG;		/* No, do it now. */
      660 
      661 /*	Get the name of the new default segment.  */
      662 
      663 	     call hcs_$fs_get_path_name (break_ptr, dir_name, (0), ent_name, code);
      664 	     if code ^= 0
      665 	     then goto SET_DEF_ERR;
      666 
      667 
      668 /*	Get the bit count and the  uid  of this segment.  Note, if the path name is for
      669*   *  a link, then we will chase the link, and get the status of the branch itself.
      670**/
      671 	     call hcs_$status_long (dir_name, ent_name, 1b, addr (branch), null (), code);
      672 	     if code ^= 0
      673 	     then goto SET_DEF_ERR;
      674 
      675 
      676 /*	Now get the pointer to the break map for this segment.  If no break map exists, it
      677*   *  will be created.
      678**/
      679 	     call db_break_map$init (break_ptr, fixed (branch.bitcnt, 24), break_map_ptr);
      680 	     if break_map_ptr = null () | break_ptr = null then do;
      681 		arg_break_ptr = null;
      682 		goto RETURN_FROM_DB_BREAK;
      683 	     end;
      684 
      685 /*	Now we must find the entry in the break segment which corresponds to the new
      686*   *  default segment.  If there is no entry for this segment, then one will be created.
      687*   *  Note, the search through the break segment entries is done for  uid's  and not
      688*   *  for path names since they may have been changed.
      689**/
      690 	     do segx = 1 to bseg.num_segs;
      691 		if bseg.seg (segx).uid = branch.uid
      692 		then goto SET_DEF_SEG_FOUND;
      693 	     end;
      694 
      695 
      696 /*	This break segment doesn't contain an entry for the dafault segment.  Thus we
      697*   *  will create one.
      698**/
      699 	     call set_break_seg_bc (segx, "0"b);
      700 
      701 	     bseg.num_segs = segx;			/* Up count of segments. */
      702 	     bseg.seg (segx).uid = branch.uid;		/* This relates the entry to the segment.  */
      703 
      704 
      705 /*	Now that we know the index of the break segment entry for the default segment we
      706*   *  can fill in the names of the segment.  These must be reset each time the segment
      707*   *  is established as the default segment.
      708**/
      709 
      710 SET_DEF_SEG_FOUND:
      711 
      712 	     bseg.seg (segx).dir_name = dir_name;
      713 	     bseg.seg (segx).ent_name = ent_name;
      714 
      715 	     def_break_map_ptr = break_map_ptr;		/* Set up default break map pointer. */
      716 	     def_segx = segx;			/* Set up default segment index. */
      717 
      718 	     return;
      719 
      720 
      721 SET_DEF_ERR:
      722 
      723 	     call com_err_ (code, "debug", "Cannot make  ^p  the default break segment.", break_ptr);
      724 	     goto RETURN_FROM_DB_BREAK;		/* Transfer out of this internal procedure and
      725*						   *  return directly to the caller of db_break. */
      726 
      727 	end SET_DEFAULTS;
      728 						/* 	*/
      729 CHECK_DEFAULT: procedure;
      730 
      731 
      732 /*	This internal procedure checks to see if there is a default segment established.
      733*   *  If not, there is an error.  It will also check to see if the break number passed
      734*   *  as an argument is valid for this segment.  If everything is OK, it will copy the
      735*   *  default variables, which are in internal static, and the break number, which is an
      736*   *  argument, into automatic variables.
      737**/
      738 
      739 	     if def_segx = 0			/* Has default segment been established?  */
      740 	     then do;				/* NO, error.  */
      741 		call ioa_$ioa_stream (debug_output, "No default break segment.");
      742 		goto RETURN_FROM_DB_BREAK;
      743 	     end;
      744 
      745 	     break_map_ptr = def_break_map_ptr;		/* Copy default variables. */
      746 	     segx = def_segx;
      747 
      748 	     call VALIDATE_BREAK_NUM;			/* Check boonds of break number. */
      749 	     call GET_BREAK_SLOT_PTR;			/* Get pointer to its break slot. */
      750 
      751 
      752 	end CHECK_DEFAULT;
      753 						/* 	*/
      754 CHECK_BREAK_NUM: procedure;
      755 
      756 
      757 /*	This internal procedure is called to perform special validation on the break number.
      758*   *  It checks to see if the break number is within valid bounds and it also checks to
      759*   *  see that the specified breakis enabled.  If the break number is valid,
      760*   *  it sets up the break slot pointer to point to the break slot associated
      761*   *  with this break number.
      762**/
      763 
      764 	     call VALIDATE_BREAK_NUM;			/* Check bounds of break number. */
      765 
      766 	     call GET_BREAK_SLOT_PTR;			/* Get pointer to this break's slot. */
      767 	     if (break_slot.type = -1) |		/* Is break not set? */
      768 	     (break_slot.type > 1)			/* Or is break disabled? */
      769 	     then do;				/* Yes, break not enabled. */
      770 		call ioa_$ioa_stream (debug_output, "Break  ^d  should be enabled but isn't.  Segment must be recompiled.", break_num);
      771 		arg_break_ptr = null;
      772 		goto RETURN_FROM_DB_BREAK;
      773 	     end;
      774 
      775 
      776 	end CHECK_BREAK_NUM;
      777 						/* 	*/
      778 VALIDATE_BREAK_NUM: procedure;
      779 
      780 
      781 /*	This procedure is called to check that the current break number is
      782*   *  within valid bounds for the current default segment.
      783**/
      784 
      785 	     if (break_num <= 0) |			/* Is break number within bounds. */
      786 	     (break_num > bmap.num_slots)
      787 	     then do;				/* No, outside bounds of break map. */
      788 		call ioa_$ioa_stream (debug_output, "Illegal break number  ^d  for segment  ^a>^a",
      789 		     break_num, bseg.seg (segx).dir_name, bseg.seg (segx).ent_name);
      790 		goto RETURN_FROM_DB_BREAK;
      791 	     end;
      792 
      793 	end VALIDATE_BREAK_NUM;
      794 						/* 	*/
      795 CHECK_SEGMENT: procedure;
      796 
      797 
      798 /*	This procedure is called to get the break map of a segment and to validate the
      799*   *  fact that the segment has breaks set.  The first thing that we must do is to
      800*   *  initiate this segment so we can get a pointer to it and get its bit count.
      801*   *  If any of the following four conditions occur, we will delete this entry in
      802*   *  the break segment:
      803*   *  1.  The segment does not exist.
      804*   *  2.  The uid of the segment doesn't match the uid in the break segment entry.
      805*   *      This implies that the name of the segment was changed and a new
      806*   *      segment was created with its old name.
      807*   *  3.  There is no break map for this segment; => it has no breaks.
      808*   *  4.  There is a break map, but there are no breaks set.
      809*   *  If the segment entry is deleted and there is a break map, the break map will
      810*   *  also be deleted.  If for any of the above reasons the segment entry is deleted
      811*   *  the  delete_seg_entry_flag  will be turned  ON.
      812**/
      813 	     delete_seg_entry_flag = "0"b;		/* Assume seg entry OK. */
      814 
      815 	     call hcs_$initiate_count (bseg.seg (segx).dir_name, bseg.seg (segx).ent_name,
      816 		"", bit_count, 0, seg_ptr, code);
      817 	     if seg_ptr = null ()			/* Does segment exist? */
      818 	     then do;				/* NO. */
      819 		call DELETE_SEG_ENTRY;
      820 		return;
      821 	     end;
      822 
      823 	     call hcs_$status_long (bseg.seg (segx).dir_name, bseg.seg (segx).ent_name, 1b,
      824 		addr (branch), null (), code);
      825 	     if bseg.seg (segx).uid ^= branch.uid	/* Is it realy the same segment?  */
      826 	     then do;				/* NO. */
      827 		call ioa_$ioa_stream (debug_output, "Path name  ^a>^a  now references new segment.",
      828 		     bseg.seg (segx).dir_name, bseg.seg (segx).ent_name);
      829 		call DELETE_SEG_ENTRY;
      830 		return;
      831 	     end;
      832 
      833 	     call db_break_map$check (seg_ptr, bit_count, break_map_ptr);
      834 	     if seg_ptr = null then return;		/* error return for illegal break format */
      835 
      836 	     if break_map_ptr = null ()		/* Does it have a break map?  */
      837 	     then do;				/* NO. */
      838 		if print_mode = 1			/* Only print this message in LONG mode. */
      839 		then call ioa_$ioa_stream (debug_output, "^a>^a has no break map.", bseg.seg (segx).dir_name,
      840 		     bseg.seg (segx).ent_name);
      841 		call DELETE_SEG_ENTRY;
      842 		return;
      843 	     end;
      844 
      845 /*	This segment has a break map.  Does it have any breaks set?  If not, we will
      846*   *  delete its break map.  This will also result in deleteing its segment entry.
      847**/
      848 	     if bmap.num_set = 0			/* Does it have any breaks set? */
      849 	     then do;				/* NO. */
      850 		call DELETE_BMAP;
      851 		return;
      852 	     end;
      853 
      854 	end CHECK_SEGMENT;
      855 						/* 	*/
      856 GET_BREAK_SLOT_PTR: procedure;
      857 
      858 
      859 /*	This internal procedure is called to get a pointer to the break slot
      860*   *  referenced by "break_num".  Temporarily, there are two versionb of
      861*   *  the break_map_header.  This procedure must decide which version is being used.
      862**/
      863 
      864 	     break_slot_ptr = addr (bmap.breaks (break_num));
      865 
      866 
      867 	end GET_BREAK_SLOT_PTR;
      868 						/* 	*/
      869 INIT_BREAK_SEG: procedure;
      870 
      871 
      872 /*	This procedure is called to get a pointer to the user's break segment in his
      873*   *  home directory.  The pointer is set in  "break_seg_ptr" which is in internal
      874*   *  static.  If no break segment exists for this user, then one will be created.
      875**/
      876 
      877 	     call user_info_$homedir (dir_name);	/* Get the name of the user's
      878*						   *  home directory.  */
      879 
      880 	     call user_info_ (ent_name);		/* Get the user's login name.
      881*						   *  Note, it is a max of 24 chars.  */
      882 
      883 	     i = index (ent_name, " ");		/* Get index of first blank. */
      884 	     substr (ent_name, i, 7) = ".breaks";	/* Add debug suffix.  */
      885 
      886 
      887 /*	The following call will get a pointer to the segment.  If none exists, it will
      888*   *  create the segment.  In any case, there is an error only if we don't get a
      889*   *  valid pointer back.  We don't use a reference name and we want RWA access to
      890*   *  the segment.
      891**/
      892 	     call hcs_$make_seg (dir_name, ent_name, "", 01011b, break_seg_ptr, code);
      893 	     if break_seg_ptr = null ()
      894 	     then do;
      895 		call com_err_ (code, "debug", "^a>^a", dir_name, ent_name);
      896 		goto RETURN_FROM_DB_BREAK;
      897 	     end;
      898 
      899 
      900 	end INIT_BREAK_SEG;
      901 						/* 	*/
      902 DO_ACTION: procedure;
      903 
      904 
      905 /*	This internal procedure acts as a transfer vector.  It calls the  db_break
      906*   *  procedure which will perform the specified action.  The action code
      907*   *  indicates the type of action.  The action flag is turned on in order to
      908*   *  indicate that the action has been performed for at least one break.
      909**/
      910 
      911 	     action_flag = "1"b;
      912 
      913 	     goto ACTION_LABEL (action_code);		/* Go to specified call.  */
      914 
      915 
      916 ACTION_LABEL (1):					/* LIST a break. */
      917 	     call LIST;
      918 	     return;
      919 
      920 
      921 
      922 ACTION_LABEL (2):					/* RESET a break. */
      923 	     call RESET;
      924 	     return;
      925 
      926 
      927 ACTION_LABEL (3):					/* DISABLE a break. */
      928 	     call DISABLE;
      929 	     return;
      930 
      931 
      932 ACTION_LABEL (4):					/* ENABLE a break. */
      933 	     call ENABLE;
      934 	     return;
      935 
      936 
      937 ACTION_LABEL (5):					/* Set a COMMAND in a break. */
      938 	     call SET_COMMAND;
      939 	     return;
      940 
      941 
      942 ACTION_LABEL (6):					/* Set a CONDITION in a break. */
      943 	     call SET_CONDITION;
      944 
      945 
      946 	end DO_ACTION;
      947 						/* 	*/
      948 LIST:	procedure;
      949 
      950 
      951 /*	This procedure is called to print the contents of one break.  The print_mode flag
      952*   *  determines the mode of printing.  There are two modes:
      953*   *  SHORT	(print_mode = 0)	Print as little as possible.
      954*   *  LONG	(print_mode = 1)	Print as  much  as possible.
      955**/
      956 
      957 dcl  line_info char (14) aligned;			/* Char representation of line num. (if available) */
      958 
      959 
      960 	     if break_slot.line_no > 0
      961 	     then call ioa_$rsnnl (" (line ^d)", line_info, j, break_slot.line_no);
      962 	     else line_info = "";
      963 
      964 /*	Print  short mode  information first.  */
      965 
      966 	     call ioa_$ioa_stream (debug_output, "^a   ^d  set at  ^a|^o^a",
      967 		break_type_name (break_slot.type), break_num,
      968 		bseg.seg (segx).ent_name, break_slot.offset, line_info);
      969 
      970 	     if print_mode = 0			/* If short mode, that's all. */
      971 	     then return;
      972 
      973 /*	Now we must print the long mode data.  First print the instruction where the
      974*   *  break is.
      975**/
      976 	     call print_text_$real_offset (addr (break_slot.old_word), source_string, break_slot.offset);
      977 	     call ioa_$ioa_stream (debug_output, "^-At instruction:  ^a", source_string);
      978 
      979 /*	Now print the command line and the condition line if they exist.  */
      980 
      981 	     if break_slot.comd_len ^= 0
      982 	     then call ioa_$ioa_stream (debug_output, "Command  =  ^a", substr (break_slot.comd_line, 1, break_slot.comd_len));
      983 
      984 	     if break_slot.cond_len ^= 0		/* Is there a condition line? */
      985 	     then do;				/* Yes, call routine that knows condition format. */
      986 		call db_parse_condition$print_line (addr (break_slot.cond_data), source_string);
      987 		call ioa_$ioa_stream (debug_output, "Condition = ^a", source_string);
      988 	     end;
      989 
      990 
      991 	end LIST;
      992 						/* 	*/
      993 RESET:	procedure;
      994 
      995 
      996 /*	This procedure is called to reset a break.  Resetting a break involves
      997*   *  removing the  mme2  instruction from the break word and freeing the break slot
      998*   *  used by the break.  When the last break in a segment is reset, its
      999*   *  break map will be deleted.  Also, its entry in the break segment array will
     1000*   *  be deleted.
     1001**/
     1002 
     1003 	     call DISABLE;				/* First disable the  mme2.  */
     1004 
     1005 	     break_slot.type = -1;			/* Now free the break slot.  */
     1006 	     bmap.num_set = bmap.num_set -1;		/* Segment has one less break set.  */
     1007 
     1008 	     if print_mode ^= 0
     1009 	     then call ioa_$ioa_stream (debug_output, "Break ^d at ^a|^o reset.",
     1010 		break_num, bseg.seg (segx).ent_name, break_slot.offset);
     1011 
     1012 /*	Now that the break has been reset, we must check to see if there are any breaks left
     1013*   *  in the segment.  If not, we will delete its break map.
     1014**/
     1015 	     if bmap.num_set = 0			/* Any breaks left in segment? */
     1016 	     then call DELETE_BMAP;			/* NO. */
     1017 
     1018 
     1019 	end RESET;
     1020 						/* 	*/
     1021 DISABLE:	procedure;
     1022 
     1023 /*	This procedure is called to disable a break.   Disabling a break involves
     1024*   *  putting the word that was originally in the break word back into the break word.
     1025*   *  This overlays the  mme2  that is there while the break is enabled.
     1026**/
     1027 
     1028 	     if break_slot.type > 1			/* Is break already disabled? */
     1029 	     then return;				/* YES. */
     1030 
     1031 /*	Get a pointer to the break and set up our own  mme2  word to look like what should
     1032*   *  be in the break word now.
     1033**/
     1034 	     break_word_ptr = ptr (break_map_ptr, break_slot.offset);
     1035 	     mme2.break_num = break_num;
     1036 
     1037 
     1038 /*	Now check to see that this is a valid break.  The break word should contain a
     1039*   *  mme2  instruction with an address equal to this break number.
     1040**/
     1041 	     if break_word_ptr -> based_word ^= addr (mme2) -> based_word
     1042 	     then do;
     1043 		call ioa_$ioa_stream (debug_output, "Break  ^d  at  ^a|^o  is invalid.",
     1044 		     break_num, bseg.seg (segx).ent_name, break_slot.offset);
     1045 		return;
     1046 	     end;
     1047 
     1048 /*	It is a valid break so we disable it now.  */
     1049 
     1050 	     break_word_ptr -> based_word = break_slot.old_word;
     1051 
     1052 
     1053 /*	Now set the type to indicate that this is a disabled break.  Regular breaks
     1054*   *  are now type  2  and temporary breaks are now type 3.
     1055**/
     1056 	     break_slot.type = break_slot.type + 2;
     1057 
     1058 
     1059 	end DISABLE;
     1060 						/* 	*/
     1061 ENABLE:	procedure;
     1062 
     1063 
     1064 /*	This procedure is called to enable a break.  Enabling a break involves simply
     1065*   *  putting a  mme2  instruction the the break word.
     1066**/
     1067 
     1068 	     if break_slot.type < 2			/* Is break already enabled */
     1069 	     then return;				/* YES, don't bother.  */
     1070 
     1071 	     mme2.break_num = break_num;		/* Addr field of mme2 = break num. */
     1072 	     ptr (break_map_ptr, break_slot.offset) -> mme2_map = mme2;
     1073 
     1074 
     1075 /*	Now set the type to indicate that the break is enabled.  If it is a regular
     1076*   *  break it will go from  2 -> 0  and if it is a temporary break if will go from
     1077*   *  3 -> 1.
     1078**/
     1079 	     break_slot.type = break_slot.type - 2;
     1080 
     1081 
     1082 	end ENABLE;
     1083 						/* 	*/
     1084 SET_COMMAND: procedure;
     1085 
     1086 
     1087 /*	This procedure sets up a command in the specified break.
     1088**/
     1089 
     1090 	     break_slot.comd_len = line_len;
     1091 
     1092 	     if line_len ^= 0			/* Is there really a command line?  */
     1093 	     then substr (break_slot.comd_line, 1, line_len) = substr (arg_line, 1, line_len);
     1094 
     1095 
     1096 	end SET_COMMAND;
     1097 
     1098 
     1099 
     1100 
     1101 
     1102 
     1103 SET_CONDITION: procedure;
     1104 
     1105 
     1106 /*	This procedure is called to set or to reset a condition in a break.  The type of
     1107*   *  break is not considered and is not changed.  Only the condition information
     1108*   *  in the break slot is changed.  We must determine if we are to set the condition
     1109*   *  or reset the condition.  If the condition length is zero, we must reset.
     1110**/
     1111 
     1112 	     if line_len = 0			/* Are we to SET or RESET? */
     1113 	     then break_slot.cond_len = 0;		/* RESET - this implies no condition. */
     1114 	     else do;				/* SET condition, there is data.  */
     1115 		break_slot.cond_len = line_len;
     1116 		substr (break_slot.cond_data, 1, line_len) = substr (arg_line, 1, line_len);
     1117 	     end;
     1118 
     1119 
     1120 	end SET_CONDITION;
     1121 						/* 	*/
     1122 DELETE_BMAP: procedure;
     1123 
     1124 
     1125 /*	This procedure is called to delete a beak map from a segment.  This is done
     1126*   *  whenever a segment is referenced which has a break map but does not have any
     1127*   *  breaks set.  This will also result in deleting the segment's entry in
     1128*   *  the break segment array.
     1129**/
     1130 
     1131 	     call db_break_map$delete (break_map_ptr);
     1132 	     break_map_ptr = null;			/* Make sure no attempt is made
     1133*						   *  look at this break map again */
     1134 
     1135 	     call DELETE_SEG_ENTRY;
     1136 
     1137 /*	If this segment is the default segment, we must reset the default segment
     1138*   *  variables to indicate that there is no default segment.
     1139**/
     1140 	     if def_segx = segx			/* Is this the default segment?  */
     1141 	     then def_segx = 0;			/* YES, but no longer.  */
     1142 
     1143 
     1144 	end DELETE_BMAP;
     1145 						/* 	*/
     1146 DELETE_SEG_ENTRY: procedure;
     1147 
     1148 
     1149 /*	This procedure is called to delete an entry in the user's break segment.
     1150*   *  We will move the last entry in the break segment array into the entry
     1151*   *  that is being deleted.  Then we will clear the last entry and decrement
     1152*   *  the count of entries.
     1153**/
     1154 
     1155 /*	Move last entry into the one being deleted.  */
     1156 
     1157 	     break_seg_ptr -> bseg_map.array (segx).entry =
     1158 		break_seg_ptr -> bseg_map.array (bseg.num_segs).entry;
     1159 
     1160 	     bseg.num_segs = bseg.num_segs - 1;		/* Decrement the count of entries. */
     1161 	     delete_seg_entry_flag = "1"b;
     1162 	     call set_break_seg_bc (bseg.num_segs, "1"b);
     1163 
     1164 	end DELETE_SEG_ENTRY;
     1165 
     1166 /*  */
     1167 /*  This procedure sets the bit count on the user's break segment.  It is called when a new segment
     1168*   slot is added or deleted.
     1169**/
     1170 set_break_seg_bc: proc (num_slots, truncate);
     1171 
     1172 dcl  num_slots fixed bin;				/* size the break map will become  */
     1173 dcl  truncate bit (1) unal;				/* truncate the break segment */
     1174 
     1175 dcl 1 break_slot aligned like bseg.seg based;
     1176 dcl  word_count fixed bin (18);
     1177 dcl  size builtin;
     1178 
     1179 	     word_count = size (break_slot) * num_slots + 1;
     1180 	     call hcs_$truncate_seg (break_seg_ptr, word_count, code);
     1181 	     if code = 0 then call hcs_$set_bc_seg (break_seg_ptr, 36 * word_count, code);
     1182 	     if code ^= 0 then call com_err_ (code, "break segment");
     1183 
     1184 	     return;
     1185 
     1186 	end set_break_seg_bc;
     1187 
     1188 /* 	*/
     1189 /*	This statement is part of the main  db_break  block.  It is provided so that
     1190*   *  internal procedures may return directly to the caller of db_break.   Thus the
     1191*   *  db_break  entry which called the internal procedure doesn't have to check for
     1192*   *  error conditions.
     1193**/
     1194 
     1195 RETURN_FROM_DB_BREAK:
     1196 
     1197 	return;
     1198 
     1199 
     1200      end db_break;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/82  1628.3  db_break.pl1                      >dumps>old>recomp>db_break.pl1
125          1    08/12/76  1010.2  db_ext_stat_.incl.pl1             >ldd>include>db_ext_stat_.incl.pl1
246          2    11/06/75  1110.0  db_break_map_map.incl.pl1         >ldd>include>db_break_map_map.incl.pl1
256          3    05/06/74  1741.6  db_inst.incl.pl1                  >ldd>include>db_inst.incl.pl1
258          4    08/12/81  2025.8  mc.incl.pl1                       >ldd>include>mc.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
action_code                     000100 automatic       fixed bin(17,0)          dcl 129 set ref 560* 579* 618* 913
action_flag                     000211 automatic       bit(1)                   unaligned dcl 166 set ref 578* 605 617* 643 911*
addr                                                   builtin function         dcl 222 ref 372 372 377 539 671 671 823 823 864 976
                                                                                  976 986 986 1041
addrel                                                 builtin function         dcl 222 ref 527 546
apu                       0(19)        based           structure                level 2 packed unaligned dcl 4-56
arg_action_code                        parameter       fixed bin(17,0)          dcl 52 ref 552 560 572 579 610 618
arg_break_num                          parameter       fixed bin(17,0)          dcl 52 ref 338 349 482 489 497 505 552 559
arg_break_ptr                          parameter       pointer                  dcl 52 set ref 338 348 382 389 497 504 681* 771*
arg_comd_len                           parameter       fixed bin(17,0)          dcl 52 set ref 338 376*
arg_comd_ptr                           parameter       pointer                  dcl 52 set ref 338 377*
arg_cond_flag                          parameter       fixed bin(17,0)          dcl 52 set ref 338 375*
arg_line                               parameter       char(236)                unaligned dcl 52 ref 552 572 610 1092 1116
arg_line_len                           parameter       fixed bin(17,0)          dcl 52 ref 552 561 572 580 610 619
arg_line_no                            parameter       fixed bin(17,0)          dcl 52 set ref 338 378*
arg_num_skips                          parameter       fixed bin(17,0)          dcl 52 set ref 338 362* 364 482 493 497 522 522
arg_print_mode                         parameter       fixed bin(17,0)          dcl 52 ref 260 269 382 392 497 507 552 562 572 581
                                                                                  610 620
arg_scu_ptr                            parameter       pointer                  dcl 52 ref 497 506
arg_seg_ptr                            parameter       pointer                  dcl 52 ref 309 314
arg_snt_ptr                            parameter       pointer                  dcl 52 ref 338 350 382 391
arg_type                               parameter       fixed bin(17,0)          dcl 52 ref 382 390
array                     1            based           structure                array level 2 dcl 203
based_word                             based           bit(36)                  dcl 217 set ref 427* 453 509 530 531 532* 533* 539*
                                                                                  547 1041 1041 1050*
bit_count                       000251 automatic       fixed bin(24,0)          dcl 179 set ref 815* 833*
bitcnt                    7(12) 000177 automatic       bit(24)                  level 2 packed unaligned dcl 145 set ref 679 679
bmap                                   based           structure                level 1 dcl 2-17
branch                          000177 automatic       structure                level 1 dcl 145 set ref 671 671 823 823
break_map_ptr                   000256 automatic       pointer                  dcl 2-8 set ref 293 296 372* 407 433* 434 440 448
                                                                                  448 523 528 529 530 531 533 588 599 599 634 634
                                                                                  679* 680 715 745* 785 833* 836 848 864 1006 1006
                                                                                  1015 1034 1072 1131* 1132*
break_num                       000016 internal static fixed bin(17,0)          level 2 in structure "mme2" packed unaligned dcl 114
                                                                                  in procedure "db_break" set ref 476* 1035* 1071*
break_num                       000101 automatic       fixed bin(17,0)          dcl 129 in procedure "db_break" set ref 330* 349*
                                                                                  407* 410 423* 426* 447* 476 489* 505* 559* 568*
                                                                                  582* 599* 634* 770* 785 785 788* 864 966* 1008*
                                                                                  1035 1043* 1071
break_offset                    000114 automatic       fixed bin(18,0)          dcl 137 set ref 401* 418 452
break_ptr                       000102 automatic       pointer                  dcl 129 set ref 314* 348* 389* 401 423* 427 453 457
                                                                                  457 462 477 504* 509 509 527 528 530 532 546* 546
                                                                                  547 547 663* 679* 680 721*
break_seg_ptr                   000010 internal static pointer                  initial dcl 100 set ref 271 274 288 296 296 304 333
                                                                                  333 436 436 622 625 627 658 690 691 701 702 710
                                                                                  713 788 788 815 815 823 823 825 827 827 838 838
                                                                                  892* 893 966 1008 1043 1157 1157 1157 1160 1160
                                                                                  1162 1180* 1181*
break_slot                             based           structure                level 1 dcl 2-35 in procedure "db_break" set ref 864
                                                                                  864
break_slot                             based           structure                level 1 dcl 1175 in procedure "set_break_seg_bc" ref
                                                                                  1179
break_slot_ptr                  000260 automatic       pointer                  dcl 2-8 set ref 362 367 367 370 372 372 376 377 378
                                                                                  410 418 420 420 427 451 452 453 457 462 467 467
                                                                                  467 467 493 515 517 522 523 527 532 566 601 636
                                                                                  767 767 864* 864 864 960 960 966 966 976 976 976
                                                                                  981 981 981 981 981 984 986 986 1005 1008 1028
                                                                                  1034 1043 1050 1056 1056 1068 1072 1079 1079 1090
                                                                                  1092 1112 1115 1116
break_type_name                 000020 internal static char(24)                 initial array dcl 120 set ref 966*
break_word_ptr                  000112 automatic       pointer                  dcl 137 set ref 1034* 1041 1050
breaks                   40            based           structure                array level 2 dcl 2-17 set ref 864
bseg                                   based           structure                level 1 dcl 188
bseg_map                               based           structure                level 1 dcl 203
code                            000252 automatic       fixed bin(35,0)          dcl 179 set ref 663* 664 671* 672 721* 815* 823*
                                                                                  892* 895* 1180* 1181 1181* 1182 1182*
com_err_                        000052 constant        entry                    external dcl 224 ref 721 895 1182
comd_len                 10            based           fixed bin(17,0)          level 2 dcl 2-35 set ref 376 467* 981 981 981 1090*
comd_line                11            based           char(128)                level 2 dcl 2-35 set ref 377 981 981 1092*
cond_data                52            based           char(236)                level 2 dcl 2-35 set ref 372 372 986 986 1116*
cond_flag                       000212 automatic       fixed bin(17,0)          dcl 166 set ref 366* 370* 372* 375
cond_len                 51            based           fixed bin(17,0)          level 2 dcl 2-35 set ref 370 467* 984 1112* 1115*
cu                        5(18)        based           structure                level 2 packed unaligned dcl 4-56
db_break_map$check              000054 constant        entry                    external dcl 224 ref 833
db_break_map$delete             000056 constant        entry                    external dcl 224 ref 1131
db_break_map$get_slots          000060 constant        entry                    external dcl 224 ref 433
db_break_map$init               000062 constant        entry                    external dcl 224 ref 679
db_ext_stat_$db_ext_stat_       000050 external static structure                level 1 dcl 1-9
db_line_no                      000064 constant        entry                    external dcl 224 ref 457
db_parse_condition$check        000066 constant        entry                    external dcl 224 ref 372
db_parse_condition$print_line   000070 constant        entry                    external dcl 224 ref 986
debug_output             10     000050 external static char(32)                 level 2 dcl 1-9 set ref 296* 304* 333* 423* 436*
                                                                                  568* 591* 605* 643* 741* 770* 788* 827* 838* 966*
                                                                                  977* 981* 987* 1008* 1043*
def_break_map_ptr               000014 internal static pointer                  dcl 109 set ref 715* 745
def_segx                        000012 internal static fixed bin(17,0)          initial dcl 109 set ref 716* 739 746 1140 1140*
delete_seg_entry_flag           000213 automatic       bit(1)                   unaligned dcl 166 set ref 286 632 638 813* 1161*
dir_name                        000115 automatic       char(168)                unaligned dcl 140 in procedure "db_break" set ref
                                                                                  663* 671* 710 877* 892* 895*
dir_name                  2            based           char(168)                array level 3 in structure "bseg" packed unaligned
                                                                                  dcl 188 in procedure "db_break" set ref 296* 333*
                                                                                  436* 710* 788* 815* 823* 827* 838*
eis                       4            based           structure                level 2 dcl 2-17
ent_name                 54            based           char(32)                 array level 3 in structure "bseg" packed unaligned
                                                                                  dcl 188 in procedure "db_break" set ref 296* 333*
                                                                                  436* 713* 788* 815* 823* 827* 838* 966* 1008*
                                                                                  1043*
ent_name                        000167 automatic       char(32)                 unaligned dcl 140 in procedure "db_break" set ref
                                                                                  663* 671* 713 880* 883 884* 892* 895*
entry                     1            based           char(204)                array level 3 dcl 203 set ref 1157* 1157
even_inst                 6            based           bit(36)                  level 2 dcl 4-56 set ref 509* 515*
fixed                                                  builtin function         dcl 222 ref 401 457 457 462 679 679
hcs_$fs_get_path_name           000072 constant        entry                    external dcl 224 ref 663
hcs_$initiate_count             000074 constant        entry                    external dcl 224 ref 815
hcs_$make_seg                   000076 constant        entry                    external dcl 224 ref 892
hcs_$set_bc_seg                 000100 constant        entry                    external dcl 224 ref 1181
hcs_$status_long                000102 constant        entry                    external dcl 224 ref 671 823
hcs_$truncate_seg               000104 constant        entry                    external dcl 224 ref 1180
i                               000253 automatic       fixed bin(17,0)          dcl 179 set ref 457* 883* 884
index                                                  builtin function         dcl 222 ref 883
inst                     22            based           bit(36)                  level 3 dcl 2-17 set ref 531*
inst_indw                17            based           bit(18)                  level 3 dcl 2-17 set ref 529*
inst_ptr                        000214 automatic       pointer                  dcl 166 set ref 527* 529 531 533
instr                                  based           structure                level 1 dcl 3-13
ioa_$ioa_stream                 000106 constant        entry                    external dcl 224 ref 296 304 333 423 436 568 591 605
                                                                                  643 741 770 788 827 838 966 977 981 987 1008 1043
ioa_$rsnnl                      000110 constant        entry                    external dcl 224 ref 960
its                       5(28)        based           bit(1)                   level 3 packed unaligned dcl 4-56 set ref 540*
j                               000254 automatic       fixed bin(17,0)          dcl 179 set ref 457* 960*
line_info                       000376 automatic       char(14)                 dcl 957 set ref 960* 962* 966*
line_len                        000104 automatic       fixed bin(17,0)          dcl 129 set ref 561* 580* 619* 1090 1092 1092 1092
                                                                                  1112 1115 1116 1116
line_no                   4            based           fixed bin(17,0)          level 2 dcl 2-35 set ref 378 457* 960 960*
mme2                     21            based           bit(36)                  level 3 in structure "bmap" dcl 2-17 in procedure
                                                                                  "db_break" set ref 530*
mme2                            000016 internal static structure                level 1 dcl 114 in procedure "db_break" set ref 477
                                                                                  1041 1072
mme2_indw                16            based           bit(18)                  level 3 dcl 2-17 set ref 528*
mme2_map                               based           structure                level 1 dcl 211 set ref 477* 1072*
new_bnum                        000216 automatic       fixed bin(17,0)          dcl 166 set ref 404* 410 410* 426* 431 440* 447
null                                                   builtin function         dcl 222 ref 271 434 599 622 634 658 671 671 680 680
                                                                                  681 771 817 823 823 834 836 893 1132
num_segs                               based           fixed bin(17,0)          level 2 dcl 188 set ref 274 288 304 625 627 690 701*
                                                                                  1157 1160* 1160 1162*
num_set                   1            based           fixed bin(17,0)          level 2 dcl 2-17 set ref 293 296* 440 448* 448 588
                                                                                  848 1006* 1006 1015
num_slots                              based           fixed bin(17,0)          level 2 in structure "bmap" dcl 2-17 in procedure
                                                                                  "db_break" ref 407 599 634 785
num_slots                              parameter       fixed bin(17,0)          dcl 1172 in procedure "set_break_seg_bc" ref 1170
                                                                                  1179
num_words                 5            based           fixed bin(17,0)          level 2 in structure "break_slot" dcl 2-35
                                                                                  in procedure "db_break" set ref 462* 523 527
num_words                 1(27) 000120 external static fixed bin(8,0)           array level 2 in structure
                                                                                  "op_mnemonic_$op_mnemonic" packed unaligned
                                                                                  dcl 248 in procedure "db_break" ref 462
odd_inst                  7            based           bit(36)                  level 2 dcl 4-56 set ref 547*
offset                    1            based           fixed bin(18,0)          level 2 dcl 2-35 set ref 418 452* 966* 976* 1008*
                                                                                  1034 1043* 1072
old_word                  2            based           bit(36)                  level 2 dcl 2-35 set ref 427 453* 515 532 976 976
                                                                                  1050
op_code                   0(18) 000016 internal static bit(36)                  initial level 2 in structure "mme2" packed unaligned
                                                                                  dcl 114 in procedure "db_break" set ref 509 547
op_code                   0(18)        based           bit(18)                  level 2 in structure "mme2_map" packed unaligned
                                                                                  dcl 211 in procedure "db_break" set ref 509 547
op_mnemonic_$op_mnemonic        000120 external static structure                array level 1 dcl 248
opcode                    0(18)        based           bit(10)                  level 2 packed unaligned dcl 3-13 ref 462
print_mode                      000105 automatic       fixed bin(17,0)          dcl 129 set ref 269* 392* 507* 562* 581* 620* 838
                                                                                  970 1008
print_num_breaks                000224 automatic       char(6)                  unaligned dcl 176 set ref 293* 295* 296*
print_text_$real_offset         000114 constant        entry                    external dcl 224 ref 976
ptr                                                    builtin function         dcl 222 ref 1034 1072
rel                                                    builtin function         dcl 222 ref 401 457 457 528 529
reserved                  6            based           fixed bin(17,0)          array level 2 dcl 2-35 set ref 467*
scu                                    based           structure                level 1 dcl 4-56
scup                            000262 automatic       pointer                  dcl 4-54 set ref 506* 509 515 538 539 540 547
seg                       1            based           structure                array level 2 dcl 188
seg_ptr                         000220 automatic       pointer                  dcl 166 set ref 815* 817 833* 834
segx                            000222 automatic       fixed bin(17,0)          dcl 166 set ref 274* 288 288* 288 296 296* 333 333
                                                                                  436 436 626* 627 638* 638 690* 691* 699* 701 702
                                                                                  710 713 716 746* 788 788 815 815 823 823 825 827
                                                                                  827 838 838 966 1008 1043 1140 1157
size                                                   builtin function         dcl 1177 in procedure "set_break_seg_bc" ref 1179
size                                                   builtin function         dcl 222 in procedure "db_break" ref 864 864
skip_count                3            based           fixed bin(17,0)          level 2 dcl 2-35 set ref 362 367* 367 467* 493* 522*
snt_ptr                         000106 automatic       pointer                  dcl 129 set ref 350* 372* 391* 457*
source_string                   000226 automatic       varying char(72)         dcl 176 set ref 976* 977* 986* 987*
substr                                                 builtin function         dcl 222 set ref 884* 981 981 1092* 1092 1116* 1116
tra                       4            based           bit(36)                  level 3 dcl 2-17 ref 533
truncate                               parameter       bit(1)                   unaligned dcl 1173 ref 1170
type                                   based           fixed bin(17,0)          level 2 in structure "break_slot" dcl 2-35
                                                                                  in procedure "db_break" set ref 410 420 420 451*
                                                                                  517 566 601 636 767 767 966 1005* 1028 1056* 1056
                                                                                  1068 1079* 1079
type                            000110 automatic       fixed bin(17,0)          dcl 129 in procedure "db_break" set ref 390* 451 474
uid                       1            based           bit(36)                  array level 3 in structure "bseg" dcl 188
                                                                                  in procedure "db_break" set ref 691 702* 825
uid                      11     000177 automatic       bit(36)                  level 2 in structure "branch" packed unaligned
                                                                                  dcl 145 in procedure "db_break" set ref 691 702
                                                                                  825
user_info_                      000112 constant        entry                    external dcl 224 ref 880
user_info_$homedir              000116 constant        entry                    external dcl 224 ref 877
version                   3            based           char(4)                  level 2 dcl 2-17 ref 523
word3                     3            based           bit(18)                  level 2 packed unaligned dcl 4-56 set ref 539
word_count                      000462 automatic       fixed bin(18,0)          dcl 1176 set ref 1179* 1180* 1181
xsf                       0(19)        based           bit(1)                   level 3 packed unaligned dcl 4-56 set ref 538*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
abx                                    internal static fixed bin(17,0)          initial dcl 4-42
apx                                    internal static fixed bin(17,0)          initial dcl 4-42
bbx                                    internal static fixed bin(17,0)          initial dcl 4-42
bpx                                    internal static fixed bin(17,0)          initial dcl 4-42
db_ext_stat_$break_instructions        external static bit(36)                  array dcl 1-27
divide                                                 builtin function         dcl 222
ilc_ptr                                automatic       pointer                  dcl 3-10
instr_pr                               based           structure                level 1 dcl 3-21
lbx                                    internal static fixed bin(17,0)          initial dcl 4-42
lpx                                    internal static fixed bin(17,0)          initial dcl 4-42
max                                                    builtin function         dcl 222
mc                                     based           structure                level 1 dcl 4-12
mcp                                    automatic       pointer                  dcl 4-10
old_bmap                               based           structure                level 1 dcl 2-12
sbx                                    internal static fixed bin(17,0)          initial dcl 4-42
scux                                   based           structure                level 1 dcl 4-206
spx                                    internal static fixed bin(17,0)          initial dcl 4-42

NAMES DECLARED BY EXPLICIT CONTEXT.
ACTION_LABEL                    000000 constant        label                    array(6) dcl 916 ref 913
CHECK_BREAK_NUM                 002242 constant        entry                    internal dcl 754 ref 354 514
CHECK_DEFAULT                   002207 constant        entry                    internal dcl 729 ref 331 491 564 583
CHECK_SEGMENT                   002353 constant        entry                    internal dcl 795 ref 275 630
DELETE_BMAP                     003556 constant        entry                    internal dcl 1122 ref 590 850 1015
DELETE_SEG_ENTRY                003577 constant        entry                    internal dcl 1146 ref 819 829 841 1135
DISABLE                         003415 constant        entry                    internal dcl 1021 ref 927 1003
DO_ACTION                       003004 constant        entry                    internal dcl 902 ref 566 601 636
ENABLE                          003503 constant        entry                    internal dcl 1061 ref 932
GET_BREAK_SLOT_PTR              002635 constant        entry                    internal dcl 856 ref 409 449 600 635 749 766
INIT_BREAK_SEG                  002644 constant        entry                    internal dcl 869 ref 271 622 658
LIST                            003025 constant        entry                    internal dcl 948 ref 472 916
RESET                           003333 constant        entry                    internal dcl 993 ref 517 922
RETURN_FROM_DB_BREAK            001737 constant        label                    dcl 1195 ref 682 724 742 772 790 896
SET_COMMAND                     003527 constant        entry                    internal dcl 1084 ref 937
SET_CONDITION                   003541 constant        entry                    internal dcl 1103 ref 942
SET_DEFAULTS                    001740 constant        entry                    internal dcl 647 ref 315 352 394 513
SET_DEF_ERR                     002154 constant        label                    dcl 721 ref 664 672
SET_DEF_SEG_FOUND               002135 constant        label                    dcl 710 set ref 691
VALIDATE_BREAK_NUM              002304 constant        entry                    internal dcl 778 ref 748 764
check_break                     000565 constant        entry                    external dcl 338
db_break                        000306 constant        entry                    external dcl 11
global                          001614 constant        entry                    external dcl 610
print_bseg                      000317 constant        entry                    external dcl 260
print_default                   000511 constant        entry                    external dcl 324
restart                         001226 constant        entry                    external dcl 497
set_break                       000665 constant        entry                    external dcl 382
set_break_seg_bc                003633 constant        entry                    internal dcl 1170 ref 699 1162
set_default                     000475 constant        entry                    external dcl 309
set_skips                       001200 constant        entry                    external dcl 482
single                          001367 constant        entry                    external dcl 552
sub_global                      001460 constant        entry                    external dcl 572

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4272        4414    3735        4302
Length      4772    3735       122         342     335          40

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
db_break                            738 external procedure  is an external procedure.  
SET_DEFAULTS                            internal procedure  shares stack frame of external procedure db_break.  
CHECK_DEFAULT                           internal procedure  shares stack frame of external procedure db_break.  
CHECK_BREAK_NUM                         internal procedure  shares stack frame of external procedure db_break.  
VALIDATE_BREAK_NUM                      internal procedure  shares stack frame of external procedure db_break.  
CHECK_SEGMENT                           internal procedure  shares stack frame of external procedure db_break.  
GET_BREAK_SLOT_PTR                      internal procedure  shares stack frame of external procedure db_break.  
INIT_BREAK_SEG                          internal procedure  shares stack frame of external procedure db_break.  
DO_ACTION                               internal procedure  shares stack frame of external procedure db_break.  
LIST                                    internal procedure  shares stack frame of external procedure db_break.  
RESET                                   internal procedure  shares stack frame of external procedure db_break.  
DISABLE                                 internal procedure  shares stack frame of external procedure db_break.  
ENABLE                                  internal procedure  shares stack frame of external procedure db_break.  
SET_COMMAND                             internal procedure  shares stack frame of external procedure db_break.  
SET_CONDITION                           internal procedure  shares stack frame of external procedure db_break.  
DELETE_BMAP                             internal procedure  shares stack frame of external procedure db_break.  
DELETE_SEG_ENTRY                        internal procedure  shares stack frame of external procedure db_break.  
set_break_seg_bc                        internal procedure  shares stack frame of external procedure db_break.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 break_seg_ptr               db_break
000012 def_segx                    db_break
000014 def_break_map_ptr           db_break
000016 mme2                        db_break
000020 break_type_name             db_break

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
db_break                 000100 action_code                 db_break
                         000101 break_num                   db_break
                         000102 break_ptr                   db_break
                         000104 line_len                    db_break
                         000105 print_mode                  db_break
                         000106 snt_ptr                     db_break
                         000110 type                        db_break
                         000112 break_word_ptr              db_break
                         000114 break_offset                db_break
                         000115 dir_name                    db_break
                         000167 ent_name                    db_break
                         000177 branch                      db_break
                         000211 action_flag                 db_break
                         000212 cond_flag                   db_break
                         000213 delete_seg_entry_flag       db_break
                         000214 inst_ptr                    db_break
                         000216 new_bnum                    db_break
                         000220 seg_ptr                     db_break
                         000222 segx                        db_break
                         000224 print_num_breaks            db_break
                         000226 source_string               db_break
                         000251 bit_count                   db_break
                         000252 code                        db_break
                         000253 i                           db_break
                         000254 j                           db_break
                         000256 break_map_ptr               db_break
                         000260 break_slot_ptr              db_break
                         000262 scup                        db_break
                         000376 line_info                   LIST
                         000462 word_count                  set_break_seg_bc

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        return              shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      db_break_map$check            db_break_map$delete           db_break_map$get_slots
db_break_map$init             db_line_no                    db_parse_condition$check      db_parse_condition$print_line
hcs_$fs_get_path_name         hcs_$initiate_count           hcs_$make_seg                 hcs_$set_bc_seg
hcs_$status_long              hcs_$truncate_seg             ioa_$ioa_stream               ioa_$rsnnl
print_text_$real_offset       user_info_                    user_info_$homedir

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
db_ext_stat_$db_ext_stat_     op_mnemonic_$op_mnemonic




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000305       260 000313       269 000327       271 000331       274 000336       275 000346       286 000347
    288 000351       291 000357       293 000360       295 000367       296 000372       299 000441       304 000443
    307 000471       309 000472       314 000502       315 000506       317 000507       324 000510       330 000516
    331 000520       333 000521       336 000555       338 000556       348 000577       349 000603       350 000605
    352 000610       354 000611       362 000612       364 000615       366 000616       367 000617       368 000621
    370 000622       372 000626       375 000645       376 000650       377 000653       378 000655       380 000657
    382 000660       389 000675       390 000701       391 000703       392 000706       394 000710       401 000711
    404 000715       407 000717       409 000726       410 000727       413 000737       418 000740       420 000744
    423 000751       424 001002       426 001003       427 001005       429 001007       431 001011       433 001014
    434 001023       436 001027       438 001063       440 001064       447 001070       448 001071       449 001073
    451 001074       452 001076       453 001101       457 001103       462 001126       467 001141       472 001155
    474 001156       476 001161       477 001165       480 001173       482 001174       489 001212       491 001214
    493 001215       495 001220       497 001221       504 001242       505 001246       506 001250       507 001253
    509 001255       513 001270       514 001271       515 001272       517 001276       522 001303       523 001307
    527 001316       528 001321       529 001324       530 001326       531 001330       532 001332       533 001334
    538 001336       539 001340       540 001342       546 001344       547 001347       550 001361       552 001362
    559 001407       560 001411       561 001413       562 001415       564 001417       566 001420       568 001425
    570 001452       572 001453       578 001476       579 001477       580 001501       581 001503       582 001505
    583 001507       588 001510       590 001513       591 001514       592 001540       599 001541       600 001554
    601 001555       603 001561       605 001563       608 001611       610 001612       617 001632       618 001633
    619 001635       620 001637       622 001641       625 001647       626 001652       627 001654       630 001660
    632 001661       634 001663       635 001676       636 001677       637 001703       638 001705       640 001710
    643 001711       645 001736      1195 001737       647 001740       658 001741       663 001747       664 002001
    671 002003       672 002045       679 002047       680 002065       681 002075       682 002100       690 002101
    691 002111       693 002117       699 002121       701 002125       702 002130       710 002135       713 002143
    715 002147       716 002151       718 002153       721 002154       724 002206       729 002207       739 002210
    741 002213       742 002233       745 002234       746 002236       748 002237       749 002240       752 002241
    754 002242       764 002243       766 002244       767 002245       770 002252       771 002277       772 002302
    776 002303       778 002304       785 002305       788 002311       790 002351       793 002352       795 002353
    813 002354       815 002355       817 002422       819 002426       820 002427       823 002430       825 002476
    827 002506       829 002536       830 002537       833 002540       834 002552       836 002557       838 002563
    841 002625       842 002626       848 002627       850 002632       851 002633       854 002634       856 002635
    864 002636       867 002643       869 002644       877 002645       880 002656       883 002667       884 002700
    892 002703       893 002742       895 002747       896 003002       900 003003       902 003004       911 003005
    913 003007       916 003011       918 003012       922 003013       924 003014       927 003015       929 003016
    932 003017       934 003020       937 003021       939 003022       942 003023       946 003024       948 003025
    960 003026       962 003062       966 003065       970 003143       976 003146       977 003172       981 003222
    984 003263       986 003267       987 003302       991 003332       993 003333      1003 003334      1005 003335
   1006 003337      1008 003342      1015 003410      1019 003414      1021 003415      1028 003416      1034 003422
   1035 003427      1041 003433      1043 003436      1045 003475      1050 003476      1056 003500      1059 003502
   1061 003503      1068 003504      1071 003510      1072 003514      1079 003524      1082 003526      1084 003527
   1090 003530      1092 003533      1096 003540      1103 003541      1112 003542      1115 003547      1116 003551
   1120 003555      1122 003556      1131 003557      1132 003566      1135 003570      1140 003571      1144 003576
   1146 003577      1157 003600      1160 003615      1161 003617      1162 003621      1164 003632      1170 003633
   1179 003635      1180 003641      1181 003654      1182 003674      1184 003721


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
