	COMPILATION LISTING OF SEGMENT probe_expr_requests_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 11/11/88  1545.4 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(88-05-18,WAAnderson), approve(88-09-30,MCR7952),
       16*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       17*     Added the call to 'probe_print_c_attr_' in the symbol_request entry.
       18*  2) change(88-05-27,WAAnderson), approve(88-09-30,MCR7952),
       19*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       20*     Added code that allows for C indirection on the lefthand side of the
       21*     assignment statement of the 'let_request'.
       22*  3) change(88-06-10,WAAnderson), approve(88-09-30,MCR7952),
       23*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       24*     Changed 'boolean_expr' (called from the 'if_request' entry) to verify
       25*     the conditional C operators == and != are used instead of the PL/1
       26*     conditional operator = and ^=.
       27*  4) change(88-09-07,WAAnderson), approve(88-09-30,MCR7952),
       28*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       29*     Added format control comment to make the source more readable.
       30*                                                   END HISTORY COMMENTS */
       31 
       32 
       33 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       34 
       35 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       36 
       37 probe_expr_requests_:
       38   proc ();
       39 
       40 
       41   call probe_error_$malfunction ();	/* dummy entry */
       42 
       43   call reject_next_argument ();	/* just so it's referenced */
       44 
       45 
       46   /*   Implements the following requests:
       47*
       48*	call
       49*	if
       50*	let
       51*	symbol
       52*	value
       53*	while
       54**/
       55   /*
       56*   Modified 3 Sept 79 JRD
       57*   Modified 20 Feb 80 JRD probe variables in symbol request */
       58   /* Added algol68 typing to 'symbol' request 09/23/82 S. Herbst */
       59   /* Modified June 83 JMAthane to add PASCAL typing to 'symbol' request */
       60   /* Changed "let" to allow := in place of = in Pascal mode 07/27/83 S. Herbst */
       61   /* Changed to call display_data_$for_probe instead of obsolete probe_print_value_ 08/02/83 Olin Sibert */
       62   /* Fixed "if" to parse line only if conditional is true 08/22/83 S. Herbst */
       63   /* Changed if request to allow "if BOOLEAN:" syntax 04/05/84 S. Herbst */
       64 
       65 
       66   dcl P_probe_info_ptr	pointer parameter;
       67 
       68   dcl code		fixed bin (35);
       69 
       70   dcl based_str_ptr		pointer;
       71   dcl based_str_lth		fixed bin (21);
       72   dcl based_str		char (based_str_lth) based (based_str_ptr);
       73 
       74   dcl (ref_1_ptr, ref_2_ptr)	pointer;
       75   dcl 1 ref_1		aligned like reference_node based (ref_1_ptr);
       76 				/* temporary reference nodes */
       77   dcl 1 ref_2		aligned like reference_node based (ref_2_ptr);
       78 
       79   dcl 1 type_info		like runtime_type_info;
       80 
       81   dcl (
       82       probe_et_$bad_constant,
       83       probe_et_$recorded_message,
       84       probe_et_$bad_predicate,
       85       probe_et_$noarg,
       86       probe_et_$syntax_error,
       87       probe_et_$misused_equal,
       88       probe_et_$misused_not_equal,
       89       probe_et_$too_many_args
       90       )			fixed bin (35) external static;
       91 
       92   dcl display_data_$for_probe entry (ptr, 1 aligned like reference_node,
       93 			fixed bin (35));
       94   dcl probe_assign_value_	entry (ptr, 1 aligned like reference_node,
       95 			1 aligned like reference_node, fixed bin (35));
       96   dcl probe_compare_reference_
       97 			entry (ptr, bit (18) aligned,
       98 			1 aligned like reference_node,
       99 			1 aligned like reference_node, fixed bin (35))
      100 			returns (bit (1) aligned);
      101   dcl probe_create_reference_ entry (ptr, ptr);
      102   dcl probe_error_		entry options (variable);
      103   dcl probe_error_$malfunction
      104 			entry options (variable);
      105   dcl probe_get_$expression	entry (ptr, 1 aligned like reference_node,
      106 			fixed bin (35));
      107   dcl probe_get_$reference	entry (ptr, 1 aligned like reference_node,
      108 			fixed bin (35));
      109   dcl probe_get_$request_list entry (ptr, ptr, fixed bin (21), fixed bin (35))
      110 			;
      111   dcl probe_get_$value	entry (ptr, 1 aligned like reference_node,
      112 			bit (36) aligned, fixed bin (35));
      113   dcl probe_invoke_$subroutine
      114 			entry (ptr, 1 aligned like reference_node,
      115 			fixed bin (35));
      116   dcl probe_listen_$check_line
      117 			entry (ptr, ptr, fixed bin (21), fixed bin (35))
      118 			;
      119   dcl probe_listen_$interpret_line
      120 			entry (ptr, ptr, fixed bin (21), fixed bin (35))
      121 			;
      122   dcl probe_print_pascal_$attr
      123 			entry (ptr, ptr, bit (1) aligned,
      124 			fixed bin (35));
      125   dcl probe_print_algol68_attr_
      126 			entry (ptr, ptr, bit (1) aligned,
      127 			fixed bin (35));
      128   dcl probe_print_pl1_attr_	entry (ptr, ptr, bit (1) aligned,
      129 			fixed bin (35));
      130   dcl probe_print_c_attr_	entry (ptr, ptr, bit (1) aligned,
      131 			fixed bin (35));
      132   dcl probe_print_cobol_attr_ entry (ptr, ptr, bit (1) aligned,
      133 			fixed bin (35));
      134   dcl probe_print_fortran_attr_
      135 			entry (ptr, ptr, bit (1) aligned,
      136 			fixed bin (35));
      137   dcl probe_variable_mgr_$find_variable
      138 			entry (ptr, ptr, fixed bin (35));
      139   dcl probe_variable_mgr_$list_var_ptr
      140 			entry (ptr, ptr unal, fixed bin (35));
      141   dcl stu_$find_runtime_symbol
      142 			entry (ptr, char (*), ptr, fixed bin)
      143 			returns (ptr);
      144   dcl stu_$get_runtime_address
      145 			entry (ptr, ptr, ptr, ptr, ptr, ptr, ptr)
      146 			returns (ptr);
      147 
      148   dcl (addr, addrel, fixed, null)
      149 			builtin;
      150 
      151 RECORDED_MESSAGE:
      152   code = probe_et_$recorded_message;
      153   go to SOME_ERROR;
      154 
      155 
      156 SYNTAX_ERROR:			/* general-purpose error exit */
      157   call probe_error_ (probe_info_ptr, probe_et_$syntax_error);
      158   go to MAIN_RETURN;
      159 
      160 
      161 SOME_ERROR:			/* general for error code type errors */
      162   call probe_error_ (probe_info_ptr, code);
      163 				/* never returns */
      164   go to MAIN_RETURN;		/* just in case */
      165 
      166 
      167 MAIN_RETURN:
      168   return;				/* only such exit from this procedure */
      169 
      170 
      171 value_request:
      172   entry (P_probe_info_ptr);
      173 
      174   /* *	Prints the value of a variable or expression */
      175 
      176   call setup (1);
      177 
      178   call require_argument ();
      179 
      180   call probe_get_$expression (probe_info_ptr, ref_1, code);
      181   if code ^= 0
      182     then go to SOME_ERROR;
      183 
      184   if probe_info.ct -> token.type = NAME_TYPE then do;
      185       if current_identifier_name = "data"
      186 	 & probe_info.language_type = C_lang_type
      187         then
      188 	   code = 1;
      189       probe_info.ct = probe_info.ct -> token.next;
      190     end;
      191 
      192   call reject_argument ();		/* nothing after this */
      193 
      194   if probe_info.flags.execute then do;
      195       call display_data_$for_probe (probe_info_ptr, ref_1, code);
      196       if code ^= 0
      197         then go to SOME_ERROR;
      198     end;
      199 
      200   go to MAIN_RETURN;		/* end of code for $value_request entry */
      201 
      202 let_request:
      203   entry (P_probe_info_ptr);
      204 
      205   dcl c_indirect_count	fixed bin;
      206   dcl not_done_indirection	bit (1);
      207   dcl ptr_overlay		based ptr;
      208 
      209   /* *	Assigns a new value to a variable */
      210 
      211   code = 0;
      212 
      213   call setup (2);
      214 
      215   c_indirect_count = 0;
      216   not_done_indirection = "1"b;
      217 
      218   do while (not_done_indirection);
      219     if probe_info.ct -> token.type < probe_info.token_info.end_token
      220          & probe_info.ct -> token.type = C_INDIRECTION then do;
      221         c_indirect_count = c_indirect_count + 1;
      222         probe_info.ct = probe_info.ct -> token.next;
      223       end;
      224       else not_done_indirection = "0"b;
      225   end;
      226 
      227   call require_argument ();
      228 
      229   call probe_get_$value (probe_info_ptr, ref_1, "000000000000"b3, code);
      230 
      231   if code ^= 0
      232     then go to SOME_ERROR;
      233 
      234   if (ref_1.symbol_ptr ^= null ()) then do;
      235       if (fixed (ref_1.symbol_ptr -> runtime_symbol.type) = c_typeref_dtype)
      236         then do;
      237 	do while (fixed (ref_1.symbol_ptr -> runtime_symbol.type)
      238 	     = c_typeref_dtype);
      239 	  ref_1.symbol_ptr =
      240 	       addrel (ref_1.symbol_ptr,
      241 	       fixed (ref_1.symbol_ptr -> runtime_symbol.son, 17));
      242 	end;
      243 	if (fixed (ref_1.symbol_ptr -> runtime_symbol.type) = c_enum_dtype)
      244 	  then do;
      245 	    ref_1.type = real_fix_bin_1_dtype;
      246 	    ref_1.precision = 35;
      247 	  end;
      248 	  else do;
      249 	    ref_1.type =
      250 	         fixed (ref_1.symbol_ptr -> runtime_symbol.type, 35);
      251 	    ref_1.precision =
      252 	         fixed (ref_1.symbol_ptr -> runtime_symbol.size, 35);
      253 	    ref_1.flags.packed =
      254 	         ref_1.symbol_ptr -> runtime_symbol.bits.packed;
      255 	  end;
      256         end;
      257     end;
      258 
      259   do while (c_indirect_count > 0);
      260     c_indirect_count = c_indirect_count - 1;
      261     if ref_1.symbol_ptr -> runtime_symbol.son ^= "0"b then do;
      262         ref_1.symbol_ptr =
      263 	   addrel (ref_1.symbol_ptr,
      264 	   fixed (ref_1.symbol_ptr -> runtime_symbol.son));
      265         ref_1.type = fixed (ref_1.symbol_ptr -> runtime_symbol.type);
      266         ref_1.address_ptr = ref_1.address_ptr -> ptr_overlay;
      267         ref_1.precision = ref_1.symbol_ptr -> runtime_symbol.size;
      268       end;
      269   end;
      270 
      271   if probe_info.ct -> operator.type ^= EQUALS &
      272        (probe_info.language_type ^= PASCAL_lang_type
      273        | probe_info.ct -> operator.type ^= PASCAL_ASSIGN)
      274     then
      275          call probe_error_ (probe_info_ptr, probe_et_$syntax_error,
      276 	    "Usage: let <value> = <expression>");
      277 
      278   call bump_ct ();			/* get the next token */
      279   call require_argument ();
      280 
      281   call probe_get_$expression (probe_info_ptr, ref_2, code);
      282 				/* get value for assignment */
      283   if code ^= 0
      284     then go to SOME_ERROR;
      285 
      286   call reject_argument ();		/* nothing after this */
      287 
      288   if probe_info.flags.execute then do;	/* do it! */
      289       call probe_assign_value_ (probe_info_ptr, ref_1, ref_2, code);
      290       if code ^= 0
      291         then go to SOME_ERROR;	/* print the message */
      292     end;
      293 
      294   go to MAIN_RETURN;		/* end of code for $let_request entry */
      295 
      296 symbol_request:
      297   entry (P_probe_info_ptr);
      298 
      299   /* *	Prints information about a symbol */
      300 
      301   dcl sb_long_sw		bit (1) aligned;
      302 
      303   call setup (1);
      304 
      305   call require_argument ();
      306   call probe_get_$reference (probe_info_ptr, ref_1, code);
      307   if code ^= 0
      308     then go to SOME_ERROR;
      309 
      310   if ref_1.flags.constant & ref_1.type ^= ext_procedure_runtime_dtype then do;
      311       code = probe_et_$bad_constant;
      312       go to SOME_ERROR;
      313     end;
      314 
      315   if probe_info.ct -> token.type >= probe_info.end_token
      316     then
      317          sb_long_sw = "0"b;		/* clearly, no options specified */
      318 
      319     else do;			/* otherwise, check for options */
      320       if probe_info.ct -> token.type ^= NAME_TYPE
      321         then go to SYNTAX_ERROR;
      322 
      323       based_str_ptr = probe_info.ct -> identifier.name;
      324       based_str_lth = probe_info.ct -> identifier.length;
      325 
      326       if based_str = "long" | based_str = "lg"
      327         then
      328 	   sb_long_sw = "1"b;
      329       else if based_str = "brief" | based_str = "bf"
      330         then
      331 	   sb_long_sw = "0"b;
      332       else go to SYNTAX_ERROR;	/* Unrecognized option */
      333 
      334       call bump_ct ();		/* get the next token */
      335       call reject_argument ();	/* not at end yet? */
      336     end;				/* of checking for options */
      337 
      338   if probe_info.flags.execute
      339     then if ref_1.flags.probe_variable
      340 	 then do;
      341 	   call probe_variable_mgr_$list_var_ptr (probe_info_ptr,
      342 	        ref_1.probe_var_info_ptr, code);
      343 	   if code ^= 0
      344 	     then go to SOME_ERROR;
      345 	 end;
      346 	 else do;
      347 	   if probe_info.language_type = FORTRAN_lang_type
      348 	     then call probe_print_fortran_attr_ (probe_info_ptr,
      349 		     addr (ref_1), sb_long_sw, (0));
      350 	   else if probe_info.language_type = COBOL_lang_type
      351 	     then call probe_print_cobol_attr_ (probe_info_ptr,
      352 		     addr (ref_1), sb_long_sw, (0));
      353 
      354 	   else if probe_info.language_type = PASCAL_lang_type
      355 	     then call probe_print_pascal_$attr (probe_info_ptr,
      356 		     addr (ref_1), sb_long_sw, (0));
      357 	   else if probe_info.language_type = ALGOL68_lang_type
      358 	     then call probe_print_algol68_attr_ (probe_info_ptr,
      359 		     addr (ref_1), sb_long_sw, (0));
      360 	   else if probe_info.language_type = PL1_lang_type
      361 	     then call probe_print_pl1_attr_ (probe_info_ptr, addr (ref_1),
      362 		     sb_long_sw, (0));
      363 	   else call probe_print_c_attr_ (probe_info_ptr, addr (ref_1),
      364 		   sb_long_sw, (0));
      365 	 end;			/* program vars */
      366 
      367   go to MAIN_RETURN;
      368 
      369 call_request:
      370   entry (P_probe_info_ptr);
      371 
      372   /* *	This fellow calls an external procedure. Sorry, no internal procedure calls
      373*   *	yet, though our experts are working around the clock to bring them to you */
      374 
      375   call setup (1);			/* need one reference node this time */
      376 
      377   call require_argument ();		/* must specify something to call, natch */
      378 
      379   call probe_get_$value (probe_info_ptr, ref_1, "110"b, code);
      380 				/* get the thing to call */
      381   if code ^= 0
      382     then go to SOME_ERROR;
      383 
      384   call reject_argument ();		/* can't have anything folowing the argument list */
      385 
      386   if probe_info.execute then do;	/* do it */
      387       call probe_invoke_$subroutine (probe_info_ptr, ref_1, code);
      388       if code ^= 0
      389         then go to SOME_ERROR;
      390     end;
      391 
      392   go to MAIN_RETURN;		/* end of code for the call request */
      393 
      394 while_request:
      395   entry (P_probe_info_ptr);
      396 
      397   /* *	The while request executes a set of probe requests for as long as the specified condition is true */
      398 
      399 
      400   dcl conditional_expr_ptr	ptr;	/* to the start of conditional expr tokens */
      401   dcl after_ptr		ptr;	/* to restore ct */
      402 
      403 
      404   dcl comparison_result	bit (1) aligned;
      405   dcl requests_ptr		pointer;
      406   dcl requests_lth		fixed bin (21);
      407 
      408 
      409   call setup (2);
      410   call require_argument ();
      411 
      412   conditional_expr_ptr = probe_info.ct;
      413 
      414   comparison_result = boolean_expr (conditional_expr_ptr);
      415   if comparison_result & probe_info.execute then do;
      416 
      417       call common_conditional_munch ();
      418 
      419       after_ptr = probe_info.ct;
      420       do while (comparison_result);
      421         call probe_listen_$interpret_line (probe_info_ptr, requests_ptr,
      422 	   requests_lth, code);
      423         if code ^= 0
      424 	then go to SOME_ERROR;
      425         comparison_result = boolean_expr (conditional_expr_ptr);
      426       end;
      427       probe_info.ct = after_ptr;
      428       if code ^= 0
      429         then go to SOME_ERROR;
      430     end;
      431     else call skip_line ();
      432 
      433   go to MAIN_RETURN;
      434 
      435 
      436 if_request:
      437   entry (P_probe_info_ptr);
      438 
      439   /* The if request executes a set of probe requests once, if the   specified condition is true */
      440 
      441 
      442   call setup (2);
      443 
      444   call require_argument ();		/* can't just say 'while' */
      445 
      446   comparison_result = boolean_expr ((probe_info.ct));
      447 
      448   call common_conditional_munch ();
      449 
      450   if comparison_result & probe_info.execute then do;
      451 
      452       call probe_listen_$interpret_line (probe_info_ptr, requests_ptr,
      453 	 requests_lth, code);
      454       if code ^= 0
      455         then go to SOME_ERROR;
      456     end;
      457   else if probe_info.setting_break then do;
      458       call probe_listen_$check_line (probe_info_ptr, requests_ptr,
      459 	 requests_lth, code);
      460       if code ^= 0
      461         then go to SOME_ERROR;
      462     end;
      463   else call skip_line ();
      464 
      465   go to MAIN_RETURN;
      466 
      467 boolean_expr:
      468   proc (exp_begin) returns (bit (1) aligned);
      469 
      470 
      471   dcl exp_begin		ptr parameter;
      472 
      473   dcl operation		bit (18) aligned;
      474   dcl result		bit (1) aligned;
      475 
      476   dcl b1al		bit (1) aligned based;
      477   dcl b1unal		bit (1) unaligned based;
      478 
      479   /* must set up probe_info.ct for sake of probe_get_$expression */
      480 
      481 
      482   probe_info.ct = exp_begin;
      483   call require_argument ();
      484   call probe_get_$expression (probe_info_ptr, ref_1, code);
      485   if code ^= 0
      486     then go to ERR_IN_BOOLEAN_EXPR;
      487 
      488   operation = probe_info.ct -> operator.type;
      489   if probe_info.language_type = C_lang_type then do;
      490       if operation = EQUALS
      491         then
      492 	   call probe_error_ (probe_info_ptr, probe_et_$misused_equal);
      493       else if operation = C_EQUAL
      494         then
      495 	   operation = EQUALS;
      496       else if operation = NOT_EQUALS
      497         then
      498 	   call probe_error_ (probe_info_ptr, probe_et_$misused_not_equal);
      499       else if operation = C_NOT_EQUAL
      500         then
      501 	   operation = NOT_EQUALS;
      502     end;
      503   if operation < LESS_THAN | operation > NOT_LESS_THAN
      504     then
      505          if operation ^= COLON
      506 	 then
      507 BAD_PRED:
      508 	   call probe_error_ (probe_info_ptr, probe_et_$bad_predicate);
      509 	 else do;			/* might be "if BOOLEAN: " */
      510 	   if ^probe_info.execute then do;
      511 				/* don't have type yet */
      512 	       call probe_variable_mgr_$find_variable (probe_info_ptr,
      513 		  addr (ref_1), code);
      514 	       if code ^= 0 then do;	/* not a probe variable */
      515 		 ref_1.symbol_ptr = stu_$find_runtime_symbol
      516 		      (probe_info.ptr_to_current_source
      517 		      -> source_info.block_ptr,
      518 		      (ref_1.name), null, 0);
      519 		 if ref_1.symbol_ptr = null
      520 		   then go to BAD_PRED;
      521 				/* no such variable */
      522 
      523 		 type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
      524 		 call runtime_symbol_info_$type (ref_1.symbol_ptr,
      525 		      addr (type_info), code);
      526 		 if code ^= 0
      527 		   then go to BAD_PRED;
      528 		 ref_1.type = type_info.type;
      529 	         end;
      530 	     end;
      531 
      532 	   if ref_1.type = bit_dtype then do;
      533 	       if probe_info.execute
      534 	         then
      535 		    if ref_1.packed
      536 		      then return ((ref_1.address_ptr -> b1unal));
      537 		      else return ((ref_1.address_ptr -> b1al));
      538 	         else return ("0"b);
      539 	     end;
      540 	     else go to BAD_PRED;
      541 	 end;
      542 
      543   call bump_ct ();			/* skip over the relational operator */
      544   call require_argument ();
      545   call probe_get_$expression (probe_info_ptr, ref_2, code);
      546   if code ^= 0
      547     then go to ERR_IN_BOOLEAN_EXPR;
      548 
      549   if probe_info.execute
      550     then result =
      551 	    probe_compare_reference_ (probe_info_ptr, operation, ref_1,
      552 	    ref_2, code);
      553     else result = "0"b;
      554   if code ^= 0
      555     then go to ERR_IN_BOOLEAN_EXPR;
      556   return (result);
      557 ERR_IN_BOOLEAN_EXPR:
      558   go to SOME_ERROR;
      559   end boolean_expr;
      560 
      561 common_conditional_munch:
      562   proc;
      563 
      564 
      565   if probe_info.ct -> operator.type ^= COLON
      566     then /* must have a colon here, but print a sensible message */
      567          call probe_error_ (probe_info_ptr, 0,
      568 	    "The relational expression and the requests to be executed must be separated by a colon."
      569 	    );
      570 
      571   call bump_ct ();			/* skip over the colon */
      572 
      573   call require_argument ();
      574 
      575   call probe_get_$request_list (probe_info_ptr, requests_ptr, requests_lth,
      576        code);
      577   if code ^= 0
      578     then
      579          go to SOME_ERROR;
      580 
      581   call reject_argument ();		/* nothing may follow the request line */
      582 
      583 
      584   end common_conditional_munch;
      585 
      586 setup:
      587   proc (P_n_references);
      588 
      589   /* *	This procedure sets up the request variables, and initializes as many
      590*   *	reference nodes and associated data as the request has requested */
      591 
      592   dcl P_n_references	fixed bin;
      593 
      594 
      595   probe_info_ptr = P_probe_info_ptr;	/* copy the global parameter */
      596 
      597   if P_n_references > 0
      598     then /* initialize a reference node */
      599          call probe_create_reference_ (probe_info_ptr, ref_1_ptr);
      600 
      601   if P_n_references > 1
      602     then /* initialize another one */
      603          call probe_create_reference_ (probe_info_ptr, ref_2_ptr);
      604 
      605   if P_n_references > 2
      606     then /* but this is too much */
      607          call probe_error_$malfunction (probe_info_ptr, 0,
      608 	    "Too many reference nodes requested: ^d", P_n_references);
      609 
      610   return;
      611 
      612   end setup;
      613 
      614 reject_argument:
      615   proc ();
      616 
      617   /* *	This procedure simply calls probe_error_ if the current token is not the
      618*   *	end of the token chain -- it is called by requests which have processed all
      619*   *	expected arguments and want to barf if there are any extras */
      620 
      621   if probe_info.ct -> token.type < probe_info.end_token
      622     then
      623          call probe_error_ (probe_info_ptr, probe_et_$too_many_args);
      624   return;
      625 
      626   end reject_argument;
      627 
      628 
      629 reject_next_argument:
      630   proc ();
      631 
      632 
      633   /* *	This is just like reject_argument, except that it tests whether there are any
      634*   *	argument tokens AFTER the current one, rather than starting with the current one */
      635 
      636   if probe_info.ct -> token.next = null ()
      637     then
      638          call probe_error_ (probe_info_ptr, probe_et_$too_many_args);
      639 
      640   if probe_info.ct -> token.next -> token.type < probe_info.end_token
      641     then
      642          call probe_error_ (probe_info_ptr, probe_et_$too_many_args);
      643   return;
      644 
      645   end reject_next_argument;
      646 
      647 
      648 require_argument:
      649   proc ();
      650 
      651 
      652   /* *	This is just like reject_argument, except that it barfs if there are not
      653*   *	any more arguments */
      654 
      655   if probe_info.ct -> token.type >= probe_info.end_token
      656     then
      657          call probe_error_ (probe_info_ptr, probe_et_$noarg);
      658   return;
      659 
      660   end require_argument;
      661 
      662 skip_line:
      663   proc;
      664 
      665   dcl prev_ct		ptr init (null);
      666 
      667 
      668   do probe_info.ct = probe_info.ct repeat (probe_info.ct -> token.next)
      669        while (probe_info.ct ^= null);
      670     prev_ct = probe_info.ct;
      671     if probe_info.ct -> token.type = end_token
      672       then go to SKIP_RETURN;
      673   end;
      674 SKIP_RETURN:
      675   probe_info.ct = prev_ct;
      676   return;
      677 
      678   end skip_line;
      679 
      680 bump_ct:
      681   proc ();
      682 
      683   /* *	This procedure makes probe_info.ct point at the next token. */
      684 
      685   probe_info.ct = probe_info.ct -> token.next;
      686 
      687   if probe_info.ct = null ()
      688     then go to SYNTAX_ERROR;		/* some protection against mistakes */
      689 
      690   return;
      691 
      692   end bump_ct;
      693 
  1     1 /*	BEGIN INCLUDE FILE probe_info.incl.pl1		*/
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(88-10-24,WAAnderson), approve(88-10-24,MCR7952),
  1     7*     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
  1     8*     Added field 'retry_using_main' to add new C feature.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* Created: 04/22/79 W. Olin Sibert, from subsystem_info	
  1    13*   Modified: 22 Sept 79 JRd to remove: 	default (ptr & (auto|based)) init (null ());
  1    14*   Added flags.setting_break 08/22/83 Steve Herbst
  1    15*   Added flags.executing_quit_request 01/15/85 Steve Herbst
  1    16**/
  1    17 
  1    18 dcl 1 probe_info aligned based (probe_info_ptr),		/* standard data for a probe invocation */
  1    19     2 probe_info_version fixed bin,			/* version of this structure */
  1    20 
  1    21     2 static_info_ptr pointer unaligned,		/* pointer to static information structure */
  1    22     2 modes_ptr pointer unaligned,			/* pointer to probe_modes structure */
  1    23 
  1    24     2 ptr_to_current_source ptr,			/* current_source is based on this */
  1    25     2 ptr_to_initial_source ptr,			/* initial_source is based on this */
  1    26     2 machine_cond_ptr pointer,			/* pointer to machine conditions, if we faulted to get here */
  1    27 
  1    28     2 token_info aligned,				/* information about token chain currently being processed */
  1    29       3 first_token pointer unaligned,			/* first token in chain */
  1    30       3 ct pointer unaligned, 			/* pointer to current token; updated in MANY places */
  1    31       3 end_token bit (18) aligned,			/* token type at which to stop scanning token chain */
  1    32       3 buffer_ptr pointer unaligned,			/* pointer to input buffer */
  1    33       3 buffer_lth fixed bin (21),			/* and length */
  1    34 
  1    35     2 random_info aligned,
  1    36       3 current_stack_frame pointer unaligned,		/* stack frame pointer for frame in which probe was invoked */
  1    37       3 input_type fixed bin, 			/* current input type */
  1    38       3 language_type fixed bin,			/* current language being processed */
  1    39       3 return_method fixed bin,			/* how we should return after exiting probe */
  1    40       3 entry_method fixed bin,			/* how we got here in the first place */
  1    41       3 pad1 (19) bit (36) aligned,
  1    42 
  1    43     2 break_info,					/* break info -- only interesting if we got here via a break */
  1    44       3 break_slot_ptr pointer,			/* pointer to break slot -- non-null IFF at a break */
  1    45       3 last_break_slot_ptr pointer unaligned,		/* pointer to previous break slot, not presently used */
  1    46       3 break_reset bit (1) aligned,			/* this break has been reset by somebody further on */
  1    47       3 real_break_return_loc pointer,			/* where to REALLY return to, modulo previous bit */
  1    48 
  1    49     2 probe_area_info,				/* information about various probe areas */
  1    50       3 break_segment_ptr pointer unaligned,		/* pointer to Personid.probe */
  1    51       3 break_area_ptr pointer unaligned,		/* pointer to area in break segment */
  1    52       3 scratch_area_ptr pointer unaligned,		/* pointer to probe scratch seg in process dir */
  1    53       3 probe_area_ptr pointer unaligned,		/* This area lasts as long as an invocation of probe. */
  1    54       3 work_area_ptr pointer unaligned,		/* This area lasts as long as the current request line */
  1    55       3 expression_area_ptr pointer unaligned,		/* This area lasts as long as the current command */
  1    56 
  1    57     2 flags aligned,				/* this, in particular, should be saved and restored correctly */
  1    58      (3 execute,					/* "1"b => execute requests, "0"b => just check syntax */
  1    59       3 in_listener,				/* ON => in probe listener loop */
  1    60       3 executing_request,				/* ON => executing a request */
  1    61       3 in_interpret_line,				/* executing in probe_listen_$interpret_line */
  1    62       3 setting_break,				/* executing "after" or "before": check syntax of "if" */
  1    63       3 executing_quit_request,			/* to prevent error looping during "quit" request */
  1    64       3 pad (30)) bit (1) unaligned,
  1    65 
  1    66     2 io_switches,					/* switches probe will do normal I/O on */
  1    67       3 input_switch pointer,
  1    68       3 output_switch pointer,
  1    69 
  1    70     2 error_info,					/* information about the last error saved for later printing */
  1    71       3 error_code fixed bin (35),
  1    72       3 error_message char (300) varying,
  1    73 
  1    74     2 listener_info,				/* internal use by probe listener */
  1    75       3 request_name character (32) varying,		/* primary name of the request being processed */
  1    76       3 abort_probe_label label variable,
  1    77       3 abort_line_label label variable,
  1    78       3 depth fixed binary,				/* count of active invocations of probe */
  1    79       3 previous pointer unaligned,			/* -> previous invocation's info */
  1    80       3 next pointer unaligned,
  1    81 
  1    82     2 end_of_probe_info pointer aligned,
  1    83     2 retry_using_main fixed bin aligned;
  1    84    
  1    85 
  1    86 dcl  probe_info_ptr pointer;
  1    87 
  1    88 dcl  probe_info_version fixed bin static options (constant) initial (1);
  1    89 
  1    90 dcl  probe_info_version_1 fixed bin static options (constant) initial (1);
  1    91 
  1    92 dcl  scratch_area area based (probe_info.scratch_area_ptr);
  1    93 dcl  probe_area area based (probe_info.probe_area_ptr);
  1    94 dcl  work_area area based (probe_info.work_area_ptr);
  1    95 dcl  expression_area area based (probe_info.expression_area_ptr);
  1    96 
  1    97 /*	END INCLUDE FILE probe_info.incl.pl1		*/
      694 
      695 
  2     1 /* BEGIN INCLUDE FILE ...  probe_break_slot.incl.pl1
  2     2*
  2     3*   This is separate from probe_break_info.incl.pl1 because many programs
  2     4*   need to get at a break_slot, but don't deserve to see the rest of that information
  2     5*
  2     6**/
  2     7 
  2     8 dcl 1 break_slot based (bsp) aligned,			/* describes (and handles) each probe break */
  2     9     2 item_type fixed bin,				/* 0 -> break_slot type code */
  2    10     2 breakmap_header_offset bit (18) unal,		/* to break map header, chain is not used */
  2    11     2 statement_item_offset bit (18) unal,
  2    12     2 size fixed bin,				/* number of words in the break_slot */
  2    13     2 sequence (0:7),				/* "before" or "after" instructions to "trap" the break */
  2    14       3 offset bit (18) unaligned,			/* address portion, some patched */
  2    15       3 skip bit (18) unaligned,			/* op code portion */
  2    16     2 old_instruction bit (36) aligned,			/* instruction that was replaced by break */
  2    17     2 symbol_block_offset bit (18) unal,		/*  for containing block */
  2    18     2 location bit (18) unal,				/* offset of instruction that was replaced by break */
  2    19     2 type fixed bin,				/* 0 -> after, 1 -> before */
  2    20     2 count fixed bin,				/* number of characters in command list */
  2    21     2 command_list character (0 refer (break_slot.count));	/* command list associated with break */
  2    22 
  2    23 dcl bsp ptr;
  2    24 
  2    25 dcl (BREAK_AFTER init (0),
  2    26      BREAK_BEFORE init (1),
  2    27      BREAK_AT init (2)) fixed bin internal static options (constant);
  2    28 
  2    29 dcl  PLACE (0:2) char (8) aligned internal static options (constant) init ("after", "before", "at");
  2    30 
  2    31 /* END INCLUDE FILE ... probe_break_slot.incl.pl1 */
      696 
      697 
  3     1 /*	BEGIN INCLUDE FILE probe_info_constants.incl.pl1	*/
  3     2 /*	Created: 06/25/79 W. Olin Sibert		*/
  3     3 
  3     4 dcl (RETURN_TO_CALLER init (1),			/* return methods */
  3     5      RETURN_TO_FRAME init (2),
  3     6      RETURN_TO_CONDITION init (3),
  3     7      RETURN_TO_BREAK init (4)) fixed bin internal static options (constant);
  3     8 
  3     9 dcl (ENTRY_AT_CALL init (1),				/* entered by a call to probe */
  3    10      ENTRY_AT_BREAK init (2), 			/* entered by a call to probe$break */
  3    11      ENTRY_AT_HALT init (3)) fixed bin internal static options (constant); /* entered by a call to probe$halt */
  3    12 
  3    13 dcl (CONSOLE_INPUT init (1),
  3    14      BREAK_INPUT init (2),
  3    15      MACRO_INPUT init (3)) fixed bin internal static options (constant);
  3    16 
  3    17 /*	END INCLUDE FILE probe_info_constants.incl.pl1	*/
      698 
      699 
  4     1 /* BEGIN INCLUDE FILE  ... probe_lang_types.incl.pl1
  4     2*
  4     3*   JRD 26 June 79
  4     4*   MBW 31 July 1981 to add algol68 */
  4     5 
  4     6 
  4     7 /****^  HISTORY COMMENTS:
  4     8*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  4     9*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  4    10*     Added C Language type.
  4    11*                                                   END HISTORY COMMENTS */
  4    12 
  4    13 
  4    14 /*   Modified June 83 JMAthane to add PASCAL language type */
  4    15 /*   Modified April 88 Hinatsu to add C language type */
  4    16 
  4    17      dcl	   (UNKNOWN_lang_type     init (1),
  4    18 	   OTHER_lang_type	      init (2),
  4    19 	   PL1_lang_type	      init (3),
  4    20 	   FORTRAN_lang_type      init (4),
  4    21 	   COBOL_lang_type	      init (5),
  4    22 	   ALM_lang_type	      init (6),
  4    23 	   ALGOL68_lang_type      init (7),
  4    24 	   PASCAL_lang_type	      init (8),
  4    25 	   C_lang_type	      init (9)) fixed bin internal static options (constant);
  4    26 
  4    27      dcl	   official_language_names (9) char (32) internal static options (constant) init
  4    28 			      ("Unknown", "other", "PL/I", "FORTRAN", "COBOL", "ALM", "Algol 68", "Pascal", "C");
  4    29 
  4    30      dcl	   palatable_language_names (9) char (32) internal static options (constant) init
  4    31 			      ("Unknown", "Other", "pl1", "fortran", "cobol", "alm", "algol68", "pascal", "c");
  4    32 
  4    33 /* END INCLUDE FILE ... probe_lang_types.incl.pl1 */
      700 
      701 
  5     1 /* BEGIN INCLUDE FILE ... probe_operators.incl.pl1 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  5     7*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  5     8*     Added new C operators.
  5     9*                                                   END HISTORY COMMENTS */
  5    10 
  5    11 
  5    12 /* These are the operator.types for each defined operator */
  5    13 /* Modified June 83 JMAthane for PASCAL_ARROW new operator */
  5    14 /* Added PASCAL_RANGE and PASCAL_ASSIGN 07/26/83 S. Herbst */
  5    15 /* Modified April 88 Hinatsu Addition of C types */
  5    16 
  5    17      dcl	   (PLUS		      init ("400001"b3), MINUS init ("400002"b3),
  5    18 	   TIMES		      init ("400003"b3), SLASH init ("400004"b3),
  5    19 	   OR_BAR		      init ("400005"b3), NOT_SIGN init ("400006"b3),
  5    20 	   LESS_THAN	      init ("400007"b3), GREATER_THAN init ("400010"b3),
  5    21 	   EQUALS		      init ("400011"b3), NOT_EQUALS init ("400012"b3),
  5    22 	   NOT_GREATER_THAN	      init ("400013"b3), NOT_LESS_THAN init ("400014"b3),
  5    23 	   PERIOD		      init ("400015"b3), COLON init ("400016"b3),
  5    24 	   AMPERSAND	      init ("400017"b3), PERCENT init ("400020"b3),
  5    25 	   DOLLAR_SIGN	      init ("400021"b3), LEFT_BRACKET init ("400022"b3),
  5    26 	   RIGHT_BRACKET	      init ("400023"b3), ARROW init ("400024"b3),
  5    27 	   COMMA		      init ("400025"b3), QUESTION_MARK init ("400026"b3),
  5    28 	   PASCAL_ARROW	      init ("400027"b3), PASCAL_RANGE init ("400030"b3),
  5    29 	   PASCAL_ASSIGN	      init ("400031"b3),
  5    30 
  5    31 /* Additons to support C types */
  5    32 	   C_LEFT_SHIFT           init ("400032"b3), C_RIGHT_SHIFT init ("400033"b3),
  5    33 
  5    34 /* operator 28 are left for future expansion */
  5    35 
  5    36 	   LEFT_PAREN	      init ("400035"b3), RIGHT_PAREN init ("400036"b3),
  5    37              C_EQUAL                init ("400037"b3), C_NOT_EQUAL init ("400040"b3),
  5    38 	   SEMI_COLON	      init ("400041"b3), NEW_LINE init ("400042"b3),
  5    39 	   C_INDIRECTION          init ("400034"b3)
  5    40 
  5    41 	   )		      bit (18) aligned internal static options (constant);
  5    42 
  5    43      dcl	   OPERATOR_VALUES	      (0:34) char (4) varying internal static options (constant) init
  5    44 			      ("????", "+", "-", "*", "/", "|", "^", "<",
  5    45 			      ">", "=", "^=", "<=", ">=", ".", ":", "&",
  5    46 			      "%", "$", "[", "]", "->", ",", "?", "^",
  5    47 			      "..", ":=", "<<", ">>", "*", "(", ")",
  5    48 			      "==", "!=", ";","
  5    49 ");
  5    50 
  5    51 /* END INCLUDE FILE ... probe_operators.incl.pl1 */
      702 
      703 
  6     1 /*	BEGIN INCLUDE FILE probe_references.incl.pl1	*/
  6     2 
  6     3 /****^  HISTORY COMMENTS:
  6     4*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  6     5*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  6     6*     Added new field (c_symbol) for C-Probe support.
  6     7*  2) change(88-10-28,WAAnderson), approve(88-10-28,MCR7952),
  6     8*     audit(88-10-31,RWaters), install(88-11-11,MR12.2-1210):
  6     9*     Added new field (c_sub_c_ptr) for C-Probe_support.
  6    10*                                                   END HISTORY COMMENTS */
  6    11 
  6    12 /*	Split out of probe_tokens, 04/22/79 WOS 	*/
  6    13 /*       modified for probe variables Feb 19 80 JRD         */
  6    14 /*   Modified June 83 JMAthane to add "type_ptr" and "builtin" fields */
  6    15 
  6    16      dcl	   1 reference_node	      aligned based,	/* information about a reference */
  6    17 	     2 symbol_ptr	      pointer aligned,	/* to symbol table entry for reference */
  6    18 	     2 type_ptr	      pointer aligned,	/* to symbol table entry for type (null if none) */
  6    19 	     2 address_ptr	      pointer aligned,	/* to location of variable */
  6    20 	     2 base_addr	      pointer aligned,	/* pointer on which whole symbol is based */
  6    21 	     2 source_info_ptr    pointer aligned,	/* to symbol structure for reference */
  6    22 
  6    23 	     2 name	      char (256) unaligned varying, /* symbol name */
  6    24 
  6    25 	     2 type	      fixed bin (35),	/* data type */
  6    26 	     2 descriptor	      fixed bin (35),	/* type || packed */
  6    27 	     2 precision	      fixed bin (35),	/* scale and precision */
  6    28 	     2 flags,
  6    29 	       3 packed	      bit (1) unal,		/* data is in packed format */
  6    30 	       3 constant	      bit (1) unal,		/* data is really a constant */
  6    31 	       3 cross_section    bit (1) unal,		/* reference is an array cross-section */
  6    32 	       3 function	      bit (1) unal,		/* reference is function value */
  6    33 	       3 octal	      bit (1) unal,		/* indicates that this is the octal bif */
  6    34 	       3 star_extent      bit (1) unal,		/* reference is a star subscript for father */
  6    35 	       3 have_generation  bit (1) unal,		/* this reference has an explicitly specified generation */
  6    36 	       3 pseudo_var	      bit (1) unal,		/* it is ok to assign to it */
  6    37 	       3 probe_variable   bit (1) unal,
  6    38 	       3 path	      bit (1) unal,		/* it's a pathname/virtual entry */
  6    39 	       3 builtin	      bit (1) unal,		/* probe builtinvalue */
  6    40 	       3 c_ptr_to_char    bit (1)  unal,
  6    41                  3 c_sub_c_ptr      bit (1)  unal,
  6    42 	       3 pad2	      bit (23) unal,
  6    43 
  6    44 	     2 optional_info,			/* information which may or may not be present */
  6    45 	       3 argument_list    pointer unaligned,	/* pointer to reference_arg_list */
  6    46 	       3 subscript_ptr    pointer unaligned,	/* pointer to reference_subscripts */
  6    47 	       3 n_arguments      fixed bin,		/* number of arguments in argument list */
  6    48 	       3 n_subscripts     fixed bin,		/* number of subscripts present */
  6    49 
  6    50 	     2 constant_token_ptr pointer unaligned,	/* pointer to constant token if this is a constant */
  6    51 	     2 subscript_refs_ptr pointer unaligned,	/* pointer to array of subscript reference node pointers */
  6    52 	     2 invocation_level   fixed bin,		/* invocation level number ("[-17]") for this reference */
  6    53 	     2 probe_var_info_ptr ptr unal,		/* only if flags.probe_variable */
  6    54                2 c_symbol_ptr  ptr unal,
  6    55 	     2 pad1	      (9) pointer unaligned,
  6    56 	     2 end_of_reference_node pointer aligned;
  6    57 
  6    58 
  6    59      dcl	   1 reference_arg_list   aligned based,	/* argument list; based on reference.argument_list */
  6    60 	     2 number	      fixed bin,		/* number of arguments actually present */
  6    61 	     2 node	      (16) pointer aligned;	/* reference node pointers for each argument */
  6    62 
  6    63 
  6    64      dcl	   1 reference_subscripts aligned based,	/* subscript array; based on reference.subscript_ptr */
  6    65 	     2 number	      fixed bin,		/* number actually present */
  6    66 	     2 value	      (2, 16) fixed bin (24); /* values for lower and upper bound for each */
  6    67 
  6    68 
  6    69      dcl	   1 subscript_reference_ptrs aligned based,	/* array of pointers to subscript reference nodes */
  6    70 	     2 ptr	      (2, 16) pointer aligned;
  6    71 
  6    72 /*	END INCLUDE FILE probe_references.incl.pl1	*/
      704 
      705 
  7     1 /* BEGIN INCLUDE FILE ... probe_seg_info.incl.pl1
  7     2*
  7     3*   25 June 79 JRDavis
  7     4*
  7     5*   Modified  7 April 1983, TO - Add fields for character offset/line
  7     6*	correction per file.
  7     7**/
  7     8 
  7     9 dcl 1 seg_info based aligned,				/* place to remember information about object seg */
  7    10     2 language_type fixed bin,			/* language of source program */
  7    11     2 bits aligned,
  7    12       3 ignore_case bit (1) unal,
  7    13       3 bound_segment bit (1) unaligned,
  7    14       3 component bit (1) unaligned,
  7    15       3 pad bit (33) unal,
  7    16     2 names,					/* where to find it */
  7    17       3 directory_name character (168) unal,		/* what directory */
  7    18       3 entry_name character (32) unal,			/* what segment */
  7    19       3 segname character (32) unal,			/* procedure segname definition */
  7    20     2 identifier fixed bin (71),			/* time of object creation */
  7    21     2 pointers,					/* location of various parts of segment */
  7    22       3 symbol_header_ptr ptr unal,			/* to symbol section */
  7    23       3 original_source_ptr ptr unal,			/* to segment source map */
  7    24       3 statement_map_ptr ptr unal,			/* to segment statement map */
  7    25       3 break_info ptr unal,				/* for unbound segments, and start of chain for
  7    26*						   bound ones, -> break_map !obsolete, I think! */
  7    27       3 chain ptr unal,				/* to entry for next component if bound */
  7    28       3 linkage_ptr ptr unal,				/* to linkage section */
  7    29     2 bounds aligned,				/* structure of bounds information */
  7    30       3 text_bounds,
  7    31         4 start fixed bin (35),
  7    32         4 end fixed bin (35),
  7    33       3 symbol_bounds,
  7    34         4 start fixed bin (35),
  7    35         4 end fixed bin (35),
  7    36     2 map_size fixed bin,				/* size of statement map */
  7    37     2 error_code fixed bin (35),			/* errors encoutered while getting info, are recorded here */
  7    38     2 bound_create_time fixed bin (71),			/* time seg containing was bound or compiled. */
  7    39     2 bound_sym_header ptr unal,			/* to sym. section header for bound seg */
  7    40     2 pad (1) fixed bin (35),
  7    41 
  7    42     2 nfiles fixed bin,
  7    43     2 per_file (seg_info_nfiles refer (seg_info.nfiles)),
  7    44       3 file_pointers ptr unal,
  7    45       3 break_line (0:3) fixed bin (18) unsigned unaligned;
  7    46 
  7    47 dcl  seg_info_nfiles fixed bin;			/* for allocation purposes */
  7    48 
  7    49 
  7    50 /* END INCLUDE FILE ... probe_seg_info.incl.pl1 */
      706 
      707 
  8     1 /* BEGIN INCLUDE FILE ... probe_source_info.incl.pl1
  8     2*
  8     3*  James R. Davis 2 July 79 */
  8     4 
  8     5 dcl 1 source_info based aligned,
  8     6       2 stmnt_map_entry_index fixed bin,		/* index in stmnt map for this stmnt */
  8     7       2 instruction_ptr ptr,				/* to last instruction executed  */
  8     8       2 block_ptr ptr,				/* to runtime_block node */
  8     9       2 stack_ptr ptr,				/* to a stack frame */
  8    10       2 entry_ptr ptr,				/* to entry seq. for this proc */
  8    11       2 seg_info_ptr ptr;				/* to seg_info */
  8    12 
  8    13 dcl 1 current_source aligned like source_info based (probe_info.ptr_to_current_source);
  8    14 dcl 1 initial_source aligned like source_info based (probe_info.ptr_to_initial_source);
  8    15 
  8    16 /* END INCLUDE FILE ... probe_source_info.incl.pl1 */
      708 
      709 
  9     1 /*	BEGIN INCLUDE FILE probe_tokens.incl.pl1	*/
  9     2 /*	Split up into probe_tokens and probe_references, 04/22/79 WOS */
  9     3 
  9     4 dcl 1 token_header aligned based,			/* header information common to all tokens */
  9     5     2 next pointer unaligned,				/* pointer to next token in chain */
  9     6     2 prev pointer unaligned,				/* same for previous token */
  9     7     2 type bit (18) aligned,
  9     8     2 buffer_ptr pointer unaligned,			/* pointer to beginning of input buffer */
  9     9     2 location fixed bin (17) unal,			/* offset in input buffer */
  9    10     2 length fixed bin (17) unal,
  9    11     2 flags aligned,
  9    12      (3 leading_whitespace,				/* there is whitespace before thios token */
  9    13       3 trailing_whitespace) bit (1) unaligned,		/* and same for after */
  9    14       3 pad1 bit (34) unaligned;
  9    15 
  9    16 dcl 1 token aligned based,				/* produced by scan_probe_input_ */
  9    17     2 header aligned like token_header;			/* that's all there is */
  9    18 
  9    19 dcl 1 identifier aligned based,			/* keyword or identifier token */
  9    20     2 header aligned like token_header,
  9    21     2 length fixed bin,				/* length of name */
  9    22     2 name pointer unaligned;				/* to string in buffer containing name */
  9    23 
  9    24 dcl 1 operator aligned based,				/* for punctuation */
  9    25     2 header aligned like token_header;			/* nothing but a header here */
  9    26 
  9    27 dcl 1 constant aligned based,				/* for strings pointers numbers etc */
  9    28     2 header aligned like token_header,
  9    29     2 encoded_precision aligned,			/* encoded precision kludge for assign_ */
  9    30       3 scale fixed bin (17) unaligned,			/* arithmetic scale */
  9    31       3 precision fixed bin (17) unaligned,		/* arithmetic precision or other size */
  9    32     2 scale_and_precision fixed bin (35),		/* An identical copy of the two values above */
  9    33     2 data_type fixed bin,				/* standard data type code + packed bit */
  9    34     2 data_ptr pointer unaligned;
  9    35 
  9    36 
  9    37 dcl (OPERATOR_TYPE init ("100"b),			/* types for above */
  9    38      NAME_TYPE init ("010"b),
  9    39      CONSTANT_TYPE init ("001"b)) bit (18) internal static options (constant);
  9    40 
  9    41 
  9    42 dcl  current_identifier_name				/* Overlays for looking at the current tokens */
  9    43      char (probe_info.ct -> identifier.length) based (probe_info.ct -> identifier.name);
  9    44 dcl 1 current_constant aligned like constant based (probe_info.ct);
  9    45 dcl 1 current_token aligned like token based (probe_info.ct);
  9    46 
  9    47 /*	END INCLUDE FILE probe_tokens.incl.pl1		*/
      710 
      711 
 10     1 /*	BEGIN INCLUDE FILE ... runtime_symbol.incl.pl1 ... Modified 07/79 */
 10     2 
 10     3 dcl	1 runtime_symbol	aligned based,
 10     4 	2 flag		unal bit(1),	/* always "1"b for Version II */
 10     5 	2 use_digit	unal bit(1),	/* if "1"b and units are half words units are really digits */
 10     6 	2 array_units	unal bit(2),
 10     7 	2 units		unal bit(2),	/* addressing units */
 10     8 	2 type		unal bit(6),	/* data type */
 10     9 	2 level		unal bit(6),	/* structure level */
 10    10 	2 ndims		unal bit(6),	/* number of dimensions */
 10    11 	2 bits		unal,
 10    12 	  3 aligned	bit(1),
 10    13 	  3 packed	bit(1),
 10    14 	  3 simple	bit(1),
 10    15 	2 skip		unal bit(1),
 10    16 	2 scale		unal bit(8),	/* arithmetic scale factor */
 10    17 	2 name		unal bit(18),	/* rel ptr to acc name */
 10    18 	2 brother		unal bit(18),	/* rel ptr to brother entry */
 10    19 	2 father		unal bit(18),	/* rel ptr to father entry */
 10    20 	2 son		unal bit(18),	/* rel ptr to son entry */
 10    21 	2 address		unal,
 10    22 	  3 location	bit(18),		/* location in storage class */
 10    23 	  3 class		bit(4),		/* storage class */
 10    24 	  3 next		bit(14),		/* rel ptr to next of same class */
 10    25 	2 size		fixed bin(35),	/* encoded string|arith size */
 10    26 	2 offset		fixed bin(35),	/* encoded offset from address */
 10    27 	2 virtual_org	fixed bin(35),
 10    28 	2 bounds(1),
 10    29 	  3 lower		fixed bin(35),	/* encoded lower bound */
 10    30 	  3 upper		fixed bin(35),	/* encoded upper bound */
 10    31 	  3 multiplier	fixed bin(35);	/* encoded multiplier */
 10    32 
 10    33 dcl	1 runtime_bound	based,
 10    34 	2 lower		fixed bin(35),
 10    35 	2 upper		fixed bin(35),
 10    36 	2 multiplier	fixed bin(35);
 10    37 
 10    38 dcl	1 runtime_block	aligned based,
 10    39 	2 flag		unal bit(1),	/* always "1"b for Version II */
 10    40 	2 quick		unal bit(1),	/* "1"b if quick block */
 10    41 	2 fortran		unal bit(1),	/* "1"b if fortran program */
 10    42 	2 standard	unal bit(1),	/* "1"b if program has std obj segment */
 10    43 	2 owner_flag	unal bit(1),	/* "1"b if block has valid owner field */
 10    44 	2 skip		unal bit(1),
 10    45 	2 type		unal bit(6),	/* = 0 for a block node */
 10    46 	2 number		unal bit(6),	/* begin block number */
 10    47 	2 start		unal bit(18),	/* rel ptr to start of symbols */
 10    48 	2 name		unal bit(18),	/* rel ptr to name of proc */
 10    49 	2 brother		unal bit(18),	/* rel ptr to brother block */
 10    50 	2 father		unal bit(18),	/* rel ptr to father block */
 10    51 	2 son		unal bit(18),	/* rel ptr to son block */
 10    52 	2 map		unal,
 10    53 	  3 first		bit(18),		/* rel ptr to first word of map */
 10    54 	  3 last		bit(18),		/* rel ptr to last word of map */
 10    55 	2 entry_info	unal bit(18),	/* info about entry of quick block */
 10    56 	2 header		unal bit(18),	/* rel ptr to symbol header */
 10    57 	2 chain(4)	unal bit(18),	/* chain(i) is rel ptr to first symbol
 10    58*					   on start list with length >= 2**i */
 10    59 	2 token(0:5)	unal bit(18),	/* token(i) is rel ptr to first token
 10    60*					   on list with length >= 2 ** i */
 10    61 	2 owner		unal bit(18);	/* rel ptr to owner block */
 10    62 
 10    63 dcl	1 runtime_token	aligned based,
 10    64 	2 next		unal bit(18),	/* rel ptr to next token */
 10    65 	2 dcl		unal bit(18),	/* rel ptr to first dcl of this token */
 10    66 	2 name,				/* ACC */
 10    67 	  3 size		unal unsigned fixed bin (9), /* number of chars in token */
 10    68 	  3 string	unal char(n refer(runtime_token.size));
 10    69 
 10    70 dcl	1 encoded_value	aligned based,
 10    71 	2 flag		bit (2) unal,
 10    72 	2 code		bit (4) unal,
 10    73 	2 n1		bit (6) unal,
 10    74 	2 n2		bit (6) unal,
 10    75 	2 n3		bit (18) unal;
 10    76 
 10    77 /*	END INCLUDE FILE ... runtime_symbol.incl.pl1 */
      712 
      713 
 11     1 /*  BEGIN INCLUDE FILE runtime_symbol_info_.incl.pl1 */
 11     2 
 11     3 
 11     4 /****^  HISTORY COMMENTS:
 11     5*  1) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
 11     6*     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1208):
 11     7*     Added runtime_symbol_info_$subrange entry which was missing.  Added
 11     8*     has_dimensions and has subrange_limits fields in type_info record.
 11     9*     Structure version numbers have not been changed since this change does not
 11    10*     affect existing programs.
 11    11*                                                   END HISTORY COMMENTS */
 11    12 
 11    13 /* Declarations for using the various entry points in runtime_symbol_info_ */
 11    14 /* NOTE: These entries do not support PL/1 version 1. */
 11    15 
 11    16 /* Made structures aligned, removed variable extent from runtime_array_info.bounds 08/25/83 S. Herbst */
 11    17 /* Added version strings to structures 10/05/83 S. Herbst */
 11    18 /* Added has_dimensions and has_subrange_limits bits in type_info
 11    19*Added subrange entry. JMAthane 08/31/84 */
 11    20 
 11    21 
 11    22      dcl	   runtime_symbol_info_$type entry (ptr, ptr, fixed bin (35));
 11    23 
 11    24      dcl	   1 runtime_type_info    aligned based,
 11    25 	     2 version	      char (8),		/* = "RUNTYP_1" */
 11    26 	     2 flags,
 11    27 	       3 aligned	      bit (1) unal,
 11    28 	       3 packed	      bit (1) unal,
 11    29 	       3 size_is_encoded  bit (1) unal,
 11    30 	       3 has_dimensions   bit (1) unal,
 11    31 	       3 has_subrange_limits bit (1) unal,
 11    32 	       3 pad	      bit (23) unal,
 11    33 	     2 scale	      fixed bin (7) unal,
 11    34 	     2 (type, base_type)  fixed bin (18) unsigned unal,
 11    35 	     2 (type_addr, base_type_addr) ptr,
 11    36 	     2 size	      fixed bin (35);
 11    37 
 11    38      dcl	   runtime_symbol_info_$father entry (ptr) returns (ptr);
 11    39 
 11    40      dcl	   runtime_symbol_info_$brother entry (ptr) returns (ptr);
 11    41 
 11    42      dcl	   runtime_symbol_info_$father_type entry (ptr) returns (ptr);
 11    43 
 11    44      dcl	   runtime_symbol_info_$son entry (ptr) returns (ptr);
 11    45 
 11    46      dcl	   runtime_symbol_info_$successor entry (ptr) returns (ptr);
 11    47 
 11    48      dcl	   runtime_symbol_info_$name entry (ptr) returns (ptr);
 11    49 
 11    50      dcl	   runtime_symbol_info_$level entry (ptr) returns (fixed bin);
 11    51 
 11    52      dcl	   runtime_symbol_info_$next entry (ptr) returns (ptr);
 11    53 
 11    54      dcl	   runtime_symbol_info_$address entry (ptr, ptr, fixed bin (35));
 11    55 
 11    56      dcl	   1 runtime_address_info aligned based,
 11    57 	     2 version	      char (8),		/* = "RUNADR_1" */
 11    58 	     2 location	      fixed bin (18) unsigned unal,
 11    59 	     2 class	      fixed bin (6) unsigned unal,
 11    60 	     2 use_digit	      fixed bin (1) unsigned unal,
 11    61 	     2 units	      fixed bin (2) unsigned unal,
 11    62 	     2 offset_is_encoded  bit (1) unal,
 11    63 	     2 pad	      bit (8) unal,
 11    64 	     2 offset	      fixed bin (35);
 11    65 
 11    66      dcl	   runtime_symbol_info_$array_dims entry (ptr) returns (fixed bin);
 11    67 
 11    68      dcl	   runtime_symbol_info_$array entry (ptr, ptr, fixed bin (35));
 11    69 
 11    70      dcl	   1 runtime_array_info   aligned based,
 11    71 	     2 version	      char (8),		/* = "RUNARY_1" */
 11    72 	     2 access_info	      aligned,
 11    73 	       3 ndims	      fixed bin (6) unsigned unaligned, /* number of dimensions */
 11    74 	       3 use_digit	      fixed bin (1) unsigned unaligned, /* if "1"b and units are half words,
 11    75*						      units are really digits */
 11    76 	       3 array_units      fixed bin (2) unsigned unaligned,
 11    77 	       3 virtual_origin_is_encoded
 11    78 			      bit (1) unaligned,
 11    79 	       3 pad	      bit (26) unaligned,
 11    80 	     2 virtual_origin     fixed bin (35),
 11    81 	     2 bounds	      (16)
 11    82 			      aligned,
 11    83 	       3 flags	      aligned,
 11    84 	         4 lower_is_encoded
 11    85 			      bit (1) unaligned,
 11    86 	         4 upper_is_encoded
 11    87 			      bit (1) unaligned,
 11    88 	         4 multiplier_is_encoded
 11    89 			      bit (1) unaligned,
 11    90 	         4 pad	      bit (33) unaligned,
 11    91 	       3 lower	      fixed bin (35),
 11    92 	       3 upper	      fixed bin (35),
 11    93 	       3 multiplier	      fixed bin (35),
 11    94 	       3 subscript_type   fixed bin (35),
 11    95 	       3 subscript_type_addr ptr;
 11    96 
 11    97      dcl	   n_dims		      fixed bin;
 11    98 
 11    99      dcl	   runtime_symbol_info_$n_variants entry (ptr) returns (fixed bin (35));
 11   100 
 11   101      dcl	   runtime_symbol_info_$variant entry (ptr, ptr, fixed bin (35));
 11   102 
 11   103      dcl	   1 runtime_variant_info aligned based,
 11   104 	     2 version	      char (8),		/* = "RUNVAR_1" */
 11   105 	     2 number_of_variants fixed bin,
 11   106 	     2 first_value_in_set fixed bin (35),	/* value corresponding to the first bit in set stings  */
 11   107 	     2 case	      (n_variants),
 11   108 	       3 set_addr	      ptr,		/* bit string specifies cases;
 11   109*						       set's base type is this node's type */
 11   110 	       3 brother_addr     ptr;		/* ptr to brother for this variant */
 11   111 
 11   112      dcl	   n_variants	      fixed bin (35);
 11   113 
 11   114      dcl	   runtime_symbol_info_$subrange entry (ptr, ptr, fixed bin (35));
 11   115 
 11   116      dcl	   1 runtime_subrange_info based,
 11   117 	     2 version	      char (8),		/* = "RUNSUB_1" */
 11   118 	     2 flags	      aligned,
 11   119 	       3 has_subrange_limits bit (1) unal,
 11   120 	       3 lower_bound_is_encoded bit (1) unal,
 11   121 	       3 upper_bound_is_encoded bit (1) unal,
 11   122 	       3 pad	      bit (33) unal,
 11   123 	     2 subrange_lower_bound fixed bin (35),
 11   124 	     2 subrange_upper_bound fixed bin (35);
 11   125 
 11   126 
 11   127      dcl	   RUNTIME_TYPE_INFO_VERSION_1 char (8) int static options (constant) init ("RUNTYP_1");
 11   128      dcl	   RUNTIME_ADDRESS_INFO_VERSION_1 char (8) int static options (constant) init ("RUNADR_1");
 11   129      dcl	   RUNTIME_ARRAY_INFO_VERSION_1 char (8) int static options (constant) init ("RUNARY_1");
 11   130      dcl	   RUNTIME_VARIANT_INFO_VERSION_1 char (8) int static options (constant) init ("RUNVAR_1");
 11   131      dcl	   RUNTIME_SUBRANGE_INFO_VERSION_1 char (8) int static options (constant) init ("RUNSUB_1");
 11   132 
 11   133 
 11   134 /* END INCLUDE FILE runtime_symbol_info_.incl.pl1 */
      714 
      715 
 12     1 dcl	1 statement_map	aligned based,
 12     2 	2 location	bit(18) unaligned,
 12     3 	2 source_id	unaligned,
 12     4 	  3 file		bit(8),
 12     5 	  3 line		bit(14),
 12     6 	  3 statement	bit(5),
 12     7 	2 source_info	unaligned,
 12     8 	  3 start		bit(18),
 12     9 	  3 length	bit(9);
      716 
      717 
 13     1 /* BEGIN INCLUDE FILE ... std_descriptor_types.incl.pl1 */
 13     2 
 13     3 
 13     4 /****^  HISTORY COMMENTS:
 13     5*  1) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
 13     6*     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1208):
 13     7*     Added pascal_string_type_dtype descriptor type.  Its number is 87.
 13     8*     Objects of this type are PASCAL string types.
 13     9*  2) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
 13    10*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
 13    11*     Added the new C types.
 13    12*                                                   END HISTORY COMMENTS */
 13    13 
 13    14 /* This include file defines mnemonic names for the Multics
 13    15*   standard descriptor types, using both pl1 and cobol terminology.
 13    16*   PG 780613
 13    17*   JRD 790530
 13    18*   JRD 791016
 13    19*   MBW 810731
 13    20*   TGO 830614 Add hex types.
 13    21*   Modified June 83 JMAthane to add PASCAL data types
 13    22*   TGO 840120 Add float dec extended and generic, float binary generic
 13    23**/
 13    24 
 13    25      dcl	   (real_fix_bin_1_dtype  init (1),
 13    26 	   real_fix_bin_2_dtype   init (2),
 13    27 	   real_flt_bin_1_dtype   init (3),
 13    28 	   real_flt_bin_2_dtype   init (4),
 13    29 	   cplx_fix_bin_1_dtype   init (5),
 13    30 	   cplx_fix_bin_2_dtype   init (6),
 13    31 	   cplx_flt_bin_1_dtype   init (7),
 13    32 	   cplx_flt_bin_2_dtype   init (8),
 13    33 	   real_fix_dec_9bit_ls_dtype init (9),
 13    34 	   real_flt_dec_9bit_dtype init (10),
 13    35 	   cplx_fix_dec_9bit_ls_dtype init (11),
 13    36 	   cplx_flt_dec_9bit_dtype init (12),
 13    37 	   pointer_dtype	      init (13),
 13    38 	   offset_dtype	      init (14),
 13    39 	   label_dtype	      init (15),
 13    40 	   entry_dtype	      init (16),
 13    41 	   structure_dtype	      init (17),
 13    42 	   area_dtype	      init (18),
 13    43 	   bit_dtype	      init (19),
 13    44 	   varying_bit_dtype      init (20),
 13    45 	   char_dtype	      init (21),
 13    46 	   varying_char_dtype     init (22),
 13    47 	   file_dtype	      init (23),
 13    48 	   real_fix_dec_9bit_ls_overp_dtype init (29),
 13    49 	   real_fix_dec_9bit_ts_overp_dtype init (30),
 13    50 	   real_fix_bin_1_uns_dtype init (33),
 13    51 	   real_fix_bin_2_uns_dtype init (34),
 13    52 	   real_fix_dec_9bit_uns_dtype init (35),
 13    53 	   real_fix_dec_9bit_ts_dtype init (36),
 13    54 	   real_fix_dec_4bit_uns_dtype init (38),	/* digit-aligned */
 13    55 	   real_fix_dec_4bit_ts_dtype init (39),	/* byte-aligned */
 13    56 	   real_fix_dec_4bit_bytealigned_uns_dtype init (40), /* COBOL */
 13    57 	   real_fix_dec_4bit_ls_dtype init (41),	/* digit-aligned */
 13    58 	   real_flt_dec_4bit_dtype init (42),		/* digit-aligned */
 13    59 	   real_fix_dec_4bit_bytealigned_ls_dtype init (43),
 13    60 	   real_flt_dec_4bit_bytealigned_dtype init (44),
 13    61 	   cplx_fix_dec_4bit_bytealigned_ls_dtype init (45),
 13    62 	   cplx_flt_dec_4bit_bytealigned_dtype init (46),
 13    63 	   real_flt_hex_1_dtype   init (47),
 13    64 	   real_flt_hex_2_dtype   init (48),
 13    65 	   cplx_flt_hex_1_dtype   init (49),
 13    66 	   cplx_flt_hex_2_dtype   init (50),
 13    67 	   c_typeref_dtype        init (54),
 13    68 	   c_enum_dtype           init (55),
 13    69              c_enum_const_dtype     init (56),
 13    70 	   c_union_dtype          init (57),
 13    71 	   algol68_straight_dtype init (59),
 13    72 	   algol68_format_dtype   init (60),
 13    73 	   algol68_array_descriptor_dtype init (61),
 13    74 	   algol68_union_dtype    init (62),
 13    75 
 13    76 	   cobol_comp_6_dtype     init (1),
 13    77 	   cobol_comp_7_dtype     init (1),
 13    78 	   cobol_display_ls_dtype init (9),
 13    79 	   cobol_structure_dtype  init (17),
 13    80 	   cobol_char_string_dtype init (21),
 13    81 	   cobol_display_ls_overp_dtype init (29),
 13    82 	   cobol_display_ts_overp_dtype init (30),
 13    83 	   cobol_display_uns_dtype init (35),
 13    84 	   cobol_display_ts_dtype init (36),
 13    85 	   cobol_comp_8_uns_dtype init (38),		/* digit aligned */
 13    86 	   cobol_comp_5_ts_dtype  init (39),		/* byte aligned */
 13    87 	   cobol_comp_5_uns_dtype init (40),
 13    88 	   cobol_comp_8_ls_dtype  init (41),		/* digit aligned */
 13    89 	   real_flt_dec_extended_dtype init (81),	/* 9-bit exponent */
 13    90 	   cplx_flt_dec_extended_dtype init (82),	/* 9-bit exponent */
 13    91 	   real_flt_dec_generic_dtype init (83),	/* generic float decimal */
 13    92 	   cplx_flt_dec_generic_dtype init (84),
 13    93 	   real_flt_bin_generic_dtype init (85),	/* generic float binary */
 13    94 	   cplx_flt_bin_generic_dtype init (86)) fixed bin internal static options (constant);
 13    95 
 13    96      dcl	   (ft_integer_dtype      init (1),
 13    97 	   ft_real_dtype	      init (3),
 13    98 	   ft_double_dtype	      init (4),
 13    99 	   ft_complex_dtype	      init (7),
 13   100 	   ft_complex_double_dtype init (8),
 13   101 	   ft_external_dtype      init (16),
 13   102 	   ft_logical_dtype	      init (19),
 13   103 	   ft_char_dtype	      init (21),
 13   104 	   ft_hex_real_dtype      init (47),
 13   105 	   ft_hex_double_dtype    init (48),
 13   106 	   ft_hex_complex_dtype   init (49),
 13   107 	   ft_hex_complex_double_dtype init (50)
 13   108 	   )		      fixed bin internal static options (constant);
 13   109 
 13   110      dcl	   (algol68_short_int_dtype init (1),
 13   111 	   algol68_int_dtype      init (1),
 13   112 	   algol68_long_int_dtype init (2),
 13   113 	   algol68_real_dtype     init (3),
 13   114 	   algol68_long_real_dtype init (4),
 13   115 	   algol68_compl_dtype    init (7),
 13   116 	   algol68_long_compl_dtype init (8),
 13   117 	   algol68_bits_dtype     init (19),
 13   118 	   algol68_bool_dtype     init (19),
 13   119 	   algol68_char_dtype     init (21),
 13   120 	   algol68_byte_dtype     init (21),
 13   121 	   algol68_struct_struct_char_dtype init (22),
 13   122 	   algol68_struct_struct_bool_dtype init (20)
 13   123 	   )		      fixed bin internal static options (constant);
 13   124 
 13   125      dcl	   (label_constant_runtime_dtype init (24),
 13   126 	   int_entry_runtime_dtype init (25),
 13   127 	   ext_entry_runtime_dtype init (26),
 13   128 	   ext_procedure_runtime_dtype init (27),
 13   129 	   picture_runtime_dtype  init (63)
 13   130 	   )		      fixed bin internal static options (constant);
 13   131 
 13   132      dcl	   (pascal_integer_dtype  init (1),
 13   133 	   pascal_real_dtype      init (4),
 13   134 	   pascal_label_dtype     init (24),
 13   135 	   pascal_internal_procedure_dtype init (25),
 13   136 	   pascal_exportable_procedure_dtype init (26),
 13   137 	   pascal_imported_procedure_dtype init (27),
 13   138 	   pascal_typed_pointer_type_dtype init (64),
 13   139 	   pascal_char_dtype      init (65),
 13   140 	   pascal_boolean_dtype   init (66),
 13   141 	   pascal_record_file_type_dtype init (67),
 13   142 	   pascal_record_type_dtype init (68),
 13   143 	   pascal_set_dtype	      init (69),
 13   144 	   pascal_enumerated_type_dtype init (70),
 13   145 	   pascal_enumerated_type_element_dtype init (71),
 13   146 	   pascal_enumerated_type_instance_dtype init (72),
 13   147 	   pascal_user_defined_type_dtype init (73),
 13   148 	   pascal_user_defined_type_instance_dtype init (74),
 13   149 	   pascal_text_file_dtype init (75),
 13   150 	   pascal_procedure_type_dtype init (76),
 13   151 	   pascal_variable_formal_parameter_dtype init (77),
 13   152 	   pascal_value_formal_parameter_dtype init (78),
 13   153 	   pascal_entry_formal_parameter_dtype init (79),
 13   154 	   pascal_parameter_procedure_dtype init (80),
 13   155 	   pascal_string_type_dtype init (87)) fixed bin int static options (constant);
 13   156 
 13   157 
 13   158 /* END INCLUDE FILE ... std_descriptor_types.incl.pl1 */
      718 
      719 
      720 
      721   end probe_expr_requests_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/88  1545.0  probe_expr_requests_.pl1          >spec>install>MR12.2-1210>probe_expr_requests_.pl1
694          1    10/27/88  1339.2  probe_info.incl.pl1               >ldd>include>probe_info.incl.pl1
696          2    07/15/80  1728.8  probe_break_slot.incl.pl1         >ldd>include>probe_break_slot.incl.pl1
698          3    11/26/79  1320.9  probe_info_constants.incl.pl1     >ldd>include>probe_info_constants.incl.pl1
700          4    10/26/88  1255.5  probe_lang_types.incl.pl1         >ldd>include>probe_lang_types.incl.pl1
702          5    10/26/88  1255.5  probe_operators.incl.pl1          >ldd>include>probe_operators.incl.pl1
704          6    11/11/88  1543.8  probe_references.incl.pl1         >spec>install>MR12.2-1210>probe_references.incl.pl1
706          7    11/02/83  1845.0  probe_seg_info.incl.pl1           >ldd>include>probe_seg_info.incl.pl1
708          8    11/26/79  1320.6  probe_source_info.incl.pl1        >ldd>include>probe_source_info.incl.pl1
710          9    11/26/79  1320.6  probe_tokens.incl.pl1             >ldd>include>probe_tokens.incl.pl1
712         10    11/26/79  1320.6  runtime_symbol.incl.pl1           >ldd>include>runtime_symbol.incl.pl1
714         11    11/12/86  1748.0  runtime_symbol_info_.incl.pl1     >ldd>include>runtime_symbol_info_.incl.pl1
716         12    05/06/74  1751.6  statement_map.incl.pl1            >ldd>include>statement_map.incl.pl1
718         13    10/26/88  1255.5  std_descriptor_types.incl.pl1     >ldd>include>std_descriptor_types.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ALGOL68_lang_type                      constant        fixed bin(17,0)          initial dcl 4-17 ref 357
COBOL_lang_type                        constant        fixed bin(17,0)          initial dcl 4-17 ref 350
COLON                                  constant        bit(18)                  initial dcl 5-17 ref 503 565
C_EQUAL                                constant        bit(18)                  initial dcl 5-17 ref 493
C_INDIRECTION                          constant        bit(18)                  initial dcl 5-17 ref 219
C_NOT_EQUAL                            constant        bit(18)                  initial dcl 5-17 ref 499
C_lang_type                            constant        fixed bin(17,0)          initial dcl 4-17 ref 185 489
EQUALS                                 constant        bit(18)                  initial dcl 5-17 ref 271 490 493
FORTRAN_lang_type                      constant        fixed bin(17,0)          initial dcl 4-17 ref 347
LESS_THAN                              constant        bit(18)                  initial dcl 5-17 ref 503
NAME_TYPE                              constant        bit(18)                  initial packed unaligned dcl 9-37 ref 184 320
NOT_EQUALS                             constant        bit(18)                  initial dcl 5-17 ref 496 499
NOT_LESS_THAN                          constant        bit(18)                  initial dcl 5-17 ref 503
PASCAL_ASSIGN                          constant        bit(18)                  initial dcl 5-17 ref 271
PASCAL_lang_type                       constant        fixed bin(17,0)          initial dcl 4-17 ref 271 354
PL1_lang_type                          constant        fixed bin(17,0)          initial dcl 4-17 ref 360
P_n_references                         parameter       fixed bin(17,0)          dcl 592 set ref 586 597 601 605 605*
P_probe_info_ptr                       parameter       pointer                  dcl 66 ref 171 202 296 369 394 436 595
RUNTIME_TYPE_INFO_VERSION_1     000000 constant        char(8)                  initial packed unaligned dcl 11-127 ref 523
addr                                                   builtin function         dcl 148 ref 347 347 350 350 354 354 357 357 360 360
                                                                                  363 363 512 512 524 524
addrel                                                 builtin function         dcl 148 ref 239 262
address_ptr               4            based           pointer                  level 2 dcl 75 set ref 266* 266 533 537
after_ptr                       000130 automatic       pointer                  dcl 401 set ref 419* 427
b1al                                   based           bit(1)                   dcl 476 ref 537
b1unal                                 based           bit(1)                   packed unaligned dcl 477 ref 533
based_str                              based           char                     packed unaligned dcl 72 ref 326 326 329 329
based_str_lth                   000104 automatic       fixed bin(21,0)          dcl 71 set ref 324* 326 326 329 329
based_str_ptr                   000102 automatic       pointer                  dcl 70 set ref 323* 326 326 329 329
bit_dtype                              constant        fixed bin(17,0)          initial dcl 13-25 ref 532
bits                      0(24)        based           structure                level 2 packed packed unaligned dcl 10-3
block_ptr                 4            based           pointer                  level 2 dcl 8-5 set ref 515*
c_enum_dtype                           constant        fixed bin(17,0)          initial dcl 13-25 ref 243
c_indirect_count                000123 automatic       fixed bin(17,0)          dcl 205 set ref 215* 221* 221 259 260* 260
c_typeref_dtype                        constant        fixed bin(17,0)          initial dcl 13-25 ref 235 237
code                            000100 automatic       fixed bin(35,0)          dcl 68 set ref 151* 161* 180* 181 185* 195* 196 211*
                                                                                  229* 231 281* 283 289* 290 306* 307 311* 341* 343
                                                                                  379* 381 387* 388 421* 423 428 452* 454 458* 460
                                                                                  484* 485 512* 514 524* 526 545* 546 549* 554 575*
                                                                                  577
comparison_result               000132 automatic       bit(1)                   dcl 404 set ref 414* 415 420 425* 446* 450
conditional_expr_ptr            000126 automatic       pointer                  dcl 400 set ref 412* 414* 425*
constant                116(01)        based           bit(1)                   level 3 in structure "ref_1" packed packed unaligned
                                                                                  dcl 75 in procedure "probe_expr_requests_" set ref
                                                                                  310
constant                               based           structure                level 1 dcl 9-27 in procedure "probe_expr_requests_"
ct                       13            based           pointer                  level 3 packed packed unaligned dcl 1-18 set ref 184
                                                                                  185 185 189* 189 219 219 222* 222 271 271 315 320
                                                                                  323 324 412 419 427* 446 482* 488 565 621 636 640
                                                                                  655 668* 668 668* 670 671* 673 674* 685* 685 687
current_identifier_name                based           char                     packed unaligned dcl 9-42 ref 185
display_data_$for_probe         000030 constant        entry                    external dcl 92 ref 195
end_token                14            based           bit(18)                  level 3 dcl 1-18 ref 219 315 621 640 655 671
execute                  64            based           bit(1)                   level 3 packed packed unaligned dcl 1-18 ref 194 288
                                                                                  338 386 415 450 510 533 549
exp_begin                              parameter       pointer                  dcl 471 ref 467 482
ext_procedure_runtime_dtype            constant        fixed bin(17,0)          initial dcl 13-125 ref 310
fixed                                                  builtin function         dcl 148 ref 235 237 239 243 249 251 262 265
flags                   116            based           structure                level 2 in structure "ref_1" dcl 75 in procedure
                                                                                  "probe_expr_requests_"
flags                    64            based           structure                level 2 in structure "probe_info" dcl 1-18
                                                                                  in procedure "probe_expr_requests_"
header                                 based           structure                level 2 in structure "token" dcl 9-16 in procedure
                                                                                  "probe_expr_requests_"
header                                 based           structure                level 2 in structure "operator" dcl 9-24
                                                                                  in procedure "probe_expr_requests_"
identifier                             based           structure                level 1 dcl 9-19
language_type            21            based           fixed bin(17,0)          level 3 dcl 1-18 ref 185 271 347 350 354 357 360 489
length                    6            based           fixed bin(17,0)          level 2 dcl 9-19 ref 185 324
name                      7            based           pointer                  level 2 in structure "identifier" packed packed
                                                                                  unaligned dcl 9-19 in procedure
                                                                                  "probe_expr_requests_" ref 185 323
name                     12            based           varying char(256)        level 2 in structure "ref_1" dcl 75 in procedure
                                                                                  "probe_expr_requests_" set ref 515
next                                   based           pointer                  level 3 packed packed unaligned dcl 9-16 ref 189 222
                                                                                  636 640 673 685
not_done_indirection            000124 automatic       bit(1)                   packed unaligned dcl 206 set ref 216* 218 224*
null                                                   builtin function         dcl 148 ref 234 515 515 519 636 665 668 687
operation                       000150 automatic       bit(18)                  dcl 473 set ref 488* 490 493 493* 496 499 499* 503
                                                                                  503 503 549*
operator                               based           structure                level 1 dcl 9-24
packed                  116            based           bit(1)                   level 3 in structure "ref_1" packed packed unaligned
                                                                                  dcl 75 in procedure "probe_expr_requests_" set ref
                                                                                  253* 533
packed                    0(25)        based           bit(1)                   level 3 in structure "runtime_symbol" packed packed
                                                                                  unaligned dcl 10-3 in procedure
                                                                                  "probe_expr_requests_" ref 253
precision               115            based           fixed bin(35,0)          level 2 dcl 75 set ref 246* 251* 267*
prev_ct                         000216 automatic       pointer                  initial dcl 665 set ref 665* 670* 674
probe_assign_value_             000032 constant        entry                    external dcl 94 ref 289
probe_compare_reference_        000034 constant        entry                    external dcl 96 ref 549
probe_create_reference_         000036 constant        entry                    external dcl 101 ref 597 601
probe_error_                    000040 constant        entry                    external dcl 102 ref 156 161 271 490 496 503 565 621
                                                                                  636 640 655
probe_error_$malfunction        000042 constant        entry                    external dcl 103 ref 41 605
probe_et_$bad_constant          000010 external static fixed bin(35,0)          dcl 81 ref 311
probe_et_$bad_predicate         000014 external static fixed bin(35,0)          dcl 81 set ref 503*
probe_et_$misused_equal         000022 external static fixed bin(35,0)          dcl 81 set ref 490*
probe_et_$misused_not_equal     000024 external static fixed bin(35,0)          dcl 81 set ref 496*
probe_et_$noarg                 000016 external static fixed bin(35,0)          dcl 81 set ref 655*
probe_et_$recorded_message      000012 external static fixed bin(35,0)          dcl 81 ref 151
probe_et_$syntax_error          000020 external static fixed bin(35,0)          dcl 81 set ref 156* 271*
probe_et_$too_many_args         000026 external static fixed bin(35,0)          dcl 81 set ref 621* 636* 640*
probe_get_$expression           000044 constant        entry                    external dcl 105 ref 180 281 484 545
probe_get_$reference            000046 constant        entry                    external dcl 107 ref 306
probe_get_$request_list         000050 constant        entry                    external dcl 109 ref 575
probe_get_$value                000052 constant        entry                    external dcl 111 ref 229 379
probe_info                             based           structure                level 1 dcl 1-18
probe_info_ptr                  000140 automatic       pointer                  dcl 1-86 set ref 156* 161* 180* 184 185 185 185 189
                                                                                  189 194 195* 219 219 219 222 222 229* 271 271 271
                                                                                  271* 281* 288 289* 306* 315 315 320 323 324 338
                                                                                  341* 347 347* 350 350* 354 354* 357 357* 360 360*
                                                                                  363* 379* 386 387* 412 415 419 421* 427 446 450
                                                                                  452* 457 458* 482 484* 488 489 490* 496* 503* 510
                                                                                  512* 515 533 545* 549 549* 565 565* 575* 595* 597*
                                                                                  601* 605* 621 621 621* 636 636* 640 640 640* 655
                                                                                  655 655* 668 668 668 670 671 671 673 674 685 685
                                                                                  687
probe_invoke_$subroutine        000054 constant        entry                    external dcl 113 ref 387
probe_listen_$check_line        000056 constant        entry                    external dcl 116 ref 458
probe_listen_$interpret_line    000060 constant        entry                    external dcl 119 ref 421 452
probe_print_algol68_attr_       000064 constant        entry                    external dcl 125 ref 357
probe_print_c_attr_             000070 constant        entry                    external dcl 130 ref 363
probe_print_cobol_attr_         000072 constant        entry                    external dcl 132 ref 350
probe_print_fortran_attr_       000074 constant        entry                    external dcl 134 ref 347
probe_print_pascal_$attr        000062 constant        entry                    external dcl 122 ref 354
probe_print_pl1_attr_           000066 constant        entry                    external dcl 128 ref 360
probe_var_info_ptr      126            based           pointer                  level 2 packed packed unaligned dcl 75 set ref 341*
probe_variable          116(08)        based           bit(1)                   level 3 packed packed unaligned dcl 75 set ref 338
probe_variable_mgr_$find_variable
                                000076 constant        entry                    external dcl 137 ref 512
probe_variable_mgr_$list_var_ptr
                                000100 constant        entry                    external dcl 139 ref 341
ptr_overlay                            based           pointer                  dcl 207 ref 266
ptr_to_current_source
                          4            based           pointer                  level 2 dcl 1-18 ref 515
random_info              17            based           structure                level 2 dcl 1-18
real_fix_bin_1_dtype                   constant        fixed bin(17,0)          initial dcl 13-25 ref 245
ref_1                                  based           structure                level 1 dcl 75 set ref 180* 195* 229* 289* 306* 347
                                                                                  347 350 350 354 354 357 357 360 360 363 363 379*
                                                                                  387* 484* 512 512 549*
ref_1_ptr                       000106 automatic       pointer                  dcl 74 set ref 180 195 229 234 235 237 239 239 239
                                                                                  243 245 246 249 249 251 251 253 253 261 262 262
                                                                                  262 265 265 266 266 267 267 289 306 310 310 338
                                                                                  341 347 347 350 350 354 354 357 357 360 360 363
                                                                                  363 379 387 484 512 512 515 515 519 524 528 532
                                                                                  533 533 537 549 597*
ref_2                                  based           structure                level 1 dcl 77 set ref 281* 289* 545* 549*
ref_2_ptr                       000110 automatic       pointer                  dcl 74 set ref 281 289 545 549 601*
reference_node                         based           structure                level 1 dcl 6-16
requests_lth                    000136 automatic       fixed bin(21,0)          dcl 406 set ref 421* 452* 458* 575*
requests_ptr                    000134 automatic       pointer                  dcl 405 set ref 421* 452* 458* 575*
result                          000151 automatic       bit(1)                   dcl 474 set ref 549* 553* 556
runtime_symbol                         based           structure                level 1 dcl 10-3
runtime_symbol_info_$type       000104 constant        entry                    external dcl 11-22 ref 524
runtime_type_info                      based           structure                level 1 dcl 11-24
sb_long_sw                      000125 automatic       bit(1)                   dcl 301 set ref 315* 326* 329* 347* 350* 354* 357*
                                                                                  360* 363*
setting_break            64(04)        based           bit(1)                   level 3 packed packed unaligned dcl 1-18 ref 457
size                      4            based           fixed bin(35,0)          level 2 dcl 10-3 ref 251 267
son                       2(18)        based           bit(18)                  level 2 packed packed unaligned dcl 10-3 ref 239 261
                                                                                  262
source_info                            based           structure                level 1 dcl 8-5
stu_$find_runtime_symbol        000102 constant        entry                    external dcl 141 ref 515
symbol_ptr                             based           pointer                  level 2 dcl 75 set ref 234 235 237 239* 239 239 243
                                                                                  249 251 253 261 262* 262 262 265 267 515* 519 524*
token                                  based           structure                level 1 dcl 9-16
token_header                           based           structure                level 1 dcl 9-4
token_info               12            based           structure                level 2 dcl 1-18
type                      2            based           bit(18)                  level 3 in structure "token" dcl 9-16 in procedure
                                                                                  "probe_expr_requests_" ref 184 219 219 315 320 621
                                                                                  640 655 671
type                      3     000112 automatic       fixed bin(18,0)          level 2 in structure "type_info" packed packed
                                                                                  unsigned unaligned dcl 79 in procedure
                                                                                  "probe_expr_requests_" set ref 528
type                      2            based           bit(18)                  level 3 in structure "operator" dcl 9-24
                                                                                  in procedure "probe_expr_requests_" ref 271 271
                                                                                  488 565
type                      0(06)        based           bit(6)                   level 2 in structure "runtime_symbol" packed packed
                                                                                  unaligned dcl 10-3 in procedure
                                                                                  "probe_expr_requests_" ref 235 237 243 249 265
type                    113            based           fixed bin(35,0)          level 2 in structure "ref_1" dcl 75 in procedure
                                                                                  "probe_expr_requests_" set ref 245* 249* 265* 310
                                                                                  528* 532
type_info                       000112 automatic       structure                level 1 unaligned dcl 79 set ref 524 524
version                         000112 automatic       char(8)                  level 2 packed packed unaligned dcl 79 set ref 523*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALM_lang_type                          internal static fixed bin(17,0)          initial dcl 4-17
AMPERSAND                              internal static bit(18)                  initial dcl 5-17
ARROW                                  internal static bit(18)                  initial dcl 5-17
BREAK_AFTER                            internal static fixed bin(17,0)          initial dcl 2-25
BREAK_AT                               internal static fixed bin(17,0)          initial dcl 2-25
BREAK_BEFORE                           internal static fixed bin(17,0)          initial dcl 2-25
BREAK_INPUT                            internal static fixed bin(17,0)          initial dcl 3-13
COMMA                                  internal static bit(18)                  initial dcl 5-17
CONSOLE_INPUT                          internal static fixed bin(17,0)          initial dcl 3-13
CONSTANT_TYPE                          internal static bit(18)                  initial packed unaligned dcl 9-37
C_LEFT_SHIFT                           internal static bit(18)                  initial dcl 5-17
C_RIGHT_SHIFT                          internal static bit(18)                  initial dcl 5-17
DOLLAR_SIGN                            internal static bit(18)                  initial dcl 5-17
ENTRY_AT_BREAK                         internal static fixed bin(17,0)          initial dcl 3-9
ENTRY_AT_CALL                          internal static fixed bin(17,0)          initial dcl 3-9
ENTRY_AT_HALT                          internal static fixed bin(17,0)          initial dcl 3-9
GREATER_THAN                           internal static bit(18)                  initial dcl 5-17
LEFT_BRACKET                           internal static bit(18)                  initial dcl 5-17
LEFT_PAREN                             internal static bit(18)                  initial dcl 5-17
MACRO_INPUT                            internal static fixed bin(17,0)          initial dcl 3-13
MINUS                                  internal static bit(18)                  initial dcl 5-17
NEW_LINE                               internal static bit(18)                  initial dcl 5-17
NOT_GREATER_THAN                       internal static bit(18)                  initial dcl 5-17
NOT_SIGN                               internal static bit(18)                  initial dcl 5-17
OPERATOR_TYPE                          internal static bit(18)                  initial packed unaligned dcl 9-37
OPERATOR_VALUES                        internal static varying char(4)          initial array dcl 5-43
OR_BAR                                 internal static bit(18)                  initial dcl 5-17
OTHER_lang_type                        internal static fixed bin(17,0)          initial dcl 4-17
PASCAL_ARROW                           internal static bit(18)                  initial dcl 5-17
PASCAL_RANGE                           internal static bit(18)                  initial dcl 5-17
PERCENT                                internal static bit(18)                  initial dcl 5-17
PERIOD                                 internal static bit(18)                  initial dcl 5-17
PLACE                                  internal static char(8)                  initial array dcl 2-29
PLUS                                   internal static bit(18)                  initial dcl 5-17
QUESTION_MARK                          internal static bit(18)                  initial dcl 5-17
RETURN_TO_BREAK                        internal static fixed bin(17,0)          initial dcl 3-4
RETURN_TO_CALLER                       internal static fixed bin(17,0)          initial dcl 3-4
RETURN_TO_CONDITION                    internal static fixed bin(17,0)          initial dcl 3-4
RETURN_TO_FRAME                        internal static fixed bin(17,0)          initial dcl 3-4
RIGHT_BRACKET                          internal static bit(18)                  initial dcl 5-17
RIGHT_PAREN                            internal static bit(18)                  initial dcl 5-17
RUNTIME_ADDRESS_INFO_VERSION_1         internal static char(8)                  initial packed unaligned dcl 11-128
RUNTIME_ARRAY_INFO_VERSION_1           internal static char(8)                  initial packed unaligned dcl 11-129
RUNTIME_SUBRANGE_INFO_VERSION_1        internal static char(8)                  initial packed unaligned dcl 11-131
RUNTIME_VARIANT_INFO_VERSION_1         internal static char(8)                  initial packed unaligned dcl 11-130
SEMI_COLON                             internal static bit(18)                  initial dcl 5-17
SLASH                                  internal static bit(18)                  initial dcl 5-17
TIMES                                  internal static bit(18)                  initial dcl 5-17
UNKNOWN_lang_type                      internal static fixed bin(17,0)          initial dcl 4-17
algol68_array_descriptor_dtype         internal static fixed bin(17,0)          initial dcl 13-25
algol68_bits_dtype                     internal static fixed bin(17,0)          initial dcl 13-110
algol68_bool_dtype                     internal static fixed bin(17,0)          initial dcl 13-110
algol68_byte_dtype                     internal static fixed bin(17,0)          initial dcl 13-110
algol68_char_dtype                     internal static fixed bin(17,0)          initial dcl 13-110
algol68_compl_dtype                    internal static fixed bin(17,0)          initial dcl 13-110
algol68_format_dtype                   internal static fixed bin(17,0)          initial dcl 13-25
algol68_int_dtype                      internal static fixed bin(17,0)          initial dcl 13-110
algol68_long_compl_dtype               internal static fixed bin(17,0)          initial dcl 13-110
algol68_long_int_dtype                 internal static fixed bin(17,0)          initial dcl 13-110
algol68_long_real_dtype                internal static fixed bin(17,0)          initial dcl 13-110
algol68_real_dtype                     internal static fixed bin(17,0)          initial dcl 13-110
algol68_short_int_dtype                internal static fixed bin(17,0)          initial dcl 13-110
algol68_straight_dtype                 internal static fixed bin(17,0)          initial dcl 13-25
algol68_struct_struct_bool_dtype       internal static fixed bin(17,0)          initial dcl 13-110
algol68_struct_struct_char_dtype       internal static fixed bin(17,0)          initial dcl 13-110
algol68_union_dtype                    internal static fixed bin(17,0)          initial dcl 13-25
area_dtype                             internal static fixed bin(17,0)          initial dcl 13-25
break_slot                             based           structure                level 1 dcl 2-8
bsp                                    automatic       pointer                  dcl 2-23
c_enum_const_dtype                     internal static fixed bin(17,0)          initial dcl 13-25
c_union_dtype                          internal static fixed bin(17,0)          initial dcl 13-25
char_dtype                             internal static fixed bin(17,0)          initial dcl 13-25
cobol_char_string_dtype                internal static fixed bin(17,0)          initial dcl 13-25
cobol_comp_5_ts_dtype                  internal static fixed bin(17,0)          initial dcl 13-25
cobol_comp_5_uns_dtype                 internal static fixed bin(17,0)          initial dcl 13-25
cobol_comp_6_dtype                     internal static fixed bin(17,0)          initial dcl 13-25
cobol_comp_7_dtype                     internal static fixed bin(17,0)          initial dcl 13-25
cobol_comp_8_ls_dtype                  internal static fixed bin(17,0)          initial dcl 13-25
cobol_comp_8_uns_dtype                 internal static fixed bin(17,0)          initial dcl 13-25
cobol_display_ls_dtype                 internal static fixed bin(17,0)          initial dcl 13-25
cobol_display_ls_overp_dtype           internal static fixed bin(17,0)          initial dcl 13-25
cobol_display_ts_dtype                 internal static fixed bin(17,0)          initial dcl 13-25
cobol_display_ts_overp_dtype           internal static fixed bin(17,0)          initial dcl 13-25
cobol_display_uns_dtype                internal static fixed bin(17,0)          initial dcl 13-25
cobol_structure_dtype                  internal static fixed bin(17,0)          initial dcl 13-25
cplx_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 13-25
cplx_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 13-25
cplx_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 13-25
cplx_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 13-25
cplx_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 13-25
cplx_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 13-25
cplx_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 13-25
cplx_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 13-25
cplx_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 13-25
cplx_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 13-25
cplx_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 13-25
cplx_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 13-25
cplx_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 13-25
current_constant                       based           structure                level 1 dcl 9-44
current_source                         based           structure                level 1 dcl 8-13
current_token                          based           structure                level 1 dcl 9-45
encoded_value                          based           structure                level 1 dcl 10-70
entry_dtype                            internal static fixed bin(17,0)          initial dcl 13-25
expression_area                        based           area(1024)               dcl 1-95
ext_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 13-125
file_dtype                             internal static fixed bin(17,0)          initial dcl 13-25
ft_char_dtype                          internal static fixed bin(17,0)          initial dcl 13-96
ft_complex_double_dtype                internal static fixed bin(17,0)          initial dcl 13-96
ft_complex_dtype                       internal static fixed bin(17,0)          initial dcl 13-96
ft_double_dtype                        internal static fixed bin(17,0)          initial dcl 13-96
ft_external_dtype                      internal static fixed bin(17,0)          initial dcl 13-96
ft_hex_complex_double_dtype            internal static fixed bin(17,0)          initial dcl 13-96
ft_hex_complex_dtype                   internal static fixed bin(17,0)          initial dcl 13-96
ft_hex_double_dtype                    internal static fixed bin(17,0)          initial dcl 13-96
ft_hex_real_dtype                      internal static fixed bin(17,0)          initial dcl 13-96
ft_integer_dtype                       internal static fixed bin(17,0)          initial dcl 13-96
ft_logical_dtype                       internal static fixed bin(17,0)          initial dcl 13-96
ft_real_dtype                          internal static fixed bin(17,0)          initial dcl 13-96
initial_source                         based           structure                level 1 dcl 8-14
int_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 13-125
label_constant_runtime_dtype           internal static fixed bin(17,0)          initial dcl 13-125
label_dtype                            internal static fixed bin(17,0)          initial dcl 13-25
n_dims                                 automatic       fixed bin(17,0)          dcl 11-97
n_variants                             automatic       fixed bin(35,0)          dcl 11-112
official_language_names                internal static char(32)                 initial array packed unaligned dcl 4-27
offset_dtype                           internal static fixed bin(17,0)          initial dcl 13-25
palatable_language_names               internal static char(32)                 initial array packed unaligned dcl 4-30
pascal_boolean_dtype                   internal static fixed bin(17,0)          initial dcl 13-132
pascal_char_dtype                      internal static fixed bin(17,0)          initial dcl 13-132
pascal_entry_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 13-132
pascal_enumerated_type_dtype           internal static fixed bin(17,0)          initial dcl 13-132
pascal_enumerated_type_element_dtype   internal static fixed bin(17,0)          initial dcl 13-132
pascal_enumerated_type_instance_dtype  internal static fixed bin(17,0)          initial dcl 13-132
pascal_exportable_procedure_dtype      internal static fixed bin(17,0)          initial dcl 13-132
pascal_imported_procedure_dtype        internal static fixed bin(17,0)          initial dcl 13-132
pascal_integer_dtype                   internal static fixed bin(17,0)          initial dcl 13-132
pascal_internal_procedure_dtype        internal static fixed bin(17,0)          initial dcl 13-132
pascal_label_dtype                     internal static fixed bin(17,0)          initial dcl 13-132
pascal_parameter_procedure_dtype       internal static fixed bin(17,0)          initial dcl 13-132
pascal_procedure_type_dtype            internal static fixed bin(17,0)          initial dcl 13-132
pascal_real_dtype                      internal static fixed bin(17,0)          initial dcl 13-132
pascal_record_file_type_dtype          internal static fixed bin(17,0)          initial dcl 13-132
pascal_record_type_dtype               internal static fixed bin(17,0)          initial dcl 13-132
pascal_set_dtype                       internal static fixed bin(17,0)          initial dcl 13-132
pascal_string_type_dtype               internal static fixed bin(17,0)          initial dcl 13-132
pascal_text_file_dtype                 internal static fixed bin(17,0)          initial dcl 13-132
pascal_typed_pointer_type_dtype        internal static fixed bin(17,0)          initial dcl 13-132
pascal_user_defined_type_dtype         internal static fixed bin(17,0)          initial dcl 13-132
pascal_user_defined_type_instance_dtype
                                       internal static fixed bin(17,0)          initial dcl 13-132
pascal_value_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 13-132
pascal_variable_formal_parameter_dtype internal static fixed bin(17,0)          initial dcl 13-132
picture_runtime_dtype                  internal static fixed bin(17,0)          initial dcl 13-125
pointer_dtype                          internal static fixed bin(17,0)          initial dcl 13-25
probe_area                             based           area(1024)               dcl 1-93
probe_info_version                     internal static fixed bin(17,0)          initial dcl 1-88
probe_info_version_1                   internal static fixed bin(17,0)          initial dcl 1-90
real_fix_bin_1_uns_dtype               internal static fixed bin(17,0)          initial dcl 13-25
real_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 13-25
real_fix_bin_2_uns_dtype               internal static fixed bin(17,0)          initial dcl 13-25
real_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 13-25
real_fix_dec_4bit_bytealigned_uns_dtype
                                       internal static fixed bin(17,0)          initial dcl 13-25
real_fix_dec_4bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 13-25
real_fix_dec_4bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 13-25
real_fix_dec_4bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 13-25
real_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 13-25
real_fix_dec_9bit_ls_overp_dtype       internal static fixed bin(17,0)          initial dcl 13-25
real_fix_dec_9bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 13-25
real_fix_dec_9bit_ts_overp_dtype       internal static fixed bin(17,0)          initial dcl 13-25
real_fix_dec_9bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 13-25
real_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 13-25
real_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 13-25
real_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 13-25
real_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 13-25
real_flt_dec_4bit_dtype                internal static fixed bin(17,0)          initial dcl 13-25
real_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 13-25
real_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 13-25
real_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 13-25
real_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 13-25
real_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 13-25
reference_arg_list                     based           structure                level 1 dcl 6-59
reference_subscripts                   based           structure                level 1 dcl 6-64
runtime_address_info                   based           structure                level 1 dcl 11-56
runtime_array_info                     based           structure                level 1 dcl 11-70
runtime_block                          based           structure                level 1 dcl 10-38
runtime_bound                          based           structure                level 1 unaligned dcl 10-33
runtime_subrange_info                  based           structure                level 1 unaligned dcl 11-116
runtime_symbol_info_$address    000000 constant        entry                    external dcl 11-54
runtime_symbol_info_$array      000000 constant        entry                    external dcl 11-68
runtime_symbol_info_$array_dims 000000 constant        entry                    external dcl 11-66
runtime_symbol_info_$brother    000000 constant        entry                    external dcl 11-40
runtime_symbol_info_$father     000000 constant        entry                    external dcl 11-38
runtime_symbol_info_$father_type
                                000000 constant        entry                    external dcl 11-42
runtime_symbol_info_$level      000000 constant        entry                    external dcl 11-50
runtime_symbol_info_$n_variants 000000 constant        entry                    external dcl 11-99
runtime_symbol_info_$name       000000 constant        entry                    external dcl 11-48
runtime_symbol_info_$next       000000 constant        entry                    external dcl 11-52
runtime_symbol_info_$son        000000 constant        entry                    external dcl 11-44
runtime_symbol_info_$subrange   000000 constant        entry                    external dcl 11-114
runtime_symbol_info_$successor  000000 constant        entry                    external dcl 11-46
runtime_symbol_info_$variant    000000 constant        entry                    external dcl 11-101
runtime_token                          based           structure                level 1 dcl 10-63
runtime_variant_info                   based           structure                level 1 dcl 11-103
scratch_area                           based           area(1024)               dcl 1-92
seg_info                               based           structure                level 1 dcl 7-9
seg_info_nfiles                        automatic       fixed bin(17,0)          dcl 7-47
statement_map                          based           structure                level 1 dcl 12-1
structure_dtype                        internal static fixed bin(17,0)          initial dcl 13-25
stu_$get_runtime_address        000000 constant        entry                    external dcl 144
subscript_reference_ptrs               based           structure                level 1 dcl 6-69
varying_bit_dtype                      internal static fixed bin(17,0)          initial dcl 13-25
varying_char_dtype                     internal static fixed bin(17,0)          initial dcl 13-25
work_area                              based           area(1024)               dcl 1-94

NAMES DECLARED BY EXPLICIT CONTEXT.
BAD_PRED                        001462 constant        label                    dcl 503 ref 519 526 532
ERR_IN_BOOLEAN_EXPR             001731 constant        label                    dcl 557 ref 485 546 554
MAIN_RETURN                     000146 constant        label                    dcl 167 ref 158 164 200 294 367 392 433 465
RECORDED_MESSAGE                000106 constant        label                    dcl 151
SKIP_RETURN                     002254 constant        label                    dcl 674 ref 671
SOME_ERROR                      000130 constant        label                    dcl 161 ref 153 181 196 231 283 290 307 312 343 381
                                                                                  388 423 428 454 460 557 577
SYNTAX_ERROR                    000112 constant        label                    dcl 156 ref 320 329 687
boolean_expr                    001344 constant        entry                    internal dcl 467 ref 414 425 446
bump_ct                         002257 constant        entry                    internal dcl 680 ref 278 334 543 571
call_request                    001076 constant        entry                    external dcl 369
common_conditional_munch        001732 constant        entry                    internal dcl 561 ref 417 448
if_request                      001247 constant        entry                    external dcl 436
let_request                     000253 constant        entry                    external dcl 202
probe_expr_requests_            000074 constant        entry                    external dcl 37
reject_argument                 002104 constant        entry                    internal dcl 614 ref 192 286 335 384 581
reject_next_argument            002131 constant        entry                    internal dcl 629 ref 43
require_argument                002201 constant        entry                    internal dcl 648 ref 178 227 279 305 377 410 444 483
                                                                                  544 573
setup                           002010 constant        entry                    internal dcl 586 ref 176 213 303 375 409 442
skip_line                       002226 constant        entry                    internal dcl 662 ref 431 463
symbol_request                  000556 constant        entry                    external dcl 296
value_request                   000152 constant        entry                    external dcl 171
while_request                   001156 constant        entry                    external dcl 394

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3022        3130    2320        3032
Length      3672    2320       106         526     502           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
probe_expr_requests_                330 external procedure  is an external procedure.  
boolean_expr                            internal procedure  shares stack frame of external procedure probe_expr_requests_.  
common_conditional_munch                internal procedure  shares stack frame of external procedure probe_expr_requests_.  
setup                                   internal procedure  shares stack frame of external procedure probe_expr_requests_.  
reject_argument                         internal procedure  shares stack frame of external procedure probe_expr_requests_.  
reject_next_argument                    internal procedure  shares stack frame of external procedure probe_expr_requests_.  
require_argument                        internal procedure  shares stack frame of external procedure probe_expr_requests_.  
skip_line                               internal procedure  shares stack frame of external procedure probe_expr_requests_.  
bump_ct                                 internal procedure  shares stack frame of external procedure probe_expr_requests_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
probe_expr_requests_     000100 code                        probe_expr_requests_
                         000102 based_str_ptr               probe_expr_requests_
                         000104 based_str_lth               probe_expr_requests_
                         000106 ref_1_ptr                   probe_expr_requests_
                         000110 ref_2_ptr                   probe_expr_requests_
                         000112 type_info                   probe_expr_requests_
                         000123 c_indirect_count            probe_expr_requests_
                         000124 not_done_indirection        probe_expr_requests_
                         000125 sb_long_sw                  probe_expr_requests_
                         000126 conditional_expr_ptr        probe_expr_requests_
                         000130 after_ptr                   probe_expr_requests_
                         000132 comparison_result           probe_expr_requests_
                         000134 requests_ptr                probe_expr_requests_
                         000136 requests_lth                probe_expr_requests_
                         000140 probe_info_ptr              probe_expr_requests_
                         000150 operation                   boolean_expr
                         000151 result                      boolean_expr
                         000216 prev_ct                     skip_line

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
display_data_$for_probe       probe_assign_value_           probe_compare_reference_      probe_create_reference_
probe_error_                  probe_error_$malfunction      probe_get_$expression         probe_get_$reference
probe_get_$request_list       probe_get_$value              probe_invoke_$subroutine      probe_listen_$check_line
probe_listen_$interpret_line  probe_print_algol68_attr_     probe_print_c_attr_           probe_print_cobol_attr_
probe_print_fortran_attr_     probe_print_pascal_$attr      probe_print_pl1_attr_
probe_variable_mgr_$find_variable                           probe_variable_mgr_$list_var_ptr
runtime_symbol_info_$type     stu_$find_runtime_symbol

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
probe_et_$bad_constant        probe_et_$bad_predicate       probe_et_$misused_equal       probe_et_$misused_not_equal
probe_et_$noarg               probe_et_$recorded_message    probe_et_$syntax_error        probe_et_$too_many_args




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     37 000073        41 000101        43 000105       151 000106       153 000111       156 000112       158 000127
    161 000130       164 000145       167 000146       171 000147       176 000157       178 000163       180 000164
    181 000177       184 000201       185 000206       189 000223       192 000226       194 000227       195 000233
    196 000246       200 000250       202 000251       211 000260       213 000261       215 000265       216 000266
    218 000270       219 000272       221 000303       222 000304       223 000306       224 000307       225 000310
    227 000311       229 000312       231 000331       234 000333       235 000337       237 000350       239 000363
    242 000371       243 000372       245 000376       246 000401       247 000403       249 000404       251 000410
    253 000413       259 000420       260 000422       261 000424       262 000431       265 000434       266 000441
    267 000444       269 000447       271 000450       278 000510       279 000511       281 000512       283 000525
    286 000527       288 000530       289 000534       290 000551       294 000553       296 000554       303 000563
    305 000567       306 000570       307 000603       310 000605       311 000614       312 000617       315 000620
    320 000631       323 000633       324 000635       326 000637       329 000652       334 000663       335 000664
    338 000665       341 000675       343 000710       345 000712       347 000713       350 000737       354 000762
    357 001005       360 001030       363 001053       367 001073       369 001074       375 001103       377 001107
    379 001110       381 001127       384 001131       386 001132       387 001136       388 001151       392 001153
    394 001154       409 001163       410 001167       412 001170       414 001173       415 001175       417 001204
    419 001205       420 001210       421 001213       423 001230       425 001232       426 001234       427 001235
    428 001240       430 001242       431 001243       433 001244       436 001245       442 001254       444 001260
    446 001261       448 001266       450 001267       452 001276       454 001313       456 001315       457 001316
    458 001322       460 001337       462 001341       463 001342       465 001343       467 001344       482 001346
    483 001352       484 001353       485 001366       488 001370       489 001374       490 001400       493 001420
    496 001425       499 001445       503 001451       510 001500       512 001504       514 001521       515 001523
    519 001570       523 001575       524 001577       526 001614       528 001616       532 001622       533 001626
    537 001645       538 001651       543 001654       544 001655       545 001656       546 001671       549 001673
    553 001721       554 001722       556 001724       557 001731       561 001732       565 001733       571 001765
    573 001766       575 001767       577 002004       581 002006       584 002007       586 002010       595 002012
    597 002016       601 002031       605 002046       610 002103       614 002104       621 002105       624 002130
    629 002131       636 002132       640 002154       643 002200       648 002201       655 002202       658 002225
    662 002226       665 002227       668 002231       670 002242       671 002244       673 002250       674 002254
    676 002256       680 002257       685 002260       687 002265       690 002267


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
