	COMPILATION LISTING OF SEGMENT le_snap_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 12/10/86  1254.9 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /****^  HISTORY COMMENTS:
        8*  1) change(86-08-12,Elhard), approve(86-08-12,MCR7505),
        9*     audit(86-12-10,DGHowe), install(86-12-10,MR12.0-1241):
       10*     Originally written to attempt to resolve links internally or to generate
       11*     an external reference if the link cannot be resolved.
       12*                                                   END HISTORY COMMENTS */
       13 
       14 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       15 
       16 le_snap_:
       17   proc (ocudp,			/** ocu_data pointer    (in )	*/
       18        lecp,			/** components pointer  (in )	*/
       19        comp,			/** component index	    (in ) */
       20        ref_section,			/** referencing section (in ) */
       21        ref_offset,			/** referencing offset  (in ) */
       22        ref_relp,			/** relpointer to link  (in ) */
       23        no_prelink,			/** must be external    (in ) */
       24        section,			/** section resolved to (out) */
       25        relp,			/** offset within scn   (out) */
       26        modifier,			/** modifier required   (out) */
       27        internal);			/** internal flag	    (out) */
       28 
       29   /*** ****************************************************************/
       30   /***							*/
       31   /***	Name:	le_snap_					*/
       32   /***	Input:	ocudp, lecp, comp, ref_section, ref_offset,	*/
       33   /***		ref_relp, no_prelink			*/
       34   /***	Function:	resolves an internal link and returns information	*/
       35   /***		regarding where it snaps to.  The information	*/
       36   /***		returned consists of the section and offset to	*/
       37   /***		refer to, and whether the resolution removed the	*/
       38   /***		indirection through the link.			*/
       39   /***	Output:	section, relp, modifier, internal		*/
       40   /***							*/
       41   /*** ****************************************************************/
       42 
       43   /* constants */
       44 
       45   dcl false		bit (1) static options (constant) init ("0"b);
       46   dcl true		bit (1) static options (constant) init ("1"b);
       47   dcl Indirection_modifier	bit (6) static options (constant) init ("20"b3);
       48   dcl None		fixed bin static options (constant) init (0);
       49 
       50   /* parameters */
       51 
       52   dcl ocudp		ptr parameter;
       53   dcl lecp		ptr parameter;
       54   dcl comp		fixed bin parameter;
       55   dcl ref_section		fixed bin (3) parameter;
       56   dcl ref_offset		fixed bin (18) unsigned parameter;
       57   dcl ref_relp		fixed bin (18) unsigned parameter;
       58   dcl no_prelink		bit (1) parameter;
       59   dcl section		fixed bin (3) parameter;
       60   dcl relp		fixed bin (18) unsigned parameter;
       61   dcl modifier		bit (6) parameter;
       62   dcl internal		bit (1) parameter;
       63 
       64   /* procedures */
       65 
       66   dcl get_system_free_area_	entry () returns (ptr);
       67   dcl le_backpatch_		entry (fixed bin, fixed bin, uns fixed bin (18),
       68 			fixed bin, fixed bin);
       69   dcl le_error_		entry options (variable);
       70 
       71   /* external */
       72 
       73   dcl error_table_$bad_class_def
       74 			external fixed bin (35);
       75   dcl le_et_$bad_link_class	external fixed bin (35);
       76   dcl le_et_$bad_link_ref	external fixed bin (35);
       77   dcl le_et_$bad_link_type	external fixed bin (35);
       78 
       79   /* based */
       80 
       81   dcl 01 defn		aligned like le_definition based (defnp);
       82   dcl 01 init		aligned like link_init based (initp);
       83   dcl 01 init_copy		aligned based (initp),
       84        02 header		aligned like link_init_copy_info.header,
       85        02 initial_data	dim (0 refer (init_copy.n_words))
       86 			bit (36) aligned;
       87   dcl 01 init_list		aligned based (initp),
       88        02 header		aligned like link_init_list_template.header,
       89        02 pad		bit (18) unaligned,
       90        02 n_words_in_list	fixed bin (18) unsigned unaligned,
       91        02 template		dim (0 refer (init_list.n_words_in_list));
       92   dcl 01 lec		aligned based (lecp),
       93        02 header		aligned like le_components.header,
       94        02 comp		dim (0 refer (lec.n_components)) like le_comp;
       95   dcl 01 led		aligned based,
       96        02 header		aligned like le_definitions.header,
       97        02 def		dim (0 refer (led.n_defs)) like le_definition;
       98   dcl 01 lel		aligned based (lelp),
       99        02 header		aligned like le_links.header,
      100        02 link		dim (0 refer (lel.n_links)) like le_link;
      101   dcl 01 lk		aligned like le_link based (lkp);
      102   dcl 01 lte		aligned based (ltep),
      103        02 n_bits		fixed bin (35) aligned,
      104        02 mbz		bit (3) unaligned,
      105        02 init_type		fixed bin (3) unsigned unaligned,
      106        02 repeat		fixed bin (30) unsigned unaligned,
      107        02 datum		bit (0 refer (lte.n_bits));
      108   dcl 01 new_copy		aligned based (new_initp),
      109        02 header		aligned like link_init_copy_info.header,
      110        02 initial_data	dim (n_words refer (init_copy.n_words))
      111 			bit (36) aligned;
      112   dcl 01 new_list		aligned based (new_initp),
      113        02 header		aligned like link_init_list_template.header,
      114        02 pad		bit (18) unaligned,
      115        02 n_words_in_list	fixed bin (18) unsigned unaligned,
      116        02 template		dim (list_size
      117 			refer (init_list.n_words_in_list));
      118   dcl 01 offsetname		aligned based (lk.offsetp),
      119        02 count		fixed bin (9) unsigned unaligned,
      120        02 string		char (0 refer (offsetname.count)) unaligned;
      121   dcl 01 pit		aligned like pointer_init_template based (pitp);
      122   dcl 01 segname		aligned based (lk.segnamep),
      123        02 count		fixed bin (9) unsigned unaligned,
      124        02 string		char (0 refer (segname.count)) unaligned;
      125   dcl sys_area		area based (sys_areap);
      126   dcl 01 tl		aligned like le_link based (tlp);
      127 
      128   /* automatic */
      129 
      130   dcl 01 auto_def		aligned like link_init_deferred automatic;
      131   dcl 01 auto_init		aligned like link_init automatic;
      132   dcl copied		bit (1) automatic;
      133   dcl defnp		ptr automatic;
      134   dcl hdr_size		fixed bin automatic;
      135   dcl i			fixed bin automatic;
      136   dcl initp		ptr automatic;
      137   dcl lelp		ptr automatic;
      138   dcl linkx		fixed bin automatic;
      139   dcl list_size		fixed bin (18) unsigned automatic;
      140   dcl lkp			ptr automatic;
      141   dcl ltep		ptr automatic;
      142   dcl new_initp		ptr automatic;
      143   dcl n_words		fixed bin (35) automatic;
      144   dcl offset		fixed bin (18) unsigned;
      145   dcl patch_mask		bit (10000) automatic;
      146   dcl pitp		ptr automatic;
      147   dcl sys_areap		ptr automatic;
      148   dcl template_index	fixed bin automatic;
      149   dcl tlp			ptr automatic;
      150 
      151   /* conditions */
      152 
      153   dcl cleanup		condition;
      154 
      155   /* builtin */
      156 
      157   dcl addr		builtin;
      158   dcl addwordno		builtin;
      159   dcl currentsize		builtin;
      160   dcl index		builtin;
      161   dcl null		builtin;
      162   dcl size		builtin;
      163   dcl substr		builtin;
      164   dcl unspec		builtin;
      165   dcl wordno		builtin;
      166 
      167   section = -1;
      168   relp = 0;
      169   modifier = ""b;
      170   internal = false;
      171 
      172   lelp = lec.comp (comp).tables.lelp;
      173 
      174   /* calculate the link table index of the referenced link */
      175 
      176   linkx = (ref_relp - lel.offset_adjustment) / 2;
      177 
      178   if linkx < 0 | linkx > lel.n_links
      179     then do;
      180       call le_error_ (LE_FATAL_ERROR, le_et_$bad_link_ref,
      181 	 "^/Reference to link|^o at ^a|^o of ^a does not refer to a link.",
      182 	 ref_relp, section_nm (ref_section), ref_offset,
      183 	 lec.comp (comp).name);
      184       return;
      185     end;
      186 
      187   lkp = addr (lel.link (linkx));
      188 
      189   /* optimize for already emitted links */
      190 
      191   if ^no_prelink & lk.relp ^= None
      192     then do;
      193       section = Linkage;
      194       relp = lk.relp;
      195       modifier = Indirection_modifier;
      196       return;
      197     end;
      198 
      199   if lk.type < 1 | lk.type > 5 | lk.type = 2
      200     then do;
      201       call le_error_ (LE_FATAL_ERROR, le_et_$bad_link_type,
      202 	 "^/Link at link|^o has an invalid type (^d).", ref_relp,
      203 	 lk.type);
      204       return;
      205     end;
      206 
      207   goto LINK_TYPE (lk.type);
      208 
      209 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      210 
      211 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      212 
      213 
      214 LINK_TYPE (1):			/** *section|0+expression	*/
      215 
      216   if lk.class = Text
      217     then do;
      218 
      219       /* if not prelinking, then relocate and re-emit */
      220 
      221       if no_prelink
      222         then do;
      223 	section = Linkage;
      224 	relp = ocu_$emit_link (ocudp, Self_Base, Text, "", "",
      225 	     lec.comp (comp).new.rel_text + lk.exp, lk.mod, null);
      226 	return;
      227         end;
      228 
      229       /* otherwise relocate and return the text offset */
      230 
      231       section = Text;
      232       relp = lec.comp (comp).new.rel_text + lk.exp;
      233       internal = true;
      234     end;
      235   else if lk.class = Linkage
      236     then do;
      237       hdr_size = size (virgin_linkage_header);
      238 
      239       /* actually a reference to combined static */
      240 
      241       if lk.exp > hdr_size & lk.exp < hdr_size + lec.comp (comp).orig.statl &
      242 	 ^lec.comp (comp).flags.separate_static
      243         then do;
      244 
      245 	/* if we are not prelinking, re-emit the link as a *static	*/
      246 	/* link.  If static is combined, ocu_ will convert it to a	*/
      247 	/* *link|0+N link and adjust the offset			*/
      248 
      249 	if no_prelink
      250 	  then do;
      251 	    section = Linkage;
      252 	    relp = ocu_$emit_link (ocudp, Self_Base, Static, "", "",
      253 	         lk.exp + lec.comp (comp).new.rel_stat, lk.mod, null);
      254 	    return;
      255 	  end;
      256 
      257 	/* otherwise, we treat it as a static reference */
      258 
      259 	section = Static;
      260 	relp = lec.comp (comp).new.rel_stat + lk.exp - hdr_size;
      261 	internal = true;
      262 	return;
      263         end;
      264 
      265       /* check for a reference to the header rather than a link or static */
      266 
      267       if lk.exp < hdr_size
      268         then do;
      269 
      270 	/* non-link, non-static linkage section references are just	*/
      271 	/* re-emitted with the same expression value, since we have	*/
      272 	/* no good way of determining how to relocate them.	*/
      273 
      274 	if no_prelink
      275 	  then do;
      276 	    relp = ocu_$emit_link (ocudp, Self_Base, Linkage, "", "",
      277 	         (lk.exp), lk.mod, null);
      278 	    section = Linkage;
      279 	    modifier = Indirection_modifier;
      280 	    return;
      281 	  end;
      282 
      283 	relp = lk.exp;
      284 	section = Linkage;
      285 	modifier = lk.mod;
      286 	internal = true;
      287 	return;
      288         end;
      289 
      290       /* the reference is to another link */
      291 
      292       if no_prelink
      293         then do;
      294 
      295 	/* we have to emit the target link of this link, so snap it	*/
      296 	/* without prelinking and regenerate the reference.	*/
      297 
      298 	call le_snap_ (ocudp, lecp, comp, Linkage, ref_relp, (lk.exp),
      299 	     no_prelink, section, relp, modifier, internal);
      300 	section = Linkage;
      301 	relp = ocu_$emit_link (ocudp, Self_Base, Linkage, "", "", (relp),
      302 	     lk.mod, null);
      303 	modifier = Indirection_modifier;
      304 	return;
      305         end;
      306 
      307       /* if the link has an indirection modifier, then we will end up	*/
      308       /* indirecting through the target link as well, so snap to the	*/
      309       /* target of that link instead.				*/
      310 
      311       if lk.mod = Indirection_modifier
      312         then call le_snap_ (ocudp, lecp, comp, Linkage, ref_relp, (lk.exp),
      313 	        false, section, relp, modifier, internal);
      314         else do;
      315 	call le_snap_ (ocudp, lecp, comp, Linkage, ref_relp, (lk.exp),
      316 	     false, section, relp, modifier, internal);
      317 	modifier = lk.mod;
      318         end;
      319       internal = true;
      320     end;
      321   else if lk.class = CLASS_SYMBOL
      322     then do;
      323 
      324       /* if not prelinking, just re-emit the link */
      325 
      326       if no_prelink
      327         then do;
      328 	section = Linkage;
      329 	relp = ocu_$emit_link (ocudp, Self_Base, Symbol, "", "",
      330 	     (lk.exp), lk.mod, null);
      331 	modifier = Indirection_modifier;
      332 	return;
      333         end;
      334 
      335       /* otherwise, relocate and return the symbol offset */
      336 
      337       section = Symbol;
      338       relp = lk.exp + lec.comp (comp).new.rel_symb;
      339       modifier = lk.mod;
      340       internal = true;
      341     end;
      342   else if lk.class = CLASS_STATIC
      343     then do;
      344 
      345       if lec.header.flags.separate_static | no_prelink
      346         then do;
      347 
      348 	/* we can't prelink to separate static */
      349 
      350 	section = Linkage;
      351 	relp = ocu_$emit_link (ocudp, Self_Base, Static, "", "",
      352 	     lk.exp + lec.comp (comp).new.rel_stat, lk.mod, null);
      353 	if ^no_prelink
      354 	  then lk.relp = relp;
      355 	modifier = Indirection_modifier;
      356 	return;
      357         end;
      358 
      359       section = Static;
      360       relp = lk.exp + lec.comp (comp).new.rel_stat;
      361       modifier = lk.mod;
      362       internal = true;
      363     end;
      364   else call le_error_ (LE_FATAL_ERROR, le_et_$bad_link_class,
      365 	  "^/Class ^d found while evaluating link at link|^o.",
      366 	  lk.class, ref_relp);
      367 
      368   return;
      369 
      370 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      371 
      372 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      373 
      374 
      375 LINK_TYPE (3):			/** refname|0+expression	*/
      376 
      377   if lec.comp (lk.target).target = None | no_prelink
      378     then do;
      379 
      380       /* the target is not internal, or we were told not to prelink,	*/
      381       /* so we just regenerate the link.			*/
      382 
      383       relp = ocu_$emit_link (ocudp, Refname_Base, 0, (segname.string), "",
      384 	 (lk.exp), lk.mod, null);
      385       section = Linkage;
      386       modifier = Indirection_modifier;
      387       if ^no_prelink
      388         then lk.relp = relp;
      389     end;
      390   else if lec.comp (lk.target).target ^= lec.comp (comp).target
      391     then do;
      392 
      393       /* the target is internal but in another component, so generate	*/
      394       /* a partial link and retain the indirection.		*/
      395 
      396       relp = ocu_$emit_partial_link (ocudp, (lec.comp (lk.target).target),
      397 	 Text, 0, lk.mod);
      398       lk.relp = relp;
      399       section = Linkage;
      400       modifier = Indirection_modifier;
      401     end;
      402   else do;
      403 
      404     /* the target is internal and in this component, so remove the	*/
      405     /* indirection and resolve from the base of the text section of	*/
      406     /* the target component.				*/
      407 
      408     relp = lk.exp + lec.comp (lk.target).new.rel_text;
      409     section = Text;
      410     modifier = lk.mod;
      411     internal = true;
      412   end;
      413 
      414   return;
      415 
      416 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      417 
      418 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      419 
      420 
      421 LINK_TYPE (4):			/** refname|entry+expression	*/
      422 
      423   if lk.target = None | no_prelink
      424     then do;
      425 
      426       /* the link is not internal, or we are not snapping it for	*/
      427       /* other reasons.					*/
      428 
      429       relp = ocu_$emit_link (ocudp, Refname_Offsetname, 0, (segname.string),
      430 	 (offsetname.string), (lk.exp), lk.mod, null);
      431       section = Linkage;
      432       modifier = Indirection_modifier;
      433       if ^no_prelink
      434         then lk.relp = relp;
      435       return;
      436     end;
      437 
      438   defnp = addr (lec.comp (lk.target).tables.ledp -> led.def (lk.defx));
      439 
      440   if lec.comp (lk.target).target ^= lec.comp (comp).target
      441     then do;
      442 
      443       /* the target of the link is in another component, so we have	*/
      444       /* to generate a partial link to the target.  If the link	*/
      445       /* points to the linkage section, we may have to backpatch if	*/
      446       /* it refers to a link.					*/
      447 
      448       if defn.type ^= Linkage
      449         then do;
      450 
      451 	/* simple partial link reference, relocate the offset	*/
      452 	/* and emit the partial link.				*/
      453 
      454 	if defn.type = Text
      455 	  then offset = lec.comp (lk.target).new.rel_text;
      456 	else if defn.type = Symbol
      457 	  then offset = lec.comp (lk.target).new.rel_symb;
      458 	else if defn.type = Static
      459 	  then offset = lec.comp (lk.target).new.rel_stat;
      460 	else call le_error_ (LE_ABORT_ERROR, error_table_$bad_class_def,
      461 		"^/Class ^d definition in ^a at definition|^o.",
      462 		defn.type, lec.comp (lk.target).name, defn.offset);
      463 
      464 	offset = offset + defn.relp + lk.exp;
      465 	relp = ocu_$emit_partial_link (ocudp, (lec.comp (lk.target).target),
      466 	     (defn.type), offset, lk.mod);
      467 	lk.relp = relp;
      468         end;
      469         else do;
      470 
      471 	/* we have a linkage reference.  Now we determine if it is	*/
      472 	/* a header, static, or link reference, and handle things	*/
      473 	/* accordingly.					*/
      474 
      475 	hdr_size = size (virgin_linkage_header);
      476 	if defn.relp < hdr_size
      477 	  then do;
      478 
      479 	    /* the reference it so the header.  Just link to the	*/
      480 	    /* same point in the new header.			*/
      481 
      482 	    relp = ocu_$emit_partial_link (ocudp,
      483 	         (lec.comp (lk.target).target), Linkage,
      484 	         defn.relp + lk.exp, lk.mod);
      485 	    lk.relp = relp;
      486 	  end;
      487 	else if defn.relp < hdr_size + lec.comp (lk.target).orig.statl
      488 	  then do;
      489 
      490 	    /* the reference is to the static section, so relocate	*/
      491 	    /* it appropriately, and emit the link.		*/
      492 
      493 	    relp = ocu_$emit_partial_link (ocudp,
      494 	         (lec.comp (lk.target).target), Linkage,
      495 	         defn.relp + lk.exp + lec.comp (lk.target).new.rel_stat,
      496 	         lk.mod);
      497 	    lk.relp = relp;
      498 	  end;
      499 	else do;
      500 
      501 	  /* the reference is to a link.  But we probably don't	*/
      502 	  /* know where that link will be emitted yet, so we will	*/
      503 	  /* have to schedule a backpatch of the offset.	*/
      504 
      505 	  relp = ocu_$emit_partial_link (ocudp,
      506 	       (lec.comp (lk.target).target), Linkage, (lk.exp), lk.mod);
      507 	  call le_backpatch_ (Patch_Link, lec.comp (comp).target, relp,
      508 	       (lk.target), (lk.defx));
      509 	  lk.relp = relp;
      510 	end;
      511 
      512         end;
      513 
      514       section = Linkage;
      515       modifier = Indirection_modifier;
      516       return;
      517     end;
      518 
      519   /* the reference is internal and within this component, so we can	*/
      520   /* actually resolve the reference.				*/
      521 
      522   if defn.type = Text
      523     then do;
      524       section = Text;
      525       relp = defn.relp + lk.exp + lec.comp (lk.target).new.rel_text;
      526       modifier = lk.mod;
      527       internal = true;
      528     end;
      529   else if defn.type = Symbol
      530     then do;
      531       section = Symbol;
      532       relp = defn.relp + lk.exp + lec.comp (lk.target).new.rel_symb;
      533       modifier = lk.mod;
      534       internal = true;
      535     end;
      536   else if defn.type = Static
      537     then do;
      538 
      539       if lec.header.flags.separate_static
      540         then do;
      541 
      542 	/* we can't prelink to separate static */
      543 
      544 	section = Linkage;
      545 	relp = ocu_$emit_link (ocudp, Self_Base, Static, "", "",
      546 	     defn.relp + lk.exp + lec.comp (lk.target).new.rel_stat,
      547 	     lk.mod, null);
      548 	modifier = Indirection_modifier;
      549 	return;
      550         end;
      551 
      552       section = Static;
      553       relp = defn.relp + lk.exp + lec.comp (lk.target).new.rel_stat;
      554       modifier = lk.mod;
      555       internal = true;
      556     end;
      557   else if defn.type = Linkage
      558     then do;
      559 
      560       /* either a link or static reference.  If static, relocate	*/
      561       /* and resolve the link.  If it is a link, we snap to the	*/
      562       /* target of the link.					*/
      563 
      564       hdr_size = size (virgin_linkage_header);
      565 
      566       if defn.relp < hdr_size + lec.comp (lk.target).orig.defnl
      567         then do;
      568 
      569 	/* a static reference, so relocate and return */
      570 
      571 	relp = defn.relp + lk.exp + lec.comp (lk.target).new.rel_stat -
      572 	     hdr_size;
      573 	section = Static;
      574 	modifier = lk.mod;
      575 	internal = true;
      576         end;
      577         else do;
      578 
      579 	/* a link reference, so we snap the target of the link	*/
      580 	/* depending on the modifier in the current link, and	*/
      581 	/* snap to there.					*/
      582 
      583 	if lk.mod = Indirection_modifier
      584 	  then call le_snap_ (ocudp, lecp, (lk.target), Linkage, ref_relp,
      585 		  defn.relp + lk.exp, false, section, relp,
      586 		  modifier, internal);
      587 	  else do;
      588 	    call le_snap_ (ocudp, lecp, (lk.target), Linkage, ref_relp,
      589 	         defn.relp + lk.exp, true, section, relp, modifier,
      590 	         internal);
      591 	    modifier = lk.mod;
      592 	  end;
      593 
      594 	internal = true;
      595         end;
      596     end;
      597   else call le_error_ (LE_ABORT_ERROR, error_table_$bad_class_def,
      598 	  "^/Class ^d found in ^a at definition|^o.",
      599 	  defn.type, lec.comp (lk.target).name, defn.offset);
      600 
      601   return;
      602 
      603 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      604 
      605 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      606 
      607 
      608 LINK_TYPE (5):			/** *section|entry+expression	*/
      609 
      610   /* for now, only *system and *heap links of this type are supported	*/
      611   /* (primarily since none of the others are used).		*/
      612 
      613   if lk.initp = null
      614     then do;
      615 
      616       /* this indicates that the actual init_info is in another MSF	*/
      617       /* component, and we need to create a deferred_init init_info	*/
      618       /* block for this link.					*/
      619 
      620       tlp = addr (lec.comp (lk.target_comp).tables.lelp ->
      621 	 lel.link (lk.target_link));
      622 
      623       auto_def.type = INIT_DEFERRED;
      624       auto_def.n_words = tl.initp -> init.n_words;
      625       auto_def.target_relp = ocu_$emit_partial_link (ocudp,
      626 	 (lec.comp (lk.target_comp).target), Linkage, 0, ""b);
      627       auto_def.link_relp = 0;
      628 
      629       section = Linkage;
      630       relp = ocu_$emit_link (ocudp, Self_Offsetname, (lk.class), "",
      631 	 (offsetname.string), (lk.exp), lk.mod, addr (auto_def));
      632       modifier = Indirection_modifier;
      633 
      634       lk.relp = relp;
      635 
      636       call le_backpatch_ (Patch_Init, lec.comp (comp).target, relp,
      637 	 (lk.target_comp), (lk.target_link));
      638     end;
      639   else if lk.extension ^= None
      640     then do;
      641 
      642       /* clear the template count */
      643 
      644       template_index = 0;
      645 
      646       /* the init info given will be used but must be extended to a	*/
      647       /* larger size.  So we generate a new init info, and extend it,	*/
      648       /* padding with zeros, to the proper size.			*/
      649 
      650       initp = lk.initp;
      651 
      652       if init.type = INIT_NO_INIT | init.type = INIT_DEFINE_AREA
      653         then do;
      654 	auto_init.type = init.type;
      655 	auto_init.n_words = init.n_words + lk.extension;
      656 	initp = addr (auto_init);
      657 	relp = ocu_$emit_link (ocudp, Self_Offsetname, (lk.class), "",
      658 	     (offsetname.string), (lk.exp), lk.mod, addr (auto_init));
      659 	lk.relp = relp;
      660 	section = Linkage;
      661 	modifier = Indirection_modifier;
      662         end;
      663       else if init.type = INIT_COPY_INFO
      664         then do;
      665 	sys_areap = get_system_free_area_ ();
      666 	new_initp = null;
      667 
      668 	if lk.extension > 50 /* arbitrary limit */
      669 	  then do;
      670 
      671 	    /* the extension is large enough that it is more	*/
      672 	    /* efficient to convert the copy info into a list	*/
      673 	    /* template.					*/
      674 
      675 	    on cleanup
      676 	      begin;
      677 	      if new_initp ^= null
      678 	        then free new_list in (sys_area);
      679 	    end;
      680 
      681 	    /* allocate a list_template init structure */
      682 
      683 	    list_size = currentsize (init_copy) + 3;
      684 	    allocate new_list in (sys_area);
      685 	    new_list.type = INIT_LIST_TEMPLATE;
      686 	    new_list.n_words = init.n_words + lk.extension;
      687 
      688 	    /* create the template for the original data */
      689 
      690 	    ltep = addr (new_list.template (1));
      691 	    lte.n_bits = init_copy.n_words * 36;
      692 	    lte.repeat = 1;
      693 	    lte.datum = unspec (init_copy.initial_data);
      694 
      695 	    /* create the template to skip the size of the extension */
      696 
      697 	    ltep = addwordno (ltep, currentsize (lte));
      698 	    lte.n_bits = lk.extension * 36;
      699 	    lte.repeat = 0;		/* skip bits */
      700 
      701 	    /* create the template for end of initialization */
      702 
      703 	    ltep = addwordno (ltep, 2);
      704 	    lte.n_bits = 0;
      705 
      706 	    /* emit the link */
      707 
      708 	    relp = ocu_$emit_link (ocudp, Self_Offsetname, (lk.class), "",
      709 	         (offsetname.string), (lk.exp), lk.mod, new_initp);
      710 	    lk.relp = relp;
      711 	    section = Linkage;
      712 	    modifier = Indirection_modifier;
      713 
      714 	    free new_list in (sys_area);
      715 
      716 	    revert cleanup;
      717 
      718 	  end;
      719 	  else do;
      720 
      721 	    /* the extenstion is small, so just extend the copy init */
      722 
      723 	    new_initp = null;
      724 
      725 	    on cleanup
      726 	      begin;
      727 	      if new_initp ^= null
      728 	        then free new_copy in (sys_area);
      729 	    end;
      730 
      731 	    /* determine the new length */
      732 
      733 	    n_words = init_copy.n_words + lk.extension;
      734 
      735 	    /* allocate the new init_info */
      736 
      737 	    allocate new_copy in (sys_area);
      738 
      739 	    /* copy the data into the new template */
      740 
      741 	    new_copy.type = INIT_COPY_INFO;
      742 	    unspec (new_copy.initial_data) = 
      743 	         unspec (init_copy.initial_data);
      744 
      745 	    /* emit the link */
      746 
      747 	    relp = ocu_$emit_link (ocudp, Self_Offsetname, (lk.class), "",
      748 	         (offsetname.string), (lk.exp), lk.mod, new_initp);
      749 	    lk.relp = relp;
      750 	    section = Linkage;
      751 	    modifier = Indirection_modifier;
      752 
      753 	    free new_copy in (sys_area);
      754 
      755 	    revert cleanup;
      756 	  end;
      757         end;
      758       else if init.type = INIT_LIST_TEMPLATE
      759         then do;
      760 	sys_areap = get_system_free_area_ ();
      761 
      762 	new_initp = null;
      763 
      764 	/* extend the list template init by adding a new skip bits	*/
      765 	/* template and end template.				*/
      766 
      767 	on cleanup
      768 	  begin;
      769 	  if new_initp ^= null
      770 	    then free new_list in (sys_area);
      771 	end;
      772 
      773 	/* allocate a larger template */
      774 
      775 	list_size = init_list.n_words_in_list + 2;
      776 
      777 	allocate new_list in (sys_area);
      778 
      779 	/* copy the old list template into the new structure */
      780 
      781 	new_list.type = INIT_LIST_TEMPLATE;
      782 	new_list.n_words = init_list.n_words + lk.extension;
      783 	unspec (new_list.template) = unspec (init_list.template);
      784 
      785 	/* the new extension template starts in the last word of	*/
      786 	/* the old template, replacing the end-of-init (n_bits = 0)	*/
      787 	/* template.					*/
      788 
      789 	ltep = addwordno (new_initp, currentsize (init_list) - 1);
      790 	lte.n_bits = lk.extension * 36;
      791 	lte.repeat = 0;
      792 
      793 	/* now append a new end-of-init template */
      794 
      795 	ltep = addwordno (ltep, 2);
      796 	lte.n_bits = 0;
      797 
      798 	/* scan the copy looking for pointer initializations */
      799 
      800 	ltep = addr (new_list.template);
      801 	template_index = 1;
      802 	substr (patch_mask, template_index, 1) = false;
      803 
      804 	do while (lte.n_bits ^= 0);
      805 
      806 	  /* see if it is a pointer initialization */
      807 
      808 	  if lte.init_type ^= 0
      809 	    then do;
      810 
      811 	      /* get a pointer to the init datum */
      812 
      813 	      pitp = addr (lte.datum);
      814 
      815 	      /* relocate text refs by adding in the text offset */
      816 
      817 	      if pit.ptr_type = 0
      818 	        then pit.word_offset = pit.word_offset +
      819 		        lec.comp (lk.target_comp).new.rel_text;
      820 
      821 	      /* relocate static refs by adding in the static offset */
      822 
      823 	      else if pit.ptr_type = 2
      824 	        then pit.word_offset = pit.word_offset +
      825 		        lec.comp (lk.target_comp).new.rel_stat;
      826 
      827 	      /* relocate linkage refs by regenerating the link	*/
      828 	      /* and putting the new link offset in the template	*/
      829 
      830 	      else do;
      831 	        if pit.section_offset = ref_relp
      832 		then substr (patch_mask, template_index, 1) = true;
      833 		else do;
      834 		  call le_snap_ (ocudp, lecp, (lk.target_comp), Linkage,
      835 		       ref_relp, (pit.section_offset), false, section,
      836 		       relp, modifier, internal);
      837 		  if section ^= None
      838 		    then if section ^= Linkage
      839 			 then pit.section_offset =
      840 				 ocu_$emit_link (ocudp, Self_Base,
      841 				 section, "", "", (relp), modifier,
      842 				 null);
      843 			 else pit.section_offset = relp;
      844 		end;
      845 	      end;
      846 	    end;
      847 
      848 	  /* skip to the next template */
      849 
      850 	  ltep = addwordno (ltep, currentsize (lte));
      851 	  template_index = template_index + 1;
      852 	  substr (patch_mask, template_index, 1) = false;
      853 
      854 	end;
      855 
      856 	/* emit the link */
      857 
      858 	relp = ocu_$emit_link (ocudp, Self_Offsetname, (lk.class), "",
      859 	     (offsetname.string), (lk.exp), lk.mod, new_initp);
      860 
      861 	/* scan to see if we have to backpatch self-referential	*/
      862 	/* pointer init templates.				*/
      863 
      864 	do while (substr (patch_mask, 1, template_index) ^= ""b);
      865 	  i = index (patch_mask, "1"b);
      866 	  call le_backpatch_ (Patch_Self_Init, lec.comp (comp).target,
      867 	       relp, 0, i);
      868 	  substr (patch_mask, i, 1) = false;
      869 	end;
      870 
      871 	lk.relp = relp;
      872 	section = Linkage;
      873 	modifier = Indirection_modifier;
      874 
      875 	/* and free the new init template */
      876 
      877 	free new_list in (sys_area);
      878 
      879 	revert cleanup;
      880 
      881         end;
      882     end;
      883 
      884   else do;
      885 
      886     /* set up flags and handler in case relocation of pointer	*/
      887     /* initializations requires us to make a copy of the template.	*/
      888 
      889     initp = lk.initp;
      890     copied = false;
      891     new_initp = null;
      892     sys_areap = get_system_free_area_ ();
      893 
      894     on cleanup
      895       begin;
      896       if copied
      897         then free new_list in (sys_area);
      898     end;
      899 
      900     template_index = 0;
      901 
      902     /* only check for pointer inits in list templates, since you	*/
      903     /* can't do them any other way.				*/
      904 
      905     if init.type = INIT_LIST_TEMPLATE
      906       then do;
      907 
      908         /* get a pointer to the first template */
      909 
      910         ltep = addr (init_list.template);
      911         template_index = 1;
      912         substr (patch_mask, template_index, 1) = false;
      913 
      914         /* scan until we hit the end template */
      915 
      916         do while (lte.n_bits ^= 0);
      917 
      918 	/* check for non-constant initialization template */
      919 
      920 	if lte.init_type ^= 0
      921 	  then do;
      922 
      923 	    /* if we haven't already copied the template, do so now	*/
      924 
      925 	    if ^copied
      926 	      then do;
      927 
      928 	        /* allocate a new template */
      929 
      930 	        list_size = init_list.n_words_in_list;
      931 	        allocate new_list in (sys_area);
      932 
      933 	        /* note that we have done so so that it can be freed */
      934 
      935 	        copied = true;
      936 
      937 	        /* copy the old template */
      938 
      939 	        unspec (new_list) = unspec (init_list);
      940 
      941 	        /* generate a new template pointer that points to	*/
      942 	        /* the same template in the new init info we were	*/
      943 	        /* looking at in the original info and continue our	*/
      944 	        /* scan using the new init info			*/
      945 
      946 	        ltep = addwordno (new_initp, wordno (ltep)-wordno (initp));
      947 	      end;
      948 
      949 	    /* get a pointer to the init datum */
      950 
      951 	    pitp = addr (lte.datum);
      952 
      953 	    /* relocate text refs by adding in the text offset */
      954 
      955 	    if pit.ptr_type = 0
      956 	      then pit.word_offset = pit.word_offset +
      957 		      lec.comp (lk.target_comp).new.rel_text;
      958 
      959 	    /* relocate static refs by adding in the static offset */
      960 
      961 	    else if pit.ptr_type = 2
      962 	      then pit.word_offset = pit.word_offset +
      963 		      lec.comp (lk.target_comp).new.rel_stat;
      964 
      965 	    /* relocate linkage refs by regenerating the link	*/
      966 	    /* and putting the new link offset in the template	*/
      967 
      968 	    else do;
      969 	      if pit.section_offset = ref_relp
      970 	        then substr (patch_mask, template_index, 1) = true;
      971 	        else do;
      972 		call le_snap_ (ocudp, lecp, (lk.target_comp), Linkage,
      973 		     ref_relp, (pit.section_offset), false, section, relp,
      974 		     modifier, internal);
      975 		if section ^= None
      976 		  then if section ^= Linkage
      977 		         then pit.section_offset =
      978 			         ocu_$emit_link (ocudp, Self_Base,
      979 			         section, "", "", (relp), modifier,
      980 			         null);
      981 		         else pit.section_offset = relp;
      982 	        end;
      983 	    end;
      984 	  end;
      985 
      986 	ltep = addwordno (ltep, currentsize (lte));
      987 	template_index = template_index + 1;
      988 	substr (patch_mask, template_index, 1) = false;
      989 
      990         end;
      991       end;
      992 
      993     if ^copied
      994       then new_initp = initp;
      995 
      996     relp = ocu_$emit_link (ocudp, Self_Offsetname, (lk.class), "",
      997          (offsetname.string), (lk.exp), lk.mod, (new_initp));
      998 
      999     /* scan to see if we have to backpatch self-referential pointer	*/
     1000     /* init templates.					*/
     1001 
     1002     if template_index > 0
     1003       then
     1004         do while (substr (patch_mask, 1, template_index) ^= ""b);
     1005         i = index (patch_mask, "1"b);
     1006         call le_backpatch_ (Patch_Self_Init, lec.comp (comp).target,
     1007 	   relp, 0, i);
     1008         substr (patch_mask, i, 1) = false;
     1009       end;
     1010 
     1011     lk.relp = relp;
     1012     section = Linkage;
     1013     modifier = Indirection_modifier;
     1014 
     1015     if copied
     1016       then free new_list in (sys_area);
     1017 
     1018     revert cleanup;
     1019   end;
     1020 
     1021   return;
     1022 
     1023 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1024 
     1025 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1026 
     1027 
  1     1 /****  START OF:	le_data.incl.pl1			 *  *  *  *  *  */
  1     2 
  1     3 /****^  HISTORY COMMENTS:
  1     4*  1) change(86-08-12,Elhard), approve(86-08-12,MCR7505),
  1     5*     audit(86-12-10,DGHowe), install(86-12-10,MR12.0-1241):
  1     6*     Originally written to define the structures used internally by le_.
  1     7*                                                   END HISTORY COMMENTS */
  1     8 
  1     9   /*** ****************************************************************/
  1    10   /***							*/
  1    11   /***	Name:	le_data					*/
  1    12   /***	Function:	This include file defines the data structures	*/
  1    13   /***		used internally by the linkage_editor subroutine.	*/
  1    14   /***							*/
  1    15   /*** ****************************************************************/
  1    16   
  1    17   /* error severity constants */
  1    18   
  1    19   dcl LE_WARNING		fixed bin static options (constant) init (1);
  1    20   dcl LE_ERROR		fixed bin static options (constant) init (2);
  1    21   dcl LE_FATAL_ERROR	fixed bin static options (constant) init (3);
  1    22   dcl LE_ABORT_ERROR	fixed bin static options (constant) init (4);
  1    23   
  1    24   /* section identifier constants */
  1    25   
  1    26   dcl Text		fixed bin (3) static options (constant)
  1    27 			init (0);
  1    28   dcl Linkage		fixed bin (3) static options (constant)
  1    29 			init (1);
  1    30   dcl Symbol		fixed bin (3) static options (constant)
  1    31 			init (2);
  1    32   dcl Definition		fixed bin (3) static options (constant)
  1    33 			init (3);
  1    34   dcl Static		fixed bin (3) static options (constant)
  1    35 			init (4);
  1    36   dcl System		fixed bin (3) static options (constant)
  1    37 			init (5);
  1    38   dcl Heap		fixed bin (3) static options (constant)
  1    39 			init (6);
  1    40   
  1    41   dcl section_nm		(0:6) char (16) static options (constant)
  1    42 			init ("text", "linkage", "symbol", "definition",
  1    43 			"static", "system", "heap");
  1    44   
  1    45   /* link type constants */
  1    46   
  1    47   dcl Self_Base		fixed bin (3) static options (constant)
  1    48 			init (1);
  1    49   dcl Refname_Base		fixed bin (3) static options (constant)
  1    50 			init (3);
  1    51   dcl Refname_Offsetname	fixed bin (3) static options (constant)
  1    52 			init (4);
  1    53   dcl Self_Offsetname	fixed bin (3) static options (constant)
  1    54 			init (5);
  1    55   
  1    56   /* backpatch type constants */
  1    57   
  1    58   dcl Patch_Link		fixed bin static options (constant) init (1);
  1    59   dcl Patch_Init		fixed bin static options (constant) init (2);
  1    60   dcl Patch_Symbol_Ref	fixed bin static options (constant) init (3);
  1    61   dcl Patch_Self_Init	fixed bin static options (constant) init (4);
  1    62   
  1    63   /*** ****************************************************************/
  1    64   /***							*/
  1    65   /***	Name:	le_components				*/
  1    66   /***	Function:	the component table is used to keep information	*/
  1    67   /***		about the input components being used and their	*/
  1    68   /***		disposition in output components.		*/
  1    69   /***							*/
  1    70   /*** ****************************************************************/
  1    71   
  1    72   dcl 01 le_components	aligned based,
  1    73        02 header		aligned,
  1    74         03 flags		aligned,
  1    75          04 separate_static	bit (1) unaligned,
  1    76          04 perprocess_static	bit (1) unaligned,
  1    77          04 mbz		bit (34) unaligned,
  1    78         03 n_components	fixed bin,
  1    79        02 comp		(0 refer (le_components.n_components))
  1    80 			like le_comp;
  1    81   
  1    82   /*** ****************************************************************/
  1    83   /***							*/
  1    84   /***	Name:	le_comp					*/
  1    85   /***	Function:	this is a single component table entry.		*/
  1    86   /***							*/
  1    87   /*** ****************************************************************/
  1    88   
  1    89   dcl 01 le_comp		aligned based,
  1    90        02 segp		ptr,
  1    91        02 bc		fixed bin (24),
  1    92        02 uid		bit (36) aligned,
  1    93        02 dtcm		fixed bin (71),
  1    94        02 name		char (32) varying,
  1    95        02 path		char (194) varying,
  1    96        02 compiler		char (8),
  1    97        02 target		fixed bin,
  1    98        02 flags		aligned,
  1    99         03 library		bit (1) unaligned,
  1   100         03 include		bit (1) unaligned,
  1   101         03 delete_table	bit (1) unaligned,
  1   102         03 separate_static	bit (1) unaligned,
  1   103         03 io_table		bit (1) unaligned,
  1   104         03 unique_path	bit (1) unaligned,
  1   105         03 mbz		bit (30) unaligned,
  1   106        02 tables		aligned,
  1   107         03 lesp		ptr,
  1   108         03 ledp		ptr,
  1   109         03 lelp		ptr,
  1   110        02 orig		aligned,
  1   111         03 textp		ptr,
  1   112         03 defnp		ptr,
  1   113         03 linkp		ptr,
  1   114         03 statp		ptr,
  1   115         03 symbp		ptr,
  1   116         03 rel_textp	ptr,
  1   117         03 rel_symbp	ptr,
  1   118         03 rel_linkp	ptr,
  1   119         03 textl		fixed bin (18) unsigned unaligned,
  1   120         03 defnl		fixed bin (18) unsigned unaligned,
  1   121         03 linkl		fixed bin (18) unsigned unaligned,
  1   122         03 statl		fixed bin (18) unsigned unaligned,
  1   123         03 symbl		fixed bin (18) unsigned unaligned,
  1   124         03 symbl_no_rel	fixed bin (18) unsigned unaligned,
  1   125         03 symbl_no_table	fixed bin (18) unsigned unaligned,
  1   126         03 n_symb_blocks	fixed bin (18) unsigned unaligned,
  1   127         03 text_boundary	fixed bin (9) unsigned unaligned,
  1   128         03 static_boundary	fixed bin (9) unsigned unaligned,
  1   129         03 next_comp	fixed bin (18) unsigned unaligned,
  1   130        02 new		aligned,
  1   131         03 rel_text		fixed bin (18) unsigned unaligned,
  1   132         03 rel_symb		fixed bin (18) unsigned unaligned,
  1   133         03 rel_stat		fixed bin (18) unsigned unaligned,
  1   134         03 text_pad		fixed bin (18) unsigned unaligned,
  1   135         03 static_pad	fixed bin (18) unsigned unaligned,
  1   136         03 symbol_pad	fixed bin (18) unsigned unaligned;
  1   137   
  1   138   /*** ****************************************************************/
  1   139   /***							*/
  1   140   /***	Name:	le_segnames				*/
  1   141   /***	Function:	the segname table is used for two purposes:	*/
  1   142   /***		 - to determine the target components of links	*/
  1   143   /***		   being resolved internally.			*/
  1   144   /***		 - to determine the segname definitions to be	*/
  1   145   /***		   emited for definitions being retained.	*/
  1   146   /***							*/
  1   147   /*** ****************************************************************/
  1   148   
  1   149   dcl 01 le_segnames	aligned based,
  1   150        02 header		aligned,
  1   151         03 n_segnames	fixed bin,
  1   152        02 segname		(segname_count refer (le_segnames.n_segnames)),
  1   153         03 str		char (32) varying,
  1   154         03 relp		fixed bin (18) unsigned unaligned,
  1   155         03 pad		bit (18) unaligned;
  1   156   dcl segname_count		fixed bin automatic;
  1   157   
  1   158   /*** ****************************************************************/
  1   159   /***							*/
  1   160   /***	Name:	le_definitions				*/
  1   161   /***	Function:	the definition table contains the definitions	*/
  1   162   /***		from the input components and is used to resolve	*/
  1   163   /***		link targets, and regenerate definition entries	*/
  1   164   /***							*/
  1   165   /*** ****************************************************************/
  1   166   
  1   167   dcl 01 le_definitions	aligned based,
  1   168        02 header		aligned,
  1   169         03 n_defs		fixed bin,
  1   170         03 pad		bit (36),
  1   171        02 def		(def_count refer (le_definitions.n_defs))
  1   172 			like le_definition;
  1   173   dcl def_count		fixed bin automatic;
  1   174   
  1   175   dcl 01 le_definition	aligned based,
  1   176        02 str		char (256) varying,
  1   177        02 type		fixed bin (18) unsigned unaligned,
  1   178        02 relp		fixed bin (18) unsigned unaligned,
  1   179        02 offset		fixed bin (18) unsigned unaligned,
  1   180        02 new_offset	fixed bin (18) unsigned unaligned,
  1   181        02 flags		aligned,
  1   182         03 force_retain	bit (1) unaligned,
  1   183         03 entrypoint	bit (1) unaligned,
  1   184         03 ignore		bit (1) unaligned,
  1   185         03 referenced	bit (1) unaligned,
  1   186         03 no_link		bit (1) unaligned,
  1   187         03 retain		bit (1) unaligned,
  1   188         03 delete		bit (1) unaligned,
  1   189         03 mbz		bit (29) unaligned;
  1   190   
  1   191   /*** ****************************************************************/
  1   192   /***							*/
  1   193   /***	Name:	le_options				*/
  1   194   /***	Function:	the option table contains definition retention	*/
  1   195   /***		information.  The input retentions options are	*/
  1   196   /***		ordered such that a linear search of the option	*/
  1   197   /***		table for the first matching starname will give	*/
  1   198   /***		the correct retention state.			*/
  1   199   /***							*/
  1   200   /*** ****************************************************************/
  1   201   
  1   202   dcl 01 le_options		aligned based,
  1   203        02 header		aligned,
  1   204         03 n_opts		fixed bin,
  1   205        02 opt		(0 refer (le_options.n_opts)),
  1   206         03 type		fixed bin (8) unaligned,
  1   207         03 used		bit (1) unaligned,
  1   208         03 inhibit_error	bit (1) unaligned,
  1   209         03 class		fixed bin (6) unaligned,
  1   210         03 order		fixed bin (17) unaligned,
  1   211         03 segname		char (32) unaligned,
  1   212         03 ep_name		char (256) unaligned;
  1   213   
  1   214   /*** ****************************************************************/
  1   215   /***							*/
  1   216   /***	Name:	le_links					*/
  1   217   /***	Function:	the link table contains information on all of the	*/
  1   218   /***		links in the input components. It is used to	*/
  1   219   /***		determine link targets, which library components	*/
  1   220   /***		will be included, and what init_info will be	*/
  1   221   /***		used, and where it will be placed.		*/
  1   222   /***							*/
  1   223   /*** ****************************************************************/
  1   224   
  1   225   dcl 01 le_links		aligned based,
  1   226        02 header		aligned,
  1   227         03 offset_adjustment	fixed bin (18),
  1   228         03 n_links		fixed bin,
  1   229        02 link		(link_count refer (le_links.n_links))
  1   230 			like le_link;
  1   231   dcl link_count		fixed bin automatic;
  1   232 
  1   233   dcl 01 le_link		aligned based,
  1   234        02 flags		unaligned,
  1   235         03 used		bit (1),
  1   236         03 mbx		bit (35),
  1   237        02 type		fixed bin (6) unsigned unaligned,
  1   238        02 class		fixed bin (6) unsigned unaligned,
  1   239        02 mod		bit (6) unaligned,
  1   240        02 exp		fixed bin (17) unaligned,
  1   241        02 target		fixed bin (18) unsigned unaligned,
  1   242        02 defx		fixed bin (18) unsigned unaligned,
  1   243        02 relp		fixed bin (18) unsigned unaligned,
  1   244        02 target_comp	fixed bin (18) unsigned unaligned,
  1   245        02 target_link	fixed bin (18) unsigned unaligned,
  1   246        02 extension		fixed bin (18) unsigned unaligned,
  1   247        02 initp		ptr unaligned,
  1   248        02 segnamep		ptr unaligned,
  1   249        02 offsetp		ptr unaligned;
  1   250   
  1   251   /*** ****************************************************************/
  1   252   /***							*/
  1   253   /***	Name:	le_binaries				*/
  1   254   /***	Function:	This table contains information about the output	*/
  1   255   /***		binaries.  It is primarily used for creation and	*/
  1   256   /***		backpatching of MSF output.			*/
  1   257   /***							*/
  1   258   /*** ****************************************************************/
  1   259   
  1   260   dcl 01 le_binaries	aligned based,
  1   261        02 header		aligned,
  1   262         03 n_binaries	fixed bin,
  1   263         03 pad		bit (36),
  1   264        02 binary		(0:0 refer (le_binaries.n_binaries)),
  1   265         03 segp		ptr,
  1   266         03 bc		fixed bin (24),
  1   267         03 uid		bit (36),
  1   268         03 aclc		fixed bin,
  1   269         03 aclp		ptr,
  1   270         03 textp		ptr,
  1   271         03 defnp		ptr,
  1   272         03 linkp		ptr,
  1   273         03 symbp		ptr,
  1   274         03 statp		ptr,
  1   275         03 textl		fixed bin (18) unsigned unaligned,
  1   276         03 defnl		fixed bin (18) unsigned unaligned,
  1   277         03 linkl		fixed bin (18) unsigned unaligned,
  1   278         03 symbl		fixed bin (18) unsigned unaligned,
  1   279         03 statl		fixed bin (18) unsigned unaligned,
  1   280         03 mbz2		bit (18) unaligned;
  1   281   
  1   282   /*** ****************************************************************/
  1   283   /***							*/
  1   284   /***	Name:	le_patches				*/
  1   285   /***	Function:	This table contains the list of backpatches to be	*/
  1   286   /***		performed when the rest of the object creation is	*/
  1   287   /***		complete. Since le_backpatch_ is the only routine	*/
  1   288   /***		concerned with this,  it is maintained completely	*/
  1   289   /***		internal to le_backpatch_.			*/
  1   290   /***							*/
  1   291   /*** ****************************************************************/
  1   292   
  1   293   dcl 01 le_patches		aligned based,
  1   294        02 header		aligned,
  1   295         03 n_patches	fixed bin,
  1   296        02 patch		(0 refer (le_patches.n_patches)) like le_patch;
  1   297        
  1   298   dcl 01 le_patch		aligned based,
  1   299        02 type		fixed bin,
  1   300        02 comp		fixed bin,
  1   301        02 relp		fixed bin (18) unsigned,
  1   302        02 target		fixed bin,
  1   303        02 index		fixed bin;
  1   304   
  1   305 /****  END OF:	le_data.incl.pl1			 *  *  *  *  *  */
     1028 
  2     1 /* Begin include file definition_dcls.incl.pl1 BIM 1981 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  2     6*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
  2     7*     Modified to add indirect bit to definition flags, add msf_map_relp to the
  2     8*     definition header, declare the msf_map, and add structures and constants
  2     9*     for deferred initialization.
  2    10*  2) change(86-06-24,DGHowe), approve(86-06-24,MCR7420),
  2    11*     audit(86-08-05,Schroth), install(86-11-20,MR12.0-1222):
  2    12*     added the structures for pointer initialization. pointer_init_template.
  2    13*     changed list_template_entry
  2    14*                                                   END HISTORY COMMENTS */
  2    15 
  2    16 
  2    17 /* Modified:  */
  2    18 /*   13 Dec 1982 by Lee A. Newcomb to put definition_header.hash_table_relp */
  2    19 /*	after unused half-word instead of before it. */
  2    20 /*   1 March 1983 by M. Weaver to add list template init type */
  2    21 
  2    22 /* format: style3,idind25 */
  2    23 /* everything for the definition section */
  2    24 
  2    25 declare	(
  2    26 	CLASS_TEXT	     init (0),		/* text section definition */
  2    27 	CLASS_LINKAGE	     init (1),		/* linkage section definition */
  2    28 	CLASS_SYMBOL	     init (2),		/* symbol section definition */
  2    29 	CLASS_SEGNAME	     init (3),		/* segment name definition */
  2    30 	CLASS_STATIC	     init (4),		/* static section definition */
  2    31 	CLASS_SYSTEM	     init (5),		/* valid only in self links, not def class */
  2    32 	CLASS_HEAP	     init (6)		/* valid only in self links, not def class */
  2    33 	)		     fixed bin (3) unsigned internal static options (constant);
  2    34 
  2    35 declare	CLASS_NAMES	     (0:6) character (12) internal static options (constant)
  2    36 			     init ("text", "linkage", "symbol", "segname", "static", "system", "heap");
  2    37 
  2    38 declare	SYMBOLIC_SECTION_NAMES   (0:6) character (8)
  2    39 			     init ("*text", "*link", "*symbol", *, "*static", "*system", "*heap") internal static
  2    40 			     options (constant);
  2    41 
  2    42 declare	1 definition_flags	     unaligned based,
  2    43 	  2 new		     bit (1),		/* should be "1"b */
  2    44 	  2 ignore	     bit (1),		/* cannot snap link to this */
  2    45 	  2 entry		     bit (1),		/* can tra here */
  2    46 	  2 retain	     bit (1),		/* binder respects this */
  2    47 	  2 argcount	     bit (1),		/* OBSOLETE */
  2    48 	  2 descriptors	     bit (1),		/* OBSOLETE */
  2    49 	  2 indirect	     bit (1),		/* target is a pointer to actual target */
  2    50 	  2 unused	     bit (8);		/* Must be zero */
  2    51 
  2    52 
  2    53 
  2    54 
  2    55 /* Header of the definition section */
  2    56 
  2    57 declare	def_header_ptr	     pointer;
  2    58 declare	1 definition_header	     aligned based (def_header_ptr),
  2    59 	  2 def_list_relp	     fixed bin (18) unsigned unaligned,
  2    60 						/* first definition, reloc def18 */
  2    61 	  2 msf_map_relp	     fixed bin (18) unsigned unaligned,
  2    62 						/* msf_map if any, or 0 if none.  reloc def18 unless none */
  2    63 	  2 hash_table_relp	     fixed bin (18) unsigned unaligned,
  2    64 						/* def hash table, if any, or 0 if none. reloc def18 unless none */
  2    65 	  2 flags		     unaligned like definition_flags;
  2    66 						/* both new and ignore must be "1"b here */
  2    67 
  2    68 /* A non class=3 definition. See segname_definition below for class=3 */
  2    69 
  2    70 
  2    71 declare	def_ptr		     pointer;
  2    72 declare	1 definition	     aligned based (def_ptr),
  2    73 	  2 forward_relp	     unal fixed bin (18) unsigned,
  2    74 						/* offset of next def */
  2    75 	  2 backward_relp	     unal fixed bin (18) unsigned,
  2    76 						/* offset of previous def */
  2    77 	  2 thing_relp	     unal fixed bin (18) unsigned,
  2    78 						/* offset in section specified by class of thing this defines */
  2    79 	  2 flags		     unaligned like definition_flags,
  2    80 	  2 class		     unal fixed bin (3) unsigned,
  2    81 						/* Type of definition */
  2    82 	  2 name_relp	     unal fixed bin (18) unsigned,
  2    83 						/* offset of ACC for symbol */
  2    84 	  2 segname_relp	     unal fixed bin (18) unsigned;
  2    85 						/* offset of segname def to which this belongs */
  2    86 
  2    87 /* Class=3, segname definition */
  2    88 
  2    89 declare	segname_ptr	     pointer;
  2    90 declare	1 segname_definition     aligned based (segname_ptr),
  2    91 	  2 forward_relp	     unal fixed bin (18) unsigned,
  2    92 						/* offset of next def */
  2    93 	  2 backward_relp	     unal fixed bin (18) unsigned,
  2    94 						/* offset of previous def */
  2    95 	  2 next_segname_relp    unal fixed bin (18) unsigned,
  2    96 						/* offset of next segname def */
  2    97 	  2 flags		     unaligned like definition_flags,
  2    98 	  2 class		     unal fixed bin (3) unsigned,
  2    99 						/* 3 for segname */
  2   100 	  2 name_relp	     unal fixed bin (18) unsigned,
  2   101 						/* offset of ACC for symbol */
  2   102 	  2 first_relp	     unal fixed bin (18) unsigned;
  2   103 						/* see following : */
  2   104 
  2   105 /* Definition blocks are chained off of segname definitions.
  2   106*   segname_definition.first_relp is one of three things:
  2   107*    (1) the def section offset of the first ordinary (class^=3) definition
  2   108*      belonging to this segname block. In the case where there are more than
  2   109*      one segname's on a block, all their first_relp will point
  2   110*      to the same place.
  2   111*
  2   112*    (2) if there are no ordinary definitions associated with this segname,
  2   113*      then it is the def section offset of the next segname. 
  2   114*
  2   115*    (3) if there are no ordinary definitions in the block, and it
  2   116*      is the last block, then it points to a word containing 0.
  2   117*
  2   118* Thus the end of a list of synonym segnames can be detected by forward_relp
  2   119*   pointing to a class=3 definition whose first_relp is not the same as
  2   120*   the current definitions first_relp.
  2   121**/
  2   122 
  2   123 /* All the definitions are linked through the forward and
  2   124*   backward thread variables. The end of the chain can is indicated
  2   125*   by forward pointing to a zero word. */
  2   126 
  2   127 
  2   128 declare	exp_ptr		     pointer;
  2   129 declare	1 exp_word	     based (exp_ptr) aligned, /* expression word in link definition */
  2   130 	  2 type_relp	     fixed bin (18) unsigned unal,
  2   131 						/* pointer (rel to defs) of type pair structure */
  2   132 	  2 expression	     fixed bin (17) unal;	/* constant expression to be added in when snapping link */
  2   133 
  2   134 declare	(
  2   135 	LINK_SELF_BASE	     init (1),		/* *section|0+expression,modifier */
  2   136 						/* which section determined by segname_relp */
  2   137 	LINK_OBSOLETE_2	     init (2),		/* not used */
  2   138 	LINK_REFNAME_BASE	     init (3),		/* refname|0+expression,modifier */
  2   139 	LINK_REFNAME_OFFSETNAME  init (4),		/* refname|offsetname+expression,modifier */
  2   140 	LINK_SELF_OFFSETNAME     init (5),		/* *section|offsetname+expression,modifier */
  2   141 	LINK_CREATE_IF_NOT_FOUND init (6),		/* OBSOLETE: like LINK_REFNAME_OFFSETNAME except that it will create instead of taking linkage_error */
  2   142 	SECTION_TEXT	     init (0),		/* *text */
  2   143 	SECTION_LINK	     init (1),		/* *link */
  2   144 	SECTION_SYMBOL	     init (2),		/* *symbol */
  2   145 	SECTION_UNUSED	     init (3),		/* reserved */
  2   146 	SECTION_STATIC	     init (4),		/* *static */
  2   147 	SECTION_SYSTEM	     init (5),		/* *system */
  2   148 	SECTION_HEAP	     init (6)		/* *heap */
  2   149 	)		     fixed bin (18) unsigned unaligned internal static options (constant);
  2   150 
  2   151 /* use CLASS_NAMES for section names */
  2   152 
  2   153 declare	LINK_TYPE_NAMES	     (1:6)
  2   154 			     init ("absolute in section", "unused", "absolute off of refname",
  2   155 			     "symbolic off of refname", "symbolic in section", "symbolic off of refname; create")
  2   156 			     character (32) varying internal static options (constant);
  2   157 
  2   158 
  2   159 declare	type_ptr		     pointer;
  2   160 declare	1 type_pair	     based (type_ptr) aligned,/* type pair in link definition */
  2   161 	  2 type		     fixed bin (18) unsigned unal,
  2   162 						/* see above */
  2   163 	  2 trap_relp	     fixed bin (18) unsigned unal,
  2   164 						/* pointer (rel to defs) to the trap word */
  2   165 						/* unless LINK_SELF_OFFSETNAME off of *system or create link */
  2   166 	  2 segname_relp	     fixed bin (18) unsigned unal,
  2   167 						/* pointer (rel to defs) to ACC reference name for segment referenced, 
  2   168* /*or section code for SELF links */
  2   169 	  2 offsetname_relp	     fixed bin (18) unsigned unal;
  2   170 						/* for OFFSETNAME links, ACC string of name of location. */
  2   171 						/* for others, must be ZERO */
  2   172 
  2   173 
  2   174 /* Link Trap Pair */
  2   175 
  2   176 declare	link_trap_ptr	     pointer;
  2   177 declare	1 link_trap_pair	     aligned based (link_trap_ptr),
  2   178 	  2 call_relp	     fixed bin (18) unsigned unaligned,
  2   179 						/* LINK18, link to thing to call */
  2   180 	  2 info_relp	     fixed bin (18) unsigned unaligned;
  2   181 						/* LINK18, link to argument list */
  2   182 
  2   183 
  2   184 /* initialization info for *system or *heap link */
  2   185 
  2   186 
  2   187 /* NOTE --------------------------------------------------
  2   188*   the following structures defining initialization information are also
  2   189*   defined in fortran_storage.incl.pl1  system_link_init_info.incl.pl1
  2   190*   and should be kept equivalent
  2   191*   -------------------------------------------------------
  2   192**/
  2   193 
  2   194 declare	(
  2   195 	INIT_NO_INIT	     init (0),
  2   196 	INIT_COPY_INFO	     init (3),
  2   197 	INIT_DEFINE_AREA	     init (4),
  2   198 	INIT_LIST_TEMPLATE	     init (5),
  2   199 	INIT_DEFERRED	     init (6)
  2   200 	)		     fixed bin internal static options (constant);
  2   201 
  2   202 /* for type = 0 or 4 */
  2   203 
  2   204 declare	link_init_ptr	     pointer;
  2   205 declare	1 link_init	     aligned based (link_init_ptr),
  2   206 	  2 n_words	     fixed bin (35),	/* number to invent */
  2   207 	  2 type		     fixed bin;		/* see types above */
  2   208 
  2   209 /* for type=3, there is data to copy */
  2   210 
  2   211 declare	1 link_init_copy_info    aligned based (link_init_ptr),
  2   212 	  2 header	     aligned like link_init,
  2   213 	  2 initial_data	     (link_init_n_words refer (link_init_copy_info.header.n_words)) bit (36) aligned;
  2   214 
  2   215 declare	link_init_n_words	     fixed bin;
  2   216 
  2   217 /* for type = 5, there is a list template to copy */
  2   218 
  2   219 declare	1 link_init_list_template
  2   220 			     aligned based (link_init_ptr),
  2   221 	  2 header	     aligned like link_init,
  2   222 	  2 pad		     bit (18) unaligned,
  2   223 	  2 n_words_in_list	     fixed bin (18) unsigned unaligned,
  2   224 	  2 template	     (link_init_n_words_in_list refer (link_init_list_template.n_words_in_list));
  2   225 
  2   226 declare	link_init_n_words_in_list
  2   227 			     fixed bin;
  2   228 
  2   229 /* A list template consists of a series of entries with the following
  2   230*   description, concatenated together.  n_bits and datum are bit items,
  2   231*   to permit a wide range of inputs.
  2   232*
  2   233*   1.  A 'repeat' of '0' signifies skipping of 'n_bits' bits.
  2   234*   2.  A 'n_bits' of '0' signifies the last item of the list.
  2   235*
  2   236*   COMMON, VLA's, and LA's are presumed to start at the base pointer
  2   237*   of their particular storage section. */
  2   238 
  2   239 declare	1 list_template_entry    aligned based,
  2   240 	  2 n_bits	     fixed bin (35) aligned,	/* size of datum */
  2   241 	  2 mbz		     bit (3) unaligned,	/* future expansion */
  2   242 	  2 init_type	     fixed bin (3) unsigned unaligned, /* 0 normal init, 1 ptr init, 2 packed ptr init */
  2   243 	  2 repeat	     fixed bin (30) unsigned unaligned,
  2   244 						/* number of times to repeat datum */
  2   245 	  2 datum		     bit (link_init_n_bits_in_datum refer (list_template_entry.n_bits));
  2   246 
  2   247 
  2   248 /* the pointer_init_template represents the initialization information
  2   249*   for ITS and packed pointers.  Both pointer types require the entire
  2   250*   72 bit structure.
  2   251**/
  2   252 
  2   253 dcl       1 pointer_init_template  based,
  2   254 	  2 ptr_type	     fixed bin (18) unsigned unaligned,  /* 0 text section, 1 linkage section, 2 static section */
  2   255 	  2 section_offset	     fixed bin (18) unsigned unaligned,  /* offset to item in specified section */
  2   256 	  2 word_offset	     fixed bin (18) unsigned unaligned,  /* offset from section item to target in words */
  2   257 	  2 mbz		     bit (12) unaligned,
  2   258 	  2 bit_offset	     fixed bin (6) unsigned unaligned;   /* offset from section item|word offset to target in bits */
  2   259 
  2   260 
  2   261 declare	link_init_n_bits_in_datum
  2   262 			     fixed bin (35);
  2   263 
  2   264 /* for type = 6, the init_info resides in another MSF component */
  2   265 /* target_relp is a linkage section offset to a partial link to */
  2   266 /* the base of the linkage section of the component containing  */
  2   267 /* the actual init_info. link_relp is the offset of the actual  */
  2   268 /* link within that linkage section.			    */
  2   269 
  2   270 declare	1 link_init_deferred     aligned based (link_init_ptr),
  2   271 	  2 header	     aligned like link_init,
  2   272 	  2 target_relp	     fixed bin (18) unsigned unaligned,
  2   273 	  2 link_relp	     fixed bin (18) unsigned unaligned;
  2   274 
  2   275 /* Definition section hash table */
  2   276 
  2   277 declare	def_ht_ptr	     pointer;
  2   278 declare	1 definition_ht	     aligned based (def_ht_ptr),
  2   279 	  2 n_entries	     fixed bin,
  2   280 	  2 table		     (def_ht_n_entries refer (definition_ht.n_entries)) aligned,
  2   281 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  2   282 	    3 unused	     bit (18) unaligned;
  2   283 
  2   284 declare	def_ht_n_entries	     fixed bin;
  2   285 
  2   286 
  2   287 /* Component name ht */
  2   288 declare	comp_ht_ptr	     pointer;
  2   289 declare	1 component_ht	     aligned based (comp_ht_ptr),
  2   290 	  2 n_entries	     fixed bin,
  2   291 	  2 table		     (comp_ht_n_entries refer (component_ht.n_entries)) aligned,
  2   292 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  2   293 						/* hashed segname */
  2   294 	    3 block_hdr_relp     fixed bin (18) unsigned unaligned;
  2   295 						/* first segname def of block containing def_relp */
  2   296 
  2   297 declare	comp_ht_n_entries	     fixed bin;
  2   298 
  2   299 /* Duplicate name table */
  2   300 
  2   301 declare	dup_table_ptr	     pointer;
  2   302 declare	1 duplicate_table	     aligned based (dup_table_ptr),
  2   303 	  2 mbz		     bit (18) unaligned,	/* to tell it from a definition */
  2   304 	  2 n_names	     fixed bin (18) unsigned unaligned,
  2   305 						/* n in table */
  2   306 	  2 table		     (dup_table_n_names refer (duplicate_table.n_names)) aligned,
  2   307 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  2   308 	    3 block_hdr_relp     fixed bin (18) unsigned unaligned;
  2   309 
  2   310 declare	dup_table_n_names	     fixed bin;
  2   311 
  2   312 /* The msf_map is found in the definition section of an	*/
  2   313 /* object MSF component.  It is used by the linker to	*/
  2   314 /* determine whether a segment is a component of an object	*/
  2   315 /* MSF or a standard single-segment object.		*/
  2   316   
  2   317   dcl msf_map_ptr		ptr;
  2   318   dcl 01 msf_map		aligned based (msf_map_ptr),
  2   319        02 version		char (8),
  2   320        02 component_count	fixed bin (15) unsigned,
  2   321        02 my_component	fixed bin (15) unsigned;
  2   322   
  2   323   dcl msf_map_version_1	char (8) static options (constant)
  2   324 			     init ("msfmp1.0");
  2   325   
  2   326 declare	acc_string_ptr	     pointer;
  2   327 declare	1 acc_string	     aligned based (acc_string_ptr),
  2   328 	  2 count		     fixed bin (9) unsigned unaligned,
  2   329 	  2 string	     character (max (3, acc_string_length) refer (acc_string.count)) unaligned,
  2   330 	  2 mbz		     bit (0) aligned;	/* this causes the statement */
  2   331 						/* unspec (acc_string) = ""b to zero out */
  2   332 						/* the last word, if the string is not of length 0mod4 */
  2   333 
  2   334 declare	acc_string_length	     fixed bin (21);
  2   335 
  2   336 
  2   337 /* end include file definitions_dcls.incl.pl1 */
     1029 
  3     1 /* BEGIN INCLUDE FILE object_link_dcls.incl.pl1 BIM 1981 from linkdcl */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  3     6*     audit(86-11-18,Schroth), install(86-11-20,MR12.0-1222):
  3     7*     Modified to add partial_link structure for an object MSF partially snapped
  3     8*     link.
  3     9*  2) change(86-11-13,DGHowe), approve(86-11-13,MCR7391), audit(86-11-13,Zwick),
  3    10*     install(86-11-20,MR12.0-1222):
  3    11*     Added a declaration of FAULT_TAG_1, FAULT_TAG_2 and FAULT_TAG_3.
  3    12*                                                   END HISTORY COMMENTS */
  3    13 
  3    14 
  3    15 /* format: style3 */
  3    16 /* everything you ever wanted in a linkage section */
  3    17 
  3    18 /*
  3    19* Last Modified (Date and Reason):
  3    20*  15 Nov 1971 by C Garman 
  3    21*   6/75 by M.Weaver to add virgin_linkage_header declaration
  3    22*   6/75 by S.Webber to comment existing structures better
  3    23*   9/77 by M. Weaver to add run_depth to link
  3    24*   7/81 by B. Margulies for firstref structure, unsigned fixed bins.
  3    25*   3/83 by M. Weaver to add flags overlaying def_ptr
  3    26**/
  3    27 
  3    28 declare	1 object_link	based aligned,		/* link pair in linkage section */
  3    29 	  2 header_relp	fixed bin (17) unal,	/* rel pointer to beginning of linkage, always negative */
  3    30 	  2 ringno	fixed bin (3) unsigned unal,	/* MBZ */
  3    31 	  2 mbz		bit (6) unal,
  3    32 	  2 run_depth	fixed bin (2) unal,		/* run unit depth, filled when link is snapped */
  3    33 	  2 tag		bit (6) unal,		/* fault tag. 46(8) if not snapped, 43(8) if snapped */
  3    34 	  2 expression_relp fixed bin (18) unsigned unal, /* pointer (rel to defs) of expression word */
  3    35 	  2 mbz2		bit (12) unal,
  3    36 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  3    37 
  3    38 declare	1 partial_link	based aligned,		/* partially snapped link */
  3    39 	  2 type		fixed bin (3) unsigned unal,	/* target section of link */
  3    40 	  2 component	fixed bin (15) unsigned unal,	/* target component index */
  3    41 	  2 mbz1		bit (12) unal,
  3    42 	  2 tag		bit (6) unal,		/* fault tag 3 47(8), ITS 43(8) if snapped */
  3    43 	  
  3    44 	  2 offset	fixed bin (18) unsigned unal,	/* word offset of link */
  3    45 	  2 mbz2		bit (3) unal,
  3    46 	  2 bit_offset	fixed bin (6) unsigned unal,	/* bit offset (in practice, always 0) */
  3    47 	  2 mbz3		bit (3) unal,
  3    48 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  3    49 
  3    50 declare	1 linkage_header	based aligned,		/* linkage block header */
  3    51 	  2 def_ptr	ptr,			/* pointer to definition section */
  3    52 	  2 symbol_ptr	ptr unal,			/* pointer to symbol section in object segment */
  3    53 	  2 original_linkage_ptr
  3    54 			ptr unal,			/* pointer to linkage section in object segment */
  3    55 	  2 unused	bit (72),
  3    56 	  2 stats,
  3    57 	    3 begin_links	fixed bin (18) unsigned unal, /* offset (rel to this section) of first link */
  3    58 	    3 block_length	fixed bin (18) unsigned unal, /* number of words in this linkage section */
  3    59 	    3 segment_number
  3    60 			fixed bin (18) unsigned unal, /* text segment number associated with this section */
  3    61 	    3 static_length fixed bin (18) unsigned unal; /* number of words of static for this segment */
  3    62 
  3    63 declare	1 linkage_header_flags
  3    64 			aligned based,		/* overlay of def_ptr for flags */
  3    65 	  2 pad1		bit (28) unaligned,		/* flags are in first word */
  3    66 	  2 static_vlas	bit (1) unaligned,		/* static section "owns" some LA/VLA segments */
  3    67 	  2 perprocess_static
  3    68 			bit (1) unaligned,		/* 1 copy of static section is shared among all tasks/run units */
  3    69 	  2 pad2		bit (6) unaligned;
  3    70 
  3    71 declare	1 virgin_linkage_header
  3    72 			aligned based,		/* template for linkage header in object segment */
  3    73 	  2 pad		bit (30) unaligned,		/* is filled in by linker */
  3    74 	  2 defs_in_link	bit (6) unaligned,		/* =o20 if defs in linkage (nonstandard) */
  3    75 	  2 def_offset	fixed bin (18) unsigned unaligned,
  3    76 						/* offset of definition section */
  3    77 	  2 first_ref_relp	fixed bin (18) unsigned unaligned,
  3    78 						/* offset of trap-at-first-reference offset array */
  3    79 	  2 filled_in_later bit (144),
  3    80 	  2 link_begin	fixed bin (18) unsigned unaligned,
  3    81 						/* offset of first link */
  3    82 	  2 linkage_section_lng
  3    83 			fixed bin (18) unsigned unaligned,
  3    84 						/* length of linkage section */
  3    85 	  2 segno_pad	fixed bin (18) unsigned unaligned,
  3    86 						/* will be segment number of copied linkage */
  3    87 	  2 static_length	fixed bin (18) unsigned unaligned;
  3    88 						/* length of static section */
  3    89 
  3    90 declare	1 fr_traps	based aligned,		/* First Reference Trap Procedures */
  3    91 	  2 decl_vers	fixed bin,		/* version of this struc, value=1, ABS reloc */
  3    92 	  2 n_traps	fixed bin,		/* number of traps on this segment, ABS */
  3    93 	  2 trap_array	(n_fr_traps refer (fr_traps.n_traps)) aligned,
  3    94 	    3 call_relp	fixed bin (18) unsigned unaligned,
  3    95 						/* LINK18, offset of link defining procedure to call */
  3    96 	    3 info_relp	fixed bin (18) unsigned unaligned;
  3    97 						/* LINK18, offser of link defining argument list for trap proc */
  3    98 
  3    99 declare	FR_TRAPS_VERSION_1	init (1) fixed bin internal static options (constant);
  3   100 declare   FAULT_TAG_1	bit(6) unaligned init ("40"b3) static options (constant);
  3   101 declare   FAULT_TAG_2	bit(6) unaligned init ("46"b3) static options (constant);
  3   102 declare   FAULT_TAG_3	bit(6) unaligned init ("47"b3) static options (constant);
  3   103 
  3   104 /* END INCLUDE FILE object_link_dcls.incl.pl1 */
     1030 
  4     1 /*  START OF:	ocu_dcls.incl.pl1			 *  *  *  *  *  */
  4     2 
  4     3 /****^  HISTORY COMMENTS:
  4     4*  1) change(86-08-12,Elhard), approve(86-08-12,MCR7505),
  4     5*     audit(86-12-10,DGHowe), install(86-12-10,MR12.0-1241):
  4     6*     Originally written to define the subroutines and data structures used by
  4     7*     callers of ocu_.
  4     8*                                                   END HISTORY COMMENTS */
  4     9 
  4    10   /*** ****************************************************************/
  4    11   /***							*/
  4    12   /***	Name:	ocu_dcls					*/
  4    13   /***	Function: These are the entrypoints and structures required	*/
  4    14   /***		to use the ocu_ object creation utilities.	*/
  4    15   /***							*/
  4    16   /*** ****************************************************************/
  4    17   
  4    18   /* open option flags */
  4    19   
  4    20   dcl OPEN_FLAGS_BOUND	bit (6) static options (constant)
  4    21 			init ("100000"b);
  4    22   dcl OPEN_FLAGS_RELOCATABLE	bit (6) static options (constant)
  4    23 			init ("010000"b);
  4    24   dcl OPEN_FLAGS_PROCEDURE	bit (6) static options (constant)
  4    25 			init ("001000"b);
  4    26   dcl OPEN_FLAGS_SEPARATE_STATIC
  4    27 			bit (6) static options (constant)
  4    28 			init ("000100"b);
  4    29   dcl OPEN_FLAGS_PERPROCESS_STATIC
  4    30 			bit (6) static options (constant)
  4    31 			init ("000010"b);
  4    32   dcl OPEN_FLAGS_NO_HASHTABLE bit (6) static options (constant)
  4    33 			init ("000001"b);
  4    34 			
  4    35   /* definition flags */
  4    36   
  4    37   dcl DEFINITION_FLAGS_IGNORE bit (4) static options (constant) init ("1000"b);
  4    38   dcl DEFINITION_FLAGS_ENTRY	bit (4) static options (constant) init ("0100"b);
  4    39   dcl DEFINITION_FLAGS_RETAIN bit (4) static options (constant) init ("0010"b);
  4    40   dcl DEFINITION_FLAGS_INDIRECT
  4    41 			bit (4) static options (constant) init ("0001"b);
  4    42   
  4    43   /* input structures */
  4    44   
  4    45   dcl word_arrayp		ptr;
  4    46   dcl word_arrayl		fixed bin (18) unsigned;
  4    47   
  4    48   dcl word_array(word_arrayl) bit (36) based (word_arrayp);
  4    49   
  4    50   dcl reloc_strp		ptr;
  4    51   dcl reloc_strl		fixed bin (21);
  4    52   
  4    53   dcl reloc_str		char (reloc_strl) based (reloc_strp);
  4    54   
  4    55   dcl component_listp	ptr;
  4    56   dcl component_count	fixed bin (15) unsigned;
  4    57   
  4    58   dcl component_list (1:component_count)
  4    59 			ptr based (component_listp);
  4    60   
  4    61   dcl 01 gen_info		aligned based,
  4    62        02 gen_created	fixed bin (71),
  4    63        02 generator		char (8),
  4    64        02 gen_number	fixed bin,
  4    65        02 gen_version	char (512) varying;
  4    66   
  4    67   /* entrypoint declarations */
  4    68   
  4    69   dcl ocu_$open		/* setup to create an object		*/
  4    70 	entry (char(*),		/* directory name	    (in )	*/
  4    71 	       char(*),		/* entry name	    (in )	*/
  4    72 	       bit(*),		/* option flags	    (in ) */
  4    73 	       ptr,		/* ocu_data pointer	    (out) */
  4    74 	       fixed bin(35));	/* error code	    (out) */
  4    75   
  4    76   dcl ocu_$close		/* create the object segment		*/
  4    77 	entry (ptr,		/* ocu_data pointer     (in )	*/
  4    78 	       fixed bin(35));	/* error code	    (out) */
  4    79   
  4    80   dcl ocu_$release		/* release storage on cleanup		*/
  4    81 	entry (ptr);		/* ocu_data pointer	    (in )	*/
  4    82   
  4    83   dcl ocu_$emit_text	/* emit a block of text words		*/
  4    84 	entry (ptr,		/* ocu_data pointer	    (in )	*/
  4    85 	       ptr,		/* word array pointer   (in ) */
  4    86 	       ptr,		/* reloc string pointer (in ) */
  4    87 	       fixed bin (18) uns)	/* word count	    (in ) */
  4    88 	returns(fixed bin (18) uns);	/* text relp	    (out) */
  4    89   
  4    90   dcl ocu_$emit_definition	/* emit a single definition entry	*/
  4    91 	entry (ptr,		/* ocu_data pointer	    (in )	*/
  4    92 	       char(*) var,		/* definition name	    (in ) */
  4    93 	       fixed bin (3),	/* target section	    (in ) */
  4    94 	       fixed bin (18) uns,	/* offset in section    (in ) */
  4    95 	       bit(*))		/* definition flags	    (in ) */
  4    96 	returns(fixed bin (18) uns);	/* definition relp	    (out) */
  4    97   
  4    98   dcl ocu_$emit_segname	/* emit a single segname definition	*/
  4    99 	entry (ptr,		/* ocu_data pointer	    (in )	*/
  4   100 	       char(*) var,		/* segname	    (in ) */
  4   101 	       bit(*))		/* definition flags	    (in ) */
  4   102 	returns(fixed bin (18) uns);	/* definition relp	    (out) */
  4   103   
  4   104   dcl ocu_$emit_msf_map	/* emit an msf map (MSF components)	*/
  4   105 	entry (ptr,		/* ocu_data pointer	    (in )	*/
  4   106 	       fixed bin (15) uns,	/* component count	    (in ) */
  4   107 	       fixed bin (15) uns);	/* my component	    (in ) */
  4   108   
  4   109   dcl ocu_$emit_static	/* emit a block of static words	*/
  4   110 	entry (ptr,		/* ocu_data pointer	    (in )	*/
  4   111 	       ptr,		/* word array pointer   (in ) */
  4   112 	       fixed bin (18) uns)	/* word count	    (in ) */
  4   113 	returns(fixed bin (18) uns);	/* static relp	    (out) */
  4   114   
  4   115   dcl ocu_$emit_link	/* emit a single external link	*/
  4   116 	entry (ptr,		/* ocu_data pointer	    (in )	*/
  4   117 	       fixed bin (3),	/* link type	    (in ) */
  4   118 	       fixed bin (3),	/* link class	    (in ) */
  4   119 	       char(*) var,		/* target refname	    (in ) */
  4   120 	       char(*) var,		/* target definition    (in ) */
  4   121 	       fixed bin,		/* expression offset    (in ) */
  4   122 	       bit(6),		/* link modifier	    (in ) */
  4   123 	       ptr)		/* init info pointer    (in ) */
  4   124 	returns(fixed bin (18) uns);	/* link relp	    (out) */
  4   125   
  4   126   dcl ocu_$emit_partial_link	/* emit a single partial link		*/
  4   127 	entry (ptr,		/* ocu_data pointer	    (in ) */
  4   128 	       fixed bin (15) uns,	/* target component	    (in ) */
  4   129 	       fixed bin (3),	/* target section	    (in ) */
  4   130 	       fixed bin (18) uns,	/* offset in section    (in ) */
  4   131 	       bit(6))		/* link modifier	    (in ) */
  4   132 	returns(fixed bin (18) uns);	/* link relp	    (out) */
  4   133   
  4   134   dcl ocu_$emit_firstref_trap	/* add a trap to the firstref block	*/
  4   135 	entry (ptr,		/* ocu_data pointer	    (in ) */
  4   136 	       fixed bin (18) uns,	/* call relp	    (in ) */
  4   137 	       fixed bin (18) uns);	/* info relp	    (in ) */
  4   138   
  4   139   dcl ocu_$emit_symbol	/* emit a block of symbol words	*/
  4   140 	entry (ptr,		/* ocu_data pointer	    (in ) */
  4   141 	       ptr,		/* word array pointer   (in ) */
  4   142 	       ptr,		/* reloc string pointer (in ) */
  4   143 	       fixed bin (18) uns)	/* word count	    (in ) */
  4   144 	returns(fixed bin (18) uns);	/* symbol relp	    (out) */
  4   145   
  4   146   dcl ocu_$backpatch	/* patch a word in the text/symbol scn	*/
  4   147 	entry (ptr,		/* ocu_data pointer	    (in ) */
  4   148 	       char(*),		/* section	    (in ) */
  4   149 	       fixed bin (18) uns,	/* offset in section    (in ) */
  4   150 	       char(*),		/* side and size	    (in ) */
  4   151 	       fixed bin (35));	/* new value to patch   (in ) */
  4   152   
  4   153   dcl ocu_$create_msf	/* create component 0 of the MSF	*/
  4   154 	entry (ptr,		/* component array ptr  (in ) */
  4   155 	       fixed bin (15) uns,	/* component count	    (in ) */
  4   156 	       ptr,		/* generator info ptr   (in ) */
  4   157 	       fixed bin(35));	/* error code	    (out) */
  4   158   
  4   159 /*  END OF:	ocu_dcls.incl.pl1			 *  *  *  *  *  */
     1031 
     1032 
     1033   end le_snap_;
     1034 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/10/86  1251.6  le_snap_.pl1                      >special_ldd>install>MR12.0-1241>le_snap_.pl1
1028         1    12/10/86  1248.4  le_data.incl.pl1                  >special_ldd>install>MR12.0-1241>le_data.incl.pl1
1029         2    11/24/86  1226.9  definition_dcls.incl.pl1          >ldd>include>definition_dcls.incl.pl1
1030         3    11/24/86  1226.9  object_link_dcls.incl.pl1         >ldd>include>object_link_dcls.incl.pl1
1031         4    12/10/86  1248.0  ocu_dcls.incl.pl1                 >special_ldd>install>MR12.0-1241>ocu_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CLASS_STATIC                           constant        fixed bin(3,0)           initial unsigned dcl 2-25 ref 342
CLASS_SYMBOL                           constant        fixed bin(3,0)           initial unsigned dcl 2-25 ref 321
INIT_COPY_INFO                         constant        fixed bin(17,0)          initial dcl 2-194 ref 663 741
INIT_DEFERRED                          constant        fixed bin(17,0)          initial dcl 2-194 ref 623
INIT_DEFINE_AREA                       constant        fixed bin(17,0)          initial dcl 2-194 ref 652
INIT_LIST_TEMPLATE                     constant        fixed bin(17,0)          initial dcl 2-194 ref 685 758 781 905
INIT_NO_INIT                           constant        fixed bin(17,0)          initial dcl 2-194 ref 652
Indirection_modifier            005574 constant        bit(6)                   initial unaligned dcl 47 ref 195 279 303 311 331 355
                                                                                  386 400 432 515 548 583 632 661 712 751 873 1013
LE_ABORT_ERROR                  000062 constant        fixed bin(17,0)          initial dcl 1-22 set ref 460* 597*
LE_FATAL_ERROR                  000064 constant        fixed bin(17,0)          initial dcl 1-21 set ref 180* 201* 364*
Linkage                         000067 constant        fixed bin(3,0)           initial dcl 1-28 set ref 193 223 235 251 276* 278
                                                                                  284 298* 300 301* 311* 315* 328 350 385 399 431
                                                                                  448 482* 493* 505* 514 544 557 583* 588* 625* 629
                                                                                  660 711 750 834* 837 872 972* 975 1012
None                                   constant        fixed bin(17,0)          initial dcl 48 ref 191 375 421 639 837 975
Patch_Init                      000066 constant        fixed bin(17,0)          initial dcl 1-59 set ref 636*
Patch_Link                      000067 constant        fixed bin(17,0)          initial dcl 1-58 set ref 507*
Patch_Self_Init                 000062 constant        fixed bin(17,0)          initial dcl 1-61 set ref 866* 1006*
Refname_Base                    000064 constant        fixed bin(3,0)           initial dcl 1-49 set ref 383*
Refname_Offsetname              000062 constant        fixed bin(3,0)           initial dcl 1-51 set ref 429*
Self_Base                       000067 constant        fixed bin(3,0)           initial dcl 1-47 set ref 224* 252* 276* 301* 329*
                                                                                  351* 545* 837* 975*
Self_Offsetname                 000060 constant        fixed bin(3,0)           initial dcl 1-53 set ref 630* 657* 708* 747* 858*
                                                                                  996*
Static                          000062 constant        fixed bin(3,0)           initial dcl 1-34 set ref 252* 259 351* 359 458 536
                                                                                  545* 552 573
Symbol                          000066 constant        fixed bin(3,0)           initial dcl 1-30 set ref 329* 337 456 529 531
Text                            000055 constant        fixed bin(3,0)           initial dcl 1-26 set ref 214 224* 231 396* 409 454
                                                                                  522 524
addr                                                   builtin function         dcl 157 ref 187 438 620 630 630 656 657 657 690 800
                                                                                  813 910 951
addwordno                                              builtin function         dcl 158 ref 697 703 789 795 850 946 986
auto_def                        000100 automatic       structure                level 1 dcl 130 set ref 630 630
auto_init                       000104 automatic       structure                level 1 dcl 131 set ref 656 657 657
class                     1(06)        based           fixed bin(6,0)           level 2 packed unsigned unaligned dcl 101 set ref
                                                                                  214 235 321 342 364* 630 657 708 747 858 996
cleanup                         000570 stack reference condition                dcl 153 ref 675 716 725 755 767 879 894 1018
comp                      2            based           structure                array level 2 in structure "lec" dcl 92 in procedure
                                                                                  "le_snap_"
comp                                   parameter       fixed bin(17,0)          dcl 54 in procedure "le_snap_" set ref 16 172 180
                                                                                  224 232 241 241 252 260 298* 311* 315* 338 351 360
                                                                                  390 440 507 636 866 1006
copied                          000106 automatic       bit(1)                   unaligned dcl 132 set ref 890* 896 925 935* 993 1015
count                                  based           fixed bin(9,0)           level 2 in structure "segname" packed unsigned
                                                                                  unaligned dcl 122 in procedure "le_snap_" ref 383
                                                                                  429
count                                  based           fixed bin(9,0)           level 2 in structure "offsetname" packed unsigned
                                                                                  unaligned dcl 118 in procedure "le_snap_" ref 429
                                                                                  630 657 708 747 858 996
currentsize                                            builtin function         dcl 159 ref 683 697 789 850 986
datum                     2            based           bit                      level 2 dcl 102 set ref 693* 813 951
def                       2            based           structure                array level 2 dcl 95 set ref 438
definition_flags                       based           structure                level 1 packed unaligned dcl 2-42
defn                                   based           structure                level 1 dcl 81
defnl                   136(18)        based           fixed bin(18,0)          array level 4 packed unsigned unaligned dcl 92 ref
                                                                                  566
defnp                           000110 automatic       pointer                  dcl 133 set ref 438* 448 454 456 458 460 460 464 465
                                                                                  476 482 487 493 522 525 529 532 536 545 553 557
                                                                                  566 571 583 588 597 597
defx                      2(18)        based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 101 ref 438
                                                                                  507
error_table_$bad_class_def      000016 external static fixed bin(35,0)          dcl 73 set ref 460* 597*
exp                       1(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 101 ref 224 232 241 241
                                                                                  252 260 267 276 283 298 311 315 329 338 351 360
                                                                                  383 408 429 464 482 493 505 525 532 545 553 571
                                                                                  583 588 630 657 708 747 858 996
extension                 4(18)        based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 101 ref 639
                                                                                  655 668 686 698 733 782 790
false                           000055 constant        bit(1)                   initial unaligned dcl 45 set ref 170 311* 315* 583*
                                                                                  802 834* 852 868 890 912 972* 988 1008
flags                   106            based           structure                array level 3 in structure "lec" dcl 92 in procedure
                                                                                  "le_snap_"
flags                                  based           structure                level 3 in structure "lec" dcl 92 in procedure
                                                                                  "le_snap_"
get_system_free_area_           000010 constant        entry                    external dcl 66 ref 665 760 892
hdr_size                        000112 automatic       fixed bin(17,0)          dcl 134 set ref 237* 241 241 260 267 475* 476 487
                                                                                  564* 566 571
header                                 based           structure                level 2 in structure "le_components" dcl 1-72
                                                                                  in procedure "le_snap_"
header                                 based           structure                level 2 in structure "lel" dcl 98 in procedure
                                                                                  "le_snap_"
header                                 based           structure                level 2 in structure "link_init_list_template"
                                                                                  dcl 2-219 in procedure "le_snap_"
header                                 based           structure                level 2 in structure "lec" dcl 92 in procedure
                                                                                  "le_snap_"
header                                 based           structure                level 2 in structure "link_init_copy_info" dcl 2-211
                                                                                  in procedure "le_snap_"
header                                 based           structure                level 2 in structure "le_links" dcl 1-225
                                                                                  in procedure "le_snap_"
header                          000100 automatic       structure                level 2 in structure "auto_def" dcl 130 in procedure
                                                                                  "le_snap_"
header                                 based           structure                level 2 in structure "new_copy" dcl 108 in procedure
                                                                                  "le_snap_"
header                                 based           structure                level 2 in structure "init_list" dcl 87 in procedure
                                                                                  "le_snap_"
header                                 based           structure                level 2 in structure "init_copy" dcl 83 in procedure
                                                                                  "le_snap_"
header                                 based           structure                level 2 in structure "le_definitions" dcl 1-167
                                                                                  in procedure "le_snap_"
header                                 based           structure                level 2 in structure "new_list" dcl 112 in procedure
                                                                                  "le_snap_"
i                               000113 automatic       fixed bin(17,0)          dcl 135 set ref 865* 866* 868 1005* 1006* 1008
index                                                  builtin function         dcl 160 ref 865 1005
init                                   based           structure                level 1 dcl 82
init_copy                              based           structure                level 1 dcl 83 set ref 683
init_list                              based           structure                level 1 dcl 87 set ref 789 939
init_type                 1(03)        based           fixed bin(3,0)           level 2 packed unsigned unaligned dcl 102 ref 808
                                                                                  920
initial_data              2            based           bit(36)                  array level 2 in structure "init_copy" dcl 83
                                                                                  in procedure "le_snap_" ref 693 742
initial_data              2            based           bit(36)                  array level 2 in structure "new_copy" dcl 108
                                                                                  in procedure "le_snap_" set ref 742*
initp                     5            based           pointer                  level 2 in structure "tl" packed unaligned dcl 126
                                                                                  in procedure "le_snap_" ref 624
initp                           000114 automatic       pointer                  dcl 136 in procedure "le_snap_" set ref 650* 652 652
                                                                                  654 655 656* 663 683 686 691 693 733 742 758 775
                                                                                  782 783 789 889* 905 910 930 939 946 993
initp                     5            based           pointer                  level 2 in structure "lk" packed unaligned dcl 101
                                                                                  in procedure "le_snap_" ref 608 650 889
internal                               parameter       bit(1)                   unaligned dcl 62 set ref 16 170* 233* 261* 286* 298*
                                                                                  311* 315* 319* 340* 362* 411* 527* 534* 555* 575*
                                                                                  583* 588* 594* 834* 972*
le_backpatch_                   000012 constant        entry                    external dcl 67 ref 507 636 866 1006
le_comp                                based           structure                level 1 dcl 1-89
le_components                          based           structure                level 1 dcl 1-72
le_definition                          based           structure                level 1 dcl 1-175
le_definitions                         based           structure                level 1 dcl 1-167
le_error_                       000014 constant        entry                    external dcl 69 ref 180 201 364 460 597
le_et_$bad_link_class           000020 external static fixed bin(35,0)          dcl 75 set ref 364*
le_et_$bad_link_ref             000022 external static fixed bin(35,0)          dcl 76 set ref 180*
le_et_$bad_link_type            000024 external static fixed bin(35,0)          dcl 77 set ref 201*
le_link                                based           structure                level 1 dcl 1-233
le_links                               based           structure                level 1 dcl 1-225
le_patch                               based           structure                level 1 dcl 1-298
lec                                    based           structure                level 1 dcl 92
lecp                                   parameter       pointer                  dcl 53 set ref 16 172 180 224 232 241 241 252 260
                                                                                  298* 311* 315* 338 345 351 360 375 390 390 396 408
                                                                                  438 440 440 454 456 458 460 465 482 487 493 493
                                                                                  505 507 525 532 539 545 553 566 571 583* 588* 597
                                                                                  620 625 636 817 823 834* 866 955 961 972* 1006
led                                    based           structure                level 1 dcl 95
ledp                    112            based           pointer                  array level 4 dcl 92 ref 438
lel                                    based           structure                level 1 dcl 98
lelp                            000116 automatic       pointer                  dcl 137 in procedure "le_snap_" set ref 172* 176 178
                                                                                  187
lelp                    114            based           pointer                  array level 4 in structure "lec" dcl 92 in procedure
                                                                                  "le_snap_" ref 172 620
link                      2            based           structure                array level 2 dcl 98 set ref 187 620
link_init                              based           structure                level 1 dcl 2-205
link_init_copy_info                    based           structure                level 1 dcl 2-211
link_init_deferred                     based           structure                level 1 dcl 2-270
link_init_list_template                based           structure                level 1 dcl 2-219
link_relp                 2(18) 000100 automatic       fixed bin(18,0)          level 2 packed unsigned unaligned dcl 130 set ref
                                                                                  627*
linkx                           000120 automatic       fixed bin(17,0)          dcl 138 set ref 176* 178 178 187
list_size                       000121 automatic       fixed bin(18,0)          unsigned dcl 139 set ref 683* 684 684 775* 777 777
                                                                                  930* 931 931
lk                                     based           structure                level 1 dcl 101
lkp                             000122 automatic       pointer                  dcl 140 set ref 187* 191 194 199 199 199 201 207 214
                                                                                  224 224 232 235 241 241 252 252 260 267 276 276
                                                                                  283 285 298 301 311 311 315 317 321 329 329 338
                                                                                  339 342 351 351 353 360 361 364 375 383 383 383
                                                                                  387 390 396 396 398 408 408 410 421 429 429 429
                                                                                  429 433 438 438 440 454 456 458 460 464 465 465
                                                                                  467 482 482 482 485 487 493 493 493 493 497 505
                                                                                  505 505 507 507 509 525 525 526 532 532 533 545
                                                                                  545 545 553 553 554 566 571 571 574 583 583 583
                                                                                  588 588 591 597 608 620 620 625 630 630 630 630
                                                                                  634 636 636 639 650 655 657 657 657 657 659 668
                                                                                  686 698 708 708 708 708 710 733 747 747 747 747
                                                                                  749 782 790 817 823 834 858 858 858 858 871 889
                                                                                  955 961 972 996 996 996 996 1011
lte                                    based           structure                level 1 dcl 102 set ref 697 850 986
ltep                            000124 automatic       pointer                  dcl 141 set ref 690* 691 692 693 697* 697 697 698
                                                                                  699 703* 703 704 789* 790 791 795* 795 796 800*
                                                                                  804 808 813 850* 850 850 910* 916 920 946* 946 951
                                                                                  986* 986 986
mod                       1(12)        based           bit(6)                   level 2 packed unaligned dcl 101 set ref 224* 252*
                                                                                  276* 285 301* 311 317 329* 339 351* 361 383* 396*
                                                                                  410 429* 465* 482* 493* 505* 526 533 545* 554 574
                                                                                  583 591 630* 657* 708* 747* 858* 996*
modifier                               parameter       bit(6)                   unaligned dcl 61 set ref 16 169* 195* 279* 285* 298*
                                                                                  303* 311* 315* 317* 331* 339* 355* 361* 386* 400*
                                                                                  410* 432* 515* 526* 533* 548* 554* 574* 583* 588*
                                                                                  591* 632* 661* 712* 751* 834* 837* 873* 972* 975*
                                                                                  1013*
n_bits                                 based           fixed bin(35,0)          level 2 dcl 102 set ref 691* 693 697 698* 704* 790*
                                                                                  796* 804 813 850 916 951 986
n_links                   1            based           fixed bin(17,0)          level 3 dcl 98 ref 178
n_words                         000100 automatic       fixed bin(35,0)          level 3 in structure "auto_def" dcl 130 in procedure
                                                                                  "le_snap_" set ref 624*
n_words                                based           fixed bin(35,0)          level 3 in structure "init_list" dcl 87 in procedure
                                                                                  "le_snap_" ref 782
n_words                                based           fixed bin(35,0)          level 3 in structure "new_list" dcl 112 in procedure
                                                                                  "le_snap_" set ref 686* 782*
n_words                                based           fixed bin(35,0)          level 3 in structure "init_copy" dcl 83 in procedure
                                                                                  "le_snap_" set ref 683 691 693 727 733 737* 742
                                                                                  742 753
n_words                         000130 automatic       fixed bin(35,0)          dcl 143 in procedure "le_snap_" set ref 733* 737 737
n_words                                based           fixed bin(35,0)          level 2 in structure "init" dcl 82 in procedure
                                                                                  "le_snap_" ref 624 655 686
n_words                         000104 automatic       fixed bin(35,0)          level 2 in structure "auto_init" dcl 131
                                                                                  in procedure "le_snap_" set ref 655*
n_words_in_list           2(18)        based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 87 set ref 677
                                                                                  684* 714 769 775 777* 783 783 789 877 896 930 931*
                                                                                  939 939 1015
name                     10            based           varying char(32)         array level 3 dcl 92 set ref 180* 460* 597*
new                     143            based           structure                array level 3 dcl 92
new_copy                               based           structure                level 1 dcl 108 set ref 727 737 753
new_initp                       000126 automatic       pointer                  dcl 142 set ref 666* 677 677 684* 685 686 690 708*
                                                                                  714 723* 727 727 737* 741 742 747* 753 762* 769
                                                                                  769 777* 781 782 783 789 800 858* 877 891* 896
                                                                                  931* 939 946 993* 996 1015
new_list                               based           structure                level 1 dcl 112 set ref 677 684 714 769 777 877 896
                                                                                  931 939* 1015
no_prelink                             parameter       bit(1)                   unaligned dcl 58 set ref 16 191 221 249 274 292 298*
                                                                                  326 345 353 375 387 421 433
null                                                   builtin function         dcl 161 ref 224 224 252 252 276 276 301 301 329 329
                                                                                  351 351 383 383 429 429 545 545 608 666 677 723
                                                                                  727 762 769 837 837 891 975 975
ocu_$emit_link                  000026 constant        entry                    external dcl 4-115 ref 224 252 276 301 329 351 383
                                                                                  429 545 630 657 708 747 837 858 975 996
ocu_$emit_partial_link          000030 constant        entry                    external dcl 4-126 ref 396 465 482 493 505 625
ocudp                                  parameter       pointer                  dcl 52 set ref 16 224* 252* 276* 298* 301* 311* 315*
                                                                                  329* 351* 383* 396* 429* 465* 482* 493* 505* 545*
                                                                                  583* 588* 625* 630* 657* 708* 747* 834* 837* 858*
                                                                                  972* 975* 996*
offset                  102            based           fixed bin(18,0)          level 2 in structure "defn" packed unsigned
                                                                                  unaligned dcl 81 in procedure "le_snap_" set ref
                                                                                  460* 597*
offset                          000131 automatic       fixed bin(18,0)          unsigned dcl 144 in procedure "le_snap_" set ref
                                                                                  454* 456* 458* 464* 464 465*
offset_adjustment                      based           fixed bin(18,0)          level 3 dcl 98 ref 176
offsetname                             based           structure                level 1 dcl 118
offsetp                   7            based           pointer                  level 2 packed unaligned dcl 101 ref 429 630 657 708
                                                                                  747 858 996
orig                    116            based           structure                array level 3 dcl 92
patch_mask                      000132 automatic       bit(10000)               unaligned dcl 145 set ref 802* 831* 852* 864 865
                                                                                  868* 912* 969* 988* 1002 1005 1008*
pit                                    based           structure                level 1 dcl 121
pitp                            000560 automatic       pointer                  dcl 146 set ref 813* 817 817 817 823 823 823 831 834
                                                                                  837 843 951* 955 955 955 961 961 961 969 972 975
                                                                                  981
pointer_init_template                  based           structure                level 1 packed unaligned dcl 2-253
ptr_type                               based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 121 ref 817
                                                                                  823 955 961
ref_offset                             parameter       fixed bin(18,0)          unsigned dcl 56 set ref 16 180*
ref_relp                               parameter       fixed bin(18,0)          unsigned dcl 57 set ref 16 176 180* 201* 298* 311*
                                                                                  315* 364* 583* 588* 831 834* 969 972*
ref_section                            parameter       fixed bin(3,0)           dcl 55 ref 16 180
rel_stat                144            based           fixed bin(18,0)          array level 4 packed unsigned unaligned dcl 92 ref
                                                                                  252 260 351 360 458 493 545 553 571 823 961
rel_symb                143(18)        based           fixed bin(18,0)          array level 4 packed unsigned unaligned dcl 92 ref
                                                                                  338 456 532
rel_text                143            based           fixed bin(18,0)          array level 4 packed unsigned unaligned dcl 92 ref
                                                                                  224 232 408 454 525 817 955
relp                    101(18)        based           fixed bin(18,0)          level 2 in structure "defn" packed unsigned
                                                                                  unaligned dcl 81 in procedure "le_snap_" ref 464
                                                                                  476 482 487 493 525 532 545 553 566 571 583 588
relp                                   parameter       fixed bin(18,0)          unsigned dcl 60 in procedure "le_snap_" set ref 16
                                                                                  168* 194* 224* 232* 252* 260* 276* 283* 298* 301*
                                                                                  301 311* 315* 329* 338* 351* 353 360* 383* 387
                                                                                  396* 398 408* 429* 433 465* 467 482* 485 493* 497
                                                                                  505* 507* 509 525* 532* 545* 553* 571* 583* 588*
                                                                                  630* 634 636* 657* 659 708* 710 747* 749 834* 837
                                                                                  843 858* 866* 871 972* 975 981 996* 1006* 1011
relp                      3            based           fixed bin(18,0)          level 2 in structure "lk" packed unsigned unaligned
                                                                                  dcl 101 in procedure "le_snap_" set ref 191 194
                                                                                  353* 387* 398* 433* 467* 485* 497* 509* 634* 659*
                                                                                  710* 749* 871* 1011*
repeat                    1(06)        based           fixed bin(30,0)          level 2 packed unsigned unaligned dcl 102 set ref
                                                                                  692* 699* 791*
section                                parameter       fixed bin(3,0)           dcl 59 set ref 16 167* 193* 223* 231* 251* 259* 278*
                                                                                  284* 298* 300* 311* 315* 328* 337* 350* 359* 385*
                                                                                  399* 409* 431* 514* 524* 531* 544* 552* 573* 583*
                                                                                  588* 629* 660* 711* 750* 834* 837 837 837* 872*
                                                                                  972* 975 975 975* 1012*
section_nm                      000005 constant        char(16)                 initial array unaligned dcl 1-41 set ref 180*
section_offset            0(18)        based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 121 set ref
                                                                                  831 834 837* 843* 969 972 975* 981*
segname                                based           structure                level 1 dcl 122
segnamep                  6            based           pointer                  level 2 packed unaligned dcl 101 ref 383 429
separate_static         106(03)        based           bit(1)                   array level 4 in structure "lec" packed unaligned
                                                                                  dcl 92 in procedure "le_snap_" ref 241
separate_static                        based           bit(1)                   level 4 in structure "lec" packed unaligned dcl 92
                                                                                  in procedure "le_snap_" ref 345 539
size                                                   builtin function         dcl 162 ref 237 475 564
statl                   137(18)        based           fixed bin(18,0)          array level 4 packed unsigned unaligned dcl 92 ref
                                                                                  241 487
string                    0(09)        based           char                     level 2 in structure "offsetname" packed unaligned
                                                                                  dcl 118 in procedure "le_snap_" ref 429 630 657
                                                                                  708 747 858 996
string                    0(09)        based           char                     level 2 in structure "segname" packed unaligned
                                                                                  dcl 122 in procedure "le_snap_" ref 383 429
substr                                                 builtin function         dcl 163 set ref 802* 831* 852* 864 868* 912* 969*
                                                                                  988* 1002 1008*
sys_area                               based           area(1024)               dcl 125 ref 677 684 714 727 737 753 769 777 877 896
                                                                                  931 1015
sys_areap                       000562 automatic       pointer                  dcl 147 set ref 665* 677 684 714 727 737 753 760*
                                                                                  769 777 877 892* 896 931 1015
tables                  110            based           structure                array level 3 dcl 92
target                  105            based           fixed bin(17,0)          array level 3 in structure "lec" dcl 92 in procedure
                                                                                  "le_snap_" set ref 375 390 390 396 440 440 465 482
                                                                                  493 505 507* 625 636* 866* 1006*
target                    2            based           fixed bin(18,0)          level 2 in structure "lk" packed unsigned unaligned
                                                                                  dcl 101 in procedure "le_snap_" ref 375 390 396
                                                                                  408 421 438 440 454 456 458 460 465 482 487 493
                                                                                  493 505 507 525 532 545 553 566 571 583 588 597
target_comp               3(18)        based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 101 ref 620
                                                                                  625 636 817 823 834 955 961 972
target_link               4            based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 101 ref 620
                                                                                  636
target_relp               2     000100 automatic       fixed bin(18,0)          level 2 packed unsigned unaligned dcl 130 set ref
                                                                                  625*
template                  3            based           fixed bin(17,0)          array level 2 in structure "init_list" dcl 87
                                                                                  in procedure "le_snap_" set ref 783 910
template                  3            based           fixed bin(17,0)          array level 2 in structure "new_list" dcl 112
                                                                                  in procedure "le_snap_" set ref 690 783* 800
template_index                  000564 automatic       fixed bin(17,0)          dcl 148 set ref 644* 801* 802 831 851* 851 852 864
                                                                                  900* 911* 912 969 987* 987 988 1002 1002
tl                                     based           structure                level 1 dcl 126
tlp                             000566 automatic       pointer                  dcl 149 set ref 620* 624
true                            000041 constant        bit(1)                   initial unaligned dcl 46 set ref 233 261 286 319 340
                                                                                  362 411 527 534 555 575 588* 594 831 935 969
type                      1            based           fixed bin(6,0)           level 2 in structure "lk" packed unsigned unaligned
                                                                                  dcl 101 in procedure "le_snap_" set ref 199 199
                                                                                  199 201* 207
type                      1     000104 automatic       fixed bin(17,0)          level 2 in structure "auto_init" dcl 131
                                                                                  in procedure "le_snap_" set ref 654*
type                      1            based           fixed bin(17,0)          level 3 in structure "new_copy" dcl 108 in procedure
                                                                                  "le_snap_" set ref 741*
type                      1            based           fixed bin(17,0)          level 2 in structure "init" dcl 82 in procedure
                                                                                  "le_snap_" ref 652 652 654 663 758 905
type                      1     000100 automatic       fixed bin(17,0)          level 3 in structure "auto_def" dcl 130 in procedure
                                                                                  "le_snap_" set ref 623*
type                    101            based           fixed bin(18,0)          level 2 in structure "defn" packed unsigned
                                                                                  unaligned dcl 81 in procedure "le_snap_" set ref
                                                                                  448 454 456 458 460* 465 522 529 536 557 597*
type                      1            based           fixed bin(17,0)          level 3 in structure "new_list" dcl 112 in procedure
                                                                                  "le_snap_" set ref 685* 781*
unspec                                                 builtin function         dcl 164 set ref 693 742* 742 783* 783 939* 939
virgin_linkage_header                  based           structure                level 1 dcl 3-71 ref 237 475 564
word_offset               1            based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 121 set ref
                                                                                  817* 817 823* 823 955* 955 961* 961
wordno                                                 builtin function         dcl 165 ref 946 946

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
CLASS_HEAP                             internal static fixed bin(3,0)           initial unsigned dcl 2-25
CLASS_LINKAGE                          internal static fixed bin(3,0)           initial unsigned dcl 2-25
CLASS_NAMES                            internal static char(12)                 initial array unaligned dcl 2-35
CLASS_SEGNAME                          internal static fixed bin(3,0)           initial unsigned dcl 2-25
CLASS_SYSTEM                           internal static fixed bin(3,0)           initial unsigned dcl 2-25
CLASS_TEXT                             internal static fixed bin(3,0)           initial unsigned dcl 2-25
DEFINITION_FLAGS_ENTRY                 internal static bit(4)                   initial unaligned dcl 4-38
DEFINITION_FLAGS_IGNORE                internal static bit(4)                   initial unaligned dcl 4-37
DEFINITION_FLAGS_INDIRECT              internal static bit(4)                   initial unaligned dcl 4-40
DEFINITION_FLAGS_RETAIN                internal static bit(4)                   initial unaligned dcl 4-39
Definition                             internal static fixed bin(3,0)           initial dcl 1-32
FAULT_TAG_1                            internal static bit(6)                   initial unaligned dcl 3-100
FAULT_TAG_2                            internal static bit(6)                   initial unaligned dcl 3-101
FAULT_TAG_3                            internal static bit(6)                   initial unaligned dcl 3-102
FR_TRAPS_VERSION_1                     internal static fixed bin(17,0)          initial dcl 3-99
Heap                                   internal static fixed bin(3,0)           initial dcl 1-38
LE_ERROR                               internal static fixed bin(17,0)          initial dcl 1-20
LE_WARNING                             internal static fixed bin(17,0)          initial dcl 1-19
LINK_CREATE_IF_NOT_FOUND               internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
LINK_OBSOLETE_2                        internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
LINK_REFNAME_BASE                      internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
LINK_REFNAME_OFFSETNAME                internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
LINK_SELF_BASE                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
LINK_SELF_OFFSETNAME                   internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
LINK_TYPE_NAMES                        internal static varying char(32)         initial array dcl 2-153
OPEN_FLAGS_BOUND                       internal static bit(6)                   initial unaligned dcl 4-20
OPEN_FLAGS_NO_HASHTABLE                internal static bit(6)                   initial unaligned dcl 4-32
OPEN_FLAGS_PERPROCESS_STATIC           internal static bit(6)                   initial unaligned dcl 4-29
OPEN_FLAGS_PROCEDURE                   internal static bit(6)                   initial unaligned dcl 4-24
OPEN_FLAGS_RELOCATABLE                 internal static bit(6)                   initial unaligned dcl 4-22
OPEN_FLAGS_SEPARATE_STATIC             internal static bit(6)                   initial unaligned dcl 4-26
Patch_Symbol_Ref                       internal static fixed bin(17,0)          initial dcl 1-60
SECTION_HEAP                           internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
SECTION_LINK                           internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
SECTION_STATIC                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
SECTION_SYMBOL                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
SECTION_SYSTEM                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
SECTION_TEXT                           internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
SECTION_UNUSED                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-134
SYMBOLIC_SECTION_NAMES                 internal static char(8)                  initial array unaligned dcl 2-38
System                                 internal static fixed bin(3,0)           initial dcl 1-36
acc_string                             based           structure                level 1 dcl 2-327
acc_string_length                      automatic       fixed bin(21,0)          dcl 2-334
acc_string_ptr                         automatic       pointer                  dcl 2-326
comp_ht_n_entries                      automatic       fixed bin(17,0)          dcl 2-297
comp_ht_ptr                            automatic       pointer                  dcl 2-288
component_count                        automatic       fixed bin(15,0)          unsigned dcl 4-56
component_ht                           based           structure                level 1 dcl 2-289
component_list                         based           pointer                  array dcl 4-58
component_listp                        automatic       pointer                  dcl 4-55
def_count                              automatic       fixed bin(17,0)          dcl 1-173
def_header_ptr                         automatic       pointer                  dcl 2-57
def_ht_n_entries                       automatic       fixed bin(17,0)          dcl 2-284
def_ht_ptr                             automatic       pointer                  dcl 2-277
def_ptr                                automatic       pointer                  dcl 2-71
definition                             based           structure                level 1 dcl 2-72
definition_header                      based           structure                level 1 dcl 2-58
definition_ht                          based           structure                level 1 dcl 2-278
dup_table_n_names                      automatic       fixed bin(17,0)          dcl 2-310
dup_table_ptr                          automatic       pointer                  dcl 2-301
duplicate_table                        based           structure                level 1 dcl 2-302
exp_ptr                                automatic       pointer                  dcl 2-128
exp_word                               based           structure                level 1 dcl 2-129
fr_traps                               based           structure                level 1 dcl 3-90
gen_info                               based           structure                level 1 dcl 4-61
le_binaries                            based           structure                level 1 dcl 1-260
le_options                             based           structure                level 1 dcl 1-202
le_patches                             based           structure                level 1 dcl 1-293
le_segnames                            based           structure                level 1 dcl 1-149
link_count                             automatic       fixed bin(17,0)          dcl 1-231
link_init_n_bits_in_datum              automatic       fixed bin(35,0)          dcl 2-261
link_init_n_words                      automatic       fixed bin(17,0)          dcl 2-215
link_init_n_words_in_list              automatic       fixed bin(17,0)          dcl 2-226
link_init_ptr                          automatic       pointer                  dcl 2-204
link_trap_pair                         based           structure                level 1 dcl 2-177
link_trap_ptr                          automatic       pointer                  dcl 2-176
linkage_header                         based           structure                level 1 dcl 3-50
linkage_header_flags                   based           structure                level 1 dcl 3-63
list_template_entry                    based           structure                level 1 dcl 2-239
msf_map                                based           structure                level 1 dcl 2-318
msf_map_ptr                            automatic       pointer                  dcl 2-317
msf_map_version_1                      internal static char(8)                  initial unaligned dcl 2-323
object_link                            based           structure                level 1 dcl 3-28
ocu_$backpatch                  000000 constant        entry                    external dcl 4-146
ocu_$close                      000000 constant        entry                    external dcl 4-76
ocu_$create_msf                 000000 constant        entry                    external dcl 4-153
ocu_$emit_definition            000000 constant        entry                    external dcl 4-90
ocu_$emit_firstref_trap         000000 constant        entry                    external dcl 4-134
ocu_$emit_msf_map               000000 constant        entry                    external dcl 4-104
ocu_$emit_segname               000000 constant        entry                    external dcl 4-98
ocu_$emit_static                000000 constant        entry                    external dcl 4-109
ocu_$emit_symbol                000000 constant        entry                    external dcl 4-139
ocu_$emit_text                  000000 constant        entry                    external dcl 4-83
ocu_$open                       000000 constant        entry                    external dcl 4-69
ocu_$release                    000000 constant        entry                    external dcl 4-80
partial_link                           based           structure                level 1 dcl 3-38
reloc_str                              based           char                     unaligned dcl 4-53
reloc_strl                             automatic       fixed bin(21,0)          dcl 4-51
reloc_strp                             automatic       pointer                  dcl 4-50
segname_count                          automatic       fixed bin(17,0)          dcl 1-156
segname_definition                     based           structure                level 1 dcl 2-90
segname_ptr                            automatic       pointer                  dcl 2-89
type_pair                              based           structure                level 1 dcl 2-160
type_ptr                               automatic       pointer                  dcl 2-159
word_array                             based           bit(36)                  array unaligned dcl 4-48
word_arrayl                            automatic       fixed bin(18,0)          unsigned dcl 4-46
word_arrayp                            automatic       pointer                  dcl 4-45

NAMES DECLARED BY EXPLICIT CONTEXT.
LINK_TYPE                       000000 constant        label                    array(5) dcl 214 ref 207
le_snap_                        000204 constant        entry                    external dcl 16 ref 298 311 315 583 588 834 972

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5762        6014    5575        5772
Length      6324    5575        32         273     164           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
le_snap_                            485 external procedure  is an external procedure.  
on unit on line 675                  64 on unit               
on unit on line 725                  64 on unit               
on unit on line 767                  64 on unit               
on unit on line 894                  64 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
le_snap_                 000100 auto_def                    le_snap_
                         000104 auto_init                   le_snap_
                         000106 copied                      le_snap_
                         000110 defnp                       le_snap_
                         000112 hdr_size                    le_snap_
                         000113 i                           le_snap_
                         000114 initp                       le_snap_
                         000116 lelp                        le_snap_
                         000120 linkx                       le_snap_
                         000121 list_size                   le_snap_
                         000122 lkp                         le_snap_
                         000124 ltep                        le_snap_
                         000126 new_initp                   le_snap_
                         000130 n_words                     le_snap_
                         000131 offset                      le_snap_
                         000132 patch_mask                  le_snap_
                         000560 pitp                        le_snap_
                         000562 sys_areap                   le_snap_
                         000564 template_index              le_snap_
                         000566 tlp                         le_snap_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_in         call_ext_out_desc   call_ext_out        return_mac          enable_op
shorten_stack       ext_entry           int_entry           trunc_fx2           index_bs_1_eis      divide_fx1
op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_system_free_area_         le_backpatch_                 le_error_                     ocu_$emit_link
ocu_$emit_partial_link

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_class_def    le_et_$bad_link_class         le_et_$bad_link_ref           le_et_$bad_link_type




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     16 000174       167 000211       168 000214       169 000215       170 000221       172 000225       176 000233
    178 000244       180 000247       184 000316       187 000317       191 000322       193 000335       194 000337
    195 000341       196 000345       199 000346       201 000357       204 000412       207 000413       214 000415
    221 000422       223 000424       224 000426       226 000512       231 000513       232 000515       233 000526
    234 000532       235 000533       237 000535       241 000537       249 000556       251 000560       252 000562
    254 000641       259 000642       260 000644       261 000651       262 000655       267 000656       274 000661
    276 000663       278 000737       279 000742       280 000746       283 000747       284 000750       285 000752
    286 000756       287 000762       292 000763       298 000765       300 001020       301 001023       303 001102
    304 001107       311 001110       315 001152       317 001206       319 001214       320 001221       321 001222
    326 001224       328 001226       329 001230       331 001307       332 001314       337 001315       338 001317
    339 001330       340 001334       341 001340       342 001341       345 001343       350 001350       351 001352
    353 001436       355 001450       356 001454       359 001455       360 001457       361 001470       362 001474
    363 001500       364 001501       368 001536       375 001537       383 001547       385 001641       386 001645
    387 001651       389 001662       390 001663       396 001666       398 001712       399 001717       400 001721
    401 001725       408 001726       409 001737       410 001741       411 001745       414 001751       421 001752
    429 001760       431 002064       432 002070       433 002074       435 002105       438 002106       440 002117
    448 002124       454 002131       456 002137       458 002145       460 002153       464 002213       465 002226
    467 002264       468 002271       475 002272       476 002274       482 002301       485 002333       486 002340
    487 002341       493 002346       497 002404       498 002411       505 002412       507 002443       509 002477
    514 002504       515 002506       516 002512       522 002513       524 002517       525 002521       526 002536
    527 002542       528 002546       529 002547       531 002551       532 002553       533 002570       534 002574
    535 002600       536 002601       539 002603       544 002606       545 002610       548 002701       549 002706
    552 002707       553 002711       554 002726       555 002732       556 002736       557 002737       564 002741
    566 002743       571 002753       573 002766       574 002770       575 002774       576 003000       583 003001
    588 003051       591 003112       594 003120       596 003125       597 003126       601 003166       608 003167
    620 003172       623 003204       624 003206       625 003211       627 003241       629 003243       630 003246
    632 003346       634 003354       636 003360       638 003413       639 003414       644 003420       650 003421
    652 003423       654 003427       655 003430       656 003434       657 003436       659 003533       660 003541
    661 003543       662 003547       663 003550       665 003552       666 003560       668 003562       675 003570
    677 003604       679 003617       683 003620       684 003625       685 003635       686 003637       690 003647
    691 003651       692 003654       693 003656       697 003665       698 003673       699 003676       703 003700
    704 003702       708 003703       710 004000       711 004006       712 004010       714 004014       716 004022
    718 004023       725 004024       727 004040       729 004052       733 004053       737 004057       741 004070
    742 004072       747 004104       749 004203       750 004211       751 004213       753 004217       755 004224
    757 004225       758 004226       760 004230       762 004236       767 004240       769 004254       771 004267
    775 004270       777 004275       781 004305       782 004307       783 004317       789 004335       790 004342
    791 004345       795 004347       796 004351       800 004352       801 004354       802 004356       804 004361
    808 004364       813 004371       817 004373       823 004417       831 004440       834 004453       837 004513
    843 004600       850 004603       851 004612       852 004613       854 004617       858 004620       864 004717
    865 004725       866 004732       868 004757       869 004763       871 004764       872 004771       873 004773
    877 004777       879 005005       882 005006       889 005007       890 005011       891 005012       892 005014
    894 005022       896 005036       898 005047       900 005050       905 005051       910 005055       911 005057
    912 005061       916 005064       920 005066       925 005073       930 005075       931 005101       935 005111
    939 005113       946 005130       951 005141       955 005144       961 005170       969 005211       972 005224
    975 005264       981 005351       986 005354       987 005363       988 005364       990 005370       993 005371
    996 005375      1002 005476      1005 005507      1006 005514      1008 005541      1009 005545      1011 005546
   1012 005553      1013 005555      1015 005561      1018 005571      1021 005572


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
