	COMPILATION LISTING OF SEGMENT dm_vu_append_simple_typed
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/17/86  0954.4 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 
        8 
        9 /****^  HISTORY COMMENTS:
       10*  1) change(86-10-28,Dupuis), approve(86-11-13,MCR7573), audit(86-11-14,Blair),
       11*     install(86-11-17,MR12.0-1220):
       12*     Fixed a subsciptrange error in the ERROR_FINISH proc.
       13*                                                   END HISTORY COMMENTS */
       14 
       15 
       16 /* DESCRIPTION:
       17*
       18*          This module appends a simple_typed_vector to a typed_vector_array.
       19*     The TVA is extended if necessary.  When extended, the old TVA structure
       20*     is freed and the p_tva_ptr parameter is changed to point to the new,
       21*     extended, copy of the TVA.
       22*
       23*     There are two calling sequences to this module:
       24*     
       25*     call dm_vu_append_simple_typed (area_ptr, slot_increase_factor,
       26*     free_old_tva, value1, value2,..., valueN, typed_vector_array_ptr, code);
       27*     
       28*     or,
       29*
       30*     call dm_vu_append_simple_typed (area_ptr, slot_increase_factor,
       31*     free_old_tva, typed_vector_array_ptr, code);
       32*     
       33*     Also, this module can be invoked as a function with the same arguments,
       34*     and it will return a pointer to the newly generated typed_vector.
       35*     
       36*     The first calling sequence will fill in the simple_typed_vector with
       37*     pointers to copies of the supplied values.  The second calling sequence
       38*     creates a simple_typed_vector with all null values.
       39*     
       40**/
       41 
       42 /* HISTORY:
       43*
       44*Written by Lindsey Spratt, 03/01/82.
       45*
       46*Modified:
       47*05/17/82 by Lindsey Spratt: Fixed handling of varying strings.
       48*09/24/82 by Lindsey Spratt:  Fixed bug where the simple_typed_vector_ptr was
       49*	  not being recorded in the typed_vector_array if there were enough
       50*	  slots in the tva to just add the vector.  It was working correctly
       51*	  in the case where the tva had to be grown.
       52*06/16/83 by Lindsey L. Spratt:  Fixed the problem where the parameter
       53*            typed_vector_array_ptr was not being updated with the new value
       54*            for the typed_vector_array_ptr when the typed_vector_array was
       55*            grown.  Also, changed the handling of varying strings to assume
       56*            that the storage pointed at by the arg_list ptr (for a varying
       57*            string) is the length word and the string, instead of assuming
       58*            that the "size" in the descriptor is the length and that the
       59*            arg_list ptr points at just the string.
       60*12/18/84 by Lindsey L. Spratt:  Changed to have standard format.  Changed to
       61*            use modern sub_err_ calling sequence.  Changed to use
       62*            error_table_$bad_subr_arg rather than $bad_arg.  Added check for
       63*            enough args being supplied, which signals with $wrong_no_of_args
       64*            if the check fails.  Changed to use the ERROR_RETURN technology
       65*            for reporting errors.  Changed to reference data_format_util_
       66*            rather than the obsolete data_mgmt_util_.
       67*02/11/85 by Lindsey L. Spratt:  Changed to use the RETURN internal procedure.
       68*            Added the ability to return the error_table_$area_too_small error
       69*            code when an area condition occurs.
       70*03/08/85 by Lindsey L. Spratt:  Fixed a bug due to old_tva_ptr being
       71*            uninitialized.  Fixed to initialize all of the automatic ptr
       72*            variables.
       73*03/18/85 by Lindsey L. Spratt:  Cleaned up the implementation of the
       74*            ERROR_RETURN proc.  Changed entire procedure to use only the
       75*            cu_$*_rel entries.  Enhanced error reporting of GET_ARG_PTR to
       76*	  include a name of the desired descriptor type.
       77**/
       78 
       79 
       80 /* format: style2,ind3 */
       81 dm_vu_append_simple_typed:
       82    proc () options (variable);
       83 
       84 /* START OF DECLARATIONS */
       85 /* Parameter */
       86 /* Automatic */
       87 
       88       dcl	    arg_idx	       fixed bin;
       89       dcl	    arg_length	       fixed bin (21) init (0);
       90       dcl	    arg_list_arg_count     fixed bin;
       91       dcl	    arg_list_ptr	       ptr init (null ());
       92       dcl	    arg_ptr	       ptr init (null);
       93       dcl	    code_arg_idx	       fixed bin;
       94       dcl	    dim_idx	       fixed bin;
       95       dcl	    free_old_typed_vector_array_ptr
       96 			       ptr init (null ());
       97       dcl	    nargs		       fixed bin;
       98       dcl	    ndims		       fixed bin;
       99       dcl	    number_of_nonvalue_args_at_end
      100 			       fixed bin;
      101       dcl	    number_of_values_given fixed bin (35) init (0);
      102       dcl	    old_tva_ptr	       ptr init (null ());
      103       dcl	    packed	       bit (1) aligned;
      104       dcl	    p_code_ptr	       ptr init (null ());
      105       dcl	    p_typed_vector_array_ptr_ptr
      106 			       ptr init (null ());
      107       dcl	    scale		       fixed bin;
      108       dcl	    size		       fixed bin (17) aligned;
      109       dcl	    storage_size	       fixed bin (35);
      110       dcl	    storage_string_ptr     ptr init (null ());
      111       dcl	    values_given	       bit (1) aligned init ("0"b);
      112       dcl	    tv_ptr_arg_idx	       fixed bin;
      113       dcl	    tva_ptr_arg_idx	       fixed bin;
      114       dcl	    type		       fixed bin;
      115       dcl	    vector_idx	       fixed bin;
      116       dcl	    work_area_ptr	       ptr init (null ());
      117 
      118 /* Based */
      119 
      120       dcl	    descriptor_string      bit (36) aligned based;
      121       dcl	    free_old_typed_vector_array
      122 			       bit (1) aligned based (free_old_typed_vector_array_ptr);
      123       dcl	    p_typed_vector_array_ptr
      124 			       based (p_typed_vector_array_ptr_ptr) ptr;
      125       dcl	    p_code	       based (p_code_ptr) fixed bin (35);
      126       dcl	    ptr_template	       based ptr aligned;
      127       dcl	    s_fixed_real_template  based fixed bin (35) aligned;
      128       dcl	    storage_string	       bit (storage_size) based (storage_string_ptr) aligned;
      129       dcl	    varying_bit_storage_string
      130 			       bit (storage_size) varying based (storage_string_ptr);
      131       dcl	    varying_char_storage_string
      132 			       char (storage_size) varying based (storage_string_ptr);
      133       dcl	    work_area	       area based (work_area_ptr);
      134 
      135 
      136 /* Builtin */
      137 
      138       dcl	    (addr, addrel, null)
      139 			       builtin;
      140 
      141 /* Condition */
      142 
      143       dcl	    (area, cleanup)	       condition;
      144 
      145 /* Constant */
      146 
      147       dcl	    (
      148 	    AREA_IS_BIG_ENOUGH     init (0),
      149 	    AREA_IS_TOO_SMALL      init (1)
      150 	    )		       fixed bin (35) internal static options (constant);
      151 
      152       dcl	    (
      153 	    BITS_PER_BYTE	       init (9),
      154 	    BITS_PER_WORD	       init (36)
      155 	    )		       fixed bin (35) internal static options (constant);
      156       dcl	    (NO_PAD, NO_NL)	       init ("0"b) bit (1) aligned internal static options (constant);
      157 
      158       dcl	    MYNAME	       init ("dm_vu_init_tva") char (40) varying internal static options (constant);
      159 
      160       dcl	    (
      161 	    AREA_PTR_ARG_IDX       init (1),
      162 	    SLOT_INCREASE_ARG_IDX  init (2),
      163 	    FREE_OLD_TVA_ARG_IDX   init (3),
      164 	    NUMBER_OF_NONVALUE_ARGS_AT_BEGINNING
      165 			       init (3),
      166 	    TVA_PTR_ARG_OFFSET_FROM_SUBROUTINE_END
      167 			       init (1),
      168 	    TVA_PTR_ARG_OFFSET_FROM_FUNCTION_END
      169 			       init (2),
      170 	    CODE_ARG_OFFSET_FROM_SUBROUTINE_END
      171 			       init (0),
      172 	    CODE_ARG_OFFSET_FROM_FUNCTION_END
      173 			       init (1),
      174 	    NUMBER_OF_NONVALUE_ARGS_AT_SUBROUTINE_END
      175 			       init (2),
      176 	    NUMBER_OF_NONVALUE_ARGS_AT_FUNCTION_END
      177 			       init (3),
      178 	    NO_TYPE	       init (-1)
      179 	    )		       fixed bin internal static options (constant);
      180 
      181 
      182 /* Entry */
      183 
      184       dcl	    cu_$arg_count_rel      entry (fixed bin, ptr, fixed bin (35));
      185       dcl	    cu_$arg_list_ptr       entry (ptr);
      186       dcl	    cu_$arg_ptr_rel	       entry (fixed bin, ptr, fixed bin (21), fixed bin (35), ptr);
      187       dcl	    data_format_util_$get_data_bit_length
      188 			       entry (bit (36) aligned, fixed bin (35), fixed bin (35));
      189       dcl	    decode_descriptor_     entry (ptr, fixed bin, fixed bin, bit (1) aligned, fixed bin, fixed bin, fixed bin);
      190       dcl	    dm_vector_util_$free_typed_vector
      191 			       entry (ptr, ptr, ptr, fixed bin (35));
      192       dcl	    ioa_$general_rs	       entry (ptr, fixed bin, fixed bin, char (*), fixed bin (21), bit (1) aligned,
      193 			       bit (1) aligned);
      194       dcl	    sub_err_	       entry () options (variable);
      195 
      196 /* External */
      197 
      198       dcl	    (
      199 	    error_table_$area_too_small,
      200 	    error_table_$bad_subr_arg,
      201 	    error_table_$wrong_no_of_args
      202 	    )		       fixed bin (35) ext;
      203 
      204 /* END OF DECLARATIONS */
      205 
      206       call cu_$arg_list_ptr (arg_list_ptr);
      207       call cu_$arg_count_rel (nargs, arg_list_ptr, (0));
      208       arg_list_arg_count = nargs;
      209 
      210       call decode_descriptor_ (arg_list_ptr, nargs, type, packed, ndims, size, scale);
      211       if type = pointer_desc
      212       then
      213          do;
      214 	  tv_ptr_arg_idx = nargs;
      215 	  tva_ptr_arg_idx = nargs - TVA_PTR_ARG_OFFSET_FROM_FUNCTION_END;
      216 	  code_arg_idx = nargs - CODE_ARG_OFFSET_FROM_FUNCTION_END;
      217 	  number_of_nonvalue_args_at_end = NUMBER_OF_NONVALUE_ARGS_AT_FUNCTION_END;
      218          end;
      219       else
      220          do;
      221 	  tv_ptr_arg_idx = -1;
      222 	  ;
      223 	  tva_ptr_arg_idx = nargs - TVA_PTR_ARG_OFFSET_FROM_SUBROUTINE_END;
      224 	  code_arg_idx = nargs - CODE_ARG_OFFSET_FROM_SUBROUTINE_END;
      225 	  number_of_nonvalue_args_at_end = NUMBER_OF_NONVALUE_ARGS_AT_SUBROUTINE_END;
      226          end;
      227 
      228       if (nargs > (NUMBER_OF_NONVALUE_ARGS_AT_BEGINNING + number_of_nonvalue_args_at_end))
      229       then values_given = "1"b;
      230       else if (nargs = (NUMBER_OF_NONVALUE_ARGS_AT_BEGINNING + number_of_nonvalue_args_at_end))
      231       then values_given = "0"b;
      232       else call sub_err_ (error_table_$wrong_no_of_args, MYNAME, ACTION_CANT_RESTART, null (), 0,
      233 	      "^/This program expects ^d arguments, or more, but was called with ^d arguments.",
      234 	      (NUMBER_OF_NONVALUE_ARGS_AT_BEGINNING + number_of_nonvalue_args_at_end), nargs);
      235 
      236       on cleanup call ERROR_FINISH ();
      237 
      238       p_code_ptr = GET_ARG_PTR (arg_list_ptr, code_arg_idx, s_fixed_real_desc, "short_fixed_real");
      239 
      240       work_area_ptr = GET_ARG_PTR (arg_list_ptr, AREA_PTR_ARG_IDX, pointer_desc, "pointer") -> ptr_template;
      241 
      242       p_typed_vector_array_ptr_ptr = GET_ARG_PTR (arg_list_ptr, tva_ptr_arg_idx, pointer_desc, "pointer");
      243 
      244       typed_vector_array_ptr = p_typed_vector_array_ptr;
      245 
      246       tva_number_of_vector_slots =
      247 	 typed_vector_array.number_of_vector_slots
      248 	 + GET_ARG_PTR (arg_list_ptr, SLOT_INCREASE_ARG_IDX, s_fixed_real_desc, "short_fixed_real")
      249 	 -> s_fixed_real_template;
      250 
      251       free_old_typed_vector_array_ptr = GET_ARG_PTR (arg_list_ptr, FREE_OLD_TVA_ARG_IDX, bit_desc, "nonvarying bit");
      252 
      253       stv_number_of_dimensions = typed_vector_array.number_of_dimensions;
      254 
      255       on area call RETURN (AREA_IS_TOO_SMALL);
      256 
      257       alloc simple_typed_vector in (work_area);
      258       simple_typed_vector.type = SIMPLE_TYPED_VECTOR_TYPE;
      259       simple_typed_vector.dimension (*).value_ptr = null ();
      260 
      261       if values_given
      262       then
      263          do;
      264 	  number_of_values_given = nargs - (number_of_nonvalue_args_at_end + NUMBER_OF_NONVALUE_ARGS_AT_BEGINNING);
      265 
      266 	  do arg_idx = NUMBER_OF_NONVALUE_ARGS_AT_BEGINNING + 1 to nargs - number_of_nonvalue_args_at_end;
      267 
      268 	     call cu_$arg_ptr_rel (arg_idx, arg_ptr, arg_length, p_code, arg_list_ptr);
      269 	     if p_code ^= 0
      270 	     then call ERROR_RETURN (p_code, "^/Unable to get a pointer to parameter ^d.", arg_idx);
      271 
      272 	     call decode_descriptor_ (arg_list_ptr, arg_idx, type, packed, ndims, size, scale);
      273 
      274 	     if type = v_char_desc
      275 	     then storage_size = size * BITS_PER_BYTE + BITS_PER_WORD;
      276 	     else if type = v_bit_desc
      277 	     then storage_size = size + BITS_PER_WORD;
      278 	     else
      279 	        do;
      280 		 call data_format_util_$get_data_bit_length (arg_list_ptr -> arg_list.desc_ptrs (arg_idx)
      281 		      -> descriptor_string, storage_size, p_code);
      282 		 if p_code ^= 0
      283 		 then call ERROR_RETURN (p_code, "^/Unable to get the length (in bits) of parameter ^d.", arg_idx);
      284 	        end;
      285 
      286 	     alloc storage_string in (work_area);
      287 	     if type = v_char_desc
      288 	     then varying_char_storage_string = addrel (arg_ptr, -1) -> varying_char_storage_string;
      289 	     else if type = v_bit_desc
      290 	     then varying_bit_storage_string = addrel (arg_ptr, -1) -> varying_bit_storage_string;
      291 	     else storage_string = arg_ptr -> storage_string;
      292 
      293 	     simple_typed_vector.dimension (arg_idx - NUMBER_OF_NONVALUE_ARGS_AT_BEGINNING).value_ptr =
      294 		storage_string_ptr;
      295 
      296 	  end;
      297          end;
      298 
      299       else number_of_values_given = 0;
      300 
      301       do dim_idx = number_of_values_given + 1 to simple_typed_vector.number_of_dimensions;
      302          simple_typed_vector.dimension (dim_idx).value_ptr = null;
      303       end;
      304 
      305 
      306       if typed_vector_array.number_of_vectors + 1 > typed_vector_array.number_of_vector_slots
      307       then
      308          do;
      309 	  tva_maximum_dimension_name_length = typed_vector_array.maximum_dimension_name_length;
      310 	  tva_number_of_dimensions = typed_vector_array.number_of_dimensions;
      311 	  old_tva_ptr = typed_vector_array_ptr;
      312 	  alloc typed_vector_array in (work_area);
      313 	  typed_vector_array.version = TYPED_VECTOR_ARRAY_VERSION_2;
      314 	  typed_vector_array.dimension_table = old_tva_ptr -> typed_vector_array.dimension_table;
      315 	  typed_vector_array.number_of_vectors = old_tva_ptr -> typed_vector_array.number_of_vectors;
      316 	  do vector_idx = 1 to typed_vector_array.number_of_vectors;
      317 	     typed_vector_array.vector_slot (vector_idx) = old_tva_ptr -> typed_vector_array.vector_slot (vector_idx);
      318 	  end;
      319 	  p_typed_vector_array_ptr = typed_vector_array_ptr;
      320          end;
      321 
      322       typed_vector_array.number_of_vectors = typed_vector_array.number_of_vectors + 1;
      323       typed_vector_array.vector_slot (typed_vector_array.number_of_vectors) = simple_typed_vector_ptr;
      324 
      325 
      326       if tv_ptr_arg_idx > 0
      327       then GET_ARG_PTR (arg_list_ptr, tv_ptr_arg_idx, pointer_desc, "pointer") -> ptr_template = simple_typed_vector_ptr;
      328 
      329       call RETURN (AREA_IS_BIG_ENOUGH);
      330 
      331 MAIN_RETURN:
      332       return;
      333 
      334 
      335 RETURN:
      336    proc (r_p_area_status);
      337       dcl	    r_p_area_status	       fixed bin (35) parm;
      338       if r_p_area_status = AREA_IS_BIG_ENOUGH
      339       then
      340          do;
      341 	  p_code = 0;
      342 	  call FINISH ();
      343          end;
      344       else if r_p_area_status = AREA_IS_TOO_SMALL
      345       then
      346          do;
      347 	  p_code = error_table_$area_too_small;
      348 	  call ERROR_FINISH ();
      349          end;
      350       else call ERROR_RETURN (error_table_$bad_subr_arg, "^/There is an internal program logic error in this program.
      351 The RETURN internal procedure was given an area status of ^d, 
      352 when only ^d and ^d are defined statuses.", r_p_area_status, AREA_IS_BIG_ENOUGH, AREA_IS_TOO_SMALL);
      353       goto MAIN_RETURN;
      354    end RETURN;
      355 
      356 
      357 ERROR_RETURN:
      358    proc () options (variable);
      359       dcl	    er_p_code_ptr	       ptr init (null ());
      360       dcl	    er_p_code	       based (er_p_code_ptr) fixed bin (35);
      361       dcl	    er_arg_list_ptr	       ptr init (null);
      362       dcl	    er_code	       fixed bin (35);
      363       dcl	    er_msg	       char (1024);
      364       dcl	    er_based_msg	       char (er_msg_length) based (addr (er_msg));
      365       dcl	    er_msg_length	       fixed bin (21) init (0);
      366 
      367       dcl	    er_nargs	       fixed bin;
      368       call cu_$arg_list_ptr (er_arg_list_ptr);
      369       call cu_$arg_count_rel (er_nargs, er_arg_list_ptr, (0));
      370       if er_nargs = 0
      371       then er_code = 0;
      372       else
      373          do;
      374 	  call cu_$arg_ptr_rel (1, er_p_code_ptr, (0), (0), er_arg_list_ptr);
      375 	  er_code = er_p_code;
      376          end;
      377       if er_nargs >= 2
      378       then call ioa_$general_rs (er_arg_list_ptr, 2, 3, er_msg, er_msg_length, NO_PAD, NO_NL);
      379 
      380       call sub_err_ (er_code, MYNAME, ACTION_CANT_RESTART, null (), 0, "^a", er_based_msg);
      381 
      382    end ERROR_RETURN;
      383 
      384 FINISH:
      385    proc ();
      386       if free_old_typed_vector_array_ptr ^= null
      387       then if free_old_typed_vector_array & old_tva_ptr ^= null
      388 	 then free old_tva_ptr -> typed_vector_array;
      389    end FINISH;
      390 
      391 ERROR_FINISH:
      392    proc ();
      393       if p_typed_vector_array_ptr_ptr ^= null
      394       then
      395          do;
      396 	  if old_tva_ptr ^= null
      397 	  then
      398 	     do;
      399 	        p_typed_vector_array_ptr = old_tva_ptr;
      400 	        old_tva_ptr = null;
      401 	        if p_typed_vector_array_ptr ^= typed_vector_array_ptr & typed_vector_array_ptr ^= null
      402 	        then free typed_vector_array;
      403 	     end;
      404 	  if simple_typed_vector_ptr ^= null
      405 	  then
      406 	     do;
      407 
      408 	        call dm_vector_util_$free_typed_vector (work_area_ptr, p_typed_vector_array_ptr,
      409 		   simple_typed_vector_ptr, (0));
      410 	        if p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors > 0
      411 	        then if p_typed_vector_array_ptr
      412 		        -> typed_vector_array
      413 		        .vector_slot (p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors)
      414 		        = simple_typed_vector_ptr
      415 		   then p_typed_vector_array_ptr
      416 			   -> typed_vector_array
      417 			   .vector_slot (p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors) = null;
      418 	     end;
      419          end;
      420    end ERROR_FINISH;
      421 
      422 GET_ARG_PTR:
      423    proc (gap_p_arg_list_ptr, gap_p_arg_idx, gap_p_required_type, gap_p_type_name) returns (ptr);
      424       dcl	    gap_p_arg_list_ptr     ptr parm;
      425       dcl	    gap_p_arg_idx	       fixed bin parm;
      426       dcl	    gap_p_required_type    fixed bin parm;
      427       dcl	    gap_p_type_name	       char (*) parm;
      428 
      429       dcl	    gap_arg_ptr	       ptr init (null);
      430       dcl	    gap_arg_len	       fixed bin (21);
      431       dcl	    gap_code	       fixed bin (35) init (0);
      432       dcl	    gap_ndims	       fixed bin;
      433       dcl	    gap_packed	       bit (1) aligned;
      434       dcl	    gap_scale	       fixed bin;
      435       dcl	    gap_size	       fixed bin;
      436       dcl	    gap_type	       fixed bin;
      437 
      438       if gap_p_required_type ^= NO_TYPE
      439       then
      440          do;
      441 	  call decode_descriptor_ (gap_p_arg_list_ptr, gap_p_arg_idx, gap_type, gap_packed, gap_ndims, gap_size,
      442 	       gap_scale);
      443 	  if gap_type ^= gap_p_required_type
      444 	  then call ERROR_RETURN (error_table_$bad_subr_arg,
      445 		  "^/Parameter ^d must be of type ^d (^a), but the one given was ^d.", gap_p_arg_idx,
      446 		  gap_p_required_type, gap_p_type_name, gap_type);
      447          end;
      448 
      449       call cu_$arg_ptr_rel (gap_p_arg_idx, gap_arg_ptr, gap_arg_len, gap_code, gap_p_arg_list_ptr);
      450       if gap_code ^= 0
      451       then call ERROR_RETURN (gap_code, "^/Unable to get a pointer to parameter ^d.", gap_p_arg_idx);
      452 
      453       return (gap_arg_ptr);
      454    end GET_ARG_PTR;
      455 
  1     1 /* ***********************************************************
  1     2*   *                                                         *
  1     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  1     4*   *                                                         *
  1     5*   *********************************************************** */
  1     6 /* BEGIN INCLUDE FILE vu_typed_vector_array.incl.pl1 */
  1     7 
  1     8 /* Written by Lindsey Spratt, 03/04/82.
  1     9*Modified:
  1    10*06/23/82 by Lindsey Spratt: Changed to version 2.  The cv entry declarations
  1    11*	  were altered.  cv_to_typed now takes ptr to the descriptor, ptr to
  1    12*	  the print_vector value (char varying), ptr to the typed_vector
  1    13*	  value location, and a code. cv_to_print now takes ptr to the
  1    14*	  descriptor, ptr to the typed_vector value, the print_vector value
  1    15*	  (char(*) varying), the maximum allowed length for the print_vector
  1    16*	  value, a temp_seg to put the value in if its to big to fit into
  1    17*	  the print_vector, and a code.
  1    18**/
  1    19 
  1    20 /* format: style2,ind3 */
  1    21      dcl	   1 typed_vector_array   based (typed_vector_array_ptr) aligned,
  1    22 	     2 version	      fixed bin (35),
  1    23 	     2 number_of_dimensions
  1    24 			      fixed bin (17),
  1    25 	     2 number_of_vectors  fixed bin (17),
  1    26 	     2 number_of_vector_slots
  1    27 			      fixed bin (17),
  1    28 	     2 maximum_dimension_name_length
  1    29 			      fixed bin (17),
  1    30 	     2 dimension_table    (tva_number_of_dimensions refer (typed_vector_array.number_of_dimensions)),
  1    31 	       3 name	      char (tva_maximum_dimension_name_length
  1    32 			      refer (typed_vector_array.maximum_dimension_name_length)) varying,
  1    33 	       3 descriptor_ptr   ptr,		/* call cv_to_print (descriptor_ptr, typed_value_ptr, */
  1    34 						/* temp_seg_ptr, max_length_for_print_value, */
  1    35 						/* print_value, code) */
  1    36 	       3 cv_to_print      entry (ptr, ptr, ptr, fixed bin (35), char (*) varying, fixed bin (35)),
  1    37 						/* call cv_to_typed (descriptor_ptr, area_ptr, */
  1    38 						/* print_value_ptr, typed_value_ptr, code) */
  1    39 	       3 cv_to_typed      entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  1    40 	     2 vector_slot	      (tva_number_of_vector_slots refer (typed_vector_array.number_of_vector_slots))
  1    41 			      pointer;
  1    42 
  1    43      dcl	   typed_vector_array_ptr ptr;
  1    44      dcl	   tva_number_of_vector_slots
  1    45 			      fixed bin;
  1    46      dcl	   tva_number_of_dimensions
  1    47 			      fixed bin;
  1    48      dcl	   tva_maximum_dimension_name_length
  1    49 			      fixed bin;
  1    50      dcl	   TYPED_VECTOR_ARRAY_VERSION_2
  1    51 			      fixed bin (35) int static options (constant) init (2);
  1    52 
  1    53 /* END INCLUDE FILE vu_typed_vector_array.incl.pl1 */
      456 
      457 
  2     1 /* ***********************************************************
  2     2*   *                                                         *
  2     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  2     4*   *                                                         *
  2     5*   *********************************************************** */
  2     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
  2     7 
  2     8 /* Written by Lindsey Spratt, 04/02/82.
  2     9*Modified:
  2    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
  2    11*	  unaligned.  Changed the type number of the simple_typed_vector to
  2    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
  2    13*	  type.
  2    14**/
  2    15 
  2    16 /* format: style2,ind3 */
  2    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
  2    18 	     2 type	      fixed bin (17) unal,
  2    19 	     2 number_of_dimensions
  2    20 			      fixed bin (17) unal,
  2    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
  2    22 	       3 value_ptr	      ptr unaligned;
  2    23 
  2    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
  2    25 	     2 type	      fixed bin (17) unal,
  2    26 	     2 number_of_dimensions
  2    27 			      fixed bin (17) unal,
  2    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
  2    29 	       3 identifier	      fixed bin (17) unal,
  2    30 	       3 pad	      bit (18) unal,
  2    31 	       3 value_ptr	      ptr unal;
  2    32 
  2    33      dcl	   simple_typed_vector_ptr
  2    34 			      ptr;
  2    35      dcl	   stv_number_of_dimensions
  2    36 			      fixed bin (17);
  2    37 
  2    38      dcl	   general_typed_vector_ptr
  2    39 			      ptr;
  2    40      dcl	   gtv_number_of_dimensions
  2    41 			      fixed bin (17);
  2    42 
  2    43      dcl	   (
  2    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
  2    45 			      init (1),		/* value_ptr was aligned. */
  2    46 	   GENERAL_TYPED_VECTOR_TYPE
  2    47 			      init (2),
  2    48 	   SIMPLE_TYPED_VECTOR_TYPE
  2    49 			      init (3)
  2    50 	   )		      fixed bin (17) internal static options (constant);
  2    51 
  2    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
      458 
      459 
  3     1 dcl (	s_fixed_real_desc		init( 1),
  3     2 	d_fixed_real_desc		init( 2),
  3     3 	s_float_real_desc		init( 3),
  3     4 	d_float_real_desc		init( 4),
  3     5 	s_fixed_cplx_desc		init( 5),
  3     6 	d_fixed_cplx_desc		init( 6),
  3     7 	s_float_cplx_desc		init( 7),
  3     8 	d_float_cplx_desc		init( 8),
  3     9 
  3    10 	D_fixed_real_desc		init( 9),
  3    11 	D_float_real_desc		init(10),
  3    12 	D_fixed_cplx_desc		init(11),
  3    13 	D_float_cplx_desc		init(12),
  3    14 
  3    15 	pointer_desc		init(13),
  3    16 	offset_desc		init(14),
  3    17 	label_desc		init(15),
  3    18 	entry_desc		init(16),
  3    19 	structure_desc		init(17),
  3    20 	area_desc			init(18),
  3    21 
  3    22 	bit_desc			init(19),
  3    23 	v_bit_desc		init(20),
  3    24 
  3    25 	char_desc			init(21),
  3    26 	v_char_desc		init(22),
  3    27 
  3    28 	file_desc			init(23)
  3    29 					) fixed bin int static options(constant);
      460 
      461 
  4     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  4     2 /* format: style3 */
  4     3 
  4     4 /* These constants are to be used for the flags argument of sub_err_ */
  4     5 /* They are just "string (condition_info_header.action_flags)" */
  4     6 
  4     7 declare	(
  4     8 	ACTION_CAN_RESTART	init (""b),
  4     9 	ACTION_CANT_RESTART init ("1"b),
  4    10 	ACTION_DEFAULT_RESTART
  4    11 			init ("01"b),
  4    12 	ACTION_QUIET_RESTART
  4    13 			init ("001"b),
  4    14 	ACTION_SUPPORT_SIGNAL
  4    15 			init ("0001"b)
  4    16 	)		bit (36) aligned internal static options (constant);
  4    17 
  4    18 /* End include file */
      462 
      463 
  5     1 /* BEGIN INCLUDE FILE ... arg_list.incl.pl1
  5     2*
  5     3*   James R. Davis 10 May 79 */
  5     4 
  5     5 
  5     6      
  5     7 /****^  HISTORY COMMENTS:
  5     8*  1) change(86-05-15,DGHowe), approve(86-05-15,MCR7375),
  5     9*     audit(86-07-15,Schroth):
  5    10*     added command_name_arglist declaration to allow the storage of the
  5    11*     command name given to the command processor
  5    12*                                                   END HISTORY COMMENTS */
  5    13 
  5    14      dcl	   1 arg_list	      aligned based,
  5    15 	     2 header,
  5    16 	       3 arg_count	      fixed bin (17) unsigned unal,
  5    17 	       3 pad1	      bit (1) unal,
  5    18 	       3 call_type	      fixed bin (18) unsigned unal,
  5    19 	       3 desc_count	      fixed bin (17) unsigned unal,
  5    20 	       3 pad2	      bit (19) unal,
  5    21 	     2 arg_ptrs	      (arg_list_arg_count refer (arg_list.arg_count)) ptr,
  5    22 	     2 desc_ptrs	      (arg_list_arg_count refer (arg_list.arg_count)) ptr;
  5    23 
  5    24 
  5    25      dcl	   1 command_name_arglist	      aligned based,
  5    26 	     2 header,
  5    27 	       3 arg_count	      fixed bin (17) unsigned unal,
  5    28 	       3 pad1	      bit (1) unal,
  5    29 	       3 call_type	      fixed bin (18) unsigned unal,
  5    30 	       3 desc_count	      fixed bin (17) unsigned unal,
  5    31 	       3 mbz              bit(1) unal,
  5    32                  3 has_command_name bit(1) unal,
  5    33 	       3 pad2	      bit (17) unal,
  5    34 	     2 arg_ptrs	      (arg_list_arg_count refer (command_name_arglist.arg_count)) ptr,
  5    35 	     2 desc_ptrs	      (arg_list_arg_count refer (command_name_arglist.arg_count)) ptr,
  5    36 	     2 name,
  5    37                  3 command_name_ptr         pointer,
  5    38                  3 command_name_length      fixed bin (21);
  5    39 	
  5    40 
  5    41 
  5    42      dcl	   1 arg_list_with_envptr aligned based,	/* used with non-quick int and entry-var calls */
  5    43 	     2 header,
  5    44 	       3 arg_count	      fixed bin (17) unsigned unal,
  5    45 	       3 pad1	      bit (1) unal,
  5    46 	       3 call_type	      fixed bin (18) unsigned unal,
  5    47 	       3 desc_count	      fixed bin (17) unsigned unal,
  5    48 	       3 pad2	      bit (19) unal,
  5    49 	     2 arg_ptrs	      (arg_list_arg_count refer (arg_list_with_envptr.arg_count)) ptr,
  5    50 	     2 envptr	      ptr,
  5    51 	     2 desc_ptrs	      (arg_list_arg_count refer (arg_list_with_envptr.arg_count)) ptr;
  5    52 
  5    53 
  5    54      dcl	   (
  5    55 	   Quick_call_type	      init (0),
  5    56 	   Interseg_call_type     init (4),
  5    57 	   Envptr_supplied_call_type
  5    58 			      init (8)
  5    59 	   )		      fixed bin (18) unsigned unal int static options (constant);
  5    60 
  5    61 /* The user must declare arg_list_arg_count - if an adjustable automatic structure
  5    62*   is being "liked" then arg_list_arg_count may be a parameter, in order to allocate
  5    63*   an argument list of the proper size in the user's stack
  5    64*
  5    65**/
  5    66 /* END INCLUDE FILE ... arg_list.incl.pl1 */
      464 
      465    end dm_vu_append_simple_typed;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/17/86  0954.4  dm_vu_append_simple_typed.pl1     >spec>install>1220>dm_vu_append_simple_typed.pl1
456          1    10/14/83  1609.1  vu_typed_vector_array.incl.pl1    >ldd>include>vu_typed_vector_array.incl.pl1
458          2    10/14/83  1609.1  vu_typed_vector.incl.pl1          >ldd>include>vu_typed_vector.incl.pl1
460          3    01/12/79  1059.7  desc_types.incl.pl1               >ldd>include>desc_types.incl.pl1
462          4    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
464          5    08/05/86  0856.8  arg_list.incl.pl1                 >ldd>include>arg_list.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000041 constant        bit(36)                  initial dcl 4-7 set ref 232* 380*
AREA_IS_BIG_ENOUGH              000042 constant        fixed bin(35,0)          initial dcl 147 set ref 329* 338 350*
AREA_IS_TOO_SMALL               000047 constant        fixed bin(35,0)          initial dcl 147 set ref 255* 344 350*
AREA_PTR_ARG_IDX                       constant        fixed bin(17,0)          initial dcl 160 set ref 240*
BITS_PER_BYTE                          constant        fixed bin(35,0)          initial dcl 152 ref 274
BITS_PER_WORD                          constant        fixed bin(35,0)          initial dcl 152 ref 274 276
CODE_ARG_OFFSET_FROM_FUNCTION_END      constant        fixed bin(17,0)          initial dcl 160 ref 216
CODE_ARG_OFFSET_FROM_SUBROUTINE_END    constant        fixed bin(17,0)          initial dcl 160 ref 224
FREE_OLD_TVA_ARG_IDX                   constant        fixed bin(17,0)          initial dcl 160 set ref 251*
MYNAME                          000002 constant        varying char(40)         initial dcl 158 set ref 232* 380*
NO_NL                           000042 constant        bit(1)                   initial dcl 156 set ref 377*
NO_PAD                          000042 constant        bit(1)                   initial dcl 156 set ref 377*
NO_TYPE                         002424 constant        fixed bin(17,0)          initial dcl 160 ref 438
NUMBER_OF_NONVALUE_ARGS_AT_BEGINNING   constant        fixed bin(17,0)          initial dcl 160 ref 228 230 232 264 266 293
NUMBER_OF_NONVALUE_ARGS_AT_FUNCTION_END
                                       constant        fixed bin(17,0)          initial dcl 160 ref 217
NUMBER_OF_NONVALUE_ARGS_AT_SUBROUTINE_END
                                       constant        fixed bin(17,0)          initial dcl 160 ref 225
SIMPLE_TYPED_VECTOR_TYPE               constant        fixed bin(17,0)          initial dcl 2-43 ref 258
SLOT_INCREASE_ARG_IDX                  constant        fixed bin(17,0)          initial dcl 160 set ref 246*
TVA_PTR_ARG_OFFSET_FROM_FUNCTION_END   constant        fixed bin(17,0)          initial dcl 160 ref 215
TVA_PTR_ARG_OFFSET_FROM_SUBROUTINE_END constant        fixed bin(17,0)          initial dcl 160 ref 223
TYPED_VECTOR_ARRAY_VERSION_2           constant        fixed bin(35,0)          initial dcl 1-50 ref 313
addr                                                   builtin function         dcl 138 ref 380
addrel                                                 builtin function         dcl 138 ref 287 289
area                            000146 stack reference condition                dcl 143 ref 255
arg_count                              based           fixed bin(17,0)          level 3 packed unsigned unaligned dcl 5-14 ref 280
arg_idx                         000100 automatic       fixed bin(17,0)          dcl 88 set ref 266* 268* 269* 272* 280 282* 293*
arg_length                      000101 automatic       fixed bin(21,0)          initial dcl 89 set ref 89* 268*
arg_list                               based           structure                level 1 dcl 5-14
arg_list_arg_count              000102 automatic       fixed bin(17,0)          dcl 90 set ref 208*
arg_list_ptr                    000104 automatic       pointer                  initial dcl 91 set ref 91* 206* 207* 210* 238* 240*
                                                                                  242* 246* 251* 268* 272* 280 326*
arg_ptr                         000106 automatic       pointer                  initial dcl 92 set ref 92* 268* 287 289 291
bit_desc                        000000 constant        fixed bin(17,0)          initial dcl 3-1 set ref 251*
cleanup                         000154 stack reference condition                dcl 143 ref 236
code_arg_idx                    000110 automatic       fixed bin(17,0)          dcl 93 set ref 216* 224* 238*
cu_$arg_count_rel               000010 constant        entry                    external dcl 184 ref 207 369
cu_$arg_list_ptr                000012 constant        entry                    external dcl 185 ref 206 368
cu_$arg_ptr_rel                 000014 constant        entry                    external dcl 186 ref 268 374 449
data_format_util_$get_data_bit_length
                                000016 constant        entry                    external dcl 187 ref 280
decode_descriptor_              000020 constant        entry                    external dcl 189 ref 210 272 441
desc_ptrs                              based           pointer                  array level 2 dcl 5-14 ref 280
descriptor_string                      based           bit(36)                  dcl 120 set ref 280*
dim_idx                         000111 automatic       fixed bin(17,0)          dcl 94 set ref 301* 302*
dimension                 1            based           structure                array level 2 packed unaligned dcl 2-17
dimension_table           6            based           structure                array level 2 dcl 1-21 set ref 314* 314
dm_vector_util_$free_typed_vector
                                000022 constant        entry                    external dcl 190 ref 408
er_arg_list_ptr                 000102 automatic       pointer                  initial dcl 361 set ref 361* 368* 369* 374* 377*
er_based_msg                           based           char                     unaligned dcl 364 set ref 380*
er_code                         000104 automatic       fixed bin(35,0)          dcl 362 set ref 370* 375* 380*
er_msg                          000105 automatic       char(1024)               unaligned dcl 363 set ref 377* 380
er_msg_length                   000505 automatic       fixed bin(21,0)          initial dcl 365 set ref 365* 377* 380 380
er_nargs                        000506 automatic       fixed bin(17,0)          dcl 367 set ref 369* 370 377
er_p_code                              based           fixed bin(35,0)          dcl 360 ref 375
er_p_code_ptr                   000100 automatic       pointer                  initial dcl 359 set ref 359* 374* 375
error_table_$area_too_small     000030 external static fixed bin(35,0)          dcl 198 ref 347
error_table_$bad_subr_arg       000032 external static fixed bin(35,0)          dcl 198 set ref 350* 443*
error_table_$wrong_no_of_args   000034 external static fixed bin(35,0)          dcl 198 set ref 232*
free_old_typed_vector_array            based           bit(1)                   dcl 121 ref 386
free_old_typed_vector_array_ptr 000112 automatic       pointer                  initial dcl 95 set ref 95* 251* 386 386
gap_arg_len                     000230 automatic       fixed bin(21,0)          dcl 430 set ref 449*
gap_arg_ptr                     000226 automatic       pointer                  initial dcl 429 set ref 429* 449* 453
gap_code                        000231 automatic       fixed bin(35,0)          initial dcl 431 set ref 431* 449* 450 450*
gap_ndims                       000232 automatic       fixed bin(17,0)          dcl 432 set ref 441*
gap_p_arg_idx                          parameter       fixed bin(17,0)          dcl 425 set ref 422 441* 443* 449* 450*
gap_p_arg_list_ptr                     parameter       pointer                  dcl 424 set ref 422 441* 449*
gap_p_required_type                    parameter       fixed bin(17,0)          dcl 426 set ref 422 438 443 443*
gap_p_type_name                        parameter       char                     unaligned dcl 427 set ref 422 443*
gap_packed                      000233 automatic       bit(1)                   dcl 433 set ref 441*
gap_scale                       000234 automatic       fixed bin(17,0)          dcl 434 set ref 441*
gap_size                        000235 automatic       fixed bin(17,0)          dcl 435 set ref 441*
gap_type                        000236 automatic       fixed bin(17,0)          dcl 436 set ref 441* 443 443*
header                                 based           structure                level 2 dcl 5-14
ioa_$general_rs                 000024 constant        entry                    external dcl 192 ref 377
maximum_dimension_name_length
                          4            based           fixed bin(17,0)          level 2 dcl 1-21 set ref 309 312* 314 317 317 323
                                                                                  386 401 410 410
nargs                           000114 automatic       fixed bin(17,0)          dcl 97 set ref 207* 208 210* 214 215 216 223 224 228
                                                                                  230 232* 264 266
ndims                           000115 automatic       fixed bin(17,0)          dcl 98 set ref 210* 272*
null                                                   builtin function         dcl 138 ref 91 92 95 102 104 105 110 116 232 232 259
                                                                                  302 359 361 380 380 386 386 393 396 400 401 404
                                                                                  410 429
number_of_dimensions      0(18)        based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  unaligned dcl 2-17 in procedure
                                                                                  "dm_vu_append_simple_typed" set ref 257* 259 301
number_of_dimensions      1            based           fixed bin(17,0)          level 2 in structure "typed_vector_array" dcl 1-21
                                                                                  in procedure "dm_vu_append_simple_typed" set ref
                                                                                  253 310 312* 314 317 317 323 386 401 410 410
number_of_nonvalue_args_at_end  000116 automatic       fixed bin(17,0)          dcl 99 set ref 217* 225* 228 230 232 264 266
number_of_values_given          000117 automatic       fixed bin(35,0)          initial dcl 101 set ref 101* 264* 299* 301
number_of_vector_slots
                          3            based           fixed bin(17,0)          level 2 dcl 1-21 set ref 246 306 312* 386 401
number_of_vectors         2            based           fixed bin(17,0)          level 2 dcl 1-21 set ref 306 315* 315 316 322* 322
                                                                                  323 410 410 410
old_tva_ptr                     000120 automatic       pointer                  initial dcl 102 set ref 102* 311* 314 315 317 386
                                                                                  386 396 399 400*
p_code                                 based           fixed bin(35,0)          dcl 125 set ref 268* 269 269* 280* 282 282* 341*
                                                                                  347*
p_code_ptr                      000124 automatic       pointer                  initial dcl 104 set ref 104* 238* 268 269 269 280
                                                                                  282 282 341 347
p_typed_vector_array_ptr               based           pointer                  dcl 123 set ref 244 319* 399* 401 408* 410 410 410
                                                                                  410 410
p_typed_vector_array_ptr_ptr    000126 automatic       pointer                  initial dcl 105 set ref 105* 242* 244 319 393 399
                                                                                  401 408 410 410 410 410 410
packed                          000122 automatic       bit(1)                   dcl 103 set ref 210* 272*
pointer_desc                    000001 constant        fixed bin(17,0)          initial dcl 3-1 set ref 211 240* 242* 326*
ptr_template                           based           pointer                  dcl 126 set ref 240 326*
r_p_area_status                        parameter       fixed bin(35,0)          dcl 337 set ref 335 338 344 350*
s_fixed_real_desc                      constant        fixed bin(17,0)          initial dcl 3-1 set ref 238* 246*
s_fixed_real_template                  based           fixed bin(35,0)          dcl 127 ref 246
scale                           000130 automatic       fixed bin(17,0)          dcl 107 set ref 210* 272*
simple_typed_vector                    based           structure                level 1 packed unaligned dcl 2-17 set ref 257
simple_typed_vector_ptr         000170 automatic       pointer                  dcl 2-33 set ref 257* 258 259 293 301 302 323 326
                                                                                  404 408* 410
size                            000131 automatic       fixed bin(17,0)          dcl 108 set ref 210* 272* 274 276
storage_size                    000132 automatic       fixed bin(35,0)          dcl 109 set ref 274* 276* 280* 286 286 287 289 291
                                                                                  291
storage_string                         based           bit                      dcl 128 set ref 286 291* 291
storage_string_ptr              000134 automatic       pointer                  initial dcl 110 set ref 110* 286* 287 289 291 293
stv_number_of_dimensions        000172 automatic       fixed bin(17,0)          dcl 2-35 set ref 253* 257 257
sub_err_                        000026 constant        entry                    external dcl 194 ref 232 380
tv_ptr_arg_idx                  000137 automatic       fixed bin(17,0)          dcl 112 set ref 214* 221* 326 326*
tva_maximum_dimension_name_length
                                000166 automatic       fixed bin(17,0)          dcl 1-48 set ref 309* 312 312
tva_number_of_dimensions        000165 automatic       fixed bin(17,0)          dcl 1-46 set ref 310* 312 312
tva_number_of_vector_slots      000164 automatic       fixed bin(17,0)          dcl 1-44 set ref 246* 312 312
tva_ptr_arg_idx                 000140 automatic       fixed bin(17,0)          dcl 113 set ref 215* 223* 242*
type                                   based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  unaligned dcl 2-17 in procedure
                                                                                  "dm_vu_append_simple_typed" set ref 258*
type                            000141 automatic       fixed bin(17,0)          dcl 114 in procedure "dm_vu_append_simple_typed" set
                                                                                  ref 210* 211 272* 274 276 287 289
typed_vector_array                     based           structure                level 1 dcl 1-21 set ref 312 386 401
typed_vector_array_ptr          000162 automatic       pointer                  dcl 1-43 set ref 244* 246 253 306 306 309 310 311
                                                                                  312* 313 314 315 316 317 319 322 322 323 323 401
                                                                                  401 401
v_bit_desc                             constant        fixed bin(17,0)          initial dcl 3-1 ref 276 289
v_char_desc                            constant        fixed bin(17,0)          initial dcl 3-1 ref 274 287
value_ptr                 1            based           pointer                  array level 3 packed unaligned dcl 2-17 set ref 259*
                                                                                  293* 302*
values_given                    000136 automatic       bit(1)                   initial dcl 111 set ref 111* 228* 230* 261
varying_bit_storage_string             based           varying bit              dcl 129 set ref 289* 289
varying_char_storage_string            based           varying char             dcl 131 set ref 287* 287
vector_idx                      000142 automatic       fixed bin(17,0)          dcl 115 set ref 316* 317 317*
vector_slot                            based           pointer                  array level 2 dcl 1-21 set ref 317* 317 323* 410
                                                                                  410*
version                                based           fixed bin(35,0)          level 2 dcl 1-21 set ref 313*
work_area                              based           area(1024)               dcl 133 ref 257 286 312
work_area_ptr                   000144 automatic       pointer                  initial dcl 116 set ref 116* 240* 257 286 312 408*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 4-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 4-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 4-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 4-7
D_fixed_cplx_desc                      internal static fixed bin(17,0)          initial dcl 3-1
D_fixed_real_desc                      internal static fixed bin(17,0)          initial dcl 3-1
D_float_cplx_desc                      internal static fixed bin(17,0)          initial dcl 3-1
D_float_real_desc                      internal static fixed bin(17,0)          initial dcl 3-1
Envptr_supplied_call_type              internal static fixed bin(18,0)          initial unsigned unaligned dcl 5-54
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 2-43
Interseg_call_type                     internal static fixed bin(18,0)          initial unsigned unaligned dcl 5-54
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 2-43
Quick_call_type                        internal static fixed bin(18,0)          initial unsigned unaligned dcl 5-54
area_desc                              internal static fixed bin(17,0)          initial dcl 3-1
arg_list_with_envptr                   based           structure                level 1 dcl 5-42
char_desc                              internal static fixed bin(17,0)          initial dcl 3-1
command_name_arglist                   based           structure                level 1 dcl 5-25
d_fixed_cplx_desc                      internal static fixed bin(17,0)          initial dcl 3-1
d_fixed_real_desc                      internal static fixed bin(17,0)          initial dcl 3-1
d_float_cplx_desc                      internal static fixed bin(17,0)          initial dcl 3-1
d_float_real_desc                      internal static fixed bin(17,0)          initial dcl 3-1
entry_desc                             internal static fixed bin(17,0)          initial dcl 3-1
file_desc                              internal static fixed bin(17,0)          initial dcl 3-1
general_typed_vector                   based           structure                level 1 packed unaligned dcl 2-24
general_typed_vector_ptr               automatic       pointer                  dcl 2-38
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 2-40
label_desc                             internal static fixed bin(17,0)          initial dcl 3-1
offset_desc                            internal static fixed bin(17,0)          initial dcl 3-1
s_fixed_cplx_desc                      internal static fixed bin(17,0)          initial dcl 3-1
s_float_cplx_desc                      internal static fixed bin(17,0)          initial dcl 3-1
s_float_real_desc                      internal static fixed bin(17,0)          initial dcl 3-1
structure_desc                         internal static fixed bin(17,0)          initial dcl 3-1

NAMES DECLARED BY EXPLICIT CONTEXT.
ERROR_FINISH                    001701 constant        entry                    internal dcl 391 ref 236 348
ERROR_RETURN                    001433 constant        entry                    internal dcl 357 ref 269 282 350 443 450
FINISH                          001637 constant        entry                    internal dcl 384 ref 342
GET_ARG_PTR                     002036 constant        entry                    internal dcl 422 ref 238 240 242 246 251 326
MAIN_RETURN                     001345 constant        label                    dcl 331 ref 353
RETURN                          001347 constant        entry                    internal dcl 335 ref 255 329
dm_vu_append_simple_typed       000236 constant        entry                    external dcl 81

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2652        2710    2425        2662
Length      3232    2425        36         305     224           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
dm_vu_append_simple_typed           312 external procedure  is an external procedure.  
on unit on line 236                  64 on unit               
on unit on line 255                  70 on unit               
RETURN                              137 internal procedure  is called by several nonquick procedures.  
ERROR_RETURN                        386 internal procedure  is declared options(variable).  
FINISH                                  internal procedure  shares stack frame of internal procedure RETURN.  
ERROR_FINISH                         76 internal procedure  is called by several nonquick procedures.  
GET_ARG_PTR                             internal procedure  shares stack frame of external procedure dm_vu_append_simple_typed.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ERROR_RETURN             000100 er_p_code_ptr               ERROR_RETURN
                         000102 er_arg_list_ptr             ERROR_RETURN
                         000104 er_code                     ERROR_RETURN
                         000105 er_msg                      ERROR_RETURN
                         000505 er_msg_length               ERROR_RETURN
                         000506 er_nargs                    ERROR_RETURN
dm_vu_append_simple_typed
                         000100 arg_idx                     dm_vu_append_simple_typed
                         000101 arg_length                  dm_vu_append_simple_typed
                         000102 arg_list_arg_count          dm_vu_append_simple_typed
                         000104 arg_list_ptr                dm_vu_append_simple_typed
                         000106 arg_ptr                     dm_vu_append_simple_typed
                         000110 code_arg_idx                dm_vu_append_simple_typed
                         000111 dim_idx                     dm_vu_append_simple_typed
                         000112 free_old_typed_vector_array_ptr
                                                            dm_vu_append_simple_typed
                         000114 nargs                       dm_vu_append_simple_typed
                         000115 ndims                       dm_vu_append_simple_typed
                         000116 number_of_nonvalue_args_at_end
                                                            dm_vu_append_simple_typed
                         000117 number_of_values_given      dm_vu_append_simple_typed
                         000120 old_tva_ptr                 dm_vu_append_simple_typed
                         000122 packed                      dm_vu_append_simple_typed
                         000124 p_code_ptr                  dm_vu_append_simple_typed
                         000126 p_typed_vector_array_ptr_ptr
                                                            dm_vu_append_simple_typed
                         000130 scale                       dm_vu_append_simple_typed
                         000131 size                        dm_vu_append_simple_typed
                         000132 storage_size                dm_vu_append_simple_typed
                         000134 storage_string_ptr          dm_vu_append_simple_typed
                         000136 values_given                dm_vu_append_simple_typed
                         000137 tv_ptr_arg_idx              dm_vu_append_simple_typed
                         000140 tva_ptr_arg_idx             dm_vu_append_simple_typed
                         000141 type                        dm_vu_append_simple_typed
                         000142 vector_idx                  dm_vu_append_simple_typed
                         000144 work_area_ptr               dm_vu_append_simple_typed
                         000162 typed_vector_array_ptr      dm_vu_append_simple_typed
                         000164 tva_number_of_vector_slots  dm_vu_append_simple_typed
                         000165 tva_number_of_dimensions    dm_vu_append_simple_typed
                         000166 tva_maximum_dimension_name_length
                                                            dm_vu_append_simple_typed
                         000170 simple_typed_vector_ptr     dm_vu_append_simple_typed
                         000172 stv_number_of_dimensions    dm_vu_append_simple_typed
                         000226 gap_arg_ptr                 GET_ARG_PTR
                         000230 gap_arg_len                 GET_ARG_PTR
                         000231 gap_code                    GET_ARG_PTR
                         000232 gap_ndims                   GET_ARG_PTR
                         000233 gap_packed                  GET_ARG_PTR
                         000234 gap_scale                   GET_ARG_PTR
                         000235 gap_size                    GET_ARG_PTR
                         000236 gap_type                    GET_ARG_PTR

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this       call_int_other_desc call_int_other
return_mac          tra_ext_1           enable_op           ext_entry           int_entry           op_alloc_
op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$arg_count_rel             cu_$arg_list_ptr              cu_$arg_ptr_rel
data_format_util_$get_data_bit_length                       decode_descriptor_
dm_vector_util_$free_typed_vector                           ioa_$general_rs               sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$area_too_small   error_table_$bad_subr_arg     error_table_$wrong_no_of_args




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     81 000235        89 000243        91 000244        92 000246        95 000247       101 000250       102 000251
    104 000252       105 000253       110 000254       111 000255       116 000256       206 000257       207 000265
    208 000301       210 000303       211 000326       214 000331       215 000333       216 000335       217 000340
    218 000342       221 000343       223 000345       224 000350       225 000352       228 000354       230 000363
    232 000366       236 000444       238 000466       240 000475       242 000505       244 000512       246 000515
    251 000531       253 000540       255 000543       257 000567       258 000603       259 000606       261 000631
    264 000633       266 000641       268 000651       269 000670       272 000715       274 000740       276 000750
    280 000757       282 001003       286 001030       287 001037       289 001055       291 001072       293 001077
    296 001106       297 001110       299 001111       301 001112       302 001131       303 001140       306 001142
    309 001147       310 001151       311 001153       312 001154       313 001207       314 001211       315 001230
    316 001232       317 001241       318 001300       319 001302       322 001304       323 001305       326 001326
    329 001337       331 001345       335 001346       338 001354       341 001357       342 001361       343 001362
    344 001363       347 001365       348 001370       349 001375       350 001376       353 001427       357 001432
    359 001440       361 001442       365 001443       368 001444       369 001452       370 001466       374 001472
    375 001515       377 001517       380 001565       382 001636       384 001637       386 001640       389 001677
    391 001700       393 001706       396 001713       399 001717       400 001721       401 001723       404 001757
    408 001764       410 002002       420 002035       422 002036       429 002047       431 002051       438 002052
    441 002056       443 002101       449 002144       450 002164       453 002212


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
