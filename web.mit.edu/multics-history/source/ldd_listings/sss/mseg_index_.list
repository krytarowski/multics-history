	COMPILATION LISTING OF SEGMENT mseg_index_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 07/11/86  0916.9 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(85-05-30,Palter), approve(86-02-20,MCR7345),
       15*     audit(86-02-21,MSharpe), install(86-07-11,MR12.0-1092):
       16*     Verify proper real access to the segment as this particular check can`t be
       17*     postponed to the access kernel.  Without this check, a process whose
       18*     authorization is greater than the access class of a message segment would
       19*     take a no_write_permission fault when trying to perform most any operation
       20*     on the segment.
       21*     Also set mseg_operation.mseg_(index ptr)_valid to ""b inside
       22*     mseg_index_$close_seg upon removing the entry from the mseg_table and
       23*     termination of the segment.
       24*                                                   END HISTORY COMMENTS */
       25 
       26 
       27 /* format: style4,delnl,insnl,ifthenstmt,ifthen */
       28 
       29 mseg_index_:
       30      procedure;
       31 
       32 /*
       33*   Module of the primitive message segment facility which  initiates
       34*   and  terminates  a  message  segment  in the administrative ring,
       35*   matching the pointer to the message segment with a  unique  index
       36*   which is passed to and from the user ring.
       37**/
       38 
       39 
       40 /* Modified for version 3 message segments by J. Stern, 10/29/74 */
       41 /* Modified by Benson Margulies for conversion to unaligned character strings */
       42 /* Modified 1984-10-11 BIM to stop calling the admin gate. */
       43 /* Modified February 1985 by M. Pandolf to move access checking to kernel. */
       44 /* Modified 1985-04-17, BIM: return pointer for speed. */
       45 
       46 /* DECLARATIONS */
       47 /* ------------ */
       48 
       49 
       50 /* fixed bin */
       51 
       52 dcl  (
       53      i,
       54      mseg_index,					/* index to a given message segment (internal) */
       55      a_mseg_index					/* used by close */
       56      ) fixed bin aligned;
       57 
       58 dcl  (
       59      a_code,					/* error code (argument) */
       60      code init (0),					/* error code (internal) */
       61      code2,					/* another error code */
       62      error_table_$ai_restricted external,
       63      error_table_$bad_subr_arg external,
       64      error_table_$dirseg external,
       65      error_table_$not_seg_type external,
       66      error_table_$notalloc ext,
       67      error_table_$segknown ext,
       68      error_table_$seg_unknown ext
       69      ) fixed bin (35) aligned;
       70 
       71 
       72 /* pointers */
       73 
       74 dcl  (
       75      a_table_ptr,					/* ptr to mseg_ptr array (argument) */
       76      new_table_ptr,					/* ptr for re-allocating table */
       77      temp_mseg_ptr,					/* pointer to specific message segment */
       78      a_op_ptr
       79      ) ptr aligned;
       80 
       81 dcl  area_ptr ptr int static init (null);
       82 
       83 dcl  linker_area area based (area_ptr);
       84 
       85 
       86 /* character strings */
       87 
       88 dcl  dn char (168);
       89 dcl  en char (32);
       90 
       91 /* bit strings */
       92 
       93 dcl  effective_access bit (36) aligned;
       94 dcl  sys_info$ring1_privilege ext bit (36) aligned;
       95 
       96 /* built in functions */
       97 
       98 dcl  (addr, bit, null) builtin;
       99 
      100 /* external entries */
      101 
      102 dcl  admin_gate_$syserr entry (/* fixed binary, character (*) */) options (variable);
      103 dcl  get_user_free_area_ entry returns (ptr);
      104 dcl  hcs_$get_access_info_seg entry (ptr, ptr, fixed bin (35));
      105 dcl  hcs_$get_user_access_modes_seg
      106 	entry (ptr, char (*), fixed bin (3), bit (36) aligned, bit (36) aligned, fixed bin (35));
      107 dcl  hcs_$initiate entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
      108 dcl  hcs_$terminate_noname ext entry (ptr aligned, fixed bin (35) aligned);
      109 dcl  pathname_ entry (char (*), char (*)) returns (char (168));
      110 dcl  sub_err_ entry () options (variable);
      111 dcl  system_privilege_$initiate ext
      112 	entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
      113 
      114 /* conditions */
      115 
      116 dcl  area condition;
      117 
      118 /**** This entrypoint is called to get a pointer, but not to record
      119*      in the table of open segments. That recording only happens
      120*      if the user has access. */
      121 
      122 mseg_index_$initiate_seg:
      123      entry (a_op_ptr, a_code);
      124 
      125 	mseg_operation_ptr = a_op_ptr;
      126 	if ^mseg_operation.mseg_pathname_valid then
      127 	     call sub_err_ (error_table_$bad_subr_arg, "mseg_$initiate_seg", ACTION_CANT_RESTART, null (), (0),
      128 		"The mseg_operation does not include a valid pathname.");
      129 
      130 	dn = mseg_operation.dir_name;
      131 	en = mseg_operation.entryname;
      132 
      133 	if mseg_operation.caller.privileges & sys_info$ring1_privilege then
      134 	     call system_privilege_$initiate (dn, en, "", 0, 1, temp_mseg_ptr, code2);
      135 	else call hcs_$initiate (dn, en, "", 0, 1, temp_mseg_ptr, code2);
      136 						/* initiate message segment */
      137 	if temp_mseg_ptr = null then do;		/* did not get back a pointer */
      138 	     if code2 = error_table_$dirseg then
      139 		code = error_table_$not_seg_type;
      140 	     else code = code2;
      141 	     go to RETURN;
      142 	end;
      143 
      144 	mseg_operation.mseg_ptr = temp_mseg_ptr;
      145 	mseg_operation.mseg_ptr_valid = "1"b;
      146 
      147 	if mseg_operation.suppress_access_checks then go to RETURN;
      148 
      149 /**** We must fetch the segment's access_info here in order to validate
      150*      that we have RW real effective access to the segment.  We can't delay
      151*      this check to the mseg_check_access_ kernal as there is at least
      152*      one gate target (mailbox_$accept_wakeups_index) which performs an
      153*      mseg_ operation before calling mseg_check_access_.  Since the mseg_
      154*      operation has to lock the segment, if we don't have the proper real
      155*      access, we would take a fault in ring 1 which isn't very nice.
      156*
      157*      If the user doesn't have RW effective access, we must determine the
      158*      appropriate error code to return.  If the segment's ring brackets
      159*      are incorrect, we'll return error_table_$not_seg_type.  If we lack
      160*      the needed access due to AIM, we'll return error_table_$ai_restricted.
      161*      If, however, we lack the access due to an incorrect real mode in the ACL,
      162*      we enter a SYSERR message and stop the user dead by calling sub_err_.
      163*      In truth, we would prefer to invoke an ACL salvager in this case but,
      164*      as one does not exist, we stop our caller as any error code we might
      165*      return would be misleading. */
      166 
      167 	call hcs_$get_access_info_seg (temp_mseg_ptr, addr (mseg_operation.access_info), code);
      168 	if code ^= 0 then do;
      169 ACCESS_CHECK_FAILED:
      170 	     call hcs_$terminate_noname (temp_mseg_ptr, (0));
      171 	     mseg_operation.mseg_ptr_valid = "0"b;	/* the pointer's not usefull if the access isn't right */
      172 	     go to RETURN;
      173 	end;
      174 
      175 	mseg_operation.access_info_valid = "1"b;
      176 
      177 	if (mseg_operation.access_info.effective_access_modes & RW_ACCESS) ^= RW_ACCESS then do;
      178 
      179 	     do i = 1 to 3;				/* check that the ring brackets are OK */
      180 		if mseg_operation.access_info.ring_brackets (i) ^= mseg_data_$execution_ring then do;
      181 		     code = error_table_$not_seg_type;
      182 		     go to ACCESS_CHECK_FAILED;
      183 		end;
      184 	     end;
      185 
      186 	     call hcs_$get_user_access_modes_seg (temp_mseg_ptr, "" /* ourself */, -1 /* this ring */, effective_access,
      187 		((36)"0"b), code);
      188 	     if code ^= 0 then go to ACCESS_CHECK_FAILED;
      189 
      190 	     if (effective_access & RW_ACCESS) ^= RW_ACCESS then do;
      191 		/*** The ACL term by which the user received his access to
      192*		     the segment does not grant RW access. */
      193 		if mseg_operation.call_admin_gate then
      194 		     call admin_gate_$syserr ((SYSERR_LOG_OR_DISCARD + SYSERR_RING1_ERROR),
      195 			"mseg_$initiate_seg: The ACL for ^a is inconsistent -- ^a does not have ""rw"" access.",
      196 			pathname_ (mseg_operation.access_info.dir_name, mseg_operation.access_info.entryname),
      197 			mseg_operation.caller.group_id);
      198 		call sub_err_ (0, "mseg_$initiate_seg", ACTION_CANT_RESTART, null (), 0,
      199 		     "The ACL for ^a is inconsistent -- you do not have ""rw"" access.",
      200 		     pathname_ (mseg_operation.access_info.dir_name, mseg_operation.access_info.entryname));
      201 	     end;
      202 
      203 	     /*** Control arrives here only when the reason we lack proper
      204*		access is due to AIM as, when AIM was ignored, we had
      205*		the necessary access. */
      206 
      207 	     code = error_table_$ai_restricted;
      208 	     go to ACCESS_CHECK_FAILED;
      209 	end;
      210 
      211 	code = 0;					/* success */
      212 
      213 	go to RETURN;
      214 
      215 /**** This is called only for the real gate open entrypoint
      216*      to insert the segment in the table. */
      217 
      218 mseg_index_$open_seg:
      219      entry (a_op_ptr, a_table_ptr, a_code);
      220 
      221 	mseg_operation_ptr = a_op_ptr;
      222 	table_ptr = a_table_ptr;
      223 
      224 	if ^mseg_operation.mseg_ptr_valid then
      225 	     call sub_err_ (error_table_$bad_subr_arg, "mseg_$open_seg", ACTION_CANT_RESTART, null (), (0),
      226 		"The mseg_operation does not include a valid mseg_ptr.");
      227 
      228 	on condition (area)
      229 	     begin;
      230 	     code = error_table_$notalloc;
      231 	     go to RETURN;
      232 	end;
      233 
      234 	if table_ptr = null then do;
      235 	     call allocate_table;
      236 	     a_table_ptr = table_ptr;
      237 	end;
      238 
      239 	temp_mseg_ptr = mseg_operation.mseg_ptr;
      240 
      241 /* See if already open */
      242 
      243 	do mseg_index = 1 to mseg_table.table_length while (mseg_table.mseg_ptr (mseg_index) ^= temp_mseg_ptr);
      244 	end;
      245 
      246 	if mseg_index <= mseg_table.table_length then go to FOUND_INDEX;
      247 
      248 /* Find an unused slot in the table */
      249 
      250 	do mseg_index = 1 to mseg_table.table_length while (mseg_table.mseg_ptr (mseg_index) ^= null);
      251 	end;
      252 
      253 	if mseg_index > mseg_table.table_length then do;	/* table full */
      254 	     call grow_table;
      255 	     a_table_ptr = table_ptr;
      256 	end;
      257 
      258 FOUND_INDEX:
      259 	mseg_table.mseg_ptr (mseg_index) = temp_mseg_ptr; /* remember pointer */
      260 	mseg_table.ref_count (mseg_index) = mseg_table.ref_count (mseg_index) + 1;
      261 						/* increment reference count */
      262 	mseg_operation.mseg_index = mseg_index;
      263 	mseg_operation.mseg_index_valid = "1"b;
      264 	go to RETURN;
      265 
      266 /**** This entrypoint both removes the index from the table
      267*      and terminates the segment. Since there is a null ref name
      268*      added per index ref count, we always terminate off a name.
      269*
      270*      For convienience, this will also operate correctly when
      271*      the index is invalid, indicating that the segment just
      272*      needs terminating */
      273 
      274 mseg_index_$close_seg:
      275      entry (a_op_ptr, a_table_ptr, a_code);
      276 
      277 	mseg_operation_ptr = a_op_ptr;
      278 
      279 	code = 0;
      280 
      281 	if mseg_operation.mseg_index_valid then do;
      282 	     mseg_index = mseg_operation.mseg_index;
      283 	     table_ptr = a_table_ptr;
      284 
      285 	     if table_ptr = null then do;
      286 UNKNOWN:
      287 		code = error_table_$seg_unknown;
      288 		go to RETURN;
      289 	     end;
      290 
      291 	     if mseg_index < 1 | mseg_index > mseg_table.table_length then go to UNKNOWN;
      292 
      293 	     if mseg_table.mseg_ptr (mseg_index) = null then go to UNKNOWN;
      294 
      295 	     mseg_table.ref_count (mseg_index) = mseg_table.ref_count (mseg_index) - 1;
      296 						/* decrement reference count */
      297 	     if mseg_table.ref_count (mseg_index) = 0 then mseg_table.mseg_ptr (mseg_index) = null;
      298 						/* remove ptr from table */
      299 
      300 	     mseg_operation.mseg_index_valid = "0"b;
      301 	end;
      302 
      303 	if mseg_operation.mseg_ptr_valid then do;
      304 	     temp_mseg_ptr = mseg_operation.mseg_ptr;
      305 	     call hcs_$terminate_noname (temp_mseg_ptr, code2);
      306 						/* terminate the message segment */
      307 	     mseg_operation.mseg_ptr_valid = "0"b;
      308 	end;
      309 
      310 RETURN:
      311 	a_code = code;				/* return error code */
      312 	return;
      313 
      314 mseg_index_$delete:
      315      entry (a_op_ptr, a_table_ptr);
      316 
      317 
      318 	mseg_operation_ptr = a_op_ptr;
      319 
      320 	if mseg_operation.mseg_ptr_valid then do;
      321 	     temp_mseg_ptr = mseg_operation.mseg_ptr;
      322 	     table_ptr = a_table_ptr;
      323 
      324 	     if table_ptr = null then return;
      325 
      326 	     do mseg_index = 1 to mseg_table.table_length;
      327 		if mseg_table.mseg_ptr (mseg_index) = temp_mseg_ptr then do;
      328 		     mseg_table.mseg_ptr (mseg_index) = null ();
      329 		     mseg_table.ref_count (mseg_index) = 0;
      330 		     return;
      331 		end;
      332 	     end;
      333 	end;
      334 
      335 	return;
      336 
      337 allocate_table:
      338      proc;
      339 
      340 /* This internal procedure allocates mseg_table in the ring 1 linker area segment. */
      341 
      342 	if area_ptr = null () then area_ptr = get_user_free_area_ ();
      343 
      344 	tlength = 100;
      345 
      346 	allocate mseg_table in (linker_area) set (table_ptr);
      347 
      348 	do i = 1 to tlength;
      349 	     mseg_table.mseg_ptr (i) = null;
      350 	     mseg_table.ref_count (i) = 0;
      351 	end;
      352 
      353      end allocate_table;
      354 
      355 
      356 grow_table:
      357      procedure;
      358 
      359 /* This internal procedure doubles mseg_table's size, changing table_ptr and
      360*   setting mseg_index to the next available slot. */
      361 
      362 	mseg_index = mseg_table.table_length + 1;
      363 	tlength = mseg_table.table_length * 2;
      364 	allocate mseg_table in (linker_area) set (new_table_ptr);
      365 
      366 	do i = 1 to mseg_index - 1;
      367 	     new_table_ptr -> mseg_table.mseg_ptr (i) = table_ptr -> mseg_table.mseg_ptr (i);
      368 	     new_table_ptr -> mseg_table.ref_count (i) = table_ptr -> mseg_table.ref_count (i);
      369 	end;
      370 
      371 	free table_ptr -> mseg_table in (linker_area);
      372 	table_ptr = new_table_ptr;
      373 
      374 	do i = mseg_index to mseg_table.table_length;
      375 	     mseg_table.mseg_ptr (i) = null;
      376 	     mseg_table.ref_count (i) = 0;
      377 	end;
      378 
      379      end grow_table;
      380 
      381 /* format: off */
      382  /* Begin include file mseg_index_table.incl.pl1 BIM 1985-04-17 */
  1     2 /* format: style4,linecom */
  1     3 
  1     4 
  1     5 dcl  table_ptr pointer;
  1     6 dcl  1 mseg_table aligned based (table_ptr),		/* table of open message segments */
  1     7        2 table_length fixed bin,
  1     8        2 table (tlength refer (mseg_table.table_length)) aligned,
  1     9          3 mseg_ptr ptr unaligned,
  1    10          3 ref_count fixed bin;
  1    11 
  1    12 declare tlength fixed bin;
  1    13 
  1    14 /* End include file mseg_index_table.incl.pl1 */
      382 
      383  /* BEGIN INCLUDE FILE ... mseg_operation.incl.pl1 */
  2     2 
  2     3 /* format: style3,idind30,linecom */
  2     4 
  2     5 /**** Created 1985-04-16, BIM: from Pandolf's  mseg_access_operation */
  2     6 
  2     7 /**** NOTES:
  2     8*      The caller of mseg_ must set mseg_operation.access_operation to record
  2     9*      the type of access checking it has performed and which mseg_ should
  2    10*      perform when needed (i.e., for those entrypoints which operate on
  2    11*      messages like mseg_$read_message).
  2    12*
  2    13*      mseg_operation.operation is reserved explicitly for use by mseg_ and
  2    14*      its underlying modules.
  2    15*
  2    16*      You must also include entry_access_info, mseg_message_info, and
  2    17*      mbx_wakeup_state along with this include file. */
  2    18 
  2    19 dcl	mseg_operation_ptr		pointer;
  2    20 dcl	MSEG_OPERATION_VERSION_1	fixed bin internal static options (constant) init (1);
  2    21 dcl	MSEG_TYPE_MBX		fixed bin init (1) internal static options (constant);
  2    22 dcl	MSEG_TYPE_MS		fixed bin init (2) internal static options (constant);
  2    23 
  2    24 dcl	1 mseg_operation		based (mseg_operation_ptr) aligned,
  2    25 	  2 version		fixed binary,	/* current version is MSEG_OPERATION_VERSION_1 */
  2    26 	  2 type			fixed binary,	/* MBX or MS */
  2    27 	  2 access_operation	fixed binary,	/* type of access checks required for the operation */
  2    28 	  2 operation		bit (36) aligned,	/* for use by mseg_ and underlying modules */
  2    29 	  2 caller		aligned,		/* always collected in gate target */
  2    30 	    3 validation_level	fixed bin (3),
  2    31 	    3 privileges		bit (18) aligned,	/* factored for speed */
  2    32 	    3 pad_align_double	fixed bin (71),	/* just to force alignment */
  2    33 	    3 authorization		bit (72) aligned,	/* must be 2word aligned */
  2    34 	    3 max_authorization	bit (72) aligned,
  2    35 	    3 group_id		char (32) unaligned,
  2    36 	  2 flags			aligned,
  2    37 	    3 mseg_pathname_valid	bit (1) unaligned,
  2    38 	    3 mseg_ptr_valid	bit (1) unaligned,
  2    39 	    3 mseg_index_valid	bit (1) unaligned,
  2    40 	    3 access_info_valid	bit (1) unaligned,
  2    41 	    3 md_ptr_valid		bit (1) unaligned,
  2    42 	    3 message_info_valid	bit (1) unaligned,	/* note -- for some operations not all fields are used */
  2    43 	    3 wakeup_state_valid	bit (1) unaligned,
  2    44 	    3 suppress_access_checks	bit (1) unaligned,	/* set by privileged interfaces, suppresses ALL access checking */
  2    45 	    3 call_admin_gate	bit (1) unaligned,	/* we is in ring 1, boss */
  2    46 	    3 only_own_access	bit (1) unaligned,	/* the user had o rather than r/d */
  2    47 	    3 add_message_info_all_valid
  2    48 				bit (1) unaligned,	/* Believe ALL the fields in message info on an add */
  2    49 	    3 pad			bit (24) unaligned,
  2    50 	  2 dir_name		char (168) unaligned,
  2    51 	  2 entryname		char (32) unaligned,
  2    52 	  2 mseg_ptr		pointer,
  2    53 	  2 md_ptr		pointer,		/* message descriptor */
  2    54 	  2 mseg_index		fixed bin,
  2    55 	  2 access_info		aligned like entry_access_info,
  2    56 	  2 message_info		aligned like mseg_message_info,
  2    57 	  2 wakeup_state		aligned like mseg_wakeup_state;
  2    58 
  2    59 /* END INCLUDE FILE ... mseg_operation.incl.pl1 */
      383 
      384  /* BEGIN INCLUDE FILE . . . mseg_message_info.incl.pl1 BIM 1984-10-10 */
  3     2 /* format: style3,idind30 */
  3     3 
  3     4 /* structure returned when message is read from a message segment */
  3     5 
  3     6 
  3     7 dcl	mseg_message_info_ptr	pointer;
  3     8 
  3     9 dcl	1 mseg_message_info		based (mseg_message_info_ptr) aligned,
  3    10 	  2 version		char (8) aligned,
  3    11 	  2 message_code		fixed bin,
  3    12 	  2 control_flags		unaligned,
  3    13 	    3 own			bit (1),
  3    14 	    3 delete		bit (1),
  3    15 	    3 pad			bit (34),
  3    16 	  2 ms_ptr		ptr,		/* pointer to message */
  3    17 	  2 ms_len		fixed bin (24),	/* length of message  in bits */
  3    18 	  2 ms_id			bit (72),		/* unique ID of message */
  3    19 						/* input in some cases */
  3    20 	  2 ms_access_class		bit (72),		/* message access class */
  3    21 	  2 sender_id		char (32) unaligned,/* process-group ID of sender */
  3    22 	  2 sender_process_id	bit (36) aligned,	/* if nonzero, process that sent */
  3    23 	  2 sender_level		fixed bin,	/* validation level of sender */
  3    24 	  2 sender_authorization	bit (72),		/* access authorization of message sender */
  3    25 	  2 sender_max_authorization	bit (72),		/* max authorization of sending process */
  3    26 	  2 sender_audit		bit (36) aligned;   /* audit flags */
  3    27 
  3    28 declare	MSEG_MESSAGE_INFO_V1	char (8) aligned init ("msegmi01") int static options (constant);
  3    29 
  3    30 declare	(
  3    31 	MSEG_READ_FIRST		init (1),
  3    32 	MSEG_READ_LAST		init (2),
  3    33 	MSEG_READ_SPECIFIED		init (3),
  3    34 	MSEG_READ_BEFORE_SPECIFIED	init (4),
  3    35 	MSEG_READ_AFTER_SPECIFIED	init (5))
  3    36 	fixed bin int static options (constant);
  3    37 
  3    38 declare  (MSEG_READ_OWN		init ("1"b),
  3    39 	MSEG_READ_DELETE		init ("01"b)
  3    40 	)			bit (36) aligned internal static options (constant);
  3    41 
  3    42 /* END INCLUDE FILE . . . mseg_message_info.incl.pl1 */
      384 
      385  /* BEGIN INCLUDE FILE ... entry_access_info.incl.pl1 */
  4     2 
  4     3 /*
  4     4*   Written  03/22/85 by M. Pandolf
  4     5*   Modified 1985-04-19, BIM: added parent access class.
  4     6**/
  4     7 
  4     8 dcl  entry_access_info_ptr pointer;
  4     9 dcl  ENTRY_ACCESS_INFO_VERSION_1 char (8) internal static options (constant)
  4    10      init ("eainf001");
  4    11 
  4    12 dcl 1 entry_access_info aligned based (entry_access_info_ptr),
  4    13     2 version char (8),				/* = ENTRY_ACCESS_INFO_VERSION_1 */
  4    14     2 type fixed bin,				/* see status_structures.incl.pl1 */
  4    15     2 dir_name char (168) unaligned,			/* parent of this entry */
  4    16     2 entryname char (32) unaligned,			/* primary name of this entry */
  4    17     2 uid bit (36) aligned,				
  4    18     2 ring_brackets (3) fixed bin (3),			/* for dirs, the dir ring brackets are here */
  4    19     2 extended_ring_brackets (3) fixed bin (3),		/* not-yet-implemented x-rb's */
  4    20     2 effective_access_modes bit (36) aligned,		/* for dirs, dir mode is here */
  4    21     2 extended_access_modes bit (36) aligned,		/* always null for dirs */
  4    22     2 access_class bit (72) aligned,			/* for multiclass, max access class */
  4    23     2 parent_access_class bit (72) aligned,		/* for multiclass, this is effectively the min access class */
  4    24     2 multiclass bit (1) aligned;
  4    25 
  4    26 /* END INCLUDE FILE ... entry_access_info.incl.pl1 */
      385 
      386  /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  5     2 /* format: style3 */
  5     3 
  5     4 /* These constants are to be used for the flags argument of sub_err_ */
  5     5 /* They are just "string (condition_info_header.action_flags)" */
  5     6 
  5     7 declare	(
  5     8 	ACTION_CAN_RESTART	init (""b),
  5     9 	ACTION_CANT_RESTART init ("1"b),
  5    10 	ACTION_DEFAULT_RESTART
  5    11 			init ("01"b),
  5    12 	ACTION_QUIET_RESTART
  5    13 			init ("001"b),
  5    14 	ACTION_SUPPORT_SIGNAL
  5    15 			init ("0001"b)
  5    16 	)		bit (36) aligned internal static options (constant);
  5    17 
  5    18 /* End include file */
      386 
      387  /* BEGIN INCLUDE FILE ... mseg_wakeup_state.incl.pl1 */
  6     2 /* Created:  April 1985 by G. Palter */
  6     3 
  6     4 /* format: style3,linecom */
  6     5 
  6     6 /* Description of the wakeup state of a message segment --
  6     7*
  6     8*   The wakeup state defines which process, if any, is willing to receive normal or urgent IPC wakeups when a message which
  6     9*   requests such a wakeup is added to a message segment.  The process is allowed to separately accept or defer normal and
  6    10*   urgent wakeups.  Note that deferring a wakeup is not the same as not accepting wakeups.  A process is not allowed to
  6    11*   stop accepting wakeups once it has accepted them as to do so would introduce a relatively high badnwidth covert
  6    12*   channel.  (In the present implementation, urgent wakeups are really no different from normal wakeups.  Eventually,
  6    13*   urgent wakeups should be implemented using an IPS signal along with the IPC wakeup).
  6    14*
  6    15*   mseg_$get_wakeup_state_seg requires that the caller supply the proper value for mseg_wakeup_state.version in the
  6    16*   mseg_operation.  If there is no wakeup state recorded in the message segment, mseg_$get_wakeup_state_seg will return
  6    17*   the status code error_table_$messages_off.
  6    18*
  6    19*   mseg_$set_wakeup_state_seg ignores the values of the access_class, process_id, and lock_id elements supplied by the
  6    20*   caller in the mseg_operation.  mseg_$set_wakeup_state_seg will, instead, furnish the values of the process making the
  6    21*   call for these elements and will return these values to its caller.  In other words, mseg_$set_wakeup_state_seg can not
  6    22*   be used by one process to accept/defer wakeups on behalf of another process. */
  6    23 
  6    24 declare	1 mseg_wakeup_state aligned based (mseg_wakeup_state_ptr),
  6    25 	  2 version	character (8) unaligned,
  6    26 	  2 flags		aligned,
  6    27 	    3 accepting_normal_wakeups		/* ON => process has accepted normal wakeups */
  6    28 			bit (1) unaligned,		/* OFF => process has deferred normal wakeups */
  6    29 	    3 accepting_urgent_wakeups		/* ON => process has accepted urgent wakeups */
  6    30 			bit (1) unaligned,		/* OFF => process has deferred urgent wakeups */
  6    31 	    3 pad		bit (34) unaligned,
  6    32 	  2 pad		bit (36) aligned,
  6    33 	  2 event_channel	fixed binary (71),		/* IPC event channel on which to send normal/urgent wakeups */
  6    34 	  2 access_class	bit (72) aligned,		/* AIM access class of the process accepting wakeups */
  6    35 	  2 process_id	bit (36) aligned,		/* ID of the process accepting wakeups */
  6    36 	  2 lock_id	bit (36) aligned;		/* lock ID used to test if said process is still alive */
  6    37 
  6    38 declare	mseg_wakeup_state_ptr
  6    39 			pointer;
  6    40 
  6    41 declare	MSEG_WAKEUP_STATE_VERSION_1
  6    42 			character (8) static options (constant) initial ("msegwkp1");
  6    43 
  6    44 /* END INCLUDE FILE ... mseg_wakeup_state.incl.pl1 */
      387 
      388  /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  7     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  7     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  7     4 
  7     5 /* This include file has an ALM version.  Keep 'em in sync! */
  7     6 
  7     7 dcl (
  7     8 
  7     9 /* The following constants define the message action codes.  This indicates
  7    10*how a message is to be handled.  */
  7    11 
  7    12      SYSERR_CRASH_SYSTEM	init (1),			
  7    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  7    14 
  7    15      SYSERR_TERMINATE_PROCESS	init (2),
  7    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  7    17 
  7    18      SYSERR_PRINT_WITH_ALARM	init (3),
  7    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  7    20 
  7    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  7    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  7    23 
  7    24      SYSERR_LOG_OR_PRINT	init (4),
  7    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  7    26 
  7    27      SYSERR_LOG_OR_DISCARD	init (5),
  7    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  7    29 
  7    30 
  7    31 /* The following constants are added to the normal severities to indicate
  7    32*different sorting classes of messages.  */
  7    33 
  7    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  7    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  7    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  7    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  7    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  7    39 	) fixed bin internal static options (constant);
  7    40 
  7    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      388 
      389  /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  8     2*
  8     3*   Values for the "access mode" argument so often used in hardcore
  8     4*   James R. Davis 26 Jan 81  MCR 4844
  8     5*   Added constants for SM access 4/28/82 Jay Pattin
  8     6*   Added text strings 03/19/85 Chris Jones
  8     7**/
  8     8 
  8     9 
  8    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  8    11 dcl	(
  8    12 	N_ACCESS		   init ("000"b),
  8    13 	R_ACCESS		   init ("100"b),
  8    14 	E_ACCESS		   init ("010"b),
  8    15 	W_ACCESS		   init ("001"b),
  8    16 	RE_ACCESS		   init ("110"b),
  8    17 	REW_ACCESS	   init ("111"b),
  8    18 	RW_ACCESS		   init ("101"b),
  8    19 	S_ACCESS		   init ("100"b),
  8    20 	M_ACCESS		   init ("010"b),
  8    21 	A_ACCESS		   init ("001"b),
  8    22 	SA_ACCESS		   init ("101"b),
  8    23 	SM_ACCESS		   init ("110"b),
  8    24 	SMA_ACCESS	   init ("111"b)
  8    25 	)		   bit (3) internal static options (constant);
  8    26 
  8    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  8    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  8    29 
  8    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  8    31 			   static options (constant);
  8    32 
  8    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  8    34 			   static options (constant);
  8    35 
  8    36 dcl	(
  8    37 	N_ACCESS_BIN	   init (00000b),
  8    38 	R_ACCESS_BIN	   init (01000b),
  8    39 	E_ACCESS_BIN	   init (00100b),
  8    40 	W_ACCESS_BIN	   init (00010b),
  8    41 	RW_ACCESS_BIN	   init (01010b),
  8    42 	RE_ACCESS_BIN	   init (01100b),
  8    43 	REW_ACCESS_BIN	   init (01110b),
  8    44 	S_ACCESS_BIN	   init (01000b),
  8    45 	M_ACCESS_BIN	   init (00010b),
  8    46 	A_ACCESS_BIN	   init (00001b),
  8    47 	SA_ACCESS_BIN	   init (01001b),
  8    48 	SM_ACCESS_BIN	   init (01010b),
  8    49 	SMA_ACCESS_BIN	   init (01011b)
  8    50 	)		   fixed bin (5) internal static options (constant);
  8    51 
  8    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      389 
      390  /* Begin include file mseg_data_.incl.pl1 BIM 1985-04-15 */
  9     2 /* format: style4 */
  9     3 
  9     4 declare  mseg_data_$lock_id bit (72) aligned external;
  9     5 declare  mseg_data_$block_size fixed bin (35) ext static;
  9     6 declare  mseg_data_$max_message_size fixed bin (35) ext static;
  9     7 declare  mseg_data_$template_operation bit (36) aligned external static; /* like mseg_operation */
  9     8 declare  mseg_data_$admin_ring fixed binary (3) external;
  9     9 declare  mseg_data_$execution_ring fixed bin (3) ext static;
  9    10 declare  mseg_data_$process_max_authorization bit (72) aligned ext static;
  9    11 declare  mseg_data_$group_id char (32) unaligned external static;
  9    12 
  9    13 /* End include file mseg_data_.incl.pl1 */
      390 
      391 
      392 
      393 /* BEGIN MESSAGE DOCUMENTATION
      394*
      395*
      396*   Message:
      397*   mseg_$initiate_seg: The ACL for PATH is inconsistent -- USER_ID does not
      398*	have "rw" access.
      399*
      400*   S:	$log
      401*
      402*   T:	$run
      403*
      404*   M:	$err
      405*	For proper operation of the message segment primitives, all ACL terms
      406*	of a message segment or mailbox must specify "rw" access to the
      407*	segment when running in ring 1.  One or more ACL terms for the
      408*	segment PATH do not provide the required access.  USER_ID identifies
      409*	one of the user whose access to the segment is incorrect.
      410*
      411*   A:	$inform
      412*
      413*
      414*   END MESSAGE DOCUMENTATION */
      415 
      416 /* format: on */
      417 
      418      end mseg_index_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/11/86  0914.1  mseg_index_.pl1                   >special_ldd>install>MR12.0-1092>mseg_index_.pl1
382          1    05/17/85  0615.6  mseg_index_table.incl.pl1         >ldd>include>mseg_index_table.incl.pl1
383          2    05/17/85  0615.6  mseg_operation.incl.pl1           >ldd>include>mseg_operation.incl.pl1
384          3    01/10/85  2002.8  mseg_message_info.incl.pl1        >ldd>include>mseg_message_info.incl.pl1
385          4    05/17/85  0615.5  entry_access_info.incl.pl1        >ldd>include>entry_access_info.incl.pl1
386          5    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
387          6    05/17/85  0615.7  mseg_wakeup_state.incl.pl1        >ldd>include>mseg_wakeup_state.incl.pl1
388          7    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
389          8    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
390          9    05/17/85  0619.0  mseg_data_.incl.pl1               >ldd>include>mseg_data_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000006 constant        bit(36)                  initial dcl 5-7 set ref 126* 198* 224*
RW_ACCESS                              constant        bit(3)                   initial unaligned dcl 8-11 ref 177 177 190 190
SYSERR_LOG_OR_DISCARD                  constant        fixed bin(17,0)          initial dcl 7-7 ref 193
SYSERR_RING1_ERROR                     constant        fixed bin(17,0)          initial dcl 7-7 ref 193
a_code                                 parameter       fixed bin(35,0)          dcl 58 set ref 122 218 274 310*
a_op_ptr                               parameter       pointer                  dcl 74 ref 122 125 218 221 274 277 314 318
a_table_ptr                            parameter       pointer                  dcl 74 set ref 218 222 236* 255* 274 283 314 322
access_info             115            based           structure                level 2 dcl 2-24 set ref 167 167
access_info_valid        24(03)        based           bit(1)                   level 3 packed unaligned dcl 2-24 set ref 175*
addr                                                   builtin function         dcl 98 ref 167 167
admin_gate_$syserr              000030 constant        entry                    external dcl 102 ref 193
area                            000174 stack reference condition                dcl 116 ref 228
area_ptr                        000010 internal static pointer                  initial dcl 81 set ref 342 342* 346 364 371
call_admin_gate          24(08)        based           bit(1)                   level 3 packed unaligned dcl 2-24 ref 193
caller                    4            based           structure                level 2 dcl 2-24
code                            000102 automatic       fixed bin(35,0)          initial dcl 58 set ref 58* 138* 140* 167* 168 181*
                                                                                  186* 188 207* 211* 230* 279* 286* 310
code2                           000103 automatic       fixed bin(35,0)          dcl 58 set ref 133* 135* 138 140 305*
dir_name                 25            based           char(168)                level 2 in structure "mseg_operation" packed
                                                                                  unaligned dcl 2-24 in procedure "mseg_index_" ref
                                                                                  130
dir_name                120            based           char(168)                level 3 in structure "mseg_operation" packed
                                                                                  unaligned dcl 2-24 in procedure "mseg_index_" set
                                                                                  ref 193* 193* 198* 198*
dn                              000110 automatic       char(168)                unaligned dcl 88 set ref 130* 133* 135*
effective_access                000172 automatic       bit(36)                  dcl 93 set ref 186* 190
effective_access_modes
                        211            based           bit(36)                  level 3 dcl 2-24 set ref 177
en                              000162 automatic       char(32)                 unaligned dcl 89 set ref 131* 133* 135*
entry_access_info                      based           structure                level 1 dcl 4-12
entryname                77            based           char(32)                 level 2 in structure "mseg_operation" packed
                                                                                  unaligned dcl 2-24 in procedure "mseg_index_" ref
                                                                                  131
entryname               172            based           char(32)                 level 3 in structure "mseg_operation" packed
                                                                                  unaligned dcl 2-24 in procedure "mseg_index_" set
                                                                                  ref 193* 193* 198* 198*
error_table_$ai_restricted      000012 external static fixed bin(35,0)          dcl 58 ref 207
error_table_$bad_subr_arg       000014 external static fixed bin(35,0)          dcl 58 set ref 126* 224*
error_table_$dirseg             000016 external static fixed bin(35,0)          dcl 58 ref 138
error_table_$not_seg_type       000020 external static fixed bin(35,0)          dcl 58 ref 138 181
error_table_$notalloc           000022 external static fixed bin(35,0)          dcl 58 ref 230
error_table_$seg_unknown        000024 external static fixed bin(35,0)          dcl 58 ref 286
flags                    24            based           structure                level 2 dcl 2-24
get_user_free_area_             000032 constant        entry                    external dcl 103 ref 342
group_id                 14            based           char(32)                 level 3 packed unaligned dcl 2-24 set ref 193*
hcs_$get_access_info_seg        000034 constant        entry                    external dcl 104 ref 167
hcs_$get_user_access_modes_seg  000036 constant        entry                    external dcl 105 ref 186
hcs_$initiate                   000040 constant        entry                    external dcl 107 ref 135
hcs_$terminate_noname           000042 constant        entry                    external dcl 108 ref 169 305
i                               000100 automatic       fixed bin(17,0)          dcl 52 set ref 179* 180* 348* 349 350* 366* 367 367
                                                                                  368 368* 374* 375 376*
linker_area                            based           area(1024)               dcl 83 ref 346 364 371
mseg_data_$execution_ring       000052 external static fixed bin(3,0)           dcl 9-9 ref 180
mseg_index              114            based           fixed bin(17,0)          level 2 in structure "mseg_operation" dcl 2-24
                                                                                  in procedure "mseg_index_" set ref 262* 282
mseg_index                      000101 automatic       fixed bin(17,0)          dcl 52 in procedure "mseg_index_" set ref 243* 243*
                                                                                  246 250* 250* 253 258 260 260 262 282* 291 291 293
                                                                                  295 295 297 297 326* 327 328 329* 362* 366 374
mseg_index_valid         24(02)        based           bit(1)                   level 3 packed unaligned dcl 2-24 set ref 263* 281
                                                                                  300*
mseg_message_info                      based           structure                level 1 dcl 3-9
mseg_operation                         based           structure                level 1 dcl 2-24
mseg_operation_ptr              000206 automatic       pointer                  dcl 2-19 set ref 125* 126 130 131 133 144 145 147
                                                                                  167 167 171 175 177 180 193 193 193 193 193 193
                                                                                  198 198 198 198 221* 224 239 262 263 277* 281 282
                                                                                  300 303 304 307 318* 320 321
mseg_pathname_valid      24            based           bit(1)                   level 3 packed unaligned dcl 2-24 ref 126
mseg_ptr                  1            based           pointer                  array level 3 in structure "mseg_table" packed
                                                                                  unaligned dcl 1-6 in procedure "mseg_index_" set
                                                                                  ref 243 250 258* 293 297* 327 328* 349* 367* 367
                                                                                  375*
mseg_ptr                110            based           pointer                  level 2 in structure "mseg_operation" dcl 2-24
                                                                                  in procedure "mseg_index_" set ref 144* 239 304
                                                                                  321
mseg_ptr_valid           24(01)        based           bit(1)                   level 3 packed unaligned dcl 2-24 set ref 145* 171*
                                                                                  224 303 307* 320
mseg_table                             based           structure                level 1 dcl 1-6 set ref 346 364 371
mseg_wakeup_state                      based           structure                level 1 dcl 6-24
new_table_ptr                   000104 automatic       pointer                  dcl 74 set ref 364* 367 368 372
null                                                   builtin function         dcl 98 ref 126 126 137 198 198 224 224 234 250 285
                                                                                  293 297 324 328 342 349 375
pathname_                       000044 constant        entry                    external dcl 109 ref 193 193 198 198
privileges                5            based           bit(18)                  level 3 dcl 2-24 ref 133
ref_count                 2            based           fixed bin(17,0)          array level 3 dcl 1-6 set ref 260* 260 295* 295 297
                                                                                  329* 350* 368* 368 376*
ring_brackets           203            based           fixed bin(3,0)           array level 3 dcl 2-24 set ref 180
sub_err_                        000046 constant        entry                    external dcl 110 ref 126 198 224
suppress_access_checks
                         24(07)        based           bit(1)                   level 3 packed unaligned dcl 2-24 ref 147
sys_info$ring1_privilege        000026 external static bit(36)                  dcl 94 ref 133
system_privilege_$initiate      000050 constant        entry                    external dcl 111 ref 133
table                     1            based           structure                array level 2 dcl 1-6
table_length                           based           fixed bin(17,0)          level 2 dcl 1-6 set ref 243 246 250 253 291 326 346*
                                                                                  362 363 364* 371 374
table_ptr                       000202 automatic       pointer                  dcl 1-5 set ref 222* 234 236 243 243 246 250 250 253
                                                                                  255 258 260 260 283* 285 291 293 295 295 297 297
                                                                                  322* 324 326 327 328 329 346* 349 350 362 363 367
                                                                                  368 371 372* 374 375 376
temp_mseg_ptr                   000106 automatic       pointer                  dcl 74 set ref 133* 135* 137 144 167* 169* 186* 239*
                                                                                  243 258 304* 305* 321* 327
tlength                         000204 automatic       fixed bin(17,0)          dcl 1-12 set ref 344* 346 346 348 363* 364 364

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 5-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 5-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 5-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 5-7
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 7-7
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 8-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
BEEP                                   internal static fixed bin(17,0)          initial dcl 7-7
CRASH                                  internal static fixed bin(17,0)          initial dcl 7-7
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 8-33
ENTRY_ACCESS_INFO_VERSION_1            internal static char(8)                  initial unaligned dcl 4-9
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 8-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 7-7
LOG                                    internal static fixed bin(17,0)          initial dcl 7-7
MSEG_MESSAGE_INFO_V1                   internal static char(8)                  initial dcl 3-28
MSEG_OPERATION_VERSION_1               internal static fixed bin(17,0)          initial dcl 2-20
MSEG_READ_AFTER_SPECIFIED              internal static fixed bin(17,0)          initial dcl 3-30
MSEG_READ_BEFORE_SPECIFIED             internal static fixed bin(17,0)          initial dcl 3-30
MSEG_READ_DELETE                       internal static bit(36)                  initial dcl 3-38
MSEG_READ_FIRST                        internal static fixed bin(17,0)          initial dcl 3-30
MSEG_READ_LAST                         internal static fixed bin(17,0)          initial dcl 3-30
MSEG_READ_OWN                          internal static bit(36)                  initial dcl 3-38
MSEG_READ_SPECIFIED                    internal static fixed bin(17,0)          initial dcl 3-30
MSEG_TYPE_MBX                          internal static fixed bin(17,0)          initial dcl 2-21
MSEG_TYPE_MS                           internal static fixed bin(17,0)          initial dcl 2-22
MSEG_WAKEUP_STATE_VERSION_1            internal static char(8)                  initial unaligned dcl 6-41
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 8-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 8-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 8-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 8-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 8-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 8-36
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 8-36
R_ACCESS                               internal static bit(3)                   initial unaligned dcl 8-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 8-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 8-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 8-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 8-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 8-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 8-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 8-36
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 7-7
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 8-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 7-7
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 8-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
a_mseg_index                           automatic       fixed bin(17,0)          dcl 52
bit                                                    builtin function         dcl 98
entry_access_info_ptr                  automatic       pointer                  dcl 4-8
error_table_$segknown                  external static fixed bin(35,0)          dcl 58
mseg_data_$admin_ring                  external static fixed bin(3,0)           dcl 9-8
mseg_data_$block_size                  external static fixed bin(35,0)          dcl 9-5
mseg_data_$group_id                    external static char(32)                 unaligned dcl 9-11
mseg_data_$lock_id                     external static bit(72)                  dcl 9-4
mseg_data_$max_message_size            external static fixed bin(35,0)          dcl 9-6
mseg_data_$process_max_authorization   external static bit(72)                  dcl 9-10
mseg_data_$template_operation          external static bit(36)                  dcl 9-7
mseg_message_info_ptr                  automatic       pointer                  dcl 3-7
mseg_wakeup_state_ptr                  automatic       pointer                  dcl 6-38

NAMES DECLARED BY EXPLICIT CONTEXT.
ACCESS_CHECK_FAILED             000437 constant        label                    dcl 169 ref 182 188 208
FOUND_INDEX                     001141 constant        label                    dcl 258 ref 246
RETURN                          001261 constant        label                    dcl 310 ref 141 147 172 213 231 264 288
UNKNOWN                         001211 constant        label                    dcl 286 ref 291 293
allocate_table                  001344 constant        entry                    internal dcl 337 ref 235
grow_table                      001414 constant        entry                    internal dcl 356 ref 254
mseg_index_                     000145 constant        entry                    external dcl 29
mseg_index_$close_seg           001157 constant        entry                    external dcl 274
mseg_index_$delete              001270 constant        entry                    external dcl 314
mseg_index_$initiate_seg        000160 constant        entry                    external dcl 122
mseg_index_$open_seg            000740 constant        entry                    external dcl 218

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2042        2116    1511        2052
Length      2530    1511        54         375     331           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mseg_index_                         288 external procedure  is an external procedure.  
on unit on line 228                  64 on unit               
allocate_table                          internal procedure  shares stack frame of external procedure mseg_index_.  
grow_table                              internal procedure  shares stack frame of external procedure mseg_index_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 area_ptr                    mseg_index_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mseg_index_              000100 i                           mseg_index_
                         000101 mseg_index                  mseg_index_
                         000102 code                        mseg_index_
                         000103 code2                       mseg_index_
                         000104 new_table_ptr               mseg_index_
                         000106 temp_mseg_ptr               mseg_index_
                         000110 dn                          mseg_index_
                         000162 en                          mseg_index_
                         000172 effective_access            mseg_index_
                         000202 table_ptr                   mseg_index_
                         000204 tlength                     mseg_index_
                         000206 mseg_operation_ptr          mseg_index_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
unpk_to_pk          call_ext_out_desc   call_ext_out        return              tra_ext             enable
ext_entry           int_entry           alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
admin_gate_$syserr            get_user_free_area_           hcs_$get_access_info_seg
hcs_$get_user_access_modes_seg                              hcs_$initiate                 hcs_$terminate_noname
pathname_                     sub_err_                      system_privilege_$initiate

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$ai_restricted    error_table_$bad_subr_arg     error_table_$dirseg           error_table_$not_seg_type
error_table_$notalloc         error_table_$seg_unknown      mseg_data_$execution_ring     sys_info$ring1_privilege




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     58 000141        29 000144       122 000153       125 000171       126 000175       130 000251       131 000255
    133 000260       135 000330       137 000373       138 000377       140 000406       141 000407       144 000410
    145 000413       147 000415       167 000420       168 000435       169 000437       171 000451       172 000454
    175 000455       177 000460       179 000464       180 000471       181 000476       182 000500       184 000501
    186 000503       188 000543       190 000545       193 000551       198 000630       207 000726       208 000731
    211 000732       213 000733       218 000734       221 000751       222 000755       224 000760       228 001032
    230 001046       231 001051       234 001054       235 001060       236 001061       239 001064       243 001067
    244 001106       246 001110       250 001113       251 001130       253 001132       254 001135       255 001136
    258 001141       260 001146       262 001147       263 001152       264 001154       274 001155       277 001170
    279 001174       281 001175       282 001200       283 001202       285 001205       286 001211       288 001214
    291 001215       293 001222       295 001227       297 001231       300 001236       303 001240       304 001243
    305 001245       307 001256       310 001261       312 001263       314 001264       318 001276       320 001302
    321 001305       322 001307       324 001312       326 001316       327 001325       328 001335       329 001337
    330 001340       332 001341       335 001343       337 001344       342 001345       344 001360       346 001362
    348 001374       349 001403       350 001410       351 001411       353 001413       356 001414       362 001415
    363 001420       364 001423       366 001435       367 001445       368 001453       369 001455       371 001457
    372 001464       374 001466       375 001475       376 001502       377 001503       379 001505


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
