	COMPILATION LISTING OF SEGMENT copy_dm_file_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 03/05/85  0847.3 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 /* format: style4,ifthenstmt,^indproc,^indcomtxt */
        7 /*---------------*/
        8 
        9 copy_dm_file_: proc (A_copy_options_ptr, A_code);
       10 
       11 /* DESCRIPTION:
       12*
       13*   Copying primitive for DM files. Takes all its input info in the copy_options
       14*   structure. The return code, if zero, pertains to the target file if
       15*   copy_options.target_err_switch is ON, otherwise to the file being copied.
       16*
       17*   The source file is opened, the target file is created and opened, and
       18*   copying is performed by successive calls to fm_$raw_put to copy the
       19*   control intervals. This way, new control interval id's are generated and
       20*   a new protected file is built.
       21**/
       22 
       23 /* HISTORY:
       24*Written by Steve Herbst, 03/22/83.
       25*Modified:
       26*04/13/83 by Steve Herbst: Changed to use raw_(get put) and abort if interrupted. 
       27*05/25/83 by Steve Herbst: Eliminated erroneous call to fm_$delete_close 
       28*06/17/83 by Steve Herbst: Changed calling sequence to use new copy_options 
       29*            include file.
       30*06/28/83 by Steve Herbst: Changed to use copy_flags.incl.pl1 
       31*08/20/84 by Matthew C. Pierret: Changed to use FILE_CREATE_INFO_VERSION_2.
       32*10/15/84 by Steve Herbst: Changed in response to audit comments:
       33*	Removed cleanup windows, Added ERROR_RETURN proc, changed to call
       34*	file_manager_$get_ci_ptr instead of $raw_get.
       35*12/13/84 by Steve Herbst: Changed again in response to audit comments:
       36*	Fixed CLEAN_UP to not delete source file, added copy_options version
       37*	check, removed references to ci_header, changed to report CLEAN_UP
       38*	errors at normal termination, fixed to never call CLEAN_UP twice.
       39*12/17/84 by Steve Herbst: Changed again in response to audit comments:
       40*	Improved journalization comments, fixed not to replace nonzero
       41*	A_code with error code from CLEAN_UP, commented CLEAN_UP design.
       42*12/18/84 by Matthew Pierret:  Changed to initialize auto_ci_parts.mbz to 0
       43*            and auto_ci_parts.number_of_parts to 1.
       44**/
       45 
       46 /* DECLARATIONS */
       47 
       48 /* Parameters */
       49 
       50 dcl  A_copy_options_ptr ptr parameter;
       51 dcl  A_code fixed bin (35) parameter;
       52 
       53 /* Based */
       54 
       55 /* Automatic */
       56 
       57 dcl  1 auto_ci_parts aligned,
       58        2 number_of_parts fixed bin init (1),
       59        2 mbz fixed bin init (0),
       60        2 part (1) like ci_parts.part;
       61 
       62 dcl  1 auto_file_create_info aligned like file_create_info;
       63 dcl  (source_opening_id, target_opening_id, txn_id) bit (36) aligned;
       64 dcl  (cleanup_called_sw, done_sw, getting_sw) bit (1);
       65 dcl  (ci_index, last_ci_num) fixed bin (27);
       66 dcl  (begin_code, code, create_code) fixed bin (35);
       67 
       68 /* External */
       69 
       70 dcl  dm_error_$ci_not_allocated fixed bin (35) ext;
       71 dcl  dm_error_$file_already_exists fixed bin (35) ext;
       72 dcl  dm_error_$file_already_open fixed bin (35) ext;
       73 dcl  dm_error_$file_not_dm_type fixed bin (35) ext;
       74 dcl  dm_error_$transaction_in_progress fixed bin (35) ext;
       75 dcl  error_table_$dirseg fixed bin (35) ext;
       76 dcl  error_table_$not_seg_type fixed bin (35) ext;
       77 dcl  error_table_$rqover fixed bin (35) ext;
       78 dcl  error_table_$unimplemented_version fixed bin (35) ext;
       79 
       80 /* Entries */
       81 
       82 dcl  file_manager_$close entry (bit (36) aligned, fixed bin (35));
       83 dcl  file_manager_$create_open entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
       84 dcl  file_manager_$delete entry (bit (36) aligned, fixed bin (35));
       85 dcl  file_manager_$get_ci_ptr entry (bit (36) aligned, fixed bin (27), ptr, fixed bin (35));
       86 dcl  file_manager_$open entry (char (*), char (*), bit (36) aligned, fixed bin (35));
       87 dcl  file_manager_$prepare_to_copy entry (bit (36) aligned, ptr, fixed bin (27), fixed bin (35));
       88 dcl  file_manager_$raw_put entry (bit (36) aligned, fixed bin (27), ptr, fixed bin (35));
       89 dcl  file_manager_$terminate_ci_ptr entry (bit (36) aligned, fixed bin (27), ptr, fixed bin (35));
       90 dcl  transaction_manager_$abort_txn entry (bit (36) aligned, fixed bin (35));
       91 dcl  transaction_manager_$begin_txn entry (fixed bin, bit (36) aligned, bit (36) aligned, fixed bin (35));
       92 dcl  transaction_manager_$commit_txn entry (bit (36) aligned, fixed bin (35));
       93 
       94 /* Builtins */
       95 
       96 dcl  (addr, null, unspec) builtin;
       97 
       98 /* Conditions */
       99 
      100 dcl  (cleanup, record_quota_overflow) condition;
      101 
      102 /* END OF DECLARATIONS */
      103 
      104 	A_code = 0;
      105 	copy_options_ptr = A_copy_options_ptr;
      106 
      107 	if copy_options.version ^= COPY_OPTIONS_VERSION_1 then
      108 	     call ERROR_RETURN (error_table_$unimplemented_version);
      109 
      110 	copy_options.target_err_switch = "0"b;		/* assume source file until target error occurs */
      111 
      112 	cleanup_called_sw = "0"b;
      113 	done_sw, getting_sw = "0"b;
      114 	txn_id, source_opening_id, target_opening_id = "0"b;
      115 	begin_code, create_code = 0;
      116 
      117 	on cleanup call CLEAN_UP (code);
      118 
      119 	call transaction_manager_$begin_txn (TM_NORMAL_MODE, "0"b, txn_id, begin_code);
      120 	if begin_code ^= 0 & begin_code ^= dm_error_$transaction_in_progress then call ERROR_RETURN (begin_code);
      121 						/* OK to use an existing transaction */
      122 
      123 	call file_manager_$open (copy_options.source_dir, copy_options.source_name, source_opening_id, code);
      124 	if source_opening_id = "0"b then
      125 	     if code = error_table_$dirseg | code = dm_error_$file_not_dm_type then
      126 		call ERROR_RETURN (error_table_$not_seg_type);
      127 	     else call ERROR_RETURN (code);
      128 
      129 	unspec (auto_file_create_info) = "0"b;
      130 	auto_file_create_info.version = FILE_CREATE_INFO_VERSION_2;
      131 	call file_manager_$prepare_to_copy (source_opening_id, addr (auto_file_create_info), last_ci_num, code);
      132 	if code ^= 0 then call ERROR_RETURN (code);
      133 
      134 	on record_quota_overflow begin;
      135 	     copy_options.target_err_switch = ^getting_sw;
      136 	     call ERROR_RETURN (error_table_$rqover);
      137 	end;
      138 
      139 	call file_manager_$create_open (copy_options.target_dir, copy_options.target_name,
      140 	     addr (auto_file_create_info), target_opening_id, create_code);
      141 	if target_opening_id = "0"b | create_code = dm_error_$file_already_exists then do;
      142 	     copy_options.target_err_switch = "1"b;
      143 	     call ERROR_RETURN (create_code);
      144 	end;
      145 
      146 	auto_ci_parts.offset_in_bytes (1) = 0;
      147 	auto_ci_parts.local_ptr (1) = null;
      148 	auto_ci_parts.length_in_bytes = CI_0_ADDRESSABLE_LENGTH;
      149 
      150 	do ci_index = 0 to last_ci_num;
      151 
      152 /* Copy only used control intervals */
      153 
      154 	     getting_sw = "1"b;
      155 	     call file_manager_$get_ci_ptr (source_opening_id, ci_index, auto_ci_parts.local_ptr (1), code);
      156 	     getting_sw = "0"b;
      157 
      158 	     if code = 0 then do;			/* copy this one; it's allocated */
      159 
      160 		call file_manager_$raw_put (target_opening_id, ci_index, addr (auto_ci_parts), code);
      161 		if code ^= 0 then do;
      162 		     copy_options.target_err_switch = "1"b; /* error is on the target file */
      163 		     call ERROR_RETURN (code);
      164 		end;
      165 
      166 		call file_manager_$terminate_ci_ptr (source_opening_id, ci_index, auto_ci_parts.local_ptr (1), code);
      167 		if code ^= 0 then call ERROR_RETURN (code);
      168 	     end;
      169 	     else if code ^= dm_error_$ci_not_allocated then call ERROR_RETURN (code);
      170 						/* if it's not allocated, just skip it */
      171 	     auto_ci_parts.length_in_bytes = CI_ADDRESSABLE_LENGTH;
      172 	end;
      173 
      174 	auto_ci_parts.local_ptr (1) = null;
      175 
      176 	done_sw = "1"b;
      177 RETURN:
      178 	if ^cleanup_called_sw then do;
      179 	     cleanup_called_sw = "1"b;
      180 	     call CLEAN_UP (code);
      181 	     if code ^= 0 & A_code = 0 then call ERROR_RETURN (code); /* previously reported A_code takes precedence */
      182 	end;
      183 
      184 	return;
      185 
      186 CLEAN_UP: proc (P_cleanup_code);
      187 
      188 /* This procedure completes even if one of its calls gets an error, since the
      189*   intent is to return the process and the objects to their former state as
      190*   well as possible. It sets a code parameter rather than reporting an error
      191*   so that the caller has the option: an error is reported at normal
      192*   termination time but not when "cleanup" is signalled. */
      193 
      194 dcl  (P_cleanup_code, code) fixed bin (35);
      195 
      196 	P_cleanup_code = 0;				/* reports errors to the main proc */
      197 						/* want to report 1st error but do all cleanup */
      198 
      199 	if auto_ci_parts.local_ptr (1) ^= null then	/* was in the middle of reading a ci */
      200 	     call file_manager_$terminate_ci_ptr
      201 		(source_opening_id, ci_index, auto_ci_parts.local_ptr (1), P_cleanup_code);
      202 
      203 	if source_opening_id ^= "0"b then call file_manager_$close (source_opening_id, code);
      204 	if P_cleanup_code = 0 then P_cleanup_code = code;
      205 
      206 	if target_opening_id ^= "0"b & create_code ^= dm_error_$file_already_open then
      207 	     call file_manager_$close (target_opening_id, code);
      208 	if P_cleanup_code = 0 then do;
      209 	     P_cleanup_code = code;
      210 	     copy_options.target_err_switch = "1"b;
      211 	end;
      212 
      213 	if txn_id ^= "0"b then
      214 	     if begin_code = dm_error_$transaction_in_progress then ;
      215 						/* What to do? Can't commit or abort the user's previous transaction. */
      216 
      217 	     else if done_sw then do;
      218 		call transaction_manager_$commit_txn (txn_id, code);
      219 		if P_cleanup_code = 0 then P_cleanup_code = code;
      220 	     end;
      221 	     else do;				/* if ^done_sw, target may be incomplete. */
      222 						/* have to delete it if we created it */
      223 		if target_opening_id ^= "0"b & create_code ^= dm_error_$file_already_exists &
      224 		     create_code ^= dm_error_$file_already_open then do;
      225 		     call file_manager_$delete (target_opening_id, code);
      226 		     if P_cleanup_code = 0 then do;
      227 			P_cleanup_code = code;
      228 			copy_options.target_err_switch = "1"b;
      229 		     end;
      230 		end;
      231 
      232 		call transaction_manager_$abort_txn (txn_id, code);
      233 		if P_cleanup_code = 0 then P_cleanup_code = code;
      234 	     end;
      235 
      236      end CLEAN_UP;
      237 
      238 ERROR_RETURN: proc (P_code);
      239 
      240 dcl  P_code fixed bin (35);
      241 
      242 	A_code = P_code;
      243 	go to RETURN;
      244 
      245      end ERROR_RETURN;
      246 
  1     1 /* BEGIN INCLUDE FILE:  copy_flags.incl.pl1 */
  1     2 
  1     3 /* Flags for attributes that should/may be copied by the copy_ subroutine. This include file is
  1     4*   required by suffix_info.incl.pl1 and copy_options.incl.pl1
  1     5*
  1     6*   Jay Pattin 6/23/83 */
  1     7 
  1     8 declare   1 copy_flags                  aligned based,      /* ON means that this attribute may be copied by copy_ */
  1     9           2 names                       bit (1) unaligned,
  1    10           2 acl                         bit (1) unaligned,
  1    11           2 ring_brackets               bit (1) unaligned,
  1    12           2 max_length                  bit (1) unaligned,
  1    13           2 copy_switch                 bit (1) unaligned,
  1    14           2 safety_switch               bit (1) unaligned,
  1    15           2 dumper_switches             bit (1) unaligned,
  1    16           2 entry_bound                 bit (1) unaligned,  /* only for vanilla object segments */
  1    17           2 extend                      bit (1) unaligned,  /* copy_ may append to end of existing object */
  1    18           2 update                      bit (1) unaligned,  /* copy_ may replace contents of existing object */
  1    19           2 mbz                         bit (26) unaligned;
  1    20 
  1    21 /* END INCLUDE FILE:  copy_flags.incl.pl1 */
      247 
      248 
  2     1 /* BEGIN INCLUDE FILE: copy_options.incl.pl1 */
  2     2 
  2     3 /* This structure declares the input structure used by the copy_ subroutine.
  2     4*
  2     5*   NOTE: This include file depends on declarations in the include file
  2     6*   copy_flags.incl.pl1.
  2     7*
  2     8*   Jay Pattin 6/1/83 */
  2     9 
  2    10 declare   copy_options_ptr              ptr;
  2    11 
  2    12 declare   1 copy_options                aligned based (copy_options_ptr),
  2    13           2 version                     char (8),           /* currently COPY_OPTIONS_VERSION_1 */
  2    14           2 caller_name                 char (32) unal,     /* Used in nd_handler_ call */
  2    15           2 source_dir                  char (168) unal,
  2    16           2 source_name                 char (32) unal,
  2    17           2 target_dir                  char (168) unal,
  2    18           2 target_name                 char (32) unal,
  2    19           2 flags,
  2    20             3 no_name_dup               bit (1) unaligned,  /* ON = don't call nd_handler_ */
  2    21             3 raw                       bit (1) unaligned,  /* ON = don't call object_type_, use hcs_ */
  2    22             3 force                     bit (1) unaligned,  /* ON = delete or force access to target */
  2    23             3 delete                    bit (1) unaligned,  /* ON = delete original after copy (for move) */
  2    24             3 target_err_switch         bit (1) unaligned,
  2    25             3 mbz                       bit (31) unaligned,
  2    26           2 copy_items                  like copy_flags;    /* see copy_flags.incl.pl1 */
  2    27 
  2    28 declare   COPY_OPTIONS_VERSION_1        char (8) static options (constant) init ("CPOPT001");
  2    29 
  2    30 /* END INCLUDE FILE: copy_options.incl.pl1 */
      249 
      250 
  3     1 /* BEGIN INCLUDE FILE dm_ci_lengths.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*       This include file contains constants which are the length in bytes
  3     5*   of the addressable portion of a control interval.  The addressable portion
  3     6*   is that part of the control interval which callers of file_manager_
  3     7*   may access, specifically, everything between the end of the control
  3     8*   interval header (ci_header) and the control interval trailer (ci_trailer).
  3     9*   Control interval 0 is slightly different, as it also contains an 
  3    10*   unaddressable portion in which it maintains the file attributes.  For
  3    11*   control interval 0 the addressable portion is everything between the end
  3    12*   of the control interval header and the beginning of the file attributes.
  3    13**/
  3    14 
  3    15 /* HISTORY:
  3    16*Written by Matthew Pierret, 11/02/84.
  3    17*Modified:
  3    18**/
  3    19 
  3    20 /* format: style2,ind3 */
  3    21 
  3    22      dcl	   CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
  3    23 			      fixed bin (17) init (4072) int static options (constant);
  3    24 
  3    25      dcl	   CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
  3    26 			      fixed bin (17) init (3176) int static options (constant);
  3    27 
  3    28 
  3    29      dcl	   CI_ADDRESSABLE_LENGTH  fixed bin (17) init (4072) int static options (constant);
  3    30 
  3    31      dcl	   CI_0_ADDRESSABLE_LENGTH
  3    32 			      fixed bin (17) init (3176) int static options (constant);
  3    33 
  3    34 /* END INCLUDE FILE dm_ci_lengths.incl.pl1 */
      251 
      252 
  4     1 /*  BEGIN INCLUDE FILE:  dm_ci_parts.incl.pl1  */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*        This include file contains the ci_parts structure.  This structure
  4     6*   is used across the file_manager_ interface to specify the parts of a
  4     7*   control interval to get or put.  If the number_of parts is equal to 0,
  4     8*   modules which take ci_parts interpret this case to mean to do everything
  4     9*   except the actual requested operation, i.e., lock the control interval
  4    10*   but don't get anything.  offset_in_bytes is the 0-originned offset in
  4    11*   bytes from the beginning of the addressable portion of the control interval.
  4    12*   An offset_in_bytes which is in the addressable portion is in error.
  4    13*   Likewise, if offset_in_bytes + length_in_bytes is outside of the addressable
  4    14*   portion, it is in error.
  4    15**/
  4    16 
  4    17 /* HISTORY:
  4    18*Written by Matthew Pierret, 01/28/82.
  4    19*  (01/28/82 Andre Bensoussan, Design.)
  4    20*Modified:
  4    21*11/07/84 by Matthew Pierret:  To add must_be_zero, initial attributes on
  4    22*            automatic storge.
  4    23**/
  4    24 
  4    25 /* format: style2,ind3 */
  4    26 
  4    27      dcl	   1 ci_parts	      aligned based (ci_parts_ptr),
  4    28 	     2 number_of_parts    fixed bin (17),
  4    29 	     2 must_be_zero	      fixed bin,
  4    30 	     2 part	      (cip_number_of_parts refer (ci_parts.number_of_parts)),
  4    31 	       3 offset_in_bytes  fixed bin (17),
  4    32 	       3 length_in_bytes  fixed bin (17),
  4    33 	       3 local_ptr	      ptr;
  4    34 
  4    35      dcl	   ci_parts_ptr	      ptr init (null ());
  4    36      dcl	   cip_number_of_parts    fixed bin (17) init (0);
  4    37 
  4    38 
  4    39 /*  BEGIN INCLUDE FILE:   dm_ci_parts.incl.pl1   */
      253 
      254 
  5     1 /* BEGIN INCLUDE FILE: dm_file_create_info.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*     This include file contains the declaration of the file_create_info
  5     5*     structure.  This structure is used to specify to file_manager_
  5     6*     attributes a file is to have.
  5     7**/
  5     8 
  5     9 /* HISTORY:
  5    10*Written by Jeffery D. Ives, 09/16/82.
  5    11*  (Original concept by Lindsey L. Spratt.)
  5    12*Modified:
  5    13*06/15/84 by Matthew Pierret:  Added ring_brackets. Changed to a char (8)
  5    14*            version.
  5    15*11/07/84 by Matthew Pierret:  Extended mbz_3 to by one word to cover the
  5    16*            gap caused by the double-word alignment of mbz_2.
  5    17**/
  5    18 
  5    19 /* format: style2,ind3 */
  5    20 
  5    21      dcl	   1 file_create_info     aligned based (file_create_info_ptr),
  5    22 	     2 version	      char (8) aligned,
  5    23 	     2 ci_size_in_bytes   fixed bin (35) init (4096),
  5    24 						/* control interval physical size, must be 4096	*/
  5    25 	     2 blocking_factor    fixed bin init (255),	/* # of cis in each msf seg, must be 64 or 255	*/
  5    26 	     2 flags	      unal,
  5    27 	       3 protected	      bit (1) unal init ("1"b),
  5    28 						/* protected against inconsistency		*/
  5    29 	       3 no_concurrency   bit (1) unal init ("0"b),
  5    30 						/* don't protect against concurrent access	*/
  5    31 	       3 no_rollback      bit (1) unal init ("0"b),
  5    32 						/* don't protect against system failure		*/
  5    33 	       3 mbz_1	      bit (15) unal init ("0"b),
  5    34 						/* must be zero for future compatability	*/
  5    35 	     2 ring_brackets      (2) fixed bin (3) unal init (0, 0),
  5    36 						/* write bracket is first element, read bracket is second */
  5    37 	     2 mbz_3	      bit (46) unal init ("0"b),
  5    38 						/* must be zero for future compatability */
  5    39 	     2 mbz_2	      (30) fixed bin (71);	/* must be zero for future compatability	*/
  5    40 
  5    41      dcl	   file_create_info_ptr   ptr;
  5    42 
  5    43      dcl	   FILE_CREATE_INFO_VERSION_2
  5    44 			      char (8) aligned static options (constant) init ("FileCr 2");
  5    45      dcl	   (
  5    46 	   FCI_WRITE_BRACKET_IDX  init (1),
  5    47 	   FCI_READ_BRACKET_IDX   init (2)
  5    48 	   )		      internal static options (constant);
  5    49 
  5    50 /* ************ END OF INCLUDE FILE: dm_file_create_info.incl.pl1 ********** */
      255 
      256 
  6     1 /*  START OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6     2 
  6     3 /* HISTORY:
  6     4*
  6     5*Designed by Matthew C. Pierret, 01/26/82.
  6     6*Coded by Jeffrey D. Ives, 04/30/82.
  6     7*Modified:
  6     8*10/18/82 by Steve Herbst: Names changed.
  6     9*01/19/83 by Steve Herbst: Added (LOWEST HIGHEST)_MODE.
  6    10**/
  6    11 
  6    12 dcl (LOWEST_MODE init (1),
  6    13      HIGHEST_MODE init (8)) fixed bin int static options (constant);
  6    14 
  6    15      dcl	   TM_NORMAL_MODE	      fixed bin static options (constant) init (1);
  6    16      dcl	   TM_STATISTICAL_MODE   fixed bin static options (constant) init (2);
  6    17      dcl	   TM_READ_ONLY_MODE     fixed bin static options (constant) init (3);
  6    18      dcl	   TM_NEVER_WRITE_MODE   fixed bin static options (constant) init (4);
  6    19      dcl	   TM_TEST_NORMAL_MODE   fixed bin static options (constant) init (5);
  6    20      dcl	   TM_TEST_STATISTICAL_MODE fixed bin static options (constant) init (6);
  6    21      dcl	   TM_TEST_READ_ONLY_MODE fixed bin static options (constant) init (7);
  6    22      dcl	   TM_TEST_NEVER_WRITE_MODE fixed bin static options (constant) init (8);
  6    23 
  6    24 /*  END OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      257 
      258 
      259 
      260      end copy_dm_file_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/05/85  0755.9  copy_dm_file_.pl1                 >spec>on>7138.pbf>copy_dm_file_.pl1
247          1    10/14/83  1606.7  copy_flags.incl.pl1               >ldd>include>copy_flags.incl.pl1
249          2    10/14/83  1606.7  copy_options.incl.pl1             >ldd>include>copy_options.incl.pl1
251          3    01/07/85  0900.7  dm_ci_lengths.incl.pl1            >ldd>include>dm_ci_lengths.incl.pl1
253          4    01/07/85  0900.8  dm_ci_parts.incl.pl1              >ldd>include>dm_ci_parts.incl.pl1
255          5    01/07/85  0901.1  dm_file_create_info.incl.pl1      >ldd>include>dm_file_create_info.incl.pl1
257          6    01/07/85  0900.0  dm_tm_modes.incl.pl1              >ldd>include>dm_tm_modes.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
A_code                                 parameter       fixed bin(35,0)          dcl 51 set ref 9 104* 181 242*
A_copy_options_ptr                     parameter       pointer                  dcl 50 ref 9 105
CI_0_ADDRESSABLE_LENGTH                constant        fixed bin(17,0)          initial dcl 3-31 ref 148
CI_ADDRESSABLE_LENGTH                  constant        fixed bin(17,0)          initial dcl 3-29 ref 171
COPY_OPTIONS_VERSION_1          000002 constant        char(8)                  initial unaligned dcl 2-28 ref 107
FILE_CREATE_INFO_VERSION_2      000000 constant        char(8)                  initial dcl 5-43 ref 130
P_cleanup_code                         parameter       fixed bin(35,0)          dcl 194 set ref 186 196* 199* 204 204* 208 209* 219
                                                                                  219* 226 227* 233 233*
P_code                                 parameter       fixed bin(35,0)          dcl 240 ref 238 242
TM_NORMAL_MODE                  000010 constant        fixed bin(17,0)          initial dcl 6-15 set ref 119*
addr                                                   builtin function         dcl 96 ref 131 131 139 139 160 160
auto_ci_parts                   000100 automatic       structure                level 1 dcl 57 set ref 160 160
auto_file_create_info           000106 automatic       structure                level 1 dcl 62 set ref 129* 131 131 139 139
begin_code                      000220 automatic       fixed bin(35,0)          dcl 66 set ref 115* 119* 120 120 120* 213
blocking_factor           3     000106 automatic       fixed bin(17,0)          initial level 2 dcl 62 set ref 62*
ci_index                        000216 automatic       fixed bin(27,0)          dcl 65 set ref 150* 155* 160* 166* 199*
ci_parts                               based           structure                level 1 dcl 4-27
ci_parts_ptr                    000242 automatic       pointer                  initial dcl 4-35 set ref 4-35*
ci_size_in_bytes          2     000106 automatic       fixed bin(35,0)          initial level 2 dcl 62 set ref 62*
cip_number_of_parts             000244 automatic       fixed bin(17,0)          initial dcl 4-36 set ref 4-36*
cleanup                         000224 stack reference condition                dcl 100 ref 117
cleanup_called_sw               000213 automatic       bit(1)                   unaligned dcl 64 set ref 112* 177 179*
code                            000100 automatic       fixed bin(35,0)          dcl 194 in procedure "CLEAN_UP" set ref 203* 204
                                                                                  206* 209 218* 219 225* 227 232* 233
code                            000221 automatic       fixed bin(35,0)          dcl 66 in procedure "copy_dm_file_" set ref 117*
                                                                                  123* 124 124 127* 131* 132 132* 155* 158 160* 161
                                                                                  163* 166* 167 167* 169 169* 180* 181 181*
copy_flags                             based           structure                level 1 dcl 1-8
copy_options                           based           structure                level 1 dcl 2-12
copy_options_ptr                000240 automatic       pointer                  dcl 2-10 set ref 105* 107 110 123 123 135 139 139
                                                                                  142 162 210 228
create_code                     000222 automatic       fixed bin(35,0)          dcl 66 set ref 115* 139* 141 143* 206 223 223
dm_error_$ci_not_allocated      000010 external static fixed bin(35,0)          dcl 70 ref 169
dm_error_$file_already_exists   000012 external static fixed bin(35,0)          dcl 71 ref 141 223
dm_error_$file_already_open     000014 external static fixed bin(35,0)          dcl 72 ref 206 223
dm_error_$file_not_dm_type      000016 external static fixed bin(35,0)          dcl 73 ref 124
dm_error_$transaction_in_progress
                                000020 external static fixed bin(35,0)          dcl 74 ref 120 213
done_sw                         000214 automatic       bit(1)                   unaligned dcl 64 set ref 113* 176* 217
error_table_$dirseg             000022 external static fixed bin(35,0)          dcl 75 ref 124
error_table_$not_seg_type       000024 external static fixed bin(35,0)          dcl 76 set ref 124*
error_table_$rqover             000026 external static fixed bin(35,0)          dcl 77 set ref 136*
error_table_$unimplemented_version
                                000030 external static fixed bin(35,0)          dcl 78 set ref 107*
file_create_info                       based           structure                level 1 dcl 5-21
file_manager_$close             000032 constant        entry                    external dcl 82 ref 203 206
file_manager_$create_open       000034 constant        entry                    external dcl 83 ref 139
file_manager_$delete            000036 constant        entry                    external dcl 84 ref 225
file_manager_$get_ci_ptr        000040 constant        entry                    external dcl 85 ref 155
file_manager_$open              000042 constant        entry                    external dcl 86 ref 123
file_manager_$prepare_to_copy   000044 constant        entry                    external dcl 87 ref 131
file_manager_$raw_put           000046 constant        entry                    external dcl 88 ref 160
file_manager_$terminate_ci_ptr  000050 constant        entry                    external dcl 89 ref 166 199
flags                   156            based           structure                level 2 in structure "copy_options" dcl 2-12
                                                                                  in procedure "copy_dm_file_"
flags                     4     000106 automatic       structure                level 2 in structure "auto_file_create_info" packed
                                                                                  unaligned dcl 62 in procedure "copy_dm_file_"
getting_sw                      000215 automatic       bit(1)                   unaligned dcl 64 set ref 113* 135 154* 156*
last_ci_num                     000217 automatic       fixed bin(27,0)          dcl 65 set ref 131* 150
length_in_bytes           3     000100 automatic       fixed bin(17,0)          array level 3 dcl 57 set ref 148* 171*
local_ptr                 4     000100 automatic       pointer                  array level 3 dcl 57 set ref 147* 155* 166* 174* 199
                                                                                  199*
mbz                       1     000100 automatic       fixed bin(17,0)          initial level 2 dcl 57 set ref 57*
mbz_1                     4(03) 000106 automatic       bit(15)                  initial level 3 packed unaligned dcl 62 set ref 62*
mbz_3                     4(26) 000106 automatic       bit(46)                  initial level 2 packed unaligned dcl 62 set ref 62*
no_concurrency            4(01) 000106 automatic       bit(1)                   initial level 3 packed unaligned dcl 62 set ref 62*
no_rollback               4(02) 000106 automatic       bit(1)                   initial level 3 packed unaligned dcl 62 set ref 62*
null                                                   builtin function         dcl 96 ref 147 174 4-35 199
number_of_parts                 000100 automatic       fixed bin(17,0)          initial level 2 dcl 57 set ref 57*
offset_in_bytes           2     000100 automatic       fixed bin(17,0)          array level 3 dcl 57 set ref 146*
part                      2            based           structure                array level 2 in structure "ci_parts" dcl 4-27
                                                                                  in procedure "copy_dm_file_"
part                      2     000100 automatic       structure                array level 2 in structure "auto_ci_parts" dcl 57
                                                                                  in procedure "copy_dm_file_"
protected                 4     000106 automatic       bit(1)                   initial level 3 packed unaligned dcl 62 set ref 62*
record_quota_overflow           000232 stack reference condition                dcl 100 ref 134
ring_brackets             4(18) 000106 automatic       fixed bin(3,0)           initial array level 2 packed unaligned dcl 62 set
                                                                                  ref 62* 62*
source_dir               12            based           char(168)                level 2 packed unaligned dcl 2-12 set ref 123*
source_name              64            based           char(32)                 level 2 packed unaligned dcl 2-12 set ref 123*
source_opening_id               000210 automatic       bit(36)                  dcl 63 set ref 114* 123* 124 131* 155* 166* 199* 203
                                                                                  203*
target_dir               74            based           char(168)                level 2 packed unaligned dcl 2-12 set ref 139*
target_err_switch       156(04)        based           bit(1)                   level 3 packed unaligned dcl 2-12 set ref 110* 135*
                                                                                  142* 162* 210* 228*
target_name             146            based           char(32)                 level 2 packed unaligned dcl 2-12 set ref 139*
target_opening_id               000211 automatic       bit(36)                  dcl 63 set ref 114* 139* 141 160* 206 206* 223 225*
transaction_manager_$abort_txn  000052 constant        entry                    external dcl 90 ref 232
transaction_manager_$begin_txn  000054 constant        entry                    external dcl 91 ref 119
transaction_manager_$commit_txn 000056 constant        entry                    external dcl 92 ref 218
txn_id                          000212 automatic       bit(36)                  dcl 63 set ref 114* 119* 213 218* 232*
unspec                                                 builtin function         dcl 96 set ref 129*
version                         000106 automatic       char(8)                  level 2 in structure "auto_file_create_info" dcl 62
                                                                                  in procedure "copy_dm_file_" set ref 130*
version                                based           char(8)                  level 2 in structure "copy_options" dcl 2-12
                                                                                  in procedure "copy_dm_file_" ref 107

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
                                       internal static fixed bin(17,0)          initial dcl 3-22
CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
                                       internal static fixed bin(17,0)          initial dcl 3-25
FCI_READ_BRACKET_IDX                   internal static fixed bin(17,0)          initial dcl 5-45
FCI_WRITE_BRACKET_IDX                  internal static fixed bin(17,0)          initial dcl 5-45
HIGHEST_MODE                           internal static fixed bin(17,0)          initial dcl 6-12
LOWEST_MODE                            internal static fixed bin(17,0)          initial dcl 6-12
TM_NEVER_WRITE_MODE                    internal static fixed bin(17,0)          initial dcl 6-18
TM_READ_ONLY_MODE                      internal static fixed bin(17,0)          initial dcl 6-17
TM_STATISTICAL_MODE                    internal static fixed bin(17,0)          initial dcl 6-16
TM_TEST_NEVER_WRITE_MODE               internal static fixed bin(17,0)          initial dcl 6-22
TM_TEST_NORMAL_MODE                    internal static fixed bin(17,0)          initial dcl 6-19
TM_TEST_READ_ONLY_MODE                 internal static fixed bin(17,0)          initial dcl 6-21
TM_TEST_STATISTICAL_MODE               internal static fixed bin(17,0)          initial dcl 6-20
file_create_info_ptr                   automatic       pointer                  dcl 5-41

NAMES DECLARED BY EXPLICIT CONTEXT.
CLEAN_UP                        000640 constant        entry                    internal dcl 186 ref 117 180
ERROR_RETURN                    001042 constant        entry                    internal dcl 238 ref 107 120 124 127 132 136 143 163
                                                                                  167 169 181
RETURN                          000611 constant        label                                           #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                                       #                            523       166 000531       167 000546       168 000556       169 000557       171 000570       172 000603
    174 000605       176 000607       177 000611       179 000613       180 000615       181 000623       184 000636
    186 000637       196 000645       199 000647       203 000670       204 000704       206 000711       208 000730
    209 000733       210 000735       213 000741       217 000751       218 000753       219 000763       220 000770
    223 000771       225 001000       226 001010       227 001013       228 001015       232 001021       233 001033
    236 001040       238 001041       242 001047       243 001054


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
