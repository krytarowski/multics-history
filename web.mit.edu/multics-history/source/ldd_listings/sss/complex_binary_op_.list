	COMPILATION LISTING OF SEGMENT complex_binary_op_
	Compiled by: Multics PL/I Compiler, Release 28d, of September 14, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 10/03/83  1429.4 mst Mon
	    Options: optimize map

        1 /* ******************************************************
        2*   *                                                    *
        3*   *                                                    *
        4*   * Copyright (c) 1972 by Massachusetts Institute of   *
        5*   * Technology and Honeywell Information Systems, Inc. *
        6*   *                                                    *
        7*   *                                                    *
        8*   ****************************************************** */
        9 
       10 complex_binary_op_:	proc(poperation,pop3,pdesc3,pop1,pdesc1,pop2,pdesc2);
       11 
       12 /* Program to implement PL/I Version II runtime complex binary operators.
       13*
       14*	Modified:	June 9, 1978 by RAB for better complex floating abs
       15*	Modified:	March 2, 1978 by RAB for better complex floating divide
       16*   Written by Richard A. Barnes October 16, 1972.  */
       17 
       18 
       19 dcl	poperation fixed bin(17),
       20 	pop3 bit(144) unaligned,
       21 	pdesc3 bit(36) aligned,
       22 	pop1 bit(144) unaligned,
       23 	pdesc1 bit(36) aligned,
       24 	pop2 bit(144) unaligned,
       25 	pdesc2 bit(36) aligned;
       26 
       27 dcl	operation fixed bin(17);
       28 
       29 dcl	1 desc1 aligned,
       30 		2 flag bit(1) unal,
       31 		2 type bit(6) unal,
       32 		2 packed bit(1) unal,
       33 		2 number_dims bit(4) unal,
       34 		2 scale bit(12) unal,
       35 		2 precision bit(12) unal;
       36 
       37 dcl	1 desc2 like desc1 aligned;
       38 dcl	1 desc3 like desc1 aligned;
       39 
       40 dcl  (	sa based(addr(a)),
       41 	sb based(addr(b)),
       42 	sc based(addr(c)),
       43 	sd based(addr(d)),
       44 	se based(addr(e)),
       45 	sf based(addr(f))) bit(72) aligned;
       46 
       47 dcl	(a,b,c,d,e,f) float bin(63);
       48 
       49 dcl	length fixed bin(17);
       50 
       51 dcl  (	ia based(addr(a)),
       52 	ib based(addr(b)),
       53 	ic based(addr(c)),
       54 	id based(addr(d)),
       55 	ie based(addr(e)),
       56 	if based(addr(f))) fixed bin(71);
       57 
       58 dcl  (	comparison	init(0),
       59 	addition		init(1),
       60 	subtraction	init(2),
       61 	multiplication	init(3),
       62 	division		init(4),
       63 	negate		init(5),
       64 	real_fun		init(6),
       65 	imag_fun		init(7),
       66 	round_fun		init(8),
       67 	complex_fun	init(9),
       68 	abs_fun		init(10),
       69 	conjg_fun		init(11)) fixed bin(17) internal static;
       70 
       71 dcl	based_fb based fixed bin(17);
       72 dcl	comp fixed bin(17);
       73 
       74 dcl	(ac,bd,ad,bc,cd,denom) float bin(63);
       75 
       76 dcl	1 dop1,
       77 		2 scale1 fixed bin(17),
       78 		2 prec1 fixed bin(17),
       79 		2 p ptr,
       80 		2 q ptr;
       81 dcl	1 dop2,
       82 		2 scale2 fixed bin(17),
       83 		2 prec2 fixed bin(17),
       84 		2 r ptr,
       85 		2 s ptr;
       86 dcl	1 dop3,
       87 		2 scale3 fixed bin(17),
       88 		2 prec3 fixed bin(17),
       89 		2 t ptr,
       90 		2 u ptr;
       91 
       92 dcl	(d1_scale,d2_scale) fixed bin(17);
       93 
       94 dcl	rtype fixed bin(17);
       95 dcl	(t1,t2,t3,t4,t5,t6) fixed bin(71);
       96 dcl	dscale fixed bin(17);
       97 dcl	rscale fixed bin(17);	/* scale of result of our operations */
       98 dcl	ifloat bit(1) aligned;
       99 dcl	code fixed bin(17);
      100 
      101 /* Function Definitions */
      102 
      103 dcl	fixed_divide_ entry(fixed bin(71),fixed bin(71),fixed bin,fixed bin,fixed bin,fixed bin) returns (fixed bin(71));
      104 dcl	fixed_round_ entry(fixed bin(71),fixed bin,fixed bin) returns(fixed bin(71));
      105 dcl	float_round_ entry(float bin(63),fixed bin) returns(float bin(63));
      106 dcl	scaler_ entry(fixed bin(71),fixed bin,fixed bin);
      107 dcl	size_check_ entry(fixed bin(71),fixed bin) returns(fixed bin);
      108 dcl	pl1_signal_$help_plio2_signal_ entry (char(*),ptr,fixed bin(15),
      109 		char(256) varying,fixed bin(15));
      110 
      111 dcl	(addr,fixed,float,index,max,mod,null,round,sqrt,substr,string) builtin;
      112 /*  */
      113 
      114 
      115 /*
      116*	(e + fi) = pop3
      117*	(a + bi) = pop1
      118*	(c + di) = pop2
      119*
      120*	(a + bi) + (c + di) = ((a+c) + (b+d)i)
      121*	(a + bi) - (c + di) = ((a-c) + (b-d)i)
      122*	(a + bi) * (c + di) = ((a*c - b*d) + (a*d + b*c)i)
      123*
      124*	(a + bi) / (c + di) = ((__a*__c_+___b*__d)_ + (__b*__c_-___a*__d)_i)
      125*			   (c*c + d*d)   (c*c + d*d)
      126*
      127*	abs((a+bi)) = sqrt(a*a + b*b)
      128*
      129*	round((a+bi),pdesc2) = (round(a,pdesc2) + round(b,pdesc2)i)
      130*
      131*	- (a + bi) = (-a - bi)
      132*							*/
      133 
      134 /*  */
      135 /*  Internal procedure to get an operand into our work area */
      136 
      137 getrand:	proc(rand,pdesc,struct);
      138 
      139 dcl	rand bit(144) unal,
      140 	1 desc like desc1 aligned;
      141 dcl	1 pdesc like desc1 aligned;
      142 
      143 dcl	1 struct,
      144 		2 pscale fixed bin(17),
      145 		2 pprec fixed bin(17),
      146 		2 pp ptr,
      147 		2 qq ptr;
      148 
      149 dcl	prec fixed bin(17);
      150 dcl	(p,q) pointer;
      151 
      152 dcl  (	a based(p),
      153 	b based(q)) float bin(63);
      154 
      155 dcl  (	sa based(p),
      156 	sb based(q)) bit(72) aligned;
      157 
      158 dcl  (	ia based(p),
      159 	ib based(q)) fixed bin(71);
      160 
      161 dcl	float bit(1) aligned defined(ifloat);
      162 dcl	short bit(1) aligned;
      163 dcl	itype fixed bin(17);
      164 
      165 dcl	rp pointer init(addr(rand));
      166 
      167 dcl	rshort(2) float bin(27) based(rp);
      168 dcl	rlong(2) float bin(63) based(rp);
      169 dcl	ishort(2) fixed bin(35) based(rp);
      170 dcl	ilong(2) fixed bin(71) based(rp);
      171 
      172 dcl	ones bit(72) aligned internal static init((72)"1"b);
      173 
      174 begin:
      175 	string(desc) = string(pdesc);
      176 	short = substr(desc.type,6,1);
      177 	itype = fixed(desc.type,6);
      178 	prec = pprec;
      179 	p = pp;
      180 	q = qq;
      181 
      182 	if float then
      183 	do;
      184 		if desc.packed then
      185 		do;
      186 			length = prec + 9;
      187 			substr(sa,1,length) = substr(rand,1,length);
      188 			if itype < 5 then b = 0;	/* real */
      189 			else substr(sb,1,length) = substr(rand,length+1,length);	/* complex */
      190 		end;
      191 		else
      192 		do;
      193 			b = 0;
      194 			if short then	/* short */
      195 			do;
      196 				a = rshort(1);
      197 				if itype > 4 then b = rshort(2);	/* complex */
      198 			end;
      199 			else			/* long  */
      200 			do;
      201 				a = rlong(1);
      202 				if itype > 4 then b = rlong(2);	/* complex */
      203 			end;
      204 		end;
      205 	end;
      206 	else					/* fixed */
      207 	do;
      208 		if desc.packed then
      209 		do;
      210 			length = prec + 1;
      211 			substr(sa,72-length+1,length) = substr(rand,1,length);
      212 			if substr(rand,1,1) then substr(sa,1,72-length) = ones;
      213 			if itype < 5 then ib = 0;
      214 			else
      215 			do;
      216 				substr(sb,72-length+1,length) = substr(rand,length+1,length);
      217 				if substr(rand,length+1,1) then substr(sb,1,72-length) = ones;
      218 			end;
      219 		end;
      220 		else
      221 		do;
      222 			ib = 0;
      223 			if short then		/* short */
      224 			do;
      225 				ia = ishort(1);
      226 				if itype > 4 then ib = ishort(2);
      227 			end;
      228 			else
      229 			do;
      230 				ia = ilong(1);
      231 				if itype > 4 then ib = ilong(2);
      232 			end;
      233 		end;
      234 	end;
      235 end;
      236 
      237 /*  */
      238 
      239 begin:
      240 	dop1.p = addr(a);
      241 	dop1.q = addr(b);
      242 	dop2.r = addr(c);
      243 	dop2.s = addr(d);
      244 	dop3.t = addr(e);
      245 	dop3.u = addr(f);
      246 
      247 	ia,ib,ic,id,ie,if = 0;
      248 	string(desc1) = pdesc1;
      249 	string(desc3) = pdesc3;
      250 	prec1 = fixed(desc1.precision,12);
      251 	prec3 = fixed(desc3.precision,12);
      252 	operation = poperation;
      253 	rtype = mod(fixed(desc1.type,6),4);
      254 	ifloat = rtype=0|rtype=3;
      255 	call getrand(pop1,desc1,dop1);
      256 	if operation < negate | operation = complex_fun then
      257 	do;
      258 		string(desc2) = pdesc2;
      259 		prec2 = fixed(desc2.precision,12);
      260 		call getrand(pop2,desc2,dop2);
      261 	end;
      262 
      263 	if ifloat then		/* float */
      264 	do;
      265 		length = prec3 + 9;
      266 		if ^desc3.packed then if length > 36 then length = 72;
      267 					       else length = 36;
      268 		go to float_op(operation);
      269 
      270 /* comparison */
      271 
      272 float_op(0):
      273 		comp = 1;		/* ^= */
      274 		if a = c then if b = d then comp = 0;		/* = */
      275 		addr(pop3)->based_fb = comp;
      276 		return;
      277 
      278 /* addition */
      279 
      280 float_op(1):
      281 		e = a + c;
      282 		f = b + d;
      283 		go to return_float;
      284 
      285 /* subtraction */
      286 
      287 float_op(2):
      288 		e = a - c;
      289 		f = b - d;
      290 		go to return_float;
      291 
      292 /* multiplication or division */
      293 
      294 float_op(3):	float_op(4):
      295 		ac = a*c;
      296 		bd = b*d;
      297 		ad = a*d;
      298 		bc = b*c;
      299 		if operation = multiplication then
      300 		do;
      301 			e = ac - bd;
      302 			f = ad + bc;
      303 			go to return_float;
      304 		end;
      305 		else	/* division */
      306 		do;
      307 			if abs(d) < abs(c)
      308 			then do;
      309 			     cd = d/c;
      310 			     denom = c + d*cd;
      311 			     e = (a + b*cd) / denom;
      312 			     f = (b - a*cd) / denom;
      313 			     end;
      314 
      315 			else do;
      316 			     cd = c/d;
      317 			     denom = c*cd + d;
      318 			     e = (a*cd + b) / denom;
      319 			     f = (b*cd - a) / denom;
      320 			     end;
      321 
      322 			go to return_float;
      323 		end;
      324 
      325 /* negate */
      326 
      327 float_op(5):
      328 		e = -a;
      329 		f = -b;
      330 		go to return_float;
      331 
      332 /* real */
      333 
      334 float_op(6):
      335 		e = a;
      336 		go to return_real;
      337 
      338 /* imag */
      339 
      340 float_op(7):
      341 		e = b;
      342 		go to return_real;
      343 
      344 /* round */
      345 
      346 float_op(8):
      347 		e = float_round_(a,prec2);
      348 		f = float_round_(b,prec2);
      349 		go to return_float;
      350 
      351 /* complex */
      352 
      353 float_op(9):
      354 		e = a;
      355 		f = c;
      356 		go to return_float;
      357 
      358 /* abs */
      359 
      360 float_op(10):
      361 		a = abs(a);
      362 		b = abs(b);
      363 
      364 		if a ^= 0.0e0
      365 		then if b ^= 0.0e0
      366 		     then if a > b
      367 			then e = a * sqrt(1.0e0b + (b/a)*(b/a));
      368 			else e = b * sqrt(1.0e0b + (a/b)*(a/b));
      369 		     else e = a;
      370 		else e = b;
      371 
      372 		go to return_real;
      373 
      374 /* conjg */
      375 
      376 float_op(11):
      377 		e = a;
      378 		f = -b;
      379 
      380 return_float:
      381 		substr(pop3,length+1,length) = substr(sf,1,length);
      382 return_real:
      383 		substr(pop3,1,length) = substr(se,1,length);
      384 		return;
      385 	end;
      386 /*  */
      387 	else				/* fixed point */
      388 	do;
      389 		scale1 = fixed(desc1.scale,12);
      390 		if scale1 > 2047 then scale1 = scale1 - 4096;
      391 		scale3 = fixed(desc3.scale,12);
      392 		if scale3 > 2047 then scale3 = scale3 - 4096;
      393 		if operation < negate | operation = complex_fun then
      394 		do;
      395 			scale2 = fixed(desc2.scale,12);
      396 			if scale2 > 2047 then scale2 = scale2 - 4096;
      397 		end;
      398 		length = prec3 + 1;
      399 		if ^desc3.packed then if length > 36 then length = 72;
      400 					       else length = 36;
      401 
      402 		code = 0;
      403 		rscale = scale1;
      404 		go to fixed_op(operation);
      405 
      406 /* comparison, addition, or subtraction */
      407 
      408 fixed_op(0):	fixed_op(1):	fixed_op(2):	fixed_op(9):
      409 
      410 		rscale = max(scale1,scale2);
      411 		dscale = scale1 - scale2;
      412 		if dscale > 0 then
      413 		do;
      414 			call scaler_(ic,dscale,code);
      415 			call scaler_(id,dscale,code);
      416 		end;
      417 		else if dscale < 0 then
      418 		do;
      419 			dscale = -dscale;
      420 			call scaler_(ia,dscale,code);
      421 			call scaler_(ib,dscale,code);
      422 		end;
      423 
      424 		if operation = comparison then
      425 		do;
      426 			comp = 1;		/* ^= */
      427 			if ia = ic then if ib = id then comp = 0;	/* = */
      428 			addr(pop3)->based_fb = comp;
      429 			return;
      430 		end;
      431 
      432 		if operation = addition then
      433 		do;
      434 			ie = ia + ic;
      435 			if = ib + id;
      436 			go to return_fixed;
      437 		end;
      438 
      439 		if operation = subtraction then
      440 		do;
      441 			ie = ia - ic;
      442 			if = ib - id;
      443 			go to return_fixed;
      444 		end;
      445 
      446 		if operation = complex_fun then
      447 		do;
      448 			ie = ia;
      449 			if = ic;
      450 			go to return_fixed;
      451 		end;
      452 
      453 /* multiplication or division */
      454 
      455 fixed_op(3):	fixed_op(4):
      456 		t1 = ia*ic;
      457 		t2 = ib*id;
      458 		t3 = ia*id;
      459 		t4 = ib*ic;
      460 		if operation = multiplication then
      461 		do;
      462 			ie = t1 - t2;
      463 			if = t3 + t4;
      464 			rscale = scale1 + scale2;
      465 			go to return_fixed;
      466 		end;
      467 		else		/* division */
      468 		do;
      469 			d1_scale = scale1 + scale2;
      470 			d2_scale = scale2 + scale2;
      471 			t5 = ic*ic;
      472 			t6 = id*id;
      473 			t5 = t5 + t6;
      474 			t1 = t1 + t2;
      475 			t3 = t4 - t3;
      476 			ie = fixed_divide_(t1,t5,d1_scale,d2_scale,scale3,code);
      477 			if = fixed_divide_(t3,t5,d1_scale,d2_scale,scale3,code);
      478 			rscale = scale3;
      479 			go to return_fixed;
      480 		end;
      481 
      482 /* negate */
      483 
      484 fixed_op(5):
      485 		ie = -ia;
      486 		if = -ib;
      487 		go to return_fixed;
      488 
      489 /* real */
      490 
      491 fixed_op(6):
      492 		ie = ia;
      493 		go to return_fixed_real;
      494 
      495 /* imag */
      496 
      497 fixed_op(7):
      498 		ie = ib;
      499 		go to return_fixed_real;
      500 
      501 /* round */
      502 
      503 fixed_op(8):
      504 		ie = fixed_round_(ia,prec2,scale1);
      505 		if = fixed_round_(ib,prec2,scale1);
      506 		rscale = prec2;
      507 		go to return_fixed;
      508 
      509 /* abs */
      510 
      511 fixed_op(10):
      512 		ie = fixed(sqrt(float(ia*ia + ib*ib,63)),71);
      513 		go to return_fixed_real;
      514 
      515 /* conjg */
      516 
      517 fixed_op(11):
      518 		ie = ia;
      519 		if = -ib;
      520 return_fixed:
      521 		dscale = scale3 - rscale;
      522 		if dscale ^= 0 then call scaler_(if,dscale,code);
      523 		if code ^= 0 then go to signal;
      524 		substr(pop3,length+1,length) = substr(sf,72-length+1,length);
      525 		if size_check_(if,length) ^= 0 then go to signal;
      526 
      527 return_fixed_real_1:
      528 		if dscale ^= 0 then
      529 		do;
      530 			call scaler_(ie,dscale,code);
      531 			if code ^= 0 then go to signal;
      532 		end;
      533 		substr(pop3,1,length) = substr(se,72-length+1,length);
      534 		if size_check_(ie,length) ^= 0 then go to signal;
      535 		return;
      536 
      537 return_fixed_real:
      538 		dscale = scale3 - rscale;
      539 		go to return_fixed_real_1;
      540 	end;
      541 
      542 /* Signal SIZE condition */
      543 
      544 signal:	call pl1_signal_$help_plio2_signal_("size",null,243,"",0);
      545 
      546 end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/03/83  1005.7  complex_binary_op_.pl1            >spec>on>pl128d>complex_binary_op_.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a                                      based           float bin(63)            dcl 152 in procedure "getrand" set ref 196* 201*
a                               000104 automatic       float bin(63)            dcl 47 in procedure "complex_binary_op_" set ref 239
                                                                                  247 274 280 287 294 297 311 312 318 319 327 334
                                                                                  346* 353 360* 360 364 364 364 364 364 368 368 369
                                                                                  376 420 427 434 441 448 455 458 484 491 503 511
                                                                                  511 517
ac                              000122 automatic       float bin(63)            dcl 74 set ref 294* 301
ad                              000126 automatic       float bin(63)            dcl 74 set ref 297* 302
addition                               constant        fixed bin(17,0)          initial dcl 58 ref 432
addr                                                   builtin function         dcl 111 ref 165 239 241 242 243 244 245 247 247 247
                                                                                  247 247 247 275 380 382 414 415 420 421 427 427
                                                                                  427 427 428 434 434 434 435 435 435 441 441 441
                                                                                  442 442 442 448 448 449 449 455 455 457 457 458
                                                                                  458 459 459 462 463 471 471 472 472 476 477 484
                                                                                  484 486 486 491 491 497 497 503 503 505 505 511
                                                                                  511 511 511 511 517 517 519 519 522 524 525 530
                                                                                  533 534
b                                      based           float bin(63)            dcl 152 in procedure "getrand" set ref 188* 193*
                                                                                  197* 202*
b                               000106 automatic       float bin(63)            dcl 47 in procedure "complex_binary_op_" set ref 241
                                                                                  247 274 282 289 296 298 311 312 318 319 329 340
                                                                                  348* 362* 362 364 364 364 364 368 368 368 370 378
                                                                                  421 427 435 442 457 459 486 497 505 511 511 519
based_fb                               based           fixed bin(17,0)          dcl 71 set ref 275* 428*
bc                              000130 automatic       float bin(63)            dcl 74 set ref 298* 302
bd                              000124 automatic       float bin(63)            dcl 74 set ref 296* 301
c                               000110 automatic       float bin(63)            dcl 47 set ref 242 247 274 280 287 294 29N          requested by Vu.Multics.m Level=4∂ $í x TÀÑÄø 8  ˇˇDESTROY            Vu.Multics.m abs2 004100035323 (logo)access_audit  †  Ä     ﬂVu                    Multics  m    @”                        ∂ $í xTÀÑ:Ä <  ˇˇLOGOUT             Vu.Multics.m Q 3 abs2   0:11 $0.62 (logo)access_audit  †  Ä     ﬂVu                    Multics  m    @”                        ∂ $í xTŒÏcÆ 7 ( ˇˇLOGIN              AWTaylor.Multics int a.h117 (create)access_audit   †  Ä     ‡AWTaylor              Multics  a                                e n8     a.h117                          VIP7400_DTR                     none∂ $í x TŒÓÀ: A  ˇˇCREATE             AWTaylor.Multics.a a.h117 004100035324 (login)access_audit     †  Ä     ‡AWTaylor              Multics  a    @‘                        ∂ $í xTŒCû— H R ˇˇLOGIN              WAAnderson.SysMaint Q 1 abs2 [mail_to_forum] (create)access_audit  †  Ä     ·WAAnderson            SysMaint m                                ç Cn8     abs2                                                            none>udd>sm>wa>new_tcp/ip>mail_to_forum.absin                                                                                                                               ∂ $í x	 TŒFà B  ˇˇCREATE             WAAnderson.SysMaint.m abs2 005100035325 (login)access_audit    †  Ä     ·WAAnderson            SysMaint m    @’                        ∂ $í x
  TŒº}% =   ˇˇABS LOGIN          requested by WAAnderson.SysMaint.m Level=4   ∂ $í x TŒ≈çŒ A  ˇˇDESTROY            WAAnderson.SysMaint.m abs2 005100035325 (logo)access_audit     †  Ä     ·WAAnderson            SysMaint m    @’                        ∂ $í xTŒ≈¨‡ E  ˇˇLOGOUT             WAAnderson.SysMaint.m Q 1 abs2   0:16 $0.91 (logo)access_audit     †  Ä     ·WAAnderson            SysMaint m    @’                        ∂ $í x TŒ˛™Z <  ˇˇDESTROY            Estock.NMLPROD.m abs1 006100035321 (logo)access_audit  †  Ä     ›Estock                NMLPROD  m    @—                        ∂ $í xTŒˇ  A  ˇˇLOGOUT             Estock.NMLPROD.m Q 3 abs1  13: 3 $43.53 (logo)access_audit     †  Ä     ›Estock                NMLPROD  m    @—                        ∂ $í x T—Üç… l 6 ˇˇDIALOUT            channel sty.u_telnet_08 from Internet.Daemon.z 003700030105 Destination= XSTY_TELNET TVT5access_audit  ∞e  Ä      	Internet              Daemon   z@   ¿E                        Ä sty.u_telnet_08                                                   STY_USER                                                        ∂ $í x T—áâi ] 6 ˇˇATTACH             channel sty.u_telnet_08 to Internet.Daemon.z 003700030105 Service=dial_outaccess_audit     ∞!  Ä      	Internet              Daemon   z¿   ¿E                        Ä sty.u_telnet_08                                                   STY_USER                                                        ∂ $í xT—ó!π @ ( ˇˇLOGIN              Westcott.Fortran int sty.s_telnet_08 (create)access_audit  †  Ä     ‚Westcott              Fortran  a                                e n     sty.s_telnet_08                 STY_TELNET                      none∂ $í x T—ôh J  ˇˇCREATE             Westcott.Fortran.a sty.s_telnet_08 006100035326 (login)access_audit    †  Ä     ‚Westcott              Fortran  a    @÷                        ∂ $í x T—å∏œ B   ˇˇact_ctl_: Automatic update: users = 26, pf=6, vcpu=0.695, rt=1.979  ∂ $í x T—Ã># l 6 ˇˇDIALOUT            channel sty.u_telnet_09 from Internet.Daemon.z 003700030105 Destination= XSTY_TELNET TVT8access_audit  ∞e  Ä      	Internet              Daemon   z@   ¿E                        Ä sty.u_telnet_09                                                   STY_USER                                                        ∂ $í x T—Õw ] 6 ˇˇATTACH             channel sty.u_telnet_09 to Internet.Daemon.z 003700030105 Service=dial_outaccess_audit     ∞!  Ä      	Internet              Daemon   z¿   ¿E                        Ä 48
ia                                     based           fixed bin(71,0)          dcl 158 in procedure "getrand" set ref 225* 230*
ia                                     based           fixed bin(71,0)          dcl 51 in procedure "complex_binary_op_" set ref
                                                                                  247* 420* 427 434 441 448 455 458 484 491 503* 511
                                                                                  511 517
ib                                     based           fixed bin(71,0)          dcl 158 in procedure "getrand" set ref 213* 222*
                                                                                  226* 231*
ib                                     based           fixed bin(71,0)          dcl 51 in procedure "complex_binary_op_" set ref
                                                                                  247* 421* 427 435 442 457 459 486 497 505* 511 511
                                                                                  519
ic                                     based           fixed bin(71,0)          dcl 51 set ref 247* 414* 427 434 441 449 455 459 471
                                                                                  471
id                                     based           fixed bin(71,0)          dcl 51 set ref 247* 415* 427 435 442 457 458 472 472
ie                                     based           fixed bin(71,0)          dcl 51 set ref 247* 434* 441* 448* 462* 476* 484*
                                                                                  491* 497* 503* 511* 517* 530* 534*
if                                     based           fixed bin(71,0)          dcl 51 set ref 247* 435* 442* 449* 463* 477* 486*
                                                                                  505* 519* 522* 525*
ifloat                          000202 automatic       bit(1)                   dcl 98 set ref 182 182 254* 263
ilong                                  based           fixed bin(71,0)          array dcl 170 ref 230 231
ishort                                 based           fixed bin(35,0)          array dcl 169 ref 225 226
itype                           000221 automatic       fixed bin(17,0)          dcl 163 set ref 177* 188 197 202 213 226 231
length                          000120 automatic       fixed bin(17,0)          dcl 49 set ref 186* 187 187 189 189 189 210* 211 211
                                                                                  211 212 216 216 216 216 217 217 265* 266 266* 267*
                                                                                  380 380 380 382 382 398* 399 399* 400* 524 524 524
                                                                                  524 525* 533 533 533 534*
max                                                    builtin function         dcl 111 ref 408
mod                                                    builtin function         dcl 111 ref 253
multiplication                         constant        fixed bin(17,0)          initial dcl 58 ref 299 460
negate                                 constant        fixed bin(17,0)          initial dcl 58 ref 256 393
null                                                   builtin function         dcl 111 ref 544 544
ones                            000030 constant        bit(72)                  initial dcl 172 ref 212 217
operation                       000100 automatic       fixed bin(17,0)          dcl 27 set ref 252* 256 256 268 299 393 393 404 424
                                                                                  432 439 446 460
p                               000214 automatic       pointer                  dcl 150 in procedure "getrand" set ref 179* 187 196
                                                                                  201 211 212 225 230
p                         2     000136 automatic       pointer                  level 2 in structure "dop1" dcl 76 in procedure
                                                                                  "complex_binary_op_" set ref 239*
packed                    0(07) 000103 automatic       bit(1)                   level 2 in structure "desc3" packed unaligned dcl 38
                                                                                  in procedure "complex_binary_op_" set ref 266 399
packed                    0(07) 000212 automatic       bit(1)                   level 2 in structure "desc" packed unaligned dcl 139
                                                                                  in procedure "getrand" set ref 184 208
pdesc                                  parameter       structure                level 1 dcl 141 ref 137 174
pdesc1                                 parameter       bit(36)                  dcl 19 ref 10 248
pdesc2                                 parameter       bit(36)                  dcl 19 ref 10 258
pdesc3                                 parameter       bit(36)                  dcl 19 ref 10 249
pl1_signal_$help_plio2_signal_  000022 constant        entry                    external dcl 108 ref 544
pop1                                   parameter       bit(144)                 unaligned dcl 19 set ref 10 255*
pop2                                   parameter       bit(144)                 unaligned dcl 19 set ref 10 260*
pop3                                   parameter       bit(144)                 unaligned dcl 19 set ref 10 275 380* 382* 428 524*
                                                                                  533*
poperation                             parameter       fixed bin(17,0)          dcl 19 ref 10 252
pp                        2            parameter       pointer                  level 2 dcl 143 ref 179
pprec                     1            parameter       fixed bin(17,0)          level 2 dcl 143 ref 178
prec                            000213 automatic       fixed bin(17,0)          dcl 149 set ref 178* 186 210
prec1                     1     000136 automatic       fixed bin(17,0)          level 2 dcl 76 set ref 250*
prec2                     1     000144 automatic       fixed bin(17,0)          level 2 dcl 81 set ref 259* 346* 348* 503* 505* 506
prec3                     1     000152 automatic       fixed bin(17,0)          level 2 dcl 86 set ref 251* 265 398
precision                 0(24) 000102 automatic       bit(12)                  level 2 in structure "desc2" packed unaligned dcl 37
                                                                                  in procedure "complex_binary_op_" set ref 259
precision                 0(24) 000101 automatic       bit(12)                  level 2 in structure "desc1" packed unaligned dcl 29
                                                                                  in procedure "complex_binary_op_" set ref 250
precision                 0(24) 000103 automatic       bit(12)                  level 2 in structure "desc3" packed unaligned dcl 38
                                                                                  in procedure "complex_binary_op_" set ref 251
q                         4     000136 automatic       pointer                  level 2 in structure "dop1" dcl 76 in procedure
                                                                                  "complex_binary_op_" set ref 241*
q                               000216 automatic       pointer                  dcl 150 in procedure "getrand" set ref 180* 188 189
                                                                                  193 197 202 213 216 217 222 226 231
qq                        4            parameter       pointer                  level 2 dcl 143 ref 180
r                         2     000144 automatic       pointer                  level 2 dcl 81 set ref 242*
rand                                   parameter       bit(144)                 unaligned dcl 139 set ref 137 165 187 189 211 212
                                                                                  216 217
rlong                                  based           float bin(63)            array dcl 168 ref 201 202
rp                              000222 automatic       pointer                  initial dcl 165 set ref 165* 196 197 201 202 225 226
                                                                                  230 231
rscale                          000201 automatic       fixed bin(17,0)          dcl 97 set ref 403* 408* 464* 478* 506* 520 537
rshort                                 based           float bin(27)            array dcl 167 ref 196 197
rtype                           000162 automatic       fixed bin(17,0)          dcl 94 set ref 253* 254 254
s                         4     000144 automatic       pointer                  level 2 dcl 81 set ref 243*
sa                                     based           bit(72)                  dcl 155 set ref 187* 211* 212*
sb                                     based           bit(72)                  dcl 155 set ref 189* 216* 217*
scale                     0(12) 000103 automatic       bit(12)                  level 2 in structure "desc3" packed unaligned dcl 38
                                                                                  in procedure "complex_binary_op_" set ref 391
scale                     0(12) 000102 automatic       bit(12)                  level 2 in structure "desc2" packed unaligned dcl 37
                                                                                  in procedure "complex_binary_op_" set ref 395
scale                     0(12) 000101 automatic       bit(12)                  level 2 in structure "desc1" packed unaligned dcl 29
                                                                                  in procedure "complex_binary_op_" set ref 389
scale1                          000136 automatic       fixed bin(17,0)          level 2 dcl 76 set ref 389* 390 390* 390 403 408 411
                                                                                  464 469 503* 505*
scale2                          000144 automatic       fixed bin(17,0)          level 2 dcl 81 set ref 395* 396 396* 396 408 411 464
                                                                                  469 470 470
scale3                          000152 automatic       fixed bin(17,0)          level 2 dcl 86 set ref 391* 392 392* 392 476* 477*
                                                                                  478 520 537
scaler_                         000016 constant        entry                    external dcl 106 ref 414 415 420 421 522 530
se                                     based           bit(72)                  dcl 40 ref 382 533
sf                                     based           bit(72)                  dcl 40 ref 380 524
short                           000220 automatic       bit(1)                   dcl 162 set ref 176* 194 223
size_check_                     000020 constant        entry                    external dcl 107 ref 525 534
sqrt                                                   builtin function         dcl 111 ref 364 368 511
string                                                 builtin function         dcl 111 set ref 174* 174 248* 249* 258*
struct                                 parameter       structure                level 1 unaligned dcl 143 ref 137
substr                                                 builtin function         dcl 111 set ref 176 187* 187 189* 189 211* 211 212
                                                                                  212* 216* 216 217 217* 380* 380 382* 382 524* 524
                                                                                  533* 533
subtraction                            constant        fixed bin(17,0)          initial dcl 58 ref 439
t                         2     000152 automatic       pointer                  level 2 dcl 86 set ref 244*
t1                              000164 automatic       fixed bin(71,0)          dcl 95 set ref 455* 462 474* 474 476*
t2                              000166 automatic       fixed bin(71,0)          dcl 95 set ref 457* 462 474
t3                              000170 automatic       fixed bin(71,0)          dcl 95 set ref 458* 463 475* 475 477*
t4                              000172 automatic       fixed bin(71,0)          dcl 95 set ref 459* 463 475
t5                              000174 automatic       fixed bin(71,0)          dcl 95 set ref 471* 473* 473 476* 477*
t6                              000176 automatic       fixed bin(71,0)          dcl 95 set ref 472* 473
type                      0(01) 000101 automatic       bit(6)                   level 2 in structure "desc1" packed unaligned dcl 29
                                                                                  in procedure "complex_binary_op_" set ref 253
type                      0(01) 000212 automatic       bit(6)                   level 2 in structure "desc" packed unaligned dcl 139
                                                                                  in procedure "getrand" set ref 176 177
u                         4     000152 automatic       pointer                  level 2 dcl 86 set ref 245*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
abs_fun                                internal static fixed bin(17,0)          initial dcl 58
conjg_fun                              internal static fixed bin(17,0)          initial dcl 58
division                               internal static fixed bin(17,0)          initial dcl 58
imag_fun                               internal static fixed bin(17,0)          initial dcl 58
index                                                  builtin function         dcl 111
real_fun                               internal static fixed bin(17,0)          initial dcl 58
round                                                  builtin function         dcl 111
round_fun                              internal static fixed bin(17,0)          initial dcl 58
sa                                     based           bit(72)                  dcl 40
sb                                     based           bit(72)                  dcl 40
sc                                     based           bit(72)                  dcl 40
sd                                     based           bit(72)                  dcl 40

NAMES DECLARED BY EXPLICIT CONTEXT.
begin                           001374 constant        label                    dcl 174 in procedure "getrand"
begin                           000101 constant        label                    dcl 239 in procedure "complex_binary_op_"
complex_binary_op_              000074 constant        entry                    external dcl 10
fixed_op                        000014 constant        label                    array(0:11) dcl 408 ref 404
float_op                        000000 constant        label                    array(0:11) dcl 272 ref 268
getrand                         001370 constant        entry                    internal dcl 137 ref 255 260
return_fixed                    001210 constant        label                    dcl 520 ref 436 443 450 465 479 487 507
return_fixed_real               001323 constant        label                    dcl 537 ref 493 499 513
return_fixed_real_1             001256 constant        label                    dcl 527 ref 539
return_float                    000523 constant        label                    dcl 380 ref 283 290 303 322 330 349 356
return_real                     000531 constant        label                    dcl 382 ref 336 342 372
signal                          001327 constant        label                    dcl 544 ref 523 525 531 534

NAME DECLARED BY CONTEXT OR IMPLICATION.
abs                                                    builtin function         ref 307 307 360 362

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1666        1712    1565        1676
Length      2100    1565        24         151     101           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
complex_binary_op_                  261 external procedure  is an external procedure.  
getrand                                 internal procedure  shares stack frame of external procedure complex_binary_op_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
complex_binary_op_       000100 operation                   complex_binary_op_
                         000101 desc1                       complex_binary_op_
                         000102 desc2                       complex_binary_op_
                         000103 desc3                       complex_binary_op_
                         000104 a                           complex_binary_op_
                         000106 b                           complex_binary_op_
                         000110 c                           complex_binary_op_
                         000112 d                           complex_binary_op_
                         000114 e                           complex_binary_op_
                         000116 f                           complex_binary_op_
                         000120 length                      complex_binary_op_
                         000121 comp                        complex_binary_op_
                         000122 ac                          complex_binary_op_
                         000124 bd                          complex_binary_op_
                         000126 ad                          complex_binary_op_
                         000130 bc                          complex_binary_op_
                         000132 cd                          complex_binary_op_
                         000134 denom                       complex_binary_op_
                         000136 dop1                        complex_binary_op_
                         000144 dop2                        complex_binary_op_
                         000152 dop3                        complex_binary_op_
                         000160 d1_scale                    complex_binary_op_
                         000161 d2_scale                    complex_binary_op_
                         000162 rtype                       complex_binary_op_
                         000164 t1                          complex_binary_op_
                         000166 t2                          complex_binary_op_
                         000170 t3                          complex_binary_op_
                         000172 t4                          complex_binary_op_
                         000174 t5                          complex_binary_op_
                         000176 t6                          complex_binary_op_
                         000200 dscale                      complex_binary_op_
                         000201 rscale                      complex_binary_op_
                         000202 ifloat                      complex_binary_op_
                         000203 code                        complex_binary_op_
                         000212 desc                        getrand
                         000213 prec                        getrand
                         000214 p                           getrand
                         000216 q                           getrand
                         000220 short                       getrand
                         000221 itype                       getrand
                         000222 rp                          getrand

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out_desc   call_ext_out        return              fl2_to_fx2          mpfx3
mod_fx1             ext_entry           dsqrt

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
fixed_divide_                 fixed_round_                  float_round_
pl1_signal_$help_plio2_signal_                              scaler_                       size_check_

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     10 000066       239 000101       241 000103       242 000105       243 000107       244 000111       245 000113
    247 00011.Daemon.z 003700030105 Destination= XSTY_TELNET TVT8access_audit  ∞e  Ä      	Internet              Daemon   z@   ¿E                        Ä sty.u_telnet_09                                                   STY_USER                                                        ∂ $í x* TŸb=î ] 6 ˇˇATTACH             channel sty.u_telnet_09 to Internet.Daemon.z 003700030105 Service=dial_outaccess_audit     ∞!  Ä      	Internet              Daemon   z¿   ¿E                        Ä sty.u_telnet_09                                                   STY_USER                                                        ∂ $í x+TŸvÚ @ ( ˇˇLOGIN              Maucieri.Multics int sty.s_telnet_09 (create)access_audit  †  Ä     ÊMaucieri              Multics  a                                e n8     sty.s_telnet_09                 STY_TELNET                      none∂ $í x, TŸx˘m J  ˇˇCREATE             Maucieri.Multics.a sty.s_telnet_09 006700035332 (login)access_audit    †  Ä     ÊMaucieri              Multics  a    ¿⁄                        ∂ $í x-T€K" 5 R ˇˇLOGIN              Vu.Multics Q FG abs1 [TR] (create)access_audit     †  Ä     ÁVu                    Multics  m                                • nx     abs1                                                            none>udd>m>Vu>lib>ecs>TR.absin                                                                                                                                              ∂ $í x. T€N}ª 9  ˇˇCREATE             Vu.Multics.m abs1 005100035333 (login)access_audit     †  Ä     ÁVu                    Multics  m    @€                        ∂ $í x/  T€mÌÍ 4   ˇˇABS LOGIN          requested by Vu.Multics.m Level=4∂ $í x0 T€q◊Ù 8  ˇˇDESTROY            Vu.Multics.m abs1 005100035333 (logo)access_audit  †  Ä     ÁVu                    Multics  m    @€                        ∂ $í x1T€qÙæ =  ˇˇLOGOUT             Vu.Multics.m Q FG abs1   0: 5 $0.33 (logo)access_audit     †  Ä     ÁVu                    Multics  m    @€                        ∂ $í x2T‹2, H R ˇˇLOGIN              WAAnderson.SysMaint Q 1 abs1 [mail_to_forum] (create)access_audit  †  Ä     ËWAAnderson            SysMaint m                                ç Cn8     abs1                                                            none>udd>sm>wa>new_tcp/ip>mail_to_forum.absin                                                                                                                               ∂ $í x3 T‹`Ú B  ˇˇCREATE             WAAnderson.SysMaint.m abs1 005100035334 (login)access_audit    †  Ä     ËWAAnderson            SysMaint m    @‹                        ∂ $í x4  T‹,J— =   ˇˇABS LOGIN          requested by WAAnderson.SysMaint.m Level=4   ∂ $í x5 T‹0õÔ A  ˇˇDESTROY            WAAnderson.SysMaint.m abs1 005100035334 (logo)access_audit     †  Ä     ËWAAnderson            SysMaint m    @‹                        ∂ $í x6T‹0∏i E  ˇˇLOGOUT             WAAnderson.SysMaint.m Q 1 abs1   0: 4 $0.26 (logo)access_audit     †  Ä     ËWAAnderson            SysMaint m    @‹                        ∂ $í x7T›p,ß 4 ( ˇˇLOGIN              Frere.Multics int a.h119 (create)access_audit  †  Ä     ÈFrere                 Multics  a                          

                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
