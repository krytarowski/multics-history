	COMPILATION LISTING OF SEGMENT db_print
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/04/82  1822.6 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 db_print: proc (arg_iocb_ptr, arg_output_switch, data_ptr, mode, rel_offset, arg_no_prt, sntp, data_type, data_size);
       12 
       13 /* Modified 10/76 by S. Barr to add COBOL data types and to use data_size with octal format */
       14 /* Modified 1/77 by S. Barr to add number to print to "l" mode */
       15 /* Modified 771116 by PG to add el & fl output modes */
       16 
       17 /* parameters */
       18 
       19 dcl  arg_iocb_ptr ptr;				/* arg_iocb pointer for iox_ ioa_ calls */
       20 dcl  arg_output_switch char (32);			/* for print_text_ (to be removed eventually) */
       21 dcl  data_type fixed bin;
       22 dcl  data_size fixed bin;
       23 dcl  data_ptr ptr,
       24      mode char (*) aligned,
       25     (rel_offset, arg_no_prt) fixed bin;
       26 
       27 /* entries */
       28 
       29 dcl
       30      print_text_ ext entry (ptr, fixed bin, char (*) aligned),
       31      db_get_sym ext entry (ptr),
       32      get_wdir_ ext entry returns (char (168) aligned),
       33      ioa_$ioa_switch entry options (variable),
       34      ioa_$ioa_switch_nnl entry options (variable),
       35      ioa_$rsnnl entry options (variable),
       36      db_line_no ext entry (ptr, fixed bin, fixed bin, fixed bin, fixed bin);
       37 dcl  comp_8_to_ascii_ entry (bit (*), char (*));
       38 dcl  gr_print_ entry (char (*));
       39 dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
       40 dcl  hcs_$initiate entry (char (*), char (*), char (*), fixed bin, fixed bin, ptr, fixed bin (35));
       41 dcl  iox_$put_chars entry (ptr, ptr, fixed bin, fixed bin (35));
       42 dcl  stu_$get_line entry (ptr, fixed bin, fixed bin, fixed bin, fixed bin, fixed bin, fixed bin);
       43 dcl  com_err_ entry options (variable);
       44 dcl  condition_ entry (char (*), entry);
       45 dcl  reversion_ entry (char (*));
       46 
       47 /* automatic & based */
       48 
       49 dcl  string char (64),
       50      num fixed bin,
       51      iocb_ptr ptr,
       52      output_switch char (32) aligned;			/* output_switch: default is user_output */
       53 
       54 dcl
       55      i9 fixed bin (9),
       56     (no_prt, j, k, first, line_no, no, okp) fixed bin,
       57      code fixed bin (35),
       58      i fixed bin;
       59 
       60 
       61 dcl  line_offset fixed bin;				/* char. position of source line */
       62 dcl  line_length fixed bin;				/* length of source line */
       63 dcl  file fixed bin;				/* file containing source line */
       64 
       65 dcl  smap_ptr ptr;
       66 dcl  packed_ptr ptr unal based (pp);
       67 dcl  packed_bit_offset bit (6) based (pp);
       68 
       69 dcl  hp ptr;
       70 dcl  pp ptr,
       71      based_ptr ptr based;
       72 
       73 dcl
       74      bits bit (arg_no_prt) based (pp),
       75      cbit_offset char (8) aligned,
       76      str char (no_prt) based (pp);
       77 
       78 dcl 1 copy_its aligned like its ;
       79 
       80 
       81 dcl  format char (20) var aligned init ("^6o ^6o ^v(^");
       82 dcl  per_line fixed bin init (4);			/* no. of items per line */
       83 dcl  octal bit (1) init ("0"b);			/* 1 = octal print out */
       84 dcl  packed_decimal bit (1) init ("0"b);		/* 1 = packed_decimal format */
       85 dcl  float bit (1) init ("0"b);			/* 1 = float binary data */
       86 dcl (offset, loc) fixed bin;
       87 dcl 1 ff aligned based (pp),
       88     2 (w0, w1, w2, w3, w4) fixed bin (35);
       89 dcl  print_err bit (1) init ("1"b);			/* 1 = print error message */
       90 
       91 /* builtins */
       92 
       93 declare (addr, addrel, baseno, binary, divide, fixed, max, min, null, ptr, rel, substr, mod, unspec, hbound) builtin;
       94 
       95 /* external static */
       96 
       97 dcl  iox_$user_output ptr ext;
       98 
       99 /* internal static */
      100 
      101 dcl  bit_loc (8) int static options (constant) init (0, 5, 9, 14, 18, 23, 27, 32);
      102 dcl  last_source char (32) static init (" ");		/* last source used for printing */
      103 dcl  MODES (21) char (6) static init ("a", "b", "p", "P", "i", "I", "l", "s", "o", "h", "d", "f", "e", "g",
      104      "x", "comp-6", "comp-7", "comp-8", "comp-5", "fl", "el");
      105 
      106 /* include files */
      107 
  1     1 	/* BEGIN INCLUDE SEGMENT ...  component_info.incl.pl1   M. Weaver  4/26/72  */
  1     2 
  1     3 declare	1 ci aligned,
  1     4 	2 dcl_version fixed bin,		/* version number of this structure */
  1     5 	2 name char(32) aligned,		/* objectname of component segment */
  1     6 	2 text_start pointer,		/* ptr to component's section of text */
  1     7 	2 stat_start pointer,		/* pointer to component's section of internal static */
  1     8 	2 symb_start pointer,		/* pointer to component's first symbol block */
  1     9 	2 defblock_ptr pointer,		/* ptr to component's definition block */
  1    10 	2 text_lng fixed bin,		/* length of text section */
  1    11 	2 stat_lng fixed bin,		/* length of internal static */
  1    12 	2 symb_lng fixed bin,		/* length of symbol section */
  1    13 	2 n_blocks fixed bin,		/* number of symbol blocks in component's symbol section */
  1    14 	2 standard bit(1) aligned,		/* indicates whether component is in standard (new) format */
  1    15 	2 compiler char(8) aligned,		/* name of component's compiler */
  1    16 	2 compile_time fixed bin(71),		/* time component was compiled */
  1    17 	2 userid char(32) aligned,		/* id of creator of component */
  1    18 	2 cvers aligned,			/* version of component's compiler in printable form */
  1    19 	  3 offset bit(18) unaligned,		/* offset in words relative to symb_start */
  1    20 	  3 length bit(18) unaligned,		/* length of name in characters */
  1    21 	2 comment aligned,			/* component's comment */
  1    22 	  3 offset bit(18) unaligned,		/* offset in words relative to symb_start */
  1    23 	  3 length bit(18) unaligned,		/* length of comment in characters */
  1    24 	2 source_map fixed bin;		/* offset, rel to beg of symbol block, of component's source map */
  1    25 
  1    26 	/* END INCLUDE SEGMENT ... component_info.incl.pl1 */
      108 
  2     1 /*	BEGIN  INCLUDE  FILE ...  db_snt.incl.pl1  Last modified  Nov 1972.  WSS  */
  2     2 /*	Modified 8/75 to add internal static pointer by S.E. Barr */
  2     3 
  2     4 
  2     5 /*	Overlay of  segment name table.  */
  2     6 
  2     7 dcl	sntp	ptr;		/* Pointer to segment name table. */
  2     8 
  2     9 dcl     1	snt	based (sntp)  aligned,
  2    10 	2  ent_pt_name char(32),	/* Entry point name. */
  2    11 	2  ent_name    char(32),	/* Entry name of segment. */
  2    12 	2  dir_name    char(168),	/* Directory name. */
  2    13 	2  pp	     ptr,		/* Pointer to current procedure. */
  2    14 	2  sp          ptr,		/* Pointer to current stack frame. */
  2    15 	2  lp          ptr,		/* Pointer to linkage section. */
  2    16 	2  symp        ptr,		/* Pointer to current symbol table block. */
  2    17 	2  symflag     bit(1) unal,	/* ON => no symbol table defined. */
  2    18 	2  std	     bit(1) unal,	/* ON => standard symbol header.  */
  2    19 	2  headp	     ptr,		/* Pointer to current symbol header. */
  2    20 	2  static_ptr  ptr;		/* Pointer to current static section. */
  2    21 
  2    22 /*	END OF INCLUDE FILE...  db_snt.incl.pl1  */
      109 
  3     1 /* BEGIN INCLUDE FILE its.incl.pl1
  3     2*   modified 27 July 79 by JRDavis to add its_unsigned
  3     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
  3     4 
  3     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
  3     6     2 pad1 bit (3) unaligned,
  3     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
  3     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
  3     9     2 pad2 bit (9) unaligned,
  3    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
  3    11 
  3    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
  3    13     2 pad3 bit (3) unaligned,
  3    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
  3    15     2 pad4 bit (3) unaligned,
  3    16     2 mod bit (6) unaligned;				/* further modification */
  3    17 
  3    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
  3    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
  3    20     2 pad1 bit (27) unaligned,
  3    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
  3    22 
  3    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
  3    24     2 pad2 bit (3) unaligned,
  3    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
  3    26     2 pad3 bit (3) unaligned,
  3    27     2 mod bit (6) unaligned;				/* further modification */
  3    28 
  3    29 
  3    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
  3    31     2 pad1 bit (3) unaligned,
  3    32     2 segno fixed bin (15) unsigned unaligned,
  3    33     2 ringno fixed bin (3) unsigned unaligned,
  3    34     2 pad2 bit (9) unaligned,
  3    35     2 its_mod bit (6) unaligned,
  3    36 
  3    37     2 offset fixed bin (18) unsigned unaligned,
  3    38     2 pad3 bit (3) unaligned,
  3    39     2 bit_offset fixed bin (6) unsigned unaligned,
  3    40     2 pad4 bit (3) unaligned,
  3    41     2 mod bit (6) unaligned;
  3    42 
  3    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
  3    44     2 pr_no fixed bin (3) unsigned unaligned,
  3    45     2 pad1 bit (27) unaligned,
  3    46     2 itp_mod bit (6) unaligned,
  3    47 
  3    48     2 offset fixed bin (18) unsigned unaligned,
  3    49     2 pad2 bit (3) unaligned,
  3    50     2 bit_offset fixed bin (6) unsigned unaligned,
  3    51     2 pad3 bit (3) unaligned,
  3    52     2 mod bit (6) unaligned;
  3    53 
  3    54 
  3    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
  3    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
  3    57 
  3    58 /* END INCLUDE FILE   its.incl.pl1 */
      110 
  4     1 dcl	1 std_symbol_header	based aligned,
  4     2 	2 dcl_version	fixed bin,
  4     3 	2 identifier	char(8),
  4     4 	2 gen_number	fixed bin,
  4     5 	2 gen_created	fixed bin(71),
  4     6 	2 object_created	fixed bin(71),
  4     7 	2 generator	char(8),
  4     8 	2 gen_version	unaligned,
  4     9 	  3 offset	bit(18),
  4    10 	  3 size		bit(18),
  4    11 	2 userid		unaligned,
  4    12 	  3 offset	bit(18),
  4    13 	  3 size		bit(18),
  4    14 	2 comment		unaligned,
  4    15 	  3 offset	bit(18),
  4    16 	  3 size		bit(18),
  4    17 	2 text_boundary	bit(18) unaligned,
  4    18 	2 stat_boundary	bit(18) unaligned,
  4    19 	2 source_map	bit(18) unaligned,
  4    20 	2 area_pointer	bit(18) unaligned,
  4    21 	2 backpointer	bit(18) unaligned,
  4    22 	2 block_size	bit(18) unaligned,
  4    23 	2 next_block	bit(18) unaligned,
  4    24 	2 rel_text	bit(18) unaligned,
  4    25 	2 rel_def		bit(18) unaligned,
  4    26 	2 rel_link	bit(18) unaligned,
  4    27 	2 rel_symbol	bit(18) unaligned,
  4    28 	2 mini_truncate	bit(18) unaligned,
  4    29 	2 maxi_truncate	bit(18) unaligned;
      111 
  5     1 /* BEGIN INCLUDE FILE ... source_map.incl.pl1 */
  5     2 
  5     3 dcl	1 source_map	aligned based,
  5     4 	2 version		fixed bin,
  5     5 	2 number		fixed bin,
  5     6 	2 map(n refer(source_map.number))	 aligned,
  5     7 	  3 pathname	unaligned,
  5     8 	    4 offset	bit(18),
  5     9 	    4 size	bit(18),
  5    10 	  3 uid		bit(36),
  5    11 	  3 dtm		fixed bin(71);
  5    12 
  5    13 /* END INCLUDE FILE  ... source_map.incl.pl1 */
      112 
      113 
      114 /* program */
      115 
      116 	if arg_iocb_ptr = null then do;
      117 	     iocb_ptr = iox_$user_output;
      118 	     output_switch = "user_output";
      119 	end;
      120 	else do;
      121 	     output_switch = arg_output_switch;
      122 	     iocb_ptr = arg_iocb_ptr;
      123 	end;
      124 
      125 	no_prt = max (1, arg_no_prt);			/* get number of units to print */
      126 	pp = data_ptr;				/* get pointer to first word to be printed */
      127 	offset = rel_offset;			/* get offset within stack or linkage */
      128 	loc = fixed (rel (pp), 17);
      129 
      130 	call condition_ ("out_of_bounds", oob_handler);
      131 
      132 	do j = 1 to hbound (MODES, 1) while (mode ^= MODES (j));
      133 	end;
      134 	if j > hbound (MODES, 1) then do;
      135 	     call ioa_$ioa_switch (iocb_ptr, "Undefined output mode ""^a""", mode);
      136 	     return;
      137 	end;
      138 
      139 	goto label (j);
      140 
      141 /* a, x	character string */
      142 label (1):
      143 label (15):
      144 
      145 	call ioa_$ioa_switch_nnl (iocb_ptr, "^6o ^6o """, loc, offset);
      146 
      147 	if arg_no_prt > 0 then do;
      148 	     call iox_$put_chars (iocb_ptr, pp, arg_no_prt, code);
      149 	     if code ^= 0 then call com_err_ (code, "debug");
      150 	end;
      151 	call ioa_$ioa_switch (iocb_ptr, """");
      152 	return;
      153 
      154 /*  b	bit string */
      155 label (2):
      156 	call ioa_$ioa_switch (iocb_ptr, "^6o ^6o ""^b""b", loc, offset, bits);
      157 	return;
      158 
      159 /* p, P	pointer */
      160 label (3):
      161 label (4):
      162 
      163 	if data_size = 36 then no = 1;
      164 	else no = 2;
      165 
      166 	do j = 1 to no_prt;
      167 
      168 	     if no = 2 then do;
      169 		if pp -> its.its_mod ^= "100011"b | pp -> its.mod
      170 		then call ioa_$ioa_switch (iocb_ptr, "^6o ^6o  ^w ^w", loc, offset, w0, w1);
      171 		else do;
      172 		     i9 = fixed (pp -> its.bit_offset, 9); /* get bit offset of pointer */
      173 		     if i9 ^= 0 then call ioa_$rsnnl ("(^d)", cbit_offset, okp, i9); /* convert it to character */
      174 		     else cbit_offset = "";
      175 		     call ioa_$ioa_switch (iocb_ptr, "^6o ^6o  ^o|^o^a", loc, offset, fixed (baseno (pp -> based_ptr), 18), fixed (rel (pp -> based_ptr), 18), cbit_offset);
      176 		end;
      177 	     end;
      178 
      179 	     else do;
      180 		if binary (packed_bit_offset) > 35
      181 		then call ioa_$ioa_switch (iocb_ptr, "^6o ^6o  ^w", loc, offset, pp -> w0);
      182 		else call ioa_$ioa_switch (iocb_ptr, "^6o ^6o  ^p", loc, offset, packed_ptr);
      183 	     end;
      184 
      185 	     pp = addrel (pp, no);
      186 	     loc = loc + no;
      187 	     offset = offset + no;
      188 	end;
      189 	return;
      190 
      191 /*  i, I	instruction */
      192 label (5):
      193 label (6):
      194 	if sntp = null then okp = 0;			/* ol_dump calls without snt table */
      195 	else okp = 1;				/* Try to get line numbers */
      196 	j = 0;
      197 
      198 	do while (j < no_prt);
      199 
      200 	     if okp = 1 then do;			/* try to get source line */
      201 
      202 		call db_line_no (sntp, loc, first, no, line_no);
      203 		if first < 0 then do;		/* can't find source line no. */
      204 		     okp = 0;
      205 		     no = no_prt - j;
      206 		end;
      207 		else do;
      208 		     call ioa_$ioa_switch (iocb_ptr, "LINE NUMBER ^d", line_no);
      209 		     no = no - loc + first;		/* In case loc is in middle of line */
      210 		end;
      211 	     end;
      212 	     else no = no_prt;
      213 
      214 	     no = min (no, no_prt - j);
      215 	     call print_text_ (pp, no, output_switch);
      216 	     loc = loc + no;
      217 	     pp = addrel (pp, no);
      218 	     j = j + no;
      219 	end;
      220 	return;
      221 
      222 /*  l	instructions for a given line */
      223 label (7):
      224 	do j = 1 to no_prt;
      225 	     call db_line_no (sntp, loc, first, no, line_no);
      226 	     if first < 0 then goto ERROR_NO_LINE;
      227 	     call ioa_$ioa_switch (iocb_ptr, "LINE NUMBER ^d", line_no);
      228 	     call print_text_ (ptr (pp, first), no, output_switch);
      229 	     loc = loc + no;
      230 	end;
      231 
      232 	return;
      233 
      234 /*  s	source line */
      235 label (8):
      236 	call print_source;
      237 	return;
      238 
      239 /*  o, h	octal */
      240 label (9):
      241 label (10):
      242 	octal = "1"b;
      243 	format = format || ".3b ^)";
      244 	if mode = "o" then per_line = 8;
      245 	call print_data;
      246 	return;
      247 
      248 /*  d, comp-6, comp-7	decimal */
      249 label (11):
      250 label (16):
      251 label (17):
      252 	format = format || "13d^)";
      253 	call print_data;
      254 	return;
      255 
      256 /*  f	float binary */
      257 label (12):
      258 	float = "1"b;
      259 	format = format || "8.4f^)";
      260 	call print_data;
      261 	return;
      262 
      263 /*  e */
      264 label (13):
      265 	float = "1"b;
      266 	format = format || "8e^)";
      267 	call print_data;
      268 	return;
      269 
      270 /*  fl    float-long */
      271 
      272 label (20):
      273 	float = "1"b;
      274 	format = format || "19.6f^)";
      275 	call print_data;
      276 	return;
      277 
      278 /*  el    exponential-long */
      279 
      280 label (21):
      281 	float = "1"b;
      282 	format = format || "19e ^)";
      283 	call print_data;
      284 	return;
      285 
      286 /*  g	graphic */
      287 label (14):
      288 	call gr_print_ (str);
      289 	return;
      290 
      291 /*  comp-5,  comp-8	COBOL */
      292 label (18):
      293 label (19):
      294 	packed_decimal = "1"b;
      295 	call print_data;
      296 	return;
      297 
      298 out:						/* for the out_of_bounds_handler */
      299 	return;
      300 ERROR_NO_LINE: call ioa_$ioa_switch (iocb_ptr, "Cannot get line.");
      301 	return;
      302 
      303 /*  */
      304 /*  print_data prints "per_line" data items on one line.  It matches the data type with
      305*   the format to prevent ioa_ from doing a data conversion before printing.
      306*   The next line is checked with the current line.  If it is the same, then "=====" will be
      307*   printed on the line instead.  This symbol will be printed only once for a series of repeated lines.
      308**/
      309 
      310 print_data: proc;
      311 
      312 dcl  same bit (1) init ("0"b);			/* ON if current output line is a repeat */
      313 dcl  print_equal bit (1);				/* ON if should print ===== */
      314 dcl  d_size fixed bin;
      315 dcl  fl (4) float bin (63);
      316 dcl  fx (4) fixed bin (71);
      317 dcl  b bit (256);					/* copy of number to print in octal */
      318 dcl  d fixed bin;					/* number of octal digits to print */
      319 dcl  num_digits fixed bin;				/* Number of digits for paced decimal comp-8 */
      320 dcl  check_ptr bit (1) aligned;			/* ON, for comp-8 with odd number of digits */
      321 dcl  add_bit bit (1) aligned;				/* ON, if must add bit to data ptr */
      322 dcl  next_p ptr;					/* points to next item to print */
      323 
      324 dcl  fxb (8) fixed bin (35) based (pp);
      325 dcl  bits (16) bit (d_size) based (pp);
      326 dcl  based_comp bit (data_size+1) unal based (next_p);
      327 
      328 dcl  data_line bit (data_line_len*2) unal based (pp);	/* line data_line_lenust printed + next line */
      329 dcl  data_line_len fixed bin;				/* number of bits in one line */
      330 
      331 	     d_size = data_size;
      332 	     if d_size = 0 then d_size = 36;		/* no size given for temporaries (%) */
      333 	     if d_size >72 & ^packed_decimal then d_size = 36;
      334 	     data_line_len = d_size * per_line;
      335 
      336 /* COBOL - Packed decimal data with an odd number of digits as an alternating data size.  (ie. 7 digits = 32 bits, 31...)
      337*   db_print is given the smaller of these 2 sizes.  The pointer is digit aligned the first time.  Later a bit
      338*   is added every other time to correct the pointer.
      339**/
      340 	     check_ptr = "0"b;
      341 	     if packed_decimal then do;
      342 		num_digits = divide (d_size *2+1, 9, 17, 0);
      343 		check_ptr = (mod (num_digits, 2) ^= 0);
      344 		unspec (copy_its) = unspec (pp);
      345 		num = fixed (copy_its.bit_offset, 6);
      346 		do i = 1 to 8 while (num > bit_loc (i));
      347 		end;
      348 
      349 /* If the pointer is not aligned on a digit boundary, then the pointer will be rounded up to the next boundary. */
      350 		if num ^= bit_loc (i) then do;
      351 		     i = min (i, 8);
      352 		     copy_its.bit_offset = substr (unspec (bit_loc (i)), 31, 6);
      353 		     unspec (pp) = unspec (copy_its);
      354 		end;
      355 		add_bit = "1"b;
      356 
      357 /* If there are an odd number of digits in a packed decimal number and we have the smaller of the two numbers
      358*   then must add 2 bits for a line of 4 numbers. (i.e. 4*31+2 for 32, 31, 32, 31) */
      359 		if check_ptr then data_line_len = data_line_len +2;
      360 	     end;
      361 	     k = loc - offset;
      362 
      363 	     do while (no_prt > 0);
      364 		per_line = min (no_prt, per_line);
      365 		if same then if print_equal then do;
      366 			call ioa_$ioa_switch (iocb_ptr, "======"); /* skip line */
      367 			print_equal = "0"b;
      368 		     end;
      369 		     else;
      370 
      371 		else do;
      372 
      373 		     if octal then do;
      374 			if d_size = 36
      375 			then call ioa_$ioa_switch (iocb_ptr, format, loc, offset, per_line, bits);
      376 
      377 /* Numbers to be printed in octal are copied into b so that they can be right justified.  Procedure ioa_ left justifies.  */
      378 			else do;
      379 			     call ioa_$ioa_switch_nnl (iocb_ptr, "^6o ^6o ", loc, offset);
      380 			     do j = 1 to per_line;
      381 				b = "0"b;
      382 				d = divide (d_size+2, 3, 17, 0);
      383 				substr (b, d*3-d_size+1, d_size) = bits (j);
      384 				call ioa_$ioa_switch_nnl (iocb_ptr, " ^v.3b", d, b);
      385 			     end;
      386 			     call ioa_$ioa_switch (iocb_ptr, "");
      387 			end;
      388 		     end;
      389 
      390 		     else if float then do;
      391 			do j = 1 to per_line;
      392 			     fl (j) = 0;
      393 			     unspec (fl (j)) = unspec (bits (j));
      394 			end;
      395 			call ioa_$ioa_switch (iocb_ptr, format, loc, offset, per_line, fl);
      396 		     end;
      397 
      398 /* COBOL data type */
      399 		     else if packed_decimal then do;
      400 			call ioa_$ioa_switch_nnl (iocb_ptr, "^6o ^6o ", loc, offset, per_line);
      401 			next_p = pp;
      402 			do j = 1 to per_line;
      403 			     call comp_8_to_ascii_ (based_comp, string);
      404 			     call ioa_$ioa_switch_nnl (iocb_ptr, "  ^a", substr (string, 1, num_digits));
      405 
      406 			     next_p = addr (next_p -> bits (2));
      407 
      408 /* Add one bit to the pointer for odd digits per number. */
      409 			     if check_ptr then do;
      410 				if add_bit then do;
      411 				     unspec (copy_its) = unspec (next_p);
      412 				     num = fixed (copy_its.bit_offset, 6)+1;
      413 				     copy_its.bit_offset = substr (unspec (num), 31, 6);
      414 				     unspec (next_p) = unspec (copy_its);
      415 				end;
      416 				add_bit = ^add_bit;
      417 			     end;
      418 			end;
      419 			call ioa_$ioa_switch (iocb_ptr, ""); /* new_line */
      420 		     end;
      421 		     else do;
      422 
      423 			if d_size = 36 then call ioa_$ioa_switch (iocb_ptr, format, loc, offset, per_line, fxb);
      424 
      425 			else do;
      426 			     do j = 1 to per_line;
      427 				if substr (bits (j), 1, 1) = "1"b then fx (j) = -1;
      428 				else fx (j) = 0;
      429 				substr (unspec (fx (j)), 73-d_size, d_size) = bits (j);
      430 			     end;
      431 			     call ioa_$ioa_switch (iocb_ptr, format, loc, offset, per_line, fx);
      432 
      433 			end;
      434 		     end;
      435 		end;
      436 
      437 		if ^same then print_equal = "1"b;
      438 
      439 /* Check for duplicate line.  Last line of comp-8 with odd number of digits will be printed. */
      440 
      441 		no_prt = no_prt - per_line;
      442 		if no_prt > 0 then do;
      443 		     if no_prt >= per_line then j = data_line_len;
      444 		     else j = no_prt * d_size;
      445 		     if check_ptr & (no_prt < 4) then same = "0"b;
      446 		     else if substr (data_line, 1, j) = substr (data_line, data_line_len + 1, j) then same = "1"b;
      447 		     else same = "0"b;
      448 		end;
      449 		pp = addr (substr (data_line, data_line_len+1, 1));
      450 		loc = fixed (rel (pp), 17);
      451 		offset = loc - k;
      452 
      453 	     end;
      454 
      455 	end print_data;
      456 
      457 /*  */
      458 /*  This procedure prints one or more lines of source code beginning with the line associated with the object code
      459*   pointed to by data_ptr.  For an unbound segment, the directory in which
      460*   the object segment was compiled is searched for the source segment.  If the source segment is not found there,
      461*   the working directory is searched.  For bound segments only the working directory is searched for the source
      462*   segment.
      463**/
      464 print_source: proc;
      465 
      466 dcl  source_based char (2) based (source_ptr);
      467 dcl  source_dir char (168);
      468 dcl  source_ent char (32);
      469 dcl  source_len fixed bin;
      470 dcl  source_name char (source_len) based (source_name_ptr);
      471 dcl  source_name_ptr ptr;
      472 dcl  source_ptr ptr;				/* pointer to source segment */
      473 
      474 	     if sntp -> snt.symflag then call db_get_sym (sntp);
      475 
      476 	     if snt.std then do;			/* standard header, use source map */
      477 		hp = snt.headp;
      478 		call stu_$get_line (hp, loc, no_prt, line_no, line_offset, line_length, file);
      479 
      480 		if line_no = -1 | line_length = 0 then go to ERROR_NO_LINE;
      481 		file = file + 1;			/* because of dimensioning in include file */
      482 
      483 		if hp -> std_symbol_header.source_map = (18)"0"b then go to ERROR_NO_LINE;
      484 		smap_ptr = addrel (hp, hp -> std_symbol_header.source_map);
      485 		source_name_ptr = addrel (hp, smap_ptr -> source_map.map (file).pathname.offset);
      486 		source_len = fixed (smap_ptr -> source_map.map (file).pathname.size, 18);
      487 
      488 /* got source name, separate it out for initiate */
      489 
      490 		call expand_pathname_ (source_name, source_dir, source_ent, code);
      491 
      492 		call hcs_$initiate (source_dir, source_ent, "", 0, 1, source_ptr, code);
      493 
      494 /* If there is no pointer to the source segment, look in the working directory.  */
      495 
      496 		if source_ptr = null () then do;
      497 
      498 		     if source_ent = last_source then print_err = "0"b;
      499 		     if print_err then call ioa_$ioa_switch (iocb_ptr, "Cannot initiate source.  ^a>^a", source_dir,
      500 			source_ent);
      501 
      502 		     source_dir = get_wdir_ ();
      503 		     call hcs_$initiate (source_dir, source_ent, "", 0, 1, source_ptr, code);
      504 
      505 		     if source_ptr = null () then do;
      506 			if ^print_err then call ioa_$ioa_switch (iocb_ptr, "Cannot initiate source.  ^a>^a",
      507 			     source_dir, source_ent);
      508 			return;
      509 		     end;
      510 		     if print_err then call ioa_$ioa_switch (iocb_ptr, "Using source  ^a>^a", source_dir, source_ent);
      511 
      512 		end;
      513 		last_source = source_ent;
      514 
      515 /* Now just write out the requisite stuff */
      516 
      517 		call iox_$put_chars (iocb_ptr, addr (substr (source_based, line_offset+1, 1)), line_length, code);
      518 		call ioa_$ioa_switch (iocb_ptr, "");	/* add new-line */
      519 		return;
      520 	     end;
      521 
      522 	     else call ioa_$ioa_switch (iocb_ptr, "Version 1 object segments are not supported by debug.");
      523 
      524 	     return;
      525 
      526 	end print_source;
      527 
      528 /*  */
      529 oob_handler: proc (mcp, name, x_p, y_p, cont_sw);
      530 
      531 /*	Procedure to handle out_of_bounds. If it occurred in the data segment,
      532*   *	the user specified to high an address or too much data. Else it's a real
      533*   *	program error and we want to hear about it.
      534*   */
      535 
      536 dcl  name char (*);
      537 dcl (x_p, y_p) ptr;
      538 dcl  cont_sw bit (1) aligned;
      539 
  6     1 /*  */
  6     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
  6     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
  6     4 /* Modified 07/07/76 by Morris for fault register data */
  6     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
  6     6 
  6     7 
  6     8 /* words 0-15 pointer registers */
  6     9 
  6    10 dcl  mcp ptr;
  6    11 
  6    12 dcl 1 mc based (mcp) aligned,
  6    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
  6    14    (2 regs,					/* registers */
  6    15       3 x (0:7) bit (18),				/* index registers */
  6    16       3 a bit (36),					/* accumulator */
  6    17       3 q bit (36),					/* q-register */
  6    18       3 e bit (8),					/* exponent */
  6    19       3 pad1 bit (28),
  6    20       3 t bit (27),					/* timer register */
  6    21       3 pad2 bit (6),
  6    22       3 ralr bit (3),				/* ring alarm register */
  6    23 
  6    24     2 scu (0:7) bit (36),
  6    25 
  6    26     2 mask bit (72),				/* mem controller mask at time of fault */
  6    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
  6    28     2 errcode fixed bin (35),				/* fault handler's error code */
  6    29     2 fim_temp,
  6    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
  6    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
  6    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
  6    33     2 fault_reg bit (36),				/* fault register */
  6    34     2 pad2 bit (1),
  6    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
  6    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
  6    37     2 fault_time bit (54),				/* time of fault */
  6    38 
  6    39     2 eis_info (0:7) bit (36)) unaligned;
  6    40 
  6    41 
  6    42 dcl (apx fixed bin init (0),
  6    43      abx fixed bin init (1),
  6    44      bpx fixed bin init (2),
  6    45      bbx fixed bin init (3),
  6    46      lpx fixed bin init (4),
  6    47      lbx fixed bin init (5),
  6    48      spx fixed bin init (6),
  6    49      sbx fixed bin init (7)) internal static;
  6    50 
  6    51 
  6    52 
  6    53 
  6    54 dcl  scup ptr;
  6    55 
  6    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
  6    57 
  6    58 
  6    59 /*	WORD (0)		*/
  6    60 
  6    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
  6    62       3 prr bit (3),				/* procedure ring register */
  6    63       3 psr bit (15),				/* procedure segment register */
  6    64       3 p bit (1),					/* procedure privileged bit */
  6    65 
  6    66     2 apu,					/* APPENDING UNIT STATUS */
  6    67       3 xsf bit (1),				/* ext seg flag - IT modification */
  6    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
  6    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
  6    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
  6    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
  6    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
  6    73       3 dsptw bit (1),				/* Fetch of DSPTW */
  6    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
  6    75       3 sdwp bit (1),				/* Fetch of SDW paged */
  6    76       3 ptw bit (1),				/* Fetch of PTW */
  6    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
  6    78       3 fap bit (1),				/* Fetch of final address paged */
  6    79       3 fanp bit (1),				/* Fetch of final address non-paged */
  6    80       3 fabs bit (1),				/* Fetch of final address absolute */
  6    81 
  6    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
  6    83 
  6    84 
  6    85 /*	WORD (1)		*/
  6    86 
  6    87     2 fd,						/* FAULT  DATA */
  6    88       3 iro bit (1),				/* illegal ring order */
  6    89       3 oeb bit (1),				/* out of execute bracket */
  6    90       3 e_off bit (1),				/* no execute */
  6    91       3 orb bit (1),				/* out of read bracket */
  6    92       3 r_off bit (1),				/* no read */
  6    93       3 owb bit (1),				/* out of write bracket */
  6    94       3 w_off bit (1),				/* no write */
  6    95       3 no_ga bit (1),				/* not a gate */
  6    96       3 ocb bit (1),				/* out of call bracket */
  6    97       3 ocall bit (1),				/* outward call */
  6    98       3 boc bit (1),				/* bad outward call */
  6    99       3 inret bit (1),				/* inward return */
  6   100       3 crt bit (1),				/* cross ring transfer */
  6   101       3 ralr bit (1),				/* ring alarm register */
  6   102       3 am_er bit (1),				/* associative memory fault */
  6   103       3 oosb bit (1),				/* out of segment bounds */
  6   104       3 paru bit (1),				/* processor parity upper */
  6   105       3 parl bit (1),				/* processor parity lower */
  6   106       3 onc_1 bit (1),				/* op not complete type 1 */
  6   107       3 onc_2 bit (1),				/* op not complete type 2 */
  6   108 
  6   109     2 port_stat,					/* PORT  STATUS */
  6   110       3 ial bit (4),				/* illegal action lines */
  6   111       3 iac bit (3),				/* illegal action channel */
  6   112       3 con_chan bit (3),				/* connect channel */
  6   113 
  6   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
  6   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
  6   116 
  6   117 
  6   118 /*	WORD (2)		*/
  6   119 
  6   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
  6   121       3 trr bit (3),				/* temporary ring register */
  6   122       3 tsr bit (15),				/* temporary segment register */
  6   123 
  6   124     2 pad2 bit (9),
  6   125 
  6   126     2 cpu_no bit (3),				/* CPU number */
  6   127 
  6   128     2 delta bit (6),				/* tally modification DELTA */
  6   129 
  6   130 
  6   131 /*	WORD (3)		*/
  6   132 
  6   133     2 word3 bit (18),
  6   134 
  6   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
  6   136       3 tsna,					/* Word 1 status */
  6   137         4 prn bit (3),				/* Word 1  PR  number */
  6   138         4 prv bit (1),				/* Word 1  PR  valid bit */
  6   139       3 tsnb,					/* Word 2  status */
  6   140         4 prn bit (3),				/* Word 2  PR  number */
  6   141         4 prv bit (1),				/* Word 2  PR  valid bit */
  6   142       3 tsnc,					/* Word 3  status */
  6   143         4 prn bit (3),				/* Word 3  PR  number */
  6   144         4 prv bit (1),				/* Word 3  PR  valid bit */
  6   145 
  6   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
  6   147 
  6   148 
  6   149 /* 	WORD (4)		*/
  6   150 
  6   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
  6   152 
  6   153     2 ir,						/* INDICATOR  REGISTERS */
  6   154       3 zero bit (1),				/* zero indicator */
  6   155       3 neg bit (1),				/* negative indicator */
  6   156       3 carry bit (1),				/* carryry indicator */
  6   157       3 ovfl bit (1),				/* overflow indicator */
  6   158       3 eovf bit (1),				/* eponent overflow */
  6   159       3 eufl bit (1),				/* exponent underflow */
  6   160       3 oflm bit (1),				/* overflow mask */
  6   161       3 tro bit (1),				/* tally runout */
  6   162       3 par bit (1),				/* parity error */
  6   163       3 parm bit (1),				/* parity mask */
  6   164       3 bm bit (1),					/* ^bar mode */
  6   165       3 tru bit (1),				/* truncation mode */
  6   166       3 mif bit (1),				/* multi-word instruction mode */
  6   167       3 abs bit (1),				/* absolute mode */
  6   168       3 pad bit (4),
  6   169 
  6   170 
  6   171 /*	WORD (5)		*/
  6   172 
  6   173     2 ca bit (18),					/* COMPUTED  ADDRESS */
  6   174 
  6   175     2 cu,						/* CONTROL UNIT STATUS */
  6   176       3 rf bit (1),					/* on first cycle of repeat instr */
  6   177       3 rpt bit (1),				/* repeat instruction */
  6   178       3 rd bit (1),					/* repeat double instruction */
  6   179       3 rl bit (1),					/* repeat link instruciton */
  6   180       3 pot bit (1),				/* IT  modification */
  6   181       3 pon bit (1),				/* return type instruction */
  6   182       3 xde bit (1),				/* XDE from Even location */
  6   183       3 xdo bit (1),				/* XDE from Odd  location */
  6   184       3 poa bit (1),				/* operation preparation */
  6   185       3 rfi bit (1),				/* tells CPU to refetch instruction */
  6   186       3 its bit (1),				/* ITS modification */
  6   187       3 if bit (1),					/* fault occured during instruction fetch */
  6   188 
  6   189     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
  6   190 
  6   191 
  6   192 /*	WORDS (6,7)	*/
  6   193 
  6   194     2 even_inst bit (36),				/* even instruction of faulting pair */
  6   195 
  6   196     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
  6   197 
  6   198 
  6   199 
  6   200 
  6   201 
  6   202 
  6   203 /*	ALTERNATE   SCU  DECLARATION		*/
  6   204 
  6   205 
  6   206 dcl 1 scux based (scup) aligned,
  6   207 
  6   208    (2 pad0 bit (36),
  6   209 
  6   210     2 fd,						/* GROUP II  FAULT DATA */
  6   211       3 isn bit (1),				/* illegal segment number */
  6   212       3 ioc bit (1),				/* illegal op  code  */
  6   213       3 ia_am bit (1),				/* illegal address - modifier */
  6   214       3 isp bit (1),				/* illegal slave  procedure */
  6   215       3 ipr bit (1),				/* illegal procedure */
  6   216       3 nea bit (1),				/* non existent address */
  6   217       3 oobb bit (1),				/* out of bounds */
  6   218       3 pad bit (29),
  6   219 
  6   220     2 pad2 bit (36),
  6   221 
  6   222     2 pad3a bit (18),
  6   223 
  6   224     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
  6   225       3 prn bit (3),				/* PR  number */
  6   226       3 prv bit (1),				/* PR  valid bit */
  6   227 
  6   228     2 pad3b bit (6)) unaligned,
  6   229 
  6   230     2 pad45 (0:1) bit (36),
  6   231 
  6   232     2 instr (0:1) bit (36);				/* Instruction ARRAY */
  6   233 
  6   234 
  6   235 
  6   236 /*  END INCLUDE FILE   mc.incl.pl1 */
      540 
      541 
      542 
      543 	     scup = addr (mcp -> mc.scu);
      544 	     if scu.tpr.tsr = substr (baseno (pp), 4) then do; /* oob in data seg. */
      545 		call reversion_ ("out_of_bounds");
      546 		call ioa_$ioa_switch (iocb_ptr, "Request goes beyond end of segment.");
      547 		go to out;
      548 	     end;
      549 
      550 /* Elsewhere, use previous handler */
      551 
      552 	     cont_sw = "1"b;
      553 	     return;
      554 
      555 	end oob_handler;
      556      end db_print;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/82  1628.8  db_print.pl1                      >dumps>old>recomp>db_print.pl1
108          1    05/06/74  1741.0  component_info.incl.pl1           >ldd>include>component_info.incl.pl1
109          2    11/06/75  1110.0  db_snt.incl.pl1                   >ldd>include>db_snt.incl.pl1
110          3    11/26/79  1320.6  its.incl.pl1                      >ldd>include>its.incl.pl1
111          4    05/06/74  1751.6  std_symbol_header.incl.pl1        >ldd>include>std_symbol_header.incl.pl1
112          5    11/26/79  1320.6  source_map.incl.pl1               >ldd>include>source_map.incl.pl1
540          6    08/12/81  2025.8  mc.incl.pl1                       >ldd>include>mc.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
MODES                           000025 constant        char(6)                  initial array unaligned dcl 103 ref 132 132 134
add_bit                         000251 automatic       bit(1)                   dcl 321 set ref 355* 410 416* 416
addr                                                   builtin function         dcl 93 ref 406 449 517 517 543
addrel                                                 builtin function         dcl 93 ref 185 217 484 485
arg_iocb_ptr                           parameter       pointer                  dcl 19 ref 11 116 122
arg_no_prt                             parameter       fixed bin(17,0)          dcl 23 set ref 11 125 147 148* 155 155
arg_output_switch                      parameter       char(32)                 unaligned dcl 20 ref 11 121
b                               000236 automatic       bit(256)                 unaligned dcl 317 set ref 381* 383* 384*
based_comp                             based           bit                      unaligned dcl 326 set ref 403*
based_ptr                              based           pointer                  dcl 70 ref 175 175 175 175
baseno                                                 builtin function         dcl 93 ref 175 175 544
binary                                                 builtin function         dcl 93 ref 180
bit_loc                         000065 constant        fixed bin(17,0)          initial array dcl 101 ref 346 350 352
bit_offset                1(21) 000162 automatic       bit(6)                   level 2 in structure "copy_its" packed unaligned
                                                                                  dcl 78 in procedure "db_print" set ref 345 352*
                                                                                  412 413*
bit_offset                1(21)        based           bit(6)                   level 2 in structure "its" packed unaligned dcl 3-5
                                                                                  in procedure "db_print" ref 172
bits                                   based           bit                      unaligned dcl 73 in procedure "db_print" set ref
                                                                                  155*
bits                                   based           bit                      array unaligned dcl 325 in procedure "print_data"
                                                                                  set ref 374* 383 393 406 427 429
cbit_offset                     000160 automatic       char(8)                  dcl 73 set ref 173* 174* 175*
check_ptr                       000250 automatic       bit(1)                   dcl 320 set ref 340* 343* 359 409 445
code                            000144 automatic       fixed bin(35,0)          dcl 54 set ref 148* 149 149* 490* 492* 503* 517*
com_err_                        000052 constant        entry                    external dcl 43 ref 149
comp_8_to_ascii_                000036 constant        entry                    external dcl 37 ref 403
condition_                      000054 constant        entry                    external dcl 44 ref 130
cont_sw                                parameter       bit(1)                   dcl 538 set ref 529 552*
copy_its                        000162 automatic       structure                level 1 dcl 78 set ref 344* 353 411* 414
d                               000246 automatic       fixed bin(17,0)          dcl 318 set ref 382* 383 384*
d_size                          000214 automatic       fixed bin(17,0)          dcl 314 set ref 331* 332 332* 333 333* 334 342 374
                                                                                  374 374 374 382 383 383 383 383 383 393 393 393
                                                                                  406 406 406 423 427 427 427 429 429 429 429 429
                                                                                  444
data_line                              based           bit                      unaligned dcl 328 set ref 446 446 449
data_line_len                   000254 automatic       fixed bin(17,0)          dcl 329 set ref 334* 359* 359 443 446 446 446 449
                                                                                  449
data_ptr                               parameter       pointer                  dcl 23 ref 11 126
data_size                              parameter       fixed bin(17,0)          dcl 22 ref 11 160 331 403 403
data_type                              parameter       fixed bin(17,0)          dcl 21 ref 11
db_get_sym                      000022 constant        entry                    external dcl 29 ref 474
db_line_no                      000034 constant        entry                    external dcl 29 ref 202 225
divide                                                 builtin function         dcl 93 ref 342 382
expand_pathname_                000042 constant        entry                    external dcl 39 ref 490
ff                                     based           structure                level 1 dcl 87
file                            000150 automatic       fixed bin(17,0)          dcl 63 set ref 478* 481* 481 485 486
first                           000140 automatic       fixed bin(17,0)          dcl 54 set ref 202* 203 209 225* 226 228 228
fixed                                                  builtin function         dcl 93 ref 128 172 175 175 175 175 345 412 450 486
fl                              000216 automatic       float bin(63)            array dcl 315 set ref 392* 393* 395*
float                           000175 automatic       bit(1)                   initial unaligned dcl 85 set ref 85* 257* 264* 272*
                                                                                  280* 390
format                          000164 automatic       varying char(20)         initial dcl 81 set ref 81* 243* 243 249* 249 259*
                                                                                  259 266* 266 274* 274 282* 282 374* 395* 423* 431*
fx                              000226 automatic       fixed bin(71,0)          array dcl 316 set ref 427* 428* 429 431*
fxb                                    based           fixed bin(35,0)          array dcl 324 set ref 423*
get_wdir_                       000024 constant        entry                    external dcl 29 ref 502
gr_print_                       000040 constant        entry                    external dcl 38 ref 287
hbound                                                 builtin function         dcl 93 ref 132 134
hcs_$initiate                   000044 constant        entry                    external dcl 40 ref 492 503
headp                   104            based           pointer                  level 2 dcl 2-9 ref 477
hp                              000154 automatic       pointer                  dcl 69 set ref 477* 478* 483 484 484 485
i                               000145 automatic       fixed bin(17,0)          dcl 54 set ref 346* 346* 350 351* 351 352
i9                              000134 automatic       fixed bin(9,0)           dcl 54 set ref 172* 173 173*
ioa_$ioa_switch                 000026 constant        entry                    external dcl 29 ref 135 151 155 169 175 180 182 208
                                                                                  227 300 366 374 386 395 419 423 431 499 506 510
                                                                                  518 522 546
ioa_$ioa_switch_nnl             000030 constant        entry                    external dcl 29 ref 142 379 384 400 404
ioa_$rsnnl                      000032 constant        entry                    external dcl 29 ref 173
iocb_ptr                        000122 automatic       pointer                  dcl 49 set ref 117* 122* 135* 142* 148* 151* 155*
                                                                                  169* 175* 180* 182* 208* 227* 300* 366* 374* 379*
                                                                                  384* 386* 395* 400* 404* 419* 423* 431* 499* 506*
                                                                                  510* 517* 518* 522* 546*
iox_$put_chars                  000046 constant        entry                    external dcl 41 ref 148 517
iox_$user_output                000060 external static pointer                  dcl 97 ref 117
its                                    based           structure                level 1 dcl 3-5
its_mod                   0(30)        based           bit(6)                   level 2 packed unaligned dcl 3-5 ref 169
j                               000136 automatic       fixed bin(17,0)          dcl 54 set ref 132* 132* 134 139 166* 196* 198 205
                                                                                  214 218* 218 223* 380* 383* 391* 392 393 393* 402*
                                                                                  426* 427 427 428 429 429* 443* 444* 446 446
k                               000137 automatic       fixed bin(17,0)          dcl 54 set ref 361* 451
last_source                     000010 internal static char(32)                 initial unaligned dcl 102 set ref 498 513*
line_length                     000147 automatic       fixed bin(17,0)          dcl 62 set ref 478* 480 517*
line_no                         000141 automatic       fixed bin(17,0)          dcl 54 set ref 202* 208* 225* 227* 478* 480
line_offset                     000146 automatic       fixed bin(17,0)          dcl 61 set ref 478* 517 517
loc                             000177 automatic       fixed bin(17,0)          dcl 86 set ref 128* 142* 155* 169* 175* 180* 182*
                                                                                  186* 186 202* 209 216* 216 225* 229* 229 361 374*
                                                                                  379* 395* 400* 423* 431* 450* 451 478*
map                       2            based           structure                array level 2 dcl 5-3
max                                                    builtin function         dcl 93 ref 125
mc                                     based           structure                level 1 dcl 6-12
mcp                                    parameter       pointer                  dcl 6-10 ref 529 543
min                                                    builtin function         dcl 93 ref 214 351 364
mod                                                    builtin function         dcl 93 in procedure "db_print" ref 343
mod                       1(30)        based           bit(6)                   level 2 in structure "its" packed unaligned dcl 3-5
                                                                                  in procedure "db_print" ref 169
mode                                   parameter       char                     dcl 23 set ref 11 132 135* 244
name                                   parameter       char                     unaligned dcl 536 ref 529
next_p                          000252 automatic       pointer                  dcl 322 set ref 401* 403 406* 406 411 414*
no                              000142 automatic       fixed bin(17,0)          dcl 54 set ref 160* 164* 168 185 186 187 202* 205*
                                                                                  209* 209 212* 214* 214 215* 216 217 218 225* 228*
                                                                                  229
no_prt                          000135 automatic       fixed bin(17,0)          dcl 54 set ref 125* 166 198 205 212 214 223 287 287
                                                                                  363 364 441* 441 442 443 444 445 478*
null                                                   builtin function         dcl 93 ref 116 192 496 505
num                             000120 automatic       fixed bin(17,0)          dcl 49 set ref 345* 346 350 412* 413
num_digits                      000247 automatic       fixed bin(17,0)          dcl 319 set ref 342* 343 404 404
octal                           000173 automatic       bit(1)                   initial unaligned dcl 83 set ref 83* 240* 373
offset                          000176 automatic       fixed bin(17,0)          dcl 86 in procedure "db_print" set ref 127* 142*
                                                                                  155* 169* 175* 180* 182* 187* 187 361 374* 379*
                                                                                  395* 400* 423* 431* 451*
offset                    2            based           bit(18)                  array level 4 in structure "source_map" packed
                                                                                  unaligned dcl 5-3 in procedure "db_print" ref 485
okp                             000143 automatic       fixed bin(17,0)          dcl 54 set ref 173* 192* 195* 200 204*
output_switch                   000124 automatic       char(32)                 dcl 49 set ref 118* 121* 215* 228*
packed_bit_offset                      based           bit(6)                   unaligned dcl 67 ref 180
packed_decimal                  000174 automatic       bit(1)                   initial unaligned dcl 84 set ref 84* 292* 333 341
                                                                                  399
packed_ptr                             based           pointer                  unaligned dcl 66 set ref 182*
pathname                  2            based           structure                array level 3 packed unaligned dcl 5-3
per_line                        000172 automatic       fixed bin(17,0)          initial dcl 82 set ref 82* 244* 334 364* 364 374*
                                                                                  380 391 395* 400* 402 423* 426 431* 441 443
pp                              000156 automatic       pointer                  dcl 70 set ref 126* 128 148* 155 169 169 169 169 172
                                                                                  175 175 175 175 180 180 182 185* 185 215* 217* 217
                                                                                  228 228 287 344 353* 374 383 393 401 423 427 429
                                                                                  446 446 449* 449 450 544
print_equal                     000213 automatic       bit(1)                   unaligned dcl 313 set ref 365 367* 437*
print_err                       000200 automatic       bit(1)                   initial unaligned dcl 89 set ref 89* 498* 499 506
                                                                                  510
print_text_                     000020 constant        entry                    external dcl 29 ref 215 228
ptr                                                    builtin function         dcl 93 ref 228 228
rel                                                    builtin function         dcl 93 ref 128 175 175 450
rel_offset                             parameter       fixed bin(17,0)          dcl 23 ref 11 127
reversion_                      000056 constant        entry                    external dcl 45 ref 545
same                            000212 automatic       bit(1)                   initial unaligned dcl 312 set ref 312* 365 437 445*
                                                                                  446* 447*
scu                                    based           structure                level 1 dcl 6-56 in procedure "oob_handler"
scu                      30            based           bit(36)                  array level 2 in structure "mc" packed unaligned
                                                                                  dcl 6-12 in procedure "oob_handler" set ref 543
scup                            000100 automatic       pointer                  dcl 6-54 set ref 543* 544
size                      2(18)        based           bit(18)                  array level 4 packed unaligned dcl 5-3 ref 486
smap_ptr                        000152 automatic       pointer                  dcl 65 set ref 484* 485 486
snt                                    based           structure                level 1 dcl 2-9
sntp                                   parameter       pointer                  dcl 2-7 set ref 11 192 202* 225* 474 474* 476 477
source_based                           based           char(2)                  unaligned dcl 466 set ref 517 517
source_dir                      000270 automatic       char(168)                unaligned dcl 467 set ref 490* 492* 499* 502* 503*
                                                                                  506* 510*
source_ent                      000342 automatic       char(32)                 unaligned dcl 468 set ref 490* 492* 498 499* 503*
                                                                                  506* 510* 513
source_len                      000352 automatic       fixed bin(17,0)          dcl 469 set ref 486* 490 490
source_map               16            based           bit(18)                  level 2 in structure "std_symbol_header" packed
                                                                                  unaligned dcl 4-1 in procedure "db_print" ref 483
                                                                                  484
source_map                             based           structure                level 1 dcl 5-3 in procedure "db_print"
source_name                            based           char                     unaligned dcl 470 set ref 490*
source_name_ptr                 000354 automatic       pointer                  dcl 471 set ref 485* 490
source_ptr                      000356 automatic       pointer                  dcl 472 set ref 492* 496 503* 505 517 517
std                     102(01)        based           bit(1)                   level 2 packed unaligned dcl 2-9 ref 476
std_symbol_header                      based           structure                level 1 dcl 4-1
str                                    based           char                     unaligned dcl 73 set ref 287*
string                          000100 automatic       char(64)                 unaligned dcl 49 set ref 403* 404 404
stu_$get_line                   000050 constant        entry                    external dcl 42 ref 478
substr                                                 builtin function         dcl 93 set ref 352 383* 404 404 413 427 429* 446 446
                                                                                  449 517 517 544
symflag                 102            based           bit(1)                   level 2 packed unaligned dcl 2-9 ref 474
tpr                       2            based           structure                level 2 packed unaligned dcl 6-56
tsr                       2(03)        based           bit(15)                  level 3 packed unaligned dcl 6-56 ref 544
unspec                                                 builtin function         dcl 93 set ref 344* 344 352 353* 353 393* 393 411*
                                                                                  411 413 414* 414 429
w0                                     based           fixed bin(35,0)          level 2 dcl 87 set ref 169* 180*
w1                        1            based           fixed bin(35,0)          level 2 dcl 87 set ref 169*
x_p                                    parameter       pointer                  dcl 537 ref 529
y_p                                    parameter       pointer                  dcl 537 ref 529

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ITP_MODIFIER                           internal static bit(6)                   initial unaligned dcl 3-56
ITS_MODIFIER                           internal static bit(6)                   initial unaligned dcl 3-55
abx                                    internal static fixed bin(17,0)          initial dcl 6-42
apx                                    internal static fixed bin(17,0)          initial dcl 6-42
bbx                                    internal static fixed bin(17,0)          initial dcl 6-42
bpx                                    internal static fixed bin(17,0)          initial dcl 6-42
ci                                     automatic       structure                level 1 dcl 1-3
itp                                    based           structure                level 1 dcl 3-18
itp_unsigned                           based           structure                level 1 dcl 3-43
its_unsigned                           based           structure                level 1 dcl 3-30
lbx                                    internal static fixed bin(17,0)          initial dcl 6-42
lpx                                    internal static fixed bin(17,0)          initial dcl 6-42
sbx                                    internal static fixed bin(17,0)          initial dcl 6-42
scux                                   based           structure                level 1 dcl 6-206
spx                                    internal static fixed bin(17,0)          initial dcl 6-42

NAMES DECLARED BY EXPLICIT CONTEXT.
ERROR_NO_LINE                   001677 constant        label                    dcl 300 ref 226 480 483
db_print                        000343 constant        entry                    external dcl 11
label                           000000 constant        label                    array(21) dcl 142 ref 139
oob_handler                     003473 constant        entry                    internal dcl 529 ref 130 130
out                             001676 constant        label                    dcl 298 ref 547
print_data                      001723 constant        entry                    internal dcl 310 ref 245 253 260 267 275 283 295
print_source                    003003 constant        entry                    internal dcl 464 ref 235

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4014        4076    3600        4024
Length      4424    3600        62         311     214          10

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
db_print                            530 external procedure  is an external procedure.  
print_data                              internal procedure  shares stack frame of external procedure db_print.  
print_source                            internal procedure  shares stack frame of external procedure db_print.  
oob_handler                          98 internal procedure  is assigned to an entry variable.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 last_source                 db_print

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
db_print                 000100 string                      db_print
                         000120 num                         db_print
                         000122 iocb_ptr                    db_print
                         000124 output_switch               db_print
                         000134 i9                          db_print
                         000135 no_prt                      db_print
                         000136 j                           db_print
                         000137 k                           db_print
                         000140 first                       db_print
                         000141 line_no                     db_print
                         000142 no                          db_print
                         000143 okp                         db_print
                         000144 code                        db_print
                         000145 i                           db_print
                         000146 line_offset                 db_print
                         000147 line_length                 db_print
                         000150 file                        db_print
                         000152 smap_ptr                    db_print
                         000154 hp                          db_print
                         000156 pp                          db_print
                         000160 cbit_offset                 db_print
                         000162 copy_its                    db_print
                         000164 format                      db_print
                         000172 per_line                    db_print
                         000173 octal                       db_print
                         000174 packed_decimal              db_print
                         000175 float                       db_print
                         000176 offset                      db_print
                         000177 loc                         db_print
                         000200 print_err                   db_print
                         000212 same                        print_data
                         000213 print_equal                 print_data
                         000214 d_size                      print_data
                         000216 fl                          print_data
                         000226 fx                          print_data
                         000236 b                           print_data
                         000246 d                           print_data
                         000247 num_digits                  print_data
                         000250 check_ptr                   print_data
                         000251 add_bit                     print_data
                         000252 next_p                      print_data
                         000254 data_line_len               print_data
                         000270 source_dir                  print_source
                         000342 source_ent                  print_source
                         000352 source_len                  print_source
                         000354 source_name_ptr             print_source
                         000356 source_ptr                  print_source
oob_handler              000100 scup                        oob_handler

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_cs            call_ext_out_desc   call_ext_out        return              tra_ext
mpfx2               mod_fx1             shorten_stack       ext_entry_desc      int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      comp_8_to_ascii_              condition_                    db_get_sym
db_line_no                    expand_pathname_              get_wdir_                     gr_print_
hcs_$initiate                 ioa_$ioa_switch               ioa_$ioa_switch_nnl           ioa_$rsnnl
iox_$put_chars                print_text_                   reversion_                    stu_$get_line

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
iox_$user_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000334        81 000356        82 000363        83 000365        84 000366        85 000367        89 000370
    116 000372       117 000377       118 000402       119 000405       121 000406       122 000412       125 000415
    126 000422       127 000425       128 000427       130 000432       132 000457       133 000474       134 000476
    135 000501       136 000527       139 000530       142 000531       147 000562       148 000565       149 000602
    151 000623       152 000642       155 000643       157 000705       160 000706       164 000715       166 000717
    168 000726       169 000731       172 001005       173 001011       174 001043       175 001045       177 001123
    180 001124       182 001174       185 001231       186 001235       187 001236       188 001237       189 001241
    192 001242       195 001251       196 001253       198 001254       200 001257       202 001262       203 001302
    204 001304       205 001305       206 001310       208 001311       209 001340       211 001344       212 001345
    214 001347       215 001355       216 001376       217 001400       218 001403       219 001404       220 001405
    223 001406       225 001415       226 001435       227 001437       228 001466       229 001513       230 001515
    232 001517       235 001520       237 001521       240 001522       243 001524       244 001536       245 001547
    246 001550       249 001551       253 001563       254 001564       257 001565       259 001567       260 001601
    261 001602       264 001603       266 001605       267 001617       268 001620       272 001621       274 001623
    275 001635       276 001636       280 001637       282 001641       283 001653       284 001654       287 001655
    289 001671       292 001672       295 001674       296 001675       298 001676       300 001677       301 001722
    310 001723       312 001724       331 001725       332 001730       333 001733       334 001741       340 001743
    341 001744       342 001746       343 001753       344 001757       345 001761       346 001765       347 001776
    350 002000       351 002004       352 002011       353 002016       355 002020       359 002022       361 002026
    363 002031       364 002033       365 002037       366 002043       367 002062       369 002063       373 002064
    374 002066       379 002135       380 002163       381 002172       382 002175       383 002201       384 002222
    385 002251       386 002253       388 002270       390 002271       391 002273       392 002301       393 002305
    394 002324       395 002326       396 002361       399 002362       400 002364       401 002415       402 002417
    403 002426       404 002451       406 002503       409 002510       410 002512       411 002514       412 002516
    413 002523       414 002530       416 002532       418 002535       419 002537       420 002554       423 002555
    426 002614       427 002623       428 002650       429 002655       430 002672       431 002674       437 002727
    441 002733       442 002735       443 002737       444 002744       445 002746       446 002755       447 002767
    449 002770       450 002774       451 002777       453 003001       455 003002       464 003003       474 003004
    476 003021       477 003027       478 003031       480 003054       481 003061       483 003062       484 003066
    485 003071       486 003101       490 003104       492 003133       496 003176       498 003202       499 003210
    502 003241       503 003253       505 003316       506 003322       508 003354       510 003355       513 003407
    517 003413       518 003433       519 003450       522 003451       524 003471       529 003472       543 003506
    544 003513       545 003527       546 003545       547 003566       552 003571       553 003573


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
