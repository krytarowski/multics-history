	COMPILATION LISTING OF SEGMENT bisync_
	Compiled by: Multics PL/I Compiler, Release 32c, of June 16, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 06/22/89  0723.3 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(86-07-28,Beattie), approve(86-07-28,MCR7482),
       15*     audit(86-09-29,Brunelle), install(86-10-07,MR12.0-1177):
       16*     Optionally allow bisync_ to send ETBs between records of a block instead
       17*     of only ETXs.
       18*  2) change(89-04-25,Beattie), approve(89-05-15,MCR8107),
       19*     audit(89-06-15,Brunelle), install(89-06-22,MR12.3-1061):
       20*     Change declaration of offset variable in the substraddr internal
       21*     procedure to fixed bin 21 to allow referencing all characters within
       22*     a segment.  Fixes problem in TR20276.
       23*                                                   END HISTORY COMMENTS */
       24 
       25 
       26 /* BISYNC_: An I/O module for doing I/O over a binary synchronous communications line. */
       27 
       28 /* Coded November 1976 by Larry Johnson */
       29 /* Modified April 1984 by Charley Marker:
       30*   a) Changed to use a fast event channel only for ring 0 calls.
       31*   b) Changed abort_attach to call hcs_$tty_detach if needed.
       32*   c) Changed to check if ad.attach_channel is event call and if it is make it event wait. */
       33 bisync_: proc;
       34 
       35 /* Parameters */
       36 
       37 dcl  arg_iocbp ptr;
       38 dcl  arg_option (*) char (*) var;			/* Options for attach */
       39 dcl  arg_sw bit (1);				/* Com_err_ switch for attach */
       40 dcl  arg_code fixed bin (35);
       41 dcl  arg_mode fixed bin;				/* The open mode */
       42 dcl  arg_buf_ptr ptr;
       43 dcl  arg_data_ptr ptr;
       44 dcl  arg_buf_len fixed bin (21);
       45 dcl  arg_data_len fixed bin (21);
       46 dcl  arg_pos_type fixed bin;
       47 dcl  arg_pos_value fixed bin (21);
       48 dcl  arg_order char (*);
       49 dcl  arg_info_ptr ptr;
       50 
       51 /* Automatic */
       52 
       53 dcl  com_err_sw bit (1);				/* Set if com_err_ sould be called on attach error */
       54 dcl  adp ptr;					/* Pointer to attach data */
       55 dcl  code fixed bin (35);
       56 dcl  iocbp ptr;
       57 dcl  empty_buffer char (1) init ("");			/* an empty buffer for ETB mode */
       58 dcl  mask bit (36) aligned;				/* For setting ips mask */
       59 dcl  state fixed bin;
       60 dcl  i fixed bin (21);
       61 dcl  open_mode fixed bin;
       62 dcl  remaining_len fixed bin (21);
       63 dcl  offset fixed bin (21);
       64 dcl  data_ptr ptr;
       65 dcl  data_len fixed bin (21);
       66 dcl  header_len fixed bin (21);
       67 dcl  buf_ptr ptr;
       68 dcl  buf_len fixed bin (21);
       69 dcl  hbuf_ptr ptr;
       70 dcl  hbuf_len fixed bin (21);
       71 dcl  order_sw bit (1);
       72 dcl  etb_found bit (1);
       73 dcl  etx_found bit (1);
       74 dcl  stx_found bit (1);
       75 dcl  eot_found bit (1);
       76 dcl  soh_found bit (1);
       77 dcl  header_found bit (1);
       78 dcl  data_found bit (1);
       79 dcl  nl_found bit (1);
       80 dcl  order char (32);
       81 dcl  info_ptr ptr;
       82 dcl  pos_type fixed bin;
       83 dcl  pos_value fixed bin (21);
       84 dcl  caller char (32);
       85 dcl (rpt, err) entry variable options (variable);
       86 dcl 1 my_area_info like area_info aligned automatic;
       87 dcl  real_transparent bit (1);
       88 dcl  time_out bit (1);
       89 
       90 dcl 1 event_info aligned,
       91     2 channel_id fixed bin (71),
       92     2 message fixed bin (71),
       93     2 sender bit (36),
       94     2 origon,
       95       3 dev_signal bit (18) unal,
       96       3 ring bit (18) unal,
       97     2 channel_index fixed bin (17);
       98 
       99 dcl 1 mode_data aligned,
      100     2 req_len fixed bin,
      101     2 req char (256);
      102 
      103 dcl  dial_msg_chan char (6);				/* Variables for dial manager */
      104 dcl  dial_msg_module char (32);
      105 dcl  dial_msg_ndialed fixed bin;
      106 
      107 dcl 1 dma aligned,
      108     2 version fixed bin,
      109     2 dial_qual char (22),
      110     2 event_channel fixed bin (71),
      111     2 channel_name char (32);
      112 
      113 dcl 1 dial_msg_flags aligned,
      114     2 dialed_up bit (1) unal,
      115     2 hung_up bit (1) unal,
      116     2 control bit (1) unal,
      117     2 pad bit (33) unal;
      118 
      119 /* Constants */
      120 
      121 dcl  BISYNC_OVERHEAD fixed bin int static options (constant) init (8);
      122 dcl  iomodule_name char (7) int static options (constant) init ("bisync_");
      123 dcl  nl char (1) int static options (constant) init ("
      124 ");
      125 
      126 /* External stuff */
      127 
      128 dcl  define_area_ entry (ptr, fixed bin (35));
      129 dcl  release_area_ entry (ptr);
      130 dcl  ipc_$create_ev_chn entry (fixed bin (71), fixed bin (35));
      131 dcl  ipc_$delete_ev_chn entry (fixed bin (71), fixed bin (35));
      132 dcl  ipc_$decl_ev_call_chn entry (fixed bin (71), entry, ptr, fixed bin, fixed bin (35));
      133 dcl  ipc_$decl_ev_wait_chn entry (fixed bin(71), fixed bin(35));
      134 dcl  ipc_$drain_chn entry (fixed bin (71), fixed bin (35));
      135 dcl  hcs_$assign_channel entry (fixed bin (71), fixed bin (35));
      136 dcl  convert_ipc_code_ entry (fixed bin (35));
      137 dcl  hcs_$tty_attach entry (char (*), fixed bin (71), fixed bin, fixed bin, fixed bin (35));
      138 dcl  hcs_$tty_detach entry (fixed bin, fixed bin, fixed bin, fixed bin (35));
      139 dcl  hcs_$set_ips_mask entry (bit (36) aligned, bit (36) aligned);
      140 dcl  hcs_$reset_ips_mask entry (bit (36) aligned, bit (36) aligned);
      141 dcl  iox_$propagate entry (ptr);
      142 dcl  iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35));
      143 dcl  com_err_ entry options (variable);
      144 dcl  hcs_$tty_write entry (fixed bin, ptr, fixed bin (21), fixed bin (21), fixed bin (21), fixed bin, fixed bin (35));
      145 dcl  hcs_$tty_read entry (fixed bin, ptr, fixed bin (21), fixed bin (21), fixed bin (21), fixed bin, fixed bin (35));
      146 dcl  hcs_$tty_order entry (fixed bin, char (*), ptr, fixed bin, fixed bin (35));
      147 dcl  hcs_$tty_abort entry (fixed bin, fixed bin, fixed bin, fixed bin (35));
      148 dcl  hcs_$tty_state entry (fixed bin, fixed bin, fixed bin (35));
      149 dcl  ipc_$block entry (ptr, ptr, fixed bin (35));
      150 dcl  timer_manager_$sleep entry (fixed bin (71), bit (2));
      151 dcl  timer_manager_$reset_alarm_wakeup entry (fixed bin (71));
      152 dcl  timer_manager_$alarm_wakeup entry (fixed bin (71), bit (2), fixed bin (71));
      153 dcl  dial_manager_$privileged_attach entry (ptr, fixed bin (35));
      154 dcl  dial_manager_$dial_out entry (ptr, fixed bin (35));
      155 dcl  dial_manager_$release_channel entry (ptr, fixed bin(35));
      156 dcl  dial_manager_$release_channel_no_hangup entry (ptr, fixed bin(35));
      157 dcl  convert_dial_message_ entry (bit (72) aligned, char (*), char (*), fixed bin, 1 like dial_msg_flags aligned,
      158      fixed bin (35));
      159 dcl  iox_$control entry (ptr, char (*), ptr, fixed bin (35));
      160 dcl  iox_$attach_name entry (char (*), ptr, char (*), ptr, fixed bin (35));
      161 dcl  iox_$open entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
      162 dcl  iox_$write_record entry (ptr, ptr, fixed bin (21), fixed bin (35));
      163 dcl  iox_$close entry (ptr, fixed bin (35));
      164 dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
      165 dcl  iox_$err_no_operation entry;
      166 
      167 dcl (addr, bin, hbound, index, length, low, max, min, null, rtrim, string, substr, unspec) builtin;
      168 
      169 dcl  sys_info$max_seg_size ext fixed bin (35);
      170 dcl  error_table_$buffer_big ext fixed bin (35);
      171 dcl  error_table_$bad_arg ext fixed bin (35);
      172 dcl  error_table_$bad_mode ext fixed bin (35);
      173 dcl  error_table_$bisync_bid_fail ext fixed bin (35);
      174 dcl  error_table_$bisync_reverse_interrupt ext fixed bin (35);
      175 dcl  error_table_$long_record ext fixed bin (35);
      176 dcl  error_table_$line_status_pending ext fixed bin (35);
      177 dcl  error_table_$not_detached ext fixed bin (35);
      178 dcl  error_table_$wrong_no_of_args ext fixed bin (35);
      179 dcl  error_table_$noarg ext fixed bin (35);
      180 dcl  error_table_$no_operation ext fixed bin (35);
      181 dcl  error_table_$no_line_status ext fixed bin (35);
      182 dcl  error_table_$badopt ext fixed bin (35);
      183 dcl  error_table_$device_parity ext fixed bin (35);
      184 dcl  error_table_$action_not_performed ext fixed bin (35);
      185 dcl  error_table_$bisync_block_bad ext fixed bin (35);
      186 dcl  error_table_$end_of_info ext fixed bin (35);
      187 dcl  error_table_$resource_attached ext fixed bin (35);
      188          
      189 dcl  conversion condition;
      190 
      191 /* Attach data block */
      192 
      193 dcl 1 ad aligned based (adp),
      194     2 work_areap ptr,				/* Pointer to work area containing this structure */
      195     2 device char (6),				/* Name of channel attached */
      196     2 attach_description char (256) var,
      197     2 open_description char (24) var,
      198     2 wait_list aligned,
      199       3 nchan fixed bin,				/* Number of channels to block on */
      200       3 channel_id fixed bin (71),			/* Channel to block on */
      201       3 timer_channel fixed bin (71),			/* Second channel when timer needed */
      202     2 attach_channel fixed bin (71),                        /* Answering service channel for attachments */
      203     2 channel fixed bin (71),			          /* The channel for Ring 0 */
      204     2 delay fixed bin (71),				/* Delay in microseconds between writes */
      205     2 log_iocbp ptr,				/* Logging IOCB, if enabled */
      206     2 tty_index fixed bin,				/* Index given to line at assignment */
      207     2 bid_limit fixed bin,				/* Number of times to retry line bid */
      208     2 ttd_time fixed bin,				/* Time between ttds */
      209     2 ttd_limit fixed bin,				/* Maximum number to send */
      210     2 transparent bit (1),				/* Set if in transparent mode */
      211     2 ascii bit (1),				/* Set if in ascii mode, reset if ebcdic */
      212     2 attach_channel_is_call bit (1),	                    /* Set if the attach channel has been converted to event call */
      213     2 temp_nontransparent bit (1),			/* Temporarily non-transparent for 1 msg */
      214     2 break_on_etb bit (1),				/* Set if ok to break on etb, otherwise wait for etx */
      215     2 break_on_eot bit (1),				/* Must watch for eots */
      216     2 saved_eot bit (1),				/* Must report eot on next get_chars */
      217     2 output_mode bit (1),				/* Set if open for one of output modes */
      218     2 hangup_sw bit (1),				/* If set, hangup on detach */
      219     2 fnp_output_reported bit (1),			/* If set, FNP reported write status */
      220     2 fnp_output_pending bit (1),			/* Output status, valid if prev bit set */
      221     2 ibm3270_mode bit (1),				/* IBM 3270 mode selected in attach */
      222     2 hasp_mode bit (1),				/* Running in hasp mode */
      223     2 master_sw bit (1),				/* Master mode requested */
      224     2 slave_sw bit (1),				/* Slave mode requested */
      225     2 tty_attached bit (1),	                              /* Set after a successful call to hcs_$tty_attach */
      226     2 multi_record bit (1),				/* Set if doing blocking and unblocking */
      227     2 output_etb_mode bit (1),			/* set if output with ETB is selected */
      228     2 use_etb bit (1),				/* controls when ETBs are used when in output_etb_mode */
      229     2 multi_record_limit fixed bin,			/* Max count of records per block */
      230     2 record_count fixed bin,				/* Records in current block */
      231     2 write_error_code fixed bin (35),			/* Error code from a prior write */
      232     2 log_sw bit (1),				/* Set if logging enabled */
      233     2 stx char (1),					/* Start of text character */
      234     2 etx char (1),					/* End of text character */
      235     2 etb char (1),					/* End of text block character */
      236     2 dle char (1),					/* Data link escape character */
      237     2 eot char (1),					/* End of transmission char */
      238     2 itb char (1),					/* End of intermediate text block */
      239     2 soh char (1),					/* Start of header */
      240     2 scanned_data_len fixed bin (21),			/* Length of input data already scanned */
      241     2 scanned_data_ptr ptr,				/* Pointer to input data already scanned */
      242     2 unscanned_data_len fixed bin (21),		/* Length of input data read but not scanned */
      243     2 unscanned_data_ptr ptr,				/* Pointer to input_ data read but not scanned */
      244     2 input_state fixed bin,				/* Current state of input buffer scan */
      245     2 block_len fixed bin (21),			/* Length of text blocks */
      246     2 max_block_len fixed bin (21),			/* Max length of text block (set at attach) */
      247     2 input_blockp ptr,				/* Pointer to block with input buffer */
      248     2 last_input_blockp ptr,				/* Last input block in chain */
      249     2 input_buf_len fixed bin (21),			/* Length of input buffer */
      250     2 input_buf_ptr ptr,				/* Address of input buffer */
      251     2 output_buf_len fixed bin (21),			/* Length of output buffer */
      252     2 output_buf_ptr ptr,				/* Address of output buffer */
      253     2 output_buf_used fixed bin (21),			/* Number of chars in output buffer */
      254     2 output_buf_left fixed bin (21),			/* Unused space in output buffer */
      255     2 last_etx fixed bin (21);			/* Index to last etx stored in output buffer */
      256 
      257 dcl  output_buffer char (ad.output_buf_len) based (ad.output_buf_ptr);
      258 dcl  unscanned_data char (ad.unscanned_data_len) based (ad.unscanned_data_ptr);
      259 dcl  scanned_data char (ad.scanned_data_len) based (ad.scanned_data_ptr);
      260 dcl  work_area area based (ad.work_areap);
      261 
      262 dcl 1 input_block aligned based (ad.input_blockp),
      263     2 next_blockp ptr init (null),
      264     2 data_len fixed bin (21),
      265     2 input_buffer char (ad.input_buf_len);
      266 
      267 dcl  data_arg char (data_len) based (data_ptr);
      268 dcl  buf_arg char (buf_len) based (buf_ptr);
      269 dcl  header_arg char (hbuf_len) based (hbuf_ptr);
      270 
      271 /* Based things for orders */
      272 
      273 dcl  event_info_channel fixed bin (71) based (info_ptr);
      274 dcl 1 rw_status aligned based (info_ptr),		/* For read_status and write_status */
      275     2 channel fixed bin (71),
      276     2 flag bit (1);
      277 dcl  order_val fixed bin based (info_ptr);		/* For orders which take a single number */
      278 dcl 1 bsc_modes aligned based (info_ptr),		/* For setting modes */
      279     2 transparent bit (1) unal,
      280     2 ebcdic bit (1) unal,
      281     2 fill bit (34) unal;
      282 dcl 1 hangup_proc aligned based (info_ptr),		/* Data for hangup_proc order */
      283     2 entry_var entry variable,
      284     2 data_ptr ptr,
      285     2 prior fixed bin;
      286 dcl 1 order_msg aligned based (info_ptr),		/* For orders that use varying strings */
      287     2 data_len fixed bin,
      288     2 data char (order_msg.data_len);
      289 
      290 dcl 1 get_chars_info aligned based (info_ptr),		/* For get_chars order */
      291     2 buf_ptr ptr,					/* Addr of callers buffer */
      292     2 buf_len fixed bin (21),				/* Length of callers buffer */
      293     2 data_len fixed bin (21),			/* Length of data return */
      294     2 hbuf_ptr ptr,					/* Addr of callers of header buffer */
      295     2 hbuf_len fixed bin (21),			/* Length of callers header buffer */
      296     2 header_len fixed bin (21),			/* Length of header return */
      297     2 flags,
      298       3 etx bit (1) unal,				/* Data ended with etx */
      299       3 etb bit (1) unal,				/* Data ended with etb */
      300       3 soh bit (1) unal,				/* Data had header */
      301       3 eot bit (1) unal,				/* Data was eot */
      302       3 pad bit (32) unal;
      303 
      304 
      305 /* Attach entry point */
      306 
      307 bisync_attach: entry (arg_iocbp, arg_option, arg_sw, arg_code);
      308 
      309 	iocbp = arg_iocbp;
      310 	com_err_sw = arg_sw;
      311 	arg_code, code = 0;
      312 
      313 	area_infop = addr (my_area_info);
      314 	area_info.version = area_info_version_1;
      315 	string (area_info.control) = "0"b;
      316 	area_info.extend = "1"b;
      317 	area_info.zero_on_free = "1"b;
      318 	area_info.owner = iomodule_name;
      319 	area_info.size = sys_info$max_seg_size;
      320 	area_info.areap = null;
      321 	adp = null;
      322 
      323 	if iocbp -> iocb.attach_descrip_ptr ^= null then do;
      324 	     code = error_table_$not_detached;
      325 	     call abort_attach ("^a", iocbp -> iocb.name);
      326 	end;
      327 
      328 	call define_area_ (area_infop, code);
      329 	if code ^= 0 then call abort_attach ("Unable to allocate temp area.", "");
      330 	allocate ad in (area_info.areap -> work_area);
      331 	unspec (ad) = "0"b;
      332 	ad.work_areap = area_info.areap;
      333 
      334 /* Process options */
      335 
      336 	if hbound (arg_option, 1) < 1 then do;		/* Must be exactly one */
      337 	     code = error_table_$wrong_no_of_args;
      338 	     call abort_attach ("Bad attach description.", "");
      339 	end;
      340 	ad.device = arg_option (1);
      341 	ad.block_len, ad.max_block_len = 256;		/* Default length */
      342 	ad.transparent = "1"b;
      343 	ad.ascii = "1"b;
      344 	ad.delay = 0;
      345 	ad.bid_limit = 30;
      346 	ad.ttd_time = 2;
      347 	ad.ttd_limit = 30;
      348 	ad.output_etb_mode = "0"b;			/* off by default */
      349 	ad.use_etb = "0"b;
      350 	dma.dial_qual = "";				/* Space for phone number */
      351 	do i = 2 to hbound (arg_option, 1);
      352 	     if arg_option (i) = "-transparent" then ad.transparent = "1"b;
      353 	     else if arg_option (i) = "-nontransparent" then ad.transparent = "0"b;
      354 	     else if arg_option (i) = "-ascii" then do;
      355 		ad.ascii = "1"b;
      356 	     end;
      357 	     else if arg_option (i) = "-ebcdic" then do;
      358 		ad.ascii = "0"b;
      359 	     end;
      360 	     else if arg_option (i) = "-size" then do;
      361 		ad.block_len, ad.max_block_len = cv_dec_arg (); /* Get size value */
      362 		if (ad.block_len < 6) | (ad.block_len > 2000) then
      363 		     call abort_attach ("Invalid block size: ^a", (arg_option (i)));
      364 	     end;
      365 	     else if arg_option (i) = "-delay" then ad.delay = 1000 * cv_dec_arg ();
      366 	     else if arg_option (i) = "-output_etb" then ad.output_etb_mode, ad.use_etb = "1"b;
      367 	     else if arg_option (i) = "-output_etx" then ad.output_etb_mode, ad.use_etb = "0"b;
      368 	     else if arg_option (i) = "-bretb" then ad.break_on_etb = "1"b;
      369 	     else if arg_option (i) = "-breot" then ad.break_on_eot = "1"b;
      370 	     else if arg_option (i) = "-hangup" then ad.hangup_sw = "1"b;
      371 	     else if arg_option (i) = "-ibm3270_mode" then ad.ibm3270_mode = "1"b;
      372 	     else if arg_option (i) = "-hasp_mode" then ad.hasp_mode = "1"b;
      373 	     else if arg_option (i) = "-master" then ad.master_sw = "1"b;
      374 	     else if arg_option (i) = "-slave" then ad.slave_sw = "1"b;
      375 	     else if arg_option (i) = "-bid_limit" then ad.bid_limit = cv_dec_arg ();
      376 	     else if arg_option (i) = "-ttd_time" then ad.ttd_time = cv_dec_arg ();
      377 	     else if arg_option (i) = "-ttd_limit" then ad.ttd_limit = cv_dec_arg ();
      378 	     else if arg_option (i) = "-multi_record" then do;
      379 		ad.multi_record = "1"b;
      380 		ad.multi_record_limit = 0;		/* Assume no limit on records per block */
      381 		if i < hbound (arg_option, 1) then	/* See if limit specified */
      382 		     if substr (arg_option (i+1), 1, 1) ^= "-" then
      383 			ad.multi_record_limit = cv_dec_arg ();
      384 	     end;
      385 	     else if arg_option (i) = "-auto_call" then do;
      386 		i = i + 1;
      387 		if i > hbound (arg_option, 1) then do;
      388 		     code = error_table_$noarg;
      389 		     call abort_attach ("No phone number after -auto_call", "");
      390 		end;
      391 		dma.dial_qual = arg_option (i);
      392 	     end;
      393 	     else if arg_option (i) = "-debug_log" then ad.log_sw = "1"b;
      394 	     else do;
      395 		code = error_table_$badopt;
      396 		call abort_attach ("^a", (arg_option (i)));
      397 	     end;
      398 	end;
      399 
      400 /* Get bisync channel from answering service. */
      401 
      402 	ad.nchan = 1;
      403 	call ipc_$create_ev_chn (ad.attach_channel, code);	/* Need normal event chan for this part */
      404 	if code ^= 0 then do;
      405 	     call convert_ipc_code_ (code);
      406 	     call abort_attach ("Unable to create event channel", "");
      407 	end;
      408 	dma.version = 1;				/* Setup dial manager data structure */
      409 	dma.event_channel = ad.attach_channel;
      410 	dma.channel_name = ad.device;
      411 	if dma.dial_qual = "" then call dial_manager_$privileged_attach (addr (dma), code);
      412 	else call dial_manager_$dial_out (addr (dma), code);
      413 	if code = error_table_$action_not_performed | code = error_table_$resource_attached
      414 	     then go to maybe_mine_already;
      415 	if code ^= 0 then call abort_attach ("From dial_manager_ attaching ^a", ad.device);
      416 	call block (ad.attach_channel, 1);                     /* Wait for answering service */
      417 	if code ^= 0 then call abort_attach ("From ipc_$block waiting for ^a attachment.", ad.device);
      418 
      419 	call convert_dial_message_ (unspec (event_info.message), dial_msg_chan, dial_msg_module,
      420 	     dial_msg_ndialed, dial_msg_flags, code);
      421 	if code ^= 0 then call abort_attach ("From dial_manager_ attaching ^a", ad.device);
      422 maybe_mine_already:
      423 	ad.channel = 0;
      424 
      425 /* Setup event channel */
      426 
      427 	if ad.ibm3270_mode then go to use_std_chan;
      428 	call hcs_$assign_channel (ad.channel, code);	/* Try fast one first  */
      429 	if code ^= 0 then do;
      430 use_std_chan:  call ipc_$create_ev_chn (ad.channel, code);	/* Try normal one */
      431 	     if code ^= 0 then do;
      432 		call convert_ipc_code_ (code);
      433 		ad.channel = 0;
      434 		call abort_attach ("Unable to create event channel.", "");
      435 	     end;
      436 	end;
      437 
      438 /* Create second event channel for timer */
      439 
      440 	call ipc_$create_ev_chn (ad.timer_channel, code);
      441 	if code ^= 0 then do;
      442 	     call convert_ipc_code_ (code);
      443 	     ad.timer_channel = 0;
      444 	     call abort_attach ("Unable to create event channel", "");
      445 	end;
      446 
      447 /* Initialize IOCB variables */
      448 
      449 	ad.input_buf_len, ad.output_buf_len = 0;
      450 	ad.input_buf_ptr, ad.output_buf_ptr = null;
      451 	ad.input_blockp = null;
      452 	ad.last_input_blockp = null;
      453 	call set_control_chars;			/* Set up control chars for this mode */
      454 
      455 /* Setup logging IOCB if requested */
      456 
      457 	if ad.log_sw then do;
      458 	     order = rtrim (iocbp -> iocb.name) || ".log"; /* Name of switch and segment */
      459 	     call iox_$attach_name (order, ad.log_iocbp, "vfile_ " || rtrim (order), null, code);
      460 	     if code = 0 then do;
      461 		call iox_$open (ad.log_iocbp, Sequential_output, "0"b, code);
      462 		if code ^= 0 then do;
      463 		     call com_err_ (code, iomodule_name, "Opening log ^a", order);
      464 		     call iox_$detach_iocb (ad.log_iocbp, code);
      465 		     ad.log_sw = "0"b;
      466 		end;
      467 	     end;
      468 	     else do;
      469 		call com_err_ (code, iomodule_name, "attaching log ^a", order);
      470 		ad.log_sw = "0"b;
      471 	     end;
      472 	end;
      473 
      474 /* Attach the device */
      475 
      476 	call hcs_$tty_attach ((ad.device), ad.channel, ad.tty_index, state, code);
      477 	if code ^= 0 then call abort_attach ("Unable to attach ^a.", ad.device);
      478 	if code = 0 then ad.tty_attached = "1"b;
      479 	mode_data.req_len = length (mode_data.req);
      480 	mode_data.req = "rawi,rawo";
      481 	call hcs_$tty_order (ad.tty_index, "modes", addr (mode_data), state, code);
      482 	call check_error_code;
      483 	if code ^= 0 then call abort_attach ("Unable to set rawi,rawo modes.", "");
      484 	call hcs_$tty_order (ad.tty_index, "set_input_message_size", addr (ad.block_len), state, code);
      485 	call check_error_code;
      486 	if code ^= 0 then call abort_attach ("Unable to set message size.", "");
      487 
      488 	if ad.ibm3270_mode then do;
      489 	     call line_control (SET_3270_MODE, 0);
      490 	     if code ^= 0 then call abort_attach ("Unable to set 3270 mode", "");
      491 	end;
      492 	if ad.hasp_mode then do;
      493 	     call line_control (SET_HASP_MODE, 0);
      494 	     if code ^= 0 then call abort_attach ("Unable to set hasp mode.", "");
      495 	     if ad.master_sw | ad.slave_sw then do;
      496 		call line_control (SET_MASTER_SLAVE_MODE, bin (ad.master_sw));
      497 		if code ^= 0 then call abort_attach ("Unable to set master or slave mode", "");
      498 	     end;
      499 	end;
      500 	call line_control (SET_BID_LIMIT, ad.bid_limit);
      501 	if code ^= 0 then call abort_attach ("Unable to set bid limit.", "");
      502 	call line_control (CONFIGURE, bin (ad.transparent || ^ad.ascii));
      503 	if code ^= 0 then call abort_attach ("Unable to configure line.", "");
      504 	call line_control2 (SET_TTD_PARAMS, ad.ttd_time, ad.ttd_limit);
      505 	if code ^= 0 then call abort_attach ("Unable to set ttd params.", "");
      506 
      507 /* Now mask and complete the iocb */
      508 
      509 	ad.attach_description = iomodule_name;
      510 	do i = 1 to hbound (arg_option, 1);
      511 	     ad.attach_description = ad.attach_description || " ";
      512 	     ad.attach_description = ad.attach_description || arg_option (i);
      513 	end;
      514 	call hcs_$set_ips_mask ("0"b, mask);
      515 	iocbp -> iocb.attach_descrip_ptr = addr (ad.attach_description);
      516 	iocbp -> iocb.attach_data_ptr = adp;
      517 	iocbp -> iocb.open = bisync_open;
      518 	iocbp -> iocb.detach_iocb = bisync_detach;
      519 	call iox_$propagate (iocbp);
      520 	call hcs_$reset_ips_mask (mask, mask);
      521 attach_return:
      522 	return;
      523 
      524 /* Internal procedure to handle decimal args */
      525 
      526 cv_dec_arg: proc returns (fixed bin);
      527 
      528 	     i = i + 1;				/* Advance to next arg */
      529 	     if i > hbound (arg_option, 1) then do;
      530 		code = error_table_$noarg;
      531 		call abort_attach ("No argument after ^a.", (arg_option (i-1)));
      532 	     end;
      533 	     on conversion go to bad_dec_arg;
      534 	     return (bin (arg_option (i)));
      535 
      536 bad_dec_arg:
      537 	     code = 0;
      538 	     call abort_attach ("Invalid decimal number. ^a", (arg_option (i)));
      539 
      540 	end cv_dec_arg;
      541 
      542 /* Internal procedure to handle attach errors */
      543 
      544 abort_attach: proc (str1, str2);
      545 
      546 dcl (str1, str2) char (*) aligned;
      547 
      548 	     if com_err_sw then call com_err_ (code, iomodule_name, str1, str2);
      549 	     if code = 0 then code = error_table_$badopt;
      550 	     arg_code = code;
      551 
      552 	     if adp ^= null then do;
      553 		if ad.tty_attached then call hcs_$tty_detach (ad.tty_index, 0, state, code); 
      554 		if ad.channel ^= 0 then call ipc_$delete_ev_chn (ad.channel, code);	
      555 		if ad.timer_channel ^= 0 then call ipc_$delete_ev_chn (ad.timer_channel, code);
      556 		if ad.attach_channel ^= 0 then call ipc_$delete_ev_chn (ad.attach_channel, code);
      557 	     end;
      558 	     if area_info.areap ^= null then call release_area_ (area_info.areap);
      559 	     go to attach_return;
      560 
      561 	end abort_attach;
      562 
      563 
      564 /* Detach entry point */
      565 
      566 bisync_detach: entry (arg_iocbp, arg_code);
      567 
      568 	iocbp = arg_iocbp;
      569 	arg_code, code = 0;
      570 
      571 	adp = iocbp -> iocb.attach_data_ptr;
      572 
      573 	if ad.log_sw then do;
      574 	     call iox_$close (ad.log_iocbp, code);
      575 	     call iox_$detach_iocb (ad.log_iocbp, code);
      576 	end;
      577 
      578 	call hcs_$set_ips_mask ("0"b, mask);
      579 
      580 	if ad.attach_channel ^= 0 then do;
      581 	     if ad.attach_channel_is_call then
      582 		call ipc_$decl_ev_wait_chn (ad.attach_channel, (0));
      583 	end;
      584 
      585 	if ad.hangup_sw then call hcs_$tty_order (ad.tty_index, "hangup", null, state, code);
      586 	call hcs_$tty_detach (ad.tty_index, 0, state, code);
      587 	dma.version = 1;				/* Setup dial manager data structure */
      588 	dma.event_channel = ad.attach_channel;
      589 	dma.channel_name = ad.device;
      590 	dma.dial_qual = "";
      591 	if ad.hangup_sw then call dial_manager_$release_channel (addr (dma), code);
      592 	else call dial_manager_$release_channel_no_hangup (addr (dma), code);
      593 	call ipc_$delete_ev_chn (ad.channel, code);
      594 	call ipc_$delete_ev_chn (ad.timer_channel, code);
      595 	call ipc_$delete_ev_chn (ad.attach_channel, code);
      596 	iocbp -> iocb.attach_descrip_ptr = null;
      597 	call iox_$propagate (iocbp);
      598 	call hcs_$reset_ips_mask (mask, mask);
      599 	call release_area_ (addr (work_area));
      600 	return;
      601 
      602 /* Open entry point */
      603 
      604 bisync_open: entry (arg_iocbp, arg_mode, arg_sw, arg_code);
      605 
      606 	iocbp = arg_iocbp -> iocb.actual_iocb_ptr;
      607 	arg_code, code = 0;
      608 	adp = iocbp -> iocb.attach_data_ptr;
      609 
      610 	open_mode = arg_mode;
      611 	if ^((open_mode = Stream_input) | (open_mode = Stream_output) | (open_mode = Stream_input_output)) then do;
      612 	     arg_code = error_table_$bad_mode;
      613 	     return;
      614 	end;
      615 
      616 	call hcs_$tty_state (ad.tty_index, state, code);	/* See if I own channel */
      617 	if code ^= 0 then do;
      618 	     arg_code = code;
      619 	     return;
      620 	end;
      621 
      622 	ad.open_description = rtrim (iox_modes (open_mode));
      623 	ad.write_error_code = 0;
      624 
      625 	call hcs_$set_ips_mask ("0"b, mask);
      626 	if ((open_mode = Stream_input) | (open_mode = Stream_input_output)) then do;
      627 	     iocbp -> iocb.get_chars = bisync_get_chars;
      628 	     iocbp -> iocb.get_line = bisync_get_line;
      629 	     iocbp -> iocb.position = bisync_position;
      630 	     iocbp -> iocb.control = bisync_control;
      631 	     call line_control (ACCEPT_BID, 0);		/* We can accept line bids now */
      632 	end;
      633 	ad.input_buf_len = 2 * ad.block_len;		/* Make generous input buffer */
      634 	allocate input_block in (work_area);
      635 	ad.last_input_blockp = ad.input_blockp;
      636 	ad.input_buf_ptr = addr (input_block.input_buffer);
      637 	ad.unscanned_data_len = 0;
      638 	ad.scanned_data_len = 0;
      639 	ad.input_state = 1;
      640 	ad.output_buf_used = 0;
      641 	ad.saved_eot = "0"b;
      642 	if ((open_mode = Stream_output) | (open_mode = Stream_input_output)) then do;
      643 	     iocbp -> iocb.put_chars = bisync_put_chars;
      644 	     iocbp -> iocb.control = bisync_control;
      645 	     ad.output_buf_len = ad.block_len + BISYNC_OVERHEAD;
      646 	     allocate output_buffer in (work_area);
      647 	     ad.output_buf_left = ad.output_buf_len;
      648 	     ad.output_mode = "1"b;			/* One of output modes selected */
      649 	end;
      650 
      651 	iocbp -> iocb.close = bisync_close;
      652 	iocbp -> iocb.open_descrip_ptr = addr (ad.open_description);
      653 	call iox_$propagate (iocbp);
      654 	call hcs_$reset_ips_mask (mask, mask);
      655 	return;
      656 
      657 /* Close entry point */
      658 
      659 bisync_close: entry (arg_iocbp, arg_code);
      660 
      661 	iocbp = arg_iocbp -> iocb.actual_iocb_ptr;
      662 	arg_code, code = 0;
      663 	adp = iocbp -> iocb.attach_data_ptr;
      664 
      665 
      666 	if ad.output_mode then do;			/* If doing output */
      667 	     if ad.multi_record & (ad.output_buf_used > 0) then call transmit_block_timed (30);
      668 	     else time_out = "0"b;
      669 	     if ^time_out then do;
      670 		substr (output_buffer, 1, 1) = ad.eot;	/* Build eot message */
      671 		ad.output_buf_used = 1;
      672 		call transmit_block_timed (30);
      673 	     end;
      674 	     free output_buffer;
      675 	end;
      676 	call internal_resetread;
      677 	free input_block;
      678 
      679 	call hcs_$set_ips_mask ("0"b, mask);
      680 	iocbp -> iocb.open_descrip_ptr = null;
      681 	iocbp -> iocb.open = bisync_open;
      682 	iocbp -> iocb.detach_iocb = bisync_detach;
      683 	iocbp -> iocb.control = iox_$err_no_operation;
      684 	call iox_$propagate (iocbp);
      685 	call hcs_$reset_ips_mask (mask, mask);
      686 	return;
      687 
      688 
      689 /* Put_chars entry point */
      690 
      691 bisync_put_chars: entry (arg_iocbp, arg_data_ptr, arg_data_len, arg_code);
      692 
      693 	iocbp = arg_iocbp -> iocb.actual_iocb_ptr;
      694 	arg_code, code = 0;
      695 	adp = iocbp -> iocb.attach_data_ptr;
      696 	data_ptr = arg_data_ptr;
      697 	data_len = arg_data_len;
      698 
      699 	if data_len < 0 then do;
      700 	     arg_code = error_table_$bad_arg;
      701 	     return;
      702 	end;
      703 
      704 	if ad.write_error_code ^= 0 then do;		/* Left over error to report */
      705 rpt_write_error:
      706 	     arg_code = ad.write_error_code;
      707 	     ad.write_error_code = 0;
      708 	     return;
      709 	end;
      710 
      711 	real_transparent = ad.transparent & ^ad.temp_nontransparent;
      712 	ad.temp_nontransparent = "0"b;
      713 
      714 	remaining_len = data_len;			/* This is decremented as data is sent */
      715 	offset = 1;				/* Current character in data to send */
      716 
      717 	do while (remaining_len >= 0);
      718 	     if real_transparent then call format_transparent_block;
      719 	     else call format_nontransparent_block;
      720 	     if ad.multi_record & (remaining_len < 0) then do; /* May not want to write this yet */
      721 		if ad.multi_record_limit = 0 then return; /* No limit on records per block */
      722 		if ad.record_count < ad.multi_record_limit then return; /* There is a limit but not reached yet */
      723 	     end;
      724 	     call transmit_block;			/* And ship it */
      725 	     if ad.write_error_code ^= 0 then go to rpt_write_error;
      726 	     if code ^= 0 then do;
      727 		arg_code = code;
      728 		return;
      729 	     end;
      730 	end;
      731 
      732 	return;
      733 
      734 /* Internal procedure to format a nontransparent bisync data block for a put_chars call. */
      735 
      736 format_nontransparent_block: proc;
      737 
      738 dcl (cl, dl) fixed bin;
      739 dcl  etb_sw bit (1);
      740 
      741 	     if ad.ascii then cl = 3;			/* Number of ctl chars, stx,etx,lrc */
      742 	     else cl = 4;				/* Just stx,etx,bcc,bcc */
      743 
      744 	     if (remaining_len + cl) > ad.output_buf_left then do; /* Won't fit fully in current block */
      745 		if ad.output_buf_used > 0 then return;	/* Return to dump what is already in buffer */
      746 		dl = ad.output_buf_left - cl;		/* Take the biggest chunk possible */
      747 		etb_sw = "1"b;			/* Since we are splitting a msg, use an etb */
      748 	     end;
      749 	     else do;				/* New message will fit in current block */
      750 		dl = remaining_len;
      751 		etb_sw = "0"b;			/* Can end with etx */
      752 	     end;
      753 
      754 	     if ad.output_buf_used > 0 then		/* Change previous record in block to end in itb */
      755 		substr (output_buffer, ad.last_etx, 1) = ad.itb;
      756 	     substr (output_buffer, ad.output_buf_used+1, 1) = ad.stx;
      757 	     if dl > 0 then				/* Copy real data */
      758 		substr (output_buffer, ad.output_buf_used+2, dl) = substr (data_arg, offset, dl);
      759 	     remaining_len = remaining_len - dl;
      760 	     offset = offset + dl;
      761 	     ad.last_etx = ad.output_buf_used + dl + 2;	/* Remember position of last etx */
      762 	     if etb_sw | ad.use_etb then substr (output_buffer, ad.last_etx, 1) = ad.etb;
      763 	     else substr (output_buffer, ad.last_etx, 1) = ad.etx;
      764 	     ad.output_buf_used = ad.output_buf_used + dl + 2;
      765 	     ad.output_buf_left = ad.output_buf_left - dl - 2;
      766 	     if ad.ascii then do;			/* Must allow for lrc */
      767 		ad.output_buf_used = ad.output_buf_used + 1;
      768 		substr (output_buffer, ad.output_buf_used, 1) = low (1);
      769 		ad.output_buf_left = ad.output_buf_left - 1;
      770 	     end;
      771 	     else ad.output_buf_left = ad.output_buf_left - 2; /* Adjust for bcc,bcc */
      772 
      773 	     ad.record_count = ad.record_count + 1;
      774 	     if remaining_len = 0 then remaining_len = -1; /* This is flag meaning done */
      775 	     return;
      776 
      777 	end format_nontransparent_block;
      778 
      779 /* Internal procedure to format a bisync transparent block */
      780 
      781 format_transparent_block: proc;
      782 
      783 dcl (i, dl, real_chars, moved) fixed bin;
      784 dcl  etb_sw bit (1);
      785 
      786 	     if (remaining_len + 6) > ad.output_buf_left then do; /* Not all data will fit in current block */
      787 		if ad.output_buf_used > 0 then return;	/* If partially full block, return to transmit it */
      788 		dl = ad.output_buf_left - 6;		/* Compute max that will fit */
      789 		etb_sw = "1"b;			/* Indicate what block is being split */
      790 	     end;
      791 	     else do;				/* It seems all data will fit (it may not because of dle's) */
      792 		dl = remaining_len;
      793 		etb_sw = "0"b;
      794 	     end;
      795 
      796 format_transparent_loop:
      797 	     real_chars = dl + 4;			/* Number of characters that will go in buffer */
      798 	     i = count_dle (substraddr (data_arg, offset), dl);
      799 	     if i > 0 then				/* There are dle's in the string */
      800 		if (real_chars + i) > ad.output_buf_left then do; /* Which will cause overflow */
      801 		     if ad.output_buf_used > 0 then return; /* Dump partially fill block first */
      802 		     dl = dl - 1;			/* Use one less character */
      803 		     etb_sw = "1"b;			/* Indicate a block is being split */
      804 		     go to format_transparent_loop;
      805 		end;
      806 
      807 	     if ad.output_buf_used > 0 then		/* Change last etx to an itb */
      808 		substr (output_buffer, ad.last_etx, 1) = ad.itb;
      809 
      810 	     substr (output_buffer, ad.output_buf_used+1, 1) = ad.dle; /* Start new block */
      811 	     substr (output_buffer, ad.output_buf_used+2, 1) = ad.stx;
      812 	     ad.output_buf_used = ad.output_buf_used + 2;
      813 	     ad.output_buf_left = ad.output_buf_left - 2;
      814 	     moved = 0;
      815 	     do while (moved < dl);			/* Copy the real data, doubleing dles */
      816 		i = index (substr (data_arg, offset, dl - moved), ad.dle); /* Check for dle */
      817 		if i = 1 then do;			/* Next char is a dle */
      818 		     substr (output_buffer, ad.output_buf_used+1, 1) = ad.dle;
      819 		     substr (output_buffer, ad.output_buf_used+2, 1) = ad.dle;
      820 		     ad.output_buf_used = ad.output_buf_used + 2;
      821 		     ad.output_buf_left = ad.output_buf_left - 2;
      822 		     offset = offset + 1;
      823 		     moved = moved + 1;
      824 		     remaining_len = remaining_len - 1;
      825 		end;
      826 		else do;				/* First char is not a dle */
      827 		     if i = 0 then i = dl - moved;	/* No dle's */
      828 		     else i = i - 1;		/* Used stuff before dle */
      829 		     substr (output_buffer, ad.output_buf_used+1, i) = substr (data_arg, offset, i);
      830 		     ad.output_buf_used = ad.output_buf_used + i;
      831 		     ad.output_buf_left = ad.output_buf_left - i;
      832 		     offset = offset + i;
      833 		     moved = moved + i;
      834 		     remaining_len = remaining_len - i;
      835 		end;
      836 	     end;
      837 	     substr (output_buffer, ad.output_buf_used+1, 1) = ad.dle; /* Finish up block */
      838 	     if etb_sw | ad.use_etb then substr (output_buffer, ad.output_buf_used+2, 1) = ad.etb;
      839 	     else substr (output_buffer, ad.output_buf_used+2, 1) = ad.etx;
      840 	     ad.last_etx = ad.output_buf_used + 2;
      841 	     ad.output_buf_used = ad.output_buf_used + 2;
      842 	     ad.output_buf_left = ad.output_buf_left - 4; /* Adjust for dle,(etx|etb|itb),bcc,bcc */
      843 
      844 	     ad.record_count = ad.record_count + 1;
      845 	     if remaining_len = 0 then remaining_len = -1;
      846 	     return;
      847 
      848 	end format_transparent_block;
      849 
      850 /* Function for counting dles in a string */
      851 
      852 count_dle: proc (p, l) returns (fixed bin);
      853 
      854 dcl  p ptr;
      855 dcl  l fixed bin;
      856 dcl  c char (l) based (p);
      857 dcl (i, j, k) fixed bin;
      858 
      859 	     if l = 0 then return (0);
      860 	     i = 1;
      861 	     j = 0;				/* The count */
      862 	     do while (i <= l);
      863 		k = index (substr (c, i), ad.dle);
      864 		if k = 0 then return (j);
      865 		j = j + 1;
      866 		i = i + k;
      867 	     end;
      868 	     return (j);
      869 
      870 	end count_dle;
      871 
      872 /* Internal procedure to transmit a bisync block during a put_chars operation */
      873 
      874 transmit_block: proc;
      875 
      876 dcl (i, j) fixed bin (21);
      877 dcl  p ptr;
      878 dcl  time_limit bit (1) init ("0"b);
      879 
      880 dcl 1 write_status aligned,
      881     2 ev_chn fixed bin (71),
      882     2 output_pending bit (1) unal;
      883 
      884 transmit_block_start:
      885 	     i = 0;				/* Characters transmitted so far */
      886 	     do while (i < ad.output_buf_used);		/* Loop until everything sent */
      887 
      888 		write_status.output_pending = "1"b;
      889 		do while (write_status.output_pending); /* Wait until all data shipped out */
      890 		     call hcs_$tty_order (ad.tty_index, "write_status", addr (write_status), state, code);
      891 		     call check_error_code;
      892 		     if ad.write_error_code ^= 0 then return;
      893 		     if code ^= 0 then go to transmit_end;
      894 		     if write_status.output_pending then do; /* Really must wait */
      895 			call hide_away_input;	/* Flush out any input before blocking */
      896 			if code ^= 0 then return;
      897 			if ad.write_error_code ^= 0 then return;
      898 			if time_limit then do;
      899 			     call set_time (n_sec);
      900 			     call block (ad.channel, 2);
      901 			end;
      902 			else call block (ad.channel, 1);
      903 			if code ^= 0 then go to transmit_end;
      904 			if event_info.channel_id = ad.timer_channel then do; /* Timed out */
      905 			     time_out = "1"b;
      906 			     go to transmit_end;
      907 			end;
      908 		     end;
      909 		end;
      910 
      911 		if ad.delay > 0 then call timer_manager_$sleep (ad.delay, "10"b);
      912 
      913 		p = substraddr (output_buffer, i+1);	/* Addr of next character to send */
      914 		call hcs_$tty_write (ad.tty_index, p, 0, ad.output_buf_used - i, j, state, code);
      915 		call check_error_code;
      916 		if ad.write_error_code ^= 0 then return;
      917 		if code ^= 0 then go to transmit_end;
      918 		if ad.log_sw then call iox_$write_record (ad.log_iocbp, p, j, (0));
      919 		i = i + j;			/* Accumulate length sent */
      920 		if i < ad.output_buf_used then do;
      921 		     call hide_away_input;
      922 		     if code ^= 0 then return;
      923 		     if ad.write_error_code ^= 0 then return;
      924 		end;
      925 	     end;
      926 
      927 	     code = 0;
      928 transmit_end:
      929 	     ad.output_buf_used = 0;
      930 	     ad.output_buf_left = ad.block_len;
      931 	     ad.record_count = 0;
      932 
      933 	     return;
      934 
      935 transmit_block_timed: entry (n_sec);			/* Call here with deadline */
      936 
      937 dcl  n_sec fixed bin;
      938 
      939 	     time_limit = "1"b;
      940 	     time_out = "0"b;
      941 	     go to transmit_block_start;
      942 
      943 	end transmit_block;
      944 
      945 /* Get_chars entry point */
      946 
      947 bisync_get_chars: entry (arg_iocbp, arg_buf_ptr, arg_buf_len, arg_data_len, arg_code);
      948 
      949 	iocbp = arg_iocbp -> iocb.actual_iocb_ptr;
      950 	adp = iocbp -> iocb.attach_data_ptr;
      951 	buf_ptr = arg_buf_ptr;
      952 	buf_len = arg_buf_len;
      953 	arg_data_len, data_len = 0;
      954 	remaining_len = buf_len;
      955 	order_sw = "0"b;				/* Not called as order */
      956 	hbuf_ptr = null;
      957 
      958 get_chars_join:
      959 	code, arg_code = 0;
      960 	header_found, data_found = "0"b;
      961 
      962 	if ad.saved_eot then do;
      963 	     ad.saved_eot = "0"b;
      964 	     eot_found = "1"b;
      965 	     go to get_chars_return;
      966 	end;
      967 
      968 get_chars_retry:
      969 	etb_found = "0"b;
      970 	soh_found = "0"b;
      971 	etx_found = "0"b;
      972 	stx_found = "0"b;
      973 	eot_found = "0"b;
      974 	do while ((remaining_len > 0) & ^etx_found);	/* Loop until request satisfied */
      975 	     if ad.scanned_data_len > 0 then		/* Return scanned data if any present * */
      976 		call move_scanned_data (min (ad.scanned_data_len, remaining_len));
      977 	     else do;
      978 		call scan_more_data;
      979 		if code ^= 0 then do;
      980 		     arg_code = code;
      981 		     return;
      982 		end;
      983 		if eot_found then do;
      984 		     if ^(header_found | data_found) then go to get_chars_return;
      985 		     ad.saved_eot = "1"b;		/* Otherwise, must report later */
      986 		     go to get_chars_return;
      987 		end;
      988 	     end;
      989 	end;
      990 
      991 	if (data_len = 0) & etx_found & ^(stx_found | soh_found) then go to get_chars_retry;
      992 						/* This means the etx we found was really from the prev block */
      993 
      994 get_chars_return:
      995 	if order_sw then go to get_chars_order_return;	/* Called as order */
      996 	if eot_found then code = error_table_$end_of_info;
      997 	arg_data_len = data_len;
      998 	return;
      999 
     1000 /* Get_chars order starts here */
     1001 
     1002 get_chars_order:
     1003 	buf_ptr = get_chars_info.buf_ptr;		/* Copy data from structure */
     1004 	buf_len = get_chars_info.buf_len;
     1005 	remaining_len = get_chars_info.buf_len;
     1006 	hbuf_ptr = get_chars_info.hbuf_ptr;		/* Likewise for header */
     1007 	hbuf_len = get_chars_info.hbuf_len;
     1008 	data_len, header_len = 0;
     1009 	get_chars_info.data_len = 0;
     1010 	get_chars_info.header_len = 0;
     1011 	string (get_chars_info.flags) = "0"b;
     1012 	order_sw = "1"b;
     1013 	go to get_chars_join;
     1014 
     1015 /* Come here at end of get_chars operation invoked as order */
     1016 
     1017 get_chars_order_return:
     1018 	if eot_found then get_chars_info.eot = "1"b;
     1019 	else do;					/* Have real data */
     1020 	     if header_found then do;
     1021 		get_chars_info.header_len = header_len;
     1022 		get_chars_info.soh = "1"b;
     1023 	     end;
     1024 	     if data_found then do;
     1025 		get_chars_info.data_len = data_len;
     1026 		if etb_found then get_chars_info.etb = "1"b;
     1027 		else if etx_found then get_chars_info.etx = "1"b;
     1028 	     end;
     1029 	end;
     1030 	go to control_return;
     1031 
     1032 /* Get_line entry point */
     1033 
     1034 bisync_get_line: entry (arg_iocbp, arg_buf_ptr, arg_buf_len, arg_data_len, arg_code);
     1035 
     1036 	iocbp = arg_iocbp -> iocb.actual_iocb_ptr;
     1037 	adp = iocbp -> iocb.attach_data_ptr;
     1038 	buf_ptr = arg_buf_ptr;
     1039 	buf_len = arg_buf_len;
     1040 	arg_data_len, data_len = 0;
     1041 	arg_code, code = 0;
     1042 	remaining_len = buf_len;
     1043 	nl_found = "0"b;
     1044 	ad.saved_eot = "0"b;
     1045 
     1046 	do while ((remaining_len > 0) & ^nl_found);
     1047 	     if ad.scanned_data_len > 0 then do;	/* Look at available data */
     1048 		i = index (scanned_data, nl);
     1049 		if i = 0 then i = ad.scanned_data_len;	/* No new-line */
     1050 		else nl_found = "1"b;
     1051 		call move_scanned_data (min (i, remaining_len));
     1052 	     end;
     1053 	     else do;
     1054 		call scan_more_data;
     1055 		if code ^= 0 then do;
     1056 		     arg_code = code;
     1057 		     return;
     1058 		end;
     1059 	     end;
     1060 	end;
     1061 
     1062 	if data_len > 0 then if substr (buf_arg, data_len, 1) ^= nl then
     1063 		arg_code = error_table_$long_record;
     1064 	arg_data_len = data_len;
     1065 	return;
     1066 
     1067 
     1068 /* Procedure to scan some more of the input buffer */
     1069 
     1070 scan_more_data: proc;
     1071 
     1072 dcl (i, j) fixed bin (21);
     1073 dcl  block_ok bit (1);				/* Set if ok to block waiting for data */
     1074 dcl  p ptr;
     1075 
     1076 	     block_ok = "1"b;			/* Ok to block at normal entry */
     1077 	     go to get_more_data;
     1078 
     1079 scan_more_data_noblock: entry;			/* Entry called to test, blocking not permitted */
     1080 	     block_ok = "0"b;
     1081 
     1082 get_more_data: code = 0;
     1083 	     do while (ad.unscanned_data_len = 0);	/* First need data to scan */
     1084 		if input_block.next_blockp = null then do; /* No extra input buffers waiting */
     1085 		     call hcs_$tty_read (ad.tty_index, ad.input_buf_ptr, 0, ad.input_buf_len, i, state, code);
     1086 		     call check_error_code;
     1087 		     if code ^= 0 then return;
     1088 		end;
     1089 		else do;				/* Free current buffer and switch to new one already full */
     1090 		     p = input_block.next_blockp;	/* Save pointer to next block */
     1091 		     free input_block;
     1092 		     ad.input_blockp = p;
     1093 		     ad.input_buf_ptr = addr (input_block.input_buffer); /* New buffer */
     1094 		     i = input_block.data_len;	/* Will never be 0 */
     1095 		end;
     1096 		if i = 0 then do;			/* Must wait for data */
     1097 		     if ^block_ok then return;
     1098 		     call block (ad.channel, 1);
     1099 		     if code ^= 0 then return;
     1100 		end;
     1101 		else do;				/* Read something */
     1102 		     if ad.log_sw then call iox_$write_record (ad.log_iocbp, ad.input_buf_ptr, i, (0));
     1103 		     ad.unscanned_data_len = i;
     1104 		     ad.unscanned_data_ptr = ad.input_buf_ptr;
     1105 		end;
     1106 	     end;
     1107 
     1108 /* Now dispatch of current state of input scan and the data type */
     1109 
     1110 	     if ad.transparent then go to get_data_trans (ad.input_state);
     1111 	     else go to get_data_non_trans (ad.input_state);
     1112 
     1113 get_data_non_trans (1):				/* Looking for stx in non_transparent mode */
     1114 	     if substr (unscanned_data, 1, 1) = ad.stx then do; /* Found data */
     1115 		stx_found = "1"b;
     1116 		ad.input_state = 2;
     1117 		call advance_unscanned_data (1);
     1118 		go to get_more_data;
     1119 	     end;
     1120 	     if substr (unscanned_data, 1, 1) = ad.soh then do; /* Found header */
     1121 		soh_found = "1"b;
     1122 		ad.input_state = 6;
     1123 		call advance_unscanned_data (1);
     1124 		go to get_more_data;
     1125 	     end;
     1126 	     if ^ad.break_on_eot | (substr (unscanned_data, 1, 1) ^= ad.eot) then do; /* Nothing else matters but eot */
     1127 		call advance_unscanned_data (1);
     1128 		go to get_more_data;
     1129 	     end;
     1130 	     call advance_unscanned_data (1);		/* Move over eot */
     1131 	     eot_found = "1"b;
     1132 	     return;
     1133 
     1134 get_data_non_trans (2):				/* In middle of block, looking for etb or etx */
     1135 	     i = index (unscanned_data, ad.etx);
     1136 	     if i = 1 then do;			/* End of block */
     1137 		call advance_unscanned_data (1);	/* Move over etx */
     1138 		etx_found = "1"b;
     1139 		if ad.ascii then ad.input_state = 3;	/* State 3 to skip lrc character */
     1140 		else ad.input_state = 1;
     1141 		return;
     1142 	     end;
     1143 	     if ad.multi_record then do;		/* Must check for itbs */
     1144 		j = index (unscanned_data, ad.itb);
     1145 		if j ^= 0 then do;			/* There is one */
     1146 		     if j = 1 then do;		/* Next char is itb */
     1147 			call advance_unscanned_data (1);
     1148 			etx_found = "1"b;		/* Treat like etx */
     1149 			if ad.ascii then ad.input_state = 4; /* Go skip lrc */
     1150 			else ad.input_state = 5;
     1151 			return;
     1152 		     end;
     1153 		     else if i = 0 then i = j;	/* If no etx, use itb */
     1154 		     else i = min (i, j);		/* Otherwise use wat comes first */
     1155 		end;
     1156 	     end;
     1157 
     1158 	     if i = 0 then i = ad.unscanned_data_len;	/* All good data */
     1159 	     else i = i - 1;			/* Use stuff before etx */
     1160 	     j = index (unscanned_data, ad.etb);	/* Check for etb too */
     1161 	     if j = 1 then do;			/* Found etb before etx */
     1162 		call advance_unscanned_data (1);	/* Over etb */
     1163 		if ad.ascii then ad.input_state = 3;	/* Skp lrc in non-transparent ascii */
     1164 		else ad.input_state = 1;		/* Back to stx search if ebcdic */
     1165 		if ad.break_on_etb then do;		/* If break wanted here */
     1166 		     etb_found = "1"b;
     1167 		     etx_found = "1"b;
     1168 		     return;
     1169 		end;
     1170 		else go to get_more_data;
     1171 	     end;
     1172 	     if j ^= 0 then i = min (i, j-1);		/* If etb present, used data before etb or etx */
     1173 	     ad.scanned_data_len = i;			/* Amount of good data found */
     1174 	     ad.scanned_data_ptr = ad.unscanned_data_ptr;
     1175 	     call advance_unscanned_data (i);
     1176 	     return;
     1177 
     1178 get_data_non_trans (3):				/* Skip over lrc character after etx or etb */
     1179 	     call advance_unscanned_data (1);
     1180 	     ad.input_state = 1;
     1181 	     go to get_more_data;
     1182 
     1183 get_data_non_trans (4):				/* Skip lrc after itb */
     1184 	     call advance_unscanned_data (1);
     1185 	     ad.input_state = 5;
     1186 	     go to get_more_data;
     1187 
     1188 get_data_non_trans (5):				/* Check for optional stx after itb */
     1189 	     if substr (unscanned_data, 1, 1) = ad.stx then ad.input_state = 1; /* Its there */
     1190 	     else do;				/* Not there, pretend it is */
     1191 		stx_found = "1"b;
     1192 		ad.input_state = 2;
     1193 	     end;
     1194 	     go to get_more_data;
     1195 
     1196 get_data_non_trans (6):				/* Scanning data in header */
     1197 	     i = index (unscanned_data, ad.etx);	/* Look for etx */
     1198 	     if i = 1 then do;			/* First char */
     1199 get_data_non_trans_6a:
     1200 		call advance_unscanned_data (1);
     1201 		etx_found = "1"b;
     1202 		if ad.ascii then ad.input_state = 3;
     1203 		else ad.input_state = 1;
     1204 		return;
     1205 	     end;
     1206 	     j = index (unscanned_data, ad.etb);	/* Also look for etb */
     1207 	     if i = 0 then i = j;			/* If no etx, use etb */
     1208 	     else if j ^= 0 then i = min (i, j);	/* Otherwise use what comes first */
     1209 	     j = index (unscanned_data, ad.stx);	/* This may also terminate header */
     1210 	     if i = 0 then i = j;			/* If no etb or etx, use stx */
     1211 	     else if j ^= 0 then i = min (i, j);	/* Otherwise use what comes first */
     1212 	     if i = 0 then do;			/* Didnt find any special chars */
     1213 		ad.scanned_data_len = ad.unscanned_data_len; /* All data is part of header */
     1214 		ad.scanned_data_ptr = ad.unscanned_data_ptr;
     1215 		ad.unscanned_data_len = 0;
     1216 		return;
     1217 	     end;
     1218 	     if i = 1 then do;			/* Control char is first */
     1219 		if substr (unscanned_data, 1, 1) = ad.stx then do; /* Start of text portion */
     1220 		     call advance_unscanned_data (1);
     1221 		     stx_found = "1"b;		/* In data */
     1222 		     soh_found = "0"b;		/* Not in header */
     1223 		     ad.input_state = 2;
     1224 		     go to get_more_data;
     1225 		end;
     1226 		if substr (unscanned_data, 1, 1) = ad.etb & ^ad.break_on_etb then do;
     1227 		     call advance_unscanned_data (1);	/* Ignore etb */
     1228 		     if ad.ascii then ad.input_state = 3;
     1229 		     else ad.input_state = 1;
     1230 		     go to get_more_data;
     1231 		end;
     1232 		etb_found = (substr (unscanned_data, 1, 1) = ad.etb);
     1233 		go to get_data_non_trans_6a;
     1234 	     end;
     1235 	     i = i - 1;				/* Number of data chars in header */
     1236 	     ad.scanned_data_len = i;
     1237 	     ad.scanned_data_ptr = ad.unscanned_data_ptr;
     1238 	     call advance_unscanned_data (i);
     1239 	     return;
     1240 
     1241 
     1242 get_data_trans (1):					/* Looking for  dle-stx sequence */
     1243 	     i = index (unscanned_data, ad.dle);	/* First, find the dle */
     1244 	     if i = 0 then do;			/* No dle, throw away data */
     1245 		ad.unscanned_data_len = 0;
     1246 		go to get_more_data;
     1247 	     end;
     1248 	     call advance_unscanned_data (i);		/* Advance past dle */
     1249 	     ad.input_state = 2;
     1250 	     go to get_more_data;
     1251 
     1252 get_data_trans (2):					/* Found dle, next char should be stx */
     1253 	     if substr (unscanned_data, 1, 1) = ad.stx then do;
     1254 		call advance_unscanned_data (1);	/* Move over stx */
     1255 		ad.input_state = 3;			/* In std input state to read data now */
     1256 		stx_found = "1"b;
     1257 		go to get_more_data;
     1258 	     end;
     1259 	     ad.input_state = 1;			/* Dle-stx not found */
     1260 	     go to get_more_data;			/* Back to look for another dle */
     1261 
     1262 get_data_trans (3):					/* In text of message, but be careful of dles */
     1263 	     i = index (unscanned_data, ad.dle);
     1264 	     if i = 1 then do;			/* Found a dle */
     1265 		call advance_unscanned_data (1);	/* Over dle */
     1266 		ad.input_state = 4;			/* Must analyze next character */
     1267 		go to get_more_data;
     1268 	     end;
     1269 	     if i = 0 then i = ad.unscanned_data_len;	/* If no dle, all text is good */
     1270 	     else i = i-1;
     1271 	     ad.scanned_data_len = i;			/* Length of real text found */
     1272 	     ad.scanned_data_ptr = ad.unscanned_data_ptr;
     1273 	     call advance_unscanned_data (i);
     1274 	     return;
     1275 
     1276 get_data_trans (4):					/* Check text char after a dle */
     1277 	     if substr (unscanned_data, 1, 1) = ad.dle then do; /* Double dle */
     1278 		ad.scanned_data_len = 1;		/* Setup as 1 good dle character */
     1279 		ad.scanned_data_ptr = ad.unscanned_data_ptr;
     1280 		ad.input_state = 3;
     1281 		call advance_unscanned_data (1);
     1282 		return;
     1283 	     end;
     1284 	     if substr (unscanned_data, 1, 1) = ad.etb then do; /* End of text block */
     1285 		call advance_unscanned_data (1);	/* Throw away etb */
     1286 		ad.input_state = 1;			/* Looking for stx now */
     1287 		if ad.break_on_etb then do;		/* Break wanted here */
     1288 		     etx_found = "1"b;
     1289 		     return;
     1290 		end;
     1291 		else go to get_more_data;
     1292 	     end;
     1293 	     if substr (unscanned_data, 1, 1) = ad.etx then do; /* Real end of message */
     1294 trans_etx:	call advance_unscanned_data (1);
     1295 		ad.input_state = 1;
     1296 		etx_found = "1"b;
     1297 		return;
     1298 	     end;
     1299 	     if ad.multi_record then if substr (unscanned_data, 1, 1) = ad.itb then go to trans_etx;
     1300 	     ad.scanned_data_ptr = addr (ad.dle);	/* A dle-?? found, treat as data */
     1301 	     ad.scanned_data_len = 1;			/* Setup to return a dle first */
     1302 	     ad.input_state = 3;			/* Then the n ext char as regular data */
     1303 	     return;
     1304 
     1305 	end scan_more_data;
     1306 
     1307 /* Procedure to move characters to users output buffer */
     1308 
     1309 move_scanned_data: proc (amt);
     1310 
     1311 dcl  amt fixed bin (21);
     1312 dcl  i fixed bin (21);
     1313 
     1314 	     if soh_found then do;			/* Moving header */
     1315 		if hbuf_ptr ^= null then do;		/* Caller gave a place */
     1316 		     i = min (amt, hbuf_len - header_len);
     1317 		     if i > 0 then substr (header_arg, header_len + 1, i) = substr (scanned_data, 1, i);
     1318 		     header_len = header_len + i;
     1319 		     call advance_scanned_data (amt);
     1320 		     header_found = "1"b;
     1321 		end;
     1322 	     end;
     1323 	     else do;
     1324 		substr (buf_arg, data_len + 1, amt) = substr (scanned_data, 1, amt);
     1325 		data_len = data_len + amt;
     1326 		call advance_scanned_data (amt);
     1327 		remaining_len = remaining_len - amt;
     1328 		data_found = "1"b;
     1329 	     end;
     1330 	     return;
     1331 
     1332 	end move_scanned_data;
     1333 
     1334 /* Procedure to  more the pointer in the unscanned data area */
     1335 
     1336 advance_unscanned_data: proc (amt);
     1337 
     1338 dcl  amt fixed bin (21);
     1339 
     1340 	     ad.unscanned_data_ptr = substraddr (unscanned_data, amt+1);
     1341 	     ad.unscanned_data_len = ad.unscanned_data_len - amt;
     1342 	     return;
     1343 
     1344 	end advance_unscanned_data;
     1345 
     1346 /* Procedure to move pointer in the scanned data area */
     1347 
     1348 advance_scanned_data: proc (amt);
     1349 
     1350 dcl  amt fixed bin (21);
     1351 
     1352 	     ad.scanned_data_ptr = substraddr (scanned_data, amt+1);
     1353 	     ad.scanned_data_len = ad.scanned_data_len - amt;
     1354 	     return;
     1355 
     1356 	end advance_scanned_data;
     1357 
     1358 /* This procedure is called before going blocked on output. it will flush ring 0
     1359*   of any input that may have come in so that the write has a chance of going
     1360*   out. any input found is chained on to an input buffer chain to be found of the
     1361*   next read call */
     1362 
     1363 hide_away_input: proc;
     1364 
     1365 dcl 1 read_status aligned automatic like rw_status;
     1366 dcl  p ptr;
     1367 
     1368 	     read_status.flag = "1"b;
     1369 	     do while (read_status.flag);		/* Loop as long as there is data */
     1370 		call hcs_$tty_order (ad.tty_index, "read_status", addr (read_status), state, code);
     1371 		call check_error_code;
     1372 		if code ^= 0 then return;
     1373 		if read_status.flag then do;		/* There is data */
     1374 		     allocate input_block in (work_area) set (p); /* Get a buffer */
     1375 		     call hcs_$tty_read (ad.tty_index, addr (p -> input_block.input_buffer), 0, ad.input_buf_len,
     1376 			p -> input_block.data_len, state, code);
     1377 		     call check_error_code;
     1378 		     if code ^= 0 then do;
     1379 			free p -> input_block;
     1380 			return;
     1381 		     end;
     1382 		     if p -> input_block.data_len > 0 then do;
     1383 			ad.last_input_blockp -> input_block.next_blockp = p;
     1384 			ad.last_input_blockp = p;
     1385 		     end;
     1386 		     else free p -> input_block;	/* Free empty buffer */
     1387 		end;
     1388 	     end;
     1389 	     return;
     1390 
     1391 	end hide_away_input;
     1392 
     1393 /* Control entry point */
     1394 
     1395 bisync_control: entry (arg_iocbp, arg_order, arg_info_ptr, arg_code);
     1396 
     1397 	iocbp = arg_iocbp -> iocb.actual_iocb_ptr;
     1398 	adp = iocbp -> iocb.attach_data_ptr;
     1399 	info_ptr = arg_info_ptr;
     1400 	arg_code, code = 0;
     1401 	order = arg_order;
     1402 
     1403 	i = 0;					/* In case order is resetread, resetwrite, or abort */
     1404 	if order = "resetread" then do;
     1405 	     i = 1;
     1406 	     call internal_resetread;
     1407 	end;
     1408 	else if order = "resetwrite" then do;
     1409 	     i = 2;
     1410 	     ad.output_buf_used = 0;
     1411 	     ad.output_buf_left = ad.output_buf_len;
     1412 	end;
     1413 	else if order = "abort" then do;
     1414 	     i = 3;
     1415 	     call internal_resetread;
     1416 	     ad.output_buf_used = 0;
     1417 	     ad.output_buf_left = ad.output_buf_len;
     1418 	end;
     1419 	if i ^= 0 then call hcs_$tty_abort (ad.tty_index, (i), state, code);
     1420 
     1421 	else if order = "event_info" then do;
     1422 	     event_info_channel = ad.channel;
     1423 	     code = 0;
     1424 	end;
     1425 
     1426 	else if order = "read_status" then do;		/* See if input available */
     1427 	     code = 0;
     1428 	     rw_status.channel = ad.channel;
     1429 	     if ad.scanned_data_len > 0 then rw_status.flag = "1"b; /* There is and I already have it */
     1430 	     else if ad.saved_eot then rw_status.flag = "1"b;
     1431 	     else do;
     1432 retry_read_status:	eot_found, etx_found, stx_found, soh_found, etb_found = "0"b;
     1433 		call scan_more_data_noblock;		/* Try scanning some more input */
     1434 		if ad.scanned_data_len > 0 then rw_status.flag = "1"b; /* That worked */
     1435 		else if eot_found then do;		/* This is data too */
     1436 		     ad.saved_eot = "1"b;		/* But save it for the get chars call */
     1437 		     rw_status.flag = "1"b;
     1438 		end;
     1439 		else if etx_found then go to retry_read_status; /* Ignore extra etx */
     1440 		else rw_status.flag = "0"b;		/* No data anywhere */
     1441 		code = 0;
     1442 	     end;
     1443 	end;
     1444 
     1445 	else if order = "set_bid_limit" then do;
     1446 	     ad.bid_limit = order_val;
     1447 	     call line_control (SET_BID_LIMIT, ad.bid_limit);
     1448 	end;
     1449 
     1450 	else if order = "get_bid_limit" then do;
     1451 	     order_val = ad.bid_limit;
     1452 	     code = 0;
     1453 	end;
     1454 
     1455 	else if order = "set_bsc_modes" then do;
     1456 	     ad.transparent = bsc_modes.transparent;
     1457 	     ad.ascii = ^bsc_modes.ebcdic;
     1458 	     call line_control (CONFIGURE, bin (ad.transparent || ^ad.ascii));
     1459 	     call set_control_chars;
     1460 	end;
     1461 
     1462 	else if order = "get_bsc_modes" then do;
     1463 	     bsc_modes.transparent = ad.transparent;
     1464 	     bsc_modes.ebcdic = ^ad.ascii;
     1465 	     code = 0;
     1466 	end;
     1467 
     1468 	else if order = "runout" then do;
     1469 	     code = 0;
     1470 
     1471 	     if ad.output_etb_mode then do;		/* calls bisync_$bisync_put_chars which already */
     1472 		ad.use_etb = "0"b;			/* knows all the right things to do */
     1473 						/* to transmit an empty record with an ETX */
     1474 		call iocbp -> iocb.put_chars (iocbp, addr (empty_buffer), 0, code);
     1475 		ad.use_etb = "1"b;
     1476 	     end;
     1477 
     1478 	     if ad.multi_record & code = 0 then
     1479 		if ad.output_mode then
     1480 		     if ad.output_buf_used > 0 then
     1481 			call transmit_block;	/* Dump last block */
     1482 	     if ad.write_error_code ^= 0 & code = 0 then do;
     1483 		code = ad.write_error_code;
     1484 		ad.write_error_code = 0;
     1485 	     end;
     1486 
     1487 	end;					/* if order = "runout" */
     1488 
     1489 	else if order = "set_size" then do;
     1490 	     if order_val > ad.max_block_len then code = error_table_$buffer_big;
     1491 	     else do;
     1492 		ad.block_len = order_val;
     1493 		if ad.output_mode then		/* Maybe doing output */
     1494 		     ad.output_buf_left = max (0, ad.block_len - ad.output_buf_used);
     1495 		code = 0;
     1496 	     end;
     1497 	end;
     1498 
     1499 	else if order = "get_size" then do;
     1500 	     order_val = ad.block_len;
     1501 	     code = 0;
     1502 	end;
     1503 
     1504 	else if order = "set_multi_record_mode" then do;
     1505 	     code = 0;
     1506 	     if info_ptr = null then do;
     1507 		ad.multi_record = "1"b;
     1508 		ad.multi_record_limit = 0;
     1509 	     end;
     1510 	     else do;
     1511 		ad.multi_record_limit = max (0, order_val);
     1512 		ad.multi_record = (ad.multi_record_limit ^= 1);
     1513 	     end;
     1514 	end;
     1515 
     1516 	else if order = "get_multi_record_mode" then do;
     1517 	     if ^ad.multi_record then order_val = 1;
     1518 	     else order_val = ad.multi_record_limit;
     1519 	     code = 0;
     1520 	end;
     1521 
     1522 	else if order = "hangup_proc" then do;
     1523 	     call ipc_$decl_ev_call_chn (ad.attach_channel, hangup_proc.entry_var, hangup_proc.data_ptr,
     1524 		hangup_proc.prior, code);
     1525 	     if code ^= 0 then call convert_ipc_code_ (code);
     1526 	     if code = 0 then ad.attach_channel_is_call = "1"b;
     1527 	end;
     1528 
     1529 	else if order = "send_nontransparent_msg" then do;
     1530 	     call iox_$control (iocbp, "runout", null, code);
     1531 	     if code = 0 then do;
     1532 		ad.temp_nontransparent = "1"b;
     1533 		call iox_$put_chars (iocbp, addr (order_msg.data), length (order_msg.data), code);
     1534 		ad.temp_nontransparent = "0"b;
     1535 		if code = 0 then call iox_$control (iocbp, "runout", null, code);
     1536 	     end;
     1537 	end;
     1538 
     1539 	else if order = "end_write_mode" then call end_write_mode;
     1540 
     1541 	else if order = "set_polling_addr" then do;
     1542 	     if info_ptr = null then do;
     1543 		valchar.data_len = 0;
     1544 		valchar.data = "";
     1545 	     end;
     1546 	     else do;
     1547 		valchar.data_len = min (order_msg.data_len, length (valchar.data));
     1548 		valchar.data = order_msg.data;
     1549 	     end;
     1550 	     call line_control_val_set (SET_POLLING_ADDR);
     1551 	end;
     1552 
     1553 	else if order = "poll" then call line_control (START_POLL, 0);
     1554 
     1555 	else if order = "get_chars" then go to get_chars_order;
     1556 
     1557 	else if order = "io_call" then call bisync_io_call;
     1558 
     1559 	else do;
     1560 	     call hcs_$tty_order (ad.tty_index, order, info_ptr, state, code);
     1561 	     call check_error_code;
     1562 	     if order = "write_status" then do;
     1563 		rw_status.channel = ad.channel;
     1564 		if ad.write_error_code ^= 0 then do;
     1565 		     code = ad.write_error_code;
     1566 		     ad.write_error_code = 0;
     1567 		end;
     1568 	     end;
     1569 	end;
     1570 
     1571 control_return:
     1572 	arg_code = code;
     1573 	return;
     1574 
     1575 /* Internal procedure to do resetread on internal I/O module buffers */
     1576 
     1577 internal_resetread: proc;
     1578 
     1579 dcl  p ptr;
     1580 
     1581 	     ad.input_state = 1;
     1582 	     ad.scanned_data_len, ad.unscanned_data_len = 0;
     1583 	     ad.saved_eot = "0"b;
     1584 
     1585 	     do while (input_block.next_blockp ^= null);
     1586 		p = input_block.next_blockp;
     1587 		free input_block;
     1588 		ad.input_blockp = p;
     1589 		ad.input_buf_ptr = addr (input_block.input_buffer);
     1590 	     end;
     1591 	     return;
     1592 
     1593 	end internal_resetread;
     1594 
     1595 /* Procedure to implement the end_write_mode order */
     1596 /* This order waits for the fnp to transmit the last output block */
     1597 
     1598 end_write_mode: proc;
     1599 
     1600 dcl 1 write_status aligned automatic like rw_status;
     1601 
     1602 	     if ^ad.output_mode then do;
     1603 		code = error_table_$no_operation;
     1604 		return;
     1605 	     end;
     1606 
     1607 	     if ad.multi_record & (ad.output_buf_used) > 0 then do; /* Write last block */
     1608 		call transmit_block;
     1609 		if code ^= 0 then return;
     1610 		if ad.write_error_code ^= 0 then do;
     1611 end_write_mode_err:
     1612 		     code = ad.write_error_code;
     1613 		     ad.write_error_code = 0;
     1614 		     return;
     1615 		end;
     1616 	     end;
     1617 	     substr (output_buffer, 1, 1) = ad.eot;	/* EOT to end transmission */
     1618 	     ad.output_buf_used = 1;
     1619 	     call transmit_block;
     1620 	     if code ^= 0 then return;
     1621 	     if ad.write_error_code ^= 0 then go to end_write_mode_err;
     1622 
     1623 /* Get the data out of ring 0 */
     1624 
     1625 	     write_status.flag = "1"b;
     1626 	     do while (write_status.flag);
     1627 		call hcs_$tty_order (ad.tty_index, "write_status", addr (write_status), state, code);
     1628 		call check_error_code;
     1629 		if code ^= 0 then return;
     1630 		if ad.write_error_code ^= 0 then go to end_write_mode_err;
     1631 		if write_status.flag then do;
     1632 		     call hide_away_input;
     1633 		     if code ^= 0 then return;
     1634 		     if ad.write_error_code ^= 0 then go to end_write_mode_err;
     1635 		     call block (ad.channel, 1);
     1636 		     if code ^= 0 then return;
     1637 		end;
     1638 	     end;
     1639 
     1640 /* Wait 5 seconds for things to settle down */
     1641 
     1642 end_write_mode0:
     1643 	     call set_time (5);
     1644 end_write_mode1:
     1645 	     call block (ad.channel, 2);
     1646 	     if code ^= 0 then return;
     1647 	     if event_info.channel_id ^= ad.timer_channel then do; /* Wakeup on device channel */
     1648 		call hide_away_input;
     1649 		if code ^= 0 then return;
     1650 		if ad.write_error_code ^= 0 then go to end_write_mode_err;
     1651 		go to end_write_mode1;
     1652 	     end;
     1653 
     1654 /* Flush any existing write status */
     1655 
     1656 	     call check_line_status;
     1657 	     if code ^= 0 & code ^= error_table_$no_line_status then return;
     1658 	     ad.fnp_output_pending = "0"b;
     1659 	     ad.fnp_output_reported = "0"b;
     1660 	     if ad.write_error_code ^= 0 then go to end_write_mode_err;
     1661 
     1662 /* See if fnp is done writing */
     1663 
     1664 	     call line_control (REPORT_WRITE_STATUS, 0);
     1665 	     if code ^= 0 then return;
     1666 	     if ad.write_error_code ^= 0 then go to end_write_mode_err;
     1667 	     call set_time (5);
     1668 	     call block (ad.channel, 2);
     1669 	     if code ^= 0 then return;
     1670 	     if event_info.channel_id ^= ad.timer_channel then do;
     1671 		call hide_away_input;
     1672 		if code ^= 0 then return;
     1673 		if ad.write_error_code ^= 0 then go to end_write_mode_err;
     1674 		if ad.fnp_output_reported then do;
     1675 		     if ad.fnp_output_pending then go to end_write_mode1;
     1676 		     else return;
     1677 		end;
     1678 	     end;
     1679 	     go to end_write_mode0;			/* Try all over again */
     1680 
     1681 	end end_write_mode;
     1682 
     1683 /* Subroutine to do the io_call order for bisync_ */
     1684 
     1685 bisync_io_call: proc;
     1686 
     1687 dcl  i fixed bin;
     1688 dcl  p ptr;
     1689 dcl 1 info aligned,					/* For info order */
     1690     2 id char (4),
     1691     2 baud_rate fixed bin (17) unal,
     1692     2 reserved bit (54) unal,
     1693     2 type fixed bin;
     1694 
     1695 dcl 1 auto_rw_status aligned like rw_status automatic;
     1696 dcl  event_info_channel fixed bin (71);
     1697 dcl 1 auto_bsc_modes like bsc_modes aligned automatic;
     1698 dcl 1 order_msg aligned based (p),
     1699     2 data_len fixed bin,
     1700     2 data char (i);
     1701 dcl  get_chars_data char (i) based;
     1702 dcl 1 auto_get_chars_info like get_chars_info aligned automatic;
     1703 
     1704 	     io_call_infop = info_ptr;
     1705 	     order = io_call_info.order_name;
     1706 	     caller = io_call_info.caller_name;
     1707 	     rpt = io_call_info.report;
     1708 	     err = io_call_info.error;
     1709 
     1710 	     if order = "info" then do;
     1711 		call iox_$control (iocbp, "info", addr (info), code);
     1712 		if code = 0 then
     1713 		     call rpt ("^a: Terminal id=""^a"", baud_rate=^d, type=^d.",
     1714 		     caller, info.id, info.baud_rate, info.type);
     1715 	     end;
     1716 
     1717 	     else if order = "read_status" then do;
     1718 		info_ptr = addr (auto_rw_status);
     1719 		call iox_$control (iocbp, "read_status", info_ptr, code);
     1720 		if code = 0 then
     1721 		     call rpt ("^a: Event channel=^.3b, input is ^[^;not ^]available.",
     1722 		     caller, unspec (rw_status.channel), rw_status.flag);
     1723 	     end;
     1724 
     1725 	     else if order = "write_status" then do;
     1726 		info_ptr = addr (auto_rw_status);
     1727 		call iox_$control (iocbp, "write_status", info_ptr, code);
     1728 		if code = 0 then
     1729 		     call rpt ("^a: Event channel=^.3b, output is ^[^;not ^]pending.",
     1730 		     caller, unspec (rw_status.channel), rw_status.flag);
     1731 	     end;
     1732 
     1733 	     else if order = "event_info" then do;
     1734 		call iox_$control (iocbp, "event_info", addr (event_info_channel), code);
     1735 		if code = 0 then call rpt ("^a: Event channel=^.3b",
     1736 		     caller, unspec (event_info_channel));
     1737 	     end;
     1738 
     1739 	     else if order = "set_bid_limit" then do;
     1740 		i = cv_io_call_dec_arg (1);
     1741 		call iox_$control (iocbp, "set_bid_limit", addr (i), code);
     1742 	     end;
     1743 
     1744 	     else if order = "get_bid_limit" then do;
     1745 		call iox_$control (iocbp, "get_bid_limit", addr (i), code);
     1746 		if code = 0 then call rpt ("^a: Bisync bid limit is ^d retries.",
     1747 		     caller, i);
     1748 	     end;
     1749 
     1750 	     else if order = "set_bsc_modes" then do;
     1751 		auto_bsc_modes.transparent = "1"b;
     1752 		auto_bsc_modes.ebcdic = "0"b;
     1753 		auto_bsc_modes.fill = "0"b;
     1754 		do i = 1 to io_call_info.nargs;
     1755 		     if io_call_info.args (i) = "ascii" then auto_bsc_modes.ebcdic = "0"b;
     1756 		     else if io_call_info.args (i) = "ebcdic" then auto_bsc_modes.ebcdic = "1"b;
     1757 		     else if io_call_info.args (i) = "transparent" then auto_bsc_modes.transparent = "1"b;
     1758 		     else if io_call_info.args (i) = "nontransparent" then auto_bsc_modes.transparent = "0"b;
     1759 		     else do;
     1760 			call err (error_table_$badopt, caller,
     1761 			     "Invalid bisync mode: ^a", io_call_info.args (i));
     1762 			code = 0;
     1763 			return;
     1764 		     end;
     1765 		end;
     1766 		call iox_$control (iocbp, "set_bsc_modes", addr (auto_bsc_modes), code);
     1767 	     end;
     1768 
     1769 	     else if order = "get_bsc_modes" then do;
     1770 		call iox_$control (iocbp, "get_bsc_modes", addr (auto_bsc_modes), code);
     1771 		if code = 0 then
     1772 		     call rpt ("^a: Current bisync mode is ^[non^]transparent ^[ebcdic^;ascii^].",
     1773 		     caller, ^auto_bsc_modes.transparent, auto_bsc_modes.ebcdic);
     1774 	     end;
     1775 
     1776 	     else if order = "set_size" then do;
     1777 		i = cv_io_call_dec_arg (1);
     1778 		call iox_$control (iocbp, "set_size", addr (i), code);
     1779 	     end;
     1780 
     1781 	     else if order = "get_size" then do;
     1782 		call iox_$control (iocbp, "get_size", addr (i), code);
     1783 		if code = 0 then call rpt ("^a: Bisync block size is ^d characters.",
     1784 		     caller, i);
     1785 	     end;
     1786 
     1787 	     else if order = "set_multi_record_mode" then do;
     1788 		if io_call_info.nargs = 0 then call iox_$control (iocbp, "set_multi_record_mode", null, code);
     1789 		else do;
     1790 		     i = cv_io_call_dec_arg (1);
     1791 		     call iox_$control (iocbp, "set_multi_record_mode", addr (i), code);
     1792 		end;
     1793 	     end;
     1794 
     1795 	     else if order = "get_multi_record_mode" then do;
     1796 		call iox_$control (iocbp, "get_multi_record_mode", addr (i), code);
     1797 		if code = 0 then call rpt ("^a: Bisync blocks contain ^[^d^;unlimited^s^] record^[s^].",
     1798 		     caller, (i ^= 0), i, (i ^= 1));
     1799 	     end;
     1800 
     1801 	     else if order = "send_nontransparent_msg" then do;
     1802 		if io_call_info.nargs = 0 then code = error_table_$noarg;
     1803 		else do;
     1804 		     i = length (io_call_info.args (1));
     1805 		     allocate order_msg in (work_area);
     1806 		     order_msg.data_len = i;
     1807 		     order_msg.data = io_call_info.args (1);
     1808 		     call iox_$control (iocbp, "send_nontransparent_msg", p, code);
     1809 		     free order_msg;
     1810 		end;
     1811 	     end;
     1812 
     1813 	     else if order = "set_polling_addr" then do;
     1814 		if io_call_info.nargs = 0 then call iox_$control (iocbp, "set_polling_addr", null, code);
     1815 		else do;
     1816 		     i = length (io_call_info.args (1));
     1817 		     allocate order_msg in (work_area);
     1818 		     order_msg.data_len = i;
     1819 		     order_msg.data = io_call_info.args (1);
     1820 		     call iox_$control (iocbp, "set_polling_addr", p, code);
     1821 		     free order_msg;
     1822 		end;
     1823 	     end;
     1824 
     1825 	     else if order = "get_chars" then do;
     1826 		i = cv_io_call_dec_arg (1);		/* Get buffer size */
     1827 		info_ptr = addr (auto_get_chars_info);
     1828 		allocate get_chars_data in (work_area) set (get_chars_info.buf_ptr);
     1829 		allocate get_chars_data in (work_area) set (get_chars_info.hbuf_ptr);
     1830 		get_chars_info.buf_len, get_chars_info.hbuf_len = i;
     1831 		call iox_$control (iocbp, "get_chars", addr (auto_get_chars_info), code);
     1832 		if code = 0 then do;		/* It worked */
     1833 		     if get_chars_info.eot then call rpt ("^a: EOT read.", caller);
     1834 		     if get_chars_info.soh then call rpt ("^a: Header: ^a", caller,
     1835 			substr (get_chars_info.hbuf_ptr -> get_chars_data, 1, get_chars_info.header_len));
     1836 		     if get_chars_info.data_len > 0 then call rpt ("^a: Data^[(ETX)^]^[(ETB)^]: ^a", caller,
     1837 			get_chars_info.etx, get_chars_info.etb,
     1838 			substr (get_chars_info.buf_ptr -> get_chars_data, 1, get_chars_info.data_len));
     1839 		end;
     1840 		free get_chars_info.buf_ptr -> get_chars_data;
     1841 		free get_chars_info.hbuf_ptr -> get_chars_data;
     1842 	     end;
     1843 
     1844 	     else call iox_$control (iocbp, (order), null, code);
     1845 
     1846 	     return;
     1847 
     1848 	end bisync_io_call;
     1849 
     1850 
     1851 /* Procedure used to convert a decimal arg during an io_call order */
     1852 
     1853 cv_io_call_dec_arg: proc (n) returns (fixed bin);
     1854 
     1855 dcl  n fixed bin;
     1856 
     1857 	     if n > io_call_info.nargs then do;
     1858 		code = error_table_$noarg;
     1859 		go to control_return;
     1860 	     end;
     1861 
     1862 	     on conversion go to cv_io_call_dec_arg_err;
     1863 	     return (bin (io_call_info.args (n)));
     1864 
     1865 cv_io_call_dec_arg_err:
     1866 	     call err (0, caller, "Invalid decimal argument: ^a", io_call_info.args (n));
     1867 	     code = 0;
     1868 	     go to control_return;
     1869 
     1870 	end cv_io_call_dec_arg;
     1871 
     1872 /* Position entry point */
     1873 
     1874 bisync_position: entry (arg_iocbp, arg_pos_type, arg_pos_value, arg_code);
     1875 
     1876 	iocbp = arg_iocbp -> iocb.actual_iocb_ptr;
     1877 	adp = iocbp -> iocb.attach_data_ptr;
     1878 	pos_type = arg_pos_type;
     1879 	pos_value = arg_pos_value;
     1880 	arg_code, code = 0;
     1881 
     1882 	if ((pos_type ^= 0) & (pos_type ^= 3)) | (pos_value < 0) then do; /* Bad args */
     1883 	     arg_code = error_table_$bad_arg;
     1884 	     return;
     1885 	end;
     1886 
     1887 	if pos_type = 3 then do while (pos_value > 0);	/* Skip over chars */
     1888 	     i = min (pos_value, ad.scanned_data_len);
     1889 	     if i > 0 then do;			/* Some available to skip */
     1890 		call advance_scanned_data (i);
     1891 		pos_value = pos_value - i;
     1892 	     end;
     1893 	     else do;
     1894 		call scan_more_data;		/* Need more chars */
     1895 		if code ^= 0 then do;
     1896 		     arg_code = code;
     1897 		     return;
     1898 		end;
     1899 	     end;
     1900 	end;
     1901 
     1902 	else do while (pos_value > 0);		/* Skip over lines */
     1903 	     if ad.scanned_data_len > 0 then do;	/* Have data to look at */
     1904 		i = index (scanned_data, nl);		/* Find end of line */
     1905 		if i = 0 then ad.scanned_data_len = 0;	/* No nl, throw data away */
     1906 		else do;
     1907 		     pos_value = pos_value - 1;
     1908 		     call advance_scanned_data (i);	/* Skip data to new-line */
     1909 		end;
     1910 	     end;
     1911 	     else do;				/* Need more data */
     1912 		call scan_more_data;
     1913 		if code ^= 0 then do;
     1914 		     arg_code = code;
     1915 		     return;
     1916 		end;
     1917 	     end;
     1918 	end;
     1919 
     1920 	arg_code = 0;
     1921 
     1922 	return;
     1923 
     1924 /* Procedure to do a line control order */
     1925 
     1926 line_control: proc (op, val1);
     1927 
     1928 dcl (op, val1, val2) fixed bin;
     1929 
     1930 	     line_ctl.val = 0;
     1931 line_control_join:
     1932 	     line_ctl.val (1) = val1;
     1933 
     1934 line_control_val_set: entry (op);
     1935 
     1936 	     line_ctl.op = op;
     1937 	     call hcs_$tty_order (ad.tty_index, "line_control", addr (line_ctl), state, code);
     1938 	     call check_error_code;
     1939 	     return;
     1940 
     1941 line_control2: entry (op, val1, val2);
     1942 
     1943 	     line_ctl.val = 0;
     1944 	     line_ctl.val (2) = val2;
     1945 	     go to line_control_join;
     1946 
     1947 	end line_control;
     1948 
     1949 /* Procedure for checking error codes and fetching line_status if required */
     1950 
     1951 check_error_code: proc;
     1952 
     1953 	     if code = 0 then return;
     1954 	     if code ^= error_table_$line_status_pending then return;
     1955 	     call check_line_status;
     1956 	     return;
     1957 
     1958 	end check_error_code;
     1959 
     1960 check_line_status: proc;
     1961 
     1962 	     call hcs_$tty_order (ad.tty_index, "line_status", addr (line_stat), state, code);
     1963 	     if code ^= 0 then return;
     1964 	     if line_stat.op = BID_FAILED then code = error_table_$bisync_bid_fail;
     1965 	     else if line_stat.op = BAD_BLOCK then code = error_table_$bisync_block_bad;
     1966 	     else if line_stat.op = REVERSE_INTERRUPT then code = error_table_$bisync_reverse_interrupt;
     1967 	     else if line_stat.op = TOO_MANY_NAKS then code = error_table_$device_parity;
     1968 	     else if line_stat.op = FNP_WRITE_STATUS then do;
     1969 		ad.fnp_output_reported = "1"b;
     1970 		ad.fnp_output_pending = (line_stat.val (1) = 1);
     1971 	     end;
     1972 
     1973 	     if code ^= 0 then do;
     1974 		ad.write_error_code = code;		/* Save for later */
     1975 		code = 0;
     1976 	     end;
     1977 	     return;
     1978 
     1979 	end check_line_status;
     1980 
     1981 /* Set bisync control characters for current mode */
     1982 
     1983 set_control_chars: proc;
     1984 
     1985 	     unspec (ad.stx) = "002"b3;
     1986 	     unspec (ad.etx) = "003"b3;
     1987 	     unspec (ad.dle) = "020"b3;
     1988 	     unspec (ad.itb) = "037"b3;
     1989 	     unspec (ad.soh) = "001"b3;
     1990 	     if ad.ascii then do;
     1991 		unspec (ad.etb) = "027"b3;
     1992 		unspec (ad.eot) = "004"b3;
     1993 	     end;
     1994 	     else do;
     1995 		unspec (ad.etb) = "046"b3;
     1996 		unspec (ad.eot) = "067"b3;
     1997 	     end;
     1998 	     return;
     1999 
     2000 	end set_control_chars;
     2001 
     2002 /* Interal procedure to block */
     2003 
     2004 block:	proc (chan_id, nchan);
     2005 
     2006 dcl  chan_id fixed bin(71);                                 /* Event channel to block on */
     2007 dcl  nchan fixed bin;				/* Number of channels to block on */
     2008 
     2009 	     ad.channel_id = chan_id;
     2010                ad.nchan = nchan;
     2011 	     call ipc_$block (addr (ad.wait_list), addr (event_info), code);
     2012 	     if code ^= 0 then call convert_ipc_code_ (code);
     2013 	     return;
     2014 
     2015 	end block;
     2016 
     2017 /* Set a timer */
     2018 
     2019 set_time:	proc (n_sec);
     2020 
     2021 dcl  n_sec fixed bin;
     2022 
     2023 	     call timer_manager_$reset_alarm_wakeup (ad.timer_channel);
     2024 	     call ipc_$drain_chn (ad.timer_channel, code);
     2025 	     call timer_manager_$alarm_wakeup ((n_sec), "11"b, ad.timer_channel);
     2026 	     return;
     2027 
     2028 	end set_time;
     2029 
     2030 /* Builtin function substraddr until it is real */
     2031 
     2032 substraddr: proc (c, n) returns (ptr);
     2033 
     2034 dcl  c char (*);
     2035 dcl  n fixed bin (21);
     2036 dcl  ca (n) char (1) based (addr (c));
     2037 
     2038 	     return (addr (ca (n)));
     2039 
     2040 	end substraddr;
     2041 
     2042 /**/
     2043 
  1     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  1     2 
  1     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  1     4 
  1     5 dcl  area_infop ptr;
  1     6 
  1     7 dcl 1 area_info aligned based (area_infop),
  1     8     2 version fixed bin,				/* version number for this structure is 1 */
  1     9     2 control aligned like area_control,		/* control bits for the area */
  1    10     2 owner char (32) unal,				/* creator of the area */
  1    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  1    12     2 size fixed bin (18),				/* size of the area in words */
  1    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  1    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  1    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  1    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  1    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  1    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  1    19 
  1    20 dcl 1 area_control aligned based,
  1    21     2 extend bit (1) unal,				/* says area is extensible */
  1    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  1    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  1    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  1    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  1    26     2 system bit (1) unal,				/* says area is managed by system */
  1    27     2 pad bit (30) unal;
  1    28 
  1    29 /* END INCLUDE FILE area_info.incl.pl1 */
     2044 
     2045 
  2     1 /* BEGIN INCLUDE FILE .... bisync_line_data.incl.pl1 */
  2     2 /* Written:  October 1977 by Larry Johnson */
  2     3 /* Modified: November 1979 by Larry Johnson and Gary Palter for HASP */
  2     4 /* Modified: February 1984 by G. Palter for HASP system wait-a-bit changes */
  2     5 
  2     6 /* Structures and codes for doing line_control and line_status operations on bisync lines */
  2     7 
  2     8 /* For line_control order */
  2     9 
  2    10 dcl 1 line_ctl aligned,
  2    11     2 op fixed binary (17) unaligned,			/* indicates action being performed */
  2    12     2 val (3) fixed binary (17) unaligned;		/* optional arguments with some ops */
  2    13 
  2    14 dcl 1 valchar based (addr (line_ctl.val (1))),		/* character overlay of line_ctl.val */
  2    15     2 data_len fixed binary (9) unaligned unsigned,
  2    16     2 data character (5) unaligned;
  2    17 
  2    18 
  2    19 /* Values for line_ctl.op */
  2    20 
  2    21 dcl (SET_BID_LIMIT		     initial (1),
  2    22      ACCEPT_BID		     initial (2),
  2    23      CONFIGURE		     initial (3),		/* val(1): 0 = non-transparent ASCII, 1 = not-tranparent EBCDIC,
  2    24*							 2 = transparent ASCII, 3 = transparent EBCDIC */
  2    25      SET_TTD_PARAMS		     initial (4),		/* val(1): ttd_time;  val(2): ttd_limit */
  2    26      REPORT_WRITE_STATUS	     initial (5),		/* Request FNP to report on output buffers */
  2    27      SET_3270_MODE		     initial (6),
  2    28      SET_POLLING_ADDR	     initial (7),
  2    29      START_POLL		     initial (8),
  2    30      SET_SELECT_ADDR	     initial (9),
  2    31      STOP_AUTO_POLL		     initial (10),
  2    32      SET_MASTER_SLAVE_MODE	     initial (11),		/* val(1): 0 = slave (host), 1 = master (workstation) */
  2    33      SET_HASP_MODE		     initial (12),
  2    34      SET_NAK_LIMIT		     initial (13),		/* val(1): maximum # of NAKs allowed in a row */
  2    35      SET_HASP_TIMERS	     initial (14))		/* val(1): initial connect timeout;  val(2): receive timeout;
  2    36*						   val(3): transmit timeout */
  2    37 	fixed binary static options (constant);
  2    38 
  2    39 
  2    40 /* For line status order */
  2    41 
  2    42 dcl 1 line_stat aligned,
  2    43     2 op fixed binary (17) unaligned,			/* contains reason for status */
  2    44     2 val (3) fixed binary (17) unaligned;
  2    45 
  2    46 
  2    47 /* Values for line_stat.op */
  2    48 
  2    49 dcl (BID_FAILED		     initial (1),
  2    50      BAD_BLOCK		     initial (2),
  2    51      REVERSE_INTERRUPT	     initial (3),
  2    52      TOO_MANY_NAKS		     initial (4),
  2    53      FNP_WRITE_STATUS	     initial (5),
  2    54      IBM3270_WRITE_COMPLETE	     initial (6),
  2    55      IBM3270_WACK_MESSAGE	     initial (7),
  2    56      IBM3270_WRITE_EOT	     initial (8),
  2    57      IBM3270_WRITE_ABORT	     initial (9),
  2    58      IBM3270_SELECT_FAILED	     initial (10),
  2    59      IBM3270_WACK_SELECT	     initial (11),
  2    60      IBM3270_NAK_OUTPUT	     initial (12),
  2    61      HASP_INIT_COMPLETE	     initial (13),
  2    62      HASP_FOREIGN_SWAB_RESET	     initial (14))
  2    63 	fixed binary static options (constant);
  2    64 	
  2    65 /* END INCLUDE FILE ..... bisync_line_data.incl.pl1 */
     2046 
     2047 
  3     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  3     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  3     3*      version number to IOX2. */
  3     4 /* format: style2 */
  3     5 
  3     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  3     7 	     2 version	      character (4) aligned,	/* IOX2 */
  3     8 	     2 name	      char (32),		/* I/O name of this block. */
  3     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  3    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  3    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  3    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  3    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  3    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  3    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  3    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  3    17 						/* open(p,mode,not_used,s) */
  3    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  3    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  3    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  3    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  3    24 						/* put_chars(p,bufptr,buflen,s) */
  3    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  3    26 						/* modes(p,newmode,oldmode,s) */
  3    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  3    28 						/* position(p,u1,u2,s) */
  3    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  3    30 						/* control(p,order,infptr,s) */
  3    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  3    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  3    34 						/* write_record(p,bufptr,buflen,s) */
  3    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  3    36 						/* rewrite_record(p,bufptr,buflen,s) */
  3    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  3    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  3    39 						/* seek_key(p,key,len,s) */
  3    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  3    41 						/* read_key(p,key,len,s) */
  3    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  3    43 						/* read_length(p,len,s) */
  3    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  3    45 						/* open_file(p,mode,desc,not_used,s) */
  3    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  3    47 						/* close_file(p,desc,s) */
  3    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  3    49 						/* detach(p,desc,s) */
  3    50 
  3    51      declare iox_$iocb_version_sentinel
  3    52 			      character (4) aligned external static;
  3    53 
  3    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
     2048 
     2049 
  4     1 /* Begin include file ..... iox_modes.incl.pl1 */
  4     2 
  4     3 /* Written by C. D. Tavares, 03/17/75 */
  4     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  4     5 
  4     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  4     7     ("stream_input", "stream_output", "stream_input_output",
  4     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  4     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  4    10      "direct_input", "direct_output", "direct_update");
  4    11 
  4    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  4    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  4    14 
  4    15 dcl (Stream_input initial (1),
  4    16      Stream_output initial (2),
  4    17      Stream_input_output initial (3),
  4    18      Sequential_input initial (4),
  4    19      Sequential_output initial (5),
  4    20      Sequential_input_output initial (6),
  4    21      Sequential_update initial (7),
  4    22      Keyed_sequential_input initial (8),
  4    23      Keyed_sequential_output initial (9),
  4    24      Keyed_sequential_update initial (10),
  4    25      Direct_input initial (11),
  4    26      Direct_output initial (12),
  4    27      Direct_update initial (13)) fixed bin int static options (constant);
  4    28 
  4    29 /* End include file ..... iox_modes.incl.pl1 */
     2050 
     2051 
  5     1 /* Begin include file ..... io_call_info.incl.pl1 */
  5     2 
  5     3 /* This include file defines the info_structure used by an I/O module to perform an "io_call" order
  5     4*   on behalf of the io_call command. */
  5     5 /* Coded April 1976 by Larry Johnson */
  5     6 /* Changed June 1977 by Larry Johnson for "io_call_af" order */
  5     7 
  5     8      dcl	   io_call_infop	      ptr;
  5     9 
  5    10      dcl	   1 io_call_info	      aligned based (io_call_infop),
  5    11 	     2 version	      fixed bin,
  5    12 	     2 caller_name	      char (32),		/* Caller name for error messages */
  5    13 	     2 order_name	      char (32),		/* Actual name of the order to be performed */
  5    14 	     2 report	      entry variable options (variable),
  5    15 						/* Entry to ioa_ like procedure to report results */
  5    16 	     2 error	      entry variable options (variable),
  5    17 						/* Entry to com_err_ like procedure to report results */
  5    18 	     2 af_returnp	      ptr,		/* Pointer to return string if "io_call_af"  order */
  5    19 	     2 af_returnl	      fixed bin,		/* Length of string */
  5    20 	     2 fill	      (5) bit (36) aligned,
  5    21 	     2 nargs	      fixed bin,		/* Number of additional command arguments provided */
  5    22 	     2 max_arglen	      fixed bin,		/* Length of longest argument (used to define array) */
  5    23 	     2 args	      (0 refer (io_call_info.nargs)) char (0 refer (io_call_info.max_arglen)) varying;
  5    24 
  5    25      dcl	   io_call_af_ret	      char (io_call_info.af_returnl) based (io_call_info.af_returnp) varying;
  5    26 						/* Return string for active function */
  5    27 
  5    28 /* End include file ..... io_call_info.incl.pl1 */
     2052 
     2053 
     2054      end bisync_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    06/22/89  0723.3  bisync_.pl1                       >spec>install>1061>bisync_.pl1
2044         1    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
2046         2    04/23/84  0745.1  bisync_line_data.incl.pl1         >ldd>include>bisync_line_data.incl.pl1
2048         3    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
2050         4    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
2052         5    07/19/79  1547.1  io_call_info.incl.pl1             >ldd>include>io_call_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACCEPT_BID                             constant        fixed bin(17,0)          initial dcl 2-21 set ref 631*
BAD_BLOCK                              constant        fixed bin(17,0)          initial dcl 2-49 ref 1965
BID_FAILED                             constant        fixed bin(17,0)          initial dcl 2-49 ref 1964
BISYNC_OVERHEAD                 000134 constant        fixed bin(17,0)          initial dcl 121 ref 645
CONFIGURE                              constant        fixed bin(17,0)          initial dcl 2-21 set ref 502* 1458*
FNP_WRITE_STATUS                       constant        fixed bin(17,0)          initial dcl 2-49 ref 1968
REPORT_WRITE_STATUS                    constant        fixed bin(17,0)          initial dcl 2-21 set ref 1664*
REVERSE_INTERRUPT                      constant        fixed bin(17,0)          initial dcl 2-49 ref 1966
SET_3270_MODE                          constant        fixed bin(17,0)          initial dcl 2-21 set ref 489*
SET_BID_LIMIT                   000232 constant        fixed bin(17,0)          initial dcl 2-21 set ref 500* 1447*
SET_HASP_MODE                   000130 constant        fixed bin(17,0)          initial dcl 2-21 set ref 493*
SET_MASTER_SLAVE_MODE           000131 constant        fixed bin(17,0)          initial dcl 2-21 set ref 496*
SET_POLLING_ADDR                       constant        fixed bin(17,0)          initial dcl 2-21 set ref 1550*
SET_TTD_PARAMS                  000220 constant        fixed bin(17,0)          initial dcl 2-21 set ref 504*
START_POLL                             constant        fixed bin(17,0)          initial dcl 2-21 set ref 1553*
Sequential_output               000166 constant        fixed bin(17,0)          initial dcl 4-15 set ref 461*
Stream_input                           constant        fixed bin(17,0)          initial dcl 4-15 ref 611 626
Stream_input_output                    constant        fixed bin(17,0)          initial dcl 4-15 ref 611 626 642
Stream_output                          constant        fixed bin(17,0)          initial dcl 4-15 ref 611 642
TOO_MANY_NAKS                          constant        fixed bin(17,0)          initial dcl 2-49 ref 1967
actual_iocb_ptr          12            based           pointer                  level 2 dcl 3-6 ref 606 661 693 949 1036 1397 1876
ad                                     based           structure                level 1 dcl 193 set ref 330 331*
addr                                                   builtin function         dcl 167 ref 313 411 411 412 412 481 481 484 484 515
                                                                                  591 591 592 592 599 599 636 652 890 890 1093 1300
                                                                                  1370 1370 1375 1375 1474 1474 1533 1533 1543 1544
                                                                                  1547 1547 1548 1589 1627 1627 1711 1711 1718 1726
                                                                                  1734 1734 1741 1741 1745 1745 1766 1766 1770 1770
                                                                                  1778 1778 1782 1782 1791 1791 1796 1796 1827 1831
                                                                                  1831 1937 1937 1962 1962 2011 2011 2011 2011 2038
                                                                                  2038
adp                             000102 automatic       pointer                  dcl 54 set ref 321* 330* 331 332 340 341 341 342 343
                                                                                  344 345 346 347 348 349 352 353 355 358 361 361
                                                                                  362 362 365 366 366 367 367 368 369 370 371 372
                                                                                  373 374 375 376 377 379 380 381 393 402 403 409
                                                                                  410 415 416 417 421 422 427 428 430 433 440 443
                                                                                  449 449 450 450 451 452 457 459 461 464 465 470
                                                                                  476 476 476 477 478 481 484 484 484 488 492 495
                                                                                  495 496 496 500 502 502 502 502 504 504 509 511
                                                                                  511 512 512 515 516 552 553 553 554 554 555 555
                                                                                  556 556 571* 573 574 575 580 581 581 585 585 586
                                                                                  588 589 591 593 594 595 599 599 608* 616 622 623
                                                                                  633 633 634 634 634 635 635 636 636 636 637 638
                                                                                  639 640 641 645 645 646 646 646 646 647 647 648
                                                                                  652 663* 666 667 667 670 670 670 671 674 674 674
                                                                                  677 677 695* 704 705 707 711 711 712 720 721 722
                                                                                  722 725 741 744 745 746 754 754 754 754 754 756
                                                                                  756 756 756 757 757 757 761 761 762 762 762 762
                                                                                  762 763 763 763 763 764 764 765 765 766 767 767
                                                                                  768 768 768 769 769 771 771 773 773 786 787 788
                                                                                  799 801 807 807 807 807 807 810 810 810 810 811
                                                                                  811 811 811 812 812 813 813 816 818 818 818 818
                                                                                  819 819 819 819 820 820 821 821 829 829 829 830
                                                                                  830 831 831 837 837 837 837 838 838 838 838 838
                                                                                  839 839 839 839 840 840 841 841 842 842 844 844
                                                                                  863 886 890 892 897 900 902 904 911 911 913 913
                                                                                  913 914 914 916 918 918 920 923 928 930 930 931
                                                                                  950* 962 963 975 975 975 985 1037* 1044 1047 1048
                                                                                  1048 1049 1083 1084 1085 1085 1085 1090 1091 1091
                                                                                  1092 1093 1093 1093 1094 1098 1102 1102 1102 1103
                                                                                  1104 1104 1110 1110 1111 1113 1113 1113 1116 1120
                                                                                  1120 1120 1122 1126 1126 1126 1126 1134 1134 1134
                                                                                  1139 1139 1140 1143 1144 1144 1144 1149 1149 1150
                                                                                  1158 1160 1160 1160 1163 1163 1164 1165 1173 1174
                                                                                  1174 1180 1185 1188 1188 1188 1188 1192 1196 1196
                                                                                  1196 1202 1202 1203 1206 1206 1206 1209 1209 1209
                                                                                  1213 1213 1214 1214 1215 1219 1219 1219 1223 1226
                                                                                  1226 1226 1226 1228 1228 1229 1232 1232 1232 1236
                                                                                  1237 1237 1242 1242 1242 1245 1249 1252 1252 1252
                                                                                  1255 1259 1262 1262 1262 1266 1269 1271 1272 1272
                                                                                  1276 1276 1276 1278 1279 1279 1280 1284 1284 1284
                                                                                  1286 1287 1293 1293 1293 1295 1299 1299 1299 1299
                                                                                  1300 1300 1301 1302 1317 1317 1324 1324 1340 1340
                                                                                  1340 1340 1341 1341 1352 1352 1352 1352 1353 1353
                                                                                  1370 1374 1374 1375 1375 1375 1375 1379 1383 1384
                                                                                  1386 1398* 1410 1411 1411 1416 1417 1417 1419 1422
                                                                                  1428 1429 1430 1434 1436 1446 1447 1451 1456 1457
                                                                                  1458 1458 1458 1458 1463 1464 1471 1472 1475 1478
                                                                                  1478 1478 1482 1483 1484 1490 1492 1493 1493 1493
                                                                                  1493 1500 1507 1508 1511 1512 1512 1517 1518 1523
                                                                                  1526 1532 1534 1560 1563 1564 1565 1566 1581 1582
                                                                                  1582 1583 1585 1586 1587 1587 1588 1589 1589 1589
                                                                                  1602 1607 1607 1610 1611 1613 1617 1617 1617 1618
                                                                                  1621 1627 1630 1634 1635 1644 1647 1650 1658 1659
                                                                                  1660 1666 1668 1670 1673 1674 1675 1805 1817 1828
                                                                                  1829 1877* 1888 1903 1904 1904 1905 1937 1962 1969
                                                                                  1970 1974 1985 1986 1987 1988 1989 1990 1991 1992
                                                                                  1995 1996 2009 2010 2011 2011 2023 2024 2025
amt                                    parameter       fixed bin(21,0)          dcl 1350 in procedure "advance_scanned_data" ref
                                                                                  1348 1352 1353
amt                                    parameter       fixed bin(21,0)          dcl 1311 in procedure "move_scanned_data" set ref
                                                                                  1309 1316 1319* 1324 1324 1325 1326* 1327
amt                                    parameter       fixed bin(21,0)          dcl 1338 in procedure "advance_unscanned_data" ref
                                                                                  1336 1340 1341
area_control                           based           structure                level 1 dcl 1-20
area_info                              based           structure                level 1 dcl 1-7
area_info_version_1                    constant        fixed bin(17,0)          initial dcl 1-3 ref 314
area_infop                      000376 automatic       pointer                  dcl 1-5 set ref 313* 314 315 316 317 318 319 320
                                                                                  328* 330 332 558 558
areap                    16            based           pointer                  level 2 dcl 1-7 set ref 320* 330 332 558 558*
arg_buf_len                            parameter       fixed bin(21,0)          dcl 44 ref 947 952 1034 1039
arg_buf_ptr                            parameter       pointer                  dcl 42 ref 947 951 1034 1038
arg_code                               parameter       fixed bin(35,0)          dcl 40 set ref 307 311* 550* 566 569* 604 607* 612*
                                                                                  618* 659 662* 691 694* 700* 705* 727* 947 958*
                                                                                  980* 1034 1041* 1056* 1062* 1395 1400* 1571* 1874
                                                                                  1880* 1883* 1896* 1914* 1920*
arg_data_len                           parameter       fixed bin(21,0)          dcl 45 set ref 691 697 947 953* 997* 1034 1040*
                                                                                  1064*
arg_data_ptr                           parameter       pointer                  dcl 43 ref 691 696
arg_info_ptr                           parameter       pointer                  dcl 49 ref 1395 1399
arg_iocbp                              parameter       pointer                  dcl 37 ref 307 309 566 568 604 606 659 661 691 693
                                                                                  947 949 1034 1036 1395 1397 1874 1876
arg_mode                               parameter       fixed bin(17,0)          dcl 41 ref 604 610
arg_option                             parameter       varying char             array dcl 38 ref 307 336 340 351 352 353 354 357 360
                                                                                  362 365 366 367 368 369 370 371 372 373 374 375
                                                                                  376 377 378 381 381 385 387 391 393 396 510 512
                                                                                  529 531 534 538
arg_order                              parameter       char                     packed unaligned dcl 48 ref 1395 1401
arg_pos_type                           parameter       fixed bin(17,0)          dcl 46 ref 1874 1878
arg_pos_value                          parameter       fixed bin(21,0)          dcl 47 ref 1874 1879
arg_sw                                 parameter       bit(1)                   packed unaligned dcl 39 ref 307 310 604
args                     44            based           varying char             array level 2 dcl 5-10 set ref 1755 1756 1757 1758
                                                                                  1760* 1804 1807 1816 1819 1863 1865*
ascii                   137            based           bit(1)                   level 2 dcl 193 set ref 343* 355* 358* 502 502 741
                                                                                  766 1139 1149 1163 1202 1228 1457* 1458 1458 1464
                                                                                  1990
attach_channel          122            based           fixed bin(71,0)          level 2 dcl 193 set ref 403* 409 416* 556 556* 580
                                                                                  581* 588 595* 1523*
attach_channel_is_call
                        140            based           bit(1)                   level 2 dcl 193 set ref 581 1526*
attach_data_ptr          16            based           pointer                  level 2 dcl 3-6 set ref 516* 571 608 663 695 950
                                                                                  1037 1398 1877
attach_descrip_ptr       14            based           pointer                  level 2 dcl 3-6 set ref 323 515* 596*
attach_description        4            based           varying char(256)        level 2 dcl 193 set ref 509* 511* 511 512* 512 515
auto_bsc_modes                  000616 automatic       structure                level 1 dcl 1697 set ref 1766 1766 1770 1770
auto_get_chars_info             000620 automatic       structure                level 1 dcl 1702 set ref 1827 1831 1831
auto_rw_status                  000610 automatic       structure                level 1 dcl 1695 set ref 1718 1726
baud_rate                 1     000604 automatic       fixed bin(17,0)          level 2 packed packed unaligned dcl 1689 set ref
                                                                                  1712*
bid_limit               133            based           fixed bin(17,0)          level 2 dcl 193 set ref 345* 375* 500* 1446* 1447*
                                                                                  1451
bin                                                    builtin function         dcl 167 ref 496 496 502 502 534 1458 1458 1863
block_len               205            based           fixed bin(21,0)          level 2 dcl 193 set ref 341* 361* 362 362 484 484
                                                                                  633 645 930 1492* 1493 1500
block_ok                        000504 automatic       bit(1)                   packed unaligned dcl 1073 set ref 1076* 1080* 1097
break_on_eot            143            based           bit(1)                   level 2 dcl 193 set ref 369* 1126
break_on_etb            142            based           bit(1)                   level 2 dcl 193 set ref 368* 1165 1226 1287
bsc_modes                              based           structure                level 1 dcl 278
buf_arg                                based           char                     packed unaligned dcl 268 set ref 1062 1324*
buf_len                   2            based           fixed bin(21,0)          level 2 in structure "get_chars_info" dcl 290
                                                                                  in procedure "bisync_" set ref 1004 1005 1830*
buf_len                         000126 automatic       fixed bin(21,0)          dcl 68 in procedure "bisync_" set ref 952* 954 1004*
                                                                                  1039* 1042 1062 1324
buf_ptr                                based           pointer                  level 2 in structure "get_chars_info" dcl 290
                                                                                  in procedure "bisync_" set ref 1002 1828* 1836
                                                                                  1836 1840
buf_ptr                         000124 automatic       pointer                  dcl 67 in procedure "bisync_" set ref 951* 1002*
                                                                                  1038* 1062 1324
c                                      based           char                     packed unaligned dcl 856 in procedure "count_dle"
                                                                                  ref 863
c                                      parameter       char                     packed unaligned dcl 2034 in procedure "substraddr"
                                                                                  set ref 2032 2038
ca                                     based           char(1)                  array packed unaligned dcl 2036 set ref 2038
caller                          000160 automatic       char(32)                 packed unaligned dcl 84 set ref 1706* 1712* 1720*
                                                                                  1728* 1735* 1746* 1760* 1771* 1783* 1797* 1833*
                                                                                  1834* 1836* 1865*
caller_name               1            based           char(32)                 level 2 dcl 5-10 ref 1706
chan_id                                parameter       fixed bin(71,0)          dcl 2006 ref 2004 2009
channel                 124            based           fixed bin(71,0)          level 2 in structure "ad" dcl 193 in procedure
                                                                                  "bisync_" set ref 422* 428* 430* 433* 476* 554
                                                                                  554* 593* 900* 902* 1098* 1422 1428 1563 1635*
                                                                                  1644* 1668*
channel                                based           fixed bin(71,0)          level 2 in structure "rw_status" dcl 274
                                                                                  in procedure "bisync_" set ref 1428* 1563* 1720
                                                                                  1720 1728 1728
channel_id              116            based           fixed bin(71,0)          level 3 in structure "ad" dcl 193 in procedure
                                                                                  "bisync_" set ref 2009*
channel_id                      000226 automatic       fixed bin(71,0)          level 2 in structure "event_info" dcl 90
                                                                                  in procedure "bisync_" set ref 904 1647 1670
channel_name             12     000352 automatic       char(32)                 level 2 dcl 107 set ref 410* 589*
cl                              000422 automatic       fixed bin(17,0)          dcl 738 set ref 741* 742* 744 746
close                    36            based           entry variable           level 2 dcl 3-6 set ref 651*
code                            000104 automatic       fixed bin(35,0)          dcl 55 set ref 311* 324* 328* 329 337* 388* 395*
                                                                                  403* 404 405* 411* 412* 413 413 415 417 419* 421
                                                                                  428* 429 430* 431 432* 440* 441 442* 459* 460 461*
                                                                                  462 463* 464* 469* 476* 477 478 481* 483 484* 486
                                                                                  490 494 497 501 503 505 530* 536* 548* 549 549*
                                                                                  550 553* 554* 555* 556* 569* 574* 575* 585* 586*
                                                                                  591* 592* 593* 594* 595* 607* 616* 617 618 662*
                                                                                  694* 726 727 890* 893 896 903 914* 917 922 927*
                                                                                  958* 979 980 996* 1041* 1055 1056 1082* 1085* 1087
                                                                                  1099 1370* 1372 1375* 1378 1400* 1419* 1423* 1427*
                                                                                  1441* 1452* 1465* 1469* 1474* 1478 1482 1483*
                                                                                  1490* 1495* 1501* 1505* 1519* 1523* 1525 1525*
                                                                                  1526 1530* 1531 1533* 1535 1535* 1560* 1565* 1571
                                                                                  1603* 1609 1611* 1620 1627* 1629 1633 1636 1646
                                                                                  1649 1657 1657 1665 1669 1672 1711* 1712 1719*
                                                                                  1720 1727* 1728 1734* 1735 1741* 1745* 1746 1762*
                                                                                  1766* 1770* 1771 1778* 1782* 1783 1788* 1791*
                                                                                  1796* 1797 1802* 1808* 1814* 1820* 1831* 1832
                                                                                  1844* 1858* 1867* 1880* 1895 1896 1913 1914 1937*
                                                                                  1953 1954 1962* 1963 1964* 1965* 1966* 1967* 1973
                                                                                  1974 1975* 2011* 2012 2012* 2024*
com_err_                        000046 constant        entry                    external dcl 143 ref 463 469 548
com_err_sw                      000100 automatic       bit(1)                   packed unaligned dcl 53 set ref 310* 548
control                  66            based           entry variable           level 2 in structure "iocb" dcl 3-6 in procedure
                                                                                  "bisync_" set ref 630* 644* 683*
control                   1            based           structure                level 2 in structure "area_info" dcl 1-7
                                                                                  in procedure "bisync_" set ref 315*
conversion                      000000 stack reference condition                dcl 189 ref 533 1862
convert_dial_message_           000102 constant        entry                    external dcl 157 ref 419
convert_ipc_code_               000030 constant        entry                    external dcl 136 ref 405 432 442 1525 2012
data                      1            based           char                     level 2 in structure "order_msg" dcl 1698
                                                                                  in procedure "bisync_io_call" set ref 1807* 1819*
data                      1            based           char                     level 2 in structure "order_msg" dcl 286
                                                                                  in procedure "bisync_" set ref 1533 1533 1533 1533
                                                                                  1548
data                      0(09)        based           char(5)                  level 2 in structure "valchar" packed packed
                                                                                  unaligned dcl 2-14 in procedure "bisync_" set ref
                                                                                  1544* 1547 1548*
data_arg                               based           char                     packed unaligned dcl 267 set ref 757 798* 798* 816
                                                                                  829
data_found                      000142 automatic       bit(1)                   packed unaligned dcl 78 set ref 960* 984 1024 1328*
data_len                               based           fixed bin(17,0)          level 2 in structure "order_msg" dcl 286
                                                                                  in procedure "bisync_" ref 1533 1533 1533 1533
                                                                                  1547 1548
data_len                  2            based           fixed bin(21,0)          level 2 in structure "input_block" dcl 262
                                                                                  in procedure "bisync_" set ref 1094 1375* 1382
data_len                               based           fixed bin(9,0)           level 2 in structure "valchar" packed packed
                                                                                  unsigned unaligned dcl 2-14 in procedure "bisync_"
                                                                                  set ref 1543* 1547*
data_len                               based           fixed bin(17,0)          level 2 in structure "order_msg" dcl 1698
                                                                                  in procedure "bisync_io_call" set ref 1806* 1818*
data_len                  3            based           fixed bin(21,0)          level 2 in structure "get_chars_info" dcl 290
                                                                                  in procedure "bisync_" set ref 1009* 1025* 1836
                                                                                  1836 1836
data_len                        000122 automatic       fixed bin(21,0)          dcl 65 in procedure "bisync_" set ref 697* 699 714
                                                                                  757 798 798 798 798 816 829 953* 991 997 1008*
                                                                                  1025 1040* 1062 1062 1064 1324 1325* 1325
data_ptr                  4            based           pointer                  level 2 in structure "hangup_proc" dcl 282
                                                                                  in procedure "bisync_" set ref 1523*
data_ptr                        000120 automatic       pointer                  dcl 64 in procedure "bisync_" set ref 696* 757 798
                                                                                  798 816 829
define_area_                    000010 constant        entry                    external dcl 128 ref 328
delay                   126            based           fixed bin(71,0)          level 2 dcl 193 set ref 344* 365* 911 911*
detach_iocb              26            based           entry variable           level 2 dcl 3-6 set ref 518* 682*
device                    2            based           char(6)                  level 2 dcl 193 set ref 340* 410 415* 417* 421* 476
                                                                                  477* 589
dial_manager_$dial_out          000074 constant        entry                    external dcl 154 ref 412
dial_manager_$privileged_attach 000072 constant        entry                    external dcl 153 ref 411
dial_manager_$release_channel   000076 constant        entry                    external dcl 155 ref 591
dial_manager_$release_channel_no_hangup
                                000100 constant        entry                    external dcl 156 ref 592
dial_msg_chan                   000336 automatic       char(6)                  packed unaligned dcl 103 set ref 419*
dial_msg_flags                  000374 automatic       structure                level 1 dcl 113 set ref 419*
dial_msg_module                 000340 automatic       char(32)                 packed unaligned dcl 104 set ref 419*
dial_msg_ndialed                000350 automatic       fixed bin(17,0)          dcl 105 set ref 419*
dial_qual                 1     000352 automatic       char(22)                 level 2 dcl 107 set ref 350* 391* 411 590*
dl                              000423 automatic       fixed bin(17,0)          dcl 738 in procedure "format_nontransparent_block"
                                                                                  set ref 746* 750* 757 757 757 759 760 761 764 765
dl                              000435 automatic       fixed bin(17,0)          dcl 783 in procedure "format_transparent_block" set
                                                                                  ref 788* 792* 796 798* 802* 802 815 816 827
dle                     170            based           char(1)                  level 2 dcl 193 set ref 810 816 818 819 837 863 1242
                                                                                  1262 1276 1300 1987*
dma                             000352 automatic       structure                level 1 dcl 107 set ref 411 411 412 412 591 591 592
                                                                                  592
ebcdic                    0(01)        based           bit(1)                   level 2 in structure "bsc_modes" packed packed
                                                                                  unaligned dcl 278 in procedure "bisync_" set ref
                                                                                  1457 1464*
ebcdic                    0(01) 000616 automatic       bit(1)                   level 2 in structure "auto_bsc_modes" packed packed
                                                                                  unaligned dcl 1697 in procedure "bisync_io_call"
                                                                                  set ref 1752* 1755* 1756* 1771*
empty_buffer                    000110 automatic       char(1)                  initial packed unaligned dcl 57 set ref 57* 1474
                                                                                  1474
entry_var                              based           entry variable           level 2 dcl 282 set ref 1523*
eot                     171            based           char(1)                  level 2 in structure "ad" dcl 193 in procedure
                                                                                  "bisync_" set ref 670 1126 1617 1992* 1996*
eot                      10(03)        based           bit(1)                   level 3 in structure "get_chars_info" packed packed
                                                                                  unaligned dcl 290 in procedure "bisync_" set ref
                                                                                  1017* 1833
eot_found                       000137 automatic       bit(1)                   packed unaligned dcl 75 set ref 964* 973* 983 996
                                                                                  1017 1131* 1432* 1435
err                             000174 automatic       entry variable           dcl 85 set ref 1708* 1760 1865
error                    26            based           entry variable           level 2 dcl 5-10 ref 1708
error_table_$action_not_performed
                                000160 external static fixed bin(35,0)          dcl 184 ref 413
error_table_$bad_arg            000126 external static fixed bin(35,0)          dcl 171 ref 700 1883
error_table_$bad_mode           000130 external static fixed bin(35,0)          dcl 172 ref 612
error_table_$badopt             000154 external static fixed bin(35,0)          dcl 182 set ref 395 549 1760*
error_table_$bisync_bid_fail    000132 external static fixed bin(35,0)          dcl 173 ref 1964
error_table_$bisync_block_bad   000162 external static fixed bin(35,0)          dcl 185 ref 1965
error_table_$bisync_reverse_interrupt
                                000134 external static fixed bin(35,0)          dcl 174 ref 1966
error_table_$buffer_big         000124 external static fixed bin(35,0)          dcl 170 ref 1490
error_table_$device_parity      000156 external static fixed bin(35,0)          dcl 183 ref 1967
error_table_$end_of_info        000164 external static fixed bin(35,0)          dcl 186 ref 996
error_table_$line_status_pending
                                000140 external static fixed bin(35,0)          dcl 176 ref 1954
error_table_$long_record        000136 external static fixed bin(35,0)          dcl 175 ref 1062
error_table_$no_line_status     000152 external static fixed bin(35,0)          dcl 181 ref 1657
error_table_$no_operation       000150 external static fixed bin(35,0)          dcl 180 ref 1603
error_table_$noarg              000146 external static fixed bin(35,0)          dcl 179 ref 388 530 1802 1858
error_table_$not_detached       000142 external static fixed bin(35,0)          dcl 177 ref 324
error_table_$resource_attached  000166 external static fixed bin(35,0)          dcl 187 ref 413
error_table_$wrong_no_of_args   000144 external static fixed bin(35,0)          dcl 178 ref 337
etb                      10(01)        based           bit(1)                   level 3 in structure "get_chars_info" packed packed
                                                                                  unaligned dcl 290 in procedure "bisync_" set ref
                                                                                  1026* 1836*
etb                     167            based           char(1)                  level 2 in structure "ad" dcl 193 in procedure
                                                                                  "bisync_" set ref 762 838 1160 1206 1226 1232 1284
                                                                                  1991* 1995*
etb_found                       000134 automatic       bit(1)                   packed unaligned dcl 72 set ref 968* 1026 1166*
                                                                                  1232* 1432*
etb_sw                          000424 automatic       bit(1)                   packed unaligned dcl 739 in procedure
                                                                                  "format_nontransparent_block" set ref 747* 751*
                                                                                  762
etb_sw                          000440 automatic       bit(1)                   packed unaligned dcl 784 in procedure
                                                                                  "format_transparent_block" set ref 789* 793* 803*
                                                                                  838
etx                      10            based           bit(1)                   level 3 in structure "get_chars_info" packed packed
                                                                                  unaligned dcl 290 in procedure "bisync_" set ref
                                                                                  1027* 1836*
etx                     166            based           char(1)                  level 2 in structure "ad" dcl 193 in procedure
                                                                                  "bisync_" set ref 763 839 1134 1196 1293 1986*
etx_found                       000135 automatic       bit(1)                   packed unaligned dcl 73 set ref 971* 974 991 1027
                                                                                  1138* 1148* 1167* 1201* 1288* 1296* 1432* 1439
event_channel            10     000352 automatic       fixed bin(71,0)          level 2 dcl 107 set ref 409* 588*
event_info                      000226 automatic       structure                level 1 dcl 90 set ref 2011 2011
event_info_channel              000614 automatic       fixed bin(71,0)          dcl 1696 in procedure "bisync_io_call" set ref 1734
                                                                                  1734 1735 1735
event_info_channel                     based           fixed bin(71,0)          dcl 273 in procedure "bisync_" set ref 1422*
extend                    1            based           bit(1)                   level 3 packed packed unaligned dcl 1-7 set ref 316*
fill                      0(02) 000616 automatic       bit(34)                  level 2 packed packed unaligned dcl 1697 set ref
                                                                                  1753*
flag                      2            based           bit(1)                   level 2 in structure "rw_status" dcl 274
                                                                                  in procedure "bisync_" set ref 1429* 1430* 1434*
                                                                                  1437* 1440* 1720* 1728*
flag                      2     000542 automatic       bit(1)                   level 2 in structure "read_status" dcl 1365
                                                                                  in procedure "hide_away_input" set ref 1368* 1369
                                                                                  1373
flag                      2     000566 automatic       bit(1)                   level 2 in structure "write_status" dcl 1600
                                                                                  in procedure "end_write_mode" set ref 1625* 1626
                                                                                  1631
flags                    10            based           structure                level 2 dcl 290 set ref 1011*
fnp_output_pending      150            based           bit(1)                   level 2 dcl 193 set ref 1658* 1675 1970*
fnp_output_reported     147            based           bit(1)                   level 2 dcl 193 set ref 1659* 1674 1969*
get_chars                46            based           entry variable           level 2 dcl 3-6 set ref 627*
get_chars_data                         based           char                     packed unaligned dcl 1701 ref 1828 1829 1834 1834
                                                                                  1836 1836 1840 1841
get_chars_info                         based           structure                level 1 dcl 290
get_line                 42            based           entry variable           level 2 dcl 3-6 set ref 628*
hangup_proc                            based           structure                level 1 dcl 282
hangup_sw               146            based           bit(1)                   level 2 dcl 193 set ref 370* 585 591
hasp_mode               152            based           bit(1)                   level 2 dcl 193 set ref 372* 492
hbound                                                 builtin function         dcl 167 ref 336 351 381 387 510 529
hbuf_len                  6            based           fixed bin(21,0)          level 2 in structure "get_chars_info" dcl 290
                                                                                  in procedure "bisync_" set ref 1007 1830*
hbuf_len                        000132 automatic       fixed bin(21,0)          dcl 70 in procedure "bisync_" set ref 1007* 1316
                                                                                  1317
hbuf_ptr                  4            based           pointer                  level 2 in structure "get_chars_info" dcl 290
                                                                                  in procedure "bisync_" set ref 1006 1829* 1834
                                                                                  1834 1841
hbuf_ptr                        000130 automatic       pointer                  dcl 69 in procedure "bisync_" set ref 956* 1006*
                                                                                  1315 1317
hcs_$assign_channel             000026 constant        entry                    external dcl 135 ref 428
hcs_$reset_ips_mask             000040 constant        entry                    external dcl 140 ref 520 598 654 685
hcs_$set_ips_mask               000036 constant        entry                    external dcl 139 ref 514 578 625 679
hcs_$tty_abort                  000056 constant        entry                    external dcl 147 ref 1419
hcs_$tty_attach                 000032 constant        entry                    external dcl 137 ref 476
hcs_$tty_detach                 000034 constant        entry                    external dcl 138 ref 553 586
hcs_$tty_order                  000054 constant        entry                    external dcl 146 ref 481 484 585 890 1370 1560 1627
                                                                                  1937 1962
hcs_$tty_read                   000052 constant        entry                    external dcl 145 ref 1085 1375
hcs_$tty_state                  000060 constant        entry                    external dcl 148 ref 616
hcs_$tty_write                  000050 constant        entry                    external dcl 144 ref 914
header_arg                             based           char                     packed unaligned dcl 269 set ref 1317*
header_found                    000141 automatic       bit(1)                   packed unaligned dcl 77 set ref 960* 984 1020 1320*
header_len                7            based           fixed bin(21,0)          level 2 in structure "get_chars_info" dcl 290
                                                                                  in procedure "bisync_" set ref 1010* 1021* 1834
                                                                                  1834
header_len                      000123 automatic       fixed bin(21,0)          dcl 66 in procedure "bisync_" set ref 1008* 1021
                                                                                  1316 1317 1318* 1318
i                               000113 automatic       fixed bin(21,0)          dcl 60 in procedure "bisync_" set ref 351* 352 353
                                                                                  354 357 360 362 365 366 367 368 369 370 371 372
                                                                                  373 374 375 376 377 378 381 381 385 386* 386 387
                                                                                  391 393 396* 510* 512* 528* 528 529 531 534 538
                                                                                  1048* 1049 1049* 1051 1051 1403* 1405* 1409* 1414*
                                                                                  1419 1419 1888* 1889 1890* 1891 1904* 1905 1908*
i                               000516 automatic       fixed bin(21,0)          dcl 1312 in procedure "move_scanned_data" set ref
                                                                                  1316* 1317 1317 1317 1318
i                               000462 automatic       fixed bin(21,0)          dcl 876 in procedure "transmit_block" set ref 884*
                                                                                  886 913 914 919* 919 920
i                               000600 automatic       fixed bin(17,0)          dcl 1687 in procedure "bisync_io_call" set ref 1740*
                                                                                  1741 1741 1745 1745 1746* 1754* 1755 1756 1757
                                                                                  1758 1760* 1777* 1778 1778 1782 1782 1783* 1790*
                                                                                  1791 1791 1796 1796 1797 1797* 1797 1804* 1805
                                                                                  1806 1807 1809 1816* 1817 1818 1819 1821 1826*
                                                                                  1828 1828 1829 1829 1830 1834 1834 1836 1836 1840
                                                                                  1840 1841 1841
i                               000502 automatic       fixed bin(21,0)          dcl 1072 in procedure "scan_more_data" set ref 1085*
                                                                                  1094* 1096 1102* 1103 1134* 1136 1153 1153* 1154*
                                                                                  1154 1158 1158* 1159* 1159 1172* 1172 1173 1175*
                                                                                  1196* 1198 1207 1207* 1208* 1208 1210 1210* 1211*
                                                                                  1211 1212 1218 1235* 1235 1236 1238* 1242* 1244
                                                                                  1248* 1262* 1264 1269 1269* 1270* 1270 1271 1273*
i                               000450 automatic       fixed bin(17,0)          dcl 857 in procedure "count_dle" set ref 860* 862
                                                                                  863 866* 866
i                               000434 automatic       fixed bin(17,0)          dcl 783 in procedure "format_transparent_block" set
                                                                                  ref 798* 799 799 816* 817 827 827* 828* 828 829
                                                                                  829 830 831 832 833 834
ibm3270_mode            151            based           bit(1)                   level 2 dcl 193 set ref 371* 427 488
id                              000604 automatic       char(4)                  level 2 dcl 1689 set ref 1712*
index                                                  builtin function         dcl 167 ref 816 863 1048 1134 1144 1160 1196 1206
                                                                                  1209 1242 1262 1904
info                            000604 automatic       structure                level 1 dcl 1689 set ref 1711 1711
info_ptr                        000154 automatic       pointer                  dcl 81 set ref 1002 1004 1005 1006 1007 1009 1010
                                                                                  1011 1017 1021 1022 1025 1026 1027 1399* 1422 1428
                                                                                  1429 1430 1434 1437 1440 1446 1451 1456 1457 1463
                                                                                  1464 1490 1492 1500 1506 1511 1517 1518 1523 1523
                                                                                  1523 1533 1533 1533 1533 1533 1533 1533 1533 1542
                                                                                  1547 1548 1548 1560* 1563 1704 1718* 1719* 1720
                                                                                  1720 1720 1726* 1727* 1728 1728 1728 1827* 1828
                                                                                  1829 1830 1830 1833 1834 1834 1834 1834 1834 1836
                                                                                  1836 1836 1836 1836 1836 1836 1840 1841
input_block                            based           structure                level 1 dcl 262 set ref 634 677 1091 1374 1379 1386
                                                                                  1587
input_blockp            210            based           pointer                  level 2 dcl 193 set ref 451* 634* 635 636 677 1084
                                                                                  1090 1091 1092* 1093 1094 1585 1586 1587 1588*
                                                                                  1589
input_buf_len           214            based           fixed bin(21,0)          level 2 dcl 193 set ref 449* 633* 634 636 677 1085*
                                                                                  1091 1093 1374 1375 1375 1375* 1379 1386 1587 1589
input_buf_ptr           216            based           pointer                  level 2 dcl 193 set ref 450* 636* 1085* 1093* 1102*
                                                                                  1104 1589*
input_buffer              3            based           char                     level 2 dcl 262 set ref 636 1093 1375 1375 1589
input_state             204            based           fixed bin(17,0)          level 2 dcl 193 set ref 639* 1110 1111 1116* 1122*
                                                                                  1139* 1140* 1149* 1150* 1163* 1164* 1180* 1185*
                                                                                  1188* 1192* 1202* 1203* 1223* 1228* 1229* 1249*
                                                                                  1255* 1259* 1266* 1280* 1286* 1295* 1302* 1581*
io_call_info                           based           structure                level 1 dcl 5-10
io_call_infop                   000404 automatic       pointer                  dcl 5-8 set ref 1704* 1705 1706 1707 1708 1754 1755
                                                                                  1756 1757 1758 1760 1788 1802 1804 1807 1814 1816
                                                                                  1819 1857 1863 1865
iocb                                   based           structure                level 1 dcl 3-6
iocbp                           000106 automatic       pointer                  dcl 56 set ref 309* 323 325 458 515 516 517 518 519*
                                                                                  568* 571 596 597* 606* 608 627 628 629 630 643 644
                                                                                  651 652 653* 661* 663 680 681 682 683 684* 693*
                                                                                  695 949* 950 1036* 1037 1397* 1398 1474 1474*
                                                                                  1530* 1533* 1535* 1711* 1719* 1727* 1734* 1741*
                                                                                  1745* 1766* 1770* 1778* 1782* 1788* 1791* 1796*
                                                                                  1808* 1814* 1820* 1831* 1844* 1876* 1877
iomodule_name                   000132 constant        char(7)                  initial packed unaligned dcl 122 set ref 318 463*
                                                                                  469* 509 548*
iox_$attach_name                000106 constant        entry                    external dcl 160 ref 459
iox_$close                      000114 constant        entry                    external dcl 163 ref 574
iox_$control                    000104 constant        entry                    external dcl 159 ref 1530 1535 1711 1719 1727 1734
                                                                                  1741 1745 1766 1770 1778 1782 1788 1791 1796 1808
                                                                                  1814 1820 1831 1844
iox_$detach_iocb                000116 constant        entry                    external dcl 164 ref 464 575
iox_$err_no_operation           000120 constant        entry                    external dcl 165 ref 683
iox_$open                       000110 constant        entry                    external dcl 161 ref 461
iox_$propagate                  000042 constant        entry                    external dcl 141 ref 519 597 653 684
iox_$put_chars                  000044 constant        entry                    external dcl 142 ref 1533
iox_$write_record               000112 constant        entry                    external dcl 162 ref 918 1102
iox_modes                       000012 constant        char(24)                 initial array dcl 4-6 ref 622
ipc_$block                      000062 constant        entry                    external dcl 149 ref 2011
ipc_$create_ev_chn              000014 constant        entry                    external dcl 130 ref 403 430 440
ipc_$decl_ev_call_chn           000020 constant        entry                    external dcl 132 ref 1523
ipc_$decl_ev_wait_chn           000022 constant        entry                    external dcl 133 ref 581
ipc_$delete_ev_chn              000016 constant        entry                    external dcl 131 ref 554 555 556 593 594 595
ipc_$drain_chn                  000024 constant        entry                    external dcl 134 ref 2024
itb                     172            based           char(1)                  level 2 dcl 193 set ref 754 807 1144 1299 1988*
j                               000503 automatic       fixed bin(21,0)          dcl 1072 in procedure "scan_more_data" set ref 1144*
                                                                                  1145 1146 1153 1154 1160* 1161 1172 1172 1206*
                                                                                  1207 1208 1208 1209* 1210 1211 1211
j                               000451 automatic       fixed bin(17,0)          dcl 857 in procedure "count_dle" set ref 861* 864
                                                                                  865* 865 868
j                               000463 automatic       fixed bin(21,0)          dcl 876 in procedure "transmit_block" set ref 914*
                                                                                  918* 919
k                               000452 automatic       fixed bin(17,0)          dcl 857 set ref 863* 864 866
l                                      parameter       fixed bin(17,0)          dcl 855 ref 852 859 862 863
last_etx                226            based           fixed bin(21,0)          level 2 dcl 193 set ref 754 761* 762 763 807 840*
last_input_blockp       212            based           pointer                  level 2 dcl 193 set ref 452* 635* 1383 1384*
length                                                 builtin function         dcl 167 ref 479 1533 1533 1547 1804 1816
line_ctl                        000400 automatic       structure                level 1 dcl 2-10 set ref 1937 1937
line_stat                       000402 automatic       structure                level 1 dcl 2-42 set ref 1962 1962
log_iocbp               130            based           pointer                  level 2 dcl 193 set ref 459* 461* 464* 574* 575*
                                                                                  918* 1102*
log_sw                  164            based           bit(1)                   level 2 dcl 193 set ref 393* 457 465* 470* 573 918
                                                                                  1102
low                                                    builtin function         dcl 167 ref 768
mask                            000111 automatic       bit(36)                  dcl 58 set ref 514* 520* 520* 578* 598* 598* 625*
                                                                                  654* 654* 679* 685* 685*
master_sw               153            based           bit(1)                   level 2 dcl 193 set ref 373* 495 496 496
max                                                    builtin function         dcl 167 ref 1493 1511
max_arglen               43            based           fixed bin(17,0)          level 2 dcl 5-10 ref 1755 1755 1756 1756 1757 1757
                                                                                  1758 1758 1760 1760 1760 1804 1804 1807 1807 1816
                                                                                  1816 1819 1819 1863 1863 1865 1865 1865
max_block_len           206            based           fixed bin(21,0)          level 2 dcl 193 set ref 341* 361* 1490
message                   2     000226 automatic       fixed bin(71,0)          level 2 dcl 90 set ref 419 419
min                                                    builtin function         dcl 167 ref 975 975 1051 1051 1154 1172 1208 1211
                                                                                  1316 1547 1888
mode_data                       000235 automatic       structure                level 1 dcl 99 set ref 481 481
moved                           000437 automatic       fixed bin(17,0)          dcl 783 set ref 814* 815 816 823* 823 827 833* 833
multi_record            156            based           bit(1)                   level 2 dcl 193 set ref 379* 667 720 1143 1299 1478
                                                                                  1507* 1512* 1517 1607
multi_record_limit      161            based           fixed bin(17,0)          level 2 dcl 193 set ref 380* 381* 721 722 1508*
                                                                                  1511* 1512 1518
my_area_info                    000200 automatic       structure                level 1 dcl 86 set ref 313
n                                      parameter       fixed bin(21,0)          dcl 2035 in procedure "substraddr" ref 2032 2038
n                                      parameter       fixed bin(17,0)          dcl 1855 in procedure "cv_io_call_dec_arg" ref 1853
                                                                                  1857 1863 1865
n_sec                                  parameter       fixed bin(17,0)          dcl 937 in procedure "transmit_block" set ref 899*
                                                                                  935
n_sec                                  parameter       fixed bin(17,0)          dcl 2021 in procedure "set_time" ref 2019 2025
name                      1            based           char(32)                 level 2 dcl 3-6 set ref 325* 458
nargs                    42            based           fixed bin(17,0)          level 2 dcl 5-10 ref 1754 1788 1802 1814 1857
nchan                   114            based           fixed bin(17,0)          level 3 in structure "ad" dcl 193 in procedure
                                                                                  "bisync_" set ref 402* 2010*
nchan                                  parameter       fixed bin(17,0)          dcl 2007 in procedure "block" ref 2004 2010
next_blockp                            based           pointer                  initial level 2 dcl 262 set ref 634* 1084 1090 1374*
                                                                                  1383* 1585 1586
nl                              015134 constant        char(1)                  initial packed unaligned dcl 123 ref 1048 1062 1904
nl_found                        000143 automatic       bit(1)                   packed unaligned dcl 79 set ref 1043* 1046 1050*
null                                                   builtin function         dcl 167 ref 320 321 323 450 451 452 459 459 552 558
                                                                                  585 585 596 634 680 956 1084 1315 1374 1506 1530
                                                                                  1530 1535 1535 1542 1585 1788 1788 1814 1814 1844
                                                                                  1844
offset                          000116 automatic       fixed bin(21,0)          dcl 63 set ref 715* 757 760* 760 798* 798* 816 822*
                                                                                  822 829 832* 832
op                                     parameter       fixed bin(17,0)          dcl 1928 in procedure "line_control" ref 1926 1934
                                                                                  1936 1941
op                              000400 automatic       fixed bin(17,0)          level 2 in structure "line_ctl" packed packed
                                                                                  unaligned dcl 2-10 in procedure "bisync_" set ref
                                                                                  1936*
op                              000402 automatic       fixed bin(17,0)          level 2 in structure "line_stat" packed packed
                                                                                  unaligned dcl 2-42 in procedure "bisync_" set ref
                                                                                  1964 1965 1966 1967 1968
open                     32            based           entry variable           level 2 dcl 3-6 set ref 517* 681*
open_descrip_ptr         20            based           pointer                  level 2 dcl 3-6 set ref 652* 680*
open_description        105            based           varying char(24)         level 2 dcl 193 set ref 622* 652
open_mode                       000114 automatic       fixed bin(17,0)          dcl 61 set ref 610* 611 611 611 622 626 626 642 642
order                           000144 automatic       char(32)                 packed unaligned dcl 80 set ref 458* 459* 459 463*
                                                                                  469* 1401* 1404 1408 1413 1421 1426 1445 1450 1455
                                                                                  1462 1468 1489 1499 1504 1516 1522 1529 1539 1541
                                                                                  1553 1555 1557 1560* 1562 1705* 1710 1717 1725
                                                                                  1733 1739 1744 1750 1769 1776 1781 1787 1795 1801
                                                                                  1813 1825 1844
order_msg                              based           structure                level 1 dcl 286 in procedure "bisync_"
order_msg                              based           structure                level 1 dcl 1698 in procedure "bisync_io_call" set
                                                                                  ref 1805 1809 1817 1821
order_name               11            based           char(32)                 level 2 dcl 5-10 ref 1705
order_sw                        000133 automatic       bit(1)                   packed unaligned dcl 71 set ref 955* 994 1012*
order_val                              based           fixed bin(17,0)          dcl 277 set ref 1446 1451* 1490 1492 1500* 1511
                                                                                  1517* 1518*
output_buf_left         225            based           fixed bin(21,0)          level 2 dcl 193 set ref 647* 744 746 765* 765 769*
                                                                                  769 771* 771 786 788 799 813* 813 821* 821 831*
                                                                                  831 842* 842 930* 1411* 1417* 1493*
output_buf_len          220            based           fixed bin(21,0)          level 2 dcl 193 set ref 449* 645* 646 646 647 670
                                                                                  674 674 754 756 757 762 763 768 807 810 811 818
                                                                                  819 829 837 838 839 913 913 1411 1417 1617
output_buf_ptr          222            based           pointer                  level 2 dcl 193 set ref 450* 646* 670 674 754 756
                                                                                  757 762 763 768 807 810 811 818 819 829 837 838
                                                                                  839 913 1617
output_buf_used         224            based           fixed bin(21,0)          level 2 dcl 193 set ref 640* 667 671* 745 754 756
                                                                                  757 761 764* 764 767* 767 768 787 801 807 810 811
                                                                                  812* 812 818 819 820* 820 829 830* 830 837 838 839
                                                                                  840 841* 841 886 914 920 928* 1410* 1416* 1478
                                                                                  1493 1607 1618*
output_buffer                          based           char                     packed unaligned dcl 257 set ref 646 670* 674 754*
                                                                                  756* 757* 762* 763* 768* 807* 810* 811* 818* 819*
                                                                                  829* 837* 838* 839* 913* 1617*
output_etb_mode         157            based           bit(1)                   level 2 dcl 193 set ref 348* 366* 367* 1471
output_mode             145            based           bit(1)                   level 2 dcl 193 set ref 648* 666 1478 1493 1602
output_pending            2     000470 automatic       bit(1)                   level 2 packed packed unaligned dcl 880 set ref 888*
                                                                                  889 894
owner                     2            based           char(32)                 level 2 packed packed unaligned dcl 1-7 set ref 318*
p                               000464 automatic       pointer                  dcl 877 in procedure "transmit_block" set ref 913*
                                                                                  914* 918*
p                                      parameter       pointer                  dcl 854 in procedure "count_dle" ref 852 863
p                               000556 automatic       pointer                  dcl 1579 in procedure "internal_resetread" set ref
                                                                                  1586* 1588
p                               000602 automatic       pointer                  dcl 1688 in procedure "bisync_io_call" set ref 1805*
                                                                                  1806 1807 1808* 1809 1817* 1818 1819 1820* 1821
p                               000546 automatic       pointer                  dcl 1366 in procedure "hide_away_input" set ref
                                                                                  1374* 1375 1375 1375 1379 1382 1383 1384 1386
p                               000506 automatic       pointer                  dcl 1074 in procedure "scan_more_data" set ref 1090*
                                                                                  1092
pos_type                        000156 automatic       fixed bin(17,0)          dcl 82 set ref 1878* 1882 1882 1887
pos_value                       000157 automatic       fixed bin(21,0)          dcl 83 set ref 1879* 1882 1887 1888 1891* 1891 1902
                                                                                  1907* 1907
position                 62            based           entry variable           level 2 dcl 3-6 set ref 629*
prior                     6            based           fixed bin(17,0)          level 2 dcl 282 set ref 1523*
put_chars                52            based           entry variable           level 2 dcl 3-6 set ref 643* 1474
read_status                     000542 automatic       structure                level 1 dcl 1365 set ref 1370 1370
real_chars                      000436 automatic       fixed bin(17,0)          dcl 783 set ref 796* 799
real_transparent                000224 automatic       bit(1)                   packed unaligned dcl 87 set ref 711* 718
record_count            162            based           fixed bin(17,0)          level 2 dcl 193 set ref 722 773* 773 844* 844 931*
release_area_                   000012 constant        entry                    external dcl 129 ref 558 599
remaining_len                   000115 automatic       fixed bin(21,0)          dcl 62 set ref 714* 717 720 744 750 759* 759 774
                                                                                  774* 786 792 824* 824 834* 834 845 845* 954* 974
                                                                                  975 975 1005* 1042* 1046 1051 1051 1327* 1327
report                   22            based           entry variable           level 2 dcl 5-10 ref 1707
req                       1     000235 automatic       char(256)                level 2 dcl 99 set ref 479 480*
req_len                         000235 automatic       fixed bin(17,0)          level 2 dcl 99 set ref 479*
rpt                             000170 automatic       entry variable           dcl 85 set ref 1707* 1712 1720 1728 1735 1746 1771
                                                                                  1783 1797 1833 1834 1836
rtrim                                                  builtin function         dcl 167 ref 458 459 622
rw_status                              based           structure                level 1 dcl 274
saved_eot               144            based           bit(1)                   level 2 dcl 193 set ref 641* 962 963* 985* 1044*
                                                                                  1430 1436* 1583*
scanned_data                           based           char                     packed unaligned dcl 259 set ref 1048 1317 1324
                                                                                  1352* 1904
scanned_data_len        174            based           fixed bin(21,0)          level 2 dcl 193 set ref 638* 975 975 975 1047 1048
                                                                                  1049 1173* 1213* 1236* 1271* 1278* 1301* 1317 1324
                                                                                  1352 1352 1353* 1353 1429 1434 1582* 1888 1903
                                                                                  1904 1905*
scanned_data_ptr        176            based           pointer                  level 2 dcl 193 set ref 1048 1174* 1214* 1237* 1272*
                                                                                  1279* 1300* 1317 1324 1352* 1352 1904
size                     13            based           fixed bin(18,0)          level 2 dcl 1-7 set ref 319*
slave_sw                154            based           bit(1)                   level 2 dcl 193 set ref 374* 495
soh                      10(02)        based           bit(1)                   level 3 in structure "get_chars_info" packed packed
                                                                                  unaligned dcl 290 in procedure "bisync_" set ref
                                                                                  1022* 1834
soh                     173            based           char(1)                  level 2 in structure "ad" dcl 193 in procedure
                                                                                  "bisync_" set ref 1120 1989*
soh_found                       000140 automatic       bit(1)                   packed unaligned dcl 76 set ref 970* 991 1121* 1222*
                                                                                  1314 1432*
state                           000112 automatic       fixed bin(17,0)          dcl 59 set ref 476* 481* 484* 553* 585* 586* 616*
                                                                                  890* 914* 1085* 1370* 1375* 1419* 1560* 1627*
                                                                                  1937* 1962*
str1                                   parameter       char                     dcl 546 set ref 544 548*
str2                                   parameter       char                     dcl 546 set ref 544 548*
string                                                 builtin function         dcl 167 set ref 315* 1011*
stx                     165            based           char(1)                  level 2 dcl 193 set ref 756 811 1113 1188 1209 1219
                                                                                  1252 1985*
stx_found                       000136 automatic       bit(1)                   packed unaligned dcl 74 set ref 972* 991 1115* 1191*
                                                                                  1221* 1256* 1432*
substr                                                 builtin function         dcl 167 set ref 381 670* 754* 756* 757* 757 762*
                                                                                  763* 768* 807* 810* 811* 816 818* 819* 829* 829
                                                                                  837* 838* 839* 863 1062 1113 1120 1126 1188 1219
                                                                                  1226 1232 1252 1276 1284 1293 1299 1317* 1317
                                                                                  1324* 1324 1617* 1834 1834 1836 1836
sys_info$max_seg_size           000122 external static fixed bin(35,0)          dcl 169 ref 319
temp_nontransparent     141            based           bit(1)                   level 2 dcl 193 set ref 711 712* 1532* 1534*
time_limit                      000466 automatic       bit(1)                   initial packed unaligned dcl 878 set ref 878* 898
                                                                                  939*
time_out                        000225 automatic       bit(1)                   packed unaligned dcl 88 set ref 668* 669 905* 940*
timer_channel           120            based           fixed bin(71,0)          level 3 dcl 193 set ref 440* 443* 555 555* 594* 904
                                                                                  1647 1670 2023* 2024* 2025*
timer_manager_$alarm_wakeup     000070 constant        entry                    external dcl 152 ref 2025
timer_manager_$reset_alarm_wakeup
                                000066 constant        entry                    external dcl 151 ref 2023
timer_manager_$sleep            000064 constant        entry                    external dcl 150 ref 911
transparent                     000616 automatic       bit(1)                   level 2 in structure "auto_bsc_modes" packed packed
                                                                                  unaligned dcl 1697 in procedure "bisync_io_call"
                                                                                  set ref 1751* 1757* 1758* 1771
transparent             136            based           bit(1)                   level 2 in structure "ad" dcl 193 in procedure
                                                                                  "bisync_" set ref 342* 352* 353* 502 502 711 1110
                                                                                  1456* 1458 1458 1463
transparent                            based           bit(1)                   level 2 in structure "bsc_modes" packed packed
                                                                                  unaligned dcl 278 in procedure "bisync_" set ref
                                                                                  1456 1463*
ttd_limit               135            based           fixed bin(17,0)          level 2 dcl 193 set ref 347* 377* 504*
ttd_time                134            based           fixed bin(17,0)          level 2 dcl 193 set ref 346* 376* 504*
tty_attached            155            based           bit(1)                   level 2 dcl 193 set ref 478* 553
tty_index               132            based           fixed bin(17,0)          level 2 dcl 193 set ref 476* 481* 484* 553* 585*
                                                                                  586* 616* 890* 914* 1085* 1370* 1375* 1419* 1560*
                                                                                  1627* 1937* 1962*
type                      3     000604 automatic       fixed bin(17,0)          level 2 dcl 1689 set ref 1712*
unscanned_data                         based           char                     packed unaligned dcl 258 set ref 1113 1120 1126 1134
                                                                                  1144 1160 1188 1196 1206 1209 1219 1226 1232 1242
                                                                                  1252 1262 1276 1284 1293 1299 1340*
unscanned_data_len      200            based           fixed bin(21,0)          level 2 dcl 193 set ref 637* 1083 1103* 1113 1120
                                                                                  1126 1134 1144 1158 1160 1188 1196 1206 1209 1213
                                                                                  1215* 1219 1226 1232 1242 1245* 1252 1262 1269
                                                                                  1276 1284 1293 1299 1340 1340 1341* 1341 1582*
unscanned_data_ptr      202            based           pointer                  level 2 dcl 193 set ref 1104* 1113 1120 1126 1134
                                                                                  1144 1160 1174 1188 1196 1206 1209 1214 1219 1226
                                                                                  1232 1237 1242 1252 1262 1272 1276 1279 1284 1293
                                                                                  1299 1340* 1340
unspec                                                 builtin function         dcl 167 set ref 331* 419 419 1720 1720 1728 1728
                                                                                  1735 1735 1985* 1986* 1987* 1988* 1989* 1991*
                                                                                  1992* 1995* 1996*
use_etb                 160            based           bit(1)                   level 2 dcl 193 set ref 349* 366* 367* 762 838 1472*
                                                                                  1475*
val                       0(18) 000402 automatic       fixed bin(17,0)          array level 2 in structure "line_stat" packed packed
                                                                                  unaligned dcl 2-42 in procedure "bisync_" set ref
                                                                                  1970
val                       0(18) 000400 automatic       fixed bin(17,0)          array level 2 in structure "line_ctl" packed packed
                                                                                  unaligned dcl 2-10 in procedure "bisync_" set ref
                                                                                  1543 1544 1547 1547 1548 1930* 1931* 1943* 1944*
val1                                   parameter       fixed bin(17,0)          dcl 1928 ref 1926 1931 1941
val2                                   parameter       fixed bin(17,0)          dcl 1928 ref 1941 1944
valchar                                based           structure                level 1 packed packed unaligned dcl 2-14
version                         000352 automatic       fixed bin(17,0)          level 2 in structure "dma" dcl 107 in procedure
                                                                                  "bisync_" set ref 408* 587*
version                                based           fixed bin(17,0)          level 2 in structure "area_info" dcl 1-7
                                                                                  in procedure "bisync_" set ref 314*
wait_list               114            based           structure                level 2 dcl 193 set ref 2011 2011
work_area                              based           area(1024)               dcl 260 set ref 330 599 599 634 646 1374 1805 1817
                                                                                  1828 1829
work_areap                             based           pointer                  level 2 dcl 193 set ref 332* 599 599 634 646 1374
                                                                                  1805 1817 1828 1829
write_error_code        163            based           fixed bin(35,0)          level 2 dcl 193 set ref 623* 704 705 707* 725 892
                                                                                  897 916 923 1482 1483 1484* 1564 1565 1566* 1610
                                                                                  1611 1613* 1621 1630 1634 1650 1660 1666 1673
                                                                                  1974*
write_status                    000566 automatic       structure                level 1 dcl 1600 in procedure "end_write_mode" set
                                                                                  ref 1627 1627
write_status                    000470 automatic       structure                level 1 dcl 880 in procedure "transmit_block" set
                                                                                  ref 890 890
zero_on_free              1(02)        based           bit(1)                   level 3 packed packed unaligned dcl 1-7 set ref 317*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Direct_input                           internal static fixed bin(17,0)          initial dcl 4-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 4-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 4-15
HASP_FOREIGN_SWAB_RESET                internal static fixed bin(17,0)          initial dcl 2-49
HASP_INIT_COMPLETE                     internal static fixed bin(17,0)          initial dcl 2-49
IBM3270_NAK_OUTPUT                     internal static fixed bin(17,0)          initial dcl 2-49
IBM3270_SELECT_FAILED                  internal static fixed bin(17,0)          initial dcl 2-49
IBM3270_WACK_MESSAGE                   internal static fixed bin(17,0)          initial dcl 2-49
IBM3270_WACK_SELECT                    internal static fixed bin(17,0)          initial dcl 2-49
IBM3270_WRITE_ABORT                    internal static fixed bin(17,0)          initial dcl 2-49
IBM3270_WRITE_COMPLETE                 internal static fixed bin(17,0)          initial dcl 2-49
IBM3270_WRITE_EOT                      internal static fixed bin(17,0)          initial dcl 2-49
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 4-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 4-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 4-15
SET_HASP_TIMERS                        internal static fixed bin(17,0)          initial dcl 2-21
SET_NAK_LIMIT                          internal static fixed bin(17,0)          initial dcl 2-21
SET_SELECT_ADDR                        internal static fixed bin(17,0)          initial dcl 2-21
STOP_AUTO_POLL                         internal static fixed bin(17,0)          initial dcl 2-21
Sequential_input                       internal static fixed bin(17,0)          initial dcl 4-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 4-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 4-15
io_call_af_ret                         based           varying char             dcl 5-25
iox_$iocb_version_sentinel             external static char(4)                  dcl 3-51
short_iox_modes                        internal static char(4)                  initial array dcl 4-12

NAMES DECLARED BY EXPLICIT CONTEXT.
abort_attach                    006725 constant        entry                    internal dcl 544 ref 325 329 338 362 389 396 406 415
                                                                                  417 421 434 444 477 483 486 490 494 497 501 503
                                                                                  505 531 538
advance_scanned_data            011334 constant        entry                    internal dcl 1348 ref 1319 1326 1890 1908
advance_unscanned_data          011276 constant        entry                    internal dcl 1336 ref 1117 1123 1127 1130 1137 1147
                                                                                  1162 1175 1178 1183 1199 1220 1227 1238 1248 1254
                                                                                  1265 1273 1281 1285 1294
attach_return                   003667 constant        label                    dcl 521 ref 559
bad_dec_arg                     006650 constant        label                    dcl 536 set ref 533
bisync_                         001150 constant        entry                    external dcl 33
bisync_attach                   001164 constant        entry                    external dcl 307
bisync_close                    004510 constant        entry                    external dcl 659 ref 651
bisync_control                  005340 constant        entry                    external dcl 1395 ref 630 644
bisync_detach                   003674 constant        entry                    external dcl 566 ref 518 682
bisync_get_chars                004774 constant        entry                    external dcl 947 ref 627
bisync_get_line                 005213 constant        entry                    external dcl 1034 ref 628
bisync_io_call                  012076 constant        entry                    internal dcl 1685 ref 1557
bisync_open                     004216 constant        entry                    external dcl 604 ref 517 681
bisync_position                 006366 constant        entry                    external dcl 1874 ref 629
bisync_put_chars                004656 constant        entry                    external dcl 691 ref 643
block                           014647 constant        entry                    internal dcl 2004 ref 416 900 902 1098 1635 1644
                                                                                  1668
check_error_code                014466 constant        entry                    internal dcl 1951 ref 482 485 891 915 1086 1371 1377
                                                                                  1561 1628 1938
check_line_status               014500 constant        entry                    internal dcl 1960 ref 1656 1955
control_return                  006356 constant        label                    dcl 1571 ref 1030 1859 1868
count_dle                       007525 constant        entry                    internal dcl 852 ref 798
cv_dec_arg                      006520 constant        entry                    internal dcl 526 ref 361 365 375 376 377 381
cv_io_call_dec_arg              014211 constant        entry                    internal dcl 1853 ref 1740 1777 1790 1826
cv_io_call_dec_arg_err          014277 constant        label                    dcl 1865 ref 1862
end_write_mode                  011600 constant        entry                    internal dcl 1598 ref 1539
end_write_mode0                 011750 constant        label                    dcl 1642 ref 1679
end_write_mode1                 011754 constant        label                    dcl 1644 ref 1651 1675
end_write_mode_err              011623 constant        label                    dcl 1611 ref 1621 1630 1634 1650 1660 1666 1673
format_nontransparent_block     007120 constant        entry                    internal dcl 736 ref 719
format_transparent_block        007250 constant        entry                    internal dcl 781 ref 718
format_transparent_loop         007272 constant        label                    dcl 796 ref 804
get_chars_join                  005031 constant        label                    dcl 958 ref 1013
get_chars_order                 005132 constant        label                    dcl 1002 ref 1555
get_chars_order_return          005155 constant        label                    dcl 1017 ref 994
get_chars_retry                 005044 constant        label                    dcl 968 ref 991
get_chars_return                005120 constant        label                    dcl 994 ref 965 984 986
get_data_non_trans              000000 constant        label                    array(6) dcl 1113 ref 1111
get_data_non_trans_6a           010616 constant        label                    dcl 1199 ref 1233
get_data_trans                  000006 constant        label                    array(4) dcl 1242 ref 1110
get_more_data                   010135 constant        label                    dcl 1082 ref 1077 1118 1124 1128 1165 1181 1186 1194
                                                                                  1224 1230 1246 1250 1257 1260 1267 1287
hide_away_input                 011372 constant        entry                    internal dcl 1363 ref 895 921 1632 1648 1671
internal_resetread              011543 constant        entry                    internal dcl 1577 ref 676 1406 1415
line_control                    014352 constant        entry                    internal dcl 1926 ref 489 493 496 500 502 631 1447
                                                                                  1458 1553 1664
line_control2                   014443 constant        entry                    internal dcl 1941 ref 504
line_control_join               014367 constant        label                    dcl 1931 ref 1945
line_control_val_set            014373 constant        entry                    internal dcl 1934 ref 1550
maybe_mine_already              002446 constant        label                    dcl 422 ref 413
move_scanned_data               011207 constant        entry                    internal dcl 1309 ref 975 1051
retry_read_status               005515 constant        label                    dcl 1432 ref 1439
rpt_write_error                 004716 constant        label                    dcl 705 ref 725
scan_more_data                  010127 constant        entry                    internal dcl 1070 ref 978 1054 1894 1912
scan_more_data_noblock          010133 constant        entry                    internal dcl 1079 ref 1433
set_control_chars               014617 constant        entry                    internal dcl 1983 ref 453 1459
set_time                        014707 constant        entry                    internal dcl 2019 ref 899 1642 1667
substraddr                      014756 constant        entry                    internal dcl 2032 ref 798 798 913 1340 1352
trans_etx                       011160 constant        label                    dcl 1294 ref 1299
transmit_block                  007601 constant        entry                    internal dcl 874 ref 724 1478 1608 1619
transmit_block_start            007603 constant        label                    dcl 884 ref 941
transmit_block_timed            010120 constant        entry                    internal dcl 935 ref 667 672
transmit_end                    010112 constant        label                    dcl 928 ref 893 903 906 917
use_std_chan                    002466 constant        label                    dcl 430 ref 427

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     16144       16334   15137       16154
Length     17022   15137       170         452    1005           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
bisync_                             821 external procedure  is an external procedure.  
cv_dec_arg                          252 internal procedure  enables or reverts conditions.  
on unit on line 533                  64 on unit               
abort_attach                         85 internal procedure  is called during a stack extension.  
format_nontransparent_block             internal procedure  shares stack frame of external procedure bisync_.  
format_transparent_block                internal procedure  shares stack frame of external procedure bisync_.  
count_dle                               internal procedure  shares stack frame of external procedure bisync_.  
transmit_block                          internal procedure  shares stack frame of external procedure bisync_.  
scan_more_data                          internal procedure  shares stack frame of external procedure bisync_.  
move_scanned_data                       internal procedure  shares stack frame of external procedure bisync_.  
advance_unscanned_data                  internal procedure  shares stack frame of external procedure bisync_.  
advance_scanned_data                    internal procedure  shares stack frame of external procedure bisync_.  
hide_away_input                         internal procedure  shares stack frame of external procedure bisync_.  
internal_resetread                      internal procedure  shares stack frame of external procedure bisync_.  
end_write_mode                          internal procedure  shares stack frame of external procedure bisync_.  
bisync_io_call                          internal procedure  shares stack frame of external procedure bisync_.  
cv_io_call_dec_arg                  254 internal procedure  enables or reverts conditions.  
on unit on line 1862                 64 on unit               
line_control                            internal procedure  shares stack frame of external procedure bisync_.  
check_error_code                        internal procedure  shares stack frame of external procedure bisync_.  
check_line_status                       internal procedure  shares stack frame of external procedure bisync_.  
set_control_chars                       internal procedure  shares stack frame of external procedure bisync_.  
block                                   internal procedure  shares stack frame of external procedure bisync_.  
set_time                                internal procedure  shares stack frame of external procedure bisync_.  
substraddr                              internal procedure  shares stack frame of external procedure bisync_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
bisync_                  000100 com_err_sw                  bisync_
                         000102 adp                         bisync_
                         000104 code                        bisync_
                         000106 iocbp                       bisync_
                         000110 empty_buffer                bisync_
                         000111 mask                        bisync_
                         000112 state                       bisync_
                         000113 i                           bisync_
                         000114 open_mode                   bisync_
                         000115 remaining_len               bisync_
                         000116 offset                      bisync_
                         000120 data_ptr                    bisync_
                         000122 data_len                    bisync_
                         000123 header_len                  bisync_
                         000124 buf_ptr                     bisync_
                         000126 buf_len                     bisync_
                         000130 hbuf_ptr                    bisync_
                         000132 hbuf_len                    bisync_
                         000133 order_sw                    bisync_
                         000134 etb_found                   bisync_
                         000135 etx_found                   bisync_
                         000136 stx_found                   bisync_
                         000137 eot_found                   bisync_
                         000140 soh_found                   bisync_
                         000141 header_found                bisync_
                         000142 data_found                  bisync_
                         000143 nl_found                    bisync_
                         000144 order                       bisync_
                         000154 info_ptr                    bisync_
                         000156 pos_type                    bisync_
                         000157 pos_value                   bisync_
                         000160 caller                      bisync_
                         000170 rpt                         bisync_
                         000174 err                         bisync_
                         000200 my_area_info                bisync_
                         000224 real_transparent            bisync_
                         000225 time_out                    bisync_
                         000226 event_info                  bisync_
                         000235 mode_data                   bisync_
                         000336 dial_msg_chan               bisync_
                         000340 dial_msg_module             bisync_
                         000350 dial_msg_ndialed            bisync_
                         000352 dma                         bisync_
                         000374 dial_msg_flags              bisync_
                         000376 area_infop                  bisync_
                         000400 line_ctl                    bisync_
                         000402 line_stat                   bisync_
                         000404 io_call_infop               bisync_
                         000422 cl                          format_nontransparent_block
                         000423 dl                          format_nontransparent_block
                         000424 etb_sw                      format_nontransparent_block
                         000434 i                           format_transparent_block
                         000435 dl                          format_transparent_block
                         000436 real_chars                  format_transparent_block
                         000437 moved                       format_transparent_block
                         000440 etb_sw                      format_transparent_block
                         000450 i                           count_dle
                         000451 j                           count_dle
                         000452 k                           count_dle
                         000462 i                           transmit_block
                         000463 j                           transmit_block
                         000464 p                           transmit_block
                         000466 time_limit                  transmit_block
                         000470 write_status                transmit_block
                         000502 i                           scan_more_data
                         000503 j                           scan_more_data
                         000504 block_ok                    scan_more_data
                         000506 p                           scan_more_data
                         000516 i                           move_scanned_data
                         000542 read_status                 hide_away_input
                         000546 p                           hide_away_input
                         000556 p                           internal_resetread
                         000566 write_status                end_write_mode
                         000600 i                           bisync_io_call
                         000602 p                           bisync_io_call
                         000604 info                        bisync_io_call
                         000610 auto_rw_status              bisync_io_call
                         000614 event_info_channel          bisync_io_call
                         000616 auto_bsc_modes              bisync_io_call
                         000620 auto_get_chars_info         bisync_io_call

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             alloc_char_temp     call_ent_var_desc   call_ent_var        call_ext_out_desc
call_ext_out        call_int_this_desc  call_int_this       call_int_other_desc return_mac          tra_ext_1
signal_op           enable_op           shorten_stack       ext_entry           ext_entry_desc      int_entry
int_entry_desc      any_to_any_truncate_op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      convert_dial_message_         convert_ipc_code_             define_area_
dial_manager_$dial_out        dial_manager_$privileged_attach                             dial_manager_$release_channel
dial_manager_$release_channel_no_hangup                     hcs_$assign_channel           hcs_$reset_ips_mask
hcs_$set_ips_mask             hcs_$tty_abort                hcs_$tty_attach               hcs_$tty_detach
hcs_$tty_order                hcs_$tty_read                 hcs_$tty_state                hcs_$tty_write
iox_$attach_name              iox_$close                    iox_$control                  iox_$detach_iocb
iox_$err_no_operation         iox_$open                     iox_$propagate                iox_$put_chars
iox_$write_record             ipc_$block                    ipc_$create_ev_chn            ipc_$decl_ev_call_chn
ipc_$decl_ev_wait_chn         ipc_$delete_ev_chn            ipc_$drain_chn                release_area_
timer_manager_$alarm_wakeup   timer_manager_$reset_alarm_wakeup                           timer_manager_$sleep

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$bad_arg          error_table_$bad_mode
error_table_$badopt           error_table_$bisync_bid_fail  error_table_$bisync_block_bad
error_table_$bisync_reverse_interrupt                       error_table_$buffer_big       error_table_$device_parity
error_table_$end_of_info      error_table_$line_status_pending                            error_table_$long_record
error_table_$no_line_status   error_table_$no_operation     error_table_$noarg            error_table_$not_detached
error_table_$resource_attached                              error_table_$wrong_no_of_args sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     57 001143        33 001147       307 001156       309 001203       310 001207       311 001214       313 001216
    314 001220       315 001222       316 001223       317 001225       318 001227       319 001232       320 001235
    321 001237       323 001240       324 001243       325 001245       328 001263       329 001274       330 001315
    331 001323       332 001326       336 001331       337 001336       338 001341       340 001360       341 001377
    342 001402       343 001404       344 001405       345 001407       346 001411       347 001413       348 001415
    349 001416       350 001417       351 001422       352 001433       353 001457       354 001467       355 001474
    356 001477       357 001500       358 001505       359 001507       360 001510       361 001515       362 001527
    364 001577       365 001601       366 001623       367 001635       368 001646       369 001657       370 001670
    371 001701       372 001712       373 001723       374 001734       375 001745       376 001762       377 001777
    378 002014       379 002021       380 002024       381 002025       384 002047       385 002050       386 002055
    387 002056       388 002061       389 002064       391 002103       392 002121       393 002122       395 002133
    396 002136       397 002166       398 002167       402 002171       403 002174       404 002205       405 002207
    406 002216       408 002235       409 002237       410 002242       411 002245       412 002265       413 002300
    415 002306       416 002330       417 002343       419 002365       421 002424       422 002446       427 002451
    428 002453       429 002464       430 002466       431 002500       432 002502       433 002511       434 002514
    440 002533       441 002545       442 002547       443 002556       444 002561       449 002600       450 002603
    451 002606       452 002610       453 002611       457 002612       458 002615       459 002644       460 002725
    461 002730       462 002750       463 002752       464 003005       465 003017       467 003021       469 003022
    470 003055       476 003057       477 003114       478 003136       479 003143       480 003145       481 003150
    482 003205       483 003206       484 003227       485 003266       486 003267       488 003310       489 003313
    490 003316       492 003337       493 003342       494 003345       495 003366       496 003373       497 003400
    500 003421       501 003432       502 003453       503 003464       504 003505       505 003520       509 003541
    510 003547       511 003561       512 003571       513 003616       514 003620       515 003633       516 003637
    517 003641       518 003645       519 003650       520 003657       521 003667       566 003670       568 003705
    569 003711       571 003713       573 003715       574 003717       575 003730       578 003742       580 003755
    581 003760       585 003774       586 004033       587 004052       588 004054       589 004057       590 004062
    591 004065       592 004103       593 004116       594 004130       595 004142       596 004154       597 004157
    598 004166       599 004176       600 004210       604 004211       606 004227       607 004234       608 004236
    610 004240       611 004242       612 004250       613 004253       616 004254       617 004267       618 004271
    619 004272       622 004273       623 004325       625 004326       626 004341       627 004346       628 004353
    629 004356       630 004361       631 004364       633 004367       634 004373       635 004407       636 004411
    637 004414       638 004415       639 004416       640 004420       641 004421       642 004422       643 004427
    644 004434       645 004437       646 004442       647 004453       648 004455       651 004457       652 004464
    653 004466       654 004475       655 004505       659 004506       661 004521       662 004526       663 004530
    666 004532       667 004534       668 004545       669 004546       670 004550       671 004555       672 004557
    674 004563       676 004571       677 004572       679 004601       680 004614       681 004617       682 004623
    683 004626       684 004632       685 004640       686 004650       691 004651       693 004671       694 004676
    695 004700       696 004702       697 004705       699 004707       700 004710       701 004713       704 004714
    705 004716       707 004721       708 004722       711 004723       712 004727       714 004730       715 004732
    717 004734       718 004736       719 004742       720 004743       721 004750       722 004752       724 004755
    725 004756       726 004761       727 004763       728 004764       730 004765       732 004766       947 004767
    949 005007       950 005014       951 005016       952 005021       953 005023       954 005025       955 005026
    956 005027       958 005031       960 005033       962 005035       963 005040       964 005041       965 005043
    968 005044       970 005045       971 005046       972 005047       973 005050       974 005051       975 005056
    978 005070       979 005071       980 005073       981 005074       983 005075       984 005077       985 005103
    986 005106       989 005107       991 005110       994 005120       996 005122       997 005127       998 005131
   1002 005132      1004 005135      1005 005140      1006 005141      1007 005143      1008 005145      1009 005147
   1010 005150      1011 005151      1012 005152      1013 005154      1017 005155      1020 005163      1021 005165
   1022 005170      1024 005172      1025 005174      1026 005177      1027 005204      1030 005210      1034 005211
   1036 005226      1037 005233      1038 005235      1039 005240      1040 005242      1041 005244      1042 005246
   1043 005247      1044 005250      1046 005251      1047 005256      1048 005261      1049 005273      1050 005277
   1051 005301      1052 005307      1054 005310      1055 005311      1056 005313      1057 005314      1060 005315
   1062 005316      1064 005330      1065 005332      1395 005333      1397 005357      1398 005364      1399 005366
   1400 005371      1401 005373      1403 005400      1404 005401      1405 005405      1406 005407      1407 005410
   1408 005411      1409 005415      1410 005417      1411 005420      1412 005422      1413 005423      1414 005427
   1415 005431      1416 005432      1417 005434      1419 005436      1421 005460      1422 005464      1423 005467
   1424 005470      1426 005471      1427 005475      1428 005476      1429 005501      1430 005507      1432 005515
   1433 005522      1434 005523      1435 005532      1436 005534      1437 005536      1438 005540      1439 005541
   1440 005543      1441 005545      1443 005546      1445 005547      1446 005553      1447 005556      1448 005566
   1450 005567      1451 005573      1452 005576      1453 005577      1455 005600      1456 005604      1457 005610
   1458 005615      1459 005624      1460 005625      1462 005626      1463 005632      1464 005637      1465 005645
   1466 005646      1468 005647      1469 005653      1471 005654      1472 005657      1474 005660      1475 005700
   1478 005703      1482 005714      1483 005721      1484 005723      1487 005724      1489 005725      1490 005731
   1492 005741      1493 005742      1495 005751      1497 005752      1499 005753      1500 005757      1501 005762
   1502 005763      1504 005764      1505 005770      1506 005771      1507 005775      1508 006000      1509 006001
   1511 006002      1512 006010      1514 006013      1516 006014      1517 006020      1518 006026      1519 006030
   1520 006031      1522 006032      1523 006036      1525 006057      1526 006070      1527 006075      1529 006076
   1530 006102      1531 006132      1532 006134      1533 006137      1534 006161      1535 006163      1537 006215
   1539 006216      1541 006224      1542 006230      1543 006234      1544 006236      1545 006244      1547 006245
   1548 006253      1549 006263      1550 006264      1551 006266      1553 006267      1555 006277      1557 006303
   1560 006311      1561 006342      1562 006343      1563 006347      1564 006352      1565 006354      1566 006355
   1571 006356      1573 006360      1874 006361      1876 006377      1877 006404      1878 006406      1879 006410
   1880 006412      1882 006414      1883 006422      1884 006425      1887 006426      1888 006434      1889 006441
   1890 006443      1891 006445      1892 006447      1894 006450      1895 006451      1896 006453      1897 006454
   1900 006455      1902 006457      1903 006462      1904 006465      1905 006477      1907 006502      1908 006504
   1910 006506      1912 006507      1913 006510      1914 006512      1915 006513      1918 006514      1920 006515
   1922 006516       526 006517       528 006525       529 006527       530 006534       531 006536       532 006602
    533 006603       534 006622       536 006650       538 006652       540 006717       544 006724       548 006745
    549 006775       550 007003       552 007004       553 007010       554 007031       555 007046       556 007063
    558 007100       559 007115       736 007120       741 007121       742 007127       744 007131       745 007134
    746 007137       747 007142       748 007144       750 007145       751 007147       754 007150       756 007157
    757 007163       759 007174       760 007176       761 007200       762 007203       763 007213       764 007216
    765 007222       766 007226       767 007230       768 007231       769 007235       770 007237       771 007240
    773 007242       774 007243       775 007247       781 007250       786 007251       787 007256       788 007261
    789 007264       790 007266       792 007267       793 007271       796 007272       798 007275       799 007322
    801 007330       802 007333       803 007335       804 007337       807 007340       810 007350       811 007354
    812 007357       813 007361       814 007363       815 007364       816 007367       817 007405       818 007413
    819 007420       820 007423       821 007425       822 007427       823 007430       824 007431       825 007433
    827 007434       828 007442       829 007444       830 007453       831 007455       832 007457       833 007461
    834 007462       836 007464       837 007465       838 007473       839 007504       840 007510       841 007513
    842 007515       844 007517       845 007520       846 007524       852 007525       859 007527       860 007533
    861 007535       862 007536       863 007542       864 007563       865 007567       866 007570       867 007571
    868 007572       878 007576       874 007601       884 007603       886 007604       888 007610       889 007612
    890 007614       891 007654       892 007655       893 007661       894 007663       895 007665       896 007666
    897 007671       898 007675       899 007677       900 007706       901 007721       902 007722       903 007734
    904 007736       905 007742       906 007744       909 007745       911 007746       913 007764       914 010013
    915 010043       916 010044       917 010050       918 010052       919 010072       920 010074       921 010100
    922 010101       923 010104       925 010110       927 010111       928 010112       930 010114       931 010116
    933 010117       935 010120       939 010123       940 010125       941 010126      1070 010127      1076 010130
   1077 010132      1079 010133      1080 010134      1082 010135      1083 010136      1084 010141      1085 010145
   1086 010171      1087 010172      1088 010175      1090 010176      1091 010201      1092 010207      1093 010212
   1094 010215      1096 010220      1097 010222      1098 010225      1099 010240      1100 010243      1102 010244
   1103 010265      1104 010270      1106 010272      1110 010273      1111 010277      1113 010301      1115 010311
   1116 010313      1117 010315      1118 010321      1120 010322      1121 010326      1122 010330      1123 010332
   1124 010336      1126 010337      1127 010345      1128 010351      1130 010352      1131 010356      1132 010360
   1134 010361      1136 010373      1137 010375      1138 010401      1139 010403      1140 010411      1141 010413
   1143 010414      1144 010416      1145 010430      1146 010431      1147 010433      1148 010437      1149 010441
   1150 010447      1151 010451      1153 010452      1154 010457      1158 010463      1159 010470      1160 010472
   1161 010504      1162 010506      1163 010512      1164 010520      1165 010522      1166 010524      1167 010526
   1168 010527      1172 010530      1173 010537      1174 010541      1175 010542      1176 010544      1178 010545
   1180 010551      1181 010554      1183 010555      1185 010561      1186 010564      1188 010565      1191 010575
   1192 010577      1194 010601      1196 010602      1198 010614      1199 010616      1201 010622      1202 010624
   1203 010632      1204 010634      1206 010635      1207 010647      1208 010657      1209 010665      1210 010677
   1211 010704      1212 010712      1213 010714      1214 010716      1215 010717      1216 010720      1218 010721
   1219 010723      1220 010732      1221 010736      1222 010740      1223 010741      1224 010744      1226 010745
   1227 010752      1228 010756      1229 010764      1230 010766      1232 010767      1233 010773      1235 010774
   1236 010776      1237 011000      1238 011001      1239 011003      1242 011004      1244 011016      1245 011017
   1246 011020      1248 011021      1249 011023      1250 011026      1252 011027      1254 011034      1255 011040
   1256 011043      1257 011045      1259 011046      1260 011050      1262 011051      1264 011063      1265 011065
   1266 011071      1267 011074      1269 011075      1270 011102      1271 011104      1272 011106      1273 011107
   1274 011111      1276 011112      1278 011122      1279 011124      1280 011125      1281 011127      1282 011133
   1284 011134      1285 011140      1286 011144      1287 011147      1288 011151      1289 011153      1293 011154
   1294 011160      1295 011164      1296 011167      1297 011171      1299 011172      1300 011200      1301 011202
   1302 011204      1303 011206      1309 011207      1314 011211      1315 011213      1316 011217      1317 011225
   1318 011236      1319 011237      1320 011245      1322 011247      1324 011250      1325 011260      1326 011262
   1327 011270      1328 011273      1330 011275      1336 011276      1340 011300      1341 011327      1342 011333
   1348 011334      1352 011336      1353 011365      1354 011371      1363 011372      1368 011373      1369 011375
   1370 011400      1371 011437      1372 011440      1373 011443      1374 011445      1375 011460      1377 011510
   1378 011511      1379 011513      1380 011522      1382 011523      1383 011526      1384 011530      1385 011531
   1386 011532      1388 011541      1389 011542      1577 011543      1581 011544      1582 011547      1583 011551
   1585 011552      1586 011557      1587 011562      1588 011570      1589 011573      1590 011576      1591 011577
   1598 011600      1602 011601      1603 011604      1604 011607      1607 011610      1608 011614      1609 011615
   1610 011620      1611 011623      1613 011626      1614 011627      1617 011630      1618 011634      1619 011636
   1620 011637      1621 011642      1625 011645      1626 011647      1627 011652      1628 011712      1629 011713
   1630 011716      1631 011721      1632 011723      1633 011724      1634 011727      1635 011732      1636 011744
   1638 011747      1642 011750      1644 011754      1646 011767      1647 011772      1648 011776      1649 011777
   1650 012002      1651 012005      1656 012006      1657 012007      1658 012015      1659 012017      1660 012020
   1664 012022      1665 012025      1666 012030      1667 012033      1668 012037      1669 012052      1670 012055
   1671 012061      1672 012062      1673 012065      1674 012070      1675 012072      1676 012074      1679 012075
   1685 012076      1704 012077      1705 012101      1706 012105      1707 012110      1708 012114      1710 012120
   1711 012124      1712 012154      1715 012211      1717 012212      1718 012216      1719 012220      1720 012250
   1723 012305      1725 012306      1726 012312      1727 012314      1728 012345      1731 012402      1733 012403
   1734 012407      1735 012442      1737 012471      1739 012472      1740 012476      1741 012510      1742 012544
   1744 012545      1745 012551      1746 012605      1748 012632      1750 012633      1751 012637      1752 012641
   1753 012643      1754 012645      1755 012655      1756 012700      1757 012710      1758 012720      1760 012730
   1762 012764      1763 012765      1765 012766      1766 012770      1767 013024      1769 013025      1770 013031
   1771 013065      1774 013124      1776 013125      1777 013131      1778 013143      1779 013173      1781 013174
   1782 013200      1783 013230      1785 013255      1787 013256      1788 013262      1790 013316      1791 013330
   1793 013361      1795 013362      1796 013366      1797 013417      1799 013461      1801 013462      1802 013466
   1804 013474      1805 013476      1806 013507      1807 013511      1808 013517      1809 013546      1811 013554
   1813 013555      1814 013561      1816 013620      1817 013622      1818 013633      1819 013635      1820 013643
   1821 013675      1823 013703      1825 013704      1826 013710      1827 013722      1828 013724      1829 013734
   1830 013745      1831 013750      1832 014002      1833 014004      1834 014032      1836 014074      1839 014143
   1840 014144      1841 014152      1842 014155      1844 014156      1846 014207      1853 014210      1857 014216
   1858 014224      1859 014226      1862 014231      1863 014250      1865 014277      1867 014345      1868 014347
   1926 014352      1930 014354      1931 014367      1934 014372      1936 014375      1937 014401      1938 014441
   1939 014442      1941 014443      1943 014445      1944 014461      1945 014465      1951 014466      1953 014467
   1954 014472      1955 014476      1956 014477      1960 014500      1962 014501      1963 014540      1964 014543
   1965 014554      1966 014562      1967 014570      1968 014576      1969 014600      1970 014603      1973 014611
   1974 014613      1975 014615      1977 014616      1983 014617      1985 014620      1986 014623      1987 014625
   1988 014627      1989 014631      1990 014633      1991 014635      1992 014637      1993 014641      1995 014642
   1996 014644      1998 014646      2004 014647      2009 014651      2010 014654      2011 014656      2012 014675
   2013 014706      2019 014707      2023 014711      2024 014721      2025 014733      2026 014755      2032 014756
   2038 014767


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
