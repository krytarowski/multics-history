	COMPILATION LISTING OF SEGMENT rcm_get_record_by_id
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/24/88  1534.9 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION
        8*
        9*          Gets the record or set of records specified by the caller. Records
       10*     are returned as simple_typed_vectors allocated in the provided area. If
       11*     called by the array entry point, these vectors are combined in a
       12*     typed_vector_array. 
       13*          This routine always gets the record collection's opening information.
       14*     A later performance gain can be achieved by adding single_info and
       15*     array_info entry points that take pointers to opening information.
       16**/
       17 
       18 /* HISTORY:
       19*Written by Matthew Pierret 04/23/82.
       20*Modified:
       21*08/20/82 by Matthew Pierret:  Made enter-able only by the entry points single 
       22*            and array.  Added use of rm_get_opening_info, which is in reality
       23*            simply the field_table.
       24*10/14/82 by Matthew Pierret:  Made to set p_typed_vector_array_ptr before 
       25*            returning.  Made to use dmu_$cv_table_to_typed_array.
       26*10/20/82 by Matthew Pierret:  Changed to incrementally up the number of vectors
       27*            in the output typed_vector_array as each new record is retrieved.
       28*01/04/83 by Lindsey Spratt:  Changed to allow calls to cm_$get_element to
       29*	  allocate a new buffer when the provided buffer is too small.
       30*02/09/83 by Lindsey Spratt:  Changed to use the
       31*	  data_mgmt_util_$new_cv_string_to_vector entry instead of
       32*	  $cv_string_to_vector.  The difference is that the $new_* entry
       33*	  will re-use an input vector rather than allocating a new one, if
       34*	  the input vector_ptr is non-null, rather than the old behavior of
       35*	  always allocating a new vector regardless of the value of the
       36*	  input vector_ptr.  Only the $single entry is actually set up to
       37*	  take advantage of this feature.
       38*03/16/83 by Matthew Pierret: Changed to receive record_collection_opening_info
       39*            structure from rm_get_opening_info, use get_dm_free_area_ () 
       40*            instead of dm_data_$area_ptr, use dm_error_$wrong_cursor_type,
       41*            convert some collection_manager_ error codes to $record_not_found.
       42*            Added cleanup handler. Moved record_cursor type check before
       43*            version check.
       44*03/24/83 by Lindsey Spratt:  Removed reference to the field_table include
       45*	  file, declared field_table_ptr locally.
       46*07/28/83 by Matthew Pierret: Changed name from rm_get_record_by_id to
       47*            rcm_get_record_by_id, and all rm_ prefixes to rcm_.
       48*04/12/84 by Lee Baldwin:  Renamed the parameters to coincide with all the other
       49*            rcm_XX routines.  Removed the p_typed_vector_type and
       50*            p_typed_vector_array_version parameters because they aren't used.
       51*05/10/84 by Matthew Pierret:  Changed to align the record buffer on an even
       52*            word.  Changed references to data_mgmt_util_ to be to
       53*            data_format_util_.  Removed declarations of un-used variables.
       54*06/07/84 by Matthew Pierret:  Re-named cm_$get_element to cm_$get.
       55*09/27/84 by Maggie Sharpe:  Changed the call to sub_err in CHECK_VERSION and
       56*            CHECK_VERSION_CHAR_8 to use new flag parameter for restart option;
       57*	  removed a (harmless) duplicate statement; cleaned up dcls.
       58*03/19/85 by Lindsey L. Spratt:  Fixed to handle the TUPLE_ID_FIELD_ID.
       59*03/20/85 by Lindsey L. Spratt:  Fixed to set aor_vector_ptr equal to
       60*            aor_p_result_ptr for the CREATE_OUTPUT_RECORD process.
       61**/
       62 /* format: style2,ind3 */
       63 
       64 /* format: style2,ind3 */
       65 
       66 rcm_get_record_by_id:
       67    proc ();
       68 
       69       return;					/* Not a real entry */
       70 
       71 /* START OF DECLARATIONS */
       72 /* Parameter */
       73 
       74       dcl	    p_record_cursor_ptr    ptr;
       75       dcl	    p_simple_typed_vector_ptr
       76 			       ptr;
       77       dcl	    p_typed_vector_array_ptr
       78 			       ptr;
       79       dcl	    p_work_area_ptr	       ptr;
       80       dcl	    p_id_list_ptr	       ptr;
       81       dcl	    p_element_id_list_ptr  ptr;
       82       dcl	    p_record_id	       bit (36) aligned;
       83       dcl	    p_code	       fixed bin (35);
       84 
       85 /* Automatic */
       86 
       87       dcl	    get_array_of_records   bit (1) aligned init ("0"b);
       88       dcl	    get_single_record      bit (1) aligned init ("0"b);
       89       dcl	    record_id	       bit (36) aligned;
       90       dcl	    record_id_field_id     fixed bin init (DEFAULT_RECORD_ID_FIELD_ID);
       91       dcl	    record_idx	       fixed bin;
       92       dcl	    record_string_length   fixed bin (35);
       93       dcl	    record_string_ptr      ptr init (null);
       94       dcl	    field_table_ptr	       ptr init (null);
       95       dcl	    descriptor_string_ptr  ptr init (null);
       96       dcl	    local_record_buffer    (DOUBLE_WORDS_PER_PAGE) fixed bin (71);
       97 						/* This declaration forces an even-word boundary */
       98       dcl	    new_buffer_was_allocated
       99 			       bit (1) aligned init ("0"b);
      100       dcl	    record_buffer_ptr      ptr init (null);
      101       dcl	    record_buffer_length   fixed bin (35) init (BITS_PER_PAGE);
      102       dcl	    dm_work_area_ptr       ptr init (null);
      103 
      104 /* Based */
      105 
      106       dcl	    dm_work_area	       area based (dm_work_area_ptr);
      107       dcl	    record_buffer	       based (record_buffer_ptr) bit (record_buffer_length) aligned;
      108 
      109 /* Builtin */
      110 
      111       dcl	    (addr, hbound, null)   builtin;
      112 
      113 /* Condition */
      114 
      115       dcl	    cleanup	       condition;
      116 
      117 /* Constant */
      118 
      119       dcl	    (
      120 	    AREA_IS_BIG_ENOUGH     init (1),
      121 	    AREA_IS_TOO_SMALL      init (2),
      122 	    BITS_PER_PAGE	       init (1024 * 36),
      123 	    DEFAULT_RECORD_ID_FIELD_ID
      124 			       init (-1),
      125 	    DOUBLE_WORDS_PER_PAGE  init (512),
      126 	    VECTOR_SLOT_INCREMENT  init (500)
      127 	    )		       fixed bin internal static options (constant);
      128 
      129       dcl	    (
      130 	    FREE_OLD_TYPED_VECTOR_ARRAY
      131 			       init ("1"b),
      132 	    TRUE		       init ("1"b),
      133 	    FALSE		       init ("0"b)
      134 	    )		       bit (1) aligned internal static options (constant);
      135 
      136       dcl	    myname	       init ("rcm_get_record_by_id") char (32) varying internal static options (constant);
      137 
      138 /* Entry */
      139 
      140       dcl	    rcm_get_opening_info   entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
      141       dcl	    data_format_util_$new_cv_string_to_vector
      142 			       entry (ptr, ptr, ptr, fixed bin (35), ptr, ptr, fixed bin (35));
      143       dcl	    data_format_util_$cv_table_to_typed_array
      144 			       entry (ptr, ptr, ptr, fixed bin (35), ptr, fixed bin (35));
      145       dcl	    dm_vector_util_$append_simple_typed_vector
      146 			       entry options (variable) returns (ptr);
      147       dcl	    dm_vector_util_$free_typed_vector
      148 			       entry (ptr, ptr, ptr, fixed bin (35));
      149       dcl	    sub_err_	       entry options (variable);
      150       dcl	    get_dm_free_area_      entry () returns (ptr);
      151 
      152 /* External */
      153 
      154       dcl	    (
      155 	    error_table_$area_too_small,
      156 	    error_table_$unimplemented_version,
      157 	    dm_error_$record_not_found,
      158 	    dm_error_$wrong_cursor_type
      159 	    )		       fixed bin (35) ext;
      160 
      161 /* END OF DECLARATIONS */
      162 
      163 single:
      164    entry (p_record_id, p_id_list_ptr, p_work_area_ptr, p_record_cursor_ptr, p_simple_typed_vector_ptr, p_code);
      165 
      166       get_single_record = "1"b;
      167       record_id = p_record_id;
      168       simple_typed_vector_ptr = p_simple_typed_vector_ptr;
      169       typed_vector_array_ptr = null ();
      170       goto JOIN;
      171 
      172 
      173 array:
      174    entry (p_element_id_list_ptr, p_id_list_ptr, p_work_area_ptr, p_record_cursor_ptr, p_typed_vector_array_ptr, p_code);
      175 
      176       element_id_list_ptr = p_element_id_list_ptr;
      177 
      178       call CHECK_VERSION ((element_id_list.version), (ELEMENT_ID_LIST_VERSION_1), "element_id_list");
      179 
      180       record_id = element_id_list.id (1);
      181       get_single_record = "0"b;
      182       simple_typed_vector_ptr = null;
      183       typed_vector_array_ptr = p_typed_vector_array_ptr;
      184       goto JOIN;
      185 
      186 
      187 JOIN:
      188       p_code = 0;
      189 
      190       record_cursor_ptr = p_record_cursor_ptr;
      191 
      192       if record_cursor.type ^= RECORD_CURSOR_TYPE
      193       then call sub_err_ (dm_error_$wrong_cursor_type, myname, ACTION_CANT_RESTART, null, 0,
      194 	      "^/Expected record cursor, type ^d; received type ^d.", RECORD_CURSOR_TYPE, record_cursor.type);
      195 
      196       call CHECK_VERSION ((record_cursor.version), (RECORD_CURSOR_VERSION_2), "record_cursor");
      197 
      198 
      199       call rcm_get_opening_info (record_cursor.file_opening_id, record_cursor.collection_id,
      200 	 record_collection_opening_info_ptr, p_code);
      201       if p_code ^= 0
      202       then return;
      203 
      204       call CHECK_VERSION_CHAR_8 (record_collection_opening_info.version, RECORD_COLLECTION_OPENING_INFO_VERSION_1,
      205 	 "record_collection_opening_info");
      206 
      207       field_table_ptr = record_collection_opening_info.field_table_ptr;
      208 
      209       dm_work_area_ptr = get_dm_free_area_ ();
      210 
      211       record_buffer_ptr = addr (local_record_buffer);
      212 
      213       on cleanup call FINISH ();
      214 
      215       call SETUP_ID_LIST (p_id_list_ptr, id_list_ptr, record_id_field_id);
      216 
      217       call collection_manager_$get (record_cursor.file_opening_id, record_cursor.collection_id, record_id, 0,
      218 	 record_buffer_ptr, record_buffer_length, dm_work_area_ptr, new_buffer_was_allocated, record_string_ptr,
      219 	 record_string_length, p_code);
      220       if p_code ^= 0
      221       then call GET_ELEMENT_ERROR_RETURN (p_code);
      222 
      223       if new_buffer_was_allocated
      224       then
      225          do;
      226 	  record_buffer_ptr = record_string_ptr;
      227 	  record_buffer_length = record_string_length;
      228          end;
      229 
      230 
      231       call CREATE_OUTPUT_RECORD (record_string_ptr, record_string_length, simple_typed_vector_ptr, field_table_ptr,
      232 	 p_work_area_ptr, id_list_ptr, record_id_field_id, record_id, (0));
      233 
      234       if get_single_record
      235       then p_simple_typed_vector_ptr = simple_typed_vector_ptr;
      236       else
      237 GET_REST_OF_RECORDS:
      238          do;
      239 	  call SETUP_OUTPUT_RECORDS (typed_vector_array_ptr, hbound (element_id_list.id, 1), record_id_field_id,
      240 	       field_table_ptr, id_list_ptr, p_work_area_ptr, typed_vector_array_ptr);
      241 
      242 	  typed_vector_array.number_of_vectors = 1;
      243 	  typed_vector_array.vector_slot (1) = simple_typed_vector_ptr;
      244 
      245 	  do record_idx = 2 to hbound (element_id_list.id, 1);
      246 
      247 	     record_id = element_id_list.id (record_idx);
      248 
      249 	     call collection_manager_$get (record_cursor.file_opening_id, record_cursor.collection_id, record_id, 0,
      250 		record_buffer_ptr, record_buffer_length, dm_work_area_ptr, new_buffer_was_allocated,
      251 		record_string_ptr, record_string_length, p_code);
      252 	     if p_code ^= 0
      253 	     then call GET_ELEMENT_ERROR_RETURN (p_code);
      254 
      255 	     if new_buffer_was_allocated
      256 	     then
      257 	        do;
      258 		 if record_buffer_ptr ^= addr (local_record_buffer)
      259 		 then free record_buffer in (dm_work_area);
      260 		 record_buffer_ptr = record_string_ptr;
      261 		 record_buffer_length = record_string_length;
      262 	        end;
      263 	     call APPEND_OUTPUT_RECORD (record_string_ptr, record_string_length, typed_vector_array_ptr,
      264 		field_table_ptr, p_work_area_ptr, id_list_ptr, record_id_field_id, record_id, (0));
      265 	  end;
      266 	  p_typed_vector_array_ptr = typed_vector_array_ptr;
      267 
      268          end GET_REST_OF_RECORDS;
      269 
      270       record_cursor.record_id = record_id;
      271       record_cursor.flags.position_is_valid = "1"b;
      272 
      273       call FINISH;
      274 RETURN:
      275       return;
      276 
      277 FINISH:
      278    proc;
      279       if record_buffer_ptr ^= addr (local_record_buffer)
      280       then free record_buffer in (dm_work_area);
      281    end FINISH;
      282 
      283 
      284 ERROR_RETURN:
      285    proc (er_p_code);
      286       dcl	    er_p_code	       fixed bin (35) parm;
      287 
      288 
      289       call FINISH ();
      290       p_code = er_p_code;
      291       goto RETURN;
      292 
      293    end ERROR_RETURN;
      294 
      295 APPEND_OUTPUT_RECORD:
      296    proc (aor_p_record_string_ptr, aor_p_record_string_length, aor_p_result_ptr, aor_p_field_table_ptr,
      297         aor_p_work_area_ptr, aor_p_id_list_ptr, aor_p_record_id_field_id, aor_p_record_id, aor_p_area_status);
      298 
      299       dcl	    aor_p_record_string_ptr
      300 			       ptr parameter;
      301       dcl	    aor_p_record_string_length
      302 			       fixed bin (35) parameter;
      303       dcl	    aor_p_result_ptr       ptr parameter;
      304       dcl	    aor_p_field_table_ptr  ptr parameter;
      305       dcl	    aor_p_work_area_ptr    ptr parameter;
      306       dcl	    aor_p_id_list_ptr      ptr parameter;
      307       dcl	    aor_p_record_id_field_id
      308 			       fixed bin parameter;
      309       dcl	    aor_p_record_id	       bit (36) aligned parameter;
      310       dcl	    aor_p_area_status      fixed bin parm;
      311 
      312       dcl	    aor_p_work_area	       based (aor_p_work_area_ptr) area;
      313 
      314       dcl	    aor_vector_ptr	       ptr init (null ());
      315       dcl	    aor_record_id_ptr      ptr init (null ());
      316       dcl	    aor_set_result_ptr_to_new_vector
      317 			       bit (1) aligned init ("0"b);
      318       dcl	    aor_typed_vector_array_ptr
      319 			       ptr init (null ());
      320       dcl	    aor_code	       fixed bin (35);
      321 
      322       aor_typed_vector_array_ptr = aor_p_result_ptr;
      323       aor_set_result_ptr_to_new_vector = "0"b;
      324 
      325       aor_code = 0;
      326 
      327       aor_vector_ptr =
      328 	 dm_vector_util_$append_simple_typed_vector (aor_p_work_area_ptr, VECTOR_SLOT_INCREMENT,
      329 	 FREE_OLD_TYPED_VECTOR_ARRAY, aor_typed_vector_array_ptr, aor_code);
      330       if aor_code ^= 0
      331       then if aor_code = error_table_$area_too_small
      332 	 then call AOR_RETURN (AREA_IS_TOO_SMALL);
      333 	 else call ERROR_RETURN (aor_code);
      334       goto AOR_JOIN;
      335 
      336 CREATE_OUTPUT_RECORD:
      337    entry (aor_p_record_string_ptr, aor_p_record_string_length, aor_p_result_ptr, aor_p_field_table_ptr,
      338         aor_p_work_area_ptr, aor_p_id_list_ptr, aor_p_record_id_field_id, aor_p_record_id, aor_p_area_status);
      339       aor_typed_vector_array_ptr = null ();
      340       aor_vector_ptr = aor_p_result_ptr;
      341       aor_set_result_ptr_to_new_vector = "1"b;
      342 AOR_JOIN:
      343       call data_format_util_$new_cv_string_to_vector (aor_p_field_table_ptr, aor_p_work_area_ptr, aor_p_record_string_ptr,
      344 	 aor_p_record_string_length, aor_p_id_list_ptr, aor_vector_ptr, aor_code);
      345       if aor_code ^= 0
      346       then if aor_code = error_table_$area_too_small
      347 	 then
      348 	    do;
      349 	       if aor_typed_vector_array_ptr ^= null ()
      350 	       then
      351 		do;
      352 		   aor_typed_vector_array_ptr -> typed_vector_array.number_of_vectors =
      353 		        aor_typed_vector_array_ptr -> typed_vector_array.number_of_vectors - 1;
      354 		   call dm_vector_util_$free_typed_vector (aor_p_work_area_ptr, aor_typed_vector_array_ptr,
      355 		        aor_vector_ptr, aor_code);
      356 		   if aor_code ^= 0
      357 		   then call ERROR_RETURN (aor_code);
      358 		end;
      359 	       call AOR_RETURN (AREA_IS_TOO_SMALL);
      360 	    end;
      361 	 else call ERROR_RETURN (aor_code);
      362 
      363       if aor_p_record_id_field_id ^= DEFAULT_RECORD_ID_FIELD_ID
      364       then
      365          do;
      366 	  alloc element_id in (aor_p_work_area) set (aor_record_id_ptr);
      367 	  aor_vector_ptr -> simple_typed_vector.dimension (aor_p_record_id_field_id).value_ptr = aor_record_id_ptr;
      368 	  unspec (aor_record_id_ptr -> element_id) = aor_p_record_id;
      369          end;
      370 
      371       call AOR_RETURN (AREA_IS_BIG_ENOUGH);
      372 AOR_MAIN_RETURN:
      373       return;
      374 
      375 AOR_RETURN:
      376    proc (aorr_p_area_status);
      377       dcl	    aorr_p_area_status     fixed bin parm;
      378       aor_p_area_status = aorr_p_area_status;
      379       if aor_set_result_ptr_to_new_vector
      380       then aor_p_result_ptr = aor_vector_ptr;
      381       else aor_p_result_ptr = aor_typed_vector_array_ptr;
      382       goto AOR_MAIN_RETURN;
      383    end AOR_RETURN;
      384 
      385    end APPEND_OUTPUT_RECORD;
      386 
      387 GET_ELEMENT_ERROR_RETURN:
      388    proc (p_code);
      389 
      390       dcl	    p_code	       fixed bin (35);
      391       dcl	    (
      392 	    dm_error_$ci_not_allocated,
      393 	    dm_error_$ci_not_in_collection,
      394 	    dm_error_$no_element
      395 	    )		       fixed bin (35) ext;
      396 
      397       if p_code = dm_error_$no_element
      398       then p_code = dm_error_$record_not_found;
      399       if p_code = dm_error_$ci_not_in_collection
      400       then p_code = dm_error_$record_not_found;
      401       if p_code = dm_error_$ci_not_allocated
      402       then p_code = dm_error_$record_not_found;
      403 
      404       call ERROR_RETURN (p_code);
      405 
      406    end GET_ELEMENT_ERROR_RETURN;
      407 
      408 
      409 SETUP_ID_LIST:
      410    proc (sil_p_input_id_list_ptr, sil_p_output_id_list_ptr, sil_p_record_id_field_id);
      411 
      412       dcl	    sil_p_input_id_list_ptr
      413 			       ptr parameter;
      414       dcl	    sil_p_output_id_list_ptr
      415 			       ptr parameter;
      416       dcl	    sil_p_record_id_field_id
      417 			       fixed bin;
      418 
      419       sil_p_output_id_list_ptr = sil_p_input_id_list_ptr;
      420       if sil_p_output_id_list_ptr = null ()
      421       then
      422          do;
      423 	  sil_p_record_id_field_id = DEFAULT_RECORD_ID_FIELD_ID;
      424          end;
      425       else
      426          do;
      427 	  call CHECK_VERSION (sil_p_output_id_list_ptr -> id_list.version, (ID_LIST_VERSION_1), "id_list");
      428 	  if sil_p_output_id_list_ptr -> id_list.number_of_ids = 0
      429 	  then
      430 	     do;
      431 	        sil_p_output_id_list_ptr = null ();
      432 	        sil_p_record_id_field_id = DEFAULT_RECORD_ID_FIELD_ID;
      433 	     end;
      434 	  else
      435 	     do;
      436 	        if sil_p_output_id_list_ptr -> id_list.id (sil_p_output_id_list_ptr -> id_list.number_of_ids)
      437 		   = DEFAULT_RECORD_ID_FIELD_ID
      438 	        then sil_p_record_id_field_id = sil_p_output_id_list_ptr -> id_list.number_of_ids;
      439 	        else sil_p_record_id_field_id = DEFAULT_RECORD_ID_FIELD_ID;
      440 	     end;
      441          end;
      442 
      443       return;
      444 
      445    end SETUP_ID_LIST;
      446 
      447 SETUP_OUTPUT_RECORDS:
      448    proc (sor_p_input_tva_ptr, sor_p_maximum_number_of_records, sor_p_record_id_field_id, sor_p_field_table_ptr,
      449         sor_p_id_list_ptr, sor_p_work_area_ptr, sor_p_output_tva_ptr);
      450 
      451       dcl	    sor_p_input_tva_ptr    ptr parameter parameter;
      452       dcl	    sor_p_maximum_number_of_records
      453 			       fixed bin (35) parameter;
      454       dcl	    sor_p_record_id_field_id
      455 			       fixed bin parameter;
      456       dcl	    sor_p_field_table_ptr  ptr parameter;
      457       dcl	    sor_p_id_list_ptr      ptr parameter;
      458       dcl	    sor_p_work_area_ptr    ptr parameter;
      459       dcl	    sor_p_output_tva_ptr   ptr parameter;
      460 
      461       dcl	    sor_p_work_area	       area based (sor_p_work_area_ptr);
      462 
      463       dcl	    sor_record_id_descriptor_ptr
      464 			       ptr;
      465       dcl	    sor_code	       fixed bin (35);
      466 
      467       if sor_p_input_tva_ptr = null ()
      468       then
      469          do;
      470 	  sor_code = 0;
      471 	  call data_format_util_$cv_table_to_typed_array (sor_p_field_table_ptr, sor_p_id_list_ptr, sor_p_work_area_ptr,
      472 	       (VECTOR_SLOT_INCREMENT), sor_p_output_tva_ptr, sor_code);
      473 	  if sor_code ^= 0
      474 	  then call ERROR_RETURN (sor_code);
      475 	  call CHECK_VERSION (sor_p_output_tva_ptr -> typed_vector_array.version, TYPED_VECTOR_ARRAY_VERSION_2,
      476 	       "typed_vector_array");
      477 	  if sor_p_record_id_field_id ^= DEFAULT_RECORD_ID_FIELD_ID
      478 	  then
      479 	     do;
      480 	        alloc arg_descriptor in (sor_p_work_area) set (sor_record_id_descriptor_ptr);
      481 	        sor_record_id_descriptor_ptr -> arg_descriptor.flag = TRUE;
      482 	        sor_record_id_descriptor_ptr -> arg_descriptor.type = bit_dtype;
      483 	        sor_record_id_descriptor_ptr -> arg_descriptor.packed = FALSE;
      484 	        sor_record_id_descriptor_ptr -> arg_descriptor.number_dims = 0;
      485 	        sor_record_id_descriptor_ptr -> arg_descriptor.size = 36;
      486 	        sor_p_output_tva_ptr -> typed_vector_array.dimension_table (sor_p_record_id_field_id).name = "0";
      487 	        sor_p_output_tva_ptr -> typed_vector_array.dimension_table (sor_p_record_id_field_id).descriptor_ptr =
      488 		   sor_record_id_descriptor_ptr;
      489 	     end;
      490          end;
      491       else
      492          do;
      493 	  sor_p_output_tva_ptr = sor_p_input_tva_ptr;
      494 	  call CHECK_VERSION (sor_p_output_tva_ptr -> typed_vector_array.version, TYPED_VECTOR_ARRAY_VERSION_2,
      495 	       "typed_vector_array");
      496          end;
      497 
      498       return;
      499 
      500    end SETUP_OUTPUT_RECORDS;
      501 
      502 CHECK_VERSION:
      503    proc (p_received_version, p_expected_version, p_structure_name);
      504 
      505       dcl	    p_received_version     fixed bin (35);
      506       dcl	    p_expected_version     fixed bin (35);
      507       dcl	    p_structure_name       char (*);
      508 
      509       if p_received_version ^= p_expected_version
      510       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      511 	      "^/Expected version ^d of the ^a structure.
      512 Received version ^d, instead.", p_expected_version, p_structure_name, p_received_version);
      513 
      514    end CHECK_VERSION;
      515 
      516 
      517 CHECK_VERSION_CHAR_8:
      518    proc (p_given_version, p_correct_version, p_structure_name);
      519 
      520       dcl	    p_structure_name       char (*);
      521       dcl	    p_given_version	       char (8) aligned;
      522       dcl	    p_correct_version      char (8) aligned;
      523 
      524       if p_given_version ^= p_correct_version
      525       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      526 	      "^/Expected version ""^8a"" of ^a structure; received ""^8a"".", p_correct_version, p_structure_name,
      527 	      p_given_version);
      528 
      529       return;
      530 
      531    end CHECK_VERSION_CHAR_8;
      532 
  1     1 /* BEGIN INCLUDE FILE ... arg_descriptor.incl.pl1
  1     2*
  1     3*   James R. Davis 1 Mar 79 */
  1     4 /* Modified June 83 JMAthane for extended arg descriptor format */
  1     5 
  1     6      dcl	   1 arg_descriptor	      based (arg_descriptor_ptr) aligned,
  1     7 	     2 flag	      bit (1) unal,
  1     8 	     2 type	      fixed bin (6) unsigned unal,
  1     9 	     2 packed	      bit (1) unal,
  1    10 	     2 number_dims	      fixed bin (4) unsigned unal,
  1    11 	     2 size	      fixed bin (24) unsigned unal;
  1    12 
  1    13      dcl	   1 fixed_arg_descriptor based (arg_descriptor_ptr) aligned,
  1    14 	     2 flag	      bit (1) unal,
  1    15 	     2 type	      fixed bin (6) unsigned unal,
  1    16 	     2 packed	      bit (1) unal,
  1    17 	     2 number_dims	      fixed bin (4) unsigned unal,
  1    18 	     2 scale	      fixed bin (11) unal,
  1    19 	     2 precision	      fixed bin (12) unsigned unal;
  1    20 
  1    21      dcl	   1 extended_arg_descriptor based (arg_descriptor_ptr) aligned,
  1    22 	     2 flag	      bit (1) unal,		/* = "1"b */
  1    23 	     2 type	      fixed bin (6) unsigned unal, /* = 58 */
  1    24 	     2 packed	      bit (1) unal,		/* significant if number_dims ^= 0 */
  1    25 	     2 number_dims	      fixed (4) unsigned unal,/* number of variable dimensions */
  1    26 	     2 size	      bit (24) unal,
  1    27 	     2 dims	      (0 refer (extended_arg_descriptor.number_dims)), /* part referenced by called generated code */
  1    28 	       3 low	      fixed bin (35),
  1    29 	       3 high	      fixed bin (35),
  1    30 	       3 multiplier	      fixed bin (35),	/* in bits if packed, in words if not */
  1    31 	     2 real_type	      fixed bin (18) unsigned unal,
  1    32 	     2 type_offset	      fixed bin (18) unsigned unal; /* offset rel to symbol tree to symbol node for type, if any */
  1    33 
  1    34      dcl	   arg_descriptor_ptr     ptr;
  1    35 
  1    36      dcl	   extended_arg_type      fixed bin init (58);
  1    37 
  1    38 /* END INCLUDE file .... arg_descriptor.incl.pl1  */
      533 
      534 
  2     1 /* BEGIN INCLUDE FILE - dm_rcm_cursor.incl.pl1 */
  2     2 
  2     3 /* HISTORY:
  2     4*Written by Matthew Pierret, 04/05/82.
  2     5*Modified:
  2     6*08/19/82 by Matthew Pierret:  Version 2. Changed collection_id to 
  2     7*            bit (36) aligned.
  2     8*07/28/83 by Matthew Pierret: Changed name from dm_rm_cursor.incl.pl1 to
  2     9*            dm_rcm_cursor.incl.pl1.
  2    10*04/13/84 by Lee Baldwin:  Renamed pf_opening_id to file_opening_id to coincide
  2    11*            with the naming conventions used in the rcm_XX routines.
  2    12**/
  2    13 
  2    14 /* format: style2,ind3 */
  2    15      dcl	   1 record_cursor	      aligned based (record_cursor_ptr),
  2    16 	     2 type	      fixed bin (17) unaligned,
  2    17 	     2 version	      fixed bin (17) unaligned,
  2    18 	     2 flags,
  2    19 	       3 position_is_valid
  2    20 			      bit (1) unal,
  2    21 	       3 pad	      bit (35) unal,
  2    22 	     2 area_ptr	      ptr,
  2    23 	     2 file_opening_id    bit (36) aligned,
  2    24 	     2 collection_id      bit (36) aligned,
  2    25 	     2 record_id	      bit (36) aligned,
  2    26 	     2 record_check_value bit (36) aligned;
  2    27 
  2    28      dcl	   record_cursor_ptr      ptr;
  2    29      dcl	   RECORD_CURSOR_VERSION_2
  2    30 			      init (2) fixed bin int static options (constant);
  2    31      dcl	   RECORD_CURSOR_TYPE     init (1) fixed bin int static options (constant);
  2    32      dcl	   BEGINNING_OF_COLLECTION_RECORD_ID
  2    33 			      init ("0"b) bit (36) aligned int static options (constant);
  2    34 
  2    35 /* END INCLUDE FILE - dm_rcm_cursor.incl.pl1 */
      535 
      536 
  3     1 /* BEGIN INCLUDE FILE dm_rcm_opening_info.incl.pl1 */
  3     2 
  3     3 /* HISTORY:
  3     4*Written by Matthew Pierret, 03/15/83. 
  3     5*Modified:
  3     6*07/28/83 by Matthew Pierret: Changed name from dm_rm_opening_info.incl.pl1 to
  3     7*            dm_rcm_opening_info.incl.pl1.
  3     8**/
  3     9 
  3    10 /* format: style2,ind3 */
  3    11      dcl	   1 record_collection_opening_info
  3    12 			      aligned based (record_collection_opening_info_ptr),
  3    13 	     2 version	      char (8) aligned init (RECORD_COLLECTION_OPENING_INFO_VERSION_1),
  3    14 	     2 current_transaction_id
  3    15 			      bit (36) aligned init ("0"b),
  3    16 	     2 current_rollback_count
  3    17 			      fixed bin (35) init (0),
  3    18 	     2 file_opening_id    bit (36) aligned init ("0"b),
  3    19 	     2 collection_id      bit (36) aligned init ("0"b),
  3    20 	     2 field_table_ptr    ptr init (null);
  3    21 
  3    22      dcl	   record_collection_opening_info_ptr
  3    23 			      ptr init (null);
  3    24      dcl	   RECORD_COLLECTION_OPENING_INFO_VERSION_1
  3    25 			      char (8) aligned init ("rc_open1") internal static options (constant);
  3    26 
  3    27 /* BEGIN INCLUDE FILE dm_rcm_opening_info.incl.pl1 */
      537 
      538 
  4     1 /* BEGIN INCLUDE FILE - dm_id_list.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION
  4     4*        The id_list structure is used to identify attributes, fields and
  4     5*   dimensions by various modules of the Data Management System.
  4     6**/
  4     7 
  4     8 /* HISTORY:
  4     9*Written by Matthew Pierret, '82.
  4    10*Modified:
  4    11*08/17/83 by Matthew Pierret: Made version constant 'internal static options
  4    12*            (constant)' and to initialize automatic variables.
  4    13**/
  4    14 
  4    15 /* format: style2,ind3 */
  4    16      dcl	   1 id_list	      aligned based (id_list_ptr),
  4    17 	     2 version	      fixed bin (35),
  4    18 	     2 number_of_ids      fixed bin (17),
  4    19 	     2 id		      (il_number_of_ids refer (id_list.number_of_ids)) fixed bin (17);
  4    20 
  4    21      dcl	   id_list_ptr	      ptr init (null);
  4    22      dcl	   il_number_of_ids	      fixed bin (17) init (-1);
  4    23      dcl	   ID_LIST_VERSION_1      fixed bin (17) init (1) internal static options (constant);
  4    24 
  4    25 /* END INCLUDE FILE - dm_id_list.incl.pl1 */
      539 
      540 
  5     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*        Contains the declaration of an element identifier.  Element
  5     6*   identifiers consist of two parts, the id (number) of the control interval
  5     7*   in which the element resides, and the index into the slot table of
  5     8*   the element in the control interval.  The declaration of the element_id 
  5     9*   structure reflects this division of the element identifier.  The structure 
  5    10*   is based on the automatic bit string element_id_string because programs
  5    11*   generally pass bit strings (element_id_string) to each other, then 
  5    12*   interpret the bit string by overlaying the element_id structure ony if
  5    13*   it is necessary to access the parts of the id.  Basing element_id on
  5    14*   addr(element_id_string) instead of on a pointer removes the necessity
  5    15*   for always setting that pointer explicitly and guarantees that changes
  5    16*   made to the string or structure do not get inconsistent.
  5    17*
  5    18*   Changes made to element_id must also be made to datum_id, declared in 
  5    19*   dm_cm_datum.incl.pl1.
  5    20**/
  5    21 
  5    22 /* HISTORY:
  5    23*Written by Matthew Pierret, 04/01/82.
  5    24*Modified:
  5    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  5    26**/
  5    27 
  5    28 /* format: style2,ind3,ll79 */
  5    29 
  5    30      dcl	   element_id_string      bit (36) aligned;
  5    31 
  5    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  5    33 	     2 control_interval_id
  5    34 			      fixed bin (24) unal unsigned,
  5    35 	     2 index	      fixed bin (12) unal unsigned;
  5    36 
  5    37 
  5    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      541 
      542 
  6     1 /* BEGIN INCLUDE FILE  - dm_element_id_list.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*          The element_id_list structure contains an array of element 
  6     5*     identifiers.  These identifiers are used as tuple, record or 
  6     6*     element identifiers.  This structure is used across the relation_manager_,
  6     7*     record_manager_ and index_manager_ interfaces.  At some time the 
  6     8*     version should be changed to be char(8)aligned, when such a conversion
  6     9*     can be coordinated with the other structures used at these interfaces.
  6    10**/
  6    11 
  6    12 /* HISTORY:
  6    13*Written by Matthew Pierret, 06/06/82.
  6    14*Modified:
  6    15*12/16/82 by Roger Lackey:  Changed number_of_elements to fixed bin (35).
  6    16*            Did not change version.
  6    17*02/11/85 by Matthew Pierret:  Added DESCRIPTION, Written by.
  6    18**/
  6    19 
  6    20 /* format: style2,ind3 */
  6    21      dcl	   1 element_id_list      aligned based (element_id_list_ptr),
  6    22 	     2 version	      fixed bin (35),
  6    23 	     2 number_of_elements fixed bin (35),
  6    24 	     2 id		      (eil_number_of_elements refer (element_id_list.number_of_elements)) bit (36) aligned;
  6    25 
  6    26      dcl	   element_id_list_ptr    ptr;
  6    27      dcl	   eil_number_of_elements fixed bin (35);
  6    28      dcl	   ELEMENT_ID_LIST_VERSION_1
  6    29 			      init (1) fixed bin (35);
  6    30 
  6    31 
  6    32 /* END INCLUDE FILE  - dm_element_id_list.incl.pl1 */
      543 
      544 
  7     1 /* BEGIN INCLUDE FILE dm_ci_lengths.incl.pl1 */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*       This include file contains constants which are the length in bytes
  7     5*   of the addressable portion of a control interval.  The addressable portion
  7     6*   is that part of the control interval which callers of file_manager_
  7     7*   may access, specifically, everything between the end of the control
  7     8*   interval header (ci_header) and the control interval trailer (ci_trailer).
  7     9*   Control interval 0 is slightly different, as it also contains an 
  7    10*   unaddressable portion in which it maintains the file attributes.  For
  7    11*   control interval 0 the addressable portion is everything between the end
  7    12*   of the control interval header and the beginning of the file attributes.
  7    13**/
  7    14 
  7    15 /* HISTORY:
  7    16*Written by Matthew Pierret, 11/02/84.
  7    17*Modified:
  7    18**/
  7    19 
  7    20 /* format: style2,ind3 */
  7    21 
  7    22      dcl	   CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
  7    23 			      fixed bin (17) init (4072) int static options (constant);
  7    24 
  7    25      dcl	   CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
  7    26 			      fixed bin (17) init (3176) int static options (constant);
  7    27 
  7    28 
  7    29      dcl	   CI_ADDRESSABLE_LENGTH  fixed bin (17) init (4072) int static options (constant);
  7    30 
  7    31      dcl	   CI_0_ADDRESSABLE_LENGTH
  7    32 			      fixed bin (17) init (3176) int static options (constant);
  7    33 
  7    34 /* END INCLUDE FILE dm_ci_lengths.incl.pl1 */
      545 
      546 
  8     1 /* ***********************************************************
  8     2*   *                                                         *
  8     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  8     4*   *                                                         *
  8     5*   *********************************************************** */
  8     6 /* BEGIN INCLUDE FILE vu_typed_vector_array.incl.pl1 */
  8     7 
  8     8 /* Written by Lindsey Spratt, 03/04/82.
  8     9*Modified:
  8    10*06/23/82 by Lindsey Spratt: Changed to version 2.  The cv entry declarations
  8    11*	  were altered.  cv_to_typed now takes ptr to the descriptor, ptr to
  8    12*	  the print_vector value (char varying), ptr to the typed_vector
  8    13*	  value location, and a code. cv_to_print now takes ptr to the
  8    14*	  descriptor, ptr to the typed_vector value, the print_vector value
  8    15*	  (char(*) varying), the maximum allowed length for the print_vector
  8    16*	  value, a temp_seg to put the value in if its to big to fit into
  8    17*	  the print_vector, and a code.
  8    18**/
  8    19 
  8    20 /* format: style2,ind3 */
  8    21      dcl	   1 typed_vector_array   based (typed_vector_array_ptr) aligned,
  8    22 	     2 version	      fixed bin (35),
  8    23 	     2 number_of_dimensions
  8    24 			      fixed bin (17),
  8    25 	     2 number_of_vectors  fixed bin (17),
  8    26 	     2 number_of_vector_slots
  8    27 			      fixed bin (17),
  8    28 	     2 maximum_dimension_name_length
  8    29 			      fixed bin (17),
  8    30 	     2 dimension_table    (tva_number_of_dimensions refer (typed_vector_array.number_of_dimensions)),
  8    31 	       3 name	      char (tva_maximum_dimension_name_length
  8    32 			      refer (typed_vector_array.maximum_dimension_name_length)) varying,
  8    33 	       3 descriptor_ptr   ptr,		/* call cv_to_print (descriptor_ptr, typed_value_ptr, */
  8    34 						/* temp_seg_ptr, max_length_for_print_value, */
  8    35 						/* print_value, code) */
  8    36 	       3 cv_to_print      entry (ptr, ptr, ptr, fixed bin (35), char (*) varying, fixed bin (35)),
  8    37 						/* call cv_to_typed (descriptor_ptr, area_ptr, */
  8    38 						/* print_value_ptr, typed_value_ptr, code) */
  8    39 	       3 cv_to_typed      entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  8    40 	     2 vector_slot	      (tva_number_of_vector_slots refer (typed_vector_array.number_of_vector_slots))
  8    41 			      pointer;
  8    42 
  8    43      dcl	   typed_vector_array_ptr ptr;
  8    44      dcl	   tva_number_of_vector_slots
  8    45 			      fixed bin;
  8    46      dcl	   tva_number_of_dimensions
  8    47 			      fixed bin;
  8    48      dcl	   tva_maximum_dimension_name_length
  8    49 			      fixed bin;
  8    50      dcl	   TYPED_VECTOR_ARRAY_VERSION_2
  8    51 			      fixed bin (35) int static options (constant) init (2);
  8    52 
  8    53 /* END INCLUDE FILE vu_typed_vector_array.incl.pl1 */
      547 
      548 
  9     1 /* ***********************************************************
  9     2*   *                                                         *
  9     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  9     4*   *                                                         *
  9     5*   *********************************************************** */
  9     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
  9     7 
  9     8 /* Written by Lindsey Spratt, 04/02/82.
  9     9*Modified:
  9    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
  9    11*	  unaligned.  Changed the type number of the simple_typed_vector to
  9    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
  9    13*	  type.
  9    14**/
  9    15 
  9    16 /* format: style2,ind3 */
  9    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
  9    18 	     2 type	      fixed bin (17) unal,
  9    19 	     2 number_of_dimensions
  9    20 			      fixed bin (17) unal,
  9    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
  9    22 	       3 value_ptr	      ptr unaligned;
  9    23 
  9    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
  9    25 	     2 type	      fixed bin (17) unal,
  9    26 	     2 number_of_dimensions
  9    27 			      fixed bin (17) unal,
  9    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
  9    29 	       3 identifier	      fixed bin (17) unal,
  9    30 	       3 pad	      bit (18) unal,
  9    31 	       3 value_ptr	      ptr unal;
  9    32 
  9    33      dcl	   simple_typed_vector_ptr
  9    34 			      ptr;
  9    35      dcl	   stv_number_of_dimensions
  9    36 			      fixed bin (17);
  9    37 
  9    38      dcl	   general_typed_vector_ptr
  9    39 			      ptr;
  9    40      dcl	   gtv_number_of_dimensions
  9    41 			      fixed bin (17);
  9    42 
  9    43      dcl	   (
  9    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
  9    45 			      init (1),		/* value_ptr was aligned. */
  9    46 	   GENERAL_TYPED_VECTOR_TYPE
  9    47 			      init (2),
  9    48 	   SIMPLE_TYPED_VECTOR_TYPE
  9    49 			      init (3)
  9    50 	   )		      fixed bin (17) internal static options (constant);
  9    51 
  9    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
      549 
      550 
 10     1 /* BEGIN INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
 10     2 
 10     3 /* DESCRIPTION:
 10     4*     This include file contains declarations of all collection_manager_ 
 10     5*     entrypoints.
 10     6**/
 10     7 
 10     8 /* HISTORY:
 10     9*Written by Matthew Pierret 
 10    10*Modified:
 10    11*04/14/82 by Lindsey Spratt: Changed the control_interval_id parameter of the
 10    12*	  allocate_control_interval operation to be unaligned, as well as
 10    13*	  unsigned.
 10    14*06/17/82 by Matthew Pierret: Added the put_element_portion opertion and
 10    15*            removed the beginning_location parameter from the put_element
 10    16*            operation. Added the create_page_file_operation.
 10    17*08/09/82 by Matthew Pierret: Changed "fixed bin (17)"s to "bit (36) aligned"s
 10    18*            wherever collection_id was required.
 10    19*            Also changed the control_interval_id parameter of the 
 10    20*            allocate_control_interval operation back to be aligned. So there.
 10    21*10/20/82 by Matthew Pierret: Changed $create_page_file to $create_file,
 10    22*            added the argument file_create_info_ptr to $create_file.
 10    23*12/13/82 by Lindsey Spratt:  Corrected $free_control_interval to
 10    24*	  include the zero_on_free bit.
 10    25*12/17/82 by Matthew Pierret: Added cm_$get_id.
 10    26*01/07/83 by Matthew Pierret: Added cm_$put_element_buffered, 
 10    27*            cm_$allocate_element_buffered, cm_$free_element_buffered.
 10    28*04/27/83 by Matthew Pierret: Added cm_$put_unprotected_element,
 10    29*            cm_$put_unprotected_header.
 10    30*11/07/83 by Matthew Pierret: Added $get_element_portion_buffered,
 10    31*             $simple_get_buffered_element.
 10    32*02/08/84 by Matthew Pierret:  Changed $get_id to have only one bit(1)aligned
 10    33*            parameter for specifying absolute/relative nature of search.
 10    34*03/16/84 by Matthew Pierret:  Added cm_$get_control_interval_ptr,
 10    35*            $get_element_ptr, $get_element_portion_ptr, $simple_get_element_ptr
 10    36*04/03/84 by Matthew Pierret:  Added cm_$compact_control_interval.
 10    37*06/06/84 by Matthew Pierret:  Re-named free_element* to delete and
 10    38*            delete_from_ci_buffer.
 10    39*            Re-named *_buffered_ci to =_ci_buffer.
 10    40*            get entries.
 10    41*            modify entries.
 10    42*            Changed calling sequence of modify entries to have a ptr/length
 10    43*            instead of length/ptr parameter pair.
 10    44*03/11/85 by R. Michael Tague:  Added $postcommit_increments.
 10    45**/
 10    46 
 10    47 /* This include file contains declarations of collection_manager_ entrypoints */
 10    48 
 10    49 /* format: style2,ind3 */
 10    50      dcl	   collection_manager_$allocate_control_interval
 10    51 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
 10    52      dcl	   collection_manager_$compact_control_interval
 10    53 			      entry (bit (36) aligned, fixed bin (24) uns, fixed bin (35));
 10    54      dcl	   collection_manager_$create_collection
 10    55 			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
 10    56      dcl	   collection_manager_$create_file
 10    57 			      entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
 10    58      dcl	   collection_manager_$destroy_collection
 10    59 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
 10    60      dcl	   collection_manager_$free_control_interval
 10    61 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, bit (1) aligned,
 10    62 			      fixed bin (35));
 10    63 
 10    64      dcl	   collection_manager_$delete
 10    65 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
 10    66 			      fixed bin (35));
 10    67      dcl	   collection_manager_$delete_from_ci_buffer
 10    68 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
 10    69 			      fixed bin (35));
 10    70 
 10    71      dcl	   collection_manager_$get
 10    72 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
 10    73 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
 10    74      dcl	   collection_manager_$get_control_interval_ptr
 10    75 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, ptr,
 10    76 			      fixed bin (35));
 10    77      dcl	   collection_manager_$get_from_ci_buffer
 10    78 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
 10    79 			      ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
 10    80      dcl	   collection_manager_$get_by_ci_ptr
 10    81 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
 10    82 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), ptr, fixed bin (35));
 10    83      dcl	   collection_manager_$get_header
 10    84 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (17), ptr, bit (1) aligned,
 10    85 			      ptr, fixed bin (35), fixed bin (35));
 10    86      dcl	   collection_manager_$get_id
 10    87 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17),
 10    88 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
 10    89      dcl	   collection_manager_$get_portion
 10    90 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
 10    91 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
 10    92 			      fixed bin (35), fixed bin (35));
 10    93      dcl	   collection_manager_$get_portion_from_ci_buffer
 10    94 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
 10    95 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
 10    96 			      fixed bin (35));
 10    97      dcl	   collection_manager_$get_portion_by_ci_ptr
 10    98 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
 10    99 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
 10   100 			      fixed bin (35));
 10   101      dcl	   collection_manager_$modify
 10   102 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 10   103 			      fixed bin (35), fixed bin (35));
 10   104      dcl	   collection_manager_$modify_unprotected
 10   105 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 10   106 			      fixed bin (35), fixed bin (35));
 10   107      dcl	   collection_manager_$modify_in_ci_buffer
 10   108 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 10   109 			      fixed bin (35), fixed bin (35));
 10   110      dcl	   collection_manager_$modify_portion
 10   111 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35), ptr,
 10   112 			      fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
 10   113      dcl	   collection_manager_$postcommit_increments
 10   114 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
 10   115      dcl	   collection_manager_$put
 10   116 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 10   117 			      fixed bin (35), fixed bin (35));
 10   118      dcl	   collection_manager_$put_in_ci_buffer
 10   119 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 10   120 			      fixed bin (35), fixed bin (35));
 10   121      dcl	   collection_manager_$put_header
 10   122 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
 10   123      dcl	   collection_manager_$put_unprotected_header
 10   124 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
 10   125 
 10   126      dcl	   collection_manager_$replace_ci_buffer
 10   127 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
 10   128 			      fixed bin (35));
 10   129      dcl	   collection_manager_$setup_ci_buffer
 10   130 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
 10   131 			      fixed bin (35));
 10   132      dcl	   collection_manager_$simple_get_by_ci_ptr
 10   133 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
 10   134 			      fixed bin (35));
 10   135      dcl	   collection_manager_$simple_get_from_ci_buffer
 10   136 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
 10   137 			      fixed bin (35));
 10   138 
 10   139 /* END INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
      551 
      552 
 11     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
 11     2 /* format: style3 */
 11     3 
 11     4 /* These constants are to be used for the flags argument of sub_err_ */
 11     5 /* They are just "string (condition_info_header.action_flags)" */
 11     6 
 11     7 declare	(
 11     8 	ACTION_CAN_RESTART	init (""b),
 11     9 	ACTION_CANT_RESTART init ("1"b),
 11    10 	ACTION_DEFAULT_RESTART
 11    11 			init ("01"b),
 11    12 	ACTION_QUIET_RESTART
 11    13 			init ("001"b),
 11    14 	ACTION_SUPPORT_SIGNAL
 11    15 			init ("0001"b)
 11    16 	)		bit (36) aligned internal static options (constant);
 11    17 
 11    18 /* End include file */
      553 
      554 
 12     1 /* BEGIN INCLUDE FILE ... std_descriptor_types.incl.pl1 */
 12     2 
 12     3 
 12     4 /****^  HISTORY COMMENTS:
 12     5*  1) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
 12     6*     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1208):
 12     7*     Added pascal_string_type_dtype descriptor type.  Its number is 87.
 12     8*     Objects of this type are PASCAL string types.
 12     9*  2) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
 12    10*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
 12    11*     Added the new C types.
 12    12*                                                   END HISTORY COMMENTS */
 12    13 
 12    14 /* This include file defines mnemonic names for the Multics
 12    15*   standard descriptor types, using both pl1 and cobol terminology.
 12    16*   PG 780613
 12    17*   JRD 790530
 12    18*   JRD 791016
 12    19*   MBW 810731
 12    20*   TGO 830614 Add hex types.
 12    21*   Modified June 83 JMAthane to add PASCAL data types
 12    22*   TGO 840120 Add float dec extended and generic, float binary generic
 12    23**/
 12    24 
 12    25      dcl	   (real_fix_bin_1_dtype  init (1),
 12    26 	   real_fix_bin_2_dtype   init (2),
 12    27 	   real_flt_bin_1_dtype   init (3),
 12    28 	   real_flt_bin_2_dtype   init (4),
 12    29 	   cplx_fix_bin_1_dtype   init (5),
 12    30 	   cplx_fix_bin_2_dtype   init (6),
 12    31 	   cplx_flt_bin_1_dtype   init (7),
 12    32 	   cplx_flt_bin_2_dtype   init (8),
 12    33 	   real_fix_dec_9bit_ls_dtype init (9),
 12    34 	   real_flt_dec_9bit_dtype init (10),
 12    35 	   cplx_fix_dec_9bit_ls_dtype init (11),
 12    36 	   cplx_flt_dec_9bit_dtype init (12),
 12    37 	   pointer_dtype	      init (13),
 12    38 	   offset_dtype	      init (14),
 12    39 	   label_dtype	      init (15),
 12    40 	   entry_dtype	      init (16),
 12    41 	   structure_dtype	      init (17),
 12    42 	   area_dtype	      init (18),
 12    43 	   bit_dtype	      init (19),
 12    44 	   varying_bit_dtype      init (20),
 12    45 	   char_dtype	      init (21),
 12    46 	   varying_char_dtype     init (22),
 12    47 	   file_dtype	      init (23),
 12    48 	   real_fix_dec_9bit_ls_overp_dtype init (29),
 12    49 	   real_fix_dec_9bit_ts_overp_dtype init (30),
 12    50 	   real_fix_bin_1_uns_dtype init (33),
 12    51 	   real_fix_bin_2_uns_dtype init (34),
 12    52 	   real_fix_dec_9bit_uns_dtype init (35),
 12    53 	   real_fix_dec_9bit_ts_dtype init (36),
 12    54 	   real_fix_dec_4bit_uns_dtype init (38),	/* digit-aligned */
 12    55 	   real_fix_dec_4bit_ts_dtype init (39),	/* byte-aligned */
 12    56 	   real_fix_dec_4bit_bytealigned_uns_dtype init (40), /* COBOL */
 12    57 	   real_fix_dec_4bit_ls_dtype init (41),	/* digit-aligned */
 12    58 	   real_flt_dec_4bit_dtype init (42),		/* digit-aligned */
 12    59 	   real_fix_dec_4bit_bytealigned_ls_dtype init (43),
 12    60 	   real_flt_dec_4bit_bytealigned_dtype init (44),
 12    61 	   cplx_fix_dec_4bit_bytealigned_ls_dtype init (45),
 12    62 	   cplx_flt_dec_4bit_bytealigned_dtype init (46),
 12    63 	   real_flt_hex_1_dtype   init (47),
 12    64 	   real_flt_hex_2_dtype   init (48),
 12    65 	   cplx_flt_hex_1_dtype   init (49),
 12    66 	   cplx_flt_hex_2_dtype   init (50),
 12    67 	   c_typeref_dtype        init (54),
 12    68 	   c_enum_dtype           init (55),
 12    69              c_enum_const_dtype     init (56),
 12    70 	   c_union_dtype          init (57),
 12    71 	   algol68_straight_dtype init (59),
 12    72 	   algol68_format_dtype   init (60),
 12    73 	   algol68_array_descriptor_dtype init (61),
 12    74 	   algol68_union_dtype    init (62),
 12    75 
 12    76 	   cobol_comp_6_dtype     init (1),
 12    77 	   cobol_comp_7_dtype     init (1),
 12    78 	   cobol_display_ls_dtype init (9),
 12    79 	   cobol_structure_dtype  init (17),
 12    80 	   cobol_char_string_dtype init (21),
 12    81 	   cobol_display_ls_overp_dtype init (29),
 12    82 	   cobol_display_ts_overp_dtype init (30),
 12    83 	   cobol_display_uns_dtype init (35),
 12    84 	   cobol_display_ts_dtype init (36),
 12    85 	   cobol_comp_8_uns_dtype init (38),		/* digit aligned */
 12    86 	   cobol_comp_5_ts_dtype  init (39),		/* byte aligned */
 12    87 	   cobol_comp_5_uns_dtype init (40),
 12    88 	   cobol_comp_8_ls_dtype  init (41),		/* digit aligned */
 12    89 	   real_flt_dec_extended_dtype init (81),	/* 9-bit exponent */
 12    90 	   cplx_flt_dec_extended_dtype init (82),	/* 9-bit exponent */
 12    91 	   real_flt_dec_generic_dtype init (83),	/* generic float decimal */
 12    92 	   cplx_flt_dec_generic_dtype init (84),
 12    93 	   real_flt_bin_generic_dtype init (85),	/* generic float binary */
 12    94 	   cplx_flt_bin_generic_dtype init (86)) fixed bin internal static options (constant);
 12    95 
 12    96      dcl	   (ft_integer_dtype      init (1),
 12    97 	   ft_real_dtype	      init (3),
 12    98 	   ft_double_dtype	      init (4),
 12    99 	   ft_complex_dtype	      init (7),
 12   100 	   ft_complex_double_dtype init (8),
 12   101 	   ft_external_dtype      init (16),
 12   102 	   ft_logical_dtype	      init (19),
 12   103 	   ft_char_dtype	      init (21),
 12   104 	   ft_hex_real_dtype      init (47),
 12   105 	   ft_hex_double_dtype    init (48),
 12   106 	   ft_hex_complex_dtype   init (49),
 12   107 	   ft_hex_complex_double_dtype init (50)
 12   108 	   )		      fixed bin internal static options (constant);
 12   109 
 12   110      dcl	   (algol68_short_int_dtype init (1),
 12   111 	   algol68_int_dtype      init (1),
 12   112 	   algol68_long_int_dtype init (2),
 12   113 	   algol68_real_dtype     init (3),
 12   114 	   algol68_long_real_dtype init (4),
 12   115 	   algol68_compl_dtype    init (7),
 12   116 	   algol68_long_compl_dtype init (8),
 12   117 	   algol68_bits_dtype     init (19),
 12   118 	   algol68_bool_dtype     init (19),
 12   119 	   algol68_char_dtype     init (21),
 12   120 	   algol68_byte_dtype     init (21),
 12   121 	   algol68_struct_struct_char_dtype init (22),
 12   122 	   algol68_struct_struct_bool_dtype init (20)
 12   123 	   )		      fixed bin internal static options (constant);
 12   124 
 12   125      dcl	   (label_constant_runtime_dtype init (24),
 12   126 	   int_entry_runtime_dtype init (25),
 12   127 	   ext_entry_runtime_dtype init (26),
 12   128 	   ext_procedure_runtime_dtype init (27),
 12   129 	   picture_runtime_dtype  init (63)
 12   130 	   )		      fixed bin internal static options (constant);
 12   131 
 12   132      dcl	   (pascal_integer_dtype  init (1),
 12   133 	   pascal_real_dtype      init (4),
 12   134 	   pascal_label_dtype     init (24),
 12   135 	   pascal_internal_procedure_dtype init (25),
 12   136 	   pascal_exportable_procedure_dtype init (26),
 12   137 	   pascal_imported_procedure_dtype init (27),
 12   138 	   pascal_typed_pointer_type_dtype init (64),
 12   139 	   pascal_char_dtype      init (65),
 12   140 	   pascal_boolean_dtype   init (66),
 12   141 	   pascal_record_file_type_dtype init (67),
 12   142 	   pascal_record_type_dtype init (68),
 12   143 	   pascal_set_dtype	      init (69),
 12   144 	   pascal_enumerated_type_dtype init (70),
 12   145 	   pascal_enumerated_type_element_dtype init (71),
 12   146 	   pascal_enumerated_type_instance_dtype init (72),
 12   147 	   pascal_user_defined_type_dtype init (73),
 12   148 	   pascal_user_defined_type_instance_dtype init (74),
 12   149 	   pascal_text_file_dtype init (75),
 12   150 	   pascal_procedure_type_dtype init (76),
 12   151 	   pascal_variable_formal_parameter_dtype init (77),
 12   152 	   pascal_value_formal_parameter_dtype init (78),
 12   153 	   pascal_entry_formal_parameter_dtype init (79),
 12   154 	   pascal_parameter_procedure_dtype init (80),
 12   155 	   pascal_string_type_dtype init (87)) fixed bin int static options (constant);
 12   156 
 12   157 
 12   158 /* END INCLUDE FILE ... std_descriptor_types.incl.pl1 */
      555 
      556    end rcm_get_record_by_id;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/24/88  1400.0  rcm_get_record_by_id.pl1          >special_ldd>install>MR12.2-1184>rcm_get_record_by_id.pl1
533          1    11/02/83  1845.0  arg_descriptor.incl.pl1           >ldd>include>arg_descriptor.incl.pl1
535          2    01/07/85  0859.4  dm_rcm_cursor.incl.pl1            >ldd>include>dm_rcm_cursor.incl.pl1
537          3    01/07/85  0859.4  dm_rcm_opening_info.incl.pl1      >ldd>include>dm_rcm_opening_info.incl.pl1
539          4    10/14/83  1609.1  dm_id_list.incl.pl1               >ldd>include>dm_id_list.incl.pl1
541          5    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
543          6    03/06/85  1031.5  dm_element_id_list.incl.pl1       >ldd>include>dm_element_id_list.incl.pl1
545          7    01/07/85  0900.7  dm_ci_lengths.incl.pl1            >ldd>include>dm_ci_lengths.incl.pl1
547          8    10/14/83  1609.1  vu_typed_vector_array.incl.pl1    >ldd>include>vu_typed_vector_array.incl.pl1
549          9    10/14/83  1609.1  vu_typed_vector.incl.pl1          >ldd>include>vu_typed_vector.incl.pl1
551         10    04/05/85  0924.4  dm_collmgr_entry_dcls.incl.pl1    >ldd>include>dm_collmgr_entry_dcls.incl.pl1
553         11    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
555         12    10/24/88  1336.9  std_descriptor_types.incl.pl1     >special_ldd>install>MR12.2-1184>std_descriptor_types.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000033 constant        bit(36)                  initial dcl 11-7 set ref 192* 509* 524*
AREA_IS_BIG_ENOUGH                     constant        fixed bin(17,0)          initial dcl 119 set ref 371*
AREA_IS_TOO_SMALL                      constant        fixed bin(17,0)          initial dcl 119 set ref 330* 359*
BITS_PER_PAGE                          constant        fixed bin(17,0)          initial dcl 119 ref 101
DEFAULT_RECORD_ID_FIELD_ID      002172 constant        fixed bin(17,0)          initial dcl 119 ref 90 363 423 432 436 439 477
DOUBLE_WORDS_PER_PAGE                  constant        fixed bin(17,0)          initial dcl 119 ref 96
ELEMENT_ID_LIST_VERSION_1       000146 automatic       fixed bin(35,0)          initial dcl 6-28 set ref 178 6-28*
FALSE                                  constant        bit(1)                   initial dcl 129 ref 483
FREE_OLD_TYPED_VECTOR_ARRAY     000033 constant        bit(1)                   initial dcl 129 set ref 327*
ID_LIST_VERSION_1                      constant        fixed bin(17,0)          initial dcl 4-23 ref 427
RECORD_COLLECTION_OPENING_INFO_VERSION_1
                                000000 constant        char(8)                  initial dcl 3-24 set ref 204*
RECORD_CURSOR_TYPE              000036 constant        fixed bin(17,0)          initial dcl 2-31 set ref 192 192*
RECORD_CURSOR_VERSION_2                constant        fixed bin(17,0)          initial dcl 2-29 ref 196
TRUE                                   constant        bit(1)                   initial dcl 129 ref 481
TYPED_VECTOR_ARRAY_VERSION_2    000037 constant        fixed bin(35,0)          initial dcl 8-50 set ref 475* 494*
VECTOR_SLOT_INCREMENT           000013 constant        fixed bin(17,0)          initial dcl 119 set ref 327* 471
addr                                                   builtin function         dcl 111 ref 211 258 279
aor_code                        000206 automatic       fixed bin(35,0)          dcl 320 set ref 325* 327* 330 330 333* 342* 345 345
                                                                                  354* 356 356* 361*
aor_p_area_status                      parameter       fixed bin(17,0)          dcl 310 set ref 295 336 378*
aor_p_field_table_ptr                  parameter       pointer                  dcl 304 set ref 295 336 342*
aor_p_id_list_ptr                      parameter       pointer                  dcl 306 set ref 295 336 342*
aor_p_record_id                        parameter       bit(36)                  dcl 309 ref 295 336 368
aor_p_record_id_field_id               parameter       fixed bin(17,0)          dcl 307 ref 295 336 363 367
aor_p_record_string_length             parameter       fixed bin(35,0)          dcl 301 set ref 295 336 342*
aor_p_record_string_ptr                parameter       pointer                  dcl 299 set ref 295 336 342*
aor_p_result_ptr                       parameter       pointer                  dcl 303 set ref 295 322 336 340 379* 381*
aor_p_work_area                        based           area(1024)               dcl 312 ref 366
aor_p_work_area_ptr                    parameter       pointer                  dcl 305 set ref 295 327* 336 342* 354* 366
aor_record_id_ptr               000200 automatic       pointer                  initial dcl 315 set ref 315* 366* 367 368
aor_set_result_ptr_to_new_vector
                                000202 automatic       bit(1)                   initial dcl 316 set ref 316* 323* 341* 379
aor_typed_vector_array_ptr      000204 automatic       pointer                  initial dcl 318 set ref 318* 322* 327* 339* 349 352
                                                                                  352 354* 381
aor_vector_ptr                  000176 automatic       pointer                  initial dcl 314 set ref 314* 327* 340* 342* 354* 367
                                                                                  379
aorr_p_area_status                     parameter       fixed bin(17,0)          dcl 377 ref 375 378
arg_descriptor                         based           structure                level 1 dcl 1-6 set ref 480
bit_dtype                              constant        fixed bin(17,0)          initial dcl 12-25 ref 482
cleanup                         000124 stack reference condition                dcl 115 ref 213
collection_id             5            based           bit(36)                  level 2 dcl 2-15 set ref 199* 217* 249*
collection_manager_$get         000036 constant        entry                    external dcl 10-71 ref 217 249
data_format_util_$cv_table_to_typed_array
                                000014 constant        entry                    external dcl 143 ref 471
data_format_util_$new_cv_string_to_vector
                                000012 constant        entry                    external dcl 141 ref 342
descriptor_ptr                         based           pointer                  array level 3 dcl 8-21 set ref 487*
descriptor_string_ptr           000112 automatic       pointer                  initial dcl 95 set ref 95*
dimension                 1            based           structure                array level 2 packed packed unaligned dcl 9-17
dimension_table           6            based           structure                array level 2 dcl 8-21
dm_error_$ci_not_allocated      000040 external static fixed bin(35,0)          dcl 391 ref 401
dm_error_$ci_not_in_collection  000042 external static fixed bin(35,0)          dcl 391 ref 399
dm_error_$no_element            000044 external static fixed bin(35,0)          dcl 391 ref 397
dm_error_$record_not_found      000032 external static fixed bin(35,0)          dcl 154 ref 397 399 401
dm_error_$wrong_cursor_type     000034 external static fixed bin(35,0)          dcl 154 set ref 192*
dm_vector_util_$append_simple_typed_vector
                                000016 constant        entry                    external dcl 145 ref 327
dm_vector_util_$free_typed_vector
                                000020 constant        entry                    external dcl 147 ref 354
dm_work_area                           based           area(1024)               dcl 106 ref 258 279
dm_work_area_ptr                000122 automatic       pointer                  initial dcl 102 set ref 102* 209* 217* 249* 258 279
element_id                             based           structure                level 1 dcl 5-32 set ref 366 368*
element_id_list                        based           structure                level 1 dcl 6-21
element_id_list_ptr             000144 automatic       pointer                  dcl 6-26 set ref 176* 178 180 239 239 245 247
er_p_code                              parameter       fixed bin(35,0)          dcl 286 ref 284 290
error_table_$area_too_small     000026 external static fixed bin(35,0)          dcl 154 ref 330 345
error_table_$unimplemented_version
                                000030 external static fixed bin(35,0)          dcl 154 set ref 509* 524*
extended_arg_type               000132 automatic       fixed bin(17,0)          initial dcl 1-36 set ref 1-36*
field_table_ptr           6            based           pointer                  initial level 2 in structure
                                                                                  "record_collection_opening_info" dcl 3-11
                                                                                  in procedure "rcm_get_record_by_id" ref 207
field_table_ptr                 000110 automatic       pointer                  initial dcl 94 in procedure "rcm_get_record_by_id"
                                                                                  set ref 94* 207* 231* 239* 263*
file_opening_id           4            based           bit(36)                  level 2 dcl 2-15 set ref 199* 217* 249*
flag                                   based           bit(1)                   level 2 packed packed unaligned dcl 1-6 set ref 481*
flags                     1            based           structure                level 2 dcl 2-15
get_array_of_records            000100 automatic       bit(1)                   initial dcl 87 set ref 87*
get_dm_free_area_               000024 constant        entry                    external dcl 150 ref 209
get_single_record               000101 automatic       bit(1)                   initial dcl 88 set ref 88* 166* 181* 234
hbound                                                 builtin function         dcl 111 ref 239 239 245
id                        2            based           bit(36)                  array level 2 in structure "element_id_list"
                                                                                  dcl 6-21 in procedure "rcm_get_record_by_id" ref
                                                                                  180 239 239 245 247
id                        2            based           fixed bin(17,0)          array level 2 in structure "id_list" dcl 4-16
                                                                                  in procedure "rcm_get_record_by_id" ref 436
id_list                                based           structure                level 1 dcl 4-16
id_list_ptr                     000140 automatic       pointer                  initial dcl 4-21 set ref 215* 231* 239* 263* 4-21*
il_number_of_ids                000142 automatic       fixed bin(17,0)          initial dcl 4-22 set ref 4-22*
local_record_buffer             000114 automatic       fixed bin(71,0)          array dcl 96 set ref 211 258 279
maximum_dimension_name_length
                          4            based           fixed bin(17,0)          level 2 dcl 8-21 ref 243 486 486 486 487 487 487
myname                          000002 constant        varying char(32)         initial dcl 136 set ref 192* 509* 524*
name                      6            based           varying char             array level 3 dcl 8-21 set ref 486*
new_buffer_was_allocated        000114 automatic       bit(1)                   initial dcl 98 set ref 98* 217* 223 249* 255
null                                                   builtin function         dcl 111 ref 93 94 95 100 102 169 182 192 192 3-22
                                                                                  4-21 314 315 318 339 349 420 431 467 509 509 524
                                                                                  524
number_dims               0(08)        based           fixed bin(4,0)           level 2 packed packed unsigned unaligned dcl 1-6 set
                                                                                  ref 484*
number_of_dimensions      1            based           fixed bin(17,0)          level 2 dcl 8-21 ref 243
number_of_elements        1            based           fixed bin(35,0)          level 2 dcl 6-21 ref 239 239 245
number_of_ids             1            based           fixed bin(17,0)          level 2 dcl 4-16 ref 428 436 436
number_of_vectors         2            based           fixed bin(17,0)          level 2 dcl 8-21 set ref 242* 352* 352
p_code                                 parameter       fixed bin(35,0)          dcl 390 in procedure "GET_ELEMENT_ERROR_RETURN" set
                                                                                  ref 387 397 397* 399 399* 401 401* 404*
p_code                                 parameter       fixed bin(35,0)          dcl 83 in procedure "rcm_get_record_by_id" set ref
                                                                                  163 173 187* 199* 201 217* 220 220* 249* 252 252*
                                                                                  290*
p_correct_version                      parameter       char(8)                  dcl 522 set ref 517 524 524*
p_element_id_list_ptr                  parameter       pointer                  dcl 81 ref 173 176
p_expected_version                     parameter       fixed bin(35,0)          dcl 506 set ref 502 509 509*
p_given_version                        parameter       char(8)                  dcl 521 set ref 517 524 524*
p_id_list_ptr                          parameter       pointer                  dcl 80 set ref 163 173 215*
p_received_version                     parameter       fixed bin(35,0)          dcl 505 set ref 502 509 509*
p_record_cursor_ptr                    parameter       pointer                  dcl 74 ref 163 173 190
p_record_id                            parameter       bit(36)                  dcl 82 ref 163 167
p_simple_typed_vector_ptr              parameter       pointer                  dcl 75 set ref 163 168 234*
p_structure_name                       parameter       char                     packed unaligned dcl 507 in procedure
                                                                                  "CHECK_VERSION" set ref 502 509*
p_structure_name                       parameter       char                     packed unaligned dcl 520 in procedure
                                                                                  "CHECK_VERSION_CHAR_8" set ref 517 524*
p_typed_vector_array_ptr               parameter       pointer                  dcl 77 set ref 173 183 266*
p_work_area_ptr                        parameter       pointer                  dcl 79 set ref 163 173 231* 239* 263*
packed                    0(07)        based           bit(1)                   level 2 packed packed unaligned dcl 1-6 set ref 483*
position_is_valid         1            based           bit(1)                   level 3 packed packed unaligned dcl 2-15 set ref
                                                                                  271*
rcm_get_opening_info            000010 constant        entry                    external dcl 140 ref 199
record_buffer                          based           bit                      dcl 107 ref 258 279
record_buffer_length            000120 automatic       fixed bin(35,0)          initial dcl 101 set ref 101* 217* 227* 249* 258 258
                                                                                  261* 279 279
record_buffer_ptr               000116 automatic       pointer                  initial dcl 100 set ref 100* 211* 217* 226* 249* 258
                                                                                  258 260* 279 279
record_collection_opening_info         based           structure                level 1 dcl 3-11
record_collection_opening_info_ptr
                                000136 automatic       pointer                  initial dcl 3-22 set ref 199* 204 207 3-22*
record_cursor                          based           structure                level 1 dcl 2-15
record_cursor_ptr               000134 automatic       pointer                  dcl 2-28 set ref 190* 192 192 196 199 199 217 217
                                                                                  249 249 270 271
record_id                       000102 automatic       bit(36)                  dcl 89 in procedure "rcm_get_record_by_id" set ref
                                                                                  167* 180* 217* 231* 247* 249* 263* 270
record_id                 6            based           bit(36)                  level 2 in structure "record_cursor" dcl 2-15
                                                                                  in procedure "rcm_get_record_by_id" set ref 270*
record_id_field_id              000103 automatic       fixed bin(17,0)          initial dcl 90 set ref 90* 215* 231* 239* 263*
record_idx                      000104 automatic       fixed bin(17,0)          dcl 91 set ref 245* 247*
record_string_length            000105 automatic       fixed bin(35,0)          dcl 92 set ref 217* 227 231* 249* 261 263*
record_string_ptr               000106 automatic       pointer                  initial dcl 93 set ref 93* 217* 226 231* 249* 260
                                                                                  263*
sil_p_input_id_list_ptr                parameter       pointer                  dcl 412 ref 409 419
sil_p_output_id_list_ptr               parameter       pointer                  dcl 414 set ref 409 419* 420 427 428 431* 436 436
                                                                                  436
sil_p_record_id_field_id               parameter       fixed bin(17,0)          dcl 416 set ref 409 423* 432* 436* 439*
simple_typed_vector                    based           structure                level 1 packed packed unaligned dcl 9-17
simple_typed_vector_ptr         000152 automatic       pointer                  dcl 9-33 set ref 168* 182* 231* 234 243
size                      0(12)        based           fixed bin(24,0)          level 2 packed packed unsigned unaligned dcl 1-6 set
                                                                                  ref 485*
sor_code                        000242 automatic       fixed bin(35,0)          dcl 465 set ref 470* 471* 473 473*
sor_p_field_table_ptr                  parameter       pointer                  dcl 456 set ref 447 471*
sor_p_id_list_ptr                      parameter       pointer                  dcl 457 set ref 447 471*
sor_p_input_tva_ptr                    parameter       pointer                  dcl 451 ref 447 467 493
sor_p_maximum_number_of_records        parameter       fixed bin(35,0)          dcl 452 ref 447
sor_p_output_tva_ptr                   parameter       pointer                  dcl 459 set ref 447 471* 475 486 487 493* 494
sor_p_record_id_field_id               parameter       fixed bin(17,0)          dcl 454 ref 447 477 486 487
sor_p_work_area                        based           area(1024)               dcl 461 ref 480
sor_p_work_area_ptr                    parameter       pointer                  dcl 458 set ref 447 471* 480
sor_record_id_descriptor_ptr    000240 automatic       pointer                  dcl 463 set ref 480* 481 482 483 484 485 487
sub_err_                        000022 constant        entry                    external dcl 149 ref 192 509 524
type                                   based           fixed bin(17,0)          level 2 in structure "record_cursor" packed packed
                                                                                  unaligned dcl 2-15 in procedure
                                                                                  "rcm_get_record_by_id" set ref 192 192*
type                      0(01)        based           fixed bin(6,0)           level 2 in structure "arg_descriptor" packed packed
                                                                                  unsigned unaligned dcl 1-6 in procedure
                                                                                  "rcm_get_record_by_id" set ref 482*
typed_vector_array                     based           structure                level 1 dcl 8-21
typed_vector_array_ptr          000150 automatic       pointer                  dcl 8-43 set ref 169* 183* 239* 239* 242 243 263*
                                                                                  266
value_ptr                 1            based           pointer                  array level 3 packed packed unaligned dcl 9-17 set
                                                                                  ref 367*
vector_slot                            based           pointer                  array level 2 dcl 8-21 set ref 243*
version                                based           fixed bin(35,0)          level 2 in structure "element_id_list" dcl 6-21
                                                                                  in procedure "rcm_get_record_by_id" ref 178
version                                based           fixed bin(35,0)          level 2 in structure "typed_vector_array" dcl 8-21
                                                                                  in procedure "rcm_get_record_by_id" set ref 475*
                                                                                  494*
version                                based           fixed bin(35,0)          level 2 in structure "id_list" dcl 4-16 in procedure
                                                                                  "rcm_get_record_by_id" set ref 427*
version                   0(18)        based           fixed bin(17,0)          level 2 in structure "record_cursor" packed packed
                                                                                  unaligned dcl 2-15 in procedure
                                                                                  "rcm_get_record_by_id" ref 196
version                                based           char(8)                  initial level 2 in structure
                                                                                  "record_collection_opening_info" dcl 3-11
                                                                                  in procedure "rcm_get_record_by_id" set ref 204*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 11-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 11-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 11-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 11-7
BEGINNING_OF_COLLECTION_RECORD_ID      internal static bit(36)                  initial dcl 2-32
CI_0_ADDRESSABLE_LENGTH                internal static fixed bin(17,0)          initial dcl 7-31
CI_ADDRESSABLE_LENGTH                  internal static fixed bin(17,0)          initial dcl 7-29
CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
                                       internal static fixed bin(17,0)          initial dcl 7-22
CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
                                       internal static fixed bin(17,0)          initial dcl 7-25
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 9-43
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 9-43
SIMPLE_TYPED_VECTOR_TYPE               internal static fixed bin(17,0)          initial dcl 9-43
algol68_array_descriptor_dtype         internal static fixed bin(17,0)          initial dcl 12-25
algol68_bits_dtype                     internal static fixed bin(17,0)          initial dcl 12-110
algol68_bool_dtype                     internal static fixed bin(17,0)          initial dcl 12-110
algol68_byte_dtype                     internal static fixed bin(17,0)          initial dcl 12-110
algol68_char_dtype                     internal static fixed bin(17,0)          initial dcl 12-110
algol68_compl_dtype                    internal static fixed bin(17,0)          initial dcl 12-110
algol68_format_dtype                   internal static fixed bin(17,0)          initial dcl 12-25
algol68_int_dtype                      internal static fixed bin(17,0)          initial dcl 12-110
algol68_long_compl_dtype               internal static fixed bin(17,0)          initial dcl 12-110
algol68_long_int_dtype                 internal static fixed bin(17,0)          initial dcl 12-110
algol68_long_real_dtype                internal static fixed bin(17,0)          initial dcl 12-110
algol68_real_dtype                     internal static fixed bin(17,0)          initial dcl 12-110
algol68_short_int_dtype                internal static fixed bin(17,0)          initial dcl 12-110
algol68_straight_dtype                 internal static fixed bin(17,0)          initial dcl 12-25
algol68_struct_struct_bool_dtype       internal static fixed bin(17,0)          initial dcl 12-110
algol68_struct_struct_char_dtype       internal static fixed bin(17,0)          initial dcl 12-110
algol68_union_dtype                    internal static fixed bin(17,0)          initial dcl 12-25
area_dtype                             internal static fixed bin(17,0)          initial dcl 12-25
arg_descriptor_ptr                     automatic       pointer                  dcl 1-34
c_enum_const_dtype                     internal static fixed bin(17,0)          initial dcl 12-25
c_enum_dtype                           internal static fixed bin(17,0)          initial dcl 12-25
c_typeref_dtype                        internal static fixed bin(17,0)          initial dcl 12-25
c_union_dtype                          internal static fixed bin(17,0)          initial dcl 12-25
char_dtype                             internal static fixed bin(17,0)          initial dcl 12-25
cobol_char_string_dtype                internal static fixed bin(17,0)          initial dcl 12-25
cobol_comp_5_ts_dtype                  internal static fixed bin(17,0)          initial dcl 12-25
cobol_comp_5_uns_dtype                 internal static fixed bin(17,0)          initial dcl 12-25
cobol_comp_6_dtype                     internal static fixed bin(17,0)          initial dcl 12-25
cobol_comp_7_dtype                     internal static fixed bin(17,0)          initial dcl 12-25
cobol_comp_8_ls_dtype                  internal static fixed bin(17,0)          initial dcl 12-25
cobol_comp_8_uns_dtype                 internal static fixed bin(17,0)          initial dcl 12-25
cobol_display_ls_dtype                 internal static fixed bin(17,0)          initial dcl 12-25
cobol_display_ls_overp_dtype           internal static fixed bin(17,0)          initial dcl 12-25
cobol_display_ts_dtype                 internal static fixed bin(17,0)          initial dcl 12-25
cobol_display_ts_overp_dtype           internal static fixed bin(17,0)          initial dcl 12-25
cobol_display_uns_dtype                internal static fixed bin(17,0)          initial dcl 12-25
cobol_structure_dtype                  internal static fixed bin(17,0)          initial dcl 12-25
collection_manager_$allocate_control_interval
                                000000 constant        entry                    external dcl 10-50
collection_manager_$compact_control_interval
                                000000 constant        entry                    external dcl 10-52
collection_manager_$create_collection
                                000000 constant        entry                    external dcl 10-54
collection_manager_$create_file 000000 constant        entry                    external dcl 10-56
collection_manager_$delete      000000 constant        entry                    external dcl 10-64
collection_manager_$delete_from_ci_buffer
                                000000 constant        entry                    external dcl 10-67
collection_manager_$destroy_collection
                                000000 constant        entry                    external dcl 10-58
collection_manager_$free_control_interval
                                000000 constant        entry                    external dcl 10-60
collection_manager_$get_by_ci_ptr
                                000000 constant        entry                    external dcl 10-80
collection_manager_$get_control_interval_ptr
                                000000 constant        entry                    external dcl 10-74
collection_manager_$get_from_ci_buffer
                                000000 constant        entry                    external dcl 10-77
collection_manager_$get_header  000000 constant        entry                    external dcl 10-83
collection_manager_$get_id      000000 constant        entry                    external dcl 10-86
collection_manager_$get_portion 000000 constant        entry                    external dcl 10-89
collection_manager_$get_portion_by_ci_ptr
                                000000 constant        entry                    external dcl 10-97
collection_manager_$get_portion_from_ci_buffer
                                000000 constant        entry                    external dcl 10-93
collection_manager_$modify      000000 constant        entry                    external dcl 10-101
collection_manager_$modify_in_ci_buffer
                                000000 constant        entry                    external dcl 10-107
collection_manager_$modify_portion
                                000000 constant        entry                    external dcl 10-110
collection_manager_$modify_unprotected
                                000000 constant        entry                    external dcl 10-104
collection_manager_$postcommit_increments
                                000000 constant        entry                    external dcl 10-113
collection_manager_$put         000000 constant        entry                    external dcl 10-115
collection_manager_$put_header  000000 constant        entry                    external dcl 10-121
collection_manager_$put_in_ci_buffer
                                000000 constant        entry                    external dcl 10-118
collection_manager_$put_unprotected_header
                                000000 constant        entry                    external dcl 10-123
collection_manager_$replace_ci_buffer
                                000000 constant        entry                    external dcl 10-126
collection_manager_$setup_ci_buffer
                                000000 constant        entry                    external dcl 10-129
collection_manager_$simple_get_by_ci_ptr
                                000000 constant        entry                    external dcl 10-132
collection_manager_$simple_get_from_ci_buffer
                                000000 constant        entry                    external dcl 10-135
cplx_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 12-25
cplx_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 12-25
cplx_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 12-25
cplx_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 12-25
cplx_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 12-25
cplx_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 12-25
cplx_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 12-25
cplx_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 12-25
cplx_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 12-25
cplx_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 12-25
cplx_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 12-25
cplx_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 12-25
cplx_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 12-25
eil_number_of_elements                 automatic       fixed bin(35,0)          dcl 6-27
element_id_string                      automatic       bit(36)                  dcl 5-30
entry_dtype                            internal static fixed bin(17,0)          initial dcl 12-25
ext_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 12-125
ext_procedure_runtime_dtype            internal static fixed bin(17,0)          initial dcl 12-125
extended_arg_descriptor                based           structure                level 1 dcl 1-21
file_dtype                             internal static fixed bin(17,0)          initial dcl 12-25
fixed_arg_descriptor                   based           structure                level 1 dcl 1-13
ft_char_dtype                          internal static fixed bin(17,0)          initial dcl 12-96
ft_complex_double_dtype                internal static fixed bin(17,0)          initial dcl 12-96
ft_complex_dtype                       internal static fixed bin(17,0)          initial dcl 12-96
ft_double_dtype                        internal static fixed bin(17,0)          initial dcl 12-96
ft_external_dtype                      internal static fixed bin(17,0)          initial dcl 12-96
ft_hex_complex_double_dtype            internal static fixed bin(17,0)          initial dcl 12-96
ft_hex_complex_dtype                   internal static fixed bin(17,0)          initial dcl 12-96
ft_hex_double_dtype                    internal static fixed bin(17,0)          initial dcl 12-96
ft_hex_real_dtype                      internal static fixed bin(17,0)          initial dcl 12-96
ft_integer_dtype                       internal static fixed bin(17,0)          initial dcl 12-96
ft_logical_dtype                       internal static fixed bin(17,0)          initial dcl 12-96
ft_real_dtype                          internal static fixed bin(17,0)          initial dcl 12-96
general_typed_vector                   based           structure                level 1 packed packed unaligned dcl 9-24
general_typed_vector_ptr               automatic       pointer                  dcl 9-38
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 9-40
int_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 12-125
label_constant_runtime_dtype           internal static fixed bin(17,0)          initial dcl 12-125
label_dtype                            internal static fixed bin(17,0)          initial dcl 12-25
offset_dtype                           internal static fixed bin(17,0)          initial dcl 12-25
pascal_boolean_dtype                   internal static fixed bin(17,0)          initial dcl 12-132
pascal_char_dtype                      internal static fixed bin(17,0)          initial dcl 12-132
pascal_entry_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 12-132
pascal_enumerated_type_dtype           internal static fixed bin(17,0)          initial dcl 12-132
pascal_enumerated_type_element_dtype   internal static fixed bin(17,0)          initial dcl 12-132
pascal_enumerated_type_instance_dtype  internal static fixed bin(17,0)          initial dcl 12-132
pascal_exportable_procedure_dtype      internal static fixed bin(17,0)          initial dcl 12-132
pascal_imported_procedure_dtype        internal static fixed bin(17,0)          initial dcl 12-132
pascal_integer_dtype                   internal static fixed bin(17,0)          initial dcl 12-132
pascal_internal_procedure_dtype        internal static fixed bin(17,0)          initial dcl 12-132
pascal_label_dtype                     internal static fixed bin(17,0)          initial dcl 12-132
pascal_parameter_procedure_dtype       internal static fixed bin(17,0)          initial dcl 12-132
pascal_procedure_type_dtype            internal static fixed bin(17,0)          initial dcl 12-132
pascal_real_dtype                      internal static fixed bin(17,0)          initial dcl 12-132
pascal_record_file_type_dtype          internal static fixed bin(17,0)          initial dcl 12-132
pascal_record_type_dtype               internal static fixed bin(17,0)          initial dcl 12-132
pascal_set_dtype                       internal static fixed bin(17,0)          initial dcl 12-132
pascal_string_type_dtype               internal static fixed bin(17,0)          initial dcl 12-132
pascal_text_file_dtype                 internal static fixed bin(17,0)          initial dcl 12-132
pascal_typed_pointer_type_dtype        internal static fixed bin(17,0)          initial dcl 12-132
pascal_user_defined_type_dtype         internal static fixed bin(17,0)          initial dcl 12-132
pascal_user_defined_type_instance_dtype
                                       internal static fixed bin(17,0)          initial dcl 12-132
pascal_value_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 12-132
pascal_variable_formal_parameter_dtype internal static fixed bin(17,0)          initial dcl 12-132
picture_runtime_dtype                  internal static fixed bin(17,0)          initial dcl 12-125
pointer_dtype                          internal static fixed bin(17,0)          initial dcl 12-25
real_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 12-25
real_fix_bin_1_uns_dtype               internal static fixed bin(17,0)          initial dcl 12-25
real_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 12-25
real_fix_bin_2_uns_dtype               internal static fixed bin(17,0)          initial dcl 12-25
real_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 12-25
real_fix_dec_4bit_bytealigned_uns_dtype
                                       internal static fixed bin(17,0)          initial dcl 12-25
real_fix_dec_4bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 12-25
real_fix_dec_4bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 12-25
real_fix_dec_4bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 12-25
real_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 12-25
real_fix_dec_9bit_ls_overp_dtype       internal static fixed bin(17,0)          initial dcl 12-25
real_fix_dec_9bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 12-25
real_fix_dec_9bit_ts_overp_dtype       internal static fixed bin(17,0)          initial dcl 12-25
real_fix_dec_9bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 12-25
real_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 12-25
real_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 12-25
real_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 12-25
real_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 12-25
real_flt_dec_4bit_dtype                internal static fixed bin(17,0)          initial dcl 12-25
real_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 12-25
real_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 12-25
real_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 12-25
real_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 12-25
real_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 12-25
structure_dtype                        internal static fixed bin(17,0)          initial dcl 12-25
stv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 9-35
tva_maximum_dimension_name_length      automatic       fixed bin(17,0)          dcl 8-48
tva_number_of_dimensions               automatic       fixed bin(17,0)          dcl 8-46
tva_number_of_vector_slots             automatic       fixed bin(17,0)          dcl 8-44
varying_bit_dtype                      internal static fixed bin(17,0)          initial dcl 12-25
varying_char_dtype                     internal static fixed bin(17,0)          initial dcl 12-25

NAMES DECLARED BY EXPLICIT CONTEXT.
AOR_JOIN                        001235 constant        label                    dcl 342 ref 334
AOR_MAIN_RETURN                 001352 constant        label                    dcl 372 ref 382
AOR_RETURN                      001353 constant        entry                    internal dcl 375 ref 330 359 371
APPEND_OUTPUT_RECORD            001143 constant        entry                    internal dcl 295 ref 263
CHECK_VERSION                   001717 constant        entry                    internal dcl 502 ref 178 196 427 475 494
CHECK_VERSION_CHAR_8            002013 constant        entry                    internal dcl 517 ref 204
CREATE_OUTPUT_RECORD            001222 constant        entry                    internal dcl 336 ref 231
ERROR_RETURN                    001120 constant        entry                    internal dcl 284 ref 333 356 361 404 473
FINISH                          001075 constant        entry                    internal dcl 277 ref 213 273 289
GET_ELEMENT_ERROR_RETURN        001370 constant        entry                    internal dcl 387 ref 220 252
GET_REST_OF_RECORDS             000653 constant        label                    dcl 236
JOIN                            000321 constant        label                    dcl 187 ref 170 184
RETURN                          001073 constant        label                    dcl 274 ref 291
SETUP_ID_LIST                   001421 constant        entry                    internal dcl 409 ref 215
SETUP_OUTPUT_RECORDS            001503 constant        entry                    internal dcl 447 ref 239
array                           000261 constant        entry                    external dcl 173
rcm_get_record_by_id            000215 constant        entry                    external dcl 66
single                          000232 constant        entry                    external dcl 163

NAME DECLARED BY CONTEXT OR IMPLICATION.
unspec                                                 builtin function         ref 368

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2464        2532    2174        2474
Length      3222    2174        46         453     267           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rcm_get_record_by_id                440 external procedure  is an external procedure.  
on unit on line 213                  64 on unit               
FINISH                               66 internal procedure  is called by several nonquick procedures.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure rcm_get_record_by_id.  
APPEND_OUTPUT_RECORD                    internal procedure  shares stack frame of external procedure rcm_get_record_by_id.  
AOR_RETURN                              internal procedure  shares stack frame of external procedure rcm_get_record_by_id.  
GET_ELEMENT_ERROR_RETURN                internal procedure  shares stack frame of external procedure rcm_get_record_by_id.  
SETUP_ID_LIST                           internal procedure  shares stack frame of external procedure rcm_get_record_by_id.  
SETUP_OUTPUT_RECORDS                    internal procedure  shares stack frame of external procedure rcm_get_record_by_id.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure rcm_get_record_by_id.  
CHECK_VERSION_CHAR_8                    internal procedure  shares stack frame of external procedure rcm_get_record_by_id.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rcm_get_record_by_id     000100 get_array_of_records        rcm_get_record_by_id
                         000101 get_single_record           rcm_get_record_by_id
                         000102 record_id                   rcm_get_record_by_id
                         000103 record_id_field_id          rcm_get_record_by_id
                         000104 record_idx                  rcm_get_record_by_id
                         000105 record_string_length        rcm_get_record_by_id
                         000106 record_string_ptr           rcm_get_record_by_id
                         000110 field_table_ptr             rcm_get_record_by_id
                         000112 descriptor_string_ptr       rcm_get_record_by_id
                         000114 new_buffer_was_allocated    rcm_get_record_by_id
                         000114 local_record_buffer         rcm_get_record_by_id
                         000116 record_buffer_ptr           rcm_get_record_by_id
                         000120 record_buffer_length        rcm_get_record_by_id
                         000122 dm_work_area_ptr            rcm_get_record_by_id
                         000132 extended_arg_type           rcm_get_record_by_id
                         000134 record_cursor_ptr           rcm_get_record_by_id
                         000136 record_collection_opening_info_ptr
                                                            rcm_get_record_by_id
                         000140 id_list_ptr                 rcm_get_record_by_id
                         000142 il_number_of_ids            rcm_get_record_by_id
                         000144 element_id_list_ptr         rcm_get_record_by_id
                         000146 ELEMENT_ID_LIST_VERSION_1   rcm_get_record_by_id
                         000150 typed_vector_array_ptr      rcm_get_record_by_id
                         000152 simple_typed_vector_ptr     rcm_get_record_by_id
                         000176 aor_vector_ptr              APPEND_OUTPUT_RECORD
                         000200 aor_record_id_ptr           APPEND_OUTPUT_RECORD
                         000202 aor_set_result_ptr_to_new_vector
                                                            APPEND_OUTPUT_RECORD
                         000204 aor_typed_vector_array_ptr  APPEND_OUTPUT_RECORD
                         000206 aor_code                    APPEND_OUTPUT_RECORD
                         000240 sor_record_id_descriptor_ptr
                                                            SETUP_OUTPUT_RECORDS
                         000242 sor_code                    SETUP_OUTPUT_RECORDS

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          alloc_auto_adj
enable_op           ext_entry           int_entry           op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
collection_manager_$get       data_format_util_$cv_table_to_typed_array
data_format_util_$new_cv_string_to_vector                   dm_vector_util_$append_simple_typed_vector
dm_vector_util_$free_typed_vector                           get_dm_free_area_             rcm_get_opening_info
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$ci_not_allocated    dm_error_$ci_not_in_collection                              dm_error_$no_element
dm_error_$record_not_found    dm_error_$wrong_cursor_type   error_table_$area_too_small
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     87 000154        88 000155        90 000156        93 000160        94 000162        95 000163        96 000164
     98 000172       100 000173       101 000175       102 000177    1   36 000201    3   22 000203    4   21 000205
 4   22 000206    6   28 000210        66 000214        69 000223       163 000224       166 000240       167 000242
    168 000245       169 000250       170 000252       173 000253       176 000267       178 000273       180 000306
    181 000311       182 000312       183 000314       184 000320       187 000321       190 000323       192 000326
    196 000405       199 000422       201 000441       204 000444       207 000466       209 000471       211 000500
    213 000502       215 000524       217 000537       220 000575       223 000606       226 000611       227 000613
    231 000615       234 000645       239 000653       242 000701       243 000704       245 000720       247 000731
    249 000734       252 000772       255 001003       258 001006       260 001021       261 001023       263 001025
    265 001055       266 001057       270 001062       271 001065       273 001067       274 001073       277 001074
    279 001102       281 001117       284 001120       289 001122       290 001126       291 001132       314 001134
    315 001136       316 001137       318 001140       295 001143       322 001146       323 001152       325 001153
    327 001154       330 001207       333 001217       334 001221       336 001222       339 001225       340 001227
    341 001233       342 001235       345 001261       349 001266       352 001272       354 001275       356 001312
    359 001316       360 001320       361 001321       363 001323       366 001327       367 001336       368 001345
    371 001350       372 001352       375 001353       378 001355       379 001360       381 001365       382 001367
    387 001370       397 001372       399 001400       401 001405       404 001412       406 001420       409 001421
    419 001423       420 001426       423 001432       424 001434       427 001435       428 001460       431 001465
    432 001467       433 001471       436 001472       439 001500       443 001502       447 001503       467 001505
    470 001511       471 001512       473 001536       475 001542       477 001571       480 001575       481 001604
    482 001606       483 001612       484 001614       485 001620       486 001622       487 001655       490 001665
    493 001666       494 001671       498 001716       502 001717       509 001730       514 002012       517 002013
    524 002024       529 002114


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
