	COMPILATION LISTING OF SEGMENT generate_def_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/20/86  1219.8 mst Thu
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 
        8 /****^  HISTORY COMMENTS:
        9*  1) change(85-09-24,Elhard), approve(85-09-24,MCR7198),
       10*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
       11*     Improved documentation, changed errname to use the caller-supplied name
       12*     instead of  "binder_", deleted support for obsolete non-standard objects.
       13*                                                   END HISTORY COMMENTS */
       14 
       15 /* format: style3,^indnoniterdo */
       16 
       17 /* ******************************************************
       18*   *                                                    *
       19*   *                                                    *
       20*   * Copyright (c) 1972 by Massachusetts Institute of   *
       21*   * Technology and Honeywell Information Systems, Inc. *
       22*   *                                                    *
       23*   *                                                    *
       24*   ****************************************************** */
       25 
       26 /* ******************************************************
       27*   *                                                    *
       28*   *                                                    *
       29*   * Copyright (c) 1978 by Massachusetts Institute of   *
       30*   * Technology and Honeywell Information Systems, Inc. *
       31*   *                                                    *
       32*   *                                                    *
       33*   ****************************************************** */
       34 
       35 /**********************************************************************/
       36 /*							*/
       37 /*	Name:	generate_def_				*/
       38 /*	Input:	compent_ptr, definition_ptr			*/
       39 /*	Function:	given a pointer to the current component_table	*/
       40 /*		entry (compent_ptr) and a pointer to an insym	*/
       41 /*		entry (definition_ptr), regenerates the specfied	*/
       42 /*		definition in the definition section of the new	*/
       43 /*		bound object_segment and threads it in place. The	*/
       44 /*		references are relocated and any links referenced	*/
       45 /*		by the definitions (as in pascal exported vars)	*/
       46 /*		are generated.				*/
       47 /*	Ouptut:	none					*/
       48 /*							*/
       49 /**********************************************************************/
       50 
       51 
       52 /* Designed and initially coded by Michael J. Spier, October 6, 1970	*/
       53 /* modified  June, july 1975 by M. Weaver for separate static */
       54 /* modified Sept 1978 by David Spector for hash-coding strm */
       55 /* modified Sept 82 by JMAthane for PASCAL exportable variables definitions */
       56 
       57 generate_def_:
       58      procedure (compent_ptr, definition_ptr);
       59 
       60 declare	(compent_ptr, definition_ptr)
       61 			pointer;
       62 
       63 /* DECLARATION OF CONSTANTS */
       64 
       65 declare	lda_pr0_instr	bit (18) static options (constant) init ("010011101001010000"b);
       66 
       67 /* DECLARATION OF EXTERNAL SYMBOLS */
       68 
       69 declare	com_err_		external entry options (variable);
       70 declare	strm_hash_$lookup	external entry (char (*), fixed bin (17));
       71 declare	strm_hash_$make_entry
       72 			external entry (char (*), fixed bin (17));
       73 declare	int_link_		entry (ptr) returns (bit (1));
       74 declare	decode_link_	entry (ptr) returns (bit (1));
       75 declare	ext_link_		entry (ptr);
       76 
       77 /* DECLARATION OF INTERNAL STATIC VARIABLES */
       78 
       79 declare	(defbase, linkbase) pointer internal static;
       80 declare	inlink		fixed bin internal static;
       81 declare	errname		char (16) aligned internal static;
       82 
       83 /* DECLARATION OF AUTOMATIC STORAGE VARIABLES */
       84 
       85 declare	(i, linkoffset)	fixed bin;
       86 declare	defoffset		fixed bin (18);
       87 declare	(p, ip, dp, sp, lp, dsp)
       88 			pointer;
       89 dcl	1 my_ext		aligned like external_ref;
       90 
       91 dcl	generate_ext_link	bit (1) init ("0"b);
       92 
       93 /* DECLARATION OF BUILTIN FUNCTIONS */
       94 
       95 declare	(addr, addrel, bin, bit, divide, fixed, substr)
       96 			builtin;
       97 
       98 /* DECLARATION OF BASED STRUCTURES */
       99 
      100 declare	1 new_def		aligned based (dp),
      101 	  2 forward_relp	unal fixed bin (18) unsigned,
      102 	  2 backward_relp	unal fixed bin (18) unsigned,
      103 	  2 thing_relp	unal fixed bin (18) unsigned,
      104 	  2 flags		unal like definition_flags,
      105 	  2 class		unal fixed bin (3) unsigned,
      106 	  2 name_relp	unal fixed bin (18) unsigned,
      107 	  2 segname_relp	unal fixed bin (18) unsigned,
      108 	  2 n_args	unal fixed bin (18) unsigned,
      109 	  2 descriptor_relp (0 refer (new_def.n_args)) unal fixed bin (18) unsigned;
      110 declare	1 last_def	aligned like new_def based (lp);
      111 declare	1 insyme		aligned like is based (sp);
      112 
      113 declare	descr_list	(1000) unal fixed bin (18) unsigned based (dsp);
      114 						/* based on descriptor ptrs in def */
      115 
      116 declare	1 dum_instr	aligned,
      117 	  2 register	bit (3) unaligned,
      118 	  2 rel_address	bit (15) unaligned,
      119 	  2 op_code	bit (18) unaligned;
      120 declare	acc_string_overlay	char (257) aligned based;
      121 
      122 
      123 	ctp = bx_$ctp;
      124 	strmp = bx_$strmp;
      125 	ctep = compent_ptr;				/* copy pointer to current component table entry */
      126 	sp = definition_ptr;			/* copy pointer to definition entry */
      127 	if insyme.regenerated = "1"b
      128 	then return;
      129 
      130 	ip = comp.insymentp;			/* pointer to component's definitions */
      131 
      132 	defoffset = bx_$curdeflng;			/* get current size of definition section */
      133 	linkoffset = bx_$tlinklng;			/* get current length of new linkage section */
      134 
      135 	dp = addrel (defbase, defoffset);		/* pointer to location where new def will be generated */
      136 	if comp.defblockp = "0"b
      137 	then do;
      138 	     comp.defblockp, comp.current_def = bit (bin (defoffset, 18), 18);
      139 						/* remember current definition */
      140 	end;
      141 	else do;
      142 	     lp = addrel (defbase, comp.current_def);	/* pointer to last def  */
      143 	     new_def.backward_relp = fixed (comp.current_def, 18);
      144 						/* backwards pointer */
      145 	     last_def.forward_relp = defoffset;		/* thread defs together */
      146 	     comp.current_def = bit (bin (defoffset, 18), 18);
      147 						/* remember last def */
      148 	end;
      149 	insyme.defrel = comp.current_def;
      150 	new_def.thing_relp = fixed (insyme.value, 18);	/* copy value of definition */
      151 	new_def.class = fixed (insyme.class, 18);	/* class of definition */
      152 	new_def.flags.new = "1"b;			/* and set new format flag */
      153 	defoffset = defoffset + 3;			/* grow def section by 3 words */
      154 
      155 /* now copy descriptor ptrs, if they exist for this entry */
      156 /* if ^insyme.has_descr then descriptors may be invalid, but copy them anyway */
      157 
      158 	if insyme.nargs > 0
      159 	then do;					/* entry has descriptors */
      160 	     new_def.flags.argcount = "1"b;		/* indicate we have arg count */
      161 	     if insyme.has_descr
      162 	     then new_def.flags.descriptors = "1"b;	/* have valid descriptors */
      163 	     new_def.n_args = insyme.nargs;
      164 	     dsp = insyme.descr_ptr;			/* initialize for better referencing */
      165 	     do i = 1 to insyme.nargs;		/* copy and relocate ptrs */
      166 		new_def.descriptor_relp (i) = descr_list (i) + comp.crelt;
      167 	     end;
      168 	     defoffset = defoffset + divide (insyme.nargs + 2, 2, 17, 0);
      169 						/* grow def section by length of array */
      170 	end;
      171 
      172 	if bx_$standard = 1
      173 	then if insyme.retain_flag
      174 	     then new_def.flags.retain = "1"b;		/* turn on only if on before */
      175 
      176 /* now lookup generated strings to see if one can be reused */
      177 
      178 	call strm_hash_$lookup (substr (insyme.symbol, 1, insyme.lng), i);
      179 	if i ^= 0
      180 	then do;					/* string is already in strm */
      181 	     new_def.name_relp = fixed (strm.entry (i).map, 18);
      182 	     goto adjust_value;
      183 	end;
      184 
      185 /* string not found, generate string and put into map */
      186 
      187 	i, strm.nstr = strm.nstr + 1;
      188 	if strm.nstr > strm.max_size
      189 	then do;
      190 	     call com_err_ (0, errname, "stringmap table overflow; please contact maintenance");
      191 	     strm.nstr = 1;
      192 	     bx_$fatal_error = 1;
      193 	end;
      194 	new_def.name_relp = defoffset;		/* pointer to newly generated symbol string */
      195 	strm.entry (i).map = bit (bin (defoffset, 18), 18);
      196 	p = addrel (defbase, defoffset);		/* pointer to new string */
      197 	substr (p -> acc_string_overlay, 1, insyme.lng) = substr (insyme.symbol, 1, insyme.lng);
      198 	defoffset = defoffset + divide (insyme.lng + 3, 4, 17, 0);
      199 						/* grow definition section */
      200 
      201 	call strm_hash_$make_entry (substr (insyme.symbol, 1, insyme.lng), i);
      202 
      203 /* now compute the value of the new definition */
      204 
      205 adjust_value:
      206 	bx_$nsymdefs = bx_$nsymdefs + 1;
      207 
      208 	if new_def.class = 0
      209 	then /* simple text reference */
      210 	     do;
      211 	     new_def.thing_relp = new_def.thing_relp + comp.crelt;
      212 
      213 	     if comp.standard_object = 1
      214 	     then /* have to do some extra fiddling here */
      215 		do;
      216 		if insyme.entrypoint
      217 		then new_def.flags.entry = "1"b;	/* standard entries are only text */
      218 		if (insyme.ignore) | (insyme.delete)
      219 		then do;
      220 		     new_def.flags.ignore = "1"b;	/* need this for name but don't want linker to find it */
      221 		     bx_$nsymdefs = bx_$nsymdefs - 1;
      222 		end;
      223 	     end;
      224 	     goto return;
      225 	end;
      226 	else if new_def.class = 2
      227 	then /* reference relative to symbol section */
      228 	     do;
      229 	     new_def.thing_relp = new_def.thing_relp + comp.crels;
      230 						/* get value of symbol */
      231 	     goto return;
      232 	end;
      233 	else if new_def.class = 1
      234 	then do;
      235 	     if new_def.thing_relp < comp.clngi + 8
      236 	     then do;				/* this is an ALM segdef located in the linkage section */
      237 		new_def.thing_relp = new_def.thing_relp + comp.creli;
      238 		goto return;
      239 	     end;
      240 	     else do;
      241 		if comp.compiler = "PASCAL  "
      242 		then do;
      243 
      244 /* We have a definition for a link, i.e. for a Pascal exportable variable which
      245*   is represented by a link.  We must regenerate the link.  To do this,
      246*   we fabricate an "instruction" that references the link along with the other
      247*   link info.  The link may indirect through another link that may be in
      248*   another component.  To handle this case, we must first call int_link_ to 
      249*   regenerate the correct target for this definition's link. */
      250 
      251 		     dum_instr.rel_address = bit (bin (new_def.thing_relp, 15), 15);
      252 		     dum_instr.register = "000"b;
      253 		     dum_instr.op_code = lda_pr0_instr; /* make instruction = lda 0|nn,* */
      254 		     my_ext.ref_ptr = addr (dum_instr);
      255 		     my_ext.dont_prelink = "0"b;
      256 		     my_ext.compent_ptr = ctep;
      257 		     my_ext.loffset = new_def.thing_relp;
      258 		     my_ext.side = "lhe";
      259 		     my_ext.relinfo = "link15";
      260 		     my_ext.dont_relocate = "0"b;
      261 		     if decode_link_ (addr (my_ext)) = "1"b
      262 		     then go to error_skip;
      263 		     generate_ext_link = "1"b;
      264 		     go to return;
      265 		end;
      266 	     end;
      267 	end;
      268 	else if new_def.class = 4
      269 	then do;					/* segdef in separate static  */
      270 	     if bx_$bound_sep_stat = 1
      271 	     then i = 0;				/*  will still have separate static */
      272 	     else do;				/* static will be in linkage section */
      273 		new_def.class = 1;			/* change to  linkage */
      274 		i = 8;				/* now static  will be further offset by linkage header */
      275 	     end;
      276 	     new_def.thing_relp = new_def.thing_relp + comp.creli + i;
      277 	     goto return;
      278 	end;
      279 	call com_err_ (0, errname, "definition ^a in file ^a has illegal class ^o",
      280 	     substr (insyme.symbol, 2, insyme.lng - 1), comp.filename, new_def.class);
      281 
      282 error_skip:
      283 	bx_$fatal_error = 1;
      284 
      285 return:
      286 	insyme.regenerated = "1"b;			/* indicate that this def has been regenerated */
      287 	if ^new_def.flags.ignore
      288 	then ip -> insym.retained = "1"b;		/* indicate that a def was retained for this component */
      289 	bx_$curdeflng = defoffset;			/* update length of new definition section */
      290 	bx_$tlinklng = linkoffset;			/* update length of new linkage section */
      291 
      292 	if generate_ext_link
      293 	then do;
      294 	     if int_link_ (addr (my_ext)) = "1"b
      295 	     then do;
      296 		my_ext.segname = "*link";
      297 		my_ext.slng = 6;
      298 		my_ext.elng = 0;
      299 		my_ext.code15, my_ext.type = "000000000000000001"b;
      300 		my_ext.expr = "000"b || dum_instr.rel_address;
      301 	     end;
      302 	     call ext_link_ (addr (my_ext));
      303 	     new_def.thing_relp = fixed (dum_instr.rel_address, 15);
      304 	end;
      305 
      306 	return;
      307 
      308 
      309 
      310 
      311 
      312 init:
      313      entry;
      314 
      315 	defbase = bx_$tdefp;			/* pointer to base of new definition section */
      316 	linkbase = bx_$tlinkp;			/* pointer to base of new linkage section */
      317 	inlink = 0;				/* reset pointer to inbound link */
      318 	if bx_$debug = 1
      319 	then errname = "generate_def_";
      320 	else errname = bx_$caller;
      321 
      322 	return;
      323 
      324 
  1     1 
  1     2 	/* the following is include file extref.incl.pl1  */
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-09-24,Elhard), approve(85-09-24,MCR7198),
  1     7*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
  1     8*     changed to be a complete structure rather than a starting with a level 2
  1     9*     variable.
  1    10*                                                   END HISTORY COMMENTS */
  1    11 
  1    12 declare	1 external_ref aligned based,
  1    13 	2 compent_ptr pointer,		/* pointer to referencing component's entry */
  1    14 	2 ref_ptr pointer,			/* pointer to referencing textword */
  1    15 	2 offset fixed bin(18),		/* offset of referencing instruction in text */
  1    16 	2 side char(3) aligned,		/* 'rhe' or 'lhe' for referencing halfword */
  1    17 	2 relinfo char(8) aligned,		/* symbolic relocation information */
  1    18 	2 section char(4) aligned,		/* referencing section of object */
  1    19 	2 loffset fixed bin,		/* link's offset in linkage section */
  1    20 	2 segname char(33) aligned,		/* segname part of external name */
  1    21 	2 slng fixed bin,			/* length of preceeding ACC string (incl count) */
  1    22 	2 entryname char(257) aligned,		/* entry part of external name */
  1    23 	2 elng fixed bin,			/* length of preceeding ACC string (incl count) */
  1    24 	2 type bit(18) unaligned,		/* type of link */
  1    25 	2 trap bit(18) unaligned,		/* trap before link if non-zero */
  1    26 	2 expr bit(18) unaligned,		/* the expression value */
  1    27 	2 code15 bit(18) unaligned,		/* if type of link is 1 or 5, this is the segbase code */
  1    28 	2 dont_prelink bit(1) unaligned,	/* if = "1" then dont snap internal link */
  1    29 	2 link_tm bit(2) unaligned,		/* the original link's TM modifier */
  1    30 	2 link_td bit(4) unaligned,		/* the original link's TD modifier */
  1    31 	2 dont_relocate bit (1) unaligned,	/* "1"b -> no referencing instruction */
  1    32 	2 padding(2) fixed bin;		/* to isolate from other variables */
      325 
      326 
  2     1 /****  START OF:	bindext.incl.pl1			 *  *  *  *  *  */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(86-06-14,Elhard), approve(86-06-14,MCR7198),
  2     6*     audit(86-06-30,Weaver):
  2     7*     Added declarations for bx_$caller and bx_$temp_bsegp.
  2     8*                                                   END HISTORY COMMENTS */
  2     9 
  2    10 /* DECLARATION OF BINDER'S MAIN DATABASE */
  2    11 
  2    12 /* include file bindext.incl.pl1 */
  2    13 
  2    14 /* Modified Sept 1978 by David Spector for using "get_temp_segment_" in temp_mgr_ */
  2    15 /* Modified Dec 1978 by David Spector for making repatch table automatically extensible */
  2    16 /* Modified 01/15/81 W. Olin Sibert for new options */
  2    17 
  2    18 declare  bx_$vers_name char (168) aligned external;	/* ASCII version name, in ACC form */
  2    19 declare  bx_$vers_number fixed bin external;		/* integer part of version number */
  2    20 declare  bx_$size fixed bin external;			/* size of main data base, for resetting */
  2    21 declare  bx_$snt_limit fixed bin external;		/* preset limit for segname table */
  2    22 declare  bx_$oddname_limit fixed bin external;		/* preset limit for oddname table */
  2    23 declare  bx_$stringmap_limit fixed bin external;		/* preset limit for stringmap table */
  2    24 declare  bx_$addname_limit fixed bin external;		/* preset limit for addname table */
  2    25 declare  bx_$area_begin fixed bin (18) external;		/* beginning of main data base */
  2    26 declare  bx_$ctp pointer external;			/* pointer to component table */
  2    27 declare  bx_$freep pointer external;			/* pointer to beginning of free area */
  2    28 declare  bx_$isp pointer external;			/* pointer to first insym table */
  2    29 declare  bx_$inpp pointer external;			/* pointer to binder's input structure */
  2    30 declare  bx_$bsegp pointer external;			/* pointer to base of new object segment */
  2    31 declare  bx_$temp pointer external;			/* pointer to threaded list of temp segments */
  2    32 declare  bx_$optp pointer external;			/* pointer to options table */
  2    33 declare  bx_$odnp pointer external;			/* pointer to oddname table */
  2    34 declare  bx_$first_rptp pointer external;		/* pointer to first chunk of repatch table */
  2    35 declare  bx_$last_rptp pointer external;		/* pointer to current chunk of threaded repatch table */
  2    36 declare  bx_$adnp pointer external;			/* pointer to addname table */
  2    37 declare  bx_$bindmap_def pointer external;		/* pointer to new object's "bind_map" definition */
  2    38 declare  bx_$bdefp pointer external;			/* pointer to new object's definition section */
  2    39 declare  bx_$bstatp pointer external;			/* pointer to new object's static section */
  2    40 declare  bx_$blnkp pointer external;			/* pointer to new object's linkage section */
  2    41 declare  bx_$bsymp pointer external;			/* pointer to new object's symbol section */
  2    42 declare  bx_$sntp pointer external;			/* pointer to segname table */
  2    43 declare  bx_$tdefp pointer external;			/* pointer to temporary new definition section */
  2    44 declare  bx_$tintp pointer external;			/* pointer to temporary new internal static */
  2    45 declare  bx_$tlinkp pointer external;			/* pointer to temporary new linkage section */
  2    46 declare  bx_$strmp pointer external;			/*  pointer to stringmap table */
  2    47 declare  bx_$n_firstrefs fixed bin external;		/* count of components with firstref traps */
  2    48 declare  bx_$bound_segname char (32) aligned external;	/* name of new bound object */
  2    49 declare  bx_$fatal_error fixed bin external;		/* 1 -> fatal error was detected */
  2    50 declare  bx_$bseg_acinfop pointer external;		/* new object's acinfop for "tssi_" */
  2    51 declare  bx_$bseg_bitcount fixed bin (24) external;	/* new object's bitcount */
  2    52 declare  bx_$o_lng fixed bin (19) external;		/* length of new bound object */
  2    53 declare  bx_$t_lng fixed bin (18) external;		/* length of new text section */
  2    54 declare  bx_$d_lng fixed bin (18) external;		/* length of new definition section */
  2    55 declare  bx_$i_lng fixed bin external;			/* length of new static section */
  2    56 declare  bx_$l_lng fixed bin external;			/* length of new linkage section */
  2    57 declare  bx_$s_lng fixed bin (18) external;		/* length of new symbol section */
  2    58 declare  bx_$addname fixed bin external;		/* 1 -> addname option specified */
  2    59 declare  bx_$debug fixed bin external;			/* 1 -> debug option was specified */
  2    60 declare  bx_$brief fixed bin external;			/* 1 -> brief option was specified */
  2    61 declare  bx_$force_order fixed bin external;		/* 1 -> -force_order specified on command line */
  2    62 declare  bx_$has_sep_stat fixed bin external;		/* 1 -> a comp has nonzero sep static */
  2    63 declare  bx_$has_comb_stat fixed bin external;		/* 1 -> a comp has nonzero combined static */
  2    64 declare  bx_$bound_sep_stat fixed bin external;		/* 1 -> bound segment has separate static */
  2    65 declare  bx_$perprocess_static fixed bin external;	/* 1 -> bound segment has perprocess static switch on */
  2    66 declare  bx_$standard fixed bin external;		/* 1 -> bound seg is in standard format */
  2    67 declare  bx_$bproc fixed bin external;			/* 1 -> at least one component is a procedure */
  2    68 declare  bx_$textlng fixed bin (18) external;		/* length of new pure text portion */
  2    69 declare  bx_$curdeflng fixed bin (18) external;		/* current length of new definition section */
  2    70 declare  bx_$tintlng fixed bin external;		/* current length of new internal static */
  2    71 declare  bx_$maxlinklng fixed bin external;		/* maximum size linkage section may attain */
  2    72 declare  bx_$maxdeflng fixed bin (18) external;		/* maximum size definition section may attain */
  2    73 declare  bx_$tlinklng fixed bin external;		/* current size of linkage section */
  2    74 declare  bx_$ncomp fixed bin external;			/* number of component objects to be bound */
  2    75 declare  bx_$v_lng fixed bin external;			/* length of version name string */
  2    76 declare  bx_$n_lng fixed bin external;			/* length of bound segment name string */
  2    77 declare  bx_$nsymdefs fixed bin external;		/* count of non-null symbol definitions */
  2    78 declare  bx_$nsegdefs fixed bin external;		/* count of non-null segment name definitions */
  2    79 declare  bx_$temp_bsegp ptr external;			/* pointer to the temporary bound seg in the process dir */
  2    80 declare  bx_$caller char (32) aligned external;		/* name of the caller of bind_ for error messages */
  2    81 
  2    82 /****  END OF:	bindext.incl.pl1			 *  *  *  *  *  */
      327 
      328 
  3     1 	/* Include file comptbl.incl.pl1 */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(85-09-24,Elhard), approve(85-09-24,MCR7198),
  3     6*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
  3     7*     added link_regeneration_table pointer (clrtp) to component structure.
  3     8*                                                   END HISTORY COMMENTS */
  3     9 
  3    10 declare	(ctp, ctep) pointer;
  3    11 
  3    12 declare	comp_tbl(1000) pointer based(ctp);
  3    13 
  3    14 
  3    15 
  3    16 declare	1 comp aligned based(ctep),		/* declaration of a component entry */
  3    17 	2 filename char(32) aligned,		/* object segment's file name */
  3    18 	2 compiler char(8) aligned,		/* name of compiler which produced this object */
  3    19 	2 format char(8) aligned,		/* format of object code (PL/1, ALM etc.)  */
  3    20 
  3    21 	2 ctxtp pointer,			/* pointer to base of text section */
  3    22 	2 cdefp pointer,			/* pointer to definitions */
  3    23 	2 cstatp pointer,			/* pointer to static section */
  3    24 	2 clnkp pointer,			/* pointer to head of linkage section */
  3    25 	2 csymp pointer,			/* pointer to symbol table */
  3    26 	2 cfrtp pointer,			/* pointer to first ref trap array */
  3    27 	2 crltp pointer,			/* pointer to rel-text */
  3    28 	2 crllp pointer,			/* pointer to rel-link */
  3    29 	2 crlsp pointer,			/* pointer to rel-symb */
  3    30 	2 insymentp pointer,		/* pointer to this component's insym table entry */
  3    31 	2 clrtp pointer,			/* pointer to link_regeneration_table */
  3    32 	2 unused_1 pointer,			/* reserve */
  3    33 	2 unused_2 pointer,			/* reserve */
  3    34 	2 unused_3 fixed bin,		/* reserve */
  3    35 	2 cindex fixed bin,			/* this entry's index in table */
  3    36 	2 standard_object fixed bin,		/* 1 -> this object has standard format */
  3    37 	2 defthread fixed bin,		/* beginning of comp's definition block */
  3    38 	2 fn_lng fixed bin,			/* length of filename string */
  3    39 	2 ignore fixed bin,			/* 1->ignore erroneous entry */
  3    40 	2 io_table fixed bin,		/* 1 -> symbol table needed for io */
  3    41 	2 table_deleted fixed bin,		/* 1 -> symbol table is being deleted */
  3    42 	2 separate_static fixed bin,		/* 1 -> component has nonzero separate static */
  3    43          (2 defblockp,			/* rel pointer to component's definition block */
  3    44 	2 current_def) bit(18) unaligned,	/* rel pointer to component's current def */
  3    45 	2 cbitcount fixed bin(24),		/* bitcount of component segment */
  3    46 	2 clngt fixed bin(18),		/* length of pure text section */
  3    47 	2 cpadt fixed bin,			/* number of added padwords for text */
  3    48 	2 clngd fixed bin(18),		/* length of definition section */
  3    49 	2 clngi fixed bin,			/* length of internal static */
  3    50 	2 cpadi fixed bin,			/* number of added padwords for internal static  */
  3    51 	2 clngs fixed bin(18),		/* length of original symbol table */
  3    52 	2 clngns fixed bin(18),		/* length of new symb section stripped of relbits */
  3    53 	2 clngss fixed bin(18),		/* length of symbol section minus relbits and table */
  3    54 	2 cpads fixed bin,			/* padding length if section length is odd */
  3    55 	2 n_sym_blks fixed bin,		/* number of symbol blocks */
  3    56 
  3    57 	2 crelt fixed bin,			/* relocation value for text */
  3    58 	2 creli fixed bin,			/* relocation value for internal static */
  3    59 	2 crels fixed bin,			/* relocation value for symbol section */
  3    60 	2 last_item fixed bin;		/*** MUST ALWAYS BE LAST IN STRUCTURE ***/
  3    61  
  3    62 
  3    63 
      329 
      330 
  4     1 	/* Include file bndtbl.incl.pl1 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(85-09-24,Elhard), approve(85-09-24,MCR7198),
  4     6*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
  4     7*     Added link_regeneration_table and eliminated the use of "p" as a pointer
  4     8*     to base structures on..
  4     9*                                                   END HISTORY COMMENTS */
  4    10 
  4    11 	/* DIVERSE BINDER TABLES */
  4    12 
  4    13 	/* Modified Oct 1978 by David Spector for hash coding snt and strm */
  4    14 	/* Modified Dec 1978 by David Spector for making repatch table
  4    15*	   automatically extensible */
  4    16 	
  4    17 declare	(sntp, adnp, odnp, rptp, rptep, strmp, lrtp) pointer;
  4    18 
  4    19 	/* The SEGNAME table  -  segnames and synonyms of all components */
  4    20 
  4    21 declare	1 snt aligned based(sntp),
  4    22 	2 hash_table (0:210) unaligned ptr,	/* prime length */
  4    23 	2 max_size fixed bin,		/* size limit of allocated segname table */
  4    24 	2 n_names fixed bin,		/* number of segname-table entries used */
  4    25 	2 entry(1000) like seg;
  4    26 
  4    27 	/* declaration of a SEGNAME entry */
  4    28 
  4    29 declare	1 seg aligned based,		/* redeclaration of a single segname */
  4    30 	  2 name char(33) aligned,		/* segname in ACC string format */
  4    31 	  2 lng fixed bin,			/* length of segname, incl ACC count */
  4    32 	  2 addname fixed bin,		/* 1-> add name to bound segment */
  4    33 	  2 defrel bit(18),			/* offset in defs of new definition */
  4    34 	  2 comp pointer,			/* pointer to associated component table */
  4    35 	  2 hash_thread ptr;		/* thread to next "seg" in bucket */
  4    36 
  4    37 
  4    38 	/* the ADDNAME table  - list of names specified by "Addname" statement */
  4    39 
  4    40 declare	1 an aligned based(adnp),
  4    41 	2 max_size fixed bin,		/* size limit of addname table */
  4    42 	2 n_an fixed bin,			/* number of names to add */
  4    43 	2 syn(1000) char(32) aligned;		/* contains the names to be added */
  4    44 
  4    45 
  4    46 	/* The ODDNAME table  -  scratchpad memory to suppress redundant error messages */
  4    47 
  4    48 declare	1 od aligned based(odnp),
  4    49 	2 max_size fixed bin,		/* max size of table */
  4    50 	2 n_odds fixed bin,			/* current size of table */
  4    51 	2 entry(1000),
  4    52 	  3 name char(289) aligned;
  4    53 
  4    54 
  4    55 	/* The REPATCH table  -  of halfwords to be relocated at a later time */
  4    56 
  4    57 declare	1 rpt aligned based(rptp),
  4    58 	2 thread unaligned ptr,			/* To next rpt (null at end) */
  4    59 	2 npt fixed bin,
  4    60 	2 entry(1000) like rpte aligned;
  4    61 
  4    62 
  4    63 declare	1 rpte aligned based(rptep),		/* declaration of single repatch table entry */
  4    64 	2 poffset bit(18) unaligned,		/* offset into text of word to be patched */
  4    65 	2 pexpr bit(18) unaligned,		/* value to add to patched halfword */
  4    66 	2 halfword char(3) aligned,		/* designates wordhalf to be patched */
  4    67 	2 pbase char(1) unaligned,		/* section designator of word to be patched */
  4    68 	2 code char(1) unaligned;		/* code of section base to be used as patch value */
  4    69 
  4    70 
  4    71 	/* The STRINGMAP table - to avoid redundant strings in definition section */
  4    72 
  4    73 declare	1 strm aligned based(strmp),
  4    74 	2 hash_table (0:862) fixed bin(17),	/* prime length */
  4    75 	2 max_size fixed bin,
  4    76 	2 nstr fixed bin,
  4    77 	2 entry(2048) unaligned,
  4    78 	  3 map bit(18),			/* rel pointer to string in def section */
  4    79 	  3 hash_thread fixed bin(17);	/* index of next strm.entry in hash bucket */
  4    80 
  4    81 	/* The LINK_REGENERATION table - to flag links which have and  */
  4    82 	/* have not been regenerated to insure generation of all links */
  4    83 	
  4    84 declare	1 lrt		aligned based (lrtp),
  4    85 	  2 count		fixed bin,
  4    86 	  2 start_offset	fixed bin (18) unsigned,
  4    87 	  2 regenerated (0 refer (lrt.count))
  4    88 			bit (18) unaligned;
  4    89 
  4    90 declare	UNRESOLVED	bit (18) static options (constant) init ("000000"b3);
  4    91 declare	INTERNALLY_RESOLVED	bit (18) static options (constant) init ("777777"b3);
      331 
      332 
  5     1 	/* Include file insym.incl.pl1 */
  5     2 
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(86-06-14,Elhard), approve(86-06-14,MCR7198),
  5     6*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
  5     7*     Changed to eliminate the use of "p" as a pointer to base the structures
  5     8*     on.
  5     9*                                                   END HISTORY COMMENTS */
  5    10 
  5    11 
  5    12 declare	1 insym aligned based,		/* declaration of the INSYM structure */
  5    13 
  5    14 	2 thread pointer,			/* pointer to the next insym structure */
  5    15 	2 n_insyms fixed bin,		/* number of insym entries */
  5    16 	(2 retained,			/* def(s) have been retained for this component */
  5    17 	2 global_nolink) bit(1) unaligned,	/* don't prelink any reference to/from this object */
  5    18 	2 entry(1000) like is;
  5    19 
  5    20 declare	1 is aligned based,
  5    21          (2 next_ext_ptr bit(18),		/* thread to next def */
  5    22 	2 trap_ptr bit(18),			/* trap pointer */
  5    23 	2 value bit(18),			/* symbol's offset value */
  5    24 	2 class bit(18)) unaligned,		/* corresponding section of the object */
  5    25 	2 def_offset fixed bin(18),		/* offset of def in original def section */
  5    26 	2 symbol char(257) aligned,		/* the symbol in ACC string form */
  5    27 	2 lng fixed bin,			/* length in chars of ACC string (incl. ACC count) */
  5    28 	2 nargs fixed bin,			/* # of args expected by entry */
  5    29 	2 descr_ptr pointer,		/* ptr to descriptor ptr array */
  5    30          (2 null_entry,			/* 1->type 3 (seg|expr) entry, no insym symbol */
  5    31 	2 snapped,			/* 0->not referenced, 1->link snapped */
  5    32 	2 has_descr,			/* 1->entry has valid descriptors */
  5    33 	2 entrypoint,			/* 0->segdef, 1->entrypoint; meaningful only for standard */
  5    34 	2 retain_flag,			/* 1->turn on retain flag; was on in original */
  5    35 	2 delete,				/* 1->don't regenerate this def in any case */
  5    36 	2 ignore,				/* 1->regenerate but ignore */
  5    37 	2 regenerated,			/* this definition already regenerated */
  5    38 	2 retain,				/* 0->don't regenerate, 1->retain definition */
  5    39 	2 no_link,			/* don't prelink to this symbol */
  5    40 	2 duplicate) bit(1) unaligned,	/* this symbol name duplicated in another block */
  5    41 	2 defrel bit (18);			/* offset in defs of regenerated definition */
  5    42 
  5    43 
  5    44 
      333 
      334 
  6     1 /* Begin include file definition_dcls.incl.pl1 BIM 1981 */
  6     2 
  6     3 
  6     4 /****^  HISTORY COMMENTS:
  6     5*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  6     6*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
  6     7*     Modified to add indirect bit to definition flags, add msf_map_relp to the
  6     8*     definition header, declare the msf_map, and add structures and constants
  6     9*     for deferred initialization.
  6    10*  2) change(86-06-24,DGHowe), approve(86-06-24,MCR7420),
  6    11*     audit(86-08-05,Schroth), install(86-11-20,MR12.0-1222):
  6    12*     added the structures for pointer initialization. pointer_init_template.
  6    13*     changed list_template_entry
  6    14*                                                   END HISTORY COMMENTS */
  6    15 
  6    16 
  6    17 /* Modified:  */
  6    18 /*   13 Dec 1982 by Lee A. Newcomb to put definition_header.hash_table_relp */
  6    19 /*	after unused half-word instead of before it. */
  6    20 /*   1 March 1983 by M. Weaver to add list template init type */
  6    21 
  6    22 /* format: style3,idind25 */
  6    23 /* everything for the definition section */
  6    24 
  6    25 declare	(
  6    26 	CLASS_TEXT	     init (0),		/* text section definition */
  6    27 	CLASS_LINKAGE	     init (1),		/* linkage section definition */
  6    28 	CLASS_SYMBOL	     init (2),		/* symbol section definition */
  6    29 	CLASS_SEGNAME	     init (3),		/* segment name definition */
  6    30 	CLASS_STATIC	     init (4),		/* static section definition */
  6    31 	CLASS_SYSTEM	     init (5),		/* valid only in self links, not def class */
  6    32 	CLASS_HEAP	     init (6)		/* valid only in self links, not def class */
  6    33 	)		     fixed bin (3) unsigned internal static options (constant);
  6    34 
  6    35 declare	CLASS_NAMES	     (0:6) character (12) internal static options (constant)
  6    36 			     init ("text", "linkage", "symbol", "segname", "static", "system", "heap");
  6    37 
  6    38 declare	SYMBOLIC_SECTION_NAMES   (0:6) character (8)
  6    39 			     init ("*text", "*link", "*symbol", *, "*static", "*system", "*heap") internal static
  6    40 			     options (constant);
  6    41 
  6    42 declare	1 definition_flags	     unaligned based,
  6    43 	  2 new		     bit (1),		/* should be "1"b */
  6    44 	  2 ignore	     bit (1),		/* cannot snap link to this */
  6    45 	  2 entry		     bit (1),		/* can tra here */
  6    46 	  2 retain	     bit (1),		/* binder respects this */
  6    47 	  2 argcount	     bit (1),		/* OBSOLETE */
  6    48 	  2 descriptors	     bit (1),		/* OBSOLETE */
  6    49 	  2 indirect	     bit (1),		/* target is a pointer to actual target */
  6    50 	  2 unused	     bit (8);		/* Must be zero */
  6    51 
  6    52 
  6    53 
  6    54 
  6    55 /* Header of the definition section */
  6    56 
  6    57 declare	def_header_ptr	     pointer;
  6    58 declare	1 definition_header	     aligned based (def_header_ptr),
  6    59 	  2 def_list_relp	     fixed bin (18) unsigned unaligned,
  6    60 						/* first definition, reloc def18 */
  6    61 	  2 msf_map_relp	     fixed bin (18) unsigned unaligned,
  6    62 						/* msf_map if any, or 0 if none.  reloc def18 unless none */
  6    63 	  2 hash_table_relp	     fixed bin (18) unsigned unaligned,
  6    64 						/* def hash table, if any, or 0 if none. reloc def18 unless none */
  6    65 	  2 flags		     unaligned like definition_flags;
  6    66 						/* both new and ignore must be "1"b here */
  6    67 
  6    68 /* A non class=3 definition. See segname_definition below for class=3 */
  6    69 
  6    70 
  6    71 declare	def_ptr		     pointer;
  6    72 declare	1 definition	     aligned based (def_ptr),
  6    73 	  2 forward_relp	     unal fixed bin (18) unsigned,
  6    74 						/* offset of next def */
  6    75 	  2 backward_relp	     unal fixed bin (18) unsigned,
  6    76 						/* offset of previous def */
  6    77 	  2 thing_relp	     unal fixed bin (18) unsigned,
  6    78 						/* offset in section specified by class of thing this defines */
  6    79 	  2 flags		     unaligned like definition_flags,
  6    80 	  2 class		     unal fixed bin (3) unsigned,
  6    81 						/* Type of definition */
  6    82 	  2 name_relp	     unal fixed bin (18) unsigned,
  6    83 						/* offset of ACC for symbol */
  6    84 	  2 segname_relp	     unal fixed bin (18) unsigned;
  6    85 						/* offset of segname def to which this belongs */
  6    86 
  6    87 /* Class=3, segname definition */
  6    88 
  6    89 declare	segname_ptr	     pointer;
  6    90 declare	1 segname_definition     aligned based (segname_ptr),
  6    91 	  2 forward_relp	     unal fixed bin (18) unsigned,
  6    92 						/* offset of next def */
  6    93 	  2 backward_relp	     unal fixed bin (18) unsigned,
  6    94 						/* offset of previous def */
  6    95 	  2 next_segname_relp    unal fixed bin (18) unsigned,
  6    96 						/* offset of next segname def */
  6    97 	  2 flags		     unaligned like definition_flags,
  6    98 	  2 class		     unal fixed bin (3) unsigned,
  6    99 						/* 3 for segname */
  6   100 	  2 name_relp	     unal fixed bin (18) unsigned,
  6   101 						/* offset of ACC for symbol */
  6   102 	  2 first_relp	     unal fixed bin (18) unsigned;
  6   103 						/* see following : */
  6   104 
  6   105 /* Definition blocks are chained off of segname definitions.
  6   106*   segname_definition.first_relp is one of three things:
  6   107*    (1) the def section offset of the first ordinary (class^=3) definition
  6   108*      belonging to this segname block. In the case where there are more than
  6   109*      one segname's on a block, all their first_relp will point
  6   110*      to the same place.
  6   111*
  6   112*    (2) if there are no ordinary definitions associated with this segname,
  6   113*      then it is the def section offset of the next segname. 
  6   114*
  6   115*    (3) if there are no ordinary definitions in the block, and it
  6   116*      is the last block, then it points to a word containing 0.
  6   117*
  6   118* Thus the end of a list of synonym segnames can be detected by forward_relp
  6   119*   pointing to a class=3 definition whose first_relp is not the same as
  6   120*   the current definitions first_relp.
  6   121**/
  6   122 
  6   123 /* All the definitions are linked through the forward and
  6   124*   backward thread variables. The end of the chain can is indicated
  6   125*   by forward pointing to a zero word. */
  6   126 
  6   127 
  6   128 declare	exp_ptr		     pointer;
  6   129 declare	1 exp_word	     based (exp_ptr) aligned, /* expression word in link definition */
  6   130 	  2 type_relp	     fixed bin (18) unsigned unal,
  6   131 						/* pointer (rel to defs) of type pair structure */
  6   132 	  2 expression	     fixed bin (17) unal;	/* constant expression to be added in when snapping link */
  6   133 
  6   134 declare	(
  6   135 	LINK_SELF_BASE	     init (1),		/* *section|0+expression,modifier */
  6   136 						/* which section determined by segname_relp */
  6   137 	LINK_OBSOLETE_2	     init (2),		/* not used */
  6   138 	LINK_REFNAME_BASE	     init (3),		/* refname|0+expression,modifier */
  6   139 	LINK_REFNAME_OFFSETNAME  init (4),		/* refname|offsetname+expression,modifier */
  6   140 	LINK_SELF_OFFSETNAME     init (5),		/* *section|offsetname+expression,modifier */
  6   141 	LINK_CREATE_IF_NOT_FOUND init (6),		/* OBSOLETE: like LINK_REFNAME_OFFSETNAME except that it will create instead of taking linkage_error */
  6   142 	SECTION_TEXT	     init (0),		/* *text */
  6   143 	SECTION_LINK	     init (1),		/* *link */
  6   144 	SECTION_SYMBOL	     init (2),		/* *symbol */
  6   145 	SECTION_UNUSED	     init (3),		/* reserved */
  6   146 	SECTION_STATIC	     init (4),		/* *static */
  6   147 	SECTION_SYSTEM	     init (5),		/* *system */
  6   148 	SECTION_HEAP	     init (6)		/* *heap */
  6   149 	)		     fixed bin (18) unsigned unaligned internal static options (constant);
  6   150 
  6   151 /* use CLASS_NAMES for section names */
  6   152 
  6   153 declare	LINK_TYPE_NAMES	     (1:6)
  6   154 			     init ("absolute in section", "unused", "absolute off of refname",
  6   155 			     "symbolic off of refname", "symbolic in section", "symbolic off of refname; create")
  6   156 			     character (32) varying internal static options (constant);
  6   157 
  6   158 
  6   159 declare	type_ptr		     pointer;
  6   160 declare	1 type_pair	     based (type_ptr) aligned,/* type pair in link definition */
  6   161 	  2 type		     fixed bin (18) unsigned unal,
  6   162 						/* see above */
  6   163 	  2 trap_relp	     fixed bin (18) unsigned unal,
  6   164 						/* pointer (rel to defs) to the trap word */
  6   165 						/* unless LINK_SELF_OFFSETNAME off of *system or create link */
  6   166 	  2 segname_relp	     fixed bin (18) unsigned unal,
  6   167 						/* pointer (rel to defs) to ACC reference name for segment referenced, 
  6   168* /*or section code for SELF links */
  6   169 	  2 offsetname_relp	     fixed bin (18) unsigned unal;
  6   170 						/* for OFFSETNAME links, ACC string of name of location. */
  6   171 						/* for others, must be ZERO */
  6   172 
  6   173 
  6   174 /* Link Trap Pair */
  6   175 
  6   176 declare	link_trap_ptr	     pointer;
  6   177 declare	1 link_trap_pair	     aligned based (link_trap_ptr),
  6   178 	  2 call_relp	     fixed bin (18) unsigned unaligned,
  6   179 						/* LINK18, link to thing to call */
  6   180 	  2 info_relp	     fixed bin (18) unsigned unaligned;
  6   181 						/* LINK18, link to argument list */
  6   182 
  6   183 
  6   184 /* initialization info for *system or *heap link */
  6   185 
  6   186 
  6   187 /* NOTE --------------------------------------------------
  6   188*   the following structures defining initialization information are also
  6   189*   defined in fortran_storage.incl.pl1  system_link_init_info.incl.pl1
  6   190*   and should be kept equivalent
  6   191*   -------------------------------------------------------
  6   192**/
  6   193 
  6   194 declare	(
  6   195 	INIT_NO_INIT	     init (0),
  6   196 	INIT_COPY_INFO	     init (3),
  6   197 	INIT_DEFINE_AREA	     init (4),
  6   198 	INIT_LIST_TEMPLATE	     init (5),
  6   199 	INIT_DEFERRED	     init (6)
  6   200 	)		     fixed bin internal static options (constant);
  6   201 
  6   202 /* for type = 0 or 4 */
  6   203 
  6   204 declare	link_init_ptr	     pointer;
  6   205 declare	1 link_init	     aligned based (link_init_ptr),
  6   206 	  2 n_words	     fixed bin (35),	/* number to invent */
  6   207 	  2 type		     fixed bin;		/* see types above */
  6   208 
  6   209 /* for type=3, there is data to copy */
  6   210 
  6   211 declare	1 link_init_copy_info    aligned based (link_init_ptr),
  6   212 	  2 header	     aligned like link_init,
  6   213 	  2 initial_data	     (link_init_n_words refer (link_init_copy_info.header.n_words)) bit (36) aligned;
  6   214 
  6   215 declare	link_init_n_words	     fixed bin;
  6   216 
  6   217 /* for type = 5, there is a list template to copy */
  6   218 
  6   219 declare	1 link_init_list_template
  6   220 			     aligned based (link_init_ptr),
  6   221 	  2 header	     aligned like link_init,
  6   222 	  2 pad		     bit (18) unaligned,
  6   223 	  2 n_words_in_list	     fixed bin (18) unsigned unaligned,
  6   224 	  2 template	     (link_init_n_words_in_list refer (link_init_list_template.n_words_in_list));
  6   225 
  6   226 declare	link_init_n_words_in_list
  6   227 			     fixed bin;
  6   228 
  6   229 /* A list template consists of a series of entries with the following
  6   230*   description, concatenated together.  n_bits and datum are bit items,
  6   231*   to permit a wide range of inputs.
  6   232*
  6   233*   1.  A 'repeat' of '0' signifies skipping of 'n_bits' bits.
  6   234*   2.  A 'n_bits' of '0' signifies the last item of the list.
  6   235*
  6   236*   COMMON, VLA's, and LA's are presumed to start at the base pointer
  6   237*   of their particular storage section. */
  6   238 
  6   239 declare	1 list_template_entry    aligned based,
  6   240 	  2 n_bits	     fixed bin (35) aligned,	/* size of datum */
  6   241 	  2 mbz		     bit (3) unaligned,	/* future expansion */
  6   242 	  2 init_type	     fixed bin (3) unsigned unaligned, /* 0 normal init, 1 ptr init, 2 packed ptr init */
  6   243 	  2 repeat	     fixed bin (30) unsigned unaligned,
  6   244 						/* number of times to repeat datum */
  6   245 	  2 datum		     bit (link_init_n_bits_in_datum refer (list_template_entry.n_bits));
  6   246 
  6   247 
  6   248 /* the pointer_init_template represents the initialization information
  6   249*   for ITS and packed pointers.  Both pointer types require the entire
  6   250*   72 bit structure.
  6   251**/
  6   252 
  6   253 dcl       1 pointer_init_template  based,
  6   254 	  2 ptr_type	     fixed bin (18) unsigned unaligned,  /* 0 text section, 1 linkage section, 2 static section */
  6   255 	  2 section_offset	     fixed bin (18) unsigned unaligned,  /* offset to item in specified section */
  6   256 	  2 word_offset	     fixed bin (18) unsigned unaligned,  /* offset from section item to target in words */
  6   257 	  2 mbz		     bit (12) unaligned,
  6   258 	  2 bit_offset	     fixed bin (6) unsigned unaligned;   /* offset from section item|word offset to target in bits */
  6   259 
  6   260 
  6   261 declare	link_init_n_bits_in_datum
  6   262 			     fixed bin (35);
  6   263 
  6   264 /* for type = 6, the init_info resides in another MSF component */
  6   265 /* target_relp is a linkage section offset to a partial link to */
  6   266 /* the base of the linkage section of the component containing  */
  6   267 /* the actual init_info. link_relp is the offset of the actual  */
  6   268 /* link within that linkage section.			    */
  6   269 
  6   270 declare	1 link_init_deferred     aligned based (link_init_ptr),
  6   271 	  2 header	     aligned like link_init,
  6   272 	  2 target_relp	     fixed bin (18) unsigned unaligned,
  6   273 	  2 link_relp	     fixed bin (18) unsigned unaligned;
  6   274 
  6   275 /* Definition section hash table */
  6   276 
  6   277 declare	def_ht_ptr	     pointer;
  6   278 declare	1 definition_ht	     aligned based (def_ht_ptr),
  6   279 	  2 n_entries	     fixed bin,
  6   280 	  2 table		     (def_ht_n_entries refer (definition_ht.n_entries)) aligned,
  6   281 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  6   282 	    3 unused	     bit (18) unaligned;
  6   283 
  6   284 declare	def_ht_n_entries	     fixed bin;
  6   285 
  6   286 
  6   287 /* Component name ht */
  6   288 declare	comp_ht_ptr	     pointer;
  6   289 declare	1 component_ht	     aligned based (comp_ht_ptr),
  6   290 	  2 n_entries	     fixed bin,
  6   291 	  2 table		     (comp_ht_n_entries refer (component_ht.n_entries)) aligned,
  6   292 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  6   293 						/* hashed segname */
  6   294 	    3 block_hdr_relp     fixed bin (18) unsigned unaligned;
  6   295 						/* first segname def of block containing def_relp */
  6   296 
  6   297 declare	comp_ht_n_entries	     fixed bin;
  6   298 
  6   299 /* Duplicate name table */
  6   300 
  6   301 declare	dup_table_ptr	     pointer;
  6   302 declare	1 duplicate_table	     aligned based (dup_table_ptr),
  6   303 	  2 mbz		     bit (18) unaligned,	/* to tell it from a definition */
  6   304 	  2 n_names	     fixed bin (18) unsigned unaligned,
  6   305 						/* n in table */
  6   306 	  2 table		     (dup_table_n_names refer (duplicate_table.n_names)) aligned,
  6   307 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  6   308 	    3 block_hdr_relp     fixed bin (18) unsigned unaligned;
  6   309 
  6   310 declare	dup_table_n_names	     fixed bin;
  6   311 
  6   312 /* The msf_map is found in the definition section of an	*/
  6   313 /* object MSF component.  It is used by the linker to	*/
  6   314 /* determine whether a segment is a component of an object	*/
  6   315 /* MSF or a standard single-segment object.		*/
  6   316   
  6   317   dcl msf_map_ptr		ptr;
  6   318   dcl 01 msf_map		aligned based (msf_map_ptr),
  6   319        02 version		char (8),
  6   320        02 component_count	fixed bin (15) unsigned,
  6   321        02 my_component	fixed bin (15) unsigned;
  6   322   
  6   323   dcl msf_map_version_1	char (8) static options (constant)
  6   324 			     init ("msfmp1.0");
  6   325   
  6   326 declare	acc_string_ptr	     pointer;
  6   327 declare	1 acc_string	     aligned based (acc_string_ptr),
  6   328 	  2 count		     fixed bin (9) unsigned unaligned,
  6   329 	  2 string	     character (max (3, acc_string_length) refer (acc_string.count)) unaligned,
  6   330 	  2 mbz		     bit (0) aligned;	/* this causes the statement */
  6   331 						/* unspec (acc_string) = ""b to zero out */
  6   332 						/* the last word, if the string is not of length 0mod4 */
  6   333 
  6   334 declare	acc_string_length	     fixed bin (21);
  6   335 
  6   336 
  6   337 /* end include file definitions_dcls.incl.pl1 */
      335 
      336 
      337      end generate_def_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/20/86  1145.0  generate_def_.pl1                 >special_ldd>install>MR12.0-1222>generate_def_.pl1
325          1    07/16/86  1222.1  extref.incl.pl1                   >ldd>include>extref.incl.pl1
327          2    07/16/86  1222.1  bindext.incl.pl1                  >ldd>include>bindext.incl.pl1
329          3    07/16/86  1222.1  comptbl.incl.pl1                  >ldd>include>comptbl.incl.pl1
331          4    07/16/86  1222.1  bndtbl.incl.pl1                   >ldd>include>bndtbl.incl.pl1
333          5    07/16/86  1222.1  insym.incl.pl1                    >ldd>include>insym.incl.pl1
335          6    11/20/86  1035.3  definition_dcls.incl.pl1          >special_ldd>install>MR12.0-1222>definition_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
acc_string_overlay                     based           char(257)                dcl 120 set ref 197*
addr                                                   builtin function         dcl 95 ref 254 261 261 294 294 302 302
addrel                                                 builtin function         dcl 95 ref 135 142 196
argcount                  1(22)        based           bit(1)                   level 3 packed unaligned dcl 100 set ref 160*
backward_relp             0(18)        based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 100 set ref
                                                                                  143*
bin                                                    builtin function         dcl 95 ref 138 146 195 251
bit                                                    builtin function         dcl 95 ref 138 146 195 251
bx_$bound_sep_stat              000052 external static fixed bin(17,0)          dcl 2-64 ref 270
bx_$caller                      000064 external static char(32)                 dcl 2-80 ref 320
bx_$ctp                         000036 external static pointer                  dcl 2-26 ref 123
bx_$curdeflng                   000056 external static fixed bin(18,0)          dcl 2-69 set ref 132 289*
bx_$debug                       000050 external static fixed bin(17,0)          dcl 2-59 ref 318
bx_$fatal_error                 000046 external static fixed bin(17,0)          dcl 2-49 set ref 192* 282*
bx_$nsymdefs                    000062 external static fixed bin(17,0)          dcl 2-77 set ref 205* 205 221* 221
bx_$standard                    000054 external static fixed bin(17,0)          dcl 2-66 ref 172
bx_$strmp                       000044 external static pointer                  dcl 2-46 ref 124
bx_$tdefp                       000040 external static pointer                  dcl 2-43 ref 315
bx_$tlinklng                    000060 external static fixed bin(17,0)          dcl 2-73 set ref 133 290*
bx_$tlinkp                      000042 external static pointer                  dcl 2-45 ref 316
class                     1(18)        based           bit(18)                  level 2 in structure "insyme" packed unaligned
                                                                                  dcl 111 in procedure "generate_def_" ref 151
class                     1(33)        based           fixed bin(3,0)           level 2 in structure "new_def" packed unsigned
                                                                                  unaligned dcl 100 in procedure "generate_def_" set
                                                                                  ref 151* 208 226 233 268 273* 279*
clngi                    64            based           fixed bin(17,0)          level 2 dcl 3-16 ref 235
code15                  127(18) 000120 automatic       bit(18)                  level 2 packed unaligned dcl 89 set ref 299*
com_err_                        000022 constant        entry                    external dcl 69 ref 190 279
comp                                   based           structure                level 1 dcl 3-16
compent_ptr                     000120 automatic       pointer                  level 2 in structure "my_ext" dcl 89 in procedure
                                                                                  "generate_def_" set ref 256*
compent_ptr                            parameter       pointer                  dcl 60 in procedure "generate_def_" ref 57 125
compiler                 10            based           char(8)                  level 2 dcl 3-16 ref 241
creli                    74            based           fixed bin(17,0)          level 2 dcl 3-16 ref 237 276
crels                    75            based           fixed bin(17,0)          level 2 dcl 3-16 ref 229
crelt                    73            based           fixed bin(17,0)          level 2 dcl 3-16 ref 166 211
ctep                            000260 automatic       pointer                  dcl 3-10 set ref 125* 130 136 138 138 142 143 146
                                                                                  149 166 211 213 229 235 237 241 256 276 279
ctp                             000256 automatic       pointer                  dcl 3-10 set ref 123*
current_def              57(18)        based           bit(18)                  level 2 packed unaligned dcl 3-16 set ref 138* 142
                                                                                  143 146* 149
decode_link_                    000032 constant        entry                    external dcl 74 ref 261
defbase                         000010 internal static pointer                  dcl 79 set ref 135 142 196 315*
defblockp                57            based           bit(18)                  level 2 packed unaligned dcl 3-16 set ref 136 138*
definition_flags                       based           structure                level 1 packed unaligned dcl 6-42
definition_ptr                         parameter       pointer                  dcl 60 ref 57 126
defoffset                       000102 automatic       fixed bin(18,0)          dcl 86 set ref 132* 135 138 145 146 153* 153 168*
                                                                                  168 194 195 196 198* 198 289
defrel                  111            based           bit(18)                  level 2 dcl 111 set ref 149*
delete                  110(05)        based           bit(1)                   level 2 packed unaligned dcl 111 ref 218
descr_list                             based           fixed bin(18,0)          array unsigned unaligned dcl 113 ref 166
descr_ptr               106            based           pointer                  level 2 dcl 111 ref 164
descriptor_relp           3(18)        based           fixed bin(18,0)          array level 2 packed unsigned unaligned dcl 100 set
                                                                                  ref 166*
descriptors               1(23)        based           bit(1)                   level 3 packed unaligned dcl 100 set ref 161*
divide                                                 builtin function         dcl 95 ref 168 198
dont_prelink            130     000120 automatic       bit(1)                   level 2 packed unaligned dcl 89 set ref 255*
dont_relocate           130(07) 000120 automatic       bit(1)                   level 2 packed unaligned dcl 89 set ref 260*
dp                              000110 automatic       pointer                  dcl 87 set ref 135* 143 150 151 152 160 161 163 166
                                                                                  172 181 194 208 211 211 216 220 226 229 229 233
                                                                                  235 237 237 251 257 268 273 276 276 279 287 303
dsp                             000116 automatic       pointer                  dcl 87 set ref 164* 166
dum_instr                       000254 automatic       structure                level 1 dcl 116 set ref 254
elng                    125     000120 automatic       fixed bin(17,0)          level 2 dcl 89 set ref 298*
entry                     1(20)        based           bit(1)                   level 3 in structure "new_def" packed unaligned
                                                                                  dcl 100 in procedure "generate_def_" set ref 216*
entry                  1541            based           structure                array level 2 in structure "strm" packed unaligned
                                                                                  dcl 4-73 in procedure "generate_def_"
entrypoint              110(03)        based           bit(1)                   level 2 packed unaligned dcl 111 ref 216
errname                         000015 internal static char(16)                 dcl 81 set ref 190* 279* 318* 320*
expr                    127     000120 automatic       bit(18)                  level 2 packed unaligned dcl 89 set ref 300*
ext_link_                       000034 constant        entry                    external dcl 75 ref 302
external_ref                           based           structure                level 1 dcl 1-12
filename                               based           char(32)                 level 2 dcl 3-16 set ref 279*
fixed                                                  builtin function         dcl 95 ref 143 150 151 181 303
flags                     1(18)        based           structure                level 2 packed unaligned dcl 100
forward_relp                           based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 110 set ref
                                                                                  145*
generate_ext_link               000253 automatic       bit(1)                   initial unaligned dcl 91 set ref 91* 263* 292
has_descr               110(02)        based           bit(1)                   level 2 packed unaligned dcl 111 ref 161
i                               000100 automatic       fixed bin(17,0)          dcl 85 set ref 165* 166 166* 178* 179 181 187* 195
                                                                                  201* 270* 274* 276
ignore                    1(19)        based           bit(1)                   level 3 in structure "new_def" packed unaligned
                                                                                  dcl 100 in procedure "generate_def_" set ref 220*
                                                                                  287
ignore                  110(06)        based           bit(1)                   level 2 in structure "insyme" packed unaligned
                                                                                  dcl 111 in procedure "generate_def_" ref 218
inlink                          000014 internal static fixed bin(17,0)          dcl 80 set ref 317*
insym                                  based           structure                level 1 dcl 5-12
insyme                                 based           structure                level 1 dcl 111
insymentp                36            based           pointer                  level 2 dcl 3-16 ref 130
int_link_                       000030 constant        entry                    external dcl 73 ref 294
ip                              000106 automatic       pointer                  dcl 87 set ref 130* 287
is                                     based           structure                level 1 dcl 5-20
last_def                               based           structure                level 1 dcl 110
lda_pr0_instr                          constant        bit(18)                  initial unaligned dcl 65 ref 253
link_init                              based           structure                level 1 dcl 6-205
linkbase                        000012 internal static pointer                  dcl 79 set ref 316*
linkoffset                      000101 automatic       fixed bin(17,0)          dcl 85 set ref 133* 290
lng                     104            based           fixed bin(17,0)          level 2 dcl 111 ref 178 178 197 197 198 201 201 279
                                                                                  279
loffset                  11     000120 automatic       fixed bin(17,0)          level 2 dcl 89 set ref 257*
lp                              000114 automatic       pointer                  dcl 87 set ref 142* 145
map                    1541            based           bit(18)                  array level 3 packed unaligned dcl 4-73 set ref 181
                                                                                  195*
max_size               1537            based           fixed bin(17,0)          level 2 dcl 4-73 ref 188
my_ext                          000120 automatic       structure                level 1 dcl 89 set ref 261 261 294 294 302 302
n_args                    3            based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 100 set ref
                                                                                  163*
name_relp                 2            based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 100 set ref
                                                                                  181* 194*
nargs                   105            based           fixed bin(17,0)          level 2 dcl 111 ref 158 163 165 168
new                       1(18)        based           bit(1)                   level 3 packed unaligned dcl 100 set ref 152*
new_def                                based           structure                level 1 dcl 100
nstr                   1540            based           fixed bin(17,0)          level 2 dcl 4-73 set ref 187 187* 188 191*
op_code                   0(18) 000254 automatic       bit(18)                  level 2 packed unaligned dcl 116 set ref 253*
p                               000104 automatic       pointer                  dcl 87 set ref 196* 197
ref_ptr                   2     000120 automatic       pointer                  level 2 dcl 89 set ref 254*
regenerated             110(07)        based           bit(1)                   level 2 packed unaligned dcl 111 set ref 127 285*
register                        000254 automatic       bit(3)                   level 2 packed unaligned dcl 116 set ref 252*
rel_address               0(03) 000254 automatic       bit(15)                  level 2 packed unaligned dcl 116 set ref 251* 300
                                                                                  303
relinfo                   6     000120 automatic       char(8)                  level 2 dcl 89 set ref 259*
retain                    1(21)        based           bit(1)                   level 3 packed unaligned dcl 100 set ref 172*
retain_flag             110(04)        based           bit(1)                   level 2 packed unaligned dcl 111 ref 172
retained                  3            based           bit(1)                   level 2 packed unaligned dcl 5-12 set ref 287*
rpte                                   based           structure                level 1 dcl 4-63
seg                                    based           structure                level 1 dcl 4-29
segname                  12     000120 automatic       char(33)                 level 2 dcl 89 set ref 296*
side                      5     000120 automatic       char(3)                  level 2 dcl 89 set ref 258*
slng                     23     000120 automatic       fixed bin(17,0)          level 2 dcl 89 set ref 297*
sp                              000112 automatic       pointer                  dcl 87 set ref 126* 127 149 150 151 158 161 163 164
                                                                                  165 168 172 178 178 178 178 197 197 197 198 201
                                                                                  201 201 201 216 218 218 279 279 279 279 285
standard_object          50            based           fixed bin(17,0)          level 2 dcl 3-16 ref 213
strm                                   based           structure                level 1 dcl 4-73
strm_hash_$lookup               000024 constant        entry                    external dcl 70 ref 178
strm_hash_$make_entry           000026 constant        entry                    external dcl 71 ref 201
strmp                           000262 automatic       pointer                  dcl 4-17 set ref 124* 181 187 187 188 188 191 195
substr                                                 builtin function         dcl 95 set ref 178 178 197* 197 201 201 279 279
symbol                    3            based           char(257)                level 2 dcl 111 ref 178 178 197 201 201 279 279
thing_relp                1            based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 100 set ref
                                                                                  150* 211* 211 229* 229 235 237* 237 251 257 276*
                                                                                  276 303*
type                    126     000120 automatic       bit(18)                  level 2 packed unaligned dcl 89 set ref 299*
value                     1            based           bit(18)                  level 2 packed unaligned dcl 111 ref 150

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
CLASS_HEAP                             internal static fixed bin(3,0)           initial unsigned dcl 6-25
CLASS_LINKAGE                          internal static fixed bin(3,0)           initial unsigned dcl 6-25
CLASS_NAMES                            internal static char(12)                 initial array unaligned dcl 6-35
CLASS_SEGNAME                          internal static fixed bin(3,0)           initial unsigned dcl 6-25
CLASS_STATIC                           internal static fixed bin(3,0)           initial unsigned dcl 6-25
CLASS_SYMBOL                           internal static fixed bin(3,0)           initial unsigned dcl 6-25
CLASS_SYSTEM                           internal static fixed bin(3,0)           initial unsigned dcl 6-25
CLASS_TEXT                             internal static fixed bin(3,0)           initial unsigned dcl 6-25
INIT_COPY_INFO                         internal static fixed bin(17,0)          initial dcl 6-194
INIT_DEFERRED                          internal static fixed bin(17,0)          initial dcl 6-194
INIT_DEFINE_AREA                       internal static fixed bin(17,0)          initial dcl 6-194
INIT_LIST_TEMPLATE                     internal static fixed bin(17,0)          initial dcl 6-194
INIT_NO_INIT                           internal static fixed bin(17,0)          initial dcl 6-194
INTERNALLY_RESOLVED                    internal static bit(18)                  initial unaligned dcl 4-91
LINK_CREATE_IF_NOT_FOUND               internal static fixed bin(18,0)          initial unsigned unaligned dcl 6-134
LINK_OBSOLETE_2                        internal static fixed bin(18,0)          initial unsigned unaligned dcl 6-134
LINK_REFNAME_BASE                      internal static fixed bin(18,0)          initial unsigned unaligned dcl 6-134
LINK_REFNAME_OFFSETNAME                internal static fixed bin(18,0)          initial unsigned unaligned dcl 6-134
LINK_SELF_BASE                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 6-134
LINK_SELF_OFFSETNAME                   internal static fixed bin(18,0)          initial unsigned unaligned dcl 6-134
LINK_TYPE_NAMES                        internal static varying char(32)         initial array dcl 6-153
SECTION_HEAP                           internal static fixed bin(18,0)          initial unsigned unaligned dcl 6-134
SECTION_LINK                           internal static fixed bin(18,0)          initial unsigned unaligned dcl 6-134
SECTION_STATIC                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 6-134
SECTION_SYMBOL                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 6-134
SECTION_SYSTEM                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 6-134
SECTION_TEXT                           internal static fixed bin(18,0)          initial unsigned unaligned dcl 6-134
SECTION_UNUSED                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 6-134
SYMBOLIC_SECTION_NAMES                 internal static char(8)                  initial array unaligned dcl 6-38
UNRESOLVED                             internal static bit(18)                  initial unaligned dcl 4-90
acc_string                             based           structure                level 1 dcl 6-327
acc_string_length                      automatic       fixed bin(21,0)          dcl 6-334
acc_string_ptr                         automatic       pointer                  dcl 6-326
adnp                                   automatic       pointer                  dcl 4-17
an                                     based           structure                level 1 dcl 4-40
bx_$addname                            external static fixed bin(17,0)          dcl 2-58
bx_$addname_limit                      external static fixed bin(17,0)          dcl 2-24
bx_$adnp                               external static pointer                  dcl 2-36
bx_$area_begin                         external static fixed bin(18,0)          dcl 2-25
bx_$bdefp                              external static pointer                  dcl 2-38
bx_$bindmap_def                        external static pointer                  dcl 2-37
bx_$blnkp                              external static pointer                  dcl 2-40
bx_$bound_segname                      external static char(32)                 dcl 2-48
bx_$bproc                              external static fixed bin(17,0)          dcl 2-67
bx_$brief                              external static fixed bin(17,0)          dcl 2-60
bx_$bseg_acinfop                       external static pointer                  dcl 2-50
bx_$bseg_bitcount                      external static fixed bin(24,0)          dcl 2-51
bx_$bsegp                              external static pointer                  dcl 2-30
bx_$bstatp                             external static pointer                  dcl 2-39
bx_$bsymp                              external static pointer                  dcl 2-41
bx_$d_lng                              external static fixed bin(18,0)          dcl 2-54
bx_$first_rptp                         external static pointer                  dcl 2-34
bx_$force_order                        external static fixed bin(17,0)          dcl 2-61
bx_$freep                              external static pointer                  dcl 2-27
bx_$has_comb_stat                      external static fixed bin(17,0)          dcl 2-63
bx_$has_sep_stat                       external static fixed bin(17,0)          dcl 2-62
bx_$i_lng                              external static fixed bin(17,0)          dcl 2-55
bx_$inpp                               external static pointer                  dcl 2-29
bx_$isp                                external static pointer                  dcl 2-28
bx_$l_lng                              external static fixed bin(17,0)          dcl 2-56
bx_$last_rptp                          external static pointer                  dcl 2-35
bx_$maxdeflng                          external static fixed bin(18,0)          dcl 2-72
bx_$maxlinklng                         external static fixed bin(17,0)          dcl 2-71
bx_$n_firstrefs                        external static fixed bin(17,0)          dcl 2-47
bx_$n_lng                              external static fixed bin(17,0)          dcl 2-76
bx_$ncomp                              external static fixed bin(17,0)          dcl 2-74
bx_$nsegdefs                           external static fixed bin(17,0)          dcl 2-78
bx_$o_lng                              external static fixed bin(19,0)          dcl 2-52
bx_$oddname_limit                      external static fixed bin(17,0)          dcl 2-22
bx_$odnp                               external static pointer                  dcl 2-33
bx_$optp                               external static pointer                  dcl 2-32
bx_$perprocess_static                  external static fixed bin(17,0)          dcl 2-65
bx_$s_lng                              external static fixed bin(18,0)          dcl 2-57
bx_$size                               external static fixed bin(17,0)          dcl 2-20
bx_$snt_limit                          external static fixed bin(17,0)          dcl 2-21
bx_$sntp                               external static pointer                  dcl 2-42
bx_$stringmap_limit                    external static fixed bin(17,0)          dcl 2-23
bx_$t_lng                              external static fixed bin(18,0)          dcl 2-53
bx_$temp                               external static pointer                  dcl 2-31
bx_$temp_bsegp                         external static pointer                  dcl 2-79
bx_$textlng                            external static fixed bin(18,0)          dcl 2-68
bx_$tintlng                            external static fixed bin(17,0)          dcl 2-70
bx_$tintp                              external static pointer                  dcl 2-44
bx_$v_lng                              external static fixed bin(17,0)          dcl 2-75
bx_$vers_name                          external static char(168)                dcl 2-18
bx_$vers_number                        external static fixed bin(17,0)          dcl 2-19
comp_ht_n_entries                      automatic       fixed bin(17,0)          dcl 6-297
comp_ht_ptr                            automatic       pointer                  dcl 6-288
comp_tbl                               based           pointer                  array dcl 3-12
component_ht                           based           structure                level 1 dcl 6-289
def_header_ptr                         automatic       pointer                  dcl 6-57
def_ht_n_entries                       automatic       fixed bin(17,0)          dcl 6-284
def_ht_ptr                             automatic       pointer                  dcl 6-277
def_ptr                                automatic       pointer                  dcl 6-71
definition                             based           structure                level 1 dcl 6-72
definition_header                      based           structure                level 1 dcl 6-58
definition_ht                          based           structure                level 1 dcl 6-278
dup_table_n_names                      automatic       fixed bin(17,0)          dcl 6-310
dup_table_ptr                          automatic       pointer                  dcl 6-301
duplicate_table                        based           structure                level 1 dcl 6-302
exp_ptr                                automatic       pointer                  dcl 6-128
exp_word                               based           structure                level 1 dcl 6-129
link_init_copy_info                    based           structure                level 1 dcl 6-211
link_init_deferred                     based           structure                level 1 dcl 6-270
link_init_list_template                based           structure                level 1 dcl 6-219
link_init_n_bits_in_datum              automatic       fixed bin(35,0)          dcl 6-261
link_init_n_words                      automatic       fixed bin(17,0)          dcl 6-215
link_init_n_words_in_list              automatic       fixed bin(17,0)          dcl 6-226
link_init_ptr                          automatic       pointer                  dcl 6-204
link_trap_pair                         based           structure                level 1 dcl 6-177
link_trap_ptr                          automatic       pointer                  dcl 6-176
list_template_entry                    based           structure                level 1 dcl 6-239
lrt                                    based           structure                level 1 dcl 4-84
lrtp                                   automatic       pointer                  dcl 4-17
msf_map                                based           structure                level 1 dcl 6-318
msf_map_ptr                            automatic       pointer                  dcl 6-317
msf_map_version_1                      internal static char(8)                  initial unaligned dcl 6-323
od                                     based           structure                level 1 dcl 4-48
odnp                                   automatic       pointer                  dcl 4-17
pointer_init_template                  based           structure                level 1 packed unaligned dcl 6-253
rpt                                    based           structure                level 1 dcl 4-57
rptep                                  automatic       pointer                  dcl 4-17
rptp                                   automatic       pointer                  dcl 4-17
segname_definition                     based           structure                level 1 dcl 6-90
segname_ptr                            automatic       pointer                  dcl 6-89
snt                                    based           structure                level 1 dcl 4-21
sntp                                   automatic       pointer                  dcl 4-17
type_pair                              based           structure                level 1 dcl 6-160
type_ptr                               automatic       pointer                  dcl 6-159

NAMES DECLARED BY EXPLICIT CONTEXT.
adjust_value                    000452 constant        label                    dcl 205 ref 182
error_skip                      000723 constant        label                    dcl 282 ref 261
generate_def_                   000067 constant        entry                    external dcl 57
init                            001026 constant        entry                    external dcl 312
return                          000727 constant        label                    dcl 285 set ref 224 231 238 264 277

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1270        1356    1063        1300
Length      1700    1063        66         305     204          12

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
generate_def_                       250 external procedure  is an external procedure.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 defbase                     generate_def_
000012 linkbase                    generate_def_
000014 inlink                      generate_def_
000015 errname                     generate_def_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
generate_def_            000100 i                           generate_def_
                         000101 linkoffset                  generate_def_
                         000102 defoffset                   generate_def_
                         000104 p                           generate_def_
                         000106 ip                          generate_def_
                         000110 dp                          generate_def_
                         000112 sp                          generate_def_
                         000114 lp                          generate_def_
                         000116 dsp                         generate_def_
                         000120 my_ext                      generate_def_
                         000253 generate_ext_link           generate_def_
                         000254 dum_instr                   generate_def_
                         000256 ctp                         generate_def_
                         000260 ctep                        generate_def_
                         000262 strmp                       generate_def_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      decode_link_                  ext_link_                     int_link_
strm_hash_$lookup             strm_hash_$make_entry

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
bx_$bound_sep_stat            bx_$caller                    bx_$ctp                       bx_$curdeflng
bx_$debug                     bx_$fatal_error               bx_$nsymdefs                  bx_$standard
bx_$strmp                     bx_$tdefp                     bx_$tlinklng                  bx_$tlinkp


CONSTANTS
001060  aa     775777777777

001061  aa     377777777777

001062  aa     077777777777

000000  aa     606000000003

000001  aa     524000000040

000002  aa     524000000055

000003  aa  154 150 145 000	lhe

000004  aa     524000000064

000005  aa     524000000020

000006  aa     404000000005

000007  aa     404000000021

000010  aa     524000000000

000011  aa     516000000001

000012  aa     464000000000

000014  aa  005 052 154 151	*li
000015  aa  156 153 000 000	nk

000016  aa  154 151 156 153	link
000017  aa  061 065 040 040	15  

000020  aa  120 101 123 103	PASC
000021  aa  101 114 040 040	AL  

000022  aa  147 145 156 145	gene
000023  aa  162 141 164 145	rate
000024  aa  137 144 145 146	_def
000025  aa  137 000 000 000	_

000026  aa  144 145 146 151	defi
000027  aa  156 151 164 151	niti
000030  aa  157 156 040 136	on ^
000031  aa  141 040 151 156	a in
000032  aa  040 146 151 154	 fil
000033  aa  145 040 136 141	e ^a
000034  aa  040 150 141 163	 has
000035  aa  040 151 154 154	 ill
000036  aa  145 147 141 154	egal
000037  aa  040 143 154 141	 cla
000040  aa  163 163 040 136	ss ^
000041  aa  157 000 000 000	o

000042  aa  163 164 162 151	stri
000043  aa  156 147 155 141	ngma
000044  aa  160 040 164 141	p ta
000045  aa  142 154 145 040	ble 
000046  aa  157 166 145 162	over
000047  aa  146 154 157 167	flow
000050  aa  073 040 160 154	; pl
000051  aa  145 141 163 145	ease
000052  aa  040 143 157 156	 con
000053  aa  164 141 143 164	tact
000054  aa  040 155 141 151	 mai
000055  aa  156 164 145 156	nten
000056  aa  141 156 143 145	ance

BEGIN PROCEDURE generate_def_
PROLOGUE SEQUENCE
000057  aa  6 00265 4401 00	sxl0 	pr6|181
						STATEMENT 1 ON LINE 91
000060  aa  6 00253 4501 00	stz  	pr6|171		generate_ext_link
000061  aa  6 00265 7201 00	lxl0 	pr6|181
000062  aa   000000 7100 10	tra  	0,0
MAIN SEQUENCE
ENTRY TO generate_def_                                      STATEMENT 1 ON LINE 57
generate_def_:
     procedure (compent_ptr, definition_ptr);

000063  at     000002000012
000064  ta     000012000000
000065  ta     000063000000
000066  da     000173300000
000067  aa   000400 6270 00	eax7 	256
000070  aa  7 00034 3521 20	epp2 	pr7|28,*
000071  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000072  aa     000004000000
000073  aa     000000000000
000074  aa   777763 7000 04	tsx0 	-13,ic		000057
						STATEMENT 1 ON LINE 123
	ctp = bx_$ctp;

000075  aa  6 00044 3701 20	epp4 	pr6|36,*
000076  la  4 00036 3735 20	epp7 	pr4|30,*		bx_$ctp
000077  aa  7 00000 3735 20	epp7 	pr7|0,*		bx_$ctp
000100  aa  6 00256 6535 00	spri7	pr6|174		ctp
						STATEMENT 1 ON LINE 124
	strmp = bx_$strmp;

000101  la  4 00044 3715 20	epp5 	pr4|36,*		bx_$strmp
000102  aa  5 00000 3715 20	epp5 	pr5|0,*		bx_$strmp
000103  aa  6 00262 6515 00	spri5	pr6|178		strmp
						STATEMENT 1 ON LINE 125
	ctep = compent_ptr;

000104  aa  6 00032 3535 20	epp3 	pr6|26,*
000105  aa  3 00002 3515 20	epp1 	pr3|2,*		compent_ptr
000106  aa  1 00000 3515 20	epp1 	pr1|0,*		compent_ptr
000107  aa  6 00260 2515 00	spri1	pr6|176		ctep
						STATEMENT 1 ON LINE 126
	sp = definition_ptr;

000110  aa  3 00004 3735 20	epp7 	pr3|4,*		definition_ptr
000111  aa  7 00000 3735 20	epp7 	pr7|0,*		definition_ptr
000112  aa  6 00112 6535 00	spri7	pr6|74		sp
						STATEMENT 1 ON LINE 127
	if insyme.regenerated = "1"b
	then return;

000113  aa  7 00110 2351 00	lda  	pr7|72		insyme.regenerated
000114  aa   000007 7350 00	als  	7
000115  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000116  aa   400000 1150 03	cmpa 	131072,du
000117  aa  0 00631 6001 00	tze  	pr0|409		return_mac
						STATEMENT 1 ON LINE 130
	ip = comp.insymentp;

000120  aa  1 00036 3715 20	epp5 	pr1|30,*		comp.insymentp
000121  aa  6 00106 6515 00	spri5	pr6|70		ip
						STATEMENT 1 ON LINE 132
	defoffset = bx_$curdeflng;

000122  la  4 00056 2361 20	ldq  	pr4|46,*		bx_$curdeflng
000123  aa  6 00102 7561 00	stq  	pr6|66		defoffset
						STATEMENT 1 ON LINE 133
	linkoffset = bx_$tlinklng;

000124  la  4 00060 2361 20	ldq  	pr4|48,*		bx_$tlinklng
000125  aa  6 00101 7561 00	stq  	pr6|65		linkoffset
						STATEMENT 1 ON LINE 135
	dp = addrel (defbase, defoffset);

000126  aa  6 00102 2361 00	ldq  	pr6|66		defoffset
000127  ia  4 00010 3521 66	epp2 	pr4|8,*ql		defbase
000130  aa   000000 0520 03	adwp2	0,du
000131  aa  6 00110 2521 00	spri2	pr6|72		dp
						STATEMENT 1 ON LINE 136
	if comp.defblockp = "0"b
	then do;

000132  aa  1 00057 2351 00	lda  	pr1|47		comp.defblockp
000133  aa   777777 3150 03	cana 	262143,du
000134  aa   000011 6010 04	tnz  	9,ic		000145
						STATEMENT 1 ON LINE 138
	     comp.defblockp, comp.current_def = bit (bin (defoffset, 18), 18);

000135  aa  6 00102 2351 00	lda  	pr6|66		defoffset
000136  aa   000002 6050 04	tpl  	2,ic		000140
000137  aa   000000 5310 00	neg  	0
000140  aa   000022 7350 00	als  	18
000141  aa  1 00057 5511 60	stba 	pr1|47,60		comp.defblockp
000142  aa   000022 7710 00	arl  	18
000143  aa  1 00057 5511 14	stba 	pr1|47,14		comp.current_def
						STATEMENT 1 ON LINE 140
	end;

000144  aa   000021 7100 04	tra  	17,ic		000165
						STATEMENT 1 ON LINE 141
	else do;

						STATEMENT 1 ON LINE 142
	     lp = addrel (defbase, comp.current_def);

000145  aa  1 00057 2351 00	lda  	pr1|47		comp.current_def
000146  aa   000022 7350 00	als  	18
000147  ia  4 00010 3521 61	epp2 	pr4|8,*au		defbase
000150  aa   000000 0520 03	adwp2	0,du
000151  aa  6 00114 2521 00	spri2	pr6|76		lp
						STATEMENT 1 ON LINE 143
	     new_def.backward_relp = fixed (comp.current_def, 18);

000152  aa   000066 7730 00	lrl  	54
000153  aa  6 00110 3735 20	epp7 	pr6|72,*		new_def.backward_relp
000154  aa  7 00000 5521 14	stbq 	pr7|0,14		new_def.backward_relp
						STATEMENT 1 ON LINE 145
	     last_def.forward_relp = defoffset;

000155  aa  6 00102 2361 00	ldq  	pr6|66		defoffset
000156  aa   000066 7370 00	lls  	54
000157  aa  2 00000 5511 60	stba 	pr2|0,60		last_def.forward_relp
						STATEMENT 1 ON LINE 146
	     comp.current_def = bit (bin (defoffset, 18), 18);

000160  aa  6 00102 2351 00	lda  	pr6|66		defoffset
000161  aa   000002 6050 04	tpl  	2,ic		000163
000162  aa   000000 5310 00	neg  	0
000163  aa  0 00264 3771 00	anaq 	pr0|180		= 000000777777 777777777777
000164  aa  1 00057 5511 14	stba 	pr1|47,14		comp.current_def
						STATEMENT 1 ON LINE 148
	end;

						STATEMENT 1 ON LINE 149
	insyme.defrel = comp.current_def;

000165  aa  1 00057 2351 00	lda  	pr1|47		comp.current_def
000166  aa   000022 7350 00	als  	18
000167  aa  6 00112 3735 20	epp7 	pr6|74,*		sp
000170  aa  7 00111 7551 00	sta  	pr7|73		insyme.defrel
						STATEMENT 1 ON LINE 150
	new_def.thing_relp = fixed (insyme.value, 18);

000171  aa  7 00001 2351 00	lda  	pr7|1		insyme.value
000172  aa   000066 7730 00	lrl  	54
000173  aa   000066 7370 00	lls  	54
000174  aa  6 00110 3715 20	epp5 	pr6|72,*		dp
000175  aa  5 00001 5511 60	stba 	pr5|1,60		new_def.thing_relp
						STATEMENT 1 ON LINE 151
	new_def.class = fixed (insyme.class, 18);

000176  aa  7 00001 2361 00	ldq  	pr7|1		insyme.class
000177  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
000200  aa  5 00001 6761 00	erq  	pr5|1		new_def.class
000201  aa   000007 3760 07	anq  	7,dl
000202  aa  5 00001 6561 00	ersq 	pr5|1		new_def.class
						STATEMENT 1 ON LINE 152
	new_def.flags.new = "1"b;

000203  aa   400000 2350 07	lda  	131072,dl
000204  aa  5 00001 2551 00	orsa 	pr5|1		new_def.new
						STATEMENT 1 ON LINE 153
	defoffset = defoffset + 3;

000205  aa   000003 2360 07	ldq  	3,dl
000206  aa  6 00102 0561 00	asq  	pr6|66		defoffset
						STATEMENT 1 ON LINE 158
	if insyme.nargs > 0
	then do;

000207  aa  7 00105 2361 00	ldq  	pr7|69		insyme.nargs
000210  aa   000056 6044 04	tmoz 	46,ic		000266
						STATEMENT 1 ON LINE 160
	     new_def.flags.argcount = "1"b;

000211  aa   020000 2350 07	lda  	8192,dl
000212  aa  5 00001 2551 00	orsa 	pr5|1		new_def.argcount
						STATEMENT 1 ON LINE 161
	     if insyme.has_descr
	     then new_def.flags.descriptors = "1"b;

000213  aa  7 00110 2351 00	lda  	pr7|72		insyme.has_descr
000214  aa   100000 3150 03	cana 	32768,du
000215  aa   000003 6000 04	tze  	3,ic		000220
000216  aa   010000 2350 07	lda  	4096,dl
000217  aa  5 00001 2551 00	orsa 	pr5|1		new_def.descriptors
						STATEMENT 1 ON LINE 163
	     new_def.n_args = insyme.nargs;

000220  aa   000066 7370 00	lls  	54
000221  aa  5 00003 5511 60	stba 	pr5|3,60		new_def.n_args
						STATEMENT 1 ON LINE 164
	     dsp = insyme.descr_ptr;

000222  aa  7 00106 3515 20	epp1 	pr7|70,*		insyme.descr_ptr
000223  aa  6 00116 2515 00	spri1	pr6|78		dsp
						STATEMENT 1 ON LINE 165
	     do i = 1 to insyme.nargs;

000224  aa  7 00105 2361 00	ldq  	pr7|69		insyme.nargs
000225  aa  6 00264 7561 00	stq  	pr6|180
000226  aa   000001 2360 07	ldq  	1,dl
000227  aa  6 00100 7561 00	stq  	pr6|64		i
000230  aa  6 00100 2361 00	ldq  	pr6|64		i
000231  aa  6 00264 1161 00	cmpq 	pr6|180
000232  aa   000027 6054 04	tpnz 	23,ic		000261
						STATEMENT 1 ON LINE 166
		new_def.descriptor_relp (i) = descr_list (i) + comp.crelt;

000233  aa   000022 4020 07	mpy  	18,dl
000234  aa   000000 6270 06	eax7 	0,ql
000235  aa  6 00100 2361 00	ldq  	pr6|64		i
000236  aa   000022 4020 07	mpy  	18,dl
000237  aa  6 00116 3735 20	epp7 	pr6|78,*		dsp
000240  aa  003 100 060 517	csl  	(pr,x7),(pr),fill(0),bool(move)
000241  aa  7 77777 40 0022	descb	pr7|-1(18),18	descr_list
000242  aa  6 00056 00 0044	descb	pr6|46,36
000243  aa  6 00056 2351 00	lda  	pr6|46
000244  aa  6 00266 7561 00	stq  	pr6|182
000245  aa   000066 7730 00	lrl  	54
000246  aa  6 00260 3715 20	epp5 	pr6|176,*		ctep
000247  aa  5 00073 0761 00	adq  	pr5|59		comp.crelt
000250  aa   000066 7370 00	lls  	54
000251  aa  6 00056 7551 00	sta  	pr6|46
000252  aa  6 00266 2351 00	lda  	pr6|182
000253  aa  6 00110 3535 20	epp3 	pr6|72,*		dp
000254  aa  003 105 060 500	csl  	(pr),(pr,al),fill(0),bool(move)
000255  aa  6 00056 00 0022	descb	pr6|46,18
000256  aa  3 00003 00 0022	descb	pr3|3,18		new_def.descriptor_relp
						STATEMENT 1 ON LINE 167
	     end;

000257  aa  6 00100 0541 00	aos  	pr6|64		i
000260  aa   777750 7100 04	tra  	-24,ic		000230
						STATEMENT 1 ON LINE 168
	     defoffset = defoffset + divide (insyme.nargs + 2, 2, 17, 0);

000261  aa  6 00112 3735 20	epp7 	pr6|74,*		sp
000262  aa  7 00105 2361 00	ldq  	pr7|69		insyme.nargs
000263  aa   000002 0760 07	adq  	2,dl
000264  aa   000002 5060 07	div  	2,dl
000265  aa  6 00102 0561 00	asq  	pr6|66		defoffset
						STATEMENT 1 ON LINE 170
	end;

						STATEMENT 1 ON LINE 172
	if bx_$standard = 1
	then if insyme.retain_flag
	     then new_def.flags.retain = "1"b;

000266  aa  6 00044 3701 20	epp4 	pr6|36,*
000267  la  4 00054 2361 20	ldq  	pr4|44,*		bx_$standard
000270  aa   000001 1160 07	cmpq 	1,dl
000271  aa   000007 6010 04	tnz  	7,ic		000300
000272  aa  7 00110 2351 00	lda  	pr7|72		insyme.retain_flag
000273  aa   020000 3150 03	cana 	8192,du
000274  aa   000004 6000 04	tze  	4,ic		000300
000275  aa   040000 2350 07	lda  	16384,dl
000276  aa  6 00110 3715 20	epp5 	pr6|72,*		dp
000277  aa  5 00001 2551 00	orsa 	pr5|1		new_def.retain
						STATEMENT 1 ON LINE 178
	call strm_hash_$lookup (substr (insyme.symbol, 1, insyme.lng), i);

000300  aa  7 00104 2361 00	ldq  	pr7|68		insyme.lng
000301  aa   524000 2760 03	orq  	174080,du
000302  aa  6 00266 7561 00	stq  	pr6|182
000303  aa  7 00104 2361 00	ldq  	pr7|68		insyme.lng
000304  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
000305  aa  6 00274 2521 00	spri2	pr6|188
000306  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000307  aa  7 00003 00 0006	desc9a	pr7|3,ql		insyme.symbol
000310  aa  2 00000 00 0006	desc9a	pr2|0,ql
000311  aa  6 00100 3521 00	epp2 	pr6|64		i
000312  aa  6 00276 2521 00	spri2	pr6|190
000313  aa  6 00266 3521 00	epp2 	pr6|182
000314  aa  6 00300 2521 00	spri2	pr6|192
000315  aa   777472 3520 04	epp2 	-198,ic		000007 = 404000000021
000316  aa  6 00302 2521 00	spri2	pr6|194
000317  aa  6 00272 6211 00	eax1 	pr6|186
000320  aa   010000 4310 07	fld  	4096,dl
000321  la  4 00024 3521 20	epp2 	pr4|20,*		strm_hash_$lookup
000322  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 179
	if i ^= 0
	then do;

000323  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
000324  aa  6 00100 2361 00	ldq  	pr6|64		i
000325  aa   000010 6000 04	tze  	8,ic		000335
						STATEMENT 1 ON LINE 181
	     new_def.name_relp = fixed (strm.entry (i).map, 18);

000326  aa  6 00262 3735 20	epp7 	pr6|178,*		strmp
000327  aa  7 01540 2351 06	lda  	pr7|864,ql	strm.map
000330  aa   000066 7730 00	lrl  	54
000331  aa   000066 7370 00	lls  	54
000332  aa  6 00110 3715 20	epp5 	pr6|72,*		dp
000333  aa  5 00002 5511 60	stba 	pr5|2,60		new_def.name_relp
						STATEMENT 1 ON LINE 182
	     goto adjust_value;

000334  aa   000116 7100 04	tra  	78,ic		000452
						STATEMENT 1 ON LINE 183
	end;

						STATEMENT 1 ON LINE 187
	i, strm.nstr = strm.nstr + 1;

000335  aa  6 00262 3735 20	epp7 	pr6|178,*		strmp
000336  aa  7 01540 2361 00	ldq  	pr7|864		strm.nstr
000337  aa   000001 0760 07	adq  	1,dl
000340  aa  6 00100 7561 00	stq  	pr6|64		i
000341  aa  7 01540 7561 00	stq  	pr7|864		strm.nstr
						STATEMENT 1 ON LINE 188
	if strm.nstr > strm.max_size
	then do;

000342  aa  7 01537 1161 00	cmpq 	pr7|863		strm.max_size
000343  aa   000033 6044 04	tmoz 	27,ic		000376
						STATEMENT 1 ON LINE 190
	     call com_err_ (0, errname, "stringmap table overflow; please contact maintenance");

000344  aa  6 00266 4501 00	stz  	pr6|182
000345  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000346  aa   777475 00 0064	desc9a	-195,52		000042 = 163164162151
000347  aa  6 00304 00 0064	desc9a	pr6|196,52
000350  aa  6 00266 3521 00	epp2 	pr6|182
000351  aa  6 00324 2521 00	spri2	pr6|212
000352  aa  6 00044 3701 20	epp4 	pr6|36,*
000353  ia  4 00015 3521 00	epp2 	pr4|13		errname
000354  aa  6 00326 2521 00	spri2	pr6|214
000355  aa  6 00304 3521 00	epp2 	pr6|196
000356  aa  6 00330 2521 00	spri2	pr6|216
000357  aa   777427 3520 04	epp2 	-233,ic		000006 = 404000000005
000360  aa  6 00332 2521 00	spri2	pr6|218
000361  aa   777424 3520 04	epp2 	-236,ic		000005 = 524000000020
000362  aa  6 00334 2521 00	spri2	pr6|220
000363  aa   777421 3520 04	epp2 	-239,ic		000004 = 524000000064
000364  aa  6 00336 2521 00	spri2	pr6|222
000365  aa  6 00322 6211 00	eax1 	pr6|210
000366  aa   014000 4310 07	fld  	6144,dl
000367  la  4 00022 3521 20	epp2 	pr4|18,*		com_err_
000370  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 191
	     strm.nstr = 1;

000371  aa   000001 2360 07	ldq  	1,dl
000372  aa  6 00262 3735 20	epp7 	pr6|178,*		strmp
000373  aa  7 01540 7561 00	stq  	pr7|864		strm.nstr
						STATEMENT 1 ON LINE 192
	     bx_$fatal_error = 1;

000374  aa  6 00044 3701 20	epp4 	pr6|36,*
000375  la  4 00046 7561 20	stq  	pr4|38,*		bx_$fatal_error
						STATEMENT 1 ON LINE 193
	end;

						STATEMENT 1 ON LINE 194
	new_def.name_relp = defoffset;

000376  aa  6 00102 2361 00	ldq  	pr6|66		defoffset
000377  aa   000066 7370 00	lls  	54
000400  aa  6 00110 3715 20	epp5 	pr6|72,*		dp
000401  aa  5 00002 5511 60	stba 	pr5|2,60		new_def.name_relp
						STATEMENT 1 ON LINE 195
	strm.entry (i).map = bit (bin (defoffset, 18), 18);

000402  aa  6 00102 2351 00	lda  	pr6|66		defoffset
000403  aa   000002 6050 04	tpl  	2,ic		000405
000404  aa   000000 5310 00	neg  	0
000405  aa   000022 7350 00	als  	18
000406  aa  6 00100 7271 00	lxl7 	pr6|64		i
000407  aa  7 01540 3535 17	epp3 	pr7|864,7		strm.map
000410  aa  3 00000 5511 60	stba 	pr3|0,60		strm.map
						STATEMENT 1 ON LINE 196
	p = addrel (defbase, defoffset);

000411  aa  6 00102 2361 00	ldq  	pr6|66		defoffset
000412  aa  6 00044 3701 20	epp4 	pr6|36,*
000413  ia  4 00010 3521 66	epp2 	pr4|8,*ql		defbase
000414  aa   000000 0520 03	adwp2	0,du
000415  aa  6 00104 2521 00	spri2	pr6|68		p
						STATEMENT 1 ON LINE 197
	substr (p -> acc_string_overlay, 1, insyme.lng) = substr (insyme.symbol, 1, insyme.lng);

000416  aa  6 00112 3515 20	epp1 	pr6|74,*		sp
000417  aa  1 00104 7261 00	lxl6 	pr1|68		insyme.lng
000420  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000421  aa  1 00003 00 0016	desc9a	pr1|3,x6		insyme.symbol
000422  aa  2 00000 00 0016	desc9a	pr2|0,x6		acc_string_overlay
						STATEMENT 1 ON LINE 198
	defoffset = defoffset + divide (insyme.lng + 3, 4, 17, 0);

000423  aa  1 00104 2361 00	ldq  	pr1|68		insyme.lng
000424  aa   000003 0760 07	adq  	3,dl
000425  aa   000004 5060 07	div  	4,dl
000426  aa  6 00102 0561 00	asq  	pr6|66		defoffset
						STATEMENT 1 ON LINE 201
	call strm_hash_$make_entry (substr (insyme.symbol, 1, insyme.lng), i);

000427  aa  1 00104 2361 00	ldq  	pr1|68		insyme.lng
000430  aa   524000 2760 03	orq  	174080,du
000431  aa  6 00266 7561 00	stq  	pr6|182
000432  aa  1 00104 2361 00	ldq  	pr1|68		insyme.lng
000433  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
000434  aa  6 00274 2521 00	spri2	pr6|188
000435  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000436  aa  1 00003 00 0006	desc9a	pr1|3,ql		insyme.symbol
000437  aa  2 00000 00 0006	desc9a	pr2|0,ql
000440  aa  6 00100 3521 00	epp2 	pr6|64		i
000441  aa  6 00276 2521 00	spri2	pr6|190
000442  aa  6 00266 3521 00	epp2 	pr6|182
000443  aa  6 00300 2521 00	spri2	pr6|192
000444  aa   777343 3520 04	epp2 	-285,ic		000007 = 404000000021
000445  aa  6 00302 2521 00	spri2	pr6|194
000446  aa  6 00272 6211 00	eax1 	pr6|186
000447  aa   010000 4310 07	fld  	4096,dl
000450  la  4 00026 3521 20	epp2 	pr4|22,*		strm_hash_$make_entry
000451  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 205
adjust_value:
	bx_$nsymdefs = bx_$nsymdefs + 1;

000452  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
000453  aa  6 00044 3701 20	epp4 	pr6|36,*
000454  la  4 00062 0541 20	aos  	pr4|50,*		bx_$nsymdefs
						STATEMENT 1 ON LINE 208
	if new_def.class = 0
	then /* simple text reference */
	     do;

000455  aa  6 00110 3735 20	epp7 	pr6|72,*		dp
000456  aa  7 00001 2361 00	ldq  	pr7|1		new_def.class
000457  aa  0 00432 3771 00	anaq 	pr0|282		= 000000000000 000000000007
000460  aa  6 00266 7561 00	stq  	pr6|182		new_def.class
000461  aa   000030 6010 04	tnz  	24,ic		000511
						STATEMENT 1 ON LINE 211
	     new_def.thing_relp = new_def.thing_relp + comp.crelt;

000462  aa  7 00001 2351 00	lda  	pr7|1		new_def.thing_relp
000463  aa   000066 7730 00	lrl  	54
000464  aa  6 00260 3715 20	epp5 	pr6|176,*		ctep
000465  aa  5 00073 0761 00	adq  	pr5|59		comp.crelt
000466  aa   000066 7370 00	lls  	54
000467  aa  7 00001 5511 60	stba 	pr7|1,60		new_def.thing_relp
						STATEMENT 1 ON LINE 213
	     if comp.standard_object = 1
	     then /* have to do some extra fiddling here */
		do;

000470  aa  5 00050 2361 00	ldq  	pr5|40		comp.standard_object
000471  aa   000001 1160 07	cmpq 	1,dl
000472  aa   000235 6010 04	tnz  	157,ic		000727
						STATEMENT 1 ON LINE 216
		if insyme.entrypoint
		then new_def.flags.entry = "1"b;

000473  aa  6 00112 3535 20	epp3 	pr6|74,*		sp
000474  aa  3 00110 2351 00	lda  	pr3|72		insyme.entrypoint
000475  aa   040000 3150 03	cana 	16384,du
000476  aa   000003 6000 04	tze  	3,ic		000501
000477  aa   100000 2350 07	lda  	32768,dl
000500  aa  7 00001 2551 00	orsa 	pr7|1		new_def.entry
						STATEMENT 1 ON LINE 218
		if (insyme.ignore) | (insyme.delete)
		then do;

000501  aa  3 00110 2351 00	lda  	pr3|72		insyme.delete
000502  aa   014000 3150 03	cana 	6144,du
000503  aa   000224 6000 04	tze  	148,ic		000727
						STATEMENT 1 ON LINE 220
		     new_def.flags.ignore = "1"b;

000504  aa   200000 2350 07	lda  	65536,dl
000505  aa  7 00001 2551 00	orsa 	pr7|1		new_def.ignore
						STATEMENT 1 ON LINE 221
		     bx_$nsymdefs = bx_$nsymdefs - 1;

000506  aa   000001 3360 07	lcq  	1,dl
000507  la  4 00062 0561 20	asq  	pr4|50,*		bx_$nsymdefs
						STATEMENT 1 ON LINE 222
		end;

						STATEMENT 1 ON LINE 223
	     end;

						STATEMENT 1 ON LINE 224
	     goto return;

000510  aa   000217 7100 04	tra  	143,ic		000727
						STATEMENT 1 ON LINE 225
	end;

						STATEMENT 1 ON LINE 226
	else if new_def.class = 2
	then /* reference relative to symbol section */
	     do;

000511  aa   000002 1160 07	cmpq 	2,dl
000512  aa   000010 6010 04	tnz  	8,ic		000522
						STATEMENT 1 ON LINE 229
	     new_def.thing_relp = new_def.thing_relp + comp.crels;

000513  aa  7 00001 2351 00	lda  	pr7|1		new_def.thing_relp
000514  aa   000066 7730 00	lrl  	54
000515  aa  6 00260 3715 20	epp5 	pr6|176,*		ctep
000516  aa  5 00075 0761 00	adq  	pr5|61		comp.crels
000517  aa   000066 7370 00	lls  	54
000520  aa  7 00001 5511 60	stba 	pr7|1,60		new_def.thing_relp
						STATEMENT 1 ON LINE 231
	     goto return;

000521  aa   000206 7100 04	tra  	134,ic		000727
						STATEMENT 1 ON LINE 232
	end;

						STATEMENT 1 ON LINE 233
	else if new_def.class = 1
	then do;

000522  aa   000001 1160 07	cmpq 	1,dl
000523  aa   000075 6010 04	tnz  	61,ic		000620
						STATEMENT 1 ON LINE 235
	     if new_def.thing_relp < comp.clngi + 8
	     then do;

000524  aa  7 00001 2351 00	lda  	pr7|1		new_def.thing_relp
000525  aa   000066 7730 00	lrl  	54
000526  aa  6 00321 7561 00	stq  	pr6|209		new_def.thing_relp
000527  aa  6 00260 3715 20	epp5 	pr6|176,*		ctep
000530  aa  5 00064 2361 00	ldq  	pr5|52		comp.clngi
000531  aa   000010 0760 07	adq  	8,dl
000532  aa  6 00321 1161 00	cmpq 	pr6|209		new_def.thing_relp
000533  aa   000006 6044 04	tmoz 	6,ic		000541
						STATEMENT 1 ON LINE 237
		new_def.thing_relp = new_def.thing_relp + comp.creli;

000534  aa  6 00321 2361 00	ldq  	pr6|209		new_def.thing_relp
000535  aa  5 00074 0761 00	adq  	pr5|60		comp.creli
000536  aa   000066 7370 00	lls  	54
000537  aa  7 00001 5511 60	stba 	pr7|1,60		new_def.thing_relp
						STATEMENT 1 ON LINE 238
		goto return;

000540  aa   000167 7100 04	tra  	119,ic		000727
						STATEMENT 1 ON LINE 239
	     end;

						STATEMENT 1 ON LINE 240
	     else do;

						STATEMENT 1 ON LINE 241
		if comp.compiler = "PASCAL  "
		then do;

000541  aa  5 00010 2351 00	lda  	pr5|8		comp.compiler
000542  aa  5 00011 2361 00	ldq  	pr5|9		comp.compiler
000543  aa   777255 1170 04	cmpaq	-339,ic		000020 = 120101123103 101114040040
000544  aa   000101 6010 04	tnz  	65,ic		000645
						STATEMENT 1 ON LINE 251
		     dum_instr.rel_address = bit (bin (new_def.thing_relp, 15), 15);

000545  aa  6 00321 2351 00	lda  	pr6|209		new_def.thing_relp
000546  aa   000002 6050 04	tpl  	2,ic		000550
000547  aa   000000 5310 00	neg  	0
000550  aa   000025 7350 00	als  	21
000551  aa   000003 7710 00	arl  	3
000552  aa  6 00254 6751 00	era  	pr6|172		dum_instr.rel_address
000553  aa   077777 3750 03	ana  	32767,du
000554  aa  6 00254 6551 00	ersa 	pr6|172		dum_instr.rel_address
						STATEMENT 1 ON LINE 252
		     dum_instr.register = "000"b;

000555  aa   000305 2350 04	lda  	197,ic		001062 = 077777777777
000556  aa  6 00254 3551 00	ansa 	pr6|172		dum_instr.register
						STATEMENT 1 ON LINE 253
		     dum_instr.op_code = lda_pr0_instr;

000557  aa   235120 2350 07	lda  	80464,dl
000560  aa  6 00254 5511 14	stba 	pr6|172,14	dum_instr.op_code
						STATEMENT 1 ON LINE 254
		     my_ext.ref_ptr = addr (dum_instr);

000561  aa  6 00254 3535 00	epp3 	pr6|172		dum_instr
000562  aa  6 00122 2535 00	spri3	pr6|82		my_ext.ref_ptr
						STATEMENT 1 ON LINE 255
		     my_ext.dont_prelink = "0"b;

000563  aa   000276 2350 04	lda  	190,ic		001061 = 377777777777
000564  aa  6 00250 3551 00	ansa 	pr6|168		my_ext.dont_prelink
						STATEMENT 1 ON LINE 256
		     my_ext.compent_ptr = ctep;

000565  aa  6 00120 6515 00	spri5	pr6|80		my_ext.compent_ptr
						STATEMENT 1 ON LINE 257
		     my_ext.loffset = new_def.thing_relp;

000566  aa  6 00321 2361 00	ldq  	pr6|209		new_def.thing_relp
000567  aa  6 00131 7561 00	stq  	pr6|89		my_ext.loffset
						STATEMENT 1 ON LINE 258
		     my_ext.side = "lhe";

000570  aa   777213 2350 04	lda  	-373,ic		000003 = 154150145000
000571  aa  6 00125 7551 00	sta  	pr6|85		my_ext.side
						STATEMENT 1 ON LINE 259
		     my_ext.relinfo = "link15";

000572  aa   777224 2370 04	ldaq 	-364,ic		000016 = 154151156153 061065040040
000573  aa  6 00126 7571 00	staq 	pr6|86		my_ext.relinfo
						STATEMENT 1 ON LINE 260
		     my_ext.dont_relocate = "0"b;

000574  aa   000264 2350 04	lda  	180,ic		001060 = 775777777777
000575  aa  6 00250 3551 00	ansa 	pr6|168		my_ext.dont_relocate
						STATEMENT 1 ON LINE 261
		     if decode_link_ (addr (my_ext)) = "1"b
		     then go to error_skip;

000576  aa  6 00120 3535 00	epp3 	pr6|80		my_ext
000577  aa  6 00270 2535 00	spri3	pr6|184
000600  aa  6 00270 3521 00	epp2 	pr6|184
000601  aa  6 00274 2521 00	spri2	pr6|188
000602  aa  6 00321 3521 00	epp2 	pr6|209
000603  aa  6 00276 2521 00	spri2	pr6|190
000604  aa  6 00272 6211 00	eax1 	pr6|186
000605  aa   010000 4310 07	fld  	4096,dl
000606  la  4 00032 3521 20	epp2 	pr4|26,*		decode_link_
000607  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000610  aa  6 00321 2351 00	lda  	pr6|209
000611  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000612  aa   400000 1150 03	cmpa 	131072,du
000613  aa   000110 6000 04	tze  	72,ic		000723
						STATEMENT 1 ON LINE 263
		     generate_ext_link = "1"b;

000614  aa   400000 2350 03	lda  	131072,du
000615  aa  6 00253 7551 00	sta  	pr6|171		generate_ext_link
						STATEMENT 1 ON LINE 264
		     go to return;

000616  aa   000111 7100 04	tra  	73,ic		000727
						STATEMENT 1 ON LINE 265
		end;

						STATEMENT 1 ON LINE 266
	     end;

						STATEMENT 1 ON LINE 267
	end;

000617  aa   000026 7100 04	tra  	22,ic		000645
						STATEMENT 1 ON LINE 268
	else if new_def.class = 4
	then do;

000620  aa   000004 1160 07	cmpq 	4,dl
000621  aa   000024 6010 04	tnz  	20,ic		000645
						STATEMENT 1 ON LINE 270
	     if bx_$bound_sep_stat = 1
	     then i = 0;

000622  la  4 00052 2361 20	ldq  	pr4|42,*		bx_$bound_sep_stat
000623  aa   000001 1160 07	cmpq 	1,dl
000624  aa   000003 6010 04	tnz  	3,ic		000627
000625  aa  6 00100 4501 00	stz  	pr6|64		i
000626  aa   000007 7100 04	tra  	7,ic		000635
						STATEMENT 1 ON LINE 272
	     else do;

						STATEMENT 1 ON LINE 273
		new_def.class = 1;

000627  aa   000001 2350 07	lda  	1,dl
000630  aa  7 00001 6751 00	era  	pr7|1		new_def.class
000631  aa   000007 3750 07	ana  	7,dl
000632  aa  7 00001 6551 00	ersa 	pr7|1		new_def.class
						STATEMENT 1 ON LINE 274
		i = 8;

000633  aa   000010 2360 07	ldq  	8,dl
000634  aa  6 00100 7561 00	stq  	pr6|64		i
						STATEMENT 1 ON LINE 275
	     end;

						STATEMENT 1 ON LINE 276
	     new_def.thing_relp = new_def.thing_relp + comp.creli + i;

000635  aa  7 00001 2351 00	lda  	pr7|1		new_def.thing_relp
000636  aa   000066 7730 00	lrl  	54
000637  aa  6 00260 3715 20	epp5 	pr6|176,*		ctep
000640  aa  5 00074 0761 00	adq  	pr5|60		comp.creli
000641  aa  6 00100 0761 00	adq  	pr6|64		i
000642  aa   000066 7370 00	lls  	54
000643  aa  7 00001 5511 60	stba 	pr7|1,60		new_def.thing_relp
						STATEMENT 1 ON LINE 277
	     goto return;

000644  aa   000063 7100 04	tra  	51,ic		000727
						STATEMENT 1 ON LINE 278
	end;

						STATEMENT 1 ON LINE 279
	call com_err_ (0, errname, "definition ^a in file ^a has illegal class ^o",
	     substr (insyme.symbol, 2, insyme.lng - 1), comp.filename, new_def.class);

000645  aa  6 00112 3735 20	epp7 	pr6|74,*		sp
000646  aa  7 00104 2361 00	ldq  	pr7|68		insyme.lng
000647  aa   000001 1760 07	sbq  	1,dl
000650  aa  6 00321 7561 00	stq  	pr6|209
000651  aa   524000 2760 03	orq  	174080,du
000652  aa  6 00266 7561 00	stq  	pr6|182
000653  aa  6 00267 4501 00	stz  	pr6|183
000654  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000655  aa   777152 00 0060	desc9a	-406,48		000026 = 144145146151
000656  aa  6 00304 00 0060	desc9a	pr6|196,48
000657  aa  6 00321 2361 00	ldq  	pr6|209
000660  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
000661  aa  6 00350 2521 00	spri2	pr6|232
000662  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000663  aa  7 00003 20 0006	desc9a	pr7|3(1),ql	insyme.symbol
000664  aa  2 00000 00 0006	desc9a	pr2|0,ql
000665  aa  6 00267 3521 00	epp2 	pr6|183
000666  aa  6 00342 2521 00	spri2	pr6|226
000667  aa  6 00044 3701 20	epp4 	pr6|36,*
000670  ia  4 00015 3521 00	epp2 	pr4|13		errname
000671  aa  6 00344 2521 00	spri2	pr6|228
000672  aa  6 00304 3521 00	epp2 	pr6|196
000673  aa  6 00346 2521 00	spri2	pr6|230
000674  aa  6 00260 3521 20	epp2 	pr6|176,*		comp.filename
000675  aa  6 00352 2521 00	spri2	pr6|234
000676  aa   000041 7270 07	lxl7 	33,dl
000677  aa  6 00110 3715 20	epp5 	pr6|72,*		dp
000700  aa  5 00001 3521 00	epp2 	pr5|1		new_def.class
000701  aa  2 00000 5035 17	abd  	pr2|0,7
000702  aa  6 00354 2521 00	spri2	pr6|236
000703  aa   777103 3520 04	epp2 	-445,ic		000006 = 404000000005
000704  aa  6 00356 2521 00	spri2	pr6|238
000705  aa   777100 3520 04	epp2 	-448,ic		000005 = 524000000020
000706  aa  6 00360 2521 00	spri2	pr6|240
000707  aa   777073 3520 04	epp2 	-453,ic		000002 = 524000000055
000710  aa  6 00362 2521 00	spri2	pr6|242
000711  aa  6 00266 3521 00	epp2 	pr6|182
000712  aa  6 00364 2521 00	spri2	pr6|244
000713  aa   777066 3520 04	epp2 	-458,ic		000001 = 524000000040
000714  aa  6 00366 2521 00	spri2	pr6|246
000715  aa   777063 3520 04	epp2 	-461,ic		000000 = 606000000003
000716  aa  6 00370 2521 00	spri2	pr6|248
000717  aa  6 00340 6211 00	eax1 	pr6|224
000720  aa   030000 4310 07	fld  	12288,dl
000721  la  4 00022 3521 20	epp2 	pr4|18,*		com_err_
000722  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 282
error_skip:
	bx_$fatal_error = 1;

000723  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
000724  aa   000001 2360 07	ldq  	1,dl
000725  aa  6 00044 3701 20	epp4 	pr6|36,*
000726  la  4 00046 7561 20	stq  	pr4|38,*		bx_$fatal_error
						STATEMENT 1 ON LINE 285
return:
	insyme.regenerated = "1"b;

000727  aa   002000 2350 03	lda  	1024,du
000730  aa  6 00112 3735 20	epp7 	pr6|74,*		sp
000731  aa  7 00110 2551 00	orsa 	pr7|72		insyme.regenerated
						STATEMENT 1 ON LINE 287
	if ^new_def.flags.ignore
	then ip -> insym.retained = "1"b;

000732  aa  6 00110 3715 20	epp5 	pr6|72,*		dp
000733  aa  5 00001 2351 00	lda  	pr5|1		new_def.ignore
000734  aa   200000 3150 07	cana 	65536,dl
000735  aa   000004 6010 04	tnz  	4,ic		000741
000736  aa   400000 2350 03	lda  	131072,du
000737  aa  6 00106 3535 20	epp3 	pr6|70,*		ip
000740  aa  3 00003 2551 00	orsa 	pr3|3		insym.retained
						STATEMENT 1 ON LINE 289
	bx_$curdeflng = defoffset;

000741  aa  6 00102 2361 00	ldq  	pr6|66		defoffset
000742  aa  6 00044 3701 20	epp4 	pr6|36,*
000743  la  4 00056 7561 20	stq  	pr4|46,*		bx_$curdeflng
						STATEMENT 1 ON LINE 290
	bx_$tlinklng = linkoffset;

000744  aa  6 00101 2361 00	ldq  	pr6|65		linkoffset
000745  la  4 00060 7561 20	stq  	pr4|48,*		bx_$tlinklng
						STATEMENT 1 ON LINE 292
	if generate_ext_link
	then do;

000746  aa  6 00253 2351 00	lda  	pr6|171		generate_ext_link
000747  aa   000055 6000 04	tze  	45,ic		001024
						STATEMENT 1 ON LINE 294
	     if int_link_ (addr (my_ext)) = "1"b
	     then do;

000750  aa  6 00120 3535 00	epp3 	pr6|80		my_ext
000751  aa  6 00270 2535 00	spri3	pr6|184
000752  aa  6 00270 3521 00	epp2 	pr6|184
000753  aa  6 00274 2521 00	spri2	pr6|188
000754  aa  6 00266 3521 00	epp2 	pr6|182
000755  aa  6 00276 2521 00	spri2	pr6|190
000756  aa  6 00272 6211 00	eax1 	pr6|186
000757  aa   010000 4310 07	fld  	4096,dl
000760  la  4 00030 3521 20	epp2 	pr4|24,*		int_link_
000761  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000762  aa  6 00266 2351 00	lda  	pr6|182
000763  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000764  aa   400000 1150 03	cmpa 	131072,du
000765  aa   000020 6010 04	tnz  	16,ic		001005
						STATEMENT 1 ON LINE 296
		my_ext.segname = "*link";

000766  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
000767  aa   777026 00 0006	desc9a	-490,6		000014 = 005052154151
000770  aa  6 00132 00 0041	desc9a	pr6|90,33		my_ext.segname
						STATEMENT 1 ON LINE 297
		my_ext.slng = 6;

000771  aa   000006 2360 07	ldq  	6,dl
000772  aa  6 00143 7561 00	stq  	pr6|99		my_ext.slng
						STATEMENT 1 ON LINE 298
		my_ext.elng = 0;

000773  aa  6 00245 4501 00	stz  	pr6|165		my_ext.elng
						STATEMENT 1 ON LINE 299
		my_ext.code15, my_ext.type = "000000000000000001"b;

000774  aa   000001 2350 07	lda  	1,dl
000775  aa  6 00247 5511 14	stba 	pr6|167,14	my_ext.code15
000776  aa   000001 2350 03	lda  	1,du
000777  aa  6 00246 5511 60	stba 	pr6|166,60	my_ext.type
						STATEMENT 1 ON LINE 300
		my_ext.expr = "000"b || dum_instr.rel_address;

001000  aa  6 00254 2351 00	lda  	pr6|172		dum_instr.rel_address
001001  aa   000003 7350 00	als  	3
001002  aa  0 00036 3771 00	anaq 	pr0|30		= 777770000000 000000000000
001003  aa   000003 7710 00	arl  	3
001004  aa  6 00247 5511 60	stba 	pr6|167,60	my_ext.expr
						STATEMENT 1 ON LINE 301
	     end;

						STATEMENT 1 ON LINE 302
	     call ext_link_ (addr (my_ext));

001005  aa  6 00120 3735 00	epp7 	pr6|80		my_ext
001006  aa  6 00270 6535 00	spri7	pr6|184
001007  aa  6 00270 3521 00	epp2 	pr6|184
001010  aa  6 00274 2521 00	spri2	pr6|188
001011  aa  6 00272 6211 00	eax1 	pr6|186
001012  aa   004000 4310 07	fld  	2048,dl
001013  aa  6 00044 3701 20	epp4 	pr6|36,*
001014  la  4 00034 3521 20	epp2 	pr4|28,*		ext_link_
001015  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 303
	     new_def.thing_relp = fixed (dum_instr.rel_address, 15);

001016  aa  6 00254 2351 00	lda  	pr6|172		dum_instr.rel_address
001017  aa   000003 7350 00	als  	3
001020  aa   000071 7730 00	lrl  	57
001021  aa   000066 7370 00	lls  	54
001022  aa  6 00110 3735 20	epp7 	pr6|72,*		dp
001023  aa  7 00001 5511 60	stba 	pr7|1,60		new_def.thing_relp
						STATEMENT 1 ON LINE 304
	end;

						STATEMENT 1 ON LINE 306
	return;

001024  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO init                                               STATEMENT 1 ON LINE 312
init:
     entry;

001025  da     000200200000
001026  aa   000400 6270 00	eax7 	256
001027  aa  7 00034 3521 20	epp2 	pr7|28,*
001030  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001031  aa     000000000000
001032  aa     000000000000
001033  aa   777024 7000 04	tsx0 	-492,ic		000057
						STATEMENT 1 ON LINE 315
	defbase = bx_$tdefp;

001034  aa  6 00044 3701 20	epp4 	pr6|36,*
001035  la  4 00040 3735 20	epp7 	pr4|32,*		bx_$tdefp
001036  aa  7 00000 3735 20	epp7 	pr7|0,*		bx_$tdefp
001037  ia  4 00010 6535 00	spri7	pr4|8		defbase
						STATEMENT 1 ON LINE 316
	linkbase = bx_$tlinkp;

001040  la  4 00042 3715 20	epp5 	pr4|34,*		bx_$tlinkp
001041  aa  5 00000 3715 20	epp5 	pr5|0,*		bx_$tlinkp
001042  ia  4 00012 6515 00	spri5	pr4|10		linkbase
						STATEMENT 1 ON LINE 317
	inlink = 0;

001043  ia  4 00014 4501 00	stz  	pr4|12		inlink
						STATEMENT 1 ON LINE 318
	if bx_$debug = 1
	then errname = "generate_def_";

001044  la  4 00050 2361 20	ldq  	pr4|40,*		bx_$debug
001045  aa   000001 1160 07	cmpq 	1,dl
001046  aa   000005 6010 04	tnz  	5,ic		001053
001047  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
001050  aa   776753 00 0015	desc9a	-533,13		000022 = 147145156145
001051  ia  4 00015 00 0020	desc9a	pr4|13,16		errname
001052  aa   000005 7100 04	tra  	5,ic		001057
						STATEMENT 1 ON LINE 320
	else errname = bx_$caller;

001053  la  4 00064 3535 20	epp3 	pr4|52,*		bx_$caller
001054  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001055  aa  3 00000 00 0020	desc9a	pr3|0,16		bx_$caller
001056  ia  4 00015 00 0020	desc9a	pr4|13,16		errname
						STATEMENT 1 ON LINE 322
	return;

001057  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 337
     end generate_def_;

  END PROCEDURE generate_def_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
