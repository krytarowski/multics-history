	COMPILATION LISTING OF SEGMENT ms_salv_util_v2_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 05/09/85  1110.2 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* ******************************************************
        8*   *                                                    *
        9*   *                                                    *
       10*   * Copyright (c) 1972 by Massachusetts Institute of   *
       11*   * Technology and Honeywell Information Systems, Inc. *
       12*   *                                                    *
       13*   *                                                    *
       14*   ****************************************************** */
       15 
       16 ms_salv_util_v2_: proc (a_forward, a_salv_ptr, a_new_alloc_ptr, a_nrec, a_alloc_len, a_saved_messages, a_saved_blocks,
       17 	a_last_saved_ms_ptr, a_code);
       18 
       19 /* Adapted from original version 2 ms_salv_util_ by J.Stern, 11/4/74 */
       20 
       21 dcl (a_saved_blocks,				/* number of saved message blocks (argument) */
       22      a_saved_messages,				/* number of saved messages (argument) */
       23      block_bit_count,				/* bit count of message portion in block */
       24      block_hdr_data,				/* words in header */
       25      block_trailer_data,				/* words in trailer */
       26      first_full_block_bit_count,			/* bits allocated to first block message portion */
       27      full_block_bit_count,				/* bits allocated to message portion */
       28      i,						/* do loop index */
       29      label_var,					/* label variable */
       30      max_message_blocks,				/* maximum blocks in a message */
       31      message_blocks,				/* number of unchecked blocks in message */
       32      mseg_data_v2_$block_hdr_data ext,			/* words in header */
       33      mseg_data_v2_$block_trailer_data ext,			/* words in trailer */
       34      saved_blocks init (0),				/* number of saved message blocks (internal) */
       35      saved_messages init (0),				/* number of saved messages (internal) */
       36      tsaved_blocks,					/* blocks saved in message */
       37      zero_words (8) init (0, 0, 0, 0, 0, 0, 0, 0)
       38      ) fixed bin;
       39 
       40 dcl (a_alloc_len,
       41      a_nrec,
       42      alloc_len,					/* length of allocation bit string */
       43      backward_offset,				/* offset to backward threaded message */
       44      bit_off,					/* offset of allocation bit for block */
       45      block_ms_words,				/* allocated size for message portion */
       46      block_offset,					/* offset to message block */
       47      block_size,					/* size of message block in words */
       48      first_block_ms_words,				/* allocated size for first block message portion */
       49      forward_offset,				/* offset to forward threaded message */
       50      max_message_size,				/* maximum words in a message */
       51      message_words,					/* word count of message */
       52      ms_offset,					/* offset to first block of message */
       53      mseg_data_v2_$block_size ext,			/* default block size */
       54      mseg_data_v2_$max_message_size ext,
       55      next_block_offset,				/* offset to next message block in message */
       56      nrec,
       57      previous_offset init (0),			/* offset to previous message */
       58      seg_size,					/* maximum size of message segment */
       59      tr_offset)					/* offset from beginning of block to trailer */
       60      fixed bin (18);
       61 
       62 dcl (
       63      a_code,					/* error code */
       64      code init (0)
       65      ) fixed bin (35);
       66 
       67 dcl (a_forward,					/* ON if salvage is forward (argument) */
       68      first_block,					/* ON if block is first block in message */
       69      forward)					/* ON if salvage is forward (internal) */
       70      bit (1) aligned;
       71 
       72 dcl (
       73      mseg_data_v2_$mseg_tr36 ext				/* trailer recognition pattern */
       74      ) bit (36) aligned;
       75 
       76 dcl (a_last_saved_ms_ptr,				/* pointer to last saved message (argument) */
       77      a_new_alloc_ptr,				/* pointer to new allocation bits(argument) */
       78      a_salv_ptr,					/* pointer to where to begin salvaging */
       79      check_ptr,					/* pointer to be tested for validity */
       80      last_saved_ms_ptr init (null),			/* pointer to last saved message(internal) */
       81      new_alloc_ptr,					/* pointer to new allocation bits(argument) */
       82      next_ms_ptr,					/* pointer to next message */
       83      test_block_ptr,				/* pointer to message block being tested */
       84      test_ms_ptr)					/* pointer to message being tested */
       85      ptr;
       86 
       87 dcl (addrel, divide, fixed, mod, null, ptr, rel) builtin;
       88 
       89 dcl  bit_mask (alloc_len) based (new_alloc_ptr) bit (1) unaligned; /* mask for setting allocation bits */
       90 
       91 dcl  zeroes char (32) aligned based (addr (zero_words (1)));
       92 
       93 
  1     1 /* BEGIN include file mseg_hdr_v2.incl.pl1 */
  1     2 
  1     3 dcl  mptr ptr,					/* pointer to message segment */
  1     4 
  1     5      1 mseg_hdr_v2 aligned based (mptr),		/* message segment header format */
  1     6      2 lock bit (36) aligned,				/* standard file system lock */
  1     7      2 mseg_pattern bit (36) aligned,			/* to identify message segments */
  1     8      2 pad (6) fixed bin,
  1     9      2 first_ms_offset bit (18) aligned,		/* offset to first logical message */
  1    10      2 last_ms_offset bit (18) aligned,			/* offset to last logical message */
  1    11      2 alloc_len fixed bin,				/* length of allocation bit string */
  1    12      2 space_left fixed bin,				/* number of empty blocks */
  1    13      2 number_of_messages fixed bin,			/* number of messages in segment */
  1    14      2 block_size fixed bin,				/* message block size */
  1    15      2 switches,
  1    16      3 aip bit (1) unaligned,				/* ON if allocation is in progress */
  1    17      3 os bit (1) unaligned,				/* ON if message segment was salvaged */
  1    18      3 ms_in_hdr bit (1) unaligned,			/* ON if there is a message in the header */
  1    19      3 pad2 bit (30) unaligned,
  1    20      2 version_number fixed bin,
  1    21      2 hdr_ms_len fixed bin,				/* length of header message, if any */
  1    22      2 hdr_ms,					/* space for header message */
  1    23      3 filler (126) fixed bin,
  1    24      3 hdr_ms_end fixed bin,
  1    25      2 alloc_bits bit (alloc_len) aligned;		/* allocation bit string */
  1    26 
  1    27 /* END include file mseg_hdr_v2.incl.pl1 */
       94 
       95 
  2     1 /* BEGIN Message Block Header include file */
  2     2 
  2     3 dcl  block_ptr ptr,					/* pointer to message block */
  2     4 
  2     5      1 ms_block_hdr aligned based(block_ptr),		/* message block header structure */
  2     6       2 f_offset bit(18) unaligned,			/* offset to next block of message */
  2     7       2 first_block bit(1) unaligned,			/* ON if block is first in message */
  2     8       2 block_count bit(17) unaligned;			/* number of message bits in block */
  2     9 
  2    10 /* END Message Block Header include file */
       96 
       97 
  3     1 /* BEGIN include file ms_block_trailer_v2.incl.pl1 */
  3     2 
  3     3 dcl  tr_ptr ptr,					/* pointer to message block trailer area */
  3     4 
  3     5      1 ms_block_trailer_v2 aligned based (tr_ptr),	/* message block trailer structure */
  3     6      2 tr_pattern bit (36) aligned,			/* for identifying beginning of trailer */
  3     7      2 f_offset bit (18) unaligned,			/* offset to next logical message */
  3     8      2 b_offset bit (18) unaligned,			/* offset to previous logical message */
  3     9      2 ms_size bit (18) unaligned,			/* bit count of message */
  3    10      2 time bit (54) unaligned,			/* time message was sent */
  3    11      2 ring_no bit (18) unaligned,			/* validation level */
  3    12      2 pad bit (18) unaligned,
  3    13      2 sender_id char (32) aligned;			/* id of message sender */
  3    14 
  3    15 /* END include file ms_block_trailer_v2.incl.pl1 */
       98 
       99 
      100 
      101 dcl  hcs_$get_max_length_seg ext entry
      102     (ptr, fixed bin (18), fixed bin (35));
      103 
      104 dcl  ptr_is_good_v2_$ms_salvager_entry ext entry
      105     (ptr, fixed bin (18)) returns (bit (1) aligned);
      106 
      107 /*  */
      108 
      109 	max_message_size = mseg_data_v2_$max_message_size;
      110 	mptr = ptr (a_salv_ptr, 0);			/* make pointer to message segment */
      111 	block_size = fixed (mseg_hdr_v2.block_size, 18);
      112 	call hcs_$get_max_length_seg (mptr, seg_size, code);
      113 	if code ^= 0
      114 	then go to FIN;
      115 	if block_size <= 0				/* check for reasonable value */
      116 	then
      117 SET_BLOCK_SIZE:
      118 	block_size = fixed (mseg_data_v2_$block_size);	/* take external one if bad */
      119 	else
      120 	if mod (seg_size, block_size) ^= 0
      121 	then go to SET_BLOCK_SIZE;
      122 	max_message_blocks = divide (max_message_size, block_size, 18, 0); /* compute max blocks in message */
      123 	block_hdr_data = mseg_data_v2_$block_hdr_data;
      124 	block_trailer_data = mseg_data_v2_$block_trailer_data;
      125 
      126 	forward = a_forward;			/* copy argument */
      127 	next_ms_ptr = a_salv_ptr;			/* where to begin salvaging */
      128 	nrec = a_nrec;
      129 	alloc_len = a_alloc_len;
      130 	ms_offset = fixed (rel (next_ms_ptr), 18);	/* offset of where to begin salvaging */
      131 	new_alloc_ptr = a_new_alloc_ptr;		/* copy argument */
      132 	last_saved_ms_ptr = null;			/* initialize pointer to last saved message */
      133 	tr_offset = block_size - block_trailer_data;	/* initialize trailer offset */
      134 	first_block_ms_words =			/* intialize word count of full first block */
      135 	block_size - (block_hdr_data + block_trailer_data);
      136 	first_full_block_bit_count =			/* initialize bit count of full first block */
      137 	first_block_ms_words * 36;
      138 	full_block_bit_count =			/* initialize bit count of full block */
      139 	(block_size - block_hdr_data) * 36;
      140 	block_ms_words =				/* initialize word count of full block */
      141 	block_size - block_hdr_data;
      142 
      143 /*  */
      144 
      145 	begin;
      146 
      147 dcl  bit_offset (max_message_blocks) fixed bin (18);	/* array of offsets into alloc bits */
      148 
      149 LABEL (1):     
      150 CHECK_MESSAGE: 
      151 
      152 	     first_block = "1"b;			/* remember this is a first block of a message */
      153 	     tsaved_blocks = 0;			/* initialize blocks saved in message */
      154 
      155 	     test_ms_ptr = next_ms_ptr;		/* set pointer to message to be tested */
      156 	     ms_offset = fixed (rel (next_ms_ptr), 18);	/* set offset of message to be tested */
      157 	     tr_ptr = addrel (test_ms_ptr, tr_offset);	/* make a pointer to the trailer */
      158 	     if tr_ptr -> ms_block_trailer_v2.tr_pattern ^= mseg_data_v2_$mseg_tr36 /* no trailer pattern */
      159 	     then go to FIN;
      160 	     forward_offset =			/* get offset to next message */
      161 	     fixed (tr_ptr -> ms_block_trailer_v2.f_offset, 18);
      162 	     if forward_offset ^= 0
      163 	     then if forward_offset > nrec*1024		/* forward offset off end of segment */
      164 	     then go to FIN;			/* give up */
      165 	     if forward_offset = 0			/* this should be last message in segment */
      166 	     then if mseg_hdr_v2.last_ms_offset ^= rel (test_ms_ptr) /* header doesn't agree */
      167 	     then go to FIN;			/* give up */
      168 	     backward_offset =			/* get offset to previous message */
      169 	     fixed (tr_ptr -> ms_block_trailer_v2.b_offset, 18);
      170 	     if backward_offset ^= 0
      171 	     then if backward_offset > nrec*1024	/* previous offset off end of message */
      172 	     then go to FIN;
      173 	     if backward_offset = 0			/* this should be first message */
      174 	     then if mseg_hdr_v2.first_ms_offset ^= rel (test_ms_ptr) /* header doesn't agree */
      175 	     then go to FIN;
      176 
      177 	     if ms_size = "0"b			/* check for zeroing out */
      178 	     | time = "0"b
      179 	     | sender_id = zeroes
      180 	     then go to FIN;
      181 
      182 	     if (forward)				/* forward salvage */
      183 	     then do;
      184 
      185 		if previous_offset ^= 0		/* there was a previous message */
      186 		then if backward_offset ^=
      187 		previous_offset			/* this message doesn't point to it */
      188 		then go to FIN;			/* give up */
      189 		check_ptr,			/* create pointer to next message */
      190 		next_ms_ptr = ptr (test_ms_ptr, forward_offset);
      191 
      192 	     end;
      193 
      194 	     else					/* backward salvage */
      195 	     do;
      196 
      197 		if previous_offset ^= 0		/* there was a previous message */
      198 		then if forward_offset ^=
      199 		previous_offset			/* this message doesn't point to it */
      200 		then go to FIN;			/* give up */
      201 		check_ptr,			/* create pointer to next message */
      202 		next_ms_ptr = ptr (test_ms_ptr, backward_offset);
      203 
      204 	     end;
      205 
      206 	     previous_offset = ms_offset;		/* remember for next message check */
      207 
      208 	     if fixed (rel (next_ms_ptr), 18) ^= 0	/* there is a next message */
      209 	     then if (^ptr_is_good_v2_$ms_salvager_entry (next_ms_ptr, block_size)) /* bad offset to next message */
      210 	     then go to FIN;			/* give up */
      211 
      212 	     message_words =			/* calculate number of words in message */
      213 	     divide (fixed (tr_ptr -> ms_block_trailer_v2.ms_size, 18)+35, 36, 18, 0);
      214 
      215 	     if message_words <= 0			/* bad word count */
      216 	     then go to FIN;			/* give up */
      217 	     if message_words > max_message_size
      218 	     then go to FIN;
      219 
      220 	     if message_words <= first_block_ms_words	/* calculate blocks in message */
      221 	     then message_blocks = 1;
      222 	     else
      223 	     message_blocks =
      224 	     divide (message_words-first_block_ms_words+block_ms_words-1, block_ms_words, 17, 0)+1;
      225 	     block_offset = fixed (rel (test_ms_ptr), 18);
      226 
      227 	     test_block_ptr = test_ms_ptr;		/* set pointer for testing rest of block */
      228 
      229 /*  */
      230 
      231 /* check the block header */
      232 
      233 LABEL (2):     
      234 CHECK_BLOCK:   
      235 
      236 /* check to see if the block has been allocated */
      237 
      238 	     bit_off = divide (block_offset, block_size, 18, 0)+1; /* calculate bit offset in alloc bits */
      239 
      240 	     do i = 1 to tsaved_blocks;		/* check against other blocks in this message */
      241 		if bit_offset (i) = bit_off		/* block is used */
      242 		then go to FIN;			/* give up */
      243 	     end;
      244 
      245 	     if new_alloc_ptr -> bit_mask (bit_off) = "1"b /* block is used */
      246 	     then go to FIN;
      247 
      248 	     if test_block_ptr -> ms_block_hdr.first_block ^=
      249 	     first_block				/* bad first block flag */
      250 	     then go to FIN;
      251 
      252 	     block_bit_count =			/* get size of message portion in block */
      253 	     fixed (test_block_ptr -> ms_block_hdr.block_count, 17);
      254 	     if block_bit_count <= 0			/* bad block bit count */
      255 	     then go to FIN;			/* give up */
      256 
      257 	     if (first_block)			/* first block of a message */
      258 	     then do;
      259 
      260 		if message_blocks ^= 1		/* another block follows */
      261 		then do;
      262 		     if block_bit_count ^=
      263 		     first_full_block_bit_count	/* error in block bit count */
      264 		     then go to FIN;
      265 		end;
      266 		else				/* no blocks follow */
      267 		if block_bit_count >
      268 		first_full_block_bit_count		/* error in block bit count */
      269 		then go to FIN;
      270 	     end;
      271 
      272 	     else					/* not first block in message */
      273 	     do;
      274 		if message_blocks ^= 1		/* another block follows */
      275 		then do;
      276 		     if block_bit_count ^=
      277 		     full_block_bit_count		/* error in block bit count */
      278 		     then go to FIN;		/* give up */
      279 		end;
      280 		else				/* last block in message */
      281 		if block_bit_count > full_block_bit_count /* bad block bit count */
      282 		then go to FIN;			/* give up */
      283 	     end;
      284 
      285 	     next_block_offset =			/* get the offset to the next message block */
      286 	     fixed (test_block_ptr -> ms_block_hdr.f_offset, 18);
      287 
      288 	     bit_offset (tsaved_blocks + 1) = bit_off;	/* remember location of block */
      289 
      290 	     if message_blocks = 1			/* last block in message */
      291 	     then do;
      292 		if next_block_offset ^= 0		/* block pointer bad */
      293 		then go to FIN;
      294 		else				/* legitimate end of message */
      295 		do;
      296 		     saved_blocks =			/* add in saved blocks */
      297 		     saved_blocks + tsaved_blocks +1;
      298 		     do i = 1 to tsaved_blocks + 1;	/* turn on the appropriate allocation bits */
      299 			new_alloc_ptr -> bit_mask (bit_offset (i)) = "1"b;
      300 		     end;
      301 		     saved_messages =		/* add in saved message */
      302 		     saved_messages + 1;
      303 		     last_saved_ms_ptr = test_ms_ptr;	/* set pointer to saved message */
      304 		     check_ptr = next_ms_ptr;		/* prepare to check pointer */
      305 		     label_var = 1;			/* prepare for next message check */
      306 		end;
      307 	     end;
      308 
      309 	     else					/* not end of message */
      310 	     do;
      311 		first_block = "0"b;			/* remember next block is not a first block */
      312 		message_blocks = message_blocks - 1;	/* decrement blocks left to check */
      313 		tsaved_blocks = tsaved_blocks + 1;	/* increment temporary saved block count */
      314 		block_offset = next_block_offset;	/* reset for testing next block */
      315 		test_block_ptr,			/* make a pointer to the next block */
      316 		check_ptr =			/* prepare to check the pointer */
      317 		ptr (test_block_ptr, next_block_offset);
      318 		label_var = 2;			/* prepare for next block check */
      319 	     end;
      320 
      321 
      322 
      323 	     if (ptr_is_good_v2_$ms_salvager_entry (check_ptr, block_size)) /* new pointer is ok */
      324 	     then go to LABEL (label_var);		/* check next block */
      325 
      326 	end;					/* of BEGIN block */
      327 
      328 /*  */
      329 
      330 FIN:	
      331 
      332 	a_saved_messages = saved_messages;		/* return appropriate values */
      333 	a_saved_blocks = saved_blocks;
      334 	a_last_saved_ms_ptr = last_saved_ms_ptr;
      335 	a_code = code;
      336 	return;
      337 
      338      end ms_salv_util_v2_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/06/85  1619.0  ms_salv_util_v2_.pl1              >spec>on>mseg>ms_salv_util_v2_.pl1
94           1    05/06/85  1121.8  mseg_hdr_v2.incl.pl1              >spec>on>mseg>mseg_hdr_v2.incl.pl1
96           2    05/06/85  1121.7  ms_block_hdr_v2.incl.pl1          >spec>on>mseg>ms_block_hdr_v2.incl.pl1
98           3    05/06/85  1121.7  ms_block_trailer_v2.incl.pl1      >spec>on>mseg>ms_block_trailer_v2.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_alloc_len                            parameter       fixed bin(18,0)          dcl 40 ref 16 129
a_code                                 parameter       fixed bin(35,0)          dcl 62 set ref 16 335*
a_forward                              parameter       bit(1)                   dcl 67 ref 16 126
a_last_saved_ms_ptr                    parameter       pointer                  dcl 76 set ref 16 334*
a_new_alloc_ptr                        parameter       pointer                  dcl 76 ref 16 131
a_nrec                                 parameter       fixed bin(18,0)          dcl 40 ref 16 128
a_salv_ptr                             parameter       pointer                  dcl 76 ref 16 110 127
a_saved_blocks                         parameter       fixed bin(17,0)          dcl 21 set ref 16 333*
a_saved_messages                       parameter       fixed bin(17,0)          dcl 21 set ref 16 330*
addrel                                                 builtin function         dcl 87 ref 157
alloc_len                       000124 automatic       fixed bin(18,0)          dcl 40 set ref 129*
b_offset                  1(18)        based           bit(18)                  level 2 packed unaligned dcl 3-3 ref 168
backward_offset                 000125 automatic       fixed bin(18,0)          dcl 40 set ref 168* 170 170 173 185 201
bit_mask                               based           bit(1)                   array unaligned dcl 89 set ref 245 299*
bit_off                         000126 automatic       fixed bin(18,0)          dcl 40 set ref 233* 241 245 288
bit_offset                      000100 automatic       fixed bin(18,0)          array dcl 147 set ref 241 288* 299
block_bit_count                 000100 automatic       fixed bin(17,0)          dcl 21 set ref 252* 254 262 266 276 280
block_count               0(19)        based           bit(17)                  level 2 packed unaligned dcl 2-3 ref 252
block_hdr_data                  000101 automatic       fixed bin(17,0)          dcl 21 set ref 123* 134 138 140
block_ms_words                  000127 automatic       fixed bin(18,0)          dcl 40 set ref 140* 222 222
block_offset                    000130 automatic       fixed bin(18,0)          dcl 40 set ref 225* 233 314*
block_size                      000131 automatic       fixed bin(18,0)          dcl 40 in procedure "ms_salv_util_v2_" set ref 111*
                                                                                  115 115* 119 122 133 134 138 140 208* 233 323*
block_size               15            based           fixed bin(17,0)          level 2 in structure "mseg_hdr_v2" dcl 1-3
                                                                                  in procedure "ms_salv_util_v2_" ref 111
block_trailer_data              000102 automatic       fixed bin(17,0)          dcl 21 set ref 124* 133 134
check_ptr                       000150 automatic       pointer                  dcl 76 set ref 189* 201* 304* 315* 323*
code                            000144 automatic       fixed bin(35,0)          initial dcl 62 set ref 62* 112* 113 335
divide                                                 builtin function         dcl 87 ref 122 212 222 233
f_offset                  1            based           bit(18)                  level 2 in structure "ms_block_trailer_v2" packed
                                                                                  unaligned dcl 3-3 in procedure "ms_salv_util_v2_"
                                                                                  ref 160
f_offset                               based           bit(18)                  level 2 in structure "ms_block_hdr" packed unaligned
                                                                                  dcl 2-3 in procedure "ms_salv_util_v2_" ref 285
first_block                     000145 automatic       bit(1)                   dcl 67 in procedure "ms_salv_util_v2_" set ref 149*
                                                                                  248 257 311*
first_block               0(18)        based           bit(1)                   level 2 in structure "ms_block_hdr" packed unaligned
                                                                                  dcl 2-3 in procedure "ms_salv_util_v2_" ref 248
first_block_ms_words            000132 automatic       fixed bin(18,0)          dcl 40 set ref 134* 136 220 222
first_full_block_bit_count      000103 automatic       fixed bin(17,0)          dcl 21 set ref 136* 262 266
first_ms_offset          10            based           bit(18)                  level 2 dcl 1-3 ref 173
fixed                                                  builtin function         dcl 87 ref 111 115 130 156 160 168 208 212 225 252
                                                                                  285
forward                         000146 automatic       bit(1)                   dcl 67 set ref 126* 182
forward_offset                  000133 automatic       fixed bin(18,0)          dcl 40 set ref 160* 162 162 165 189 197
full_block_bit_count            000104 automatic       fixed bin(17,0)          dcl 21 set ref 138* 276 280
hcs_$get_max_length_seg         000022 constant        entry                    external dcl 101 ref 112
i                               000105 automatic       fixed bin(17,0)          dcl 21 set ref 240* 241* 298* 299*
label_var                       000106 automatic       fixed bin(17,0)          dcl 21 set ref 305* 318* 323
last_ms_offset           11            based           bit(18)                  level 2 dcl 1-3 ref 165
last_saved_ms_ptr               000152 automatic       pointer                  initial dcl 76 set ref 76* 132* 303* 334
max_message_blocks              000107 automatic       fixed bin(17,0)          dcl 21 set ref 122* 147
max_message_size                000134 automatic       fixed bin(18,0)          dcl 40 set ref 109* 122 217
message_blocks                  000110 automatic       fixed bin(17,0)          dcl 21 set ref 220* 222* 260 274 290 312* 312
message_words                   000135 automatic       fixed bin(18,0)          dcl 40 set ref 212* 215 217 220 222
mod                                                    builtin function         dcl 87 ref 119
mptr                            000164 automatic       pointer                  dcl 1-3 set ref 110* 111 112* 165 173
ms_block_hdr                           based           structure                level 1 dcl 2-3
ms_block_trailer_v2                    based           structure                level 1 dcl 3-3
ms_offset                       000136 automatic       fixed bin(18,0)          dcl 40 set ref 130* 156* 206
ms_size                   2            based           bit(18)                  level 2 packed unaligned dcl 3-3 ref 177 212
mseg_data_v2_$block_hdr_data    000010 external static fixed bin(17,0)          dcl 21 ref 123
mseg_data_v2_$block_size        000014 external static fixed bin(18,0)          dcl 40 ref 115
mseg_data_v2_$block_trailer_data
                                000012 external static fixed bin(17,0)          dcl 21 ref 124
mseg_data_v2_$max_message_size  000016 external static fixed bin(18,0)          dcl 40 ref 109
mseg_data_v2_$mseg_tr36         000020 external static bit(36)                  dcl 72 ref 158
mseg_hdr_v2                            based           structure                level 1 dcl 1-3
new_alloc_ptr                   000154 automatic       pointer                  dcl 76 set ref 131* 245 299
next_block_offset               000137 automatic       fixed bin(18,0)          dcl 40 set ref 285* 292 314 315
next_ms_ptr                     000156 automatic       pointer                  dcl 76 set ref 127* 130 155 156 189* 201* 208 208*
                                                                                  304
nrec                            000140 automatic       fixed bin(18,0)          dcl 40 set ref 128* 162 170
null                                                   builtin function         dcl 87 ref 76 132
previous_offset                 000141 automatic       fixed bin(18,0)          initial dcl 40 set ref 40* 185 185 197 197 206*
ptr                                                    builtin function         dcl 87 ref 110 189 201 315
ptr_is_good_v2_$ms_salvager_entry
                                000024 constant        entry                    external dcl 104 ref 208 323
rel                                                    builtin function         dcl 87 ref 130 156 165 173 208 225
saved_blocks                    000111 automatic       fixed bin(17,0)          initial dcl 21 set ref 21* 296* 296 333
saved_messages                  000112 automatic       fixed bin(17,0)          initial dcl 21 set ref 21* 301* 301 330
seg_size                        000142 automatic       fixed bin(18,0)          dcl 40 set ref 112* 119
sender_id                 5            based           char(32)                 level 2 dcl 3-3 ref 177
test_block_ptr                  000160 automatic       pointer                  dcl 76 set ref 227* 248 252 285 315 315*
test_ms_ptr                     000162 automatic       pointer                  dcl 76 set ref 155* 157 165 173 189 201 225 227 303
time                      2(18)        based           bit(54)                  level 2 packed unaligned dcl 3-3 ref 177
tr_offset                       000143 automatic       fixed bin(18,0)          dcl 40 set ref 133* 157
tr_pattern                             based           bit(36)                  level 2 dcl 3-3 ref 158
tr_ptr                          000166 automatic       pointer                  dcl 3-3 set ref 157* 158 160 168 177 177 177 212
tsaved_blocks                   000113 automatic       fixed bin(17,0)          dcl 21 set ref 153* 240 288 296 298 313* 313
zero_words                      000114 automatic       fixed bin(17,0)          initial array dcl 21 set ref 21* 21* 21* 21* 21* 21*
                                                                                  21* 21* 177
zeroes                                 based           char(32)                 dcl 91 ref 177

NAME DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
block_ptr                              automatic       pointer                  dcl 2-3

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_BLOCK                     000500 constant        label                    dcl 233
CHECK_MESSAGE                   000210 constant        label                    dcl 149
FIN                             000743 constant        label                    dcl 330 ref 113 158 162 165 170 173 177 185 197 208
                                                                                  215 217 241 245 248 254 262 266 276 280 292
LABEL                           000000 constant        label                    array(2) dcl 149 ref 323
SET_BLOCK_SIZE                  000113 constant        label                    dcl 115 ref 119
ms_salv_util_v2_                000021 constant        entry                    external dcl 16

NAME DECLARED BY CONTEXT OR IMPLICATION.
addr                                                   builtin function         ref 177

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1104        1132     761        1114
Length      1362     761        26         213     123           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ms_salv_util_v2_                    130 external procedure  is an external procedure.  
begin block on line 145              82 begin block         uses auto adjustable storage.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 145  000100 bit_offset                  begin block on line 145
ms_salv_util_v2_         000100 block_bit_count             ms_salv_util_v2_
                         000101 block_hdr_data              ms_salv_util_v2_
                         000102 block_trailer_data          ms_salv_util_v2_
                         000103 first_full_block_bit_count  ms_salv_util_v2_
                         000104 full_block_bit_count        ms_salv_util_v2_
                         000105 i                           ms_salv_util_v2_
                         000106 label_var                   ms_salv_util_v2_
                         000107 max_message_blocks          ms_salv_util_v2_
                         000110 message_blocks              ms_salv_util_v2_
                         000111 saved_blocks                ms_salv_util_v2_
                         000112 saved_messages              ms_salv_util_v2_
                         000113 tsaved_blocks               ms_salv_util_v2_
                         000114 zero_words                  ms_salv_util_v2_
                         000124 alloc_len                   ms_salv_util_v2_
                         000125 backward_offset             ms_salv_util_v2_
                         000126 bit_off                     ms_salv_util_v2_
                         000127 block_ms_words              ms_salv_util_v2_
                         000130 block_offset                ms_salv_util_v2_
                         000131 block_size                  ms_salv_util_v2_
                         000132 first_block_ms_words        ms_salv_util_v2_
                         000133 forward_offset              ms_salv_util_v2_
                         000134 max_message_size            ms_salv_util_v2_
                         000135 message_words               ms_salv_util_v2_
                         000136 ms_offset                   ms_salv_util_v2_
                         000137 next_block_offset           ms_salv_util_v2_
                         000140 nrec                        ms_salv_util_v2_
                         000141 previous_offset             ms_salv_util_v2_
                         000142 seg_size                    ms_salv_util_v2_
                         000143 tr_offset                   ms_salv_util_v2_
                         000144 code                        ms_salv_util_v2_
                         000145 first_block                 ms_salv_util_v2_
                         000146 forward                     ms_salv_util_v2_
                         000150 check_ptr                   ms_salv_util_v2_
                         000152 last_saved_ms_ptr           ms_salv_util_v2_
                         000154 new_alloc_ptr               ms_salv_util_v2_
                         000156 next_ms_ptr                 ms_salv_util_v2_
                         000160 test_block_ptr              ms_salv_util_v2_
                         000162 test_ms_ptr                 ms_salv_util_v2_
                         000164 mptr                        ms_salv_util_v2_
                         000166 tr_ptr                      ms_salv_util_v2_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
enter_begin         leave_begin         call_ext_out        return              tra_ext             alloc_auto_adj
mod_fx1             ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
hcs_$get_max_length_seg       ptr_is_good_v2_$ms_salvager_entry

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
mseg_data_v2_$block_hdr_data  mseg_data_v2_$block_size      mseg_data_v2_$block_trailer_data
mseg_data_v2_$max_message_size                              mseg_data_v2_$mseg_tr36




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     16 000012        21 000026        40 000061        62 000062        76 000063       109 000065       110 000067
    111 000073       112 000075       113 000107       115 000111       119 000117       122 000123       123 000126
    124 000131       126 000133       127 000137       128 000142       129 000144       130 000146       131 000151
    132 000154       133 000156       134 000161       136 000167       138 000171       140 000175       145 000200
    147 000203       149 000210       153 000213       155 000214       156 000216       157 000221       158 000225
    160 000234       162 000241       165 000252       168 000264       170 000271       173 000302       177 000314
    182 000346       185 000351       189 000360       192 000367       197 000370       201 000377       206 000406
    208 000410       212 000434       215 000443       217 000447       220 000456       222 000465       225 000473
    227 000476       233 000500       240 000505       241 000516       243 000525       245 000530       248 000541
    252 000552       254 000556       257 000563       260 000566       262 000571       265 000577       266 000600
    270 000606       274 000607       276 000612       279 000620       280 000621       285 000627       288 000633
    290 000636       292 000641       296 000646       298 000653       299 000664       300 000672       301 000674
    303 000675       304 000677       305 000701       307 000703       311 000704       312 000705       313 000707
    314 000710       315 000712       318 000717       323 000721       326 000742       330 000743       333 000746
    334 000750       335 000752       336 000754


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
