	COMPILATION LISTING OF SEGMENT rlm_get_tuple_id
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 12/01/87  0913.6 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /* format: off */
       10 
       11 /* DESCRIPTION:
       12*
       13*         This module searches through a relation, using the
       14*     record_manager_ and/or the index_manager_, returning an array
       15*     of tuple ids that identify the tuples found. This program is a
       16*     replacement for rlm_general_search$get_tuple_id. A call to
       17*     rlm_general_search$get_id has been retained because in the future
       18*     a requirement to implement multiple and-groups or provide the other
       19*     rlm_general_search entrypoints may arise.
       20*
       21*         If a search specification is supplied that doesn't have constraints,
       22*     then the record_manager_ is used to get the tuple ids (case 3 in the
       23*     table below). If constraints are present and they only constrain 
       24*     non-indexed fields, then the record_manager_ is used to get the tuple ids
       25*     (this is also case 3). If constraints are present and they only constrain
       26*     fields that are in one index, then the index_manager_ is used to get the
       27*     tuple ids (case 2). Otherwise the index_manager_ is used to get the tuple
       28*     ids, and then record_manager_ is used to search these tuples to determine
       29*     if they meet the rest of the constraints (case 1). Case 1 is implemented
       30*     by the internal subroutine SEARCH_INDEX_AND_RECORD_COLLECTIONS. Case 2
       31*     is implemented by the internal subroutine SEARCH_INDEX_COLLECTION. Case 3
       32*     is implemented by the internal subroutine SEARCH_RECORD_COLLECTION.
       33*
       34*     ______________________________________________
       35*     |            | Index Search  |  Record Search |
       36*     |------------|---------------|----------------|
       37*     |    Case 1. |     Yes       |      Yes       |
       38*     |    Case 2. |     Yes       |      No        |
       39*     |    Case 3. |     No        |      Yes       |
       40*     |____________|_______________|________________|
       41**/
       42 
       43 /****^  HISTORY COMMENTS:
       44*  1) change(86-08-19,Dupuis), approve(86-08-19,MCR7401), audit(86-09-30,Blair),
       45*     install(86-10-02,MR12.0-1173):
       46*     Written during August/September of 1986.
       47*  2) change(87-10-27,Hergert), approve(87-11-25,MCR7799),
       48*     audit(87-11-25,Dupuis), install(87-12-01,MR12.2-1007):
       49*     Fixed bug where an uninitialized variable was causing the procedure
       50*     to return to its caller a zero error code when there were no more tuples.
       51*                                                   END HISTORY COMMENTS */
       52 
       53 rlm_get_tuple_id: proc (
       54 
       55 	p_relation_cursor_ptr,    /* input: to the relation cursor */
       56 	p_specification_ptr,      /* input: to the relation search spec */
       57 	p_callers_area_ptr,       /* input: element_id_list might go here */
       58 	p_element_id_list_ptr,    /* input/output: to the element_id_list */
       59 	p_code                    /* output: success or failure */
       60 	   );
       61 
       62 dcl p_callers_area_ptr ptr parameter;
       63 dcl p_code fixed bin (35) parameter;
       64 dcl p_element_id_list_ptr ptr;
       65 dcl p_relation_cursor_ptr ptr parameter;
       66 dcl p_specification_ptr ptr parameter;
       67 
       68 	relation_cursor_ptr = p_relation_cursor_ptr;
       69 	relation_search_specification_ptr = p_specification_ptr;
       70 	callers_area_ptr = p_callers_area_ptr;
       71 	element_id_list_ptr = p_element_id_list_ptr;
       72 	p_code = 0;
       73 
       74 	call INITIALIZE;
       75 
       76 	on cleanup begin;
       77 	     cleanup_signalled = ON;
       78 	     call TERMINATE;
       79 	end;
       80 
       81 	call SETUP_SEARCH_SPECIFICATION (there_is_an_and_group_supplied,
       82 	     primary_collection_id, secondary_collection_id,
       83 	     current_indexes_index, search_the_index, search_the_records,
       84 	     search_specification_is_relative, id_list_ptr);
       85 
       86 	call SETUP_REQUIRED_CURSORS_AND_AREA (primary_cursor_ptr, secondary_cursor_ptr, temporary_area_ptr);
       87 
       88 	if search_the_index & search_the_records
       89 	then call SEARCH_INDEX_AND_RECORD_COLLECTIONS (number_of_tuples_found);
       90 	else if search_the_records
       91 	     then call SEARCH_RECORD_COLLECTION (number_of_tuples_found);
       92 	     else call SEARCH_INDEX_COLLECTION (number_of_tuples_found);
       93 
       94 	if number_of_tuples_found = 0
       95 	then p_code = dm_error_$tuple_not_found;
       96 
       97 	call TERMINATE;
       98 	call UPDATE_RELATION_CURSOR;
       99 
      100 RETURN:
      101 	return;
      102 
      103 CHECK_VERSION: proc (
      104 
      105 	cv_p_structure_name,   /* input: name of structure */
      106 	cv_p_received_version, /* input: version of structure */
      107 	cv_p_expected_version  /* input: expected version of structure */
      108 		   );
      109 
      110 dcl cv_p_expected_version char (8) aligned;
      111 dcl cv_p_received_version char (8) aligned;
      112 dcl cv_p_structure_name char (*);
      113 
      114 	if cv_p_received_version ^= cv_p_expected_version
      115 	then call sub_err_ (error_table_$unimplemented_version, MY_NAME, ACTION_CANT_RESTART, null, 0,
      116 	     "^/Expected version ^a of the ^a structure.^/Received version ^a instead.",
      117 	     cv_p_expected_version, cv_p_structure_name, cv_p_received_version);
      118 
      119 	return;
      120 
      121      end CHECK_VERSION;
      122 
      123 CHECK_VERSION_FB: proc (
      124 
      125 	cvf_p_structure_name,   /* input: name of structure */
      126 	cvf_p_received_version, /* input: version of structure */
      127 	cvf_p_expected_version  /* input: expected version of structure */
      128 		   );
      129 
      130 dcl cvf_p_expected_version fixed bin (35);
      131 dcl cvf_p_received_version fixed bin (35);
      132 dcl cvf_p_structure_name char (*);
      133 
      134 	if cvf_p_received_version ^= cvf_p_expected_version
      135 	then call sub_err_ (error_table_$unimplemented_version, MY_NAME, ACTION_CANT_RESTART, null, 0,
      136 	     "^/Expected version ^d of the ^a structure.^/Received version ^d instead.",
      137 	     cvf_p_expected_version, cvf_p_structure_name, cvf_p_received_version);
      138 
      139 	return;
      140 
      141      end CHECK_VERSION_FB;
      142 
      143 ERROR_RETURN: proc (
      144 
      145 	er_p_code	/* input: a standard Multics error code */
      146 	         );
      147 
      148 dcl er_p_code fixed bin (35) parameter;
      149 
      150 	p_code = er_p_code;
      151 	call TERMINATE;
      152 
      153 	goto RETURN;
      154 
      155      end ERROR_RETURN;
      156 
      157 INITIALIZE: proc;
      158 
      159 dcl i_code fixed bin (35);
      160 
      161 	call CHECK_VERSION ("relation_cursor", relation_cursor.version, RELATION_CURSOR_VERSION_2);
      162 
      163 	if relation_search_specification_ptr = null
      164 	then call sub_err_ (error_table_$null_info_ptr, MY_NAME, ACTION_CANT_RESTART, null, 0,
      165 	     "^/Support for a null search specification isn't implemented.");
      166 	call CHECK_VERSION_FB ("specification", relation_search_specification.head.version, SPECIFICATION_VERSION_4);
      167 
      168 	if element_id_list_ptr ^= null
      169 	then call CHECK_VERSION_FB ("element_id_list", element_id_list.version, ELEMENT_ID_LIST_VERSION_1);
      170 	else call sub_err_ (error_table_$null_info_ptr, MY_NAME, ACTION_CANT_RESTART, null, 0,
      171 	     "^/Only support for a pre-allocated element_id_list is implemented.");
      172 
      173 	id_list_ptr = null;
      174 	index_constraints_field_ids_ptr = null;
      175 	index_element_id_list_ptr = null;
      176 	interval_list_ptr = null;
      177 	primary_cursor_ptr = null;
      178 	record_constraints_field_ids_ptr = null;
      179 	record_element_id_list_ptr = null;
      180 	secondary_cursor_ptr = null;
      181 	temporary_area_ptr = null;
      182 	typed_vector_array_ptr = null;
      183 	cleanup_signalled = OFF;
      184 	search_specification_is_relative = OFF;
      185 
      186 	if relation_cursor.work_area_ptr = null
      187 	then relation_cursor.work_area_ptr = get_dm_free_area_ ();
      188 	work_area_ptr = relation_cursor.work_area_ptr;
      189 
      190 	call rlm_opening_info$get (relation_cursor.file_opening_id, relation_opening_info_ptr, i_code);
      191 	if i_code ^= 0
      192 	then call ERROR_RETURN (i_code);
      193 
      194 	call CHECK_VERSION ("relation_opening_info", relation_opening_info.version, RELATION_OPENING_INFO_VERSION_2);
      195 
      196 	relation_header_ptr = relation_opening_info.relation_header_ptr;
      197 	call CHECK_VERSION ("relation_header", relation_header.version, RELATION_HEADER_VERSION_3);
      198 
      199 	attribute_info_ptr = relation_opening_info.attribute_info_ptr;
      200 	call CHECK_VERSION ("attribute_info", attribute_info.version, ATTRIBUTE_INFO_VERSION_1);
      201 
      202 	index_attribute_map_ptr = relation_opening_info.index_attribute_map_ptr;
      203 	call CHECK_VERSION ("index_attribute_map", index_attribute_map.version, INDEX_ATTRIBUTE_MAP_VERSION_2);
      204 
      205           /* MRDS *never* *ever* sets number_of_and_groups to more than 1. */
      206 	if relation_search_specification.number_of_and_groups > 1
      207 	then do;
      208 	     call rlm_general_search$get_id (p_relation_cursor_ptr, p_specification_ptr,
      209 		p_callers_area_ptr, p_element_id_list_ptr, p_code);
      210 	     return;
      211 	end;
      212 
      213 	return;
      214 
      215      end INITIALIZE;
      216 
      217 MOVE_TYPED_VECTOR_ARRAY_TO_ELEMENT_ID_LIST: proc (
      218 
      219 	mtvateil_p_typed_vector_array_ptr, /* input: to a typed_vector_array  */
      220 	mtvateil_p_area_ptr,               /* input: to an area for allocations */
      221 	mtvateil_p_element_id_list_ptr,    /* input/output: to an element_id_list */
      222 	mtvateil_p_number_of_tuple_ids     /* output: that the typed_vector_array contained */
      223 				         );
      224 
      225 /*   This subroutine moves tuple ids from a typed_vector_array to an 
      226*     element_id_list. The element_id_list is allocated, if necessary, in the
      227*     area provided by the caller. The typed_vector_array points to
      228*     simple_typed_vectors, which in turn point to tuple ids. These structures
      229*     aren't freed after the tuple ids have been moved into the
      230*     element_id_list. Instead, the area is refreshed or thrown away later
      231*     in this program. */
      232 
      233 dcl mtvateil_area area (sys_info$max_seg_size) based (mtvateil_p_area_ptr);
      234 dcl mtvateil_loop fixed bin (35);
      235 dcl mtvateil_p_area_ptr ptr parameter;
      236 dcl mtvateil_p_element_id_list_ptr ptr parameter;
      237 dcl mtvateil_p_number_of_tuple_ids fixed bin (35) parameter;
      238 dcl mtvateil_p_typed_vector_array_ptr ptr parameter;
      239 dcl mtvateil_tuple_id bit (36) aligned based;
      240 
      241 	if mtvateil_p_typed_vector_array_ptr = null
      242 	then return;
      243 
      244 	call CHECK_VERSION_FB ("typed_vector_array", 
      245 	     mtvateil_p_typed_vector_array_ptr -> typed_vector_array.version, 
      246 	     TYPED_VECTOR_ARRAY_VERSION_2);
      247 	mtvateil_p_number_of_tuple_ids = mtvateil_p_typed_vector_array_ptr 
      248 	     -> typed_vector_array.number_of_vectors;
      249 
      250 	if mtvateil_p_element_id_list_ptr = null
      251 	then do;
      252 	     eil_number_of_elements = mtvateil_p_number_of_tuple_ids;
      253 	     allocate element_id_list in (mtvateil_area) set (mtvateil_p_element_id_list_ptr);
      254 	     mtvateil_p_element_id_list_ptr -> element_id_list.version = ELEMENT_ID_LIST_VERSION_1;
      255 	end;
      256 	else mtvateil_p_element_id_list_ptr -> element_id_list.number_of_elements
      257 	     = mtvateil_p_number_of_tuple_ids;
      258 
      259 	do mtvateil_loop = 1 to mtvateil_p_number_of_tuple_ids;
      260 	     mtvateil_p_element_id_list_ptr -> element_id_list.id (mtvateil_loop)
      261 		= mtvateil_p_typed_vector_array_ptr -> typed_vector_array
      262 		.vector_slot (mtvateil_loop) -> simple_typed_vector.value_ptr (1) -> mtvateil_tuple_id;
      263 	end;
      264 
      265 	return;
      266 
      267      end MOVE_TYPED_VECTOR_ARRAY_TO_ELEMENT_ID_LIST;
      268 
      269 SEARCH_INDEX_AND_RECORD_COLLECTIONS: proc (
      270 
      271 	siarc_p_number_of_tuples_found   /* output: from the search */
      272 				  );
      273 
      274 /*   This subroutine implements case 1. The caller has requested that N tuple 
      275*     ids be retrieved, and the index and records must be searched in order to
      276*     satisfy the search constraints. For this example we will use 1,000 for N
      277*     (the default value of mrds_data_$max_tids_returned_per_call). This
      278*     subroutine first retrieves 1000 tuple ids via index_manager_. It then
      279*     uses record_manager_ to search these 1000 tuples to determine if they
      280*     satisfy the remaining constraints. Let's say that 50 tuples do. It will
      281*     then change the search specification to be relative, and will go back to
      282*     the index_manager_ to get 950 tuple ids. These 950 will be passed to
      283*     record_manager_, etc., etc. This looping between the index_manager_ and
      284*     record_manager_ will continue until all of the keys in the index have
      285*     been examined, or, 1000 tuple ids that match the constraints have been
      286*     retrieved. */
      287 
      288 dcl siarc_another_pass_is_required bit (1) aligned;
      289 dcl siarc_code fixed bin (35);
      290 dcl siarc_field_id fixed bin;
      291 dcl siarc_number_of_tuples_remaining_after_record_search fixed bin;
      292 dcl siarc_p_number_of_tuples_found fixed bin (35) parameter;
      293 
      294 	call MAKE_CONSTRAINT_LISTS_FOR_INDEX_AND_RECORD_COLLECTIONS;
      295 	siarc_p_number_of_tuples_found = 0;
      296 	siarc_another_pass_is_required = ON;
      297 	element_id_list.number_of_elements = 0;
      298 
      299 	do while (siarc_another_pass_is_required);
      300 	     search_specification.range.size
      301 		= number_of_tuples_to_retrieve - siarc_p_number_of_tuples_found;
      302 	     call GET_TUPLE_IDS_FROM_INDEX_COLLECTION;
      303 	     if index_element_id_list_ptr ^= null
      304 	     then call SEARCH_THESE_RECORDS_FOR_MATCHES;
      305 	     else siarc_number_of_tuples_remaining_after_record_search = 0;
      306 	     siarc_p_number_of_tuples_found = siarc_p_number_of_tuples_found
      307 		+ siarc_number_of_tuples_remaining_after_record_search;
      308 	     search_specification.head.type = RELATIVE_SEARCH_SPECIFICATION_TYPE;
      309 	     if siarc_another_pass_is_required
      310 	     then if siarc_p_number_of_tuples_found >= number_of_tuples_to_retrieve
      311 		then siarc_another_pass_is_required = OFF;
      312 	          else do;
      313 		     call define_area_ (area_infop, siarc_code);
      314 		     if siarc_code ^= 0
      315 		     then call ERROR_RETURN (siarc_code);
      316 		end;
      317 	     else;
      318 	end; 
      319 
      320 	return;
      321 
      322 GET_TUPLE_IDS_FROM_INDEX_COLLECTION: proc;
      323 
      324 /*  This subroutine gets tuple ids from the index_manager_. Any
      325*    element_id_list that is left over from the previous call is freed,
      326*    and then the constraints for this index search are moved into the
      327*    search_specification structure. The index_manager_ is then called and
      328*    returns a typed_vector_array that eventually points to the tuple ids that
      329*    satisfy the constraints of the search. These tuple ids are moved to the
      330*    element_id_list pointed to by index_element_id_list_ptr, and this 
      331*    element_id_list will later be input to the record_manager_'s search. */
      332 
      333 dcl gtific_code fixed bin (35);
      334 dcl gtific_loop fixed bin;
      335 
      336 	index_element_id_list_ptr = null;
      337 	typed_vector_array_ptr = null;
      338 	interval_list_ptr = null;
      339 
      340 	do gtific_loop = 1 to number_of_index_and_record_constraints;
      341 	     search_specification.and_group (1).constraint (gtific_loop).field_id
      342 		= index_constraints_field_ids (gtific_loop);
      343 	end;
      344 
      345 	call index_manager_$get_key (search_specification_ptr, id_list_ptr,
      346 	     temporary_area_ptr, primary_cursor_ptr, typed_vector_array_ptr,
      347 	     interval_list_ptr, gtific_code);
      348 	if gtific_code ^= 0 & gtific_code ^= dm_error_$key_not_found
      349 	then call ERROR_RETURN (gtific_code);
      350 
      351 	if gtific_code = dm_error_$key_not_found
      352 	then siarc_another_pass_is_required = OFF;
      353 	else if typed_vector_array.number_of_vectors < search_specification.range.size
      354 	     then siarc_another_pass_is_required = OFF;
      355 
      356 	call MOVE_TYPED_VECTOR_ARRAY_TO_ELEMENT_ID_LIST (typed_vector_array_ptr,
      357 	     temporary_area_ptr, index_element_id_list_ptr, (0));
      358 
      359 	return;
      360 
      361      end GET_TUPLE_IDS_FROM_INDEX_COLLECTION;
      362 
      363 MAKE_CONSTRAINT_LISTS_FOR_INDEX_AND_RECORD_COLLECTIONS: proc;
      364 
      365 /*   This subroutine makes a constraint list for the index_manager_ and a 
      366*     constraint list for the record_manager_. It makes them from the
      367*     constraints present in the relation_search_specification that is passed in
      368*     by the caller. The constraints will identify attributes by their position
      369*     in the relation. The record_manager_ and index_manager_ will use any
      370*     constraints whose value is greater than zero, so an attribute that isn't
      371*     present in the index or record collection needs to be set to zero by
      372*     this subroutine, so that the index_manager_ or record_manager_ will
      373*     ignore it. Also, the index_manager_ wants an index into the 
      374*     index_attribute_map instead of the attributes position within the 
      375*     relation, so this adjustment must also be done.
      376*
      377*     An example best illustrates this. Suppose that attribute number 6 is
      378*     indexed for this example. The transformation could look something like:
      379*
      380*         ON INPUT             FOR THE INDEX           FOR THE RECORD
      381*     constraint (1) = 5     constraint (1) = 0       constraint (1) = 5
      382*     constraint (2) = 2     constraint (2) = 0       constraint (2) = 2
      383*     constraint (3) = 6     constraint (3) = 1       constraint (3) = 0
      384*     constraint (4) = 5     constraint (4) = 0       constraint (4) = 5
      385*     constraint (5) = 3     constraint (5) = 0       constraint (5) = 3 */
      386 
      387 dcl mclfiarc_inner_loop fixed bin;
      388 dcl mclfiarc_loop fixed bin;
      389 
      390 	number_of_index_and_record_constraints = relation_search_specification.and_group (1).number_of_constraints;
      391 	allocate index_constraints_field_ids in (work_area) set (index_constraints_field_ids_ptr);
      392 	allocate record_constraints_field_ids in (work_area) set (record_constraints_field_ids_ptr);
      393 	index_constraints_field_ids (*) = 0;
      394 	record_constraints_field_ids (*) = 0;
      395 	
      396 	do mclfiarc_loop = 1 to number_of_index_and_record_constraints;
      397 	     siarc_field_id = relation_search_specification.and_group (1)
      398 		.constraint (mclfiarc_loop).field_id;
      399 	     do mclfiarc_inner_loop = 1 to index_attribute_map.index (current_indexes_index).number_of_attributes
      400 		while (siarc_field_id ^= index_attribute_map.index (current_indexes_index)
      401 		.attribute_id (mclfiarc_inner_loop));
      402 	     end;
      403 	     if mclfiarc_inner_loop > index_attribute_map.index (current_indexes_index).number_of_attributes
      404 	     then record_constraints_field_ids (mclfiarc_loop) = siarc_field_id;
      405 	     else index_constraints_field_ids (mclfiarc_loop) = mclfiarc_inner_loop;
      406 	end;
      407 
      408 	return;
      409 
      410      end MAKE_CONSTRAINT_LISTS_FOR_INDEX_AND_RECORD_COLLECTIONS;
      411 
      412 SEARCH_THESE_RECORDS_FOR_MATCHES: proc;
      413 
      414 /*   This subroutine takes an element_id_list as input that identifies the 
      415*     tuples selected by the index search, and gets the record_manager_ to
      416*     search these tuples applying the additional constraints. The tuples that
      417*     satisfy these additional constraints will be returned to the caller. These
      418*     tuples have their ids returned by record_manager_ in the element_id_list
      419*     pointed to by record_element_id_list_ptr. These tuple ids are then moved
      420*     into the caller's element_id_list. */
      421 
      422 dcl strfm_code fixed bin (35);
      423 dcl strfm_loop fixed bin;
      424 
      425 	record_element_id_list_ptr = null;
      426 
      427 	do strfm_loop = 1 to number_of_index_and_record_constraints;
      428 	     search_specification.and_group (1).constraint (strfm_loop).field_id
      429 		= record_constraints_field_ids (strfm_loop);
      430 	end;
      431 
      432 	call record_manager_$get_record_ids_by_interval (index_element_id_list_ptr,
      433 	     search_specification_ptr, interval_list_ptr, temporary_area_ptr,
      434 	     secondary_cursor_ptr, record_element_id_list_ptr, strfm_code);
      435 	if strfm_code ^= dm_error_$record_not_found & strfm_code ^= 0
      436 	then call ERROR_RETURN (strfm_code);
      437 
      438 	if strfm_code = 0
      439 	then do;
      440 	     siarc_number_of_tuples_remaining_after_record_search
      441 		= record_element_id_list_ptr -> element_id_list.number_of_elements;
      442 	     do strfm_loop = 1 to siarc_number_of_tuples_remaining_after_record_search;
      443 		element_id_list.number_of_elements = element_id_list.number_of_elements + 1;
      444 		element_id_list.id (element_id_list.number_of_elements)
      445 		     = record_element_id_list_ptr -> element_id_list.id (strfm_loop);
      446 	     end;
      447 	end;
      448 	else siarc_number_of_tuples_remaining_after_record_search = 0;
      449 
      450 	return;
      451 
      452      end SEARCH_THESE_RECORDS_FOR_MATCHES;
      453 
      454      end SEARCH_INDEX_AND_RECORD_COLLECTIONS;
      455 
      456 SEARCH_INDEX_COLLECTION: proc (
      457 
      458 	sic_p_number_of_tuples_found  /* output: from the index search */
      459 			);
      460 
      461 /*   This subroutine searches an index via the index_manager_ and returns the
      462*     tuple ids of tuples that satisfied the search constraints. The constraints
      463*     are moved from the caller-supplied relation_search_specification into the
      464*     search_specification structure, and then the attribute ids (the position
      465*     of the attribute within the relation) are transformed into indexes into 
      466*     the index_attribute_map. The index_manager_ is then called, and the
      467*     returned tuple ids are moved from the typed_vector_array to the caller's
      468*     element_id_list. */
      469 
      470 dcl sic_attribute_id fixed bin;
      471 dcl sic_code fixed bin (35);
      472 dcl sic_inner_loop fixed bin;
      473 dcl sic_loop fixed bin;
      474 dcl sic_p_number_of_tuples_found fixed bin (35) parameter;
      475 
      476 	do sic_loop = 1 to relation_search_specification.and_group (1).number_of_constraints;
      477 	     sic_attribute_id = relation_search_specification.and_group (1).constraint (sic_loop).field_id;
      478 	     do sic_inner_loop = 1 to index_attribute_map.index (current_indexes_index).number_of_attributes
      479 		while (index_attribute_map.index (current_indexes_index)
      480 		.attribute_id (sic_inner_loop) ^= sic_attribute_id);
      481 	     end;
      482 	     if sic_inner_loop > index_attribute_map.index (current_indexes_index).number_of_attributes
      483 	     then call sub_err_ (dm_error_$unexpected_search_case, MY_NAME, ACTION_CANT_RESTART, null, 0,
      484 		"^/Attribute #^d wasn't found in the index_attribute_map.", sic_attribute_id);
      485 	     search_specification.and_group (1).constraint (sic_loop).field_id = sic_inner_loop;
      486 	end;
      487 
      488 	call index_manager_$get_key (search_specification_ptr, id_list_ptr,
      489 	     temporary_area_ptr, primary_cursor_ptr, typed_vector_array_ptr,
      490 	     interval_list_ptr, sic_code);
      491 	if sic_code = 0
      492 	then call MOVE_TYPED_VECTOR_ARRAY_TO_ELEMENT_ID_LIST (
      493 	     typed_vector_array_ptr, callers_area_ptr, element_id_list_ptr, sic_p_number_of_tuples_found);
      494 	else if sic_code = dm_error_$key_not_found
      495 	     then sic_p_number_of_tuples_found = 0;
      496 	     else call ERROR_RETURN (sic_code);
      497 
      498 	return;
      499 
      500      end SEARCH_INDEX_COLLECTION;
      501 
      502 SEARCH_RECORD_COLLECTION: proc (
      503 
      504 	src_p_number_of_tuples_found /* output: from the record search */
      505 			 );
      506 
      507 /*   This subroutine searches a relation via the record_manager_ and returns
      508*     the tuple ids of tuples that satisified the search constraints. The tuple
      509*     ids are moved into the caller-supplied element_id_list by the
      510*     record_manager_. */
      511 
      512 dcl src_code fixed bin (35);
      513 dcl src_p_number_of_tuples_found fixed bin (35) parameter;
      514 
      515 	call record_manager_$get_record_ids_by_spec (search_specification_ptr,
      516 	     work_area_ptr, primary_cursor_ptr, element_id_list_ptr, src_code);
      517 
      518 	if src_code = 0
      519 	then src_p_number_of_tuples_found = element_id_list_ptr -> element_id_list.number_of_elements;
      520 	else if src_code = dm_error_$record_not_found
      521 	     then src_p_number_of_tuples_found = 0;
      522 	     else call ERROR_RETURN (src_code);
      523 
      524 	return;
      525 
      526      end SEARCH_RECORD_COLLECTION;
      527 
      528 SETUP_REQUIRED_CURSORS_AND_AREA: proc (
      529 
      530 	srcaa_p_primary_cursor_ptr,      /* output: for index_manager_ or record_manager_ */
      531 	srcaa_p_secondary_cursor_ptr,    /* output: for record_manager_ or null */
      532 	srcaa_p_area_ptr                 /* output: to an area or null */
      533 		         );
      534 
      535 /*   This subroutine sets up the required cursors and area. If it is case 1 
      536*     then the primary cursor will be for the index and the secondary cursor 
      537*     will be for the records. If it is case 2 the primary cursor will be
      538*     for the index and the secondary cursor will be null. If it is case 3
      539*     the primary cursor will be for the records and the secondary cursor
      540*     will be null. If the index has to be searched then a temporary area
      541*     will be acquired so that the typed_vector_array, simple_typed_vectors,
      542*     etc. don't have to be freed. Instead the area will be refreshed. */
      543 
      544 dcl srcaa_code fixed bin (35);
      545 dcl srcaa_p_area_ptr ptr;
      546 dcl srcaa_p_primary_cursor_ptr ptr parameter;
      547 dcl srcaa_p_secondary_cursor_ptr ptr parameter;
      548 
      549 	if ^search_specification_is_relative
      550 	then do;
      551 	     if search_the_index
      552 	     then call index_manager_$create_cursor (relation_cursor.file_opening_id,
      553 		primary_collection_id, relation_cursor.work_area_ptr,
      554 		srcaa_p_primary_cursor_ptr, srcaa_code);
      555 	     else call record_manager_$create_cursor (relation_cursor.file_opening_id,
      556 		primary_collection_id, relation_cursor.work_area_ptr,
      557 		srcaa_p_primary_cursor_ptr, srcaa_code);
      558 	     if srcaa_code ^= 0
      559 	     then call ERROR_RETURN (srcaa_code);
      560 	end;
      561 	else srcaa_p_primary_cursor_ptr = relation_cursor.current.cursor_ptr;
      562 
      563 	if search_the_index & search_the_records
      564 	then do;
      565 	     call record_manager_$create_cursor (
      566 		relation_cursor.file_opening_id, secondary_collection_id,
      567 		relation_cursor.work_area_ptr, srcaa_p_secondary_cursor_ptr, srcaa_code);
      568 	     if srcaa_code ^= 0
      569 	     then call ERROR_RETURN (srcaa_code);
      570 	end;
      571 	else srcaa_p_secondary_cursor_ptr = null;
      572 
      573 	if search_the_index
      574 	then do;
      575 	     call get_temp_segment_ (MY_NAME, srcaa_p_area_ptr, srcaa_code);
      576 	     if srcaa_code ^= 0
      577 	     then call ERROR_RETURN (srcaa_code);
      578 	     area_infop = addr (automatic_area_info);
      579 	     unspec (area_info) = OFF;
      580 	     area_info.version = area_info_version_1;
      581 	     unspec (area_info.control) = OFF;
      582 	     area_info.control.extend = ON;
      583 	     area_info.owner = MY_NAME;
      584 	     area_info.size = sys_info$max_seg_size;
      585 	     area_info.areap = srcaa_p_area_ptr;
      586 	     call define_area_ (area_infop, srcaa_code);
      587 	     if srcaa_code ^= 0
      588 	     then call ERROR_RETURN (srcaa_code);
      589 	end;
      590 	else srcaa_p_area_ptr = null;
      591 
      592 	relation_cursor.flags.current_state_is_consistent = OFF;
      593 
      594 	return;
      595 
      596      end SETUP_REQUIRED_CURSORS_AND_AREA;
      597 
      598 SETUP_SEARCH_SPECIFICATION: proc (
      599 
      600 	sss_p_there_is_an_and_group,   /* output: if number_of_and_groups = 1*/
      601 	sss_p_primary_collection_id,   /* output: for the index or record collection */
      602 	sss_p_secondary_collection_id, /* output: for the record collection when primary is for the index collection */
      603 	sss_p_current_indexes_index,   /* output: index of our current index, or -1 if there isn't one */
      604 	sss_p_search_the_index,        /* output: on if we have to search the index collection */
      605 	sss_p_search_the_records,      /* output: on if we have to search the record collection */
      606 	sss_p_search_specification_is_relative,
      607                                          /* output: on if this search is a continuation of a previous search */
      608 	sss_p_id_list_ptr              /* output: to an id_list if we have to search the index collection */
      609 			   );
      610 
      611 /*   This subroutine takes a relation_search_specification as input and
      612*     creates a search_specification that will later be used by the 
      613*     index_manager_ and/or the record_manager_. The search_specification
      614*     is the internal version of the relation_search_specification. Additional
      615*     comments are provided in-line in the code below. */
      616 
      617 dcl sss_current_attribute fixed bin;
      618 dcl sss_current_constraint fixed bin;
      619 dcl sss_loop fixed bin;
      620 dcl sss_p_current_indexes_index fixed bin parameter;
      621 dcl sss_p_id_list_ptr ptr parameter;
      622 dcl sss_p_primary_collection_id bit (36) aligned parameter;
      623 dcl sss_p_search_specification_is_relative bit (1) aligned parameter;
      624 dcl sss_p_search_the_index bit (1) aligned parameter;
      625 dcl sss_p_search_the_records bit (1) aligned parameter;
      626 dcl sss_p_secondary_collection_id bit (36) aligned parameter;
      627 dcl sss_p_there_is_an_and_group bit (1) aligned parameter;
      628 
      629 	if relation_search_specification.head.type = ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
      630 	then call SETUP_ABSOLUTE_SEARCH_SPEC;
      631 	else if relation_search_specification.head.type = RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
      632 	     then call SETUP_RELATIVE_SEARCH_SPEC;
      633 	     else call sub_err_ (dm_error_$unsup_search_spec_head_type,
      634 		MY_NAME, ACTION_CANT_RESTART, null, 0,
      635 		"^/The type of specification supplied (^d) is not supported.",
      636 		relation_search_specification.head.type);
      637 
      638           /* size is not supposed to be used for ALL_RANGE_TYPE */
      639 
      640 	if search_specification.range.type ^= ALL_RANGE_TYPE
      641 	then number_of_tuples_to_retrieve = search_specification.range.size;
      642 	else number_of_tuples_to_retrieve = MAXIMUM_REASONABLE_VALUE;
      643 	element_id_list.number_of_elements = number_of_tuples_to_retrieve;
      644 
      645 	sss_p_there_is_an_and_group = (search_specification.number_of_and_groups = 1);
      646 
      647           /* Move each constraint from relation_search_specification to search_specification. */
      648 
      649 	if sss_p_there_is_an_and_group
      650 	then do sss_loop = 1 to relation_search_specification.and_group (1).number_of_constraints;
      651 	     search_specification.and_group (1).number_of_constraints = sss_loop;
      652 	     search_specification.and_group (1).constraint (sss_loop)
      653 		= relation_search_specification.and_group (1).constraint (sss_loop);
      654 	end;
      655 
      656 	/* If the search is a continuation get the primary collection id from the relation_cursor. Otherwise */
      657           /* set the primary collection id to the index or record collection id. */
      658 
      659 	if sss_p_search_specification_is_relative
      660 	then sss_p_primary_collection_id = relation_cursor.current.collection_id;
      661 	else if sss_p_there_is_an_and_group
      662 	     then if relation_search_specification.and_group (1).flags.collection_id_supplied
      663 	          then sss_p_primary_collection_id = relation_search_specification.and_group (1).search_collection_id;
      664 	          else sss_p_primary_collection_id = relation_header.record_collection_id;
      665 	     else sss_p_primary_collection_id = relation_header.record_collection_id;
      666 
      667           /* If the primary collection id is for the index then look up the index into the index_attribute_map. */
      668 
      669 	if sss_p_primary_collection_id = relation_header.record_collection_id
      670 	then do;
      671 	     sss_p_current_indexes_index = -1;
      672 	     sss_p_search_the_index = OFF;
      673 	end;
      674 	else do;
      675 	     do sss_p_current_indexes_index = 1 to hbound (index_attribute_map.index, 1)
      676 		while (index_attribute_map.index (sss_p_current_indexes_index).collection_id 
      677 		^= sss_p_primary_collection_id);
      678 	     end;
      679 	     if sss_p_current_indexes_index > hbound (index_attribute_map.index, 1)
      680 	     then call ERROR_RETURN (dm_error_$index_not_in_relation);
      681 	     sss_p_search_the_index = ON;
      682 	end;
      683 
      684           /* If we aren't going to do an index search then a record search is necessary. */
      685           /* A record search is also necessary if all of the fields constrained aren't present in the index. */
      686 
      687 	if ^sss_p_search_the_index
      688 	then sss_p_search_the_records = ON;
      689 	else if sss_p_search_specification_is_relative
      690 	     then sss_p_search_the_records = relation_cursor.current.flags.search_index_and_record_collection;
      691 	     else do;
      692 		sss_p_search_the_records = OFF;
      693 		do sss_current_constraint = 1 to search_specification.and_group (1).number_of_constraints
      694 		     while (^sss_p_search_the_records);
      695 		     do sss_current_attribute = 1 to 
      696 			index_attribute_map.index (sss_p_current_indexes_index).number_of_attributes
      697 			while (search_specification.and_group (1).constraint (sss_current_constraint).field_id
      698 			^= index_attribute_map.index (sss_p_current_indexes_index)
      699 			.attribute_id (sss_current_attribute));
      700 		     end;
      701 		     if sss_current_attribute
      702 		     > index_attribute_map.index (sss_p_current_indexes_index).number_of_attributes
      703 		     then sss_p_search_the_records = ON;
      704 		end;
      705 	     end;
      706 
      707           /* Set the secondary collection id to the record collection or nothing. */
      708 
      709 	if sss_p_search_the_index & sss_p_search_the_records
      710 	then sss_p_secondary_collection_id = relation_header.record_collection_id;
      711 	else sss_p_secondary_collection_id = OFF;
      712 
      713           /*  If we're going to search the index then set the id_list to point to the tuple identifier. */
      714 
      715 	if sss_p_search_the_index
      716 	then do;
      717 	     il_number_of_ids = 1;
      718 	     allocate id_list in (work_area) set (sss_p_id_list_ptr);
      719 	     sss_p_id_list_ptr -> id_list.version = ID_LIST_VERSION_1;
      720 	     sss_p_id_list_ptr -> id_list.id (1) = index_attribute_map.index
      721 		(sss_p_current_indexes_index).number_of_attributes + 1;
      722 	end;
      723 
      724 	return;
      725 
      726 SETUP_ABSOLUTE_SEARCH_SPEC: proc;
      727 
      728 /*   This subroutine is called the first time through a search. It initializes
      729*     relation_cursor.current and allocates/initializes the search_specification
      730*     structure used by the index_manager_ and record_manager_. */
      731 
      732 	unspec (relation_cursor.flags) = OFF;
      733 	unspec (relation_cursor.current) = OFF;
      734 	relation_cursor.current.specification_ptr = null;
      735 	relation_cursor.current.cursor_ptr = null;
      736 
      737 	ss_maximum_number_of_constraints = relation_search_specification.maximum_number_of_constraints;
      738 	ss_number_of_and_groups = max (0, relation_search_specification.number_of_and_groups);
      739 	allocate search_specification in (work_area) set (search_specification_ptr);
      740 
      741 	search_specification.head = relation_search_specification.head;
      742 	search_specification.head.type = ABSOLUTE_SEARCH_SPECIFICATION_TYPE;
      743 	search_specification.range.type = relation_search_specification.range.type;
      744 	search_specification.range.size = relation_search_specification.range.size;
      745 
      746 	return;
      747 
      748      end SETUP_ABSOLUTE_SEARCH_SPEC;
      749 
      750 SETUP_RELATIVE_SEARCH_SPEC: proc;
      751 
      752 /*   This subroutine is called the second thru Nth phase of the search. It
      753*     mostly does consistency checks. */
      754 
      755 	sss_p_search_specification_is_relative = ON;
      756 
      757 	if ^relation_cursor.flags.current_state_is_consistent
      758 	| relation_cursor.current.cursor_ptr = null
      759 	then call sub_err_ (dm_error_$bad_rel_cursor_pos, MY_NAME,
      760 	     ACTION_CANT_RESTART, null, 0,
      761 	     "^/The relation cursor does not completely describe a current position.");
      762 
      763 	if relation_cursor.current.specification_ptr = null
      764 	then call sub_err_ (dm_error_$rel_cursor_spec_mismatch, MY_NAME,
      765 	     ACTION_CANT_RESTART, null, 0,
      766 	     "^/Expected a search specification; received a null specification.");
      767 
      768 	search_specification_ptr = relation_cursor.current.specification_ptr;
      769 	search_specification.head.type =      @                        ˆ]37Û	Íâ~2r        h  r   Ò   ¶   ¶         @                                                                                                   = L          SwX‘                                                   „H      *  ™ÿ          &   H   ‚               &                   Ä                               z       Ú                                                       ø                        ˆ]37 Ò    &ˆ]3MGoÁW    z Ä ¶  a    Ä     r     cp6_issues.forum                    ˆ]3MRyÃ    àý°„&               ¸  ˜ ˜ ¶  a   â~2r        ˆ]37              *@  À       ˆ]3M                 Multics                             ˆ]37          *@  À       ˆ]3n                 Mabey                               ˆ]37   z   r 	    cp6i.forum                          ˆ]3M   r  &ˆ]3nGoÁY    Ú ø ¶  a    ø     Ò     cp6_issues_log.forum                ˆ]3nRyÃ    ÂŸzŒB               ¸  ® ® ¶  a   â~2r        ˆ]37       Ú   Ò 9    cp6il.forum                         ˆ]3n          m@  À       ˆ]3n                  SysDaemon                           ˆ]37               Ring_1_Repair                       ˆ]37                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         static;
      859 dcl dm_error_$index_not_in_relation fixed bin(35) ext static;
      860 dcl dm_error_$key_not_found fixed bin(35) ext static;
      861 dcl dm_error_$record_not_found fixed bin(35) ext static;
      862 dcl dm_error_$rel_cursor_spec_mismatch fixed bin(35) ext static;
      863 dcl dm_error_$tuple_not_found fixed bin(35) ext static;
      864 dcl dm_error_$unexpected_search_case fixed bin(35) ext static;
      865 dcl dm_error_$unsup_search_spec_head_type fixed bin(35) ext static;
      866 
      867 dcl error_table_$null_info_ptr fixed bin(35) ext static;
      868 dcl error_table_$unimplemented_version fixed bin(35) ext static;
      869 
      870 dcl get_dm_free_area_ entry() returns(ptr);
      871 dcl get_temp_segment_ entry (char(*), ptr, fixed bin(35));
      872 
      873 dcl hbound builtin;
      874 
      875 dcl index_constraints_field_ids (number_of_index_and_record_constraints) fixed bin based (index_constraints_field_ids_ptr);
      876 dcl index_constraints_field_ids_ptr ptr;
      877 dcl index_element_id_list_ptr ptr;
      878 
      879 dcl max builtin;
      880 
      881 dcl null builtin;
      882 dcl number_of_index_and_record_constraints fixed bin;
      883 dcl number_of_tuples_found fixed bin (35);
      884 dcl number_of_tuples_to_retrieve fixed bin (35);
      885 
      886 dcl primary_collection_id bit (36) aligned;
      887 dcl primary_cursor_ptr ptr;
      888 
      889 dcl record_constraints_field_ids (number_of_index_and_record_constraints) fixed bin based (record_constraints_field_ids_ptr);
      890 dcl record_constraints_field_ids_ptr ptr;
      891 dcl record_element_id_list_ptr ptr;
      892 dcl release_temp_segment_ entry (char(*), ptr, fixed bin(35));
      893 dcl rlm_general_search$get_id entry (ptr, ptr, ptr, ptr, fixed bin(35));
      894 dcl rlm_opening_info$get entry (bit(36) aligned, ptr, fixed bin(35));
      895 
      896 dcl search_the_index bit (1) aligned;
      897 dcl search_the_records bit (1) aligned;
      898 dcl search_specification_is_relative bit (1) aligned;
      899 dcl secondary_collection_id bit (36) aligned;
      900 dcl secondary_cursor_ptr ptr;
      901 dcl sub_err_ entry() options(variable);
      902 dcl sys_info$max_seg_size fixed bin(35) ext static;
      903 
      904 dcl temporary_area_ptr ptr;
      905 dcl there_is_an_and_group_supplied bit (1) aligned;
      906 
      907 dcl unspec builtin;
      908 
      909 dcl work_area area (sys_info$max_seg_size) based (work_area_ptr);
      910 dcl work_area_ptr ptr;
      911 
  1     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  1     2 
  1     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  1     4 
  1     5 dcl  area_infop ptr;
  1     6 
  1     7 dcl 1 area_info aligned based (area_infop),
  1     8     2 version fixed bin,				/* version number for this structure is 1 */
  1     9     2 control aligned like area_control,		/* control bits for the area */
  1    10     2 owner char (32) unal,				/* creator of the area */
  1    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  1    12     2 size fixed bin (18),				/* size of the area in words */
  1    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  1    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  1    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  1    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  1    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  1    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  1    19 
  1    20 dcl 1 area_control aligned based,
  1    21     2 extend bit (1) unal,				/* says area is extensible */
  1    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  1    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  1    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  1    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  1    26     2 system bit (1) unal,				/* says area is managed by system */
  1    27     2 pad bit (30) unal;
  1    28 
  1    29 /* END INCLUDE FILE area_info.incl.pl1 */
      912 
      913 
  2     1 /* BEGIN INCLUDE FILE  - dm_element_id_list.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*          The element_id_list structure contains an array of element 
  2     5*     identifiers.  These identifiers are used as tuple, record or 
  2     6*     element identifiers.  This structure is used across the relation_manager_,
  2     7*     record_manager_ and index_manager_ interfaces.  At some time the 
  2     8*     version should be changed to be char(8)aligned, when such a conversion
  2     9*     can be coordinated with the other structures used at these interfaces.
  2    10**/
  2    11 
  2    12 /* HISTORY:
  2    13*Written by Matthew Pierret, 06/06/82.
  2    14*Modified:
  2    15*12/16/82 by Roger Lackey:  Changed number_of_elements to fixed bin (35).
  2    16*            Did not change version.
  2    17*02/11/85 by Matthew Pierret:  Added DESCRIPTION, Written by.
  2    18**/
  2    19 
  2    20 /* format: style2,ind3 */
  2    21      dcl	   1 element_id_list      aligned based (element_id_list_ptr),
  2    22 	     2 version	      fixed bin (35),
  2    23 	     2 number_of_elements fixed bin (35),
  2    24 	     2 id		      (eil_number_of_elements refer (element_id_list.number_of_elements)) bit (36) aligned;
  2    25 
  2    26      dcl	   element_id_list_ptr    ptr;
  2    27      dcl	   eil_number_of_elements fixed bin (35);
  2    28      dcl	   ELEMENT_ID_LIST_VERSION_1
  2    29 			      init (1) fixed bin (35);
  2    30 
  2    31 
  2    32 /* END INCLUDE FILE  - dm_element_id_list.incl.pl1 */
      914 
      915 
  3     1 /* BEGIN INCLUDE FILE dm_range_constants.incl.pl1. */
  3     2 
  3     3 /* HISTORY:
  3     4*Written by Matthew Pierret, 05/27/83.
  3     5*Modified:
  3     6**/
  3     7 
  3     8      dcl	   (
  3     9 	   ALL_RANGE_TYPE	      init (1),
  3    10 	   LOW_RANGE_TYPE	      init (2),
  3    11 	   HIGH_RANGE_TYPE	      init (3)
  3    12 	   )		      fixed bin internal static options (constant);
  3    13 
  3    14 
  3    15 /* END INCLUDE FILE dm_range_constants.incl.pl1. */
      916 
      917 
  4     1 /* BEGIN INCLUDE FILE - dm_id_list.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION
  4     4*        The id_list structure is used to identify attributes, fields and
  4     5*   dimensions by various modules of the Data Management System.
  4     6**/
  4     7 
  4     8 /* HISTORY:
  4     9*Written by Matthew Pierret, '82.
  4    10*Modified:
  4    11*08/17/83 by Matthew Pierret: Made version constant 'internal static options
  4    12*            (constant)' and to initialize automatic variables.
  4    13**/
  4    14 
  4    15 /* format: style2,ind3 */
  4    16      dcl	   1 id_list	      aligned based (id_list_ptr),
  4    17 	     2 version	      fixed bin (35),
  4    18 	     2 number_of_ids      fixed bin (17),
  4    19 	     2 id		      (il_number_of_ids refer (id_list.number_of_ids)) fixed bin (17);
  4    20 
  4    21      dcl	   id_list_ptr	      ptr init (null);
  4    22      dcl	   il_number_of_ids	      fixed bin (17) init (-1);
  4    23      dcl	   ID_LIST_VERSION_1      fixed bin (17) init (1) internal static options (constant);
  4    24 
  4    25 /* END INCLUDE FILE - dm_id_list.incl.pl1 */
      918 
      919 
  5     1 /* BEGIN INCLUDE FILE - dm_idxmgr_entry_dcls.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*          This include file has all of the declarations for the index_manager_
  5     6*     external interface.  It is useful for programs which are making extensive
  5     7*     use of the index_manager_ to include this include file rather than
  5     8*     individually declaring each of the entries.
  5     9*     
  5    10**/
  5    11 
  5    12 /* HISTORY:
  5    13*
  5    14*Written by Lindsey Spratt, 06/25/82.
  5    15*Modified:
  5    16*07/28/82 by Lindsey Spratt: Extended the create_collection entry calling
  5    17*	  sequence to include the number_of_duplication_fields.
  5    18*08/10/82 by Matthew Pierret: Changed the create_collection entry calling 
  5    19*            sequence to return a "bit (36) aligned" collection id instead of
  5    20*            "fixed bin (17)".  Changed create_cursor calling sequence likewise.
  5    21*08/19/82 by Lindsey Spratt:  Renamed create_collection to create_index. Added
  5    22*	  the put_key_array entry.  Added the id_list_ptr to the get_key
  5    23*	  entry.  Added the create_subset_index entry.
  5    24*08/23/82 by Lindsey Spratt:  Added the position_cursor entry.
  5    25*09/27/82 by Lindsey Spratt:  Added the get_count and get_duplicate_key_count
  5    26*	  entries.
  5    27*11/09/82 by Lindsey Spratt:  Added ptr to get_key for the interval_list.
  5    28*	  Changed get_duplicate_key_count to get_key_count_array.
  5    29*05/31/83 by Matthew Pierret: Added $destroy_index and $destroy_cursor.
  5    30*05/02/84 by Lee Baldwin:  Renamed $get_count to $get_key_count_by_spec.
  5    31*10/23/84 by Lindsey L. Spratt:  Addressed auditing comments - alphabetized
  5    32*            entries, fixed $create_index to use "fixed bin (17)" instead of
  5    33*            just "fixed bin", added a description section.
  5    34**/
  5    35 
  5    36 /* format: style2,ind3 */
  5    37 
  5    38      dcl	   index_manager_$create_cursor entry (bit (36) aligned, bit (36) aligned, ptr, ptr, fixed bin (35));
  5    39      dcl	   index_manager_$create_index entry (bit (36) aligned, ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
  5    40      dcl	   index_manager_$create_subset_index entry (ptr, bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  5    41      dcl	   index_manager_$delete_key entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35));
  5    42      dcl	   index_manager_$destroy_cursor entry (ptr, fixed bin (35));
  5    43      dcl	   index_manager_$destroy_index entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  5    44      dcl	   index_manager_$get_key entry (ptr, ptr, ptr, ptr, ptr, ptr, fixed bin (35));
  5    45      dcl	   index_manager_$get_key_count_array entry (ptr, ptr, ptr, fixed bin (35));
  5    46      dcl	   index_manager_$get_key_count_by_spec entry (ptr, ptr, fixed bin (35), fixed bin (35));
  5    47      dcl	   index_manager_$position_cursor entry (ptr, ptr, ptr, fixed bin (35));
  5    48      dcl	   index_manager_$put_key entry (ptr, ptr, fixed bin (35));
  5    49      dcl	   index_manager_$put_key_array entry (ptr, ptr, fixed bin (35));
  5    50 
  5    51 /* END INCLUDE FILE - dm_idxmgr_entry_dcls.incl.pl1 */
      920 
      921 
  6     1 /* BEGIN INCLUDE FILE - dm_interval_list.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*
  6     5*          The interval_list structure is used to describe a number of
  6     6*     intervals of keys in an associated typed_vector_array.  With each
  6     7*     interval is a list of the and_groups from the search_specification used
  6     8*     to find those keys.  All of the constraints on fields which are specified
  6     9*     in the and_groups associated with an interval and are in the keys are
  6    10*     completely satisfied by the keys in the interval.
  6    11**/
  6    12 
  6    13 /* HISTORY:
  6    14*
  6    15*Written by Lindsey Spratt, 11/09/82.
  6    16*Modified:
  6    17**/
  6    18 
  6    19 /* format: style2,ind3 */
  6    20      dcl	   1 interval_list	      based (interval_list_ptr) aligned,
  6    21 	     2 version	      char (8),		/* Must be set to INTERVAL_LIST_VERSION_2. */
  6    22 	     2 number_of_intervals
  6    23 			      fixed bin (17) unal,
  6    24 	     2 pad	      bit (18) unal,
  6    25 	     2 interval	      (intl_number_of_intervals refer (interval_list.number_of_intervals)),
  6    26 	       3 low_vector_idx   fixed bin (35),	/* The first vector in the associated typed_vector_array for this interval. */
  6    27 	       3 high_vector_idx  fixed bin (35),	/* The last vector for this interval. */
  6    28 	       3 and_group_id_list_ptr
  6    29 			      ptr;		/* points to an id_list which identifies the */
  6    30 						/* and_groups in the associated search_specification */
  6    31 						/* which apply to the vectors in this interval. */
  6    32 
  6    33      dcl	   interval_list_ptr      ptr init (null);
  6    34      dcl	   INTERVAL_LIST_VERSION_2
  6    35 			      init ("IntLst 2") char (8) aligned internal static options (constant);
  6    36      dcl	   intl_number_of_intervals
  6    37 			      fixed bin init (0);
  6    38 
  6    39 /* END INCLUDE FILE dm_interval_list.incl.pl1 */
      922 
      923 
  7     1 /* BEGIN INCLUDE FILE dm_rcdmgr_entry_dcls.incl.pl1 */
  7     2 
  7     3 /* This include file contains declarations of record_manager_ entry points. */
  7     4 
  7     5 /* HISTORY:
  7     6*Written by Matthew Pierret 05/12/82.
  7     7*Modified:
  7     8*12/14/82 by Matthew Pierret: Changed $get_ids to $get_id.
  7     9*04/01/83 by Matthew Pierret: Added $get_records_and_ids and
  7    10*            $get_records_and_ids_by_interval.
  7    11*04/04/83 by Matthew Pierret: Added $destroy_collection and $destroy_cursor.
  7    12*05/24/83 by Matthew Pierret: Corrected mis-spelling of "manger" for
  7    13*            rcm_$destroy_cursor.
  7    14*06/06/83 by Matthew Pierret: Corrected rcm_$get_record_count_by_intervals -
  7    15*            added a ptr parameter. 
  7    16*06/13/83 by Matthew Pierret:  Changed rcm_$*_by_intervals to correctly be
  7    17*            rcm_$=_by_interval.
  7    18*04/12/84 by Lee Baldwin:  Renamed some of the entry points (see 
  7    19*            record_manager_.alm) and changed the declarations of
  7    20*            those that used to pass a typed_vector_type and a
  7    21*            typed_vector_array_version.
  7    22*04/26/84 by Lee Baldwin:  Changed the arg list of
  7    23*            $get_record_count_by_interval to not take a work_area_ptr.
  7    24**/
  7    25 
  7    26 /* format: style2,ind3 */
  7    27      dcl	   record_manager_$create_collection
  7    28 			      entry (bit (36) aligned, ptr, ptr, ptr, bit (36) aligned, fixed bin (35));
  7    29      dcl	   record_manager_$create_cursor
  7    30 			      entry (bit (36) aligned, bit (36) aligned, ptr, ptr, fixed bin (35));
  7    31      dcl	   record_manager_$destroy_collection
  7    32 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  7    33      dcl	   record_manager_$destroy_cursor
  7    34 			      entry (ptr, fixed bin (35));
  7    35 
  7    36      dcl	   record_manager_$get_record_by_id
  7    37 			      entry (bit (36) aligned, ptr, ptr, ptr, ptr, fixed bin (35));
  7    38      dcl	   record_manager_$get_records_by_id_list
  7    39 			      entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35));
  7    40      dcl	   record_manager_$get_records_by_spec
  7    41 			      entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35));
  7    42      dcl	   record_manager_$get_records_by_interval
  7    43 			      entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35), ptr, ptr, fixed bin (35));
  7    44      dcl	   record_manager_$get_records_and_ids_by_spec
  7    45 			      entry (ptr, ptr, ptr, ptr, ptr, ptr, fixed bin (35));
  7    46      dcl	   record_manager_$get_records_and_ids_by_interval
  7    47 			      entry (ptr, ptr, ptr, ptr, ptr, fixed bin (17), ptr, ptr, ptr, fixed bin (35));
  7    48      dcl	   record_manager_$get_record_ids_by_spec
  7    49                                     entry (ptr, ptr, ptr, ptr, fixed bin (35));
  7    50      dcl	   record_manager_$get_record_ids_by_interval
  7    51 			      entry (ptr, ptr, ptr, ptr, ptr, ptr, fixed bin (35));
  7    52      dcl	   record_manager_$get_record_count
  7    53 			      entry (ptr, ptr, fixed bin (35), fixed bin (35));
  7    54      dcl	   record_manager_$get_record_count_by_interval
  7    55 			      entry (ptr, ptr, ptr, ptr, fixed bin (35), fixed bin (35));
  7    56 
  7    57      dcl	   record_manager_$put_record_by_id
  7    58 			      entry (bit (36) aligned, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35));
  7    59 
  7    60      dcl	   record_manager_$put_records_by_id
  7    61 			      entry (bit (36) aligned, ptr, fixed bin (35), ptr, ptr, fixed bin (35));
  7    62 
  7    63      dcl	   record_manager_$delete_record_by_id
  7    64 			      entry (bit (36) aligned, ptr, fixed bin (35));
  7    65 
  7    66      dcl	   record_manager_$delete_records_by_id_list
  7    67 			      entry (ptr, ptr, fixed bin (35), fixed bin (35));
  7    68 
  7    69      dcl	   record_manager_$delete_records_by_spec
  7    70 			      entry (ptr, ptr, fixed bin (35), fixed bin (35));
  7    71 
  7    72      dcl	   record_manager_$modify_record_by_id
  7    73 			      entry (bit (36) aligned, ptr, ptr, fixed bin (35));
  7    74 
  7    75      dcl	   record_manager_$modify_records_by_id_list
  7    76 			      entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35));
  7    77 
  7    78      dcl	   record_manager_$modify_records_by_spec
  7    79 			      entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35));
  7    80 
  7    81 /* END INCLUDE FILE dm_rcdmgr_entry_dcls.incl.pl1 */
      924 
      925 
  8     1 /* BEGIN INCLUDE FILE dm_rlm_attribute_info.incl.pl1 */
  8     2 
  8     3 /* DESCRIPTION
  8     4*        
  8     5*   Relation attributes descriptor and name.  This info is kept in the header
  8     6*   collection of existing files, therefore this incl should not be changed.
  8     7**/
  8     8 
  8     9 /* HISTORY:
  8    10*Written by Matthew Pierret, 02/25/83.
  8    11*Modified:
  8    12*10/29/84 by Stanford S. Cox:  Changed to not init version.
  8    13*12/14/84 by Stanford S. Cox:  Backed out previous structure alignment changes
  8    14*   which were incompatible with existing DM files.        
  8    15**/
  8    16 
  8    17 /* format: style2,ind3 */
  8    18      dcl	   1 attribute_info	      aligned based (attribute_info_ptr),
  8    19 	     2 version	      char (8),
  8    20 	     2 number_of_attributes
  8    21 			      fixed bin (17) unal,
  8    22 	     2 maximum_attribute_name_length
  8    23 			      fixed bin (17) unal,
  8    24 	     2 attribute	      (ai_number_of_attributes refer (attribute_info.number_of_attributes)),
  8    25 	       3 descriptor	      bit (36) aligned,
  8    26 	       3 name	      char (ai_maximum_attribute_name_length
  8    27 			      refer (attribute_info.maximum_attribute_name_length)) varying;
  8    28 
  8    29      dcl	   attribute_info_ptr     ptr init (null);
  8    30      dcl	   ai_maximum_attribute_name_length
  8    31 			      fixed bin (17);
  8    32      dcl	   ai_number_of_attributes
  8    33 			      fixed bin (17);
  8    34      dcl	   ATTRIBUTE_INFO_VERSION_1
  8    35 			      init ("attrinf1") char (8) aligned internal static options (constant);
  8    36 
  8    37 /* END INCLUDE FILE dm_rlm_attribute_info.incl.pl1 */
  8    38 
      926 
      927 
  9     1 /* BEGIN INCLUDE FILE dm_rlm_cursor.incl.pl1 */
  9     2 
  9     3 /* HISTORY:
  9     4*
  9     5*Written by Matthew Pierret, 05/19/83. 
  9     6*Modified:
  9     7*06/24/83 by Lindsey L. Spratt:  Changed to version 2.  Added the current.flags
  9     8*            structure, to add the search_index_and_record_collection flag.
  9     9*            This flag is only meaningful when doing a relative search.  It is
  9    10*            used by rlm_general_search to know what state the
  9    11*            internal_search_specification was left in (suitable for searching
  9    12*            the index or suitable for searching the records).
  9    13*10/29/84 by Stanford S. Cox:  Changed to not init version.
  9    14*02/12/85 by S. Cox:  Chg and_group_idx to fb17, current.flags.mbz to bit35.
  9    15**/
  9    16 
  9    17 /* format: style2,ind3 */
  9    18      dcl	   1 relation_cursor      aligned based (relation_cursor_ptr),
  9    19 	     2 version	      char (8),		/* version of this structure */
  9    20 	     2 work_area_ptr      ptr init (null),	/* points to area in which cursor is allocated. */
  9    21 	     2 file_opening_id    bit (36) aligned init ("0"b),
  9    22 						/* opening id of file in which relation resides */
  9    23 	     2 flags	      aligned,
  9    24 	       3 current_state_is_consistent
  9    25 			      bit (1) unal init ("0"b),
  9    26 						/* On if all values in current are insynch */
  9    27 	       3 mbz	      bit (35) unal init ("0"b),
  9    28 						/* must be zero */
  9    29 	     2 current,				/* current position in search */
  9    30 	       3 and_group_idx    fixed bin (17) aligned init (0),
  9    31 						/* in relation_search_specification */
  9    32 	       3 flags	      aligned,
  9    33 	         4 search_index_and_record_collection
  9    34 			      bit (1) unal init ("0"b),
  9    35 	         4 mbz	      bit (35) unal init ("0"b),
  9    36 	       3 collection_id    bit (36) aligned init ("0"b),
  9    37 						/* that cursor is define over */
  9    38 	       3 specification_ptr
  9    39 			      ptr init (null),	/* points to index or record specification */
  9    40 	       3 cursor_ptr	      ptr init (null);	/* points to index or record cursor */
  9    41 
  9    42      dcl	   relation_cursor_ptr    ptr init (null);
  9    43      dcl	   RELATION_CURSOR_VERSION_2
  9    44 			      init ("relcrs02") char (8) aligned internal static options (constant);
  9    45 
  9    46 /* END INCLUDE FILE dm_rlm_cursor.incl.pl1 */
      928 
      929 
 10     1 /* BEGIN INCLUDE FILE - dm_rlm_header.incl.pl1 */
 10     2 
 10     3 /* HISTORY:
 10     4*Written by Matthew Pierret, 1982.
 10     5*Modified:
 10     6*02/25/83 by Matthew Pierret: Added attribute_info_element_id, 
 10     7*            header_info_update_count, RELATION_HEADER_VERSION_2.
 10     8*05/29/84 by Matthew Pierret: Added caller_header_element_id, 
 10     9*            RELATION_HEADER_VERSION_3.
 10    10*10/29/84 by Stanford S. Cox:  Changed to not init version.
 10    11**/
 10    12 
 10    13 /* format: style2,ind3 */
 10    14 
 10    15      dcl	   1 relation_header      aligned based (relation_header_ptr),
 10    16 	     2 version	      char (8),
 10    17 	     2 header_info_update_count
 10    18 			      fixed bin (35) aligned init (0),
 10    19 	     2 record_collection_id
 10    20 			      bit (36) aligned init ("0"b),
 10    21 	     2 cluster_index_id   bit (36) aligned init ("0"b),
 10    22 	     2 attribute_info_element_id
 10    23 			      bit (36) aligned init ("0"b),
 10    24 	     2 index_attribute_map_element_id
 10    25 			      bit (36) aligned init ("0"b),
 10    26 	     2 caller_header_element_id
 10    27 			      bit (36) aligned init ("0"b);
 10    28 
 10    29      dcl	   relation_header_ptr    ptr init (null);
 10    30      dcl	   RELATION_HEADER_VERSION_3
 10    31 			      init ("RelHdr 3") char (8) aligned internal static options (constant);
 10    32 
 10    33 /* END INCLUDE FILE - dm_rlm_header.incl.pl1 */
      930 
      931 
 11     1 /* BEGIN INCLUDE FILE - dm_rlm_index_attr_map.incl.pl1 */
 11     2 
 11     3 /* DESCRIPTION
 11     4*        
 11     5*   Relation index components.  This info is kept in the header
 11     6*   collection of existing files, therefore this incl should not be changed.
 11     7**/
 11     8 
 11     9 /* HISTORY:
 11    10*Written by Matthew Pierret, 01/15/83.
 11    11*Modified:
 11    12*10/29/84 by Stanford S. Cox: Changed to not init version.
 11    13*12/14/84 by Stanford S. Cox:  Backed out previous structure alignment changes
 11    14*   which were incompatible with existing DM files.        
 11    15**/
 11    16 
 11    17 /* format: style2,ind3 */
 11    18      dcl	   1 index_attribute_map  aligned based (index_attribute_map_ptr),
 11    19 	     2 version	      char (8),
 11    20 	     2 number_of_indices  fixed bin (17) unal init (0),
 11    21 	     2 maximum_number_of_indices
 11    22 			      fixed bin (17) unal,
 11    23 	     2 maximum_number_of_attributes_per_index
 11    24 			      fixed bin (17) unal,
 11    25 	     2 mbz	      fixed bin (17) unal,
 11    26 	     2 index	      (iam_maximum_number_of_indices refer (index_attribute_map.maximum_number_of_indices)),
 11    27 	       3 collection_id    bit (36) aligned,
 11    28 	       3 style	      fixed bin (17) unal,
 11    29 	       3 number_of_duplication_fields
 11    30 			      fixed bin (17) unal,
 11    31 	       3 number_of_attributes
 11    32 			      fixed bin (17) unal,
 11    33 	       3 attribute_id     (iam_maximum_number_of_attributes_per_index
 11    34 			      refer (index_attribute_map.maximum_number_of_attributes_per_index)) fixed
 11    35 			      bin (17) unal;
 11    36 
 11    37      dcl	   index_attribute_map_ptr
 11    38 			      ptr init (null);
 11    39      dcl	   iam_maximum_number_of_indices
 11    40 			      fixed bin (17);
 11    41      dcl	   iam_maximum_number_of_attributes_per_index
 11    42 			      fixed bin (17);
 11    43      dcl	   INDEX_ATTRIBUTE_MAP_VERSION_2
 11    44 			      init ("idx_map2") char (8) aligned internal static options (constant);
 11    45      dcl	   INITIAL_NUMBER_OF_INDICES
 11    46 			      init (5) fixed bin (17);
 11    47      dcl	   UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
 11    48 			      init (0) fixed bin (17);
 11    49 
 11    50 /* END INCLUDE FILE - dm_rlm_index_attr_map.incl.pl1 */
      932 
      933 
 12     1 /* BEGIN INCLUDE FILE dm_relation_spec.incl.pl1 */
 12     2 
 12     3 /* HISTORY:
 12     4*Written by Matthew Pierret, 05/10/83.
 12     5*Modified:
 12     6**/
 12     7 
 12     8 /* format: style2,ind3 */
 12     9      dcl	   1 relation_search_specification
 12    10 			      aligned based (relation_search_specification_ptr),
 12    11 	     2 head	      like specification_head,
 12    12 	     2 maximum_number_of_constraints
 12    13 			      fixed bin (17) unal,
 12    14 	     2 number_of_and_groups
 12    15 			      fixed bin (17) unal,
 12    16 	     2 flags	      unal,
 12    17 	       3 return_unique_tuples
 12    18 			      bit (1) unal,
 12    19 	       3 mbz	      bit (35) unal,
 12    20 	     2 range,
 12    21 	       3 type	      fixed bin (17),
 12    22 	       3 size	      fixed bin (17),
 12    23 	     2 and_group	      (rss_number_of_and_groups refer (relation_search_specification.number_of_and_groups)),
 12    24 	       3 search_collection_id
 12    25 			      bit (36) aligned,
 12    26 	       3 flags	      unal,
 12    27 	         4 collection_id_supplied
 12    28 			      bit (1) unal,
 12    29 	         4 mbz	      bit (17) unal,
 12    30 	       3 number_of_constraints
 12    31 			      fixed bin (17) unal,
 12    32 	       3 constraint	      (rss_maximum_number_of_constraints
 12    33 			      refer (relation_search_specification.maximum_number_of_constraints)),
 12    34 	         4 field_id	      fixed bin (17) unal,
 12    35 	         4 operator_code  fixed bin (17) unal,
 12    36 	         4 value_field_id fixed bin (17) unal,
 12    37 	         4 mbz	      bit (18) unal,
 12    38 	         4 value_ptr      ptr;
 12    39 
 12    40 
 12    41      dcl	   1 relation_numeric_specification
 12    42 			      aligned based (relation_numeric_specification_ptr),
 12    43 	     2 head	      like specification_head,
 12    44 	     2 collection_id      bit (36) aligned,
 12    45 	     2 range_size	      fixed bin (35),
 12    46 	     2 position_number    fixed bin (17) unal,
 12    47 	     2 pad	      bit (18) unal;
 12    48 
 12    49 
 12    50      dcl	   (relation_search_specification_ptr, relation_numeric_specification_ptr)
 12    51 			      ptr init (null);
 12    52      dcl	   (rss_number_of_and_groups, rss_maximum_number_of_constraints)
 12    53 			      fixed bin (17) init (0);
 12    54 
 12    55 
 12    56 
 12    57 /* END INCLUDE FILE dm_relation_spec.incl.pl1 */
      934 
      935 
 13     1 /* BEGIN INCLUDE FILE - dm_rlm_opening_info.incl.pl1 */
 13     2 
 13     3 /* Written by Matthew Pierret, 09/08/82. 
 13     4*Modified:
 13     5*01/18/83 by Matthew Pierret:  Changed version to be char (8). Added 
 13     6*            transaction_id.
 13     7*02/25/83 by Matthew Pierret:  Changed to relation_opening_info (from
 13     8*            relation_info).
 13     9*10/29/84 by Stanford S. Cox:  Changed to not init version.
 13    10**/
 13    11 
 13    12 
 13    13 /* format: style2,ind3 */
 13    14 
 13    15      dcl	   1 relation_opening_info
 13    16 			      aligned based (relation_opening_info_ptr),
 13    17 	     2 version	      char (8),
 13    18 	     2 per_process,
 13    19 	       3 current_transaction_id
 13    20 			      bit (36) aligned init ("0"b),
 13    21 	       3 current_rollback_count
 13    22 			      fixed bin (35) init (0),
 13    23 	       3 file_opening_id  bit (36) aligned init ("0"b),
 13    24 	       3 number_of_openings
 13    25 			      fixed bin (17) aligned init (0),
 13    26 	       3 lock_advice      aligned,
 13    27 	         4 this_process   bit (2) unaligned init ("0"b),
 13    28 	         4 other_processes
 13    29 			      bit (2) unaligned init ("0"b),
 13    30 	         4 mbz1	      bit (32) unaligned init ("0"b),
 13    31 	       3 record_cursor_ptr
 13    32 			      ptr init (null),
 13    33 	       3 index_cursor_array_ptr
 13    34 			      ptr init (null),
 13    35 	     2 relation_header_ptr
 13    36 			      ptr init (null),
 13    37 	     2 attribute_info_ptr ptr init (null),
 13    38 	     2 index_attribute_map_ptr
 13    39 			      ptr init (null);
 13    40 
 13    41      dcl	   relation_opening_info_ptr
 13    42 			      ptr;
 13    43      dcl	   RELATION_OPENING_INFO_VERSION_2
 13    44 			      init ("rlmopen2") char (8) aligned internal static options (constant);
 13    45 
 13    46 
 13    47 /* END INCLUDE FILE - dm_rlm_opening_info.incl.pl1 */
      936 
      937 
 14     1 /* BEGIN INCLUDE FILE - dm_specification.incl.pl1 */
 14     2 
 14     3 /* DESCRIPTION:
 14     4*
 14     5*          The specification structure is used to identify sets items based on
 14     6*     the value of some of the contents of the items (the
 14     7*     search_specification), or based on the ordinal position (the
 14     8*     numeric_specification) of the first or last item in the desired set of
 14     9*     items in the set of all possible items.  It is used with the relation,
 14    10*     index and record managers.  The items for these three managers are
 14    11*     tuples, keys and records, respectively.  The sets of "all possible
 14    12*     items", for determination of ordinal position for these three managers
 14    13*     are: a relation, an index, and a record collection, respectively.
 14    14*     
 14    15*          The specification_head structure, in dm_specification_head.incl.pl1,
 14    16*     must be included in any program which uses this (the
 14    17*     dm_specification.incl.pl1) include file.
 14    18**/
 14    19 
 14    20 /* HISTORY:
 14    21*
 14    22*Written by Lindsey Spratt, 05/19/82.
 14    23*Modified:
 14    24*08/17/82 by Matthew Pierret:  Added all specification type constants.
 14    25*09/24/82 by Ronald Harvey: Changed version and added and_groups.
 14    26*10/22/82 by Lindsey Spratt:  Added the range_size to the numeric_specification.
 14    27*	  Changed the version to 3.
 14    28*05/11/83 by Matthew Pierret: Moved specification_head and and type constants
 14    29*            to dm_specification_head.incl.pl1. Added constraint.value_field_id.
 14    30*            Moved range type constants into dm_range_constants.incl.pl1.
 14    31*05/20/83 by Matthew Pierret: Added constraint.value_field_id for specifying
 14    32*            intra-key/record compares.
 14    33*10/02/84 by Lindsey L. Spratt:  Moved a misplaced journalization comment.
 14    34*            Added a DESCRIPTION comment.
 14    35**/
 14    36 
 14    37 /* format: style2,ind3 */
 14    38      dcl	   1 search_specification based (search_specification_ptr),
 14    39 	     2 head	      like specification_head,
 14    40 	     2 maximum_number_of_constraints
 14    41 			      fixed bin (17) unal,
 14    42 	     2 number_of_and_groups
 14    43 			      fixed bin (17) unal,
 14    44 	     2 range	      unal,
 14    45 	       3 type	      fixed bin (17),
 14    46 	       3 size	      fixed bin (17),
 14    47 	     2 and_group	      (ss_number_of_and_groups refer (search_specification.number_of_and_groups)),
 14    48 	       3 number_of_constraints
 14    49 			      fixed bin (17) unal,
 14    50 	       3 constraint	      (ss_maximum_number_of_constraints
 14    51 			      refer (search_specification.maximum_number_of_constraints)),
 14    52 	         4 field_id	      fixed bin (17) unal,
 14    53 	         4 operator_code  fixed bin (17) unal,
 14    54 	         4 value_field_id fixed bin (17) unal,
 14    55 	         4 pad	      bit (18) unal,
 14    56 	         4 value_ptr      ptr unal;
 14    57 
 14    58      dcl	   search_specification_ptr
 14    59 			      ptr;
 14    60      dcl	   (ss_number_of_and_groups, ss_maximum_number_of_constraints)
 14    61 			      fixed bin (17);
 14    62 
 14    63      dcl	   1 numeric_specification
 14    64 			      based (numeric_specification_ptr),
 14    65 	     2 head	      like specification_head,
 14    66 	     2 range_size	      fixed bin (35) aligned,
 14    67 	     2 position_number    fixed bin (17) unal,
 14    68 	     2 pad	      bit (18) unal;
 14    69 
 14    70      dcl	   numeric_specification_ptr
 14    71 			      ptr;
 14    72 
 14    73 /* END INCLUDE FILE - dm_specification.incl.pl1 */
      938 
      939 
 15     1 /* BEGIN INCLUDE FILE dm_specification_head.incl.pl1 */
 15     2 
 15     3 /* HISTORY:
 15     4*Written by Matthew Pierret, 05/11/83. (Extracted from dm_specification.incl.pl1)
 15     5*Modified:
 15     6*05/20/83 by Matthew Pierret: Changed to use version 4.
 15     7**/
 15     8 
 15     9 /* format: style2,ind3 */
 15    10      dcl	   1 specification_head   based (specification_head_ptr),
 15    11 	     2 version	      fixed bin (35),
 15    12 	     2 type	      fixed bin (17) unal,
 15    13 	     2 pad	      bit (18) unal,
 15    14 	     2 subset_specification_ptr
 15    15 			      ptr;
 15    16 
 15    17 
 15    18      dcl	   specification_head_ptr ptr;
 15    19      dcl	   SPECIFICATION_VERSION_4
 15    20 			      init (4) fixed bin (35) internal static options (constant);
 15    21 
 15    22      dcl	   (
 15    23 	   SEARCH_SPECIFICATION_TYPE
 15    24 			      init (1),
 15    25 	   ABSOLUTE_SEARCH_SPECIFICATION_TYPE
 15    26 			      init (1),
 15    27 	   NUMERIC_SPECIFICATION_TYPE
 15    28 			      init (2),
 15    29 	   ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
 15    30 			      init (2),
 15    31 	   RELATIVE_SEARCH_SPECIFICATION_TYPE
 15    32 			      init (3),
 15    33 	   RELATIVE_NUMERIC_SPECIFICATION_TYPE
 15    34 			      init (4),
 15    35 	   ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
 15    36 			      init (5),
 15    37 	   RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
 15    38 			      init (6),
 15    39 	   ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
 15    40 			      init (7),
 15    41 	   RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
 15    42 			      init (8)
 15    43 	   )		      fixed bin (17) internal static options (constant);
 15    44 
 15    45 
 15    46 /* END INCLUDE FILE dm_specification_head.incl.pl1 */
      940 
      941 
 16     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
 16     2 /* format: style3 */
 16     3 
 16     4 /* These constants are to be used for the flags argument of sub_err_ */
 16     5 /* They are just "string (condition_info_header.action_flags)" */
 16     6 
 16     7 declare	(
 16     8 	ACTION_CAN_RESTART	init (""b),
 16     9 	ACTION_CANT_RESTART init ("1"b),
 16    10 	ACTION_DEFAULT_RESTART
 16    11 			init ("01"b),
 16    12 	ACTION_QUIET_RESTART
 16    13 			init ("001"b),
 16    14 	ACTION_SUPPORT_SIGNAL
 16    15 			init ("0001"b)
 16    16 	)		bit (36) aligned internal static options (constant);
 16    17 
 16    18 /* End include file */
      942 
      943 
 17     1 /* ***********************************************************
 17     2*   *                                                         *
 17     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
 17     4*   *                                                         *
 17     5*   *********************************************************** */
 17     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
 17     7 
 17     8 /* Written by Lindsey Spratt, 04/02/82.
 17     9*Modified:
 17    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
 17    11*	  unaligned.  Changed the type number of the simple_typed_vector to
 17    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
 17    13*	  type.
 17    14**/
 17    15 
 17    16 /* format: style2,ind3 */
 17    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
 17    18 	     2 type	      fixed bin (17) unal,
 17    19 	     2 number_of_dimensions
 17    20 			      fixed bin (17) unal,
 17    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
 17    22 	       3 value_ptr	      ptr unaligned;
 17    23 
 17    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
 17    25 	     2 type	      fixed bin (17) unal,
 17    26 	     2 number_of_dimensions
 17    27 			      fixed bin (17) unal,
 17    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
 17    29 	       3 identifier	      fixed bin (17) unal,
 17    30 	       3 pad	      bit (18) unal,
 17    31 	       3 value_ptr	      ptr unal;
 17    32 
 17    33      dcl	   simple_typed_vector_ptr
 17    34 			      ptr;
 17    35      dcl	   stv_number_of_dimensions
 17    36 			      fixed bin (17);
 17    37 
 17    38      dcl	   general_typed_vector_ptr
 17    39 			      ptr;
 17    40      dcl	   gtv_number_of_dimensions
 17    41 			      fixed bin (17);
 17    42 
 17    43      dcl	   (
 17    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
 17    45 			      init (1),		/* value_ptr was aligned. */
 17    46 	   GENERAL_TYPED_VECTOR_TYPE
 17    47 			      init (2),
 17    48 	   SIMPLE_TYPED_VECTOR_TYPE
 17    49 			      init (3)
 17    50 	   )		      fixed bin (17) internal static options (constant);
 17    51 
 17    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
      944 
      945 
 18     1 /* ***********************************************************
 18     2*   *                                                         *
 18     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
 18     4*   *                                                         *
 18     5*   *********************************************************** */
 18     6 /* BEGIN INCLUDE FILE vu_typed_vector_array.incl.pl1 */
 18     7 
 18     8 /* Written by Lindsey Spratt, 03/04/82.
 18     9*Modified:
 18    10*06/23/82 by Lindsey Spratt: Changed to version 2.  The cv entry declarations
 18    11*	  were altered.  cv_to_typed now takes ptr to the descriptor, ptr to
 18    12*	  the print_vector value (char varying), ptr to the typed_vector
 18    13*	  value location, and a code. cv_to_print now takes ptr to the
 18    14*	  descriptor, ptr to the typed_vector value, the print_vector value
 18    15*	  (char(*) varying), the maximum allowed length for the print_vector
 18    16*	  value, a temp_seg to put the value in if its to big to fit into
 18    17*	  the print_vector, and a code.
 18    18**/
 18    19 
 18    20 /* format: style2,ind3 */
 18    21      dcl	   1 typed_vector_array   based (typed_vector_array_ptr) aligned,
 18    22 	     2 version	      fixed bin (35),
 18    23 	     2 number_of_dimensions
 18    24 			      fixed bin (17),
 18    25 	     2 number_of_vectors  fixed bin (17),
 18    26 	     2 number_of_vector_slots
 18    27 			      fixed bin (17),
 18    28 	     2 maximum_dimension_name_
8
 > êa   bYÎ        ‰‘áÍ      
      *@  À       ’½í    

     *@  À       ’½í    

      ê*@  À       ’½í    

(     ø*@  À       ’½í    
 
0     Ü*@  À       ’½í    
(
8   > ê*@  À       ’½í    
0     L Ü*@  À       ’½í    
ž	â  &”¤€¤Ro79   
H
H ¼ êm         
@     0L0592.firm                         ”¤€¤        Û	‡÷Ì               ø 
–
f ¼ êm   bYÎ        ‰‘áÍ      
n      *@  À       ”¤€¤    
f
v     *@  À       ”¤€¤    
n
~     ê*@  À       ”¤€¤    
v
†     ø*@  À       ”¤€¤    
~
Ž     Ü*@  À       ”¤€¤    
†
–   ¼ ê*@  À       ”¤€¤    
Ž     L Ü*@  À       ”¤€¤    
ü
@  &”ÙZêRo7F   
¦
¦ ¼ êm         
ž Œ    813785.firm                         ”ÙZê        àý°„5               ø 
ô
Ä ¼ êm   bYÎ        ‰‘áÍ      
Ì      *@  À       ”ÙZê    
Ä
Ô     *@  À       ”ÙZê    
Ì
Ü     ê*@  À       ”ÙZê    
Ô
ä     ø*@  À       ”ÙZê    
Ü
ì     Ü*@  À       ”ÙZê    
ä
ô   ¼ ê*@  À       ”ÙZê    
ì     L Ü*@  À       ”ÙZê    
Z
ž  &•g=ÒRo7^   

   êm         
ü ë    821440.firm                         •g=Ò        Ûî2®,               ø 
R
"   êm   bYÎ        ‰‘áÍ      
*      *@  À       •g=Ò    
"
2     *@  À       •g=Ò    
*
:     ê*@  À       •g=Ò    
2
B     ø*@  À       •g=Ò    
:
J     Ü*@  À       •g=Ò    
B
R     ê*@  À       •g=Ò    
J     L Ü*@  À       •g=Ò    
¸
ü  &–‰ÙRo7q   
b
b   êm         
Z      901802.firm                         –‰Ù        ÂŸzŒV               ø 
°
€   êm   bYÎ        ‰‘áÍ      
ˆ      *@  À       –‰Ù    
€
     *@  À       –‰Ù    
ˆ
˜     ê*@  À       –‰Ù    

      ø*@  À       –‰Ù    
˜
¨     Ü*@  À       –‰Ù    
 
°     ê*@  À       –‰Ù    
¨     L Ü*@  À       –‰Ù    
Z  &—@Æ¸Ro7   
À
À 0 êm         
¸ ÷    773875.firm                         —@Æ¸        Û	ÍÙ               ø 
Þ 0 êm   bYÎ        ‰‘áÍ      
æ      *@  À       —@Æ¸    
Þ
î     *@  À       —@Æ¸    
æ
ö     ê*@  À       —@Æ¸    
î
þ     ø*@  À       —@Æ¸    
ö     Ü*@  À       —@Æ¸    
þ   0 ê*@  À       —@Æ¸         L Ü*@  À       —@Æ¸    ˜
¸  &—YåÄRo7‹    > êa          Ü`  agp120                              —YåÄ        Û	Íô               ø \< > êa   bYÎ        ‰‘áÍ      D      *@  À       —YåÄ    <L     *@  À       —YåÄ    DT     Ü*@  À       —YåÄ    L\   > ê*@  À       —YåÄ    T     L Ü*@  À       —YåÄ    ~:  &¤`\§Ro9}   ll ¼ êm         d     773720.firm                         ¤`\§        Û	Í¶               ø ’` ¼ êm   bYÎ        ‰‘áÍ    Æ       L Ü*@  À       ¡šÎÀ    Š       ® ø*@  À       ¡šÎÀ      º      *@  À       ¤	Ž?    ’         Ü*@  À       ¡šÎÀ    ¢         ø*@  À       ¡šÎÀ    ¼         *@  À       ¡šÐu    š     *@  À       ¤	Ž?    :Ü  &¤	Ž?Ro9O   ÊÊ v êa         Â ë
  771240.firm                         ¤	Ž?        Û	‡÷(               ø (š v êa   bYÎ        ‰‘áÍ    VN     Ü*@  À       ¡š;º    ª          *@  À       £(;I           L Ü*@  À       £(;I    ö     Ü*@  À       ¤	Ž?    ª         *@  À       ¡šÎÀ    ºö     ê*@  À       ¤	Ž?    D     L Ü*@  À       ¡šLÛ    H  &¡š;ºRo8ß   (( „ êm           R    853493.firm                         ¡š;º        ÂŸzŒë               ø v „ êm   bYÎ        ‰‘áÍ    ‚     *@  À       ¡š;º    èv   „ ê*@  À       ¡š;º    ‚è     ø*@  À       ¡š;º     ª     ê*@  À       ¡šLÛ    	þø     *@  À       £•)’    ø      v ê*@  À       £(;I    N     L Ü*@  À       ¡š;º      d  &¤`q\Ro9’   †† ¼ êm         ~   773720                              ¤`q\        Û	Í5               ø ¶ˆ ¼ êm   bYÎ        ‰‘áÍ    ´         Ü*@  À       ¡šÐu    H       L Ü*@  À       ¡šÐu    ¬       ® ø*@  À       ¡šÐu    ¤         ø*@  À       ¡šÐu    
   ¼ ê*@  À       ¤	ZO    `     *@  À       ¤	ZO         ø*@  À       ¤	ZO    ÂT  &¤	ZORo94   ää ¼ êm         Ü ½    781741.firm                         ¤	ZO        àý°„
                ø 
` ¼ êm   bYÎ           constant        fixed bin(17,0)          initial dcl 15-22 ref 742
ACTION_CANT_RESTART             000016 constant        bit(36)                  initial dcl 16-7 set ref 114* 134* 163* 170* 482*
                                                                                  633* 757* 763* 775* 783*
ALL_RANGE_TYPE                         constant        fixed bin(17,0)          initial dcl 3-8 ref 640
ATTRIBUTE_INFO_VERSION_1        000010 constant        char(8)                  initial dcl 8-34 set ref 200*
ELEMENT_ID_LIST_VERSION_1       000175 automatic       fixed bin(35,0)          initial dcl 2-28 set ref 2-28* 168* 254
ID_LIST_VERSION_1                      constant        fixed bin(17,0)          initial dcl 4-23 ref 719
INDEX_ATTRIBUTE_MAP_VERSION_2   000002 constant        char(8)                  initial dcl 11-43 set ref 203*
INITIAL_NUMBER_OF_INDICES       000216 automatic       fixed bin(17,0)          initial dcl 11-45 set ref 11-45*
MAXIMUM_REASONABLE_VALUE               constant        fixed bin(35,0)          initial dcl 846 ref 642
MY_NAME                         000012 constant        char(16)                 initial unaligned dcl 847 set ref 114* 134* 163*
                                                                                  170* 482* 575* 583 633* 757* 763* 775* 783* 816*
OFF                                    constant        bit(1)                   initial unaligned dcl 843 ref 183 184 309 351 353
                                                                                  579 581 592 672 692 711 732 733
ON                              000016 constant        bit(1)                   initial unaligned dcl 844 ref 77 296 582 681 687 701
                                                                                  755 837
RELATION_CURSOR_VERSION_2       000006 constant        char(8)                  initial dcl 9-43 set ref 161*
RELATION_HEADER_VERSION_3       000004 constant        char(8)                  initial dcl 10-30 set ref 197*
RELATION_OPENING_INFO_VERSION_2 000000 constant        char(8)                  initial dcl 13-43 set ref 194*
RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       constant        fixed bin(17,0)          initial dcl 15-22 ref 631
RELATIVE_SEARCH_SPECIFICATION_TYPE     constant        fixed bin(17,0)          initial dcl 15-22 ref 308 769
SPECIFICATION_VERSION_4         000046 constant        fixed bin(35,0)          initial dcl 15-19 set ref 166*
TYPED_VECTOR_ARRAY_VERSION_2    000045 constant        fixed bin(35,0)          initial dcl 18-50 set ref 244*
UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
                                000217 automatic       fixed bin(17,0)          initial dcl 11-47 set ref 11-47*
addr                                                   builtin function         dcl 849 ref 578
and_group                10            based           structure                array level 2 in structure
                                                                                  "relation_search_specification" dcl 12-9
                                                                                  in procedure "rlm_get_tuple_id"
and_group                 6            based           structure                array level 2 in structure "search_specification"
                                                                                  packed unaligned dcl 14-38 in procedure
                                                                                  "rlm_get_tuple_id"
area_control                           based           structure                level 1 dcl 1-20
area_info                              based           structure                level 1 dcl 1-7 set ref 579*
area_info_version_1                    constant        fixed bin(17,0)          initial dcl 1-3 ref 580
area_infop                      000170 automatic       pointer                  dcl 1-5 set ref 313* 578* 579 580 581 582 583 584
                                                                                  585 586*
areap                    16            based           pointer                  level 2 dcl 1-7 set ref 585*
attribute_id              6(18)        based           fixed bin(17,0)          array level 3 packed unaligned dcl 11-18 ref 399 478
                                                                                  695
attribute_info                         based           structure                level 1 dcl 8-18
attribute_info_ptr       16            based           pointer                  initial level 2 in structure "relation_opening_info"
                                                                                  dcl 13-15 in procedure "rlm_get_tuple_id" ref 199
attribute_info_ptr              000206 automatic       pointer                  initial dcl 8-29 in procedure "rlm_get_tuple_id" set
                                                                                  ref 8-29* 199* 200
automatic_area_info             000100 automatic       structure                level 1 unaligned dcl 850 set ref 578
callers_area_ptr                000124 automatic       pointer                  dcl 852 set ref 70* 491*
cleanup                         000126 stack reference condition                dcl 853 ref 76
cleanup_signalled               000134 automatic       bit(1)                   dcl 854 set ref 77* 183*
collection_id             4            based           bit(36)                  array level 3 in structure "index_attribute_map"
                                                                                  dcl 11-18 in procedure "rlm_get_tuple_id" ref 675
collection_id            10            based           bit(36)                  initial level 3 in structure "relation_cursor"
                                                                                  dcl 9-18 in procedure "rlm_get_tuple_id" set ref
                                                                                  659 775 775* 783 783* 832*
collection_id_supplied
                         11            based           bit(1)                   array level 4 packed unaligned dcl 12-9 ref 661 775
constraint               12            based           structure                array level 3 in structure
                                                                                  "relation_search_specification" dcl 12-9
                                                                                  in procedure "rlm_get_tuple_id" ref 652
constraint                6(18)        based           structure                array level 3 in structure "search_specification"
                                                                                  packed unaligned dcl 14-38 in procedure
                                                                                  "rlm_get_tuple_id" set ref 652*
control                   1            based           structure                level 2 dcl 1-7 set ref 581*
current                   6            based           structure                level 2 dcl 9-18 set ref 733*
current_indexes_index           000135 automatic       fixed bin(17,0)          dcl 855 set ref 81* 399 399 403 478 478 482
current_state_is_consistent
                          5            based           bit(1)                   initial level 3 packed unaligned dcl 9-18 set ref
                                                                                  592* 757 837*
cursor_ptr               14            based           pointer                  initial level 3 dcl 9-18 set ref 561 735* 757 834*
cv_p_expected_version                  parameter       char(8)                  dcl 110 set ref 103 114 114*
cv_p_received_version                  parameter       char(8)                  dcl 111 set ref 103 114 114*
cv_p_structure_name                    parameter       char                     unaligned dcl 112 set ref 103 114*
cvf_p_expected_version                 parameter       fixed bin(35,0)          dcl 130 set ref 123 134 134*
cvf_p_received_version                 parameter       fixed bin(35,0)          dcl 131 set ref 123 134 134*
cvf_p_structure_name                   parameter       char                     unaligned dcl 132 set ref 123 134*
define_area_                    000010 constant        entry                    external dcl 857 ref 313 586
dimension                 1            based           structure                array level 2 packed unaligned dcl 17-17
dm_error_$bad_rel_cursor_pos    000012 external static fixed bin(35,0)          dcl 858 set ref 757*
dm_error_$index_not_in_relation 000014 external static fixed bin(35,0)          dcl 859 set ref 679*
dm_error_$key_not_found         000016 external static fixed bin(35,0)          dcl 860 ref 348 351 494
dm_error_$record_not_found      000020 external static fixed bin(35,0)          dcl 861 ref 435 520
dm_error_$rel_cursor_spec_mismatch
                                000022 external static fixed bin(35,0)          dcl 862 set ref 763* 775* 783*
dm_error_$tuple_not_found       000024 external static fixed bin(35,0)          dcl 863 ref 94
dm_error_$unexpected_search_case
                                000026 external static fixed bin(35,0)          dcl 864 set ref 482*
dm_error_$unsup_search_spec_head_type
                                000030 external static fixed bin(35,0)          dcl 865 set ref 633*
eil_number_of_elements          000174 automatic       fixed bin(35,0)          dcl 2-27 set ref 252* 253 253
element_id_list                        based           structure                level 1 dcl 2-21 set ref 253 807
element_id_list_ptr             000172 automatic       pointer                  dcl 2-26 set ref 71* 168 168 297 443 443 444 444
                                                                                  491* 515* 518 643
er_p_code                              parameter       fixed bin(35,0)          dcl 148 ref 143 150
error_table_$null_info_ptr      000032 external static fixed bin(35,0)          dcl 867 set ref 163* 170*
error_table_$unimplemented_version
                                000034 external static fixed bin(35,0)          dcl 868 set ref 114* 134*
extend                    1            based           bit(1)                   level 3 packed unaligned dcl 1-7 set ref 582*
field_id                 12            based           fixed bin(17,0)          array level 4 in structure
                                                                                  "relation_search_specification" packed unaligned
                                                                                  dcl 12-9 in procedure "rlm_get_tuple_id" ref 397
                                                                                  477
field_id                  6(18)        based           fixed bin(17,0)          array level 4 in structure "search_specification"
                                                                                  packed unaligned dcl 14-38 in procedure
                                                                                  "rlm_get_tuple_id" set ref 341* 428* 485* 695
file_opening_id           4            based           bit(36)                  initial level 2 dcl 9-18 set ref 190* 551* 555* 565*
flags                    11            based           structure                array level 3 in structure
                                                                                  "relation_search_specification" packed unaligned
                                                                                  dcl 12-9 in procedure "rlm_get_tuple_id"
flags                     7            based           structure                level 3 in structure "relation_cursor" dcl 9-18
                                                                                  in procedure "rlm_get_tuple_id"
flags                     5            based           structure                level 2 in structure "relation_cursor" dcl 9-18
                                                                                  in procedure "rlm_get_tuple_id" set ref 732*
get_dm_free_area_               000036 constant        entry                    external dcl 870 ref 186
get_temp_segment_               000040 constant        entry                    external dcl 871 ref 575
gtific_code                     000320 automatic       fixed bin(35,0)          dcl 333 set ref 345* 348 348 348* 351
gtific_loop                     000321 automatic       fixed bin(17,0)          dcl 334 set ref 340* 341 341*
hbound                                                 builtin function         dcl 873 ref 675 679
head                                   based           structure                level 2 in structure "search_specification"
                                                                                  unaligned dcl 14-38 in procedure
                                                                                  "rlm_get_tuple_id" set ref 741*
head                                   based           structure                level 2 in structure "relation_search_specification"
                                                                                  dcl 12-9 in procedure "rlm_get_tuple_id" set ref
                                                                                  741
i_code                          000266 automatic       fixed bin(35,0)          dcl 159 set ref 190* 191 191*
id                        2            based           bit(36)                  array level 2 in structure "element_id_list"
                                                                                  dcl 2-21 in procedure "rlm_get_tuple_id" set ref
                                                                                  260* 444* 444
id                        2            based           fixed bin(17,0)          array level 2 in structure "id_list" dcl 4-16
                                                                                  in procedure "rlm_get_tuple_id" set ref 720*
id_list                                based           structure                level 1 dcl 4-16 set ref 718 804
id_list_ptr                     000176 automatic       pointer                  initial dcl 4-21 set ref 81* 4-21* 173* 345* 488*
                                                                                  804 804
il_number_of_ids                000200 automatic       fixed bin(17,0)          initial dcl 4-22 set ref 4-22* 717* 718 718
index                     4            based           structure                array level 2 dcl 11-18 ref 675 679
index_attribute_map                    based           structure                level 1 dcl 11-18
index_attribute_map_ptr         000214 automatic       pointer                  initial dcl 11-37 in procedure "rlm_get_tuple_id"
                                                                                  set ref 11-37* 202* 203 399 399 403 478 478 482
                                                                                  675 675 679 695 695 701 720
index_attribute_map_ptr
                         20            based           pointer                  initial level 2 in structure "relation_opening_info"
                                                                                  dcl 13-15 in procedure "rlm_get_tuple_id" ref 202
index_constraints_field_ids            based           fixed bin(17,0)          array dcl 875 set ref 341 391 393* 405* 810
index_constraints_field_ids_ptr 000136 automatic       pointer                  dcl 876 set ref 174* 341 391* 393 405 810 810
index_element_id_list_ptr       000140 automatic       pointer                  dcl 877 set ref 175* 303 336* 356* 432*
index_manager_$create_cursor    000054 constant        entry                    external dcl 5-38 ref 551
index_manager_$get_key          000056 constant        entry                    external dcl 5-44 ref 345 488
interval_list_ptr               000202 automatic       pointer                  initial dcl 6-33 set ref 6-33* 176* 338* 345* 432*
                                                                                  488*
intl_number_of_intervals        000204 automatic       fixed bin(17,0)          initial dcl 6-36 set ref 6-36*
max                                                    builtin function         dcl 879 ref 738
maximum_dimension_name_length
                          4            based           fixed bin(17,0)          level 2 dcl 18-21 ref 260
maximum_number_of_attributes_per_index
                          3            based           fixed bin(17,0)          level 2 packed unaligned dcl 11-18 ref 399 399 399
                                                                                  399 403 403 478 478 478 478 482 482 675 675 695
                                                                                  695 695 695 701 701 720 720
maximum_number_of_constraints
                          4            based           fixed bin(17,0)          level 2 in structure "relation_search_specification"
                                                                                  packed unaligned dcl 12-9 in procedure
                                                                                  "rlm_get_tuple_id" ref 390 390 397 397 476 476 477
                                                                                  477 649 649 652 652 652 652 652 652 652 652 652
                                                                                  652 661 661 661 661 737 775 775 775 775 775 775
maximum_number_of_constraints
                          4            based           fixed bin(17,0)          level 2 in structure "search_specification" packed
                                                                                  unaligned dcl 14-38 in procedure
                                                                                  "rlm_get_tuple_id" set ref 341 341 428 428 485 485
                                                                                  651 651 652 652 652 652 652 652 652 652 652 652
                                                                                  693 693 695 695 739*
maximum_number_of_indices
                          2(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 11-18 ref 675 679
mclfiarc_inner_loop             000332 automatic       fixed bin(17,0)          dcl 387 set ref 399* 399* 403 405
mclfiarc_loop                   000333 automatic       fixed bin(17,0)          dcl 388 set ref 396* 397 403 405*
mtvateil_area                          based           area                     dcl 233 ref 253
mtvateil_loop                   000276 automatic       fixed bin(35,0)          dcl 234 set ref 259* 260 260*
mtvateil_p_area_ptr                    parameter       pointer                  dcl 235 ref 217 253
mtvateil_p_element_id_list_ptr         parameter       pointer                  dcl 236 set ref 217 250 253* 254 256 260
mtvateil_p_number_of_tuple_ids         parameter       fixed bin(35,0)          dcl 237 set ref 217 247* 252 256 259
mtvateil_p_typed_vector_array_ptr      parameter       pointer                  dcl 238 ref 217 241 244 247 260
mtvateil_tuple_id                      based           bit(36)                  dcl 239 ref 260
null                                                   builtin function         dcl 881 ref 4-21 6-33 8-29 9-42 10-29 11-37 12-50
                                                                                  12-50 114 114 134 134 163 163 163 168 170 170 173
                                                                                  174 175 176 177 178 179 180 181 182 186 241 250
                                                                                  303 336 337 338 425 482 482 571 590 633 633 734
                                                                                  735 757 757 757 763 763 763 775 775 783 783 801
                                                                                  804 807 810 813 816
number_of_and_groups      4(18)        based           fixed bin(17,0)          level 2 in structure "relation_search_specification"
                                                                                  packed unaligned dcl 12-9 in procedure
                                                                                  "rlm_get_tuple_id" ref 206 738 773
number_of_and_groups      4(18)        based           fixed bin(17,0)          level 2 in structure "search_specification" packed
                                                                                  unaligned dcl 14-38 in procedure
                                                                                  "rlm_get_tuple_id" set ref 645 739*
number_of_attributes      6            based           fixed bin(17,0)          array level 3 packed unaligned dcl 11-18 ref 399 403
                                                                                  478 482 695 701 720
number_of_constraints
                          6            based           fixed bin(17,0)          array level 3 in structure "search_specification"
                                                                                  packed unaligned dcl 14-38 in procedure
                                                                                  "rlm_get_tuple_id" set ref 651* 693
number_of_constraints
                         11(18)        based           fixed bin(17,0)          array level 3 in structure
                                                                                  "relation_search_specification" packed unaligned
                                                                                  dcl 12-9 in procedure "rlm_get_tuple_id" ref 390
                                                                                  476 649
number_of_dimensions      1            based           fixed bin(17,0)          level 2 dcl 18-21 ref 260
number_of_elements        1            based           fixed bin(35,0)          level 2 dcl 2-21 set ref 253* 256* 297* 440 443* 443
                                                                                  444 518 643* 807
number_of_ids             1            based           fixed bin(17,0)          level 2 dcl 4-16 set ref 718* 804
number_of_index_and_record_constraints
                                000142 automatic       fixed bin(17,0)          dcl 882 set ref 340 390* 391 392 393 394 396 427 810
                                                                                  813
number_of_tuples_found          000143 automatic       fixed bin(35,0)          dcl 883 set ref 88* 90* 92* 94
number_of_tuples_to_retrieve    000144 automatic       fixed bin(35,0)          dcl 884 set ref 300 309 640* 642* 643
number_of_vectors         2            based           fixed bin(17,0)          level 2 dcl 18-21 ref 247 353
owner                     2            based           char(32)                 level 2 packed unaligned dcl 1-7 set ref 583*
p_callers_area_ptr                     parameter       pointer                  dcl 62 set ref 53 70 208*
p_code                                 parameter       fixed bin(35,0)          dcl 63 set ref 53 72* 94* 150* 208*
p_element_id_list_ptr                  parameter       pointer                  dcl 64 set ref 53 71 208*
p_relation_cursor_ptr                  parameter       pointer                  dcl 65 set ref 53 68 208*
p_specification_ptr                    parameter       pointer                  dcl 66 set ref 53 69 208*
primary_collection_id           000145 automatic       bit(36)                  dcl 886 set ref 81* 551* 555* 832
primary_cursor_ptr              000146 automatic       pointer                  dcl 887 set ref 86* 177* 345* 488* 515* 834
range                     6            based           structure                level 2 in structure "relation_search_specification"
                                                                                  dcl 12-9 in procedure "rlm_get_tuple_id"
range                     5            based           structure                level 2 in structure "search_specification" packed
                                                                                  unaligned dcl 14-38 in procedure
                                                                                  "rlm_get_tuple_id"
record_collection_id      3            based           bit(36)                  initial level 2 dcl 10-15 ref 664 665 669 709 783
record_constraints_field_ids           based           fixed bin(17,0)          array dcl 889 set ref 392 394* 403* 428 813
record_constraints_field_ids_ptr
                                000150 automatic       pointer                  dcl 890 set ref 178* 392* 394 403 428 813 813
record_element_id_list_ptr      000152 automatic       pointer                  dcl 891 set ref 179* 425* 432* 440 444 807 807
record_manager_$create_cursor   000060 constant        entry                    external dcl 7-29 ref 555 565
record_manager_$destroy_cursor  000062 constant        entry                    external dcl 7-33 ref 801
record_manager_$get_record_ids_by_interval
                                000066 constant        entry                    external dcl 7-50 ref 432
record_manager_$get_record_ids_by_spec
                                000064 constant        entry                    external dcl 7-48 ref 515
relation_cursor                        based           structure                level 1 dcl 9-18
relation_cursor_ptr             000210 automatic       pointer                  initial dcl 9-42 set ref 68* 9-42* 161 186 186 188
                                                                                  190 551 551 555 555 561 565 565 592 659 689 732
                                                                                  733 734 735 757 757 763 768 775 775 783 783 830
                                                                                  832 833 834 837
relation_header                        based           structure                level 1 dcl 10-15
relation_header_ptr             000212 automatic       pointer                  initial dcl 10-29 in procedure "rlm_get_tuple_id"
                                                                                  set ref 10-29* 196* 197 664 665 669 709 783
relation_header_ptr      14            based           pointer                  initial level 2 in structure "relation_opening_info"
                                                                                  dcl 13-15 in procedure "rlm_get_tuple_id" ref 196
relation_numeric_specification_ptr
                                000222 automatic       pointer                  initial dcl 12-50 set ref 12-50*
relation_opening_info                  based           structure                level 1 dcl 13-15
relation_opening_info_ptr       000226 automatic       pointer                  dcl 13-41 set ref 190* 194 196 199 202
relation_search_specification          based           structure                level 1 dcl 12-9
relation_search_specification_ptr
                                000220 automatic       pointer                  initial dcl 12-50 set ref 69* 12-50* 163 166 206 390
                                                                                  397 476 477 629 631 633 649 652 661 661 737 738
                                                                                  741 743 744 770 771 773 775 775 775
release_temp_segment_           000042 constant        entry                    external dcl 892 ref 816
rlm_general_search$get_id       000044 constant        entry                    external dcl 893 ref 208
rlm_opening_info$get            000046 constant        entry                    external dcl 894 ref 190
rss_maximum_number_of_constraints
                                000225 automatic       fixed bin(17,0)          initial dcl 12-52 set ref 12-52*
rss_number_of_and_groups        000224 automatic       fixed bin(17,0)          initial dcl 12-52 set ref 12-52*
search_collection_id     10            based           bit(36)                  array level 3 dcl 12-9 set ref 661 775 775*
search_index_and_record_collection
                          7            based           bit(1)                   initial level 4 packed unaligned dcl 9-18 set ref
                                                                                  689 830*
search_specification                   based           structure                level 1 unaligned dcl 14-38 set ref 739
search_specification_is_relative
                                000156 automatic       bit(1)                   dcl 898 set ref 81* 184* 549 828
search_specification_ptr        000230 automatic       pointer                  dcl 14-58 set ref 300 308 341 345* 353 428 432* 485
                                                                                  488* 515* 640 640 645 651 652 693 695 739* 741 742
                                                                                  743 744 768* 769 770 771 833
search_the_index                000154 automatic       bit(1)                   dcl 896 set ref 81* 88 551 563 573 830
search_the_records              000155 automatic       bit(1)                   dcl 897 set ref 81* 88 90 563 830
secondary_collection_id         000157 automatic       bit(36)                  dcl 899 set ref 81* 565*
secondary_cursor_ptr            000160 automatic       pointer                  dcl 900 set ref 86* 180* 432* 801 801*
siarc_another_pass_is_required  000306 automatic       bit(1)                   dcl 288 set ref 296* 299 309 309* 351* 353*
siarc_code                      000307 automatic       fixed bin(35,0)          dcl 289 set ref 313* 314 314*
siarc_field_id                  000310 automatic       fixed bin(17,0)          dcl 290 set ref 397* 399 403
siarc_number_of_tuples_remaining_after_record_search
                                000311 automatic       fixed bin(17,0)          dcl 291 set ref 305* 306 440* 442 448*
siarc_p_number_of_tuples_found         parameter       fixed bin(35,0)          dcl 292 set ref 269 295* 300 306* 306 309
sic_attribute_id                000400 automatic       fixed bin(17,0)          dcl 470 set ref 477* 478 482*
sic_code                        000401 automatic       fixed bin(35,0)          dcl 471 set ref 488* 491 494 496*
sic_inner_loop                  000402 automatic       fixed bin(17,0)          dcl 472 set ref 478* 478* 482 485
sic_loop                        000403 automatic       fixed bin(17,0)          dcl 473 set ref 476* 477 485*
sic_p_number_of_tuples_found           parameter       fixed bin(35,0)          dcl 474 set ref 456 491* 494*
simple_typed_vector                    based           structure                level 1 packed unaligned dcl 17-17
size                      5(18)        based           fixed bin(17,0)          level 3 in structure "search_specification" packed
                                                                                  unaligned dcl 14-38 in procedure
                                                                                  "rlm_get_tuple_id" set ref 300* 353 640 744* 771*
size                     13            based           fixed bin(18,0)          level 2 in structure "area_info" dcl 1-7
                                                                                  in procedure "rlm_get_tuple_id" set ref 584*
size                      7            based           fixed bin(17,0)          level 3 in structure "relation_search_specification"
                                                                                  dcl 12-9 in procedure "rlm_get_tuple_id" ref 744
                                                                                  771
specification_head                     based           structure                level 1 unaligned dcl 15-10
specification_ptr        12            based           pointer                  initial level 3 dcl 9-18 set ref 734* 763 768 833*
src_code                        000456 automatic       fixed bin(35,0)          dcl 512 set ref 515* 518 520 522*
src_p_number_of_tuples_found           parameter       fixed bin(35,0)          dcl 513 set ref 502 518* 520*
srcaa_code                      000466 automatic       fixed bin(35,0)          dcl 544 set ref 551* 555* 558 558* 565* 568 568*
                                                                                  575* 576 576* 586* 587 587*
srcaa_p_area_ptr                       parameter       pointer                  dcl 545 set ref 528 575* 585 590*
srcaa_p_primary_cursor_ptr             parameter       pointer                  dcl 546 set ref 528 551* 555* 561*
srcaa_p_secondary_cursor_ptr           parameter       pointer                  dcl 547 set ref 528 565* 571*
ss_maximum_number_of_constraints
                                000233 automatic       fixed bin(17,0)          dcl 14-60 set ref 737* 739 739
ss_number_of_and_groups         000232 automatic       fixed bin(17,0)          dcl 14-60 set ref 738* 739 739
sss_current_attribute           000476 automatic       fixed bin(17,0)          dcl 617 set ref 695* 695* 701
sss_current_constraint          000477 automatic       fixed bin(17,0)          dcl 618 set ref 693* 695*
sss_loop                        000500 automatic       fixed bin(17,0)          dcl 619 set ref 649* 651 652 652 652 652 652 652 652
                                                                                  652 652 652*
sss_p_current_indexes_index            parameter       fixed bin(17,0)          dcl 620 set ref 598 671* 675* 675* 679 695 695 701
                                                                                  720
sss_p_id_list_ptr                      parameter       pointer                  dcl 621 set ref 598 718* 719 720
sss_p_primary_collection_id            parameter       bit(36)                  dcl 622 set ref 598 659* 661* 664* 665* 669 675
sss_p_search_specification_is_relative parameter       bit(1)                   dcl 623 set ref 598 659 689 755*
sss_p_search_the_index                 parameter       bit(1)                   dcl 624 set ref 598 672* 681* 687 709 715
sss_p_search_the_records               parameter       bit(1)                   dcl 625 set ref 598 687* 689* 692* 693 701* 709
sss_p_secondary_collection_id          parameter       bit(36)                  dcl 626 set ref 598 709* 711*
sss_p_there_is_an_and_group            parameter       bit(1)                   dcl 627 set ref 598 645* 649 661
strfm_code                      000366 automatic       fixed bin(35,0)          dcl 422 set ref 432* 435 435 435* 438
strfm_loop                      000367 automatic       fixed bin(17,0)          dcl 423 set ref 427* 428 428* 442* 444*
sub_err_                        000050 constant        entry                    external dcl 901 ref 114 134 163 170 482 633 757 763
                                                                                  775 783
sys_info$max_seg_size           000052 external static fixed bin(35,0)          dcl 902 ref 584
temporary_area_ptr              000162 automatic       pointer                  dcl 904 set ref 86* 181* 345* 356* 432* 488* 816
                                                                                  816*
there_is_an_and_group_supplied  000164 automatic       bit(1)                   dcl 905 set ref 81*
type                      6            based           fixed bin(17,0)          level 3 in structure "relation_search_specification"
                                                                                  dcl 12-9 in procedure "rlm_get_tuple_id" ref 743
                                                                                  770
type                      1            based           fixed bin(17,0)          level 3 in structure "search_specification" packed
                                                                                  unaligned dcl 14-38 in procedure
                                                                                  "rlm_get_tuple_id" set ref 308* 742* 769*
type                      1            based           fixed bin(17,0)          level 3 in structure "relation_search_specification"
                                                                                  packed unaligned dcl 12-9 in procedure
                                                                                  "rlm_get_tuple_id" set ref 629 631 633*
type                      5            based           fixed bin(17,0)          level 3 in structure "search_specification" packed
                                                                                  unaligned dcl 14-38 in procedure
                                                                                  "rlm_get_tuple_id" set ref 640 743* 770*
typed_vector_array                     based           structure                level 1 dcl 18-21
typed_vector_array_ptr          000234 automatic       pointer                  dcl 18-43 set ref 182* 337* 345* 353 356* 488* 491*
unspec                                                 builtin function         dcl 907 set ref 579* 581* 732* 733*
value_ptr                 1            based           pointer                  array level 3 packed unaligned dcl 17-17 ref 260
vector_slot                            based           pointer                  array level 2 dcl 18-21 ref 260
version                                based           char(8)                  level 2 in structure "relation_opening_info"
                                                                                  dcl 13-15 in procedure "rlm_get_tuple_id" set ref
                                                                                  194*
version                                based           char(8)                  level 2 in structure "relation_cursor" dcl 9-18
                                                                                  in procedure "rlm_get_tuple_id" set ref 161*
version                                based           char(8)                  level 2 in structure "attribute_info" dcl 8-18
                                                                                  in procedure "rlm_get_tuple_id" set ref 200*
version                                based           fixed bin(35,0)          level 2 in structure "id_list" dcl 4-16 in procedure
                                                                                  "rlm_get_tuple_id" set ref 719*
version                                based           fixed bin(17,0)          level 2 in structure "area_info" dcl 1-7
                                                                                  in procedure "rlm_get_tuple_id" set ref 580*
version                                based           char(8)                  level 2 in structure "index_attribute_map" dcl 11-18
                                                                                  in procedure "rlm_get_tuple_id" set ref 203*
version                                based           fixed bin(35,0)          level 2 in structure "element_id_list" dcl 2-21
                                                                                  in procedure "rlm_get_tuple_id" set ref 168* 254*
version                                based           char(8)                  level 2 in structure "relation_header" dcl 10-15
                                                                                  in procedure "rlm_get_tuple_id" set ref 197*
version                                based           fixed bin(35,0)          level 3 in structure "relation_search_specification"
                                                                                  dcl 12-9 in procedure "rlm_get_tuple_id" set ref
                                                                                  166*
version                                based           fixed bin(35,0)          level 2 in structure "typed_vector_array" dcl 18-21
                                                                                  in procedure "rlm_get_tuple_id" set ref 244*
work_area                              based           area                     dcl 909 ref 391 392 718 739
work_area_ptr                   000166 automatic       pointer                  dcl 910 in procedure "rlm_get_tuple_id" set ref 188*
                                                                                  391 392 515* 718 739
work_area_ptr             2            based           pointer                  initial level 2 in structure "relation_cursor"
                                                                                  dcl 9-18 in procedure "rlm_get_tuple_id" set ref
                                                                                  186 186* 188 551* 555* 565*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSOLUTE_NUMERIC_SPECIFICATION_TYPE    internal static fixed bin(17,0)          initial dcl 15-22
ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 15-22
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 16-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 16-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 16-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 16-7
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 17-43
HIGH_RANGE_TYPE                        internal static fixed bin(17,0)          initial dcl 3-8
INTERVAL_LIST_VERSION_2                internal static char(8)                  initial dcl 6-34
LOW_RANGE_TYPE                         internal static fixed bin(17,0)          initial dcl 3-8
NUMERIC_SPECIFICATION_TYPE             internal static fixed bin(17,0)          initial dcl 15-22
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 17-43
RELATIVE_NUMERIC_SPECIFICATION_TYPE    internal static fixed bin(17,0)          initial dcl 15-22
RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 15-22
SEARCH_SPECIFICATION_TYPE              internal static fixed bin(17,0)          initial dcl 15-22
SIMPLE_TYPED_VECTOR_TYPE               internal static fixed bin(17,0)          initial dcl 17-43
ai_maximum_attribute_name_length       automatic       fixed bin(17,0)          dcl 8-30
ai_number_of_attributes                automatic       fixed bin(17,0)          dcl 8-32
general_typed_vector                   based           structure                level 1 packed unaligned dcl 17-24
general_typed_vector_ptr               automatic       pointer                  dcl 17-38
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 17-40
iam_maximum_number_of_attributes_per_index
                                       automatic       fixed bin(17,0)          dcl 11-41
iam_maximum_number_of_indices          automatic       fixed bin(17,0)          dcl 11-39
index_manager_$create_index     000000 constant        entry                    external dcl 5-39
index_manager_$create_subset_index
                                000000 constant        entry                    external dcl 5-40
index_manager_$delete_key       000000 constant        entry                    external dcl 5-41
index_manager_$destroy_cursor   000000 constant        entry                    external dcl 5-42
index_manager_$destroy_index    000000 constant        entry                    external dcl 5-43
index_manager_$get_key_count_array
                                000000 constant        entry                    external dcl 5-45
index_manager_$get_key_count_by_spec
                                000000 constant        entry                    external dcl 5-46
index_manager_$position_cursor  000000 constant        entry                    external dcl 5-47
index_manager_$put_key          000000 constant        entry                    external dcl 5-48
index_manager_$put_key_array    000000 constant        entry                    external dcl 5-49
interval_list                          based           structure                level 1 dcl 6-20
numeric_specification                  based           structure                level 1 unaligned dcl 14-63
numeric_specification_ptr              automatic       pointer                  dcl 14-70
record_manager_$create_collection
                                000000 constant        entry                    external dcl 7-27
record_manager_$delete_record_by_id
                                000000 constant        entry                    external dcl 7-63
record_manager_$delete_records_by_id_list
                                000000 constant        entry                    external dcl 7-66
record_manager_$delete_records_by_spec
                                000000 constant        entry                    external dcl 7-69
record_manager_$destroy_collection
                                000000 constant        entry                    external dcl 7-31
record_manager_$get_record_by_id
                                000000 constant        entry                    external dcl 7-36
record_manager_$get_record_count
                                000000 constant        entry                    external dcl 7-52
record_manager_$get_record_count_by_interval
                                000000 constant        entry                    external dcl 7-54
record_manager_$get_records_and_ids_by_interval
                                000000 constant        entry                    external dcl 7-46
record_manager_$get_records_and_ids_by_spec
                                000000 constant        entry                    external dcl 7-44
record_manager_$get_records_by_id_list
                                000000 constant        entry                    external dcl 7-38
record_manager_$get_records_by_interval
                                000000 constant        entry                    external dcl 7-42
record_manager_$get_records_by_spec
                                000000 constant        entry                    external dcl 7-40
record_manager_$modify_record_by_id
                                000000 constant        entry                    external dcl 7-72
record_manager_$modify_records_by_id_list
                                000000 constant        entry                    external dcl 7-75
record_manager_$modify_records_by_spec
                                000000 constant        entry                    external dcl 7-78
record_manager_$put_record_by_id
                                000000 constant        entry                    external dcl 7-57
record_manager_$put_records_by_id
                                000000 constant        entry                    external dcl 7-60
relation_numeric_specification         based           structure                level 1 dcl 12-41
simple_typed_vector_ptr                automatic       pointer                  dcl 17-33
specification_head_ptr                 automatic       pointer                  dcl 15-18
stv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 17-35
tva_maximum_dimension_name_length      automatic       fixed bin(17,0)          dcl 18-48
tva_number_of_dimensions               automatic       fixed bin(17,0)          dcl 18-46
tva_number_of_vector_slots             automatic       fixed bin(17,0)          dcl 18-44

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   000542 constant        entry                    internal dcl 103 ref 161 194 197 200 203
CHECK_VERSION_FB                000644 constant        entry                    internal dcl 123 ref 166 168 244
ERROR_RETURN                    000740 constant        entry                    internal dcl 143 ref 191 314 348 435 496 522 558 568
                                                                                  576 587 679
GET_TUPLE_IDS_FROM_INDEX_COLLECTION
                                001652 constant        entry                    internal dcl 322 ref 302
INITIALIZE                      000752 constant        entry                    internal dcl 157 ref 74
MAKE_CONSTRAINT_LISTS_FOR_INDEX_AND_RECORD_COLLECTIONS
                                001761 constant        entry                    internal dcl 363 ref 294
MOVE_TYPED_VECTOR_ARRAY_TO_ELEMENT_ID_LIST
                                001414 constant        entry                    internal dcl 217 ref 356 491
RETURN                          000541 constant        label                    dcl 100 ref 153
SEARCH_INDEX_AND_RECORD_COLLECTIONS
                                001560 constant        entry                    internal dcl 269 ref 88
SEARCH_INDEX_COLLECTION         002276 constant        entry                    internal dcl 456 ref 92
SEARCH_RECORD_COLLECTION        002562 constant        entry                    internal dcl 502 ref 90
SEARCH_THESE_RECORDS_FOR_MATCHES
                                002160 constant        entry                    internal dcl 412 ref 303
SETUP_ABSOLUTE_SEARCH_SPEC      003641 constant        entry                    internal dcl 726 ref 629
SETUP_RELATIVE_SEARCH_SPEC      003730 constant        entry                    internal dcl 750 ref 631
SETUP_REQUIRED_CURSORS_AND_AREA 002623 constant        entry                    internal dcl 528 ref 86
SETUP_SEARCH_SPECIFICATION      003047 constant        entry                    internal dcl 598 ref 81
TERMINATE                       004237 constant        entry                    internal dcl 795 ref 78 97 151
UPDATE_RELATION_CURSOR          004355 constant        entry                    internal dcl 823 ref 98
rlm_get_tuple_id                000403 constant        entry                    external dcl 53

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5074        5164    4512        5104
Length      6010    4512        70         607     361           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rlm_get_tuple_id                    875 external procedure  is an external procedure.  
on unit on line 76                   64 on unit               
CHECK_VERSION                           internal procedure  shares stack frame of external procedure rlm_get_tuple_id.  
CHECK_VERSION_FB                        internal procedure  shares stack frame of external procedure rlm_get_tuple_id.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure rlm_get_tuple_id.  
INITIALIZE                              internal procedure  shares stack frame of external procedure rlm_get_tuple_id.  
MOVE_TYPED_VECTOR_ARRAY_TO_ELEMENT_ID_LIST
                                        internal procedure  shares stack frame of external procedure rlm_get_tuple_id.  
SEARCH_INDEX_AND_RECORD_COLLECTIONS
                                        internal procedure  shares stack frame of external procedure rlm_get_tuple_id.  
GET_TUPLE_IDS_FROM_INDEX_COLLECTION
                                        internal procedure  shares stack frame of external procedure rlm_get_tuple_id.  
MAKE_CONSTRAINT_LISTS_FOR_INDEX_AND_RECORD_COLLECTIONS
                                        internal procedure  shares stack frame of external procedure rlm_get_tuple_id.  
SEARCH_THESE_RECORDS_FOR_MATCHES
                                        internal procedure  shares stack frame of external procedure rlm_get_tuple_id.  
SEARCH_INDEX_COLLECTION                 internal procedure  shares stack frame of external procedure rlm_get_tuple_id.  
SEARCH_RECORD_COLLECTION                internal procedure  shares stack frame of external procedure rlm_get_tuple_id.  
SETUP_REQUIRED_CURSORS_AND_AREA
                                        internal procedure  shares stack frame of external procedure rlm_get_tuple_id.  
SETUP_SEARCH_SPECIFICATION              internal procedure  shares stack frame of external procedure rlm_get_tuple_id.  
SETUP_ABSOLUTE_SEARCH_SPEC              internal procedure  shares stack frame of external procedure rlm_get_tuple_id.  
SETUP_RELATIVE_SEARCH_SPEC              internal procedure  shares stack frame of external procedure rlm_get_tuple_id.  
TERMINATE                            86 internal procedure  is called by several nonquick procedures.  
UPDATE_RELATION_CURSOR                  internal procedure  shares stack frame of external procedure rlm_get_tuple_id.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rlm_get_tuple_id         000100 automatic_area_info         rlm_get_tuple_id
                         000124 callers_area_ptr            rlm_get_tuple_id
                         000134 cleanup_signalled           rlm_get_tuple_id
                         000135 current_indexes_index       rlm_get_tuple_id
                         000136 index_constraints_field_ids_ptr
                                                            rlm_get_tuple_id
                         000140 index_element_id_list_ptr   rlm_get_tuple_id
                         000142 number_of_index_and_record_constraints
                                                            rlm_get_tuple_id
                         000143 number_of_tuples_found      rlm_get_tuple_id
                         000144 number_of_tuples_to_retrieve
                                                            rlm_get_tuple_id
                         000145 primary_collection_id       rlm_get_tuple_id
                         000146 primary_cursor_ptr          rlm_get_tuple_id
                         000150 record_constraints_field_ids_ptr
                                                            rlm_get_tuple_id
                         000152 record_element_id_list_ptr  rlm_get_tuple_id
                         000154 search_the_index            rlm_get_tuple_id
                         000155 search_the_records          rlm_get_tuple_id
                         000156 search_specification_is_relative
                                                            rlm_get_tuple_id
                         000157 secondary_collection_id     rlm_get_tuple_id
                         000160 secondary_cursor_ptr        rlm_get_tuple_id
                         000162 temporary_area_ptr          rlm_get_tuple_id
                         000164 there_is_an_and_group_supplied
                                                            rlm_get_tuple_id
                         000166 work_area_ptr               rlm_get_tuple_id
                         000170 area_infop                  rlm_get_tuple_id
                         000172 element_id_list_ptr         rlm_get_tuple_id
                         000174 eil_number_of_elements      rlm_get_tuple_id
                         000175 ELEMENT_ID_LIST_VERSION_1   rlm_get_tuple_id
                         000176 id_list_ptr                 rlm_get_tuple_id
                         000200 il_number_of_ids            rlm_get_tuple_id
                         000202 interval_list_ptr           rlm_get_tuple_id
                         000204 intl_number_of_intervals    rlm_get_tuple_id
                         000206 attribute_info_ptr          rlm_get_tuple_id
                         000210 relation_cursor_ptr         rlm_get_tuple_id
                         000212 relation_header_ptr         rlm_get_tuple_id
                         000214 index_attribute_map_ptr     rlm_get_tuple_id
                         000216 INITIAL_NUMBER_OF_INDICES   rlm_get_tuple_id
                         000217 UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
                                                            rlm_get_tuple_id
                         000220 relation_search_specification_ptr
                                                            rlm_get_tuple_id
                         000222 relation_numeric_specification_ptr
                                                            rlm_get_tuple_id
                         000224 rss_number_of_and_groups    rlm_get_tuple_id
                         000225 rss_maximum_number_of_constraints
                                                            rlm_get_tuple_id
                         000226 relation_opening_info_ptr   rlm_get_tuple_id
                         000230 search_specification_ptr    rlm_get_tuple_id
                         000232 ss_number_of_and_groups     rlm_get_tuple_id
                         000233 ss_maximum_number_of_constraints
                                                            rlm_get_tuple_id
                         000234 typed_vector_array_ptr      rlm_get_tuple_id
                         000266 i_code                      INITIALIZE
                         000276 mtvateil_loop               MOVE_TYPED_VECTOR_ARRAY_TO_ELEMENT_ID_LIST
                         000306 siarc_another_pass_is_required
                                                            SEARCH_INDEX_AND_RECORD_COLLECTIONS
                         000307 siarc_code                  SEARCH_INDEX_AND_RECORD_COLLECTIONS
                         000310 siarc_field_id              SEARCH_INDEX_AND_RECORD_COLLECTIONS
                         000311 siarc_number_of_tuples_remaining_after_record_search
                                                            SEARCH_INDEX_AND_RECORD_COLLECTIONS
                         000320 gtific_code                 GET_TUPLE_IDS_FROM_INDEX_COLLECTION
                         000321 gtific_loop                 GET_TUPLE_IDS_FROM_INDEX_COLLECTION
                         000332 mclfiarc_inner_loop         MAKE_CONSTRAINT_LISTS_FOR_INDEX_AND_RECORD_COLLECTIONS
                         000333 mclfiarc_loop               MAKE_CONSTRAINT_LISTS_FOR_INDEX_AND_RECORD_COLLECTIONS
                         000366 strfm_code                  SEARCH_THESE_RECORDS_FOR_MATCHES
                         000367 strfm_loop                  SEARCH_THESE_RECORDS_FOR_MATCHES
                         000400 sic_attribute_id            SEARCH_INDEX_COLLECTION
                         000401 sic_code                    SEARCH_INDEX_COLLECTION
                         000402 sic_inner_loop              SEARCH_INDEX_COLLECTION
                         000403 sic_loop                    SEARCH_INDEX_COLLECTION
                         000456 src_code                    SEARCH_RECORD_COLLECTION
                         000466 srcaa_code                  SETUP_REQUIRED_CURSORS_AND_AREA
                         000476 sss_current_attribute       SETUP_SEARCH_SPECIFICATION
                         000477 sss_current_constraint      SETUP_SEARCH_SPECIFICATION
                         000500 sss_loop                    SETUP_SEARCH_SPECIFICATION

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac
enable_op           ext_entry           int_entry           op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
define_area_                  get_dm_free_area_             get_temp_segment_             index_manager_$create_cursor
index_manager_$get_key        record_manager_$create_cursor record_manager_$destroy_cursor
record_manager_$get_record_ids_by_interval                  record_manager_$get_record_ids_by_spec
release_temp_segment_         rlm_general_search$get_id     rlm_opening_info$get          sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bad_rel_cursor_pos  dm_error_$index_not_in_relation                             dm_error_$key_not_found
dm_error_$record_not_found    dm_error_$rel_cursor_spec_mismatch                          dm_error_$tuple_not_found
dm_error_$unexpected_search_case                            dm_error_$unsup_search_spec_head_type
error_table_$null_info_ptr    error_table_$unimplemented_version                          sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     53 000376    2   28 000410    4   21 000412    4   22 000414    6   33 000416    6   36 000420    8   29 000421
 9   42 000422   10   29 000423   11   37 000424   11   45 000425   11   47 000427   12   50 000430   12   52 000433
     68 000435        69 000441        70 000444        71 000447        72 000452        74 000453        76 000454
     77 000470        78 000473        79 000500        81 000501        86 000503        88 000505        90 000516
     92 000524        94 000526        97 000534        98 000540       100 000541       103 000542       114 000553
    119 000643       123 000644       134 000655       139 000737       143 000740       150 000742       151 000745
    153 000751       157 000752       161 000753       163 000776       166 001045       168 001070       170 001120
    173 001163       174 001165       175 001166       176 001167       177 001170       178 001171       179 001172
    180 001173       181 001174       182 001175       183 001176       184 001177       186 001200       188 001213
    190 001216       191 001232       194 001236       196 001263       197 001266       199 001311       200 001314
    202 001337       203 001342       206 001364       208 001372       210 001412       213 001413       217 001414
    241 001416       244 001423       247 001452       250 001457       252 001463       253 001465       254 001501
    255 001503       256 001504       259 001510       260 001517       263 001552       265 001557       269 001560
    294 001562       295 001563       296 001565       297 001567       299 001571       300 001574       302 001604
    303 001605       305 001613       306 001614       308 001621       309 001624       313 001633       314 001644
    318 001650       320 001651       322 001652       336 001653       337 001655       338 001656       340 001657
    341 001667       343 001703       345 001705       348 001730       351 001737       353 001745       356 001755
    359 001760       363 001761       390 001762       391 001777       392 002004       393 002011       394 002023
    396 002035       397 002045       399 002052       402 002123       403 002125       405 002151       406 002155
    408 002157       412 002160       425 002161       427 002163       428 002173       430 002207       432 002211
    435 002234       438 002244       440 002246       442 002251       443 002257       444 002264       446 002271
    447 002273       448 002274       450 002275       456 002276       476 002300       477 002323       478 002330
    481 002401       482 002403       485 002471       486 002504       488 002506       491 002531       494 002551
    496 002557       498 002561       502 002562       515 002564       518 002603       520 002612       522 002620
    524 002622       528 002623       549 002625       551 002630       555 002655       558 002676       560 002702
    561 002703       563 002706       565 002714       568 002735       570 002741       571 002742       573 002745
    575 002750       576 002772       578 002776       579 003000       580 003003       581 003005       582 003007
    583 003011       584 003014       585 003017       586 003023       587 003033       589 003037       590 003040
    592 003043       594 003046       598 003047       629 003051       631 003061       633 003065       640 003134
    642 003146       643 003150       645 003152       649 003161       651 003205       652 003210       654 003276
    659 003300       661 003310       664 003322       665 003326       669 003331       671 003335       672 003337
    673 003340       675 003341       678 003372       679 003374       681 003411       687 003414       689 003422
    692 003432       693 003433       695 003451       700 003537       701 003541       704 003563       709 003565
    711 003600       715 003601       717 003604       718 003606       719 003617       720 003621       724 003640
    726 003641       732 003642       733 003644       734 003647       735 003651       737 003652       738 003656
    739 003665       741 003706       742 003717       743 003722       744 003725       746 003727       750 003730
    755 003731       757 003734       763 004007       768 004057       769 004062       770 004064       771 004070
    773 004072       775 004076       782 004161       783 004162       789 004235       795 004236       801 004244
    804 004262       807 004274       810 004307       813 004316       816 004325       819 004354       823 004355
    828 004356       830 004361       832 004373       833 004375       834 004377       837 004401       839 004404


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
