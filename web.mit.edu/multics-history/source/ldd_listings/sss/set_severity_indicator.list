	COMPILATION LISTING OF SEGMENT set_severity_indicator
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/20/86  1222.7 mst Thu
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 set_severity_indicator: ssi: proc ();
       12 
       13 
       14 /*
       15*
       16*   This command sets a specified severity indicator.
       17*
       18*   Usage: ssi severity_indicator indicator_value
       19*
       20*   where severity_indicator is the name of the severity indicator to be set
       21*   to the indicator value specified.
       22*
       23*   Written 5/6/80 by Michael R. Jordan
       24*   Modified for installation 5/81 by Michael R. Jordan.
       25*
       26**/
       27 
       28 /*		CONSTANTS			*/
       29 
       30 
       31 dcl  ME char (22) static options (constant) init ("set_severity_indicator");
       32 
       33 
       34 /*		STATIC DATA		*/
       35 
       36 
       37 /*		AUTOMATIC			*/
       38 
       39 
       40 dcl  found bit (1) aligned;				/* ON => variable was found */
       41 dcl  node_ptr ptr;					/* ptr to variable node */
       42 dcl  code fixed bin (35);				/* error code */
       43 dcl  nargs fixed bin;				/* number of command arguments supplied */
       44 dcl  arg_ptr ptr;					/* ptr to arg */
       45 dcl  arg_len fixed bin;				/* length of arg */
       46 dcl  indicator_name char (22);			/* severity indicator name */
       47 
       48 dcl 1 my_init_info like init_info_single_word;
       49 
       50 
       51 /*		BASED			*/
       52 
       53 
       54 dcl  arg char (arg_len) based (arg_ptr);		/* a command line argument */
       55 dcl  severity_indicator fixed bin (35) aligned based;
       56 
       57 
       58 /*		EXTERNAL ENTRIES		*/
       59 
       60 
       61 dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
       62 dcl  cu_$arg_count entry (fixed bin);
       63 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
       64 dcl  set_ext_variable_ entry (char (*), ptr, ptr, bit (1) aligned, ptr, fixed bin (35));
       65 dcl  com_err_ entry options (variable);
       66 
       67 
       68 /*		ERROR CODES		*/
       69 
       70 
       71 dcl  error_table_$bad_arg fixed bin (35) ext;
       72 dcl  error_table_$wrong_no_of_args fixed bin (35) ext;
       73 dcl  error_table_$bigarg fixed bin (35) ext;
       74 
       75 
       76 /*		BUILTINS and CONDITIONS	*/
       77 
       78 
       79 dcl  addr builtin;
       80 dcl  length builtin;
       81 dcl  rtrim builtin;
       82 dcl  stackbaseptr builtin;
       83 
       84 	my_init_info.size = 1;
       85 	my_init_info.type = TEMPLATE_INIT;
       86 	my_init_info.init_template (1) = 0;
       87 
       88 
       89 /*
       90*
       91*   Make sure there are the proper number of arguments.
       92*
       93**/
       94 
       95 
       96 	call cu_$arg_count (nargs);			/* get number of args */
       97 	if nargs ^= 2
       98 	then do;
       99 	     code = error_table_$wrong_no_of_args;
      100 USAGE:	     call com_err_ (code, ME, "^/Usage:  ^a indicator_name indicator_value", ME);
      101 	     return;
      102 	end;
      103 
      104 
      105 /*
      106*
      107*   First we must get the severity indicator name.  We should also make sure it is
      108*   a valid severity indicator name.
      109*
      110**/
      111 
      112 
      113 	call cu_$arg_ptr (1, arg_ptr, arg_len, code);
      114 	if code ^= 0
      115 	then do;
      116 	     call com_err_ (code, ME, "Cannot get argument #1.");
      117 	     return;
      118 	end;
      119 	indicator_name = arg;
      120 	if indicator_name ^= arg			/* name too long */
      121 	then do;
      122 	     call com_err_ (error_table_$bigarg, ME,
      123 		"^a^/The maximum length for a severity indicator name is ^d characters.",
      124 		arg, length (indicator_name));
      125 	     return;
      126 	end;
      127 
      128 
      129 /*
      130*
      131*   Next we should get the new value for the indicator.  It must be a valid
      132*   decimal integer.
      133*
      134**/
      135 
      136 
      137 	call cu_$arg_ptr (2, arg_ptr, arg_len, code);
      138 	if code ^= 0
      139 	then do;
      140 	     call com_err_ (code, ME, "cannot get argument #2.");
      141 	     return;
      142 	end;
      143 	my_init_info.init_template (1) = cv_dec_check_ (arg, code);
      144 	if code ^= 0				/* bad indicator value */
      145 	then do;
      146 	     call com_err_ (error_table_$bad_arg, ME,
      147 		"^/Severity indicator value must be a decimal integer.");
      148 	     return;
      149 	end;
      150 
      151 
      152 /*
      153*
      154*   And, at last, we can attempt to create and set the indicator.  If the
      155*   indicator already exists we can try to reset it.  If the data type 'seems'
      156*   incompatible we will complain.  (Note that in the current implementation the
      157*   only check we can make is that the indicator is a one word value.)
      158*
      159**/
      160 
      161 
      162 	call set_ext_variable_ (rtrim (indicator_name) || "_severity_", addr (my_init_info), stackbaseptr (), found, node_ptr, code);
      163 	if code ^= 0
      164 	then do;
      165 	     call com_err_ (code, ME, "^/Error setting the severity indicator ^a.", indicator_name);
      166 	     return;
      167 	end;
      168 	if found					/* in this case we must reset the indicator */
      169 	then do;
      170 	     if node_ptr -> variable_node.vbl_size ^= 1
      171 	     then do;
      172 		call com_err_ (0b, ME, "Severity indicator ^a is not a single word variable.", indicator_name);
      173 		return;
      174 	     end;
      175 	     node_ptr -> variable_node.vbl_ptr -> severity_indicator = my_init_info.init_template (1);
      176 	end;
      177 
      178 	return;
      179 
  1     1 /* Begin include file ... system_link_init_info.incl.pl1 ... 5/6/80 MRJ */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  1     7*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
  1     8*     Modified to declare DEFERRED_INIT type constant.
  1     9*  2) change(86-06-24,DGHowe), approve(86-06-24,MCR7420), audit(86-11-12,Zwick),
  1    10*     install(86-11-20,MR12.0-1222):
  1    11*     added the external pointer initialization structure and the constants
  1    12*     required to use them.
  1    13*                                                   END HISTORY COMMENTS */
  1    14 
  1    15 
  1    16 /* Modified: 82-11-17 by T. Oke to add list_init_info and LIST_TEMPLATE_INIT. */
  1    17 
  1    18 /* format: style3,idind25 */
  1    19 
  1    20 /* NOTE --------------------------------------------------
  1    21*   the following structures defining initialization information can also
  1    22*   be found in fortran_storage.incl.pl1  definition_dcls.incl.pl1
  1    23*   and should be kept equivalent
  1    24*   -------------------------------------------------------
  1    25**/
  1    26 
  1    27 dcl	init_info_ptr	     ptr;			/* ptr to structure below */
  1    28 dcl	init_size		     fixed bin (35);	/* size (in words) of initialization template */
  1    29 
  1    30 dcl	1 init_info	     aligned based (init_info_ptr),
  1    31 	  2 size		     fixed bin (35),	/* size (in words) of data */
  1    32 	  2 type		     fixed bin,		/* type of initialization: see below */
  1    33 	  2 init_template	     (init_size refer (init_info.size)) fixed bin (35);
  1    34 
  1    35 dcl	1 init_info_single_word  aligned based (init_info_ptr),
  1    36 						/* for convenience of people like ssi */
  1    37 	  2 size		     fixed bin (19),	/* = 1 */
  1    38 	  2 type		     fixed bin,		/* = TEMPLATE_INIT */
  1    39 	  2 init_template	     (1) fixed bin (35);	/* = value */
  1    40 
  1    41 dcl	1 list_init_info	     aligned based,
  1    42 	  2 size		     fixed bin (35),	/* length of variable */
  1    43 	  2 type		     fixed bin,		/* LIST_TEMPLATE_INIT */
  1    44 	  2 pad		     bit (18) unaligned,
  1    45 	  2 list_size	     fixed bin (18) unsigned unaligned,
  1    46 						/* size in words of template */
  1    47 	  2 template	     (0 refer (list_init_info.list_size)) bit (36);
  1    48 						/* first create_entry position */
  1    49 
  1    50 /* A list template consists of a series of entries with the following
  1    51*   description, concatenated together.  n_bits and datum are bit items,
  1    52*   to permit a wide range of inputs.
  1    53*
  1    54*   1.  A 'repeat' of '0' signifies skipping of 'n_bits' bits.
  1    55*   2.  A 'n_bits' of '0' signifies the last item of the list.
  1    56*
  1    57*   COMMON, VLA's, and LA's are presumed to start at the base pointer
  1    58*   of their particular storage section. */
  1    59 
  1    60 dcl	1 list_template_entry    aligned based,
  1    61 	  2 n_bits	     fixed bin (35) aligned,	/* size of datum */
  1    62 	  2 mbz		     bit (3) unaligned,	/* future expansion */
  1    63 	  2 init_type	     fixed bin (3) unsigned unaligned, /* 0 normal init, 1 ptr init, 2 packed ptr init */
  1    64 	  2 repeat	     fixed bin (30) unsigned unaligned,
  1    65 						/* number of times to repeat datum */
  1    66 	  2 datum		     bit (init_n_bits_in_datum refer (list_template_entry.n_bits));
  1    67 
  1    68 /* list_template_entry_ptr is defined such that it can be used as an
  1    69*   automatic definition overlay with a fixed size datum. it has a declared 
  1    70*   size of 72 to allow for the its pointer sixe of 72 bits.
  1    71**/
  1    72 
  1    73 dcl	1 list_template_entry_ptr	aligned based,
  1    74 	  2 n_bits	     fixed bin (35) aligned,
  1    75 	  2 mbz		     bit(3) unaligned,
  1    76 	  2 init_type	     fixed bin (3) unsigned unaligned,
  1    77 	  2 repeat	     fixed bin (30) unsigned unaligned,
  1    78 	  2 datum		     bit(72);
  1    79 
  1    80 /* the pointer_init_template represents the initialization information
  1    81*   for ITS and packed pointers.  Both pointer types require the entire
  1    82*   72 bit structure.
  1    83**/
  1    84 
  1    85 dcl       1 pointer_init_template  based,
  1    86 	  2 ptr_type	     fixed bin (18) unsigned unaligned,  /* 0 text section, 1 linkage section, 2 static section */
  1    87 	  2 section_offset	     fixed bin (18) unsigned unaligned,  /* offset to item in specified section */
  1    88 	  2 word_offset	     fixed bin (18) unsigned unaligned,  /* word offset from section item to target */
  1    89 	  2 mbz		     bit (12) unaligned,
  1    90 	  2 bit_offset	     fixed bin (6) unsigned unaligned;   /* bit offset from section item|word offset to target */
  1    91 
  1    92 
  1    93 dcl	init_n_bits_in_datum     fixed bin (35);
  1    94 
  1    95 dcl	NO_INIT		     fixed bin static options (constant) init (0);
  1    96 dcl	TEMPLATE_INIT	     fixed bin static options (constant) init (3);
  1    97 dcl	EMPTY_AREA_INIT	     fixed bin static options (constant) init (4);
  1    98 dcl	LIST_TEMPLATE_INIT	     fixed bin static options (constant) init (5);
  1    99 dcl	INIT_DEFERRED	     fixed bin static options (constant) init (6);
  1   100 dcl	ITS_PTR_INIT	     fixed bin (3) unsigned static options (constant) init(1);
  1   101 dcl	PACKED_PTR_INIT	     fixed bin (3) unsigned static options (constant) init(2);
  1   102 dcl	PTR_INIT_TEXT	     fixed bin (17) static options (constant) init(0);
  1   103 dcl	PTR_INIT_LOT	     fixed bin (17) static options (constant) init(1);
  1   104 dcl	PTR_INIT_ISOT	     fixed bin (17) static options (constant) init(2);
  1   105 	
  1   106 
  1   107 /* End include file ... system_link_init_info.incl.pl1 */
      180 
      181 
  2     1 /* BEGIN INCLUDE FILE ... system_link_names.incl.pl1 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396), audit(86-11-12,Zwick),
  2     6*     install(86-11-20,MR12.0-1222):
  2     7*     added the declaration of the heap_header.
  2     8*  2) change(86-10-20,DGHowe), approve(86-10-20,MCR7420), audit(86-11-12,Zwick),
  2     9*     install(86-11-20,MR12.0-1222):
  2    10*     add the seg ptr to the variable node structure.
  2    11*                                                   END HISTORY COMMENTS */
  2    12 
  2    13 
  2    14 /* created by M. Weaver 7/28/76 */
  2    15 /* Modified: 82-11-19 by T. Oke to add LIST_TEMPLATE_INIT. */
  2    16 /* Modified 02/11/83 by M. Weaver to add have_vla_variables flag */
  2    17 
  2    18 
  2    19 dcl 1 variable_table_header aligned based,	/* header for name table */
  2    20      2 hash_table (0:63) ptr unaligned,		/* hash table for variable nodes */
  2    21      2 total_search_time fixed bin (71),	/* total time to search for variables */
  2    22      2 total_allocation_time fixed bin (71),	/* total time spent allocating and initializing nodes and variables */
  2    23      2 number_of_searches fixed bin,		/* number of times names were looked up */
  2    24      2 number_of_variables fixed bin (35),	/* number of variables allocated by the linker, incl deletions */
  2    25      2 flags unaligned,
  2    26         3 have_vla_variables bit (1) unaligned,	/* on if some variables are > sys_info$max_seg_size */
  2    27         3 pad bit (11) unaligned,
  2    28      2 cur_num_of_variables fixed bin (24) unal,	/* current number of variables allocated */
  2    29      2 number_of_steps fixed bin,		/* total number of nodes looked at */
  2    30      2 total_allocated_size fixed bin (35);	/* current amount of storage in user area */
  2    31 
  2    32 
  2    33 dcl 1 variable_node aligned based,		/* individual variable information */
  2    34      2 forward_thread ptr unaligned,		/* thread to next node off same hash bucket */
  2    35      2 vbl_size fixed bin (24) unsigned unaligned, /* length in words of variable */
  2    36      2 init_type fixed bin (11) unaligned,	/* 0=not init; 3=init template; 4=area 5=list_template*/
  2    37      2 time_allocated fixed bin (71),		/* time when variable was allocated */
  2    38      2 vbl_ptr ptr,				/* pointer to variable's storage */
  2    39      2 init_ptr ptr,			/* pointer to original init info in object seg */
  2    40      2 name_size fixed bin(21) aligned,		/* length of name in characters */
  2    41      2 name char (nchars refer (variable_node.name_size)), /* name of variable */
  2    42      2 seg_ptr  pointer;
  2    43 
  2    44 /* variable_node.seg_ptr
  2    45*   Is a pointer to the segment containing the initialization information
  2    46*   for this variable. It is used as a segment base pointer for external
  2    47*   pointer initialization via list_init_.
  2    48*
  2    49*   The init_ptr can not be used as a reference to the defining segment
  2    50*   due to the possibility of set_fortran_common being used to initialize
  2    51*   the external variables. sfc will generate an initialization information
  2    52*   structure if multiple intialization sizes are found in the specified 
  2    53*   segments. sfc stores the address of this structure in the init_ptr field.
  2    54*   This is one reason why sfc does not perform external pointer 
  2    55*   initialization.
  2    56*
  2    57*   The seg_ptr is set to point at the segment used to define the 
  2    58*   initialization information. term_ sets this field to null on termination
  2    59*   due to the possiblity of executing a different segment which defines
  2    60*   initialization information. In this way the seg_ptr field will either
  2    61*   be valid or null.
  2    62**/
  2    63 
  2    64 dcl 1 heap_header based,
  2    65      2 version            char(8),                /* specifies the verison of the header */
  2    66      2 heap_name_list_ptr pointer,		/* points to the variable_table_header for this heap */
  2    67      2 previous_heap_ptr  pointer,		/* points to the previous heap or is null */
  2    68      2 area_ptr	      pointer,		/* points to the heap area */
  2    69      2 execution_level    fixed bin (17);	/* specifies the execution level this header deals with */
  2    70 
  2    71 dcl heap_header_version_1 char(8) static options (constant)
  2    72 			    init ("Heap_v01");
  2    73 	
  2    74 
  2    75 /* END INCLUDE FILE ... system_link_names.incl.pl1 */
      182 
      183 
      184 
      185      end set_severity_indicator;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/20/86  1142.6  set_severity_indicator.pl1        >special_ldd>install>MR12.0-1222>set_severity_indicator.pl1
180          1    11/20/86  1035.4  system_link_init_info.incl.pl1    >special_ldd>install>MR12.0-1222>system_link_init_info.incl.pl1
182          2    11/20/86  1035.4  system_link_names.incl.pl1        >special_ldd>install>MR12.0-1222>system_link_names.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ME                              000000 constant        char(22)                 initial unaligned dcl 31 set ref 100* 100* 116* 122*
                                                                                  140* 146* 165* 172*
TEMPLATE_INIT                          constant        fixed bin(17,0)          initial dcl 1-96 ref 85
addr                                                   builtin function         dcl 79 ref 162 162
arg                                    based           char                     unaligned dcl 54 set ref 119 120 122* 143*
arg_len                         000110 automatic       fixed bin(17,0)          dcl 45 set ref 113* 119 120 122 122 137* 143 143
arg_ptr                         000106 automatic       pointer                  dcl 44 set ref 113* 119 120 122 137* 143
code                            000104 automatic       fixed bin(35,0)          dcl 42 set ref 99* 100* 113* 114 116* 137* 138 140*
                                                                                  143* 144 162* 163 165*
com_err_                        000020 constant        entry                    external dcl 65 ref 100 116 122 140 146 165 172
cu_$arg_count                   000012 constant        entry                    external dcl 62 ref 96
cu_$arg_ptr                     000014 constant        entry                    external dcl 63 ref 113 137
cv_dec_check_                   000010 constant        entry                    external dcl 61 ref 143
error_table_$bad_arg            000022 external static fixed bin(35,0)          dcl 71 set ref 146*
error_table_$bigarg             000026 external static fixed bin(35,0)          dcl 73 set ref 122*
error_table_$wrong_no_of_args   000024 external static fixed bin(35,0)          dcl 72 ref 99
found                           000100 automatic       bit(1)                   dcl 40 set ref 162* 168
indicator_name                  000111 automatic       char(22)                 unaligned dcl 46 set ref 119* 120 122 122 162 165*
                                                                                  172*
init_info_single_word                  based           structure                level 1 dcl 1-35
init_template             2     000117 automatic       fixed bin(35,0)          array level 2 dcl 48 set ref 86* 143* 175
length                                                 builtin function         dcl 80 ref 122 122
my_init_info                    000117 automatic       structure                level 1 unaligned dcl 48 set ref 162 162
nargs                           000105 automatic       fixed bin(17,0)          dcl 43 set ref 96* 97
node_ptr                        000102 automatic       pointer                  dcl 41 set ref 162* 170 175
rtrim                                                  builtin function         dcl 81 ref 162
set_ext_variable_               000016 constant        entry                    external dcl 64 ref 162
severity_indicator                     based           fixed bin(35,0)          dcl 55 set ref 175*
size                            000117 automatic       fixed bin(19,0)          level 2 dcl 48 set ref 84*
stackbaseptr                                           builtin function         dcl 82 ref 162 162
type                      1     000117 automatic       fixed bin(17,0)          level 2 dcl 48 set ref 85*
variable_node                          based           structure                level 1 dcl 2-33
vbl_ptr                   4            based           pointer                  level 2 dcl 2-33 ref 175
vbl_size                  1            based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 2-33 ref 170

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
EMPTY_AREA_INIT                        internal static fixed bin(17,0)          initial dcl 1-97
INIT_DEFERRED                          internal static fixed bin(17,0)          initial dcl 1-99
ITS_PTR_INIT                           internal static fixed bin(3,0)           initial unsigned dcl 1-100
LIST_TEMPLATE_INIT                     internal static fixed bin(17,0)          initial dcl 1-98
NO_INIT                                internal static fixed bin(17,0)          initial dcl 1-95
PACKED_PTR_INIT                        internal static fixed bin(3,0)           initial unsigned dcl 1-101
PTR_INIT_ISOT                          internal static fixed bin(17,0)          initial dcl 1-104
PTR_INIT_LOT                           internal static fixed bin(17,0)          initial dcl 1-103
PTR_INIT_TEXT                          internal static fixed bin(17,0)          initial dcl 1-102
heap_header                            based           structure                level 1 unaligned dcl 2-64
heap_header_version_1                  internal static char(8)                  initial unaligned dcl 2-71
init_info                              based           structure                level 1 dcl 1-30
init_info_ptr                          automatic       pointer                  dcl 1-27
init_n_bits_in_datum                   automatic       fixed bin(35,0)          dcl 1-93
init_size                              automatic       fixed bin(35,0)          dcl 1-28
list_init_info                         based           structure                level 1 dcl 1-41
list_template_entry                    based           structure                level 1 dcl 1-60
list_template_entry_ptr                based           structure                level 1 dcl 1-73
pointer_init_template                  based           structure                level 1 packed unaligned dcl 1-85
variable_table_header                  based           structure                level 1 dcl 2-19

NAMES DECLARED BY EXPLICIT CONTEXT.
USAGE                           000204 constant        label                    dcl 100
set_severity_indicator          000156 constant        entry                    external dcl 11
ssi                             000147 constant        entry                    external dcl 11

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1002        1032     660        1012
Length      1274     660        30         225     122           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ssi                                 172 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ssi                      000100 found                       ssi
                         000102 node_ptr                    ssi
                         000104 code                        ssi
                         000105 nargs                       ssi
                         000106 arg_ptr                     ssi
                         000110 arg_len                     ssi
                         000111 indicator_name              ssi
                         000117 my_init_info                ssi

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count                 cu_$arg_ptr                   cv_dec_check_
set_ext_variable_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$bigarg           error_table_$wrong_no_of_args


CONSTANTS
000000  aa  163 145 164 137	set_
000001  aa  163 145 166 145	seve
000002  aa  162 151 164 171	rity
000003  aa  137 151 156 144	_ind
000004  aa  151 143 141 164	icat
000005  aa  157 162 000 000	or

000006  aa     524000000064

000007  aa     404000000001

000010  aa     524000000052

000011  aa     514000000001

000012  aa     464000000000

000013  aa     524000000000

000014  aa     524000000065

000015  aa     404000000005

000016  aa     526000000000

000017  aa     524000000106

000020  aa     524000000027

000021  aa     524000000053

000022  aa     526000000026

000023  aa     404000000043

000024  aa  137 163 145 166	_sev
000025  aa  145 162 151 164	erit
000026  aa  171 137 000 000	y_

000027  aa  143 141 156 156	cann
000030  aa  157 164 040 147	ot g
000031  aa  145 164 040 141	et a
000032  aa  162 147 165 155	rgum
000033  aa  145 156 164 040	ent 
000034  aa  043 062 056 000	#2.

000035  aa  103 141 156 156	Cann
000036  aa  157 164 040 147	ot g
000037  aa  145 164 040 141	et a
000040  aa  162 147 165 155	rgum
000041  aa  145 156 164 040	ent 
000042  aa  043 061 056 000	#1.

000043  aa  136 057 105 162	^/Er
000044  aa  162 157 162 040	ror 
000045  aa  163 145 164 164	sett
000046  aa  151 156 147 040	ing 
000047  aa  164 150 145 040	the 
000050  aa  163 145 166 145	seve
000051  aa  162 151 164 171	rity
000052  aa  040 151 156 144	 ind
000053  aa  151 143 141 164	icat
000054  aa  157 162 040 136	or ^
000055  aa  141 056 000 000	a.

000056  aa  136 057 125 163	^/Us
000057  aa  141 147 145 072	age:
000060  aa  040 040 136 141	  ^a
000061  aa  040 151 156 144	 ind
000062  aa  151 143 141 164	icat
000063  aa  157 162 137 156	or_n
000064  aa  141 155 145 040	ame 
000065  aa  151 156 144 151	indi
000066  aa  143 141 164 157	cato
000067  aa  162 137 166 141	r_va
000070  aa  154 165 145 000	lue

000071  aa  123 145 166 145	Seve
000072  aa  162 151 164 171	rity
000073  aa  040 151 156 144	 ind
000074  aa  151 143 141 164	icat
000075  aa  157 162 040 136	or ^
000076  aa  141 040 151 163	a is
000077  aa  040 156 157 164	 not
000100  aa  040 141 040 163	 a s
000101  aa  151 156 147 154	ingl
000102  aa  145 040 167 157	e wo
000103  aa  162 144 040 166	rd v
000104  aa  141 162 151 141	aria
000105  aa  142 154 145 056	ble.

000106  aa  136 057 123 145	^/Se
000107  aa  166 145 162 151	veri
000110  aa  164 171 040 151	ty i
000111  aa  156 144 151 143	ndic
000112  aa  141 164 157 162	ator
000113  aa  040 166 141 154	 val
000114  aa  165 145 040 155	ue m
000115  aa  165 163 164 040	ust 
000116  aa  142 145 040 141	be a
000117  aa  040 144 145 143	 dec
000120  aa  151 155 141 154	imal
000121  aa  040 151 156 164	 int
000122  aa  145 147 145 162	eger
000123  aa  056 000 000 000	.

000124  aa  136 141 136 057	^a^/
000125  aa  124 150 145 040	The 
000126  aa  155 141 170 151	maxi
000127  aa  155 165 155 040	mum 
000130  aa  154 145 156 147	leng
000131  aa  164 150 040 146	th f
000132  aa  157 162 040 141	or a
000133  aa  040 163 145 166	 sev
000134  aa  145 162 151 164	erit
000135  aa  171 040 151 156	y in
000136  aa  144 151 143 141	dica
000137  aa  164 157 162 040	tor 
000140  aa  156 141 155 145	name
000141  aa  040 151 163 040	 is 
000142  aa  136 144 040 143	^d c
000143  aa  150 141 162 141	hara
000144  aa  143 164 145 162	cter
000145  aa  163 056 000 000	s.

BEGIN PROCEDURE ssi
ENTRY TO ssi                                                STATEMENT 1 ON LINE 11
set_severity_indicator: ssi: proc ();

000146  da     000113200000
000147  aa   000260 6270 00	eax7 	176
000150  aa  7 00034 3521 20	epp2 	pr7|28,*
000151  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000152  aa     000000000000
000153  aa     000000000000
000154  aa   000007 7100 04	tra  	7,ic		000163
ENTRY TO set_severity_indicator                             STATEMENT 1 ON LINE 11
set_severity_indicator: ssi: proc ();

000155  da     000116200000
000156  aa   000260 6270 00	eax7 	176
000157  aa  7 00034 3521 20	epp2 	pr7|28,*
000160  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000161  aa     000000000000
000162  aa     000000000000
						STATEMENT 1 ON LINE 84
	my_init_info.size = 1;

000163  aa   000001 2360 07	ldq  	1,dl
000164  aa  6 00117 7561 00	stq  	pr6|79		my_init_info.size
						STATEMENT 1 ON LINE 85
	my_init_info.type = TEMPLATE_INIT;

000165  aa   000003 2360 07	ldq  	3,dl
000166  aa  6 00120 7561 00	stq  	pr6|80		my_init_info.type
						STATEMENT 1 ON LINE 86
	my_init_info.init_template (1) = 0;

000167  aa  6 00121 4501 00	stz  	pr6|81		my_init_info.init_template
						STATEMENT 1 ON LINE 96
	call cu_$arg_count (nargs);

000170  aa  6 00105 3521 00	epp2 	pr6|69		nargs
000171  aa  6 00124 2521 00	spri2	pr6|84
000172  aa  6 00122 6211 00	eax1 	pr6|82
000173  aa   004000 4310 07	fld  	2048,dl
000174  la  4 00012 3521 20	epp2 	pr4|10,*		cu_$arg_count
000175  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 97
	if nargs ^= 2
	then do;

000176  aa  6 00105 2361 00	ldq  	pr6|69		nargs
000177  aa   000002 1160 07	cmpq 	2,dl
000200  aa   000033 6000 04	tze  	27,ic		000233
						STATEMENT 1 ON LINE 99
	     code = error_table_$wrong_no_of_args;

000201  aa  6 00044 3701 20	epp4 	pr6|36,*
000202  la  4 00024 2361 20	ldq  	pr4|20,*		error_table_$wrong_no_of_args
000203  aa  6 00104 7561 00	stq  	pr6|68		code
						STATEMENT 1 ON LINE 100
USAGE:	     call com_err_ (code, ME, "^/Usage:  ^a indicator_name indicator_value", ME);

000204  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000205  aa   777652 00 0054	desc9a	-86,44		000056 = 136057125163
000206  aa  6 00126 00 0054	desc9a	pr6|86,44
000207  aa  6 00104 3521 00	epp2 	pr6|68		code
000210  aa  6 00144 2521 00	spri2	pr6|100
000211  aa   777567 3520 04	epp2 	-137,ic		000000 = 163145164137
000212  aa  6 00146 2521 00	spri2	pr6|102
000213  aa  6 00126 3521 00	epp2 	pr6|86
000214  aa  6 00150 2521 00	spri2	pr6|104
000215  aa   777563 3520 04	epp2 	-141,ic		000000 = 163145164137
000216  aa  6 00152 2521 00	spri2	pr6|106
000217  aa   777604 3520 04	epp2 	-124,ic		000023 = 404000000043
000220  aa  6 00154 2521 00	spri2	pr6|108
000221  aa   777601 3520 04	epp2 	-127,ic		000022 = 526000000026
000222  aa  6 00156 2521 00	spri2	pr6|110
000223  aa  6 00162 2521 00	spri2	pr6|114
000224  aa   777575 3520 04	epp2 	-131,ic		000021 = 524000000053
000225  aa  6 00160 2521 00	spri2	pr6|112
000226  aa  6 00142 6211 00	eax1 	pr6|98
000227  aa   020000 4310 07	fld  	8192,dl
000230  la  4 00020 3521 20	epp2 	pr4|16,*		com_err_
000231  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 101
	     return;

000232  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 102
	end;

						STATEMENT 1 ON LINE 113
	call cu_$arg_ptr (1, arg_ptr, arg_len, code);

000233  aa   000001 2360 07	ldq  	1,dl
000234  aa  6 00141 7561 00	stq  	pr6|97
000235  aa  6 00141 3521 00	epp2 	pr6|97
000236  aa  6 00130 2521 00	spri2	pr6|88
000237  aa  6 00106 3521 00	epp2 	pr6|70		arg_ptr
000240  aa  6 00132 2521 00	spri2	pr6|90
000241  aa  6 00110 3521 00	epp2 	pr6|72		arg_len
000242  aa  6 00134 2521 00	spri2	pr6|92
000243  aa  6 00104 3521 00	epp2 	pr6|68		code
000244  aa  6 00136 2521 00	spri2	pr6|94
000245  aa  6 00126 6211 00	eax1 	pr6|86
000246  aa   020000 4310 07	fld  	8192,dl
000247  aa  6 00044 3701 20	epp4 	pr6|36,*
000250  la  4 00014 3521 20	epp2 	pr4|12,*		cu_$arg_ptr
000251  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 114
	if code ^= 0
	then do;

000252  aa  6 00104 2361 00	ldq  	pr6|68		code
000253  aa   000026 6000 04	tze  	22,ic		000301
						STATEMENT 1 ON LINE 116
	     call com_err_ (code, ME, "Cannot get argument #1.");

000254  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000255  aa   777561 00 0030	desc9a	-143,24		000035 = 103141156156
000256  aa  6 00126 00 0030	desc9a	pr6|86,24
000257  aa  6 00104 3521 00	epp2 	pr6|68		code
000260  aa  6 00144 2521 00	spri2	pr6|100
000261  aa   777517 3520 04	epp2 	-177,ic		000000 = 163145164137
000262  aa  6 00146 2521 00	spri2	pr6|102
000263  aa  6 00126 3521 00	epp2 	pr6|86
000264  aa  6 00150 2521 00	spri2	pr6|104
000265  aa   777536 3520 04	epp2 	-162,ic		000023 = 404000000043
000266  aa  6 00152 2521 00	spri2	pr6|106
000267  aa   777533 3520 04	epp2 	-165,ic		000022 = 526000000026
000270  aa  6 00154 2521 00	spri2	pr6|108
000271  aa   777527 3520 04	epp2 	-169,ic		000020 = 524000000027
000272  aa  6 00156 2521 00	spri2	pr6|110
000273  aa  6 00142 6211 00	eax1 	pr6|98
000274  aa   014000 4310 07	fld  	6144,dl
000275  aa  6 00044 3701 20	epp4 	pr6|36,*
000276  la  4 00020 3521 20	epp2 	pr4|16,*		com_err_
000277  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 117
	     return;

000300  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 118
	end;

						STATEMENT 1 ON LINE 119
	indicator_name = arg;

000301  aa  6 00106 3735 20	epp7 	pr6|70,*		arg_ptr
000302  aa  6 00110 7271 00	lxl7 	pr6|72		arg_len
000303  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
000304  aa  7 00000 00 0017	desc9a	pr7|0,x7		arg
000305  aa  6 00111 00 0026	desc9a	pr6|73,22		indicator_name
						STATEMENT 1 ON LINE 120
	if indicator_name ^= arg			/* name too long */
	then do;

000306  aa  040 140 106 500	cmpc 	(pr),(pr,rl),fill(040)
000307  aa  6 00111 00 0026	desc9a	pr6|73,22		indicator_name
000310  aa  7 00000 00 0017	desc9a	pr7|0,x7		arg
000311  aa   000043 6000 04	tze  	35,ic		000354
						STATEMENT 1 ON LINE 122
	     call com_err_ (error_table_$bigarg, ME,
		"^a^/The maximum length for a severity indicator name is ^d characters.",
		arg, length (indicator_name));

000312  aa  6 00110 2361 00	ldq  	pr6|72		arg_len
000313  aa   526000 2760 03	orq  	175104,du
000314  aa  6 00141 7561 00	stq  	pr6|97
000315  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000316  aa   777607 00 0110	desc9a	-121,72		000124 = 136141136057
000317  aa  6 00142 00 0110	desc9a	pr6|98,72
000320  aa   000026 2360 07	ldq  	22,dl
000321  aa  6 00164 7561 00	stq  	pr6|116
000322  aa  6 00044 3701 20	epp4 	pr6|36,*
000323  la  4 00026 3521 20	epp2 	pr4|22,*		error_table_$bigarg
000324  aa  6 00170 2521 00	spri2	pr6|120
000325  aa   777453 3520 04	epp2 	-213,ic		000000 = 163145164137
000326  aa  6 00172 2521 00	spri2	pr6|122
000327  aa  6 00142 3521 00	epp2 	pr6|98
000330  aa  6 00174 2521 00	spri2	pr6|124
000331  aa  7 00000 3521 00	epp2 	pr7|0		arg
000332  aa  6 00176 2521 00	spri2	pr6|126
000333  aa  6 00164 3521 00	epp2 	pr6|116
000334  aa  6 00200 2521 00	spri2	pr6|128
000335  aa   777466 3520 04	epp2 	-202,ic		000023 = 404000000043
000336  aa  6 00202 2521 00	spri2	pr6|130
000337  aa   777463 3520 04	epp2 	-205,ic		000022 = 526000000026
000340  aa  6 00204 2521 00	spri2	pr6|132
000341  aa   777456 3520 04	epp2 	-210,ic		000017 = 524000000106
000342  aa  6 00206 2521 00	spri2	pr6|134
000343  aa  6 00141 3521 00	epp2 	pr6|97
000344  aa  6 00210 2521 00	spri2	pr6|136
000345  aa   777450 3520 04	epp2 	-216,ic		000015 = 404000000005
000346  aa  6 00212 2521 00	spri2	pr6|138
000347  aa  6 00166 6211 00	eax1 	pr6|118
000350  aa   024000 4310 07	fld  	10240,dl
000351  la  4 00020 3521 20	epp2 	pr4|16,*		com_err_
000352  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 125
	     return;

000353  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 126
	end;

						STATEMENT 1 ON LINE 137
	call cu_$arg_ptr (2, arg_ptr, arg_len, code);

000354  aa   000002 2360 07	ldq  	2,dl
000355  aa  6 00141 7561 00	stq  	pr6|97
000356  aa  6 00141 3521 00	epp2 	pr6|97
000357  aa  6 00130 2521 00	spri2	pr6|88
000360  aa  6 00106 3521 00	epp2 	pr6|70		arg_ptr
000361  aa  6 00132 2521 00	spri2	pr6|90
000362  aa  6 00110 3521 00	epp2 	pr6|72		arg_len
000363  aa  6 00134 2521 00	spri2	pr6|92
000364  aa  6 00104 3521 00	epp2 	pr6|68		code
000365  aa  6 00136 2521 00	spri2	pr6|94
000366  aa  6 00126 6211 00	eax1 	pr6|86
000367  aa   020000 4310 07	fld  	8192,dl
000370  aa  6 00044 3701 20	epp4 	pr6|36,*
000371  la  4 00014 3521 20	epp2 	pr4|12,*		cu_$arg_ptr
000372  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 138
	if code ^= 0
	then do;

000373  aa  6 00104 2361 00	ldq  	pr6|68		code
000374  aa   000026 6000 04	tze  	22,ic		000422
						STATEMENT 1 ON LINE 140
	     call com_err_ (code, ME, "cannot get argument #2.");

000375  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000376  aa   777432 00 0030	desc9a	-230,24		000027 = 143141156156
000377  aa  6 00126 00 0030	desc9a	pr6|86,24
000400  aa  6 00104 3521 00	epp2 	pr6|68		code
000401  aa  6 00144 2521 00	spri2	pr6|100
000402  aa   777376 3520 04	epp2 	-258,ic		000000 = 163145164137
000403  aa  6 00146 2521 00	spri2	pr6|102
000404  aa  6 00126 3521 00	epp2 	pr6|86
000405  aa  6 00150 2521 00	spri2	pr6|104
000406  aa   777415 3520 04	epp2 	-243,ic		000023 = 404000000043
000407  aa  6 00152 2521 00	spri2	pr6|106
000410  aa   777412 3520 04	epp2 	-246,ic		000022 = 526000000026
000411  aa  6 00154 2521 00	spri2	pr6|108
000412  aa   777406 3520 04	epp2 	-250,ic		000020 = 524000000027
000413  aa  6 00156 2521 00	spri2	pr6|110
000414  aa  6 00142 6211 00	eax1 	pr6|98
000415  aa   014000 4310 07	fld  	6144,dl
000416  aa  6 00044 3701 20	epp4 	pr6|36,*
000417  la  4 00020 3521 20	epp2 	pr4|16,*		com_err_
000420  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 141
	     return;

000421  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 142
	end;

						STATEMENT 1 ON LINE 143
	my_init_info.init_template (1) = cv_dec_check_ (arg, code);

000422  aa  6 00110 2361 00	ldq  	pr6|72		arg_len
000423  aa   526000 2760 03	orq  	175104,du
000424  aa  6 00141 7561 00	stq  	pr6|97
000425  aa  6 00106 3521 20	epp2 	pr6|70,*		arg
000426  aa  6 00144 2521 00	spri2	pr6|100
000427  aa  6 00104 3521 00	epp2 	pr6|68		code
000430  aa  6 00146 2521 00	spri2	pr6|102
000431  aa  6 00121 3521 00	epp2 	pr6|81		my_init_info.init_template
000432  aa  6 00150 2521 00	spri2	pr6|104
000433  aa  6 00141 3521 00	epp2 	pr6|97
000434  aa  6 00152 2521 00	spri2	pr6|106
000435  aa   777366 3520 04	epp2 	-266,ic		000023 = 404000000043
000436  aa  6 00154 2521 00	spri2	pr6|108
000437  aa  6 00156 2521 00	spri2	pr6|110
000440  aa  6 00142 6211 00	eax1 	pr6|98
000441  aa   014000 4310 07	fld  	6144,dl
000442  aa  6 00044 3701 20	epp4 	pr6|36,*
000443  la  4 00010 3521 20	epp2 	pr4|8,*		cv_dec_check_
000444  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 144
	if code ^= 0				/* bad indicator value */
	then do;

000445  aa  6 00104 2361 00	ldq  	pr6|68		code
000446  aa   000026 6000 04	tze  	22,ic		000474
						STATEMENT 1 ON LINE 146
	     call com_err_ (error_table_$bad_arg, ME,
		"^/Severity indicator value must be a decimal integer.");

000447  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000450  aa   777437 00 0070	desc9a	-225,56		000106 = 136057123145
000451  aa  6 00142 00 0070	desc9a	pr6|98,56
000452  aa  6 00044 3701 20	epp4 	pr6|36,*
000453  la  4 00022 3521 20	epp2 	pr4|18,*		error_table_$bad_arg
000454  aa  6 00170 2521 00	spri2	pr6|120
000455  aa   777323 3520 04	epp2 	-301,ic		000000 = 163145164137
000456  aa  6 00172 2521 00	spri2	pr6|122
000457  aa  6 00142 3521 00	epp2 	pr6|98
000460  aa  6 00174 2521 00	spri2	pr6|124
000461  aa   777342 3520 04	epp2 	-286,ic		000023 = 404000000043
000462  aa  6 00176 2521 00	spri2	pr6|126
000463  aa   777337 3520 04	epp2 	-289,ic		000022 = 526000000026
000464  aa  6 00200 2521 00	spri2	pr6|128
000465  aa   777327 3520 04	epp2 	-297,ic		000014 = 524000000065
000466  aa  6 00202 2521 00	spri2	pr6|130
000467  aa  6 00166 6211 00	eax1 	pr6|118
000470  aa   014000 4310 07	fld  	6144,dl
000471  la  4 00020 3521 20	epp2 	pr4|16,*		com_err_
000472  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 148
	     return;

000473  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 149
	end;

						STATEMENT 1 ON LINE 162
	call set_ext_variable_ (rtrim (indicator_name) || "_severity_", addr (my_init_info), stackbaseptr (), found, node_ptr, code);

000474  aa  000 000 165 500	tctr 	(pr)
000475  aa  6 00111 00 0026	desc9a	pr6|73,22		indicator_name
000476  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
000477  aa  6 00056 0001 00	arg  	pr6|46
000500  aa  6 00056 2361 00	ldq  	pr6|46
000501  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
000502  aa  6 00164 7561 00	stq  	pr6|116
000503  aa   000026 2360 07	ldq  	22,dl
000504  aa  6 00164 1761 00	sbq  	pr6|116
000505  aa  6 00164 7561 00	stq  	pr6|116
000506  aa   000012 0760 07	adq  	10,dl
000507  aa  6 00165 7561 00	stq  	pr6|117
000510  aa   524000 2760 03	orq  	174080,du
000511  aa  6 00141 7561 00	stq  	pr6|97
000512  aa  6 00165 2361 00	ldq  	pr6|117
000513  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
000514  aa  6 00164 2351 00	lda  	pr6|116
000515  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000516  aa  6 00111 00 0005	desc9a	pr6|73,al		indicator_name
000517  aa  2 00000 00 0005	desc9a	pr2|0,al
000520  aa  040 105 100 404	mlr  	(ic),(pr,al),fill(040)
000521  aa   777304 00 0012	desc9a	-316,10		000024 = 137163145166
000522  aa  2 00000 00 0012	desc9a	pr2|0,10
000523  aa  6 00224 2521 00	spri2	pr6|148
000524  aa  6 00117 3735 00	epp7 	pr6|79		my_init_info
000525  aa  6 00216 6535 00	spri7	pr6|142
000526  aa  6 00000 3511 00	epbp1	pr6|0
000527  aa  6 00220 2515 00	spri1	pr6|144
000530  aa  6 00216 3521 00	epp2 	pr6|142
000531  aa  6 00226 2521 00	spri2	pr6|150
000532  aa  6 00220 3521 00	epp2 	pr6|144
000533  aa  6 00230 2521 00	spri2	pr6|152
000534  aa  6 00100 3521 00	epp2 	pr6|64		found
000535  aa  6 00232 2521 00	spri2	pr6|154
000536  aa  6 00102 3521 00	epp2 	pr6|66		node_ptr
000537  aa  6 00234 2521 00	spri2	pr6|156
000540  aa  6 00104 3521 00	epp2 	pr6|68		code
000541  aa  6 00236 2521 00	spri2	pr6|158
000542  aa  6 00141 3521 00	epp2 	pr6|97
000543  aa  6 00240 2521 00	spri2	pr6|160
000544  aa   777246 3520 04	epp2 	-346,ic		000012 = 464000000000
000545  aa  6 00242 2521 00	spri2	pr6|162
000546  aa  6 00244 2521 00	spri2	pr6|164
000547  aa  6 00250 2521 00	spri2	pr6|168
000550  aa   777241 3520 04	epp2 	-351,ic		000011 = 514000000001
000551  aa  6 00246 2521 00	spri2	pr6|166
000552  aa   777251 3520 04	epp2 	-343,ic		000023 = 404000000043
000553  aa  6 00252 2521 00	spri2	pr6|170
000554  aa  6 00222 6211 00	eax1 	pr6|146
000555  aa   030000 4310 07	fld  	12288,dl
000556  aa  6 00044 3701 20	epp4 	pr6|36,*
000557  la  4 00016 3521 20	epp2 	pr4|14,*		set_ext_variable_
000560  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 163
	if code ^= 0
	then do;

000561  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
000562  aa  6 00104 2361 00	ldq  	pr6|68		code
000563  aa   000031 6000 04	tze  	25,ic		000614
						STATEMENT 1 ON LINE 165
	     call com_err_ (code, ME, "^/Error setting the severity indicator ^a.", indicator_name);

000564  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000565  aa   777257 00 0054	desc9a	-337,44		000043 = 136057105162
000566  aa  6 00126 00 0054	desc9a	pr6|86,44
000567  aa  6 00104 3521 00	epp2 	pr6|68		code
000570  aa  6 00144 2521 00	spri2	pr6|100
000571  aa   777207 3520 04	epp2 	-377,ic		000000 = 163145164137
000572  aa  6 00146 2521 00	spri2	pr6|102
000573  aa  6 00126 3521 00	epp2 	pr6|86
000574  aa  6 00150 2521 00	spri2	pr6|104
000575  aa  6 00111 3521 00	epp2 	pr6|73		indicator_name
000576  aa  6 00152 2521 00	spri2	pr6|106
000577  aa   777224 3520 04	epp2 	-364,ic		000023 = 404000000043
000600  aa  6 00154 2521 00	spri2	pr6|108
000601  aa   777221 3520 04	epp2 	-367,ic		000022 = 526000000026
000602  aa  6 00156 2521 00	spri2	pr6|110
000603  aa  6 00162 2521 00	spri2	pr6|114
000604  aa   777204 3520 04	epp2 	-380,ic		000010 = 524000000052
000605  aa  6 00160 2521 00	spri2	pr6|112
000606  aa  6 00142 6211 00	eax1 	pr6|98
000607  aa   020000 4310 07	fld  	8192,dl
000610  aa  6 00044 3701 20	epp4 	pr6|36,*
000611  la  4 00020 3521 20	epp2 	pr4|16,*		com_err_
000612  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 166
	     return;

000613  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 167
	end;

						STATEMENT 1 ON LINE 168
	if found					/* in this case we must reset the indicator */
	then do;

000614  aa  6 00100 2351 00	lda  	pr6|64		found
000615  aa   400000 3150 03	cana 	131072,du
000616  aa   000041 6000 04	tze  	33,ic		000657
						STATEMENT 1 ON LINE 170
	     if node_ptr -> variable_node.vbl_size ^= 1
	     then do;

000617  aa  6 00102 3735 20	epp7 	pr6|66,*		node_ptr
000620  aa  7 00001 2351 00	lda  	pr7|1		variable_node.vbl_size
000621  aa   000060 7730 00	lrl  	48
000622  aa   000001 1160 07	cmpq 	1,dl
000623  aa   000032 6000 04	tze  	26,ic		000655
						STATEMENT 1 ON LINE 172
		call com_err_ (0b, ME, "Severity indicator ^a is not a single word variable.", indicator_name);

000624  aa  6 00141 4501 00	stz  	pr6|97
000625  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000626  aa   777244 00 0064	desc9a	-348,52		000071 = 123145166145
000627  aa  6 00142 00 0064	desc9a	pr6|98,52
000630  aa  6 00141 3521 00	epp2 	pr6|97
000631  aa  6 00170 2521 00	spri2	pr6|120
000632  aa   777146 3520 04	epp2 	-410,ic		000000 = 163145164137
000633  aa  6 00172 2521 00	spri2	pr6|122
000634  aa  6 00142 3521 00	epp2 	pr6|98
000635  aa  6 00174 2521 00	spri2	pr6|124
000636  aa  6 00111 3521 00	epp2 	pr6|73		indicator_name
000637  aa  6 00176 2521 00	spri2	pr6|126
000640  aa   777147 3520 04	epp2 	-409,ic		000007 = 404000000001
000641  aa  6 00200 2521 00	spri2	pr6|128
000642  aa   777160 3520 04	epp2 	-400,ic		000022 = 526000000026
000643  aa  6 00202 2521 00	spri2	pr6|130
000644  aa  6 00206 2521 00	spri2	pr6|134
000645  aa   777141 3520 04	epp2 	-415,ic		000006 = 524000000064
000646  aa  6 00204 2521 00	spri2	pr6|132
000647  aa  6 00166 6211 00	eax1 	pr6|118
000650  aa   020000 4310 07	fld  	8192,dl
000651  aa  6 00044 3701 20	epp4 	pr6|36,*
000652  la  4 00020 3521 20	epp2 	pr4|16,*		com_err_
000653  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 173
		return;

000654  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 174
	     end;

						STATEMENT 1 ON LINE 175
	     node_ptr -> variable_node.vbl_ptr -> severity_indicator = my_init_info.init_template (1);

000655  aa  6 00121 2361 00	ldq  	pr6|81		my_init_info.init_template
000656  aa  7 00004 7561 20	stq  	pr7|4,*		severity_indicator
						STATEMENT 1 ON LINE 176
	end;

						STATEMENT 1 ON LINE 178
	return;

000657  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 185
     end set_severity_indicator;

  END PROCEDURE ssi


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
