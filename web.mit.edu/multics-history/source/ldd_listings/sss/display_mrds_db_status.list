	COMPILATION LISTING OF SEGMENT display_mrds_db_status
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/23/86  1014.1 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 
       19 
       20 display_mrds_db_status: dmdbs: proc;
       21 
       22 
       23 /*
       24*   .                       BEGIN_DESCRIPTION
       25*   This commands provides the DBA with  (semi)  current  information
       26*   about  the  status  of a data base obtained from the dbc segment.
       27*   The information about dead processes reflects status  as  of  the
       28*   last time the data base was opened.
       29*   .                       END_DESCRIPTION
       30**/
       31 
       32 /*
       33*   .                       HISTORY
       34*   Written by Oris Friesen, Summer 1978.
       35*
       36*   Modified by Al Kepner, Feb  14,  1979  to  improve  diagnosis  of
       37*   invalid control arguments.
       38*
       39*   Modified by Al Kepner, Feb 14, 1979 to  accomodate  MR7.0  fscope
       40*   mechanism.
       41*
       42*   Modified by Jim Gray - - 21-June-80, to return no model,  instead
       43*   of no model/submodl error message.
       44*
       45*   80-12-08 Jim Gray : changed scope  mode  display  to  handle  r-u
       46*   modes   for   version   4   dbc,  and  new  read/modify_attr  and
       47*   append/delete_tuple  modes  for  version  5  dbc   and   fil_list
       48*   structures.  It  also  can  now  get a pointer to either "dbc" or
       49*   "db,control" named segment for finding the dbc structure. This is
       50*   done   via   the  new  mu_concurrency_control$get_control_segment
       51*   routine. Also added dbc structure version to header output.
       52*
       53*   80-12-12 Jim Gray : Improved control  arg  information  in  usage
       54*   message.
       55*
       56*   81-01-31      Jim      Gray      :       added       use       of
       57*   mrds_dsl_get_version$get_path_info,  and new interface overcoming
       58*   short comings of the dsl_$get_db_version interface.
       59*
       60*   81-02-03 Jim Gray :  changed  format  of  output  display  to  be
       61*   arranged with the colons columnized for easier reading.
       62*
       63*   81-02-04 Jim Gray : made default display  equivalent  to  Lindsey
       64*   Spratt's  -terse  option,  that displays things that are not in a
       65*   normal state, with info inbetween the -brief and -long option.
       66*
       67*   81-02-11 Jim Gray : extended, to allow submodel paths to be given
       68*   to this command, in which case, the actual db path is gotten from
       69*   the submodel header, and only the relations in the submodel  view
       70*   have their scope modes shown.
       71*
       72*   81-02-12 Jim Gray : added check to see that when the database  is
       73*   in  the  secured  state,  that if the user is not a DBA, that his
       74*   path given is to a submodel residing in the  submodel  dir  under
       75*   the database.
       76*
       77*   81-06-03 Davids: changed the  calls  of  mrds_dsm_dsmd$*  to  the
       78*   appropriate mrds_dsm_* calls, also changed the corresponding data
       79*   structures (user interface to internal mrds interface).  Modified
       80*   the  call  dmdbs_v1 to occur only if the input path was that of a
       81*   version 3 datamodel and to report an error if it was a  submodel,
       82*   (v1   does   not  support  submodels).  Removed  declarations  of
       83*   unreferenced variables.
       84*
       85*   82-05-07 Woodka: Changed to indicate if database is inconsistent,
       86*   and give an appropriate error message. Changed to indicate if the
       87*   trouble switch is set.
       88*
       89*   82-07-01  Roger Lackey : Modified the calls to mu_db_inconsistent to use
       90*   mdbm_util_$inconsistent_* for binding.
       91*
       92*   83-06-21 Davids: Removed check for old version database and the call
       93*   to v1 code if it was an old version db (old version dbs can no longer
       94*   be opened)
       95**/
       96 
       97 	num_filns = 0;
       98 	user_flag, proc_flag, brief_flag, long_flag = "0"b;
       99 
      100 /* BEGIN CHANGE 81-02-11 ********************************************** */
      101 
      102 	submodel_open, db_model_open = "0"b;
      103 	area_ptr = null ();
      104 
      105 	on cleanup call clean_up ();
      106 
      107 	call get_temp_segment_ (caller_name, area_ptr, code);
      108 	if code ^= 0 then do;
      109 		area_ptr = null ();
      110 		call clean_up ();
      111 		call com_err_ (code, caller_name, "^/^a",
      112 		     "Unable to get a temporary segment.");
      113 		return;
      114 	     end;
      115 
      116 	area_ptr -> work_area = empty ();
      117 
      118 /* END CHANGE 81-02-11 ********************************************** */
      119 
      120 	call cu_$arg_count (nargs);
      121 
      122 	if nargs < 1 then do;
      123 		call com_err_ (0, caller_name,
      124 		     "^/Usage:  display_mrds_db_status db_path {-bf|-lg} {-proc_id PID|-user PERSON}");
      125 		call clean_up ();
      126 		return;
      127 
      128 	     end;
      129 
      130 	db_dir = copy (" ", 168);
      131 	call cu_$arg_ptr (1, dbp_ptr, dbp_len, code);	/* get data base path */
      132 	if code ^= 0 then do;
      133 		call com_err_ (code, caller_name, "data base pathname");
      134 						/* exit with com_err_ message */
      135 		call clean_up ();
      136 		return;
      137 
      138 	     end;
      139 
      140 /* BEGIN CHANGE 81-01-31 *************************************************** */
      141 
      142 	in_path = dbp;
      143 	call mrds_dsl_get_version$get_path_info (in_path, area_ptr,
      144 	     mrds_path_info_structure_version, mrds_path_info_ptr, code);
      145 
      146 	if mrds_path_info_ptr = null () then
      147 	     db_path = in_path;
      148 	else db_path = mrds_path_info.absolute_path;
      149 
      150 	if code ^= 0 then do;
      151 		if code = mrds_error_$no_model_submodel then
      152 		     code = mrds_error_$no_database;
      153 		call com_err_ (code, caller_name, "^/^a", dbp);
      154 		call clean_up ();
      155 		return;
      156 
      157 	     end;
      158 
      159 /* BEGIN CHANGE 81-02-11 **************************************************** */
      160 
      161 	submodel = "0"b;
      162 	if mrds_path_info.type.submodel then do;
      163 
      164 /* if submodel path given, need to get real db path,
      165*   then a list of relations available in this view of the db */
      166 
      167 		sm_abs_path = db_path;
      168 
      169 		call mrds_dsm_open$read (sm_abs_path, submodel_iocb_ptr, code);
      170 						/* path is really to submodel */
      171 		if code ^= 0 then do;
      172 			call com_err_ (code, caller_name, "^/^a ^a",
      173 			     "Unable to open the submodel:", sm_abs_path);
      174 			call clean_up ();
      175 			return;
      176 
      177 		     end;
      178 
      179 		submodel_open = "1"b;		/* remember, so clean up can close */
      180 
      181 /* now get the real db path from the submodel header */
      182 
      183 		call mrds_dsm_read_header$db_path (submodel_iocb_ptr, db_path, code);
      184 		if code ^= 0 then do;
      185 			call com_err_ (code, caller_name, "^/^a ^a",
      186 			     "Unable to get the header for the submodel:", sm_abs_path);
      187 			call clean_up ();
      188 			return;
      189 
      190 		     end;
      191 
      192 		call mrds_dsm_get_relation_names (area_ptr, mrds_dsm_relation_names_ptr, submodel_iocb_ptr, code);
      193 		if code ^= 0 then do;
      194 			call com_err_ (code, caller_name, "^/^a ^a",
      195 			     "Unable to get the list for relations for the submodel:", sm_abs_path);
      196 			call clean_up ();
      197 			return;
      198 		     end;
      199 
      200 /* get the details on the real db */
      201 
      202 		call mrds_dsl_get_version$get_path_info (db_path, area_ptr,
      203 		     mrds_path_info_structure_version, mrds_path_info_ptr, code);
      204 		if mrds_path_info_ptr = null () then ;
      205 		else db_path = mrds_path_info.absolute_path;
      206 
      207 		if code ^= 0 then do;
      208 			call com_err_ (code, caller_name, "^/^a ^a",
      209 			     "Unable to get information on the database path:", db_path);
      210 			call clean_up ();
      211 			return;
      212 
      213 		     end;
      214 
      215 		submodel = "1"b;			/* rememeber we started with a submodel */
      216 
      217 	     end;
      218 
      219 /* END CHANGE 81-02-11 **************************************************** */
      220 
      221 /* END CHANGE 81-01-31 ***************************************************** */
      222 
      223 /* BEGIN CHANGE 81-02-12 *************************************************** */
      224 
      225 /* check for a secured database */
      226 
      227 	call mrds_dm_open (db_path, 2 /* retrieval mode */,
      228 	     data_model_ptr, code);
      229 	if code ^= 0 then do;
      230 		call com_err_ (code, caller_name, "^/^a ^a",
      231 		     "Unable to open the data model for database:", db_path);
      232 		call clean_up ();
      233 		return;
      234 	     end;
      235 
      236 	db_model_open = "1"b;			/* remember for clean up */
      237 
      238 	call mrds_dm_db_secured$get_secured_status (data_model_ptr, area_ptr,
      239 	     database_state_structure_version, database_state_ptr, code);
      240 	if code ^= 0 then do;
      241 		call com_err_ (code, caller_name, "^/^a ^a",
      242 		     "Unable to get the secured state for the database:", db_path);
      243 		call clean_up ();
      244 		return;
      245 	     end;
      246 
      247 	if ^database_state.secured then ;
      248 	else do;
      249 
      250 /* secure database, check the user class - DBA or peon */
      251 
      252 		call mrds_dm_authorization$get_user_class (rtrim (db_path), area_ptr,
      253 		     mrds_authorization_structure_version, mrds_authorization_ptr, code);
      254 		if code ^= 0 then do;
      255 			call com_err_ (code, caller_name, "^/^a ^a",
      256 			     "Unable to get the user class for the database:", db_path);
      257 			call clean_up ();
      258 			return;
      259 		     end;
      260 
      261 		if mrds_authorization.administrator then ;
      262 		else do;
      263 
      264 /* user is a peon, not a DBA, check that he is using a secured submodel */
      265 
      266 			if ^submodel then
      267 			     secured_submodel = "0"b;
      268 			else do;			/* submodel path given */
      269 
      270 				call expand_pathname_ (sm_abs_path, sm_dir, sm_name, code);
      271 				if code ^= 0 then do;
      272 					call com_err_ (code, caller_name, "^/^a ^a",
      273 					     "Unable to expand the submodel pathname:", sm_abs_path);
      274 					call clean_up ();
      275 					return;
      276 				     end;
      277 
      278 				secured_submodel = mrds_dm_secured_submodel (db_path, sm_dir, sm_name);
      279 
      280 			     end;
      281 
      282 /* not secured submodel, tell user and get out */
      283 
      284 			if ^secured_submodel then do;
      285 				if ^submodel then
      286 				     call com_err_ (mrds_error_$inc_secure_open, caller_name, "^/^a^a^a ^a",
      287 					"The database """, db_path, """ has been secured,",
      288 					"but the caller is not a DBA, and must use a submodel to reference it.");
      289 				else call com_err_ (mrds_error_$inc_secure_open, caller_name, "^/^a^a^a^a^a  ^a^a^a",
      290 					"The submodel """, sm_abs_path, """ refers to a database """,
      291 					db_path, """ that has been secured,",
      292 					"but the submodel itself is not in the databases inferior directory """,
      293 					mrds_data_$submodel_dir_name, """.");
      294 
      295 				call clean_up ();
      296 				return;
      297 			     end;
      298 
      299 		     end;
      300 
      301 	     end;
      302 
      303 /* END CHANGE 81-02-12 ************************************************* */
      304 
      305 	call expand_pathname_ (db_path, db_dir, db_ent, code);
      306 	if code ^= 0
      307 	then do;
      308 		call com_err_ (code, caller_name, "^a", dbp);
      309 						/* call clean_up () ;
      310*						   return to command level */ call clean_up ();
      311 		return;
      312 
      313 	     end;
      314 
      315 	if length (rtrim (db_path)) > 164
      316 	then do;
      317 		call com_err_ (error_table_$pathlong, caller_name, "^a", db_path);
      318 		call clean_up ();
      319 		return;
      320 
      321 	     end;
      322 
      323 	if nargs >= 2 then do;
      324 
      325 		call cu_$arg_ptr (2, arg_ptr, arg_len, code);
      326 		if arg = "-brief" | arg = "-bf"
      327 		then brief_flag = "1"b;
      328 
      329 		else if arg = "-long" | arg = "-lg"
      330 		then long_flag = "1"b;
      331 
      332 		else if arg = "-proc_id" | arg = "-pid"
      333 		then proc_flag = "1"b;
      334 
      335 		else if arg = "-user"
      336 		then user_flag = "1"b;
      337 		else do;
      338 			call com_err_ (error_table_$badopt, caller_name, """^a""", arg);
      339 			call clean_up ();
      340 			return;
      341 
      342 		     end;
      343 	     end;
      344 
      345 	call mu_concurrency_control$get_control_segment (db_path, dbc_ptr, dbc_bit_count, code);
      346 	if code ^= 0 then do;
      347 		call com_err_ (code, caller_name, "^/^a", "Unable to get a pointer to the database control segment.");
      348 		call clean_up ();
      349 		return;
      350 
      351 	     end;
      352 
      353 
      354 	call mdbm_util_$inconsistent_get_info (data_model_ptr, incon_value, incon_name, incon_message, undo_request);
      355 						/* get consistency information */
      356 
      357 
      358 	hdr.message = incon_message;
      359 						/* set inconsistency message */
      360 	if hdr.message = " "
      361 	then hdr.message = "No reason for the inconsistency was given ";
      362 
      363 	if ^user_flag & ^proc_flag
      364 	then call db_report;			/* report is driven by contents of data base control segment */
      365 	else call user_report;			/* report is driven by user name or by process id...
      366*						   either of which are supplied by command string */
      367 
      368 	call clean_up ();
      369 
      370 
      371 
      372 
      373 	return;
      374 db:  entry;
      375 	dcl     dbs		 bit (1) int static init ("0"b);
      376 	dbs = ^dbs;
      377 	return;
      378 
      379 db_report: proc;
      380 
      381 	hdr.dbp = db_path;
      382 	if long_flag then
      383 	     call ioa_ ("^/Concurrency control version:  ^d", dbc.version);
      384 	call ioa_ ("^13xData base path:  ^a", hdr.dbp);
      385 	if long_flag then
      386 	     call ioa_ ("^20xVersion:  ^d", mrds_path_info.mrds_version);
      387 	if incon_value then
      388 	     hdr.state = "Inconsistent";
      389 	else hdr.state = "Consistent";
      390 	if long_flag | incon_value then
      391 	     call ioa_ ("^22xState:  ^a", hdr.state);
      392 	if incon_value then
      393 	     call ioa_ ("^21xReason:  ^a", hdr.message);
      394 
      395 	if dbc.trouble_switch then
      396 	     hdr.switch = "trouble switch on";
      397 	else hdr.switch = "trouble switch off";
      398 	if long_flag | dbc.trouble_switch then
      399 	     call ioa_ ("^13xTrouble Switch:  ^a", hdr.switch);
      400 
      401 
      402 	if dbc.quiesce_sw | dbc.quiesce_db | dbc.quiesce_files
      403 	then do;
      404 		go to quiesce_case (fixed (substr (string (dbc.flags), 3, 3)));
      405 quiesce_case (1):	;
      406 		call ioa_$nnl ("^30xQuiesce request queued for selected files");
      407 		goto end_quiesce_case;
      408 
      409 quiesce_case (2):	;
      410 		call ioa_$nnl ("^30xQuiesce request queued");
      411 		goto end_quiesce_case;
      412 
      413 quiesce_case (3):	;
      414 		call ioa_$nnl ("^30xInvalid combination of quiesce flags");
      415 		goto end_quiesce_case;
      416 
      417 quiesce_case (4):	;
      418 		call ioa_$nnl ("^30xInvalid combination of quiesce flags");
      419 		goto end_quiesce_case;
      420 
      421 quiesce_case (5):	;
      422 		call ioa_$nnl ("^30xData base is quiesced for selected files");
      423 		goto end_quiesce_case;
      424 
      425 quiesce_case (6):	;
      426 		call ioa_$nnl ("^30xData base is quiesced");
      427 		goto end_quiesce_case;
      428 
      429 quiesce_case (7):	;
      430 		call ioa_$nnl ("^30xInvalid combination of quiesce flags");
      431 		goto end_quiesce_case;
      432 
      433 end_quiesce_case:	;
      434 		if live_process (dbc.quiesce_lock) | (dbc.quiesce_lock = "0"b)
      435 		then call ioa_ (".");
      436 		else call ioa_ (" by a dead process.");
      437 		if dbs then do;
      438 			call ioa_ ("db: Quiesce lock_id = ^12o", fixed (dbc.quiesce_lock));
      439 		     end;
      440 	     end;
      441 	if dbc.dead_proc_flag
      442 	then call ioa_ ("^15xAvailability:  Active scope set by dead process");
      443 	hdr.nopen = dbc.open_users;
      444 	call ioa_ ("^17xOpen users:  ^d", hdr.nopen);
      445 	if dbc.open_users > 0 then do;
      446 		hdr.nact = dbc.active_users;
      447 		hdr.npact = dbc.wakeup_waiters;
      448 		hdr.nwait = dbc.waiting_users;
      449 
      450 		call ioa_ ("^/^16xScope users:  ^d  Active", hdr.nact);
      451 		if long_flag | hdr.npact > 0 then
      452 		     call ioa_ ("^30x^d  Awakening", hdr.npact);
      453 		if long_flag | hdr.nwait > 0 then
      454 		     call ioa_ ("^30x^d  Queued", hdr.nwait);
      455 	     end;
      456 	if ^brief_flag | long_flag then do;
      457 
      458 		ul_ptr = convert (dbc_ptr, dbc.open_users_ofs);
      459 
      460 		do idx = 1 to hdr.nopen while (ul_ptr ^= null);
      461 		     call do_user;
      462 		     ul_ptr = convert (dbc_ptr, user_list.next_open_ofs);
      463 		end;
      464 	     end;
      465      end db_report;
      466 
      467 user_report: proc;
      468 
      469 /* this report format is driven by user supplied arguments
      470*   consisting of user names and/or process ids
      471**/
      472 
      473 
      474 	arg_count = 3;
      475 	do while (arg_count <= nargs);
      476 
      477 	     call cu_$arg_ptr (arg_count, arg_ptr, arg_len, code);
      478 	     if code ^= 0 then do;
      479 		     call com_err_ (code, caller_name, "argument nbr ^d", arg_count);
      480 		     call clean_up ();
      481 		     return;
      482 
      483 		end;
      484 
      485 	     if user_flag then do;
      486 		     found = "0"b;
      487 		     comp_len = index (arg, "*") - 1;	/* eliminate anything following and including an asterisk */
      488 		     if comp_len <= 0 then comp_len = arg_len;
      489 		     ul_ptr = convert (dbc_ptr, dbc.open_users_ofs);
      490 
      491 		     comp_ptr = addr (user_list.group_id);
      492 		     do while (ul_ptr ^= null);
      493 			if before (arg, "*") = addr (user_list.group_id) -> comp_string
      494 			then do;
      495 				call do_user;
      496 				found = "1"b;
      497 			     end;
      498 
      499 			ul_ptr = convert (dbc_ptr, user_list.next_open_ofs);
      500 		     end;
      501 
      502 		     if ^found then do;
      503 			     call com_err_ (mrds_error_$user_not_found, caller_name, "^a", arg);
      504 			     call clean_up ();
      505 			     return;
      506 
      507 			end;
      508 
      509 		end;				/* end of processing for a given user name */
      510 	     else if proc_flag then do;
      511 		     found = "0"b;
      512 		     call ascii_to_bit (arg, bit_var);	/* convert process id from ascii string to bit string */
      513 		     ul_ptr = convert (dbc_ptr, dbc.open_users_ofs);
      514 		     do while (ul_ptr ^= null & ^found);/* halt after first one is found...
      515*						   cannot be duplicate process ids */
      516 			if bit_var = user_list.process_id then do;
      517 				call do_user;
      518 				found = "1"b;
      519 			     end;
      520 			ul_ptr = convert (dbc_ptr, user_list.next_open_ofs);
      521 		     end;
      522 
      523 		     if ^found then do;
      524 			     call com_err_ (mrds_error_$process_not_found, caller_name, "^a", arg);
      525 			     call clean_up ();
      526 			     return;
      527 
      528 			end;
      529 		end;				/* end of processing for a given process id */
      530 
      531 	     else do;
      532 		     call com_err_ (error_table_$badopt, caller_name, "^a", "control arg");
      533 		     call clean_up ();
      534 		     return;
      535 
      536 		end;
      537 
      538 	     ok = "0"b;
      539 	     if arg_count < nargs then do while (^ok);
      540 						/* get next control arg */
      541 		     call cu_$arg_ptr (arg_count + 1, arg_ptr, arg_len, code);
      542 		     if code ^= 0 then do;
      543 			     call com_err_ (code, caller_name, "^a", "control arg");
      544 			     call clean_up ();
      545 			     return;
      546 
      547 			end;
      548 
      549 		     if arg = "-bf" | arg = "-brief" | arg = "-lg" | arg = "-long"
      550 		     then arg_count = arg_count + 1;	/* ignore */
      551 		     else ok = "1"b;
      552 		end;
      553 	     if arg_count >= nargs then return;
      554 	     if arg = "-user" then do;
      555 		     user_flag = "1"b;
      556 		     proc_flag = "0"b;
      557 		end;
      558 	     else if arg = "-proc_id" | arg = "-pid" then do;
      559 		     proc_flag = "1"b;
      560 		     user_flag = "0"b;
      561 		end;
      562 	     else do;
      563 		     call com_err_ (error_table_$badopt, caller_name, """^a""", arg);
      564 		     call clean_up ();
      565 		     return;
      566 
      567 		end;
      568 	     arg_count = arg_count + 2;
      569 
      570 /* now go back up and get a name */
      571 	end;
      572 						/* have reached end of command string */
      573 
      574      end user_report;
      575 
      576 do_user: proc;
      577 
      578 	usr.id = user_list.group_id;
      579 	call ioa_ ("^/^12xUser process id:  ^a", usr.id);
      580 	call bit_to_ascii (user_list.process_id, usr.pid);
      581 	if long_flag | user_flag | proc_flag then
      582 	     call ioa_ ("^13xProcess number:  ^a", usr.pid);
      583 	if ^brief_flag then do;
      584 		if user_list.dead_proc
      585 		then usr.state = "Dead";
      586 		else if live_process (user_list.db_lock_id)
      587 		then usr.state = "Alive";
      588 		else usr.state = "Dead";
      589 		if long_flag | user_flag | proc_flag | usr.state = "Dead" then
      590 		     call ioa_ ("^14xProcess state:  ^a", usr.state);
      591 		usr.mode = "";
      592 		if user_list.open_mode = mdbm_data_$normal_mode then usr.mode = "Normal";
      593 		else if user_list.open_mode = mdbm_data_$quiesce_mode then usr.mode = "Quiesce";
      594 		if long_flag | user_flag | proc_flag | usr.mode ^= "Normal" then
      595 		     call ioa_ ("^17xUsage mode:  ^a", usr.mode);
      596 		if dbs then do;
      597 			call ioa_ ("db: lock_id = ^12o", fixed (user_list.db_lock_id));
      598 			call ioa_ ("db: ul_ptr = ^p", ul_ptr);
      599 		     end;
      600 
      601 		if user_list.open_mode < 3 then do;	/* only for shared openings */
      602 			if user_list.active_sw then do;
      603 				usr.scope = "Active";
      604 				if user_list.queue_activ then usr.activate = "Queue";
      605 				else usr.activate = "Normal";
      606 				if long_flag | user_flag | proc_flag then
      607 				     call ioa_ ("^22xScope:  ^a", usr.scope);
      608 				if long_flag | user_flag | proc_flag | usr.activate = "Queue" then
      609 				     call ioa_ ("^17xActivation:  ^a", usr.activate);
      610 			     end;
      611 
      612 			else if user_list.waiting_sw then do;
      613 				usr.scope = "Waiting";
      614 				if user_list.priority_high then usr.pri = "High";
      615 				else pri = "Normal";
      616 				usr.allow = user_list.allowance_count;
      617 				usr.bypass = user_list.bypass_count;
      618 				call ioa_ ("^22xScope:  ^a", usr.scope);
      619 				call ioa_ ("^19xPriority:  ^a", usr.pri);
      620 				if user_list.dead_proc_conflict
      621 				then call ioa_ ("^13xConflict state:  Blocked by dead process");
      622 
      623 				call ioa_ ("^12xAllowance count:  ^d", usr.allow);
      624 				call ioa_ ("^15xBypass count:  ^d", usr.bypass);
      625 			     end;
      626 
      627 			else if long_flag | user_flag | proc_flag then do;
      628 						/* no scope is currently in effect and none has been requested */
      629 				usr.scope = "None";
      630 				call ioa_ ("^22xScope:  ^a", usr.scope);
      631 			     end;
      632 		     end;
      633 
      634 		if user_list.open_mode < 3 then do;	/* only for shared openings */
      635 
      636 			if ^submodel then do;
      637 
      638 				fl_ptr = convert (dbc_ptr, user_list.fil_list_ofs);
      639 
      640 				if fl_ptr ^= null () then do;
      641 					call ioa_ ("^/^19xRelation^27xPermits^3xPrevents^/");
      642 				     end;
      643 
      644 				do while (fl_ptr ^= null);
      645 				     fila.name = fil_list.name;
      646 				     call display_permits_prevents ();
      647 
      648 				     fl_ptr = convert (dbc_ptr, fil_list.next_ofs);
      649 				end;
      650 			     end;
      651 
      652 /* BEGIN CHANGE 81-02-11 *************************************************** */
      653 
      654 			else do;			/* submodel path supplied, only show relations in users view */
      655 
      656 /* look up each relation in the submodel view, in the dbc relation list */
      657 
      658 				code = 0;
      659 				header_output = "0"b;
      660 				do i = 1 to mrds_dsm_relation_names.nrels while (code = 0);
      661 
      662 /* get the model name for this submodel relation */
      663 
      664 				     call mrds_dsm_read_relation (mrds_dsm_relation_names.relation (i),
      665 					area_ptr, str_ptr, submodel_iocb_ptr, code);
      666 				     if code ^= 0 then do;
      667 					     call com_err_ (code, caller_name, "^/^a ^a",
      668 						"Unable to get the model name for submodel relation:",
      669 						mrds_dsm_relation_names.relation (i));
      670 					     call clean_up ();
      671 					     return;
      672 					end;
      673 
      674 /* find the relation in the scope list */
      675 
      676 				     done = "0"b;
      677 				     fl_ptr = convert (dbc_ptr, user_list.fil_list_ofs);
      678 				     do while (^done);
      679 					if fl_ptr = null () then
      680 					     done = "1"b;
      681 					else if fil_list.name = str_ptr -> relation_block.dm_rel_name then
      682 					     done = "1"b;
      683 					else fl_ptr = convert (dbc_ptr, fil_list.next_ofs);
      684 
      685 				     end;
      686 
      687 				     if fl_ptr = null () then ; /* scope not set for this rel */
      688 				     else do;
      689 
      690 /* output the scope display, using the submodel name */
      691 
      692 					     fila.name = mrds_dsm_relation_names.relation (i);
      693 
      694 					     if header_output then ;
      695 					     else do;
      696 						     header_output = "1"b;
      697 						     call ioa_ ("^/^19xRelation^27xPermits^3xPrevents^/");
      698 						end;
      699 
      700 					     call display_permits_prevents ();
      701 
      702 					end;
      703 
      704 				end;
      705 
      706 
      707 			     end;
      708 
      709 		     end;
      710 
      711 /* END CHANGE 81-02-11 ******************************************************* */
      712 
      713 	     end;
      714      end do_user;
      715 
      716 display_permits_prevents: procedure ();
      717 
      718 /* routine to display permitted/prevented scope modes for this file/relation,
      719*   with the  modes presented based on the version of the dbc structure */
      720 
      721 	permit_string, prevent_string = "";		/* init */
      722 
      723 	if dbc.version ^= 4 & dbc.version ^= 5 then do;
      724 		call com_err_ (mrds_error_$version_not_supported, caller_name,
      725 		     "^/^a ^d", "Unknown database control segment version =", dbc.version);
      726 		call clean_up ();
      727 		return;
      728 
      729 	     end;
      730 
      731 	else if dbc.version = 4 then do;
      732 
      733 /* old r-u mode version dbc permits */
      734 
      735 		if fil_list.permits.read_attr then
      736 		     permit_string = "r";
      737 		if fil_list.permits.update then
      738 		     permit_string = permit_string || "u";
      739 		if permit_string = "" then
      740 		     permit_string = "n";
      741 
      742 /* r-u prevents */
      743 
      744 		if fil_list.prevents.read_attr then
      745 		     prevent_string = "r";
      746 		if fil_list.prevents.update then
      747 		     prevent_string = prevent_string || "u";
      748 		if prevent_string = "" then
      749 		     prevent_string = "n";
      750 
      751 	     end;
      752 
      753 /* for version 5 dbc structures, display the new form of the r-s-m-d scope modes
      754*   These are now read_attr-append_tuple-modify_attr-delete_tuple, in order
      755*   to be consistent with the submodel security MRDS acl keywords. */
      756 
      757 	else do;					/* new version 5 dbc, r-s-m-d modes */
      758 
      759 		if fil_list.permits.read_attr then
      760 		     permit_string = permit_string || "r";
      761 
      762 		if fil_list.permits.append_tuple then
      763 		     permit_string = permit_string || "a";
      764 
      765 		if fil_list.permits.modify_attr then
      766 		     permit_string = permit_string || "m";
      767 
      768 		if fil_list.permits.delete_tuple then
      769 		     permit_string = permit_string || "d";
      770 
      771 		if permit_string = "" then do;
      772 			permit_string = "n";
      773 		     end;
      774 
      775 /* r-s-m-d prevent modes */
      776 
      777 		if fil_list.prevents.read_attr then
      778 		     prevent_string = prevent_string || "r";
      779 
      780 		if fil_list.prevents.append_tuple then
      781 		     prevent_string = prevent_string || "a";
      782 
      783 		if fil_list.prevents.modify_attr then
      784 		     prevent_string = prevent_string || "m";
      785 
      786 		if fil_list.prevents.delete_tuple then
      787 		     prevent_string = prevent_string || "d";
      788 
      789 		if prevent_string = "" then do;
      790 			prevent_string = "n";
      791 		     end;
      792 
      793 
      794 	     end;
      795 
      796 /* output the constructed mode strings */
      797 
      798 	call ioa_ ("^21x^32a^3x^4a^6x^4a", fila.name, permit_string, prevent_string);
      799 
      800 
      801 
      802 	declare (permit_string, prevent_string) char (128) varying; /* mode display  temp strings */
      803 	declare mrds_error_$version_not_supported fixed bin (35) ext; /* not known dbc version */
      804 
      805      end;
      806 
      807 ascii_to_bit: proc (asc, bit_var);
      808 
      809 /* convert ascii representation of octal number to bit string */
      810 
      811 	dcl     asc		 char (*);	/* octal number in ascii */
      812 	dcl     charr		 (12) char (1) unal based (ch_ptr); /* array of ascii characters representing an octal id */
      813 	dcl     ch_ptr		 ptr;		/* ptr to character array */
      814 	dcl     bit_var		 bit (36) varying;	/* result bit string */
      815 	dcl     i			 fixed bin;	/* index variable */
      816 
      817 	dcl     1 nine_bit		 unal based,	/* structure of bits for each ascii character */
      818 		2 fill		 bit (6) unal,	/* bits to be discarded */
      819 		2 last_3		 bit (3) unal;	/* relevant bits in each ascii character */
      820 
      821 	bit_var = ""b;				/* initialize */
      822 	ch_ptr = addr (asc);
      823 
      824 	do i = 1 to 12;
      825 	     if length (asc) + i <= 12
      826 	     then bit_var = bit_var || "000"b;		/* take care of missing leading zeroes */
      827 
      828 	     else bit_var = bit_var || addr (charr (i)) -> nine_bit.last_3;
      829 
      830 	end;
      831 
      832      end ascii_to_bit;
      833 
      834 bit_to_ascii: proc (bits, asc);
      835 
      836 /* convert a 12 octal digit to ascii representation */
      837 
      838 	dcl     bits		 bit (36) unal;	/* input bit string */
      839 	dcl     asc		 char (12);	/* output ascii representation of octal string */
      840 	dcl     thr_bit_asc		 (36) bit (3) unal based; /* three bit array for ascii string */
      841 	dcl     thr_bit_bit		 (12) bit (3) unal based; /* three bit array for bit string */
      842 	dcl     i			 fixed bin;
      843 
      844 	asc = "000000000000";			/* initialize with ocatl sixties */
      845 	do i = 1 to 12;
      846 	     addr (asc) -> thr_bit_asc (3 * i) = addr (bits) -> thr_bit_bit (i);
      847 	end;
      848 
      849      end bit_to_ascii;
      850 
      851 convert: proc (a_ptr, ofs) returns (ptr);
      852 
      853 /* this procedure function converts an offset from "0"b to null
      854*   or from the offset value to a pointer value within the segment denoted by a_ptr
      855**/
      856 
      857 	dcl     result		 ptr;		/* the reultant pointer value */
      858 	dcl     a_ptr		 ptr;		/* ptr to the segment to which the offset refers */
      859 	dcl     ofs		 bit (18) unal;	/* the bit offset */
      860 
      861 	dcl     (null, ptr)		 builtin;
      862 
      863 	if ofs ^= NULL_OFS
      864 	then result = ptr (a_ptr, ofs);
      865 	else result = null;
      866 
      867 	return (result);
      868 
      869      end convert;
      870 
      871 live_process: proc (lock_id) returns (bit (1));
      872 
      873 /* This function returns "1"b if the lock_id (input parameter)
      874*   corresponds to a live process.  Otherwise "0"b is returned. */
      875 	l = lock_id;
      876 	call set_lock_$lock (l, 0, icode);
      877 	return (icode = error_table_$lock_wait_time_exceeded |
      878 	     icode = error_table_$locked_by_this_process);
      879 	dcl     icode		 fixed bin (35);
      880 	dcl     l			 bit (36) aligned;
      881 	dcl     lock_id		 bit (36) aligned parm;
      882      end live_process;
      883 
      884 /* BEGIN CHANGE 81-02-11 ************************************************* */
      885 
      886 clean_up: procedure ();
      887 
      888 /* routine to close any open submodel, or model
      889*   and get rid of temp storage space */
      890 
      891 	if submodel_open then do;
      892 
      893 		call mrds_dsm_close$force (submodel_iocb_ptr);
      894 		submodel_open = "0"b;
      895 
      896 	     end;
      897 
      898 	if area_ptr ^= null then do;
      899 
      900 		call release_temp_segment_ (caller_name, area_ptr, discard);
      901 
      902 		area_ptr = null ();
      903 
      904 	     end;
      905 
      906 	if db_model_open then do;
      907 
      908 		call mrds_dm_close (data_model_ptr, discard);
      909 
      910 		db_model_open = "0"b;
      911 
      912 		data_model_ptr = null ();
      913 
      914 	     end;
      915 
      916      end;
      917 
      918 /* END CHANGE 81-02-11 *********************************************** */
      919 
      920 	dcl     (user_flag,				/* denotes -user option */
      921 	        proc_flag,				/* denotes -process_id or -pid option */
      922 	        brief_flag,				/* denotes -brief option */
      923 	        long_flag,				/* denotes -long option */
      924 	        found)		 bit (1) unal init ("0"b); /* a user_list entry was found if ON */
      925 
      926 	dcl     (nargs,				/* nbr of aruments passed by user */
      927 	        dbp_len,				/* length of data base pathname */
      928 	        comp_len,				/* length of group_id compare string */
      929 	        arg_count,				/* nbr of arguments processed */
      930 	        arg_len)		 fixed bin;	/* length of each argument */
      931 
      932 	dcl     code		 fixed bin (35);	/* status code */
      933 	dcl     idx		 fixed dec (6);	/* index */
      934 
      935 	dcl     (comp_ptr,				/* ptr to group_id compare string */
      936 	        arg_ptr,				/* ptr to control arg */
      937 	        dbp_ptr)		 ptr;		/* ptr to data base pathname */
      938 
      939 
      940 	dcl     db_dir		 char (168);	/* containing directory pathname of the data base */
      941 	dcl     db_ent		 char (32);	/* entry name of the data base */
      942 
      943 	dcl     in_path		 char (168);	/* db pathname suitable for passing */
      944 	dcl     db_path		 char (168);	/* absolute pathname of data base */
      945 
      946 	dcl     arg		 char (arg_len) based (arg_ptr);
      947 	dcl     dbp		 char (dbp_len) based (dbp_ptr);
      948 
      949 
      950 
      951 	dcl     1 hdr,				/* report data for the data base control segment */
      952 		2 dbp		 char (168),	/* data base pathname expanded */
      953 		2 state		 char (24),	/* data base state: consistent or not consistent */
      954 		2 message		 char (500),	/* explanation of data base state if inconsistent */
      955 		2 switch		 char (24),	/* status of the trouble switch */
      956 		2 nopen		 fixed dec (6),	/* nbr of users with data base currently open */
      957 		2 nact		 fixed dec (6),	/* nbr users with scopes currently in effect */
      958 		2 npact		 fixed dec (6),	/* nbr users awakened but not yet with active scope */
      959 		2 nwait		 fixed dec (6);	/* nbr users queued waiting for a scope setting */
      960 
      961 
      962 	dcl     1 usr,				/* report data for each open user of data base */
      963 		2 id		 char (32),	/* group id of the user */
      964 		2 pid		 char (12),	/* process id of the user */
      965 		2 mode		 char (19),	/* open mode : r, u, er, eu */
      966 		2 state		 char (5),	/* dead process or is it alive */
      967 		2 scope		 char (7),	/* active, waiting or in between scope usage */
      968 		2 pri		 char (6),	/* normal or high priority */
      969 		2 activate	 char (6),	/* was user activated from set_scope or from queue */
      970 		2 allow		 fixed dec (6),	/* allowance count of bypasses */
      971 		2 bypass		 fixed dec (6);	/* nbr times user was bypassed */
      972 
      973 
      974 	dcl     1 fila,
      975 		2 name		 char (32),	/* name of file which has a scope set */
      976 		2 prm		 char (2) unal,	/* permit scope: n or combination of r and u */
      977 		2 prv		 char (2) unal;	/* prevent scope: n or combination of r and u */
      978 
      979 
      980 	dcl     1 three_bits	 aligned,
      981 		2 one_bit		 bit (1) unal init ("0"b), /* structure for binary representation of scope bits */
      982 		2 two_bit		 bit (2) unal;
      983 
      984 	dcl     ok		 bit (1) unal;	/* ON => control arg is ok */
      985 
      986 	dcl     comp_string		 char (comp_len) based (comp_ptr); /* group_id to be compared, without the asterisks */
      987 
      988 	dcl
      989 	        bit_var		 bit (36) varying;	/* process id string */
      990 
      991 	dcl     (addr,
      992 	        null,
      993 	        before,
      994 	        length,
      995 	        fixed,
      996 	        index,
      997 	        copy,
      998 	        empty,
      999 	        rel,
     1000 	        rtrim,
     1001 	        string,
     1002 	        substr)		 builtin;
     1003 
     1004 	dcl     ioa_		 entry options (variable);
     1005 	dcl     ioa_$nnl		 entry options (variable);
     1006 	declare expand_pathname_	 entry (char (*), char (*), char (*), fixed bin (35));
     1007 	dcl     com_err_		 entry options (variable);
     1008 	dcl     cu_$arg_count	 entry (fixed bin);
     1009 	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin, fixed bin (35));
     1010 	declare mrds_dsl_get_version$get_path_info entry (char (*), ptr, fixed bin, ptr, fixed bin (35)); /* get path details */
     1011 	dcl     set_lock_$lock	 entry (bit (36) aligned, fixed bin, fixed bin (35));
     1012 	dcl     sys_info$max_seg_size	 fixed bin ext;
     1013 
     1014 	dcl     mdbm_data_$normal_mode fixed bin ext;
     1015 	dcl     mdbm_data_$quiesce_mode fixed bin ext;
     1016 
     1017 	dcl     mrds_error_$user_not_found fixed bin (35) ext;
     1018 	declare mrds_error_$no_database fixed bin (35) ext; /* no model */
     1019 	declare dbc_bit_count	 fixed bin (24);	/* unused */
     1020 	declare mu_concurrency_control$get_control_segment entry (char (168), ptr, fixed bin (24), fixed bin (35)); /* gets control seg ptr */
     1021 	dcl     mdbm_util_$inconsistent_get_info entry (ptr, bit (1) unal, char (*), char (*), char (*));
     1022 						/* gets consistency status for database */
     1023 	dcl     incon_value		 bit (1);		/* true ==> db is inconsistent */
     1024 	dcl     incon_name		 char (32);	/* name of request associated with the message */
     1025 	dcl     incon_message	 char (500);	/* explanation of inconsistency */
     1026 	dcl     undo_request	 char (100);	/* request that will make db consistent */
     1027 	dcl     caller_name		 char (32) init ("display_mrds_db_status"); /* name of calling routine */
     1028 	dcl     mrds_error_$no_model_submodel fixed bin (35) ext; /* path not to mrds object */
     1029 	declare str_ptr		 ptr;		/* points to submodel relation info */
     1030 	declare submodel		 bit (1);		/* on => submodel pathname given */
     1031 	declare (get_temp_segment_, release_temp_segment_) entry (char (*), ptr, fixed bin (35)); /* gets/returns temp storage */
     1032 	declare submodel_open	 bit (1);		/* on => submodel currently open */
     1033 	declare work_area		 area (sys_info$max_seg_size) based (area_ptr); /* temp storage */
     1034 	declare area_ptr		 ptr;		/* to temp storage */
     1035 	declare cleanup		 condition;
     1036 	declare discard		 fixed bin (35);	/* unused error code */
     1037 	declare done		 bit (1);		/* on => name found in model concurrency list */
     1038 	declare header_output	 bit (1);		/* on => header for permits/prevents output */
     1039 	declare i			 fixed bin;	/* loop index */
     1040 	declare data_model_ptr	 ptr;		/* pointer to database model */
     1041 	declare mrds_dm_db_secured$get_secured_status entry (ptr, ptr, fixed bin, ptr, fixed bin (35)); /* gets secured bit */
     1042 	declare mrds_dm_open	 entry (char (168), fixed bin, ptr, fixed bin (35)); /* open database model */
     1043 	declare mrds_dm_close	 entry (ptr, fixed bin (35)); /* closes database model */
     1044 	declare mrds_dm_authorization$get_user_class entry (char (*), ptr, fixed bin, ptr, fixed bin (35)); /* finds if user a DBA */
     1045 	declare mrds_dm_secured_submodel entry (char (*), char (*), char (*)) returns (bit (1)); /* returns true if submodel in sm dir */
     1046 	dcl     mrds_dsm_close$force	 entry (ptr);
     1047 	dcl     mrds_dsm_get_relation_names entry (ptr, ptr, ptr, fixed bin (35));
     1048 	dcl     mrds_dsm_open$read	 entry (char (*), ptr, fixed bin (35));
     1049 	dcl     mrds_dsm_read_header$db_path entry (ptr, char (168), fixed bin (35));
     1050 	dcl     mrds_dsm_read_relation entry (char (*), ptr, ptr, ptr, fixed bin (35));
     1051 	dcl     submodel_iocb_ptr	 ptr init (null ());
     1052 	declare mrds_data_$submodel_dir_name char (16) ext; /* name of submodel dir */
     1053 	declare mrds_error_$inc_secure_open fixed bin (35) ext; /* attempt to open thru non-secure submodel */
     1054 	declare secured_submodel	 bit (1);		/* on => submodel in submodel dir */
     1055 	declare sm_name		 char (32);	/* entryname of submodel */
     1056 	declare sm_dir		 char (168);	/* containing dir of submodel */
     1057 	declare sm_abs_path		 char (168);	/* absolute path to submodel */
     1058 	declare db_model_open	 bit (1);		/* on => database model opened */
     1059 	dcl     mrds_error_$process_not_found fixed bin (35) ext;
     1060 
     1061 	dcl     error_table_$badopt	 fixed bin (35) ext;
     1062 	dcl     error_table_$locked_by_this_process fixed bin (35) ext;
     1063 	dcl     error_table_$lock_wait_time_exceeded fixed bin (35) ext;
     1064 	dcl     error_table_$pathlong	 fixed bin (35) ext;
     1065 
  1     1 /*	BEGIN INCLUDE FILE		mdbm_dbc.incl.pl1	08/23/78   odf			*/
  1     2 
  1     3 /* HISTORY:
  1     4*
  1     5*   Modified by odf for new version data bases in August 1978
  1     6*   Modified by Al Kepner, March 8, 1979 to add new flags for quiescing
  1     7*   Modified by M. Pierret, 8 April 1980 to look prettier, add pads
  1     8*   Modified by M. Pierret, 22 August 1980, grouping like fields (flags, offsets..)
  1     9*
  1    10*   80-11-19 Jim Gray : modified to change version number from 4  to 5 to allow
  1    11*   automatic update of dbc structures to new r-s-m-d-u scope codes from r-u.
  1    12**/
  1    13 
  1    14 dcl 1 dbc based (dbc_ptr),				/* data base control segment description */
  1    15     2 proper,
  1    16       3 version fixed bin,				/* version number of this structure */
  1    17       3 dtd_mrds fixed bin (71),			/* date time dumped by mrds utility */
  1    18       3 flags,
  1    19         4 trouble_switch bit (1) unal,			/* ON => ungraceful termination of a user process */
  1    20         4 dead_proc_flag bit (1) unal,			/* ON => dead process has access to part of data base */
  1    21         4 quiesce_sw bit (1) unal,			/* ON => db is quiesced for a administrative user */
  1    22         4 quiesce_db bit (1) unal,			/* ON => The entire data base is being quiesced. */
  1    23         4 quiesce_files bit (1) unal,			/* ON => A selected set of files is being quiesced. */
  1    24         4 pad bit (31) unal,				/* reserved for future use */
  1    25       3 quiesce_lock bit (36) aligned,			/* lock word for quiescing data base */
  1    26       3 wakeup_waiters fixed bin,			/* nbr users who have been sent a wakeup signal but have not yet
  1    27*						   received it */
  1    28       3 user_counts,
  1    29         4 open_users fixed bin,			/* nbr of users with data base open in any mode */
  1    30         4 active_users fixed bin,			/* nbr of users currently having a scope set */
  1    31         4 waiting_users fixed bin,			/* nbr of users waiting to set scope */
  1    32       3 open_lock bit (36) aligned,			/* lock word for opening data base */
  1    33       3 scope_lock bit (36) aligned,			/* lock word for setting and deleting scope */
  1    34       3 sa_size fixed bin (35),			/* size in words of static area  */
  1    35       3 pad2 bit (144),
  1    36       3 offsets,
  1    37         4 open_users_ofs bit (18) unal,			/* bit offset to list of users with data base currently open */
  1    38         4 active_users_ofs bit (18) unal,		/* bit offset to list of active users in shared mode */
  1    39         4 waiting_users_ofs bit (18) unal,		/* bit offset to list of waiting users in shared mode */
  1    40         4 obsolete bit (36) unal,			/* obsolete */
  1    41       3 pad3 bit (144),
  1    42     2 static_area area (sys_info$max_seg_size - fixed (rel (addr (dbc.static_area))) + 1);
  1    43 
  1    44 dcl  dbc_ptr ptr init (null ());
  1    45 
  1    46 dcl  VERSION_NBR fixed bin init (5) static internal options (constant);
  1    47 
  1    48 
  1    49 /* END mdbm_dcb.incl.pl1  */
  1    50 
  1    51 
     1066 
     1067 
  2     1 /* BEGIN mdbm_users.incl.pl1   -- odf, 08/10/78  */
  2     2 
  2     3 
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(86-10-03,Dupuis), approve(86-10-21,MCR7562), audit(86-10-22,Blair),
  2     7*     install(86-10-23,MR12.0-1199):
  2     8*     Deleted the DEFAULT_WAIT variable.
  2     9*                                                   END HISTORY COMMENTS */
  2    10 
  2    11 
  2    12 /* HISTORY:
  2    13*   Written by Oris Friesen August 10, 1978.
  2    14*   Modified by M. Pierret 13 December 1979, changing wakeup messages.
  2    15*   Modified by M. Pierret 13 April 1980 (Jason's birthday) to remove priority and wakeup structures
  2    16*   Modified by M. Pierret 13 August 1980 to group like fields (ids, offsets...)
  2    17*   Modified by Jim Gray - - 80-11-19, to add fields to fil_list to allow for complete
  2    18*   r-u-s-m-d scope codes, instead of just r-u.
  2    19*
  2    20*   80-12-10 Jim Gray : change names of fil_list prevent/permit modes
  2    21*   store to append_tuple, retreive to read_attr, delete to delete_tuple, modify to modify_attr,
  2    22*   and pad to mbz for consistency with MRDS access acl modes.
  2    23*
  2    24*   80-12-12 Jim Gray : Changed DEFAULT_WAIT declaration to fixed bin 35 from 71,
  2    25*   so that the wait_seconds fb35 overlay would not get 0 and thus never wait.
  2    26*   This is currently only used in mrds_dsl_set_fscope.
  2    27*
  2    28*   82-09-22 Davids: addede the opening_id element to the fil_list structure.
  2    29*   Put it at the end to make the new structure compatable with the old so
  2    30*   that testing could take place without having to recompile all the modules
  2    31*   that use the structure.
  2    32*
  2    33*   82-10-14 Davids: removed the opening_id element and added the rmri_ptr
  2    34*   element. This was done because set_fscope must be able to open the
  2    35*   relation if its not yet opened.
  2    36*   ---------------------------------------------------------------------------
  2    37*   DESCRIPTION:
  2    38*
  2    39*   The dbc contains the following information in its static area.
  2    40*   One group of information is composed of structures (user_list)
  2    41*   threaded 3 ways to form 3 lists. They are the list of active
  2    42*   scope users, of open users, and of users waiting to set scope.
  2    43*   The beginning of each of these lists is pointed to by fields
  2    44*   in the dbc proper.  All of these lists share the user_list structures,
  2    45*   and are completely contained within these structures, i.e., there
  2    46*   is no extraneous information in some knook in Scottsdale.
  2    47*
  2    48*   Associated with each user_list structure is a linked list of
  2    49*   fil_list structures.  The list is of all of the files (relations)
  2    50*   included in the user's scope request.  Unlike the user_list
  2    51*   structures which were shared by several different lists, the structures
  2    52*   in a user's file list are exclusively hers.  The entries contain
  2    53*   information about the scope request and the file name, and have
  2    54*   no real connection with the actual files in the resultant model.
  2    55*   --------------------------------------------------------------------------- */
  2    56 
  2    57 dcl 1 user_list based (ul_ptr),
  2    58     2 ids,
  2    59       3 group_id char (32),				/* group identifier of this user */
  2    60       3 process_id bit (36),				/* process identifier of this user */
  2    61       3 db_lock_id bit (36) aligned,			/* the unique lock id for this process --
  2    62*						   used to identify dead processes */
  2    63       3 ev_chn_id fixed bin (71),			/* event channel id for this process */
  2    64       3 rdbi_bits bit (72),				/* bit string of rdbi_ptr
  2    65*						   to allow concurrent openings by same process */
  2    66     2 flags,
  2    67       3 open_mode fixed bin unal,			/* the mode of the db. opening -- NORMAL or QUIESCE */
  2    68       3 passive_sw bit (1) unal,			/* OFF => -permit update on some file */
  2    69       3 active_sw bit (1) unal,			/* ON => user has a scope set */
  2    70       3 waiting_sw bit (1) unal,			/* ON => user is waiting for scope to be set */
  2    71       3 priority_high bit (1) unal,			/* obsolete */
  2    72       3 event_signal_sw bit (1) unal,			/* ON => user has been signalled thru event wait channel */
  2    73       3 dead_proc bit (1) unal,			/* ON => this user's process has died  and is inactive */
  2    74       3 dead_proc_conflict
  2    75      bit (1) unal,					/* this user's scope request conflicts with a dead process */
  2    76       3 queue_activ bit (1) unal,			/* activated from the waiting queue */
  2    77       3 pad bit (28),				/* reserved for future use */
  2    78     2 allowance_count fixed bin,			/* obsolete */
  2    79     2 bypass_count fixed bin,				/* obsolete */
  2    80     2 offsets,
  2    81       3 fil_list_ofs bit (18) unal,			/* bit offset to list of files in this user's scope request */
  2    82       3 next_active_ofs bit (18) unal,			/* bit offset to next user in this list of active scope users */
  2    83       3 next_waiting_ofs bit (18) unal,			/* bit offset to next user in user list waiting to set scope */
  2    84       3 next_open_ofs bit (18) unal,			/* bit offset to next user who has data base open in any mode */
  2    85     2 num_filns fixed bin,				/* number of files potentially accessible by this user */
  2    86     2 file (num_filns refer (user_list.num_filns)) char (30);
  2    87 						/* names of files accessible by this user */
  2    88 
  2    89 dcl 1 fil_list based (fl_ptr),			/* of files which a given user has specified for a scope  */
  2    90     2 name char (30),				/* data model name of the file specified in scope request */
  2    91     2 permits,					/* permit codes for scope setting or deleting */
  2    92       3 mbz1 bit (15) unal,
  2    93       3 modify_attr bit (1) unal,
  2    94       3 delete_tuple bit (1) unal,
  2    95       3 append_tuple bit (1) unal,
  2    96       3 update bit (1) unal,
  2    97       3 read_attr bit (1) unal,
  2    98     2 prevents,					/* prevent codes for scope setting or deleting */
  2    99       3 update bit (1) unal,
  2   100       3 read_attr bit (1) unal,
  2   101       3 append_tuple bit (1) unal,
  2   102       3 delete_tuple bit (1) unal,
  2   103       3 modify_attr bit (1) unal,
  2   104       3 mbz2 bit (29) unal,
  2   105     2 next_ofs bit (18) unal,				/* bit offset to next file entry for this user's scope request */
  2   106     2 rmri_ptr ptr;                                         /* pointer to the relation's rm_rel_info str */
  2   107                                                             /* needed so that the relation can be opened if need be */
  2   108 
  2   109 dcl  ul_ptr ptr init (null ());
  2   110 dcl  fl_ptr ptr init (null ());
  2   111 
  2   112 dcl  num_filns fixed bin;				/* number of files accessible by a given user */
  2   113 
  2   114 
  2   115 dcl  WAIT init (0) fixed bin int static options (constant);
  2   116 						/* the number of later user requests for which a user
  2   117*						   request will wait before it must be honored */
  2   118 dcl  NULL_OFS bit (18) init ("111111111111111111"b) unal int static options (constant);
  2   119 dcl  DQ_OPEN bit (1) unal init ("1"b) int static options (constant);
  2   120 						/* dequeue from open list */
  2   121 dcl  NO_DQ_OPEN bit (1) init ("0"b) int static options (constant);
  2   122 						/*  do not dequeue from open list */
  2   123 dcl  CHAR_Q_F char (8) init ("que_free") int static options (constant);
  2   124 dcl  QUE_FREE fixed bin (71);
  2   125 dcl  CHAR_ALARM char (8) init ("alarm___") int static options (constant);
  2   126 						/* wakeup up signal for time-out */
  2   127 dcl  ALARM fixed bin (71);
  2   128 dcl  FIRST_QUEUE bit (1) init ("1"b) int static options (constant);
  2   129 						/* this is the 1st time process will asleep */
  2   130 dcl  QUEUE_AGAIN bit (1) init ("0"b) int static options (constant);
  2   131 						/* being queued for the 2nd, 3rd ... time */
  2   132 dcl  SET bit (1) unal init ("1"b) int static options (constant);
  2   133 						/* check to see which scopes can be set */
  2   134 dcl  DEL bit (1) unal init ("0"b) int static options (constant);
  2   135 						/* check to see which scopes can be deleted */
  2   136 dcl  ALIVE init ("1"b) bit (1) unal int static options (constant);
  2   137 						/* process is alive */
  2   138 dcl  DEAD init ("0"b) bit (1) unal int static options (constant);
  2   139 						/* process is dead */
  2   140 dcl  Q_PRM init (3) fixed bin (35) int static options (constant);
  2   141 						/* permit retrieve, update */
  2   142 dcl  Q_PRV init (3) fixed bin (35) int static options (constant);
  2   143 						/* prevent retrieve, update */
  2   144 dcl  Q_PRM_BITS bit (2) unal init ("11"b) int static options (constant);
  2   145 						/* permit retrieve, update */
  2   146 dcl  Q_PRV_BITS bit (2) unal init ("11"b) int static options (constant);
  2   147 						/* prevent retrieve, update */
  2   148 dcl  REL_SEC bit (2) init ("11"b) int static options (constant);
  2   149 						/* measure wait time in relative seconds */
  2   150 dcl  FREE_FIL_LIST bit (1) unal init ("1"b) int static options (constant);
  2   151 						/* free this user's file lists */
  2   152 dcl  SAVE_FIL_LIST bit (1) unal init ("0"b) int static options (constant);
  2   153 						/* do not free this user's file lists */
  2   154 
  2   155 /* END mdbm_users.incl.pl1 */
  2   156 
     1068 
     1069 
  3     1 /* BEGIN INCLUDE FILE mrds_path_info.incl.pl1 - -  Jim Gray 81-01-22 */
  3     2 
  3     3 /* HISTORY:
  3     4*
  3     5*   81-01-22 Jim Gray : originaly created for the dsl_$get_path_info interface,
  3     6*   a slight extension to the undocumented mrds_dsl_get_version$header.
  3     7*
  3     8**/
  3     9 
  3    10 /* DESCRIPTION:
  3    11*
  3    12*   This structure returns information about a relative pathname, given
  3    13*   to a pathname accepting mrds interface. The information returned
  3    14*   is the absolute pathname, plus in the case that
  3    15*   the relative path points to a mrds database or submodel
  3    16*   whether it is a model or a submodel, the mrds version of
  3    17*   the model or submodel, it's creator, and the time of creation.
  3    18*
  3    19**/
  3    20 
  3    21 
  3    22 declare 1 mrds_path_info aligned based (mrds_path_info_ptr),
  3    23         2 version fixed bin,				/* version number for this structure */
  3    24         2 absolute_path char (168),			/* the absolute path from the input relative path */
  3    25         2 type,
  3    26 	3 not_mrds bit (1) unal,			/* on => path not to model or submodel */
  3    27 	3 model bit (1) unal,			/* on => path to database model, thus possible .db suffix */
  3    28 	3 submodel bit (1) unal,			/* on => path to submodel, thus possible .dsm suffix */
  3    29 	3 mbz1 bit (33) unal,
  3    30         2 mrds_version fixed bin,			/* the mrds version number of the model or submodel */
  3    31         2 creator_id char (32),			/* the person.project.tag of the creator */
  3    32         2 creation_time fixed bin (71),			/* convert date to binary form of time model/submodel created */
  3    33         2 mbz2 bit (36) unal ;
  3    34 
  3    35 
  3    36 declare  mrds_path_info_ptr ptr ;
  3    37 
  3    38 declare  mrds_path_info_structure_version fixed bin init (1) int static options (constant) ;
  3    39 
  3    40 /* END  INCLUDE FILE mrds_path_info.incl.pl1 */
     1070 
     1071 
  4     1 /*	BEGIN INCLUDE FILE		mrds_dsm_rel_block.incl.pl1
  4     2*
  4     3*   Created October, 1975 for release in MR 4.0
  4     4*
  4     5*   The relation_block contains the relation name and  the  attribute
  4     6*   names and access information
  4     7*
  4     8*   HISTORY
  4     9*
  4    10*   80-04-10 Spratt: changed to have version  number,  be  explicitly
  4    11*   .        based, use an automatic variable in the refer for num of
  4    12*   .        attributes,  add access flags for rel and attr's, remove
  4    13*   .        attr key flags. This is for the  first  Attribute  Level
  4    14*   .        Security version of MRDS.
  4    15*
  4    16*   81-01-14 Davids: increased submodel rel  and  attr  names  to  64
  4    17*   .        characters and made dsm_rel_name char  varying.  changed
  4    18*   .        access  bits  from  a  bit  string to individually named
  4    19*   .        flags.
  4    20**/
  4    21 
  4    22 dcl  relation_block_ptr ptr;
  4    23 dcl  rb_number_of_attributes fixed bin (35);
  4    24 dcl  RELATION_BLOCK_VERSION_1 fixed bin (35) internal static options (constant) init (1);
  4    25 
  4    26 dcl 1 relation_block based (relation_block_ptr),
  4    27 						/* Relation block */
  4    28     2 version fixed bin (35),
  4    29     2 dsm_rel_name char (64) varying,			/* Data submodel relation name */
  4    30     2 dm_rel_name char (32),				/* Data model relation name */
  4    31     2 rel_access unal,
  4    32       3 append bit (1),
  4    33       3 delete bit (1),
  4    34       3 null bit (1),
  4    35       3 mbz1 bit (33),
  4    36     2 no_rb_attributes fixed bin,			/* The number of attributes in this relation */
  4    37     2 attribute_info (rb_number_of_attributes refer (relation_block.no_rb_attributes)),
  4    38       3 dsm_attr_name char (64) varying,		/* Data submodel attribute name */
  4    39       3 attr_access unal,				/* Data submodel attribute flags */
  4    40         4 read bit (1),
  4    41         4 modify bit (1),
  4    42         4 null bit (1),
  4    43         4 mbz2 bit (33),				/* For future use */
  4    44       3 dm_attr_name char (32) varying,			/* Data model attribute name */
  4    45       3 dm_attr_flags,				/* Data model attribute flags */
  4    46         4 mbz3 bit (36);				/* For future use */
  4    47 
  4    48 /* 	END INCLUDE FILE 		mrds_dsm_rel_block.incl.pl1  */
  4    49 
     1072 
     1073 
  5     1 /* BEGIN INCLUDE FILE mrds_dsm_relation_names.incl.pl1 -- nsd 81/01/12 */
  5     2 
  5     3 /*
  5     4*This include file is for internal mrds use only. It  is  used  to
  5     5*return an array of submodel relation names.
  5     6*
  5     7*HISTORY
  5     8*
  5     9*81-01-12 Davids: written
  5    10*
  5    11*81-09-14 Davids: changed relation to char (32) from char (64). 64
  5    12*was  a  proposed  maximum  but  could not be implemented. Several
  5    13*modules would not compile when compiled with  -prefix  stringsize
  5    14*becuase they made assignments of the form char (32) = char (64).
  5    15**/
  5    16 
  5    17 dcl 1 mrds_dsm_relation_names based (mrds_dsm_relation_names_ptr),
  5    18     2 nrels fixed bin,
  5    19     2 relation (mrds_dsm_relation_names_nrels_alloc refer (mrds_dsm_relation_names.nrels)) char (32);
  5    20 
  5    21 dcl  mrds_dsm_relation_names_nrels_alloc fixed bin;
  5    22 
  5    23 dcl  mrds_dsm_relation_names_ptr ptr;
  5    24 
  5    25 /* END INCLUDE FILE mrds_dsm_relation_names.incl.pl1 */
  5    26 
     1074 
     1075 
  6     1 /* BEGIN INCLUDE FILE mrds_database_state.incl.pl1 - - 81-01-20 Jim Gray */
  6     2 
  6     3 /* HISTORY:
  6     4*
  6     5*   81-01-20 Jim Gray : original created for the mmi_$get_secured_status interface
  6     6*
  6     7**/
  6     8 
  6     9 /* DESCRIPTION:
  6    10*
  6    11*   This structure returns the database state (secured or unsecured)
  6    12*   for determining how commands and subroutines will behave for each case.
  6    13*   The secured bit was kept separate from the unsecured,
  6    14*   rather than it's logical "not", to allow for future extensibility
  6    15*   of database secured states.
  6    16*
  6    17**/
  6    18 
  6    19 
  6    20 declare 1 database_state aligned based (database_state_ptr),
  6    21         2 version fixed bin,				/* version number of this structure */
  6    22         2 unsecured bit (1) unal,			/* database not secured */
  6    23         2 secured bit (1) unal,			/* database has been secured */
  6    24         2 mbz bit (34) unal ;
  6    25 
  6    26 
  6    27 declare  database_state_ptr ptr ;			/* pointer for referring to the structure */
  6    28 
  6    29 declare  database_state_structure_version fixed bin init (1) int static options (constant) ;
  6    30 
  6    31 /* END INCLUDE FILE mrds_database_state.incl.pl1 */
     1076 
     1077 
  7     1 /* BEGIN INCLUDE FILE mrds_authorization.incl.pl1 - - 81-01-20 Jim Gray */
  7     2 
  7     3 /* HISTORY:
  7     4*
  7     5*   81-01-20 Jim Gray : original created for the mmi_$get_authorization interface
  7     6*
  7     7**/
  7     8 
  7     9 /* DESCRIPTION:
  7    10*
  7    11*   this structure returns the callers user_class
  7    12*   either database administrator or normal user.
  7    13*   Note that these separate classes were used to allow
  7    14*   future expansion to the user classes, rather than
  7    15*   make them logical "not"'s of one another.
  7    16*   NOTE: a DBA is always also a normal user, thus if the caller
  7    17*   is a DBA, his normal_user bit will be on also.
  7    18*
  7    19**/
  7    20 
  7    21 
  7    22 declare 1 mrds_authorization aligned based (mrds_authorization_ptr),
  7    23         2 version fixed bin,				/* version number of this structure */
  7    24         2 administrator bit (1) unal,			/* caller is a DBA */
  7    25         2 normal_user bit (1) unal,			/* caller has no special priviledges */
  7    26         2 mbz bit (34) unal ;
  7    27 
  7    28 
  7    29 declare  mrds_authorization_ptr ptr ;			/* pointer for referring to the structure */
  7    30 
  7    31 declare  mrds_authorization_structure_version fixed bin init (1) int static options (constant) ;
  7    32 
  7    33 /* END INCLUDE FILE mrds_authorization.incl.pl1 */
     1078 
     1079 
     1080 
     1081      end display_mrds_db_status;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/23/86  1009.0  display_mrds_db_status.pl1        >spec>install>1199>display_mrds_db_status.pl1
1066         1    10/14/83  1609.0  mdbm_dbc.incl.pl1                 >ldd>include>mdbm_dbc.incl.pl1
1068         2    10/23/86  1006.0  mdbm_users.incl.pl1               >spec>install>1199>mdbm_users.incl.pl1
1070         3    10/14/83  1608.8  mrds_path_info.incl.pl1           >ldd>include>mrds_path_info.incl.pl1
1072         4    10/14/83  1608.7  mrds_dsm_rel_block.incl.pl1       >ldd>include>mrds_dsm_rel_block.incl.pl1
1074         5    10/14/83  1609.0  mrds_dsm_relation_names.incl.pl1  >ldd>include>mrds_dsm_relation_names.incl.pl1
1076         6    10/14/83  1608.8  mrds_database_state.incl.pl1      >ldd>include>mrds_database_state.incl.pl1
1078         7    10/14/83  1608.8  mrds_authorization.incl.pl1       >ldd>include>mrds_authorization.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
NULL_OFS                               constant        bit(18)                  initial unaligned dcl 2-118 ref 863
a_ptr                                  parameter       pointer                  dcl 858 ref 851 863
absolute_path             1            based           char(168)                level 2 dcl 3-22 ref 148 205
activate                 24(09) 000625 automatic       char(6)                  level 2 packed unaligned dcl 962 set ref 604* 605*
                                                                                  608 608*
active_sw                16(19)        based           bit(1)                   level 3 packed unaligned dcl 2-57 ref 602
active_users             10            based           fixed bin(17,0)          level 4 dcl 1-14 ref 446
addr                                                   builtin function         dcl 991 ref 491 493 822 828 846 846
administrator             1            based           bit(1)                   level 2 packed unaligned dcl 7-22 ref 261
allow                    26     000625 automatic       fixed dec(6,0)           level 2 dcl 962 set ref 616* 623*
allowance_count          20            based           fixed bin(17,0)          level 2 dcl 2-57 ref 616
append_tuple             10(04)        based           bit(1)                   level 3 in structure "fil_list" packed unaligned
                                                                                  dcl 2-89 in procedure "dmdbs" ref 780
append_tuple              7(35)        based           bit(1)                   level 3 in structure "fil_list" packed unaligned
                                                                                  dcl 2-89 in procedure "dmdbs" ref 762
area_ptr                        001150 automatic       pointer                  dcl 1034 set ref 103* 107* 109* 116 143* 192* 202*
                                                                                  238* 252* 664* 898 900* 902*
arg                                    based           char                     unaligned dcl 946 set ref 326 326 329 329 332 332
                                                                                  335 338* 487 493 503* 512* 524* 549 549 549 549
                                                                                  554 558 558 563*
arg_count                       000110 automatic       fixed bin(17,0)          dcl 926 set ref 474* 475 477* 479* 539 541 549* 549
                                                                                  553 568* 568
arg_len                         000111 automatic       fixed bin(17,0)          dcl 926 set ref 325* 326 326 329 329 332 332 335 338
                                                                                  338 477* 487 488 493 503 503 512 512 524 524 541*
                                                                                  549 549 549 549 554 558 558 563 563
arg_ptr                         000120 automatic       pointer                  dcl 935 set ref 325* 326 326 329 329 332 332 335 338
                                                                                  477* 487 493 503 512 524 541* 549 549 549 549 554
                                                                                  558 558 563
asc                                    parameter       char                     unaligned dcl 811 in procedure "ascii_to_bit" set
                                                                                  ref 807 822 825
asc                                    parameter       char(12)                 unaligned dcl 839 in procedure "bit_to_ascii" set
                                                                                  ref 834 844* 846
before                                                 builtin function         dcl 991 ref 493
bit_var                                parameter       varying bit(36)          dcl 814 in procedure "ascii_to_bit" set ref 807 821*
                                                                                  825* 825 828* 828
bit_var                         000672 automatic       varying bit(36)          dcl 988 in procedure "dmdbs" set ref 512* 516
bits                                   parameter       bit(36)                  unaligned dcl 838 set ref 834 846
brief_flag                      000102 automatic       bit(1)                   initial unaligned dcl 920 set ref 98* 326* 456 583
                                                                                  920*
bypass                   30     000625 automatic       fixed dec(6,0)           level 2 dcl 962 set ref 617* 624*
bypass_count             21            based           fixed bin(17,0)          level 2 dcl 2-57 ref 617
caller_name                     001134 automatic       char(32)                 initial unaligned dcl 1027 set ref 107* 111* 123*
                                                                                  133* 153* 172* 185* 194* 208* 230* 241* 255* 272*
                                                                                  285* 289* 308* 317* 338* 347* 479* 503* 524* 532*
                                                                                  543* 563* 667* 724* 900* 1027*
ch_ptr                          001512 automatic       pointer                  dcl 813 set ref 822* 828
charr                                  based           char(1)                  array unaligned dcl 812 set ref 828
cleanup                         001152 stack reference condition                dcl 1035 ref 105
code                            000112 automatic       fixed bin(35,0)          dcl 932 set ref 107* 108 111* 131* 132 133* 143* 150
                                                                                  151 151* 153* 169* 171 172* 183* 184 185* 192* 193
                                                                                  194* 202* 207 208* 227* 229 230* 238* 240 241*
                                                                                  252* 254 255* 270* 271 272* 305* 306 308* 325*
                                                                                  345* 346 347* 477* 478 479* 541* 542 543* 658* 660
                                                                                  664* 666 667*
com_err_                        000020 constant        entry                    external dcl 1007 ref 111 123 133 153 172 185 194
                                                                                  208 230 241 255 272 285 289 308 317 338 347 479
                                                                                  503 524 532 543 563 667 724
comp_len                        000107 automatic       fixed bin(17,0)          dcl 926 set ref 487* 488 488* 493
comp_ptr                        000116 automatic       pointer                  dcl 935 set ref 491*
comp_string                            based           char                     unaligned dcl 986 ref 493
copy                                                   builtin function         dcl 991 ref 130
cu_$arg_count                   000022 constant        entry                    external dcl 1008 ref 120
cu_$arg_ptr                     000024 constant        entry                    external dcl 1009 ref 131 325 477 541
data_model_ptr                  001164 automatic       pointer                  dcl 1040 set ref 227* 238* 354* 908* 912*
database_state                         based           structure                level 1 dcl 6-20
database_state_ptr              001342 automatic       pointer                  dcl 6-27 set ref 238* 247
database_state_structure_version
                                000111 constant        fixed bin(17,0)          initial dcl 6-29 set ref 238*
db_dir                          000124 automatic       char(168)                unaligned dcl 940 set ref 130* 305*
db_ent                          000176 automatic       char(32)                 unaligned dcl 941 set ref 305*
db_lock_id               11            based           bit(36)                  level 3 dcl 2-57 set ref 586* 597 597
db_model_open                   001325 automatic       bit(1)                   unaligned dcl 1058 set ref 102* 236* 906 910*
db_path                         000260 automatic       char(168)                unaligned dcl 944 set ref 146* 148* 167 183* 202*
                                                                                  205* 208* 227* 230* 241* 252 252 255* 278* 285*
                                                                                  289* 305* 315 317* 345* 381
dbc                                    based           structure                level 1 unaligned dcl 1-14
dbc_bit_count                   000674 automatic       fixed bin(24,0)          dcl 1019 set ref 345*
dbc_ptr                         001326 automatic       pointer                  initial dcl 1-44 set ref 345* 1-44* 382 395 398 402
                                                                                  402 402 404 434 434 438 438 441 443 445 446 447
                                                                                  448 458* 458 462* 489* 489 499* 513* 513 520* 638*
                                                                                  648* 677* 683* 723 723 724 731
dbp                                    based           char                     unaligned dcl 947 in procedure "dmdbs" set ref 142
                                                                                  153* 308*
dbp                             000332 automatic       char(168)                level 2 in structure "hdr" packed unaligned dcl 951
                                                                                  in procedure "dmdbs" set ref 381* 384*
dbp_len                         000106 automatic       fixed bin(17,0)          dcl 926 set ref 131* 142 153 153 308 308
dbp_ptr                         000122 automatic       pointer                  dcl 935 set ref 131* 142 153 308
dbs                             000010 internal static bit(1)                   initial unaligned dcl 375 set ref 376* 376 437 596
dead_proc                16(23)        based           bit(1)                   level 3 packed unaligned dcl 2-57 ref 584
dead_proc_conflict       16(24)        based           bit(1)                   level 3 packed unaligned dcl 2-57 ref 620
dead_proc_flag            4(01)        based           bit(1)                   level 4 packed unaligned dcl 1-14 ref 441
delete_tuple             10(05)        based           bit(1)                   level 3 in structure "fil_list" packed unaligned
                                                                                  dcl 2-89 in procedure "dmdbs" ref 786
delete_tuple              7(34)        based           bit(1)                   level 3 in structure "fil_list" packed unaligned
                                                                                  dcl 2-89 in procedure "dmdbs" ref 768
discard                         001160 automatic       fixed bin(35,0)          dcl 1036 set ref 900* 908*
dm_rel_name              22            based           char(32)                 level 2 packed unaligned dcl 4-26 ref 681
done                            001161 automatic       bit(1)                   unaligned dcl 1037 set ref 676* 678 679* 681*
empty                                                  builtin function         dcl 991 ref 116
error_table_$badopt             000110 external static fixed bin(35,0)          dcl 1061 set ref 338* 532* 563*
error_table_$lock_wait_time_exceeded
                                000114 external static fixed bin(35,0)          dcl 1063 ref 877
error_table_$locked_by_this_process
                                000112 external static fixed bin(35,0)          dcl 1062 ref 877
error_table_$pathlong           000116 external static fixed bin(35,0)          dcl 1064 set ref 317*
expand_pathname_                000016 constant        entry                    external dcl 1006 ref 270 305
fil_list                               based           structure                level 1 unaligned dcl 2-89
fil_list_ofs             22            based           bit(18)                  level 3 packed unaligned dcl 2-57 set ref 638* 677*
fila                            000657 automatic       structure                level 1 packed unaligned dcl 974
fixed                                                  builtin function         dcl 991 ref 404 438 438 597 597
fl_ptr                          001332 automatic       pointer                  initial dcl 2-110 set ref 2-110* 638* 640 644 645
                                                                                  648* 648 677* 679 681 683* 683 687 735 737 744 746
                                                                                  759 762 765 768 777 780 783 786
flags                     4            based           structure                level 3 in structure "dbc" packed unaligned dcl 1-14
                                                                                  in procedure "dmdbs" ref 404
flags                    16            based           structure                level 2 in structure "user_list" packed unaligned
                                                                                  dcl 2-57 in procedure "dmdbs"
found                           000104 automatic       bit(1)                   initial unaligned dcl 920 set ref 486* 496* 502 511*
                                                                                  514 518* 523 920*
get_temp_segment_               000052 constant        entry                    external dcl 1031 ref 107
group_id                               based           char(32)                 level 3 packed unaligned dcl 2-57 set ref 491 493
                                                                                  578
hdr                             000332 automatic       structure                level 1 unaligned dcl 951
header_output                   001162 automatic       bit(1)                   unaligned dcl 1038 set ref 659* 694 696*
i                               001514 automatic       fixed bin(17,0)          dcl 815 in procedure "ascii_to_bit" set ref 824* 825
                                                                                  828*
i                               001524 automatic       fixed bin(17,0)          dcl 842 in procedure "bit_to_ascii" set ref 845* 846
                                                                                  846*
i                               001163 automatic       fixed bin(17,0)          dcl 1039 in procedure "dmdbs" set ref 660* 664 667
                                                                                  692*
icode                           001544 automatic       fixed bin(35,0)          dcl 879 set ref 876* 877 877
id                              000625 automatic       char(32)                 level 2 packed unaligned dcl 962 set ref 578* 579*
ids                                    based           structure                level 2 unaligned dcl 2-57
idx                             000114 automatic       fixed dec(6,0)           dcl 933 set ref 460*
in_path                         000206 automatic       char(168)                unaligned dcl 943 set ref 142* 143* 146
incon_message                   000706 automatic       char(500)                unaligned dcl 1025 set ref 354* 358
incon_name                      000676 automatic       char(32)                 unaligned dcl 1024 set ref 354*
incon_value                     000675 automatic       bit(1)                   unaligned dcl 1023 set ref 354* 387 390 392
index                                                  builtin function         dcl 991 ref 487
ioa_                            000012 constant        entry                    external dcl 1004 ref 382 384 385 390 392 398 434
                                                                                  436 438 441 444 450 451 453 579 581 589 594 597
                                                                                  598 606 608 618 619 620 623 624 630 641 697 798
ioa_$nnl                        000014 constant        entry                    external dcl 1005 ref 406 410 414 418 422 426 430
l                               001545 automatic       bit(36)                  dcl 880 set ref 875* 876*
last_3                    0(06)        based           bit(3)                   level 2 packed unaligned dcl 817 ref 828
length                                                 builtin function         dcl 991 ref 315 825
lock_id                                parameter       bit(36)                  dcl 881 ref 871 875
long_flag                       000103 automatic       bit(1)                   initial unaligned dcl 920 set ref 98* 329* 382 385
                                                                                  390 398 451 453 456 581 589 594 606 608 627 920*
mdbm_data_$normal_mode          000034 external static fixed bin(17,0)          dcl 1014 ref 592
mdbm_data_$quiesce_mode         000036 external static fixed bin(17,0)          dcl 1015 ref 593
mdbm_util_$inconsistent_get_info
                                000046 constant        entry                    external dcl 1021 ref 354
message                  60     000332 automatic       char(500)                level 2 packed unaligned dcl 951 set ref 358* 360
                                                                                  360* 392*
mode                     13     000625 automatic       char(19)                 level 2 packed unaligned dcl 962 set ref 591* 592*
                                                                                  593* 594 594*
modify_attr               7(33)        based           bit(1)                   level 3 in structure "fil_list" packed unaligned
                                                                                  dcl 2-89 in procedure "dmdbs" ref 765
modify_attr              10(06)        based           bit(1)                   level 3 in structure "fil_list" packed unaligned
                                                                                  dcl 2-89 in procedure "dmdbs" ref 783
mrds_authorization                     based           structure                level 1 dcl 7-22
mrds_authorization_ptr          001344 automatic       pointer                  dcl 7-29 set ref 252* 261
mrds_authorization_structure_version
                                000111 constant        fixed bin(17,0)          initial dcl 7-31 set ref 252*
mrds_data_$submodel_dir_name    000102 external static char(16)                 unaligned dcl 1052 set ref 289*
mrds_dm_authorization$get_user_class
                                000064 constant        entry                    external dcl 1044 ref 252
mrds_dm_close                   000062 constant        entry                    external dcl 1043 ref 908
mrds_dm_db_secured$get_secured_status
                                000056 constant        entry                    external dcl 1041 ref 238
mrds_dm_open                    000060 constant        entry                    external dcl 1042 ref 227
mrds_dm_secured_submodel        000066 constant        entry                    external dcl 1045 ref 278
mrds_dsl_get_version$get_path_info
                                000026 constant        entry                    external dcl 1010 ref 143 202
mrds_dsm_close$force            000070 constant        entry                    external dcl 1046 ref 893
mrds_dsm_get_relation_names     000072 constant        entry                    external dcl 1047 ref 192
mrds_dsm_open$read              000074 constant        entry                    external dcl 1048 ref 169
mrds_dsm_read_header$db_path    000076 constant        entry                    external dcl 1049 ref 183
mrds_dsm_read_relation          000100 constant        entry                    external dcl 1050 ref 664
mrds_dsm_relation_names                based           structure                level 1 unaligned dcl 5-17
mrds_dsm_relation_names_ptr     001340 automatic       pointer                  dcl 5-23 set ref 192* 660 664 667 692
mrds_error_$inc_secure_open     000104 external static fixed bin(35,0)          dcl 1053 set ref 285* 289*
mrds_error_$no_database         000042 external static fixed bin(35,0)          dcl 1018 ref 151
mrds_error_$no_model_submodel   000050 external static fixed bin(35,0)          dcl 1028 ref 151
mrds_error_$process_not_found   000106 external static fixed bin(35,0)          dcl 1059 set ref 524*
mrds_error_$user_not_found      000040 external static fixed bin(35,0)          dcl 1017 set ref 503*
mrds_error_$version_not_supported
                                000120 external static fixed bin(35,0)          dcl 803 set ref 724*
mrds_path_info                         based           structure                level 1 dcl 3-22
mrds_path_info_ptr              001336 automatic       pointer                  dcl 3-36 set ref 143* 146 148 162 202* 204 205 385
mrds_path_info_structure_version
                                000111 constant        fixed bin(17,0)          initial dcl 3-38 set ref 143* 202*
mrds_version             54            based           fixed bin(17,0)          level 2 dcl 3-22 set ref 385*
mu_concurrency_control$get_control_segment
                                000044 constant        entry                    external dcl 1020 ref 345
nact                    265     000332 automatic       fixed dec(6,0)           level 2 dcl 951 set ref 446* 450*
name                                   based           char(30)                 level 2 in structure "fil_list" packed unaligned
                                                                                  dcl 2-89 in procedure "dmdbs" ref 645 681
name                            000657 automatic       char(32)                 level 2 in structure "fila" packed unaligned dcl 974
                                                                                  in procedure "dmdbs" set ref 645* 692* 798*
nargs                           000105 automatic       fixed bin(17,0)          dcl 926 set ref 120* 122 323 475 539 553
next_ofs                 11            based           bit(18)                  level 2 packed unaligned dcl 2-89 set ref 648* 683*
next_open_ofs            23(18)        based           bit(18)                  level 3 packed unaligned dcl 2-57 set ref 462* 499*
                                                                                  520*
nine_bit                               based           structure                level 1 packed unaligned dcl 817
nopen                   263     000332 automatic       fixed dec(6,0)           level 2 dcl 951 set ref 443* 444* 460
npact                   267     000332 automatic       fixed dec(6,0)           level 2 dcl 951 set ref 447* 451 451*
nrels                                  based           fixed bin(17,0)          level 2 dcl 5-17 ref 660
null                                                   builtin function         dcl 861 in procedure "convert" ref 865
null                                                   builtin function         dcl 991 in procedure "dmdbs" ref 103 109 146 204
                                                                                  1051 1-44 2-109 2-110 460 492 514 640 644 679 687
                                                                                  898 902 912
num_filns                       001334 automatic       fixed bin(17,0)          dcl 2-112 set ref 97*
nwait                   271     000332 automatic       fixed dec(6,0)           level 2 dcl 951 set ref 448* 453 453*
offsets                  22            based           structure                level 2 in structure "user_list" packed unaligned
                                                                                  dcl 2-57 in procedure "dmdbs"
offsets                  21            based           structure                level 3 in structure "dbc" packed unaligned dcl 1-14
                                                                                  in procedure "dmdbs"
ofs                                    parameter       bit(18)                  unaligned dcl 859 ref 851 863 863
ok                              000671 automatic       bit(1)                   unaligned dcl 984 set ref 538* 539 551*
one_bit                         000670 automatic       bit(1)                   initial level 2 packed unaligned dcl 980 set ref
                                                                                  980*
open_mode                16            based           fixed bin(17,0)          level 3 packed unaligned dcl 2-57 ref 592 593 601
                                                                                  634
open_users                7            based           fixed bin(17,0)          level 4 dcl 1-14 ref 443 445
open_users_ofs           21            based           bit(18)                  level 4 packed unaligned dcl 1-14 set ref 458* 489*
                                                                                  513*
permit_string                   001402 automatic       varying char(128)        dcl 802 set ref 721* 735* 737* 737 739 739* 759* 759
                                                                                  762* 762 765* 765 768* 768 771 772* 798*
permits                   7(18)        based           structure                level 2 packed unaligned dcl 2-89
pid                      10     000625 automatic       char(12)                 level 2 packed unaligned dcl 962 set ref 580* 581*
prevent_string                  001443 automatic       varying char(128)        dcl 802 set ref 721* 744* 746* 746 748 748* 777* 777
                                                                                  780* 780 783* 783 786* 786 789 790* 798*
prevents                 10(02)        based           structure                level 2 packed unaligned dcl 2-89
pri                      22(27) 000625 automatic       char(6)                  level 2 packed unaligned dcl 962 set ref 614* 615*
                                                                                  619*
priority_high            16(21)        based           bit(1)                   level 3 packed unaligned dcl 2-57 ref 614
proc_flag                       000101 automatic       bit(1)                   initial unaligned dcl 920 set ref 98* 332* 363 510
                                                                                  556* 559* 581 589 594 606 608 627 920*
process_id               10            based           bit(36)                  level 3 packed unaligned dcl 2-57 set ref 516 580*
proper                                 based           structure                level 2 unaligned dcl 1-14
ptr                                                    builtin function         dcl 861 ref 863
queue_activ              16(25)        based           bit(1)                   level 3 packed unaligned dcl 2-57 ref 604
quiesce_db                4(03)        based           bit(1)                   level 4 packed unaligned dcl 1-14 ref 402
quiesce_files             4(04)        based           bit(1)                   level 4 packed unaligned dcl 1-14 ref 402
quiesce_lock              5            based           bit(36)                  level 3 dcl 1-14 set ref 434* 434 438 438
quiesce_sw                4(02)        based           bit(1)                   level 4 packed unaligned dcl 1-14 ref 402
read_attr                10(03)        based           bit(1)                   level 3 in structure "fil_list" packed unaligned
                                                                                  dcl 2-89 in procedure "dmdbs" ref 744 777
read_attr                10(01)        based           bit(1)                   level 3 in structure "fil_list" packed unaligned
                                                                                  dcl 2-89 in procedure "dmdbs" ref 735 759
relation                  1            based           char(32)                 array level 2 packed unaligned dcl 5-17 set ref 664*
                                                                                  667* 692
relation_block                         based           structure                level 1 unaligned dcl 4-26
release_temp_segment_           000054 constant        entry                    external dcl 1031 ref 900
result                          001534 automatic       pointer                  dcl 857 set ref 863* 865* 867
rtrim                                                  builtin function         dcl 991 ref 252 252 315
scope                    21     000625 automatic       char(7)                  level 2 packed unaligned dcl 962 set ref 603* 606*
                                                                                  613* 618* 629* 630*
secured                   1(01)        based           bit(1)                   level 2 packed unaligned dcl 6-20 ref 247
secured_submodel                001170 automatic       bit(1)                   unaligned dcl 1054 set ref 266* 278* 284
set_lock_$lock                  000030 constant        entry                    external dcl 1011 ref 876
sm_abs_path                     001253 automatic       char(168)                unaligned dcl 1057 set ref 167* 169* 172* 185* 194*
                                                                                  270* 272* 289*
sm_dir                          001201 automatic       char(168)                unaligned dcl 1056 set ref 270* 278*
sm_name                         001171 automatic       char(32)                 unaligned dcl 1055 set ref 270* 278*
state                    52     000332 automatic       char(24)                 level 2 in structure "hdr" packed unaligned dcl 951
                                                                                  in procedure "dmdbs" set ref 387* 389* 390*
state                    17(27) 000625 automatic       char(5)                  level 2 in structure "usr" packed unaligned dcl 962
                                                                                  in procedure "dmdbs" set ref 584* 586* 588* 589
                                                                                  589*
str_ptr                         001144 automatic       pointer                  dcl 1029 set ref 664* 681
string                                                 builtin function         dcl 991 ref 404
submodel                        001146 automatic       bit(1)                   unaligned dcl 1030 in procedure "dmdbs" set ref 161*
                                                                                  215* 266 285 636
submodel                 53(02)        based           bit(1)                   level 3 in structure "mrds_path_info" packed
                                                                                  unaligned dcl 3-22 in procedure "dmdbs" ref 162
submodel_iocb_ptr               001166 automatic       pointer                  initial dcl 1051 set ref 169* 183* 192* 664* 893*
                                                                                  1051*
submodel_open                   001147 automatic       bit(1)                   unaligned dcl 1032 set ref 102* 179* 891 894*
substr                                                 builtin function         dcl 991 ref 404
switch                  255     000332 automatic       char(24)                 level 2 packed unaligned dcl 951 set ref 395* 397*
                                                                                  398*
sys_info$max_seg_size           000032 external static fixed bin(17,0)          dcl 1012 ref 116
thr_bit_asc                            based           bit(3)                   array unaligned dcl 840 set ref 846*
thr_bit_bit                            based           bit(3)                   array unaligned dcl 841 ref 846
three_bits                      000670 automatic       structure                level 1 dcl 980
trouble_switch            4            based           bit(1)                   level 4 packed unaligned dcl 1-14 ref 395 398
type                     53            based           structure                level 2 dcl 3-22
ul_ptr                          001330 automatic       pointer                  initial dcl 2-109 set ref 2-109* 458* 460 462* 462
                                                                                  489* 491 492 493 499* 499 513* 514 516 520* 520
                                                                                  578 580 584 586 592 593 597 597 598* 601 602 604
                                                                                  612 614 616 617 620 634 638 677
undo_request                    001103 automatic       char(100)                unaligned dcl 1026 set ref 354*
update                   10            based           bit(1)                   level 3 in structure "fil_list" packed unaligned
                                                                                  dcl 2-89 in procedure "dmdbs" ref 737
update                   10(02)        based           bit(1)                   level 3 in structure "fil_list" packed unaligned
                                                                                  dcl 2-89 in procedure "dmdbs" ref 746
user_counts               7            based           structure                level 3 unaligned dcl 1-14
user_flag                       000100 automatic       bit(1)                   initial unaligned dcl 920 set ref 98* 335* 363 485
                                                                                  555* 560* 581 589 594 606 608 627 920*
user_list                              based           structure                level 1 unaligned dcl 2-57
usr                             000625 automatic       structure                level 1 unaligned dcl 962
version                                based           fixed bin(17,0)          level 3 dcl 1-14 set ref 382* 723 723 724* 731
waiting_sw               16(20)        based           bit(1)                   level 3 packed unaligned dcl 2-57 ref 612
waiting_users            11            based           fixed bin(17,0)          level 4 dcl 1-14 ref 448
wakeup_waiters            6            based           fixed bin(17,0)          level 3 dcl 1-14 ref 447
work_area                              based           area                     dcl 1033 set ref 116*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALARM                                  automatic       fixed bin(71,0)          dcl 2-127
ALIVE                                  internal static bit(1)                   initial unaligned dcl 2-136
CHAR_ALARM                             internal static char(8)                  initial unaligned dcl 2-125
CHAR_Q_F                               internal static char(8)                  initial unaligned dcl 2-123
DEAD                                   internal static bit(1)                   initial unaligned dcl 2-138
DEL                                    internal static bit(1)                   initial unaligned dcl 2-134
DQ_OPEN                                internal static bit(1)                   initial unaligned dcl 2-119
FIRST_QUEUE                            internal static bit(1)                   initial unaligned dcl 2-128
FREE_FIL_LIST                          internal static bit(1)                   initial unaligned dcl 2-150
NO_DQ_OPEN                             internal static bit(1)                   initial unaligned dcl 2-121
QUEUE_AGAIN                            internal static bit(1)                   initial unaligned dcl 2-130
QUE_FREE                               automatic       fixed bin(71,0)          dcl 2-124
Q_PRM                                  internal static fixed bin(35,0)          initial dcl 2-140
Q_PRM_BITS                             internal static bit(2)                   initial unaligned dcl 2-144
Q_PRV                                  internal static fixed bin(35,0)          initial dcl 2-142
Q_PRV_BITS                             internal static bit(2)                   initial unaligned dcl 2-146
RELATION_BLOCK_VERSION_1               internal static fixed bin(35,0)          initial dcl 4-24
REL_SEC                                internal static bit(2)                   initial unaligned dcl 2-148
SAVE_FIL_LIST                          internal static bit(1)                   initial unaligned dcl 2-152
SET                                    internal static bit(1)                   initial unaligned dcl 2-132
VERSION_NBR                            internal static fixed bin(17,0)          initial dcl 1-46
WAIT                                   internal static fixed bin(17,0)          initial dcl 2-115
mrds_dsm_relation_names_nrels_alloc    automatic       fixed bin(17,0)          dcl 5-21
rb_number_of_attributes                automatic       fixed bin(35,0)          dcl 4-23
rel                                                    builtin function         dcl 991
relation_block_ptr                     automatic       pointer                  dcl 4-22

NAMES DECLARED BY EXPLICIT CONTEXT.
ascii_to_bit                    006715 constant        entry                    internal dcl 807 ref 512
bit_to_ascii                    007006 constant        entry                    internal dcl 834 ref 580
clean_up                        007120 constant        entry                    internal dcl 886 ref 105 110 125 135 154 174 187 196
                                                                                  210 232 243 257 274 295 310 318 339 348 368 480
                                                                                  504 525 533 544 564 670 726
convert                         007035 constant        entry                    internal dcl 851 ref 458 462 489 499 513 520 638 648
                                                                                  677 683
db                              003371 constant        entry                    external dcl 374
db_report                       003404 constant        entry                    internal dcl 379 ref 363
display_mrds_db_status          001155 constant        entry                    external dcl 20
display_permits_prevents        006354 constant        entry                    internal dcl 716 ref 646 700
dmdbs                           001145 constant        entry                    external dcl 20
do_user                         005174 constant        entry                    internal dcl 576 ref 461 495 517
end_quiesce_case                003773 constant        label                    dcl 433 ref 407 411 415 419 423 427 431
live_process                    007060 constant        entry                    internal dcl 871 ref 434 586
quiesce_case                    000000 constant        label                    array(7) dcl 405 set ref 404
user_report                     004333 constant        entry                    internal dcl 467 ref 365

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     10010       10132    7240       10020
Length     10612    7240       122         444     547           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
dmdbs                              1234 external procedure  is an external procedure.  
on unit on line 105                  64 on unit               
db_report                               internal procedure  shares stack frame of external procedure dmdbs.  
user_report                             internal procedure  shares stack frame of external procedure dmdbs.  
do_user                                 internal procedure  shares stack frame of external procedure dmdbs.  
display_permits_prevents                internal procedure  shares stack frame of external procedure dmdbs.  
ascii_to_bit                            internal procedure  shares stack frame of external procedure dmdbs.  
bit_to_ascii                            internal procedure  shares stack frame of external procedure dmdbs.  
convert                                 internal procedure  shares stack frame of external procedure dmdbs.  
live_process                            internal procedure  shares stack frame of external procedure dmdbs.  
clean_up                             82 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 dbs                         dmdbs

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
dmdbs                    000100 user_flag                   dmdbs
                         000101 proc_flag                   dmdbs
                         000102 brief_flag                  dmdbs
                         000103 long_flag                   dmdbs
                         000104 found                       dmdbs
                         000105 nargs                       dmdbs
                         000106 dbp_len                     dmdbs
                         000107 comp_len                    dmdbs
                         000110 arg_count                   dmdbs
                         000111 arg_len                     dmdbs
                         000112 code                        dmdbs
                         000114 idx                         dmdbs
                         000116 comp_ptr                    dmdbs
                         000120 arg_ptr                     dmdbs
                         000122 dbp_ptr                     dmdbs
                         000124 db_dir                      dmdbs
                         000176 db_ent                      dmdbs
                         000206 in_path                     dmdbs
                         000260 db_path                     dmdbs
                         000332 hdr                         dmdbs
                         000625 usr                         dmdbs
                         000657 fila                        dmdbs
                         000670 three_bits                  dmdbs
                         000671 ok                          dmdbs
                         000672 bit_var                     dmdbs
                         000674 dbc_bit_count               dmdbs
                         000675 incon_value                 dmdbs
                         000676 incon_name                  dmdbs
                         000706 incon_message               dmdbs
                         001103 undo_request                dmdbs
                         001134 caller_name                 dmdbs
                         001144 str_ptr                     dmdbs
                         001146 submodel                    dmdbs
                         001147 submodel_open               dmdbs
                         001150 area_ptr                    dmdbs
                         001160 discard                     dmdbs
                         001161 done                        dmdbs
                         001162 header_output               dmdbs
                         001163 i                           dmdbs
                         001164 data_model_ptr              dmdbs
                         001166 submodel_iocb_ptr           dmdbs
                         001170 secured_submodel            dmdbs
                         001171 sm_name                     dmdbs
                         001201 sm_dir                      dmdbs
                         001253 sm_abs_path                 dmdbs
                         001325 db_model_open               dmdbs
                         001326 dbc_ptr                     dmdbs
                         001330 ul_ptr                      dmdbs
                         001332 fl_ptr                      dmdbs
                         001334 num_filns                   dmdbs
                         001336 mrds_path_info_ptr          dmdbs
                         001340 mrds_dsm_relation_names_ptr dmdbs
                         001342 database_state_ptr          dmdbs
                         001344 mrds_authorization_ptr      dmdbs
                         001402 permit_string               display_permits_prevents
                         001443 prevent_string              display_permits_prevents
                         001512 ch_ptr                      ascii_to_bit
                         001514 i                           ascii_to_bit
                         001524 i                           bit_to_ascii
                         001534 result                      convert
                         001544 icode                       live_process
                         001545 l                           live_process

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          enable_op           shorten_stack       ext_entry           int_entry           op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count                 cu_$arg_ptr                   expand_pathname_
get_temp_segment_             ioa_                          ioa_$nnl
mdbm_util_$inconsistent_get_info                            mrds_dm_authorization$get_user_class
mrds_dm_close                 mrds_dm_db_secured$get_secured_status                       mrds_dm_open
mrds_dm_secured_submodel      mrds_dsl_get_version$get_path_info                          mrds_dsm_close$force
mrds_dsm_get_relation_names   mrds_dsm_open$read            mrds_dsm_read_header$db_path  mrds_dsm_read_relation
mu_concurrency_control$get_control_segment                  release_temp_segment_         set_lock_$lock

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$lock_wait_time_exceeded
error_table_$locked_by_this_process                         error_table_$pathlong         mdbm_data_$normal_mode
mdbm_data_$quiesce_mode       mrds_data_$submodel_dir_name  mrds_error_$inc_secure_open   mrds_error_$no_database
mrds_error_$no_model_submodel mrds_error_$process_not_found mrds_error_$user_not_found
mrds_error_$version_not_supported                           sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    920 001123       980 001130      1027 001132      1051 001135    1   44 001137    2  109 001140    2  110 001141
     20 001144        97 001163        98 001164       102 001170       103 001172       105 001174       107 001216
    108 001237       109 001241       110 001243       111 001247       113 001301       116 001302       120 001306
    122 001315       123 001320       125 001345       126 001351       130 001352       131 001355       132 001374
    133 001376       135 001425       136 001431       142 001432       143 001437       146 001467       148 001477
    150 001503       151 001505       153 001512       154 001543       155 001547       161 001550       162 001551
    167 001555       169 001560       171 001601       172 001603       174 001641       175 001645       179 001646
    183 001650       184 001663       185 001665       187 001723       188 001727       192 001730       193 001745
    194 001747       196 002005       197 002011       202 002012       204 002042       205 002047       207 002053
    208 002055       210 002113       211 002117       215 002120       227 002122       229 002141       230 002143
    232 002201       233 002205       236 002206       238 002210       240 002227       241 002231       243 002267
    244 002273       247 002274       252 002301       254 002351       255 002354       257 002412       258 002416
    261 002417       266 002424       270 002430       271 002454       272 002456       274 002514       275 002520
    278 002521       284 002545       285 002550       289 002633       295 002737       296 002743       305 002744
    306 002770       308 002772       310 003024       311 003030       315 003031       317 003044       318 003073
    319 003077       323 003100       325 003103       326 003122       329 003137       332 003152       335 003165
    338 003174       339 003226       340 003232       345 003233       346 003250       347 003252       348 003304
    349 003310       354 003311       358 003342       360 003345       363 003354       365 003362       368 003363
    373 003367       374 003370       376 003377       377 003403       379 003404       381 003405       382 003410
    384 003432       385 003452       387 003476       389 003505       390 003510       392 003536       395 003562
    397 003573       398 003576       402 003621       404 003625       405 003631       406 003632       407 003646
    409 003647       410 003650       411 003664       413 003665       414 003666       415 003702       417 003703
    418 003704       419 003720       421 003721       422 003722       423 003736       425 003737       426 003740
    427 003754       429 003755       430 003756       431 003772       433 003773       434 003774       436 004031
    437 004045       438 004050       441 004073       443 004113       444 004117       445 004142       446 004145
    447 004150       448 004153       450 004156       451 004176       453 004224       456 004253       458 004257
    460 004272       461 004310       462 004311       463 004326       465 004332       467 004333       474 004334
    475 004336       477 004341       478 004356       479 004360       480 004411       481 004415       485 004416
    486 004420       487 004421       488 004433       489 004436       491 004451       492 004453       493 004460
    495 004475       496 004476       499 004500       500 004515       502 004516       503 004520       504 004552
    505 004556       509 004557       510 004560       511 004562       512 004563       513 004602       514 004615
    516 004626       517 004634       518 004635       520 004637       521 004654       523 004655       524 004657
    525 004711       526 004715       529 004716       532 004717       533 004752       534 004756       538 004757
    539 004760       541 004766       542 005006       543 005010       544 005043       545 005047       549 005050
    551 005074       552 005076       553 005077       554 005103       555 005111       556 005113       557 005114
    558 005115       559 005125       560 005127       561 005130       563 005131       564 005163       565 005167
    568 005170       571 005172       574 005173       576 005174       578 005175       579 005201       580 005221
    581 005232       583 005260       584 005262       586 005272       588 005311       589 005314       591 005355
    592 005360       593 005373       594 005400       596 005434       597 005437       598 005462       601 005503
    602 005510       603 005513       604 005516       605 005525       606 005530       608 005557       610 005624
    612 005625       613 005630       614 005633       615 005642       616 005645       617 005650       618 005653
    619 005674       620 005716       623 005736       624 005756       625 005776       627 005777       629 006005
    630 006010       634 006031       636 006036       638 006040       640 006052       641 006056       644 006072
    645 006076       646 006102       648 006103       649 006116       650 006117       658 006120       659 006121
    660 006122       664 006133       666 006167       667 006171       670 006234       671 006240       676 006241
    677 006242       678 006255       679 006260       681 006267       683 006300       685 006312       687 006313
    692 006320       694 006327       696 006332       697 006334       700 006350       704 006351       714 006353
    716 006354       721 006355       723 006357       724 006364       726 006422       727 006426       731 006427
    735 006431       737 006441       739 006453       744 006464       746 006473       748 006505       751 006516
    759 006517       762 006532       765 006544       768 006556       771 006570       772 006575       777 006601
    780 006613       783 006625       786 006637       789 006651       790 006656       798 006662       805 006714
    807 006715       821 006726       822 006731       824 006733       825 006741       828 006761       830 007003
    832 007005       834 007006       844 007010       845 007014       846 007021       847 007032       849 007034
    851 007035       863 007037       865 007053       867 007055       871 007060       875 007062       876 007064
    877 007100       886 007117       891 007125       893 007130       894 007136       898 007140       900 007144
    902 007165       906 007170       908 007172       910 007203       912 007205       916 007207


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
