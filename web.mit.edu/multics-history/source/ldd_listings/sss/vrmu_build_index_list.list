	COMPILATION LISTING OF SEGMENT vrmu_build_index_list
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/21/84  1435.4 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 vrmu_build_index_list: proc (vrm_rel_desc_ptr, vrm_open_info_ptr, tuple_ptr, change_bits_ptr, key_list_ptr, code);
       19 
       20 /* NOTES:
       21*
       22*   This procedure builds a list of indexes to be added or deleted from a tuple.
       23**/
       24 
       25 /* HISTORY:
       26*
       27*   Initially written by JA Weeldreyer -- July, 1978.
       28*   6-sept-79 Davids: Modified to accommodate a change to vrmu_encode_key calling sequence
       29*   18-oct-79 modified to correctly calculate the lengths of varying strings.
       30*   28-nov-79 Davids: Removed calculation of length (in bits) of varying strings
       31*   so that length word will consistantly contain the number of bits or characters
       32*   (depending on data type) throughtout MRDS (i hope).
       33*   8-may-80  Davids:  modified  assignments  of  tuple_num_atts  and
       34*   tuple_nvar_atts  to  take  values from rm_rel_info.model_num_attr
       35*   and  model_nvar_atts   rather   than   rm_rel_info.num_attr   and
       36*   nvar_atts.  This  was  to  fix  a problem with submodels were the
       37*   submodel view did not contain a varying string attribute and  the
       38*   model did.
       39*
       40*   Modified by Jim Gray - - June 1980, to make kl_ptr and input parameter,
       41*   so that the calling routine could decide if the same space for key_list
       42*   could be reused, which previously limited large modify operations.
       43*
       44*   81-05-29 Jim Gray : changed to use new resultant structure.
       45*
       46*   82-09-17 R. Harvey: Renamed from mu_build_indl and modified for use
       47*   by vfile_relmgr_.
       48*
       49**/
       50 
       51 	index_value_length,
       52 	     num_dims = 0;				/* This was part of descriptor... */
       53 
       54 	data_ptr = addr (tuple.data);
       55 
       56 	ksl_number_of_values, kl_number_of_keys = vrm_rel_desc.number_sec_indexes; /* set up the key list */
       57 
       58 	key_list.number_of_keys = 0;
       59 	cb_number_of_change_bits = vrm_rel_desc.number_attrs;
       60 
       61 
       62 	key_source_list_ptr = addr (local_ksl);		/* init for doing sec. indexes */
       63 	key_source_list.number_of_values = 1;
       64 	kv_ptr = addr (local_kv);
       65 
       66 	do i = 1 to vrm_open_info.number_of_index_collections; /* for every secondary index */
       67 
       68 	     vrm_collection_info_ptr = vrm_open_info.index_collection (i).info_ptr;
       69 	     attr_no = vrm_collection_info.attribute (1).attr_index;
       70 	     if change_bits.position (attr_no) then do;
       71 		     call add_key_source_list_item (1, addr (vrm_rel_desc.attr (attr_no)));
       72 		     call make_key_list_entry (vrm_collection_info.id);
       73 		     key_list.key_info.item_index (key_list.number_of_keys) = i; /* fill in index info */
       74 		     key_list.key_info.cand_key (key_list.number_of_keys),
       75 			key_list.key_info.unique_val (key_list.number_of_keys) = "0"b;
       76 		end;				/* if index changed */
       77 
       78 	end;					/* adding secondary indexes */
       79 
       80 	code = 0;
       81 
       82 exit:
       83 	return;
       84 
       85 add_key_source_list_item: proc (ind, raip);
       86 
       87 /* Procedure to add item to key source list */
       88 
       89 	dcl     ind		 fixed bin;
       90 	dcl     raip		 ptr;
       91 	dcl     bit_str		 bit (raip -> vrm_attr_info.bit_length) based;
       92 
       93 
       94 	desc_ptr = addr (raip -> vrm_attr_info.descriptor);
       95 	key_source_list.val_info.val_ptr (ind) = addr (key_vals (ind));
       96 	key_source_list.val_info.desc_ptr (ind) = desc_ptr;
       97 	if raip -> vrm_attr_info.varying then do;	/* move in var. len. attr */
       98 		offset = tuple.var_offsets (raip -> vrm_attr_info.bit_offset);
       99 		key_source_list.val_info.val_ptr (ind) = addr (bit_data (offset));
      100 	     end;					/* moving var. */
      101 	else /* moving fixed length */
      102 	     key_source_list.val_info.val_ptr (ind) -> bit_str = substr (data_str, raip -> vrm_attr_info.bit_offset,
      103 		raip -> vrm_attr_info.bit_length);
      104 
      105      end add_key_source_list_item;
      106 
      107 make_key_list_entry: proc (ind_id);
      108 
      109 /* Procedure to ad entry to key list */
      110 
      111 	dcl     ind_id		 bit (8) unal;
      112 
      113 	key_list.number_of_keys = key_list.number_of_keys + 1;
      114 	call vrmu_encode_key (key_source_list_ptr, key_list.key_info.key (key_list.number_of_keys), not_used, icode);
      115 	if icode ^= 0 then call error (icode);
      116 	index_ptr = addr (key_list.key_info.vf_info.key (key_list.number_of_keys));
      117 	index_ptr = addrel (index_ptr, 1);		/* get past length */
      118 	index.index_id = ind_id;
      119 	index.rel_id = vrm_rel_desc.rel_id;
      120 	key_list.key_info.vf_info.input_key (key_list.number_of_keys) = "1"b;
      121 	key_list.key_info.vf_info.input_desc (key_list.number_of_keys) = "0"b;
      122 
      123      end make_key_list_entry;
      124 
      125 error: proc (cd);
      126 
      127 /* error procedure */
      128 
      129 	dcl     cd		 fixed bin (35);
      130 
      131 	code = cd;
      132 	go to exit;
      133 
      134      end error;
      135 
  1     1 /*   BEGIN INCLUDE   vrm_open_info.incl.pl1		    */
  1     2 
  1     3 /* R. Harvey  82-11-02 
  1     4*   82-09-82 Roger Lackey: added iocb_list_ptr */
  1     5 
  1     6 dcl 1 vrm_open_info aligned based (vrm_open_info_ptr),	/* Vfile relation description */
  1     7     2 version char (8),				/* Version number of this structure */
  1     8     2 opening_id bit (36) aligned,			/* Opening id associated with this desc */
  1     9     2 file_uid bit (36) aligned,			/* Unique id of msf dir */
  1    10     2 number_of_openings fixed bin,			/* Number of separate calls to vrm$open */
  1    11     2 switches,
  1    12       3 shared bit (1) unal,				/* Open relation in shared mode */
  1    13       3 pad bit (35) unal init ("0"b),			/* Unused must be zero */
  1    14     2 database_dir_path char (168) varying,		/* Absolute path of database */
  1    15     2 relation_name char (30) varying,			/* Name of relation */
  1    16     2 relation_model_ptr pointer,			/* Pointer to the relation_model in the relation itself or a temp seg */
  1    17     2 com_ptr pointer,				/* Temp seg for cursors and scratch space */
  1    18     2 iocb_list_ptr pointer,				/* Pointer to first vrm_iocb_list_block */
  1    19     2 primary_key_info_ptr pointer,			/* Special case collection info ptr */
  1    20     2 number_of_index_collections fixed bin,		/* Count of index collections (include primary key) */
  1    21     2 index_collection (voi_no_of_index_collections
  1    22 		   refer (vrm_open_info.number_of_index_collections)),
  1    23       3 id bit (36),
  1    24       3 info_ptr ptr unal;				/* Points to more detailed info */
  1    25 
  1    26 
  1    27 dcl  VRM_OPEN_INFO_VERSION_1 char (8) int static options (constant) init ("       1");
  1    28 dcl  vrm_open_info_ptr ptr;
  1    29 dcl  voi_no_of_index_collections fixed bin;
  1    30 
  1    31 /*   END INCLUDE  vrm_open_info.incl.pl1	   */
      136 
      137 
  2     1 /*   BEGIN INCLUDE  vrm_rel_desc.incl.pl1		   */
  2     2 
  2     3 /* 83-05-26 Roger Lackey : Added vrm_attr_info.key_head bit for relation_cursors */
  2     4 
  2     5 dcl 1 vrm_rel_desc based (vrm_rel_desc_ptr),
  2     6     2 record_id bit (12) unal,			/* Distinguish us from tuples and collection records */
  2     7     2 version char (8),				/* Version of this structure */
  2     8     2 file_id bit (7),				/* Value of file id from model */
  2     9     2 rel_id bit (12),				/* Relation id */
  2    10     2 switches,
  2    11       3 MRDS_compatible bit (1) unal,			/* For pre-relation_manager_ MRDS */
  2    12       3 stationary_records
  2    13      bit (1) unal,					/* On = stationary */
  2    14       3 indexed bit (1) unal,				/* This relation has attributes with secondary indices */
  2    15       3 pad bit (33) unal,
  2    16     2 var_offset fixed bin (35),			/* Position of first varying attr */
  2    17     2 maximum_data_length
  2    18      fixed bin (35),				/* Maximum size of tuple in characters */
  2    19     2 number_primary_key_attrs
  2    20      fixed bin,					/* Number of attributes which make up the primary key */
  2    21     2 number_sec_indexes fixed bin,			/* Number of attributes which have a secondary index */
  2    22     2 last_var_attr_no fixed bin,			/* Attr index of last varying attribute */
  2    23     2 number_var_attrs fixed bin,			/* Number of varying attributes */
  2    24     2 number_attrs fixed bin,				/* Number of attribute in rel */
  2    25     2 attr (vrd_no_of_attrs				/* Description of each attribute */
  2    26      refer (vrm_rel_desc.number_attrs)) aligned like vrm_attr_info;
  2    27 
  2    28 dcl 1 vrm_attr_info based (vrm_attr_info_ptr),
  2    29 						/* Attribute specific info */
  2    30     2 name char (32),				/* Name of the attribute */
  2    31     2 descriptor bit (36) aligned,			/* domain descriptor */
  2    32     2 varying bit (1) unal,				/* ON = This is a varying string */
  2    33     2 key_head bit (1) unal,				/* ON = This attr can be a keyhead */
  2    34     2 primary_key_attr bit (1) unal,			/* ON = This is a primary key attribute */
  2    35     2 pad bit (15) unal,				/* unused */
  2    36     2 index_collextion_ix fixed bin (17) unal,		/* Index into vrm_open_info.index_collection array if key_head is on */
  2    37     2 bit_length fixed bin (35),			/* Maximum bit length of tuple */
  2    38     2 bit_offset fixed bin (35);			/* Offset in tuple if fixed, index to offset in tuple if varying */
  2    39 
  2    40 
  2    41 dcl  vrm_rel_desc_ptr pointer;
  2    42 dcl  vrd_no_of_attrs fixed bin;
  2    43 dcl  VRM_REL_DESC_RECORD_ID bit (12) unal int static options (constant) init ("100000000000"b);
  2    44 dcl  VRM_REL_DESC_VERSION_1 char (8) int static options (constant) init ("       1");
  2    45 dcl  vrm_attr_info_ptr pointer;
  2    46 dcl  VRM_REL_DESC_KEY char (256) varying int static options (constant) init ("@relation_description");
  2    47 
  2    48 /*   END INCLUDE  vrm_rel_desc.incl.pl1		   */
      138 
      139 
  3     1 /*   BEGIN INCLUDE   vrm_collection_info.incl.pl1		    */
  3     2 
  3     3 /*  R. Harvey  82-11-02 */
  3     4 
  3     5 
  3     6      dcl	   1 vrm_collection_info  aligned based (vrm_collection_info_ptr),
  3     7 						/* Index collection description */
  3     8 	     2 record_id	      unal,
  3     9 	       3 header	      bit (4) unal,		/* collection type */
  3    10 	       3 id	      bit (8) unal,		/* index id */
  3    11 	     2 unique	      bit (1) unal,
  3    12 	     2 primary_key	      bit (1) unal,		/* This is the MRDS primary key collection */
  3    13 	     2 pad	      bit (26) unal,
  3    14 	     2 number_of_attributes
  3    15 			      fixed bin,
  3    16 	     2 attribute	      (vci_no_of_attributes refer (vrm_collection_info.number_of_attributes)),
  3    17 	       3 attr_index	      fixed bin,		/* Attribute number in relation description */
  3    18 	       3 key_offset	      fixed bin,		/* Offset within key in bits */
  3    19 	       3 key_bit_len      fixed bin ;		/* Length of key in bits */
  3    20 
  3    21      dcl	   vrm_collection_info_ptr
  3    22 			      ptr;
  3    23      dcl	   vci_no_of_attributes   fixed bin;
  3    24      dcl	   vrm_collection_header_type
  3    25 			      bit (4) unal int static options (constant) init ("1100"b);
  3    26      dcl	   VRM_COLLECTION_KEY_HEAD char (16) int static options (constant) init ("@collection_info");
  3    27 
  3    28 /*   END INCLUDE  vrm_collection_info.incl.pl1	   */
      140 
      141 
  4     1 /* BEGIN vrm_tuple.incl.pl1 -- jaw, 7/25/78 */
  4     2 
  4     3 /* 82-08-27 R. Harvey: taken from mdbm_tuple.incl.pl1 for vfile_relmgr_.
  4     4*   Modified dimension references to point to entries in vrm_rel_desc.    */ 
  4     5 
  4     6 
  4     7 dcl 1 tuple aligned based (tuple_ptr),			/* tuple format, all file types */
  4     8     2 rel_id bit (12) unal,				/* relation id */
  4     9     2 attr_exists (vrm_rel_desc.number_attrs) bit (1) unal,	/* existance flags */
  4    10     2 var_offsets (vrm_rel_desc.number_var_attrs) fixed bin (35) unal, /* offsets for variable attr.; stored as len|value */
  4    11     2 force_even_word (tuple_pad_length) fixed bin (71) aligned, /* pad to even word boundary */
  4    12     2 data char (vrm_rel_desc.maximum_data_length) unal;		/* space for data */
  4    13 
  4    14 
  4    15 dcl  tuple_ptr ptr;
  4    16 dcl  tuple_length fixed bin (21);			/* byte count */
  4    17 
  4    18 declare  tuple_pad_length fixed bin internal static init (0) ; /* minimum array size needed for even word padding */
  4    19 
  4    20 
  4    21 
  4    22 /* END vrm_tuple.incl.pl1 */
  4    23 
      142 
      143 
  5     1 /* BEGIN mdbm_descriptor.incl.pl1 -- jaw 5/31/78 */
  5     2 /* modified by Jim Gray - - Nov. 1979, to change type from fixed bin(5) to
  5     3*   unsigned fixed bin(6), so new packed decimal data types could be handled.
  5     4*   also the duplicate mrds_descriptor.incl.pl1 was eliminated. */
  5     5 
  5     6 dcl 1 descriptor based (desc_ptr),			/* map of Multics descriptor */
  5     7     2 version bit (1) unal,				/* DBM handles vers. 1 only */
  5     8     2 type unsigned fixed bin (6) unal,			/* data type */
  5     9     2 packed bit (1) unal,				/* on if data item is packed */
  5    10     2 number_dims bit (4) unal,			/* dimensions */
  5    11     2 size,					/* size for string data */
  5    12       3 scale bit (12) unal,				/* scale for num. data */
  5    13       3 precision bit (12) unal,			/* prec. for num. data */
  5    14     2 array_info (num_dims),
  5    15       3 lower_bound fixed bin (35),			/* lower bound of dimension */
  5    16       3 upper_bound fixed bin (35),			/* upper bound of dimension */
  5    17       3 multiplier fixed bin (35);			/*  element separation */
  5    18 
  5    19 dcl  desc_ptr ptr;
  5    20 dcl  num_dims fixed bin init (0) ;			/* more useful form of number_dims */
  5    21 
  5    22 /* END mdbm_descriptor.incl.pl1 */
  5    23 
  5    24 
      144 
  6     1 /* BEGIN vrm_index.incl.pl1 -- jaw, 5/12/78 */
  6     2 
  6     3 /* Renamed 9/29/82 by R. Harvey */
  6     4 
  6     5 /* This structure defines the header that gets put onto the beginning of
  6     6*   each key stored into a database */
  6     7 
  6     8 
  6     9 dcl 1 index aligned based (index_ptr),			/* layout of mdbm_index for all file types */
  6    10     2 rel_id bit (12) unal,				/* relation id */
  6    11     2 index_id bit (8) unal,				/* id of index within rel */
  6    12     2 mbz bit (7) unal,				/* pad to char. */
  6    13     2 index_value char (index_value_length) unal;		/* index value; max 253 chars */
  6    14 
  6    15 dcl  index_ptr ptr;
  6    16 dcl  index_value_length fixed bin (35);
  6    17 
  6    18 /* END vrm_index.incl.pl1 */
  6    19 
      145 
  7     1 /* BEGIN vrm_key_list.incl.pl1 -- jaw, 1/17/79 */
  7     2 
  7     3 dcl 1 key_list aligned based (key_list_ptr),		/* list of keys for add_key or delete_key */
  7     4     2 number_of_keys fixed bin,			/* no. keys in list */
  7     5     2 key_info (kl_number_of_keys refer (key_list.number_of_keys)),
  7     6       3 item_index fixed bin,				/* attr. index or plink index */
  7     7       3 cand_key bit (1) unal,			/* on if key is for candidate key */
  7     8       3 unique_val bit (1) unal,			/* on if value must be unique */
  7     9       3 pad bit (34) unal,
  7    10       3 vf_info,					/* info for vfile control orders */
  7    11         4 input_key bit (1) unal,			/* if key val supplied */
  7    12         4 input_desc bit (1) unal,			/* if desc. supplied */
  7    13         4 reserved bit (34) unal,
  7    14         4 vf_desc,					/* vfile_ descriptor */
  7    15 	5 comp_no fixed bin (17) unal,
  7    16 	5 offset bit (18) unal,
  7    17         4 key char (256) var;
  7    18 
  7    19 dcl  key_list_ptr ptr;
  7    20 dcl  kl_number_of_keys fixed bin;
  7    21 
  7    22 /* END vrm_key_list.incl.pl1 */
      146 
  8     1 /* BEGIN vrm_key_source_list.incl.pl1 -- jaw, 6/1/78 */
  8     2 
  8     3 /* HISTORY:
  8     4*
  8     5*   81-07-18 Jim Gray : added pointer to the rm_attr_info for display purposes
  8     6*
  8     7*   81-07-19 Jim Gray : added condition that will  used  against  the
  8     8*   key value for display purposes
  8     9*   82-09-29  R. Harvey: Stolen and modified for vfile_relmgr_
  8    10*
  8    11**/
  8    12 
  8    13 
  8    14 dcl 1 key_source_list aligned based (key_source_list_ptr),	/* source info for key encoding */
  8    15     2 number_of_values fixed bin,			/* no. values in key */
  8    16     2 val_info (ksl_number_of_values refer (key_source_list.number_of_values)),
  8    17 /*      3 condition_code fixed bin,			/* encoding for condition used on this key attr */
  8    18       3 val_ptr ptr,				/* to value */
  8    19       3 desc_ptr ptr;				/* to descriptor */
  8    20 
  8    21 dcl  key_source_list_ptr ptr;
  8    22 dcl  ksl_number_of_values fixed bin;
  8    23 
  8    24 /* END vrm_key_source_list.incl.pl1 */
  8    25 
      147 
  9     1 /* BEGIN vrm_change_bits.incl.pl1 -- R. Harvey */
  9     2 
  9     3 dcl  1 change_bits based (change_bits_ptr),
  9     4        2 number_of_change_bits fixed bin (17),
  9     5        2 position (cb_number_of_change_bits refer (change_bits.number_of_change_bits)) bit (1) unal;
  9     6 
  9     7 dcl  cb_number_of_change_bits fixed bin;
  9     8 dcl  change_bits_ptr ptr;
  9     9 
  9    10 /* END vrm_change_bits.incl.pl1 */
      148 
      149 
      150 	dcl     (data_ptr,				/* pointer to tuple.data */
      151 	        kv_ptr)		 ptr;		/* pointer to aligned key source values */
      152 
      153 	dcl     i			 fixed bin;	/* internal index */
      154 
      155 	dcl     attr_no		 fixed bin;	/* temporary attribute index */
      156 
      157 	dcl     (code,				/* Output: status code */
      158 	        icode,				/* internal status code */
      159 	        offset)		 fixed bin (35);	/* bit position within tuple.data */
      160 
      161 	dcl     key_vals		 (ksl_number_of_values) char (vrm_data_$max_kattr_length) based (kv_ptr); /* to hold values so they are aligned */
      162 	dcl     local_kv		 (4, vrm_data_$max_kattr_length / 8) fixed bin (71); /* to avoid allocations */
      163 	dcl     1 local_ksl		 aligned,		/* to avoid allocations */
      164 		2 nvals		 fixed bin,
      165 		2 val_info	 (4) like key_source_list.val_info;
      166 	dcl     bit_data		 (vrm_rel_desc.maximum_data_length * 9) bit (1) unal based (data_ptr); /* array view of tupe.data */
      167 	dcl     data_str		 bit (vrm_rel_desc.maximum_data_length * 9) based (data_ptr); /* string view */
      168 
      169 
      170 	dcl     vrm_data_$max_kattr_length ext fixed bin (35);
      171 
      172 
      173 	dcl     (addr,
      174 	        addrel,
      175 	        substr)		 builtin;
      176 
      177 	dcl     not_used		 fixed bin (35);	/* parameter to vrmu_encode_key, not used by this routine */
      178 	dcl     vrmu_encode_key	 entry (ptr, char (256) var, fixed bin (35), fixed bin (35));
      179 
      180 
      181 
      182      end vrmu_build_index_list;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/21/84  0933.9  vrmu_build_index_list.pl1         >special_ldd>online>mrds_install>vrmu_build_index_list.pl1
136          1    10/14/83  1609.1  vrm_open_info.incl.pl1            >ldd>include>vrm_open_info.incl.pl1
138          2    10/14/83  1609.1  vrm_rel_desc.incl.pl1             >ldd>include>vrm_rel_desc.incl.pl1
140          3    10/14/83  1609.1  vrm_collection_info.incl.pl1      >ldd>include>vrm_collection_info.incl.pl1
142          4    10/14/83  1609.1  vrm_tuple.incl.pl1                >ldd>include>vrm_tuple.incl.pl1
144          5    10/14/83  1608.6  mdbm_descriptor.incl.pl1          >ldd>include>mdbm_descriptor.incl.pl1
145          6    10/14/83  1609.1  vrm_index.incl.pl1                >ldd>include>vrm_index.incl.pl1
146          7    10/14/83  1609.1  vrm_key_list.incl.pl1             >ldd>include>vrm_key_list.incl.pl1
147          8    10/14/83  1609.1  vrm_key_source_list.incl.pl1      >ldd>include>vrm_key_source_list.incl.pl1
148          9    10/14/83  1609.1  vrm_change_bits.incl.pl1          >ldd>include>vrm_change_bits.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
addr                                                   builtin function         dcl 173 ref 54 62 64 71 71 94 95 99 116
addrel                                                 builtin function         dcl 173 ref 117
attr                     14            based           structure                array level 2 dcl 2-5 set ref 71 71
attr_index                3            based           fixed bin(17,0)          array level 3 dcl 3-6 ref 69
attr_no                         000123 automatic       fixed bin(17,0)          dcl 155 set ref 69* 70 71 71
attribute                 3            based           structure                array level 2 dcl 3-6
bit_data                               based           bit(1)                   array unaligned dcl 166 set ref 99
bit_length               12            based           fixed bin(35,0)          level 2 dcl 2-28 ref 101 101
bit_offset               13            based           fixed bin(35,0)          level 2 dcl 2-28 ref 98 101
bit_str                                based           bit                      unaligned dcl 91 set ref 101*
cand_key                  2            based           bit(1)                   array level 3 packed unaligned dcl 7-3 set ref 74*
cb_number_of_change_bits        000115 automatic       fixed bin(17,0)          dcl 9-7 set ref 59*
cd                                     parameter       fixed bin(35,0)          dcl 129 ref 125 131
change_bits                            based           structure                level 1 unaligned dcl 9-3
change_bits_ptr                        parameter       pointer                  dcl 9-8 ref 18 70
code                                   parameter       fixed bin(35,0)          dcl 157 set ref 18 80* 131*
data                                   based           char                     level 2 packed unaligned dcl 4-7 set ref 54
data_ptr                        000116 automatic       pointer                  dcl 150 set ref 54* 99 101
data_str                               based           bit                      unaligned dcl 167 ref 101
desc_ptr                  4            based           pointer                  array level 3 in structure "key_source_list"
                                                                                  dcl 8-14 in procedure "vrmu_build_index_list" set
                                                                                  ref 96*
desc_ptr                        000102 automatic       pointer                  dcl 5-19 in procedure "vrmu_build_index_list" set
                                                                                  ref 94* 96
descriptor               10            based           bit(36)                  level 2 dcl 2-28 set ref 94
i                               000122 automatic       fixed bin(17,0)          dcl 153 set ref 66* 68 73*
icode                           000124 automatic       fixed bin(35,0)          dcl 157 set ref 114* 115 115*
id                        0(04)        based           bit(8)                   level 3 packed unaligned dcl 3-6 set ref 72*
ind                                    parameter       fixed bin(17,0)          dcl 89 ref 85 95 95 96 99 101
ind_id                                 parameter       bit(8)                   unaligned dcl 111 ref 107 118
index                                  based           structure                level 1 dcl 6-9
index_collection        103            based           structure                array level 2 dcl 1-6
index_id                  0(12)        based           bit(8)                   level 2 packed unaligned dcl 6-9 set ref 118*
index_ptr                       000106 automatic       pointer                  dcl 6-15 set ref 116* 117* 117 118 119
index_value_length              000110 automatic       fixed bin(35,0)          dcl 6-16 set ref 51*
info_ptr                104            based           pointer                  array level 3 packed unaligned dcl 1-6 ref 68
input_desc                3(01)        based           bit(1)                   array level 4 packed unaligned dcl 7-3 set ref 121*
input_key                 3            based           bit(1)                   array level 4 packed unaligned dcl 7-3 set ref 120*
item_index                1            based           fixed bin(17,0)          array level 3 dcl 7-3 set ref 73*
key                       5            based           varying char(256)        array level 4 dcl 7-3 set ref 114* 116
key_info                  1            based           structure                array level 2 dcl 7-3
key_list                               based           structure                level 1 dcl 7-3
key_list_ptr                           parameter       pointer                  dcl 7-19 ref 18 58 73 73 74 74 74 74 113 113 114 114
                                                                                  116 116 120 120 121 121
key_source_list                        based           structure                level 1 dcl 8-14
key_source_list_ptr             000112 automatic       pointer                  dcl 8-21 set ref 62* 63 95 96 99 101 114*
key_vals                               based           char                     array unaligned dcl 161 set ref 95
kl_number_of_keys               000111 automatic       fixed bin(17,0)          dcl 7-20 set ref 56*
ksl_number_of_values            000114 automatic       fixed bin(17,0)          dcl 8-22 set ref 56*
kv_ptr                          000120 automatic       pointer                  dcl 150 set ref 64* 95
local_ksl                       000126 automatic       structure                level 1 dcl 163 set ref 62
local_kv                        000126 automatic       fixed bin(71,0)          array dcl 162 set ref 64
maximum_data_length       6            based           fixed bin(35,0)          level 2 dcl 2-5 ref 54 101
not_used                        000150 automatic       fixed bin(35,0)          dcl 177 set ref 114*
num_dims                        000104 automatic       fixed bin(17,0)          initial dcl 5-20 set ref 51* 5-20*
number_attrs             13            based           fixed bin(17,0)          level 2 dcl 2-5 ref 54 59 98
number_of_index_collections
                        102            based           fixed bin(17,0)          level 2 dcl 1-6 ref 66
number_of_keys                         based           fixed bin(17,0)          level 2 dcl 7-3 set ref 58* 73 74 74 113* 113 114
                                                                                  116 120 121
number_of_values                       based           fixed bin(17,0)          level 2 dcl 8-14 set ref 63*
number_sec_indexes       10            based           fixed bin(17,0)          level 2 dcl 2-5 ref 56
number_var_attrs         12            based           fixed bin(17,0)          level 2 dcl 2-5 ref 54
offset                          000125 automatic       fixed bin(35,0)          dcl 157 set ref 98* 99
position                  1            based           bit(1)                   array level 2 packed unaligned dcl 9-3 ref 70
raip                                   parameter       pointer                  dcl 90 ref 85 94 97 98 101 101 101
record_id                              based           structure                level 2 packed unaligned dcl 3-6
rel_id                                 based           bit(12)                  level 2 in structure "index" packed unaligned
                                                                                  dcl 6-9 in procedure "vrmu_build_index_list" set
                                                                                  ref 119*
rel_id                    2(25)        based           bit(12)                  level 2 in structure "vrm_rel_desc" packed unaligned
                                                                                  dcl 2-5 in procedure "vrmu_build_index_list" ref
                                                                                  119
substr                                                 builtin function         dcl 173 ref 101
tuple                                  based           structure                level 1 dcl 4-7
tuple_pad_length                       constant        fixed bin(17,0)          initial dcl 4-18 ref 54
tuple_ptr                              parameter       pointer                  dcl 4-15 ref 18 54 98
unique_val                2(01)        based           bit(1)                   array level 3 packed unaligned dcl 7-3 set ref 74*
val_info                  2            based           structure                array level 2 dcl 8-14
val_ptr                   2            based           pointer                  array level 3 dcl 8-14 set ref 95* 99* 101
var_offsets                            based           fixed bin(35,0)          array level 2 packed unaligned dcl 4-7 ref 98
varying                  11            based           bit(1)                   level 2 packed unaligned dcl 2-28 ref 97
vf_info                   3            based           structure                array level 3 dcl 7-3
vrm_attr_info                          based           structure                level 1 unaligned dcl 2-28
vrm_collection_info                    based           structure                level 1 dcl 3-6
vrm_collection_info_ptr         000100 automatic       pointer                  dcl 3-21 set ref 68* 69 72
vrm_data_$max_kattr_length      000010 external static fixed bin(35,0)          dcl 170 ref 95 95 95 162
vrm_open_info                          based           structure                level 1 dcl 1-6
vrm_open_info_ptr                      parameter       pointer                  dcl 1-28 ref 18 66 68
vrm_rel_desc                           based           structure                level 1 unaligned dcl 2-5
vrm_rel_desc_ptr                       parameter       pointer                  dcl 2-41 ref 18 54 54 54 56 59 71 71 98 101 119
vrmu_encode_key                 000012 constant        entry                    external dcl 178 ref 114

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
VRM_COLLECTION_KEY_HEAD                internal static char(16)                 initial unaligned dcl 3-26
VRM_OPEN_INFO_VERSION_1                internal static char(8)                  initial unaligned dcl 1-27
VRM_REL_DESC_KEY                       internal static varying char(256)        initial dcl 2-46
VRM_REL_DESC_RECORD_ID                 internal static bit(12)                  initial unaligned dcl 2-43
VRM_REL_DESC_VERSION_1                 internal static char(8)                  initial unaligned dcl 2-44
descriptor                             based           structure                level 1 unaligned dcl 5-6
tuple_length                           automatic       fixed bin(21,0)          dcl 4-16
vci_no_of_attributes                   automatic       fixed bin(17,0)          dcl 3-23
voi_no_of_index_collections            automatic       fixed bin(17,0)          dcl 1-29
vrd_no_of_attrs                        automatic       fixed bin(17,0)          dcl 2-42
vrm_attr_info_ptr                      automatic       pointer                  dcl 2-45
vrm_collection_header_type             internal static bit(4)                   initial unaligned dcl 3-24

NAMES DECLARED BY EXPLICIT CONTEXT.
add_key_source_list_item        000173 constant        entry                    internal dcl 85 ref 71
error                           000352 constant        entry                    internal dcl 125 ref 115
exit                            000172 constant        label                    dcl 82 ref 132
make_key_list_entry             000265 constant        entry                    internal dcl 107 ref 72
vrmu_build_index_list           000012 constant        entry                    external dcl 18

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       446         462     375         456
Length      1030     375        14         332      51           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
vrmu_build_index_list               153 external procedure  is an external procedure.  
add_key_source_list_item                internal procedure  shares stack frame of external procedure vrmu_build_index_list.  
make_key_list_entry                     internal procedure  shares stack frame of external procedure vrmu_build_index_list.  
error                                   internal procedure  shares stack frame of external procedure vrmu_build_index_list.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
vrmu_build_index_list    000100 vrm_collection_info_ptr     vrmu_build_index_list
                         000102 desc_ptr                    vrmu_build_index_list
                         000104 num_dims                    vrmu_build_index_list
                         000106 index_ptr                   vrmu_build_index_list
                         000110 index_value_length          vrmu_build_index_list
                         000111 kl_number_of_keys           vrmu_build_index_list
                         000112 key_source_list_ptr         vrmu_build_index_list
                         000114 ksl_number_of_values        vrmu_build_index_list
                         000115 cb_number_of_change_bits    vrmu_build_index_list
                         000116 data_ptr                    vrmu_build_index_list
                         000120 kv_ptr                      vrmu_build_index_list
                         000122 i                           vrmu_build_index_list
                         000123 attr_no                     vrmu_build_index_list
                         000124 icode                       vrmu_build_index_list
                         000125 offset                      vrmu_build_index_list
                         000126 local_ksl                   vrmu_build_index_list
                         000126 local_kv                    vrmu_build_index_list
                         000150 not_used                    vrmu_build_index_list

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return              alloc_auto_adj      ext_entry           trunc_fx2           divide_fx1

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
vrmu_encode_key

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
vrm_data_$max_kattr_length




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     18 000004    5   20 000017       162 000020        51 000035        54 000037        56 000062        58 000065
     59 000067        62 000071        63 000073        64 000075        66 000077        68 000111        69 000117
     70 000121        71 000127        72 000140        73 000150        74 000160        78 000166        80 000170
     82 000172        85 000173        94 000175        95 000201        96 000214        97 000215        98 000224
     99 000245       100 000253       101 000254       105 000264       107 000265       113 000267       114 000272
    115 000312       116 000316       117 000325       118 000327       119 000334       120 000345       121 000347
    123 000351       125 000352       131 000354       132 000357


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
