	COMPILATION LISTING OF SEGMENT open_uns_file
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/04/82  1736.2 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* changed October, 1978 by Jim Paradise to impliment the -no_end option (see end of source for comments) */
       12 
       13 open_uns_file:
       14      proc (iocb_ptr, fcb_ptr_arg, first_seg_ptr, is_new_file, mode, close_x, first_seg_bitcount, max_component_size, code);
       15 
       16 	code = 0;
       17 	if atb.header_present			/* -header attach option present */
       18 	then if is_new_file				/*  set header identifier in new file */
       19 	     then do;				/* initialize header */
       20 		     call hcs_$set_bc_seg (first_seg_ptr, 36 * size (header), code);
       21 		     if code ^= 0
       22 		     then return;			/* shouldn't happen */
       23 		     first_seg_ptr -> header.identifier = atb.header_id;
       24 		end;
       25 	     else if (first_seg_ptr -> file_code ^= uns_code)
       26 		     | ((first_seg_ptr -> header.identifier ^= atb.header_id) & (atb.header_id ^= 0))
       27 	     then do;				/* signal error--identifiers must match */
       28 		     code = error_table_$incompatible_attach;
       29 		     return;			/* opening is unsuccessful */
       30 		end;
       31 	call create_initialize_cb;
       32 	close_x = close_uns_file;
       33 	control = control_uns_file;
       34 	if mode = 1				/* input */
       35 	then do;
       36 		get_line = get_line_uns_file;
       37 		get_chars = get_chars_uns_file;
       38 		position = position_uns_file;
       39 	     end;
       40 	else if mode = 2				/* output */
       41 	then do;
       42 		put_chars = fast_put;
       43 	     end;
       44 	else do;					/* input - output */
       45 		get_line = get_line_uns_file;
       46 		get_chars = get_chars_uns_file;
       47 		position = position_uns_file;
       48 		put_chars = fast_put;
       49 	     end;
       50 	return;					/* end open routine */
       51 
       52 control_uns_file:
       53      entry (iocb_ptr, order, info_ptr, code);
       54 	code = 0;
       55 	call get_current_state;
       56 
       57 	if order = "read_position"
       58 	then if current_state = read_state
       59 	     then do;
       60 		     info.next_position = base_pos + read_pos - 1;
       61 						/* essentially the defining
       62*						   relationship for absolute position in the read state */
       63 		     info.end_position = end_pos;	/* always valid in read state */
       64 		end;
       65 	     else if current_state = write_state
       66 	     then do;
       67 		     info.next_position = base_pos + write_pos - 1;
       68 						/* -1 because byte offset
       69*						   starts with 1 at base of segment */
       70 		     info.end_position = info.next_position;
       71 						/* pos always at eof in write state */
       72 		end;
       73 	     else do;				/* beyond eof */
       74 		     info.next_position = base_pos + write_pos - 1;
       75 		     info.end_position = end_pos;
       76 		end;
       77 
       78 /* for debugging
       79*   else if order = "display_uns_cb" then call display_uns_cb;
       80**/
       81 
       82 	else if (order = "truncate") & (^input_only)
       83 	then do;
       84 		if current_state = read_state
       85 		then do;				/* might not be at eof so truncate */
       86 			call truncate_and_change_to_write;
       87 			code = foo;		/* what the hell */
       88 		     end;
       89 		else if current_state = beyond_eof_state
       90 		then code = error_table_$no_operation;	/* not allowed */
       91 	     end;
       92 
       93 	else if order = "file_status"
       94 	then do;
       95 		call vfile_status_$seg (iocb_ptr, file_base_ptr, info_ptr, code);
       96 		return;
       97 	     end;
       98 
       99 	else if order = "io_call"
      100 	then call vfile_io_control (iocb_ptr, file_base_ptr, info_ptr, code);
      101 	else code = error_table_$no_operation;
      102 
      103 	return;					/* end of control routine */
      104 
      105 create_initialize_cb:
      106      proc;
      107 	call alloc_cb_file (size (cb_uns_file), open_data_ptr);
      108 	write_limit = 4 * max_component_size + 1;
      109 	beyond_limits = 2 ** 34 - 1;
      110 	fcb_ptr = fcb_ptr_arg;
      111 	seg_ptr = first_seg_ptr;
      112 	call hcs_$status_mins (seg_ptr, foo2, bitcount, foo35);
      113 	component = 0;
      114 	header_is_present = atb.header_present;		/* -header option was used for attachment */
      115 	if header_is_present
      116 	then base_pos = -4 * size (header);		/* absolute byte position of file base is negative */
      117 	else base_pos = 0;				/* no header--first byte is byte_0 */
      118 	if is_new_file & header_is_present
      119 	then end_seg = 4 * size (header) + 1;
      120 	else end_seg = divide (first_seg_bitcount + 8, 9, 21, 0) + 1;
      121 	read_pos = 1 - base_pos;			/* byte offset of zeroth position in file */
      122 	tail_len = end_seg - read_pos;		/* bytes remaining beyond next_pos in this segment */
      123 	write_pos, old_write_pos = beyond_limits;	/* start in read state */
      124 	input_only = (mode = 1);			/* stream_input */
      125 	ssf_sw = atb.ssf;				/* -ssf option indicates no msf's allowed */
      126 	noend = atb.noend_sw;			/* -no_end attach option */
      127 	is_msf = atb.msf;				/* on if already an msf */
      128 	append_sw = atb.appending;			/* -append attachment */
      129 	no_trunc_sw = atb.no_trunc;			/* -no_trunc attach option */
      130 	current_state = read_state;
      131 	call set_end_pos;				/* gets total byte count of file */
      132 	if (mode = 2) | (^append_sw & ^no_trunc_sw & (mode = 3))
      133 						/* start in write state */
      134 	then do;
      135 		write_pos, old_write_pos = read_pos;	/* tail_len already zero */
      136 		current_state = write_state;		/* for completeness */
      137 	     end;
      138 	file_base_ptr = seg_ptr;
      139      end;						/* end create_initialize_cb */
      140 
      141 
      142 close_uns_file:
      143      entry (iocb_ptr);
      144 	call get_current_state;
      145 	call change_to_read_state;
      146 						/* sets bit count of file */
      147 	call free_cb_file (size (cb_uns_file), open_data_ptr);
      148 	return;					/* end close routine */
      149 
      150 get_chars_uns_file:
      151      entry (iocb_ptr, buff_ptr, buff_len, rec_len, code);
      152 	call get_current_state;
      153 	if current_state = beyond_eof_state
      154 	then do;
      155 		code = error_table_$end_of_info;
      156 		rec_len = 0;			/* no data */
      157 		return;
      158 	     end;
      159 	len = min (tail_len, buff_len);
      160 	if len > 0
      161 	then do;
      162 		buffer = record_read;
      163 		read_pos = read_pos + len;
      164 		tail_len = tail_len - len;
      165 		if buff_len = len			/* all bytes moved */
      166 		then do;
      167 			code = 0;
      168 			rec_len = len;
      169 		     end;
      170 		else do;				/* exceptional case_end of segment */
      171 			call get_chars_uns_file (iocb_ptr, addr (buff_tail), buff_len - len, rec_len, code);
      172 			rec_len = rec_len + len;
      173 			if (code ^= 0) & (rec_len > 0)
      174 			then code = error_table_$short_record;
      175 		     end;
      176 	     end;
      177 	else if buff_len <= 0
      178 	then do;					/* no move */
      179 		code = 0;
      180 		rec_len = 0;
      181 	     end;
      182 	else do;					/* end of segment case */
      183 		call next_seg_read;
      184 		if code ^= 0 & code ^= error_table_$end_of_info
      185 						/* msf error */
      186 		then return;
      187 		if code ^= 0
      188 		then rec_len = 0;
      189 		else call get_chars_uns_file (iocb_ptr, buff_ptr, buff_len, rec_len, code);
      190 	     end;
      191 	return;					/* end get chars routine */
      192 
      193 get_line_uns_file:
      194      entry (iocb_ptr, buff_ptr, buff_len, rec_len, code);
      195 	call get_current_state;
      196 	if current_state = beyond_eof_state
      197 	then do;
      198 		code = error_table_$end_of_info;
      199 		rec_len = 0;			/* no data */
      200 		return;
      201 	     end;
      202 	len = min (tail_len, buff_len);
      203 	if len > 0
      204 	then do;
      205 		len2 = len;
      206 		len = index (record_read, new_line);
      207 		if len ^= 0			/* new line found */
      208 		then do;
      209 			code = 0;
      210 			buffer = record_read;
      211 			rec_len = len;
      212 			read_pos = read_pos + len;
      213 			tail_len = tail_len - len;
      214 		     end;
      215 		else do;				/* new_line not found */
      216 			len = len2;
      217 			buffer = record_read;	/* move len bytes */
      218 			read_pos = read_pos + len;
      219 			tail_len = tail_len - len;
      220 			if buff_len = len
      221 			then do;			/* long record case */
      222 				rec_len = len;
      223 				code = error_table_$long_record;
      224 			     end;
      225 			else do;			/* end of segment case */
      226 				call get_line_uns_file (iocb_ptr, addr (buff_tail), buff_len - len, rec_len, code);
      227 				rec_len = rec_len + len;
      228 				if (code ^= 0) & (rec_len > 0)
      229 				then code = error_table_$short_record;
      230 			     end;
      231 		     end;
      232 	     end;
      233 	else if buff_len <= 0
      234 	then do;					/* no move */
      235 		code = error_table_$long_record;
      236 		rec_len = 0;
      237 	     end;
      238 	else do;					/* end of segment case */
      239 		call next_seg_read;
      240 		if code ^= 0 & code ^= error_table_$end_of_info
      241 						/* msf error */
      242 		then return;
      243 		if code ^= 0
      244 		then rec_len = 0;
      245 		else call get_line_uns_file (iocb_ptr, buff_ptr, buff_len, rec_len, code);
      246 	     end;
      247 	return;					/* end of get_line routine */
      248 
      249 skip_record:
      250      proc;					/* skips one record and (as needed by read) increments len2 by
      251*						   length skipped, excluding new_line */
      252 	do while ("1"b);				/* may cross boundaries of msf components */
      253 	     len = tail_len;
      254 	     if len ^= 0
      255 	     then do;
      256 		     len = index (record_read, new_line);
      257 		     if len ^= 0
      258 		     then do;			/* new line found */
      259 			     code = 0;
      260 			     len2 = len2 + len - 1;
      261 			     read_pos = read_pos + len;
      262 			     tail_len = tail_len - len;
      263 			     return;
      264 			end;
      265 		     else do;			/* record extends to next seg */
      266 			     len2 = len2 + tail_len;
      267 			     read_pos = read_pos + tail_len;
      268 			     tail_len = 0;
      269 			end;
      270 		end;
      271 	     else do;				/* at end of seg */
      272 		     call next_seg_read;
      273 		     if code ^= 0
      274 		     then return;
      275 		end;
      276 	end;
      277      end;						/* end skip record */
      278 
      279 next_seg_read:
      280      proc;
      281 	if current_state ^= read_state
      282 	then code = error_table_$end_of_info;
      283 	else do;
      284 		foo = 0;
      285 		if ^is_msf
      286 		then next_seg_ptr = null;
      287 		else do;
      288 			call msf_manager_$get_ptr (fcb_ptr, component + 1, "0"b, next_seg_ptr, bitcount, foo);
      289 		     end;
      290 		if next_seg_ptr = null
      291 		then do;
      292 			if foo ^= 0		/* msf error? */
      293 			then do;			/* return a code back */
      294 				if foo = error_table_$noentry
      295 						/* way to find eof */
      296 				then code = error_table_$end_of_info;
      297 				else code = foo;	/* return the code */
      298 			     end;
      299 			else code = error_table_$end_of_info;
      300 			return;
      301 		     end;
      302 		else do;
      303 			base_pos = base_pos + end_seg - 1;
      304 						/* absolute byte position of new seg base */
      305 			seg_ptr = next_seg_ptr;
      306 			call hcs_$status_mins (seg_ptr, foo2, bitcount, foo35);
      307 			component = component + 1;
      308 			tail_len = divide (bitcount + 8, 9, 21, 0);
      309 			end_seg = tail_len + 1;
      310 			read_pos = 1;
      311 			code = 0;
      312 		     end;
      313 	     end;
      314      end;						/* end next seg read */
      315 
      316 position_uns_file:
      317      entry (iocb_ptr, pos_type, skip, code);
      318 	call get_current_state;
      319 	if pos_type = 0
      320 	then call position_skip;
      321 	else if pos_type = 2			/* direct positioning */
      322 	then call position_abs;
      323 	else if pos_type = 1
      324 	then call position_eof;
      325 	else if pos_type ^= -1
      326 	then code = error_table_$bad_arg;
      327 	else call position_bof;
      328 	return;					/* end position routine */
      329 
      330 change_to_read_state:
      331      proc;					/* no effect if already in read state */
      332 	if current_state = read_state
      333 	then return;
      334 	if current_state = beyond_eof_state
      335 	then write_pos, old_write_pos = beyond_limits;	/* switch to read state
      336*						   no change, since the positioning absolute to beyond eof
      337*						   did a position_eof before everything */
      338 	else do;
      339 		end_seg = write_pos;
      340 		read_pos = write_pos;
      341 		end_pos = base_pos + end_seg - 1;	/* must be last comp since write state */
      342 		tail_len = 0;
      343 		write_pos, old_write_pos = beyond_limits;
      344 		call hcs_$set_bc_seg (seg_ptr, 9 * (end_seg - 1), foo);
      345 	     end;
      346      end;						/* end change_to_read_state */
      347 
      348 
      349 position_abs:
      350      proc;					/* sets position directly to specified byte */
      351 	if skip < 0				/* negative absolute position is undefined */
      352 	then code = error_table_$negative_nelem;
      353 	else do;
      354 		call change_to_read_state;
      355 		code = 0;
      356 		if skip >= end_pos
      357 		then do;
      358 			call position_eof;
      359 			if skip > end_pos		/* attempt to pass eof */
      360 			then if ^noend		/* not allowed by specifying -no_end */
      361 			     then code = error_table_$end_of_info;
      362 			     else do;		/* -no_end specified */
      363 				     write_pos, old_write_pos = skip + 1 - base_pos;
      364 						/* set the position beyond to the absolute position: */
      365 				     current_state = beyond_eof_state;
      366 				end;		/* segment(s) may not be defined */
      367 			return;			/* done processing in this case */
      368 		     end;
      369 
      370 		do while ((skip < base_pos) & (code = 0));
      371 						/* requested pos in previous component */
      372 		     call prev_seg_read;
      373 		end;
      374 
      375 		do while ((skip >= base_pos + end_seg) & (code = 0));
      376 						/* requested pos in succeeding component */
      377 		     call next_seg_read;
      378 		end;
      379 
      380 		if code ^= 0 & code ^= error_table_$end_of_info
      381 						/* msf error */
      382 		then return;
      383 
      384 		if code = 0			/* position lies within current segment */
      385 		then do;
      386 			read_pos = skip + 1 - base_pos;
      387 						/* set next byte offset for reading */
      388 			tail_len = end_seg - read_pos;
      389 						/* bytes following next in this segment */
      390 		     end;
      391 	     end;
      392      end position_abs;
      393 
      394 position_skip:
      395      proc;
      396 	if skip > 0
      397 	then do;					/* check if pos'ed after eof */
      398 		if current_state = beyond_eof_state
      399 		then do;
      400 			code = error_table_$end_of_info;
      401 			return;
      402 		     end;
      403 		else do;				/* forwards skip */
      404 			code = 0;
      405 			count = skip;
      406 			do while (count > 0);
      407 			     len2 = 0;		/* skip record increments this for read */
      408 			     call skip_record;
      409 			     if code ^= 0 & code ^= error_table_$end_of_info
      410 						/* msf error */
      411 			     then return;
      412 			     if code ^= 0
      413 			     then count = 0;
      414 			     else count = count - 1;
      415 			end;
      416 		     end;
      417 	     end;
      418 	else do;					/* backwards skip */
      419 		count = -skip;
      420 		code = 0;
      421 		call change_to_read_state;
      422 		do while (count > 0);
      423 		     call find_preceding_new_line;
      424 		     if code = 0
      425 		     then count = count - 1;
      426 		     else count = 0;
      427 		end;
      428 		if code = 0			/* positioned at new_line character */
      429 		then do;
      430 			call find_preceding_new_line;
      431 			if code = 0		/* positioned at new_line character */
      432 			then call get_chars_uns_file (iocb_ptr, addr (dummy_buffer), 1, foo21, foo);
      433 						/* skips over new line character */
      434 			code = 0;
      435 		     end;
      436 	     end;
      437      end position_skip;
      438 
      439 find_preceding_new_line:
      440      proc;
      441 						/* this moves read_pos back to first preceding new_line
      442*						   character or beginning of file if there is none.
      443*						   In the latter case code is set to end_of_info */
      444 
      445 	do while (code = 0);			/* may cross msf component boundaries */
      446 	     flag = "1"b;
      447 	     k = read_pos;
      448 	     if header_is_present
      449 	     then if component = 0
      450 		then min_pos = 4 * size (header) + 1;	/* can't position beneath header */
      451 		else min_pos = 1;
      452 	     else min_pos = 1;
      453 	     do while (flag);
      454 		k = k - 1;
      455 		if k < min_pos			/* at base of segment */
      456 		then flag = "0"b;
      457 		else if seg (k) = new_line
      458 		then flag = "0"b;
      459 	     end;
      460 	     if k >= min_pos			/* new_line found */
      461 	     then do;
      462 		     code = 0;
      463 		     read_pos = k;
      464 		     tail_len = end_seg - k;
      465 		     return;
      466 		end;
      467 	     else do;				/* beginning of segment */
      468 		     read_pos = min_pos;
      469 		     tail_len = end_seg - read_pos;
      470 		     if component = 0		/* beginning of file */
      471 		     then do;
      472 			     code = error_table_$end_of_info;
      473 			     return;
      474 			end;
      475 		     else call prev_seg_read;		/* moves pos to end of prev seg */
      476 		end;
      477 	end;
      478 
      479 	dcl     flag		 bit (1) aligned;
      480 	dcl     (k, min_pos)	 fixed bin (21);
      481      end;						/* end_find_preceding_line */
      482 	dcl     count		 fixed bin;
      483 	dcl     foo21		 fixed bin (21);
      484 
      485 position_eof:
      486      proc;
      487 	if current_state = beyond_eof_state
      488 	then do;
      489 		call change_to_read_state;
      490 	     end;
      491 	code = 0;
      492 	if current_state = read_state
      493 	then do;
      494 		do while (code = 0);
      495 		     call next_seg_read;
      496 		end;
      497 		if code ^= error_table_$end_of_info	/* msf error */
      498 		then return;
      499 		code = 0;
      500 		read_pos = end_seg;
      501 		tail_len = 0;
      502 	     end;
      503      end;						/* end position_eof */
      504 
      505 position_bof:
      506      proc;					/* sets position to beginning of file */
      507 	code = 0;
      508 	call change_to_read_state;
      509 	if ^is_msf
      510 	then do;					/* current segment must be first */
      511 		read_pos = 1 - base_pos;
      512 		tail_len = end_seg - read_pos;
      513 		return;
      514 	     end;
      515 	call msf_manager_$get_ptr (fcb_ptr, 0, "0"b, next_seg_ptr, bitcount, foo);
      516 	if next_seg_ptr ^= null
      517 	then do;
      518 		seg_ptr = next_seg_ptr;
      519 		call hcs_$status_mins (seg_ptr, foo2, bitcount, foo35);
      520 		component = 0;
      521 		if header_is_present
      522 		then base_pos = -4 * size (header);	/* abs pos of first seg base is neg */
      523 		else base_pos = 0;			/* first byte in seg is zeroth absolute byte position */
      524 		end_seg = divide (bitcount + 8, 9, 21, 0) + 1;
      525 		read_pos = 1 - base_pos;
      526 		tail_len = end_seg - read_pos;	/* always holds in read state */
      527 	     end;
      528 	else code = foo;
      529      end position_bof;
      530 
      531 put_chars_uns_file:
      532      entry (iocb_ptr, buff_ptr, buff_len, code);
      533 	code = 0;
      534 	call get_current_state;
      535 	len = max (buff_len, 0);
      536 	old_pos = write_pos;
      537 	write_pos, old_write_pos = write_pos + len;
      538 	if write_pos <= write_limit			/* normal case */
      539 	then do;
      540 		record_write = buffer;
      541 	     end;
      542 	else if old_pos < write_limit			/* long record case */
      543 	then do;
      544 		len = write_limit - old_pos;
      545 		write_pos, old_write_pos = write_limit;
      546 		record_write = buffer;
      547 		call put_chars_uns_file (iocb_ptr, addr (buff_tail), buff_len - len, code);
      548 	     end;
      549 	else do;					/* end of seg or read state */
      550 		write_pos, old_write_pos = old_pos;
      551 		code = 0;
      552 		if write_pos = write_limit		/* end of seg case */
      553 		then call new_seg_write;
      554 		else if current_state = beyond_eof_state
      555 		then do;				/* spacing beyond eof */
      556 			do while ((write_pos > write_limit) & (code = 0));
      557 						/* space to proper component */
      558 			     old_pos = write_pos;	/* save position */
      559 			     call new_seg_write;	/* write out seg, and get new one */
      560 			     write_pos, old_write_pos = old_pos - write_limit + 1;
      561 			     end_seg = write_pos;
      562 			end;
      563 			if code = 0		/* only continue if no errors */
      564 			then do;			/* output the characters */
      565 				current_state = write_state;
      566 				call put_chars_uns_file (iocb_ptr, buff_ptr, buff_len, code);
      567 						/* output */
      568 				return;		/* done */
      569 			     end;
      570 		     end;
      571 		else if append_sw			/* -append attachment */
      572 		then do;				/* go to end of file and change to write state */
      573 			call position_eof;		/* sets tail_len to 0 */
      574 			write_pos, old_write_pos = end_seg;
      575 						/* changes to write state */
      576 			current_state = write_state;
      577 		     end;
      578 		else if ^no_trunc_sw		/* did not use -no_trunc option */
      579 		then call truncate_and_change_to_write;
      580 		else do;				/* rewrite and possibly append */
      581 			if buff_len <= 0
      582 			then return;		/* no-op in this case */
      583 			if tail_len > 0		/* not yet at end of seg */
      584 			then do;			/* replace bytes in tail */
      585 				len = min (tail_len, buff_len);
      586 						/* may need next comp */
      587 				old_pos = read_pos; /* start at read position */
      588 				record_write = buffer;
      589 						/* move buffer contents */
      590 				read_pos = read_pos + len;
      591 						/* advance next position */
      592 				tail_len = tail_len - len;
      593 						/* fewer chars remain */
      594 				if buff_len > len	/* part of buffer not moved */
      595 				then call put_chars_uns_file (iocb_ptr, addr (buff_tail), buff_len - len, code);
      596 						/* move rest of buffer */
      597 				return;		/* finished put operation */
      598 			     end;
      599 			else do;			/* end of segment case */
      600 				call next_seg_read; /* looks for next component */
      601 				if code ^= 0	/* end of file */
      602 				then do;
      603 					write_pos, old_write_pos = end_seg;
      604 						/* change to write state */
      605 					current_state = write_state;
      606 					code = 0; /* not an error */
      607 				     end;
      608 			     end;
      609 		     end;
      610 		if code = 0
      611 		then call put_chars_uns_file (iocb_ptr, buff_ptr, buff_len, code);
      612 	     end;
      613 	current_state = write_state;
      614 	return;					/* end put chars routine */
      615 
      616 prev_seg_read:
      617      proc;					/* moves position to end of previous component */
      618 	call msf_manager_$get_ptr (fcb_ptr, component - 1, "0"b, next_seg_ptr, bitcount, foo);
      619 	if next_seg_ptr = null
      620 	then do;
      621 		code = error_table_$bad_file;
      622 		return;
      623 	     end;
      624 	else do;
      625 		seg_ptr = next_seg_ptr;
      626 		component = component - 1;
      627 		read_pos = divide (bitcount + 8, 9, 21, 0) + 1;
      628 						/* position at end of seg */
      629 		end_seg = read_pos;
      630 		tail_len = 0;
      631 		if (header_is_present) & (component = 0)
      632 		then base_pos = -4 * size (header);	/* offsets header at file base */
      633 		else base_pos = base_pos - end_seg + 1; /* subtract contents of prev segment */
      634 	     end;
      635      end prev_seg_read;
      636 
      637 new_seg_write:
      638      proc;
      639 	if ssf_sw					/* prevents adding new component */
      640 	then do;					/* flag the error */
      641 		code = error_table_$file_is_full;
      642 		return;
      643 	     end;
      644 	if ^is_msf				/* single segment */
      645 	then do;
      646 		call msf_manager_$open (substr (attach_descrip_string, 8, dname_len),
      647 		     substr (attach_descrip_string, 9 + dname_len, ename_len), fcb_ptr, foo);
      648 		is_msf = "1"b;
      649 		atb.fcbp = fcb_ptr;
      650 	     end;
      651 	call msf_manager_$get_ptr (fcb_ptr, component + 1, "1"b, next_seg_ptr, foo24, foo);
      652 	if next_seg_ptr = null
      653 	then code = foo;
      654 	else do;
      655 		call hcs_$set_bc_seg (seg_ptr, 9 * (write_limit - 1), foo);
      656 		seg_ptr = next_seg_ptr;
      657 		component = component + 1;
      658 		write_pos, old_write_pos = 1;
      659 		base_pos = base_pos + write_limit - 1;	/* set base position of new comp */
      660 		end_seg = 1;
      661 		read_pos = 1;
      662 		code = 0;
      663 	     end;
      664      end;						/* end new_seg_write */
      665 
      666 set_end_pos:
      667      proc;					/* determines number of bytes in file */
      668 	if is_new_file
      669 	then end_pos = 0;				/* file is empty */
      670 	else do;					/* get last component, set end_pos , and reset position if necessary */
      671 		call position_eof;			/*  finds last component */
      672 		end_pos = base_pos + end_seg - 1;	/* base pos was set by position_eof */
      673 		if (mode = 1) | ((mode = 3) & (append_sw | no_trunc_sw))
      674 						/* bof at open */
      675 		then call position_bof;		/* resets positions */
      676 	     end;
      677      end set_end_pos;
      678 
      679 truncate_and_change_to_write:
      680      proc;
      681 	end_seg = read_pos;
      682 	write_pos, old_write_pos = end_seg;
      683 	current_state = write_state;
      684 	tail_len = 0;
      685 	call hcs_$set_bc_seg (seg_ptr, 9 * (end_seg - 1), foo);
      686 	if ^is_msf
      687 	then call hcs_$truncate_seg (seg_ptr, divide (end_seg + 2, 4, 18, 0), foo);
      688 	else call msf_manager_$adjust (fcb_ptr, component, 9 * (end_seg - 1), "010"b, foo);
      689      end;						/* end truncate_and_change_to_write */
      690 
      691 get_current_state:
      692      proc;
      693 	if write_pos = beyond_limits
      694 	then do;
      695 		current_state = read_state;
      696 		return;
      697 	     end;
      698 	if write_pos ^= old_write_pos			/* fast_put has done some work */
      699 	then do;
      700 		current_state = write_state;
      701 		return;
      702 	     end;
      703 	if current_state = beyond_eof_state
      704 	then return;
      705 	current_state = write_state;
      706 	return;
      707      end get_current_state;
      708 
      709 /* for debugging
      710*   display_uns_cb: proc;
      711*   call ioa_ ( "uns_cb: ^p ^- current_state: ^d ^- write_limit: ^d ^- is_msf: ^b",
      712*   open_data_ptr, current_state, write_limit, is_msf);
      713*   call ioa_ ( "ptrs: ^-fcb: ^p ^-file_base: ^p ^-comp num: ^d ^-seg: ^p",
      714*   fcb_ptr, file_base_ptr, component, seg_ptr );
      715*   call ioa_ ( "read_pos: ^d ^-tail_len: ^d ^-base_pos: ^d ^-end_pos: ^d",
      716*   read_pos, tail_len, base_pos, end_pos );
      717*   call ioa_ ( "end_seg: ^d ^-write_pos: ^d ^-old_write_pos: ^d",
      718*   end_seg, write_pos, old_write_pos );
      719*   return;
      720*   end;
      721**/
      722 
      723 /* DECLARATIONS FOR WHOLE PROGRAM */
      724 	dcl     (vfile_io_control, vfile_status_$seg)
      725 				 entry (ptr, ptr, ptr, fixed (35));
      726 	dcl     fast_put		 entry (ptr, ptr, fixed (21), fixed (35));
      727 	dcl     max		 builtin;
      728 	dcl     addr		 builtin;
      729 	dcl     alloc_cb_file	 entry (fixed bin, ptr);
      730 	dcl     bitcount		 fixed bin (24);
      731 	dcl     buffer		 char (len) based (buff_ptr);
      732 						/* len is length
      733*						   that will be used in data transfer */
      734 	dcl     buff_len		 fixed bin (21);	/* length as specified in call */
      735 	dcl     buff_ptr		 ptr;
      736 	dcl     buff_tail		 char (buff_len - len) based (addr (buff_array (len + 1)));
      737 						/* remainder of buffer after
      738*						   data transfer, its length is > 0 */
      739 	dcl     buff_array		 (buff_len) char (1) based (buff_ptr);
      740 	dcl     1 header		 based (seg_ptr),	/* optional header for unstructured files */
      741 		2 common_header_words,
      742 		  3 file_code	 fixed,		/* identifies file type */
      743 		  3 words		 (3) fixed,
      744 		2 identifier	 fixed (35),	/* user defined field */
      745 		2 words		 (11) fixed;	/* for possible future use */
      746 	dcl     uns_code		 static internal fixed init (31191);
  1     1 /* include file for common portions of vfile_'s attach block used in
  1     2*   several modules--created by M. Asherman 1/9/76
  1     3*   Modified 8/28/76 to add last_comp */
  1     4 
  1     5      dcl	   1 atb		      based (iocb_ptr -> iocb.actual_iocb_ptr -> iocb.attach_data_ptr),
  1     6 						/* attach block */
  1     7 	     2 flags	      aligned,
  1     8 	       3 (pad1, appending, no_trunc, pad2, ssf, header_present, blocked, shared, pad3, msf, inv_lock_reset,
  1     9 		  dup_ok_sw, trans_sw, noend_sw, exclu_sw, stat_sw, checkpoint_sw)
  1    10 			      bit (1) unal,
  1    11 	       3 pad5	      bit (19) unal,
  1    12 	     2 wait_time	      fixed (35),
  1    13 	     2 word	      fixed,
  1    14 	     2 max_rec_len	      fixed (35),
  1    15 	     2 header_id	      fixed (35),
  1    16 	     2 word2	      fixed,
  1    17 	     2 attach_descrip_string
  1    18 			      char (256),
  1    19 	     2 dname_len,
  1    20 	     2 ename_len	      fixed,
  1    21 	     2 words3	      (9) fixed,
  1    22 	     2 opening_mode	      fixed,
  1    23 	     2 word4	      fixed,
  1    24 	     2 fcbp	      ptr,
  1    25 	     2 fsp	      ptr,		/* first seg ptr */
  1    26 	     2 close_x	      entry,		/* set to close routine */
  1    27 	     2 last_comp	      fixed,		/* msf component number */
  1    28 	     2 tcf_iocbp	      ptr;		/* iocb ptr for transaction control switch */
      747 
      748 	dcl     order		 char (*);
      749 	dcl     info_ptr		 ptr;
      750 	dcl     1 info		 based (info_ptr),	/* used for "read_position" order */
      751 		2 next_position	 fixed (34),	/* absolute position of next byte */
      752 		2 end_position	 fixed (34);	/* total number of bytes in the file */
      753 	dcl     1 cb_uns_file	 based (open_data_ptr),
      754 		2 seg_ptr		 ptr,		/* ptr to base of current segment in file */
      755 		2 write_limit	 fixed bin (34),	/* 1+(max size of first component) */
      756 		2 beyond_limits	 fixed bin (34),	/* max 34 bit number */
      757 		2 fcb_ptr		 ptr,		/* ptr to msf_manager control block */
      758 		2 component	 fixed bin,	/* component number for current seg */
      759 		2 end_seg		 fixed bin (34),	/* in read state =
      760*						   first byte beyond countents of current segment
      761*						   in write state is same for moment write state
      762*						   entered */
      763 		2 read_pos	 fixed bin (34),	/* in read state =
      764*						   next byte to be read, in write state is
      765*						   same as end_seg */
      766 		2 tail_len	 fixed bin (34),	/* in read state = number of
      767*						   bytes remaining in current seg, in
      768*						   write state = 0 */
      769 		2 write_pos	 fixed bin (34),	/* in read state =
      770*						   beyond_limits, in write state = next byte
      771*						   to be written.  Hence write_pos = write_limit
      772*						   is end of segment condition for writing */
      773 		2 base_pos	 fixed (34),	/* absolute position of first byte in current seg */
      774 		2 end_pos		 fixed (34),	/* in read state gives total byte count of file */
      775 		2 input_only	 bit (1) aligned,	/* mode is stream_input */
      776 		2 append_sw	 bit (1) aligned,	/* -append attach option used */
      777 		2 no_trunc_sw	 bit (1) aligned,	/* -no_trunc option */
      778 		2 header_is_present	 bit (1) aligned,	/* -header option */
      779 		2 ssf_sw		 bit (1) aligned,	/* prevents growth to msf */
      780 		2 is_msf		 bit (1) aligned,	/* set when msf opened */
      781 		2 file_base_ptr	 ptr,
      782 		2 noend		 bit (1) aligned,	/* -no_end attach option */
      783 		2 old_write_pos	 fixed (34),	/* save of the previous write_pos to determine
      784*						   if fast_put did any writing */
      785 		2 current_state	 fixed bin;	/* what state the file is in at time of entry */
      786 	dcl     close_x		 entry;
      787 	dcl     code		 fixed bin (35);
      788 	dcl     divide		 builtin;
      789 	dcl     dummy_buffer	 char (1);
      790 	dcl     error_table_$bad_file	 external fixed bin (35);
      791 	dcl     error_table_$short_record
      792 				 external fixed (35) static;
      793 	dcl     (error_table_$incompatible_attach, error_table_$file_is_full, error_table_$no_operation,
      794 	        error_table_$negative_nelem)
      795 				 fixed (35) external static;
      796 	dcl     error_table_$end_of_info
      797 				 external fixed bin (35);
      798 	dcl     error_table_$noentry	 external fixed bin (35);
      799 	dcl     error_table_$long_record
      800 				 external fixed bin (35);
      801 	dcl     error_table_$bad_arg	 external fixed bin (35);
      802 	dcl     fcb_ptr_arg		 ptr;
      803 	dcl     first_seg_ptr	 ptr;
      804 	dcl     first_seg_bitcount	 fixed bin (24);
      805 	dcl     foo		 fixed bin (35);
      806 	dcl     foo2		 fixed bin (2);
      807 	dcl     foo24		 fixed bin (24);
      808 	dcl     foo35		 fixed bin (35);
      809 	dcl     free_cb_file	 entry (fixed bin, ptr);
      810 	dcl     hcs_$status_mins	 entry (ptr, fixed bin (2), fixed bin (24), fixed bin (35));
      811 	dcl     hcs_$terminate_noname	 entry (ptr, fixed (35));
      812 	dcl     hcs_$truncate_seg	 entry (ptr, fixed (18), fixed (35));
      813 	dcl     msf_manager_$open	 entry (char (*), char (*), ptr, fixed (35));
      814 	dcl     hcs_$set_bc_seg	 entry (ptr,	/* ptr to segment */
      815 				 fixed bin (24),	/* bitcount */
      816 				 fixed bin (35));	/* status code */
      817 	dcl     index		 builtin;
      818 	dcl     is_new_file		 bit (1) aligned;
      819 						/* for debugging
      820*						   dcl ioa_ entry options (variable);
      821*						*/
      822 	dcl     iocb_ptr		 ptr;		/* for open and close entries this points to the actual iocb.
      823*						   for other entries it points to an iocb that may be syned */
      824 	dcl     len		 fixed bin (21);	/* length of string to be
      825*						   moved in one operation */
      826 	dcl     len2		 fixed bin (21);
      827 	dcl     max_component_size	 fixed bin (19);
      828 	dcl     min		 builtin;
      829 	dcl     mode		 fixed bin;	/* = 1, 2, or 3 */
      830 	dcl     msf_manager_$adjust	 entry (ptr,	/* fcb_ptr */
      831 				 fixed bin,	/* component number of segment to be
      832*						   made last segment */
      833 				 fixed bin (24),	/* bitcount for that seg -- not reliable */
      834 				 bit (3),		/* "010" =  don't set bit counts (use hcs_$set_bc_seg), truncate
      835*						   segment, dont terminate components */
      836 				 fixed bin (35));	/* status code */
      837 	dcl     msf_manager_$get_ptr	 entry (ptr,	/* fcb_ptr */
      838 				 fixed bin,	/* component number of desired segment */
      839 				 bit (1),		/* create switch */
      840 				 ptr,		/* ptr to seg or null if error, output */
      841 				 fixed bin (24),	/* bitcount of segment, output */
      842 				 fixed bin (35));	/* status code */
      843 	dcl     null		 builtin;
      844 	dcl     next_seg_ptr	 ptr;
      845 	dcl     new_line		 static internal char (1) init ("
      846 ");
      847 	dcl     old_pos		 fixed bin (21);
      848 	dcl     pos_type		 fixed bin;
      849 	dcl     record_read		 char (len) based (addr (seg (read_pos)));
      850 	dcl     record_write	 char (len) based (addr (seg (old_pos)));
      851 	dcl     rec_len		 fixed bin (21);
      852 	dcl     seg		 (1048576) char (1) based (seg_ptr);
      853 	dcl     skip		 fixed (34);
      854 	dcl     size		 builtin;
      855 						/* state variables */
      856 	dcl     read_state		 fixed bin init (1);
      857 	dcl     beyond_eof_state	 fixed bin init (2);
      858 	dcl     write_state		 fixed bin init (3);
  2     1 
  2     2      dcl	   1 iocb		      aligned based (iocb_ptr),
  2     3 						/* I/O control block. */
  2     4 	     2 iocb_version	      fixed init (1),	/* Version number of structure. */
  2     5 	     2 name	      char (32),		/* I/O name of this block. */
  2     6 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  2     7 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  2     8 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  2     9 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  2    10 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  2    11 	     2 reserved	      bit (72),		/* Reserved for future use. */
  2    12 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  2    13 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  2    14 						/* open(p,mode,not_used,s) */
  2    15 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  2    16 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  2    17 						/* get_line(p,bufptr,buflen,actlen,s) */
  2    18 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  2    19 						/* get_chars(p,bufptr,buflen,actlen,s) */
  2    20 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  2    21 						/* put_chars(p,bufptr,buflen,s) */
  2    22 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  2    23 						/* modes(p,newmode,oldmode,s) */
  2    24 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  2    25 						/* position(p,u1,u2,s) */
  2    26 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  2    27 						/* control(p,order,infptr,s) */
  2    28 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  2    29 						/* read_record(p,bufptr,buflen,actlen,s) */
  2    30 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  2    31 						/* write_record(p,bufptr,buflen,s) */
  2    32 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  2    33 						/* rewrite_record(p,bufptr,buflen,s) */
  2    34 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  2    35 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  2    36 						/* seek_key(p,key,len,s) */
  2    37 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  2    38 						/* read_key(p,key,len,s) */
  2    39 	     2 read_length	      entry (ptr, fixed (21), fixed (35));
  2    40 						/* read_length(p,len,s) */
  2    41 
      859 
      860 
      861 /* GENERAL COMMENTS
      862*   This external procedure implements io to-from
      863*   unstructured files.  The entries open and close are
      864*   called from open_file and close_file, see vfile_attach .
      865*   They setup (respectively free) the control block, which
      866*   the other entries access through open_data_ptr
      867*   in the actual iocb.  The other entries are called
      868*   through the iocb.  The code for each entry immediately
      869*   follows the entry and terminates with a return
      870*   statement.
      871*
      872*   Before reading the code, familiarize yourself with
      873*   the general conventions for implementing attachments
      874*   (see the MPM), and the specs for the operations.
      875*
      876*
      877*   At the beginning (and again at the end) of an
      878*   operation (e.g. get_line), the control block is
      879*   in either the read state or the write state.
      880*   See the declaration of cb_uns_file for details.
      881*   The two states are distinguished by the value
      882*   of write_pos, but there are other differences as well.
      883*
      884*   The general method for each operation is to test for
      885*   the nonexceptional case, control block in the
      886*   correct state and the buffer not too long for
      887*   the remainder of the segment.  In the exceptional
      888*   cases some progress is made, i.e. some data is
      889*   transferred, or the contro blocks state is
      890*   changed, or a new segment is obtained.  Then
      891*   the operation is completed by a recursive call. */
      892 
      893 /* changes due to implimenting of the -no_end option:
      894*   1. operations were changed to accept the idea of being beyond end-of-file (eof)
      895*   2. the positioning to allow the changing of write_pos to be greater than the end_pos
      896*   3. a way of identifying the state of the file
      897*   4. a new state of the file was added: beyond eof
      898*   5. the write_pos needed to be stored away in another place to be able to determine
      899*   that fast_put had done some work, and therefore the file was in write state
      900*   6. mostly in need of determining if there was a problem in msf_manager_
      901*   changes were made to allow error codes other than expected to reflect through
      902**/
      903      end /* end of open_uns_file program */;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/82  1620.8  open_uns_file.pl1                 >dumps>old>recomp>open_uns_file.pl1
747          1    07/19/79  1547.0  vf_attach_block.incl.pl1          >ldd>include>vf_attach_block.incl.pl1
859          2    07/02/81  1905.0  iocbv.incl.pl1                    >ldd>include>iocbv.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
actual_iocb_ptr          12            based           pointer                  level 2 dcl 2-2 ref 17 23 25 25 114 125 126 127 128
                                                                                  129 646 646 646 646 646 646 646 646 646 646 649
addr                                                   builtin function         dcl 728 ref 162 171 171 171 171 206 210 217 226 226
                                                                                  226 226 256 431 431 540 546 547 547 547 547 588
                                                                                  594 594 594 594
alloc_cb_file                   000016 constant        entry                    external dcl 729 ref 107
append_sw                16            based           bit(1)                   level 2 dcl 753 set ref 128* 132 571 673
appending                 0(01)        based           bit(1)                   level 3 packed unaligned dcl 1-5 ref 128
atb                                    based           structure                level 1 unaligned dcl 1-5
attach_data_ptr          16            based           pointer                  level 2 dcl 2-2 ref 17 23 25 25 114 125 126 127 128
                                                                                  129 646 646 646 646 646 646 646 646 646 646 649
attach_descrip_string
                          6            based           char(256)                level 2 packed unaligned dcl 1-5 ref 646 646 646 646
base_pos                 13            based           fixed bin(34,0)          level 2 dcl 753 set ref 60 67 74 115* 117* 121 303*
                                                                                  303 341 363 370 375 386 511 521* 523* 525 631*
                                                                                  633* 633 659* 659 672
beyond_eof_state                000116 automatic       fixed bin(17,0)          initial dcl 857 set ref 89 153 196 334 365 398 487
                                                                                  554 703 857*
beyond_limits             3            based           fixed bin(34,0)          level 2 dcl 753 set ref 109* 123 334 343 693
bitcount                        000102 automatic       fixed bin(24,0)          dcl 730 set ref 112* 288* 306* 308 515* 519* 524
                                                                                  618* 627
buff_array                             based           char(1)                  array unaligned dcl 739 set ref 171 171 226 226 547
                                                                                  547 594 594
buff_len                               parameter       fixed bin(21,0)          dcl 734 set ref 150 159 165 171 171 171 177 189* 193
                                                                                  202 220 226 226 226 233 245* 531 535 547 547 547
                                                                                  566* 581 585 594 594 594 594 610*
buff_ptr                               parameter       pointer                  dcl 735 set ref 150 162 171 171 189* 193 210 217 226
                                                                                  226 245* 531 540 546 547 547 566* 588 594 594 610*
buff_tail                              based           char                     unaligned dcl 736 set ref 171 171 226 226 547 547
                                                                                  594 594
buffer                                 based           char                     unaligned dcl 731 set ref 162* 210* 217* 540 546 588
cb_uns_file                            based           structure                level 1 unaligned dcl 753 set ref 107 107 147 147
close_x                                parameter       entry variable           dcl 786 set ref 13 32*
code                                   parameter       fixed bin(35,0)          dcl 787 set ref 13 16* 20* 21 28* 52 54* 87* 89* 95*
                                                                                  99* 101* 150 155* 167* 171* 173 173* 179* 184 184
                                                                                  187 189* 193 198* 209* 223* 226* 228 228* 235* 240
                                                                                  240 243 245* 259* 273 281* 294* 297* 299* 311* 316
                                                                                  325* 351* 355* 359* 370 375 380 380 384 400* 404*
                                                                                  409 409 412 420* 424 428 431 434* 445 462* 472*
                                                                                  491* 494 497 499* 507* 528* 531 533* 547* 551* 556
                                                                                  563 566* 594* 601 606* 610 610* 621* 641* 652*
                                                                                  662*
common_header_words                    based           structure                level 2 unaligned dcl 740
component                 6            based           fixed bin(17,0)          level 2 dcl 753 set ref 113* 288 307* 307 448 470
                                                                                  520* 618 626* 626 631 651 657* 657 688*
control                  66            based           entry variable           level 2 dcl 2-2 set ref 33*
count                           000100 automatic       fixed bin(17,0)          dcl 482 set ref 405* 406 412* 414* 414 419* 422 424*
                                                                                  424 426*
current_state            30            based           fixed bin(17,0)          level 2 dcl 753 set ref 57 65 84 89 130* 136* 153
                                                                                  196 281 332 334 365* 398 487 492 554 565* 576*
                                                                                  605* 613* 683* 695* 700* 703 705*
divide                                                 builtin function         dcl 788 ref 120 308 524 627 686 686
dname_len               106            based           fixed bin(17,0)          level 2 dcl 1-5 ref 646 646 646 646
dummy_buffer                    000103 automatic       char(1)                  unaligned dcl 789 set ref 431 431
ename_len               107            based           fixed bin(17,0)          level 2 dcl 1-5 ref 646 646
end_pos                  14            based           fixed bin(34,0)          level 2 dcl 753 set ref 63 75 341* 356 359 668* 672*
end_position              1            based           fixed bin(34,0)          level 2 dcl 750 set ref 63* 70* 75*
end_seg                   7            based           fixed bin(34,0)          level 2 dcl 753 set ref 118* 120* 122 303 309* 339*
                                                                                  341 344 375 388 464 469 500 512 524* 526 561* 574
                                                                                  603 629* 633 660* 672 681* 682 685 686 686 688
error_table_$bad_arg            000042 external static fixed bin(35,0)          dcl 801 ref 325
error_table_$bad_file           000020 external static fixed bin(35,0)          dcl 790 ref 621
error_table_$end_of_info        000034 external static fixed bin(35,0)          dcl 796 ref 155 184 198 240 281 294 299 359 380 400
                                                                                  409 472 497
error_table_$file_is_full       000026 external static fixed bin(35,0)          dcl 793 ref 641
error_table_$incompatible_attach
                                000024 external static fixed bin(35,0)          dcl 793 ref 28
error_table_$long_record        000040 external static fixed bin(35,0)          dcl 799 ref 223 235
error_table_$negative_nelem     000032 external static fixed bin(35,0)          dcl 793 ref 351
error_table_$no_operation       000030 external static fixed bin(35,0)          dcl 793 ref 89 101
error_table_$noentry            000036 external static fixed bin(35,0)          dcl 798 ref 294
error_table_$short_record       000022 external static fixed bin(35,0)          dcl 791 ref 173 228
fast_put                        000014 constant        entry                    external dcl 726 ref 42 48
fcb_ptr                   4            based           pointer                  level 2 dcl 753 set ref 110* 288* 515* 618* 646* 649
                                                                                  651* 688*
fcb_ptr_arg                            parameter       pointer                  dcl 802 ref 13 110
fcbp                    124            based           pointer                  level 2 dcl 1-5 set ref 649*
file_base_ptr            24            based           pointer                  level 2 dcl 753 set ref 95* 99* 138*
file_code                              based           fixed bin(17,0)          level 3 dcl 740 ref 25
first_seg_bitcount                     parameter       fixed bin(24,0)          dcl 804 ref 13 120
first_seg_ptr                          parameter       pointer                  dcl 803 set ref 13 20* 23 25 25 111
flag                            000174 automatic       bit(1)                   dcl 479 set ref 446* 453 455* 457*
flags                                  based           structure                level 2 dcl 1-5
foo                             000104 automatic       fixed bin(35,0)          dcl 805 set ref 87 284* 288* 292 294 297 344* 431*
                                                                                  515* 528 618* 646* 651* 652 655* 685* 686* 688*
foo2                            000105 automatic       fixed bin(2,0)           dcl 806 set ref 112* 306* 519*
foo21                           000101 automatic       fixed bin(21,0)          dcl 483 set ref 431*
foo24                           000106 automatic       fixed bin(24,0)          dcl 807 set ref 651*
foo35                           000107 automatic       fixed bin(35,0)          dcl 808 set ref 112* 306* 519*
free_cb_file                    000044 constant        entry                    external dcl 809 ref 147
get_chars                46            based           entry variable           level 2 dcl 2-2 set ref 37* 46*
get_line                 42            based           entry variable           level 2 dcl 2-2 set ref 36* 45*
hcs_$set_bc_seg                 000054 constant        entry                    external dcl 814 ref 20 344 655 685
hcs_$status_mins                000046 constant        entry                    external dcl 810 ref 112 306 519
hcs_$truncate_seg               000050 constant        entry                    external dcl 812 ref 686
header                                 based           structure                level 1 unaligned dcl 740 set ref 20 115 118 448 521
                                                                                  631
header_id                 4            based           fixed bin(35,0)          level 2 dcl 1-5 ref 23 25 25
header_is_present        20            based           bit(1)                   level 2 dcl 753 set ref 114* 115 118 448 521 631
header_present            0(05)        based           bit(1)                   level 3 packed unaligned dcl 1-5 ref 17 114
identifier                4            based           fixed bin(35,0)          level 2 dcl 740 set ref 23* 25
index                                                  builtin function         dcl 817 ref 206 256
info                                   based           structure                level 1 unaligned dcl 750
info_ptr                               parameter       pointer                  dcl 749 set ref 52 60 63 67 70 70 74 75 95* 99*
input_only               15            based           bit(1)                   level 2 dcl 753 set ref 82 124*
iocb                                   based           structure                level 1 dcl 2-2
iocb_ptr                               parameter       pointer                  dcl 822 set ref 13 17 20 23 25 25 33 36 37 38 42 45
                                                                                  46 47 48 52 57 60 60 63 65 67 67 74 74 75 82 84 89
                                                                                  95* 95 99* 99 107 107 107 108 109 110 111 112 113
                                                                                  114 114 115 115 115 117 118 118 118 120 121 121
                                                                                  122 122 122 123 123 123 124 125 125 126 126 127
                                                                                  127 128 128 129 129 130 132 132 135 135 135 136
                                                                                  138 138 142 147 147 147 150 153 159 162 162 163
                                                                                  163 164 164 171* 189* 193 196 202 206 206 210 210
                                                                                  212 212 213 213 217 217 218 218 219 219 226* 245*
                                                                                  253 256 256 261 261 262 262 266 267 267 267 268
                                                                                  281 285 288 288 303 303 303 305 306 307 307 308
                                                                                  309 309 310 316 332 334 334 334 334 339 339 340
                                                                                  340 341 341 341 342 343 343 343 344 344 356 359
                                                                                  359 363 363 363 365 370 375 375 386 386 388 388
                                                                                  388 398 431* 447 448 448 448 457 463 464 464 468
                                                                                  469 469 469 470 487 492 500 500 501 509 511 511
                                                                                  512 512 512 515 518 519 520 521 521 521 523 524
                                                                                  525 525 526 526 526 531 536 537 537 537 538 538
                                                                                  540 542 544 545 545 545 546 547* 550 550 552 552
                                                                                  554 556 556 558 560 560 560 561 561 565 566* 571
                                                                                  574 574 574 576 578 583 585 587 588 590 590 592
                                                                                  592 594* 603 603 603 605 610* 613 618 618 625 626
                                                                                  626 627 629 629 630 631 631 631 631 633 633 633
                                                                                  639 644 646 646 646 646 646 646 646 646 646 646
                                                                                  646 648 649 649 651 651 655 655 656 657 657 658
                                                                                  658 659 659 659 660 661 668 672 672 672 673 673
                                                                                  681 681 682 682 682 683 684 685 685 686 686 686
                                                                                  686 688 688 688 693 693 695 698 698 700 703 705
is_msf                   22            based           bit(1)                   level 2 dcl 753 set ref 127* 285 509 644 648* 686
is_new_file                            parameter       bit(1)                   dcl 818 ref 13 17 118 668
k                               000175 automatic       fixed bin(21,0)          dcl 480 set ref 447* 454* 454 455 457 460 463 464
len                             000110 automatic       fixed bin(21,0)          dcl 824 set ref 159* 160 162 162 163 164 165 168 171
                                                                                  171 171 171 171 172 202* 203 205 206* 206 207 210
                                                                                  210 211 212 213 216* 217 217 218 219 220 222 226
                                                                                  226 226 226 226 227 253* 254 256* 256 257 260 261
                                                                                  262 535* 537 540 540 544* 546 546 547 547 547 547
                                                                                  547 585* 588 588 590 592 594 594 594 594 594 594
len2                            000111 automatic       fixed bin(21,0)          dcl 826 set ref 205* 216 260* 260 266* 266 407*
max                                                    builtin function         dcl 727 ref 535
max_component_size                     parameter       fixed bin(19,0)          dcl 827 ref 13 108
min                                                    builtin function         dcl 828 ref 159 202 585
min_pos                         000176 automatic       fixed bin(21,0)          dcl 480 set ref 448* 451* 452* 455 460 468
mode                                   parameter       fixed bin(17,0)          dcl 829 ref 13 34 40 124 132 132 673 673
msf                       0(09)        based           bit(1)                   level 3 packed unaligned dcl 1-5 ref 127
msf_manager_$adjust             000056 constant        entry                    external dcl 830 ref 688
msf_manager_$get_ptr            000060 constant        entry                    external dcl 837 ref 288 515 618 651
msf_manager_$open               000052 constant        entry                    external dcl 813 ref 646
new_line                        003550 constant        char(1)                  initial unaligned dcl 845 ref 206 256 457
next_position                          based           fixed bin(34,0)          level 2 dcl 750 set ref 60* 67* 70 74*
next_seg_ptr                    000112 automatic       pointer                  dcl 844 set ref 285* 288* 290 305 515* 516 518 618*
                                                                                  619 625 651* 652 656
no_trunc                  0(02)        based           bit(1)                   level 3 packed unaligned dcl 1-5 ref 129
no_trunc_sw              17            based           bit(1)                   level 2 dcl 753 set ref 129* 132 578 673
noend                    26            based           bit(1)                   level 2 dcl 753 set ref 126* 359
noend_sw                  0(13)        based           bit(1)                   level 3 packed unaligned dcl 1-5 ref 126
null                                                   builtin function         dcl 843 ref 285 290 516 619 652
old_pos                         000114 automatic       fixed bin(21,0)          dcl 847 set ref 536* 540 542 544 546 550 558* 560
                                                                                  587* 588
old_write_pos            27            based           fixed bin(34,0)          level 2 dcl 753 set ref 123* 135* 334* 343* 363*
                                                                                  537* 545* 550* 560* 574* 603* 658* 682* 698
open_data_ptr            22            based           pointer                  level 2 dcl 2-2 set ref 20 57 60 60 63 65 67 67 74
                                                                                  74 75 82 84 89 95 99 107 107 107* 108 109 110 111
                                                                                  112 113 114 115 115 115 117 118 118 118 120 121
                                                                                  121 122 122 122 123 123 123 124 125 126 127 128
                                                                                  129 130 132 132 135 135 135 136 138 138 147 147
                                                                                  147* 153 159 162 162 163 163 164 164 196 202 206
                                                                                  206 210 210 212 212 213 213 217 217 218 218 219
                                                                                  219 253 256 256 261 261 262 262 266 267 267 267
                                                                                  268 281 285 288 288 303 303 303 305 306 307 307
                                                                                  308 309 309 310 332 334 334 334 334 339 339 340
                                                                                  340 341 341 341 342 343 343 343 344 344 356 359
                                                                                  359 363 363 363 365 370 375 375 386 386 388 388
                                                                                  388 398 447 448 448 448 457 463 464 464 468 469
                                                                                  469 469 470 487 492 500 500 501 509 511 511 512
                                                                                  512 512 515 518 519 520 521 521 521 523 524 525
                                                                                  525 526 526 526 536 537 537 537 538 538 540 542
                                                                                  544 545 545 545 546 550 550 552 552 554 556 556
                                                                                  558 560 560 560 561 561 565 571 574 574 574 576
                                                                                  578 583 585 587 588 590 590 592 592 603 603 603
                                                                                  605 613 618 618 625 626 626 627 629 629 630 631
                                                                                  631 631 631 633 633 633 639 644 646 648 649 651
                                                                                  651 655 655 656 657 657 658 658 659 659 659 660
                                                                                  661 668 672 672 672 673 673 681 681 682 682 682
                                                                                  683 684 685 685 686 686 686 686 688 688 688 693
                                                                                  693 695 698 698 700 703 705
order                                  parameter       char                     unaligned dcl 748 ref 52 57 82 93 99
pos_type                               parameter       fixed bin(17,0)          dcl 848 ref 316 319 321 323 325
position                 62            based           entry variable           level 2 dcl 2-2 set ref 38* 47*
put_chars                52            based           entry variable           level 2 dcl 2-2 set ref 42* 48*
read_pos                 10            based           fixed bin(34,0)          level 2 dcl 753 set ref 60 121* 122 135 162 163* 163
                                                                                  206 210 212* 212 217 218* 218 256 261* 261 267*
                                                                                  267 310* 340* 386* 388 447 463* 468* 469 500* 511*
                                                                                  512 525* 526 587 590* 590 627* 629 661* 681
read_state                      000115 automatic       fixed bin(17,0)          initial dcl 856 set ref 57 84 130 281 332 492 695
                                                                                  856*
rec_len                                parameter       fixed bin(21,0)          dcl 851 set ref 150 156* 168* 171* 172* 172 173 180*
                                                                                  187* 189* 193 199* 211* 222* 226* 227* 227 228
                                                                                  236* 243* 245*
record_read                            based           char                     unaligned dcl 849 ref 162 206 210 217 256
record_write                           based           char                     unaligned dcl 850 set ref 540* 546* 588*
seg                                    based           char(1)                  array unaligned dcl 852 set ref 162 206 210 217 256
                                                                                  457 540 546 588
seg_ptr                                based           pointer                  level 2 dcl 753 set ref 20 111* 112* 115 118 138 162
                                                                                  206 210 217 256 305* 306* 344* 448 457 518* 519*
                                                                                  521 540 546 588 625* 631 655* 656* 685* 686*
size                                                   builtin function         dcl 854 ref 20 107 107 115 118 147 147 448 521 631
skip                                   parameter       fixed bin(34,0)          dcl 853 ref 316 351 356 359 363 370 375 386 396 405
                                                                                  419
ssf                       0(04)        based           bit(1)                   level 3 packed unaligned dcl 1-5 ref 125
ssf_sw                   21            based           bit(1)                   level 2 dcl 753 set ref 125* 639
tail_len                 11            based           fixed bin(34,0)          level 2 dcl 753 set ref 122* 159 164* 164 202 213*
                                                                                  213 219* 219 253 262* 262 266 267 268* 308* 309
                                                                                  342* 388* 464* 469* 501* 512* 526* 583 585 592*
                                                                                  592 630* 684*
uns_code                               constant        fixed bin(17,0)          initial dcl 746 ref 25
vfile_io_control                000010 constant        entry                    external dcl 724 ref 99
vfile_status_$seg               000012 constant        entry                    external dcl 724 ref 95
write_limit               2            based           fixed bin(34,0)          level 2 dcl 753 set ref 108* 538 542 544 545 552 556
                                                                                  560 655 659
write_pos                12            based           fixed bin(34,0)          level 2 dcl 753 set ref 67 74 123* 135* 334* 339 340
                                                                                  343* 363* 536 537 537* 538 545* 550* 552 556 558
                                                                                  560* 561 574* 603* 658* 682* 693 698
write_state                     000117 automatic       fixed bin(17,0)          initial dcl 858 set ref 65 136 565 576 605 613 683
                                                                                  700 705 858*

NAME DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
hcs_$terminate_noname           000000 constant        entry                    external dcl 811

NAMES DECLARED BY EXPLICIT CONTEXT.
change_to_read_state            002203 constant        entry                    internal dcl 330 ref 145 354 421 489 508
close_uns_file                  000454 constant        entry                    external dcl 142 ref 32
control_uns_file                000233 constant        entry                    external dcl 52 ref 33
create_initialize_cb            001514 constant        entry                    internal dcl 105 ref 31
find_preceding_new_line         002525 constant        entry                    internal dcl 439 ref 423 430
get_chars_uns_file              000510 constant        entry                    external dcl 150 ref 37 46 171 189 431
get_current_state               003517 constant        entry                    internal dcl 691 ref 55 144 152 195 318 534
get_line_uns_file               000670 constant        entry                    external dcl 193 ref 36 45 226 245
new_seg_write                   003131 constant        entry                    internal dcl 637 ref 552 559
next_seg_read                   002034 constant        entry                    internal dcl 279 ref 183 239 272 377 495 600
open_uns_file                   000051 constant        entry                    external dcl 13
position_abs                    002263 constant        entry                    internal dcl 349 ref 321
position_bof                    002701 constant        entry                    internal dcl 505 ref 327 673
position_eof                    002637 constant        entry                    internal dcl 485 ref 323 358 573 671
position_skip                   002412 constant        entry                    internal dcl 394 ref 319
position_uns_file               001110 constant        entry                    external dcl 316 ref 38 47
prev_seg_read                   003027 constant        entry                    internal dcl 616 ref 372 475
put_chars_uns_file              001154 constant        entry                    external dcl 531 ref 547 566 594 610
set_end_pos                     003345 constant        entry                    internal dcl 666 ref 131
skip_record                     001764 constant        entry                    internal dcl 249 ref 408
truncate_and_change_to_write    003410 constant        entry                    internal dcl 679 ref 86 578

NAME DECLARED BY CONTEXT OR IMPLICATION.
substr                                                 builtin function         ref 646 646 646 646

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4100        4162    3553        4110
Length      4446    3553        62         250     324           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
open_uns_file                       366 external procedure  is an external procedure.  
create_initialize_cb                    internal procedure  shares stack frame of external procedure open_uns_file.  
skip_record                             internal procedure  shares stack frame of external procedure open_uns_file.  
next_seg_read                           internal procedure  shares stack frame of external procedure open_uns_file.  
change_to_read_state                    internal procedure  shares stack frame of external procedure open_uns_file.  
position_abs                            internal procedure  shares stack frame of external procedure open_uns_file.  
position_skip                           internal procedure  shares stack frame of external procedure open_uns_file.  
find_preceding_new_line                 internal procedure  shares stack frame of external procedure open_uns_file.  
position_eof                            internal procedure  shares stack frame of external procedure open_uns_file.  
position_bof                            internal procedure  shares stack frame of external procedure open_uns_file.  
prev_seg_read                           internal procedure  shares stack frame of external procedure open_uns_file.  
new_seg_write                           internal procedure  shares stack frame of external procedure open_uns_file.  
set_end_pos                             internal procedure  shares stack frame of external procedure open_uns_file.  
truncate_and_change_to_write            internal procedure  shares stack frame of external procedure open_uns_file.  
get_current_state                       internal procedure  shares stack frame of external procedure open_uns_file.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
open_uns_file            000100 count                       open_uns_file
                         000101 foo21                       open_uns_file
                         000102 bitcount                    open_uns_file
                         000103 dummy_buffer                open_uns_file
                         000104 foo                         open_uns_file
                         000105 foo2                        open_uns_file
                         000106 foo24                       open_uns_file
                         000107 foo35                       open_uns_file
                         000110 len                         open_uns_file
                         000111 len2                        open_uns_file
                         000112 next_seg_ptr                open_uns_file
                         000114 old_pos                     open_uns_file
                         000115 read_state                  open_uns_file
                         000116 beyond_eof_state            open_uns_file
                         000117 write_state                 open_uns_file
                         000174 flag                        find_preceding_new_line
                         000175 k                           find_preceding_new_line
                         000176 min_pos                     find_preceding_new_line

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_cs            call_ext_in         call_ext_out_desc   call_ext_out        return
shorten_stack       ext_entry           ext_entry_desc      real_to_real_rd

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
alloc_cb_file                 fast_put                      free_cb_file                  hcs_$set_bc_seg
hcs_$status_mins              hcs_$truncate_seg             msf_manager_$adjust           msf_manager_$get_ptr
msf_manager_$open             vfile_io_control              vfile_status_$seg

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$bad_file         error_table_$end_of_info      error_table_$file_is_full
error_table_$incompatible_attach                            error_table_$long_record      error_table_$negative_nelem
error_table_$no_operation     error_table_$noentry          error_table_$short_record




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    856 000032       857 000034       858 000036        13 000042        16 000062        17 000063        20 000075
     21 000112        23 000114        24 000125        25 000126        28 000141        29 000144        31 000145
     32 000146        33 000154        34 000161        36 000164        37 000170        38 000173        39 000176
     40 000177        42 000201        43 000206        45 000207        46 000213        47 000216        48 000221
     50 000225        52 000226        54 000252        55 000253        57 000254        60 000271        63 000303
     64 000306        65 000307        67 000311        70 000323        72 000325        74 000326        75 000340
     76 000343        82 000344        84 000355        86 000360        87 000361        88 000363        89 000364
     91 000371        93 000372        95 000377        96 000417        99 000420       101 000445       103 000450
    142 000451       144 000462       145 000463       147 000464       148 000502       150 000503       152 000521
    153 000522       155 000531       156 000534       157 000535       159 000536       160 000543       162 000545
    163 000554       164 000555       165 000557       167 000563       168 000564       169 000566       171 000567
    172 000613       173 000616       176 000625       177 000626       179 000630       180 000631       181 000632
    183 000633       184 000634       187 000641       189 000646       191 000665       193 000666       195 000701
    196 000702       198 000711       199 000714       200 000715       202 000716       203 000723       205 000725
    206 000726       207 000741       209 000744       210 000745       211 000752       212 000753       213 000754
    214 000756       216 000757       217 000761       218 000766       219 000767       220 000771       222 000774
    223 000776       224 001001       226 001002       227 001026       228 001031       232 001040       233 001041
    235 001043       236 001046       237 001047       239 001050       240 001051       243 001056       245 001063
    247 001102       316 001103       318 001121       319 001122       321 001127       323 001133       325 001137
    327 001145       328 001146       531 001147       533 001165       534 001166       535 001167       536 001175
    537 001202       538 001205       540 001210       541 001220       542 001221       544 001224       545 001227
    546 001232       547 001242       548 001265       550 001266       551 001270       552 001271       554 001276
    556 001301       558 001312       559 001314       560 001315       561 001330       562 001332       563 001333
    565 001335       566 001337       568 001353       570 001354       571 001355       573 001357       574 001360
    576 001367       577 001371       578 001372       581 001376       583 001400       585 001402       587 001406
    588 001410       590 001417       592 001421       594 001423       597 001450       600 001451       601 001452
    603 001454       605 001463       606 001465       610 001466       613 001505       614 001513       105 001514
    107 001515       108 001533       109 001543       110 001605       111 001610       112 001615       113 001634
    114 001641       115 001646       117 001652       118 001653       120 001663       121 001670       122 001673
    123 001676       124 001701       125 001705       126 001711       127 001715       128 001721       129 001725
    130 001731       131 001733       132 001734       135 001751       136 001757       138 001761       139 001763
    249 001764       253 001765       254 001773       256 001774       257 002007       259 002010       260 002011
    261 002014       262 002016       263 002020       266 002021       267 002023       268 002024       270 002025
    272 002026       273 002027       276 002032       277 002033       279 002034       281 002035       284 002050
    285 002051       288 002056       290 002104       292 002110       294 002112       297 002120       298 002121
    299 002122       300 002125       303 002126       305 002143       306 002145       307 002164       308 002171
    309 002175       310 002177       311 002201       314 002202       330 002203       332 002204       334 002214
    339 002222       340 002224       341 002226       342 002237       343 002240       344 002243       346 002262
    349 002263       351 002264       354 002273       355 002274       356 002275       358 002304       359 002305
    363 002322       365 002333       367 002335       370 002336       372 002347       373 002350       375 002351
    377 002363       378 002364       380 002365       384 002373       386 002375       388 002406       392 002411
    394 002412       396 002413       398 002416       400 002424       401 002427       404 002430       405 002431
    406 002433       407 002435       408 002436       409 002437       412 002445       414 002451       415 002453
    417 002454       419 002455       420 002457       421 002460       422 002461       423 002463       424 002464
    426 002471       427 002472       428 002473       430 002475       431 002476       434 002523       437 002524
    439 002525       445 002526       446 002530       447 002532       448 002540       451 002547       452 002552
    453 002554       454 002556       455 002560       457 002565       459 002577       460 002600       462 002603
    463 002604       464 002611       465 002614       468 002615       469 002623       470 002626       472 002630
    473 002633       475 002634       477 002635       481 002636       485 002637       487 002640       489 002647
    491 002650       492 002651       494 002660       495 002662       496 002663       497 002664       499 002670
    500 002671       501 002677       503 002700       505 002701       507 002702       508 002703       509 002704
    511 002712       512 002715       513 002720       515 002721       516 002745       518 002751       519 002756
    520 002775       521 003002       523 003007       524 003010       525 003015       526 003020       527 003023
    528 003024       529 003026       616 003027       618 003030       619 003062       621 003066       622 003071
    625 003072       626 003077       627 003104       629 003111       630 003112       631 003113       633 003122
    635 003130       637 003131       639 003132       641 003140       642 003143       644 003144       646 003146
    648 003214       649 003223       651 003227       652 003261       655 003270       656 003313       657 003320
    658 003324       659 003327       660 003340       661 003342       662 003343       664 003344       666 003345
    668 003346       671 003357       672 003360       673 003375       677 003407       679 003410       681 003411
    682 003417       683 003421       684 003423       685 003424       686 003443       688 003471       689 003516
    691 003517       693 003520       695 003527       696 003531       698 003532       700 003534       701 003536
    703 003537       705 003543       706 003545


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
