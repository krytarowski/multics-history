	COMPILATION LISTING OF SEGMENT mrds_dsl_retrieve
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-05-05_1829.14_Fri_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
       15*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
       16*     This entry is being made to cover the change made on 85-06-27 by Thanh
       17*     Nguyen. (see mrds #137)
       18*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
       19*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
       20*     Check to see if we were called by copy_mrds_data before issuing an error
       21*     about the se_txn not being the same as the current txn (mrds #156).
       22*  3) change(86-06-19,Dupuis), approve(86-08-07,MCR7491),
       23*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
       24*     This entry is being made to cover the change made on 86-02-18 by John
       25*     Hergert (mrds error list #153).
       26*  4) change(87-01-22,Hergert), approve(88-07-11,MCR7903),
       27*     audit(88-07-07,Dupuis), install(88-08-01,MR12.2-1073):
       28*     For new parser, changed references to sel_ptr to selct_list_ptr.
       29*                                                   END HISTORY COMMENTS */
       30 
       31 
       32 mrds_dsl_retrieve: retrieve: proc;
       33 
       34 /* (database_index, selection_expression, values,...., values, code) */
       35 
       36 /* BEGIN DESCRIPTION
       37*
       38*   The purpose of this procedure is to implement the dsl_$retrieve function.
       39*   This procedure creates an argument list for and calls translate,
       40*   then calls search.
       41*
       42*   END DESCRIPTION
       43**/
       44 
       45 /* HISTORY:
       46*
       47*   76-02-01  Originally written by R. D. Lackey.
       48*
       49*   77-03-01 R. D. Lackey: Modified  to support set operations.
       50*
       51*   77-09-01 R. D. Lackey: Modified  to  correct  deletion  of  non-
       52*   allocated file.
       53*
       54*   77-11-01 R. D. Lackey:  Modified  to  correct  static  variables
       55*   used by  multiple databases.
       56*
       57*   78-07-01 Oris Friesen: Modified  to  fix  problems  with  nested
       58*   intersects  and  differences.
       59*
       60*   78-07-14 Oris Friesen: Modified to fix union bug.
       61*
       62*   78-10-01 JA  Weeldreyer: Incorporated  MR7.0  changes.
       63*
       64*   79-03-26 Al Kepner: Added caller parameter to mrds_dsl_translate.
       65*
       66*   79-08-27 Al Kepner : Modified  to expand  the  current_data   and
       67*   static_data  variables  (used  in eliminating duplicates) to full
       68*   segments.
       69*
       70*   79-10-24  Davids: Modified the  length  calculation  for  varying
       71*   strings  so  that it takes into account bit verus character data.
       72*   Also so that it takes the length from the correct location in the
       73*   tuple.
       74*
       75*   79-10-30 Jim Gray: Modified to set  the  select_list pointer from
       76*   dbcb.current_ptr when a -current clause is used.
       77*
       78*   79-11-14 Jim Gray: Modified to fix  looping  cleanup  handler bug
       79*   by adding clean_up_condition variable.
       80*
       81*   80-02-14 Jim Gray: Modified to put allocations in a   non-freeing
       82*   extensible area managed by this routine.
       83*
       84*   80-04-01 Jim Gray: Modified to change data_ptr passed back by the
       85*   $set_tuple entry used by define_temp_rel so that it points to the
       86*   data  portion  of  the  varying  character  string  current_data,
       87*   not the count word.
       88*
       89*   80-05-08  Davids:  modified  assignments  of  tuple_num_atts  and
       90*   tuple_nvar_atts  to  take  values from rm_rel_info.model_num_attr
       91*   and  model_nvar_atts   rather   than   rm_rel_info.num_attr   and
       92*   nvar_atts.  This  was  to  fix  a problem with submodels were the
       93*   submodel view did not contain a varying string attribute and  the
       94*   model did.
       95*
       96*   80-09-16 Davids: removed  declarations  of  variables  that  were
       97*   never referenced. Also removed from the entry point set_tuple two
       98*   lines of code that as the first thing done  saved  the  value  of
       99*   area_ptr  in  a temporary and then set the value of area_ptr back
      100*   before the return. the assignment into a temporary was causing an
      101*   illegal   modifier   condition   because  of  the  value  of  the
      102*   uninitialized bits in the stack (area_ptr is  automatic)  -  this
      103*   only  happened when the code was compiled with optimize. when the
      104*   code was not compiled with optimize  other  garbage  values  were
      105*   used  which by coincidence represented a pointer. since there was
      106*   no reason to save the value of area_ptr the code was removed.
      107*
      108*   80-09-16 Jim  Gray:  to  put  the  duplicate  processing  and set
      109*   operation processing vfile storage  into  the  same  directory as
      110*   the resultant model which may be  other  than the [pd],  due to a
      111*   call to set_mrds_temp_dir.
      112*
      113*   80-09-18 Jim  Gray:  to  correct  the  routine  build_data_string,
      114*   the last assignment, where the true length is being set, to change
      115*   cur_pos / 9 to (cur_pos - 1) /  9, so that one too many characters
      116*   are not set as the length. this is due to the fact that cur_pos is
      117*   a substr index, not an offset.
      118*
      119*   80-09-23 Jim Gray: to  make sure that the per  call work area was
      120*   cleaned up when the cleanup condition was invoked, not just after
      121*   errors and normal exit. This required taking the temp file  clean
      122*   up into a separate routine, so that the non "-another" case could
      123*   do its  own cleanup without causing new temp segs to be generated.
      124*
      125*   80-11-10 Jim Gray: to change dele_$path calls to hcs_$del_dir_tree
      126*   and hcs_$delentry_file calls to improve performance.
      127*
      128*   81-01-17 Jim Gray : made same changes as  made  to  mus_mod_ubtup
      129*   for TR 8670, the variable involved in this case was tup_array.
      130*
      131*   81-01-29  Gray : removed references to mdbm_data_$current_version
      132*   using a constant instead to allow for future db version expansion.
      133*
      134*   81-02-03 Jim Gray : changed calculation of the varying  attribute
      135*   bit  length in the routine build_data_string in answer to TR 9041
      136*   so that set operations would work correctly.  Also  made  comment
      137*   about the problem with the set operation tuple not being the same
      138*   format  as  temp  and  perm  rel  tuples,  which  was  fixed   in
      139*   mrds_dsl_define_temp_rel instead.
      140*
      141*   81-03-11 Jim Gray : changed setting of  select_list  pointer  for
      142*   set  operations  so  that  -another  calls  would get the correct
      143*   select list. See TR 9269.
      144*
      145*   81-03-24 Jim Gray : added capability for selection expression  to
      146*   be declared by caller to be char varying as well as just char.
      147*
      148*   81-07-02  Roger  Lackey  :  to  fixed  the   place   where   call
      149*   clean_up_per_call_area  was  called  so  that error exit does not
      150*   call it twice.
      151*
      152*   81-07-15 Roger Lackey : to add code to automatically turn on  the
      153*   retain_dup  (like -dup argument in select exp) when the following
      154*   conditions exists: 1) only a single tuple varaiable exists 2) all
      155*   primary  key  attributes  are  selected  3)  only one "and" group
      156*   exists
      157*
      158*   81-07-25 Jim Gray : changed handling of no  and  group  case  for
      159*   auto -dup, so that when no where clause exists, if only one tuple
      160*   variable is specified, the -dup option can still be  forced  when
      161*   all key attrs are selected.
      162*
      163*   81-09-10   Jim   Gray   :   For   TR   11483,   changed   routine
      164*   return_data_temp,  so  that  set  operations  referring to tuples
      165*   having varying character strings  got  their  lengths  calculated
      166*   properly.  It  previously  was not considering whether the length
      167*   was in bits or chars.
      168*
      169*   81-09-10 Davids: Moved the code that sets the value  of  num_ptrs
      170*   to  before  any  reference  num_ptrs  is  made,  i.e.  before any
      171*   reference to arg_des_ptr is made. This prevents a  subscriptrange
      172*   condition.
      173*
      174*   81-10-22 Davids: Have converted references of the form:
      175*   .          ptr = addr (bit_array (large_offset))
      176*   .	              to
      177*   .          ptr = add_bit_offset (bit_array_ptr, large_offset - 1)
      178*   This gets around a pl1 bug (tr11784) that causes the first method
      179*   to  produce  the  wrong  value  when  the code is compiled with a
      180*   subscriptrange condition. The "-1" is needed because  bit_array's
      181*   first element is 1 not 0.
      182*
      183*   82-06-17  R.   Harvey:  Modified dup_check to not concatenate key
      184*   with  rest  of record when record is longer than 256 chars.  This
      185*   gets  around  a  pl1  bug  (tr12672) and also makes the code more
      186*   efficient.				 
      187*					 
      188*   82-07-21 D. Woodka : Modified to correct a bug  (tr phx12285)  so	 
      189*   the  dup_check  procedure would  not  return  with icode ^= 0 and 
      190*   dup_flag = ON. This caused  a loop  of code in move_db_to_file to
      191*   execute one too many times and return an end_of_information error
      192*   code.
      193*
      194*   82-08-23 Mike Kubicar : Converted module to use the simple vector
      195*   structure instead of the tuple structure.
      196*
      197*   82-10-25 Davids: Minor changes to the build_data_string internal proc.
      198*   move the assignment of the rai_ptr to the first thing in the
      199*   select_list.num_items loop so that the definition order can be determined,
      200*   it was being assigned after that point. Also changed the assignment into
      201*   bit_str to just assign the whole tup_data value instead of taking a
      202*   substr since the value now contains only the value of the attribute
      203*   of interest.
      204*
      205*   82-11-04 Davids: Yet another change to build_data_string. Corrected the
      206*   compound statement executed for the case of
      207*                 if old_vi ^= select_list.item.var_index (i)
      208*   it incorrected included the assignment of the tuple_data pointer (td_ptr)
      209*   which meant that value of the tuple_data changed only when the tuple
      210*   variable index changed. This was screwing up the data stored to determine
      211*   duplicates and resulted in non-duplicate data being identified as a duplicate.
      212*
      213*   83-01-03 Davids: Modified the build_data_string internal proc to correctly
      214*   build the data string, i.e. make sure that it starts out as a string of
      215*   nulls and only move that part of the varying strings that contain data.
      216*
      217*   83-01-06 Davids: Added code to handle transactions.
      218*
      219*   83-01-11 Davids: Modified the declaration of tup_data in build_data_string
      220*   to be actual_len instead of rm_attr_info.bit_length. This stops a 
      221*   stringsize condition what was causing the unused bits of tup_data from
      222*   being truncated during the assignment into the data_string.
      223*
      224*   83-01-14 Davids: Added code to set mftxn_code = 0 if the code was really
      225*   tuple_not_found - that is not an error so the transaction should commit.
      226*   Also so that this module will return the error code returned by the
      227*   transaction code if there is a problem finishing the transaction - that type
      228*   of error is more important than a mrds error.
      229*
      230*   83-01-24 Davids: modifed to set mstxn_id = "0"b as the first thing, so that
      231*   it is set incase an error occurs in argument processing or getting the 
      232*   database index.
      233*
      234*   83-02-03 Roger Lackey : Removed the bit_str init from build_data_string and 
      235*   replaced it with a substr to be used when necessary.
      236*
      237*   83-04-11 Davids: replaced references to add_bit_offset with references to 
      238*   addbitno.
      239*
      240*   83-05-04 Davids: Modified so that mu_define_area is called with a name
      241*   of MRDS || dbi_pic. This will allow closes to be faster since all
      242*   temp_segments with the name MRDS || dbi_pic can be deleted/freed in 1 call.
      243*   the variable dbi_pic was created as an easy way to convert from fixed bin
      244*   to character.
      245*
      246*   83-05-24 R. Harvey: Added code to support to re-retrieve a tuple when 
      247*   -current specifies attributes that were not previously retrieved. Also fixed
      248*   another occurrence of the bug TR 12672.
      249*
      250*   83-05-31 Mike Kubicar : Updated relation manager calling sequences.
      251*
      252*   83-06-08 Davids: Added the internal procedure build_vector_from_string
      253*   and modified the set_tuple entry to call it so that the data returned
      254*   is in the form of a vector instead of just a varying character string.
      255*
      256*   83-06-20 Davids: Removed check for old version database and the call
      257*   to v1 code if it was an old version db (old version dbs can no longer
      258*   be opened)
      259*
      260*   83-08-03 Harvey: Fixed TR phx15427 where duplicate suppression is not 
      261*   performed on a submodel where no key attributes are present.
      262*
      263*   83-08-22 Mike Kubicar : Removed the redundant bit fd.dup_keys_allowed.
      264*   Duplicate suppression is done before this bit is checked.  It also caused
      265*   an error with duplicate suppression of sets.
      266*
      267*   83-10-03 Paul Benjamin: Added comments in repsonse to audit; became 10th
      268*   person to modify the code.
      269*
      270*   84-08-29 Thanh Nguyen & Roger Lackey: Fixed the subroutine 
      271*   build_vector_from_string to advance the "current position" for the varying 
      272*   character string as same as any other data type when building the simple 
      273*   typed vector list. 
      274*
      275*   84-12-19 Thanh Nguyen: Added code to continue to retrieve another tuple if
      276*   the retrieved tuple from -another was deleted by another parallel running 
      277*   process (error code = mrds_error_$inconsistent_data_length) in share mode.
      278*
      279*   85-01-15 Thanh Nguyen:  Added code to create a special work area using 
      280*   mu_define_area$define_spec_temp_dir_area.  For now, this work area is used
      281*   by mu_retrieve and mu_get_data to "allocate" value_for_db and value_for_user
      282*   thru function mrds_space_allocate and reinitialize the area thru subroutine
      283*   mrds_area_initialize.
      284*
      285*   85-01-25 Thanh Nguyen & John Hergert: Moved the code which was added at
      286*   84-12-19 to get_next_tuple subroutine in mu_retrieve to improve performance.
      287*
      288*   85-04-14 Thanh Nguyen: Added code to reject the transaction of a retrieve
      289*   with "-another" and the tx id is not the same as the transaction of the 
      290*   original select expression.  And also added code to return an warning error
      291*   along with data when the scope was changed from non-shared mode to shared 
      292*   mode.
      293*
      294*   85-06-27 Thanh Nguyen : Modified code not to call to error in the case of 
      295*   invalid dbi.  Also moved the reseting of dbcb.non_shared_to_shared flag
      296*   from init subroutine of this module to mrds_dsl_optimize and 
      297*   mrds_dsl_gen_srch_prog.
      298*
      299*   86-02-18 Hergert: Fixed bug where invalid dbi caused linkage error
      300*   to transaction_manager_. This is because mstxn_txn_id was uninitialized.
      301**/
      302 
      303 /* INPUT CONDITIONS:
      304*
      305*   database_index 		is the index of the database the caller wishes to retrieve.
      306*
      307*   selection_expression 	is the expression supplied by the user to select the tuples to be retrieved.
      308*
      309*   values  		are the retrieved tuple values or attribute values.
      310**/
      311 
      312 /* OUTPUT DEFINITIONS:
      313*
      314*   If no errors are encountered the retrieval was performed.
      315*
      316*   code = 0;			    if no errors were detected.
      317*
      318*   code = error_table_$bad_ptr;	    if the dbcbw_ptr could not be obtained.
      319*
      320*   code = mrds_error_$tuple_not_found;      if a tuple selected was not found in the database.
      321*
      322*   code = mrds_error_$invalid_db_index;     if no dbcb_ptr was found for the database index.
      323*
      324*   If less then  4 arguments were passed to this procedure the
      325*   condition arg_error will be signaled.
      326*
      327*code = something else;		    if another error is detected by this module.
      328**/
      329 
      330 	area_ptr, dbcb_ptr = null;
      331 	mstxn_txn_id = "0"b;
      332 	st_entry = "0"b;				/* remember retr. entry */
      333 	call cu_$arg_list_ptr (al_ptr);		/* Get pointer to this proc arg list */
      334 	if al_ptr = null then signal arg_error;		/* This returns you to command level */
      335 
      336 	nargs = divide (arg_list.arg_count, 2, 17, 0);	/* Get the number of arguments to this proc */
      337 	if nargs < 4 then signal arg_error;		/* This returns to command level */
      338 
      339 
      340 
      341 	if arg_list.code = 4 then num_ptrs = arg_list.arg_count; /* Determine number of ptrs in arg list */
      342 	else num_ptrs = arg_list.arg_count + 1;
      343 
      344 
      345 	call cu_$arg_ptr (nargs, cd_ptr, arg_len, icode); /* Get  pointer to callers return code */
      346 	if icode ^= 0 then signal arg_error;		/* This returns to command level */
      347 
      348 	call cu_$arg_ptr (1, dbi_ptr, arg_len, icode);	/* Get pointer to database index */
      349 	if icode ^= 0 then call error (icode);
      350 
      351 	call cu_$arg_ptr (2, se_ptr, se_len, icode);	/* Get pointer to selection expression */
      352 	if icode ^= 0 then call error (icode);
      353 
      354 
      355 	if arg_list.code = 4 then
      356 	     desc_ptr = arg_list.arg_des_ptr (nargs + 2);
      357 	else desc_ptr = arg_list.arg_des_ptr (nargs + 3);
      358 
      359 	if descriptor.type = 22 then do;
      360 		se_len_ptr = addrel (se_ptr, -1);	/* get current length of varying string */
      361 		se_len = se_len_ptr -> fb35u;
      362 	     end;
      363 
      364 
      365 	appl_ptr = addr (arg_list.arg_des_ptr (3));	/* Get pointer to the beginning  */
      366 						/*   of the arg_ptr_list for translate */
      367 						/* Now get pointer to beginning of descriptor */
      368 						/*   pointer list for translate */
      369 	if arg_list.code = 4 then adpl_ptr = addr (arg_list.arg_des_ptr (nargs + 3));
      370 	else adpl_ptr = addr (arg_list.arg_des_ptr (nargs + 4));
      371 
      372 	num_args = nargs - 3;			/* Number of args passed to translate */
      373 
      374 	call mu_database_index$get_resultant_model_pointer (database_index, dbcb_ptr); /* Get the dbcb pointer */
      375 	if dbcb_ptr = null then do;
      376 	     code = mrds_error_$invalid_db_index;
      377 	     return;
      378 	end;
      379 
      380 	call init;
      381 
      382 	mstxn_transactions_needed = dbcb.transactions_needed;
      383 
      384 	original_appl_ptr = appl_ptr;			/* static data needed in case transaction is rolled back */
      385 	original_adpl_ptr = adpl_ptr;
      386 	original_num_args = num_args;
      387 
      388 	on cleanup begin;				/* Establish a cleanup handler */
      389 		call mstxn_cleanup;
      390 		call cleanup_handler;
      391 	     end;
      392 	on any_other call mstxn_any_other;		/* Establish an any_other handler */
  1     1 /* ====== BEGIN INCLUDE FILE	          mrds_start_transaction.incl.pl1 =========================== */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the changes made on 85-05-06 and
  1     9*     85-04-19 by Thanh Nguyen. The dependency on dbcb.user_started_transaction
  1    10*     was removed because not all modules need the dbcb, and the
  1    11*     user_transaction_id field was added for mrds_dsl_retrieve (mrds error
  1    12*     list #136).
  1    13*                                                   END HISTORY COMMENTS */
  1    14 
  1    15 
  1    16 /*
  1    17*                    BEGIN_DESCRIPTION
  1    18*
  1    19*   A generalized routine accessed by all MRDS modules (with the temporary 
  1    20*   (perhaps) exception of restructuring modules) that must start transactions 
  1    21*   if none are present.  The intent is that it be executed as inline code.
  1    22*   The variable mstxn_transactions_needed must be set prior to entering this
  1    23*   code.  In most cases a simple assignment from dbcb_data.transactions_needed
  1    24*   will suffice.  Included are procedures called mstxn_cleanup and 
  1    25*   mstxn_any_other.  These procedures must be called by cleanup and any_other 
  1    26*   handlers in the program.  Such handlers should be established just prior to
  1    27*   the inclusion of this code and disabled just following the inclusion of
  1    28*   mrds_finish_transaction.  Directly prior to establishing the handlers
  1    29*   mstxn_txn_id must be set to "0"b.  This must be done even though this 
  1    30*   include file does the same, because this code might not have been entered 
  1    31*   yet when the handler is invoked.  Directly following this include file the 
  1    32*   contents of mstxn_code should be examined.  If zero, then either the 
  1    33*   transaction was successfully started or no transaction was required.  If the
  1    34*   mrds_finish_transaction code is referenced in general error handling 
  1    35*   situations where the possibility exists that the code in this include file 
  1    36*   has not been executed, it is necessary to initialize mstxn_txn_id to "0"b at
  1    37*   the beginning of the program.
  1    38*
  1    39*                    END_DESCRIPTION
  1    40*
  1    41*   Written 82-09-28 by Paul W. Benjamin.
  1    42*   Modified 82-12-09 by PWB to include mstxn_any_other.
  1    43*   Modified 83-01-07 by PWB to not reference the dbcb.
  1    44*   Modified 83-01-10 by PWB to add a call to continue_to_signal_ to the
  1    45*		 any_other handler in situations where the module did
  1    46*		 not start the transaction.
  1    47*   Modified 83-05-05 by PWB to abandon when abort fails.
  1    48*   Modified 83-05-18 by PWB to use mstxn_temp_code in calls to abandon and
  1    49*		 and abort.
  1    50*   Modified 83-05-19 by PWB to handle transaction_deadlock and 
  1    51*		 transaction_bj_full conditions.
  1    52*   Modified 84-02-04 by PWB to add trailing underscores to the 2 conditions
  1    53*		 and to handle transaction_lock_timeout_.
  1    54*   Modified 85-04-14 by Thanh Nguyen: Added code to set the 
  1    55*                     dbcb.user_started_transaction flag.
  1    56*   Modified 85-04-19 by Thanh Nguyen to add user_started_transaction flag.
  1    57*   Modified 85-05-06 By Thanh Nguyen to synchronize this include file in the 
  1    58*                     directory >ldd>include and >exl>mrd>i
  1    59**/
  1    60 
  1    61 dcl continue_to_signal_ entry (fixed bin(35));
  1    62 dcl dm_error_$no_current_transaction fixed bin (35) ext static;
  1    63 dcl error_table_$null_info_ptr fixed bin(35) ext static;
  1    64 dcl find_condition_info_ entry (ptr, ptr, fixed bin(35));
  1    65 dcl mstxn_code fixed bin (35);
  1    66 dcl mstxn_retries fixed;
  1    67 dcl mstxn_temp_code fixed bin (35);
  1    68 dcl mstxn_transactions_needed bit (1) aligned;
  1    69 dcl user_started_transaction bit (1) aligned;
  1    70 dcl mstxn_txn_id bit (36) aligned;
  1    71 dcl user_transaction_id bit (36) aligned;
  1    72 dcl transaction_manager_$abandon_txn entry (bit (36) aligned, fixed bin (35));
  1    73 dcl transaction_manager_$abort_txn entry (bit (36) aligned, fixed bin (35));
  1    74 dcl transaction_manager_$begin_txn entry (fixed bin, fixed bin (35), bit (36) aligned, fixed bin (35));
  1    75 dcl transaction_manager_$get_current_txn_id entry (bit (36) aligned, fixed bin (35));
  1    76 dcl transaction_manager_$handle_conditions entry ();
  1    77 dcl 1 mstxn_condition_info like condition_info;
  1    78 
  2     1 /*  START OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*Designed by Matthew C. Pierret, 01/26/82.
  2     6*Coded by Jeffrey D. Ives, 04/30/82.
  2     7*Modified:
  2     8*10/18/82 by Steve Herbst: Names changed.
  2     9*01/19/83 by Steve Herbst: Added (LOWEST HIGHEST)_MODE.
  2    10**/
  2    11 
  2    12 dcl (LOWEST_MODE init (1),
  2    13      HIGHEST_MODE init (8)) fixed bin int static options (constant);
  2    14 
  2    15      dcl	   TM_NORMAL_MODE	      fixed bin static options (constant) init (1);
  2    16      dcl	   TM_STATISTICAL_MODE   fixed bin static options (constant) init (2);
  2    17      dcl	   TM_READ_ONLY_MODE     fixed bin static options (constant) init (3);
  2    18      dcl	   TM_NEVER_WRITE_MODE   fixed bin static options (constant) init (4);
  2    19      dcl	   TM_TEST_NORMAL_MODE   fixed bin static options (constant) init (5);
  2    20      dcl	   TM_TEST_STATISTICAL_MODE fixed bin static options (constant) init (6);
  2    21      dcl	   TM_TEST_READ_ONLY_MODE fixed bin static options (constant) init (7);
  2    22      dcl	   TM_TEST_NEVER_WRITE_MODE fixed bin static options (constant) init (8);
  2    23 
  2    24 /*  END OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    79 

  1    80 
  3     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  3     2 
  3     3 /* Structure for find_condition_info_.
  3     4*
  3     5*   Written 1-Mar-79 by M. N. Davidoff.
  3     6**/
  3     7 
  3     8 /* automatic */
  3     9 
  3    10      declare condition_info_ptr     pointer;
  3    11 
  3    12 /* based */
  3    13 
  3    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  3    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  3    16 	     2 version	      fixed binary,		/* Must be 1 */
  3    17 	     2 condition_name     char (32) varying,	/* name of condition */
  3    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  3    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  3    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  3    21 	     2 flags	      unaligned,
  3    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  3    23 	       3 pad1	      bit (35),
  3    24 	     2 pad2	      bit (36),
  3    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  3    26 	     2 pad3	      (4) bit (36);
  3    27 
  3    28 /* internal static */
  3    29 
  3    30      declare condition_info_version_1
  3    31 			      fixed binary internal static options (constant) initial (1);
  3    32 
  3    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
  1    81 
  1    82 
  1    83 	mstxn_code = 0;
  1    84 	mstxn_txn_id = "0"b;
  1    85 	
  1    86 	if ^mstxn_transactions_needed			/* only need transactions */
  1    87 	     then goto mstxn_exit;			/* for protected page files */
  1    88 	mstxn_retries = 0;
  1    89 	call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
  1    90 	if mstxn_code ^= dm_error_$no_current_transaction	/* and if none already in progress */
  1    91 	     then do;				
  1    92 	     user_started_transaction = "1"b;
  1    93 	     user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1    94 	     mstxn_txn_id = "0"b;			/* you didn't start it, it's none of your business */
  1    95 	     goto mstxn_exit;	
  1    96 	end;
  1    97 
  1    98 	user_started_transaction = "0"b;
  1    99 	call transaction_manager_$begin_txn (TM_NORMAL_MODE, 0, mstxn_txn_id, mstxn_code);
  1   100 	user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1   101 
  1   102 mstxn_cleanup:
  1   103 proc;
  1   104 
  1   105 /*  This procedure MUST be called by a cleanup handler. */
  1   106 
  1   107           if mstxn_txn_id ^= "0"b
  1   108           then do;
  1   109 	     call transaction_manager_$abort_txn (mstxn_txn_id, mstxn_temp_code);
  1   110 	     if mstxn_temp_code ^= 0
  1   111 		then call transaction_manager_$abandon_txn (mstxn_txn_id, mstxn_temp_code);
  1   112 	end;
  1   113 	
  1   114      end mstxn_cleanup;
  1   115 
  1   116 mstxn_any_other:
  1   117 proc;
  1   118 
  1   119 /*  This procedure MUST be called by an any_other handler. */
  1   120 
  1   121           if mstxn_txn_id ^= "0"b
  1   122           then do;
  1   123 	     call find_condition_info_ (null (), addr(mstxn_condition_info), mstxn_temp_code);
  1   124 	     if mstxn_condition_info.condition_name = "transaction_deadlock_"
  1   125 		then do;
  1   126 		mftxn_code = dm_error_$lock_deadlock;
  1   127 		goto mftxn_check_code;
  1   128 	     end;
  1   129 	     else if mstxn_condition_info.condition_name = "transaction_bj_full_"
  1   130 		| mstxn_condition_info.condition_name = "transaction_lock_timeout_"
  1   131 		then do;
  1   132 		mftxn_code = dm_error_$bj_journal_full;
  1   133 		goto mftxn_check_code;
  1   134 	     end;
  1   135 	     else call transaction_manager_$handle_conditions;
  1   136 	end;
  1   137 	else call continue_to_signal_ (mstxn_code);	/* code returned will always be zero */
  1   138      end mstxn_any_other;
  1   139      
  1   140 mstxn_exit:
  1   141      
  1   142 /* ------ END INCLUDE FILE	          mrds_start_transaction.incl.pl1 --------------------------- */
      393 
      394 
      395 	if mstxn_code ^= 0
      396 	then call error (mstxn_code);
      397 
      398 	dbcb.user_started_transaction = user_started_transaction;
      399 	dbi_pic = dbcb.dbi;
      400 	call mu_define_area$define_temp_dir_area (dbcb.retrieve_area_ptr, database_index, (sys_info$max_seg_size), "MRDS" || dbi_pic,
      401 	     "0"b /* not extensible */, "1"b /* no freeing */, "0"b, "0"b /* no zeroing */, icode);
      402 	if icode ^= 0 then call error (icode);
      403 	area_ptr = dbcb.retrieve_area_ptr;
      404 						/* Create a work area for mu_retrieve to allocate the value_for_user and value_for_db. */
      405 	call mu_define_area$define_spec_temp_dir_area (dbcb.work_area_ptr, database_index, "MRDS" || dbi_pic, icode);
      406 	if icode ^= 0 then call error (icode);
      407 
      408 	call mrds_dsl_translate (dbcb_ptr, area_ptr, mrds_data_$caller_retrieve,
      409 	     se_ptr, se_len, appl_ptr, adpl_ptr, num_args, icode);
      410 	if icode ^= 0 then call error (icode);
      411 	if ^dbcb.val_rtrv then call error (mrds_error_$inval_rtrv_expr);
      412 
      413 	if dbcb.another_flag = ON then do;
      414 		if dbcb.se_transaction_id ^= "0"b
      415 		then if dbcb.se_transaction_id ^= user_transaction_id
      416 		     then if ^dbcb.data.dont_check_txn_id
      417 		          then call error (mrds_error_$inconsistent_transaction_se);
      418 	     end;
      419 	else if dbcb.current_flag = OFF then do;	/* If this invocation is not because of */
      420 		call clean_up_temp_files ();		/* -another cleanup the previous tuple area */
      421 		retrieve_info.auto_dup_determined = "0"b; /* Not determined yet */
      422 
      423 	     end;
      424 
      425 
      426 	if dbcb.ss_ptr ^= null then do;		/* SET RETRIEVALS are handled special */
      427 		ss_ptr = dbcb.ss_ptr;
      428 		if ^dbcb.another_flag then call init_set;
      429 
      430 
      431 		select_list_ptr = dbcb.select_ptr;
      432 
      433 
      434 		call get_set_another;		/* Pass the tuple data to user */
      435 	     end;					/* set retrieval */
      436 
      437 	else do;					/* Non-set retrieval */
      438 		call mrds_dsl_search (dbcb_ptr, area_ptr, icode); /* Search for a tuple */
      439 		if icode ^= 0 then call error (icode);
      440 
      441 		retrieve_info.retain_dup = dbcb.dup_retain; /* ON => we retain duplicates */
      442 
      443 		ti_ptr = dbcb.ti_ptr;		/* Establish tuple_info pointer */
      444 		range_ptr = dbcb.range_ptr;
      445 		select_list_ptr = dbcb.select_ptr;
      446 
      447 
      448 		if dbcb.another_flag = ON & retrieve_info.retain_dup = OFF then do;
      449 
      450 /*  If not done yet determine if retain dup should automatically be turned on */
      451 
      452 
      453 
      454 			if dbcb.pred_ptr = null then
      455 			     number_of_and_groups = 0;/* check for 1 T.V. relation dump  */
      456 			else number_of_and_groups = dbcb.pred_ptr -> pred_array.num_ands;
      457 
      458 
      459 			if ^retrieve_info.auto_dup_determined &
      460 			     number_of_and_groups < 2 &
      461 			     range.num_vars = 1 then do; /* Only one tuple variable must exists */
      462 				rmri_ptr = range.tup_var (1).ri_ptr;
      463 				if select_list.num_items >= rm_rel_info.nkey_attr & rm_rel_info.nkey_attr > 0 then do; /* Got to have enough key attrs */
      464 					key_used_len = rm_rel_info.nkey_attr;
      465 
      466 					allocate key_used in (dbcb.static_area) set (key_used_ptr);
      467 					key_used (*) = "0"b; /* Init to off */
      468 
      469 					do i = 1 to select_list.num_items; /* See if we use all primary key attrs */
      470 					     found = "0"b;
      471 
      472 					     do j = 1 to key_used_len while (^found);
      473 						if select_list.item (i).ai_ptr = rm_rel_info.key_attr_ptrs (j) then do;
      474 							found = "1"b;
      475 							key_used (j) = "1"b; /* Remember we used it */
      476 						     end;
      477 					     end;
      478 					end;	/* END i = 1 to select_list.num_items */
      479 
      480 					if index (string (key_used), "0"b) = 0 then dbcb.dup_retain, retrieve_info.retain_dup = "1"b;
      481 					if key_used_ptr ^= null then free key_used;
      482 				     end;
      483 				retrieve_info.auto_dup_determined = "1"b; /* Rember we determined it already */
      484 			     end;			/* END if range.num_vars = 1 */
      485 
      486 			if ^retrieve_info.retain_dup then call another; /* If selection expression was -another and
      487*						   we are not retaining duplicates then call the another proc */
      488 
      489 		     end;
      490 
      491 
      492 
      493 		else if dbcb.current_flag = OFF & retrieve_info.retain_dup = OFF then do;
      494 			call build_data_string (static_data);
      495 						/* Otherwise save the data for possible future use by -another */
      496 			retrieve_info.unique_count = 1;
      497 
      498 		     end;
      499 		else if dbcb.current_flag = ON then
      500 		     select_list_ptr = dbcb.current_ptr;	/* get select list for -current */
      501 
      502 		call return_data_tup;
      503 		num_tuples_retrieved = num_tuples_retrieved + 1;
      504 
      505 	     end;
      506 
      507 	if num_tuples_retrieved = 0 then /* If none were retrieved return an error */
      508 	     call error (mrds_error_$tuple_not_found);
      509 
      510 	else if dbcb.another_flag = ON & dbcb.non_shared_to_shared then
      511 	     code = mrds_error_$incomp_se_and_scope;
      512 	else code = 0;				/* Return with no errors */
      513 
      514 
      515 
      516 	call clean_up_per_call_area ();
      517 
      518 exit:
      519 
      520 	if code = mrds_error_$tuple_not_found | /* tuple not found is not really */
      521 	     code = mrds_error_$incomp_se_and_scope	/* This is just the warning, we allow to return data. */
      522 	then mftxn_code = 0;			/* an error so we don't want transaction to abort */
      523 	else mftxn_code = code;
      524 
  4     1 /* ====== BEGIN INCLUDE FILE           mrds_finish_transaction.incl.pl1 =========================== */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  4     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  4     8*     This entry is being made to cover the change made on 85-05-06 by Thanh
  4     9*     Nguyen. The code now checks a local flag. (mrds error list #136).
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /*
  4    14*                    BEGIN_DESCRIPTION
  4    15*
  4    16*   A generalized routine accessed by all MRDS modules that begin and commit 
  4    17*   transactions.  The intent is that it be executed as inline code. It is 
  4    18*   assumed that mrds_start_transaction was executed previously in the 
  4    19*   procedure.  Prior to this include file the program should assign the value 
  4    20*   of its local error code to mftxn_code.  The program utilizing this
  4    21*   include file must supply a function labeled should_rollback that returns
  4    22*   bit (1).  This routine should examine the error code mftxn_code and whether
  4    23*   the transaction should be aborted or rolled back.  "0"b means abort and "1"b
  4    24*   means rollback.  This procedure may choose to simply return "0"b as it 
  4    25*   appears that MRDS will generally NOT rollback transactions.  This routine
  4    26*   does rollback and restart if the before journal is full but only attempts it
  4    27*   once.  A procedure labelled restore_significant_data must also be supplied, 
  4    28*   where any data that was saved prior to the transaction is restored.  A 
  4    29*   procedure consisting solely of a return statement can be supplied if 
  4    30*   necessary.  After execution of this include file, mftxn_code must be
  4    31*   examined.  If it was 0 before entering the code and is non-zero afterward,
  4    32*   then the commit has failed.  Otherwise it will be unchanged.
  4    33*
  4    34*                    END_DESCRIPTION
  4    35*
  4    36*   Written 82-09-30 by Paul W. Benjamin.
  4    37*   Modified 83-01-13 by PWB to add retry on deadlocks and to return a non-zero 
  4    38*                     error code only when the transaction is in an error state.
  4    39*   Modified 83-02-04 by PWB to reset transaction id to 0 upon completion.
  4    40*   Modified 83-05-05 by PWB to abort when rollback fails, abandon when abort
  4    41*		 fails, and to abort rather than rollback when bj is full.
  4    42*   Modified 83-05-18 by PWB to use mftxn_temp_code in calls to abandon, abort
  4    43*		 and rollback.
  4    44*   Modified 83-05-19 by PWB to add mftxn_check_code label.  It is transferred
  4    45*		 to by the mstxn_any_other procedure.
  4    46*   Modified 85-04-14 by Thanh Nguyen not to commit the transaction in case of
  4    47*                     the user already started his own transaction.
  4    48*   Modified 85-05-06 by Thanh Nguyen to synchronize this include file between
  4    49*                     the directory >ldd>include and >exl>mrd>i.
  4    50**/
  4    51 
  4    52 dcl dm_error_$bj_journal_full fixed bin(35) ext static;
  4    53 dcl dm_error_$lock_deadlock fixed bin(35) ext static;
  4    54 dcl mftxn_code fixed bin (35);
  4    55 dcl mftxn_temp_code fixed bin (35);
  4    56 dcl transaction_manager_$commit_txn entry (bit (36) aligned, fixed bin (35));
  4    57 dcl transaction_manager_$rollback_txn entry (bit (36) aligned, fixed bin (17), fixed bin (35));
  4    58 	
  4    59 
  4    60 	if mstxn_txn_id = "0"b | user_started_transaction = "1"b	/* No transaction or we did not started it */
  4    61 	     then do;
  4    62 	     mftxn_code = 0;
  4    63 	     goto mftxn_exit;
  4    64 	end;
  4    65 mftxn_check_code:
  4    66 	if mftxn_code = 0
  4    67 	     then do;
  4    68 	     call transaction_manager_$commit_txn (mstxn_txn_id, mftxn_code);
  4    69 	     if mftxn_code ^= 0
  4    70 		then do;
  4    71 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    72 		if mftxn_temp_code ^= 0
  4    73 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    74 	     end;
  4    75 	end;
  4    76 	else do;
  4    77 	     call restore_significant_data;
  4    78 	     if mftxn_code = dm_error_$lock_deadlock	/* retry just once if deadlock */
  4    79 		& mstxn_retries < 1		
  4    80 		then do;
  4    81 		     mstxn_retries = mstxn_retries + 1;
  4    82 		     call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    83 		     if mftxn_temp_code ^= 0
  4    84 			then do;
  4    85 			call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    86 			if mftxn_temp_code ^= 0
  4    87 			     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    88 		     end;
  4    89 		     else do;
  4    90 			mstxn_code = 0;
  4    91 			goto mstxn_exit;		/* go back and try again */
  4    92 		     end;
  4    93 		end;
  4    94 	     else if should_rollback ()		/* let the program decide */
  4    95 		then do;
  4    96 		call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    97 		if mftxn_temp_code ^= 0
  4    98 		     then do;
  4    99 		     call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   100 		     if mftxn_temp_code ^= 0
  4   101 			then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   102 		end;
  4   103 		else do;
  4   104 		     mstxn_code = 0;
  4   105 		     goto mstxn_exit;		/* go back and try again */
  4   106 		end;
  4   107 	     end;
  4   108 	     else do;
  4   109 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   110 		if mftxn_temp_code ^= 0
  4   111 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   112 	     end;
  4   113 	end;
  4   114 	mstxn_txn_id = "0"b;			/* should never be nonzero unless there is a txn */
  4   115 mftxn_exit:
  4   116      
  4   117 /* ------ END INCLUDE FILE	          mrds_finish_transaction.incl.pl1 --------------------------- */
      525 
      526 
      527 	if mftxn_code ^= 0				/* problems finishing the transaction are more important */
      528 	then code = mftxn_code;			/* than any error mrds could produce on its own */
      529 
      530 	return;					/* Return to caller with some code */
      531 
      532 should_rollback:
      533      proc () returns (bit (1));
      534 
      535 /* This module requests no rollbacks. */
      536 
      537 	return ("0"b);
      538 
      539      end should_rollback;
      540 
      541 restore_significant_data: proc;
      542 
      543 	appl_ptr = original_appl_ptr;
      544 	adpl_ptr = original_adpl_ptr;
      545 	num_args = original_num_args;
      546 
      547 	call clean_up_per_call_area ();
      548 
      549      end restore_significant_data;
      550 
      551 set_tuple: entry (a_dbcb_ptr, a_area_ptr, data_ptr, a_code);
      552 
      553 /* ENtry to retrieve a tuple for define temp rel given a set selection expr. */
      554 
      555 	dcl     (a_dbcb_ptr,
      556 	        a_area_ptr,
      557 	        data_ptr)		 ptr;
      558 	dcl     a_code		 fixed bin (35);
      559 
      560 	area_ptr = a_area_ptr;
      561 	dbcb_ptr = a_dbcb_ptr;
      562 	st_entry = "1"b;
      563 	call init;
      564 	ss_ptr = dbcb.ss_ptr;
      565 	if ^dbcb.another_flag then do;		/* if first time */
      566 		call init_set;
      567 	     end;
      568 	call get_temp_record (set_info.cur_fdx, current_data, icode); /* get next tuple */
      569 	if icode = error_table_$end_of_info then icode = mrds_error_$tuple_not_found;
      570 	if icode ^= 0 then call error (icode);
      571 	num_tuples_retrieved = num_tuples_retrieved + 1;
      572 	set_info.cur_data_valid = "0"b;
      573 	call build_vector_from_string (addr (current_data), data_ptr);
      574 	a_code = 0;
      575 
      576 st_exit:
      577 	return;
      578 
      579 add_record: proc (fdx, data);				/* Adds a data item to a temp-file */
      580 						/* Duplicates are retained according to the attach description */
      581 	dcl     data		 char (*) varying;
      582 	dcl     fdx		 fixed bin;
      583 	dcl     key_only		 bit (1);
      584 
      585 	key_only = (length (data) <= 256);
      586 	fd_ptr = retrieve_info.ret_fd_ptr (fdx);	/* Set the file desc pointer */
      587 
      588 	if key_only = ON then do;
      589 		call iox_$seek_key (fd.iocb_ptr, (data), rec_len, icode);
      590 		if icode ^= error_table_$no_record then if icode ^= 0 then call error (icode);
      591 		fd.rec_buf = "";
      592 		fd.cur_key = data;
      593 		fd.rec_len = 0;
      594 	     end;
      595 	else do;
      596 		call iox_$seek_key (fd.iocb_ptr, (substr (data, 1, 256)), rec_len, icode);
      597 		if icode ^= error_table_$no_record then if icode ^= 0 then call error (icode);
      598 		fd.cur_key = substr (data, 1, 256);
      599 		fd.rec_buf = substr (data, 257);
      600 		fd.rec_len = length (data) - 256;
      601 	     end;
      602 
      603 	if (icode = error_table_$no_record) | (icode = 0) then do;
      604 		call iox_$write_record (fd.iocb_ptr, addr (fd.rec_buf), fd.rec_len, icode);
      605 		fd.rec_count = fd.rec_count + 1;
      606 	     end;
      607 	else call error (icode);
      608 
      609      end add_record;
      610 
      611 another: proc;
      612 
      613 /* This internal procedure handles the case where the selection expression is "-another".
      614*   It checks for duplicate data from prievious calls to a retrieve with -another.
      615*
      616*   This procedure returns to its calling procedure only when a unique data group has been found otherwise the
      617*   error procedure is called.
      618**/
      619 
      620 	dcl     fdx		 fixed bin internal static;
      621 
      622 	dup_flag = ON;				/* Set duplicate record indicator on to start with */
      623 
      624 	do while (dup_flag = ON);
      625 	     call build_data_string (current_data);
      626 
      627 	     if retrieve_info.unique_count = 1 then do;
      628 		     if current_data ^= static_data then do; /* If the current data is
      629*						   different then the first data acquired form
      630*						   retrieve then do */
      631 						/* Create a new duplicate data file */
      632 			     call create_temp_file (fdx);
      633 			     call add_record (fdx, static_data); /* Add the first data rec */
      634 						/*   add_record set the dup_flag */
      635 			     call add_record (fdx, current_data); /* Add the second data record */
      636 			     retrieve_info.unique_count = 2; /* The number of unique records = 2 */
      637 			     dup_flag = OFF;	/* Turn it off cause we don't have any now */
      638 			end;
      639 						/* If current_data = record then it is a duplicate
      640*						   and dup_flag is left on */
      641 		end;
      642 
      643 	     else do;				/* This is for unique count greater then or equal  2 */
      644 		     dup_flag = OFF;
      645 		     if retrieve_info.retain_dup = OFF then /* We are retaining duplicates */
      646 			call dup_check (fdx, current_data, dup_flag); /* This sets the dup_flag */
      647 		     if dup_flag = OFF then do;
      648 			     call add_record (fdx, current_data);
      649 			     retrieve_info.unique_count = retrieve_info.unique_count + 1; /* If no
      650*						   duplicates were found the
      651*						   record was added to duplicate file
      652*						   so add one to the unique data count */
      653 			end;
      654 		end;				/* Else the record was a duplicate and dup_flag is still on */
      655 
      656 	     if dup_flag = ON then call mrds_dsl_search (dbcb_ptr, area_ptr, icode); /* See if ANOTHER record exists */
      657 	     if icode ^= 0 then call error (icode);
      658 
      659 	end;					/* END of do while (dup_flag = ON */
      660 
      661 	return;					/* Return to calling proc */
      662      end another;
      663 
      664 build_data_string: proc (data_str);
      665 
      666 /* Procedure to build a character string from the selected attributes. */
      667 
      668 	dcl     bit_str		 bit (9 * maxlength (data_str)) based (bs_ptr);
      669 	dcl     data_str		 char (*) var;
      670 	dcl     (bs_ptr,
      671 	        td_ptr)		 ptr;
      672 	dcl     tup_data		 bit (actual_len) based (td_ptr);
      673 	dcl     (cur_pos,
      674 	        old_vi,
      675 	        j,
      676 	        i)		 fixed bin (35);
      677 	dcl     length_word_overlay	 fixed bin (35) unaligned based;
      678 	dcl     actual_len		 fixed bin (35);	/* actual amount of bits of data in tup_data */
      679 
      680 	cur_pos = 1;				/* initialize */
      681 
      682 	bs_ptr = addrel (addr (data_str), 1);		/* point to data portion of string */
      683 	old_vi = 0;
      684 
      685 	do i = 1 to select_list.num_items;		/* look at every selected attribute */
      686 
      687 	     rai_ptr = select_list.item.ai_ptr (i);	/* get info pointers */
      688 
      689 	     if old_vi ^= select_list.item.var_index (i) then do; /* if must initialize */
      690 		     old_vi = select_list.item.var_index (i); /* set for next time */
      691 		     rmri_ptr = range.tup_var.ri_ptr (select_list.item.var_index (i));
      692 
      693 		     do j = 1 to tuple_info.num_tuples while (tuple_info.tuple.var_index (j) ^= old_vi);
      694 		     end;				/* locate tuple ptr */
      695 		     simple_typed_vector_ptr
      696 			= tuple_info.tuple.tuple_ptr (j);
      697 		end;				/* tuple initialization */
      698 	     td_ptr = simple_typed_vector.
      699 		dimension (rm_attr_info.defn_order).value_ptr;
      700 
      701 	     if mu_data_class$varying (addr (rm_attr_info.domain_ptr -> rm_domain_info.db_desc))
      702 	     then do;
      703 		     if mu_data_class$bit (addr (rm_attr_info.domain_ptr -> rm_domain_info.db_desc))
      704 		     then actual_len = td_ptr -> length_word_overlay + 36; /* + 36 for length word */
      705 		     else actual_len = td_ptr -> length_word_overlay * 9 + 36; /* char count * 9 for bit count */
      706 		end;
      707 	     else actual_len = rm_attr_info.bit_length;	/* set up for fixed length */
      708 
      709 	     substr (bit_str, cur_pos, actual_len) = tup_data; /* move the value */
      710 	     if actual_len < rm_attr_info.bit_length then
      711 		substr (bit_str, cur_pos + actual_len, rm_attr_info.bit_length - actual_len) = "0"b;
      712 	     cur_pos = cur_pos + rm_attr_info.bit_length;
      713 	     if cur_pos > length (bit_str) then call error (mrds_error_$max_retr_len);
      714 
      715 	end;					/* concatenation loop */
      716 
      717 	addr (data_str) -> fb35u = ceil ((cur_pos - 1) / 9); /* set true length */
      718 
      719      end build_data_string;
      720 
      721 build_vector_from_string: proc (bvfs_data_ptr, bvfs_simple_typed_vector_ptr);
      722 
      723 /*
      724*   This procedur takes a varying bit string containing data and converts it
      725*   to a simple vector containing data.
      726**/
      727 
      728 /* PARAMETERS */
      729 
      730 	dcl     bvfs_data_ptr	 ptr;		/* (input) pointer to a varying char string containing data */
      731 	dcl     bvfs_simple_typed_vector_ptr ptr;	/* (input) pointer to a vector, the data will be output */
      732 
      733 
      734 /* AUTOMATIC */
      735 
      736 	dcl     cur_pos		 fixed bin (35);	/* position of first bit of the next attr value */
      737 	dcl     old_vi		 fixed bin (35);	/* var_index of the last attr looked at */
      738 	dcl     i			 fixed bin (35);	/* loop counter */
      739 	dcl     bit_string_len	 fixed bin (35);	/* number of bits in data string */
      740 	dcl     bit_string_ptr	 ptr;		/* pointer to data bits */
      741 
      742 /* BASED */
      743 
      744 	dcl     bit_array		 (bit_string_len) bit (1) unal based (bit_string_ptr);
      745 						/* bit string of data to be converted to vector */
      746 	dcl     length_word_overlay	 fixed bin (35) unal based;
      747 
      748 
      749 
      750 
      751 	bit_string_len = bvfs_data_ptr -> length_word_overlay * 9;
      752 	bit_string_ptr = addrel (bvfs_data_ptr, 1);
      753 
      754 	select_list_ptr = dbcb.select_ptr;
      755 
      756 	cur_pos = 1;
      757 	old_vi = 0;
      758 
      759 	bvfs_simple_typed_vector_ptr ->
      760 	     simple_typed_vector.number_of_dimensions = select_list.num_items;
      761 
      762 	do i = 1 to select_list.num_items;
      763 	     if cur_pos > bit_string_len
      764 	     then call error (mrds_error_$max_retr_len);
      765 
      766 	     if old_vi ^= select_list.item.var_index (i)
      767 	     then old_vi = select_list.item.var_index (i);
      768 
      769 	     rai_ptr = select_list.item.ai_ptr (i);
      770 
      771 	     bvfs_simple_typed_vector_ptr ->
      772 		simple_typed_vector.dimension (i).value_ptr = addr (bit_array (cur_pos));
      773 
      774 	     cur_pos = cur_pos + rm_attr_info.bit_length;
      775 	end;
      776 
      777 	return;
      778 
      779      end build_vector_from_string;
      780 
      781 create_temp_file: proc (x);				/* Creates a temp-file and its file desctor block */
      782 
      783 /*  	PARAMETER	*/
      784 
      785 	dcl     x			 fixed bin;	/* (OUTPUT) retrieve_info.ret_fd_ptr table index */
      786 
      787 
      788 /*	MULTICS	*/
      789 
      790 
      791 	dcl     unique_chars_	 entry (bit (*)) returns (char (15));
      792 
      793 /*	OTHERS	*/
      794 
      795 	dcl     atd		 char (200);
      796 	dcl     KEYED_SEQ_UPDATE	 fixed bin internal static options (constant) init (10);
      797 	dcl     number		 picture "99";
      798 
      799 
      800 	x = 0;					/* Init */
      801 
      802 	do i = 1 to mrds_data_$max_sets while (x = 0);	/* Find first null pointer in table */
      803 	     if retrieve_info.ret_fd_ptr (i) = null then x = i;
      804 	end;
      805 	if x = 0 then call error (mrds_error_$too_many_temp_files);
      806 
      807 	allocate fd in (dbcb.static_area) set (fd_ptr);
      808 	retrieve_info.ret_fd_ptr (x) = fd_ptr;		/* Save the file descriptor pointer */
      809 
      810 	number = x;				/* Make the number a picture */
      811 
      812 	fd.name = unique_chars_ ("0"b) || ".mrds_temp." || number; /* Generate a unique file name */
      813 
      814 	atd = "vfile_ " || rtrim (get_resultant_dir ()) || ">" || fd.name || "-dup_ok"; /* develop attach descriptor */
      815 
      816 	call iox_$attach_ioname ((fd.name), fd.iocb_ptr, atd, icode);
      817 	if icode = 0 then
      818 	     call iox_$open (fd.iocb_ptr, KEYED_SEQ_UPDATE, "0"b, icode);
      819 	if icode ^= 0 then call error (icode);
      820 
      821 
      822 	fd.cur_key = low (256);
      823 	fd.desc = 0;
      824 	fd.rec_count = 0;
      825 
      826      end create_temp_file;
      827 
      828 delete_temp_file: proc (x);				/* Deletes a single temp-file */
      829 
      830 	dcl     x			 fixed bin;	/* (INPUT) retrieve_info.ret_fd_ptr index */
      831 
      832 	dcl     file_name		 char (32);
      833 
      834 
      835 	if retrieve_info.ret_fd_ptr (x) ^= null then do;
      836 		fd_ptr = retrieve_info.ret_fd_ptr (x);	/* Set the pointer to the file descriptor */
      837 		file_name = fd.name;
      838 
      839 		call iox_$close (fd.iocb_ptr, icode);
      840 		if icode = 0 then call iox_$detach_iocb (fd.iocb_ptr, icode);
      841 		if icode = 0 then call iox_$destroy_iocb (fd.iocb_ptr, icode);
      842 		if icode = 0 then
      843 		     begin;
      844 
      845 			call hcs_$del_dir_tree (get_resultant_dir (), file_name, icode);
      846 			if icode = error_table_$notadir | icode = 0 then
      847 			     call hcs_$delentry_file (get_resultant_dir (), file_name, icode);
      848 
      849 			declare hcs_$del_dir_tree	 entry (char (*), char (*), fixed bin (35)); /* deletes sub directory contents */
      850 			declare hcs_$delentry_file	 entry (char (*), char (*), fixed bin (35)); /* deletes segs and empty dirs */
      851 			declare error_table_$notadir	 fixed bin (35) ext; /* entry was not a directory */
      852 
      853 		     end;
      854 
      855 		if icode ^= 0 & ^clean_up_condition then call error (icode);
      856 		free fd in (dbcb.static_area);	/* Deallocate this file descriptor */
      857 		retrieve_info.ret_fd_ptr (x) = null;
      858 	     end;
      859      end delete_temp_file;
      860 
      861 get_resultant_dir: procedure () returns (char (168));
      862 
      863 /* routine to get the resultant models storage directory */
      864 
      865 	declare pathname		 char (168);	/* directory under which resultant model is stored */
      866 	declare mrds_dsl_resultant_storage$get_opening_temp_dir entry (fixed bin (35), fixed bin (35))
      867 				 returns (char (168)); /* gets temp dir for a particular opening */
      868 
      869 /* good index, get a pathname from the dbcb segment pointer */
      870 
      871 	pathname = mrds_dsl_resultant_storage$get_opening_temp_dir (dbcb.dbi, icode);
      872 	if icode ^= 0 then
      873 	     call error (icode);			/* does not return */
      874 
      875 /* 				The dbcb segment pointer could not be expanded into a pathname. */
      876 
      877 	else return (pathname);			/* good path of model dir found */
      878 
      879      end;
      880 
      881 delete_temp_record: proc (fdx, data);
      882 
      883 	dcl     fdx		 fixed bin;	/* (INPUT) File desc index into retrieve_info.ret_fd_ptr array */
      884 	dcl     data		 char (*) varying;	/* (INPUT) */
      885 	dcl     (new_key, rec_found)	 bit (1);
      886 
      887 	fd_ptr = retrieve_info.ret_fd_ptr (fdx);	/* Set the file desc pointer */
      888 
      889 	if length (data) <= 256 then do;		/* All data resides in key */
      890 		call iox_$seek_key (fd.iocb_ptr, (data), rec_len, icode);
      891 		if icode = 0 then
      892 		     call iox_$delete_record (fd.iocb_ptr, icode);
      893 	     end;
      894 
      895 	else do;					/* All data does _n_o_t reside in the key */
      896 		new_key, rec_found = OFF;		/* Init */
      897 
      898 		call iox_$seek_key (fd.iocb_ptr, substr (data, 1, 256), rec_len, icode);
      899 		do while (icode = 0 & new_key = OFF & rec_found = OFF);
      900 		     call iox_$read_key (fd.iocb_ptr, fd.cur_key, fd.rec_len, icode);
      901 		     if fd.cur_key ^= substr (data, 1, 256) then
      902 			new_key = ON;
      903 		     if icode = 0 & new_key = OFF then do;
      904 			     call iox_$read_record (fd.iocb_ptr, addr (fd.rec_buf), length (fd.rec_buf), fd.rec_len, icode);
      905 			     if icode = 0 then
      906 				if substr (data, 257) = substr (fd.rec_buf, 1, rec_len) then
      907 				     rec_found = ON;
      908 			end;
      909 		end;
      910 		if icode = 0 then do;
      911 			if rec_found = ON then
      912 			     call iox_$delete_record (fd.iocb_ptr, icode);
      913 			else icode = error_table_$no_record;
      914 		     end;
      915 	     end;
      916 	if icode ^= 0 then call error (icode);
      917 
      918      end delete_temp_record;
      919 
      920 difference: proc;					/* SET DIFFERENCE operation */
      921 
      922 	set_info.cur_data_valid = OFF;		/* not valid while being changed */
      923 
      924 	if sb (set_info.sbi - 1).file = OFF then do;	/* If it's not in a file, put it in one */
      925 		call create_temp_file (sb (set_info.sbi - 1).fdx);
      926 		call move_db_to_file (set_info.sbi - 1, sb (set_info.sbi - 1).ss_item_num, sb (set_info.sbi - 1).fdx);
      927 		sb (set_info.sbi - 1).file = ON;	/* it's in a file now */
      928 	     end;
      929 
      930 	fd_ptr = retrieve_info.ret_fd_ptr (sb (set_info.sbi - 1).fdx); /* So we use the right file desc */
      931 	call iox_$position (fd.iocb_ptr, -1, 0, icode);	/* Position to BOF to read it seq  */
      932 
      933 	set_info.cur_fdx = sb (set_info.sbi - 1).fdx;	/* This is where the difference
      934*						   between these two will reside */
      935 
      936 	call init_search (set_info.sbi);
      937 
      938 	call get_data (set_info.sbi, current_data, icode);
      939 
      940 	do while (icode = 0);			/* Do the difference */
      941 
      942 	     if icode = 0 then do;			/* If we got the data then see if a match
      943*						   is found from the previous selected data */
      944 		     call dup_check (sb (set_info.sbi - 1).fdx, current_data, dup_flag);
      945 		     if dup_flag = ON then do;	/* If so this is an difference so delete it  */
      946 			     call delete_temp_record (set_info.cur_fdx, current_data); /* Remove it
      947*						   from temp file */
      948 			end;
      949 		     dbcb.another_flag = ON;		/* For mrds_dsl_search in get_data */
      950 		end;
      951 
      952 	     call get_data (set_info.sbi, current_data, icode);
      953 
      954 
      955 	end;
      956 
      957 	if icode ^= error_table_$end_of_info then call error (icode);
      958 	else icode = 0;
      959 
      960 	if sb (set_info.sbi).file then call delete_temp_file (sb (set_info.sbi).fdx); /* Delete the temp file
      961*						   no longer needed */
      962 	set_info.sbi = set_info.sbi - 1;		/* Set up for next set operation */
      963 	sb (set_info.sbi).fdx = set_info.cur_fdx;	/* This becomes that set block file desc index */
      964 
      965 
      966 
      967      end difference;
      968 
      969 dup_check: proc (fdx, data, dup_flag);
      970 
      971 	dcl     fdx		 fixed bin;	/* (INPUT) File desc index into retrieve_info.ret_fd_ptr array */
      972 	dcl     data		 char (*) varying;	/* (INPUT) */
      973 	dcl     dup_flag		 bit (1);		/* (OUTPUT) ON = duplicate record found */
      974 	dcl     new_key		 bit (1);
      975 
      976 	fd_ptr = retrieve_info.ret_fd_ptr (fdx);	/* Set the file desc pointer */
      977 	dup_flag = OFF;				/* Set OFF to start with */
      978 
      979 	if length (data) <= 256 then do;		/* All data resides in key */
      980 		call iox_$seek_key (fd.iocb_ptr, (data), rec_len, icode);
      981 		if icode = 0 then
      982 		     dup_flag = ON;
      983 	     end;
      984 
      985 	else do;					/* All data does _n_o_t reside in the key */
      986 		new_key = OFF;			/* Init */
      987 
      988 		call iox_$seek_key (fd.iocb_ptr, substr (data, 1, 256), rec_len, icode);
      989 		if icode ^= 0 then if icode ^= error_table_$no_record then call error (icode);
      990 		do while (icode = 0 & new_key = OFF & dup_flag = OFF);
      991 		     call iox_$read_key (fd.iocb_ptr, fd.cur_key, fd.rec_len, icode);
      992 		     if fd.cur_key ^= substr (data, 1, 256) then
      993 			new_key = ON;
      994 		     if icode = 0 & new_key = OFF then do;
      995 			     call iox_$read_record (fd.iocb_ptr, addr (fd.rec_buf), length (fd.rec_buf), fd.rec_len, icode);
      996 			     if icode = 0 then
      997 				if substr (data, 257) = substr (fd.rec_buf, 1, rec_len) then
      998 				     dup_flag = ON;
      999 			end;
     1000 		end;
     1001 
     1002 	     end;
     1003 
     1004      end dup_check;
     1005 
     1006 
     1007 get_data: proc (sbi, current_data, icode);
     1008 
     1009 /* This procedure gets the next data record from either the database or a temp-file
     1010*   for the set block specified by set block index (sbi)
     1011*
     1012*   when the data is to be retrieve from the database the calling procedure
     1013*   must have called init_search prior to the first call to get_data
     1014*   so that mrds_dsl_search will get subsequent tuples for
     1015*   the selection expression		*/
     1016 
     1017 
     1018 	dcl     sbi		 fixed bin;	/* (INPUT) Set block index */
     1019 	dcl     current_data	 char (*) varying;	/* (OUTPUT) data returned */
     1020 	dcl     icode		 fixed bin (35);	/* (OUTPUT) Error code */
     1021 
     1022 	if sb (sbi).file = ON then do;		/* Data is from a file */
     1023 		call get_temp_record (sb (sbi).fdx, current_data, icode);
     1024 		if icode ^= 0 then if icode ^= error_table_$end_of_info then call error (icode);
     1025 	     end;
     1026 	else do;					/* Data is from the database */
     1027 		call mrds_dsl_search (dbcb_ptr, area_ptr, icode);
     1028 		if icode = 0 then
     1029 		     call build_data_string (current_data);
     1030 		else do;
     1031 			if icode ^= mrds_error_$tuple_not_found then call error (icode);
     1032 			else icode = error_table_$end_of_info;
     1033 		     end;
     1034 	     end;
     1035 
     1036      end get_data;
     1037 
     1038 get_set_another: proc;				/* Retrieve set another operation */
     1039 
     1040 	call get_temp_record (set_info.cur_fdx, current_data, icode); /* Get next record from
     1041*						   temp file */
     1042 
     1043 	if icode = 0 then /* If there is one move it to user's variables */
     1044 	     call return_data_temp (current_data);
     1045 	else if icode = error_table_$end_of_info then /* Convert this to mrds_error */
     1046 	     icode = mrds_error_$tuple_not_found;
     1047 
     1048 	if icode ^= 0 then call error (icode);
     1049 
     1050 	num_tuples_retrieved = num_tuples_retrieved + 1;
     1051 
     1052 	set_info.cur_data_valid = ON;			/* It's valid now */
     1053 
     1054      end get_set_another;
     1055 
     1056 get_temp_record: proc (fdx, current_data, icode);		/* Gets a single record from a temp-file */
     1057 
     1058 	dcl     fdx		 fixed bin;	/* (INPUT) File descriptor index into
     1059*						   retrieve_info.ret_fd_ptr array */
     1060 	dcl     current_data	 char (*) varying;	/* (OUTPUT) Char string of key||data record */
     1061 	dcl     icode		 fixed bin (35);	/* (OUTPUT) Error code */
     1062 
     1063 	fd_ptr = retrieve_info.ret_fd_ptr (fdx);	/* Set the file desc pointer */
     1064 	set_info.cur_data_valid = OFF;
     1065 
     1066 
     1067 	call iox_$read_key (fd.iocb_ptr, fd.cur_key, fd.rec_len, icode);
     1068 
     1069 	if icode = 0 then do;
     1070 		if fd.rec_len > 0 then /* If there is any data in record read the record */
     1071 		     call iox_$read_record (fd.iocb_ptr, addr (fd.rec_buf), mrds_data_$max_data_length,
     1072 			fd.rec_len, icode);
     1073 		else do;				/* Otherwise position to next rec as read_record would */
     1074 			call iox_$position (fd.iocb_ptr, 0, 1, icode);
     1075 			if icode = error_table_$end_of_info then icode = 0; /* We'l catch this on next call */
     1076 		     end;
     1077 	     end;
     1078 
     1079 	if icode = 0 then do;
     1080 		current_data = fd.cur_key || substr (fd.rec_buf, 1, fd.rec_len); /* Key + any data */
     1081 		set_info.cur_data_valid = ON;		/* It's valid now */
     1082 	     end;
     1083 
     1084 
     1085 
     1086      end get_temp_record;
     1087 
     1088 init: proc;
     1089 
     1090 /* initialization procedure */
     1091 
     1092 	num_tuples_retrieved, icode = 0;		/* Init  to start with */
     1093 	key_used_ptr = null;
     1094 
     1095 	if dbcb.retr_info_ptr = null then do;
     1096 		allocate retrieve_info in (dbcb.static_area) set (dbcb.retr_info_ptr);
     1097 		retrieve_info.version = retrieve_info_version;
     1098 		do i = 1 to mrds_data_$max_sets;
     1099 		     retrieve_info.ret_fd_ptr (i) = null;
     1100 		end;
     1101 	     end;
     1102 
     1103      end init;
     1104 
     1105 init_search: proc (sbi);				/* Initializes mrds_dsl_search fo a new selection esbipression */
     1106 
     1107 	dcl     x			 fixed bin;
     1108 	dcl     sbi		 fixed bin;	/* select block index */
     1109 
     1110 	if sb.file (sbi) = ON
     1111 	then do;
     1112 		fd_ptr = retrieve_info.ret_fd_ptr (sb.fdx (sbi));
     1113 		call iox_$position (fd.iocb_ptr, -1, 0, icode); /* point to beginning */
     1114 		if icode ^= 0 then call error (icode);
     1115 	     end;
     1116 
     1117 	else do;
     1118 		x = sb.ss_item_num (sbi);
     1119 		range_ptr,
     1120 		     dbcb.range_ptr = select_sets.items (x).range_ptr;
     1121 		dbcb.so_ptr = select_sets.items (x).so_ptr;
     1122 		ti_ptr,
     1123 		     dbcb.ti_ptr = select_sets.items (x).ti_ptr;
     1124 		select_list_ptr,
     1125 		     dbcb.select_ptr = select_sets.items (x).select_ptr;
     1126 		dbcb.another_flag, dbcb.current_flag = OFF; /* So dsl_search will initialixe */
     1127 	     end;
     1128 
     1129      end init_search;
     1130 
     1131 init_set: proc;
     1132 
     1133 /* Procedure to build a set of data */
     1134 
     1135 	if select_sets.dup_retain then call error (mrds_error_$no_dups_for_set_oper);
     1136 	do i = 1 to mrds_data_$max_sets;		/* free any file descriptors that may be allocated */
     1137 	     if retrieve_info.ret_fd_ptr (i) ^= null then /* Delete temp file and */
     1138 		call delete_temp_file (i);		/* Null the dbdb.ret_fd_ptr (i) */
     1139 	end;
     1140 
     1141 	retrieve_info.first_sw = ON;			/* So setup_set will initialize */
     1142 
     1143 	call setup_set_info;
     1144 
     1145 	do while (set_info.last_sb_oper = OFF);
     1146 						/* 1 => union 2 => intersection  3 =>Difference */
     1147 	     goto case (set_info.oper);
     1148 
     1149 case (1):	     call union;
     1150 	     goto case_out;
     1151 
     1152 case (2):	     call intersection;
     1153 	     goto case_out;
     1154 
     1155 case (3):	     call difference;
     1156 	     goto case_out;
     1157 
     1158 case_out:
     1159 	     call setup_set_info;			/* Setup next set operation */
     1160 	end;
     1161 
     1162 	goto kase (set_info.oper);
     1163 
     1164 kase (1): call union;
     1165 	goto kase_out;
     1166 
     1167 kase (2): call intersection;
     1168 	goto kase_out;
     1169 
     1170 kase (3): call difference;
     1171 	goto kase_out;
     1172 
     1173 kase_out:
     1174 
     1175 	fd_ptr = retrieve_info.ret_fd_ptr (set_info.cur_fdx);
     1176 	call iox_$position (fd.iocb_ptr, -1, 0, icode);	/* Rewind the file */
     1177 
     1178      end init_set;
     1179 
     1180 intersection: proc;					/* INTERSECTION SET operation */
     1181 
     1182 	set_info.cur_data_valid = OFF;		/* Cause were gona change it */
     1183 
     1184 	if sb (set_info.sbi - 1).file = OFF then do;	/* If its not inafile put in one */
     1185 		call create_temp_file (sb (set_info.sbi - 1).fdx);
     1186 		call move_db_to_file (set_info.sbi - 1, sb (set_info.sbi - 1).ss_item_num, sb (set_info.sbi - 1).fdx);
     1187 		sb (set_info.sbi - 1).file = ON;	/* Got it on a file now */
     1188 	     end;
     1189 
     1190 	fd_ptr = retrieve_info.ret_fd_ptr (sb (set_info.sbi - 1).fdx); /* So we use the right file desc */
     1191 	call iox_$position (fd.iocb_ptr, -1, 0, icode);	/* Position to BOF cause were gonna read it seq  */
     1192 
     1193 	call create_temp_file (set_info.cur_fdx);	/* Tempfile
     1194*						   for intersection */
     1195 	call init_search (set_info.sbi);
     1196 
     1197 	call get_data (set_info.sbi, current_data, icode);
     1198 
     1199 	do while (icode = 0);			/* Do the intersection */
     1200 
     1201 	     if icode = 0 then do;			/* If we got the data then see if a match
     1202*						   is found from the previous selected data */
     1203 		     call dup_check (sb (set_info.sbi - 1).fdx, current_data, dup_flag);
     1204 		     if dup_flag = ON then do;	/* If so this is an intersection so save it  */
     1205 			     call dup_check (set_info.cur_fdx, current_data, dup_flag); /* see if there is
     1206*						   already one on the file */
     1207 			     if ^dup_flag then call add_record (set_info.cur_fdx, current_data);
     1208 			end;
     1209 		     dbcb.another_flag = ON;		/* For mrds_dsl_search in get_data */
     1210 		end;
     1211 
     1212 	     call get_data (set_info.sbi, current_data, icode);
     1213 
     1214 	end;
     1215 
     1216 	if icode ^= error_table_$end_of_info then call error (icode);
     1217 	else icode = 0;
     1218 
     1219 	if sb (set_info.sbi).file then call delete_temp_file (sb (set_info.sbi).fdx); /* Delete the temp file
     1220*						   no longer needed */
     1221 	set_info.sbi = set_info.sbi - 1;		/* Set up for next set operation */
     1222 
     1223 	sb (set_info.sbi).fdx = set_info.cur_fdx;	/* This becomes that set block file desc index */
     1224 
     1225 
     1226 
     1227      end intersection;
     1228 
     1229 move_db_to_file: proc (sbi, is, fdx);			/* Adds data selected to a temp-file */
     1230 
     1231 	dcl     is		 fixed bin;	/* (INPUT) Select sets item index */
     1232 	dcl     fdx		 fixed bin;	/* (INPUT) File desc index into retrieve_info.ret_fd_ptr array */
     1233 	dcl     sbi		 fixed bin;	/* INPUT: select block index used by init_search */
     1234 
     1235 
     1236 	call init_search (sbi);			/* Init pointers for mrds_dsl_search */
     1237 
     1238 	icode = 0;
     1239 
     1240 	do while (icode = 0);			/* Get all the tuples that satisfy the selection exp */
     1241 
     1242 	     call mrds_dsl_search (dbcb_ptr, area_ptr, icode);
     1243 
     1244 	     if icode = 0 then do;			/* If we found one get it from db  */
     1245 
     1246 		     call build_data_string (current_data);
     1247 		     if icode = 0 then do;
     1248 			     call dup_check (fdx, current_data, dup_flag);
     1249 			     if dup_flag = OFF then call add_record (fdx, current_data);
     1250 			end;
     1251 		     dbcb.another_flag = ON;		/* So search will continue searching */
     1252 
     1253 		end;
     1254 	end;
     1255 
     1256 	if icode ^= 0 then if icode ^= mrds_error_$tuple_not_found then call error (icode);
     1257 
     1258      end move_db_to_file;
     1259 
     1260 move_file_to_file: proc (from_fdx, to_fdx);
     1261 
     1262 /* Moves data from a temp-file to a temp-file handling duplicates */
     1263 
     1264 	dcl     (from_fdx,				/* (INPUT) file descriptor index
     1265*						   into retrieve_info.ret_fd_ptr array */
     1266 	        to_fdx)		 fixed bin;	/* (INPUT) File des index into retrieve_info.ret_fd_ptr array */
     1267 
     1268 
     1269 	fd_ptr = retrieve_info.ret_fd_ptr (from_fdx);
     1270 
     1271 	call iox_$position (fd.iocb_ptr, -1, 0, icode);	/* Rewind the file */
     1272 
     1273 	if icode ^= 0 then call error (icode);
     1274 
     1275 	do while (icode = 0);			/* As long as there are records on input file */
     1276 
     1277 	     call get_temp_record (from_fdx, current_data, icode); /* Get rec from file */
     1278 
     1279 	     if icode = 0 then do;
     1280 		     call dup_check (to_fdx, current_data, dup_flag);
     1281 		     if dup_flag = OFF then call add_record (to_fdx, current_data);
     1282 		end;
     1283 	end;
     1284 
     1285 	if icode ^= 0 then if icode ^= error_table_$end_of_info then call error (icode);
     1286 
     1287      end move_file_to_file;
     1288 
     1289 return_data_temp: proc (data_str);
     1290 
     1291 /* Procedure to return data to the caller from a temporary hold file. */
     1292 
     1293 	dcl     bs_ptr		 ptr;
     1294 	dcl     data_str		 char (*) var;
     1295 	dcl     (cur_pos,
     1296 	        len,
     1297 	        i)		 fixed bin (35);
     1298 
     1299 	cur_pos = 1;				/* initialize */
     1300 	bs_ptr = addr (data_str);
     1301 	bs_ptr = addrel (bs_ptr, 1);
     1302 
     1303 START_RETURN_DATA_TEMP:
     1304 
     1305 	do i = 1 to select_list.num_items;		/* for each selected attribute */
     1306 
     1307 	     rai_ptr = select_list.item.ai_ptr (i);	/* point to attr info */
     1308 
     1309 	     len = rm_attr_info.bit_length;
     1310 
     1311 	     call mu_get_data$get_data_item (rai_ptr, dbcb.work_area_ptr,
     1312 		addbitno (bs_ptr, cur_pos - 1),
     1313 		select_list.item.user_ptr (i),
     1314 		select_list.item.user_desc_ptr (i), icode);
     1315 	     if icode ^= 0 then
     1316 		if icode = error_table_$noalloc then
     1317 		     go to START_RETURN_DATA_TEMP;
     1318 		else call error (icode);
     1319 
     1320 	     cur_pos = cur_pos + len;			/* tidy up */
     1321 
     1322 	end;					/* select item loop */
     1323 
     1324      end return_data_temp;
     1325 
     1326 return_data_tup: proc;
     1327 
     1328 /* Procedure to return data to the caller from the tuples retrieved. */
     1329 
     1330 BEGIN_RETURN_DATA_TUP:
     1331 
     1332 	do i = 1 to select_list.num_vars;		/* loop for each selected item */
     1333 	     var_index = move_list_array.var_index (i);
     1334 	     do j = 1 to tuple_info.num_tuples while (tuple_info.tuple.var_index (j) ^= var_index);
     1335 	     end;
     1336 	     icode = 0;
     1337 	     if range.tup_var (var_index).copy_for_current
     1338 	     then do;
     1339 		     rmri_ptr = range.tup_var (var_index).ri_ptr;
     1340 		     call mu_cursor_manager_$get (dbcb.dbi, rmri_ptr, (0), rm_rel_info.rel_id,
     1341 			dbcb.relmgr_entries.create_cursor, dbcb.relmgr_entries.open,
     1342 			dbcb.cursor_ptrs_storage_ptr, dbcb.cursor_storage_area_ptr,
     1343 			cursor_ptr, icode);
     1344 		     if icode ^= 0 then call error (icode);
     1345 		     call dbcb.relmgr_entries.get_tuple_by_id (
     1346 			cursor_ptr,
     1347 			tuple_info.tuple (var_index).tuple_id,
     1348 			rm_rel_info.id_list_ptr, dbcb.select_area_ptr,
     1349 			tuple_info.tuple (var_index).tuple_ptr,
     1350 			icode);
     1351 		     if icode ^= 0 then call error (icode);
     1352 		     range.tup_var (var_index).copy_for_current = "0"b;
     1353 		     range.tup_var (var_index).copied_for_current = "1"b;
     1354 		end;				/* copy for current */
     1355 	     call mu_get_data$get_data (range.tup_var.ri_ptr (move_list_array.var_index (i)), dbcb.work_area_ptr,
     1356 		tuple_info.tuple.tuple_ptr (j), move_list_array.ml_ptr (i), icode);
     1357 	     if icode ^= 0 then
     1358 		if icode ^= error_table_$noalloc
     1359 		then call error (icode);
     1360 		else go to BEGIN_RETURN_DATA_TUP;
     1361 	end;					/* loop for each item */
     1362 
     1363 
     1364 	dcl     icode		 fixed bin (35);
     1365 	dcl     cursor_ptr		 ptr;
     1366 	dcl     (i, j)		 fixed bin;
     1367 	dcl     var_index		 fixed bin;
     1368 
     1369      end return_data_tup;
     1370 
     1371 setup_set_info: proc;				/* Prepares set_info and set blocks for next set operation */
     1372 
     1373 	dcl     ix		 fixed bin;
     1374 
     1375 
     1376 
     1377 	if retrieve_info.first_sw = ON then do;		/* First time this proc has been called for this set selection */
     1378 
     1379 		set_info.cur_fdx = 0;
     1380 		set_info.ssi = 0;
     1381 		set_info.sbi = 0;
     1382 		set_info.cur_data_valid = OFF;
     1383 		retrieve_info.first_sw = OFF;
     1384 		set_info.last_sb_oper = OFF;
     1385 	     end;
     1386 
     1387 
     1388 	do while (select_sets.items (set_info.ssi + 1).oper_flag = OFF);
     1389 	     set_info.ssi = set_info.ssi + 1;
     1390 	     ix, set_info.sbi = set_info.sbi + 1;
     1391 
     1392 	     sb (ix).ss_item_num = set_info.ssi;
     1393 	     sb (ix).fdx = 0;
     1394 	     sb (ix).file = OFF;
     1395 	     sb (ix).eod = OFF;
     1396 	     sb (ix).first = ON;
     1397 	end;
     1398 
     1399 	set_info.ssi = set_info.ssi + 1;
     1400 	set_info.oper = select_sets.items (set_info.ssi).op_code;
     1401 	if set_info.ssi + 1 > select_sets.nitems then
     1402 	     set_info.last_sb_oper = ON;
     1403 
     1404      end setup_set_info;
     1405 
     1406 union: proc;					/* UNION set operation */
     1407 
     1408 	set_info.cur_data_valid = OFF;		/* It isgona change */
     1409 
     1410 	if sb (set_info.sbi - 1).file = ON then do;	/* Previous set block is a file so use it */
     1411 		set_info.cur_fdx = sb (set_info.sbi - 1).fdx;
     1412 		if sb (set_info.sbi).file = ON then /* Current set block is a file so add it to previous */
     1413 		     call move_file_to_file (sb (set_info.sbi).fdx, set_info.cur_fdx); /*   set block file */
     1414 
     1415 		else /* Add the selected tuples from db to previous sb file */
     1416 		     call move_db_to_file (set_info.sbi, sb (set_info.sbi).ss_item_num, set_info.cur_fdx);
     1417 	     end;
     1418 
     1419 	else do;					/* Previous set block was not a file */
     1420 		if sb (set_info.sbi).file = ON then do; /* Current sb is a file */
     1421 			set_info.cur_fdx = sb (set_info.sbi).fdx;
     1422 			call move_db_to_file (set_info.sbi - 1, sb (set_info.sbi - 1).ss_item_num, set_info.cur_fdx);
     1423 		     end;
     1424 
     1425 		else do;				/* Neither previous sb or current sb is a file */
     1426 			call create_temp_file (set_info.cur_fdx);
     1427 			call move_db_to_file (set_info.sbi, sb (set_info.sbi).ss_item_num, set_info.cur_fdx);
     1428 			call move_db_to_file (set_info.sbi - 1, sb (set_info.sbi - 1).ss_item_num, set_info.cur_fdx);
     1429 		     end;
     1430 
     1431 		sb (set_info.sbi - 1).fdx = set_info.cur_fdx; /* Stash the fdx */
     1432 		sb (set_info.sbi - 1).file = ON;	/* Indicate that the file exists */
     1433 	     end;
     1434 
     1435 	set_info.sbi = set_info.sbi - 1;		/* Keep track of where we are */
     1436 
     1437 
     1438      end union;
     1439 
     1440 
     1441 error: proc (cd);
     1442 
     1443 	dcl     cd		 fixed bin (35);	/* (INPUT) error code */
     1444 
     1445 	if st_entry then do;
     1446 		a_code = cd;
     1447 		goto st_exit;
     1448 	     end;
     1449 	else do;
     1450 		code = cd;			/* Return the error code to caller */
     1451 		call cleanup_handler;		/* Tidy up before we leave */
     1452 		goto exit;			/* Exit mrds_dsl_sec_retrieve */
     1453 	     end;
     1454 
     1455      end error;
     1456 
     1457 cleanup_handler: proc;
     1458 
     1459 	clean_up_condition = ON;			/* to avoid loops */
     1460 
     1461 	on seg_fault_error goto get_out;
     1462 
     1463 	call clean_up_temp_files ();
     1464 
     1465 	call clean_up_per_call_area ();
     1466 
     1467 get_out:
     1468 	clean_up_condition = OFF;
     1469 
     1470 	return;
     1471 
     1472      end cleanup_handler;
     1473 
     1474 clean_up_per_call_area: procedure ();
     1475 
     1476 /* routine to capture philosophy for "releasing" per call work area */
     1477 
     1478 	if dbcb_ptr = null () then ;
     1479 	else if dbcb.retrieve_area_ptr ^= null () then do;
     1480 		call mu_release_area (dbcb.retrieve_area_ptr);
     1481 
     1482 /* do not null area pointers, this would cause getting new temp segs, instead of reuse */
     1483 
     1484 	     end;
     1485 
     1486      end;
     1487 
     1488 clean_up_temp_files: procedure ();
     1489 
     1490 /* routine to get rid of all temp files */
     1491 
     1492 	if dbcb_ptr ^= null then do;
     1493 		if dbcb.retr_info_ptr ^= null then do;
     1494 			do i = 1 to mrds_data_$max_sets; /* free any file descriptors that may be allocated */
     1495 			     if retrieve_info.ret_fd_ptr (i) ^= null then /* Delete temp file and */
     1496 				call delete_temp_file (i); /* Null the dbdb.ret_fd_ptr (i) */
     1497 			end;
     1498 		     end;
     1499 	     end;
     1500 
     1501      end;
     1502 
     1503 
  5     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  5     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  5     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  5     9*     Nguyen. The scopes_changed flag was added to make checking for this
  5    10*     more efficient (mrds error list #137).
  5    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  5    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  5    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  5    14*     care if multiple txns use the same selection_expression. (mrds #156)
  5    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  5    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  5    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  5    18*                                                   END HISTORY COMMENTS */
  5    19 
  5    20 
  5    21 /* WARNING
  5    22*          If the dbcb structure is changed then the mrds_data_
  5    23*          item saved_res_version MUST be incremented to invalidate all
  5    24*          existing saved resultants
  5    25**/
  5    26 
  5    27 /* HISTORY :
  5    28*
  5    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  5    30*   tid_list management
  5    31*
  5    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  5    33*   phony resultant in mu_database_index, without having the area dcl
  5    34*   included.
  5    35*
  5    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  5    37*   mrds_dsl_store
  5    38*
  5    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  5    40*   switches
  5    41*
  5    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  5    43*   expression,  so  that relation statistics can be updated relative
  5    44*   to number of selection expressions seem. Also  removed  init  for
  5    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  5    46*   mrds_dsl_init_res.
  5    47*
  5    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  5    49*
  5    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  5    51*   for the conversion to the relation manager.
  5    52*
  5    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  5    54*   substructures so that the entries and costs can change
  5    55*   depending on the type of database that is opened.
  5    56*
  5    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  5    58*   since modify uses a different vector type (general) than does store.
  5    59*
  5    60*   82-09-20 Davids: changed names of (store modify)_vector to
  5    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  5    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  5    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  5    64*   during the first call.
  5    65*
  5    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  5    67*   since it deals with the pointers to the cursors and not the cursors
  5    68*   themelves and added the element cursor_storage_area_ptr which points
  5    69*   to the area where the cursors are kept.
  5    70*
  5    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  5    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  5    73*   anything.
  5    74*
  5    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  5    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  5    77*   by mrds_dsl_define_temp_rel.
  5    78*
  5    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  5    80*   is needed by mu_store.
  5    81*
  5    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  5    83*   bin to float bin since the values are not integers.
  5    84*
  5    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  5    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  5    87*   added to the end of the structure to allow modules that don't use
  5    88*   the element to continue to reference the dbcb structure without recompiling.
  5    89*
  5    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  5    91*   are needed so that temp rels can be created with the same file attributes
  5    92*   as the permanent relations.
  5    93*
  5    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  5    95*   added the resultant_in_pdir bit.
  5    96*
  5    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  5    98*   added the res_already_made element.
  5    99*
  5   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  5   101*
  5   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  5   103*   one of the unused pointers.
  5   104*
  5   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  5   106*
  5   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  5   108*   leaving unused_ptrs(1).
  5   109*
  5   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  5   111*   unused_ptrs (1).
  5   112*
  5   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  5   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  5   115*   spare ptrs, entries and reserved storages for future enhancement, since
  5   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  5   117*
  5   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  5   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  5   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  5   121**/
  5   122 
  5   123 
  5   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  5   125*   that constitutes the non-secure portion of the resultant model that is
  5   126*   created during the opening of a database. it contains variables that
  5   127*   are used during the runtime access of the database, and an area
  5   128*   for evaluation of requests. it points to four other
  5   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  5   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  5   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  5   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  5   133*   used in the elimination of duplicate tuples during a retrieve.
  5   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  5   135*   that is used when the database is using the file scope mechanism
  5   136*   for concurrency control over file readying. the segment overlayed via
  5   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  5   138*   across database openings. the pointer to this dbcb structure is kept in a table
  5   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  5   140*   opening instances of resultant models. (see mu_database_index routine) */
  5   141 
  5   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  5   143 	     2 data	      like dbcb_data,
  5   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  5   145 
  5   146      dcl	   dbcb_ptr	      ptr;
  5   147 
  5   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  5   149*						   like references can avoid getting the area declaration */
  5   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  5   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  5   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  5   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  5   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  5   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  5   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  5   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  5   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  5   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  5   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  5   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  5   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  5   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  5   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  5   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  5   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  5   167*						   for eliminating duplicate tuples. */
  5   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  5   169*						   for eliminating duplicate tuples. */
  5   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  5   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  5   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  5   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  5   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  5   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  5   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  5   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  5   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  5   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  5   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  5   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  5   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  5   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  5   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  5   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  5   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  5   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  5   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  5   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  5   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  5   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  5   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  5   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  5   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  5   195 	     2 val_del	      bit (1) unal,		/* for delete */
  5   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  5   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  5   198*                                                                     not imply that the database is of type page_file */
  5   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  5   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  5   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  5   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  5   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  5   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  5   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  5   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  5   207*						   inside a sequence of -another selection expression. */
  5   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  5   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  5   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  5   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  5   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  5   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  5   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  5   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  5   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  5   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  5   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  5   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  5   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  5   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  5   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  5   223 	     2 relmgr_entries,			/* relation manager entries */
  5   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  5   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  5   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  5   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  5   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  5   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  5   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  5   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  5   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  5   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  5   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  5   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  5   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  5   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  5   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  5   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  5   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  5   241 	       3 reserved_entries (5) entry (),
  5   242 	     2 access_costs,			/* access costs for permute */
  5   243 	       3 total_primary_key_cost float bin,
  5   244 	       3 access_cost      float bin,
  5   245 	       3 access_overhead  float bin,
  5   246 	       3 us_access_cost   float bin,
  5   247 	       3 os_access_cost   float bin,
  5   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  5   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  5   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  5   251 
  5   252 /* END mrds_dbcb.incl.pl1 */
  5   253 
  5   254 
     1504 
     1505 
  6     1 /* BEGIN mdbm_rm_rel_info.incl.pl1 -- jaw, 11/16/78 */
  6     2 
  6     3 /* WARNING
  6     4*          If the rm_rel_info structure is changed then the mrds_data_
  6     5*          item saved_res_version MUST be incremented to invalidate all
  6     6*          existing saved resultants
  6     7**/
  6     8 
  6     9 /* HISTORY:
  6    10*
  6    11*   Modified by Jim Gray - - May 1980, to  include  model  number  of
  6    12*   attributes,   and   varying  attributes,  so  that  partial  view
  6    13*   submodels will have the  info  needed  to  properly  set  up  the
  6    14*   varying length array headers in the tuple structure.
  6    15*
  6    16*   Modified  by  Jim  Gray  -  -  80-11-06,  to  rename   r_perm   =
  6    17*   status_perm,     s_perm    =    append_tuple_perm,    d_perm    =
  6    18*   delete_tuple_perm, and make m_perm = unused_perm.
  6    19*
  6    20*   81-01-23 Jim Gray : added bit to indicate whether the last  model
  6    21*   view attribute was varying character or bit, since a partial view
  6    22*   submodel will not have this information in the resultant, and  it
  6    23*   is  needed for determining the new tuple length in mus_mod_ubtup,
  6    24*   since with exact length storage  of  varying  length  attributes,
  6    25*   each  tuple  can  be  a  different  length,  which is can only be
  6    26*   determined by examining the tuple itself.
  6    27*
  6    28*   81-01-29 Jim Gray : added curent  tuple  count,  to  provide  for
  6    29*   interface  to  allow  temp  rel  population  to  be known, and to
  6    30*   provide a more efficient means of finding an approx. current perm
  6    31*   relation population.
  6    32*
  6    33*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  6    34*   blocked  files, foreign keys, and ids procedures. Also set number
  6    35*   of files per rel to a constant of 1.
  6    36*
  6    37*   81-05-28 Jim Gray : combined data  from  rm_file_info  into  this
  6    38*   structure so that only one structure per relation is needed.
  6    39*
  6    40*   81-07-02 Jim Gray : added total_key and dup_key vfile  statistics
  6    41*   counts.   Also  added  number  of  operations  count  since  last
  6    42*   statistics update, and a time  since  the  statistics  were  last
  6    43*   updated.
  6    44*
  6    45*   81-07-06 Jim Gray :  added  a  per  selection  expression  update
  6    46*   identifier so that small relations could be updated on a per S.E.
  6    47*   basis
  6    48*
  6    49*   82-04-21 R. Lackey : Added number_selected (ri_niocbs_init refer (rm_rel_info.niocbs)) fixed bin (35)
  6    50*   to end of structure   TR 12205 (Suggestion).
  6    51*   
  6    52*   82-08-19 D. Woodka :  Removed  rm_rel_info.max_data_len  field for
  6    53*   the DMS conversion. 
  6    54*
  6    55*   82-08-30 Davids: added the opening_id element and removed the iocb
  6    56*   array and the niocb element for DMS conversion. Also removed the
  6    57*   number_selected array (and ri_niocbs_init) since subsets are not
  6    58*   going to be used.
  6    59*
  6    60*   82-09-20 Mike Kubicar : changed rm_rel_info.rel_id to bit (36) aligned
  6    61*   so that it can be used with relation manager.  Also added
  6    62*   rm_rel_info.primary_key_index_id for relation manager.
  6    63*
  6    64*   82-09-22 Mike Kubicar : Removed the, now useless, fields var_attr_ptrs,
  6    65*   nvar_atts, model_nvar_atts.
  6    66*
  6    67*   82-09-24 Davids: Removed current_key_count and current_dup_key_count
  6    68*   since the duplicate key count for each secondary index is now being
  6    69*   kept in the attr_info structure and key_count was only needed to
  6    70*   help in calculating the average selectivity of each index which
  6    71*   can now be gotten directly from each index's dup key count. Also
  6    72*   removed the file_id element since it is no longer needed for
  6    73*   anything.
  6    74*
  6    75*   82-09-27 Mike Kubicar : removed file_id_len for the same reason file_id
  6    76*   was removed.
  6    77*
  6    78*   82-11-05 Mike Kubicar : added a pointer to an id_list structure to be
  6    79*   used when retrieving tuples from this relation.
  6    80*
  6    81*   83-04-06 Davids: Added the scope_flags_ptr which points to the scope_flags structure
  6    82*   for the relation. Note that this structure is part of the resultant NOT
  6    83*   part of the db.control structure. The scopes are duplicated in the resultant
  6    84*   to reduce contention for the db.control structure. Note also that the pointer
  6    85*   will always point to a scope_flags structure even if no scopes have been
  6    86*   set on the relation, the structure is allocated when the db is opened.
  6    87**/
  6    88 
  6    89 
  6    90 /* DESCRIPTION:
  6    91*
  6    92*   This structure is allocated in the area part of the structure  in
  6    93*   mdbm_rm_db_info.incl.pl1  as  part of the resultant model created
  6    94*   at open  time  for  a  database.  There  will  be  one  of  these
  6    95*   rm_rel_info   structures  for  each  relation  appearing  in  the
  6    96*   database view (there may be less than the total in  the  database
  6    97*   for  a  submodel  openings).  There  will  also  be  one for each
  6    98*   temporary relation currently defined for that opening.
  6    99*
  6   100*   The structure in mdbm_rm_rel_array.incl.pl1 contains pointers  to
  6   101*   all  rm_rel_info  structures  allocated. It is used for searching
  6   102*   for the appropriate  structure.  This  array  is  pointed  to  by
  6   103*   rm_db_info. There are two arrays, one for perm rels, one for temp
  6   104*   rels.
  6   105*
  6   106*   The      rm_rel_info      structure      points      to       the
  6   107*   mdbm_rm_attr_info.incl.pl1  structures,  one  for  each attribute
  6   108*   appearing in this view of the relation. Each  of  these  in  turn
  6   109*   point  to a mdbm_rm_domain_info.incl.pl1 structure for the domain
  6   110*   info for each attr.
  6   111*
  6   112*   Most of the other information here deals with  specifics  of  the
  6   113*   relation's  logical  definition,  such as key and secondary index
  6   114*   attribute inidicators, security permissions, and  tuple  physical
  6   115*   construction details.
  6   116*
  6   117**/
  6   118 
  6   119      dcl	   1 rm_rel_info	      aligned based (rmri_ptr), /* relation information */
  6   120 	     2 name	      char (32),		/* from submodel */
  6   121 	     2 model_name	      char (30),		/* from model */
  6   122 	     2 rel_id	      bit (36) aligned,	/* unique id. */
  6   123 	     2 retrieve	      bit (1) unal,		/* operations allowed by this view */
  6   124 	     2 modify	      bit (1) unal,
  6   125 	     2 delete	      bit (1) unal,
  6   126 	     2 store	      bit (1) unal,
  6   127 	     2 total_key	      bit (1) unal,		/* on if view includes full primary key */
  6   128 	     2 indexed	      bit (1) unal,		/* on if exists sec. index */
  6   129 	     2 mdbm_secured	      bit (1) unal,		/* on if mdbm must check security */
  6   130 	     2 status_perm	      bit (1) unal,		/* if user has status. perm. */
  6   131 	     2 append_tuple_perm  bit (1) unal,		/* if user has store perm. */
  6   132 	     2 delete_tuple_perm  bit (1) unal,		/* if user has del. perm. */
  6   133 	     2 unused_perm	      bit (1) unal,		/* for future use. */
  6   134 	     2 last_model_attr_char_var bit (1) unal,	/* on => last model varying attr is char */
  6   135 	     2 reserved	      bit (24) unal,	/* for future use */
  6   136 	     2 num_attr	      fixed bin,		/* total no. of attr. in rel. */
  6   137 	     2 model_num_attr     fixed bin,		/* total attrs in model relation */
  6   138 	     2 nkey_attr	      fixed bin,		/* no. of key attr. */
  6   139 	     2 model_nkey_attr    fixed bin,		/* total number of keys in model */
  6   140 	     2 primary_key_index_id bit (36) aligned,     /* Index id of relation's primary key */
  6   141 	     2 nsec_inds	      fixed bin,		/* no. sec. indexes */
  6   142 	     2 max_key_len	      fixed bin (35),	/* max length (chars) of primary key */
  6   143 	     2 current_tuple_population fixed bin (35),	/* last known total  tuple count for this relation */
  6   144 	     2 last_statistics_update_count fixed bin,	/* number of operations's, since this rels stats were updated */
  6   145 	     2 last_statistics_update_time fixed bin (71),/* last time this rels stats were updated */
  6   146 	     2 last_statistics_update_s_e_ref_num fixed bin (35), /* last select expr ID that updated this rels stats */
  6   147 	     2 ready_mode	      fixed bin,		/* 1 => r, 2 => mr, 3 => u, 4 => l, 5 => sr, 6 => su */
  6   148 	     2 file_type	      fixed bin,		/* 1 => unblocked, 2 => blocked, 3 => temporary */
  6   149 	     2 tuple_id_len	      fixed bin,		/* no. bits in local tuple id */
  6   150 	     2 opening_id	      bit (36) aligned,	/* relation manager opening is */
  6   151 	     2 key_attr_ptrs      (nkey_attr_init refer (rm_rel_info.nkey_attr)) ptr, /* ptrs to key attr. */
  6   152 	     2 attr_ptrs	      (natts_init refer (rm_rel_info.num_attr)) ptr, /* ptrs to all attr. */
  6   153 	     2 id_list_ptr        ptr,		/* Id list for retrieves from the relation */
  6   154                2 scope_flags_ptr    ptr;                    /* pointer to the scope_flags structure for the rel */
  6   155 
  6   156      dcl	   rmri_ptr	      ptr;
  6   157      dcl	   (nkey_attr_init,
  6   158 	   natts_init,
  6   159 	   nvar_atts_init)	      fixed bin;
  6   160 
  6   161 /* END mdbm_rm_rel_info.incl.pl1 */
  6   162 
  6   163 
     1506 
     1507 
  7     1 /*  BEGIN  mdbm_rm_attr_info.incl.pl1  --  jaw,  11/16/78  */
  7     2 
  7     3 /* WARNING
  7     4*          If the rm_attr_info structure is changed then the mrds_data_
  7     5*          item saved_res_version MUST be incremented to invalidate all
  7     6*          existing saved resultants
  7     7**/
  7     8 
  7     9 /*
  7    10*
  7    11*   Modified  by  Jim  Gray - - 80-11-05, to add mdbm_secured bit, so
  7    12*   that rm_rel_info does not have to be checked
  7    13*
  7    14*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  7    15*   foreign keys.
  7    16*
  7    17*   82-08-19  D. Woodka : removed rm_attr_info.bit_offset for the DMS
  7    18*   conversion.
  7    19*
  7    20*   82-09-15 Davids: added the number_of_dups field.
  7    21*
  7    22*   82-09-20 Mike Kubicar : changed the index_id field to be bit (36)
  7    23*   aligned.  This is to conform with the new definition in the database
  7    24*   model.  Also removed the now useless field varying.
  7    25*
  7    26*   82-11-05 Davids: added the field model_defn_order and clarified the
  7    27*   comment for the field defn_order.
  7    28*
  7    29*   83-05-23 Mike Kubicar : changed number_of_dups to fixed bin (35) since
  7    30*   that's what relation manager returns.
  7    31*
  7    32**/
  7    33 
  7    34 
  7    35 /*
  7    36*   this   structure   is   allocated   in   the   static   area   of
  7    37*   mdbm_rm_db_info.incl.pl1  once for each attribute per relation in
  7    38*   a     readied     file.      it     in     turn     points     to
  7    39*   mdbm_rm_domain_info.incl.pl1  for  the  attributes  domain.   the
  7    40*   rm_attr_info  is  pointed  to  by mdbm_rm_rel_info.incl.pl1.  all
  7    41*   structures  are  in  the  rm_db_info  area.   the  attribute data
  7    42*   position  within  a  tuple as stored in the data file are kept in
  7    43*   this resultant model of the attribute.
  7    44* */
  7    45 
  7    46 dcl 1 rm_attr_info aligned based (rai_ptr),		/* resultant attr. info */
  7    47     2 name char (32),				/* from submodel */
  7    48     2 model_name char (32),				/* from model */
  7    49     2 key_attr bit (1) unal,				/* if key attribute */
  7    50     2 index_attr bit (1) unal,			/* if secondary index */
  7    51     2 read_perm bit (1) unal,				/* user has retr. permission */
  7    52     2 modify_perm bit (1) unal,			/* user has modify permission */
  7    53     2 mdbm_secured bit (1) unal,			/* on => database secured */
  7    54     2 reserved bit (30) unal,				/* for future use */
  7    55     2 index_id bit (36) aligned,			/* index id if index_attr */
  7    56     2 defn_order fixed bin,				/* relative order in which attr is defined in the view */
  7    57     2 key_order fixed bin,				/* relative order defined in prim. key */
  7    58     2 bit_length fixed bin (35),			/* length if fixed, max. len. if var. */
  7    59     2 domain_ptr ptr,				/* to domain info */
  7    60     2 number_of_dups fixed bin (35),                        /* if the attribute is indexed this will
  7    61*                                                               be the number of duplicate values, exact
  7    62*                                                               for a page_file database, an estimate for a vfile type */
  7    63     2 model_defn_order fixed bin;                           /* relative order in which attr is defined in the model */
  7    64 
  7    65 dcl  rai_ptr ptr int automatic init (null ());
  7    66 
  7    67 /* END mdbm_rm_attr_info.incl.pl1 */
  7    68 
  7    69 
     1508 
     1509 
  8     1 /* BEGIN mdbm_rm_domain_info.incl.pl1 -- jaw, 9/26/78 */
  8     2 
  8     3 /* WARNING
  8     4*          If the rm_domain_info structure is changed then the mrds_data_
  8     5*          item saved_res_version MUST be incremented to invalidate all
  8     6*          existing saved resultants
  8     7**/
  8     8 
  8     9 /* DESCRIPTION:
  8    10*
  8    11*   This  structure  is  allocated  in  the  mdbm_rm_db_info.incl.pl1
  8    12*   static  area,  once per attribute used in a relation in a readied
  8    13*   file. it is pointed to by the mdbm_rm_attr_info.incl.pl1, and may
  8    14*   point  to  mdbm_rm_ck_and_group.incl.pl1  if  a  "-check"  option
  8    15*   boolean expression was declared for this domain. it contains  the
  8    16*   descriptor  for  this domain data type, and other resultant model
  8    17*   information.
  8    18*
  8    19*
  8    20*   HISTORY:
  8    21*
  8    22*   81-05-06  Rickie  E.  Brinegar:  Modified  ck_proc,  encode_proc,
  8    23*   decode_proc to be entry variables instead of entry pointers. This
  8    24*   allows these programs to be written in languages other than pl1.
  8    25*
  8    26*   81-05-28 Jim Gray : removed unused procedure points,  and  unused
  8    27*   check  stack  structure  elements.  Also made the descriptors bit
  8    28*   (36) in this structure, rather than pointers to  the  descriptors
  8    29*   elsewhere.  Also  removed un-needed redundant assign_ parameters,
  8    30*   that are actually available in the descriptors.
  8    31*
  8    32*
  8    33**/
  8    34 
  8    35 dcl 1 rm_domain_info aligned based (rdi_ptr),		/* domain information */
  8    36     2 name char (32),				/* domain name */
  8    37     2 db_desc bit (36),				/*  to desc. for db. */
  8    38     2 user_desc bit (36),				/* desc for user visible data */
  8    39     2 user_bit_len fixed bin,				/* storage length of users data */
  8    40     2 ck_proc_entry entry variable,			/* to check proc. entry */
  8    41     2 encd_proc_entry entry variable,			/* to encode proc entry */
  8    42     2 decd_proc_entry entry variable,			/* to decode proc entry */
  8    43     2 ck_proc bit (1) unal,				/* Is there a check proc */
  8    44     2 encd_proc bit (1) unal,				/* Is there an encode proc */
  8    45     2 decd_proc bit (1) unal,				/* Is there a decode proc */
  8    46     2 pad bit (33) unal,
  8    47     2 next_domain_ptr ptr ;				/* to next domain, in list of all domains */
  8    48 						/* to check stack and groups */
  8    49 
  8    50 
  8    51 dcl  rdi_ptr ptr int automatic init (null ());
  8    52 
  8    53 /* END mdbm_rm_domain_info.incl.pl1 */
  8    54 
  8    55 
     1510 
     1511 
  9     1 /* BEGIN mrds_range.incl.pl1 -- jaw, 10/20/78 */
  9     2 
  9     3 /* Modified 83-04-22 by R. Harvey to add needed_bits */
  9     4 
  9     5 dcl 1 range aligned based (range_ptr),
  9     6     2 num_vars fixed bin,				/* number of tuple variables */
  9     7     2 tup_var (mrds_data_$max_tup_var refer (range.num_vars)), /* info for each tuple variable */
  9     8       3 name char (mrds_data_$max_id_len),		/* name of tuple variable */
  9     9       3 temp_rel bit (1) unal,			/* on if temporary relation */
  9    10       3 used bit (1) unal,				/* 1 => this tuple variable is referenced by
  9    11*						   a -select clause. */
  9    12       3 whole_tuple_selected bit (1) unal,		/* the whole tuple variable is referenced in the select clause */
  9    13       3 copy_for_current bit (1) unal,			/* -current requests attributes not previously retrieved */
  9    14       3 copied_for_current bit (1) unal,		/* tuple copied during previous -current */
  9    15       3 reserved bit (31) unal,			/* reserved for future use */
  9    16       3 rel_index fixed bin,				/* index to assoc. relation */
  9    17       3 stv_ptr ptr,				/* simple typed vector */
  9    18       3 idl_ptr ptr,				/* id_list ptr */
  9    19       3 needed_bits aligned,
  9    20         4 attr (mrds_data_$max_attributes) bit (1) unal,
  9    21       3 ri_ptr ptr;					/* pointer to rel info for assoc. relation */
  9    22 
  9    23 dcl  range_ptr ptr;
  9    24 
  9    25 /* END mrds_range.incl.pl1 */
  9    26 
     1512 
     1513 
 10     1 /* BEGIN mrds_select_list.incl.pl1 -- jaw 10/20/78 */
 10     2 
 10     3 /* HISTORY:
 10     4*
 10     5*   81-06-01 Jim Gray : removed user len and type elements,
 10     6*   since mu_convert rather than assign_ is now used.
 10     7*
 10     8*   84-11-22 John Hergert: added fr_ptr
 10     9*
 10    10*/****^  HISTORY COMMENTS:
 10    11*  1) change(86-07-17,Dupuis), approve(86-08-05,MCR7491), audit(86-08-08,Blair),
 10    12*     install(86-08-15,MR12.0-1127):
 10    13*     85-11-22 Hergert: Added variable var_exists so that it may be kept
 10    14*     around per select expression (in sets) and when compiling. (mrds #158)
 10    15*  2) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
 10    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
 10    17*     For new parser, (and general readability) renamed sel_ptr to
 10    18*     select_list_ptr.
 10    19*                                                   END HISTORY COMMENTS */
 10    20 
 10    21 
 10    22 dcl 1 select_list based (select_list_ptr),			/* tabular representation of -select clause */
 10    23     2 num_vars fixed bin,				/* number of free variables */
 10    24     2 mla_ptr ptr,					/* pointer to array of move list pointers */
 10    25     2 fr_ptr ptr,                                           /* pointer to free_raltions struct in mrds_dsl_select_clause */
 10    26     2 num_items fixed bin,				/* number of attributes specified in select list */
 10    27     2 var_exists (36) bit(1),
 10    28     2 item (mrds_data_$max_select_items refer (select_list.num_items)),
 10    29       3 must_convert bit (1) unal,			/* on if conversion required */
 10    30       3 key bit (1) unal,				/* on if to be key attr. in temp. rel. */
 10    31       3 index bit (1) unal,				/* on if index attribute in temp rel */
 10    32       3 reserved bit (33) unal,			/* reserved for future use */
 10    33       3 var_index fixed bin,				/*  index of assoc. tuple variable */
 10    34       3 ai_ptr ptr,					/* ptr to attr_info */
 10    35       3 user_desc_ptr ptr,				/* to descriptor for user value */
 10    36       3 user_ptr ptr ;				/* pointer to user's area */
 10    37 
 10    38 dcl  select_list_ptr ptr int automatic init (null ());
 10    39 
 10    40 dcl 1 move_list_array (select_list.num_vars) based (select_list.mla_ptr),
 10    41     2 var_index fixed bin,
 10    42     2 ml_ptr ptr;
 10    43 
 10    44 /* END mrds_select_list.incl.pl1 */
 10    45 
     1514 
     1515 
 11     1 /* BEGIN mrds_tuple_info.incl.pl1 -- jaw 11/2/78 */
 11     2 
 11     3 /* HISTORY:
 11     4*
 11     5*   Modified in March 1977 by O Friesen to hold allocated ptr and length
 11     6*   82-10-29 Mike Kubicar : Made tuple_id aligned
 11     7*
 11     8**/
 11     9  
 11    10 dcl 1 tuple_info aligned based (ti_ptr),
 11    11     2 num_tuples fixed bin,				/* no. of tuples for which info given */
 11    12     2 tuple (ti_ntuples_init refer (tuple_info.num_tuples)),
 11    13       3 tuple_ptr ptr,				/* pointer to found tuple */
 11    14       3 tuple_id bit (36) aligned,			/* tuple id for  found tuple */
 11    15       3 var_index fixed bin;				/* index to tuple variable  */
 11    16 
 11    17 dcl  ti_ptr ptr;
 11    18 dcl  ti_ntuples_init fixed bin;
 11    19 
 11    20 /* END mrds_tuple_info.incl.pl1 */
 11    21 
     1516 
     1517 
 12     1 /* BEGIN mdbm_arg_list.incl.pl1 -- jaw 5/31/78 */
 12     2 /* the duplicate mrds_arg_list.incl.pl1 was eliminated by Jim Gray, Nov. 1979 */
 12     3 
 12     4 /* layout of argument list for IDS and DBM entries with options (variable) */
 12     5 
 12     6 dcl 1 arg_list based (al_ptr),
 12     7     2 arg_count fixed bin (17) unal,			/* 2 * no. of args. */
 12     8     2 code fixed bin (17) unal,			/* 4 => normal, 8 => special */
 12     9     2 desc_count fixed bin (17) unal,			/* 2 * no. of descriptors */
 12    10     2 pad fixed bin (17) unal,			/* must be 0 */
 12    11     2 arg_des_ptr (num_ptrs) ptr;			/* argument/descriptor pointer */
 12    12 
 12    13 dcl  al_ptr ptr;
 12    14 dcl  num_ptrs fixed bin;
 12    15 
 12    16 /* END mdbm_arg_list.incl.pl1  */
 12    17 
     1518 
     1519 
 13     1 /* BEGIN mrds_select_sets.incl.pl1		rdl,	2/27/79			*/
 13     2 
 13     3 dcl 1 select_sets aligned based (ss_ptr),
 13     4     2 dup_retain bit (1) unal,			/* ON => duplicate selected tuples must be preserved */
 13     5     2 pad bit (35) unal,				/* Resevered for furture use */
 13     6     2 domains (mrds_data_$max_select_items) char (32),	/* domain name of each select item */
 13     7     2 nitems fixed bin,				/* Number of items in this structure */
 13     8     2 items (nitems_init refer (select_sets.nitems)),
 13     9       3 oper_flag bit (1) unal,			/* On => this item is an operator */
 13    10       3 pad bit (35) unal,				/* Reserved for future use */
 13    11       3 op_code fixed bin,				/* Valid only if oper_flag id on
 13    12*						   1 -> union
 13    13*						   2 => intersection
 13    14*						   3 => Difference 			*/
 13    15       3 range_ptr ptr,				/* Valid only if oper_flag  is OFF, these pointers are */
 13    16       3 select_ptr ptr,				/* used by  mrds_dsl_search */
 13    17       3 so_ptr ptr,
 13    18       3 ti_ptr ptr;					/* to tuple info structure for this block */
 13    19 
 13    20 
 13    21 dcl  ss_ptr ptr;					/* Pointer to the selected sets */
 13    22 dcl  nitems_init fixed bin;
 13    23 
 13    24 dcl  UNION fixed bin internal static options (constant) init (1);
 13    25 dcl  INTERSECTION fixed bin internal static options (constant) init (2);
 13    26 dcl  DIFFERENCE fixed bin internal static options (constant) init (3);
 13    27 
 13    28 /* END mrds_dsl_select_sets.incl.pl1					*/
 13    29 
     1520 
     1521 
 14     1 /* BEGIN mrds_retrieve_info.incl.pl1   -- RDL,  11/10/77   */
 14     2 
 14     3 /* HISTORY:
 14     4*   Originator unknown:
 14     5*   81-07-16 Roger Lackey : to add auto_dup_determined and make  other switches unal
 14     6**/
 14     7 dcl 1 retrieve_info aligned based (dbcb.retr_info_ptr),	/* Retrieve static data */
 14     8     2 version fixed bin (35),				/* Version number */
 14     9     2 retain_dup bit (1) unal,			/* On = duplicates must be preserved */
 14    10     2 first_sw bit (1) unal,				/* On = new set selection expression */
 14    11     2 auto_dup_determined bit (1) unal,			/* ON = that auto dup has been determined for the current sel exp */
 14    12     2 reserved bit (33) unal,				/* Reserved for furture use */
 14    13     2 unique_count fixed bin (17),			/* Unique records retrieve */
 14    14     2 ret_fd_ptr (mrds_data_$max_sets) ptr;		/* Array of pointers to sec_retrieve temp file desc */
 14    15 
 14    16 
 14    17 dcl  retrieve_info_version fixed bin (35) int static options (constant) init (1);
 14    18 
 14    19 /* END mrds_retrieve_info.incl.pl1  */
 14    20 
     1522 
     1523 
 15     1 /*	BEGIN INCLUDE FILE		mrds_fd.incl.pl1	10/20/78	RDL			*/
 15     2 
 15     3 /*  HISTORY:
 15     4*
 15     5*83-09-07 Mike Kubicar : removed bits dealing with duplicate keys.  They are
 15     6*no longer handled at the file level.
 15     7**/
 15     8 
 15     9 dcl 1 fd aligned based (fd_ptr),
 15    10     2 name char (32),				/* File name */
 15    11     2 iocb_ptr ptr,
 15    12     2 cur_key char (256) varying,
 15    13     2 desc fixed bin (35),
 15    14     2 rec_count fixed bin (24),
 15    15     2 rec_len fixed bin (21),
 15    16     2 rec_buf char (mrds_data_$max_data_length);
 15    17 
 15    18 dcl  fd_ptr ptr;
 15    19 
 15    20 /* 	END INCLUDE FILE		mrds_fd.incl.pl1				*/
 15    21 
     1524 
     1525 
 16     1 /* BEGIN mdbm_descriptor.incl.pl1 -- jaw 5/31/78 */
 16     2 /* modified by Jim Gray - - Nov. 1979, to change type from fixed bin(5) to
 16     3*   unsigned fixed bin(6), so new packed decimal data types could be handled.
 16     4*   also the duplicate mrds_descriptor.incl.pl1 was eliminated. */
 16     5 
 16     6 dcl 1 descriptor based (desc_ptr),			/* map of Multics descriptor */
 16     7     2 version bit (1) unal,				/* DBM handles vers. 1 only */
 16     8     2 type unsigned fixed bin (6) unal,			/* data type */
 16     9     2 packed bit (1) unal,				/* on if data item is packed */
 16    10     2 number_dims bit (4) unal,			/* dimensions */
 16    11     2 size,					/* size for string data */
 16    12       3 scale bit (12) unal,				/* scale for num. data */
 16    13       3 precision bit (12) unal,			/* prec. for num. data */
 16    14     2 array_info (num_dims),
 16    15       3 lower_bound fixed bin (35),			/* lower bound of dimension */
 16    16       3 upper_bound fixed bin (35),			/* upper bound of dimension */
 16    17       3 multiplier fixed bin (35);			/*  element separation */
 16    18 
 16    19 dcl  desc_ptr ptr;
 16    20 dcl  num_dims fixed bin init (0) ;			/* more useful form of number_dims */
 16    21 
 16    22 /* END mdbm_descriptor.incl.pl1 */
 16    23 
 16    24 
     1526 
     1527 
 17     1 /* BEGIN mrds_predicate_tree.incl.pl1 -- jaw, 2/14/79 */
 17     2 
 17     3 /* HISTORY:
 17     4*
 17     5*   81-06-01 Jim Gray : removed assn type and len, now that
 17     6*   mu_convert is being used.
 17     7*
 17     8*
 17     9**/
 17    10 
 17    11 
 17    12 dcl 1 pred_node based (pn_ptr),			/*  structure of predicate tree node */
 17    13     2 type fixed bin,				/*  indicates if node or leaf */
 17    14     2 id unal,					/* id for node */
 17    15       3 lleaf_id like pred_leaf.id,			/* id for left leaf */
 17    16       3 op_code bit (6) unal,				/* operator code for this node */
 17    17       3 rleaf_id like pred_leaf.id,			/* id for right leaf */
 17    18     2 term_type fixed bin (5) unal,			/* if term, indicates type of term */
 17    19     2 root bit (1) unal,				/* on if root node */
 17    20     2 term bit (1) unal,				/* on if node is term */
 17    21     2 determined bit (1) unal,			/* on if term is "determined" independent of other terms */
 17    22     2 reserved bit (21) unal,				/* reserved for future use */
 17    23     2 parent ptr,					/* pointer to parent node */
 17    24     2 lbr ptr,					/* pointer to left branch */
 17    25     2 rbr ptr;					/* pointer to right branch */
 17    26 
 17    27 dcl  pn_ptr ptr;
 17    28 
 17    29 dcl 1 pred_array based (pred_ptr),			/* list representation of pred. */
 17    30     2 type fixed bin,				/*  indicates array, rather than node or leaf */
 17    31     2 num_ands fixed bin,				/* is the number of and groups */
 17    32     2 and_ptr (num_ands_init refer (pred_array.num_ands)) ptr; /* pointers to the and groups */
 17    33 
 17    34 dcl  pred_ptr ptr;
 17    35 
 17    36 dcl 1 and_group based (ag_ptr),			/* list of pointers to all terms in and group */
 17    37     2 num_terms fixed bin,				/* number of terms in list */
 17    38     2 term_ptr (num_terms_init refer (and_group.num_terms)) ptr; /* point to terms in this and group */
 17    39 
 17    40 dcl  ag_ptr ptr;
 17    41 dcl (num_ands_init,
 17    42      num_terms_init) fixed bin;
 17    43 
 17    44 dcl ((CURRENT_OP init ("000001"b)),			/* pred_node op_codes */
 17    45     (AND_OP init ("000010"b)),
 17    46     (OR_OP init ("000011"b)),
 17    47     (NOT_OP init ("000100"b)),
 17    48     (EQ_OP init ("000101"b)),
 17    49     (NE_OP init ("000110"b)),
 17    50     (LT_OP init ("000111"b)),
 17    51     (GT_OP init ("001000"b)),
 17    52     (LE_OP init ("001001"b)),
 17    53     (GE_OP init ("001010"b)),
 17    54     (ALL_OP init ("001011"b))) bit (6) int static options (constant);
 17    55 
 17    56 dcl ((CONST init (1)),				/* pred leaf data types */
 17    57     (ATTR init (2)),
 17    58     (EXPRES init (3))) fixed bin int static options (constant);
 17    59 
 17    60 dcl ((NODE init (0)),				/* type indicators */
 17    61     (LEAF init (1)),
 17    62     (ARRAY init (2))) fixed bin int static options (constant);
 17    63 
 17    64 dcl ((V_C init (1)),				/* pred_node term_types */
 17    65     (V_V init (2))) fixed bin (5) int static options (constant);
 17    66 
 17    67 dcl 1 pred_leaf based (pl_ptr),			/* structure for a predicate tree leaf */
 17    68     2 type fixed bin,				/* indicates if node or leaf */
 17    69     2 id,						/* leaf id */
 17    70       3 var_id bit (18) unal,				/* index of tuple var. */
 17    71       3 attr_id bit (18) unal,			/* defn order of attr. */
 17    72     2 dummy bit (1) unal,				/* on if dummy leaf for ALL_OP */
 17    73     2 reserved bit (35) unal,				/* reserved for future use */
 17    74     2 data_type fixed bin,				/* whether const, attr, or expr */
 17    75     2 lit_offset fixed bin (35),			/* bit offset of literal or expr. result */
 17    76     2 lit_length fixed bin (35),			/* bit length of literal or expr. result */
 17    77     2 rslt_desc bit (36),				/* descriptor of expr. result */
 17    78     2 lit_ptr ptr,					/* ptr to literal or expr. result value */
 17    79     2 lit_desc_ptr ptr,				/* ptr to literal or expr. result desc. */
 17    80     2 ai_ptr ptr,					/* to rm_attr_info for attribute */
 17    81     2 expr_ptr ptr,					/* pointer to expr. structure if expr. leaf */
 17    82     2 parent ptr;					/* pointer to parent node */
 17    83 
 17    84 dcl  pl_ptr ptr;
 17    85 
 17    86 /* END mrds_predicate_tree.incl.pl1 */
 17    87 
     1528 
     1529 
 18     1 /* ***********************************************************
 18     2*   *                                                         *
 18     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
 18     4*   *                                                         *
 18     5*   *********************************************************** */
 18     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
 18     7 
 18     8 /* Written by Lindsey Spratt, 04/02/82.
 18     9*Modified:
 18    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
 18    11*	  unaligned.  Changed the type number of the simple_typed_vector to
 18    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
 18    13*	  type.
 18    14**/
 18    15 
 18    16 /* format: style2,ind3 */
 18    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
 18    18 	     2 type	      fixed bin (17) unal,
 18    19 	     2 number_of_dimensions
 18    20 			      fixed bin (17) unal,
 18    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
 18    22 	       3 value_ptr	      ptr unaligned;
 18    23 
 18    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
 18    25 	     2 type	      fixed bin (17) unal,
 18    26 	     2 number_of_dimensions
 18    27 			      fixed bin (17) unal,
 18    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
 18    29 	       3 identifier	      fixed bin (17) unal,
 18    30 	       3 pad	      bit (18) unal,
 18    31 	       3 value_ptr	      ptr unal;
 18    32 
 18    33      dcl	   simple_typed_vector_ptr
 18    34 			      ptr;
 18    35      dcl	   stv_number_of_dimensions
 18    36 			      fixed bin (17);
 18    37 
 18    38      dcl	   general_typed_vector_ptr
 18    39 			      ptr;
 18    40      dcl	   gtv_number_of_dimensions
 18    41 			      fixed bin (17);
 18    42 
 18    43      dcl	   (
 18    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
 18    45 			      init (1),		/* value_ptr was aligned. */
 18    46 	   GENERAL_TYPED_VECTOR_TYPE
 18    47 			      init (2),
 18    48 	   SIMPLE_TYPED_VECTOR_TYPE
 18    49 			      init (3)
 18    50 	   )		      fixed bin (17) internal static options (constant);
 18    51 
 18    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
     1530 
     1531 
     1532 
     1533 	dcl     current_data	 char (4 * sys_info$max_seg_size - 4) varying based (dbcb.current_data_ptr);
     1534 	dcl     static_data		 char (4 * sys_info$max_seg_size - 4) varying based (dbcb.static_data_ptr);
     1535 
     1536 	dcl     1 set_info		 aligned internal static,
     1537 		2 oper		 fixed bin,	/* Set operation being performed */
     1538 		2 ssi		 fixed bin,	/* Current select_sets index */
     1539 		2 sbi		 fixed bin,	/* Current selct_block index */
     1540 		2 cur_fdx		 fixed bin,	/* Current file desc index into retrieve_info.ret_fd_ptr array */
     1541 		2 cur_data_valid	 bit (1) unaligned, /* ON => data in variable current_data is valid */
     1542 		2 last_sb_oper	 bit (1) unaligned, /* ON => this is last set block */
     1543 		2 reserved	 bit (34) unaligned;/* Reserved for future use */
     1544 
     1545 
     1546 
     1547 	dcl     1 sb		 (20) aligned internal static, /* Set block */
     1548 		2 ss_item_num	 fixed bin,	/* Index into select_sets table */
     1549 		2 fdx		 fixed bin,	/* File desc index into dbdb.ret_fd_ptr array */
     1550 		2 file		 bit (1) unaligned, /* ON => this set_block is a file */
     1551 		2 eod		 bit (1) unaligned, /* ON => end of data for this set_block */
     1552 		2 first		 bit (1) unaligned, /* ON => this first reference to this set_block */
     1553 		2 reserved	 bit (33) unaligned;/* Reserved for future use */
     1554 						/* Multics Subroutines */
     1555 
     1556 	dcl     cu_$arg_list_ptr	 entry (ptr);
     1557 	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin, fixed bin (35));
     1558 	dcl     error_table_$end_of_info ext fixed bin (35);
     1559 	dcl     error_table_$no_record ext fixed bin (35);
     1560 	dcl     error_table_$noalloc	 ext fixed bin (35);
     1561 	dcl     iox_$attach_ioname	 entry (char (*), ptr, char (*), fixed bin (35));
     1562 	dcl     iox_$close		 entry (ptr, fixed bin (35));
     1563 	dcl     iox_$delete_record	 entry (ptr, fixed bin (35));
     1564 	dcl     iox_$open		 entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
     1565 	dcl     iox_$position	 entry (ptr, fixed bin, fixed bin (21), fixed bin (35));
     1566 	dcl     iox_$read_key	 entry (ptr, char (256) varying, fixed bin (21), fixed bin (35));
     1567 	dcl     iox_$read_record	 entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
     1568 	dcl     iox_$seek_key	 entry (ptr, char (256) varying, fixed bin (21), fixed bin (35));
     1569 	dcl     iox_$write_record	 entry (ptr, ptr, fixed bin (21), fixed bin (35));
     1570 	dcl     (iox_$detach_iocb, iox_$destroy_iocb) entry (ptr, fixed bin (35));
     1571 
     1572 	dcl     sys_info$max_seg_size	 ext fixed bin (35);
     1573 
     1574 /*   DBM Routines */
     1575 
     1576 	dcl     mrds_data_$caller_retrieve fixed bin (17) ext;
     1577 	dcl     mrds_data_$max_attributes fixed bin (35) ext static;
     1578 	dcl     mrds_data_$max_data_length fixed bin (21) ext;
     1579 	dcl     mrds_data_$max_id_len	 fixed bin (35) ext;
     1580 	dcl     mrds_data_$max_select_items ext fixed bin;
     1581 	dcl     mrds_data_$max_sets	 ext fixed bin;
     1582 	dcl     mrds_dsl_search	 entry (ptr, ptr, fixed bin (35));
     1583 	dcl     mrds_dsl_translate	 entry (ptr, ptr, fixed bin, ptr, fixed bin, ptr, ptr, fixed bin, fixed bin (35));
     1584 	dcl     mrds_error_$incomp_se_and_scope ext fixed bin (35);
     1585 	dcl     mrds_error_$inconsistent_transaction_se ext fixed bin (35);
     1586 	dcl     mrds_error_$invalid_db_index ext fixed bin (35);
     1587 	dcl     mrds_error_$inval_rtrv_expr ext fixed bin (35);
     1588 	dcl     mrds_error_$max_retr_len ext fixed bin (35);
     1589 	dcl     mrds_error_$no_dups_for_set_oper ext fixed bin (35);
     1590 	dcl     mrds_error_$too_many_temp_files ext fixed bin (35);
     1591 	dcl     mrds_error_$tuple_not_found ext fixed bin (35);
     1592 	dcl     mu_database_index$get_resultant_model_pointer entry (fixed bin (35), ptr);
     1593 	dcl     mu_get_data$get_data	 entry (ptr, ptr, ptr, ptr, fixed bin (35));
     1594 	dcl     mu_get_data$get_data_item entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35));
     1595 	dcl     mu_data_class$varying	 entry (ptr) returns (bit (1) aligned);
     1596 	dcl     mu_data_class$bit	 entry (ptr) returns (bit (1) aligned);
     1597 
     1598 /*  OTHERS  */
     1599 
     1600 	dcl     (se_ptr,				/* pointer to selection expr. */
     1601 	        cd_ptr,				/* pointer to status code */
     1602 	        dbi_ptr,				/* ptr to db index */
     1603 	        appl_ptr,				/* pointer to args for translate */
     1604 	        adpl_ptr)		 ptr;		/* pointer to descs for translate */
     1605 
     1606 	dcl     fb35u		 fixed bin (35) unal based;
     1607 
     1608 	dcl     icode		 fixed bin (35);	/* Internal error code */
     1609 
     1610 	dcl     code		 fixed bin (35) based (cd_ptr); /* Output: status code */
     1611 	dcl     database_index	 fixed bin (35) based (dbi_ptr); /* input: db index */
     1612 	dcl     rec_len		 fixed bin (21);
     1613 
     1614 	dcl     (nargs,				/* num args passed in */
     1615 	        se_len,				/* length of selection expr. */
     1616 	        arg_len,				/* length of an arg */
     1617 	        number_of_and_groups,			/* Number of and groups in a slection exp */
     1618 	        num_args,				/* num args for translate */
     1619 	        num_tuples_retrieved)	 fixed bin;	/* Count of tuples found on this call to secure_retrieve */
     1620 	dcl     i			 fixed bin;
     1621 
     1622 	dcl     (null,
     1623 	        addr,
     1624 	        ceil,
     1625 	        addbitno,
     1626 	        addrel,
     1627 	        substr,
     1628 	        length,
     1629 	        low,
     1630 	        maxlength,
     1631 	        index,
     1632 	        rtrim,
     1633 	        divide,
     1634 	        fixed,
     1635 	        rel,
     1636 	        string)		 builtin;
     1637 
     1638 	dcl     (cleanup, any_other, arg_error) condition;
     1639 
     1640 	dcl     dup_flag		 bit (1);		/* Duplicate record indicator */
     1641 	dcl     st_entry		 bit (1);		/* to remember which entry used */
     1642 	dcl     original_appl_ptr	 ptr;		/* copy of original value of appl_ptr incase of rollback */
     1643 	dcl     original_adpl_ptr	 ptr;		/* copy of original value of adpl_ptr incase of rollback */
     1644 	dcl     original_num_args	 fixed bin;	/* copy of original value of num_args incase of rollback */
     1645 
     1646 /* STATIC VARIABLES */
     1647 
     1648 	dcl     OFF		 bit (1) init ("0"b) internal static options (constant);
     1649 	dcl     ON		 bit (1) init ("1"b) internal static options (constant);
     1650 	declare clean_up_condition	 bit (1) init ("0"b); /* on => clean up proc called */
     1651 	declare seg_fault_error	 condition;
     1652 	declare mu_release_area	 entry (ptr);
     1653 	declare area_ptr		 ptr;
     1654 	dcl     mu_cursor_manager_$get entry (fixed bin (35), ptr, fixed bin (35), bit (36) aligned, entry, entry, ptr, ptr,
     1655 				 ptr, fixed bin (35));
     1656 	declare mu_define_area$define_temp_dir_area entry (ptr, fixed bin (35), fixed bin (18), char (11), bit (1) aligned,
     1657 				 bit (1) aligned, bit (1) aligned, bit (1) aligned, fixed bin (35));
     1658 	dcl     mu_define_area$define_spec_temp_dir_area entry (ptr, fixed bin (35), char (11), fixed bin (35));
     1659 	declare se_len_ptr		 ptr;		/* temp for getting varying se length */
     1660 	dcl     found		 bit (1);
     1661 	dcl     j			 fixed bin;
     1662 	dcl     key_used		 (key_used_len) bit (1) based (key_used_ptr);
     1663 	dcl     key_used_len	 fixed bin;
     1664 	dcl     key_used_ptr	 ptr;
     1665 	dcl     dbi_pic		 picture "999";
     1666 
     1667      end mrds_dsl_retrieve;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/05/00  1829.1  mrds_dsl_retrieve.pl1             >udd>sm>ds>w>ml>mrds_dsl_retrieve.pl1
393          1    02/05/86  1516.4  mrds_start_transaction.incl.pl1   >ldd>incl>mrds_start_transaction.incl.pl1
1-79         2    01/07/85  1000.0  dm_tm_modes.incl.pl1              >ldd>incl>dm_tm_modes.incl.pl1
1-81         3    06/28/79  1304.8  condition_info.incl.pl1           >ldd>incl>condition_info.incl.pl1
525          4    02/05/86  1516.4  mrds_finish_transaction.incl.pl1  >ldd>incl>mrds_finish_transaction.incl.pl1
1504         5    08/04/88  2143.3  mrds_dbcb.incl.pl1                >ldd>incl>mrds_dbcb.incl.pl1
1506         6    10/14/83  1709.1  mdbm_rm_rel_info.incl.pl1         >ldd>incl>mdbm_rm_rel_info.incl.pl1
1508         7    10/14/83  1709.1  mdbm_rm_attr_info.incl.pl1        >ldd>incl>mdbm_rm_attr_info.incl.pl1
1510         8    10/14/83  1709.1  mdbm_rm_domain_info.incl.pl1      >ldd>incl>mdbm_rm_domain_info.incl.pl1
1512         9    10/14/83  1709.1  mrds_range.incl.pl1               >ldd>incl>mrds_range.incl.pl1
1514        10    08/04/88  2143.3  mrds_select_list.incl.pl1         >ldd>incl>mrds_select_list.incl.pl1
1516        11    10/14/83  1709.0  mrds_tuple_info.incl.pl1          >ldd>incl>mrds_tuple_info.incl.pl1
1518        12    10/14/83  1709.0  mdbm_arg_list.incl.pl1            >ldd>incl>mdbm_arg_list.incl.pl1
1520        13    10/14/83  1708.4  mrds_select_sets.incl.pl1         >ldd>incl>mrds_select_sets.incl.pl1
1522        14    10/14/83  1709.0  mrds_retrieve_info.incl.pl1       >ldd>incl>mrds_retrieve_info.incl.pl1
1524        15    10/14/83  1709.1  mrds_fd.incl.pl1                  >ldd>incl>mrds_fd.incl.pl1
1526        16    10/14/83  1708.6  mdbm_descriptor.incl.pl1          >ldd>incl>mdbm_descriptor.incl.pl1
1528        17    10/14/83  1708.9  mrds_predicate_tree.incl.pl1      >ldd>incl>mrds_predicate_tree.incl.pl1
1530        18    10/14/83  1709.1  vu_typed_vector.incl.pl1          >ldd>incl>vu_typed_vector.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
KEYED_SEQ_UPDATE                000020 constant        fixed bin(17,0)          initial dcl 796 set ref 817*
OFF                                    constant        bit(1)                   initial packed unaligned dcl 1648 ref 419 448 493
                                                                                  493 637 644 645 647 896 899 899 903 922 924 977
                                                                                  986 990 990 994 1064 1126 1145 1182 1184 1249 1281
                                                                                  1382 1383 1384 1388 1394 1395 1408 1467
ON                                     constant        bit(1)                   initial packed unaligned dcl 1649 ref 413 448 499
                                                                                  510 588 622 624 656 901 905 911 927 945 949 981
                                                                                  992 996 1022 1052 1081 1110 1141 1187 1204 1209
                                                                                  1251 1377 1396 1401 1410 1412 1420 1432 1459
TM_NORMAL_MODE                  000025 constant        fixed bin(17,0)          initial dcl 2-15 set ref 1-99*
a_area_ptr                             parameter       pointer                  dcl 555 ref 551 560
a_code                                 parameter       fixed bin(35,0)          dcl 558 set ref 551 574* 1446*
a_dbcb_ptr                             parameter       pointer                  dcl 555 ref 551 561
actual_len                      000344 automatic       fixed bin(35,0)          dcl 678 set ref 703* 705* 707* 709 709 710 710 710
addbitno                                               builtin function         dcl 1622 ref 1311 1311
addr                                                   builtin function         dcl 1622 ref 365 369 370 573 573 1-123 1-123 604 604
                                                                                  682 701 701 703 703 717 771 904 904 995 995 1070
                                                                                  1070 1300
addrel                                                 builtin function         dcl 1622 ref 360 682 752 1301
adpl_ptr                        000210 automatic       pointer                  dcl 1600 set ref 369* 370* 385 408* 544*
ai_ptr                   12            based           pointer                  array level 3 dcl 10-22 ref 473 687 769 1307
al_ptr                          000162 automatic       pointer                  dcl 12-13 set ref 333* 334 336 341 341 342 355 355
                                                                                  357 365 369 369 370
another_flag            106            based           bit(1)                   level 3 packed packed unaligned dcl 5-142 set ref
                                                                                  413 428 448 510 565 949* 1126* 1209* 1251*
any_other                       000232 stack reference condition                dcl 1638 ref 392
appl_ptr                        000206 automatic       pointer                  dcl 1600 set ref 365* 384 408* 543*
area_ptr                        000256 automatic       pointer                  dcl 1653 set ref 330* 403* 408* 438* 560* 656* 1027*
                                                                                  1242*
arg_count                              based           fixed bin(17,0)          level 2 packed packed unaligned dcl 12-6 ref 336 341
                                                                                  342
arg_des_ptr               2            based           pointer                  array level 2 dcl 12-6 set ref 355 357 365 369 370
arg_error                       000240 stack reference condition                dcl 1638 ref 334 337 346
arg_len                         000216 automatic       fixed bin(17,0)          dcl 1614 set ref 345* 348*
arg_list                               based           structure                level 1 unaligned dcl 12-6
atd                             000374 automatic       char(200)                packed unaligned dcl 795 set ref 814* 816*
auto_dup_determined       1(02)        based           bit(1)                   level 2 packed packed unaligned dcl 14-7 set ref
                                                                                  421* 459 483*
bit_array                              based           bit(1)                   array packed unaligned dcl 744 set ref 771
bit_length               24            based           fixed bin(35,0)          level 2 dcl 7-46 ref 707 710 710 712 774 1309
bit_str                                based           bit                      packed unaligned dcl 668 set ref 709* 710* 713
bit_string_len                  000361 automatic       fixed bin(35,0)          dcl 739 set ref 751* 763
bit_string_ptr                  000362 automatic       pointer                  dcl 740 set ref 752* 771
bs_ptr                          000610 automatic       pointer                  dcl 1293 in procedure "return_data_temp" set ref
                                                                                  1300* 1301* 1301 1311 1311
bs_ptr                          000334 automatic       pointer                  dcl 670 in procedure "build_data_string" set ref
                                                                                  682* 709 710 713
bvfs_data_ptr                          parameter       pointer                  dcl 730 ref 721 751 752
bvfs_simple_typed_vector_ptr           parameter       pointer                  dcl 731 ref 721 759 771
cd                                     parameter       fixed bin(35,0)          dcl 1443 ref 1441 1446 1450
cd_ptr                          000202 automatic       pointer                  dcl 1600 set ref 345* 376 510 512 518 518 523 4-115
                                                                                  1450
ceil                                                   builtin function         dcl 1622 ref 717
clean_up_condition              000255 automatic       bit(1)                   initial packed unaligned dcl 1650 set ref 855 1459*
                                                                                  1467* 1650*
cleanup                         000224 stack reference condition                dcl 1638 ref 388
code                      0(18)        based           fixed bin(17,0)          level 2 in structure "arg_list" packed packed
                                                                                  unaligned dcl 12-6 in procedure "retrieve" ref 341
                                                                                  355 369
code                                   based           fixed bin(35,0)          dcl 1610 in procedure "retrieve" set ref 376* 510*
                                                                                  512* 518 518 523 4-115* 1450*
condition_info                         based           structure                level 1 dcl 3-14
condition_name            3     000110 automatic       varying char(32)         level 2 dcl 1-77 set ref 1-124 1-129 1-129
continue_to_signal_             000112 constant        entry                    external dcl 1-61 ref 1-137
copied_for_current                     based           bit(1)                   array level 3 packed packed unaligned dcl 9-5 set
                                                                                  ref 1353*
copy_for_current                       based           bit(1)                   array level 3 packed packed unaligned dcl 9-5 set
                                                                                  ref 1337 1352*
create_cursor           156            based           entry variable           level 4 dcl 5-142 set ref 1340*
cu_$arg_list_ptr                000142 constant        entry                    external dcl 1556 ref 333
cu_$arg_ptr                     000144 constant        entry                    external dcl 1557 ref 345 348 351
cur_data_valid            4     000010 internal static bit(1)                   level 2 packed packed unaligned dcl 1536 set ref
                                                                                  572* 922* 1052* 1064* 1081* 1182* 1382* 1408*
cur_fdx                   3     000010 internal static fixed bin(17,0)          level 2 dcl 1536 set ref 568* 933* 946* 963 1040*
                                                                                  1173 1193* 1205* 1207* 1223 1379* 1411* 1412*
                                                                                  1415* 1421* 1422* 1426* 1427* 1428* 1431
cur_key                  12            based           varying char(256)        level 2 dcl 15-9 set ref 592* 598* 822* 900* 901
                                                                                  991* 992 1067* 1080
cur_pos                         000356 automatic       fixed bin(35,0)          dcl 736 in procedure "build_vector_from_string" set
                                                                                  ref 756* 763 771 774* 774
cur_pos                         000340 automatic       fixed bin(35,0)          dcl 673 in procedure "build_data_string" set ref
                                                                                  680* 709 710 712* 712 713 717
cur_pos                         000612 automatic       fixed bin(35,0)          dcl 1295 in procedure "return_data_temp" set ref
                                                                                  1299* 1311 1311 1320* 1320
current_data                           based           varying char             dcl 1533 in procedure "retrieve" set ref 568* 573
                                                                                  573 625* 628 635* 645* 648* 938* 944* 946* 952*
                                                                                  1040* 1043* 1197* 1203* 1205* 1207* 1212* 1246*
                                                                                  1248* 1249* 1277* 1280* 1281*
current_data                           parameter       varying char             dcl 1019 in procedure "get_data" set ref 1007 1023*
                                                                                  1028*
current_data                           parameter       varying char             dcl 1060 in procedure "get_temp_record" set ref 1056
                                                                                  1080*
current_data_ptr         40            based           pointer                  level 3 dcl 5-142 ref 568 573 573 625 628 635 645
                                                                                  648 938 944 946 952 1040 1043 1197 1203 1205 1207
                                                                                  1212 1246 1248 1249 1277 1280 1281
current_flag            106(01)        based           bit(1)                   level 3 packed packed unaligned dcl 5-142 set ref
                                                                                  419 493 499 1126*
current_ptr              16            based           pointer                  level 3 dcl 5-142 ref 499
cursor_ptr                      000626 automatic       pointer                  dcl 1365 set ref 1340* 1345*
cursor_ptrs_storage_ptr
                        130            based           pointer                  level 3 dcl 5-142 set ref 1340*
cursor_storage_area_ptr
                        132            based           pointer                  level 3 dcl 5-142 set ref 1340*
data                                   based           structure                level 2 in structure "dbcb" dcl 5-142 in procedure
                                                                                  "retrieve"
data                                   parameter       varying char             dcl 884 in procedure "delete_temp_record" ref 881
                                                                                  889 890 898 898 901 905
data                                   parameter       varying char             dcl 972 in procedure "dup_check" ref 969 979 980 988
                                                                                  988 992 996
data                                   parameter       varying char             dcl 581 in procedure "add_record" ref 579 585 589
                                                                                  592 596 598 599 600
data_ptr                               parameter       pointer                  dcl 555 set ref 551 573*
data_str                               parameter       varying char             dcl 669 in procedure "build_data_string" set ref 664
                                                                                  682 709 710 713 717
data_str                               parameter       varying char             dcl 1294 in procedure "return_data_temp" set ref
                                                                                  1289 1300
database_index                         based           fixed bin(35,0)          dcl 1611 set ref 374* 400* 405*
db_desc                  10            based           bit(36)                  level 2 dcl 8-35 set ref 701 701 703 703
dbcb                                   based           structure                level 1 dcl 5-142
dbcb_data                              based           structure                level 1 unaligned dcl 5-148
dbcb_ptr                        000144 automatic       pointer                  dcl 5-146 set ref 330* 374* 375 382 398 399 400 403
                                                                                  405 408* 411 413 414 414 414 419 421 426 427 428
                                                                                  431 438* 441 441 443 444 445 448 448 454 456 459
                                                                                  466 480 480 483 486 493 493 494 496 499 499 510
                                                                                  510 561* 564 565 568 573 573 586 625 627 628 628
                                                                                  633 635 636 645 645 648 649 649 656* 754 803 807
                                                                                  808 835 836 856 857 871 887 930 938 944 946 949
                                                                                  952 976 1027* 1040 1043 1063 1095 1096 1096 1097
                                                                                  1099 1112 1119 1121 1122 1124 1126 1126 1137 1141
                                                                                  1173 1190 1197 1203 1205 1207 1209 1212 1242* 1246
                                                                                  1248 1249 1251 1269 1277 1280 1281 1311 1340 1340
                                                                                  1340 1340 1340 1345 1345 1355 1377 1383 1478 1479
                                                                                  1480 1492 1493 1495
dbi                     114            based           fixed bin(35,0)          level 3 dcl 5-142 set ref 399 871* 1340*
dbi_pic                         000270 automatic       picture(3)               packed unaligned dcl 1665 set ref 399* 400 405
dbi_ptr                         000204 automatic       pointer                  dcl 1600 set ref 348* 374 400 405
defn_order               22            based           fixed bin(17,0)          level 2 dcl 7-46 ref 698
desc                    113            based           fixed bin(35,0)          level 2 dcl 15-9 set ref 823*
desc_ptr                        000172 automatic       pointer                  dcl 16-19 set ref 355* 357* 359
descriptor                             based           structure                level 1 unaligned dcl 16-6
dimension                 1            based           structure                array level 2 packed packed unaligned dcl 18-17
divide                                                 builtin function         dcl 1622 ref 336
dm_error_$bj_journal_full       000132 external static fixed bin(35,0)          dcl 4-52 ref 1-132
dm_error_$lock_deadlock         000134 external static fixed bin(35,0)          dcl 4-53 ref 4-78 1-126
dm_error_$no_current_transaction
                                000114 external static fixed bin(35,0)          dcl 1-62 ref 1-90
domain_ptr               26            based           pointer                  level 2 dcl 7-46 ref 701 701 703 703
dont_check_txn_id       106(25)        based           bit(1)                   level 3 packed packed unaligned dcl 5-142 ref 414
dup_flag                        000246 automatic       bit(1)                   packed unaligned dcl 1640 in procedure "retrieve"
                                                                                  set ref 622* 624 637* 644* 645* 647 656 944* 945
                                                                                  1203* 1204 1205* 1207 1248* 1249 1280* 1281
dup_flag                               parameter       bit(1)                   packed unaligned dcl 973 in procedure "dup_check"
                                                                                  set ref 969 977* 981* 990 996*
dup_retain              106(04)        based           bit(1)                   level 3 in structure "dbcb" packed packed unaligned
                                                                                  dcl 5-142 in procedure "retrieve" set ref 441 480*
dup_retain                             based           bit(1)                   level 2 in structure "select_sets" packed packed
                                                                                  unaligned dcl 13-3 in procedure "retrieve" ref
                                                                                  1135
eod                       2(01) 000015 internal static bit(1)                   array level 2 packed packed unaligned dcl 1547 set
                                                                                  ref 1395*
error_table_$end_of_info        000146 external static fixed bin(35,0)          dcl 1558 ref 569 957 1024 1032 1045 1075 1216 1285
error_table_$no_record          000150 external static fixed bin(35,0)          dcl 1559 ref 590 597 603 913 989
error_table_$noalloc            000152 external static fixed bin(35,0)          dcl 1560 ref 1315 1357
error_table_$notadir            000274 external static fixed bin(35,0)          dcl 851 ref 846
fb35u                                  based           fixed bin(35,0)          packed unaligned dcl 1606 set ref 361 717*
fd                                     based           structure                level 1 dcl 15-9 set ref 807 856
fd_ptr                          000170 automatic       pointer                  dcl 15-18 set ref 586* 589 591 592 593 596 598 599
                                                                                  600 604 604 604 604 605 605 807* 808 812 814 816
                                                                                  816 817 822 823 824 836* 837 839 840 841 856 887*
                                                                                  890 891 898 900 900 900 901 904 904 904 904 904
                                                                                  904 905 911 930* 931 976* 980 988 991 991 991 992
                                                                                  995 995 995 995 995 995 996 1063* 1067 1067 1067
                                                                                  1070 1070 1070 1070 1070 1074 1080 1080 1080 1112*
                                                                                  1113 1173* 1176 1190* 1191 1269* 1271
fdx                                    parameter       fixed bin(17,0)          dcl 1058 in procedure "get_temp_record" ref 1056
                                                                                  1063
fdx                                    parameter       fixed bin(17,0)          dcl 883 in procedure "delete_temp_record" ref 881
                                                                                  887
fdx                                    parameter       fixed bin(17,0)          dcl 582 in procedure "add_record" ref 579 586
fdx                                    parameter       fixed bin(17,0)          dcl 1232 in procedure "move_db_to_file" set ref 1229
                                                                                  1248* 1249*
fdx                                    parameter       fixed bin(17,0)          dcl 971 in procedure "dup_check" ref 969 976
fdx                       1     000015 internal static fixed bin(17,0)          array level 2 in structure "sb" dcl 1547
                                                                                  in procedure "retrieve" set ref 925* 926* 930 933
                                                                                  944* 960* 963* 1023* 1112 1185* 1186* 1190 1203*
                                                                                  1219* 1223* 1393* 1411 1412* 1421 1431*
fdx                             000111 internal static fixed bin(17,0)          dcl 620 in procedure "another" set ref 632* 633*
                                                                                  635* 645* 648*
file                      2     000015 internal static bit(1)                   array level 2 packed packed unaligned dcl 1547 set
                                                                                  ref 924 927* 960 1022 1110 1184 1187* 1219 1394*
                                                                                  1410 1412 1420 1432*
file_name                       000100 automatic       char(32)                 packed unaligned dcl 832 set ref 837* 845* 846*
find_condition_info_            000116 constant        entry                    external dcl 1-64 ref 1-123
first                     2(02) 000015 internal static bit(1)                   array level 2 packed packed unaligned dcl 1547 set
                                                                                  ref 1396*
first_sw                  1(01)        based           bit(1)                   level 2 packed packed unaligned dcl 14-7 set ref
                                                                                  1141* 1377 1383*
found                           000262 automatic       bit(1)                   packed unaligned dcl 1660 set ref 470* 472 474*
from_fdx                               parameter       fixed bin(17,0)          dcl 1264 set ref 1260 1269 1277*
get_tuple_by_id         202            based           entry variable           level 4 dcl 5-142 ref 1345
hcs_$del_dir_tree               000270 constant        entry                    external dcl 849 ref 845
hcs_$delentry_file              000272 constant        entry                    external dcl 850 ref 846
i                               000630 automatic       fixed bin(17,0)          dcl 1366 in procedure "return_data_tup" set ref
                                                                                  1330* 1333 1355 1355*
i                               000360 automatic       fixed bin(35,0)          dcl 738 in procedure "build_vector_from_string" set
                                                                                  ref 762* 766 766 769 771*
i                               000343 automatic       fixed bin(35,0)          dcl 673 in procedure "build_data_string" set ref
                                                                                  685* 687 689 690 691*
i                               000222 automatic       fixed bin(17,0)          dcl 1620 in procedure "retrieve" set ref 469* 473*
                                                                                  802* 803 803* 1098* 1099* 1136* 1137 1137* 1494*
                                                                                  1495 1495*
i                               000614 automatic       fixed bin(35,0)          dcl 1295 in procedure "return_data_temp" set ref
                                                                                  1303* 1307 1311 1311*
icode                           000212 automatic       fixed bin(35,0)          dcl 1608 in procedure "retrieve" set ref 345* 346
                                                                                  348* 349 349* 351* 352 352* 400* 402 402* 405* 406
                                                                                  406* 408* 410 410* 438* 439 439* 568* 569 569* 570
                                                                                  570* 589* 590 590 590* 596* 597 597 597* 603 603
                                                                                  604* 607* 656* 657 657* 816* 817 817* 819 819*
                                                                                  839* 840 840* 841 841* 842 845* 846 846 846* 855
                                                                                  855* 871* 872 872* 890* 891 891* 898* 899 900* 903
                                                                                  904* 905 910 911* 913* 916 916* 931* 938* 940 942
                                                                                  952* 957 957* 958* 980* 981 988* 989 989 989* 990
                                                                                  991* 994 995* 996 1040* 1043 1045 1045* 1048 1048*
                                                                                  1092* 1113* 1114 1114* 1176* 1191* 1197* 1199 1201
                                                                                  1212* 1216 1216* 1217* 1238* 1240 1242* 1244 1247
                                                                                  1256 1256 1256* 1271* 1273 1273* 1275 1277* 1279
                                                                                  1285 1285 1285* 1311* 1315 1315 1318*
icode                                  parameter       fixed bin(35,0)          dcl 1061 in procedure "get_temp_record" set ref 1056
                                                                                  1067* 1069 1070* 1074* 1075 1075* 1079
icode                                  parameter       fixed bin(35,0)          dcl 1020 in procedure "get_data" set ref 1007 1023*
                                                                                  1024 1024 1024* 1027* 1028 1031 1031* 1032*
icode                           000624 automatic       fixed bin(35,0)          dcl 1364 in procedure "return_data_tup" set ref
                                                                                  1336* 1340* 1344 1344* 1345* 1351 1351* 1355* 1357
                                                                                  1357 1357*
id                        1            based           structure                level 2 packed packed unaligned dcl 17-67
id_list_ptr                            based           pointer                  level 2 dcl 6-119 set ref 1345*
index                                                  builtin function         dcl 1622 ref 480
iocb_ptr                 10            based           pointer                  level 2 dcl 15-9 set ref 589* 596* 604* 816* 817*
                                                                                  839* 840* 841* 890* 891* 898* 900* 904* 911* 931*
                                                                                  980* 988* 991* 995* 1067* 1070* 1074* 1113* 1176*
                                                                                  1191* 1271*
iox_$attach_ioname              000154 constant        entry                    external dcl 1561 ref 816
iox_$close                      000156 constant        entry                    external dcl 1562 ref 839
iox_$delete_record              000160 constant        entry                    external dcl 1563 ref 891 911
iox_$destroy_iocb               000200 constant        entry                    external dcl 1570 ref 841
iox_$detach_iocb                000176 constant        entry                    external dcl 1570 ref 840
iox_$open                       000162 constant        entry                    external dcl 1564 ref 817
iox_$position                   000164 constant        entry                    external dcl 1565 ref 931 1074 1113 1176 1191 1271
iox_$read_key                   000166 constant        entry                    external dcl 1566 ref 900 991 1067
iox_$read_record                000170 constant        entry                    external dcl 1567 ref 904 995 1070
iox_$seek_key                   000172 constant        entry                    external dcl 1568 ref 589 596 890 898 980 988
iox_$write_record               000174 constant        entry                    external dcl 1569 ref 604
is                                     parameter       fixed bin(17,0)          dcl 1231 ref 1229
item                     10            based           structure                array level 2 unaligned dcl 10-22
items                                  based           structure                array level 2 dcl 13-3
ix                              000644 automatic       fixed bin(17,0)          dcl 1373 set ref 1390* 1392 1393 1394 1395 1396
j                               000342 automatic       fixed bin(35,0)          dcl 673 in procedure "build_data_string" set ref
                                                                                  693* 693* 695
j                               000631 automatic       fixed bin(17,0)          dcl 1366 in procedure "return_data_tup" set ref
                                                                                  1334* 1334* 1355
j                               000263 automatic       fixed bin(17,0)          dcl 1661 in procedure "retrieve" set ref 472* 473
                                                                                  475*
key_attr_ptrs            44            based           pointer                  array level 2 dcl 6-119 ref 473
key_only                        000316 automatic       bit(1)                   packed unaligned dcl 583 set ref 585* 588
key_used                               based           bit(1)                   array packed unaligned dcl 1662 set ref 466 467*
                                                                                  475* 480 481
key_used_len                    000264 automatic       fixed bin(17,0)          dcl 1663 set ref 464* 466 467 472 480 481
key_used_ptr                    000266 automatic       pointer                  dcl 1664 set ref 466* 467 475 480 481 481 1093*
last_sb_oper              4(01) 000010 internal static bit(1)                   level 2 packed packed unaligned dcl 1536 set ref
                                                                                  1145 1384* 1401*
len                             000613 automatic       fixed bin(35,0)          dcl 1295 set ref 1309* 1320
length                                                 builtin function         dcl 1622 ref 585 600 713 889 904 904 979 995 995
length_word_overlay                    based           fixed bin(35,0)          packed unaligned dcl 677 in procedure
                                                                                  "build_data_string" ref 703 705
length_word_overlay                    based           fixed bin(35,0)          packed unaligned dcl 746 in procedure
                                                                                  "build_vector_from_string" ref 751
low                                                    builtin function         dcl 1622 ref 822
maxlength                                              builtin function         dcl 1622 ref 709 710 713
mftxn_code                      000142 automatic       fixed bin(35,0)          dcl 4-54 set ref 518* 523* 4-62* 4-65 4-68* 4-69
                                                                                  4-78 4-115 4-115 1-126* 1-132*
mftxn_temp_code                 000143 automatic       fixed bin(35,0)          dcl 4-55 set ref 4-71* 4-72 4-72* 4-82* 4-83 4-85*
                                                                                  4-86 4-86* 4-96* 4-97 4-99* 4-100 4-100* 4-109*
                                                                                  4-110 4-110*
ml_ptr                    2            based           pointer                  array level 2 dcl 10-40 set ref 1355*
mla_ptr                   2            based           pointer                  level 2 dcl 10-22 ref 1333 1355 1355
move_list_array                        based           structure                array level 1 unaligned dcl 10-40
mrds_data_$caller_retrieve      000204 external static fixed bin(17,0)          dcl 1576 set ref 408*
mrds_data_$max_attributes       000206 external static fixed bin(35,0)          dcl 1577 ref 462 462 462 691 691 691 1337 1337 1339
                                                                                  1339 1339 1352 1352 1353 1353 1355 1355 1355
mrds_data_$max_data_length      000210 external static fixed bin(21,0)          dcl 1578 set ref 591 599 604 604 807 856 904 904 904
                                                                                  904 905 995 995 995 995 996 1070 1070 1070* 1080
mrds_data_$max_id_len           000212 external static fixed bin(35,0)          dcl 1579 ref 462 462 462 691 691 691 1337 1337 1337
                                                                                  1339 1339 1339 1352 1352 1352 1353 1353 1353 1355
                                                                                  1355 1355
mrds_data_$max_select_items     000214 external static fixed bin(17,0)          dcl 1580 ref 1119 1121 1122 1124 1388 1400 1401
mrds_data_$max_sets             000216 external static fixed bin(17,0)          dcl 1581 ref 802 1096 1098 1136 1494
mrds_dsl_resultant_storage$get_opening_temp_dir
                                000276 constant        entry                    external dcl 866 ref 871
mrds_dsl_search                 000220 constant        entry                    external dcl 1582 ref 438 656 1027 1242
mrds_dsl_translate              000222 constant        entry                    external dcl 1583 ref 408
mrds_error_$incomp_se_and_scope 000224 external static fixed bin(35,0)          dcl 1584 ref 510 518
mrds_error_$inconsistent_transaction_se
                                000226 external static fixed bin(35,0)          dcl 1585 set ref 414*
mrds_error_$inval_rtrv_expr     000232 external static fixed bin(35,0)          dcl 1587 set ref 411*
mrds_error_$invalid_db_index    000230 external static fixed bin(35,0)          dcl 1586 ref 376
mrds_error_$max_retr_len        000234 external static fixed bin(35,0)          dcl 1588 set ref 713* 763*
mrds_error_$no_dups_for_set_oper
                                000236 external static fixed bin(35,0)          dcl 1589 set ref 1135*
mrds_error_$too_many_temp_files 000240 external static fixed bin(35,0)          dcl 1590 set ref 805*
mrds_error_$tuple_not_found     000242 external static fixed bin(35,0)          dcl 1591 set ref 507* 518 569 1031 1045 1256
mstxn_code                      000100 automatic       fixed bin(35,0)          dcl 1-65 set ref 1-83* 1-89* 1-90 1-99* 1-140 1-140*
                                                                                  4-90* 4-104* 1-137*
mstxn_condition_info            000110 automatic       structure                level 1 unaligned dcl 1-77 set ref 1-123 1-123
mstxn_retries                   000101 automatic       fixed bin(17,0)          dcl 1-66 set ref 1-88* 4-78 4-81* 4-81
mstxn_temp_code                 000102 automatic       fixed bin(35,0)          dcl 1-67 set ref 1-109* 1-110 1-110* 1-123*
mstxn_transactions_needed       000103 automatic       bit(1)                   dcl 1-68 set ref 382* 1-86
mstxn_txn_id                    000105 automatic       bit(36)                  dcl 1-70 set ref 331* 1-84* 1-89* 1-93 1-94* 1-99*
                                                                                  1-100 4-60 4-68* 4-71* 4-72* 4-82* 4-85* 4-86*
                                                                                  4-96* 4-99* 4-100* 4-109* 4-110* 4-114* 1-107
                                                                                  1-109* 1-110* 1-121
mu_cursor_manager_$get          000260 constant        entry                    external dcl 1654 ref 1340
mu_data_class$bit               000254 constant        entry                    external dcl 1596 ref 703
mu_data_class$varying           000252 constant        entry                    external dcl 1595 ref 701
mu_database_index$get_resultant_model_pointer
                                000244 constant        entry                    external dcl 1592 ref 374
mu_define_area$define_spec_temp_dir_area
                                000264 constant        entry                    external dcl 1658 ref 405
mu_define_area$define_temp_dir_area
                                000262 constant        entry                    external dcl 1656 ref 400
mu_get_data$get_data            000246 constant        entry                    external dcl 1593 ref 1355
mu_get_data$get_data_item       000250 constant        entry                    external dcl 1594 ref 1311
mu_release_area                 000256 constant        entry                    external dcl 1652 ref 1480
name                                   based           char(32)                 level 2 dcl 15-9 set ref 812* 814 816 837
nargs                           000214 automatic       fixed bin(17,0)          dcl 1614 set ref 336* 337 345* 355 357 369 370 372
new_key                         000466 automatic       bit(1)                   packed unaligned dcl 885 in procedure
                                                                                  "delete_temp_record" set ref 896* 899 901* 903
new_key                         000504 automatic       bit(1)                   packed unaligned dcl 974 in procedure "dup_check"
                                                                                  set ref 986* 990 992* 994
nitems                                 based           fixed bin(17,0)          level 2 dcl 13-3 ref 1401
nkey_attr                24            based           fixed bin(17,0)          level 2 dcl 6-119 ref 463 463 464 1345
non_shared_to_shared    106(23)        based           bit(1)                   level 3 packed packed unaligned dcl 5-142 ref 510
null                                                   builtin function         dcl 1622 ref 330 334 375 426 454 481 7-65 8-51 10-38
                                                                                  1-123 1-123 803 835 857 1093 1095 1099 1137 1478
                                                                                  1479 1492 1493 1495
num_ands                  1            based           fixed bin(17,0)          level 2 dcl 17-29 ref 456
num_args                        000220 automatic       fixed bin(17,0)          dcl 1614 set ref 372* 386 408* 545*
num_attr                 22            based           fixed bin(17,0)          level 2 dcl 6-119 ref 1345
num_dims                        000174 automatic       fixed bin(17,0)          initial dcl 16-20 set ref 16-20*
num_items                 6            based           fixed bin(17,0)          level 2 dcl 10-22 ref 463 469 685 759 762 1303
num_ptrs                        000164 automatic       fixed bin(17,0)          dcl 12-14 set ref 341* 342*
num_tuples                             based           fixed bin(17,0)          level 2 dcl 11-10 ref 693 1334
num_tuples_retrieved            000221 automatic       fixed bin(17,0)          dcl 1614 set ref 503* 503 507 571* 571 1050* 1050
                                                                                  1092*
num_vars                               based           fixed bin(17,0)          level 2 in structure "select_list" dcl 10-22
                                                                                  in procedure "retrieve" ref 1330
num_vars                               based           fixed bin(17,0)          level 2 in structure "range" dcl 9-5 in procedure
                                                                                  "retrieve" ref 459
number                          000456 automatic       picture(2)               packed unaligned dcl 797 set ref 810* 812
number_of_and_groups            000217 automatic       fixed bin(17,0)          dcl 1614 set ref 454* 456* 459
number_of_dimensions      0(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 18-17 set ref
                                                                                  759*
old_vi                          000357 automatic       fixed bin(35,0)          dcl 737 in procedure "build_vector_from_string" set
                                                                                  ref 757* 766 766*
old_vi                          000341 automatic       fixed bin(35,0)          dcl 673 in procedure "build_data_string" set ref
                                                                                  683* 689 690* 693
op_code                                based           fixed bin(17,0)          array level 3 dcl 13-3 ref 1400
open                    146            based           entry variable           level 4 dcl 5-142 set ref 1340*
oper                            000010 internal static fixed bin(17,0)          level 2 dcl 1536 set ref 1147 1162 1400*
oper_flag                              based           bit(1)                   array level 3 packed packed unaligned dcl 13-3 ref
                                                                                  1388
original_adpl_ptr               000252 automatic       pointer                  dcl 1643 set ref 385* 544
original_appl_ptr               000250 automatic       pointer                  dcl 1642 set ref 384* 543
original_num_args               000254 automatic       fixed bin(17,0)          dcl 1644 set ref 386* 545
pathname                        000100 automatic       char(168)                packed unaligned dcl 865 set ref 871* 877
pred_array                             based           structure                level 1 unaligned dcl 17-29
pred_leaf                              based           structure                level 1 unaligned dcl 17-67
pred_ptr                 56            based           pointer                  level 3 dcl 5-142 ref 454 456
rai_ptr                         000150 automatic       pointer                  initial dcl 7-65 set ref 7-65* 687* 698 701 701 703
                                                                                  703 707 710 710 712 769* 774 1307* 1309 1311*
range                                  based           structure                level 1 dcl 9-5
range_ptr                       000154 automatic       pointer                  dcl 9-23 in procedure "retrieve" set ref 444* 459
                                                                                  462 691 1119* 1337 1339 1352 1353 1355
range_ptr                 2            based           pointer                  level 3 in structure "dbcb" dcl 5-142 in procedure
                                                                                  "retrieve" set ref 444 1119*
range_ptr                              based           pointer                  array level 3 in structure "select_sets" dcl 13-3
                                                                                  in procedure "retrieve" ref 1119
rdi_ptr                         000152 automatic       pointer                  initial dcl 8-51 set ref 8-51*
rec_buf                 116            based           char                     level 2 dcl 15-9 set ref 591* 599* 604 604 904 904
                                                                                  904 904 905 995 995 995 995 996 1070 1070 1080
rec_count               114            based           fixed bin(24,0)          level 2 dcl 15-9 set ref 605* 605 824*
rec_found                       000467 automatic       bit(1)                   packed unaligned dcl 885 set ref 896* 899 905* 911
rec_len                 115            based           fixed bin(21,0)          level 2 in structure "fd" dcl 15-9 in procedure
                                                                                  "retrieve" set ref 593* 600* 604* 900* 904* 991*
                                                                                  995* 1067* 1070 1070* 1080
rec_len                         000213 automatic       fixed bin(21,0)          dcl 1612 in procedure "retrieve" set ref 589* 596*
                                                                                  890* 898* 905 980* 988* 996
rel_id                   20            based           bit(36)                  level 2 dcl 6-119 set ref 1340*
relmgr_entries          146            based           structure                level 3 dcl 5-142
ret_fd_ptr                4            based           pointer                  array level 2 dcl 14-7 set ref 586 803 808* 835 836
                                                                                  857* 887 930 976 1063 1099* 1112 1137 1173 1190
                                                                                  1269 1495
retain_dup                1            based           bit(1)                   level 2 packed packed unaligned dcl 14-7 set ref
                                                                                  441* 448 480* 486 493 645
retr_info_ptr            22            based           pointer                  level 3 dcl 5-142 set ref 421 441 448 459 480 483
                                                                                  486 493 496 586 627 636 645 649 649 803 808 835
                                                                                  836 857 887 930 976 1063 1095 1096* 1097 1099 1112
                                                                                  1137 1141 1173 1190 1269 1377 1383 1493 1495
retrieve_area_ptr        46            based           pointer                  level 3 dcl 5-142 set ref 400* 403 1479 1480*
retrieve_info                          based           structure                level 1 dcl 14-7 set ref 1096
retrieve_info_version                  constant        fixed bin(35,0)          initial dcl 14-17 ref 1097
ri_ptr                                 based           pointer                  array level 3 dcl 9-5 set ref 462 691 1339 1355*
rm_attr_info                           based           structure                level 1 dcl 7-46
rm_domain_info                         based           structure                level 1 dcl 8-35
rm_rel_info                            based           structure                level 1 dcl 6-119
rmri_ptr                        000146 automatic       pointer                  dcl 6-156 set ref 462* 463 463 464 473 691* 1339*
                                                                                  1340* 1340 1345
rtrim                                                  builtin function         dcl 1622 ref 814
sb                              000015 internal static structure                array level 1 dcl 1547
sbi                                    parameter       fixed bin(17,0)          dcl 1018 in procedure "get_data" ref 1007 1022 1023
sbi                                    parameter       fixed bin(17,0)          dcl 1108 in procedure "init_search" ref 1105 1110
                                                                                  1112 1118
sbi                       2     000010 internal static fixed bin(17,0)          level 2 in structure "set_info" dcl 1536
                                                                                  in procedure "retrieve" set ref 924 925 926 926
                                                                                  926 927 930 933 936* 938* 944 952* 960 960 962*
                                                                                  962 963 1184 1185 1186 1186 1186 1187 1190 1195*
                                                                                  1197* 1203 1212* 1219 1219 1221* 1221 1223 1381*
                                                                                  1390 1390* 1410 1411 1412 1412 1415* 1415 1420
                                                                                  1421 1422 1422 1427* 1427 1428 1428 1431 1432
                                                                                  1435* 1435
sbi                                    parameter       fixed bin(17,0)          dcl 1233 in procedure "move_db_to_file" set ref 1229
                                                                                  1236*
se_len                          000215 automatic       fixed bin(17,0)          dcl 1614 set ref 351* 361* 408*
se_len_ptr                      000260 automatic       pointer                  dcl 1659 set ref 360* 361
se_ptr                          000200 automatic       pointer                  dcl 1600 set ref 351* 360 408*
se_transaction_id       116            based           bit(36)                  level 3 dcl 5-142 ref 414 414
seg_fault_error                 000000 stack reference condition                dcl 1651 ref 1461
select_area_ptr          36            based           pointer                  level 3 dcl 5-142 set ref 1345*
select_list                            based           structure                level 1 unaligned dcl 10-22
select_list_ptr                 000156 automatic       pointer                  initial dcl 10-38 set ref 431* 445* 463 469 473 499*
                                                                                  10-38* 685 687 689 690 691 754* 759 762 766 766
                                                                                  769 1124* 1303 1307 1311 1311 1330 1333 1355 1355
select_ptr                4            based           pointer                  level 3 in structure "dbcb" dcl 5-142 in procedure
                                                                                  "retrieve" set ref 431 445 754 1124*
select_ptr                             based           pointer                  array level 3 in structure "select_sets" dcl 13-3
                                                                                  in procedure "retrieve" ref 1124
select_sets                            based           structure                level 1 dcl 13-3
set_info                        000010 internal static structure                level 1 dcl 1536
simple_typed_vector                    based           structure                level 1 packed packed unaligned dcl 18-17
simple_typed_vector_ptr         000176 automatic       pointer                  dcl 18-33 set ref 695* 698
so_ptr                   10            based           pointer                  level 3 in structure "dbcb" dcl 5-142 in procedure
                                                                                  "retrieve" set ref 1121*
so_ptr                                 based           pointer                  array level 3 in structure "select_sets" dcl 13-3
                                                                                  in procedure "retrieve" ref 1121
ss_item_num                     000015 internal static fixed bin(17,0)          array level 2 dcl 1547 set ref 926* 1118 1186* 1392*
                                                                                  1415* 1422* 1427* 1428*
ss_ptr                   20            based           pointer                  level 3 in structure "dbcb" dcl 5-142 in procedure
                                                                                  "retrieve" ref 426 427 564
ss_ptr                          000166 automatic       pointer                  dcl 13-21 in procedure "retrieve" set ref 427* 564*
                                                                                  1119 1121 1122 1124 1135 1388 1400 1401
ssi                       1     000010 internal static fixed bin(17,0)          level 2 dcl 1536 set ref 1380* 1388 1389* 1389 1392
                                                                                  1399* 1399 1400 1401
st_entry                        000247 automatic       bit(1)                   packed unaligned dcl 1641 set ref 332* 562* 1445
static_area             306            based           area                     level 2 dcl 5-142 ref 466 807 856 1096
static_data                            based           varying char             dcl 1534 set ref 494* 628 633*
static_data_ptr          42            based           pointer                  level 3 dcl 5-142 ref 494 628 633
string                                                 builtin function         dcl 1622 ref 480
substr                                                 builtin function         dcl 1622 set ref 596 598 599 709* 710* 898 898 901
                                                                                  905 905 988 988 992 996 996 1080
sys_info$max_seg_size           000202 external static fixed bin(35,0)          dcl 1572 ref 400 494 568 625 633 635 645 648 938 944
                                                                                  946 952 1040 1043 1197 1203 1205 1207 1212 1246
                                                                                  1248 1249 1277 1280 1281
td_ptr                          000336 automatic       pointer                  dcl 670 set ref 698* 703 705 709
ti_ptr                          000160 automatic       pointer                  dcl 11-17 in procedure "retrieve" set ref 443* 693
                                                                                  693 695 1122* 1334 1334 1345 1345 1355
ti_ptr                                 based           pointer                  array level 3 in structure "select_sets" dcl 13-3
                                                                                  in procedure "retrieve" ref 1122
ti_ptr                   12            based           pointer                  level 3 in structure "dbcb" dcl 5-142 in procedure
                                                                                  "retrieve" set ref 443 1122*
to_fdx                                 parameter       fixed bin(17,0)          dcl 1264 set ref 1260 1280* 1281*
transaction_manager_$abandon_txn
                                000120 constant        entry                    external dcl 1-72 ref 4-72 4-86 4-100 4-110 1-110
transaction_manager_$abort_txn  000122 constant        entry                    external dcl 1-73 ref 4-71 4-85 4-99 4-109 1-109
transaction_manager_$begin_txn  000124 constant        entry                    external dcl 1-74 ref 1-99
transaction_manager_$commit_txn 000136 constant        entry                    external dcl 4-56 ref 4-68
transaction_manager_$get_current_txn_id
                                000126 constant        entry                    external dcl 1-75 ref 1-89
transaction_manager_$handle_conditions
                                000130 constant        entry                    external dcl 1-76 ref 1-135
transaction_manager_$rollback_txn
                                000140 constant        entry                    external dcl 4-57 ref 4-82 4-96
transactions_needed     106(13)        based           bit(1)                   level 3 packed packed unaligned dcl 5-142 ref 382
tup_data                               based           bit                      packed unaligned dcl 672 ref 709
tup_var                   2            based           structure                array level 2 dcl 9-5
tuple                     2            based           structure                array level 2 dcl 11-10
tuple_id                  4            based           bit(36)                  array level 3 dcl 11-10 set ref 1345*
tuple_info                             based           structure                level 1 dcl 11-10
tuple_ptr                 2            based           pointer                  array level 3 dcl 11-10 set ref 695 1345* 1355*
type                      0(01)        based           fixed bin(6,0)           level 2 packed packed unsigned unaligned dcl 16-6
                                                                                  ref 359
unique_chars_                   000266 constant        entry                    external dcl 791 ref 812
unique_count              2            based           fixed bin(17,0)          level 2 dcl 14-7 set ref 496* 627 636* 649* 649
user_desc_ptr            14            based           pointer                  array level 3 dcl 10-22 set ref 1311*
user_ptr                 16            based           pointer                  array level 3 dcl 10-22 set ref 1311*
user_started_transaction
                        106(22)        based           bit(1)                   level 3 in structure "dbcb" packed packed unaligned
                                                                                  dcl 5-142 in procedure "retrieve" set ref 398*
user_started_transaction        000104 automatic       bit(1)                   dcl 1-69 in procedure "retrieve" set ref 1-92* 1-98*
                                                                                  398 4-60
user_transaction_id             000106 automatic       bit(36)                  dcl 1-71 set ref 1-93* 1-100* 414
val_rtrv                106(09)        based           bit(1)                   level 3 packed packed unaligned dcl 5-142 ref 411
value_ptr                 1            based           pointer                  array level 3 packed packed unaligned dcl 18-17 set
                                                                                  ref 698 771*
var_index                 5            based           fixed bin(17,0)          array level 3 in structure "tuple_info" dcl 11-10
                                                                                  in procedure "retrieve" ref 693 1334
var_index                              based           fixed bin(17,0)          array level 2 in structure "move_list_array"
                                                                                  dcl 10-40 in procedure "retrieve" ref 1333 1355
var_index                11            based           fixed bin(17,0)          array level 3 in structure "select_list" dcl 10-22
                                                                                  in procedure "retrieve" ref 689 690 691 766 766
var_index                       000632 automatic       fixed bin(17,0)          dcl 1367 in procedure "return_data_tup" set ref
                                                                                  1333* 1334 1337 1339 1345 1345 1352 1353
version                                based           fixed bin(35,0)          level 2 dcl 14-7 set ref 1097*
work_area_ptr            70            based           pointer                  level 3 dcl 5-142 set ref 405* 1311* 1355*
x                               000546 automatic       fixed bin(17,0)          dcl 1107 in procedure "init_search" set ref 1118*
                                                                                  1119 1121 1122 1124
x                                      parameter       fixed bin(17,0)          dcl 785 in procedure "create_temp_file" set ref 781
                                                                                  800* 802 803* 805 808 810
x                                      parameter       fixed bin(17,0)          dcl 830 in procedure "delete_temp_file" ref 828 835
                                                                                  836 857

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALL_OP                                 internal static bit(6)                   initial packed unaligned dcl 17-44
AND_OP                                 internal static bit(6)                   initial packed unaligned dcl 17-44
ARRAY                                  internal static fixed bin(17,0)          initial dcl 17-60
ATTR                                   internal static fixed bin(17,0)          initial dcl 17-56
CONST                                  internal static fixed bin(17,0)          initial dcl 17-56
CURRENT_OP                             internal static bit(6)                   initial packed unaligned dcl 17-44
DIFFERENCE                             internal static fixed bin(17,0)          initial dcl 13-26
EQ_OP                                  internal static bit(6)                   initial packed unaligned dcl 17-44
EXPRES                                 internal static fixed bin(17,0)          initial dcl 17-56
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 18-43
GE_OP                                  internal static bit(6)                   initial packed unaligned dcl 17-44
GT_OP                                  internal static bit(6)                   initial packed unaligned dcl 17-44
HIGHEST_MODE                           internal static fixed bin(17,0)          initial dcl 2-12
INTERSECTION                           internal static fixed bin(17,0)          initial dcl 13-25
LEAF                                   internal static fixed bin(17,0)          initial dcl 17-60
LE_OP                                  internal static bit(6)                   initial packed unaligned dcl 17-44
LOWEST_MODE                            internal static fixed bin(17,0)          initial dcl 2-12
LT_OP                                  internal static bit(6)                   initial packed unaligned dcl 17-44
NE_OP                                  internal static bit(6)                   initial packed unaligned dcl 17-44
NODE                                   internal static fixed bin(17,0)          initial dcl 17-60
NOT_OP                                 internal static bit(6)                   initial packed unaligned dcl 17-44
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 18-43
OR_OP                                  internal static bit(6)                   initial packed unaligned dcl 17-44
SIMPLE_TYPED_VECTOR_TYPE               internal static fixed bin(17,0)          initial dcl 18-43
TM_NEVER_WRITE_MODE                    internal static fixed bin(17,0)          initial dcl 2-18
TM_READ_ONLY_MODE                      internal static fixed bin(17,0)          initial dcl 2-17
TM_STATISTICAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-16
TM_TEST_NEVER_WRITE_MODE               internal static fixed bin(17,0)          initial dcl 2-22
TM_TEST_NORMAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-19
TM_TEST_READ_ONLY_MODE                 internal static fixed bin(17,0)          initial dcl 2-21
TM_TEST_STATISTICAL_MODE               internal static fixed bin(17,0)          initial dcl 2-20
UNION                                  internal static fixed bin(17,0)          initial dcl 13-24
V_C                                    internal static fixed bin(5,0)           initial dcl 17-64
V_V                                    internal static fixed bin(5,0)           initial dcl 17-64
ag_ptr                                 automatic       pointer                  dcl 17-40
and_group                              based           structure                level 1 unaligned dcl 17-36
condition_info_ptr                     automatic       pointer                  dcl 3-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 3-30
error_table_$null_info_ptr             external static fixed bin(35,0)          dcl 1-63
fixed                                                  builtin function         dcl 1622
general_typed_vector                   based           structure                level 1 packed packed unaligned dcl 18-24
general_typed_vector_ptr               automatic       pointer                  dcl 18-38
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 18-40
natts_init                             automatic       fixed bin(17,0)          dcl 6-157
nitems_init                            automatic       fixed bin(17,0)          dcl 13-22
nkey_attr_init                         automatic       fixed bin(17,0)          dcl 6-157
num_ands_init                          automatic       fixed bin(17,0)          dcl 17-41
num_terms_init                         automatic       fixed bin(17,0)          dcl 17-41
nvar_atts_init                         automatic       fixed bin(17,0)          dcl 6-157
pl_ptr                                 automatic       pointer                  dcl 17-84
pn_ptr                                 automatic       pointer                  dcl 17-27
pred_node                              based           structure                level 1 unaligned dcl 17-12
pred_ptr                               automatic       pointer                  dcl 17-34
rel                                                    builtin function         dcl 1622
stv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 18-35
ti_ntuples_init                        automatic       fixed bin(17,0)          dcl 11-18

NAMES DECLARED BY EXPLICIT CONTEXT.
BEGIN_RETURN_DATA_TUP           007253 constant        label                    dcl 1330 ref 1357
START_RETURN_DATA_TEMP          007153 constant        label                    dcl 1303 set ref 1315
add_record                      002171 constant        entry                    internal dcl 579 ref 633 635 648 1207 1249 1281
another                         002421 constant        entry                    internal dcl 611 ref 486
build_data_string               002704 constant        entry                    internal dcl 664 ref 494 625 1028 1246
build_vector_from_string        003227 constant        entry                    internal dcl 721 ref 573
case                            000000 constant        label                    array(3) dcl 1149 ref 1147
case_out                        006120 constant        label                    dcl 1158 ref 1150 1153 1156
clean_up_per_call_area          010247 constant        entry                    internal dcl 1474 ref 516 547 1465
clean_up_temp_files             010277 constant        entry                    internal dcl 1488 ref 420 1463
cleanup_handler                 010202 constant        entry                    internal dcl 1457 ref 390 1451
create_temp_file                003347 constant        entry                    internal dcl 781 ref 632 925 1185 1193 1426
delete_temp_file                003676 constant        entry                    internal dcl 828 ref 960 1137 1219 1495
delete_temp_record              004167 constant        entry                    internal dcl 881 ref 946
difference                      004442 constant        entry                    internal dcl 920 ref 1155 1170
dup_check                       004771 constant        entry                    internal dcl 969 ref 645 944 1203 1205 1248 1280
error                           010147 constant        entry                    internal dcl 1441 ref 349 352 1-140 402 406 410 411
                                                                                  414 439 507 570 590 597 607 657 713 763 805 819
                                                                                  855 872 916 957 989 1024 1031 1048 1114 1135 1216
                                                                                  1256 1273 1285 1318 1344 1351 1357
exit                            001423 constant        label                    dcl 518 ref 1452
get_data                        005227 constant        entry                    internal dcl 1007 ref 938 952 1197 1212
get_out                         010243 constant        label                    dcl 1467 ref 1461
get_resultant_dir               004121 constant        entry                    internal dcl 861 ref 814 845 845 846 846
get_set_another                 005354 constant        entry                    internal dcl 1038 ref 434
get_temp_record                 005456 constant        entry                    internal dcl 1056 ref 568 1023 1040 1277
init                            005630 constant        entry                    internal dcl 1088 ref 380 563
init_search                     005676 constant        entry                    internal dcl 1105 ref 936 1195 1236
init_set                        006034 constant        entry                    internal dcl 1131 ref 428 566
intersection                    006161 constant        entry                    internal dcl 1180 ref 1152 1167
kase                            000003 constant        label                    array(3) dcl 1164 ref 1162
kase_out                        006132 constant        label                    dcl 1173 ref 1165 1168 1171
mftxn_check_code                001443 constant        label                    dcl 4-65 ref 1-127 1-133
mftxn_exit                      001663 constant        label                    dcl 4-115 ref 4-63
move_db_to_file                 006550 constant        entry                    internal dcl 1229 ref 926 1186 1415 1422 1427 1428
move_file_to_file               006731 constant        entry                    internal dcl 1260 ref 1412
mrds_dsl_retrieve               000125 constant        entry                    external dcl 32
mstxn_any_other                 002051 constant        entry                    internal dcl 1-116 ref 392
mstxn_cleanup                   002017 constant        entry                    internal dcl 1-102 ref 389
mstxn_exit                      000535 constant        label                    dcl 1-140 ref 1-86 1-95 4-91 4-105
restore_significant_data        002155 constant        entry                    internal dcl 541 ref 4-77
retrieve                        000115 constant        entry                    external dcl 32
return_data_temp                007132 constant        entry                    internal dcl 1289 ref 1043
return_data_tup                 007252 constant        entry                    internal dcl 1326 ref 502
set_tuple                       001674 constant        entry                    external dcl 551
setup_set_info                  007655 constant        entry                    internal dcl 1371 ref 1143 1158
should_rollback                 002146 constant        entry                    internal dcl 532 ref 4-94
st_exit                         002016 constant        label                    dcl 576 ref 1447
union                           007763 constant        entry                    internal dcl 1406 ref 1149 1164

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11446       11746   10364       11456
Length     12776   10364       300        1014    1062         102

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
retrieve                           1120 external procedure  is an external procedure.  
on unit on line 388                  76 on unit               
on unit on line 392                  82 on unit               
mstxn_cleanup                           internal procedure  shares stack frame of on unit on line 388.  
mstxn_any_other                         internal procedure  shares stack frame of on unit on line 392.  
should_rollback                         internal procedure  shares stack frame of external procedure retrieve.  
restore_significant_data                internal procedure  shares stack frame of external procedure retrieve.  
add_record                              internal procedure  shares stack frame of external procedure retrieve.  
another                                 internal procedure  shares stack frame of external procedure retrieve.  
build_data_string                       internal procedure  shares stack frame of external procedure retrieve.  
build_vector_from_string                internal procedure  shares stack frame of external procedure retrieve.  
create_temp_file                        internal procedure  shares stack frame of external procedure retrieve.  
delete_temp_file                    142 internal procedure  is called by several nonquick procedures.  
begin block on line 842                 begin block         shares stack frame of internal procedure delete_temp_file.  
get_resultant_dir                   114 internal procedure  is called by several nonquick procedures.  
delete_temp_record                      internal procedure  shares stack frame of external procedure retrieve.  
difference                              internal procedure  shares stack frame of external procedure retrieve.  
dup_check                               internal procedure  shares stack frame of external procedure retrieve.  
get_data                                internal procedure  shares stack frame of external procedure retrieve.  
get_set_another                         internal procedure  shares stack frame of external procedure retrieve.  
get_temp_record                         internal procedure  shares stack frame of external procedure retrieve.  
init                                    internal procedure  shares stack frame of external procedure retrieve.  
init_search                             internal procedure  shares stack frame of external procedure retrieve.  
init_set                                internal procedure  shares stack frame of external procedure retrieve.  
intersection                            internal procedure  shares stack frame of external procedure retrieve.  
move_db_to_file                         internal procedure  shares stack frame of external procedure retrieve.  
move_file_to_file                       internal procedure  shares stack frame of external procedure retrieve.  
return_data_temp                        internal procedure  shares stack frame of external procedure retrieve.  
return_data_tup                         internal procedure  shares stack frame of external procedure retrieve.  
setup_set_info                          internal procedure  shares stack frame of external procedure retrieve.  
union                                   internal procedure  shares stack frame of external procedure retrieve.  
error                                64 internal procedure  is called by several nonquick procedures.  
cleanup_handler                      70 internal procedure  enables or reverts conditions.  
on unit on line 1461                 64 on unit               
clean_up_per_call_area               68 internal procedure  is called by several nonquick procedures.  
clean_up_temp_files                  72 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 set_info                    retrieve
000015 sb                          retrieve
000111 fdx                         another

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
delete_temp_file         000100 file_name                   delete_temp_file
get_resultant_dir        000100 pathname                    get_resultant_dir
retrieve                 000100 mstxn_code                  retrieve
                         000101 mstxn_retries               retrieve
                         000102 mstxn_temp_code             retrieve
                         000103 mstxn_transactions_needed   retrieve
                         000104 user_started_transaction    retrieve
                         000105 mstxn_txn_id                retrieve
                         000106 user_transaction_id         retrieve
                         000110 mstxn_condition_info        retrieve
                         000142 mftxn_code                  retrieve
                         000143 mftxn_temp_code             retrieve
                         000144 dbcb_ptr                    retrieve
                         000146 rmri_ptr                    retrieve
                         000150 rai_ptr                     retrieve
                         000152 rdi_ptr                     retrieve
                         000154 range_ptr                   retrieve
                         000156 select_list_ptr             retrieve
                         000160 ti_ptr                      retrieve
                         000162 al_ptr                      retrieve
                         000164 num_ptrs                    retrieve
                         000166 ss_ptr                      retrieve
                         000170 fd_ptr                      retrieve
                         000172 desc_ptr                    retrieve
                         000174 num_dims                    retrieve
                         000176 simple_typed_vector_ptr     retrieve
                         000200 se_ptr                      retrieve
                         000202 cd_ptr                      retrieve
                         000204 dbi_ptr                     retrieve
                         000206 appl_ptr                    retrieve
                         000210 adpl_ptr                    retrieve
                         000212 icode                       retrieve
                         000213 rec_len                     retrieve
                         000214 nargs                       retrieve
                         000215 se_len                      retrieve
                         000216 arg_len                     retrieve
                         000217 number_of_and_groups        retrieve
                         000220 num_args                    retrieve
                         000221 num_tuples_retrieved        retrieve
                         000222 i                           retrieve
                         000246 dup_flag                    retrieve
                         000247 st_entry                    retrieve
                         000250 original_appl_ptr           retrieve
                         000252 original_adpl_ptr           retrieve
                         000254 original_num_args           retrieve
                         000255 clean_up_condition          retrieve
                         000256 area_ptr                    retrieve
                         000260 se_len_ptr                  retrieve
                         000262 found                       retrieve
                         000263 j                           retrieve
                         000264 key_used_len                retrieve
                         000266 key_used_ptr                retrieve
                         000270 dbi_pic                     retrieve
                         000316 key_only                    add_record
                         000334 bs_ptr                      build_data_string
                         000336 td_ptr                      build_data_string
                         000340 cur_pos                     build_data_string
                         000341 old_vi                      build_data_string
                         000342 j                           build_data_string
                         000343 i                           build_data_string
                         000344 actual_len                  build_data_string
                         000356 cur_pos                     build_vector_from_string
                         000357 old_vi                      build_vector_from_string
                         000360 i                           build_vector_from_string
                         000361 bit_string_len              build_vector_from_string
                         000362 bit_string_ptr              build_vector_from_string
                         000374 atd                         create_temp_file
                         000456 number                      create_temp_file
                         000466 new_key                     delete_temp_record
                         000467 rec_found                   delete_temp_record
                         000504 new_key                     dup_check
                         000546 x                           init_search
                         000610 bs_ptr                      return_data_temp
                         000612 cur_pos                     return_data_temp
                         000613 len                         return_data_temp
                         000614 i                           return_data_temp
                         000624 icode                       return_data_tup
                         000626 cursor_ptr                  return_data_tup
                         000630 i                           return_data_tup
                         000631 j                           return_data_tup
                         000632 var_index                   return_data_tup
                         000644 ix                          setup_set_info

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_le_a              alloc_char_temp     cat_realloc_chars   call_ent_var        call_ext_out_desc
call_ext_out        call_int_this       call_int_other      return_mac          tra_ext_1           signal_op
enable_op           shorten_stack       ext_entry           int_entry           ceil_fx2            index_bs_1_eis
divide_fx3          op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
continue_to_signal_           cu_$arg_list_ptr              cu_$arg_ptr                   find_condition_info_
hcs_$del_dir_tree             hcs_$delentry_file            iox_$attach_ioname            iox_$close
iox_$delete_record            iox_$destroy_iocb             iox_$detach_iocb              iox_$open
iox_$position                 iox_$read_key                 iox_$read_record              iox_$seek_key
iox_$write_record             mrds_dsl_resultant_storage$get_opening_temp_dir             mrds_dsl_search
mrds_dsl_translate            mu_cursor_manager_$get        mu_data_class$bit             mu_data_class$varying
mu_database_index$get_resultant_model_pointer               mu_define_area$define_spec_temp_dir_area
mu_define_area$define_temp_dir_area                         mu_get_data$get_data          mu_get_data$get_data_item
mu_release_area               transaction_manager_$abandon_txn
transaction_manager_$abort_txn                              transaction_manager_$begin_txn
transaction_manager_$commit_txn                             transaction_manager_$get_current_txn_id
transaction_manager_$handle_conditions                      transaction_manager_$rollback_txn
unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bj_journal_full     dm_error_$lock_deadlock       dm_error_$no_current_transaction
error_table_$end_of_info      error_table_$no_record        error_table_$noalloc          error_table_$notadir
mrds_data_$caller_retrieve    mrds_data_$max_attributes     mrds_data_$max_data_length    mrds_data_$max_id_len
mrds_data_$max_select_items   mrds_data_$max_sets           mrds_error_$incomp_se_and_scope
mrds_error_$inconsistent_transaction_se                     mrds_error_$inval_rtrv_expr   mrds_error_$invalid_db_index
mrds_error_$max_retr_len      mrds_error_$no_dups_for_set_oper
mrds_error_$too_many_temp_files                             mrds_error_$tuple_not_found   sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 7   65 000104    8   51 000106   10   38 000107   16   20 000110      1650 000111        32 000114       330 000133
    331 000136       332 000137       333 000140       334 000147       336 000156       337 000162       341 000167
    342 000200       345 000204       346 000221       348 000226       349 000245       351 000255       352 000274
    355 000304       357 000320       359 000325       360 000332       361 000335       365 000343       369 000346
    370 000357       372 000364       374 000367       375 000400       376 000404       377 000407       380 000410
    382 000411       384 000416       385 000420       386 000422       388 000424       389 000440       390 000441
    391 000446       392 000447    1   83 000465    1   84 000466    1   86 000467    1   88 000471    1   89 000472
 1   90 000503    1   92 000507    1   93 000511    1   94 000513    1   95 000514    1   98 000515    1   99 000516
 1  100 000533    1  140 000535       398 000545       399 000553       400 000563       402 000631       403 000641
    405 000644       406 000670       408 000700       410 000727       411 000737       413 000752       414 000757
    418 000775       419 000776       420 001001       421 001005       426 001011       427 001016       428 001020
    431 001024       434 001027       435 001030       438 001031       439 001044       441 001054       443 001063
    444 001065       445 001067       448 001071       454 001102       456 001110       459 001113       462 001124
    463 001164       464 001171       466 001172       467 001202       469 001215       470 001225       472 001226
    473 001237       474 001253       475 001255       477 001262       478 001264       480 001266       481 001301
    483 001312       486 001316       489 001323       493 001324       494 001333       496 001354       498 001360
    499 001361       502 001366       503 001367       507 001370       510 001402       512 001416       516 001417
    518 001423       523 001433    4   60 001434    4   62 001441    4   63 001442    4   65 001443    4   68 001445
 4   69 001456    4   71 001460    4   72 001471    4   75 001504    4   77 001505    4   78 001506    4   81 001515
 4   82 001516    4   83 001531    4   85 001533    4   86 001544    4   88 001557    4   90 001560    4   91 001561
 4   93 001562    4   94 001563    4   96 001570    4   97 001604    4   99 001606    4  100 001617    4  102 001632
 4  104 001633    4  105 001634    4  107 001635    4  109 001636    4  110 001647    4  114 001662    4  115 001663
    530 001666       551 001667       560 001702       561 001706       562 001711       563 001713       564 001714
    565 001717       566 001723       568 001724       569 001756       570 001764       571 001774       572 001775
    573 002000       574 002014       576 002016    1  102 002017    1  107 002020    1  109 002023    1  110 002034
 1  114 002050    1  116 002051    1  121 002052    1  123 002055    1  124 002074    1  126 002102    1  127 002105
 1  129 002110    1  132 002122    1  133 002125    1  135 002130    1  136 002135    1  137 002136    1  138 002145
    532 002146       537 002150       541 002155       543 002156       544 002160       545 002162       547 002164
    549 002170       579 002171       585 002202       586 002210       588 002216       589 002221       590 002246
    591 002262       592 002270       593 002302       594 002303       596 002304       597 002326       598 002342
    599 002352       600 002361       603 002364       604 002371       605 002407       606 002411       607 002412
    609 002420       611 002421       622 002422       624 002424       625 002430       627 002452       628 002457
    632 002467       633 002476       635 002524       636 002552       637 002556       641 002560       644 002561
    645 002563       647 002617       648 002622       649 002650       656 002653       657 002672       659 002702
    661 002703       664 002704       680 002715       682 002717       683 002725       685 002726       687 002740
    689 002744       690 002751       691 002753       693 003014       694 003030       695 003035       698 003042
    701 003052       703 003072       705 003125       706 003136       707 003137       709 003142       710 003150
    712 003164       713 003170       715 003203       717 003210       719 003226       721 003227       751 003231
    752 003242       754 003244       756 003247       757 003251       759 003252       762 003262       763 003271
    766 003303       769 003315       771 003317       774 003334       775 003341       777 003346       781 003347
    800 003351       802 003352       803 003366       804 003400       805 003402       807 003414       808 003426
    810 003434       812 003445       814 003505       816 003574       817 003625       819 003647       822 003657
    823 003671       824 003673       826 003674       828 003675       835 003703       836 003716       837 003721
    839 003724       840 003734       841 003751       842 003766       845 003771       846 004022       855 004062
    856 004076       857 004106       859 004117       861 004120       871 004126       872 004142       877 004155
    879 004163       881 004167       887 004200       889 004207       890 004213       891 004240       893 004254
    896 004255       898 004260       899 004302       900 004310       901 004326       903 004340       904 004344
    905 004367       909 004405       910 004406       911 004410       913 004426       916 004431       918 004441
    920 004442       922 004443       924 004446       925 004453       926 004461       927 004501       930 004506
    931 004516       933 004535       936 004542       938 004550       940 004602       942 004604       944 004605
    945 004641       946 004645       949 004673       952 004676       955 004730       957 004731       958 004743
    960 004744       962 004760       963 004763       967 004770       969 004771       976 005002       977 005011
    979 005015       980 005021       981 005046       983 005055       986 005056       988 005057       989 005101
    990 005114       991 005126       992 005144       994 005156       995 005162       996 005205      1000 005225
   1004 005226      1007 005227      1022 005240      1023 005251      1024 005273      1025 005307      1027 005310
   1028 005322      1031 005337      1032 005351      1036 005353      1038 005354      1040 005355      1043 005407
   1045 005434      1048 005441      1050 005451      1052 005452      1054 005455      1056 005456      1063 005467
   1064 005476      1067 005501      1069 005515      1070 005520      1074 005545      1075 005565      1079 005573
   1080 005576      1081 005623      1086 005627      1088 005630      1092 005631      1093 005633      1095 005635
   1096 005641      1097 005653      1098 005655      1099 005665      1100 005673      1103 005675      1105 005676
   1110 005700      1112 005710      1113 005717      1114 005736      1115 005746      1118 005747      1119 005752
   1121 005771      1122 006000      1124 006010      1126 006020      1129 006033      1131 006034      1135 006035
   1136 006047      1137 006057      1139 006074      1141 006076      1143 006102      1145 006103      1147 006110
   1149 006112      1150 006113      1152 006114      1153 006115      1155 006116      1156 006117      1158 006120
   1160 006121      1162 006122      1164 006124      1165 006125      1167 006126      1168 006127      1170 006130
   1171 006131      1173 006132      1176 006141      1178 006160      1180 006161      1182 006162      1184 006165
   1185 006172      1186 006200      1187 006220      1190 006225      1191 006235      1193 006254      1195 006263
   1197 006272      1199 006324      1201 006326      1203 006327      1204 006363      1205 006367      1207 006421
   1209 006452      1212 006455      1214 006507      1216 006510      1217 006522      1219 006523      1221 006537
   1223 006542      1227 006547      1229 006550      1236 006552      1238 006560      1240 006561      1242 006564
   1244 006577      1246 006601      1247 006623      1248 006625      1249 006660      1251 006712      1254 006715
   1256 006716      1258 006730      1260 006731      1269 006733      1271 006741      1273 006761      1275 006771
   1277 006774      1279 007027      1280 007031      1281 007064      1283 007116      1285 007117      1287 007131
   1289 007132      1299 007143      1300 007145      1301 007151      1303 007153      1307 007163      1309 007167
   1311 007172      1315 007225      1318 007232      1320 007240      1322 007244      1324 007251      1326 007252
   1330 007253      1333 007263      1334 007270      1335 007304      1336 007306      1337 007307      1339 007355
   1340 007366      1344 007420      1345 007430      1351 007465      1352 007475      1353 007543      1355 007551
   1357 007637      1361 007652      1369 007654      1371 007655      1377 007656      1379 007665      1380 007667
   1381 007670      1382 007671      1383 007673      1384 007675      1388 007676      1389 007717      1390 007720
   1392 007724      1393 007730      1394 007731      1395 007733      1396 007735      1397 007737      1399 007740
   1400 007741      1401 007751      1404 007762      1406 007763      1408 007764      1410 007767      1411 007776
   1412 010001      1415 010022      1417 010035      1420 010036      1421 010043      1422 010045      1423 010064
   1426 010065      1427 010073      1428 010110      1431 010130      1432 010136      1435 010142      1438 010145
   1441 010146      1445 010154      1446 010157      1447 010163      1450 010166      1451 010171      1452 010176
   1457 010201      1459 010207      1461 010212      1463 010231      1465 010236      1467 010243      1470 010245
   1474 010246      1478 010254      1479 010262      1480 010267      1486 010275      1488 010276      1492 010304
   1493 010311      1494 010316      1495 010326      1497 010344      1501 010347


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
