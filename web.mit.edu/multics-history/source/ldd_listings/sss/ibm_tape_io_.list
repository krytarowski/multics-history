	COMPILATION LISTING OF SEGMENT ibm_tape_io_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-01-27_1813.38_Thu_mst
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 
       11 
       12 /****^  HISTORY COMMENTS:
       13*  1) change(88-09-16,Farley), approve(88-10-06,MCR8003),
       14*     audit(88-10-06,Fawcett), install(88-10-10,MR12.2-1152):
       15*     Correct a problem of getting a hardware status of "Transmission parity
       16*     alert" when writing the data to tape in ascii mode.  This requires the
       17*     zeroing of the reserved fields in the RDW, SDW and BDW structures.
       18*  2) change(00-01-26,Schroth), approve(00-01-26,MECR-Y2K):
       19*     Changed expiry date checking to use new pfm_utils_$label_unexpired to
       20*     verify if a file has expired.
       21*                                                   END HISTORY COMMENTS */
       22 
       23 
       24 /****^  HIST
       25*ORY COMMENTS:
       26*  1) change(85-06-10,GWMay), approve(), audit(), install():
       27*     modified call to pfm_utils_$position_in_file to use
       28*     the position constant required by the routine rather than a numeric
       29*     value.
       30*  2) change(88-02-03,GWMay), approve(88-02-03,MCR7837),
       31*     audit(88-04-12,Farley), install(88-04-19,MR12.2-1039):
       32*     Changed to process user specified labels correctly.
       33*     Changed to correctly set the RCP auth code in the header.
       34*                                                   END HISTORY COMMENTS */
       35 
       36 ibm_tape_io_: procedure;
       37 
       38 /* format: style4 */
       39 
       40 /* *	This program is known as a tape Per-Format module and runs under
       41*   *	control of the mtape_ I/O module and is meant to process tape volumes
       42*   *	and files in IBM standard format.
       43*   *
       44*   *	This Per-Format module uses the following PFM dependent option flags:
       45*   *
       46*   *	mtape_open_info.pfm_opt_sw (1) = "1"b = -dos
       47*   *	mtape_open_info.pfm_opt_sw (1) = "0"b = -no_dos
       48*   *	mtape_open_info.pfm_opt_sw (2) = "1"b = -system_use
       49*   *	mtape_open_info.pfm_opt_sw (2) = "0"b = -no_system_use
       50*   *
       51*   *	Modification History:
       52*   *
       53*   *	Created by J. A. Bush 11/01/82
       54*   *	Modified by J. A. Bush 11/10/83 for performance improvements
       55*   *	Modified by Greg Texada 11/21/84 to pad U format records too.
       56**/
       57 
       58 /*		ARGUMENT DATA		*/
       59 
       60 dcl  arg_mtdp ptr;					/* Pointer to the mtape data structure */
       61 dcl  arg_code fixed bin (35);				/* Return error code */
       62 dcl  arg_info_ptr ptr;				/* Pointer to Order data from iox_$control call */
       63 dcl  arg_io_call_infop ptr;				/* Pointer to io_call control info structure */
       64 dcl  arg_order_name char (*);				/* Name of Control order to be processed */
       65 dcl  arg_lr_ptr ptr;				/* Pointer to current label record structure */
       66 dcl  arg_labno fixed bin;				/* label record within label group */
       67 dcl  arg_type fixed bin;				/* 1 => BOF; 2 => EOV; 3 => EOF */
       68 dcl  arg_convert fixed bin;				/* Label record conversion indicator */
       69 
       70 /*		AUTOMATIC DATA		*/
       71 
       72 dcl  Schecked_labels bit (1) aligned;
       73 dcl  buf_ptr ptr;					/* Auto copy of users buffer pointer */
       74 dcl  buf_len fixed bin (21);				/* Auto copy of users lrec buffer */
       75 dcl  rec_len fixed bin (21);				/* Auto copy of logical record length */
       76 dcl  order_name char (32);				/* Auto copy of order name */
       77 dcl  info_ptr ptr;					/* Auto copy of order info pointer */
       78 dcl  user_label_data char (76);			/* storage for user label data */
       79 dcl  auth_code char (3) aligned;
       80 dcl  today char (6);
       81 dcl  temp_fmt char (3);
       82 dcl  temp_mode char (6);
       83 dcl  (term, long_record, output) bit (1) aligned;
       84 dcl  (nvp, nlp, move_ptr) ptr;
       85 dcl  (i, desc_type, label_type, n_segs, uln, open_idx, slab) fixed bin;
       86 dcl  (move_len, crl, bytes_remaining, bytes_processed) fixed bin (21);
       87 dcl  dbl bit (18);
       88 dcl  pic1 picture "9";
       89 dcl  pic2 picture "99";
       90 dcl  pic4 picture "9999";
       91 dcl  pic5 picture "99999";
       92 dcl  pic6 picture "999999";
       93 dcl  (code, fl_code) fixed bin (35);
       94 
       95 /*		CONSTANT DATA		*/
       96 
       97 dcl  myname char (32) int static options (constant) init ("ibm_tape_io_");
       98 dcl  LABEL_LENGTH fixed bin (21) int static options (constant) init (80); /* length of label records in bytes */
       99 dcl  MAX_IBM_RECORD_SIZE fixed bin int static options (constant) init (99999);
      100 dcl  WRITING bit (1) aligned int static options (constant) init ("1"b);
      101 dcl  OPENING bit (1) aligned int static options (constant) init ("0"b);
      102 dcl  NON_MOD_FOUR fixed bin int static options (constant) init (1);
      103 dcl  IBM_ASCII_PAD_CHAR char (1) int static options (constant) init (" ");
      104 dcl  IBM_EBCDIC_PAD_CHAR char (1) int static options (constant) init ("_");
      105 dcl  CW_LENGTH fixed bin int static options (constant) init (4); /* Length of an record and segment descriptors */
      106 dcl  (SEG_B_E init (0),				/* Record begins and ends in this segment */
      107      SEG_B_NE init (1),				/* Record begins but does not end in this segment */
      108      SEG_NB_E init (2),				/* Record ends but does not begin in this segment */
      109      SEG_NB_NE init (3))				/* Record neither begins nor ends in this segment */
      110 	fixed bin int static options (constant);
      111 dcl  U_LABEL_ID (3) char (3) int static options (constant) init
      112 	("UHL", "UTL", "UTL");
      113 dcl  IBM_FORMAT_CODES (0:7) char (3) int static options (constant) init
      114 	("   ", "U  ", "F  ", "V  ", "VS ", "FB ", "VB ", "VBS");
      115 dcl  LC char (26) int static options (constant) init
      116 	("abcdefghijklmnopqrstuvwxyz");
      117 dcl  UC char (26) int static options (constant) init
      118 	("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
      119 
      120 /*		EXTERNAL STATIC DATA	*/
      121 
      122 dcl  error_table_$end_of_info fixed bin (35) ext static;
      123 dcl  error_table_$eov_on_write fixed bin (35) ext static;
      124 dcl  error_table_$long_record fixed bin (35) ext static;
      125 dcl  error_table_$invalid_record_desc fixed bin (35) ext static;
      126 dcl  error_table_$bad_file fixed bin (35) ext static;
      127 dcl  error_table_$no_operation fixed bin (35) ext static;
      128 dcl  error_table_$no_file fixed bin (35) ext static;
      129 dcl  error_table_$no_next_volume fixed bin (35) ext static;
      130 dcl  error_table_$invalid_label_format fixed bin (35) ext static;
      131 dcl  error_table_$unimplemented_version fixed bin (35) ext static;
      132 dcl  error_table_$uninitialized_volume fixed bin (35) ext static;
      133 
      134 /*		BUILTIN FUNCTIONS		*/
      135 
      136 dcl  (addr, binary, bit, copy, fixed, hbound, index, lbound, length,
      137      ltrim, mod, null, rel, size, substr, translate) builtin;
      138 dcl  conversion condition;
      139 
      140 /*		EXTERNAL ENTRIES		*/
      141 
      142 dcl  authenticate_ entry (char (*)) returns (char (3) aligned);
      143 dcl  ebcdic_to_ascii_ entry (char (*), char (*));
      144 dcl  ascii_to_ebcdic_ entry (char (*), char (*));
      145 
      146 /* 		BASED VARIABLES		*/
      147 
      148 dcl  based_area area based (mtape_data.areap);
      149 dcl  based_label_record char (LABEL_LENGTH) based (mtape_label_record.lab_ptr);
      150 dcl  based_lrec_data char (move_len) based;		/* to move data to/from users buffer */
      151 dcl  based_lrec_index (buf_len) char (1) based (mtape_data.arg_buf_ptr); /* to increment users buffer ptr */
      152 
      153 dcl  1 bdw unaligned based (mtape_data.cur_buf_ptr),	/* block descriptor word */
      154        2 length bit (18),				/* binary length of block */
      155        2 reserved fixed bin (17);			/* reserved for future system use (MBZ) */
      156 
      157 dcl  1 vb_record unaligned based (mtape_data.log_record_ptr), /* Template for V/VB formated records */
      158        2 rdw,					/* record descriptor word */
      159          3 length bit (18),				/* binary length of record */
      160          3 reserved fixed bin (17),			/* reserved for future system use (MBZ) */
      161        2 rdata char (move_len);			/* logical record data */
      162 
      163 dcl  1 vbs_record unaligned based (mtape_data.log_record_ptr), /* Template for VS/VBS formated records */
      164        2 sdw,					/* Segment descriptor word */
      165          3 length bit (18),				/* binary length of record */
      166          3 span_indicator fixed bin (8),		/* controls of segments in record */
      167          3 reserved fixed bin (8),			/* reserved for future system use (MBZ) */
      168        2 rdata char (move_len),			/* logical record data */
      169        2 nxt_lrec char (1);				/* to position to nxt record */
      170 
      171 /* pfm_init - entry to initialize the Per-Format module, setting up file and volume
      172*   processing parameters and determining correctness of current volume */
      173 
      174 pfm_init: entry (arg_mtdp, arg_code);
      175 
      176 	call SETUP;				/* initialize our enviornment */
      177 	call CHECK_VERSION (mtdp, mtape_data_version_1, "mtape_data"); /* check version of this structure every time */
      178 
      179 /* When the pfm_init entry is called for the first time we must allocate a label record structure to
      180*   read tape labels into. We must also check the various structure versions to make sure
      181*   we know what the caller is talking about. */
      182 
      183 	if mtape_data.tlb = null then do;
      184 	     mcip = mtape_data.close_info_ptr;		/* set ptr to close into structure */
      185 	     call pfm_utils_$init_label_record (mtdp, null, null, mtape_data.tlb, LABEL_LENGTH);
      186 	     mtape_data.tlb -> mtape_label_record.conversion = MTAPE_CV_UC_EBCDIC; /* IBM labels in EBCDIC */
      187 	     call CHECK_VERSION (mtape_data.tlb, mtape_lr_version_1, "mtape_label_record");
      188 	     call CHECK_VERSION (vs_ptr, mtape_vs_version_1, "mtape_vol_set");
      189 	     call CHECK_VERSION (maip, mtape_attach_info_version_1, "mtape_attach_info");
      190 	     call CHECK_VERSION (moip, mtape_open_info_version_1, "mtape_open_info");
      191 	     call CHECK_VERSION (mcip, mtape_close_info_version_1, "mtape_close_info");
      192 	     call CHECK_VERSION (mpfmip, mtape_pfm_info_version_1, "mtape_pfm_info");
      193 	     call mtape_$alloc (mtdp, MTAPE_ALLOC_FI, null, 0, fi_ptr); /* allocate dummy file_info structure */
      194 	     call CHECK_VERSION (fi_ptr, mtape_fi_version_1, "mtape_file_info"); /* and check its version */
      195 	     free mtape_file_info in (based_area);	/* we can free it now */
      196 
      197 /* initialize the pfm_info structure for this PFM */
      198 
      199 	     mtape_pfm_info.open_modes_allowed (1) = Sequential_input;
      200 	     mtape_pfm_info.open_modes_allowed (2) = Sequential_output;
      201 	     mtape_pfm_info.bof_prefix = "HDR";
      202 	     mtape_pfm_info.eov_prefix = "EOV";
      203 	     mtape_pfm_info.eof_prefix = "EOF";
      204 	     mtape_pfm_info.module_id = "IBM";
      205 	     mtape_pfm_info.no_labels_ok = "1"b;
      206 	     mtape_pfm_info.multi_volumes_ok = "1"b;
      207 	     mtape_pfm_info.extended_error_recovery = "0"b;
      208 	end;
      209 	if mtape_vol_set.volume_type = Volume_ibm_tape then /* If an ibm tape.. */
      210 	     call CHECK_VOL_LABELS (mtape_vol_set.volume_check); /* check the volume labels */
      211 	else do;					/* Not an ibm tape, don't bother to read labels */
      212 	     if mtape_vol_set.volume_type = Volume_blank |
      213 		mtape_vol_set.volume_type = Volume_unreadable then
      214 		mtape_vol_set.volume_check = BLANK_VOLUME;
      215 	     else if mtape_vol_set.volume_type = Volume_unknown_format then
      216 		mtape_vol_set.volume_check = UNLABELED_VOLUME;
      217 	     else mtape_vol_set.volume_check = RECOG_FORMAT_VOLUME;
      218 	     mtape_data.lab_buf_len = LABEL_LENGTH;	/* set in case subsequent volumes are labeled */
      219 	end;
      220 
      221 pfm_init_return:					/* target of non-local gotos */
      222 	arg_code = code;
      223 	return;
      224 
      225 /* file_open - entry to do format specific processing in opening the file
      226*   or file set (i.e. read and write file labels) */
      227 
      228 file_open: entry (arg_mtdp, arg_code);
      229 
      230 	call SETUP;				/* initialize our enviornment */
      231 	call SET_OPEN_IDX;				/* determine what type of processing to do */
      232 	call pfm_utils_$file_search (mtdp, fi_ptr, vs_ptr, code); /* search for the file */
      233 	if code ^= 0 & open_idx ^= 1 then		/* if error and not creating file.. */
      234 	     go to open_return;			/* quit now */
      235 	go to open_action (open_idx);			/* do the appropriate thing */
      236 
      237 open_action (0):					/* open for input */
      238 	call CHECK_USER_LABELS (BOF_LABEL);		/* go see if user labels to be processed */
      239 	call SET_FILE_ATTRIBUTES;			/* complete file attributes from open desc */
      240 	go to open_return;
      241 
      242 open_action (1):					/* Open for output, creation */
      243 	if code = 0 |				/* if no error */
      244 	     code = error_table_$no_file |		/* or if could not find file */
      245 	     code = error_table_$uninitialized_volume then do; /* or if bad vol label */
      246 	     if NEED_TO_INIT_VOLUME () then do;		/* if volume requires initialization.. */
      247 		call INIT_VOL_LABELS;		/* initialize the volume labels */
      248 		if code ^= 0 then go to open_return;
      249 	     end;
      250 	     code = 0;				/* reset possible error code */
      251 	     call SETUP_NEW_FILE;			/* setup new file info structure */
      252 	     if code ^= 0 then go to open_return;
      253 	     call pfm_utils_$write_file_labels (mtdp, BOF_LABEL, code); /* go write the file header labels */
      254 	     if code = 0 then			/* if no error */
      255 		if mtape_vol_set.volume_end then	/* did we run out of tape? */
      256 		     call EOV_ON_WRITE (OPENING);	/* yes, do volume switch now */
      257 	end;
      258 	go to open_return;
      259 
      260 open_action (2):					/* open for output, extend existing file */
      261 	mtape_data.phy_block = mtape_file_info.block_count; /* preset block number */
      262 open_action (3):					/* open for output, modify existing file */
      263 	call pfm_utils_$truncate_file_set (mtdp);	/* get rid of EOF labels if extend | modify */
      264 	mtape_file_info.gen_version = mod (mtape_file_info.gen_version, 100) + 1; /* increment version */
      265 open_return:
      266 	arg_code = code;				/* return error code */
      267 
      268 	return;
      269 
      270 /* file_close - entry to do format specific processing in closing the file
      271*   or file set (i.e. read and write file trailer labels) */
      272 
      273 file_close: entry (arg_mtdp, arg_code);
      274 
      275 	call SETUP;				/* initialize our enviornment */
      276 	mcip = mtape_data.close_info_ptr;		/* set up close info ptr too */
      277 
      278 	if mtape_open_info.open_mode = Sequential_input then /* input operation? */
      279 	     output = "0"b;				/* yes, reset output flag */
      280 	else output = "1"b;				/* true if sqo or sqio */
      281 	if output & mtape_data.error_lock ^= error_table_$no_next_volume then do; /* if writing tape */
      282 	     if mtape_data.error_lock = 0 then do;	/* flush out only if possible */
      283 		if mtape_data.processed > mtape_data.buffer_offset then /* if we have some unwritten data */
      284 		     call WRITE_BLOCK;		/* write a short block */
      285 		call mtape_$flush_buffers (mtdp, code); /* write out all queued buffers */
      286 		if code ^= 0 then			/* if some error writing data */
      287 		     if code = error_table_$eov_on_write then /* Is it end of tape? */
      288 			call EOV_ON_WRITE (WRITING);	/* Go close out volume and initiate volume switch */
      289 		if code ^= 0 then
      290 		     go to close_file_return;
      291 	     end;
      292 	     call pfm_utils_$write_file_labels (mtdp, EOF_LABEL, code); /* write out EOF labels */
      293 	     if code ^= 0 then			/* error writing labels.. */
      294 		go to close_file_return;
      295 	end;
      296 	else do;					/* input operation, must make sure tape is stoped */
      297 	     call mtape_$stop_tape (mtdp, code);
      298 	     if code ^= 0 then
      299 		go to close_file_return;
      300 	end;
      301 
      302 	Schecked_labels = "0"b;
      303 						/* USER trailers can only be returned when */
      304 						/* positioned after the file data */
      305 	if ^output & mtape_file_info.position_within_file = AT_EOF then do;
      306 	     call CHECK_USER_LABELS (EOF_LABEL);	/* go see if user labels to be processed */
      307 	     Schecked_labels = "1"b;
      308 	end;
      309 
      310 	if mtape_close_info.position ^= 0 then do;	/* if not leaving tape where it is.. */
      311 	     call pfm_utils_$position_in_file (mtdp, fi_ptr,
      312 		vs_ptr, mtape_close_info.position, code);
      313 	     if ^output & code = 0 & ^Schecked_labels &
      314 		mtape_file_info.position_within_file = AT_EOFH then
      315 		call CHECK_USER_LABELS (EOF_LABEL);
      316 	end;
      317 
      318 close_file_return:
      319 	arg_code = code;				/* copy return error code (if any) */
      320 	return;
      321 
      322 /* read - entry to read format specific logical records from the current file */
      323 
      324 read: entry (arg_mtdp, arg_code);
      325 
      326 	mtdp = arg_mtdp;				/* copy arguments */
      327 	buf_ptr = mtape_data.arg_buf_ptr;		/* If = null, return length of next record */
      328 	buf_len = mtape_data.arg_buf_len;
      329 	code, rec_len = 0;				/* initialize return record length */
      330 	long_record = "0"b;				/* init long record flag */
      331 	if mtape_data.remain <= 0 then		/* Do we need to read in a block? */
      332 	     call GET_NXT_RECORD;			/* yes, do it */
      333 	go to READ_TYPE (mtape_data.ad_file_format);	/* process depending on file format */
      334 
      335 READ_TYPE (1):					/* Process "U" formated records */
      336 	crl, move_len = mtape_data.remain;		/* user gets entire block */
      337 	move_ptr = mtape_data.log_record_ptr;		/* set pointer to move data from */
      338 	call MOVE_TO_USER;				/* move the data to the users buffer */
      339 	go to read_return;
      340 
      341 READ_TYPE (2):					/* Process "F/FB" formated records */
      342 	if mtape_data.record_size > mtape_data.remain then/* don't try to move more than we have */
      343 	     crl = mtape_data.remain;
      344 	else crl = mtape_data.record_size;
      345 	move_len = crl;
      346 	move_ptr = mtape_data.log_record_ptr;		/* set pointer to move data from */
      347 	call MOVE_TO_USER;				/* give the user his data */
      348 	go to read_return;
      349 
      350 READ_TYPE (3):					/* Process "V/VB" formated records */
      351 	if mtape_data.remain < CW_LENGTH then		/* in case we have mod 4 padded block */
      352 	     call GET_NXT_RECORD;			/* go read next block */
      353 	if mtape_data.hdw_mode ^= MTAPE_HWM_BIN then do;	/* if not binary mode */
      354 	     dbl = vb_record.rdw.length;		/* 9 bit mode, must shift rdw length */
      355 	     substr (dbl, 10) = substr (dbl, 11);
      356 	     crl = binary (bit (substr (dbl, 1, 17), 17), 21);
      357 	end;
      358 	else crl = binary (vb_record.rdw.length, 21);	/* binary mode copy length */
      359 	move_len = crl - CW_LENGTH;
      360 	move_ptr = addr (vb_record.rdata);		/* set pointer to move data from */
      361 	call MOVE_TO_USER;				/* give the user his data */
      362 	go to read_return;
      363 
      364 READ_TYPE (4):					/* Process "VS/VBS" formated records */
      365 	if mtape_data.remain < CW_LENGTH then		/* in case we have mod 4 padded block */
      366 	     call GET_NXT_RECORD;			/* go read next block */
      367 	term = "0"b;				/* reset terminate condition */
      368 	do n_segs = 1 by 1 while (^term);		/* 1 record may be made up of several segments and blocks */
      369 	     call CONVERT_DESC;			/* convert segment descriptor */
      370 	     if n_segs = 1 then			/* if first pass through */
      371 		do while (desc_type ^= SEG_B_E & desc_type ^= SEG_B_NE); /* make sure we get new record */
      372 		mtape_data.remain = mtape_data.remain - crl;
      373 		mtape_data.log_record_ptr = addr (vbs_record.nxt_lrec);
      374 		if mtape_data.remain <= 0 then	/* Do we have to read in a new block? */
      375 		     call GET_NXT_RECORD;
      376 		call CONVERT_DESC;
      377 	     end;
      378 	     move_ptr = addr (vbs_record.rdata);	/* set ptr to move data */
      379 	     call MOVE_TO_USER;			/* give the user his data */
      380 	     if desc_type = SEG_B_E | desc_type = SEG_NB_E then /* end of the record? */
      381 		term = "1"b;			/* yes, set terminate condition */
      382 	     else if mtape_data.remain <= 0 then	/* No, New segment in next block? */
      383 		call GET_NXT_RECORD;		/* yes, do it */
      384 	end;
      385 
      386 read_return:
      387 	mtape_data.arg_rec_len = rec_len;		/* give the user the length of the record */
      388 	if code = 0 then				/* if no error but.. */
      389 	     if long_record then			/* we had a longer record than the users buffer */
      390 		code = error_table_$long_record;	/* tell him about it */
      391 	arg_code = code;				/* return error code */
      392 	return;
      393 
      394 /* write - entry to write format specific logical records into the current file */
      395 
      396 write: entry (arg_mtdp, arg_code);
      397 
      398 	mtdp = arg_mtdp;				/* Copy arguments */
      399 	buf_ptr = mtape_data.arg_buf_ptr;
      400 	buf_len = mtape_data.arg_buf_len;
      401 	code = 0;
      402 	if buf_ptr = null then do;			/* User wants to flush out buffers */
      403 	     if mtape_data.processed > mtape_data.buffer_offset then /* if we have some unwritten data */
      404 		call WRITE_BLOCK;			/* write a short block */
      405 	     call mtape_$flush_buffers (mtdp, code);	/* write out all queued buffers */
      406 	     if code ^= 0 then			/* if some error writing data */
      407 		if code = error_table_$eov_on_write then do; /* Is it end of tape? */
      408 		     call LOAD_PTRS;		/* load up structure pointers */
      409 		     call EOV_ON_WRITE (WRITING);	/* Go close out volume and initiate volume switch */
      410 		end;
      411 	     go to write_return;			/* return to user */
      412 	end;
      413 	go to WRITE_TYPE (mtape_data.ad_file_format);	/* process depending on file format */
      414 
      415 WRITE_TYPE (1):					/* Write "U" formated records */
      416 	call LONG_RECORD_CHECK (buf_len, "0"b);		/* check for long record */
      417 	move_len = buf_len;				/* writes entire block */
      418 	move_ptr = mtape_data.log_record_ptr;		/* set pointer to move data to */
      419 	call MOVE_TO_BUFFER (0, 0);			/* move the data to the tape buffer */
      420 	go to write_return;
      421 
      422 WRITE_TYPE (2):					/* Write "F/FB" formated records */
      423 	call LONG_RECORD_CHECK (buf_len, "1"b);		/* check for long record */
      424 	if mtape_data.record_size > mtape_data.remain then/* don't try to move more than we have */
      425 	     call WRITE_BLOCK;			/* write out the current block */
      426 	move_len = buf_len;
      427 	move_ptr = mtape_data.log_record_ptr;		/* set pointer to move data from */
      428 	call MOVE_TO_BUFFER (0, 1);			/* give the user his data */
      429 	go to write_return;
      430 
      431 WRITE_TYPE (3):					/* Write "V/VB" formated records */
      432 	call LONG_RECORD_CHECK (buf_len, "1"b);		/* check for long record */
      433 	if buf_len + CW_LENGTH > mtape_data.remain then	/* if record won't fit in this block */
      434 	     call WRITE_BLOCK;			/* write out the current block */
      435 	move_len = buf_len;				/* set record length */
      436 	dbl = bit (binary (move_len + CW_LENGTH, 18), 18);/* convert byte count for scw */
      437 	if mtape_data.hdw_mode ^= MTAPE_HWM_BIN then	/* if not binary mode */
      438 	     substr (dbl, 2, 9) = substr (dbl, 3, 8) || "0"b; /* shift out 9th bit */
      439 	vb_record.rdw.length = dbl;			/* set record length */
      440 	vb_record.rdw.reserved = 0;			/* set MBZ field */
      441 	move_ptr = addr (vb_record.rdata);		/* set pointer to move data from */
      442 	call MOVE_TO_BUFFER (CW_LENGTH, CW_LENGTH);	/* copy the users data  */
      443 	go to write_return;
      444 
      445 WRITE_TYPE (4):					/* Write "VS/VBS" formated records */
      446 	call LONG_RECORD_CHECK (buf_len, "1"b);		/* check for long record */
      447 	bytes_remaining = buf_len;			/* set user buffer extents */
      448 	bytes_processed = 0;
      449 	term = "0"b;				/* reset terminate condition */
      450 	do n_segs = 1 by 1 while (^term);		/* 1 record may be made up of several segments and blocks */
      451 	     if bytes_remaining <= mtape_data.remain - CW_LENGTH then do; /* will record fit in this block? */
      452 		term = "1"b;			/* yes, set terminate condition */
      453 		if n_segs = 1 then			/* entire record fit in 1st block? */
      454 		     desc_type = SEG_B_E;		/* Yes, record begins and ends in this segment */
      455 		else desc_type = SEG_NB_E;		/* No, record ends but does not begin in this segment */
      456 		move_len = bytes_remaining;		/* move last part (or all) of record */
      457 	     end;
      458 	     else do;				/* No, record will not fit in current block */
      459 		if n_segs = 1 then			/* is this the first record segment? */
      460 		     desc_type = SEG_B_NE;		/* Yes, record begins but does not end in this segment */
      461 		else desc_type = SEG_NB_NE;		/* No, record neither begins nor ends in this segment */
      462 		move_len = mtape_data.remain - CW_LENGTH; /* use rest of or entire block */
      463 		bytes_remaining = bytes_remaining - move_len; /* decrement remaining bytes to process */
      464 	     end;
      465 	     bytes_processed = bytes_processed + move_len;/* add up total moved so far */
      466 	     dbl = bit (binary (move_len + CW_LENGTH, 18), 18); /* convert byte count for scw */
      467 	     move_ptr = addr (vbs_record.rdata);	/* set ptr to move data */
      468 	     if mtape_data.hdw_mode ^= MTAPE_HWM_BIN then /* if not binary mode */
      469 		substr (dbl, 2, 9) = substr (dbl, 3, 8) || "0"b; /* shift out 9th bit */
      470 	     vbs_record.sdw.length = dbl;		/* set record length */
      471 	     vbs_record.sdw.span_indicator = desc_type;	/* and span indicator */
      472 	     vbs_record.sdw.reserved = 0;		/* set MBZ field */
      473 	     call MOVE_TO_BUFFER (CW_LENGTH, CW_LENGTH + 1); /* copy the users data */
      474 	     buf_ptr = addr (based_lrec_index (bytes_processed + 1)); /* increment users buffer ptr */
      475 	end;
      476 
      477 write_return:
      478 	arg_code = code;				/* return error code */
      479 	return;
      480 
      481 /* order - entry to process format specific control orders not recognized by mtape_ */
      482 
      483 order: entry (arg_mtdp, arg_order_name, arg_info_ptr, arg_io_call_infop, arg_code);
      484 
      485 	call SETUP;				/* initialize our enviornment */
      486 	order_name = arg_order_name;
      487 	info_ptr = arg_info_ptr;
      488 
      489 	arg_code = error_table_$no_operation;		/* IBM PFM has no local control operations */
      490 	return;
      491 
      492 /* decode_file_labels - entry to extract info contained in file labels, and fill in file_info structure */
      493 
      494 decode_file_labels: entry (arg_mtdp, arg_lr_ptr, arg_labno, arg_type, arg_code);
      495 
      496 	call SETUP;				/* initialize our enviornment */
      497 	lr_ptr = arg_lr_ptr;
      498 
      499 	on conversion begin;			/* set up handler for conversion errors */
      500 	     code = error_table_$invalid_label_format;	/* set appropriate error code */
      501 	     call mtape_$error (mtdp, code,
      502 		"^/Converting IBM ^a^d label record to binary. Label contents:^/""^a""",
      503 		substr (based_label_record, 1, 3), arg_labno, based_label_record);
      504 	     go to dfl_return;
      505 	end;
      506 
      507 	ibm_hdr1P, ibm_hdr2P = mtape_label_record.lab_ptr;/* set up both template ptrs */
      508 	go to LTYPE (arg_type);			/* decode appropriate label type */
      509 
      510 LTYPE (1):					/* Beginning of file label */
      511 	if ibm_hdr1.label_id = IBM_L1_ID (IBM_HDR1) then do;
      512 						/* IBM HDR1 label */
      513 	     if arg_labno ^= 1 then
      514 		call mtape_$error (mtdp, error_table_$invalid_label_format, "
      515 Additional IBM HDR1 label found while looking for IBM ^a^d label
      516 for file ^a.  Read continues using:
      517 ""^a""",
      518 		     substr (based_label_record, 1, 3), arg_labno,
      519 		     mtape_file_info.file_id,
      520 		     based_label_record);
      521 
      522 	     mtape_file_info.file_id = ibm_hdr1.dataset_id;
      523 	     mtape_file_info.file_set_id = ibm_hdr1.dataset_serial;
      524 	     mtape_file_info.seq_number = binary (ibm_hdr1.dataset_sequence, 17);
      525 	     mtape_file_info.generation = binary (ibm_hdr1.generation, 17);
      526 	     mtape_file_info.gen_version = binary (ibm_hdr1.version, 17);
      527 	     mtape_file_info.creation_date = ibm_hdr1.creation;
      528 	     mtape_file_info.expiration_date = ibm_hdr1.expiration;
      529 	     mtape_file_info.section = 1;		/* set for section 1 initially */
      530 	     if mtape_file_info.prev_fi_ptr ^= null then	/* if we have a previous file */
      531 		if mtape_file_info.prev_fi_ptr -> mtape_file_info.file_id = mtape_file_info.file_id then
      532 		     mtape_file_info.section = mtape_file_info.prev_fi_ptr -> mtape_file_info.section + 1;
      533 	     mtape_file_info.pfm_opt_sw (1) = "1"b;	/* DOS file until proven otherwise */
      534 	     if ibm_hdr1.system = IBM_SYS_CODE then	/* tape recorded by this module? */
      535 		mtape_file_info.native_file = "1"b;	/* yes, set flag */
      536 	end;
      537 	else if ibm_hdr2.label_id = IBM_L2_ID (IBM_HDR2) then do; /* IBM HDR2 label */
      538 
      539 	     if arg_labno ^= 2 then
      540 		call mtape_$error (mtdp, error_table_$invalid_label_format, "
      541 Additional IBM HDR2 label found while looking for IBM ^a^d label
      542 for file ^a.  Read continues using:
      543 ""^a""",
      544 		     substr (based_label_record, 1, 3), arg_labno,
      545 		     mtape_file_info.file_id, based_label_record);
      546 
      547 	     mtape_file_info.pfm_opt_sw (1) = "0"b;	/* this is not a DOS file */
      548 	     temp_fmt = ibm_hdr2.format || ibm_hdr2.block_attribute; /* form file format code */
      549 	     if substr (temp_fmt, 2, 1) = "R" then	/* if records are blocked and spanned */
      550 		substr (temp_fmt, 2, 2) = "BS";	/* correct format code */
      551 	     if ibm_hdr2.format = "V" then		/* if variable length format */
      552 		mtape_file_info.buffer_offset = size (bdw) * 4; /* compensate for block descriptor */
      553 	     mtape_file_info.block_size = binary (ibm_hdr2.blksize, 21);
      554 	     mtape_file_info.record_size = binary (ibm_hdr2.lrecl, 21);
      555 	     mtape_file_info.length_mode = NON_MOD_FOUR;	/* set special length mode as default */
      556 	     mtape_file_info.hdw_mode = MTAPE_UNSPECIFIED;
      557 	     mtape_file_info.conversion = MTAPE_CV_EBCDIC;/* EBCDIC conversion by default */
      558 	     if mtape_file_info.native_file then	/* if recorded by mtape_ */
      559 		if ibm_system_use.mode ^= "" then do;	/* and was recorded with "-system_use" */
      560 		     if ibm_system_use.mode = "1" then do; /* if recorded in ASCII mode */
      561 			mtape_file_info.conversion = MTAPE_NO_CONVERSION; /* no conversion necessary */
      562 			mtape_file_info.hdw_mode = MTAPE_HWM_NINE; /* set nine mode */
      563 		     end;
      564 		     else if ibm_system_use.mode = "2" then /* if recorded in EBCDIC */
      565 			mtape_file_info.hdw_mode = MTAPE_HWM_NINE; /* set nine mode */
      566 		     else if ibm_system_use.mode = "3" then do; /* if recorded in binary mode.. */
      567 			mtape_file_info.conversion = MTAPE_NO_CONVERSION; /* no conversion necessary */
      568 			mtape_file_info.hdw_mode = MTAPE_HWM_BIN;
      569 		     end;
      570 		end;
      571 	     mtape_file_info.file_code = temp_fmt;	/* set file code */
      572 	     do i = 0 to hbound (IBM_FORMAT_CODES, 1);	/* set the file format */
      573 		if temp_fmt = IBM_FORMAT_CODES (i) then /* found it */
      574 		     mtape_file_info.file_format = i;
      575 	     end;
      576 	end;
      577 	else if substr (based_label_record, 1,
      578 	     length (U_LABEL_ID (arg_type))) = U_LABEL_ID (arg_type) then /* user labels present */
      579 	     mtape_file_info.user_labels_present = "1"b;
      580 	return;
      581 
      582 LTYPE (2):					/* End of volume label */
      583 	if arg_labno = 1 then			/* if IBM EOV1 label */
      584 	     mtape_file_info.block_count = binary (ibm_hdr1.blkcnt, 35); /* extract block count */
      585 	else if arg_labno = 2 then do;		/* if IBM EOV2 label */
      586 	     if mtape_vol_set.volume_check = MTAPE_VOLUME then /* check Multics specific stuff */
      587 		if ibm_system_use.next_volname ^= "" then do; /* if recorded with "-system_use" */
      588 		     if mtape_vol_set.next_vs_ptr = null then do; /* if no VS structure */
      589 			call mtape_$alloc (mtdp, MTAPE_ALLOC_VS, mtape_data.vs_tail, 0, nvp);
      590 			mtape_data.vs_tail = nvp;
      591 		     end;
      592 		     else nvp = mtape_vol_set.next_vs_ptr;
      593 		     if nvp -> mtape_vol_set.volume_name ^=
      594 			ibm_system_use.next_volname then
      595 			nvp -> mtape_vol_set.volume_name = ibm_system_use.next_volname;
      596 		end;
      597 	end;
      598 	else if substr (based_label_record, 1,
      599 	     length (U_LABEL_ID (arg_type))) = U_LABEL_ID (arg_type) then do; /* user labels present */
      600 	     mtape_file_info.user_labels_present = "1"b;
      601 	     call CHECK_USER_LABELS (EOV_LABEL);
      602 	end;
      603 
      604 	return;
      605 LTYPE (3):					/* End of file label */
      606 	if ibm_hdr1.label_id = IBM_L1_ID (IBM_EOF1) then do;
      607 	     if arg_labno ^= 1 then
      608 		call mtape_$error (mtdp, error_table_$invalid_label_format, "
      609 Additional IBM EOF1 label found while looking for IBM ^a^d label
      610 for file ^a.  Read continues using:
      611 ""^a""",
      612 		     substr (based_label_record, 1, 3), arg_labno,
      613 		     mtape_file_info.file_id, based_label_record);
      614 
      615 	     mtape_file_info.block_count = binary (ibm_hdr1.blkcnt, 35); /* extract block count */
      616 	     mtape_file_info.gen_version = binary (ibm_hdr1.version, 17); /* save in case modified | extended file */
      617 	end;
      618 	else if substr (based_label_record, 1,
      619 	     length (U_LABEL_ID (arg_type))) = U_LABEL_ID (arg_type) then /* user labels present */
      620 
      621 	     mtape_file_info.user_labels_present = "1"b;
      622 
      623 dfl_return:
      624 	arg_code = code;
      625 	return;
      626 
      627 /* encode_file_labels - entry to fill in file labels from info obtained from file_info structure */
      628 
      629 encode_file_labels: entry (arg_mtdp, arg_lr_ptr, arg_labno, arg_type, arg_convert, arg_code);
      630 
      631 	call SETUP;				/* initialize our enviornment */
      632 	lr_ptr = arg_lr_ptr;
      633 	based_label_record = "";			/* initialize to blanks first */
      634 	arg_convert = MTAPE_CV_UC_EBCDIC;		/* set conversion to uper case ebcdic */
      635 	if arg_labno = 1 then do;			/* init HDR1/EOV1/EOF1 label */
      636 	     if arg_type = EOV_LABEL then		/* if writing EOV sequence */
      637 		if mtape_vol_set.next_vs_ptr = null then do; /* and no next volume */
      638 		     call mtape_$user_query (mtdp, Q_NO_NEXT_VOLUME, code); /* ask user for a new one */
      639 		     if code ^= 0 then		/* if he didn't want to continue */
      640 			go to efl_return;		/* forget it */
      641 		end;
      642 	     ibm_hdr1P = mtape_label_record.lab_ptr;
      643 	     ibm_hdr1.label_id = IBM_L1_ID (arg_type);	/* Now fill it in */
      644 	     ibm_hdr1.dataset_id = substr (mtape_file_info.file_id, 1, length (ibm_hdr1.dataset_id));
      645 	     ibm_hdr1.dataset_serial = substr (mtape_file_info.file_set_id, 1, length (ibm_hdr1.dataset_serial));
      646 	     pic4 = mtape_vol_set.volume_index;
      647 	     ibm_hdr1.volume_sequence = pic4;
      648 	     pic4 = mtape_file_info.seq_number;
      649 	     ibm_hdr1.dataset_sequence = pic4;
      650 	     if mtape_file_info.generation = 0 then	/* if not a file generation */
      651 		ibm_hdr1.generation, ibm_hdr1.version = "";
      652 	     else do;
      653 		pic4 = mtape_file_info.generation;
      654 		ibm_hdr1.generation = pic4;
      655 		pic2 = mtape_file_info.gen_version;
      656 		ibm_hdr1.version = pic2;
      657 	     end;
      658 	     ibm_hdr1.creation = mtape_file_info.creation_date;
      659 	     ibm_hdr1.expiration = mtape_file_info.expiration_date;
      660 	     ibm_hdr1.security = "0";			/* Always unlimited access */
      661 	     if arg_type > BOF_LABEL then do;		/* if EOV/EOF label */
      662 		pic6 = mtape_file_info.block_count;	/* fill in the block count */
      663 		ibm_hdr1.blkcnt = pic6;
      664 	     end;
      665 	     else ibm_hdr1.blkcnt = "000000";		/* used only for EOF/EOV1 records */
      666 	     ibm_hdr1.system = IBM_SYS_CODE;
      667 	     return;
      668 	end;
      669 	else if arg_labno = 2 & ^mtape_file_info.pfm_opt_sw (1) then do; /* init HDR2/EOV2/EOF2 label */
      670 	     ibm_hdr2P = mtape_label_record.lab_ptr;
      671 	     ibm_hdr2.label_id = IBM_L2_ID (arg_type);	/* Now fill it in */
      672 	     ibm_hdr2.format = substr (IBM_FORMAT_CODES (mtape_file_info.file_format), 1, 1);
      673 	     pic5 = mtape_file_info.block_size;
      674 	     ibm_hdr2.blksize = pic5;
      675 	     if mtape_file_info.record_size <= MAX_IBM_RECORD_SIZE then do; /* if it will fit */
      676 		pic5 = mtape_file_info.record_size;
      677 		ibm_hdr2.lrecl = pic5;
      678 	     end;
      679 	     else ibm_hdr2.lrecl = "00000";
      680 	     if mtape_file_info.file_format < 5 then	/* if records are not blocked */
      681 		if mtape_file_info.file_format ^= 4 then/* and not spanned */
      682 		     ibm_hdr2.block_attribute = " ";
      683 		else ibm_hdr2.block_attribute = "S";	/* records are spanned but not blocked */
      684 	     else if mtape_file_info.file_format ^= 7 then/* records are blocked but not spanned */
      685 		ibm_hdr2.block_attribute = "B";
      686 	     else ibm_hdr2.block_attribute = "R";	/* records are both blocked and spanned */
      687 	     if mtape_file_info.section > 1 then	/* if a volume switch has ocurred */
      688 		ibm_hdr2.dataset_position = "1";
      689 	     else ibm_hdr2.dataset_position = "0";
      690 	     do i = 0 to hbound (MTAPE_VALID_DENSITIES, 1) - 1; /* set the density code */
      691 		if mtape_vol_set.volume_density = MTAPE_VALID_DENSITIES (i + 1) then
      692 		     pic1 = i;
      693 	     end;
      694 	     ibm_hdr2.density = pic1;
      695 	     ibm_hdr2.recording_technique = "";		/* odd parity, no translation */
      696 	     ibm_hdr2.control_characters = " ";		/* No control characters used */
      697 	     ibm_hdr2.jobstep_id = "MULTICS /" || ltrim (mtape_file_info.creation_date);
      698 	     if mtape_file_info.pfm_opt_sw (2) then do;	/* if "-system_use" specified */
      699 		if arg_type = EOV_LABEL then do;	/* if at EOV */
      700 		     if mtape_vol_set.next_vs_ptr ^= null then /* and if we have another volume */
      701 			ibm_system_use.next_volname =
      702 			     substr (mtape_vol_set.next_vs_ptr -> mtape_vol_set.volume_name, 1, length (ibm_system_use.next_volname));
      703 		     arg_convert = MTAPE_CV_EBCDIC;	/* don't convert volume id */
      704 		end;
      705 		if mtape_file_info.hdw_mode = MTAPE_HWM_BIN then /* if recording in binary mode */
      706 		     ibm_system_use.mode = "3";
      707 		else if mtape_file_info.conversion = MTAPE_CV_EBCDIC then /* if recording EBCDIC data */
      708 		     ibm_system_use.mode = "2";
      709 		else ibm_system_use.mode = "1";	/* ASCII NINE mode */
      710 	     end;
      711 	     return;
      712 	end;
      713 	else if mtape_open_info.label_entry_present then do; /* if writing user labels */
      714 	     if mtape_file_info.pfm_opt_sw (1) then	/* if DOS file */
      715 		slab = 1;				/* only 1 system label */
      716 	     else slab = 2;				/* otherwise there is 2 */
      717 	     if arg_labno < (10 + slab) then do;	/* and not at max of 9 yet */
      718 		uln = arg_labno - slab;		/* user labels start at 1 */
      719 		user_label_data = "";
      720 		call mtape_open_info.user_label (mtape_data.iocb_ptr, user_label_data, uln, arg_type,
      721 		     mtape_file_info.section, code);	/* call the user label routine */
      722 		if code ^= 0 then			/* if error indicated from user routine */
      723 		     if code = error_table_$end_of_info then /* but it is normal termination */
      724 			go to efl_return;		/* return with end of info indication */
      725 		     else do;			/* some other error report it */
      726 			call mtape_$error (mtdp, code,
      727 			     "^/Calling the user label processing routine to process the ^a^d label record.",
      728 			     U_LABEL_ID (arg_type), uln, slab);
      729 			code = error_table_$end_of_info; /* force user label termination */
      730 			go to efl_return;
      731 		     end;
      732 		pic1 = uln;			/* convert label number to ascii */
      733 		based_label_record = U_LABEL_ID (arg_type) || pic1 || user_label_data; /* form completed user label */
      734 		go to efl_return;
      735 	     end;
      736 	end;
      737 	code = error_table_$end_of_info;		/* terminate label processing */
      738 
      739 efl_return:
      740 	arg_code = code;				/* copy error code */
      741 	return;
      742 
      743 /* CHECK_NEW_FILE_SECTION - internal procedure to check consistency of new file section */
      744 
      745 CHECK_NEW_FILE_SECTION: proc;
      746 
      747 dcl  per_file_overlay char (ov_len) based (addr (mtape_file_info.per_file_info));
      748 dcl  ov_len fixed bin;
      749 dcl  pp ptr;
      750 
      751 	code = 0;
      752 	fi_ptr = mtape_file_info.next_fi_ptr;		/* file info will be allocated if null */
      753 	call pfm_utils_$read_file_labels (mtdp, fi_ptr, vs_ptr, label_type, code); /* read new file sect. HDR labels */
      754 	if code ^= 0 then
      755 	     return;
      756 	if label_type ^= BOF_LABEL then do;		/* error if not header labels */
      757 	     code = error_table_$bad_file;
      758 	     call mtape_$error (mtdp, code,
      759 		"^/^[EOV^;EOF^] file label found where BOF label record expected", label_type);
      760 	     return;
      761 	end;
      762 	call SET_FILE_ATTRIBUTES;			/* set up missing pieces */
      763 	pp = mtape_file_info.prev_fi_ptr;		/* get prev file ptr */
      764 	ov_len = (binary (rel (addr (mtape_file_info.per_section_info))) -
      765 	     binary (rel (addr (mtape_file_info.per_file_info)))) * 4;
      766 	if mtape_file_info.record_size ^= pp -> mtape_file_info.record_size then /* if record sizes */
      767 	     if mtape_file_info.record_size = 0 then	/* are ^=, but new section = 0 */
      768 		pp -> mtape_file_info.record_size = 0;	/* make 1st section = 0 too */
      769 	if mtape_file_info.section ^= pp -> mtape_file_info.section + 1 |
      770 	     per_file_overlay ^= addr (pp -> mtape_file_info.per_file_info) -> per_file_overlay then do;
      771 	     code = error_table_$bad_file;		/* set an appropriate error code */
      772 	     call mtape_$error (mtdp, code,
      773 		"^/New file section for File ""^a"" on volume ""^a"" is inconsistent with previous section",
      774 		pp -> mtape_file_info.file_id, mtape_vol_set.volume_id);
      775 	end;
      776 	call mtape_$set_mode (mtdp, "data", mtape_data.hdw_mode, null, code); /* set hardware mode */
      777 
      778      end CHECK_NEW_FILE_SECTION;
      779 
      780 /* CHECK_USER_LABELS - procedure to check if user labels and a user label entry exist */
      781 
      782 CHECK_USER_LABELS: proc (htype);
      783 
      784 dcl  htype fixed bin;
      785 dcl  flrp ptr;
      786 
      787 	if mtape_file_info.user_labels_present then	/* if file contains user labels */
      788 	     if mtape_open_info.label_entry_present then do; /* and user wants to see them */
      789 		if htype > BOF_LABEL then		/* trailer labels? */
      790 		     flrp = mtape_file_info.first_file_trail_ptr; /* yes, search trailer list */
      791 		else flrp = mtape_file_info.first_file_lab_ptr; /* search header list */
      792 		do lr_ptr = flrp repeat mtape_label_record.next_lab_ptr /* search up to 1st user label */
      793 		     while (substr (based_label_record, 1, 1) ^= "U");
      794 		end;
      795 		do lr_ptr = lr_ptr repeat mtape_label_record.next_lab_ptr
      796 		     while (lr_ptr ^= null);		/* send him all labels */
      797 		     user_label_data = substr (based_label_record, 5); /* copy user data */
      798 		     i = fixed (substr (based_label_record, 4, 1), 17); /* get label number */
      799 		     call mtape_open_info.user_label (mtape_data.iocb_ptr, /* call the user label routine */
      800 			user_label_data, i, htype, mtape_file_info.section, (0)); /* ignore error code */
      801 		end;
      802 	     end;
      803 
      804      end CHECK_USER_LABELS;
      805 
      806 /* CHECK_VERSION - internal procedure to check struture version numbers */
      807 
      808 CHECK_VERSION: proc (s_ptr, req_version, struc_name);
      809 
      810 dcl  s_ptr ptr;
      811 dcl  req_version char (8);
      812 dcl  struc_name char (32);
      813 
      814 dcl  1 version_check based (s_ptr) aligned,		/* generic structure to check verison number */
      815        2 version char (8);
      816 
      817 	if version_check.version ^= req_version then do;	/* they do not match */
      818 	     code = error_table_$unimplemented_version;	/* set error code */
      819 	     call mtape_$error (mtdp, code,
      820 		"^/^a: Expecting ""^a"" version for ^a structure. Version recorded in received structure is ""^a"".",
      821 		myname, req_version, struc_name, version_check.version);
      822 	     go to pfm_init_return;			/* take non-local goto and return to caller */
      823 	end;
      824 
      825      end CHECK_VERSION;
      826 
      827 /* CHECK_VOL_LABELS - internal procedure to read volume label(s) of a known IBM volume */
      828 
      829 CHECK_VOL_LABELS: proc (ridx);
      830 
      831 dcl  ridx fixed bin;
      832 
      833 	call mtape_$order (mtdp, "rew", 0, null, code);	/* Rewind to load point */
      834 	if code ^= 0 then do;
      835 	     call mtape_$error (mtdp, code,
      836 		"While rewinding volume ^a prior to reading volume label(s)", mtape_vol_set.volume_id);
      837 	     return;
      838 	end;
      839 	nlp = mtape_vol_set.first_vl_ptr;		/* arm the label record ptr */
      840 	ibm_vol1P = mtape_data.tlb -> mtape_label_record.lab_ptr; /* get pointer to VOL1 structure */
      841 	term = "0"b;				/* get us through the first pass */
      842 	do i = 1 by 1 while (^term);			/* read up to HDR1 label */
      843 	     call mtape_$read_label (mtdp, mtape_data.tlb, code); /* read label record */
      844 	     if code ^= 0 then do;
      845 		call mtape_$error (mtdp, code,
      846 		     "Attempting to read IBM volume label record from volume ^a.", mtape_vol_set.volume_id);
      847 		return;
      848 	     end;
      849 	     if ibm_vol1.label_id = IBM_VOL1 then do;	/* if this is VOL1 label */
      850 		if ibm_vol1.owner_id.mult_id = MULTICS_IBM_VERSION then /* only true if recorded by mtape_ */
      851 		     ridx = MTAPE_VOLUME;
      852 		else ridx = NON_MULT_VOLUME;		/* volume recorded by other vendor */
      853 	     end;
      854 	     else if ibm_vol1.label_id = IBM_L1_ID (BOF_LABEL) then do; /* check if HDR1 label */
      855 		term = "1"b;			/* this is the place to stop reading labels */
      856 		mtape_vol_set.number_of_vol_labels = i - 1; /* set number of vol labels */
      857 		ibm_hdr1P = ibm_vol1P;		/* check expiration date of first file */
      858 		if ridx = NON_MULT_VOLUME then	/* check if recorded by tape_ibm_ */
      859 		     if substr (ibm_hdr1.system, 1, 12) = substr (IBM_SYS_CODE, 1, 12) then
      860 			ridx = MULT_PRIOR_VOLUME;	/* yes, tape recorded by tape_ibm_ */
      861 		mtape_vol_set.first_file_unexpired = pfm_utils_$label_unexpired (ibm_hdr1.expiration);	/* check the label date and set the flag */
      862 	     end;
      863 	     if ^term then do;			/* link in this label  (if not HDR1) */
      864 		if nlp = null then do;		/* if no label record structure exists.. */
      865 		     call pfm_utils_$init_label_record (mtdp, mtape_vol_set.last_vl_ptr,
      866 			mtape_vol_set.first_vl_ptr, lr_ptr, LABEL_LENGTH);
      867 		     mtape_label_record.conversion = MTAPE_CV_UC_EBCDIC; /* IBM labels in EBCDIC */
      868 		end;
      869 		else lr_ptr = nlp;			/* it does exist, use it */
      870 		based_label_record = mtape_data.tlb -> mtape_label_record.lab_ptr -> based_label_record;
      871 		nlp = mtape_label_record.next_lab_ptr;	/* update pointer for next label */
      872 	     end;
      873 	end;
      874 	call mtape_$order (mtdp, "bsr", 1, null, code);	/* backspace in front of HDR1 */
      875 	if code ^= 0 then
      876 	     call mtape_$error (mtdp, code,
      877 		"Attempting to backspace over ^a label record of volume ^a.",
      878 		ibm_vol1.label_id, mtape_vol_set.volume_id);
      879 
      880      end CHECK_VOL_LABELS;
      881 
      882 /* CONVERT_DESC - internal procedure to convert RDW for S/VBS formated records */
      883 
      884 CONVERT_DESC: proc;
      885 
      886 	if mtape_data.hdw_mode ^= MTAPE_HWM_BIN then do;	/* if not binary mode */
      887 	     dbl = vbs_record.sdw.length;		/* 9 bit mode, must shift rdw length */
      888 	     substr (dbl, 10) = substr (dbl, 11);
      889 	     crl = binary (bit (substr (dbl, 1, 17), 17), 21);
      890 	end;
      891 	else crl = binary (vbs_record.sdw.length, 21);	/* binary mode copy length */
      892 	move_len = crl - CW_LENGTH;
      893 	desc_type = vbs_record.sdw.span_indicator;	/* get the control character */
      894 	if desc_type < SEG_B_E | desc_type > SEG_NB_NE then do; /* invalid descriptor */
      895 	     code = error_table_$invalid_record_desc;	/* set appropriate error code */
      896 	     call mtape_$error (mtdp, code,
      897 		"^/^a ^a SDW at record ^d, block ^d, ^[of file section ^d ^;^s^]of file named ""^a"".",
      898 		"Converting IBM", IBM_FORMAT_CODES (mtape_file_info.file_format),
      899 		mtape_data.log_record, mtape_data.phy_block, (mtape_file_info.section > 1),
      900 		mtape_file_info.section, mtape_file_info.file_id);
      901 	     go to read_return;			/* return to user with error */
      902 	end;
      903 
      904      end CONVERT_DESC;
      905 
      906 /* EOV_ON_WRITE - internal procedure to close out volume and initiate volume switch */
      907 
      908 EOV_ON_WRITE: proc (who_called);
      909 
      910 dcl  who_called bit (1) aligned;
      911 
      912 	call pfm_utils_$write_file_labels (mtdp, EOV_LABEL, code); /* yes, write out the EOV labels */
      913 	if code ^= 0 then return;			/* some problem with writing labels, give up */
      914 	mtape_vol_set.volume_end = "0"b;		/* reset volume end flag */
      915 	nvp = mtape_vol_set.next_vs_ptr;		/* copy pointer, in case its null */
      916 	call mtape_$volume_switch (mtdp, nvp, code);	/* do the magic */
      917 	if code ^= 0 then do;			/* could'nt do the switch */
      918 	     call mtape_$error (mtdp, code,
      919 		"Couldn't mount new volume at volume switch time");
      920 	     return;
      921 	end;
      922 	vs_ptr = mtape_data.vs_current;		/* point to new volume */
      923 	call INIT_VOL_LABELS;			/* init volume labels */
      924 	if code ^= 0 then return;
      925 	fi_ptr = null;				/* this will ensure we get file_info struct allocated */
      926 	call pfm_utils_$setup_file (mtdp, fi_ptr, "1"b);	/* set up new file section structure */
      927 	call pfm_utils_$write_file_labels (mtdp, BOF_LABEL, code); /* and write out the section header labels */
      928 	if code ^= 0 then return;			/* if errors.. */
      929 	if who_called = WRITING then do;		/* if actually writing data */
      930 	     call mtape_$set_mode (mtdp, "data", mtape_data.hdw_mode, null, code); /* set hardware mode */
      931 	     if code ^= 0 then return;
      932 	     call mtape_$set_mode (mtdp, "length", mtape_data.length_mode, null, code); /* and special len mode */
      933 	     if code ^= 0 then return;
      934 	     if mtape_data.cur_buf_idx > lbound (mtape_data.buf_ptrs, 1) then /* if we have suspened bufs */
      935 		call mtape_$flush_buffers (mtdp, code); /* flush out any suspended buffers */
      936 	end;
      937 
      938      end EOV_ON_WRITE;
      939 
      940 /* GET_NXT_RECORD - subroutine to position to next logical record, reading nxt tape block if necessary */
      941 
      942 GET_NXT_RECORD: proc;
      943 
      944 dcl  term bit (1) aligned;
      945 
      946 	term = "0"b;
      947 	do while (^term);				/* in case we have to read 1 block of new file section */
      948 	     call mtape_$read_block (mtdp, code);	/* so read it in */
      949 	     if code ^= 0 then			/* if some error */
      950 		if code = error_table_$end_of_info then do; /* if EOF, read trailer */
      951 		     call LOAD_PTRS;		/* Load up structure pointers */
      952 		     call pfm_utils_$read_file_labels (mtdp, fi_ptr, vs_ptr, label_type, fl_code);
      953 		     if fl_code ^= 0 then do;		/* some problem reading labels, abort */
      954 			code = fl_code;
      955 			go to read_return;		/* Take non-local goto and return */
      956 		     end;
      957 		     if label_type = EOF_LABEL then	/* is this really end of the data file? */
      958 			go to read_return;		/* Take non-local goto and return */
      959 		     else if label_type = EOV_LABEL then do; /* No, volume switch has already been done */
      960 			call CHECK_NEW_FILE_SECTION;	/* go check out new file section labels */
      961 			if code ^= 0 then		/* some error */
      962 			     go to read_return;	/* Take non-local goto and return */
      963 		     end;
      964 		     else do;			/* if label_type = BOF, this is error */
      965 			code = error_table_$bad_file; /* set appropriate error code */
      966 			call mtape_$error (mtdp, code,
      967 			     "^/IBM HDR1 file label found where EOF1 or EOV1 file label record expected");
      968 			go to read_return;		/* Take non-local goto and return */
      969 		     end;
      970 		end;
      971 		else go to read_return;		/* some other error, let user see what it is */
      972 	     else do;				/* successfully read the block */
      973 		term = "1"b;			/* set terminate condition */
      974 		if mtape_data.ad_file_format > 2 then do; /* if variable length records */
      975 		     if mtape_data.hdw_mode ^= MTAPE_HWM_BIN then do; /* if not binary mode */
      976 			dbl = bdw.length;		/* 9 bit mode, must shift bdw length */
      977 			substr (dbl, 10) = substr (dbl, 11);
      978 			mtape_data.cur_block.length = binary (bit (substr (dbl, 1, 17), 17), 21);
      979 		     end;
      980 		     else mtape_data.cur_block.length = binary (bdw.length, 21); /* binary mode copy length */
      981 		     mtape_data.remain = mtape_data.length - mtape_data.processed; /* reset, based on recorded len */
      982 		end;
      983 	     end;
      984 	end;
      985 
      986      end GET_NXT_RECORD;
      987 
      988 /* INIT_VOL_LABELS - internal procedure to initialize and write the VOL1 and dummy HDR1 label records */
      989 
      990 INIT_VOL_LABELS: proc;
      991 
      992 	if mtape_vol_set.first_file_unexpired then	/* if not expired */
      993 	     if ^mtape_open_info.force then do;		/* and not ignoring expiration dates */
      994 		call mtape_$user_query (mtdp, Q_UNEXPIRED_VOLUME, code); /* ask user */
      995 		if code ^= 0 then return;		/* user does not want labels destroyed */
      996 	     end;
      997 
      998 	call mtape_$order (mtdp, "den", 0, addr (mtape_attach_info.density), code); /* Rewind and set density */
      999 	if code ^= 0 then do;
     1000 	     call mtape_$error (mtdp, code,
     1001 		"^/While rewinding and setting density to ^d BPI on volume ^a prior to volume initialization",
     1002 		mtape_attach_info.density, mtape_vol_set.volume_id);
     1003 	     return;
     1004 	end;
     1005 	if ^mtape_attach_info.labeled then do;		/* if unlabeled volume */
     1006 	     mtape_vol_set.number_of_vol_labels = 0;	/* set up volume parameters */
     1007 	     mtape_vol_set.first_vl_ptr, mtape_vol_set.last_vl_ptr = null; /* in case they were'nt */
     1008 	     mtape_vol_set.volume_density = mtape_attach_info.density; /* reset volume parameters to */
     1009 	     mtape_vol_set.volume_type = Volume_unknown_format; /* reflect that its an unlabeled volume recorded at */
     1010 	     mtape_vol_set.volume_check = MTAPE_VOLUME;	/* requested density */
     1011 	     return;				/* thats all for an unlabeled volume */
     1012 	end;
     1013 	nlp = mtape_vol_set.first_vl_ptr;		/* arm the label record ptr */
     1014 	mtape_vol_set.volume_id = mtape_vol_set.volume_name;
     1015 
     1016 	auth_code = authenticate_ ((mtape_vol_set.volume_id));
     1017 	if nlp = null then do;			/* if no label record structure exists.. */
     1018 	     call pfm_utils_$init_label_record (mtdp, mtape_vol_set.last_vl_ptr,
     1019 		mtape_vol_set.first_vl_ptr, lr_ptr, LABEL_LENGTH);
     1020 	     mtape_label_record.conversion = MTAPE_CV_UC_EBCDIC; /* IBM lables are always ebcdic */
     1021 	end;
     1022 	else lr_ptr = nlp;				/* it does exist, use it */
     1023 	nlp = mtape_label_record.next_lab_ptr;		/* update pointer for next label */
     1024 	ibm_vol1P = mtape_label_record.lab_ptr;
     1025 	ibm_vol1.label_id = IBM_VOL1;			/* set label id */
     1026 	ibm_vol1.volume_serial = substr (mtape_vol_set.volume_id, 1, length (ibm_vol1.volume_serial)); /* set canonacical volume name */
     1027 	ibm_vol1.owner_id.auth_code = auth_code;	/* set authentication code for RCP */
     1028 	ibm_vol1.owner_id.mult_id = MULTICS_IBM_VERSION;	/* indicate recorded by mtape_ */
     1029 	call mtape_$write_label (mtdp, lr_ptr, code);	/* write it out */
     1030 	if code ^= 0 then do;			/* if unrecoverable error */
     1031 	     call mtape_$error (mtdp, code,
     1032 		"Attempting to write IBM VOL1 label record on volume ^a.",
     1033 		mtape_vol_set.volume_id);
     1034 	     return;
     1035 	end;
     1036 	mtape_vol_set.number_of_vol_labels = 1;		/* set this constant */
     1037 	if mtape_vol_set.last_vl_ptr ^= lr_ptr then do;	/* in case there were more labels before */
     1038 	     mtape_vol_set.last_vl_ptr = lr_ptr;	/* truncate the chain */
     1039 	     mtape_label_record.next_lab_ptr = null;
     1040 	end;
     1041 
     1042 /* Now write the dummy HDR1 label */
     1043 
     1044 	lr_ptr = mtape_data.tlb;
     1045 	based_label_record = IBM_L1_ID (BOF_LABEL) || copy ("0", 76);
     1046 	call mtape_$write_label (mtdp, lr_ptr, code);	/* write it out */
     1047 	if code ^= 0 then do;			/* if unrecoverable error */
     1048 	     call mtape_$error (mtdp, code,
     1049 		"^/While initializing volume ^a with dummy IBM HDR1 label record",
     1050 		mtape_vol_set.volume_id);
     1051 	     return;
     1052 	end;
     1053 	call mtape_$order (mtdp, "eof", 1, null, code);	/* write an EOF mark */
     1054 	if code ^= 0 then do;
     1055 	     call mtape_$error (mtdp, code,
     1056 		"^/While writing an EOF mark following dummy IBM HDR1 label record on volume ^a",
     1057 		mtape_vol_set.volume_id);
     1058 	     return;
     1059 	end;
     1060 	mtape_vol_set.volume_density = mtape_attach_info.density; /* reset volume parameters to */
     1061 	mtape_vol_set.volume_type = Volume_ibm_tape;	/* reflect that its an IBM volume recorded at */
     1062 	mtape_vol_set.volume_check = MTAPE_VOLUME;	/* requested density by mtape_ */
     1063 
     1064 /* Position for writing first file */
     1065 
     1066 	call mtape_$order (mtdp, "rew", 0, null, code);	/* Rewind to load point */
     1067 	if code ^= 0 then do;
     1068 	     call mtape_$error (mtdp, code,
     1069 		"^/While rewinding volume ^a after volume initialization", mtape_vol_set.volume_id);
     1070 	     return;
     1071 	end;
     1072 	call mtape_$order (mtdp, "fsr", 1, null, code);	/* position to write over dummy HDR1 label */
     1073 	if code ^= 0 then
     1074 	     call mtape_$error (mtdp, code,
     1075 		"^/While positioning for writing first file label on volume ^a", mtape_vol_set.volume_id);
     1076 
     1077      end INIT_VOL_LABELS;
     1078 
     1079 /* LOAD_PTRS - procedure to load structure pointers for exeception processing
     1080*   of time critical external entries (read and write) */
     1081 
     1082 LOAD_PTRS: proc;
     1083 
     1084 	vs_ptr = mtape_data.vs_current;		/* load up pertinent structure pointers */
     1085 	fi_ptr = mtape_data.fi_current;
     1086 	maip = mtape_data.attach_info_ptr;
     1087 	moip = mtape_data.open_info_ptr;
     1088 	mpfmip = mtape_data.pfm_info_ptr;
     1089 
     1090      end LOAD_PTRS;
     1091 
     1092 /* LONG_RECORD_CHECK - procedure to check if a requested write of a logical record will fit */
     1093 
     1094 LONG_RECORD_CHECK: proc (length, rec_blk_ck);
     1095 
     1096 dcl  length fixed bin (21);
     1097 dcl  rec_blk_ck bit (1) aligned;
     1098 
     1099 	if rec_blk_ck then do;			/* comparing against record length */
     1100 	     if length > mtape_data.record_size then	/* is it to big */
     1101 		code = error_table_$long_record;	/* yes, set code */
     1102 	end;
     1103 	else if length > mtape_data.block_size then	/* comparing against blk size, will it fit */
     1104 	     code = error_table_$long_record;		/* no, set code */
     1105 	if code ^= 0 then				/* if we have a long record.. */
     1106 	     go to write_return;			/* take non-local goto to write return exit */
     1107 
     1108      end LONG_RECORD_CHECK;
     1109 
     1110 /* MOVE_TO_BUFFER - subroutine to move user data to tape buffer on write,
     1111*   initiating a write of the buffer if full */
     1112 
     1113 MOVE_TO_BUFFER: proc (cwl, min_len);
     1114 
     1115 dcl  cwl fixed bin;					/* control word length */
     1116 dcl  min_len fixed bin;				/* minimum length of next record */
     1117 dcl  pad_chars fixed bin;
     1118 dcl  rcd_pad char (pad_chars) based (addr (tape_blk (mtape_data.processed + move_len + 1)));
     1119 
     1120 	if mtape_data.conversion = MTAPE_CV_EBCDIC then	/* if data recorded in ebcdic.. */
     1121 	     call ascii_to_ebcdic_ (buf_ptr -> based_lrec_data, move_ptr -> based_lrec_data);
     1122 	else move_ptr -> based_lrec_data = buf_ptr -> based_lrec_data; /* move data to tape buffer */
     1123 	if (mtape_data.ad_file_format = 1) | (mtape_data.ad_file_format = 2) then
     1124 						/* If "U" or "F" or "FB" format		*/
     1125 	     if move_len < mtape_data.record_size then do;/* and record is not fUll */
     1126 		pad_chars = mtape_data.record_size - move_len; /* pad record out with blanks */
     1127 		rcd_pad = copy (" ", pad_chars);
     1128 		if mtape_data.conversion = MTAPE_CV_EBCDIC then /* make them ebcdic blanks */
     1129 		     call ascii_to_ebcdic_ (rcd_pad, rcd_pad); /* if appropriate */
     1130 		move_len = mtape_data.record_size;	/* reflect on all data moved */
     1131 	     end;
     1132 	mtape_data.processed = mtape_data.processed + move_len + cwl; /* add up bytes processed */
     1133 	mtape_data.remain = mtape_data.block_size - mtape_data.processed; /* decrement remaining bytes */
     1134 	if ^mtape_data.file_blocked then		/* if not "FB", "VB", or "VBS" format */
     1135 	     call WRITE_BLOCK;			/* write the block out now */
     1136 	else if mtape_data.remain < min_len then	/* if blocked but block full.. */
     1137 	     call WRITE_BLOCK;			/* write the block out now */
     1138 	else mtape_data.log_record_ptr = addr (tape_blk (mtape_data.processed + 1));
     1139 						/* Not blocked, set for next lrec */
     1140 
     1141      end MOVE_TO_BUFFER;
     1142 
     1143 /* MOVE_TO_USER - subroutine to move data from tape buffer to user buffer on read */
     1144 
     1145 MOVE_TO_USER: proc;
     1146 
     1147 	if buf_ptr = null then			/* if caller just wants length.. */
     1148 	     rec_len = rec_len + move_len;		/* thats it */
     1149 	else do;					/* this is a real read */
     1150 	     if ^long_record then do;			/* if we can still fit the data in */
     1151 		if buf_len - move_len < 0 then do;
     1152 		     long_record = "1"b;		/* we have more data than user can take */
     1153 		     move_len = buf_len;		/* move what we can */
     1154 		end;
     1155 		buf_len = buf_len - move_len;		/* and decrement length remaining in users buffer */
     1156 		if move_len > 0 then do;		/* if we have some data to move, move it */
     1157 		     if mtape_data.conversion = MTAPE_CV_EBCDIC then /* tape recorded in ebcdic */
     1158 			call ebcdic_to_ascii_ (move_ptr -> based_lrec_data, buf_ptr -> based_lrec_data);
     1159 		     else buf_ptr -> based_lrec_data = move_ptr -> based_lrec_data; /* move computed of bytes */
     1160 		     rec_len = rec_len + move_len;	/* tell user how long record is anyway */
     1161 		     buf_ptr = addr (based_lrec_index (rec_len + 1)); /* increment users buffer ptr */
     1162 		end;
     1163 	     end;
     1164 	end;
     1165 	mtape_data.processed = mtape_data.processed + crl;
     1166 	mtape_data.remain = mtape_data.cur_block.length - mtape_data.processed;
     1167 	if mtape_data.remain > 0 then
     1168 	     mtape_data.log_record_ptr = addr (tape_blk (mtape_data.processed + 1));
     1169 
     1170      end MOVE_TO_USER;
     1171 
     1172 /* NEED_TO_INIT_VOLUME - function to determine if a tape volume requires initializaton */
     1173 
     1174 NEED_TO_INIT_VOLUME: proc returns (bit (1) aligned);
     1175 
     1176 	if mtape_vol_set.volume_check > NON_MULT_VOLUME then /* if this is not an IBM volume */
     1177 	     return ("1"b);
     1178 	if mtape_open_info.modify | mtape_open_info.extend then /* if modifying or extending */
     1179 	     return ("0"b);				/* existing file, do not init volume */
     1180 	if ^mtape_data.first_file then do;		/* if the first opening */
     1181 	     if mtape_open_info.seq_number = 1 then	/* or we want file number 1 */
     1182 		return ("1"b);
     1183 	     if mtape_open_info.next_file then		/* or next (first) file */
     1184 		return ("1"b);
     1185 	end;
     1186 	return ("0"b);
     1187 
     1188      end NEED_TO_INIT_VOLUME;
     1189 
     1190 /* SET_FILE_FORMAT - internal procedure to set file format in file info from open data */
     1191 
     1192 SET_FILE_FORMAT: proc;
     1193 
     1194 	temp_fmt = translate (mtape_open_info.file_format, UC, LC); /* file format in upper case */
     1195 	mtape_file_info.file_code = temp_fmt;		/* set file code */
     1196 	do i = 0 to hbound (IBM_FORMAT_CODES, 1);	/* set the file format */
     1197 	     if temp_fmt = IBM_FORMAT_CODES (i) then	/* found it */
     1198 		mtape_file_info.file_format = i;
     1199 	end;
     1200 	if substr (mtape_file_info.file_code, 1, 1) = "V" then /* if variable block size format */
     1201 	     mtape_file_info.buffer_offset = size (bdw) * 4; /* account for block data word offset */
     1202 
     1203      end SET_FILE_FORMAT;
     1204 
     1205 /* SET_OPEN_IDX - subroutine to determine what kind of opening this is */
     1206 
     1207 SET_OPEN_IDX: proc;
     1208 
     1209 	if mtape_open_info.open_mode = Sequential_input then do; /* input operation? */
     1210 	     output = "0"b;				/* yes, reset output flag */
     1211 	     open_idx = 0;				/* and set input open idx value */
     1212 	end;
     1213 	else do;					/* some type of output operation */
     1214 	     output = "1"b;				/* true if sqo or sqio */
     1215 	     if mtape_open_info.modify then		/* if modifying an existing file */
     1216 		open_idx = 3;
     1217 	     else if mtape_open_info.extend then	/* if extending current file */
     1218 		open_idx = 2;
     1219 	     else open_idx = 1;			/* otherwise create new file */
     1220 	end;
     1221 
     1222      end SET_OPEN_IDX;
     1223 
     1224 /* SET_RECORD_SIZE - internal procedure to set record size either from defaults or as specified by the user */
     1225 
     1226 SET_RECORD_SIZE: proc;
     1227 
     1228 	if mtape_open_info.record_length = MTAPE_UNSPECIFIED then do; /* if no "-record" value specified by user */
     1229 	     if index (mtape_file_info.file_code, "S") ^= 0 then /* if Spanned format */
     1230 		mtape_file_info.record_size = mtape_open_info.default_span_rlen; /* set default */
     1231 	     else if index (mtape_file_info.file_code, "V") ^= 0 then /* if variable format */
     1232 		mtape_file_info.record_size = mtape_open_info.default_var_rlen; /* set default */
     1233 	     else mtape_file_info.record_size = mtape_open_info.default_fix_rlen; /* assume fixed or U format */
     1234 	end;
     1235 	else mtape_file_info.record_size = mtape_open_info.record_length; /* if user specified it */
     1236 
     1237      end SET_RECORD_SIZE;
     1238 
     1239 /* SET_RECORDING_MODE - internal procedure to set the recording mode in the file_info structure */
     1240 
     1241 SET_RECORDING_MODE: proc;
     1242 
     1243 	mtape_file_info.conversion = MTAPE_NO_CONVERSION; /* set no conversion as default */
     1244 	temp_mode = translate (mtape_open_info.recording_mode, UC, LC); /* mode to UC */
     1245 	if temp_mode = "ASCII" then			/* record in standard ascii mode */
     1246 	     mtape_file_info.hdw_mode = MTAPE_HWM_NINE;
     1247 	else if temp_mode = "EBCDIC" then do;		/* record in ebcdic mode */
     1248 	     mtape_file_info.hdw_mode = MTAPE_HWM_NINE;
     1249 	     mtape_file_info.conversion = MTAPE_CV_EBCDIC;/* set conversion for ASCII <==> EBCDIC */
     1250 	end;
     1251 	else mtape_file_info.hdw_mode = MTAPE_HWM_BIN;	/* Must be binary mode */
     1252      end SET_RECORDING_MODE;
     1253 
     1254 /* SETUP - internal procedure to set up enviornment for the external entries */
     1255 
     1256 SETUP: proc;
     1257 
     1258 	mtdp = arg_mtdp;				/* get pointers to pertinient data */
     1259 	vs_ptr = mtape_data.vs_current;
     1260 	fi_ptr = mtape_data.fi_current;
     1261 	maip = mtape_data.attach_info_ptr;
     1262 	moip = mtape_data.open_info_ptr;
     1263 	mpfmip = mtape_data.pfm_info_ptr;
     1264 	arg_code, code = 0;				/* and reset error codes */
     1265 
     1266      end SETUP;
     1267 
     1268 /* SETUP_NEW_FILE - procedure to create a file info structure and initialize it with open options */
     1269 
     1270 SETUP_NEW_FILE: proc;
     1271 
     1272 	if fi_ptr ^= null then			/* if replacing existing file */
     1273 	     if ^mtape_open_info.force then		/* and not ignoring expiration dates */
     1274 		if pfm_utils_$label_unexpired ((mtape_file_info.expiration_date)) then do;	/* if expiration date is in future */
     1275 		     call mtape_$user_query (mtdp, Q_UNEXPIRED_FILE, code); /* ask user what to do */
     1276 		     if code ^= 0 then return;	/* abort file opening on "no" answer */
     1277 		     if mtape_file_info.position_within_file ^= AT_BOFH then do;
     1278 			call pfm_utils_$position_in_file (mtdp, fi_ptr, vs_ptr, AT_BOFH, code);
     1279 			if code ^= 0 then return;
     1280 		     end;
     1281 		end;
     1282 	call pfm_utils_$setup_file (mtdp, fi_ptr, "0"b);	/* do the common stuff first */
     1283 	call SET_FILE_FORMAT;			/* set the file format in file info structure */
     1284 	call SET_RECORDING_MODE;			/* set the recording mode */
     1285 	if mtape_file_info.record_size = MTAPE_UNSPECIFIED then /* no record length */
     1286 	     call SET_RECORD_SIZE;			/* either use given or default */
     1287 	mtape_file_info.gen_version = 0;
     1288 	mtape_file_info.creation_date = pfm_utils_$julian_date (""); /* set todays date */
     1289 	if mtape_open_info.expiration ^= "" then	/* if expiration specified.. */
     1290 	     mtape_file_info.expiration_date = pfm_utils_$julian_date ((mtape_open_info.expiration));
     1291 	else mtape_file_info.expiration_date = " 00000";	/* no expiration specified */
     1292 	mtape_file_info.pfm_opt_sw (1) = mtape_open_info.pfm_opt_sw (1); /* copy DOS flag */
     1293 	mtape_file_info.pfm_opt_sw (2) = mtape_open_info.pfm_opt_sw (2); /* and system_use flag */
     1294 
     1295 SET_FILE_ATTRIBUTES: entry;				/* to set file attributes if not already set */
     1296 
     1297 	if mtape_file_info.file_format = MTAPE_UNSPECIFIED then /* if file format not specified */
     1298 	     call SET_FILE_FORMAT;
     1299 	mtape_file_info.length_mode = NON_MOD_FOUR;	/* set special length mode as default */
     1300 	if mtape_file_info.hdw_mode = MTAPE_UNSPECIFIED then /* recording mode not set */
     1301 	     call SET_RECORDING_MODE;			/* set it */
     1302 	if mtape_file_info.block_size = MTAPE_UNSPECIFIED then /* no block size */
     1303 	     mtape_file_info.block_size = mtape_open_info.block_length; /* use given */
     1304 	if mtape_file_info.record_size = MTAPE_UNSPECIFIED then /* no record length */
     1305 	     call SET_RECORD_SIZE;			/* either use given or default */
     1306 	if mtape_data.conversion = MTAPE_CV_EBCDIC then	/* if converting to ebcdic */
     1307 	     mtape_data.padding_char = IBM_EBCDIC_PAD_CHAR; /* set EBCDIC pad char */
     1308 	else mtape_data.padding_char = IBM_ASCII_PAD_CHAR;/* otherwise set ASCII pad char */
     1309 
     1310      end SETUP_NEW_FILE;
     1311 
     1312 /* WRITE_BLOCK - procedure to write out the current block when full */
     1313 
     1314 WRITE_BLOCK: proc;
     1315 
     1316 	if mtape_data.ad_file_format > 2 then do;	/* if variable length records */
     1317 	     dbl = bit (binary (mtape_data.processed, 18), 18);
     1318 	     if mtape_data.hdw_mode ^= MTAPE_HWM_BIN then /* if not binary mode */
     1319 		substr (dbl, 2, 9) = substr (dbl, 3, 8) || "0"b; /* 9 bit mode, must shift bdw length */
     1320 	     bdw.length = dbl;
     1321 	     bdw.reserved = 0;			/* set MBZ field */
     1322 	end;
     1323 	call mtape_$write_block (mtdp, code);
     1324 	if code ^= 0 then				/* some error */
     1325 	     if code = error_table_$eov_on_write then do; /* Is it end of tape? */
     1326 		call LOAD_PTRS;			/* Load up structure pointers */
     1327 		call EOV_ON_WRITE (WRITING);		/* Go close out volume and initiate volume switch */
     1328 		if code ^= 0 then
     1329 		     go to write_return;		/* If problem, take non-local goto and return */
     1330 	     end;
     1331 	     else go to write_return;			/* other error return to caller */
     1332 
     1333      end WRITE_BLOCK;
     1334 
  1     1 /* BEGIN INCLUDE FILE mtape_includes.incl.pl1. Created by J. A. Bush 07/29/83 */
  1     2 /* This include file contains all of the mtape_ include files necessary for a
  1     3*   Per-Format module to obtain the proper references */
  1     4 
  2     1 /* BEGIN INCLUDE FILE mtape_data.incl.pl1. Created by J. A. Bush 10/06/82  */
  2     2 /* format: style4 */
  2     3 
  2     4 dcl  mtdp ptr;
  2     5 
  2     6 dcl  mtape_data_version_1 char (8) int static options (constant) init ("mtdv0001");
  2     7 
  2     8 dcl  1 mtape_data aligned based (mtdp),
  2     9        2 version char (8),				/* Current structure version */
  2    10        2 areap ptr,					/* Pointer to an allocation area  */
  2    11        2 iocb_ptr ptr,				/* Pointer to our IO control block */
  2    12        2 atdp ptr,					/* Pointer to the attach description string  */
  2    13        2 opdp ptr,					/* Pointer to the open description string */
  2    14        2 cldp ptr,					/* Pointer to close description string */
  2    15        2 dtdp ptr,					/* Pointer to detach description string */
  2    16        2 cmtdp ptr,					/* If non-null, Ptr to allocated copy of mtape_data */
  2    17        2 vs_head ptr,				/* Pointer to the first volume_set structure  */
  2    18        2 vs_tail ptr,				/* Pointer to the last volume_set structure  */
  2    19        2 vs_current ptr,				/* Pointer to the current volume_set structure  */
  2    20        2 vs_mounted_tail ptr,				/* Pointer to MRM volume_set member */
  2    21        2 fi_head ptr,				/* Pointer to the first file_info structure  */
  2    22        2 fi_tail ptr,				/* Pointer to the last file_info structure  */
  2    23        2 fi_current ptr,				/* Pointer to the current file_info structure  */
  2    24        2 tape_infop ptr,				/* Pointer to rcp tape info structure */
  2    25        2 last_ur_status_ptr ptr,			/* If non-null, Ptr to last unrecoverable status */
  2    26        2 io_echan fixed bin (71),			/* Fast wait channel for I/O interrupts */
  2    27        2 mount_echan fixed bin (71),			/* Regular wait channel for mount requests */
  2    28        2 data_xfer_args,				/* Arguments for time critical (read/write) calls */
  2    29          3 arg_buf_ptr ptr,				/* Pointer to users buffer */
  2    30          3 arg_buf_len fixed bin (21),			/* Length of users buffer in bytes */
  2    31          3 arg_rec_len fixed bin (21),			/* Length of record read in bytes */
  2    32        2 error_lock fixed bin (35),			/* if ^= 0 = file locked error code */
  2    33        2 abs_ans char (3),				/* Query answer (yes or no) for abs user */
  2    34        2 user_type bit (1),				/* "1"b => interactive; "0"b => absentee */
  2    35        2 display_errors bit (1),			/* "1"b => display verbose error messages */
  2    36        2 force_end_of_volume bit (1),			/* "1"b => simulate EOV on next write */
  2    37        2 opd_len fixed bin (21),			/* Allocated length of open description */
  2    38        2 drives_in_use fixed bin,			/* Number of tape drives currently in use */
  2    39        2 data_buffers,				/* Info about data buffers */
  2    40          3 buf_ptrs (8) ptr,				/* Pointers to a subset of ioi buffers */
  2    41          3 blind_buf_ptrs (8) ptr,			/* Pointers to other subset of buffers */
  2    42          3 buf_len (8) fixed bin (21),			/* Length of buffers in 9 bit bytes */
  2    43          3 blind_buf_len (8) fixed bin (21),		/* Lengths of other subset of buffers */
  2    44          3 nbufs fixed bin,				/* Number of data buffers currently in use */
  2    45          3 buf_size fixed bin (21),			/* Allocated size of data buffers in bytes */
  2    46          3 bufs_per_subset fixed bin,			/* Number of buffers to write/read per I/O */
  2    47          3 cur_buf_idx fixed bin,			/* Index into subset of current buffer */
  2    48          3 run bit (1),				/* "1"b => wrt I/O queued thru tape_ioi_; "0"b => ^Queued */
  2    49        2 label_buffer,				/* Info about label record buffer */
  2    50          3 lab_bufp ptr,				/* Pointer to label I/O buffer */
  2    51          3 lab_buf_len fixed bin (21),			/* Length of label buffer in 9 bit bytes */
  2    52        2 tlb ptr,					/* Pointer to a temp label record structure */
  2    53        2 position,					/* Position on current volume */
  2    54          3 phy_file fixed bin,			/* physical file number */
  2    55          3 phy_block fixed bin,			/* physical block within physical file */
  2    56        2 current_file,				/* instantanious info about current file */
  2    57          3 cur_block,				/* info about current block */
  2    58 	 4 cur_buf_ptr ptr,				/* Pointer to the current data buffer */
  2    59 	 4 log_record_ptr ptr,			/* Pointer to current logical record */
  2    60 	 4 length fixed bin (21),			/* Length of current block in bytes */
  2    61 	 4 processed fixed bin (21),			/* Number of chars processed already */
  2    62 	 4 remain fixed bin (21),			/* Number of chars remaining to be processed */
  2    63 	 4 log_record fixed bin (21),			/* Log. record within the current block */
  2    64          3 char_size fixed bin,			/* Size in bits of the data chars of this file */
  2    65          3 padding_char char (1),			/* To pad blocks to mod 4 on binary writes */
  2    66          3 length_mode fixed bin,			/* 0 => W/R mod 4 blocks; 1 => W/R non-mod 4 blocks */
  2    67          3 hdw_mode fixed bin,			/* Hardware recording mode:
  2    68*						   1 = binary; 2 = nine track; 3 = BCD */
  2    69          3 conversion fixed bin,			/* File data conversion:
  2    70*						   0 = no conversion; 1 = ASCII<->EBCDIC; 2 = ASCII<->BCD */
  2    71          3 buffer_offset fixed bin,			/* Number of bytes prior to data */
  2    72          3 block_size fixed bin (21),			/* Maximum block size for this file */
  2    73          3 record_size fixed bin (21),			/* Maximum record size for this file */
  2    74          3 prev_block_no fixed bin (21),		/* Number of previous block read */
  2    75          3 ad_file_format fixed bin,			/* 1 = U; 2 = F; 3 = D or V; 4 = S or VS */
  2    76          3 file_blocked bit (1),			/* "1"b => file is blocked */
  2    77          3 native_file bit (1),			/* "1"b => current file written by mtape_ PFM */
  2    78          3 write_after_read bit (1),			/* "1"b => truncate file (and file_set) at this record */
  2    79          3 first_file bit (1),			/* "1"b => first file has been processed */
  2    80          3 tot_bytes_processed fixed bin (35),		/* total bytes in this file section */
  2    81          3 last_io fixed bin,				/* Last I/O operation (1 = read; 2 = write) */
  2    82          3 lrec_rrcx fixed bin,			/* current index of the lrec round robin counter */
  2    83          3 lrec_rrc,				/* history of last n logical records */
  2    84 	 4 block_no (0:7) fixed bin (35),		/* block (within file section) where lrec starts */
  2    85 	 4 block_len (0:7) fixed bin (35),		/* block len of current block */
  2    86 	 4 lrec_no (0:7) fixed bin (35),		/* logical record within currnt block */
  2    87 	 4 abs_byte (0:7) fixed bin (35),		/* byte (within file section) where lrec starts */
  2    88 	 4 byte_offset (0:7) fixed bin,		/* offset of 1st byte of lrec (within block) */
  2    89          3 blk_rrcx fixed bin,			/* index into blk_rrrc array of last block */
  2    90          3 blk_rrrc (0:7) fixed bin (35),		/* contains Lrec count of last n blocks */
  2    91          3 tot_lrec fixed bin (35),			/* Total logical records processed in current file */
  2    92        2 tioi_id bit (36),				/* Identifier used for calls to tape_ioi_ */
  2    93        2 attach_info_ptr ptr,				/* Pointer to attach option info */
  2    94        2 open_info_ptr ptr,				/* Pointer to open option info */
  2    95        2 close_info_ptr ptr,				/* Pointer to close option info */
  2    96        2 detach_info_ptr ptr,				/* Pointer to detach option info */
  2    97        2 pfm_info_ptr ptr,				/* Pointer to PFM info block */
  2    98        2 saved_pfm_info_ptr ptr,			/* Pointer to info for "change_module" control OP */
  2    99        2 pfm_name char (32),				/* Name of Per-Format module */
  2   100        2 pfm_required_entries like pfm_entries,		/* Required entry point declarations in PFM */
  2   101        2 pfm_work_area (32) fixed bin (35);		/* PFM work buffer */
  2   102 
  2   103 dcl  1 pfm_entries based aligned,			/* Entry declarations for PFM entries */
  2   104        2 pfm_init entry (ptr, fixed bin (35)),		/* PFM initialization entry */
  2   105        2 file_open entry (ptr, fixed bin (35)),		/* PFM file_open entry */
  2   106        2 file_close entry (ptr, fixed bin (35)),		/* PFM file_close entry */
  2   107        2 read entry (ptr, fixed bin (35)),		/* PFM read entry */
  2   108        2 write entry (ptr, fixed bin (35)),		/* PFM write entry */
  2   109        2 order entry (ptr, char (*), ptr, ptr, fixed bin (35)), /* PFM control order entry */
  2   110        2 decode_file_labels entry (ptr, ptr, fixed bin, fixed bin, fixed bin (35)),
  2   111        2 encode_file_labels entry (ptr, ptr, fixed bin, fixed bin, fixed bin, fixed bin (35));
  2   112 
  2   113 dcl  all_buf_ptrs (16) ptr based (addr (mtape_data.buf_ptrs));
  2   114 dcl  all_buf_lens (16) fixed bin (21) based (addr (mtape_data.buf_len));
  2   115 dcl  tape_blk (mtape_data.length) char (1) unaligned based (mtape_data.cur_buf_ptr); /* template for a tape block */
  2   116 
  2   117 /* END INCLUDE FILE mtape_data.incl.pl1 */
  1     5 
  1     6 
  3     1 /* BEGIN INCLUDE FILE mtape_vol_set.incl.pl1. Created by J. A. Bush 10/13/82 */
  3     2 /* The include file mtape_err_stats.incl.pl1 is referenced by this include file */
  3     3 /* format: style4 */
  3     4 
  3     5 dcl  vs_ptr ptr;
  3     6 
  3     7 dcl  mtape_vs_version_1 char (8) int static options (constant) init ("mtvsv001");
  3     8 
  3     9 dcl  1 mtape_vol_set aligned based (vs_ptr),
  3    10        2 version char (8),				/* Current version */
  3    11        2 prev_vs_ptr ptr,				/* Pointer to previous volume set entry */
  3    12        2 next_vs_ptr ptr,				/* Pointer to next volume set entry */
  3    13        2 mrm_vs_ptr ptr,				/* Pointer to Most Recently Mounted VS member */
  3    14        2 lrm_vs_ptr ptr,				/* Pointer to Least Recently Mounted VS member */
  3    15        2 first_vl_ptr ptr,				/* Pointer to the first volume label record structure */
  3    16        2 last_vl_ptr ptr,				/* Pointer to the last volume label record structure */
  3    17        2 volume_name char (32),			/* Name specified in the attach description */
  3    18        2 volume_id char (32),				/* Name as recorded in the volume label */
  3    19        2 mount_comment char (64),			/* Mount comment from attach description */
  3    20        2 demount_comment char (64),			/* Demount comment from detach description */
  3    21        2 device_name char (8),			/* Device volume is currently or last mounted on */
  3    22        2 rcp_id bit (36),				/* RCP activation for this volume */
  3    23        2 tioi_id bit (36),				/* tape_ioi_ activation for this volume */
  3    24        2 volume_index fixed bin,			/* Volume sequence number within volume set */
  3    25        2 volume_density fixed bin,			/* Actual volume density determined by RCP */
  3    26        2 volume_type fixed bin,			/* Use rcp_volume_formats.incl.pl1 for decode */
  3    27        2 volume_check fixed bin,			/* Refer to named constants below for values */
  3    28        2 number_of_vol_labels fixed bin,		/* # of volume label records on this volume */
  3    29        2 auth_required bit (1),			/* "1"b => Operator authentication was required */
  3    30        2 mounted bit (1),				/* "1"b => volume currently mounted */
  3    31        2 ever_mounted bit (1),			/* "1"b => volume has been mounted */
  3    32        2 volume_end bit (1),				/* "1"b => reached end of volume (EOT foil) on write */
  3    33        2 first_file_unexpired bit (1),			/* "1"b => first file of volume is unexpired */
  3    34        2 dev_att_retry bit (1),			/* "1"b => DEVICE ATTENTION recovery in progress */
  3    35        2 pwr_off_retry bit (1),			/* "1"b => POWER OFF recovery in progress */
  3    36        2 mounts fixed bin,				/* Number of times volume mounted during attachment */
  3    37        2 tot_error_stats like mtape_err_stats,		/* Summation of error statistics for all mounts */
  3    38        2 rel_error_stats like mtape_err_stats;		/* Summation of error statistics, this mount */
  3    39 
  3    40 /* Named constants applied to volume_check variable, when volume label read by PFMs pfm_init entry */
  3    41 
  3    42 dcl  (MTAPE_VOLUME init (1),				/* Volume recorded by mtape_ (desired type) */
  3    43      MULT_PRIOR_VOLUME init (2),			/* Volume recorded by prior Multics software
  3    44*						   (desired type) */
  3    45      NON_MULT_VOLUME init (3),			/* Volume recorded by other vendor (desired type) */
  3    46      BLANK_VOLUME init (4),				/* Volume is blank/unreadable */
  3    47      UNLABELED_VOLUME init (5),			/* Volume is unlabeled or has unrecognized label */
  3    48      RECOG_FORMAT_VOLUME init (6)			/* Volume has label of other recognized format */
  3    49      ) fixed bin int static options (constant);
  3    50 
  3    51 /* END INCLUDE FILE mtape_vol_set.incl.pl1 */
  1     7 
  1     8 
  4     1 /* BEGIN INCLUDE FILE mtape_label_record.incl.pl1. Created by J. A. Bush 10/13/82 */
  4     2 /* format: style4 */
  4     3 
  4     4 dcl  lr_ptr ptr;
  4     5 
  4     6 dcl  mtape_lr_version_1 char (8) int static options (constant) init ("mtlrv001");
  4     7 
  4     8 dcl  1 mtape_label_record aligned based (lr_ptr),
  4     9        2 version char (8),				/* Current version */
  4    10        2 prev_lab_ptr ptr,				/* Pointer to previous label record structure */
  4    11        2 next_lab_ptr ptr,				/* Pointer to next label record structure */
  4    12        2 lab_ptr ptr,				/* Pointer to the actual format specific label record */
  4    13        2 lab_length fixed bin,			/* Length in 9 bit bytes of the label record */
  4    14        2 mode fixed bin,				/* Hardware recording mode:
  4    15*						   1 = binary
  4    16*						   2 = nine
  4    17*						   3 = bcd */
  4    18        2 conversion fixed bin;			/* Character set conversion required:
  4    19*						   1 = no conversion
  4    20*						   2 = ASCII <==> EBCDIC (any case)
  4    21*						   3 = ASCII <==> BCD
  4    22*						   4 = ASCII ==> Upper case ASCII
  4    23*						   5 = ASCII ==> Upper case EBCDIC */
  4    24 
  4    25 /* END INCLUDE FILE mtape_label_record.incl.pl1 */
  1     9 
  1    10 
  5     1 /* BEGIN INCLUDE FILE mtape_err_stats.incl.pl1. Created by J. A. Bush 07/22/83. */
  5     2 /* format: style4 */
  5     3 
  5     4 dcl  es_ptr ptr;
  5     5 
  5     6 dcl  1 mtape_err_stats aligned based (es_ptr),		/* Error statistics block */
  5     7        2 read like err_entry,				/* For read operations */
  5     8        2 write like err_entry,			/* For write operations */
  5     9        2 orders like err_entry,			/* For non-data xfer operations */
  5    10        2 successful_retry (7) fixed bin (35);		/* retrys that succeeded after 1-7 trys */
  5    11 
  5    12 dcl  1 err_entry aligned based,
  5    13        2 errors fixed bin (35),
  5    14        2 operations fixed bin (35);
  5    15 
  5    16 /* END INCLUDE FILE mtape_err_stats.incl.pl1 */
  1    11 
  1    12 
  6     1 /* BEGIN INCLUDE FILE mtape_file_info.incl.pl1. Created by J. A. Bush 10/13/82 */
  6     2 /* format: style4 */
  6     3 
  6     4 dcl  fi_ptr ptr;
  6     5 
  6     6 dcl  mtape_fi_version_1 char (8) int static options (constant) init ("mtfiv001");
  6     7 
  6     8 dcl  1 mtape_file_info aligned based (fi_ptr),
  6     9        2 version char (8),				/* Current version */
  6    10        2 prev_fi_ptr ptr,				/* Pointer to the previous file info structure */
  6    11        2 next_fi_ptr ptr,				/* Pointer to the next file info structure */
  6    12        2 first_file_lab_ptr ptr,			/* Pointer to 1st label record struc. */
  6    13        2 last_file_lab_ptr ptr,			/* Pointer to last label record struc. */
  6    14        2 first_file_trail_ptr ptr,			/* Pointer to 1st trailer record struc. */
  6    15        2 last_file_trail_ptr ptr,			/* Pointer to last trailer record struc. */
  6    16        2 first_file_section_ptr ptr,			/* Pointer to file_info struct. of 1st file section */
  6    17        2 begin_vs_ptr ptr,				/* Pointer to 1st volume set struct. containing this file */
  6    18        2 end_vs_ptr ptr,				/* Pointer to last volume set struct. containing this file */
  6    19        2 position_within_file fixed bin,		/* 0 = In HDR; 1 = In data file; 2 = In trailer;
  6    20*						   3 = Not positioned within this file
  6    21*						   4 = At beginning of data file; 5 = At EOF */
  6    22        2 per_file_info,				/* Information pertaining to entire file */
  6    23          3 file_id char (32),				/* File identifier or name */
  6    24          3 file_set_id char (32),			/* Identifies the file set */
  6    25          3 creation_date char (6),			/* File creation date in form " yyddd" */
  6    26          3 expiration_date char (6),			/* File expiration date in form " yyddd" */
  6    27          3 file_code char (3),			/* Printable file code */
  6    28          3 file_format fixed bin,			/* Current file format:
  6    29*						   0 = unspecified; 1 = U; 2 = F; 3 = D or V;
  6    30*						   4 = S or VS; 5 = FB;
  6    31*						   6 = DB or VB; 7 = SB or VBS; */
  6    32          3 seq_number fixed bin,			/* File sequence number */
  6    33          3 generation fixed bin,			/* File generation number, if supported */
  6    34          3 gen_version fixed bin,			/* File generation version number, if supported */
  6    35          3 char_size fixed bin,			/* Size in bits of the data chars of this file */
  6    36          3 hdw_mode fixed bin,			/* Hardware mode: 1 = binary; 2 = nine; 3 = BCD */
  6    37          3 conversion fixed bin,			/* File data conversion:
  6    38*						   1 = no conversion; 2 = ASCII<->EBCDIC; 3 = ASCII<->BCD */
  6    39          3 buffer_offset fixed bin,			/* Number of bytes prior to data */
  6    40          3 length_mode fixed bin,			/* 0 => W/R mod 4 blocks; 1 => W/R non-mod 4 blocks */
  6    41          3 block_size fixed bin (21),			/* Maximum block size for this file */
  6    42          3 record_size fixed bin (21),			/* Maximum record size for this file */
  6    43          3 native_file bit (1),			/* "1"b => current file written by mtape_ PFM */
  6    44          3 user_labels_present bit (1),			/* "1"b => UHL<n>/UTL<n> are present */
  6    45          3 unlabeled_file bit (1),			/* "1"b => this is unlabeled file */
  6    46          3 pfm_opt_sw (5) bit (1),			/* PFM dependent */
  6    47          3 pfm_opt_value (5) fixed bin (35),		/* PFM dependent */
  6    48          3 pfm_opt_str (5) char (32),			/* PFM dependent */
  6    49        2 per_section_info,				/* Information pertaining only to this file section */
  6    50          3 section fixed bin,				/* File section number for multi-volume files */
  6    51          3 phy_file fixed bin,			/* Phy. file of HDR label GRP, on the current volume */
  6    52          3 first_file_on_volume bit (1),		/* "1"b => First file or file section on this volume */
  6    53          3 end_of_file_set bit (1),			/* "1"b => This is last file of file set */
  6    54          3 block_count fixed bin (35),			/* Number of blocks in this file section */
  6    55          3 read_errors fixed bin (35),			/* of errors encountered reading this file */
  6    56          3 write_errors fixed bin (35);			/* of errors encountered writing this file */
  6    57 
  6    58 /* END INCLUDE FILE mtape_file_info.incl.pl1 */
  1    13 
  1    14 
  7     1 /* BEGIN INCLUDE FILE mtape_attach_info.incl.pl1. Created by J. A. Bush 06/13/83 */
  7     2 /* format: style4 */
  7     3 
  7     4 dcl  maip ptr;
  7     5 
  7     6 dcl  mtape_attach_info_version_1 char (8) int static options (constant) init ("maiv0001");
  7     7 
  7     8 dcl  1 mtape_attach_info aligned based (maip),
  7     9        2 version char (8),				/* Current structure version */
  7    10        2 density fixed bin (35),			/* 200, 556, 800, 1600, 6250 BPI */
  7    11        2 tracks fixed bin (35),			/* Number of tracks, 7 or 9 */
  7    12        2 speed bit (36),				/* "000"b = any speed; "1xx"b = 75 IPS;
  7    13*						   "x1x"b = 125 IPS; "xx1"b = 200 IPS */
  7    14        2 ndrives fixed bin (35),			/* 0 = unspecified; 1 - 63 devices to be used */
  7    15        2 wait_time fixed bin (35),			/* time to wait in minutes for available device */
  7    16        2 pfm_prefix char (21),			/* if "-volume_type" was specified */
  7    17        2 default_pfm_prefix char (21),			/* if no "-vt" specified and blank volume */
  7    18        2 display bit (1),				/* Display attach description on user_output */
  7    19        2 labeled bit (1),				/* "1"b => labeled; "0"b => unlabeled volume set */
  7    20        2 wait bit (1),				/* "1"b => wait for available devices; "0"b => don't wait */
  7    21        2 system bit (1),				/* "1"b => User wants to be a "system" process */
  7    22        2 ring bit (1);				/* "1"b => write ring in; "0"b => no write ring */
  7    23 
  7    24 /* END INCLUDE FILE mtape_attach_info.incl.pl1 */
  1    15 
  1    16 
  8     1 /*  BEGIN INCLUDE FILE mtape_pfm_info.incl.pl1. Created by J. A. Bush 06/16/83 */
  8     2 /* format: style4 */
  8     3 
  8     4 dcl  mpfmip ptr;
  8     5 
  8     6 dcl  mtape_pfm_info_version_1 char (8) int static options (constant) init ("mpiv0001");
  8     7 
  8     8 dcl  1 mtape_pfm_info aligned based (mpfmip),		/* PFM information block */
  8     9        2 version char (8),				/* Current structure version */
  8    10        2 module_id char (21),				/* For identification of PFM. (e.g. ANSI, IBM, GCOS) */
  8    11        2 open_modes_allowed (3) fixed bin,		/* Allowable open modes for this PFM */
  8    12        2 bof_prefix char (3),				/* For identification of BOF labels */
  8    13        2 eov_prefix char (3),				/* For identification of EOV labels */
  8    14        2 eof_prefix char (3),				/* For identification of EOF labels */
  8    15        2 no_labels_ok bit (1),			/* "1"b => PFM processes unlabeled volumes */
  8    16        2 multi_volumes_ok bit (1),			/* "1"b => PFM processes multi-volume sets */
  8    17        2 extended_error_recovery bit (1),		/* "1"b => PFM will do error recovery after mtape_ gives up */
  8    18        2 pfm_open_options like pfm_options,		/* open options common to this PFM */
  8    19        2 pfm_close_options like pfm_options;		/* close options common to this PFM */
  8    20 
  8    21 dcl  1 pfm_options aligned based,			/* common to open and close pfm options */
  8    22        2 pfm_opt_flags (5),				/* identifies use of "pfm_opt_sw (1-5)" close flags */
  8    23          3 flag_name char (32),			/* name of flag */
  8    24          3 flag_ant_name char (32),			/* antonym name */
  8    25        2 pfm_opt_value_name (5) char (32),		/* identifies use of "pfm_opt_value (1-5)" */
  8    26        2 pfm_opt_str_name (5) char (32);		/* identifies use of "pfm_opt_str (1-5)" */
  8    27 
  8    28 /*  END INCLUDE FILE mtape_pfm_info.incl.pl1 */
  1    17 
  1    18 
  9     1 /* BEGIN INCLUDE FILE mtape_open_close_info.incl.pl1. Created by J. A. Bush 06/13/83 */
  9     2 /* format: style4 */
  9     3 
  9     4 dcl  moip ptr;					/* Pointer to mtape_open_info structure */
  9     5 dcl  mcip ptr;					/* Pointer to mtape_close_info structure */
  9     6 
  9     7 dcl  mtape_open_info_version_1 char (8) int static options (constant) init ("moiv0001");
  9     8 dcl  mtape_close_info_version_1 char (8) int static options (constant) init ("mciv0001");
  9     9 
  9    10 dcl  1 mtape_open_info aligned based (moip),
  9    11        2 version char (8),				/* Current structure version */
  9    12        2 cs_ptr ptr,				/* Pointer to arg processing control structure */
  9    13        2 cal_ptr ptr,				/* Pointer to arg processing ctl arg list */
  9    14        2 so_ptr ptr,				/* Pointer to last saved iox_ options */
  9    15        2 open_mode fixed bin,				/* iox_ opening mode */
  9    16        2 comment char (80),				/* Display on user_output after open */
  9    17        2 expiration char (24),			/* File expiration date */
  9    18        2 file_format char (3),			/* File format code */
  9    19        2 recording_mode char (6),			/* Ascii, ebcdic, or binary */
  9    20        2 file_name char (32),				/* Name of file to be recorded */
  9    21        2 replace_id char (32),			/* Name of file to replace */
  9    22        2 init_to_zero,				/* Enables clearing rest of structure */
  9    23          3 block_length fixed bin (35),			/* Block size in bytes */
  9    24          3 record_length fixed bin (35),		/* Record length specified by user */
  9    25          3 default_span_rlen fixed bin (35),		/* Default record length for spanned records */
  9    26          3 default_var_rlen fixed bin (35),		/* Default record length for variable records */
  9    27          3 default_fix_rlen fixed bin (35),		/* Default record length for fixed records */
  9    28          3 seq_number fixed bin (35),			/* File sequence number */
  9    29          3 append bit (1),				/* "1"b => append file to end of file set */
  9    30          3 create bit (1),				/* "1"b => create this file */
  9    31          3 display bit (1),				/* "1"b => display the open description */
  9    32          3 extend bit (1),				/* "1"b => extend the current file */
  9    33          3 force bit (1),				/* "1"b => disregard file expiration when creating */
  9    34          3 last_file bit (1),				/* "1"b => position to last file of file set */
  9    35          3 next_file bit (1),				/* "1"b => position to next file of file set */
  9    36          3 modify bit (1),				/* "1"b => modify the current file */
  9    37          3 label_entry_present bit (1),			/* "1"b => user label entry is valid */
  9    38          3 user_label entry (ptr, char (*), fixed bin, fixed bin, fixed bin, fixed bin (35)),
  9    39          3 pfm_args like pfm_arg_values;		/* see structure below */
  9    40 
  9    41 dcl  1 mtape_close_info aligned based (mcip),
  9    42        2 version char (8),				/* Current structure version */
  9    43        2 cs_ptr ptr,				/* Pointer to arg processing control structure */
  9    44        2 cal_ptr ptr,				/* Pointer to arg processing ctl arg list */
  9    45        2 so_ptr ptr,				/* Pointer to last saved iox_ options */
  9    46        2 comment char (80),				/* Display on user_output after open */
  9    47        2 init_to_zero,				/* Enables clearing rest of structure */
  9    48          3 display bit (1),				/* Display open description for user */
  9    49          3 position fixed bin,			/* For positioning on file closing:
  9    50*						   0 = Leave at current position;
  9    51*						   1 = Position to beginning of file;
  9    52*						   2 = Position to end of file;
  9    53*						   3 = Position to beginning of file section;
  9    54*						   4 = Position to end of file section */
  9    55          3 pfm_args like pfm_arg_values;		/* see structure below */
  9    56 
  9    57 dcl  1 pfm_arg_values aligned based,			/* Common to open and close_info */
  9    58        2 pfm_opt_sw (5) bit (1),			/* PFM dependent */
  9    59        2 pfm_opt_value (5) fixed bin (35),		/* PFM dependent */
  9    60        2 pfm_opt_str (5) char (32);			/* PFM dependent */
  9    61 
  9    62 /* END INCLUDE FILE mtape_open_close_info.incl.pl1 */
  1    19 
  1    20 
 10     1 /* BEGIN INCLUDE FILE mtape_constants.incl.pl1. Created by J. A. Bush 10/07/82 */
 10     2 /* format: style4 */
 10     3 
 10     4 /* This include file defines various named constants used throughout mtape_
 10     5*   and its associated Per-Format modules */
 10     6 
 10     7 /* Storage allocation constants, used to denote what type of storage to allocate */
 10     8 
 10     9 dcl  (MTAPE_ALLOC_VS init (1),			/* to allocate a volume_set structure */
 10    10      MTAPE_ALLOC_LR init (2),				/* to allocate a label record structure */
 10    11      MTAPE_ALLOC_FI init (3),				/* to allocate a file_info structure */
 10    12      MTAPE_ALLOC_STR init (4)				/* to allocate a character string, or undefined block */
 10    13      ) fixed bin int static options (constant);
 10    14 
 10    15 /* Volume density constants */
 10    16 
 10    17 dcl  MTAPE_VALID_DENSITIES (5) init (200, 556, 800, 1600, 6250)
 10    18 	fixed bin int static options (constant);
 10    19 
 10    20 /* Device speed constants */
 10    21 
 10    22 dcl  MTAPE_SPEED_VALUES (4) init (0, 75, 125, 200)	/* 0 is any speed device */
 10    23 	fixed bin int static options (constant);
 10    24 
 10    25 /* Hardware Mode constants */
 10    26 
 10    27 dcl  (MTAPE_HWM_BIN init (1),				/* For binary hardware mode */
 10    28      MTAPE_HWM_NINE init (2),				/* For nine hardware mode */
 10    29      MTAPE_HWM_BCD init (3)				/* For BCD hardware mode */
 10    30      ) fixed bin int static options (constant);
 10    31 
 10    32 /* Data conversion constants */
 10    33 
 10    34 dcl  (MTAPE_UNSPECIFIED init (0),			/* attribute not specified */
 10    35      MTAPE_NO_CONVERSION init (1),			/* No conversion on input or output */
 10    36      MTAPE_CV_EBCDIC init (2),			/* Convert to/from EBCDIC (from/to ASCII) */
 10    37      MTAPE_CV_BCD init (3),				/* Convert to/from BCD (from/to ASCII) */
 10    38      MTAPE_CV_UC_ASCII init (4),			/* Convert to Upper case ASCII (from any case ASCII) */
 10    39      MTAPE_CV_UC_EBCDIC init (5)			/* Convert to Upper case EBCDIC (from any case ASCII) */
 10    40      ) fixed bin int static options (constant);
 10    41 
 10    42 /* File positioning constants */
 10    43 
 10    44 dcl  (NOT_POSITIONED_IN_FILE init (0),			/* Not currently positioned within this file */
 10    45      AT_BOFH init (1),				/* Positioned at beginning of file hdr */
 10    46      AT_EOFH init (2),				/* Positioned at end of file hdr */
 10    47      AT_BOFD init (3),				/* Positioned at beginning of file data */
 10    48      AT_IFD init (4),				/* Positioned in file data, not beginning */
 10    49      AT_EOFD init (5),				/* Positioned prior to end of data file */
 10    50      AT_BOFT init (6),				/* Positioned at beginning of trailer label file */
 10    51      AT_EOFT init (7),				/* Positioned at end of trailer label file */
 10    52      AT_EOF init (8),				/* Positioned after trailer labels at EOF */
 10    53      FILES_PER_FILE_GRP init (3)			/* # of physical files per file (section) group */
 10    54      ) fixed bin int static options (constant);
 10    55 
 10    56 dcl  (BOF_LABEL init (1),				/* indicates beginning of file label */
 10    57      EOV_LABEL init (2),				/* indicates end of volume label */
 10    58      EOF_LABEL init (3)				/* indicates end of file label */
 10    59      ) fixed bin int static options (constant);
 10    60 
 10    61 /* user query constant codes */
 10    62 
 10    63 dcl  (Q_NO_NEXT_VOLUME init (1),
 10    64      Q_LABELED_VOLUME init (2),
 10    65      Q_UNEXPIRED_VOLUME init (3),
 10    66      Q_INCORRECT_VOLUME init (4),
 10    67      Q_UNEXPIRED_FILE init (5),
 10    68      Q_ABORT_FILE init (6)
 10    69      ) fixed bin int static options (constant);
 10    70 
 10    71 /* END INCLUDE FILE mtape_constants.incl.pl1 */
  1    21 
  1    22 
 11     1 /* BEGIN INCLUDE FILE mtape_dcls.incl.pl1. Created by J. A. Bush 04/20/83 */
 11     2 /* format: style4 */
 11     3 
 11     4 /****^  HISTORY COMMENTS:
 11     5*  1) change(00-01-26,Schroth), approve(00-01-26,MECR-Y2K):
 11     6*     Add declaration of pfm_utils_$label_unexpired for label date expiry checks
 11     7*                                                   END HISTORY COMMENTS */
 11     8 
 11     9 /* Usage: call mtape_$alloc (mtdp, type, link_tail, length, alloc_ptr); */
 11    10 dcl  mtape_$alloc entry (ptr, fixed bin, ptr, fixed bin (21), ptr);
 11    11 
 11    12 /* Usage: call mtape_$allocate_buffers (mtdp, block_size, code); */
 11    13 dcl  mtape_$allocate_buffers entry (ptr, fixed bin (21), fixed bin (35));
 11    14 
 11    15 /* Usage: call mtape_$demount (mtdp, code);
 11    16*dcl  mtape_$demount entry (ptr, fixed bin (35));
 11    17*
 11    18*/* Usage: call mtape_$error (mtdp, code, ioa_cntl_string, arguments); */
 11    19 dcl  mtape_$error entry options (variable);
 11    20 
 11    21 /* Usage: call mtape_$flush_buffers (mtdp, code); */
 11    22 dcl  mtape_$flush_buffers entry (ptr, fixed bin (35));
 11    23 
 11    24 /* Usage: call mtape_$mount (mtdp, code);
 11    25*dcl  mtape_$mount entry (ptr, fixed bin (35));
 11    26*/* Usage: call mtape_$order (mtdp, mnemonic, repeat_count, info_ptr, code); */
 11    27 dcl  mtape_$order entry (ptr, char (*), fixed bin, ptr, fixed bin (35));
 11    28 
 11    29 /* Usage: call mtape_$read_block (mtdp, code); */
 11    30 dcl  mtape_$read_block entry (ptr, fixed bin (35));
 11    31 
 11    32 /* Usage: call mtape_$read_label (mtdp, lr_ptr, code); */
 11    33 dcl  mtape_$read_label entry (ptr, ptr, fixed bin (35));
 11    34 
 11    35 /* Usage: call mtape_$set_mode (mtdp, mode, mode_index, mode_ptr, code); */
 11    36 dcl  mtape_$set_mode entry (ptr, char (*), fixed bin, ptr, fixed bin (35));
 11    37 
 11    38 /* Usage: call mtape_$stop_tape (mtdp, code); */
 11    39 dcl  mtape_$stop_tape entry (ptr, fixed bin (35));
 11    40 
 11    41 /* Usage: call mtape_$user_query (mtdp, query_code, code); */
 11    42 dcl  mtape_$user_query entry (ptr, fixed bin, fixed bin (35));
 11    43 
 11    44 /* Usage: call mtape_$volume_switch (mtdp, new_vs_ptr, code); */
 11    45 dcl  mtape_$volume_switch entry (ptr, ptr, fixed bin (35));
 11    46 
 11    47 /* Usage: call mtape_$write_block (mtdp, code); */
 11    48 dcl  mtape_$write_block entry (ptr, fixed bin (35));
 11    49 
 11    50 /* Usage: call mtape_$write_label (mtdp, lr_ptr, code); */
 11    51 dcl  mtape_$write_label entry (ptr, ptr, fixed bin (35));
 11    52 
 11    53 /* Usage: call pfm_utils_$file_search (mtdp, fi_ptr, vs_ptr, code); */
 11    54 dcl  pfm_utils_$file_search entry (ptr, ptr, ptr, fixed bin (35));
 11    55 
 11    56 /* Usage: call pfm_utils_$init_label_record (mtdp, link_tail, link_head, lr_ptr, length); */
 11    57 dcl  pfm_utils_$init_label_record entry (ptr, ptr, ptr, ptr, fixed bin (21));
 11    58 
 11    59 /* Usage: bool_unexpired = pfm_utils_$label_unexpired (label_date_string); */
 11    60 dcl  pfm_utils_$label_unexpired entry (char (*)) returns (bit (1) aligned);
 11    61 
 11    62 /* Usage: blk_yyddd = pfm_utils_$julian_date (date_time_string); */
 11    63 dcl  pfm_utils_$julian_date entry (char (*)) returns (char (6));
 11    64 
 11    65 /* Usage: call pfm_utils_$position_in_file (mtdp, fi_ptr, vs_ptr, position_constant, code); */
 11    66 dcl  pfm_utils_$position_in_file entry (ptr, ptr, ptr, fixed bin, fixed bin (35));
 11    67 
 11    68 /* Usage: call pfm_utils_$read_file_labels (mtdp, fi_ptr, vs_ptr, label_type, code); */
 11    69 dcl  pfm_utils_$read_file_labels entry (ptr, ptr, ptr, fixed bin, fixed bin (35));
 11    70 
 11    71 /* Usage: call pfm_utils_$setup_file (mtdp, fi_ptr, new_section); */
 11    72 dcl  pfm_utils_$setup_file entry (ptr, ptr, bit (1) aligned);
 11    73 
 11    74 /* Usage: call pfm_utils_$truncate_file_set (mtdp); */
 11    75 dcl  pfm_utils_$truncate_file_set entry (ptr);
 11    76 
 11    77 /* Usage: call pfm_utils_$write_file_labels (mtdp, label_type, code); */
 11    78 dcl  pfm_utils_$write_file_labels entry (ptr, fixed bin, fixed bin (35));
 11    79 
 11    80 /* END INCLUDE FILE mtape_dcls.incl.pl1 */
  1    23 
  1    24 
  1    25 /* END INCLUDE FILE mtape_includes.incl.pl1 */
     1335 
     1336 
 12     1 /* --------------- BEGIN include file rcp_volume_formats.incl.pl1 --------------- */
 12     2 
 12     3 
 12     4 
 12     5 /****^  HISTORY COMMENTS:
 12     6*  1) change(86-12-08,GWMay), approve(86-12-08,PBF7552),
 12     7*     audit(86-12-08,Martinson), install(86-12-17,MR12.0-1250):
 12     8*     added array entry 0 to the volume format types to indicate that the tape
 12     9*     volume was not authenticated by rcp.
 12    10*                                                   END HISTORY COMMENTS */
 12    11 
 12    12 
 12    13 /* General volume types */
 12    14 
 12    15 dcl (Volume_unauthenticated initial (0),
 12    16      Volume_blank initial (1),
 12    17      Volume_unknown_format initial (6),
 12    18      Volume_unreadable initial (7),
 12    19 
 12    20 /* Tape volume types */
 12    21 
 12    22      Volume_multics_tape initial (2),
 12    23      Volume_gcos_tape initial (3),
 12    24      Volume_ibm_tape initial (4),
 12    25      Volume_ansi_tape initial (5)) fixed bin static options (constant);
 12    26 
 12    27 /* Printable descriptions of volume types */
 12    28 
 12    29 dcl  Tape_volume_types (0:7) char (16) static options (constant) initial
 12    30     ("unauthenticated",
 12    31      "blank",
 12    32      "Multics",
 12    33      "GCOS",
 12    34      "IBM",
 12    35      "ANSI",
 12    36      "unrecognizable",
 12    37      "unreadable");
 12    38 
 12    39 /* ---------------- END include file rcp_volume_formats.incl.pl1 ---------------- */
     1337 
     1338 
 13     1 /*  BEGIN INCLUDE FILE:  ibm_vol1.incl.pl1                  */
 13     2 /*  Modified by J. A. Bush 11/06/82 for use by mtape_ */
 13     3 /*  format: style4 */
 13     4 
 13     5 dcl  ibm_vol1P ptr;					/* pointer on which ibm_vol1 is based */
 13     6 
 13     7 dcl  1 ibm_vol1 unaligned based (ibm_vol1P),
 13     8        2 label_id char (4),				/* VOL1 */
 13     9        2 volume_serial char (6),			/* volume serial number (can be alphameric) */
 13    10        2 reserved1 char (1),				/* "0" */
 13    11        2 VTOC_pointer char (10),			/* " " */
 13    12        2 reserved2 char (20),				/* " " */
 13    13        2 owner_id,					/* Owner identifier field (10 characters) */
 13    14          3 auth_code char (3),			/* Multics stores authentication code here */
 13    15          3 mult_id char (7),				/* Inited with MULTICS_IBM_VERSION */
 13    16        2 reserved3 char (29);				/* " " */
 13    17 
 13    18 dcl  IBM_VOL1 char (4) int static options (constant) init ("VOL1");
 13    19 dcl  MULTICS_IBM_VERSION char (7) int static options (constant) /* current mtape_/IBM version */
 13    20 	init ("MULT001");				/* goes in the owner_id2 field */
 13    21 
 13    22 /*  END INCLUDE FILE:  ibm_vol1.incl.pl1                    */
     1339 
     1340 
 14     1 /*  BEGIN INCLUDE FILE:  ibm_hdr1.incl.pl1                  */
 14     2 /*  Modified by J. A. Bush 04/26/83 for use by mtape_ */
 14     3 
 14     4 /* format: style4 */
 14     5 
 14     6 dcl  ibm_hdr1P ptr;					/* pointer on which ibm_hdr1 is based */
 14     7 
 14     8 dcl  1 ibm_hdr1 unaligned based (ibm_hdr1P),
 14     9        2 label_id char (4),				/* HDR1/EOF1/EOV1 */
 14    10        2 dataset_id char (17),			/* equivalent to ANSI file identifier */
 14    11        2 dataset_serial char (6),			/* equivalent to ANSI file set identifier */
 14    12        2 volume_sequence char (4),			/* volume sequence number - no ANSI equivalent */
 14    13        2 dataset_sequence char (4),			/* equivalent to ANSI file sequence number */
 14    14        2 generation char (4),				/* " " if not member of generation data set */
 14    15        2 version char (2),				/* " " if not member of generation data set */
 14    16        2 creation char (6),				/* " yyddd" - equivalent to ANSI creation date */
 14    17        2 expiration char (6),				/* " yyddd" - equivalent to ANSI expiration date */
 14    18        2 security char (1),				/* "0" on output :: ignored on input */
 14    19        2 blkcnt char (6),				/* equivalent to ANSI block count */
 14    20        2 system char (13),				/* system code = "MULTICS IBM2 " for mtape_ */
 14    21        2 reserved char (7);				/* " " */
 14    22 
 14    23 dcl  IBM_L1_ID (3) char (4) int static options (constant) init
 14    24 	("HDR1", "EOV1", "EOF1");
 14    25 dcl  (IBM_HDR1 init (1),
 14    26      IBM_EOV1 init (2),
 14    27      IBM_EOF1 init (3)) fixed bin int static options (constant);
 14    28 dcl  IBM_SYS_CODE char (13) int static options (constant) init ("MULTICS IBM2 ");
 14    29 
 14    30 /*  END INCLUDE FILE:  ibm_hdr1.incl.pl1                    */
     1341 
     1342 
 15     1 /*  BEGIN INCLUDE FILE:  ibm_hdr2.incl.pl1                  */
 15     2 /*  Modified by J. A. Bush 04/26/83 for use by mtape_ */
 15     3 
 15     4 /* format: style4 */
 15     5 
 15     6 dcl  ibm_hdr2P ptr;					/* pointer on which ibm_hdr2 is based */
 15     7 
 15     8 dcl  1 ibm_hdr2 unaligned based (ibm_hdr2P),
 15     9        2 label_id char (4),				/* HDR2/EOF2/EOV2 */
 15    10        2 format char (1),				/* U/F/V */
 15    11        2 blksize char (5),				/* equivalent to ANSI block length - 32760 maximum */
 15    12        2 lrecl char (5),				/* equivalent to ANSI record length - 32760 maximum */
 15    13 						/* for VS and VBS, 0 means lrecl > 32756 */
 15    14        2 density char (1),				/* no ANSI equivalent */
 15    15 						/* 2 = 800 bpi; 3 = 1600 cpi; 4 = 6250 cpi */
 15    16        2 dataset_position char (1),			/* no ANSI equivalent */
 15    17 						/* 0 = no volume switch has occurred */
 15    18 						/* 1 = volume switch has occurred */
 15    19        2 jobstep_id char (17),			/* no ANSI equivalent */
 15    20        2 recording_technique char (2),			/* no ANSI equivalent - "  " = 9 track */
 15    21        2 control_characters char (1),			/* no ANSI equivalent */
 15    22        2 reserved1 char (1),				/* " " */
 15    23        2 block_attribute char (1),			/* no ANSI equivalent */
 15    24 						/* "B" - records are blocked */
 15    25 						/* "S" - records are spanned */
 15    26 						/* "R" - records are blocked and spanned */
 15    27 						/* " " - records are neither blocked nor spanned */
 15    28        2 reserved2 char (41);				/* " " */
 15    29 
 15    30 dcl  1 ibm_system_use unaligned based (addr (ibm_hdr2.reserved2)), /* mtape IBM overlay */
 15    31        2 mode char (1),				/* 1 - ASCII, 9 mode; 2 - EBCDIC, 9 mode; 3 - binary */
 15    32        2 next_volname char (6);			/* Next volume id in EOV2 label */
 15    33 
 15    34 dcl  IBM_L2_ID (3) char (4) int static options (constant) init
 15    35 	("HDR2", "EOV2", "EOF2");
 15    36 dcl  (IBM_HDR2 init (1),
 15    37      IBM_EOV2 init (2),
 15    38      IBM_EOF2 init (3)) fixed bin int static options (constant);
 15    39 
 15    40 /*  END INCLUDE FILE:  ibm_hdr2.incl.pl1                    */
     1343 
     1344 
 16     1 /* Begin include file ..... iox_modes.incl.pl1 */
 16     2 
 16     3 /* Written by C. D. Tavares, 03/17/75 */
 16     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
 16     5 
 16     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
 16     7     ("stream_input", "stream_output", "stream_input_output",
 16     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
 16     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
 16    10      "direct_input", "direct_output", "direct_update");
 16    11 
 16    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
 16    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
 16    14 
 16    15 dcl (Stream_input initial (1),
 16    16      Stream_output initial (2),
 16    17      Stream_input_output initial (3),
 16    18      Sequential_input initial (4),
 16    19      Sequential_output initial (5),
 16    20      Sequential_input_output initial (6),
 16    21      Sequential_update initial (7),
 16    22      Keyed_sequential_input initial (8),
 16    23      Keyed_sequential_output initial (9),
 16    24      Keyed_sequential_update initial (10),
 16    25      Direct_input initial (11),
 16    26      Direct_output initial (12),
 16    27      Direct_update initial (13)) fixed bin int static options (constant);
 16    28 
 16    29 /* End include file ..... iox_modes.incl.pl1 */
     1345 
     1346 
     1347      end ibm_tape_io_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/27/00  1811.8  ibm_tape_io_.pl1                  >udd>sm>ds>y2k>update>ibm_tape_io_.pl1
1335         1    02/16/84  1452.3  mtape_includes.incl.pl1           >ldd>incl>mtape_includes.incl.pl1
1-5          2    02/16/84  1452.3  mtape_data.incl.pl1               >ldd>incl>mtape_data.incl.pl1
1-7          3    02/16/84  1452.4  mtape_vol_set.incl.pl1            >ldd>incl>mtape_vol_set.incl.pl1
1-9          4    02/16/84  1452.3  mtape_label_record.incl.pl1       >ldd>incl>mtape_label_record.incl.pl1
1-11         5    02/16/84  1452.3  mtape_err_stats.incl.pl1          >ldd>incl>mtape_err_stats.incl.pl1
1-13         6    02/16/84  1452.3  mtape_file_info.incl.pl1          >ldd>incl>mtape_file_info.incl.pl1
1-15         7    02/16/84  1452.3  mtape_attach_info.incl.pl1        >ldd>incl>mtape_attach_info.incl.pl1
1-17         8    02/16/84  1452.4  mtape_pfm_info.incl.pl1           >ldd>incl>mtape_pfm_info.incl.pl1
1-19         9    06/11/85  1429.6  mtape_open_close_info.incl.pl1    >ldd>incl>mtape_open_close_info.incl.pl1
1-21        10    02/16/84  1452.3  mtape_constants.incl.pl1          >ldd>incl>mtape_constants.incl.pl1
1-23        11    01/27/00  1752.3  mtape_dcls.incl.pl1               >udd>sm>ds>y2k>update>mtape_dcls.incl.pl1
1337        12    12/17/86  1550.5  rcp_volume_formats.incl.pl1       >ldd>incl>rcp_volume_formats.incl.pl1
1339        13    10/06/83  1413.5  ibm_vol1.incl.pl1                 >ldd>incl>ibm_vol1.incl.pl1
1341        14    10/06/83  1413.5  ibm_hdr1.incl.pl1                 >ldd>incl>ibm_hdr1.incl.pl1
1343        15    10/06/83  1413.5  ibm_hdr2.incl.pl1                 >ldd>incl>ibm_hdr2.incl.pl1
1345        16    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>incl>iox_modes.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
AT_BOFH                         000206 constant        fixed bin(17,0)          initial dcl 10-44 set ref 1277 1278*
AT_EOF                                 constant        fixed bin(17,0)          initial dcl 10-44 ref 305
AT_EOFH                                constant        fixed bin(17,0)          initial dcl 10-44 ref 313
BLANK_VOLUME                           constant        fixed bin(17,0)          initial dcl 3-42 ref 212
BOF_LABEL                       000206 constant        fixed bin(17,0)          initial dcl 10-56 set ref 237* 253* 661 756 789 854
                                                                                  927* 1045
CW_LENGTH                              constant        fixed bin(17,0)          initial dcl 105 set ref 350 359 364 433 436 442*
                                                                                  442* 451 462 466 473* 473 892
EOF_LABEL                       000204 constant        fixed bin(17,0)          initial dcl 10-56 set ref 292* 306* 313* 957
EOV_LABEL                       000202 constant        fixed bin(17,0)          initial dcl 10-56 set ref 601* 636 699 912* 959
IBM_ASCII_PAD_CHAR                     constant        char(1)                  initial packed unaligned dcl 103 ref 1308
IBM_EBCDIC_PAD_CHAR                    constant        char(1)                  initial packed unaligned dcl 104 ref 1306
IBM_EOF1                               constant        fixed bin(17,0)          initial dcl 14-25 ref 605
IBM_FORMAT_CODES                000100 constant        char(3)                  initial array packed unaligned dcl 113 set ref 572
                                                                                  573 672 896* 1196 1197
IBM_HDR1                               constant        fixed bin(17,0)          initial dcl 14-25 ref 510
IBM_HDR2                               constant        fixed bin(17,0)          initial dcl 15-36 ref 537
IBM_L1_ID                       000026 constant        char(4)                  initial array packed unaligned dcl 14-23 ref 510 605
                                                                                  643 854 1045
IBM_L2_ID                       000017 constant        char(4)                  initial array packed unaligned dcl 15-34 ref 537 671
IBM_SYS_CODE                    000022 constant        char(13)                 initial packed unaligned dcl 14-28 ref 534 666 858
IBM_VOL1                        000034 constant        char(4)                  initial packed unaligned dcl 13-18 ref 849 1025
LABEL_LENGTH                    000111 constant        fixed bin(21,0)          initial dcl 98 set ref 149 185* 218 865* 1018*
LC                              000071 constant        char(26)                 initial packed unaligned dcl 115 ref 1194 1244
MAX_IBM_RECORD_SIZE                    constant        fixed bin(17,0)          initial dcl 99 ref 675
MTAPE_ALLOC_FI                  000204 constant        fixed bin(17,0)          initial dcl 10-9 set ref 193*
MTAPE_ALLOC_VS                  000206 constant        fixed bin(17,0)          initial dcl 10-9 set ref 589*
MTAPE_CV_EBCDIC                        constant        fixed bin(17,0)          initial dcl 10-34 ref 557 703 707 1120 1128 1157
                                                                                  1249 1306
MTAPE_CV_UC_EBCDIC                     constant        fixed bin(17,0)          initial dcl 10-34 ref 186 634 867 1020
MTAPE_HWM_BIN                          constant        fixed bin(17,0)          initial dcl 10-27 ref 353 437 468 568 705 886 975
                                                                                  1251 1318
MTAPE_HWM_NINE                         constant        fixed bin(17,0)          initial dcl 10-27 ref 562 564 1245 1248
MTAPE_NO_CONVERSION                    constant        fixed bin(17,0)          initial dcl 10-34 ref 561 567 1243
MTAPE_UNSPECIFIED                      constant        fixed bin(17,0)          initial dcl 10-34 ref 556 1228 1285 1297 1300 1302
                                                                                  1304
MTAPE_VALID_DENSITIES           000035 constant        fixed bin(17,0)          initial array dcl 10-17 ref 690 691
MTAPE_VOLUME                           constant        fixed bin(17,0)          initial dcl 3-42 ref 586 850 1010 1062
MULTICS_IBM_VERSION             000032 constant        char(7)                  initial packed unaligned dcl 13-19 ref 850 1028
MULT_PRIOR_VOLUME                      constant        fixed bin(17,0)          initial dcl 3-42 ref 858
NON_MOD_FOUR                           constant        fixed bin(17,0)          initial dcl 102 ref 555 1299
NON_MULT_VOLUME                        constant        fixed bin(17,0)          initial dcl 3-42 ref 852 858 1176
OPENING                                constant        bit(1)                   initial dcl 101 set ref 254*
Q_NO_NEXT_VOLUME                000206 constant        fixed bin(17,0)          initial dcl 10-63 set ref 638*
Q_UNEXPIRED_FILE                000177 constant        fixed bin(17,0)          initial dcl 10-63 set ref 1275*
Q_UNEXPIRED_VOLUME              000204 constant        fixed bin(17,0)          initial dcl 10-63 set ref 994*
RECOG_FORMAT_VOLUME                    constant        fixed bin(17,0)          initial dcl 3-42 ref 217
SEG_B_E                                constant        fixed bin(17,0)          initial dcl 106 ref 370 380 453 894
SEG_B_NE                               constant        fixed bin(17,0)          initial dcl 106 ref 370 459
SEG_NB_E                               constant        fixed bin(17,0)          initial dcl 106 ref 380 455
SEG_NB_NE                              constant        fixed bin(17,0)          initial dcl 106 ref 461 894
Schecked_labels                 000100 automatic       bit(1)                   dcl 72 set ref 302* 307* 313
Sequential_input                       constant        fixed bin(17,0)          initial dcl 16-15 ref 199 278 1209
Sequential_output                      constant        fixed bin(17,0)          initial dcl 16-15 ref 200
UC                              000062 constant        char(26)                 initial packed unaligned dcl 117 ref 1194 1244
UNLABELED_VOLUME                       constant        fixed bin(17,0)          initial dcl 3-42 ref 215
U_LABEL_ID                      000106 constant        char(3)                  initial array packed unaligned dcl 111 set ref 577
                                                                                  577 598 598 618 618 726* 733
Volume_blank                           constant        fixed bin(17,0)          initial dcl 12-15 ref 212
Volume_ibm_tape                        constant        fixed bin(17,0)          initial dcl 12-15 ref 209 1061
Volume_unknown_format                  constant        fixed bin(17,0)          initial dcl 12-15 ref 215 1009
Volume_unreadable                      constant        fixed bin(17,0)          initial dcl 12-15 ref 212
WRITING                                constant        bit(1)                   initial dcl 100 set ref 286* 409* 929 1327*
ad_file_format          201            based           fixed bin(17,0)          level 3 dcl 2-8 ref 333 413 974 1123 1123 1316
addr                                                   builtin function         dcl 136 ref 360 373 378 441 467 474 558 560 564 566
                                                                                  586 593 593 700 700 705 707 709 764 764 769 769
                                                                                  998 998 1127 1128 1128 1138 1161 1167
areap                     2            based           pointer                  level 2 dcl 2-8 ref 195
arg_buf_len              50            based           fixed bin(21,0)          level 3 dcl 2-8 ref 328 400
arg_buf_ptr              46            based           pointer                  level 3 dcl 2-8 ref 327 399 474 1161
arg_code                               parameter       fixed bin(35,0)          dcl 61 set ref 174 221* 228 265* 273 318* 324 391*
                                                                                  396 477* 483 489* 494 623* 629 739* 1264*
arg_convert                            parameter       fixed bin(17,0)          dcl 68 set ref 629 634* 703*
arg_info_ptr                           parameter       pointer                  dcl 62 ref 483 487
arg_io_call_infop                      parameter       pointer                  dcl 63 ref 483
arg_labno                              parameter       fixed bin(17,0)          dcl 66 set ref 494 501* 513 513* 539 539* 582 585
                                                                                  607 607* 629 635 669 717 718
arg_lr_ptr                             parameter       pointer                  dcl 65 ref 494 497 629 632
arg_mtdp                               parameter       pointer                  dcl 60 ref 174 228 273 324 326 396 398 483 494 629
                                                                                  1258
arg_order_name                         parameter       char                     packed unaligned dcl 64 ref 483 486
arg_rec_len              51            based           fixed bin(21,0)          level 3 dcl 2-8 set ref 386*
arg_type                               parameter       fixed bin(17,0)          dcl 67 set ref 494 508 577 577 598 598 618 618 629
                                                                                  636 643 661 671 699 720* 726 733
ascii_to_ebcdic_                000042 constant        entry                    external dcl 144 ref 1120 1128
attach_info_ptr         274            based           pointer                  level 2 dcl 2-8 ref 1086 1261
auth_code                       000143 automatic       char(3)                  dcl 79 in procedure "ibm_tape_io_" set ref 1016*
                                                                                  1027
auth_code                12(09)        based           char(3)                  level 3 in structure "ibm_vol1" packed packed
                                                                                  unaligned dcl 13-7 in procedure "ibm_tape_io_" set
                                                                                  ref 1027*
authenticate_                   000036 constant        entry                    external dcl 142 ref 1016
based_area                             based           area(1024)               dcl 148 ref 195
based_label_record                     based           char(80)                 packed unaligned dcl 149 set ref 501 501 501* 513
                                                                                  513 513* 539 539 539* 577 598 607 607 607* 618
                                                                                  633* 733* 792 797 798 870* 870 1045*
based_lrec_data                        based           char                     packed unaligned dcl 150 set ref 1120* 1120* 1122*
                                                                                  1122 1157* 1157* 1159* 1159
based_lrec_index                       based           char(1)                  array packed unaligned dcl 151 set ref 474 1161
bdw                                    based           structure                level 1 packed packed unaligned dcl 153 set ref 551
                                                                                  1200
binary                                                 builtin function         dcl 136 ref 356 358 436 466 524 525 526 553 554 582
                                                                                  615 616 764 764 889 891 978 980 1317
bit                                                    builtin function         dcl 136 ref 356 436 466 889 978 1317
blkcnt                   15(18)        based           char(6)                  level 2 packed packed unaligned dcl 14-8 set ref 582
                                                                                  615 663* 665*
blksize                   1(09)        based           char(5)                  level 2 packed packed unaligned dcl 15-8 set ref 553
                                                                                  674*
block_attribute          11(18)        based           char(1)                  level 2 packed packed unaligned dcl 15-8 set ref 548
                                                                                  680* 683* 684* 686*
block_count             156            based           fixed bin(35,0)          level 3 dcl 6-8 set ref 260 582* 615* 662
block_length             66            based           fixed bin(35,0)          level 3 dcl 9-10 ref 1302
block_size               63            based           fixed bin(21,0)          level 3 in structure "mtape_file_info" dcl 6-8
                                                                                  in procedure "ibm_tape_io_" set ref 553* 673 1302
                                                                                  1302*
block_size              176            based           fixed bin(21,0)          level 3 in structure "mtape_data" dcl 2-8
                                                                                  in procedure "ibm_tape_io_" ref 1103 1133
bof_prefix               13            based           char(3)                  level 2 dcl 8-8 set ref 201*
buf_len                         000104 automatic       fixed bin(21,0)          dcl 74 set ref 328* 400* 415* 417 422* 426 431* 433
                                                                                  435 445* 447 1151 1153 1155* 1155
buf_ptr                         000102 automatic       pointer                  dcl 73 set ref 327* 399* 402 474* 1120 1122 1147
                                                                                  1157 1159 1161*
buf_ptrs                 62            based           pointer                  array level 3 dcl 2-8 ref 934
buffer_offset            61            based           fixed bin(17,0)          level 3 in structure "mtape_file_info" dcl 6-8
                                                                                  in procedure "ibm_tape_io_" set ref 551* 1200*
buffer_offset           175            based           fixed bin(17,0)          level 3 in structure "mtape_data" dcl 2-8
                                                                                  in procedure "ibm_tape_io_" ref 283 403
bytes_processed                 000174 automatic       fixed bin(21,0)          dcl 86 set ref 448* 465* 465 474
bytes_remaining                 000173 automatic       fixed bin(21,0)          dcl 86 set ref 447* 451 456 463* 463
close_info_ptr          300            based           pointer                  level 2 dcl 2-8 ref 184 276
code                            000206 automatic       fixed bin(35,0)          dcl 93 set ref 221 232* 233 242 242 242 248 250* 252
                                                                                  253* 254 265 285* 286 286 289 292* 293 297* 298
                                                                                  311* 313 318 329* 388 388* 391 401* 405* 406 406
                                                                                  477 500* 501* 623 638* 639 720* 722 722 726* 729*
                                                                                  737* 739 751* 753* 754 757* 758* 771* 772* 776*
                                                                                  818* 819* 833* 834 835* 843* 844 845* 874* 875
                                                                                  875* 895* 896* 912* 913 916* 917 918* 924 927* 928
                                                                                  930* 931 932* 933 934* 948* 949 949 954* 961 965*
                                                                                  966* 994* 995 998* 999 1000* 1029* 1030 1031*
                                                                                  1046* 1047 1048* 1053* 1054 1055* 1066* 1067 1068*
                                                                                  1072* 1073 1073* 1100* 1103* 1105 1264* 1275* 1276
                                                                                  1278* 1279 1323* 1324 1324 1328
control_characters       11            based           char(1)                  level 2 packed packed unaligned dcl 15-8 set ref
                                                                                  696*
conversion               60            based           fixed bin(17,0)          level 3 in structure "mtape_file_info" dcl 6-8
                                                                                  in procedure "ibm_tape_io_" set ref 557* 561* 567*
                                                                                  707 1243* 1249*
conversion               12            based           fixed bin(17,0)          level 2 in structure "mtape_label_record" dcl 4-8
                                                                                  in procedure "ibm_tape_io_" set ref 186* 867*
                                                                                  1020*
conversion              174            based           fixed bin(17,0)          level 3 in structure "mtape_data" dcl 2-8
                                                                                  in procedure "ibm_tape_io_" ref 1120 1128 1157
                                                                                  1306
conversion                      000210 stack reference condition                dcl 138 in procedure "ibm_tape_io_" ref 499
copy                                                   builtin function         dcl 136 ref 1045 1127
creation                 12(09)        based           char(6)                  level 2 packed packed unaligned dcl 14-8 set ref 527
                                                                                  658*
creation_date            45            based           char(6)                  level 3 dcl 6-8 set ref 527* 658 697 1288*
crl                             000172 automatic       fixed bin(21,0)          dcl 86 set ref 335* 341* 344* 345 356* 358* 359 372
                                                                                  889* 891* 892 1165
cur_block               160            based           structure                level 3 dcl 2-8
cur_buf_idx             145            based           fixed bin(17,0)          level 3 dcl 2-8 ref 934
cur_buf_ptr             160            based           pointer                  level 4 dcl 2-8 ref 551 976 980 1127 1128 1128 1138
                                                                                  1167 1200 1320 1321
current_file            160            based           structure                level 2 dcl 2-8
cwl                                    parameter       fixed bin(17,0)          dcl 1115 ref 1113 1132
data_buffers             62            based           structure                level 2 dcl 2-8
data_xfer_args           46            based           structure                level 2 dcl 2-8
dataset_id                1            based           char(17)                 level 2 packed packed unaligned dcl 14-8 set ref 522
                                                                                  644* 644
dataset_position          4            based           char(1)                  level 2 packed packed unaligned dcl 15-8 set ref
                                                                                  687* 689*
dataset_sequence          7(27)        based           char(4)                  level 2 packed packed unaligned dcl 14-8 set ref 524
                                                                                  649*
dataset_serial            5(09)        based           char(6)                  level 2 packed packed unaligned dcl 14-8 set ref 523
                                                                                  645* 645
dbl                             000175 automatic       bit(18)                  packed unaligned dcl 87 set ref 354* 355* 355 356
                                                                                  436* 437* 437 439 466* 468* 468 470 887* 888* 888
                                                                                  889 976* 977* 977 978 1317* 1318* 1318 1320
default_fix_rlen         72            based           fixed bin(35,0)          level 3 dcl 9-10 ref 1233
default_span_rlen        70            based           fixed bin(35,0)          level 3 dcl 9-10 ref 1229
default_var_rlen         71            based           fixed bin(35,0)          level 3 dcl 9-10 ref 1231
density                   2            based           fixed bin(35,0)          level 2 in structure "mtape_attach_info" dcl 7-8
                                                                                  in procedure "ibm_tape_io_" set ref 998 998 1000*
                                                                                  1008 1060
density                   3(27)        based           char(1)                  level 2 in structure "ibm_hdr2" packed packed
                                                                                  unaligned dcl 15-8 in procedure "ibm_tape_io_" set
                                                                                  ref 694*
desc_type                       000163 automatic       fixed bin(17,0)          dcl 85 set ref 370 370 380 380 453* 455* 459* 461*
                                                                                  471 893* 894 894
ebcdic_to_ascii_                000040 constant        entry                    external dcl 143 ref 1157
eof_prefix               15            based           char(3)                  level 2 dcl 8-8 set ref 203*
eov_prefix               14            based           char(3)                  level 2 dcl 8-8 set ref 202*
err_entry                              based           structure                level 1 dcl 5-12
error_lock               52            based           fixed bin(35,0)          level 2 dcl 2-8 ref 281 282
error_table_$bad_file           000020 external static fixed bin(35,0)          dcl 126 ref 757 771 965
error_table_$end_of_info        000010 external static fixed bin(35,0)          dcl 122 ref 722 729 737 949
error_table_$eov_on_write       000012 external static fixed bin(35,0)          dcl 123 ref 286 406 1324
error_table_$invalid_label_format
                                000030 external static fixed bin(35,0)          dcl 130 set ref 500 513* 539* 607*
error_table_$invalid_record_desc
                                000016 external static fixed bin(35,0)          dcl 125 ref 895
error_table_$long_record        000014 external static fixed bin(35,0)          dcl 124 ref 388 1100 1103
error_table_$no_file            000024 external static fixed bin(35,0)          dcl 128 ref 242
error_table_$no_next_volume     000026 external static fixed bin(35,0)          dcl 129 ref 281
error_table_$no_operation       000022 external static fixed bin(35,0)          dcl 127 ref 489
error_table_$unimplemented_version
                                000032 external static fixed bin(35,0)          dcl 131 ref 818
error_table_$uninitialized_volume
                                000034 external static fixed bin(35,0)          dcl 132 ref 242
expiration               13(27)        based           char(6)                  level 2 in structure "ibm_hdr1" packed packed
                                                                                  unaligned dcl 14-8 in procedure "ibm_tape_io_" set
                                                                                  ref 528 659* 861*
expiration               35            based           char(24)                 level 2 in structure "mtape_open_info" dcl 9-10
                                                                                  in procedure "ibm_tape_io_" ref 1289 1289
expiration_date          47            based           char(6)                  level 3 dcl 6-8 set ref 528* 659 1272 1289* 1291*
extend                   77            based           bit(1)                   level 3 dcl 9-10 ref 1178 1217
extended_error_recovery
                         20            based           bit(1)                   level 2 dcl 8-8 set ref 207*
fi_current               34            based           pointer                  level 2 dcl 2-8 ref 1085 1260
fi_ptr                          000224 automatic       pointer                  dcl 6-4 set ref 193* 194* 195 232* 260 264 264 305
                                                                                  311* 313 513 522 523 524 525 526 527 528 529 530
                                                                                  530 530 530 530 533 534 539 547 551 553 554 555
                                                                                  556 557 558 561 562 564 567 568 571 573 577 582
                                                                                  600 607 615 616 618 644 645 648 650 653 655 658
                                                                                  659 662 669 672 673 675 676 680 680 684 687 697
                                                                                  698 705 707 714 720 752* 752 753* 763 764 764 766
                                                                                  766 769 769 787 789 791 799 896 896 896 896 925*
                                                                                  926* 952* 1085* 1195 1197 1200 1200 1229 1229 1231
                                                                                  1231 1233 1235 1243 1245 1248 1249 1251 1260* 1272
                                                                                  1272 1277 1278* 1282* 1285 1287 1288 1289 1291
                                                                                  1292 1293 1297 1299 1300 1302 1302 1304
file_blocked            202            based           bit(1)                   level 3 dcl 2-8 ref 1134
file_code                51            based           char(3)                  level 3 dcl 6-8 set ref 571* 1195* 1200 1229 1231
file_format              43            based           char(3)                  level 2 in structure "mtape_open_info" dcl 9-10
                                                                                  in procedure "ibm_tape_io_" ref 1194
file_format              52            based           fixed bin(17,0)          level 3 in structure "mtape_file_info" dcl 6-8
                                                                                  in procedure "ibm_tape_io_" set ref 573* 672 680
                                                                                  680 684 896 1197* 1297
file_id                  25            based           char(32)                 level 3 dcl 6-8 set ref 513* 522* 530 530 539* 607*
                                                                                  644 772* 896*
file_set_id              35            based           char(32)                 level 3 dcl 6-8 set ref 523* 645
first_file              205            based           bit(1)                   level 3 dcl 2-8 ref 1180
first_file_lab_ptr        6            based           pointer                  level 2 dcl 6-8 ref 791
first_file_trail_ptr     12            based           pointer                  level 2 dcl 6-8 ref 789
first_file_unexpired    113            based           bit(1)                   level 2 dcl 3-9 set ref 861* 992
first_vl_ptr             12            based           pointer                  level 2 dcl 3-9 set ref 839 865* 1007* 1013 1018*
fixed                                                  builtin function         dcl 136 ref 798
fl_code                         000207 automatic       fixed bin(35,0)          dcl 93 set ref 952* 953 954
flrp                            000270 automatic       pointer                  dcl 785 set ref 789* 791* 792
force                   100            based           bit(1)                   level 3 dcl 9-10 ref 992 1272
format                    1            based           char(1)                  level 2 packed packed unaligned dcl 15-8 set ref 548
                                                                                  551 672*
gen_version              55            based           fixed bin(17,0)          level 3 dcl 6-8 set ref 264* 264 526* 616* 655 1287*
generation               54            based           fixed bin(17,0)          level 3 in structure "mtape_file_info" dcl 6-8
                                                                                  in procedure "ibm_tape_io_" set ref 525* 650 653
generation               10(27)        based           char(4)                  level 2 in structure "ibm_hdr1" packed packed
                                                                                  unaligned dcl 14-8 in procedure "ibm_tape_io_" set
                                                                                  ref 525 650* 654*
hbound                                                 builtin function         dcl 136 ref 572 690 1196
hdw_mode                173            based           fixed bin(17,0)          level 3 in structure "mtape_data" dcl 2-8
                                                                                  in procedure "ibm_tape_io_" set ref 353 437 468
                                                                                  776* 886 930* 975 1318
hdw_mode                 57            based           fixed bin(17,0)          level 3 in structure "mtape_file_info" dcl 6-8
                                                                                  in procedure "ibm_tape_io_" set ref 556* 562* 564*
                                                                                  568* 705 1245* 1248* 1251* 1300
htype                                  parameter       fixed bin(17,0)          dcl 784 set ref 782 789 799*
i                               000162 automatic       fixed bin(17,0)          dcl 85 set ref 572* 573 573* 690* 691 691* 798* 799*
                                                                                  842* 856* 1196* 1197 1197*
ibm_hdr1                               based           structure                level 1 packed packed unaligned dcl 14-8
ibm_hdr1P                       000240 automatic       pointer                  dcl 14-6 set ref 507* 510 522 523 524 525 526 527
                                                                                  528 534 582 605 615 616 642* 643 644 644 645 645
                                                                                  647 649 650 650 654 656 658 659 660 663 665 666
                                                                                  857* 858 861
ibm_hdr2                               based           structure                level 1 packed packed unaligned dcl 15-8
ibm_hdr2P                       000242 automatic       pointer                  dcl 15-6 set ref 507* 537 548 548 551 553 554 558
                                                                                  560 564 566 586 593 593 670* 671 672 674 677 679
                                                                                  680 683 684 686 687 689 694 695 696 697 700 700
                                                                                  705 707 709
ibm_system_use                         based           structure                level 1 packed packed unaligned dcl 15-30
ibm_vol1                               based           structure                level 1 packed packed unaligned dcl 13-7
ibm_vol1P                       000236 automatic       pointer                  dcl 13-5 set ref 840* 849 850 854 857 875 1024* 1025
                                                                                  1026 1026 1027 1028
index                                                  builtin function         dcl 136 ref 1229 1231
info_ptr                        000116 automatic       pointer                  dcl 77 set ref 487*
init_to_zero             34            based           structure                level 2 in structure "mtape_close_info" dcl 9-41
                                                                                  in procedure "ibm_tape_io_"
init_to_zero             66            based           structure                level 2 in structure "mtape_open_info" dcl 9-10
                                                                                  in procedure "ibm_tape_io_"
iocb_ptr                  4            based           pointer                  level 2 dcl 2-8 set ref 720* 799*
jobstep_id                4(09)        based           char(17)                 level 2 packed packed unaligned dcl 15-8 set ref
                                                                                  697*
lab_buf_len             152            based           fixed bin(21,0)          level 3 dcl 2-8 set ref 218*
lab_ptr                   6            based           pointer                  level 2 dcl 4-8 ref 501 501 501 507 513 513 513 539
                                                                                  539 539 577 598 607 607 607 618 633 642 670 733
                                                                                  792 797 798 840 870 870 1024 1045
label_buffer            150            based           structure                level 2 dcl 2-8
label_entry_present     104            based           bit(1)                   level 3 dcl 9-10 ref 713 787
label_id                               based           char(4)                  level 2 in structure "ibm_vol1" packed packed
                                                                                  unaligned dcl 13-7 in procedure "ibm_tape_io_" set
                                                                                  ref 849 854 875* 1025*
label_id                               based           char(4)                  level 2 in structure "ibm_hdr2" packed packed
                                                                                  unaligned dcl 15-8 in procedure "ibm_tape_io_" set
                                                                                  ref 537 671*
label_id                               based           char(4)                  level 2 in structure "ibm_hdr1" packed packed
                                                                                  unaligned dcl 14-8 in procedure "ibm_tape_io_" set
                                                                                  ref 510 605 643*
label_type                      000164 automatic       fixed bin(17,0)          dcl 85 set ref 753* 756 758* 952* 957 959
labeled                  24            based           bit(1)                   level 2 dcl 7-8 ref 1005
last_vl_ptr              14            based           pointer                  level 2 dcl 3-9 set ref 865* 1007* 1018* 1037 1038*
lbound                                                 builtin function         dcl 136 ref 934
length                                 based           bit(18)                  level 3 in structure "vbs_record" packed packed
                                                                                  unaligned dcl 163 in procedure "ibm_tape_io_" set
                                                                                  ref 470* 887 891
length                                 parameter       fixed bin(21,0)          dcl 1096 in procedure "LONG_RECORD_CHECK" ref 1094
                                                                                  1100 1103
length                                 based           bit(18)                  level 3 in structure "vb_record" packed packed
                                                                                  unaligned dcl 157 in procedure "ibm_tape_io_" set
                                                                                  ref 354 358 439*
length                  164            based           fixed bin(21,0)          level 4 in structure "mtape_data" dcl 2-8
                                                                                  in procedure "ibm_tape_io_" set ref 978* 980* 981
                                                                                  1166
length                                 based           bit(18)                  level 2 in structure "bdw" packed packed unaligned
                                                                                  dcl 153 in procedure "ibm_tape_io_" set ref 976
                                                                                  980 1320*
length                                                 builtin function         dcl 136 in procedure "ibm_tape_io_" ref 577 598 618
                                                                                  644 645 700 1026
length_mode             172            based           fixed bin(17,0)          level 3 in structure "mtape_data" dcl 2-8
                                                                                  in procedure "ibm_tape_io_" set ref 932*
length_mode              62            based           fixed bin(17,0)          level 3 in structure "mtape_file_info" dcl 6-8
                                                                                  in procedure "ibm_tape_io_" set ref 555* 1299*
log_record              167            based           fixed bin(21,0)          level 4 dcl 2-8 set ref 896*
log_record_ptr          162            based           pointer                  level 4 dcl 2-8 set ref 337 346 354 358 360 373* 373
                                                                                  378 418 427 439 440 441 467 470 471 472 887 891
                                                                                  893 1138* 1167*
long_record                     000151 automatic       bit(1)                   dcl 83 set ref 330* 388 1150 1152*
lr_ptr                          000222 automatic       pointer                  dcl 4-4 set ref 497* 501 501 501 507 513 513 513 539
                                                                                  539 539 577 598 607 607 607 618 632* 633 642 670
                                                                                  733 792* 792* 794 795* 795 795* 797 798* 801 865*
                                                                                  867 869* 870 871 1018* 1020 1022* 1023 1024 1029*
                                                                                  1037 1038 1039 1044* 1045 1046*
lrecl                     2(18)        based           char(5)                  level 2 packed packed unaligned dcl 15-8 set ref 554
                                                                                  677* 679*
ltrim                                                  builtin function         dcl 136 ref 697
maip                            000226 automatic       pointer                  dcl 7-4 set ref 189* 998 998 1000 1005 1008 1060
                                                                                  1086* 1261*
mcip                            000234 automatic       pointer                  dcl 9-5 set ref 184* 191* 276* 310 311
min_len                                parameter       fixed bin(17,0)          dcl 1116 ref 1113 1136
mod                                                    builtin function         dcl 136 ref 264
mode                                   based           char(1)                  level 2 packed packed unaligned dcl 15-30 set ref
                                                                                  558 560 564 566 705* 707* 709*
modify                  103            based           bit(1)                   level 3 dcl 9-10 ref 1178 1215
module_id                 2            based           char(21)                 level 2 dcl 8-8 set ref 204*
moip                            000232 automatic       pointer                  dcl 9-4 set ref 190* 278 713 720 787 799 992 1087*
                                                                                  1178 1178 1181 1183 1194 1209 1215 1217 1228 1229
                                                                                  1231 1233 1235 1244 1262* 1272 1289 1289 1292 1293
                                                                                  1302
move_len                        000171 automatic       fixed bin(21,0)          dcl 86 set ref 335* 345* 359* 360 373 378 417* 426*
                                                                                  435* 436 441 456* 462* 463 465 466 467 892* 1120
                                                                                  1120 1120 1120 1122 1122 1123 1126 1127 1128 1128
                                                                                  1130* 1132 1147 1151 1153* 1155 1156 1157 1157
                                                                                  1157 1157 1159 1159 1160
move_ptr                        000160 automatic       pointer                  dcl 84 set ref 337* 346* 360* 378* 418* 427* 441*
                                                                                  467* 1120 1122 1157 1159
mpfmip                          000230 automatic       pointer                  dcl 8-4 set ref 192* 199 200 201 202 203 204 205 206
                                                                                  207 1088* 1263*
mtape_$alloc                    000044 constant        entry                    external dcl 11-10 ref 193 589
mtape_$error                    000046 constant        entry                    external dcl 11-19 ref 501 513 539 607 726 758 772
                                                                                  819 835 845 875 896 918 966 1000 1031 1048 1055
                                                                                  1068 1073
mtape_$flush_buffers            000050 constant        entry                    external dcl 11-22 ref 285 405 934
mtape_$order                    000052 constant        entry                    external dcl 11-27 ref 833 874 998 1053 1066 1072
mtape_$read_block               000054 constant        entry                    external dcl 11-30 ref 948
mtape_$read_label               000056 constant        entry                    external dcl 11-33 ref 843
mtape_$set_mode                 000060 constant        entry                    external dcl 11-36 ref 776 930 932
mtape_$stop_tape                000062 constant        entry                    external dcl 11-39 ref 297
mtape_$user_query               000064 constant        entry                    external dcl 11-42 ref 638 994 1275
mtape_$volume_switch            000066 constant        entry                    external dcl 11-45 ref 916
mtape_$write_block              000070 constant        entry                    external dcl 11-48 ref 1323
mtape_$write_label              000072 constant        entry                    external dcl 11-51 ref 1029 1046
mtape_attach_info                      based           structure                level 1 dcl 7-8
mtape_attach_info_version_1     000050 constant        char(8)                  initial packed unaligned dcl 7-6 set ref 189*
mtape_close_info                       based           structure                level 1 dcl 9-41
mtape_close_info_version_1      000042 constant        char(8)                  initial packed unaligned dcl 9-8 set ref 191*
mtape_data                             based           structure                level 1 dcl 2-8
mtape_data_version_1            000060 constant        char(8)                  initial packed unaligned dcl 2-6 set ref 177*
mtape_err_stats                        based           structure                level 1 dcl 5-6
mtape_fi_version_1              000052 constant        char(8)                  initial packed unaligned dcl 6-6 set ref 194*
mtape_file_info                        based           structure                level 1 dcl 6-8 set ref 195
mtape_label_record                     based           structure                level 1 dcl 4-8
mtape_lr_version_1              000054 constant        char(8)                  initial packed unaligned dcl 4-6 set ref 187*
mtape_open_info                        based           structure                level 1 dcl 9-10
mtape_open_info_version_1       000044 constant        char(8)                  initial packed unaligned dcl 9-7 set ref 190*
mtape_pfm_info                         based           structure                level 1 dcl 8-8
mtape_pfm_info_version_1        000046 constant        char(8)                  initial packed unaligned dcl 8-6 set ref 192*
mtape_vol_set                          based           structure                level 1 dcl 3-9
mtape_vs_version_1              000056 constant        char(8)                  initial packed unaligned dcl 3-7 set ref 188*
mtdp                            000216 automatic       pointer                  dcl 2-4 set ref 177* 183 184 185* 185 186 187 193*
                                                                                  195 218 232* 253* 260 262* 276 281 282 283 283
                                                                                  285* 292* 297* 311* 326* 327 328 331 333 335 337
                                                                                  341 341 341 344 346 350 353 354 358 360 364 372
                                                                                  372 373 373 374 378 382 386 398* 399 400 403 403
                                                                                  405* 413 418 424 424 427 433 437 439 440 441 451
                                                                                  462 467 468 470 471 472 474 501* 513* 539* 551
                                                                                  589* 589 590 607* 638* 720 726* 753* 758* 772*
                                                                                  776* 776 799 819* 833* 835* 840 843* 843 845* 865*
                                                                                  870 874* 875* 886 887 891 893 896* 896 896 912*
                                                                                  916* 918* 922 926* 927* 930* 930 932* 932 934 934
                                                                                  934* 948* 952* 966* 974 975 976 978 980 980 981
                                                                                  981 981 994* 998* 1000* 1018* 1029* 1031* 1044
                                                                                  1046* 1048* 1053* 1055* 1066* 1068* 1072* 1073*
                                                                                  1084 1085 1086 1087 1088 1100 1103 1120 1123 1123
                                                                                  1123 1126 1127 1127 1128 1128 1128 1128 1128 1130
                                                                                  1132 1132 1133 1133 1133 1134 1136 1138 1138 1138
                                                                                  1157 1161 1165 1165 1166 1166 1166 1167 1167 1167
                                                                                  1167 1180 1200 1258* 1259 1260 1261 1262 1263
                                                                                  1275* 1278* 1282* 1306 1306 1308 1316 1317 1318
                                                                                  1320 1321 1323*
mult_id                  13            based           char(7)                  level 3 packed packed unaligned dcl 13-7 set ref 850
                                                                                  1028*
multi_volumes_ok         17            based           bit(1)                   level 2 dcl 8-8 set ref 206*
myname                          000112 constant        char(32)                 initial packed unaligned dcl 97 set ref 819*
n_segs                          000165 automatic       fixed bin(17,0)          dcl 85 set ref 368* 370* 450* 453 459*
native_file              65            based           bit(1)                   level 3 dcl 6-8 set ref 534* 558
next_fi_ptr               4            based           pointer                  level 2 dcl 6-8 ref 752
next_file               102            based           bit(1)                   level 3 dcl 9-10 ref 1183
next_lab_ptr              4            based           pointer                  level 2 dcl 4-8 set ref 794 801 871 1023 1039*
next_volname              0(09)        based           char(6)                  level 2 packed packed unaligned dcl 15-30 set ref
                                                                                  586 593 593 700* 700
next_vs_ptr               4            based           pointer                  level 2 dcl 3-9 ref 588 592 636 700 700 915
nlp                             000156 automatic       pointer                  dcl 84 set ref 839* 864 869 871* 1013* 1017 1022
                                                                                  1023*
no_labels_ok             16            based           bit(1)                   level 2 dcl 8-8 set ref 205*
null                                                   builtin function         dcl 136 ref 183 185 185 185 185 193 193 402 530 588
                                                                                  636 700 776 776 795 833 833 864 874 874 925 930
                                                                                  930 932 932 1007 1017 1039 1053 1053 1066 1066
                                                                                  1072 1072 1147 1272
number_of_vol_labels    106            based           fixed bin(17,0)          level 2 dcl 3-9 set ref 856* 1006* 1036*
nvp                             000154 automatic       pointer                  dcl 84 set ref 589* 590 592* 593 593 915* 916*
nxt_lrec                               based           char(1)                  level 2 packed packed unaligned dcl 163 set ref 373
open_idx                        000167 automatic       fixed bin(17,0)          dcl 85 set ref 233 235 1211* 1215* 1217* 1219*
open_info_ptr           276            based           pointer                  level 2 dcl 2-8 ref 1087 1262
open_mode                10            based           fixed bin(17,0)          level 2 dcl 9-10 ref 278 1209
open_modes_allowed       10            based           fixed bin(17,0)          array level 2 dcl 8-8 set ref 199* 200*
order_name                      000106 automatic       char(32)                 packed unaligned dcl 76 set ref 486*
output                          000152 automatic       bit(1)                   dcl 83 set ref 278* 280* 281 305 313 1210* 1214*
ov_len                          000256 automatic       fixed bin(17,0)          dcl 748 set ref 764* 769 769
owner_id                 12(09)        based           structure                level 2 packed packed unaligned dcl 13-7
pad_chars                       000362 automatic       fixed bin(17,0)          dcl 1117 set ref 1126* 1127 1127 1128 1128 1128 1128
padding_char            171            based           char(1)                  level 3 dcl 2-8 set ref 1306* 1308*
per_file_info            25            based           structure                level 2 dcl 6-8 set ref 764 769 769
per_file_overlay                       based           char                     packed unaligned dcl 747 ref 769 769
per_section_info        152            based           structure                level 2 dcl 6-8 set ref 764
pfm_arg_values                         based           structure                level 1 dcl 9-57
pfm_args                112            based           structure                level 3 dcl 9-10
pfm_entries                            based           structure                level 1 dcl 2-103
pfm_info_ptr            304            based           pointer                  level 2 dcl 2-8 ref 1088 1263
pfm_opt_sw              112            based           bit(1)                   array level 4 in structure "mtape_open_info"
                                                                                  dcl 9-10 in procedure "ibm_tape_io_" ref 1292 1293
pfm_opt_sw               70            based           bit(1)                   array level 3 in structure "mtape_file_info" dcl 6-8
                                                                                  in procedure "ibm_tape_io_" set ref 533* 547* 669
                                                                                  698 714 1292* 1293*
pfm_options                            based           structure                level 1 dcl 8-21
pfm_utils_$file_search          000074 constant        entry                    external dcl 11-54 ref 232
pfm_utils_$init_label_record    000076 constant        entry                    external dcl 11-57 ref 185 865 1018
pfm_utils_$julian_date          000102 constant        entry                    external dcl 11-63 ref 1288 1289
pfm_utils_$label_unexpired      000100 constant        entry                    external dcl 11-60 ref 861 1272
pfm_utils_$position_in_file     000104 constant        entry                    external dcl 11-66 ref 311 1278
pfm_utils_$read_file_labels     000106 constant        entry                    external dcl 11-69 ref 753 952
pfm_utils_$setup_file           000110 constant        entry                    external dcl 11-72 ref 926 1282
pfm_utils_$truncate_file_set    000112 constant        entry                    external dcl 11-75 ref 262
pfm_utils_$write_file_labels    000114 constant        entry                    external dcl 11-78 ref 253 292 912 927
phy_block               157            based           fixed bin(17,0)          level 3 dcl 2-8 set ref 260* 896*
pic1                            000176 automatic       picture(1)               packed unaligned dcl 88 set ref 691* 694 732* 733
pic2                            000177 automatic       picture(2)               packed unaligned dcl 89 set ref 655* 656
pic4                            000200 automatic       picture(4)               packed unaligned dcl 90 set ref 646* 647 648* 649
                                                                                  653* 654
pic5                            000202 automatic       picture(5)               packed unaligned dcl 91 set ref 673* 674 676* 677
pic6                            000204 automatic       picture(6)               packed unaligned dcl 92 set ref 662* 663
position                 35            based           fixed bin(17,0)          level 3 in structure "mtape_close_info" dcl 9-41
                                                                                  in procedure "ibm_tape_io_" set ref 310 311*
position                156            based           structure                level 2 in structure "mtape_data" dcl 2-8
                                                                                  in procedure "ibm_tape_io_"
position_within_file     24            based           fixed bin(17,0)          level 2 dcl 6-8 ref 305 313 1277
pp                              000260 automatic       pointer                  dcl 749 set ref 763* 766 766 769 769 772
prev_fi_ptr               2            based           pointer                  level 2 dcl 6-8 ref 530 530 530 763
processed               165            based           fixed bin(21,0)          level 4 dcl 2-8 set ref 283 403 981 1127 1128 1128
                                                                                  1132* 1132 1133 1138 1165* 1165 1166 1167 1317
rcd_pad                                based           char                     packed unaligned dcl 1118 set ref 1127* 1128* 1128*
rdata                     1            based           char                     level 2 in structure "vb_record" packed packed
                                                                                  unaligned dcl 157 in procedure "ibm_tape_io_" set
                                                                                  ref 360 441
rdata                     1            based           char                     level 2 in structure "vbs_record" packed packed
                                                                                  unaligned dcl 163 in procedure "ibm_tape_io_" set
                                                                                  ref 378 467
rdw                                    based           structure                level 2 packed packed unaligned dcl 157
rec_blk_ck                             parameter       bit(1)                   dcl 1097 ref 1094 1099
rec_len                         000105 automatic       fixed bin(21,0)          dcl 75 set ref 329* 386 1147* 1147 1160* 1160 1161
record_length            67            based           fixed bin(35,0)          level 3 dcl 9-10 ref 1228 1235
record_size              64            based           fixed bin(21,0)          level 3 in structure "mtape_file_info" dcl 6-8
                                                                                  in procedure "ibm_tape_io_" set ref 554* 675 676
                                                                                  766 766 766 766* 1229* 1231* 1233* 1235* 1285 1304
record_size             177            based           fixed bin(21,0)          level 3 in structure "mtape_data" dcl 2-8
                                                                                  in procedure "ibm_tape_io_" ref 341 344 424 1100
                                                                                  1123 1126 1130
recording_mode           44            based           char(6)                  level 2 dcl 9-10 ref 1244
recording_technique      10(18)        based           char(2)                  level 2 packed packed unaligned dcl 15-8 set ref
                                                                                  695*
rel                                                    builtin function         dcl 136 ref 764 764
remain                  166            based           fixed bin(21,0)          level 4 dcl 2-8 set ref 331 335 341 341 350 364 372*
                                                                                  372 374 382 424 433 451 462 981* 1133* 1136 1166*
                                                                                  1167
req_version                            parameter       char(8)                  packed unaligned dcl 811 set ref 808 817 819*
reserved                  0(18)        based           fixed bin(17,0)          level 3 in structure "vb_record" packed packed
                                                                                  unaligned dcl 157 in procedure "ibm_tape_io_" set
                                                                                  ref 440*
reserved                  0(27)        based           fixed bin(8,0)           level 3 in structure "vbs_record" packed packed
                                                                                  unaligned dcl 163 in procedure "ibm_tape_io_" set
                                                                                  ref 472*
reserved                  0(18)        based           fixed bin(17,0)          level 2 in structure "bdw" packed packed unaligned
                                                                                  dcl 153 in procedure "ibm_tape_io_" set ref 1321*
reserved2                11(27)        based           char(41)                 level 2 packed packed unaligned dcl 15-8 set ref 558
                                                                                  560 564 566 586 593 593 700 700 705 707 709
ridx                                   parameter       fixed bin(17,0)          dcl 831 set ref 829 850* 852* 858 858*
s_ptr                                  parameter       pointer                  dcl 810 ref 808 817 819
sdw                                    based           structure                level 2 packed packed unaligned dcl 163
section                 152            based           fixed bin(17,0)          level 3 dcl 6-8 set ref 529* 530* 530 687 720* 769
                                                                                  769 799* 896 896*
security                 15(09)        based           char(1)                  level 2 packed packed unaligned dcl 14-8 set ref
                                                                                  660*
seq_number               73            based           fixed bin(35,0)          level 3 in structure "mtape_open_info" dcl 9-10
                                                                                  in procedure "ibm_tape_io_" ref 1181
seq_number               53            based           fixed bin(17,0)          level 3 in structure "mtape_file_info" dcl 6-8
                                                                                  in procedure "ibm_tape_io_" set ref 524* 648
size                                                   builtin function         dcl 136 ref 551 1200
slab                            000170 automatic       fixed bin(17,0)          dcl 85 set ref 714* 716* 717 718 726*
span_indicator            0(18)        based           fixed bin(8,0)           level 3 packed packed unaligned dcl 163 set ref 471*
                                                                                  893
struc_name                             parameter       char(32)                 packed unaligned dcl 812 set ref 808 819*
substr                                                 builtin function         dcl 136 set ref 355* 355 356 437* 437 468* 468 501
                                                                                  501 513 513 539 539 549 549* 577 598 607 607 618
                                                                                  644 645 672 700 792 797 798 858 858 888* 888 889
                                                                                  977* 977 978 1026 1200 1318* 1318
system                   17            based           char(13)                 level 2 packed packed unaligned dcl 14-8 set ref 534
                                                                                  666* 858
tape_blk                               based           char(1)                  array packed unaligned dcl 2-115 set ref 1127 1128
                                                                                  1128 1138 1167
temp_fmt                        000144 automatic       char(3)                  packed unaligned dcl 81 set ref 548* 549 549* 571
                                                                                  573 1194* 1195 1197
temp_mode                       000146 automatic       char(6)                  packed unaligned dcl 82 set ref 1244* 1245 1247
term                            000330 automatic       bit(1)                   dcl 944 in procedure "GET_NXT_RECORD" set ref 946*
                                                                                  947 973*
term                            000150 automatic       bit(1)                   dcl 83 in procedure "ibm_tape_io_" set ref 367* 368
                                                                                  380* 449* 450 452* 841* 842 855* 863
tlb                     154            based           pointer                  level 2 dcl 2-8 set ref 183 185* 186 187* 840 843*
                                                                                  870 1044
translate                                              builtin function         dcl 136 ref 1194 1244
uln                             000166 automatic       fixed bin(17,0)          dcl 85 set ref 718* 720* 726* 732
user_label              106            based           entry variable           level 3 dcl 9-10 ref 720 799
user_label_data                 000120 automatic       char(76)                 packed unaligned dcl 78 set ref 719* 720* 733 797*
                                                                                  799*
user_labels_present      66            based           bit(1)                   level 3 dcl 6-8 set ref 577* 600* 618* 787
vb_record                              based           structure                level 1 packed packed unaligned dcl 157
vbs_record                             based           structure                level 1 packed packed unaligned dcl 163
version                  11(27)        based           char(2)                  level 2 in structure "ibm_hdr1" packed packed
                                                                                  unaligned dcl 14-8 in procedure "ibm_tape_io_" set
                                                                                  ref 526 616 650* 656*
version                                based           char(8)                  level 2 in structure "version_check" dcl 814
                                                                                  in procedure "CHECK_VERSION" set ref 817 819*
version_check                          based           structure                level 1 dcl 814
volume_check            105            based           fixed bin(17,0)          level 2 dcl 3-9 set ref 209* 212* 215* 217* 586
                                                                                  1010* 1062* 1176
volume_density          103            based           fixed bin(17,0)          level 2 dcl 3-9 set ref 691 1008* 1060*
volume_end              112            based           bit(1)                   level 2 dcl 3-9 set ref 254 914*
volume_id                26            based           char(32)                 level 2 dcl 3-9 set ref 772* 835* 845* 875* 1000*
                                                                                  1014* 1016 1026 1031* 1048* 1055* 1068* 1073*
volume_index            102            based           fixed bin(17,0)          level 2 dcl 3-9 ref 646
volume_name              16            based           char(32)                 level 2 dcl 3-9 set ref 593 593* 700 1014
volume_sequence           6(27)        based           char(4)                  level 2 packed packed unaligned dcl 14-8 set ref
                                                                                  647*
volume_serial             1            based           char(6)                  level 2 packed packed unaligned dcl 13-7 set ref
                                                                                  1026* 1026
volume_type             104            based           fixed bin(17,0)          level 2 dcl 3-9 set ref 209 212 212 215 1009* 1061*
vs_current               24            based           pointer                  level 2 dcl 2-8 ref 922 1084 1259
vs_ptr                          000220 automatic       pointer                  dcl 3-5 set ref 188* 209 209 212 212 212 215 215 217
                                                                                  232* 254 311* 586 588 592 636 646 691 700 700 753*
                                                                                  772 835 839 845 856 861 865 865 875 914 915 922*
                                                                                  952* 992 1000 1006 1007 1007 1008 1009 1010 1013
                                                                                  1014 1014 1016 1018 1018 1026 1031 1036 1037 1038
                                                                                  1048 1055 1060 1061 1062 1068 1073 1084* 1176
                                                                                  1259* 1278*
vs_tail                  22            based           pointer                  level 2 dcl 2-8 set ref 589* 590*
who_called                             parameter       bit(1)                   dcl 910 ref 908 929

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
AT_BOFD                                internal static fixed bin(17,0)          initial dcl 10-44
AT_BOFT                                internal static fixed bin(17,0)          initial dcl 10-44
AT_EOFD                                internal static fixed bin(17,0)          initial dcl 10-44
AT_EOFT                                internal static fixed bin(17,0)          initial dcl 10-44
AT_IFD                                 internal static fixed bin(17,0)          initial dcl 10-44
Direct_input                           internal static fixed bin(17,0)          initial dcl 16-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 16-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 16-15
FILES_PER_FILE_GRP                     internal static fixed bin(17,0)          initial dcl 10-44
IBM_EOF2                               internal static fixed bin(17,0)          initial dcl 15-36
IBM_EOV1                               internal static fixed bin(17,0)          initial dcl 14-25
IBM_EOV2                               internal static fixed bin(17,0)          initial dcl 15-36
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 16-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 16-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 16-15
MTAPE_ALLOC_LR                         internal static fixed bin(17,0)          initial dcl 10-9
MTAPE_ALLOC_STR                        internal static fixed bin(17,0)          initial dcl 10-9
MTAPE_CV_BCD                           internal static fixed bin(17,0)          initial dcl 10-34
MTAPE_CV_UC_ASCII                      internal static fixed bin(17,0)          initial dcl 10-34
MTAPE_HWM_BCD                          internal static fixed bin(17,0)          initial dcl 10-27
MTAPE_SPEED_VALUES                     internal static fixed bin(17,0)          initial array dcl 10-22
NOT_POSITIONED_IN_FILE                 internal static fixed bin(17,0)          initial dcl 10-44
Q_ABORT_FILE                           internal static fixed bin(17,0)          initial dcl 10-63
Q_INCORRECT_VOLUME                     internal static fixed bin(17,0)          initial dcl 10-63
Q_LABELED_VOLUME                       internal static fixed bin(17,0)          initial dcl 10-63
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 16-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 16-15
Stream_input                           internal static fixed bin(17,0)          initial dcl 16-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 16-15
Stream_output                          internal static fixed bin(17,0)          initial dcl 16-15
Tape_volume_types                      internal static char(16)                 initial array packed unaligned dcl 12-29
Volume_ansi_tape                       internal static fixed bin(17,0)          initial dcl 12-15
Volume_gcos_tape                       internal static fixed bin(17,0)          initial dcl 12-15
Volume_multics_tape                    internal static fixed bin(17,0)          initial dcl 12-15
Volume_unauthenticated                 internal static fixed bin(17,0)          initial dcl 12-15
all_buf_lens                           based           fixed bin(21,0)          array dcl 2-114
all_buf_ptrs                           based           pointer                  array dcl 2-113
es_ptr                                 automatic       pointer                  dcl 5-4
iox_modes                              internal static char(24)                 initial array dcl 16-6
mtape_$allocate_buffers         000000 constant        entry                    external dcl 11-13
short_iox_modes                        internal static char(4)                  initial array dcl 16-12
today                                  automatic       char(6)                  packed unaligned dcl 80

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_NEW_FILE_SECTION          004443 constant        entry                    internal dcl 745 ref 960
CHECK_USER_LABELS               004671 constant        entry                    internal dcl 782 ref 237 306 313 601
CHECK_VERSION                   005016 constant        entry                    internal dcl 808 ref 177 187 188 189 190 191 192 194
CHECK_VOL_LABELS                005077 constant        entry                    internal dcl 829 ref 209
CONVERT_DESC                    005515 constant        entry                    internal dcl 884 ref 369 376
EOV_ON_WRITE                    005663 constant        entry                    internal dcl 908 ref 254 286 409 1327
GET_NXT_RECORD                  006140 constant        entry                    internal dcl 942 ref 331 350 364 374 382
INIT_VOL_LABELS                 006310 constant        entry                    internal dcl 990 ref 247 923
LOAD_PTRS                       007220 constant        entry                    internal dcl 1082 ref 408 951 1326
LONG_RECORD_CHECK               007241 constant        entry                    internal dcl 1094 ref 415 422 431 445
LTYPE                           000014 constant        label                    array(3) dcl 510 ref 508
MOVE_TO_BUFFER                  007270 constant        entry                    internal dcl 1113 ref 419 428 442 473
MOVE_TO_USER                    007435 constant        entry                    internal dcl 1145 ref 338 347 361 379
NEED_TO_INIT_VOLUME             007543 constant        entry                    internal dcl 1174 ref 246
READ_TYPE                       000004 constant        label                    array(4) dcl 335 ref 333
SETUP                           007772 constant        entry                    internal dcl 1256 ref 176 230 275 485 496 631
SETUP_NEW_FILE                  010020 constant        entry                    internal dcl 1270 ref 251
SET_FILE_ATTRIBUTES             010233 constant        entry                    internal dcl 1295 ref 239 762
SET_FILE_FORMAT                 007603 constant        entry                    internal dcl 1192 ref 1283 1297
SET_OPEN_IDX                    007643 constant        entry                    internal dcl 1207 ref 231
SET_RECORDING_MODE              007735 constant        entry                    internal dcl 1241 ref 1284 1300
SET_RECORD_SIZE                 007672 constant        entry                    internal dcl 1226 ref 1285 1304
WRITE_BLOCK                     010271 constant        entry                    internal dcl 1314 ref 283 403 424 433 1134 1136
WRITE_TYPE                      000010 constant        label                    array(4) dcl 415 ref 413
close_file_return               001670 constant        label                    dcl 318 ref 289 293 298
decode_file_labels              002511 constant        entry                    external dcl 494
dfl_return                      003544 constant        label                    dcl 623 ref 504
efl_return                      004440 constant        label                    dcl 739 ref 639 722 730 734
encode_file_labels              003555 constant        entry                    external dcl 629
file_close                      001503 constant        entry                    external dcl 273
file_open                       001345 constant        entry                    external dcl 228
ibm_tape_io_                    001076 constant        entry                    external dcl 36
open_action                     000000 constant        label                    array(0:3) dcl 237 ref 235
open_return                     001476 constant        label                    dcl 265 ref 233 240 248 252 258
order                           002450 constant        entry                    external dcl 483
pfm_init                        001110 constant        entry                    external dcl 174
pfm_init_return                 001340 constant        label                    dcl 221 ref 822
read                            001675 constant        entry                    external dcl 324
read_return                     002075 constant        label                    dcl 386 ref 339 348 362 901 949 955 957 961 968
write                           002113 constant        entry                    external dcl 396
write_return                    002440 constant        label                    dcl 477 ref 411 420 429 443 1105 1324 1328

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11452       11570   10750       11462
Length     12434   10750       116         630     502           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ibm_tape_io_                       1200 external procedure  is an external procedure.  
on unit on line 499                 108 on unit               
CHECK_NEW_FILE_SECTION                  internal procedure  shares stack frame of external procedure ibm_tape_io_.  
CHECK_USER_LABELS                       internal procedure  shares stack frame of external procedure ibm_tape_io_.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure ibm_tape_io_.  
CHECK_VOL_LABELS                        internal procedure  shares stack frame of external procedure ibm_tape_io_.  
CONVERT_DESC                            internal procedure  shares stack frame of external procedure ibm_tape_io_.  
EOV_ON_WRITE                            internal procedure  shares stack frame of external procedure ibm_tape_io_.  
GET_NXT_RECORD                          internal procedure  shares stack frame of external procedure ibm_tape_io_.  
INIT_VOL_LABELS                         internal procedure  shares stack frame of external procedure ibm_tape_io_.  
LOAD_PTRS                               internal procedure  shares stack frame of external procedure ibm_tape_io_.  
LONG_RECORD_CHECK                       internal procedure  shares stack frame of external procedure ibm_tape_io_.  
MOVE_TO_BUFFER                          internal procedure  shares stack frame of external procedure ibm_tape_io_.  
MOVE_TO_USER                            internal procedure  shares stack frame of external procedure ibm_tape_io_.  
NEED_TO_INIT_VOLUME                     internal procedure  shares stack frame of external procedure ibm_tape_io_.  
SET_FILE_FORMAT                         internal procedure  shares stack frame of external procedure ibm_tape_io_.  
SET_OPEN_IDX                            internal procedure  shares stack frame of external procedure ibm_tape_io_.  
SET_RECORD_SIZE                         internal procedure  shares stack frame of external procedure ibm_tape_io_.  
SET_RECORDING_MODE                      internal procedure  shares stack frame of external procedure ibm_tape_io_.  
SETUP                                   internal procedure  shares stack frame of external procedure ibm_tape_io_.  
SETUP_NEW_FILE                          internal procedure  shares stack frame of external procedure ibm_tape_io_.  
WRITE_BLOCK                             internal procedure  shares stack frame of external procedure ibm_tape_io_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ibm_tape_io_             000100 Schecked_labels             ibm_tape_io_
                         000102 buf_ptr                     ibm_tape_io_
                         000104 buf_len                     ibm_tape_io_
                         000105 rec_len                     ibm_tape_io_
                         000106 order_name                  ibm_tape_io_
                         000116 info_ptr                    ibm_tape_io_
                         000120 user_label_data             ibm_tape_io_
                         000143 auth_code                   ibm_tape_io_
                         000144 temp_fmt                    ibm_tape_io_
                         000146 temp_mode                   ibm_tape_io_
                         000150 term                        ibm_tape_io_
                         000151 long_record                 ibm_tape_io_
                         000152 output                      ibm_tape_io_
                         000154 nvp                         ibm_tape_io_
                         000156 nlp                         ibm_tape_io_
                         000160 move_ptr                    ibm_tape_io_
                         000162 i                           ibm_tape_io_
                         000163 desc_type                   ibm_tape_io_
                         000164 label_type                  ibm_tape_io_
                         000165 n_segs                      ibm_tape_io_
                         000166 uln                         ibm_tape_io_
                         000167 open_idx                    ibm_tape_io_
                         000170 slab                        ibm_tape_io_
                         000171 move_len                    ibm_tape_io_
                         000172 crl                         ibm_tape_io_
                         000173 bytes_remaining             ibm_tape_io_
                         000174 bytes_processed             ibm_tape_io_
                         000175 dbl                         ibm_tape_io_
                         000176 pic1                        ibm_tape_io_
                         000177 pic2                        ibm_tape_io_
                         000200 pic4                        ibm_tape_io_
                         000202 pic5                        ibm_tape_io_
                         000204 pic6                        ibm_tape_io_
                         000206 code                        ibm_tape_io_
                         000207 fl_code                     ibm_tape_io_
                         000216 mtdp                        ibm_tape_io_
                         000220 vs_ptr                      ibm_tape_io_
                         000222 lr_ptr                      ibm_tape_io_
                         000224 fi_ptr                      ibm_tape_io_
                         000226 maip                        ibm_tape_io_
                         000230 mpfmip                      ibm_tape_io_
                         000232 moip                        ibm_tape_io_
                         000234 mcip                        ibm_tape_io_
                         000236 ibm_vol1P                   ibm_tape_io_
                         000240 ibm_hdr1P                   ibm_tape_io_
                         000242 ibm_hdr2P                   ibm_tape_io_
                         000256 ov_len                      CHECK_NEW_FILE_SECTION
                         000260 pp                          CHECK_NEW_FILE_SECTION
                         000270 flrp                        CHECK_USER_LABELS
                         000330 term                        GET_NXT_RECORD
                         000362 pad_chars                   MOVE_TO_BUFFER

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               alloc_char_temp     call_ent_var_desc   call_ext_out_desc   call_ext_out        return_mac
tra_ext_1           mpfx2               mdfx1               enable_op           shorten_stack       ext_entry
ext_entry_desc      int_entry           any_to_any_truncate_op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ascii_to_ebcdic_              authenticate_                 ebcdic_to_ascii_              mtape_$alloc
mtape_$error                  mtape_$flush_buffers          mtape_$order                  mtape_$read_block
mtape_$read_label             mtape_$set_mode               mtape_$stop_tape              mtape_$user_query
mtape_$volume_switch          mtape_$write_block            mtape_$write_label            pfm_utils_$file_search
pfm_utils_$init_label_record  pfm_utils_$julian_date        pfm_utils_$label_unexpired    pfm_utils_$position_in_file
pfm_utils_$read_file_labels   pfm_utils_$setup_file         pfm_utils_$truncate_file_set  pfm_utils_$write_file_labels

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_file         error_table_$end_of_info      error_table_$eov_on_write
error_table_$invalid_label_format                           error_table_$invalid_record_desc
error_table_$long_record      error_table_$no_file          error_table_$no_next_volume   error_table_$no_operation
error_table_$unimplemented_version                          error_table_$uninitialized_volume




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     36 001075       174 001103       176 001120       177 001121       183 001126       184 001133       185 001135
    186 001157       187 001163       188 001200       189 001205       190 001212       191 001217       192 001224
    193 001231       194 001253       195 001260       199 001262       200 001265       201 001267       202 001271
    203 001273       204 001275       205 001300       206 001302       207 001303       209 001304       212 001317
    215 001326       217 001333       218 001335       221 001340       223 001342       228 001343       230 001355
    231 001356       232 001357       233 001374       235 001401       237 001403       239 001405       240 001406
    242 001407       246 001416       247 001423       248 001424       250 001426       251 001427       252 001430
    253 001432       254 001445       258 001454       260 001455       262 001461       264 001470       265 001476
    268 001500       273 001501       275 001513       276 001514       278 001517       280 001525       281 001527
    282 001536       283 001540       285 001544       286 001555       289 001564       292 001566       293 001601
    295 001603       297 001604       298 001615       302 001617       305 001620       306 001626       307 001630
    310 001632       311 001635       313 001654       318 001670       320 001672       324 001673       326 001705
    327 001711       328 001713       329 001715       330 001717       331 001720       333 001723       335 001726
    337 001731       338 001733       339 001734       341 001735       344 001743       345 001744       346 001745
    347 001747       348 001750       350 001751       353 001755       354 001761       355 001766       356 001772
    357 001775       358 001776       359 002005       360 002007       361 002012       362 002013       364 002014
    367 002020       368 002021       369 002026       370 002027       372 002036       373 002041       374 002046
    376 002051       377 002052       378 002053       379 002057       380 002060       382 002067       384 002073
    386 002075       388 002100       391 002107       392 002110       396 002111       398 002123       399 002127
    400 002131       401 002133       402 002134       403 002140       405 002144       406 002155       408 002162
    409 002163       411 002165       413 002166       415 002170       417 002174       418 002176       419 002201
    420 002205       422 002206       424 002212       426 002217       427 002221       428 002224       429 002231
    431 002232       433 002236       435 002244       436 002246       437 002254       439 002272       440 002276
    441 002301       442 002303       443 002305       445 002306       447 002312       448 002314       449 002315
    450 002316       451 002322       452 002327       453 002331       455 002337       456 002341       457 002343
    459 002344       461 002352       462 002354       463 002357       465 002361       466 002363       467 002371
    468 002374       470 002411       471 002414       472 002422       473 002425       474 002431       475 002436
    477 002440       479 002442       483 002443       485 002466       486 002467       487 002475       489 002500
    490 002503       494 002504       496 002521       497 002522       499 002526       500 002542       501 002545
    504 002613       507 002616       508 002622       510 002625       513 002634       522 002712       523 002717
    524 002722       525 002734       526 002750       527 002764       528 002772       529 002776       530 003000
    533 003014       534 003016       536 003023       537 003024       539 003032       547 003110       548 003112
    549 003127       551 003136       553 003143       554 003155       555 003171       556 003174       557 003176
    558 003200       560 003213       561 003216       562 003220       563 003222       564 003223       566 003230
    567 003232       568 003234       571 003236       572 003241       573 003245       575 003256       576 003260
    577 003261       580 003275       582 003276       585 003315       586 003317       588 003327       589 003333
    590 003354       591 003357       592 003360       593 003362       597 003373       598 003374       600 003404
    601 003407       604 003411       605 003412       607 003421       615 003477       616 003513       617 003527
    618 003530       623 003544       625 003546       629 003547       631 003565       632 003566       633 003572
    634 003576       635 003600       636 003603       638 003613       639 003626       642 003630       643 003633
    644 003641       645 003645       646 003650       647 003660       648 003663       649 003672       650 003675
    653 003706       654 003715       655 003720       656 003730       658 003733       659 003736       660 003741
    661 003744       662 003750       663 003760       664 003763       665 003764       666 003767       667 003772
    669 003773       670 004000       671 004001       672 004006       673 004013       674 004023       675 004026
    676 004031       677 004041       678 004044       679 004045       680 004050       683 004061       684 004065
    686 004073       687 004076       689 004105       690 004110       691 004117       693 004134       694 004136
    695 004142       696 004145       697 004150       698 004202       699 004205       700 004211       703 004222
    705 004224       707 004234       709 004243       711 004246       713 004247       714 004252       716 004260
    717 004262       718 004265       719 004270       720 004273       722 004326       726 004333       729 004376
    730 004401       732 004402       733 004412       734 004434       737 004435       739 004440       741 004442
    745 004443       751 004444       752 004445       753 004450       754 004467       756 004472       757 004475
    758 004500       760 004527       762 004530       763 004531       764 004534       766 004553       769 004564
    771 004575       772 004600       776 004633       778 004670       782 004671       787 004673       789 004701
    791 004707       792 004711       794 004720       795 004723       797 004730       798 004735       799 004752
    801 005011       804 005015       808 005016       817 005020       818 005027       819 005032       822 005075
    825 005076       829 005077       833 005101       834 005136       835 005140       837 005171       839 005172
    840 005175       841 005201       842 005202       843 005206       844 005222       845 005224       847 005255
    849 005256       850 005265       852 005275       853 005300       854 005301       855 005304       856 005306
    857 005312       858 005313       861 005326       863 005346       864 005350       865 005354       867 005374
    868 005377       869 005400       870 005402       871 005412       873 005415       874 005417       875 005455
    880 005514       884 005515       886 005516       887 005522       888 005526       889 005532       890 005535
    891 005536       892 005545       893 005547       894 005556       895 005561       896 005564       901 005661
    904 005662       908 005663       912 005665       913 005700       914 005703       915 005705       916 005707
    917 005722       918 005724       920 005750       922 005751       923 005754       924 005755       925 005760
    926 005762       927 005777       928 006012       929 006015       930 006022       931 006057       932 006062
    933 006117       934 006122       938 006137       942 006140       946 006141       947 006142       948 006144
    949 006155       951 006162       952 006163       953 006202       954 006204       955 006205       957 006206
    959 006211       960 006213       961 006214       963 006216       965 006217       966 006222       968 006245
    970 006246       973 006247       974 006251       975 006255       976 006260       977 006264       978 006270
    979 006273       980 006274       981 006303       984 006306       986 006307       990 006310       992 006311
    994 006320       995 006333       998 006336       999 006374      1000 006376      1003 006433      1005 006434
   1006 006437      1007 006441      1008 006445      1009 006451      1010 006453      1011 006455      1013 006456
   1014 006461      1016 006465      1017 006505      1018 006511      1020 006531      1021 006534      1022 006535
   1023 006537      1024 006542      1025 006545      1026 006550      1027 006554      1028 006557      1029 006562
   1030 006575      1031 006577      1034 006630      1036 006631      1037 006634      1038 006640      1039 006642
   1044 006645      1045 006650      1046 006664      1047 006677      1048 006701      1051 006732      1053 006733
   1054 006771      1055 006773      1058 007024      1060 007025      1061 007031      1062 007033      1066 007035
   1067 007072      1068 007074      1070 007125      1072 007126      1073 007164      1077 007217      1082 007220
   1084 007221      1085 007224      1086 007227      1087 007232      1088 007235      1090 007240      1094 007241
   1099 007243      1100 007246      1102 007255      1103 007256      1105 007265      1108 007267      1113 007270
   1120 007272      1122 007322      1123 007330      1126 007341      1127 007344      1128 007353      1130 007405
   1132 007410      1133 007415      1134 007420      1136 007424      1138 007430      1141 007434      1145 007435
   1147 007436      1150 007445      1151 007447      1152 007452      1153 007454      1155 007456      1156 007460
   1157 007462      1159 007512      1160 007520      1161 007522      1165 007527      1166 007532      1167 007535
   1170 007542      1174 007543      1176 007545      1178 007554      1180 007563      1181 007566      1183 007574
   1186 007601      1192 007603      1194 007604      1195 007611      1196 007615      1197 007621      1199 007631
   1200 007633      1203 007642      1207 007643      1209 007644      1210 007650      1211 007651      1212 007652
   1214 007653      1215 007655      1217 007662      1219 007667      1222 007671      1226 007672      1228 007673
   1229 007676      1231 007713      1233 007727      1234 007731      1235 007732      1237 007734      1241 007735
   1243 007736      1244 007741      1245 007747      1247 007757      1248 007762      1249 007764      1250 007766
   1251 007767      1252 007771      1256 007772      1258 007773      1259 007777      1260 010001      1261 010004
   1262 010007      1263 010012      1264 010015      1266 010017      1270 010020      1272 010021      1275 010054
   1276 010067      1277 010072      1278 010076      1279 010115      1282 010120      1283 010135      1284 010136
   1285 010137      1287 010143      1288 010145      1289 010167      1291 010222      1292 010225      1293 010230
   1295 010232      1297 010234      1299 010240      1300 010243      1302 010246      1304 010254      1306 010257
   1308 010266      1310 010270      1314 010271      1316 010272      1317 010276      1318 010303      1320 010320
   1321 010324      1323 010327      1324 010340      1326 010345      1327 010346      1328 010350      1333 010352


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
