	COMPILATION LISTING OF SEGMENT cpm_initialize_
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 07/05/88  1432.0 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1985 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /* format: off */
       10 
       11 /* Per-process initialization of the Multics Control Point Manager (cpm_) */
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
       15*     audit(86-10-20,Fawcett), install(86-11-03,MR12.0-1206):
       16*     Written to support control point management in March 1985 by G. Palter
       17*     based on C. Hornig's task_init_.
       18*  2) change(88-04-25,Farley), approve(88-05-26,MCR7901), audit(88-06-07,GWMay),
       19*     install(88-07-05,MR12.2-1053):
       20*     Changed RNT area expansion code to use stack_header.rnt_ptr directly,
       21*     instead of copying to the automatic rntp variable.  The RNT area can move
       22*     and using the stack_header is the only sure way of referencing the correct
       23*     location.  Also inhibit interrupts during this period.
       24*                                                   END HISTORY COMMENTS */
       25 
       26 /* format: style3,linecom */
       27 
       28 cpm_initialize_:
       29      procedure ();
       30 
       31 dcl	1 local_ai	aligned like area_info;
       32 
       33 dcl	control_point_id_string
       34 			character (12);
       35 
       36 dcl	code		fixed binary (35);
       37 
       38 dcl	new_rnt_area	area (local_ai.size) based (local_ai.areap);
       39 dcl	old_rnt_area	area (old_area_size) based (old_areap);
       40 dcl	rnt_area		area (stack_header.rnt_ptr -> rnt.rnt_area_size) based (stack_header.rnt_ptr -> rnt.areap);
       41 dcl	new_rntp		pointer;
       42 dcl	old_areap		pointer;
       43 dcl	old_area_size	fixed bin (18);
       44 
       45 dcl	old_mask		bit (36) aligned;
       46 
       47 dcl	system_area	area based (system_area_ptr);
       48 dcl	system_area_ptr	pointer;
       49 
       50 dcl	sys_info$max_seg_size
       51 			fixed binary (19) external;
       52 
       53 dcl	cpm_$nulle	entry () options (variable);
       54 dcl	cpm_overseer_$cl_intermediary
       55 			entry (bit (36) aligned);
       56 dcl	(
       57 	cu_$get_cl_intermediary,
       58 	cu_$set_cl_intermediary
       59 	)		entry (entry (bit (36) aligned));
       60 dcl	define_area_	entry (pointer, fixed binary (35));
       61 dcl	get_privileges_	entry () returns (bit (36) aligned);
       62 dcl	get_ring_		entry () returns (fixed binary (3));
       63 dcl	get_system_free_area_
       64 			entry () returns (pointer);
       65 dcl	hcs_$get_ips_mask	entry (bit (36) aligned);
       66 dcl	hcs_$reset_ips_mask entry (bit (36) aligned, bit (36) aligned);
       67 dcl	hcs_$set_ips_mask	entry (bit (36) aligned, bit (36) aligned);
       68 dcl	hcs_$grow_lot	entry (fixed binary (3));
       69 dcl	ioa_$rsnnl	entry () options (variable);
       70 dcl	sub_err_		entry () options (variable);
       71 dcl	user_info_$usage_data
       72 			entry (fixed binary, fixed binary (71), fixed binary (71), fixed binary (71),
       73 			fixed binary (71), fixed binary (71));
       74 
       75 dcl	(addr, addwordno, baseno, binary, empty, length, null, stackbaseptr, string, substr, unspec, wordno)
       76 			builtin;
       77 
       78 dcl	cleanup		condition;
       79 
       80 /* cpm_initialize_: entry (); */
       81 
       82 	sb = stackbaseptr ();
       83 	system_area_ptr = get_system_free_area_ ();
       84 
       85 
       86 /* Grow the LOT to its maximum size -- Otherwise, when ring 0 grows the LOT, it will only update the LOT and ISOT pointers
       87*   in the header of the stack which happens to be running at the time.  The stacks of the other control points would, as a
       88*   result, contain incorrect LOT and ISOT pointers and the process would not be long for the world */
       89 
       90 	if stack_header.cur_lot_size < stack_header.max_lot_size
       91 	then call hcs_$grow_lot (get_ring_ ());
       92 
       93 
       94 /* Grow the RNT to a full segment for the same reasons as above */
       95 
       96 	if stack_header.rnt_ptr -> rnt.rnt_area_size < sys_info$max_seg_size
       97 	then do;
       98 
       99 		old_mask = "0"b;
      100 		on cleanup
      101 		     begin;
      102 			if old_mask
      103 			then call hcs_$reset_ips_mask (old_mask, old_mask);
      104 		     end;
      105 		call hcs_$set_ips_mask ("0"b, old_mask);
      106 
      107 		local_ai.version = area_info_version_1;
      108 		string (local_ai.control) = ""b;
      109 		local_ai.zero_on_free = "1"b;		/* set control flags expected by ring 0 */
      110 		local_ai.system = "1"b;
      111 		local_ai.owner = "RNT";
      112 		local_ai.size = sys_info$max_seg_size;
      113 		local_ai.areap = null ();		/* let define_area_ find us a segment */
      114 
      115 		call define_area_ (addr (local_ai), code);
      116 		if code ^= 0
      117 		then call sub_err_ (code, cpm_data_$subsystem_name, ACTION_CANT_RESTART, null (), 0,
      118 			"Growing the RNT.");
      119 
      120 		old_area_size = stack_header.rnt_ptr -> rnt.rnt_area_size;
      121 		new_rnt_area = rnt_area;		/* copy the RNT contents to its new area */
      122 
      123 		if old_area_size ^= stack_header.rnt_ptr -> rnt.rnt_area_size
      124 		then do;				/* Ooops, the RNT grew/moved while copying */
      125 			new_rnt_area = empty;
      126 			new_rnt_area = rnt_area;
      127 		     end;
      128 
      129 		new_rntp =
      130 		     addwordno (local_ai.areap, relwordno (stack_header.rnt_ptr, stack_header.rnt_ptr -> rnt.areap));
      131 		new_rntp -> rnt.srulep =
      132 		     addwordno (local_ai.areap,
      133 		     relwordno (stack_header.rnt_ptr -> rnt.srulep, stack_header.rnt_ptr -> rnt.areap));
      134 		new_rntp -> rnt.areap = local_ai.areap;
      135 		new_rntp -> rnt.rnt_area_size = local_ai.size;
      136 
      137 		old_areap = stack_header.rnt_ptr -> rnt.areap;
      138 		old_area_size = stack_header.rnt_ptr -> rnt.rnt_area_size;
      139 
      140 		stack_header.rnt_ptr = new_rntp;	/* switch to the new RNT ... */
      141 		free old_rnt_area in (system_area);	/* ... and get rid of the old one */
      142 
      143 		call hcs_$reset_ips_mask (old_mask, old_mask);
      144 		revert cleanup;
      145 	     end;
      146 
      147 
      148 /* Setup the definition of the root control point -- The root control point is the control point which uses the "normal"
      149*   stack in the current ring */
      150 
      151 	cpd_ptr = addr (cpm_data_$root_control_point_data);
      152 
      153 	control_point_data.id,			/* generate the standard unique ID */
      154 	     control_point_data.group_id = baseno (sb);
      155 
      156 	control_point_data.state = CPM_READY;		/* it must be ready -- we're using it now */
      157 
      158 	string (control_point_data.flags) = ""b;
      159 	control_point_data.preferred = "1"b;		/* this control point "owns" the terminal, etc. */
      160 
      161 	control_point_data.priority = 1;		/* "standard" priority */
      162 
      163 	control_point_data.stack_ptr = sb;		/* the current stack belongs to the root */
      164 	control_point_data.last_frame_ptr = null ();	/* no place for control to resume as we haven't left yet */
      165 
      166 CANT_DESTROY_ROOT:
      167 	control_point_data.destroy = CANT_DESTROY_ROOT;	/* a label which prevents destruction */
      168 
      169 	control_point_data.parent,			/* this is the only control point */
      170 	     control_point_data.peers, control_point_data.children, control_point_data.ready_queue = null ();
      171 
      172 	control_point_data.user_cl_intermediary = cpm_$nulle;
      173 
      174 	control_point_data.comment = "Root Control Point";
      175 
      176 	call hcs_$get_ips_mask (control_point_data.ips_mask);
      177 	substr (control_point_data.ips_mask, 36) = "1"b;	/* construct a mask suitable for use by hcs_$reset_ips_mask */
      178 
      179 	control_point_data.privileges = get_privileges_ ();
      180 	control_point_data.cl_intermediary = cpm_overseer_$cl_intermediary;
      181 
      182 	call ioa_$rsnnl ("^12.3b", control_point_id_string, (0), control_point_data.id);
      183 	call find_iocb ("user_i/o", control_point_data.user_io);
      184 	call find_iocb ("user_input", control_point_data.user_input);
      185 	call find_iocb ("user_output", control_point_data.user_output);
      186 	call find_iocb ("error_output", control_point_data.error_output);
      187 
      188 	control_point_data.meters = 0;
      189 	control_point_data.meters.n_schedules = 1;	/* it's been scheduled to run once when the process started */
      190 
      191 	stack_header.cpm_data_ptr = cpd_ptr;		/* the definition is now complete */
      192 
      193 
      194 /* Setup global data */
      195 
      196 	cpm_data_$n_control_points = 1;		/* there's just one active control point */
      197 	cpm_data_$gc_control_points = "0"b;		/* ...and there's no garbage to be cleaned up */
      198 
      199 	cpm_data_$preferred_control_point = cpd_ptr;	/* this is the prefeered control point ... */
      200 	cpm_data_$preferred_control_point_stack.stack_depth = 0;
      201 						/* ... and the stack of prior ones is empty */
      202 
      203 	cpm_data_$ready_queue.first,			/* this is the only ready control point */
      204 	     cpm_data_$ready_queue.last = cpd_ptr;
      205 
      206 	cpm_data_$previous_control_point = cpd_ptr;	/* claim we ran previously to make cpm_$generate_call happy */
      207 
      208 	unspec (cpm_data_$valid_control_points) = ""b;	/* only this control point is valid */
      209 	cpm_data_$valid_control_points.map (binary (baseno (sb), 18, 0)) = "1"b;
      210 
      211 	cpm_data_$global_meters = 0;			/* no meters yet but make sure real time computed OK */
      212 	call user_info_$usage_data ((0), (0), (0), cpm_data_$global_meters.last_meters.real_time, (0), (0));
      213 
      214 
      215 /* Control point management is now enabled */
      216 
      217 	stack_header.cpm_enabled = substr (control_point_data.id, 1, length (stack_header.cpm_enabled));
      218 						/* Place the stack number from the upper half of the id  into stack_header.cpm_enabled (non-zero) */
      219 
      220 	call cu_$get_cl_intermediary (cpm_data_$saved_cl_intermediary);
      221 	call cu_$set_cl_intermediary (cpm_overseer_$cl_intermediary);
      222 						/* switch to our special CL intermediary */
      223 
      224 	return;
      225 
      226 /* Creates an unattached I/O switch which can be used to save one of the control point's standard attachments when it
      227*   stops running */
      228 
      229 find_iocb:
      230      procedure (p_switch_name, p_switch_iocb);
      231 
      232 dcl	p_switch_name	character (*) parameter;
      233 dcl	p_switch_iocb	pointer parameter;
      234 
      235 dcl	switch_name	character (32) varying;
      236 
      237 	switch_name = control_point_id_string;
      238 	switch_name = switch_name || ".";
      239 	switch_name = switch_name || p_switch_name;
      240 
      241 	call iox_$find_iocb ((switch_name), p_switch_iocb, code);
      242 
      243 	if code ^= 0
      244 	then call sub_err_ (code, cpm_data_$subsystem_name, ACTION_CANT_RESTART, null (), 0, "Creating an IOCB for ^a.",
      245 		switch_name);
      246 
      247 	return;
      248 
      249      end find_iocb;
      250 
      251 
      252 
      253 /* Returns the word offset of one pointer relative to another */
      254 
      255 relwordno:
      256      procedure (p_ptr, p_base_ptr) returns (fixed binary (18));
      257 
      258 dcl	p_ptr		pointer parameter;
      259 dcl	p_base_ptr	pointer parameter;
      260 
      261 	return (wordno (p_ptr) - wordno (p_base_ptr));
      262 
      263      end relwordno;
      264 
      265 /* format: off */
      266  /* BEGIN INCLUDE FILE ... cpm_data_.incl.pl1 */
  1     2 
  1     3 /****^  HISTORY COMMENTS:
  1     4*  1) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  1     5*     audit(86-10-08,Fawcett), install(86-11-03,MR12.0-1206):
  1     6*     Written to support control point management in March 1985 by G. Palter.
  1     7*                                                   END HISTORY COMMENTS */
  1     8 
  1     9 /* format: style3,linecom */
  1    10 
  1    11 /* Static data defined by the Control Point Manager for external use */
  1    12 
  1    13 dcl	cpm_data_$n_control_points			/* # of control points actually extant in the process */
  1    14 			fixed binary external;
  1    15 
  1    16 /* END INCLUDE FILE ... cpm_data_.incl.pl1 */
      266 
      267  /* BEGIN INCLUDE FILE ... cpm_internal_data.incl.pl1 */
  2     2 
  2     3 /****^  HISTORY COMMENTS:
  2     4*  1) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  2     5*     audit(86-10-08,Fawcett), install(86-11-03,MR12.0-1206):
  2     6*     Written to support control point management in March 1985 by G. Palter.
  2     7*                                                   END HISTORY COMMENTS */
  2     8 
  2     9 /* format: style3,linecom */
  2    10 
  2    11 /* NOTE: This include file references structures contained in the following independent include files --
  2    12*	cpm_control_point_data.incl.pl1	cpm_ctrl_pt_meters.incl.pl1
  2    13*	process_usage.incl.pl1	*/
  2    14 
  2    15 
  2    16 /* Constants defined by the Control Point Manager for internal use only */
  2    17 
  2    18 dcl	cpm_data_$subsystem_name			/* our name for use in error messages, etc. */
  2    19 			character (32) external;
  2    20 
  2    21 
  2    22 /* Static data defined by the Control Point Manager for internal use only */
  2    23 
  2    24 dcl	1 cpm_data_$root_control_point_data		/* definition of the root control point */
  2    25 			like control_point_data aligned external;
  2    26 
  2    27 dcl	cpm_data_$gc_control_points			/* ON => there are destroyed control points to ... */
  2    28 			bit (1) aligned external;	/* ... be garbage collected */
  2    29 
  2    30 dcl	cpm_data_$saved_cl_intermediary		/* the process' original CL intermediary */
  2    31 			entry (bit (36) aligned) variable external;
  2    32 
  2    33 dcl	cpm_data_$preferred_control_point		/* -> definition of the preferred control point */
  2    34 			pointer external;
  2    35 
  2    36 dcl	1 cpm_data_$preferred_control_point_stack	/* preferred control points stacked by ... */
  2    37 			aligned external,		/* ... event calls and timers */
  2    38 	  2 stack_depth	fixed binary,		/* ... # of entries in the stack at present */
  2    39 	  2 pad		bit (36) aligned,
  2    40 	  2 cpd_ptr_stack	(16) pointer;		/* ... the actual stack */
  2    41 
  2    42 dcl	1 cpm_data_$ready_queue			/* ordered list of ready control points in the process */
  2    43 			aligned external,
  2    44 	  2 first		pointer,
  2    45 	  2 last		pointer;
  2    46 
  2    47 dcl	cpm_data_$previous_control_point		/* -> definition of control point which ran before current */
  2    48 			pointer external;
  2    49 
  2    50 dcl	1 cpm_data_$valid_control_points		/* maps stack segment numbers into an indication of ... */
  2    51 			aligned external,		/* ... whether there is a live control point there */
  2    52 	  2 map		(0:4095) bit (1) unaligned;
  2    53 
  2    54 dcl	1 cpm_data_$global_meters			/* global meters kept by the control point manager */
  2    55 			aligned external,
  2    56 	  2 overhead	like control_point_meters,	/* ... scheduling overhead */
  2    57 	  2 last_meters	like control_point_meters;	/* ... used to compute meters (not really a meter) */
  2    58 
  2    59 /* END INCLUDE FILE ... cpm_internal_data.incl.pl1 */
      267 
      268  /* BEGIN INCLUDE FILE ... cpm_control_point_data.incl.pl1 */
  3     2 
  3     3 /****^  HISTORY COMMENTS:
  3     4*  1) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  3     5*     audit(86-10-08,Fawcett), install(86-11-03,MR12.0-1206):
  3     6*     Written to support control point management in March 1985 by G. Palter.
  3     7*                                                   END HISTORY COMMENTS */
  3     8 
  3     9 /* format: style3,linecom,idind22 */
  3    10 
  3    11 /* NOTE: This include file references structures contained in the following independent include files --
  3    12*	cpm_ctrl_pt_meters.incl.pl1		process_usage.incl.pl1	*/
  3    13 
  3    14 
  3    15 /* Definition of a single control point in the process */
  3    16 
  3    17 dcl	1 control_point_data  aligned based (cpd_ptr),
  3    18 	  2 id		  bit (36) aligned,		/* unique ID of this control point */
  3    19 	  2 group_id	  bit (36) aligned,		/* unique ID of containing group of control points */
  3    20 	  2 state		  fixed binary,		/* scheduling state (see below) */
  3    21 	  2 flags,
  3    22 	    3 preferred	  bit (1) unaligned,	/* ON => this is the preferred task (infinite priority) */
  3    23 	    3 swapped_switches			/* ON => this control point's switches were swapped ... */
  3    24 			  bit (1) unaligned,	/* ... with the root's during an unclaimed signal */
  3    25 	    3 pad		  bit (34) unaligned,
  3    26 	  2 priority	  fixed binary,		/* scheduling priority */
  3    27 	  2 pad		  bit (36) aligned,
  3    28 	  2 stack_ptr	  pointer,		/* -> the stack used by this control point */
  3    29 	  2 last_frame_ptr	  pointer,		/* -> last frame in said stack where control is to resume */
  3    30 	  2 destroy	  label,			/* transferring to this label will kill the control point */
  3    31 	  2 parent	  pointer,		/* -> defintion of this control point's parent */
  3    32 	  2 peers,				/* linked list of this control point's peers */
  3    33 	    3 prev_peer	  pointer,
  3    34 	    3 next_peer	  pointer,
  3    35 	  2 children,				/* linked list of this control point's children */
  3    36 	    3 first_child	  pointer,
  3    37 	    3 last_child	  pointer,
  3    38 	  2 ready_queue,				/* ordered list of control points in the ready state */
  3    39 	    3 prev_ready	  pointer,
  3    40 	    3 next_ready	  pointer,
  3    41 	  2 user_cl_intermediary			/* procedure to be called by cpm_overseer_$cl_intermediary */
  3    42 			  entry (bit (1) aligned),
  3    43 	  2 comment	  character (64),		/* a description of this control point */
  3    44 	  2 saved_environment,			/* data saved when the control point stops running ... */
  3    45 	    3 ips_mask	  bit (36) aligned,		/* ... IPS mask when it stopped running */
  3    46 	    3 privileges	  bit (36) aligned,		/* ... system privileges */
  3    47 	    3 cl_intermediary entry (bit (36) aligned),	/* ... CL intermediary */
  3    48 	    3 io_switches,				/* ... standard I/O switches */
  3    49 	      4 user_io	  pointer,
  3    50 	      4 user_input	  pointer,
  3    51 	      4 user_output	  pointer,
  3    52 	      4 error_output  pointer,
  3    53 	  2 meters	  like control_point_meters;	/* per control point metering data */
  3    54 
  3    55 dcl	cpd_ptr		  pointer;
  3    56 
  3    57 
  3    58 /* Scheduler states for a control point */
  3    59 
  3    60 dcl	(
  3    61 	CPM_DESTROYED	  initial (0),		/* waiting to be deleted */
  3    62 	CPM_STOPPED	  initial (1),		/* can not run without an explicit cpm_$start */
  3    63 	CPM_BLOCKED	  initial (2),		/* blocked on an IPC event channel */
  3    64 	CPM_READY		  initial (3)		/* eligible to run on next call to cpm_$scheduler */
  3    65 	)		  fixed binary static options (constant);
  3    66 
  3    67 /* END INCLUDE FILE ... cpm_control_point_data.incl.pl1 */
      268 
  4     1 /* BEGIN INCLUDE FILE ... cpm_ctrl_pt_meters.incl.pl1 */
  4     2 
  4     3 /****^  HISTORY COMMENTS:
  4     4*  1) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  4     5*     audit(86-10-08,Fawcett), install(86-11-03,MR12.0-1206):
  4     6*     Written to support control point management in March 1985 by G. Palter.
  4     7*                                                   END HISTORY COMMENTS */
  4     8 
  4     9 /* format: style3,linecom */
  4    10 
  4    11 /* NOTE: The include file references structures contained in the following independent include file --
  4    12*	process_usage.incl.pl1	*/
  4    13 
  4    14 
  4    15 /* Definition of control point metering data -- A set of metering data is kept independently for each control point which
  4    16*   provides usage statistics for that control point.  In addition, another set of metering data is kept to record the
  4    17*   overhead involved in the control point scheduler */
  4    18 
  4    19 dcl	1 control_point_meters
  4    20 			aligned based (cpm_ptr),
  4    21 	  2 n_schedules	fixed binary,		/* # of times the control point has been run or
  4    22*						   # of times the scheduler has been invoked */
  4    23 	  2 pad		fixed binary,
  4    24 	  2 real_time	fixed binary (71),		/* ... real time used by the control point or scheduler */
  4    25 	  2 usage		like process_usage;		/* ... CPU, memory, etc. */
  4    26 
  4    27 dcl	cpm_ptr		pointer;
  4    28 
  4    29 
  4    30 /* Definition of the structure used in calls to cpm_$get_control_point_meters and cpm_$get_scheduler_meters */
  4    31 
  4    32 dcl	1 control_point_meters_argument
  4    33 			aligned based (cpma_ptr),
  4    34 	  2 version	character (8) unaligned,
  4    35 	  2 meters	like control_point_meters;
  4    36 
  4    37 dcl	CONTROL_POINT_METERS_ARGUMENT_VERSION_1
  4    38 			character (8) static options (constant) initial ("cpma_001");
  4    39 
  4    40 dcl	MAX_NUMBER_OF_METERS
  4    41 			fixed bin internal static options (constant) init (9);
  4    42 
  4    43 dcl	cpma_ptr		pointer;
  4    44 
  4    45 /* END INCLUDE FILE ... cpm_ctrl_pt_meters.incl.pl1 */
      269 
  5     1 /* BEGIN INCLUDE FILE process_usage.incl.pl1 WRITTEN 09/17/76 BY Richard Bratt */
  5     2 
  5     3 declare
  5     4          process_usage_pointer pointer,
  5     5          1 process_usage based (process_usage_pointer),
  5     6          2 number_wanted fixed bin,			/* max number of entries to be returned */
  5     7          2 number_can_return fixed bin,			/* the number of entries currently returnable */
  5     8          2 cpu_time fixed bin (71),
  5     9          2 paging_measure fixed bin (71),
  5    10          2 page_faults fixed bin (34),
  5    11          2 pd_faults fixed bin (34),
  5    12          2 virtual_cpu_time fixed bin (71),
  5    13          2 segment_faults fixed bin (34),
  5    14          2 bounds_faults fixed bin (34),
  5    15          2 vtoc_reads fixed bin (34),
  5    16          2 vtoc_writes fixed bin (34);
  5    17 
  5    18 /* END INCLUDE FILE process_usage.incl.pl1      */
      270 
      271  /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
  6     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
  6     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
  6     4 /*	Modified April 1983 by C. Hornig for tasking */
  6     5 
  6     6 /****^  HISTORY COMMENTS:
  6     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
  6     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
  6     9*     added the heap_header_ptr definition.
  6    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  6    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
  6    12*     Modified to support control point management.  These changes were actually
  6    13*     made in February 1985 by G. Palter.
  6    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
  6    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
  6    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
  6    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
  6    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
  6    19*     (ITS pair).
  6    20*                                                   END HISTORY COMMENTS */
  6    21 
  6    22 /* format: style2 */
  6    23 
  6    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
  6    25 
  6    26      dcl	   1 stack_header	      based (sb) aligned,
  6    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
  6    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
  6    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
  6    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
  6    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
  6    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
  6    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
  6    34 	     2 pad4	      bit (2) unal,
  6    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
  6    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
  6    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
  6    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
  6    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
  6    40 	     2 null_ptr	      ptr,		/*  (16)  */
  6    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
  6    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
  6    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
  6    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
  6    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
  6    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
  6    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
  6    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
  6    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
  6    50 	     2 return_no_pop_op_ptr
  6    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
  6    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
  6    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
  6    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
  6    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
  6    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
  6    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
  6    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
  6    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
  6    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
  6    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
  6    62 	     2 trace,
  6    63 	       3 frames,
  6    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
  6    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
  6    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
  6    67 	     2 pad2	      bit (36),		/*  (61) */
  6    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
  6    69 
  6    70 /*	The following offset refers to a table within the  pl1  operator table.  */
  6    71 
  6    72      dcl	   tv_offset	      fixed bin init (361) internal static;
  6    73 						/* (551) octal */
  6    74 
  6    75 
  6    76 /*	The following constants are offsets within this transfer vector table.  */
  6    77 
  6    78      dcl	   (
  6    79 	   call_offset	      fixed bin init (271),
  6    80 	   push_offset	      fixed bin init (272),
  6    81 	   return_offset	      fixed bin init (273),
  6    82 	   return_no_pop_offset   fixed bin init (274),
  6    83 	   entry_offset	      fixed bin init (275)
  6    84 	   )		      internal static;
  6    85 
  6    86 
  6    87 
  6    88 
  6    89 
  6    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
  6    91*	move the whole stack header should use this overlay.
  6    92**/
  6    93 
  6    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
  6    95 
  6    96 
  6    97 
  6    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
      271 
      272  /* BEGIN INCLUDE FILE RNT.INCL.PL1 - WRITTEN SEPTEMBER 1974 BY R. BRATT */
  7     2 /* modified July 1976 by R. Bratt; updated March 1977 by M. Weaver */
  7     3 /* modified November 1977 by M. Weaver to use PL/I offsets instead of pointers */
  7     4 
  7     5 dcl (rntp, rntep) ptr;
  7     6 dcl lth fixed bin (17);
  7     7 dcl based_rnt_area area based;
  7     8 
  7     9 dcl 1 rnt aligned based (rntp),
  7    10     2 areap ptr,					/* pointer to area for rnte allocations */
  7    11     2 meters,
  7    12       3 insert,
  7    13         4 trys fixed bin (17) unaligned,
  7    14         4 wins fixed bin (17) unaligned,
  7    15       3 get_segno like insert,
  7    16       3 get_refnames like insert,
  7    17       3 delete_segno like insert,
  7    18       3 delete_name like insert,
  7    19     2 rnt_area_size fixed bin,
  7    20     2 srulep ptr,
  7    21     2 name_hash_table (0:127) offset (rnt.areap -> based_rnt_area),
  7    22     2 segno_hash_table (0:127) offset (rnt.areap -> based_rnt_area);
  7    23 
  7    24 dcl 1 rnte aligned based (rntep),
  7    25     2 name_fp offset (rnt.areap -> based_rnt_area),
  7    26     2 segno_fp offset (rnt.areap -> based_rnt_area),
  7    27     (2 segno fixed bin (17),
  7    28     2 length fixed bin (17),
  7    29     2 name char (lth refer (rnte.length)))unaligned;
  7    30 
  7    31 /* --------------------END RNT.INCL.PL1--------------------- */
      272 
      273  /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  8     2 
  8     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  8     4 
  8     5 dcl  area_infop ptr;
  8     6 
  8     7 dcl 1 area_info aligned based (area_infop),
  8     8     2 version fixed bin,				/* version number for this structure is 1 */
  8     9     2 control aligned like area_control,		/* control bits for the area */
  8    10     2 owner char (32) unal,				/* creator of the area */
  8    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  8    12     2 size fixed bin (18),				/* size of the area in words */
  8    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  8    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  8    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  8    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  8    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  8    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  8    19 
  8    20 dcl 1 area_control aligned based,
  8    21     2 extend bit (1) unal,				/* says area is extensible */
  8    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  8    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  8    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  8    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  8    26     2 system bit (1) unal,				/* says area is managed by system */
  8    27     2 pad bit (30) unal;
  8    28 
  8    29 /* END INCLUDE FILE area_info.incl.pl1 */
      273 
      274  /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  9     2 /* format: style3 */
  9     3 
  9     4 /* These constants are to be used for the flags argument of sub_err_ */
  9     5 /* They are just "string (condition_info_header.action_flags)" */
  9     6 
  9     7 declare	(
  9     8 	ACTION_CAN_RESTART	init (""b),
  9     9 	ACTION_CANT_RESTART init ("1"b),
  9    10 	ACTION_DEFAULT_RESTART
  9    11 			init ("01"b),
  9    12 	ACTION_QUIET_RESTART
  9    13 			init ("001"b),
  9    14 	ACTION_SUPPORT_SIGNAL
  9    15 			init ("0001"b)
  9    16 	)		bit (36) aligned internal static options (constant);
  9    17 
  9    18 /* End include file */
      274 
      275  /* --------------- BEGIN include file iox_dcls.incl.pl1 --------------- */
 10     2 
 10     3 /* Written 05/04/78 by C. D. Tavares */
 10     4 /* Fixed declaration of iox_$find_iocb_n 05/07/80 by R. Holmstedt */
 10     5 /* Modified 5/83 by S. Krupp to add declarations for:  iox_$open_file,
 10     6*     iox_$close_file, iox_$detach and iox_$attach_loud entries. */
 10     7 
 10     8 dcl  iox_$attach_name entry (char (*), pointer, char (*), pointer, fixed bin (35)),
 10     9      iox_$attach_ptr entry (pointer, char (*), pointer, fixed bin (35)),
 10    10      iox_$close entry (pointer, fixed bin (35)),
 10    11      iox_$control entry (pointer, char (*), pointer, fixed bin (35)),
 10    12      iox_$delete_record entry (pointer, fixed bin (35)),
 10    13      iox_$destroy_iocb entry (pointer, fixed bin (35)),
 10    14      iox_$detach_iocb entry (pointer, fixed bin (35)),
 10    15      iox_$err_not_attached entry options (variable),
 10    16      iox_$err_not_closed entry options (variable),
 10    17      iox_$err_no_operation entry options (variable),
 10    18      iox_$err_not_open entry options (variable),
 10    19      iox_$find_iocb entry (char (*), pointer, fixed bin (35)),
 10    20      iox_$find_iocb_n entry (fixed bin, ptr, fixed bin(35)),
 10    21      iox_$get_chars entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
 10    22      iox_$get_line entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
 10    23      iox_$look_iocb entry (char (*), pointer, fixed bin (35)),
 10    24      iox_$modes entry (pointer, char (*), char (*), fixed bin (35)),
 10    25      iox_$move_attach entry (pointer, pointer, fixed bin (35)),
 10    26      iox_$open entry (pointer, fixed bin, bit (1) aligned, fixed bin (35)),
 10    27      iox_$position entry (pointer, fixed bin, fixed bin (21), fixed bin (35)),
 10    28      iox_$propagate entry (pointer),
 10    29      iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35)),
 10    30      iox_$read_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
 10    31      iox_$read_length entry (pointer, fixed bin (21), fixed bin (35)),
 10    32      iox_$read_record entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
 10    33      iox_$rewrite_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
 10    34      iox_$seek_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
 10    35      iox_$write_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
 10    36      iox_$open_file entry(ptr, fixed bin, char(*), bit(1) aligned, fixed bin(35)),
 10    37      iox_$close_file entry(ptr, char(*), fixed bin(35)),
 10    38      iox_$detach entry(ptr, char(*), fixed bin(35)),
 10    39      iox_$attach_loud entry(ptr, char(*), ptr, fixed bin(35));
 10    40 
 10    41 dcl (iox_$user_output,
 10    42      iox_$user_input,
 10    43      iox_$user_io,
 10    44      iox_$error_output) external static pointer;
 10    45 
 10    46 /* ---------------- END include file iox_dcls.incl.pl1 ---------------- */
      275 
      276 /* format: on */
      277 
      278      end cpm_initialize_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/05/88  1426.2  cpm_initialize_.pl1               >spec>install>MR12.2-1053>cpm_initialize_.pl1
266          1    11/07/86  1550.3  cpm_data_.incl.pl1                >ldd>include>cpm_data_.incl.pl1
267          2    11/07/86  1550.3  cpm_internal_data.incl.pl1        >ldd>include>cpm_internal_data.incl.pl1
268          3    11/07/86  1550.3  cpm_control_point_data.incl.pl1   >ldd>include>cpm_control_point_data.incl.pl1
269          4    11/07/86  1550.3  cpm_ctrl_pt_meters.incl.pl1       >ldd>include>cpm_ctrl_pt_meters.incl.pl1
270          5    10/26/76  1333.6  process_usage.incl.pl1            >ldd>include>process_usage.incl.pl1
271          6    11/07/86  1550.3  stack_header.incl.pl1             >ldd>include>stack_header.incl.pl1
272          7    01/27/78  1711.4  rnt.incl.pl1                      >ldd>include>rnt.incl.pl1
273          8    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
274          9    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
275         10    05/23/83  0916.6  iox_dcls.incl.pl1                 >ldd>include>iox_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000017 constant        bit(36)                  initial dcl 9-7 set ref 116* 243*
CPM_READY                              constant        fixed bin(17,0)          initial dcl 3-60 ref 156
addr                                                   builtin function         dcl 75 ref 115 115 151
addwordno                                              builtin function         dcl 75 ref 129 131
area_control                           based           structure                level 1 dcl 8-20
area_info                              based           structure                level 1 dcl 8-7
area_info_version_1                    constant        fixed bin(17,0)          initial dcl 8-3 ref 107
areap                                  based           pointer                  level 2 in structure "rnt" dcl 7-9 in procedure
                                                                                  "cpm_initialize_" set ref 121 126 129* 131* 134*
                                                                                  137
areap                    16     000100 automatic       pointer                  level 2 in structure "local_ai" dcl 31 in procedure
                                                                                  "cpm_initialize_" set ref 113* 121 125 126 129 131
                                                                                  134
baseno                                                 builtin function         dcl 75 ref 153 209
binary                                                 builtin function         dcl 75 ref 209
children                 24            based           structure                level 2 dcl 3-17 set ref 169*
cl_intermediary          62            based           entry variable           level 3 dcl 3-17 set ref 180*
cleanup                         000140 stack reference condition                dcl 78 ref 100 144
code                            000127 automatic       fixed bin(35,0)          dcl 36 set ref 115* 116 116* 241* 243 243*
comment                  40            based           char(64)                 level 2 dcl 3-17 set ref 174*
control                   1     000100 automatic       structure                level 2 dcl 31 set ref 108*
control_point_data                     based           structure                level 1 dcl 3-17
control_point_id_string         000124 automatic       char(12)                 packed unaligned dcl 33 set ref 182* 237
control_point_meters                   based           structure                level 1 dcl 4-19
cpd_ptr                         000146 automatic       pointer                  dcl 3-55 set ref 151* 153 153 156 158 159 161 163
                                                                                  164 166 169 169 169 169 172 174 176 177 179 180
                                                                                  182 183 184 185 186 188 189 191 199 203 206 217
cpm_$nulle                      000014 constant        entry                    external dcl 53 ref 172
cpm_data_$gc_control_points     000060 external static bit(1)                   dcl 2-27 set ref 197*
cpm_data_$global_meters         000076 external static structure                level 1 dcl 2-54 set ref 211*
cpm_data_$n_control_points      000052 external static fixed bin(17,0)          dcl 1-13 set ref 196*
cpm_data_$preferred_control_point
                                000064 external static pointer                  dcl 2-33 set ref 199*
cpm_data_$preferred_control_point_stack
                                000066 external static structure                level 1 dcl 2-36
cpm_data_$previous_control_point
                                000072 external static pointer                  dcl 2-47 set ref 206*
cpm_data_$ready_queue           000070 external static structure                level 1 dcl 2-42
cpm_data_$root_control_point_data
                                000056 external static structure                level 1 dcl 2-24 set ref 151
cpm_data_$saved_cl_intermediary 000062 external static entry variable           dcl 2-30 set ref 220*
cpm_data_$subsystem_name        000054 external static char(32)                 packed unaligned dcl 2-18 set ref 116* 243*
cpm_data_$valid_control_points  000074 external static structure                level 1 dcl 2-50 set ref 208*
cpm_data_ptr              4            based           pointer                  level 2 dcl 6-26 set ref 191*
cpm_enabled              13(18)        based           bit(18)                  level 2 packed packed unaligned dcl 6-26 set ref
                                                                                  217* 217
cpm_overseer_$cl_intermediary   000016 constant        entry                    external dcl 54 ref 180 221 221
cu_$get_cl_intermediary         000020 constant        entry                    external dcl 56 ref 220
cu_$set_cl_intermediary         000022 constant        entry                    external dcl 56 ref 221
cur_lot_size             13            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-26 ref 90
define_area_                    000024 constant        entry                    external dcl 60 ref 115
destroy                  12            based           label variable           level 2 dcl 3-17 set ref 166*
empty                                                  builtin function         dcl 75 ref 125
error_output             74            based           pointer                  level 4 dcl 3-17 set ref 186*
first                           000070 external static pointer                  level 2 dcl 2-42 set ref 203*
flags                     3            based           structure                level 2 dcl 3-17 set ref 158*
get_privileges_                 000026 constant        entry                    external dcl 61 ref 179
get_ring_                       000030 constant        entry                    external dcl 62 ref 90 90
get_system_free_area_           000032 constant        entry                    external dcl 63 ref 83
group_id                  1            based           bit(36)                  level 2 dcl 3-17 set ref 153*
hcs_$get_ips_mask               000034 constant        entry                    external dcl 65 ref 176
hcs_$grow_lot                   000042 constant        entry                    external dcl 68 ref 90
hcs_$reset_ips_mask             000036 constant        entry                    external dcl 66 ref 102 143
hcs_$set_ips_mask               000040 constant        entry                    external dcl 67 ref 105
id                                     based           bit(36)                  level 2 dcl 3-17 set ref 153* 182* 217
insert                    2            based           structure                level 3 dcl 7-9
io_switches              66            based           structure                level 3 dcl 3-17
ioa_$rsnnl                      000044 constant        entry                    external dcl 69 ref 182
iox_$find_iocb                  000100 constant        entry                    external dcl 10-8 ref 241
ips_mask                 60            based           bit(36)                  level 3 dcl 3-17 set ref 176* 177*
last                      2     000070 external static pointer                  level 2 dcl 2-42 set ref 203*
last_frame_ptr           10            based           pointer                  level 2 dcl 3-17 set ref 164*
last_meters              22     000076 external static structure                level 2 dcl 2-54
length                                                 builtin function         dcl 75 ref 217
local_ai                        000100 automatic       structure                level 1 dcl 31 set ref 115 115
map                             000074 external static bit(1)                   array level 2 packed packed unaligned dcl 2-50 set
                                                                                  ref 209*
max_lot_size             12            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-26 ref 90
meters                    2            based           structure                level 2 in structure "rnt" dcl 7-9 in procedure
                                                                                  "cpm_initialize_"
meters                   76            based           structure                level 2 in structure "control_point_data" dcl 3-17
                                                                                  in procedure "cpm_initialize_" set ref 188*
n_schedules              76            based           fixed bin(17,0)          level 3 dcl 3-17 set ref 189*
new_rnt_area                           based           area                     dcl 38 set ref 121* 125* 126*
new_rntp                        000130 automatic       pointer                  dcl 41 set ref 129* 131 134 135 140
null                                                   builtin function         dcl 75 ref 113 116 116 164 169 243 243
old_area_size                   000134 automatic       fixed bin(18,0)          dcl 43 set ref 120* 123 138* 141
old_areap                       000132 automatic       pointer                  dcl 42 set ref 137* 141
old_mask                        000135 automatic       bit(36)                  dcl 45 set ref 99* 102 102* 102* 105* 143* 143*
old_rnt_area                           based           area                     dcl 39 ref 141
owner                     2     000100 automatic       char(32)                 level 2 packed packed unaligned dcl 31 set ref 111*
p_base_ptr                             parameter       pointer                  dcl 259 ref 255 261
p_ptr                                  parameter       pointer                  dcl 258 ref 255 261
p_switch_iocb                          parameter       pointer                  dcl 233 set ref 229 241*
p_switch_name                          parameter       char                     packed unaligned dcl 232 ref 229 239
parent                   16            based           pointer                  level 2 dcl 3-17 set ref 169*
peers                    20            based           structure                level 2 dcl 3-17 set ref 169*
preferred                 3            based           bit(1)                   level 3 packed packed unaligned dcl 3-17 set ref
                                                                                  159*
priority                  4            based           fixed bin(17,0)          level 2 dcl 3-17 set ref 161*
privileges               61            based           bit(36)                  level 3 dcl 3-17 set ref 179*
process_usage                          based           structure                level 1 unaligned dcl 5-3
ready_queue              30            based           structure                level 2 dcl 3-17 set ref 169*
real_time                24     000076 external static fixed bin(71,0)          level 3 dcl 2-54 set ref 212*
rnt                                    based           structure                level 1 dcl 7-9
rnt_area                               based           area                     dcl 40 ref 121 126
rnt_area_size             7            based           fixed bin(17,0)          level 2 dcl 7-9 set ref 96 120 123 135* 138
rnt_ptr                  62            based           pointer                  level 2 dcl 6-26 set ref 96 120 121 123 126 129* 129
                                                                                  131 131 137 138 140*
saved_environment        60            based           structure                level 2 dcl 3-17
sb                              000150 automatic       pointer                  dcl 6-24 set ref 82* 90 90 96 120 121 123 126 129
                                                                                  129 131 131 137 138 140 153 163 191 209 217 217
size                     13     000100 automatic       fixed bin(18,0)          level 2 dcl 31 set ref 112* 125 135
srulep                   10            based           pointer                  level 2 dcl 7-9 set ref 131* 131*
stack_depth                     000066 external static fixed bin(17,0)          level 2 dcl 2-36 set ref 200*
stack_header                           based           structure                level 1 dcl 6-26
stack_ptr                 6            based           pointer                  level 2 dcl 3-17 set ref 163*
stackbaseptr                                           builtin function         dcl 75 ref 82
state                     2            based           fixed bin(17,0)          level 2 dcl 3-17 set ref 156*
string                                                 builtin function         dcl 75 set ref 108* 158*
sub_err_                        000046 constant        entry                    external dcl 70 ref 116 243
substr                                                 builtin function         dcl 75 set ref 177* 217
switch_name                     000160 automatic       varying char(32)         dcl 235 set ref 237* 238* 238 239* 239 241 243*
sys_info$max_seg_size           000012 external static fixed bin(19,0)          dcl 50 ref 96 112
system                    1(05) 000100 automatic       bit(1)                   level 3 packed packed unaligned dcl 31 set ref 110*
system_area                            based           area(1024)               dcl 47 ref 141
system_area_ptr                 000136 automatic       pointer                  dcl 48 set ref 83* 141
unspec                                                 builtin function         dcl 75 set ref 208*
user_cl_intermediary     34            based           entry variable           level 2 dcl 3-17 set ref 172*
user_info_$usage_data           000050 constant        entry                    external dcl 71 ref 212
user_input               70            based           pointer                  level 4 dcl 3-17 set ref 184*
user_io                  66            based           pointer                  level 4 dcl 3-17 set ref 183*
user_output              72            based           pointer                  level 4 dcl 3-17 set ref 185*
version                         000100 automatic       fixed bin(17,0)          level 2 dcl 31 set ref 107*
wordno                                                 builtin function         dcl 75 ref 261 261
zero_on_free              1(02) 000100 automatic       bit(1)                   level 3 packed packed unaligned dcl 31 set ref 109*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 9-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 9-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 9-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 9-7
CONTROL_POINT_METERS_ARGUMENT_VERSION_1
                                       internal static char(8)                  initial packed unaligned dcl 4-37
CPM_BLOCKED                            internal static fixed bin(17,0)          initial dcl 3-60
CPM_DESTROYED                          internal static fixed bin(17,0)          initial dcl 3-60
CPM_STOPPED                            internal static fixed bin(17,0)          initial dcl 3-60
MAX_NUMBER_OF_METERS                   internal static fixed bin(17,0)          initial dcl 4-40
area_infop                             automatic       pointer                  dcl 8-5
based_rnt_area                         based           area(1024)               dcl 7-7
call_offset                            internal static fixed bin(17,0)          initial dcl 6-78
control_point_meters_argument          based           structure                level 1 dcl 4-32
cpm_ptr                                automatic       pointer                  dcl 4-27
cpma_ptr                               automatic       pointer                  dcl 4-43
entry_offset                           internal static fixed bin(17,0)          initial dcl 6-78
iox_$attach_loud                000000 constant        entry                    external dcl 10-8
iox_$attach_name                000000 constant        entry                    external dcl 10-8
iox_$attach_ptr                 000000 constant        entry                    external dcl 10-8
iox_$close                      000000 constant        entry                    external dcl 10-8
iox_$close_file                 000000 constant        entry                    external dcl 10-8
iox_$control                    000000 constant        entry                    external dcl 10-8
iox_$delete_record              000000 constant        entry                    external dcl 10-8
iox_$destroy_iocb               000000 constant        entry                    external dcl 10-8
iox_$detach                     000000 constant        entry                    external dcl 10-8
iox_$detach_iocb                000000 constant        entry                    external dcl 10-8
iox_$err_no_operation           000000 constant        entry                    external dcl 10-8
iox_$err_not_attached           000000 constant        entry                    external dcl 10-8
iox_$err_not_closed             000000 constant        entry                    external dcl 10-8
iox_$err_not_open               000000 constant        entry                    external dcl 10-8
iox_$error_output                      external static pointer                  dcl 10-41
iox_$find_iocb_n                000000 constant        entry                    external dcl 10-8
iox_$get_chars                  000000 constant        entry                    external dcl 10-8
iox_$get_line                   000000 constant        entry                    external dcl 10-8
iox_$look_iocb                  000000 constant        entry                    external dcl 10-8
iox_$modes                      000000 constant        entry                    external dcl 10-8
iox_$move_attach                000000 constant        entry                    external dcl 10-8
iox_$open                       000000 constant        entry                    external dcl 10-8
iox_$open_file                  000000 constant        entry                    external dcl 10-8
iox_$position                   000000 constant        entry                    external dcl 10-8
iox_$propagate                  000000 constant        entry                    external dcl 10-8
iox_$put_chars                  000000 constant        entry                    external dcl 10-8
iox_$read_key                   000000 constant        entry                    external dcl 10-8
iox_$read_length                000000 constant        entry                    external dcl 10-8
iox_$read_record                000000 constant        entry                    external dcl 10-8
iox_$rewrite_record             000000 constant        entry                    external dcl 10-8
iox_$seek_key                   000000 constant        entry                    external dcl 10-8
iox_$user_input                        external static pointer                  dcl 10-41
iox_$user_io                           external static pointer                  dcl 10-41
iox_$user_output                       external static pointer                  dcl 10-41
iox_$write_record               000000 constant        entry                    external dcl 10-8
lth                                    automatic       fixed bin(17,0)          dcl 7-6
process_usage_pointer                  automatic       pointer                  dcl 5-3
push_offset                            internal static fixed bin(17,0)          initial dcl 6-78
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 6-78
return_offset                          internal static fixed bin(17,0)          initial dcl 6-78
rnte                                   based           structure                level 1 dcl 7-24
rntep                                  automatic       pointer                  dcl 7-5
rntp                                   automatic       pointer                  dcl 7-5
stack_header_overlay                   based           fixed bin(17,0)          array dcl 6-94
tv_offset                              internal static fixed bin(17,0)          initial dcl 6-72

NAMES DECLARED BY EXPLICIT CONTEXT.
CANT_DESTROY_ROOT               000465 constant        label                    dcl 166 set ref 166
cpm_initialize_                 000067 constant        entry                    external dcl 28
find_iocb                       001054 constant        entry                    internal dcl 229 ref 183 184 185 186
relwordno                       001224 constant        entry                    internal dcl 255 ref 129 131

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1654        1756    1245        1664
Length      2406    1245       102         413     406           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cpm_initialize_                     231 external procedure  is an external procedure.  
on unit on line 100                  70 on unit               
find_iocb                               internal procedure  shares stack frame of external procedure cpm_initialize_.  
relwordno                               internal procedure  shares stack frame of external procedure cpm_initialize_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cpm_initialize_          000100 local_ai                    cpm_initialize_
                         000124 control_point_id_string     cpm_initialize_
                         000127 code                        cpm_initialize_
                         000130 new_rntp                    cpm_initialize_
                         000132 old_areap                   cpm_initialize_
                         000134 old_area_size               cpm_initialize_
                         000135 old_mask                    cpm_initialize_
                         000136 system_area_ptr             cpm_initialize_
                         000146 cpd_ptr                     cpm_initialize_
                         000150 sb                          cpm_initialize_
                         000160 switch_name                 find_iocb

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          enable_op           shorten_stack
ext_entry           int_entry           op_freen_           op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
area_assign_                  cpm_$nulle                    cpm_overseer_$cl_intermediary cu_$get_cl_intermediary
cu_$set_cl_intermediary       define_area_                  get_privileges_               get_ring_
get_system_free_area_         hcs_$get_ips_mask             hcs_$grow_lot                 hcs_$reset_ips_mask
hcs_$set_ips_mask             ioa_$rsnnl                    iox_$find_iocb                sub_err_
user_info_$usage_data

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
cpm_data_$gc_control_points   cpm_data_$global_meters       cpm_data_$n_control_points
cpm_data_$preferred_control_point                           cpm_data_$preferred_control_point_stack
cpm_data_$previous_control_point                            cpm_data_$ready_queue
cpm_data_$root_control_point_data                           cpm_data_$saved_cl_intermediary
cpm_data_$subsystem_name      cpm_data_$valid_control_points                              sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     28 000066        82 000074        83 000076        90 000104        96 000132        99 000140       100 000141
    102 000155       104 000167       105 000170       107 000203       108 000205       109 000206       110 000210
    111 000212       112 000215       113 000220       115 000222       116 000234       120 000304       121 000310
    123 000325       125 000332       126 000335       129 000354       131 000373       134 000414       135 000416
    137 000420       138 000424       140 000427       141 000430       143 000432       144 000442       151 000443
    153 000446       156 000452       158 000454       159 000455       161 000457       163 000461       164 000463
    166 000465       169 000471       172 000501       174 000506       176 000511       177 000517       179 000522
    180 000531       182 000537       183 000566       184 000605       185 000626       186 000650       188 000671
    189 000711       191 000713       196 000715       197 000717       199 000720       200 000721       203 000722
    206 000725       208 000727       209 000733       211 000742       212 001000       217 001025       220 001031
    221 001040       224 001053       229 001054       237 001065       238 001072       239 001101       241 001115
    243 001146       247 001223       255 001224       261 001226


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
