	COMPILATION LISTING OF SEGMENT probe_trace_a_stack_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1135.27_Tue_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(88-09-30,WAAnderson), approve(88-09-30,MCR7863),
       16*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       17*     Fixed bugs associated with object segments compiled with the -brief_table
       18*     control argument.
       19*  2) change(88-09-30,WAAnderson), approve(88-09-30,MCR7952),
       20*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       21*     Added format control comment to make the source more readable.
       22*                                                   END HISTORY COMMENTS */
       23 
       24 
       25 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       26 
       27 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       28 
       29 probe_trace_a_stack_:
       30   proc (P_probe_info_ptr, P_first, P_all);
       31 
       32   /* trace the stack, starting at the frame P_first - build structure of levels   in the area scratch_area
       33*
       34*   James R. Davis 22 June 79
       35*   Modified 25 Aug 79 JRD */
       36   /* Changed to store component info for each stack frame 09/18/81 S. Herbst */
       37   /* Changed to store printed frame number I.J, J^=0 for support frames 12/10/81 S. Herbst */
       38   /* Changed to detect caller loop in symbol table, and stop 02/25/82 S. Herbst */
       39   /* Removed remaining call to stu_$get_runtime_block (calling stu_find_containing_block instead) 10/31/83 M. Weaver */
       40   /* Changed not to print funny quick-block levels for which no instruction_ptr 02/17/84 S. Herbst */
       41 
       42   dcl P_probe_info_ptr	ptr aligned parameter;
       43   dcl P_first		ptr aligned parameter;
       44   dcl P_all		bit (1) aligned parameter;
       45 				/* include support frames? */
       46 
       47   dcl include_support	bit (1) aligned;
       48   dcl (p, prev_lfp, saved_lfp, test_lfp)
       49 			ptr;
       50   dcl (frame_decimal, frame_number)
       51 			fixed bin;
       52   dcl code		fixed bin (35);
       53   dcl condition_frame	ptr;	/*  to most recent frame where a condition occured */
       54   dcl was_error		bit (1) aligned;
       55 				/* was that condition "error" ? */
       56 
       57   dcl component_info_$offset	entry (ptr, fixed bin (18), ptr, fixed bin (35))
       58 			;
       59   dcl find_condition_info_	entry (ptr, ptr, fixed bin (35));
       60   dcl stack_frame_exit_	entry (ptr, ptr, ptr, bit (1) aligned, ptr,
       61 			char (32) aligned, ptr);
       62   dcl is_condition_frame_	entry (ptr) returns (bit (1) aligned);
       63 
       64   dcl 1 frame_situation	aligned like stack_frame_exit_str;
       65   dcl 1 cond_info		aligned like condition_info;
       66 
       67   dcl probe_seg_info_	entry (ptr, ptr, fixed bin (35)) returns (ptr);
       68 
       69   dcl (addr, addrel, baseno, bin, binary, null, ptr, rel,
       70       string, stackbaseptr, unspec)
       71 			builtin;
       72 
       73   dcl area		condition;
       74 
       75 
       76   probe_info_ptr = P_probe_info_ptr;
       77   include_support = P_all;
       78   if stack_info.good_stack & include_support = stack_info.traced_with_all
       79     then return;
       80 
       81   stack_info.max_level = 0;		/* haven't got any frames yet */
       82   stack_info.traced_with_all = include_support;
       83   lfp, prev_lfp = null ();		/* have no frames at the start */
       84   condition_frame = null ();		/* there are no conditions */
       85   was_error = "0"b;			/* and none are "error" */
       86 
       87   do sp = P_first repeat (sp -> stack_frame.prev_sp) while (sp ^= null);
       88     if is_condition_frame_ (sp)
       89       then do;
       90         condition_frame = sp;		/* it happended here */
       91         call find_condition_info_ (sp, addr (cond_info), (0));
       92         was_error = is_this_an_error_frame ();
       93       end;			/* condition framing */
       94       else cond_info.mc_ptr, cond_info.wc_ptr = null ();
       95 
       96     if this_frame_should_be_traced () then do;
       97         lfp = new_level ();
       98 
       99         level_frame.support = sp -> stack_frame_flags.support;
      100 
      101         level_frame.condition_frame_ptr = condition_frame;
      102         level_frame.flags.error_signalled = was_error;
      103         condition_frame = null ();	/* has been claimed */
      104         was_error = "0"b;
      105 
      106         call stack_frame_exit_ (sp, cond_info.mc_ptr, cond_info.wc_ptr,
      107 	   (sp -> stack_frame_flags.crawl_out),
      108 	   p, (""), addr (frame_situation));
      109 
      110         level_frame.instruction_ptr = p;
      111         level_frame.stack_ptr = sp;
      112 
      113         if frame_situation.entry_ptr_invalid
      114 				/* only return_to_ring_0 will be invalid */
      115 	then level_frame.seg_info_ptr =
      116 		probe_seg_info_ (probe_info_ptr, null (), (0));
      117 				/* this is dummy */
      118 	else call analyze_frame (sp); /* there is much to learn about this frame */
      119       end;			/* of handling frame we like */
      120   end;				/* of loop thru stack */
      121 
      122 RENUMBER:
      123   frame_number, frame_decimal = 0;
      124 
      125   do p = lfp repeat (p -> level_frame.prev) while (p ^= null);
      126     if p -> level_frame.support
      127       then frame_decimal = frame_decimal + 1;
      128       else do;
      129         frame_number = frame_number + 1;
      130         frame_decimal = 0;
      131       end;
      132     p -> level_frame.printed_number = frame_number;
      133     p -> level_frame.printed_decimal = frame_decimal;
      134   end;
      135 
      136   stack_info.good_stack = "1"b;
      137   return;
      138 
      139 is_this_an_error_frame:
      140   proc () returns (bit (1) aligned);
      141   return (cond_info.condition_name = "error" &
      142        cond_info.info_ptr = null () & cond_info.mc_ptr = null ());
      143   end is_this_an_error_frame;
      144 
      145 
      146 this_frame_should_be_traced:
      147   proc () returns (bit (1) aligned);
      148   return (include_support | ^sp -> stack_frame_flags.support);
      149   end this_frame_should_be_traced;
      150 
      151 
      152 analyze_frame:
      153   proc (a_sp);
      154 
      155   dcl a_sp		ptr parameter;
      156   dcl stu_$find_containing_block
      157 			entry (ptr, fixed bin (18) unsigned)
      158 			returns (ptr);
      159   dcl stu_$get_map_index	entry (ptr, fixed bin (18) unsigned, fixed bin,
      160 			ptr);
      161 
      162   dcl bp			ptr;	/* to runtime_block node */
      163   dcl hp			ptr;	/* to std_symbol_header */
      164 
      165   dcl entryp		ptr;
      166   dcl seg_infop		ptr;
      167   dcl continue_tracing	bit (1) aligned;
      168 
      169 
      170 
      171   entryp = a_sp -> stack_frame.entry_ptr;
      172 				/* entry that created this frame */
      173 
      174   level_frame.seg_info_ptr, seg_infop =
      175        probe_seg_info_ (probe_info_ptr, entryp, code);
      176   level_frame.run_unit_manager = a_sp -> stack_frame_flags.run_unit_manager;
      177 
      178   hp = level_frame.seg_info_ptr -> seg_info.symbol_header_ptr;
      179 
      180   if hp ^= null ()
      181     then call stu_$get_map_index (hp, bin (rel (p), 18),
      182 	    level_frame.stmnt_map_entry_index, (null));
      183 
      184   bp = stu_$find_containing_block (hp, bin (rel (p), 18));
      185 
      186   if bp = null () /* no symbol table can do no more */
      187     then do;
      188       level_frame.entry_ptr = entryp;
      189     end;
      190     else do;
      191 
      192       /* may be a quick block - first calculate information that will be true for all blocks that share this frame
      193*   then trace back quick calls */
      194 
      195       level_frame.block_ptr = bp;
      196 
      197       saved_lfp = lfp;
      198 
      199       continue_tracing = bp -> runtime_block.quick;
      200 				/* trace only while we're quick */
      201       do while (continue_tracing);
      202         level_frame.flags.quick = "1"b; /* obviously */
      203 
      204         /* first location of this block executed */
      205         level_frame.entry_ptr =
      206 	   ptr (bp,
      207 	   addrel (bp, bp -> runtime_block.first) -> statement_map.location)
      208 	   ;
      209 
      210         /* is the above wrong thing to do for multiple entry blocks?
      211*   probably so, but how can you tell if thats the case ? */
      212 
      213         if seg_infop -> seg_info.language_type = FORTRAN_lang_type
      214 				/* FT quick block is also externally callable - skip the
      215*						   descriptor flag,   point to real entry seq */
      216 	then level_frame.entry_ptr = addrel (level_frame.entry_ptr, 1);
      217 
      218         /* now get ptr to caller, and determine block */
      219 
      220         if bp -> runtime_block.entry_info ^= "0"b /* quick proc */
      221 	then do;
      222 	  p = addrel (a_sp, bp -> runtime_block.entry_info)
      223 	       -> quick_entry.return;
      224 
      225 	  /* for FT the quick_entry.return ptr is left pointing into pl1 operators, so that
      226*   the returing quick block will skip the non-quick father and go directly to father's caller */
      227 
      228 	  if baseno (p)
      229 	       = baseno (stackbaseptr () -> stack_header.pl1_operators_ptr)
      230 	    then do;
      231 	      p = null ();		/* no place to return to in THIS seg */
      232 	      bp = addrel (bp, bp -> runtime_block.father);
      233 	    end;
      234 
      235 	    /* additional code here would ensure that there was only one frame in the level_chain
      236*   for this FT case, thus users would see only one fram,e, which is what they want to see */
      237 
      238 	    else do;
      239 	      p = addrel (p, -1);	/* point to the calling instruction */
      240 	      bp = stu_$find_containing_block (hp, bin (rel (p), 18));
      241 	    end;
      242 	end;			/* entry info hacking */
      243 	else do;			/* assume begin block */
      244 	  p = addrel (level_frame.entry_ptr, -1);
      245 				/* assume we fell in */
      246 	  bp = addrel (bp, bp -> runtime_block.father);
      247 				/* "called" by father, obviously */
      248 	end;
      249 
      250         /* now p -> last loc in caller, bp is callers block */
      251         do test_lfp = lfp /* detect caller loop in symbol table */
      252 	   repeat (test_lfp -> level_frame.prev)
      253 	   while (test_lfp ^= saved_lfp);
      254 
      255 	if test_lfp -> level_frame.block_ptr = bp
      256 	  then go to NO_MORE_QUICK;
      257         end;
      258 
      259 
      260         /* make a new level for caller, who may or may not be quick but we already know much about it */
      261 
      262         if p ^= null then do;		/* print level only if we have instruction_ptr */
      263 
      264 	  lfp = new_level ();
      265 
      266 	  level_frame.instruction_ptr = p;
      267 	  level_frame.block_ptr = bp;
      268 	  level_frame.stack_ptr = a_sp;
      269 	  level_frame.seg_info_ptr = seg_infop;
      270 
      271 	  if p ^= null
      272 	    then call stu_$get_map_index (hp, bin (rel (p), 18),
      273 		    level_frame.stmnt_map_entry_index, (null));
      274 
      275 	  if bp = null ()		/* can't find father ! */
      276 	    then continue_tracing = "0"b;
      277 	  else if bp -> runtime_block.quick
      278 	    then continue_tracing = "1"b;
      279 				/* how good is the optimizer? */
      280 	  else continue_tracing = "0"b;
      281 				/* fatherblock is owner */
      282 	end;
      283 	else continue_tracing = "0"b;
      284       end;			/* quick loop */
      285 
      286 NO_MORE_QUICK:
      287 				/* now we know we have a level for the OWNER of the frame */
      288       level_frame.entry_ptr = entryp;
      289 
      290     end;				/* frame with symbol table */
      291 
      292   call component_info_$offset (ptr (entryp, 0), binary (rel (entryp), 18),
      293        addr (ci), code);
      294   level_frame.component_text_ptr = null;
      295   if code = 0
      296     then
      297          if rel (ci.text_start) ^= "0"b then do;
      298 	   level_frame.component_name = ci.name;
      299 	   level_frame.component_text_ptr = text_start;
      300 	 end;
      301 
      302 
      303   end analyze_frame;
      304 				/*  */
      305 
      306 new_level:
      307   proc () returns (ptr);
      308 
      309   /* return a ptr to a new level_frame  and intialize the new level_frame
      310*
      311*   old level_frames from previous use in this process are re-cycled if available,
      312*   this conserves time */
      313 
      314   return (initialize_level (get_ptr_to_new ()));
      315 
      316 
      317 
      318 
      319 get_ptr_to_new:
      320   proc () returns (ptr);
      321 
      322   /* global imports scratch_area, stack_info, lfp */
      323 
      324   if lfp = null () /* first call , have no frames */
      325     then do;
      326       if stack_info.level_chain = null ()
      327         then do;			/* first time ever in whole process */
      328 	allocate level_frame in (scratch_area) set (stack_info.level_chain);
      329 	unspec (stack_info.level_chain -> level_frame) = "0"b;
      330 	stack_info.level_chain -> level_frame.next = null ();
      331 				/* obviously */
      332         end;
      333       return (stack_info.level_chain);
      334     end;				/* null lfp case */
      335     else do;			/* can use lfp */
      336       if level_frame.next = null /* have used them all up */
      337         then do;			/* must make a new one */
      338 	on area go to RENUMBER;	/* give up if stack is too big */
      339 	allocate level_frame in (scratch_area) set (level_frame.next);
      340 	unspec (level_frame.next -> level_frame) = "0"b;
      341 	level_frame.next -> level_frame.next = null ();
      342 				/* obviously there is no next, either */
      343         end;			/* making a brand new level */
      344       return (level_frame.next);
      345     end;
      346   end get_ptr_to_new;
      347 
      348 initialize_level:
      349   proc (tp) returns (ptr);
      350 
      351   /* initialize the level_frame we have ptr to, and return its address */
      352   dcl tp			ptr parameter;
      353 
      354   tp -> level_frame.stmnt_map_entry_index = -1;
      355   tp -> level_frame.instruction_ptr,
      356        tp -> level_frame.block_ptr, tp -> level_frame.stack_ptr,
      357        tp -> level_frame.entry_ptr,
      358        tp -> level_frame.seg_info_ptr, tp -> level_frame.condition_frame_ptr =
      359        null ();
      360   string (tp -> level_frame.flags) = "0"b;
      361 
      362   tp -> level_frame.number, stack_info.max_level =
      363        stack_info.max_level + 1;
      364   tp -> level_frame.prev = prev_lfp;
      365   prev_lfp = tp;
      366 
      367   return (tp);
      368   end initialize_level;
      369 
      370   end new_level;
      371 				/*  */
      372 
  1     1 /*	BEGIN INCLUDE FILE probe_info.incl.pl1		*/
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(88-10-24,WAAnderson), approve(88-10-24,MCR7952),
  1     7*     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
  1     8*     Added field 'retry_using_main' to add new C feature.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* Created: 04/22/79 W. Olin Sibert, from subsystem_info	
  1    13*   Modified: 22 Sept 79 JRd to remove: 	default (ptr & (auto|based)) init (null ());
  1    14*   Added flags.setting_break 08/22/83 Steve Herbst
  1    15*   Added flags.executing_quit_request 01/15/85 Steve Herbst
  1    16**/
  1    17 
  1    18 dcl 1 probe_info aligned based (probe_info_ptr),		/* standard data for a probe invocation */
  1    19     2 probe_info_version fixed bin,			/* version of this structure */
  1    20 
  1    21     2 static_info_ptr pointer unaligned,		/* pointer to static information structure */
  1    22     2 modes_ptr pointer unaligned,			/* pointer to probe_modes structure */
  1    23 
  1    24     2 ptr_to_current_source ptr,			/* current_source is based on this */
  1    25     2 ptr_to_initial_source ptr,			/* initial_source is based on this */
  1    26     2 machine_cond_ptr pointer,			/* pointer to machine conditions, if we faulted to get here */
  1    27 
  1    28     2 token_info aligned,				/* information about token chain currently being processed */
  1    29       3 first_token pointer unaligned,			/* first token in chain */
  1    30       3 ct pointer unaligned, 			/* pointer to current token; updated in MANY places */
  1    31       3 end_token bit (18) aligned,			/* token type at which to stop scanning token chain */
  1    32       3 buffer_ptr pointer unaligned,			/* pointer to input buffer */
  1    33       3 buffer_lth fixed bin (21),			/* and length */
  1    34 
  1    35     2 random_info aligned,
  1    36       3 current_stack_frame pointer unaligned,		/* stack frame pointer for frame in which probe was invoked */
  1    37       3 input_type fixed bin, 			/* current input type */
  1    38       3 language_type fixed bin,			/* current language being processed */
  1    39       3 return_method fixed bin,			/* how we should return after exiting probe */
  1    40       3 entry_method fixed bin,			/* how we got here in the first place */
  1    41       3 pad1 (19) bit (36) aligned,
  1    42 
  1    43     2 break_info,					/* break info -- only interesting if we got here via a break */
  1    44       3 break_slot_ptr pointer,			/* pointer to break slot -- non-null IFF at a break */
  1    45       3 last_break_slot_ptr pointer unaligned,		/* pointer to previous break slot, not presently used */
  1    46       3 break_reset bit (1) aligned,			/* this break has been reset by somebody further on */
  1    47       3 real_break_return_loc pointer,			/* where to REALLY return to, modulo previous bit */
  1    48 
  1    49     2 probe_area_info,				/* information about various probe areas */
  1    50       3 break_segment_ptr pointer unaligned,		/* pointer to Personid.probe */
  1    51       3 break_area_ptr pointer unaligned,		/* pointer to area in break segment */
  1    52       3 scratch_area_ptr pointer unaligned,		/* pointer to probe scratch seg in process dir */
  1    53       3 probe_area_ptr pointer unaligned,		/* This area lasts as long as an invocation of probe. */
  1    54       3 work_area_ptr pointer unaligned,		/* This area lasts as long as the current request line */
  1    55       3 expression_area_ptr pointer unaligned,		/* This area lasts as long as the current command */
  1    56 
  1    57     2 flags aligned,				/* this, in particular, should be saved and restored correctly */
  1    58      (3 execute,					/* "1"b => execute requests, "0"b => just check syntax */
  1    59       3 in_listener,				/* ON => in probe listener loop */
  1    60       3 executing_request,				/* ON => executing a request */
  1    61       3 in_interpret_line,				/* executing in probe_listen_$interpret_line */
  1    62       3 setting_break,				/* executing "after" or "before": check syntax of "if" */
  1    63       3 executing_quit_request,			/* to prevent error looping during "quit" request */
  1    64       3 pad (30)) bit (1) unaligned,
  1    65 
  1    66     2 io_switches,					/* switches probe will do normal I/O on */
  1    67       3 input_switch pointer,
  1    68       3 output_switch pointer,
  1    69 
  1    70     2 error_info,					/* information about the last error saved for later printing */
  1    71       3 error_code fixed bin (35),
  1    72       3 error_message char (300) varying,
  1    73 
  1    74     2 listener_info,				/* internal use by probe listener */
  1    75       3 request_name character (32) varying,		/* primary name of the request being processed */
  1    76       3 abort_probe_label label variable,
  1    77       3 abort_line_label label variable,
  1    78       3 depth fixed binary,				/* count of active invocations of probe */
  1    79       3 previous pointer unaligned,			/* -> previous invocation's info */
  1    80       3 next pointer unaligned,
  1    81 
  1    82     2 end_of_probe_info pointer aligned,
  1    83     2 retry_using_main fixed bin aligned;
  1    84    
  1    85 
  1    86 dcl  probe_info_ptr pointer;
  1    87 
  1    88 dcl  probe_info_version fixed bin static options (constant) initial (1);
  1    89 
  1    90 dcl  probe_info_version_1 fixed bin static options (constant) initial (1);
  1    91 
  1    92 dcl  scratch_area area based (probe_info.scratch_area_ptr);
  1    93 dcl  probe_area area based (probe_info.probe_area_ptr);
  1    94 dcl  work_area area based (probe_info.work_area_ptr);
  1    95 dcl  expression_area area based (probe_info.expression_area_ptr);
  1    96 
  1    97 /*	END INCLUDE FILE probe_info.incl.pl1		*/
      373 
      374 
      375   /* ;;;;;;; */
      376 
  2     1 /*	BEGIN INCLUDE FILE probe_static_info.incl.pl1	*/
  2     2 
  2     3 /* *	This include file describes per-process information about probe, such
  2     4*   *	as various options available and the info directories and modes.
  2     5*   *
  2     6*   *	Created: 06/06/79 W. Olin Sibert */
  2     7 
  2     8 dcl 1 probe_static_info aligned based (probe_info.static_info_ptr), /* per-process data about probe */
  2     9     2 probe_info_version fixed bin,			/* same as probe_info.probe_info_version */
  2    10 
  2    11     2 version aligned,
  2    12       3 major_version fixed bin,
  2    13       3 minor_version fixed bin,
  2    14       3 version_string char (32) unaligned,		/* like "4.3f, patch 1" */
  2    15 
  2    16     2 name char (32) unaligned,			/* "probe" */
  2    17     2 prompt character (40) varying,			/* prompt for reading requests */
  2    18     2 switches,
  2    19       3 brief_sw bit (1) unaligned,			/* briefer break messages, no header (default OFF) */
  2    20       3 no_handle_faults_sw bit (1) unaligned,		/* don't handle bad ptr faults (default OFF) */
  2    21       3 recursive_breaks_sw bit (1) unaligned,		/* don't ignore recursive breaks in probe */
  2    22       3 prompt_on_sw bit (1) unaligned,			/* prompt for request lines */
  2    23       3 switch_pad bit (32) unaligned,
  2    24 
  2    25     2 scratch_segment_ptr pointer,			/* pointer to probe_scratch_ -- always valid */
  2    26     2 break_segment_ptr pointer,			/* pointer to Person.breaks -- valid only if needed */
  2    27 
  2    28     2 seg_info_offset_ptr pointer,			/* pointer to seg_info_offset array */
  2    29 
  2    30     2 probe_segno bit (18),				/* segment number of probe itself */
  2    31    2 last_break_segno bit (18),			/* segment number of last interrupted program */
  2    32 
  2    33     2 stack_info aligned,				/* information about the stack trace in probe_scratch_ */
  2    34       3 level_chain pointer unaligned,			/* first level frame entry pointer */
  2    35       3 max_level fixed bin,				/* number of stack levels */
  2    36       3 flags aligned,
  2    37        (4 good_stack,
  2    38         4 traced_with_all,				/* whether the stack trace includes support frames */
  2    39         4 pad1 (34)) bit (1) unaligned,
  2    40 
  2    41     2 modes_ptr pointer unaligned,			/* pointer to modes -- same as probe_info.modes_ptr */
  2    42 
  2    43     2 request_table_info aligned,			/* info for request definitions */
  2    44       3 array_ptr pointer,				/* pointer to array of request table pointers */
  2    45       3 array_size fixed bin, 			/* number of elements in use */
  2    46       3 array_max_size fixed bin,			/* max number of elements in array */
  2    47       3 using_internal_array bit (1) aligned,		/* whether or not we are using the array in probe_static_info */
  2    48 
  2    49     2 io_switches,					/* switches probe does its I/O on */
  2    50       3 input_switch pointer,
  2    51       3 output_switch pointer,
  2    52       3 (private_input_sw, private_output_sw) bit (1) aligned,
  2    53 						/* created by ids, ods and should be destroyed */
  2    54 
  2    55     2 info_directory_info aligned,			/* info about info directories */
  2    56       3 array_ptr pointer,
  2    57       3 array_size fixed bin,
  2    58       3 array_max_size fixed bin,
  2    59       3 using_internal_array bit (1) aligned,
  2    60 
  2    61     2 exclude_name_info aligned,			/* info for exclude array used in printing values */
  2    62       3 array_ptr pointer,
  2    63       3 array_size fixed bin,
  2    64       3 array_max_size fixed bin,
  2    65       3 using_internal_array bit (1) aligned,
  2    66 
  2    67     2 null_seg_info_ptr pointer unaligned,		/* pointer to the "null" seg_info block */
  2    68 
  2    69     2 initial_arrays,				/* initial versions of various arrays */
  2    70       3 request_table_ptr_array (10) pointer aligned,
  2    71       3 info_directory_name_array (3) char (168) unaligned,
  2    72       3 exclude_name_array (6) char (32) unaligned,
  2    73 
  2    74     2 metering_info,					/* last values for "mode meter" */
  2    75       3 last_clock fixed bin (71),
  2    76       3 last_vclock fixed bin (71),
  2    77       3 last_page_faults fixed bin,
  2    78 
  2    79     2 end_of_probe_static_info fixed bin;
  2    80 
  2    81 
  2    82 dcl 1 probe_seg_info_array aligned based (probe_static_info.seg_info_offset_ptr),
  2    83     2 count fixed bin,				/* number of entries in seg_info_offset array */
  2    84     2 seg_info_offset (0 : seg_info_offset_count refer (probe_seg_info_array.count)) bit (18) aligned;
  2    85 
  2    86 dcl  seg_info_offset_count fixed bin;			/* one less than the number of info_offsets */
  2    87 
  2    88 dcl  probe_request_tables (probe_static_info.request_table_info.array_max_size) /* array of request table pointers */
  2    89      pointer aligned based (probe_static_info.request_table_info.array_ptr);
  2    90 
  2    91 dcl  probe_info_directories (probe_static_info.info_directory_info.array_max_size) /* array of info directories */
  2    92      char (168) unaligned based (probe_static_info.info_directory_info.array_ptr);
  2    93 
  2    94 dcl  probe_exclude_names (probe_static_info.exclude_name_info.array_max_size) /* array of exclude names */
  2    95      char (168) unaligned based (probe_static_info.exclude_name_info.array_ptr);
  2    96 
  2    97 /*	END INCLUDE FILE probe_static_info.incl.pl1	*/
      377 
      378 
      379   /* ;;;;;;; */
      380   /* ;;;;;;; */
      381 
  3     1 /* BEGIN INCLUDE FILE ... probe_level_frame.incl.pl1  */
  3     2 
  3     3 /* Modified 25 Aug 79 JRDavis */
  3     4 /* Added printed_(number decimal) for numbering support frames 12/10/81 S. Herbst */
  3     5 
  3     6 dcl 1 level_frame based (lfp) aligned,
  3     7       2 next ptr unal,
  3     8       2 prev ptr unal,
  3     9       2 number fixed bin,
  3    10       2 printed_number fixed bin,
  3    11       2 printed_decimal fixed bin,
  3    12       2 condition_frame_ptr ptr,
  3    13       2 flags unal,
  3    14         3 quick bit (1) unal,
  3    15         3 error_signalled bit (1) unal,
  3    16         3 support bit (1) unal,
  3    17         3 run_unit_manager bit (1) unal,
  3    18         3 pad bit (32) unal,
  3    19       2 source_info aligned like source_info,
  3    20       2 component_info aligned,
  3    21        3 component_name char (32),
  3    22        3 component_text_ptr ptr;
  3    23 
  3    24 dcl lfp ptr;
  3    25 
  3    26 /* END INCLUDE FILE ... probe_level_frame.incl.pl1 */
      382 
      383 
      384   /* ;;;;;;; */
      385 
  4     1 /* BEGIN INCLUDE FILE ... probe_source_info.incl.pl1
  4     2*
  4     3*  James R. Davis 2 July 79 */
  4     4 
  4     5 dcl 1 source_info based aligned,
  4     6       2 stmnt_map_entry_index fixed bin,		/* index in stmnt map for this stmnt */
  4     7       2 instruction_ptr ptr,				/* to last instruction executed  */
  4     8       2 block_ptr ptr,				/* to runtime_block node */
  4     9       2 stack_ptr ptr,				/* to a stack frame */
  4    10       2 entry_ptr ptr,				/* to entry seq. for this proc */
  4    11       2 seg_info_ptr ptr;				/* to seg_info */
  4    12 
  4    13 dcl 1 current_source aligned like source_info based (probe_info.ptr_to_current_source);
  4    14 dcl 1 initial_source aligned like source_info based (probe_info.ptr_to_initial_source);
  4    15 
  4    16 /* END INCLUDE FILE ... probe_source_info.incl.pl1 */
      386 
      387 
      388   /* ;;;;;;; */
      389 
  5     1 /* BEGIN INCLUDE FILE ... probe_seg_info.incl.pl1
  5     2*
  5     3*   25 June 79 JRDavis
  5     4*
  5     5*   Modified  7 April 1983, TO - Add fields for character offset/line
  5     6*	correction per file.
  5     7**/
  5     8 
  5     9 dcl 1 seg_info based aligned,				/* place to remember information about object seg */
  5    10     2 language_type fixed bin,			/* language of source program */
  5    11     2 bits aligned,
  5    12       3 ignore_case bit (1) unal,
  5    13       3 bound_segment bit (1) unaligned,
  5    14       3 component bit (1) unaligned,
  5    15       3 pad bit (33) unal,
  5    16     2 names,					/* where to find it */
  5    17       3 directory_name character (168) unal,		/* what directory */
  5    18       3 entry_name character (32) unal,			/* what segment */
  5    19       3 segname character (32) unal,			/* procedure segname definition */
  5    20     2 identifier fixed bin (71),			/* time of object creation */
  5    21     2 pointers,					/* location of various parts of segment */
  5    22       3 symbol_header_ptr ptr unal,			/* to symbol section */
  5    23       3 original_source_ptr ptr unal,			/* to segment source map */
  5    24       3 statement_map_ptr ptr unal,			/* to segment statement map */
  5    25       3 break_info ptr unal,				/* for unbound segments, and start of chain for
  5    26*						   bound ones, -> break_map !obsolete, I think! */
  5    27       3 chain ptr unal,				/* to entry for next component if bound */
  5    28       3 linkage_ptr ptr unal,				/* to linkage section */
  5    29     2 bounds aligned,				/* structure of bounds information */
  5    30       3 text_bounds,
  5    31         4 start fixed bin (35),
  5    32         4 end fixed bin (35),
  5    33       3 symbol_bounds,
  5    34         4 start fixed bin (35),
  5    35         4 end fixed bin (35),
  5    36     2 map_size fixed bin,				/* size of statement map */
  5    37     2 error_code fixed bin (35),			/* errors encoutered while getting info, are recorded here */
  5    38     2 bound_create_time fixed bin (71),			/* time seg containing was bound or compiled. */
  5    39     2 bound_sym_header ptr unal,			/* to sym. section header for bound seg */
  5    40     2 pad (1) fixed bin (35),
  5    41 
  5    42     2 nfiles fixed bin,
  5    43     2 per_file (seg_info_nfiles refer (seg_info.nfiles)),
  5    44       3 file_pointers ptr unal,
  5    45       3 break_line (0:3) fixed bin (18) unsigned unaligned;
  5    46 
  5    47 dcl  seg_info_nfiles fixed bin;			/* for allocation purposes */
  5    48 
  5    49 
  5    50 /* END INCLUDE FILE ... probe_seg_info.incl.pl1 */
      390 
      391 
      392   /* ;;;;;;; */
      393 
  6     1 /* BEGIN INCLUDE FILE  ... probe_lang_types.incl.pl1
  6     2*
  6     3*   JRD 26 June 79
  6     4*   MBW 31 July 1981 to add algol68 */
  6     5 
  6     6 
  6     7 /****^  HISTORY COMMENTS:
  6     8*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  6     9*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  6    10*     Added C Language type.
  6    11*                                                   END HISTORY COMMENTS */
  6    12 
  6    13 
  6    14 /*   Modified June 83 JMAthane to add PASCAL language type */
  6    15 /*   Modified April 88 Hinatsu to add C language type */
  6    16 
  6    17      dcl	   (UNKNOWN_lang_type     init (1),
  6    18 	   OTHER_lang_type	      init (2),
  6    19 	   PL1_lang_type	      init (3),
  6    20 	   FORTRAN_lang_type      init (4),
  6    21 	   COBOL_lang_type	      init (5),
  6    22 	   ALM_lang_type	      init (6),
  6    23 	   ALGOL68_lang_type      init (7),
  6    24 	   PASCAL_lang_type	      init (8),
  6    25 	   C_lang_type	      init (9)) fixed bin internal static options (constant);
  6    26 
  6    27      dcl	   official_language_names (9) char (32) internal static options (constant) init
  6    28 			      ("Unknown", "other", "PL/I", "FORTRAN", "COBOL", "ALM", "Algol 68", "Pascal", "C");
  6    29 
  6    30      dcl	   palatable_language_names (9) char (32) internal static options (constant) init
  6    31 			      ("Unknown", "Other", "pl1", "fortran", "cobol", "alm", "algol68", "pascal", "c");
  6    32 
  6    33 /* END INCLUDE FILE ... probe_lang_types.incl.pl1 */
      394 
      395 
      396   /* ;;;;;;; */
      397 
  7     1 	/* BEGIN INCLUDE SEGMENT ...  component_info.incl.pl1   M. Weaver  4/26/72  */
  7     2 
  7     3 declare	1 ci aligned,
  7     4 	2 dcl_version fixed bin,		/* version number of this structure */
  7     5 	2 name char(32) aligned,		/* objectname of component segment */
  7     6 	2 text_start pointer,		/* ptr to component's section of text */
  7     7 	2 stat_start pointer,		/* pointer to component's section of internal static */
  7     8 	2 symb_start pointer,		/* pointer to component's first symbol block */
  7     9 	2 defblock_ptr pointer,		/* ptr to component's definition block */
  7    10 	2 text_lng fixed bin,		/* length of text section */
  7    11 	2 stat_lng fixed bin,		/* length of internal static */
  7    12 	2 symb_lng fixed bin,		/* length of symbol section */
  7    13 	2 n_blocks fixed bin,		/* number of symbol blocks in component's symbol section */
  7    14 	2 standard bit(1) aligned,		/* indicates whether component is in standard (new) format */
  7    15 	2 compiler char(8) aligned,		/* name of component's compiler */
  7    16 	2 compile_time fixed bin(71),		/* time component was compiled */
  7    17 	2 userid char(32) aligned,		/* id of creator of component */
  7    18 	2 cvers aligned,			/* version of component's compiler in printable form */
  7    19 	  3 offset bit(18) unaligned,		/* offset in words relative to symb_start */
  7    20 	  3 length bit(18) unaligned,		/* length of name in characters */
  7    21 	2 comment aligned,			/* component's comment */
  7    22 	  3 offset bit(18) unaligned,		/* offset in words relative to symb_start */
  7    23 	  3 length bit(18) unaligned,		/* length of comment in characters */
  7    24 	2 source_map fixed bin;		/* offset, rel to beg of symbol block, of component's source map */
  7    25 
  7    26 	/* END INCLUDE SEGMENT ... component_info.incl.pl1 */
      398 
      399 
      400   /* ;;;;;;; */
      401 
      402 
  8     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  8     2 
  8     3 /* Structure for find_condition_info_.
  8     4*
  8     5*   Written 1-Mar-79 by M. N. Davidoff.
  8     6**/
  8     7 
  8     8 /* automatic */
  8     9 
  8    10      declare condition_info_ptr     pointer;
  8    11 
  8    12 /* based */
  8    13 
  8    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  8    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  8    16 	     2 version	      fixed binary,		/* Must be 1 */
  8    17 	     2 condition_name     char (32) varying,	/* name of condition */
  8    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  8    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  8    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  8    21 	     2 flags	      unaligned,
  8    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  8    23 	       3 pad1	      bit (35),
  8    24 	     2 pad2	      bit (36),
  8    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  8    26 	     2 pad3	      (4) bit (36);
  8    27 
  8    28 /* internal static */
  8    29 
  8    30      declare condition_info_version_1
  8    31 			      fixed binary internal static options (constant) initial (1);
  8    32 
  8    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
      403 
      404 
      405   /* ;;;;;;; */
      406 
  9     1 /* BEGIN INCLUDE FILE ... stack_frame_exit_str.incl.pl1 */
  9     2 
  9     3      dcl	   1 stack_frame_exit_str aligned based,
  9     4 	     2 bad_frame	      bit (1) unal,		/*  frame supplied was not legal */
  9     5 	     2 exists_ppr	      bit (1) unal,		/*  the ppr from machine conditions is used */
  9     6 	     2 ppr_is_owner	      bit (1) unal,		/*  the owner of this frame took the fault */
  9     7 	     2 ppr_is_ops	      bit (1) unal,		/*  the fault occured in pl1 operators */
  9     8 	     2 caller_is_owner    bit (1) unal,		/*  fault in ops, and ops called by owner */
  9     9 	     2 entry_ptr_invalid  bit (1) unal,		/*  was null or otherwise bad */
  9    10 	     2 ret_ptr_is_ops     bit (1) unal,		/*  return ptr in frame points to ops */
  9    11 	     2 called_begin_block bit (1) unal,		/*  this frame "called" a non-quick begin block */
  9    12 	     2 pad	      bit (28) unal;
  9    13 
  9    14 /* END INCLUDE FILE ... stack_frame_exit_str.incl.pl1 */
      407 
      408 
      409   /* ;;;;;;; */
      410 
 10     1 /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
 10     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
 10     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
 10     4 /*	Modified April 1983 by C. Hornig for tasking */
 10     5 
 10     6 /****^  HISTORY COMMENTS:
 10     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
 10     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
 10     9*     added the heap_header_ptr definition.
 10    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
 10    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
 10    12*     Modified to support control point management.  These changes were actually
 10    13*     made in February 1985 by G. Palter.
 10    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
 10    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
 10    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
 10    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
 10    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
 10    19*     (ITS pair).
 10    20*                                                   END HISTORY COMMENTS */
 10    21 
 10    22 /* format: style2 */
 10    23 
 10    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
 10    25 
 10    26      dcl	   1 stack_header	      based (sb) aligned,
 10    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
 10    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
 10    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
 10    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
 10    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
 10    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
 10    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
 10    34 	     2 pad4	      bit (2) unal,
 10    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
 10    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
 10    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
 10    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
 10    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
 10    40 	     2 null_ptr	      ptr,		/*  (16)  */
 10    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
 10    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
 10    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
 10    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
 10    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
 10    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
 10    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
 10    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
 10    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
 10    50 	     2 return_no_pop_op_ptr
 10    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
 10    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
 10    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
 10    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
 10    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
 10    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
 10    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
 10    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
 10    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
 10    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
 10    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
 10    62 	     2 trace,
 10    63 	       3 frames,
 10    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
 10    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
 10    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
 10    67 	     2 pad2	      bit (36),		/*  (61) */
 10    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
 10    69 
 10    70 /*	The following offset refers to a table within the  pl1  operator table.  */
 10    71 
 10    72      dcl	   tv_offset	      fixed bin init (361) internal static;
 10    73 						/* (551) octal */
 10    74 
 10    75 
 10    76 /*	The following constants are offsets within this transfer vector table.  */
 10    77 
 10    78      dcl	   (
 10    79 	   call_offset	      fixed bin init (271),
 10    80 	   push_offset	      fixed bin init (272),
 10    81 	   return_offset	      fixed bin init (273),
 10    82 	   return_no_pop_offset   fixed bin init (274),
 10    83 	   entry_offset	      fixed bin init (275)
 10    84 	   )		      internal static;
 10    85 
 10    86 
 10    87 
 10    88 
 10    89 
 10    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
 10    91*	move the whole stack header should use this overlay.
 10    92**/
 10    93 
 10    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
 10    95 
 10    96 
 10    97 
 10    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
      411 
      412 
      413   /* ;;;;;;; */
      414 
 11     1 /*	BEGIN INCLUDE FILE ... runtime_symbol.incl.pl1 ... Modified 07/79 */
 11     2 
 11     3 dcl	1 runtime_symbol	aligned based,
 11     4 	2 flag		unal bit(1),	/* always "1"b for Version II */
 11     5 	2 use_digit	unal bit(1),	/* if "1"b and units are half words units are really digits */
 11     6 	2 array_units	unal bit(2),
 11     7 	2 units		unal bit(2),	/* addressing units */
 11     8 	2 type		unal bit(6),	/* data type */
 11     9 	2 level		unal bit(6),	/* structure level */
 11    10 	2 ndims		unal bit(6),	/* number of dimensions */
 11    11 	2 bits		unal,
 11    12 	  3 aligned	bit(1),
 11    13 	  3 packed	bit(1),
 11    14 	  3 simple	bit(1),
 11    15 	2 skip		unal bit(1),
 11    16 	2 scale		unal bit(8),	/* arithmetic scale factor */
 11    17 	2 name		unal bit(18),	/* rel ptr to acc name */
 11    18 	2 brother		unal bit(18),	/* rel ptr to brother entry */
 11    19 	2 father		unal bit(18),	/* rel ptr to father entry */
 11    20 	2 son		unal bit(18),	/* rel ptr to son entry */
 11    21 	2 address		unal,
 11    22 	  3 location	bit(18),		/* location in storage class */
 11    23 	  3 class		bit(4),		/* storage class */
 11    24 	  3 next		bit(14),		/* rel ptr to next of same class */
 11    25 	2 size		fixed bin(35),	/* encoded string|arith size */
 11    26 	2 offset		fixed bin(35),	/* encoded offset from address */
 11    27 	2 virtual_org	fixed bin(35),
 11    28 	2 bounds(1),
 11    29 	  3 lower		fixed bin(35),	/* encoded lower bound */
 11    30 	  3 upper		fixed bin(35),	/* encoded upper bound */
 11    31 	  3 multiplier	fixed bin(35);	/* encoded multiplier */
 11    32 
 11    33 dcl	1 runtime_bound	based,
 11    34 	2 lower		fixed bin(35),
 11    35 	2 upper		fixed bin(35),
 11    36 	2 multiplier	fixed bin(35);
 11    37 
 11    38 dcl	1 runtime_block	aligned based,
 11    39 	2 flag		unal bit(1),	/* always "1"b for Version II */
 11    40 	2 quick		unal bit(1),	/* "1"b if quick block */
 11    41 	2 fortran		unal bit(1),	/* "1"b if fortran program */
 11    42 	2 standard	unal bit(1),	/* "1"b if program has std obj segment */
 11    43 	2 owner_flag	unal bit(1),	/* "1"b if block has valid owner field */
 11    44 	2 skip		unal bit(1),
 11    45 	2 type		unal bit(6),	/* = 0 for a block node */
 11    46 	2 number		unal bit(6),	/* begin block number */
 11    47 	2 start		unal bit(18),	/* rel ptr to start of symbols */
 11    48 	2 name		unal bit(18),	/* rel ptr to name of proc */
 11    49 	2 brother		unal bit(18),	/* rel ptr to brother block */
 11    50 	2 father		unal bit(18),	/* rel ptr to father block */
 11    51 	2 son		unal bit(18),	/* rel ptr to son block */
 11    52 	2 map		unal,
 11    53 	  3 first		bit(18),		/* rel ptr to first word of map */
 11    54 	  3 last		bit(18),		/* rel ptr to last word of map */
 11    55 	2 entry_info	unal bit(18),	/* info about entry of quick block */
 11    56 	2 header		unal bit(18),	/* rel ptr to symbol header */
 11    57 	2 chain(4)	unal bit(18),	/* chain(i) is rel ptr to first symbol
 11    58*					   on start list with length >= 2**i */
 11    59 	2 token(0:5)	unal bit(18),	/* token(i) is rel ptr to first token
 11    60*					   on list with length >= 2 ** i */
 11    61 	2 owner		unal bit(18);	/* rel ptr to owner block */
 11    62 
 11    63 dcl	1 runtime_token	aligned based,
 11    64 	2 next		unal bit(18),	/* rel ptr to next token */
 11    65 	2 dcl		unal bit(18),	/* rel ptr to first dcl of this token */
 11    66 	2 name,				/* ACC */
 11    67 	  3 size		unal unsigned fixed bin (9), /* number of chars in token */
 11    68 	  3 string	unal char(n refer(runtime_token.size));
 11    69 
 11    70 dcl	1 encoded_value	aligned based,
 11    71 	2 flag		bit (2) unal,
 11    72 	2 code		bit (4) unal,
 11    73 	2 n1		bit (6) unal,
 11    74 	2 n2		bit (6) unal,
 11    75 	2 n3		bit (18) unal;
 11    76 
 11    77 /*	END INCLUDE FILE ... runtime_symbol.incl.pl1 */
      415 
      416 
      417   /* ;;;;;;; */
      418 
 12     1 dcl	1 quick_entry	aligned based,
 12     2 	2 return		ptr,
 12     3 	2 argptr		ptr,
 12     4 	2 descptr		ptr;
      419 
      420 
      421   /* ;;;;;;; */
      422 
 13     1 /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
 13     2 
 13     3 /* format: off */
 13     4 
 13     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
 13     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
 13     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
 13     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
 13     9 
 13    10 
 13    11 /****^  HISTORY COMMENTS:
 13    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
 13    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
 13    14*     Modified to add constants for the translator_id field in the stack_frame
 13    15*     structure.
 13    16*                                                   END HISTORY COMMENTS */
 13    17 
 13    18 
 13    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
 13    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
 13    21 						/* with indicators (nonzero for Fortran hexfp caller) */
 13    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
 13    23 
 13    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
 13    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
 13    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
 13    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
 13    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
 13    29 
 13    30 
 13    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
 13    32 
 13    33 dcl  stack_frame_min_length fixed bin static init(48);
 13    34 
 13    35 
 13    36 dcl 1 stack_frame based(sp) aligned,
 13    37     2 pointer_registers(0 : 7) ptr,
 13    38     2 prev_sp pointer,
 13    39     2 next_sp pointer,
 13    40     2 return_ptr pointer,
 13    41     2 entry_ptr pointer,
 13    42     2 operator_and_lp_ptr ptr,			/* serves as both */
 13    43     2 arg_ptr pointer,
 13    44     2 static_ptr ptr unaligned,
 13    45     2 support_ptr ptr unal, /* only used by fortran I/O */
 13    46     2 on_unit_relp1 bit(18) unaligned,
 13    47     2 on_unit_relp2 bit(18) unaligned,
 13    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
 13    49*						   0 => PL/I version II
 13    50*						   1 => ALM
 13    51*						   2 => PL/I version I   
 13    52*						   3 => signal caller frame
 13    53*						   4 => signaller frame */
 13    54     2 operator_return_offset bit(18) unaligned,
 13    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
 13    56     2 a bit(36),					/* accumulator */
 13    57     2 q bit(36),					/* q-register */
 13    58     2 e bit(36),					/* exponent */
 13    59     2 timer bit(27) unaligned,				/* timer */
 13    60     2 pad bit(6) unaligned,
 13    61     2 ring_alarm_reg bit(3) unaligned;
 13    62 
 13    63 
 13    64 dcl 1 stack_frame_flags based(sp) aligned,
 13    65     2 pad(0 : 7) bit(72),				/* skip over prs */
 13    66     2 xx0 bit(22) unal,
 13    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
 13    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
 13    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
 13    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
 13    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
 13    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
 13    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
 13    74     2 condition bit(1) unal,				/* on if condition established in this frame */
 13    75     2 xx0a bit(6) unal,
 13    76     2 xx1 fixed bin,
 13    77     2 xx2 fixed bin,
 13    78     2 xx3 bit(25) unal,
 13    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
 13    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
 13    81     2 xx3a bit(9) unaligned,
 13    82     2 xx4(9) bit(72) aligned,
 13    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
 13    84*						*  operator puts a pointer to the base of
 13    85*						*  the calling procedure here. (text base ptr)  */
 13    86     2 xx5 bit(72) aligned,
 13    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
 13    88 
 13    89 /* format: on */
 13    90 
 13    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
      423 
      424 
      425   /* ;;;;;;; */
      426 
 14     1 dcl	1 std_symbol_header	based aligned,
 14     2 	2 dcl_version	fixed bin,
 14     3 	2 identifier	char(8),
 14     4 	2 gen_number	fixed bin,
 14     5 	2 gen_created	fixed bin(71),
 14     6 	2 object_created	fixed bin(71),
 14     7 	2 generator	char(8),
 14     8 	2 gen_version	unaligned,
 14     9 	  3 offset	bit(18),
 14    10 	  3 size		bit(18),
 14    11 	2 userid		unaligned,
 14    12 	  3 offset	bit(18),
 14    13 	  3 size		bit(18),
 14    14 	2 comment		unaligned,
 14    15 	  3 offset	bit(18),
 14    16 	  3 size		bit(18),
 14    17 	2 text_boundary	bit(18) unaligned,
 14    18 	2 stat_boundary	bit(18) unaligned,
 14    19 	2 source_map	bit(18) unaligned,
 14    20 	2 area_pointer	bit(18) unaligned,
 14    21 	2 backpointer	bit(18) unaligned,
 14    22 	2 block_size	bit(18) unaligned,
 14    23 	2 next_block	bit(18) unaligned,
 14    24 	2 rel_text	bit(18) unaligned,
 14    25 	2 rel_def		bit(18) unaligned,
 14    26 	2 rel_link	bit(18) unaligned,
 14    27 	2 rel_symbol	bit(18) unaligned,
 14    28 	2 mini_truncate	bit(18) unaligned,
 14    29 	2 maxi_truncate	bit(18) unaligned;
      427 
      428 
      429   /* ;;;;;;; */
      430 
 15     1 dcl	1 statement_map	aligned based,
 15     2 	2 location	bit(18) unaligned,
 15     3 	2 source_id	unaligned,
 15     4 	  3 file		bit(8),
 15     5 	  3 line		bit(14),
 15     6 	  3 statement	bit(5),
 15     7 	2 source_info	unaligned,
 15     8 	  3 start		bit(18),
 15     9 	  3 length	bit(9);
      431 
      432 
      433   end probe_trace_a_stack_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1135.2  probe_trace_a_stack_.pl1          >udd>sm>ds>w>ml>probe_trace_a_stack_.pl1
373          1    10/27/88  1439.2  probe_info.incl.pl1               >ldd>incl>probe_info.incl.pl1
377          2    11/12/82  1724.3  probe_static_info.incl.pl1        >ldd>incl>probe_static_info.incl.pl1
382          3    05/17/82  1511.1  probe_level_frame.incl.pl1        >ldd>incl>probe_level_frame.incl.pl1
386          4    11/26/79  1420.6  probe_source_info.incl.pl1        >ldd>incl>probe_source_info.incl.pl1
390          5    11/02/83  1945.0  probe_seg_info.incl.pl1           >ldd>incl>probe_seg_info.incl.pl1
394          6    10/26/88  1355.5  probe_lang_types.incl.pl1         >ldd>incl>probe_lang_types.incl.pl1
398          7    05/06/74  1841.0  component_info.incl.pl1           >ldd>incl>component_info.incl.pl1
403          8    06/28/79  1304.8  condition_info.incl.pl1           >ldd>incl>condition_info.incl.pl1
407          9    06/28/79  1304.8  stack_frame_exit_str.incl.pl1     >ldd>incl>stack_frame_exit_str.incl.pl1
411         10    11/07/86  1650.3  stack_header.incl.pl1             >ldd>incl>stack_header.incl.pl1
415         11    11/26/79  1420.6  runtime_symbol.incl.pl1           >ldd>incl>runtime_symbol.incl.pl1
419         12    05/06/74  1843.0  quick_entry.incl.pl1              >ldd>incl>quick_entry.incl.pl1
423         13    11/07/86  1650.3  stack_frame.incl.pl1              >ldd>incl>stack_frame.incl.pl1
427         14    05/06/74  1851.6  std_symbol_header.incl.pl1        >ldd>incl>std_symbol_header.incl.pl1
431         15    05/06/74  1851.6  statement_map.incl.pl1            >ldd>incl>statement_map.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
FORTRAN_lang_type                      constant        fixed bin(17,0)          initial dcl 6-17 ref 213
P_all                                  parameter       bit(1)                   dcl 44 ref 29 77
P_first                                parameter       pointer                  dcl 43 ref 29 87
P_probe_info_ptr                       parameter       pointer                  dcl 42 ref 29 76
a_sp                                   parameter       pointer                  dcl 155 ref 152 171 176 222 268
addr                                                   builtin function         dcl 69 ref 91 91 106 106 292 292
addrel                                                 builtin function         dcl 69 ref 205 213 222 232 239 244 246
area                            000000 stack reference condition                dcl 73 ref 338
baseno                                                 builtin function         dcl 69 ref 228 228
bin                                                    builtin function         dcl 69 ref 180 180 184 184 240 240 271 271
binary                                                 builtin function         dcl 69 ref 292 292
block_ptr                16            based           pointer                  level 3 dcl 3-6 set ref 195* 255 267* 355*
bp                              000254 automatic       pointer                  dcl 162 set ref 184* 186 195 199 205 205 205 220 222
                                                                                  232* 232 232 240* 246* 246 246 255 267 275 277
ci                              000160 automatic       structure                level 1 dcl 7-3 set ref 292 292
code                            000114 automatic       fixed bin(35,0)          dcl 52 set ref 174* 292* 295
component_info           26            based           structure                level 2 dcl 3-6
component_info_$offset          000010 constant        entry                    external dcl 57 ref 292
component_name           26            based           char(32)                 level 3 dcl 3-6 set ref 298*
component_text_ptr       36            based           pointer                  level 3 dcl 3-6 set ref 294* 299*
cond_info                       000122 automatic       structure                level 1 dcl 65 set ref 91 91
condition_frame                 000116 automatic       pointer                  dcl 53 set ref 84* 90* 101 103*
condition_frame_ptr       6            based           pointer                  level 2 dcl 3-6 set ref 101* 355*
condition_info                         based           structure                level 1 dcl 8-14
condition_name            3     000122 automatic       varying char(32)         level 2 dcl 65 set ref 141
continue_tracing                000264 automatic       bit(1)                   dcl 167 set ref 199* 201 275* 277* 280* 283*
crawl_out                20(25)        based           bit(1)                   level 2 packed packed unaligned dcl 13-64 ref 106
entry_info                4            based           bit(18)                  level 2 packed packed unaligned dcl 11-38 ref 220
                                                                                  222
entry_ptr                22            based           pointer                  level 3 in structure "level_frame" dcl 3-6
                                                                                  in procedure "probe_trace_a_stack_" set ref 188*
                                                                                  205* 213* 213 244 286* 355*
entry_ptr                26            based           pointer                  level 2 in structure "stack_frame" dcl 13-36
                                                                                  in procedure "probe_trace_a_stack_" ref 171
entry_ptr_invalid         0(05) 000121 automatic       bit(1)                   level 2 packed packed unaligned dcl 64 set ref 113
entryp                          000260 automatic       pointer                  dcl 165 set ref 171* 174* 188 286 292 292 292 292
error_signalled          10(01)        based           bit(1)                   level 3 packed packed unaligned dcl 3-6 set ref 102*
father                    2            based           bit(18)                  level 2 packed packed unaligned dcl 11-38 ref 232
                                                                                  246
find_condition_info_            000012 constant        entry                    external dcl 59 ref 91
first                     3            based           bit(18)                  level 3 packed packed unaligned dcl 11-38 ref 205
flags                    10            based           structure                level 2 in structure "level_frame" packed packed
                                                                                  unaligned dcl 3-6 in procedure
                                                                                  "probe_trace_a_stack_" set ref 360*
flags                    52            based           structure                level 3 in structure "probe_static_info" dcl 2-8
                                                                                  in procedure "probe_trace_a_stack_"
frame_decimal                   000112 automatic       fixed bin(17,0)          dcl 50 set ref 122* 126* 126 130* 133
frame_number                    000113 automatic       fixed bin(17,0)          dcl 50 set ref 122* 129* 129 132
frame_situation                 000121 automatic       structure                level 1 dcl 64 set ref 106 106
good_stack               52            based           bit(1)                   level 4 packed packed unaligned dcl 2-8 set ref 78
                                                                                  136*
hp                              000256 automatic       pointer                  dcl 163 set ref 178* 180 180* 184* 240* 271*
include_support                 000100 automatic       bit(1)                   dcl 47 set ref 77* 78 82 148
info_ptr                 14     000122 automatic       pointer                  level 2 dcl 65 set ref 141
instruction_ptr          14            based           pointer                  level 3 dcl 3-6 set ref 110* 266* 355*
is_condition_frame_             000016 constant        entry                    external dcl 62 ref 88
language_type                          based           fixed bin(17,0)          level 2 dcl 5-9 ref 213
level_chain              50            based           pointer                  level 3 packed packed unaligned dcl 2-8 set ref 326
                                                                                  328* 329 330 333
level_frame                            based           structure                level 1 dcl 3-6 set ref 328 329* 339 340*
lfp                             000156 automatic       pointer                  dcl 3-24 set ref 83* 97* 99 101 102 110 111 113 125
                                                                                  174 176 178 180 188 195 197 202 205 213 213 244
                                                                                  251 264* 266 267 268 269 271 286 294 298 299 324
                                                                                  336 339 340 341 344
location                               based           bit(18)                  level 2 packed packed unaligned dcl 15-1 ref 205
map                       3            based           structure                level 2 packed packed unaligned dcl 11-38
max_level                51            based           fixed bin(17,0)          level 3 dcl 2-8 set ref 81* 362 362*
mc_ptr                          000122 automatic       pointer                  level 2 dcl 65 set ref 94* 106* 141
name                      1     000160 automatic       char(32)                 level 2 dcl 7-3 set ref 298
next                                   based           pointer                  level 2 packed packed unaligned dcl 3-6 set ref 330*
                                                                                  336 339* 340 341* 341 344
null                                                   builtin function         dcl 69 ref 83 84 87 94 103 113 113 125 141 141 180
                                                                                  180 186 231 262 271 271 275 294 324 326 330 336
                                                                                  341 355
number                    2            based           fixed bin(17,0)          level 2 dcl 3-6 set ref 362*
p                               000102 automatic       pointer                  dcl 48 set ref 106* 110 125* 125* 126 132 133* 134
                                                                                  180 180 184 184 222* 228 231* 239* 239 240 240
                                                                                  244* 262 266 271 271 271
pl1_operators_ptr        34            based           pointer                  level 2 dcl 10-26 ref 228
pointers                 76            based           structure                level 2 dcl 5-9
prev                      1            based           pointer                  level 2 packed packed unaligned dcl 3-6 set ref 134
                                                                                  257 364*
prev_lfp                        000104 automatic       pointer                  dcl 48 set ref 83* 364 365*
prev_sp                  20            based           pointer                  level 2 dcl 13-36 ref 120
printed_decimal           4            based           fixed bin(17,0)          level 2 dcl 3-6 set ref 133*
printed_number            3            based           fixed bin(17,0)          level 2 dcl 3-6 set ref 132*
probe_area_info          56            based           structure                level 2 dcl 1-18
probe_info                             based           structure                level 1 dcl 1-18
probe_info_ptr                  000154 automatic       pointer                  dcl 1-86 set ref 76* 78 78 81 82 113* 136 174* 326
                                                                                  328 328 329 330 333 339 362 362
probe_seg_info_                 000020 constant        entry                    external dcl 67 ref 113 174
probe_static_info                      based           structure                level 1 dcl 2-8
ptr                                                    builtin function         dcl 69 ref 205 292 292
quick                    10            based           bit(1)                   level 3 in structure "level_frame" packed packed
                                                                                  unaligned dcl 3-6 in procedure
                                                                                  "probe_trace_a_stack_" set ref 202*
quick                     0(01)        based           bit(1)                   level 2 in structure "runtime_block" packed packed
                                                                                  unaligned dcl 11-38 in procedure
                                                                                  "probe_trace_a_stack_" ref 199 277
quick_entry                            based           structure                level 1 dcl 12-1
rel                                                    builtin function         dcl 69 ref 180 180 184 184 240 240 271 271 292 292
                                                                                  295
return                                 based           pointer                  level 2 dcl 12-1 ref 222
run_unit_manager         10(03)        based           bit(1)                   level 3 in structure "level_frame" packed packed
                                                                                  unaligned dcl 3-6 in procedure
                                                                                  "probe_trace_a_stack_" set ref 176*
run_unit_manager         20(23)        based           bit(1)                   level 2 in structure "stack_frame_flags" packed
                                                                                  packed unaligned dcl 13-64 in procedure
                                                                                  "probe_trace_a_stack_" ref 176
runtime_block                          based           structure                level 1 dcl 11-38
saved_lfp                       000106 automatic       pointer                  dcl 48 set ref 197* 251
scratch_area                           based           area(1024)               dcl 1-92 ref 328 339
scratch_area_ptr         60            based           pointer                  level 3 packed packed unaligned dcl 1-18 ref 328 339
seg_info                               based           structure                level 1 dcl 5-9
seg_info_ptr             24            based           pointer                  level 3 dcl 3-6 set ref 113* 174* 178 269* 355*
seg_infop                       000262 automatic       pointer                  dcl 166 set ref 174* 213 269
source_info              12            based           structure                level 2 in structure "level_frame" dcl 3-6
                                                                                  in procedure "probe_trace_a_stack_"
source_info                            based           structure                level 1 dcl 4-5 in procedure "probe_trace_a_stack_"
sp                              000230 automatic       pointer                  dcl 13-31 set ref 87* 87* 88* 90 91* 99 106* 106 111
                                                                                  118* 120 148
stack_frame                            based           structure                level 1 dcl 13-36
stack_frame_exit_               000014 constant        entry                    external dcl 60 ref 106
stack_frame_exit_str                   based           structure                level 1 dcl 9-3
stack_frame_flags                      based           structure                level 1 dcl 13-64
stack_header                           based           structure                level 1 dcl 10-26
stack_info               50            based           structure                level 2 dcl 2-8
stack_ptr                20            based           pointer                  level 3 dcl 3-6 set ref 111* 268* 355*
stackbaseptr                                           builtin function         dcl 69 ref 228
statement_map                          based           structure                level 1 dcl 15-1
static_info_ptr           1            based           pointer                  level 2 packed packed unaligned dcl 1-18 ref 78 78
                                                                                  81 82 136 326 328 329 330 333 362 362
stmnt_map_entry_index
                         12            based           fixed bin(17,0)          level 3 dcl 3-6 set ref 180* 271* 354*
string                                                 builtin function         dcl 69 set ref 360*
stu_$find_containing_block      000022 constant        entry                    external dcl 156 ref 184 240
stu_$get_map_index              000024 constant        entry                    external dcl 159 ref 180 271
support                  20(28)        based           bit(1)                   level 2 in structure "stack_frame_flags" packed
                                                                                  packed unaligned dcl 13-64 in procedure
                                                                                  "probe_trace_a_stack_" ref 99 148
support                  10(02)        based           bit(1)                   level 3 in structure "level_frame" packed packed
                                                                                  unaligned dcl 3-6 in procedure
                                                                                  "probe_trace_a_stack_" set ref 99* 126
symbol_header_ptr        76            based           pointer                  level 3 packed packed unaligned dcl 5-9 ref 178
test_lfp                        000110 automatic       pointer                  dcl 48 set ref 251* 251* 255* 257
text_start               12     000160 automatic       pointer                  level 2 dcl 7-3 set ref 295 299
tp                                     parameter       pointer                  dcl 352 ref 348 354 355 355 355 355 355 355 360 362
                                                                                  364 365 367
traced_with_all          52(01)        based           bit(1)                   level 4 packed packed unaligned dcl 2-8 set ref 78
                                                                                  82*
unspec                                                 builtin function         dcl 69 set ref 329* 340*
was_error                       000120 automatic       bit(1)                   dcl 54 set ref 85* 92* 102 104*
wc_ptr                   16     000122 automatic       pointer                  level 2 dcl 65 set ref 94* 106*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALGOL68_lang_type                      internal static fixed bin(17,0)          initial dcl 6-17
ALM_lang_type                          internal static fixed bin(17,0)          initial dcl 6-17
COBOL_lang_type                        internal static fixed bin(17,0)          initial dcl 6-17
C_lang_type                            internal static fixed bin(17,0)          initial dcl 6-17
OTHER_lang_type                        internal static fixed bin(17,0)          initial dcl 6-17
PASCAL_lang_type                       internal static fixed bin(17,0)          initial dcl 6-17
PL1_lang_type                          internal static fixed bin(17,0)          initial dcl 6-17
RETURN_PTR_MASK                        internal static bit(72)                  initial packed unaligned dcl 13-19
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial packed unaligned dcl 13-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial packed unaligned dcl 13-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial packed unaligned dcl 13-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial packed unaligned dcl 13-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial packed unaligned dcl 13-27
UNKNOWN_lang_type                      internal static fixed bin(17,0)          initial dcl 6-17
call_offset                            internal static fixed bin(17,0)          initial dcl 10-78
condition_info_ptr                     automatic       pointer                  dcl 8-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 8-30
current_source                         based           structure                level 1 dcl 4-13
encoded_value                          based           structure                level 1 dcl 11-70
entry_offset                           internal static fixed bin(17,0)          initial dcl 10-78
expression_area                        based           area(1024)               dcl 1-95
initial_source                         based           structure                level 1 dcl 4-14
official_language_names                internal static char(32)                 initial array packed unaligned dcl 6-27
palatable_language_names               internal static char(32)                 initial array packed unaligned dcl 6-30
probe_area                             based           area(1024)               dcl 1-93
probe_exclude_names                    based           char(168)                array packed unaligned dcl 2-94
probe_info_directories                 based           char(168)                array packed unaligned dcl 2-91
probe_info_version                     internal static fixed bin(17,0)          initial dcl 1-88
probe_info_version_1                   internal static fixed bin(17,0)          initial dcl 1-90
probe_request_tables                   based           pointer                  array dcl 2-88
probe_seg_info_array                   based           structure                level 1 dcl 2-82
push_offset                            internal static fixed bin(17,0)          initial dcl 10-78
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 10-78
return_offset                          internal static fixed bin(17,0)          initial dcl 10-78
runtime_bound                          based           structure                level 1 unaligned dcl 11-33
runtime_symbol                         based           structure                level 1 dcl 11-3
runtime_token                          based           structure                level 1 dcl 11-63
sb                                     automatic       pointer                  dcl 10-24
seg_info_nfiles                        automatic       fixed bin(17,0)          dcl 5-47
seg_info_offset_count                  automatic       fixed bin(17,0)          dcl 2-86
stack_frame_min_length                 internal static fixed bin(17,0)          initial dcl 13-33
stack_header_overlay                   based           fixed bin(17,0)          array dcl 10-94
std_symbol_header                      based           structure                level 1 dcl 14-1
tv_offset                              internal static fixed bin(17,0)          initial dcl 10-72
work_area                              based           area(1024)               dcl 1-94

NAMES DECLARED BY EXPLICIT CONTEXT.
NO_MORE_QUICK                   000737 constant        label                    dcl 286 ref 255
RENUMBER                        000265 constant        label                    dcl 122 ref 338
analyze_frame                   000361 constant        entry                    internal dcl 152 ref 118
get_ptr_to_new                  001023 constant        entry                    internal dcl 319 ref 314 314
initialize_level                001142 constant        entry                    internal dcl 348 ref 314
is_this_an_error_frame          000322 constant        entry                    internal dcl 139 ref 92
new_level                       001004 constant        entry                    internal dcl 306 ref 97 264
probe_trace_a_stack_            000022 constant        entry                    external dcl 29
this_frame_should_be_traced     000347 constant        entry                    internal dcl 146 ref 96

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1370        1416    1232        1400
Length      2100    1232        26         446     136           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
probe_trace_a_stack_                260 external procedure  is an external procedure.  
is_this_an_error_frame                  internal procedure  shares stack frame of external procedure probe_trace_a_stack_.  
this_frame_should_be_traced             internal procedure  shares stack frame of external procedure probe_trace_a_stack_.  
analyze_frame                           internal procedure  shares stack frame of external procedure probe_trace_a_stack_.  
new_level                               internal procedure  shares stack frame of external procedure probe_trace_a_stack_.  
get_ptr_to_new                       72 internal procedure  enables or reverts conditions.  
on unit on line 338                  64 on unit               
initialize_level                        internal procedure  shares stack frame of external procedure probe_trace_a_stack_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
probe_trace_a_stack_     000100 include_support             probe_trace_a_stack_
                         000102 p                           probe_trace_a_stack_
                         000104 prev_lfp                    probe_trace_a_stack_
                         000106 saved_lfp                   probe_trace_a_stack_
                         000110 test_lfp                    probe_trace_a_stack_
                         000112 frame_decimal               probe_trace_a_stack_
                         000113 frame_number                probe_trace_a_stack_
                         000114 code                        probe_trace_a_stack_
                         000116 condition_frame             probe_trace_a_stack_
                         000120 was_error                   probe_trace_a_stack_
                         000121 frame_situation             probe_trace_a_stack_
                         000122 cond_info                   probe_trace_a_stack_
                         000154 probe_info_ptr              probe_trace_a_stack_
                         000156 lfp                         probe_trace_a_stack_
                         000160 ci                          probe_trace_a_stack_
                         000230 sp                          probe_trace_a_stack_
                         000254 bp                          analyze_frame
                         000256 hp                          analyze_frame
                         000260 entryp                      analyze_frame
                         000262 seg_infop                   analyze_frame
                         000264 continue_tracing            analyze_frame

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out        call_int_this       return_mac          tra_ext_1           enable_op
ext_entry           int_entry           op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
component_info_$offset        find_condition_info_          is_condition_frame_           probe_seg_info_
stack_frame_exit_             stu_$find_containing_block    stu_$get_map_index

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     29 000016        76 000027        77 000033        78 000036        81 000050        82 000051        83 000056
     84 000061        85 000063        87 000064        88 000074        90 000110        91 000112        92 000130
     93 000132        94 000133        96 000136        97 000143        99 000151       101 000160       102 000162
    103 000167       104 000171       106 000172       110 000226       111 000231       113 000233       118 000257
    120 000261       122 000265       125 000267       126 000276       129 000304       130 000305       132 000306
    133 000310       134 000312       136 000315       137 000321       139 000322       141 000324       146 000347
    148 000351       152 000361       171 000363       174 000367       176 000410       178 000421       180 000424
    184 000453       186 000471       188 000475       189 000500       195 000501       197 000504       199 000506
    201 000512       202 000514       205 000517       213 000531       220 000537       222 000543       228 000551
    231 000561       232 000563       233 000567       239 000570       240 000572       242 000610       244 000611
    246 000615       251 000621       255 000630       257 000635       262 000640       264 000644       266 000652
    267 000655       268 000660       269 000665       271 000670       275 000717       277 000725       280 000733
    282 000734       283 000735       284 000736       286 000737       292 000742       294 000766       295 000771
    298 000775       299 001001       303 001003       306 001004       314 001006       319 001022       324 001030
    326 001035       328 001042       329 001054       330 001063       333 001065       336 001074       338 001077
    339 001116       340 001127       341 001133       344 001136       348 001142       354 001144       355 001150
    360 001171       362 001174       364 001202       365 001204       367 001205


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
