	COMPILATION LISTING OF SEGMENT memo
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 01/23/89  1227.9 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1989                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(86-07-11,Rauschelbach), approve(86-07-11,MCR7450),
       15*     audit(86-08-05,GJohnson), install(86-08-08,MR12.0-1122):
       16*     Changed argument processing to accept short name -dft for -default.
       17*  2) change(86-07-15,Rauschelbach), approve(86-07-15,MCR7472),
       18*     audit(86-08-05,GJohnson), install(86-08-08,MR12.0-1122):
       19*     Write access checking and error handling were changed to fix an endless
       20*     loop.  Argument processing was changed to handle null or zero secondary
       21*     arguments.  The expiration_string variable was changed to a based type to
       22*     accomodate long date strings. Changed default location of memo segment to
       23*     user_info_$homedir, as is documented instead of
       24*     static_project>static_person. Non error messages were changed to use ioa_
       25*     instead of com_err_. Moved and added initialized of variables to
       26*     initialize_memo.
       27*  3) change(86-08-25,Lippard), approve(86-07-15,PBF7472),
       28*     audit(86-09-10,GWMay), install(86-09-11,MR12.0-1152):
       29*     Fix bug with checking write access.
       30*  4) change(88-09-20,Flegel), approve(88-12-07,MCR8021), audit(88-12-14,Lee),
       31*     install(89-01-23,MR12.3-1010):
       32*     phx21142 - included "-match" in the option_count calculation so that an
       33*                     action_arg is required.
       34*                                                   END HISTORY COMMENTS */
       35 
       36 
       37 memo: procedure () options (variable);
       38 
       39 /* *	This is a command procedure for maintaining a list of memos, with differing maturity dates,
       40*   *	and various options for processing.
       41*   *
       42*   *	Completely rewritten, June, 1979, W. Olin Sibert
       43*   *      Changed iox_$order to iox_$control, 2/12/82 R. Holmstedt
       44*   */
       45 
       46 dcl  code fixed bin (35);
       47 dcl  nargs fixed bin;           /* Moved out of process_args to global 				*/
       48 dcl  rsp pointer;
       49 dcl  rsl fixed bin (21);
       50 dcl  rs char (rsl) varying based (rsp);
       51 dcl  P_arg_list ptr;        /* for use with the new argument routine cu_$arg_ptr_rel 			*/
       52 dcl  P_expiration_string ptr;        /* pointer for based expiration_string				*/
       53 dcl  L_expiration_string fixed bin (21);    /* length for based expiration_string			*/
       54 dcl  complain entry variable options (variable);
       55 
       56 dcl  temp1 fixed bin;
       57 dcl  idx fixed bin;
       58 dcl  temp_date fixed bin (71);
       59 dcl (month_value, day_of_month, year_value) fixed bin;
       60 dcl  zone_value char (3) aligned;
       61 dcl  fs_mode fixed bin (5);
       62 
       63 
       64 dcl (list_sw, print_sw, delete_sw, postpone_sw) bit (1) aligned;
       65 dcl (set_memo_sw, set_pathname_sw) bit (1) aligned;
       66 dcl (alarm_sw, invisible_sw, call_sw, per_process_sw, repeat_sw,
       67      expires_sw, remains_sw, single_sw, repeat_count_sw) bit (1) aligned;
       68 dcl (mature_sw, immature_sw) bit (1) aligned;
       69 dcl (turn_timer_on_sw, turn_timer_off_sw) bit (1) aligned;
       70 dcl  status_sw bit (1) aligned;
       71 dcl (brief_sw, totals_sw, force_sw) bit (1) aligned;
       72 dcl  process_memos_sw bit (1) aligned;
       73 dcl  select_options_specified_sw bit (1) aligned;
       74 dcl  af_sw bit (1) aligned;
       75 dcl  memo_segment_modified bit (1) aligned;		/* set if we do something likely to change the bitcount */
       76 dcl (have_read_access, have_write_access) bit (1) aligned;
       77 dcl  complained bit (1) aligned init("0"b);                 /* set if we gave a benign complaint		*/
       78       
       79 dcl  default_memo_directory char (64) internal static init("");
       80 dcl  time_now fixed bin (71);
       81 dcl  memo_time_now fixed bin (35);
       82 
       83 dcl 1 term_switch aligned like terminate_file_switches;      /* switches for terminate_file_ functions	*/
       84 dcl 1 arg_flags aligned like memo_segment_entry.flags;
       85 dcl 1 set_flags aligned like memo_segment_entry.flags;
       86 dcl 1 select_flags aligned like memo_segment_entry.flags;
       87 
       88 dcl  maturity_time fixed bin (71);
       89 dcl (from_time, to_time) fixed bin (71);
       90 dcl  postpone_time fixed bin (71);
       91 dcl  repeat_string char (32);
       92 dcl  repeat_count fixed bin;
       93 dcl  expiration_string char (L_expiration_string) based (P_expiration_string); /* based to accomodate very long expiration time descriptions */
       94 dcl  expiration_time fixed bin (71);
       95 dcl  expiration_delta fixed bin (35);
       96 
       97 dcl  memo_text char (132) varying;			/* text of memo to set */
       98 
       99 dcl  dname char (168);
      100 dcl  ename char (32);
      101 
      102 dcl  n_match_strings fixed bin;			/* number of slots actually used in the array */
      103 dcl  match_string (40) char (32) varying;		/* strings to match against memo text */
      104 dcl  n_memo_numbers fixed bin;			/* number of slots used in array */
      105 dcl 1 memo_number (200) aligned,			/* ranges of memo numbers to list/print/delete/postpone */
      106     2 start fixed bin (17) unaligned,
      107     2 finish fixed bin (17) unaligned;
      108 dcl  n_class_names fixed bin;				/* number of class names specified */
      109 dcl  class_name (20) char (32);			/* and the array containing their names */
      110 
      111 dcl  memo_match_count fixed bin;
      112 
      113 dcl  memo_bits (MAX_NUMBER_MEMOS) bit (1) unaligned;
      114 
      115 dcl  static_initialized bit (1) aligned internal static init ("0"b); 
      116                                                             /* initialized flag */
      117 dcl  static_pointer pointer internal static init (null ()); /* static pointer to default memo segment */
      118 dcl  static_dname char (168) internal static init ("");	/* pathname of default memo segment */
      119 dcl  static_ename char (32) internal static init ("");	/* pathname of default memo segment */
      120 dcl  static_uid bit (36) aligned internal static init (""b); /* static UID of segment, for validity checking */
      121 dcl  memo_timers_enabled bit (1) aligned internal static init ("0"b);
      122 dcl  memo_invocation_count fixed bin internal static init (0);
      123 dcl  end_of_time fixed bin (71) internal static init (-1);
      124 dcl  end_of_memo_time fixed bin (35) internal static init (-1);
      125 dcl  static_person char (32) varying internal static init ("");
      126 dcl  static_project char (32) varying internal static init ("");
      127 
      128 
      129 dcl  active_fnc_err_ entry options (variable);
      130 dcl  com_err_ entry options (variable);
      131 dcl  command_query_$yes_no entry options (variable);
      132 dcl  convert_date_to_binary_ entry (char (*), fixed bin (71), fixed bin (35));
      133 dcl  convert_date_to_binary_$relative entry (char (*), fixed bin (71), fixed bin (71), fixed bin (35));
      134 dcl  cu_$arg_list_ptr entry (ptr);
      135 dcl  cu_$af_return_arg_rel entry (fixed bin, ptr, fixed bin(21), fixed bin(35), ptr);
      136 dcl  cu_$arg_ptr_rel entry (fixed bin, ptr, fixed bin(21), fixed bin(35), ptr);
      137 dcl  decode_clock_value_ entry (fixed bin (71), fixed bin, fixed bin, fixed bin,
      138      fixed bin (71), fixed bin, char (3) aligned);
      139 dcl  encode_clock_value_ entry (fixed bin, fixed bin, fixed bin, fixed bin, fixed bin, fixed bin,
      140      fixed bin (71), fixed bin, char (3) aligned, fixed bin (71), fixed bin (35));
      141 dcl  expand_pathname_$add_suffix entry (char (*), char (*), char (*), char (*), fixed bin (35));
      142 dcl  hcs_$fs_get_mode entry (pointer, fixed bin (5), fixed bin (35));
      143 dcl  hcs_$get_uid_seg entry (pointer, bit (36) aligned, fixed bin (35));
      144 dcl  hcs_$initiate_count entry (char (*), char (*), char (*), fixed bin (24), fixed bin (2), pointer, fixed bin (35));
      145 dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), pointer, fixed bin (35));
      146 dcl  hcs_$set_bc_seg entry (pointer, fixed bin (24), fixed bin (35));
      147 dcl  ioa_ entry options (variable);
      148 dcl  ioa_$ioa_switch entry options (variable);
      149 dcl  iox_$control entry (ptr, char(*), ptr, fixed bin(35));
      150 dcl  memo_delete_ entry (pointer, fixed bin, bit (1) aligned);
      151 dcl  memo_list_ entry (pointer, fixed bin, bit (*));
      152 dcl  memo_list_$format_time entry (fixed bin (71)) returns (char (40) varying);
      153 dcl  memo_process_memos_ entry (pointer, (*) bit (1) unaligned, fixed bin (35), bit(1) aligned);
      154 dcl  memo_set_ entry (pointer, char (*), bit (36) aligned, fixed bin (35), fixed bin (35), char (*)) returns (fixed bin);
      155 dcl  memo_timer_set_ entry (pointer, entry);
      156 dcl  memo_upgrade_memo_segment_ entry (pointer);
      157 dcl  memo_util_$end_of_time entry () returns (fixed bin (71));
      158 dcl  timer_manager_$reset_alarm_call entry (entry);
      159 dcl  terminate_file_ entry (ptr, fixed bin(24), bit(*), fixed bin(35));
      160 dcl  user_info_ entry (char (*), char (*), char (*));
      161 dcl  user_info_$homedir entry (char (*));
      162      
      163 dcl  iox_$user_io pointer external static;
      164 dcl  iox_$error_output pointer external static;
      165 dcl  sys_info$time_correction_constant fixed bin (71) external static;
      166 
      167 dcl (error_table_$badopt,
      168      error_table_$bad_conversion,
      169      error_table_$inconsistent,
      170      error_table_$noarg,
      171      error_table_$noentry,
      172      error_table_$no_r_permission,     
      173      error_table_$no_w_permission,
      174      error_table_$not_act_fnc) fixed bin (35) external static;
      175 
      176 dcl  SPACE char (1) aligned init (" ") internal static options (constant);
      177 dcl  WHOAMI char (32) internal static options (constant) init ("memo");
      178 
      179 dcl  (cleanup, conversion, size) condition;
      180 
      181 dcl (null, substr, length, maxlength, binary, min, divide, multiply, ltrim, rtrim, convert, char, clock, hbound, index, string, verify) builtin;
      182 
      183 
      184 
      185 
      186 	call initialize_memo ();			/* set things up */
      187 
      188 	memo_segment_modified = "0"b;
      189 
      190 	on condition (cleanup) call clean_things_up ();	/* set up to restart the timers */
      191 
      192 	memo_invocation_count = memo_invocation_count + 1; /* Remember that there is an active invocation */
      193           call cu_$arg_list_ptr (P_arg_list);
      194 	
      195 	call process_args ();			/* find out about our arguments */
      196 
      197 	if dname = "" then do;			/* no pathname explicitly specified, use default. */
      198 	     call get_default_memo_seg ();
      199 	     memo_segment_ptr = static_pointer;		/* set our pointer */
      200 	     end;
      201 
      202 	else if set_pathname_sw then do;		/* otherwise, perhaps set it in static */
      203 	     static_pointer = null ();		/* new memo seg */
      204 	     static_dname = dname;
      205 	     static_ename = ename;
      206 	     static_uid = ""b;
      207 
      208 	     call get_default_memo_seg ();		/* get the new default one */
      209 	     memo_segment_ptr = static_pointer;
      210 	     end;
      211 
      212 	else do;					/* otherwise, just use it for now */
      213 	     call hcs_$initiate_count (dname, ename, "", 0, 0, memo_segment_ptr, code);
      214 	     if memo_segment_ptr = null () then do;
      215 		call complain (code, WHOAMI,"^/memo segment ^a>^a does not exist.", dname, ename);
      216 		complained = "1"b;
      217 		goto MAIN_RETURN;
      218 		end;
      219 
      220                /* handling for this temporarily known memo segment must be handled seperately */
      221                call hcs_$fs_get_mode (memo_segment_ptr, fs_mode, code); /* now, see if we have access */
      222 	     if code ^= 0 then do;			/* seems unlikely */
      223 	        call complain (code, WHOAMI, "^a>^a", dname, ename);
      224 	        complained = "1"b;
      225          	        goto MAIN_RETURN;
      226 	        end;
      227           
      228 	     if fs_mode = (R_ACCESS_BIN + W_ACCESS_BIN) | fs_mode = (R_ACCESS_BIN + E_ACCESS_BIN + W_ACCESS_BIN) then
      229 	        have_write_access, have_read_access = "1"b;
      230 	     else if fs_mode = R_ACCESS_BIN | fs_mode = (R_ACCESS_BIN + E_ACCESS_BIN) then
      231 	        have_read_access = "1"b;
      232 
      233 	     if ^have_read_access then do;			/* sorry, can't do anything at all with it */
      234 	        call complain (error_table_$no_r_permission, WHOAMI,
      235 "^/memo segment: ^a>^a", dname, ename);
      236                   complained = "1"b;
      237 	        goto MAIN_RETURN;
      238                   end;
      239 
      240                if memo_segment.version ^= MEMO_SEGMENT_VERSION_3 then do;
      241 		call complain (0, WHOAMI, "Memo segment ^a>^a is not compatible with current version of memo.",
      242 		     dname, ename);
      243 		complained = "1"b;
      244 		goto MAIN_RETURN;
      245 		end;
      246 	     end;					/* of getting memo segment pointer */
      247 
      248 
      249 
      250 	if status_sw then do;			/* report status of default memo segment */
      251 	     call ioa_ ("Default memo segment is ^[^a>^a (^p), UID = ^w^;<<Unset>>^]",
      252 		(static_pointer ^= null ()), static_dname, static_ename, static_pointer, static_uid);
      253 	     if static_pointer ^= null () then
      254 		call ioa_ ("Default memo segment is version ^d, ^d slots max used.",
      255 		     static_pointer -> memo_segment.version, static_pointer -> memo_segment.max_number_used);
      256 
      257 	     call ioa_ ("Memo timers are ^[en^;dis^]abled.", memo_timers_enabled);
      258 	     complained = "1"b;
      259 	     goto MAIN_RETURN;			/* all done, since we know -status was only operation */
      260 	     end;
      261 	  
      262 
      263 	if process_memos_sw then do;			/* select the memos, and process them. Selection defaults to */
      264 	     call select_memos ();			/* mature, nonalarm memos, if user did not specify otherwise */
      265 
      266 	     if memo_match_count > 0 then do;
      267 		memo_segment_modified = "1"b; 	/* assume this will modify it */
      268 		call memo_process_memos_ (memo_segment_ptr, memo_bits, memo_time_now, have_write_access);
      269 		end;
      270 
      271 	     else if ^brief_sw then			/* only print silly message if user wants it, of course */
      272 		call ioa_$ioa_switch (iox_$error_output, "No memos.");
      273 	     end; 				/* of case for no explicitly specified options */
      274 
      275 
      276 
      277 	else if print_sw then do;			/* print selected memos */
      278 	     call select_memos ();
      279 
      280 	     if memo_match_count = 0 then do;		/* nothing there */
      281 NO_MEMOS_SELECTED:	if ^brief_sw then call ioa_$ioa_switch (iox_$error_output, "No memos selected.");
      282 		complained = "1"b;
      283 		goto MAIN_RETURN;
      284 		end;
      285 
      286 	     do idx = 1 to memo_segment.max_number_used;
      287 		if memo_bits (idx) = "1"b then do;
      288 		     call ioa_ ("^3d)^2x^a", idx, memo_entry (idx).data);
      289 		     end;
      290 		end;				/* of loop through memos */
      291 	     end; 				/* of case for deletion */
      292 
      293 
      294 	else if list_sw then do;			/* produce formatted memo listing */
      295 	     call select_memos ();
      296 
      297 	     if (memo_match_count = 0) & ^af_sw then	/* nothing there */
      298 		goto NO_MEMOS_SELECTED;
      299 
      300 	     if totals_sw then do;			/* just print (or return) total count */
      301 		if af_sw then rs = ltrim (char (memo_match_count));
      302 		else call ioa_ ("^d memos selected.", memo_match_count);
      303 		end;
      304 
      305 	     else do idx = 1 to memo_segment.max_number_used;
      306 		if memo_bits (idx) = "1"b then do;
      307 		     if af_sw then do;		/* list as an AF returns a list of memo numbers */
      308 			if length (rs) > 0 then rs = rs || " "; /* separated, natch, by spaces */
      309 			rs = rs || ltrim (char (idx));
      310 			end;			/* of AF case */
      311 		     else call memo_list_ (memo_segment_ptr, idx, ""b);
      312 		     end;
      313 		end;				/* of loop through memos */
      314 	     end; 				/* of case for listing */
      315 
      316 
      317 
      318 
      319 	else if delete_sw then do;			/* delete selected memos */
      320 	     call select_memos ();			/* find out about the ones to delete */
      321 
      322 	     if memo_match_count = 0 then goto NO_MEMOS_SELECTED; /* nothing there */
      323 
      324 	     if ^have_write_access then do;
      325 		call complain (0, WHOAMI, "Must have w access to ^a>^a to delete memos.", dname, ename);
      326 		goto MAIN_RETURN;
      327 		end;
      328 
      329 	     memo_segment_modified = "1"b;		/* remember that it has been modified */
      330 
      331 	     do idx = 1 to memo_segment.max_number_used;	/* loop through them all */
      332 		if memo_bits (idx) = "1"b then do;	/* this one was selected */
      333 		     call memo_delete_ (memo_segment_ptr, idx, force_sw);
      334 		     end;
      335 		end;				/* of loop through memos */
      336 	     end; 				/* of case for deletion */
      337 
      338 
      339 	else if postpone_sw then do;			/* postpone some until later */
      340 	     call select_memos ();
      341 
      342 	     if memo_match_count = 0 then goto NO_MEMOS_SELECTED; /* nothing there */
      343 
      344 	     if ^have_write_access then do;
      345 		call complain (0, WHOAMI, "Must have w access to ^a>^a to postpone memos.", dname, ename);
      346 		goto MAIN_RETURN;
      347 		end;
      348 
      349 	     memo_segment_modified = "1"b;		/* remember that it has been modified */
      350 
      351 	     do idx = 1 to memo_segment.max_number_used;
      352 		if memo_bits (idx) = "1"b then do;
      353 		     memo_entry (idx).time = from_gmt (postpone_time);
      354 		     end;
      355 		end;
      356 	     end; 				/* of case for postponement */
      357 
      358 
      359 
      360 	else if set_memo_sw then do;			/* we are to set one */
      361 	     set_flags = arg_flags;			/* copy flags from whatever was specified earlier */
      362 	     set_flags.print = "1"b;
      363 
      364 	     if call_sw then do;
      365 		set_flags.execute = "1"b;
      366 		set_flags.print = "0"b;
      367 		end;
      368 
      369 	     if invisible_sw then maturity_time = end_of_time; /* kludgy way of indicating invisibility */
      370 
      371 	     if maturity_time = -1 then maturity_time = time_now;
      372 
      373 	     if expires_sw then do;			/* must calculate "expiration delta" here, since there isn't */
      374 		call convert_date_to_binary_$relative	/* room to store the actual string. Thus, values like "1month" */
      375 		     (expiration_string, expiration_time, maturity_time, code); /* may behave strangely */
      376 
      377 		if code ^= 0 then do;
      378 		     call complain (code, WHOAMI, "Expiration time ^a. Memo not set.", expiration_string);
      379 		     complained = "1"b;
      380 		     goto MAIN_RETURN;
      381 		     end;
      382 
      383 		if expiration_time <= maturity_time then do; /* can't expire before set, dummy. */
      384 		     call complain (0, WHOAMI, "Expiration time ^a happens before maturity (^a). Memo not set.",
      385 			expiration_string, memo_list_$format_time (maturity_time));
      386 		     complained = "1"b;
      387 		     goto MAIN_RETURN;
      388 		     end;
      389 
      390 		expiration_delta = divide ((expiration_time - maturity_time), 1000000, 35, 0); /* change to seconds */
      391 		end;
      392 
      393 	     else expiration_delta = 0;		/* otherwise, doesn't expire */
      394 
      395 	     if ^have_write_access then do;
      396 		call complain (0, WHOAMI, "Must have w access to ^a>^a to set a memo. Memo not set.", dname, ename);
      397 		goto MAIN_RETURN;
      398 		end;
      399 
      400 	     memo_segment_modified = "1"b;
      401 
      402 	     temp1 = memo_set_ (memo_segment_ptr, (memo_text), string (arg_flags),
      403 		from_gmt (maturity_time), expiration_delta, repeat_string);
      404 
      405 	     if af_sw then rs = ltrim (char (temp1));	/* return index of memo which just got set */
      406 	     end;					/* of case for setting a memo */
      407 
      408 
      409 
      410 	if turn_timer_off_sw then			/* now, turn timers on and off, and set them */
      411 	     memo_timers_enabled = "0"b;
      412 	if turn_timer_on_sw then
      413 	     memo_timers_enabled = "1"b;
      414 
      415 MAIN_RETURN:					/* all done here */
      416 	call clean_things_up ();			/* turn timers on & clean up, if necessary */
      417 
      418 	return;
      419 
      420 
      421 
      422 
      423 memo$alarm_entry: entry ();
      424 
      425 /* *	This entry is invoked by the alarm timer which goes off to make alarm memos work */
      426 
      427 	call initialize_memo ();
      428 
      429 	complain = com_err_;    /* moved in front of on unit to avoid window				*/
      430 
      431           call hcs_$fs_get_mode (static_pointer, fs_mode, code); /* now, see if we have access */
      432 	if code ^= 0 then do;			/* seems unlikely */
      433 	   call complain (code, WHOAMI, "^a>^a", dname, ename);
      434          	   return;
      435 	   end;
      436           
      437 	if fs_mode = (R_ACCESS_BIN + W_ACCESS_BIN) | fs_mode = (R_ACCESS_BIN + E_ACCESS_BIN + W_ACCESS_BIN) then
      438 	   have_write_access = "1"b;
      439 
      440 	on condition (cleanup) call clean_things_up ();	/* turn timers back on, etc. */
      441 
      442 	memo_invocation_count = memo_invocation_count + 1;
      443 
      444 	memo_segment_ptr = static_pointer;
      445 	if memo_segment_ptr = null () then do;
      446 	     call complain (0, WHOAMI, "No memo segment is active. Please type ""memo"" to reset.");
      447 	     return;
      448 	     end;
      449 
      450 	call select_mature_memos ("1"b);		/* select all mature alarm memos */
      451 
      452 	if memo_match_count > 0 then do;
      453 	     memo_segment_modified = "1"b;		/* assume it will get modified */
      454 	     call memo_process_memos_ (memo_segment_ptr, memo_bits, memo_time_now, have_write_access);
      455 	     end;
      456 	else call complain (0, WHOAMI, "Warning: Alarm received with no memos mature.");
      457 
      458 	call iox_$control (iox_$user_io, "start", (null ()), (0));
      459 
      460 	call clean_things_up ();			/* exit in an orderly fashion */
      461 
      462 	return;					/* done with alarm_entry */
      463 
      464 
      465 
      466 select_all_memos: proc ();
      467 
      468 /* *	This procedure selects all existing memos. */
      469 
      470 dcl  idx fixed bin;
      471 
      472 	memo_match_count = 0;
      473 	string (memo_bits) = ""b;			/* start out with none */
      474 
      475 	do idx = 1 to memo_segment.max_number_used;
      476 	     if memo_entry (idx).taken ^= ""b then do;
      477 		memo_match_count = memo_match_count + 1;
      478 		memo_bits (idx) = "1"b;
      479 		end;
      480 	     end;					/* of loop through memos */
      481 
      482 	return;
      483 	end select_all_memos;
      484        
      485 
      486 
      487 select_mature_memos: proc (P_alarm);
      488 
      489 /* *	This procedure selects all the mature memos which are either alarm or non-alarm */
      490 
      491 dcl  P_alarm bit (1) aligned;
      492 
      493 dcl  idx fixed bin;
      494 
      495 	memo_match_count = 0;
      496 	string (memo_bits) = ""b;			/* start out with none */
      497 
      498 	do idx = 1 to memo_segment.max_number_used;
      499 	     if memo_entry (idx).taken ^= ""b then
      500 		if memo_entry (idx).flags.alarm = P_alarm then /* perform filtering on alarmedness */
      501 		     if memo_entry (idx).time <= memo_time_now then do; /* got one */
      502 			memo_match_count = memo_match_count + 1;
      503 			memo_bits (idx) = "1"b;
      504 			end;
      505 	     end;					/* of loop through memos */
      506 
      507 	return;
      508 	end select_mature_memos;
      509        
      510 
      511 
      512 select_memos: proc () options (non_quick);
      513 
      514 /* *	This procedure sets bits in the memo_bits array to indicate which memos have been selected.
      515*   *	It has knowledge of the type of operation being performed; that is, it behaves differently
      516*   *	when printing, listing, deleting, or postponing. */
      517 
      518 dcl  string_match_bits (memo_segment.max_number_used) bit (1) unaligned;
      519 dcl  range_match_bits (memo_segment.max_number_used) bit (1) unaligned;
      520 dcl  type_match_bits (memo_segment.max_number_used) bit (1) unaligned;
      521 dcl  range_match_count (n_memo_numbers) fixed bin;
      522 
      523 dcl  total_string_match_count fixed bin;
      524 dcl (idx, jdx) fixed bin;
      525 dcl  matched bit (1) aligned;
      526 dcl (start, finish) fixed bin;
      527 
      528 
      529 	string (string_match_bits) = ""b;		/* start out with none */
      530 	string (range_match_bits) = ""b;
      531 	string (type_match_bits) = ""b;
      532 	range_match_count (*) = 0;
      533 
      534 	if delete_sw | postpone_sw then do;		/* special checking, since otherwise no args would mean "all" */
      535 	     if n_match_strings = 0 & n_memo_numbers = 0 then do; /* can't delete just "invisible", etc. memos, either. */
      536 		call complain (0, WHOAMI, "At least one memo specifier must be used for deletion or postponement.");
      537 		complained = "1"b;
      538 		goto MAIN_RETURN;
      539 		end;
      540 	     end;
      541 
      542 	if n_memo_numbers = 0 & n_match_strings = 0 & ^select_options_specified_sw then do;
      543 	     if print_sw | process_memos_sw then	/* mark only the mature ones, if -print or -process specified */
      544 		call select_mature_memos ("0"b);	/* select mature, non-alarm memos */
      545 	     else call select_all_memos ();		/* select all existing memos */
      546 	     return;
      547 	     end;
      548 
      549 	if n_match_strings > 0 then do;
      550 	     total_string_match_count = 0;
      551 	     do idx = 1 to memo_segment.max_number_used;	/* try to match against strings */
      552 		if memo_entry (idx).taken ^= ""b then do;
      553 		     do jdx = 1 to n_match_strings while (^string_match_bits (idx));
      554 			if index (memo_entry (idx).data, match_string (jdx)) > 0 then do;
      555 			     string_match_bits (idx) = "1"b;
      556 			     total_string_match_count = total_string_match_count + 1;
      557 			     end;
      558 			end;
      559 		     end;
      560 		end;
      561 	     end;
      562 
      563 	if n_memo_numbers > 0 then do;
      564 	     do idx = 1 to n_memo_numbers;		/* loop through all the ranges */
      565 		start = min (memo_segment.max_number_used + 1, memo_number (idx).start);
      566 		finish = min (memo_segment.max_number_used, memo_number (idx).finish);
      567 		do jdx = start to finish;
      568 		     if memo_entry (jdx).taken ^= ""b then do;
      569 			range_match_bits (jdx) = "1"b;
      570 			range_match_count (idx) = range_match_count (idx) + 1;
      571 			end;
      572 		     end;
      573 		end;
      574 	     end;
      575 
      576 	if select_options_specified_sw then do;		/* only select certain types of memos */
      577 	     select_flags = arg_flags;
      578 	     if ^invisible_sw & string (select_flags) = ""b then do; /* no explicitly specified options */
      579 		string (select_flags) = "777777777777"b3; /* turn them all on */
      580 		select_flags.pad1 = ""b;		/* except for the padding */
      581 		end;
      582 
      583 	     do idx = 1 to memo_segment.max_number_used;
      584 		if memo_entry (idx).taken ^= ""b then do;
      585 		     matched = "0"b;
      586 		     if (string (memo_entry (idx).flags) & string (select_flags)) ^= ""b then
      587 			matched = "1"b;		/* got it by selecting on flags */
      588 
      589 		     if from_time ^= -1 then do;	/* see if it's in the right time range */
      590 			matched = "1"b;
      591 			if memo_entry (idx).time >= end_of_memo_time then matched = "0"b; /* discard invisibles */
      592 			else if memo_entry (idx).time < from_gmt (from_time) then matched = "0"b;
      593 			else if memo_entry (idx).time > from_gmt (to_time) then matched = "0"b;
      594 			end;
      595 
      596 		     if invisible_sw then		/* kludge mechanism to select invisible memos because it's */
      597 			if memo_entry (idx).time >= end_of_memo_time then /* done by date, rather than having a flag */
      598 			     matched = "1"b;
      599 
      600 		     if string_match_bits (idx) then    /* phx21142 - another kludge to pass match strings */
      601 			matched = "1"b;		/* ... as a match is a select_option */
      602 
      603 		     type_match_bits (idx) = matched;
      604 		     end;
      605 		end;				/* of loop through memos */
      606 	     end;
      607 
      608 	if n_memo_numbers > 0 then do;		/* see if any of the numbers or ranges lost */
      609 	     do idx = 1 to n_memo_numbers;
      610 		if range_match_count (idx) = 0 then do; /* yup... */
      611 		     if memo_number (idx).start = memo_number (idx).finish then
      612 			call complain (0, WHOAMI, "No memos selected by specifier ^d.", memo_number (idx).start);
      613 		     else call complain (0, WHOAMI, "No memos selected by range ^d:^d.",
      614 			memo_number (idx).start, memo_number (idx).finish);
      615 		     complained = "1"b;
      616 		     goto MAIN_RETURN;
      617 		     end;
      618 		end;
      619 	     end;
      620 
      621 	if n_memo_numbers > 0 then do;
      622 	     string (memo_bits) = string (range_match_bits);
      623 	     if n_match_strings > 0 then
      624 		string (memo_bits) = string (memo_bits) & string (string_match_bits);
      625 	     if select_options_specified_sw then
      626 		string (memo_bits) = string (memo_bits) & string (type_match_bits);
      627 	     end;
      628 
      629 	else if n_match_strings > 0 then do;
      630 	     string (memo_bits) = string (string_match_bits);
      631 	     if select_options_specified_sw then
      632 		string (memo_bits) = string (memo_bits) & string (type_match_bits);
      633 	     end;
      634 
      635 	else string (memo_bits) = string (type_match_bits);
      636 
      637 	memo_match_count = 0;
      638 	do idx = 1 to memo_segment.max_number_used;	/* now count the total number of matches */
      639 	     if memo_bits (idx) = "1"b then
      640 		memo_match_count = memo_match_count + 1;
      641 	     end;
      642 
      643 	return;
      644 	end select_memos;
      645        
      646 
      647 
      648 process_args: proc ();
      649 
      650 /* *	This procedure processes command arguments for the memo command. */
      651 
      652 dcl  argno fixed bin;
      653 dcl (al, al1) fixed bin (21);
      654 dcl (ap, ap1) pointer;
      655 dcl  arg char (al) based (ap);
      656 dcl  arg1 char (al1) based (ap1);
      657 dcl (n1, n2, n3) fixed bin (35);
      658 dcl (collecting_memo_sw, collecting_numbers_sw) bit (1) aligned;
      659 dcl (action_count, real_action_count, option_count) fixed bin;
      660 dcl  might_set_sw bit (1) aligned;
      661 dcl  answer bit (1) aligned;
      662 dcl  repeat_time fixed bin (71);
      663 
      664 	    
      665 	    
      666 
      667 	call cu_$af_return_arg_rel (nargs, rsp, rsl, code, P_arg_list);
      668 	if code = 0 then do;
      669 	     af_sw = "1"b;
      670 	     complain = active_fnc_err_;
      671 	     rs = "";
      672 	     end;
      673 
      674 	else if code = error_table_$not_act_fnc then do;
      675 	     af_sw = "0"b;
      676 	     complain = com_err_;
      677 	     end;
      678 
      679 	else do;
      680 	     call com_err_ (code, WHOAMI);
      681 	     complained = "1"b;
      682 	     goto MAIN_RETURN;
      683 	     end;
      684 
      685 
      686 	might_set_sw = "1"b;			/* assume memo is gonna get set until we learn otherwise */
      687 	collecting_memo_sw = "0"b;			/* true as soon as we encounter first apparent memo text */
      688 	collecting_numbers_sw = "0"b;			/* true if we are collecting numbers, rather than text. */
      689 
      690 
      691 
      692 
      693 LOOP_THROUGH_ARGUMENTS:
      694 
      695 	do argno = 1 to nargs;
      696 	     call cu_$arg_ptr_rel (argno, ap, al, (0), P_arg_list);
      697 	     if list_sw | print_sw | postpone_sw | delete_sw | process_memos_sw then do;
      698 		might_set_sw = "0"b;
      699 		collecting_numbers_sw = "1"b;
      700 		end;
      701 
      702 	     if substr (arg, 1, 1) ^= "-" | collecting_memo_sw then do; /* not a control arg, see what to do */
      703 		if ^collecting_memo_sw & ^collecting_numbers_sw then /* if not numbers, time to start with text */
      704 		     collecting_memo_sw = "1"b;
      705 
      706 		if collecting_numbers_sw then do;	/* try it out as a number */
      707 		     might_set_sw = "0"b;		/* we're doing some sort of list/print/whatever, so no memo */
      708 		     n1 = verify (arg, "0123456789:");	/* is it a number or a range ? */
      709 		     if n1 ^= 0 then do;
      710 BAD_MEMO_NUMBER:		code = error_table_$bad_conversion;
      711 			call complain (code, WHOAMI,
      712 			     "Memo number must be a positive integer or a range, not ""^a"".", arg);
      713 			complained = "1"b;
      714 			goto MAIN_RETURN;
      715 			end;
      716 
      717 		     n1 = index (arg, ":");		/* get index of range delimiter */
      718 		     if n1 = 0 then do;		/* no colon, just a single integer */
      719 		          on conversion, size goto BAD_MEMO_NUMBER;
      720                               n2 = convert (n2, arg);
      721                               revert conversion, size;
      722 			n3 = n2;			/* range start and end are the same */
      723 			end;
      724 
      725 		     else do;			/* otherwise, it's a range */
      726 			if n1 = 1 | n1 = al then	/* colon at start or end */
      727 			     goto BAD_MEMO_NUMBER;
      728 
      729 			on conversion, size goto BAD_MEMO_NUMBER;
      730 			n2 = convert (n2, substr (arg, 1, n1 -1)); /* start of range */
      731 			n3 = convert (n3, substr (arg, n1 + 1));   /* end of range */
      732 			revert conversion, size;
      733 
      734 			if n3 < n2 then do;		/* can't list 12 through 10, y'know.... */
      735 			     call complain (0, WHOAMI,
      736 				"The upper bound of a range must be greater than the lower bound: ^a", arg);
      737 			     complained = "1"b;
      738 			     goto MAIN_RETURN;
      739 			     end;
      740 			end;
      741 
      742                          if n2 = 0 then do;     /* null second argument check */
      743 		        call complain (0, WHOAMI,
      744 "0 is not an acceptable memo number.");
      745                             complained = "1"b;
      746 		        goto MAIN_RETURN;
      747 		        end;
      748 
      749 		     if n_memo_numbers >= hbound (memo_number, 1) then do;
      750 			call complain (0, WHOAMI, "Too many memo numbers specified. Max is ^d.",
      751 			     hbound (memo_number, 1));
      752 			complained = "1"b;
      753 			goto MAIN_RETURN;
      754 			end;
      755 
      756 		     n_memo_numbers = n_memo_numbers + 1; /* remember this one in our list */
      757 		     memo_number (n_memo_numbers).start = n2;
      758 		     memo_number (n_memo_numbers).finish = n3;
      759 		     end;				/* of case for a number */
      760 
      761 		else if collecting_memo_sw then do;	/* otherwise, add it to the memo text string */
      762 		     if al + 1 + length (memo_text) > maxlength (memo_text) then do;
      763 			call complain (0, WHOAMI, "Memo text is too long. Max is ^d characters. Memo not set.",
      764 			     maxlength (memo_text));
      765 			complained = "1"b;
      766 			goto MAIN_RETURN;
      767 			end;
      768 
      769 		     if length (memo_text) > 0 then	/* add a space if not first word */
      770 			memo_text = memo_text || SPACE;
      771 		     memo_text = memo_text || arg;	/* and add the argument as well */
      772 		     might_set_sw = "1"b;		/* all further error messages should say Memo not set */
      773 		     set_memo_sw = "1"b;		/* we know we're supposed to set it, now */
      774 		     end;				/* of case for adding memo text */
      775 
      776 		end;				/* of case for non control argument */
      777 
      778 	     else if arg = "-memo" then do;		/* means next arg is memo text */
      779 		if collecting_numbers_sw then do;
      780 		     call complain (error_table_$inconsistent, WHOAMI,
      781 			"Memo setting (with -memo) may not be combined with any other operations. Memo not set.");
      782 		     complained = "1"b;
      783 		     goto MAIN_RETURN;
      784 		     end;
      785 
      786 		if argno = nargs then do;
      787 		     call complain (error_table_$noarg, WHOAMI, "Some memo text must follow -memo.^2xMemo not set.");
      788 		     complained = "1"b;
      789 		     goto MAIN_RETURN;
      790 		     end;
      791 
      792 		collecting_memo_sw = "1"b;
      793 		end;
      794 
      795 	     else if arg = "-brief" | arg = "-bf" then brief_sw = "1"b;
      796 	     else if arg = "-long" | arg = "-lg" then brief_sw = "0"b;
      797 	     else if arg = "-totals" | arg = "-total" | arg = "-tt" then totals_sw = "1"b;
      798 	     else if arg = "-on" then turn_timer_on_sw = "1"b;
      799 	     else if arg = "-off" then turn_timer_off_sw = "1"b;
      800 	     else if arg = "-force" | arg = "-fc" then force_sw = "1"b;
      801 	     else if arg = "-status" | arg = "-st" then status_sw = "1"b;
      802 
      803 	     else if arg = "-invisible" | arg = "-iv" then invisible_sw = "1"b;
      804 	     else if arg = "-alarm" | arg = "-al" then alarm_sw = "1"b;
      805 	     else if arg = "-call" then call_sw = "1"b;
      806 	     else if arg = "-repeat_when_processed" | arg = "-rwp" then per_process_sw = "1"b;
      807 	     else if arg = "-retain" | arg = "-ret" then remains_sw = "1"b;
      808 	     else if arg = "-no_retain" | arg = "-nret" then single_sw = "1"b;
      809 
      810 	     else if arg = "-postpone" | arg = "-pp" then do; /* postpone all the memos specified */
      811 		postpone_time = get_next_date_arg ();	/* get the date to postpone to */
      812 
      813 		collecting_numbers_sw = "1"b;		/* and get ready to collect memo numbers */
      814 		postpone_sw = "1"b;
      815 		end;
      816 
      817 	     else if arg = "-list" | arg = "-ls" then list_sw = "1"b;
      818 	     else if arg = "-print" | arg = "-pr" then print_sw = "1"b;
      819 	     else if arg = "-delete" | arg = "-dl" then delete_sw = "1"b;
      820 	     else if arg = "-process" then process_memos_sw = "1"b;
      821 
      822 	     else if arg = "-date" | arg = "-dt" then do; /* midnight of this particular date */
      823 		if maturity_time ^= -1 then do;	/* already have one */
      824 ALREADY_HAVE_DATE:	     call complain (0, WHOAMI,
      825 			"Only one value may be specified with -date or -time.^[^2xMemo not set.^]", might_set_sw);
      826 		     complained = "1"b;
      827 		     goto MAIN_RETURN;
      828 		     end;
      829 
      830 		maturity_time = get_next_date_arg ();
      831 
      832 		call decode_clock_value_ (maturity_time, month_value, day_of_month, year_value, (0), (0), zone_value);
      833 		call encode_clock_value_ (month_value,
      834 		     day_of_month, year_value, 0, 0, 0, 0, 0, zone_value, maturity_time, code);
      835 
      836 		if code ^= 0 then do;
      837 		     call complain (code, WHOAMI, "^a^[.^2xMemo not set.^]", arg, might_set_sw);
      838 		     complained = "1"b;
      839 		     goto MAIN_RETURN;
      840 		     end;
      841 		end;				/* of processing for -date */
      842 
      843 	     else if arg = "-time" | arg = "-tm" then do;
      844 		if maturity_time ^= -1 then goto ALREADY_HAVE_DATE;
      845 
      846 		maturity_time = get_next_date_arg ();
      847 		end;				/* of processing for -time */
      848 
      849 	     else if arg = "-from" | arg = "-fm" then do; /* list memos maturing at or after this time */
      850 		if from_time ^= -1 then do;		/* already have one */
      851 		     call complain (0, WHOAMI, "Only one value may be specified for -from.");
      852 		     complained = "1"b;
      853 		     goto MAIN_RETURN;
      854 		     end;
      855 
      856 		from_time = get_next_date_arg ();
      857 		end;				/* of processing for -from */
      858 
      859 	     else if arg = "-to" then do;		/* list memos maturing at or before this time */
      860 		if to_time ^= -1 then do;		/* already have one */
      861 		     call complain (0, WHOAMI, "Only one value may be specified for -to.");
      862 		     complained = "1"b;
      863 		     goto MAIN_RETURN;
      864 		     end;
      865 
      866 		to_time = get_next_date_arg ();
      867 		end;				/* of processing for -to */
      868 
      869 	     else if arg = "-repeat" | arg = "-rp" | arg = "-rpt" then do;
      870 		if repeat_sw then do;		/* we already have one */
      871 		     call complain (0, WHOAMI,
      872 			"Only one value may be specified for -repeat.^[^2xMemo not set.^]", might_set_sw);
      873 		     complained = "1"b;
      874 		     goto MAIN_RETURN;
      875 		     end;
      876 
      877 		repeat_sw = "1"b;			/* remember that we have a repeat specification */
      878 
      879 		if argno = nargs then		/* if last argument, and listing, printing, etc., */
      880 		     if list_sw | print_sw | postpone_sw | delete_sw then /* accept it as an option specification */
      881 			goto END_ARGUMENT_LOOP;
      882 
      883 		call get_next_string_arg ();		/* puts it in arg1 */
      884 
      885 		if al1 > maxlength (repeat_string) then do; /* too long */
      886 		     call complain (0, WHOAMI, "The repeat string may only be ^d characters.^[^2xMemo not set.^]",
      887 			maxlength (repeat_string), might_set_sw);
      888 		     complained = "1"b;
      889 		     goto MAIN_RETURN;
      890 		     end;
      891 
      892 		repeat_string = arg1;
      893 		end;				/* of processing for -repeat */
      894 
      895 
      896 	     else if arg = "-times" then do;		/* limit on how many times we can repeat */
      897 		if "1"b then goto BADOPT;		/* for now, it's unimplemented */
      898 		repeat_count_sw = "1"b;		/* remember that we have one */
      899 
      900 		if argno = nargs then		/* if last argument, and listing, printing, etc., */
      901 		     if list_sw | print_sw | postpone_sw | delete_sw then /* accept it as an option specification */
      902 			goto END_ARGUMENT_LOOP;
      903 
      904 		call get_next_string_arg ();		/* put it in arg1 */
      905 
      906 		on conversion, size goto BAD_CONVERSION;
      907 		repeat_count = convert (repeat_count, arg1);
      908 		revert conversion, size;
      909 
      910 		if repeat_count < 1 then goto BAD_REPEAT_COUNT; /* must be positive, ninny (code will be zero) */
      911 		end;				/* of processing for -times */
      912 
      913 	     else if arg = "-expires" | arg = "-expire" | arg = "-exp" | arg = "-ex" then do;
      914 		if expires_sw then do;
      915 		     call complain (0, WHOAMI,
      916 			"Only one value may be specified for expiration time.^[^2xMemo not set.^], might_set_sw");
      917 		     complained = "1"b;
      918 		     goto MAIN_RETURN;
      919 		     end;
      920 
      921 		expires_sw = "1"b;			/* remember that we have an expiration specification */
      922 
      923 		if argno = nargs then		/* if last argument, and listing, printing, etc., */
      924 		     if list_sw | print_sw | postpone_sw | delete_sw then /* accept it as an option specification */
      925 			goto END_ARGUMENT_LOOP;
      926 
      927 		call get_next_string_arg ();		/* puts it in arg1 */
      928 
      929 		call convert_date_to_binary_ (arg1, temp_date, code);
      930 		if code ^= 0 then do;
      931 		     call complain (code, WHOAMI,
      932 			"^a must be followed by a valid time value not ""^a"".^[^2xMemo not set.^]",
      933 			arg, arg1, might_set_sw);
      934 		     complained = "1"b;
      935 		     goto MAIN_RETURN;
      936 		     end;
      937 
      938 		L_expiration_string = al1;
      939                     P_expiration_string = ap1;
      940 		end;				/* of processing for -expires */
      941 
      942 	     else if arg = "-class" then do;		/* memos in this class or classes */
      943 		if "1"b then goto BADOPT;		/* for now, it's unimplemented */
      944 		call get_next_string_arg ();		/* puts it in arg1 */
      945 
      946 		if al1 > maxlength (class_name (1)) then do; /* too long */
      947 		     call complain (0, WHOAMI, "A class name may only be ^d characters.", maxlength (class_name (1)));
      948 		     complained = "1"b;
      949 		     goto MAIN_RETURN;
      950 		     end;
      951 
      952 		if n_class_names >= hbound (class_name, 1) then do;
      953 		     call complain (0, WHOAMI, "Too many class names specified. Max is ^d.", hbound (class_name, 1));
      954 		     complained = "1"b;
      955 		     goto MAIN_RETURN;
      956 		     end;
      957 
      958 		n_class_names = n_class_names + 1;
      959 		class_name (n_class_names) = arg1;
      960 		end;				/* of processing for -class */
      961 
      962 	     else if arg = "-match" then do;		/* memos matching this string */
      963 		call get_next_string_arg ();		/* puts it in arg1 */
      964 
      965 		if al1 > maxlength (match_string (1)) then do; /* too long */
      966 		     call complain (0, WHOAMI, "The match string may only be ^d characters.",
      967 			maxlength (match_string (1)));
      968 		     complained = "1"b;
      969 		     goto MAIN_RETURN;
      970 		     end;
      971 
      972 		if n_match_strings >= hbound (match_string, 1) then do;
      973 		     call complain (0, WHOAMI, "Too many match strings specified. Max is ^d.", hbound (match_string, 1));
      974 		     complained = "1"b;
      975 		     goto MAIN_RETURN;
      976 		     end;
      977 
      978 		n_match_strings = n_match_strings + 1;
      979 		match_string (n_match_strings) = arg1;
      980 		end;				/* of processing for -match */
      981 
      982 	     else if arg = "-path_name" | arg = "-pathname" | arg = "-path" | arg = "-pn" then do;
      983 		if dname ^= "" then do;		/* already have one */
      984 		     call complain (0, WHOAMI, "Only one pathname may be specified.^[^2xMemo not set.^]", might_set_sw);
      985 		     complained = "1"b;
      986 		     goto MAIN_RETURN;
      987 		     end;
      988 
      989 		call get_next_string_arg ();		/* puts it in arg1 */
      990 
      991 		if arg1 = "-default" | arg1 = "-dft" then do; /* construct default pathname */
      992 		     call user_info_$homedir (dname);
      993 		     ename = static_person || ".memo";
      994 		     end;
      995 
      996 		else do;				/* otherwise, a real pathname */
      997 		     call expand_pathname_$add_suffix (arg1, "memo", dname, ename, code);
      998 		     if code ^= 0 then do;
      999 			call complain (code, WHOAMI, "^a^[.^2xMemo not set.^]", arg1, might_set_sw);
     1000 			complained = "1"b;
     1001 			goto MAIN_RETURN;
     1002 			end;
     1003 		     end;
     1004 		end;				/* of processing for -pathname */
     1005 
     1006 	     else do;				/* not one of ours, Jack. */
     1007 BADOPT:		call complain (error_table_$badopt, WHOAMI, "^a^[.^2xMemo not set.^]", arg, might_set_sw);
     1008 		complained = "1"b;
     1009 		goto MAIN_RETURN;
     1010 		end;
     1011 
     1012 END_ARGUMENT_LOOP:
     1013 end LOOP_THROUGH_ARGUMENTS;
     1014 	  
     1015 
     1016 
     1017 
     1018 	if (^set_memo_sw) & (maturity_time > 0) & (to_time = -1) & (from_time = -1) then do;
     1019 	     to_time = maturity_time; 		/* Kludge to make memo -print -time 2359.9 work like it */
     1020 	     maturity_time = -1;			/* used to work. */
     1021 	     end;
     1022 
     1023 	if to_time > 0 & from_time = -1 then		/* to without from, list all from beginning */
     1024 	     from_time = 0;
     1025 
     1026 	if from_time > 0 & to_time = -1 then		/* from without to, list all until the end of time */
     1027 	     to_time = end_of_time;
     1028 
     1029 	action_count = binary (set_memo_sw, 1)
     1030 	     + binary (process_memos_sw, 1)
     1031 	     + binary (postpone_sw, 1)
     1032 	     + binary (delete_sw, 1)
     1033 	     + binary (list_sw, 1)
     1034 	     + binary (print_sw, 1);
     1035 
     1036 	string (arg_flags) = ""b;			/* copy the flags into a copy of the structure */
     1037 	arg_flags.repeatsw = repeat_sw;
     1038 	arg_flags.single = single_sw;
     1039 	arg_flags.remains = remains_sw;
     1040 	arg_flags.expires = expires_sw;
     1041 	arg_flags.execute = call_sw;
     1042 	arg_flags.alarm = alarm_sw;
     1043 	arg_flags.per_process = per_process_sw;
     1044 
     1045 	option_count = binary (invisible_sw, 1)		/* whether any memo options were specified */
     1046 	     + binary ((string (arg_flags) ^= ""b), 1)	/* assorted options here */
     1047 	     + binary (mature_sw, 1)
     1048 	     + binary (immature_sw, 1)
     1049 	     + binary ((maturity_time ^= -1), 1)
     1050 	     + binary ((repeat_count ^= -1), 1)
     1051 	     + binary ((from_time ^= -1), 1)
     1052 	     + binary ((n_match_strings ^= 0), 1);	/* MF - phx21142 - -match needs to be included */
     1053 
     1054 	select_options_specified_sw = (option_count > 0); /* flag for use in select_memos */
     1055 
     1056 /* *	Now check for various illegal combinations. An example is provided for most of these,
     1057*   *	which illustrates the type of error that might cause the illegal combination. */
     1058 
     1059 	if turn_timer_on_sw & turn_timer_off_sw then	/* memo -on -off */
     1060 	     call inconsistent ("-on and -off.");
     1061 
     1062 	real_action_count = action_count;		/* to detect those options which may be combined */
     1063 
     1064 	if action_count = 0 & (turn_timer_on_sw | turn_timer_off_sw) then do; /* allow timer to be turned on and off */
     1065 	     if option_count > 0 then			/* along with other actions, as well as alone */
     1066 		call inconsistent ("No memo options may be specified when turning the timers on and off.");
     1067 	     real_action_count = 1;			/* memo -invisible -off */
     1068 	     end;
     1069 
     1070 	if action_count = 0 & dname ^= "" then do;	/* memo -invisible -pathname >frobboz */
     1071 	     if option_count > 0 then
     1072 		call inconsistent ("No memo options may be specified when setting the default pathname.");
     1073 	     set_pathname_sw = "1"b;			/* we are to set the static pathname */
     1074 	     memo_timers_enabled = "0"b;		/* turn this off, so switching segs won't blow us out */
     1075 	     real_action_count = 1;			/* turn it into an "action", so succeeding tests will work */
     1076 	     end;
     1077 
     1078 	if real_action_count = 0 & option_count = 0 then do; /* if no other options specified, we're just to process */
     1079 	     turn_timer_on_sw = "1"b;		/* mature memos and turn on the timers */
     1080 	     process_memos_sw = "1"b;			/* so indicate that */
     1081 	     end;
     1082 
     1083 	else if real_action_count = 0 then do;		/* nothing specified */
     1084 	     call complain (error_table_$noarg, WHOAMI,	/* memo -invisible */
     1085 		"Some action must be specified when memo options are specified.^2xMemo not set.");
     1086 	     complained = "1"b;
     1087 	     goto MAIN_RETURN;
     1088 	     end;					/* of case for no explicit actions */
     1089 
     1090 	if repeat_sw then do;			/* check the repeat time for validity */
     1091 	     call convert_date_to_binary_$relative (repeat_string, repeat_time, time_now, code);
     1092 	     if code ^= 0 then do;
     1093 		call complain (code, WHOAMI,
     1094 		     "-repeat must be followed by a valid time offset, not ""^a"".^[^2xMemo not set.^]",
     1095 		     repeat_string, set_memo_sw);
     1096 		complained = "1"b;
     1097 		goto MAIN_RETURN;
     1098 		end;
     1099 
     1100 	     if repeat_time <= time_now then do;
     1101 		call complain (0, WHOAMI, "The repeat string ^a yields a time in the past.^[^2xMemo not set.^]",
     1102 		     repeat_string, set_memo_sw);
     1103 		complained = "1"b;
     1104 		goto MAIN_RETURN;
     1105 		end;
     1106 
     1107 	     if set_memo_sw & ^force_sw & ((repeat_time - time_now) < (60 * 1000000)) then do; /* allow forcing */
     1108 						/* if setting a memo, not supposed to say -repeat 1second */
     1109 		call command_query_$yes_no (answer, 0, WHOAMI, "", /* but give the user a chance anyway */
     1110 		     "The repeat interval ^a is less than one minute. Do you still wish to use it?", repeat_string);
     1111 		if answer = "0"b then do;
     1112 		     call complain (0, WHOAMI, "Memo not set.");
     1113 		     complained = "1"b;
     1114 		     goto MAIN_RETURN;
     1115 		     end;
     1116 		end;
     1117 	     end; 				/* of testing for -repeat */
     1118 
     1119 
     1120 
     1121 	if action_count > 1 then call inconsistent	/* memo -delete -print */
     1122 	     ("Only one action (printing, listing, deletion, postponement or memo setting) may be specified.");
     1123 
     1124 	if force_sw & ^(delete_sw | postpone_sw | set_memo_sw) then /* memo -force -list */
     1125 	     call inconsistent ("-force may only be specified with -delete or -postpone.");
     1126 
     1127 	if set_memo_sw & (from_time ^= -1 | mature_sw | immature_sw) then
     1128 	     call inconsistent			/* memo -from 3days Shoot first, ask questions later. */
     1129 		("The -from, -to, -mature and -immature control arguments may not be combined with memo setting.");
     1130 
     1131 	if af_sw & ^(set_memo_sw | list_sw) then	/* ps [memo -delete 10] */
     1132 	     call inconsistent ("Only memo setting and listing are allowed as an active function.");
     1133 
     1134 	if (from_time ^= -1) & (maturity_time ^= -1) then /* memo -ls -date Monday -from Tuesday */
     1135 	     call inconsistent ("The -from and -to arguments may not be combined with -date or -time.");
     1136 
     1137 	if set_memo_sw & ^alarm_sw & remains_sw then	/* memo -remains Buy new aardvark leash. */
     1138 	     call inconsistent ("-remains may only be used when setting an alarm memo.");
     1139 
     1140 	if set_memo_sw & ^repeat_sw & per_process_sw then /* memo -per_process Check for elephants in the basement. */
     1141 	     call inconsistent ("-repeat_when_processed may only be used when setting a repeating memo.");
     1142 
     1143 	if set_memo_sw & brief_sw then		/* memo -brief Buy 3 cans of frog propellant tomorrow! */
     1144 	     call inconsistent ("-brief not allowed when setting a memo.");
     1145 
     1146 	if set_memo_sw & (n_memo_numbers > 0 | n_match_strings > 0) then /* memo -match EGGs Win 20 free dance lessons */
     1147 	     call inconsistent ("No memo numbers or match strings may be specified when setting a memo.");
     1148 
     1149 	if set_memo_sw & (n_class_names > 1) then	/* memo -class C1 -class C2 This is a ring 1 multi-class memo */
     1150 	     call inconsistent ("At most one memo class may be specified when setting a memo.");
     1151 
     1152 	if status_sw & nargs > 1 then 		/* This is cheating, but I really want it only for debugging */
     1153 	     call inconsistent ("-status must be the only argument if it is specified.");
     1154 
     1155 	if totals_sw & ^list_sw then			/* memo -delete -tt */
     1156 	     call inconsistent ("-totals may only be used with -list.");
     1157 
     1158 	return;
     1159 
     1160 BAD_CONVERSION:	     code = error_table_$bad_conversion;
     1161 BAD_REPEAT_COUNT:	     call complain (code, WHOAMI,
     1162 			"-times must be followed by a positive number, not ""^a"".^[^2xMemo not set.^]",
     1163 			arg1, might_set_sw);
     1164 		     complained = "1"b;
     1165 		     goto MAIN_RETURN;
     1166 
     1167 
     1168 get_next_date_arg: proc () returns (fixed bin (71));
     1169 
     1170 /* *	This procedure extracts the next argument in the string, and returns it as a clock value */
     1171 
     1172 dcl  temp_time fixed bin (71);
     1173 
     1174 	     if argno = nargs then do;
     1175 		call complain (error_table_$noarg, WHOAMI,
     1176 		     "Date/Time after ^a.^[^2xMemo not set.^]", arg, might_set_sw);
     1177 		complained = "1"b;
     1178 		goto MAIN_RETURN;
     1179 		end;
     1180 
     1181 	     argno = argno + 1;
     1182 	     call cu_$arg_ptr_rel (argno, ap1, al1, (0), P_arg_list);
     1183 
     1184 	     call convert_date_to_binary_ (arg1, temp_time, code);
     1185 	     if code ^= 0 then do;
     1186 		call complain (code, WHOAMI, "^a ^a^[.^2xMemo not set.^]", arg, arg1, might_set_sw);
     1187 		complained = "1"b;
     1188 		goto MAIN_RETURN;
     1189 		end;
     1190 
     1191 	     return (temp_time);
     1192 	     end get_next_date_arg;
     1193 	  
     1194 
     1195 get_next_string_arg: proc ();
     1196 
     1197 /* *	This procedure extracts the next argument in the string, and returns it as a clock value */
     1198 
     1199 	     if argno = nargs then do;
     1200 		call complain (error_table_$noarg, WHOAMI, "After ^a.^[^2xMemo not set^]", arg, might_set_sw);
     1201 		complained = "1"b;
     1202 		goto MAIN_RETURN;
     1203 		end;
     1204 
     1205 	     argno = argno + 1;
     1206 	     call cu_$arg_ptr_rel (argno, ap1, al1, (0), P_arg_list);
     1207 
     1208 	     return;
     1209 	     end get_next_string_arg;
     1210 	  
     1211 
     1212 
     1213 inconsistent: proc (P_message);
     1214 
     1215 /* *	This procedure just calls complain with the message and punts. */
     1216 
     1217 dcl  P_message char (*) parameter;
     1218 
     1219 	     call complain (error_table_$inconsistent, WHOAMI, "^a^[^2xMemo not set.^]", P_message, set_memo_sw);
     1220 	     complained = "1"b;
     1221 	     goto MAIN_RETURN;
     1222 
     1223 	     end inconsistent;
     1224 	  
     1225 
     1226 	end process_args;
     1227        
     1228 
     1229 
     1230 
     1231 get_default_memo_seg: proc ();
     1232 
     1233 /* *	This procedure tries to set the static_pointer to point to the right default memo segment */
     1234 
     1235 dcl  temp_uid bit (36) aligned;
     1236 
     1237 	if static_pointer ^= null () then do;		/* it claims we have one, so let's check.... */
     1238 	     call hcs_$get_uid_seg (static_pointer, temp_uid, code);
     1239 	     if code ^= 0 then do;
     1240 MEMO_SEG_ERROR:	call complain (code, WHOAMI, "^a>^a", static_dname, static_ename);
     1241 		complained = "1"b;
     1242 		goto MAIN_RETURN;
     1243 		end;
     1244 
     1245 	     if temp_uid ^= static_uid then do;		/* Oh dear. Reused segment number.... */
     1246 		call com_err_ (0, WHOAMI, "Warning: ^a>^a has been terminated since last invocation of memo command.",
     1247 		     static_dname, static_ename);
     1248 		static_pointer = null ();		/* flag it as invalid */
     1249 		end;
     1250 	     end;
     1251 
     1252 	if static_pointer = null () then do;		/* the segment isn't there. Let's see if we can find it */
     1253 	     if static_dname = "" then do;		/* first call, so set the pathname to the right default. */
     1254 		static_dname = default_memo_directory;
     1255 		static_ename = static_person || ".memo";
     1256 		dname = static_dname;
     1257 		ename = static_ename;
     1258 		end;
     1259 
     1260 	     call hcs_$initiate_count (static_dname, static_ename, "", (0), 0, static_pointer, code);
     1261 
     1262 	     if static_pointer = null () & code = error_table_$noentry then do; /* create if not there ? */
     1263 		call hcs_$make_seg (static_dname, static_ename, "", R_ACCESS_BIN + W_ACCESS_BIN, static_pointer, code);
     1264 
     1265 		if static_pointer = null () then goto MEMO_SEG_ERROR; /* couldn't create, give up. */
     1266 		else call ioa_ ("^a: Creating ^a>^a.", WHOAMI, static_dname, static_ename);
     1267 
     1268 		static_pointer -> memo_segment.version = MEMO_SEGMENT_VERSION_3; /* start out right.... */
     1269 		end;				/* of attempt to create memo segment */
     1270 
     1271 	     if static_pointer = null () then		/* still?? we lost, then */
     1272 		goto MEMO_SEG_ERROR;
     1273 
     1274 	     call hcs_$get_uid_seg (static_pointer, static_uid, code); /* remember its identifier, for good measure */
     1275 	     if code ^= 0 then goto MEMO_SEG_ERROR;
     1276 	     end;					/* of nonexistent memo seg case */
     1277 
     1278 	call hcs_$fs_get_mode (static_pointer, fs_mode, code); /* now, see if we have access */
     1279 	if code ^= 0 then do;			/* seems unlikely */
     1280 	     call complain (code, WHOAMI, "^a>^a", dname, ename);
     1281 	     complained = "1"b;
     1282 	     goto MAIN_RETURN;
     1283 	     end;
     1284 
     1285 	if fs_mode = (R_ACCESS_BIN + W_ACCESS_BIN) | fs_mode = (R_ACCESS_BIN + E_ACCESS_BIN + W_ACCESS_BIN) then
     1286 	     have_write_access, have_read_access = "1"b;
     1287 	else if fs_mode = R_ACCESS_BIN | fs_mode = (R_ACCESS_BIN + E_ACCESS_BIN) then
     1288 	     have_read_access = "1"b;
     1289 
     1290 	if ^have_read_access then do;			/* sorry, can't do anything at all with it */
     1291 	     call complain (error_table_$no_r_permission, WHOAMI, "
     1292 memo segment: ^a>^a", static_dname, static_ename);
     1293 
     1294 	     goto MAIN_RETURN;
     1295 	     end;
     1296 
     1297 	if static_pointer -> memo_segment.version < MEMO_SEGMENT_VERSION_3 then /* try to covert */
     1298 	     call memo_upgrade_memo_segment_ (static_pointer); /* before testing again */
     1299 
     1300 	if static_pointer -> memo_segment.version ^= MEMO_SEGMENT_VERSION_3 then do;
     1301 	     call complain (0, WHOAMI, "Memo segment ^a>^a is is not the correct version.", static_dname, static_ename);
     1302 	     complained = "1"b;
     1303 	     goto MAIN_RETURN;
     1304 	     end;
     1305 
     1306 	return;
     1307 	end get_default_memo_seg;
     1308        
     1309 
     1310 
     1311 initialize_memo: proc ();
     1312 
     1313 /* *	This procedure initializes various variables for an invocation of memo. */
     1314 
     1315 dcl (person, project) char (32);
     1316 
     1317 	if ^static_initialized then do;
     1318 	     end_of_time = memo_util_$end_of_time ();	/* call and find out */
     1319 	     end_of_memo_time = from_gmt (end_of_time);
     1320 	     call user_info_ (person, project, (""));
     1321 	     static_person = rtrim (person);
     1322 	     static_project = rtrim (project);
     1323 	     call user_info_$homedir (default_memo_directory);
     1324 	     static_initialized = "1"b;
     1325 	     end;
     1326 
     1327 	P_expiration_string = null;
     1328 	L_expiration_string = 0;
     1329 	P_arg_list = null;
     1330 	call timer_manager_$reset_alarm_call (memo$alarm_entry);
     1331 
     1332 	complained = "0"b;
     1333 	memo_bits (*) = ""b;
     1334 	time_now = clock ();
     1335 	memo_time_now = from_gmt (time_now);
     1336 /* variable initializations moved here from process_args so they will be initialized from both entry points	*/
     1337 	memo_segment_modified = "0"b;			/* start out assuming that it wasn't modified */
     1338 	memo_segment_ptr = null ();			/* and with a null pointer to it */
     1339  	memo_text = "";				/* the collected text of the memo being set */
     1340 	n_match_strings, n_memo_numbers = 0;		/* how many match strings/memo numbers have been collected */
     1341 	n_class_names = 0;				/* how many memo classes to process */
     1342 	list_sw, print_sw, delete_sw, postpone_sw = "0"b; /* one per action, other than setting */
     1343 	process_memos_sw = "0"b;			/* this is done if nothing else is specified */
     1344 	set_memo_sw = "0"b;
     1345 	set_pathname_sw = "0"b;			/* whether to use the specified pathname permanently */
     1346 	select_options_specified_sw = "0"b;
     1347 	maturity_time = -1;				/* the date we are interested in */
     1348 	repeat_string = "";				/* how often to repeat the memo */
     1349 	repeat_count = -1;				/* max number of times it gets repeated before exploding */
     1350 	repeat_sw, expires_sw, remains_sw, single_sw,	/* set if the option in question is to be used */
     1351 	     per_process_sw, alarm_sw, call_sw, repeat_count_sw, invisible_sw = "0"b;
     1352 	dname, ename = "";				/* pathname of specified memo segment */
     1353 	brief_sw = "0"b;				/* controls noisiness of messages */
     1354 	force_sw = "0"b;				/* whether or not to force deletion */
     1355 	totals_sw = "0"b;				/* for listing only, print total count rather than memos */
     1356 	turn_timer_on_sw, turn_timer_off_sw = "0"b;	/* timer control flags */
     1357 	af_sw = "0"b;
     1358 	fs_mode = 0;
     1359 	status_sw = "0"b;				/* whether to report status of default memo segment */
     1360 	from_time, to_time = -1;			/* time to list from/to */
     1361 	mature_sw, immature_sw = "0"b;		/* select only mature/immature memos */
     1362 	have_write_access = "0"b;
     1363 	have_read_access = "0"b;
     1364           complained ="0"b;
     1365 	nargs = 0;
     1366 
     1367 	return;
     1368 	end initialize_memo;
     1369        
     1370 
     1371 
     1372 from_gmt:	proc (clock_value) returns (fixed bin (35));
     1373 
     1374 dcl  clock_value fixed bin (71) parameter;
     1375 dcl  memo_time fixed bin (35);
     1376 
     1377 	memo_time = divide ((clock_value - sys_info$time_correction_constant), 1000000, 35, 0);
     1378 
     1379 	return (memo_time);
     1380 	end from_gmt;
     1381        
     1382 
     1383 clean_things_up: proc ();
     1384 
     1385 /* *	This is the cleanup handler procedure; actually, all it does is turn timers back on if needed. */
     1386 dcl  size builtin;
     1387 
     1388      if static_pointer = null then     /* check if we got here before static variables were set */
     1389         return;                        /* if so, no need to clean them up */
     1390      if have_write_access | complained then do; /* do we need to clean up the static variables? */
     1391 	if memo_segment_modified then			/* set the bitcount, maybe? */
     1392 	     if memo_segment_ptr ^= null () then
     1393 		call hcs_$set_bc_seg (memo_segment_ptr, multiply ((size (memo_segment_header)
     1394 		     + memo_segment.max_number_used * size (memo_segment_entry)), 36, 24, 0), (0));
     1395 
     1396 	memo_invocation_count = memo_invocation_count - 1; /* "unstack" */
     1397 	if memo_invocation_count < 0 then memo_invocation_count = 0;
     1398 
     1399 	if static_pointer ^= null () then		/* only if we have one, of course */
     1400 	     if memo_timers_enabled then
     1401 		if memo_invocation_count = 0 then	/* Only outermost invocation diddles timers */
     1402 		     call memo_timer_set_ (static_pointer, memo$alarm_entry);
     1403            end;
     1404         
     1405         else do; /* terminate the file we can't use, and clear the static variables that describe it */
     1406            term_switch.truncate = "0"b;
     1407            term_switch.set_bc = "0"b;
     1408            term_switch.terminate = "1"b;  /* set switch for terminate_file_ to terminate a null reference name*/
     1409            term_switch.force_write = "1"b; /* set switch to remove modified memo segment from main memory	*/
     1410            term_switch.delete = "0"b;
     1411            call terminate_file_ (memo_segment_ptr, 0, string (term_switch),
     1412 	    code);
     1413            if code ^= 0 then
     1414               call complain (code, WHOAMI, 
     1415 "Unable to terminate memo segment. ^/memo segment: ^a>^a.", dname, ename);
     1416 	 else do;
     1417 	    static_pointer = null;   /* reset static variables 					*/
     1418               static_initialized = "0"b;
     1419 	    static_uid = ""b;
     1420 	    memo_timers_enabled = "0"b;
     1421 	    memo_invocation_count = 0;
     1422 	    end_of_time = -1;
     1423 	    end_of_memo_time = -1;
     1424 	    static_person = "";
     1425 	    static_project = "";
     1426               if list_sw | print_sw | (list_sw & set_pathname_sw & nargs = 3) | (print_sw & set_pathname_sw & nargs = 3) then;
     1427               else 
     1428 	       call complain (error_table_$no_w_permission,WHOAMI,"^a>^a.
     1429 Unable to delete or reschedule memos. Memos disabled.",static_dname,static_ename);
     1430 	    static_dname = "";
     1431 	    static_ename = "";
     1432 	    end;
     1433 	 end;
     1434         return;
     1435         end clean_things_up;
     1436  /* BEGIN INCLUDE FILE ... memo_segment.incl.pl1 ... July, 1979 ... W. Olin Sibert */
  1     2 /* *	This include file describes a memo segment. Presently, this structure is still
  1     3*   *	compatible with "old" version 3 memo segments, although it uses more of the pad
  1     4*   *	fields; hence, it is still identified as version 3. If the conversion to version
  1     5*   *	4 memo segments is ever done, this will have to be changed for version 4.
  1     6*   */
  1     7 
  1     8 dcl  memo_segment_ptr pointer;
  1     9 
  1    10 dcl  MAX_NUMBER_MEMOS fixed bin internal static options (constant) init (5802);
  1    11 						/* max number of memos in a memo segment */
  1    12 
  1    13 dcl  MEMO_SEGMENT_VERSION_3 fixed bin internal static options (constant) init (3);
  1    14 
  1    15 dcl 1 memo_segment aligned based (memo_segment_ptr),	/* current version of whole segment */
  1    16     2 header like memo_segment_header,
  1    17     2 memo_entry (MAX_NUMBER_MEMOS) like memo_segment_entry;
  1    18 
  1    19 dcl 1 memo_segment_header aligned based,		/* header for memo segment */
  1    20     2 version fixed bin (35), 			/* presently 3 */
  1    21     2 max_number_used fixed bin (35);			/* The highest entry known to be used */
  1    22 
  1    23 dcl 1 memo_segment_entry aligned based, 		/* the entry for a single memo */
  1    24     2 taken bit (36) aligned, 			/* Zero if this entry free */
  1    25     2 flags aligned,				/* data about this memo */
  1    26       3 print bit (1) unaligned,			/* normal type memo */
  1    27       3 alarm bit (1) unaligned,			/* alarm type */
  1    28       3 execute bit (1) unaligned,			/* execute type */
  1    29       3 repeatsw bit (1) unaligned,			/* has repeat string */
  1    30       3 expires bit (1) unaligned,			/* has expiration time */
  1    31       3 remains bit (1) unaligned,			/* do not delete this memo when its alarm goes off */
  1    32       3 single bit (1) unaligned,			/* delete this non-alarm memo after one printing or execution */
  1    33       3 per_process bit (1) unaligned,			/* causes repeat to be done from time_now, not maturity */
  1    34       3 pad1 bit (28) unaligned,			/* not used */
  1    35     2 exp_delta fixed bin (35),			/* delta time before memo expires */
  1    36     2 time fixed bin (35),				/* time this memo matures */
  1    37     2 data char (132) aligned,			/* the memo message */
  1    38     2 repeat char (32) aligned;			/* the repeat string */
  1    39 
  1    40 /*	END INCLUDE FILE memo_segment.incl.pl1		*/
     1436 
     1437  /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  2     2*
  2     3*   Values for the "access mode" argument so often used in hardcore
  2     4*   James R. Davis 26 Jan 81  MCR 4844
  2     5*   Added constants for SM access 4/28/82 Jay Pattin
  2     6*   Added text strings 03/19/85 Chris Jones
  2     7**/
  2     8 
  2     9 
  2    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  2    11 dcl	(
  2    12 	N_ACCESS		   init ("000"b),
  2    13 	R_ACCESS		   init ("100"b),
  2    14 	E_ACCESS		   init ("010"b),
  2    15 	W_ACCESS		   init ("001"b),
  2    16 	RE_ACCESS		   init ("110"b),
  2    17 	REW_ACCESS	   init ("111"b),
  2    18 	RW_ACCESS		   init ("101"b),
  2    19 	S_ACCESS		   init ("100"b),
  2    20 	M_ACCESS		   init ("010"b),
  2    21 	A_ACCESS		   init ("001"b),
  2    22 	SA_ACCESS		   init ("101"b),
  2    23 	SM_ACCESS		   init ("110"b),
  2    24 	SMA_ACCESS	   init ("111"b)
  2    25 	)		   bit (3) internal static options (constant);
  2    26 
  2    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  2    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  2    29 
  2    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  2    31 			   static options (constant);
  2    32 
  2    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  2    34 			   static options (constant);
  2    35 
  2    36 dcl	(
  2    37 	N_ACCESS_BIN	   init (00000b),
  2    38 	R_ACCESS_BIN	   init (01000b),
  2    39 	E_ACCESS_BIN	   init (00100b),
  2    40 	W_ACCESS_BIN	   init (00010b),
  2    41 	RW_ACCESS_BIN	   init (01010b),
  2    42 	RE_ACCESS_BIN	   init (01100b),
  2    43 	REW_ACCESS_BIN	   init (01110b),
  2    44 	S_ACCESS_BIN	   init (01000b),
  2    45 	M_ACCESS_BIN	   init (00010b),
  2    46 	A_ACCESS_BIN	   init (00001b),
  2    47 	SA_ACCESS_BIN	   init (01001b),
  2    48 	SM_ACCESS_BIN	   init (01010b),
  2    49 	SMA_ACCESS_BIN	   init (01011b)
  2    50 	)		   fixed bin (5) internal static options (constant);
  2    51 
  2    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
     1437 
     1438  /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  3     2 /* format: style2,^inddcls,idind32 */
  3     3 
  3     4 declare 1 terminate_file_switches	based,
  3     5 	2 truncate		bit (1) unaligned,
  3     6 	2 set_bc			bit (1) unaligned,
  3     7 	2 terminate		bit (1) unaligned,
  3     8 	2 force_write		bit (1) unaligned,
  3     9 	2 delete			bit (1) unaligned;
  3    10 
  3    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  3    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  3    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  3    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  3    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  3    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  3    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  3    18 
  3    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
     1438 
     1439        
     1440 
     1441 	end memo; 				/* external procedure memo */
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/23/89  1228.0  memo.pl1                          >spec>install>1010>memo.pl1
1436         1    08/18/81  1510.4  memo_segment.incl.pl1             >ldd>include>memo_segment.incl.pl1
1437         2    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
1438         3    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
E_ACCESS_BIN                           constant        fixed bin(5,0)           initial dcl 2-36 ref 228 230 437 1285 1287
L_expiration_string             000112 automatic       fixed bin(21,0)          dcl 53 set ref 374 374 378 378 384 384 938* 1328*
MAX_NUMBER_MEMOS                       constant        fixed bin(17,0)          initial dcl 1-10 ref 1-15 113
MEMO_SEGMENT_VERSION_3                 constant        fixed bin(17,0)          initial dcl 1-13 ref 240 1268 1297 1300
P_alarm                                parameter       bit(1)                   dcl 491 ref 487 499
P_arg_list                      000106 automatic       pointer                  dcl 51 set ref 193* 667* 696* 1182* 1206* 1329*
P_expiration_string             000110 automatic       pointer                  dcl 52 set ref 374 378 384 939* 1327*
P_message                              parameter       char                     packed unaligned dcl 1217 set ref 1213 1219*
R_ACCESS_BIN                           constant        fixed bin(5,0)           initial dcl 2-36 ref 228 228 230 230 437 437 1263
                                                                                  1285 1285 1287 1287
SPACE                           014306 constant        char(1)                  initial dcl 176 ref 769
WHOAMI                          000000 constant        char(32)                 initial packed unaligned dcl 177 set ref 215* 223*
                                                                                  234* 241* 325* 345* 378* 384* 396* 433* 446* 456*
                                                                                  536* 611* 613* 680* 711* 735* 743* 750* 763* 780*
                                                                                  787* 824* 837* 851* 861* 871* 886* 915* 931* 947*
                                                                                  953* 966* 973* 984* 999* 1007* 1084* 1093* 1101*
                                                                                  1109* 1112* 1161* 1175* 1186* 1200* 1219* 1240*
                                                                                  1246* 1266* 1280* 1291* 1301* 1413* 1427*
W_ACCESS_BIN                           constant        fixed bin(5,0)           initial dcl 2-36 ref 228 228 437 437 1263 1285 1285
action_count                    000115 automatic       fixed bin(17,0)          dcl 659 set ref 1029* 1062 1064 1070 1121
active_fnc_err_                 000150 constant        entry                    external dcl 129 ref 670
af_sw                           000162 automatic       bit(1)                   dcl 74 set ref 297 301 307 405 669* 675* 1131 1357*
al                              000101 automatic       fixed bin(21,0)          dcl 653 set ref 696* 702 708 711 711 717 720 726 730
                                                                                  731 735 735 762 771 778 795 795 796 796 797 797
                                                                                  797 798 799 800 800 801 801 803 803 804 804 805
                                                                                  806 806 807 807 808 808 810 810 817 817 818 818
                                                                                  819 819 820 822 822 837 837 843 843 849 849 859
                                                                                  869 869 869 896 913 913 913 913 931 931 942 962
                                                                                  982 982 982 982 1007 1007 1175 1175 1186 1186 1200
                                                                                  1200
al1                             000102 automatic       fixed bin(21,0)          dcl 653 set ref 885 892 907 929 929 931 931 938 946
                                                                                  959 965 979 991 991 997 997 999 999 1161 1161
                                                                                  1182* 1184 1184 1186 1186 1206*
alarm                     0(01) 000174 automatic       bit(1)                   level 2 in structure "arg_flags" packed packed
                                                                                  unaligned dcl 84 in procedure "memo" set ref 1042*
alarm                     3(01)        based           bit(1)                   array level 4 in structure "memo_segment" packed
                                                                                  packed unaligned dcl 1-15 in procedure "memo" ref
                                                                                  499
alarm_sw                        000137 automatic       bit(1)                   dcl 66 set ref 804* 1042 1137 1350*
answer                          000121 automatic       bit(1)                   dcl 661 set ref 1109* 1111
ap                              000104 automatic       pointer                  dcl 654 set ref 696* 702 708 711 717 720 730 731 735
                                                                                  771 778 795 795 796 796 797 797 797 798 799 800
                                                                                  800 801 801 803 803 804 804 805 806 806 807 807
                                                                                  808 808 810 810 817 817 818 818 819 819 820 822
                                                                                  822 837 843 843 849 849 859 869 869 869 896 913
                                                                                  913 913 913 931 942 962 982 982 982 982 1007 1175
                                                                                  1186 1200
ap1                             000106 automatic       pointer                  dcl 654 set ref 892 907 929 931 939 959 979 991 991
                                                                                  997 999 1161 1182* 1184 1186 1206*
arg                                    based           char                     packed unaligned dcl 655 set ref 702 708 711* 717
                                                                                  720 730 731 735* 771 778 795 795 796 796 797 797
                                                                                  797 798 799 800 800 801 801 803 803 804 804 805
                                                                                  806 806 807 807 808 808 810 810 817 817 818 818
                                                                                  819 819 820 822 822 837* 843 843 849 849 859 869
                                                                                  869 869 896 913 913 913 913 931* 942 962 982 982
                                                                                  982 982 1007* 1175* 1186* 1200*
arg1                                   based           char                     packed unaligned dcl 656 set ref 892 907 929* 931*
                                                                                  959 979 991 991 997* 999* 1161* 1184* 1186*
arg_flags                       000174 automatic       structure                level 1 dcl 84 set ref 361 402 402 577 1036* 1045
argno                           000100 automatic       fixed bin(17,0)          dcl 652 set ref 693* 696* 786 879 900 923* 1174
                                                                                  1181* 1181 1182* 1199 1205* 1205 1206*
binary                                                 builtin function         dcl 181 ref 1029 1029 1029 1029 1029 1029 1045 1045
                                                                                  1045 1045 1045 1045 1045 1045
brief_sw                        000155 automatic       bit(1)                   dcl 71 set ref 271 281 795* 796* 1143 1353*
call_sw                         000141 automatic       bit(1)                   dcl 66 set ref 364 805* 1041 1350*
char                                                   builtin function         dcl 181 ref 301 309 405
class_name                      001434 automatic       char(32)                 array packed unaligned dcl 109 set ref 946 947 947
                                                                                  952 953 953 959*
cleanup                         001676 stack reference condition                dcl 179 ref 190 440
clock                                                  builtin function         dcl 181 ref 1334
clock_value                            parameter       fixed bin(71,0)          dcl 1374 ref 1372 1377
code                            000100 automatic       fixed bin(35,0)          dcl 46 set ref 213* 215* 221* 222 223* 374* 377 378*
                                                                                  431* 432 433* 667* 668 674 680* 710* 711* 833* 836
                                                                                  837* 929* 930 931* 997* 998 999* 1091* 1092 1093*
                                                                                  1160* 1161* 1184* 1185 1186* 1238* 1239 1240*
                                                                                  1260* 1262 1263* 1274* 1275 1278* 1279 1280* 1411*
                                                                                  1413 1413*
collecting_memo_sw              000113 automatic       bit(1)                   dcl 658 set ref 687* 702 703 703* 761 792*
collecting_numbers_sw           000114 automatic       bit(1)                   dcl 658 set ref 688* 699* 703 706 779 813*
com_err_                        000152 constant        entry                    external dcl 130 ref 429 676 680 1246
command_query_$yes_no           000154 constant        entry                    external dcl 131 ref 1109
complain                        000114 automatic       entry variable           dcl 54 set ref 215 223 234 241 325 345 378 384 396
                                                                                  429* 433 446 456 536 611 613 670* 676* 711 735 743
                                                                                  750 763 780 787 824 837 851 861 871 886 915 931
                                                                                  947 953 966 973 984 999 1007 1084 1093 1101 1112
                                                                                  1161 1175 1186 1200 1219 1240 1280 1291 1301 1413
                                                                                  1427
complained                      000166 automatic       bit(1)                   initial dcl 77 set ref 77* 216* 224* 236* 243* 258*
                                                                                  282* 379* 386* 537* 615* 681* 713* 737* 745* 752*
                                                                                  765* 782* 788* 826* 838* 852* 862* 873* 888* 917*
                                                                                  934* 948* 954* 968* 974* 985* 1000* 1008* 1086*
                                                                                  1096* 1103* 1113* 1164* 1177* 1187* 1201* 1220*
                                                                                  1241* 1281* 1302* 1332* 1364* 1390
conversion                      000000 stack reference condition                dcl 179 ref 719 721 729 732 906 908
convert                                                builtin function         dcl 181 ref 720 730 731 907
convert_date_to_binary_         000156 constant        entry                    external dcl 132 ref 929 1184
convert_date_to_binary_$relative
                                000160 constant        entry                    external dcl 133 ref 374 1091
cu_$af_return_arg_rel           000164 constant        entry                    external dcl 135 ref 667
cu_$arg_list_ptr                000162 constant        entry                    external dcl 134 ref 193
cu_$arg_ptr_rel                 000166 constant        entry                    external dcl 136 ref 696 1182 1206
data                      6            based           char(132)                array level 3 dcl 1-15 set ref 288* 554
day_of_month                    000125 automatic       fixed bin(17,0)          dcl 59 set ref 832* 833*
decode_clock_value_             000170 constant        entry                    external dcl 137 ref 832
default_memo_directory          000010 internal static char(64)                 initial packed unaligned dcl 79 set ref 1254 1323*
delete                    0(04) 000173 automatic       bit(1)                   level 2 packed packed unaligned dcl 83 set ref 1410*
delete_sw                       000133 automatic       bit(1)                   dcl 64 set ref 319 534 697 819* 879 900 923 1029
                                                                                  1124 1342*
divide                                                 builtin function         dcl 181 ref 390 1377
dname                           000267 automatic       char(168)                packed unaligned dcl 99 set ref 197 204 213* 215*
                                                                                  223* 234* 241* 325* 345* 396* 433* 983 992* 997*
                                                                                  1070 1256* 1280* 1352* 1413*
ename                           000341 automatic       char(32)                 packed unaligned dcl 100 set ref 205 213* 215* 223*
                                                                                  234* 241* 325* 345* 396* 433* 993* 997* 1257*
                                                                                  1280* 1352* 1413*
encode_clock_value_             000172 constant        entry                    external dcl 139 ref 833
end_of_memo_time                000124 internal static fixed bin(35,0)          initial dcl 124 set ref 591 596 1319* 1423*
end_of_time                     000122 internal static fixed bin(71,0)          initial dcl 123 set ref 369 1026 1318* 1319* 1422*
error_table_$bad_conversion     000256 external static fixed bin(35,0)          dcl 167 ref 710 1160
error_table_$badopt             000254 external static fixed bin(35,0)          dcl 167 set ref 1007*
error_table_$inconsistent       000260 external static fixed bin(35,0)          dcl 167 set ref 780* 1219*
error_table_$no_r_permission    000266 external static fixed bin(35,0)          dcl 167 set ref 234* 1291*
error_table_$no_w_permission    000270 external static fixed bin(35,0)          dcl 167 set ref 1427*
error_table_$noarg              000262 external static fixed bin(35,0)          dcl 167 set ref 787* 1084* 1175* 1200*
error_table_$noentry            000264 external static fixed bin(35,0)          dcl 167 ref 1262
error_table_$not_act_fnc        000272 external static fixed bin(35,0)          dcl 167 ref 674
execute                   0(02) 000175 automatic       bit(1)                   level 2 in structure "set_flags" packed packed
                                                                                  unaligned dcl 85 in procedure "memo" set ref 365*
execute                   0(02) 000174 automatic       bit(1)                   level 2 in structure "arg_flags" packed packed
                                                                                  unaligned dcl 84 in procedure "memo" set ref 1041*
expand_pathname_$add_suffix     000174 constant        entry                    external dcl 141 ref 997
expiration_delta                000224 automatic       fixed bin(35,0)          dcl 95 set ref 390* 393* 402*
expiration_string                      based           char                     packed unaligned dcl 93 set ref 374* 378* 384*
expiration_time                 000222 automatic       fixed bin(71,0)          dcl 94 set ref 374* 383 390
expires                   0(04) 000174 automatic       bit(1)                   level 2 packed packed unaligned dcl 84 set ref 1040*
expires_sw                      000144 automatic       bit(1)                   dcl 66 set ref 373 914 921* 1040 1350*
finish                    0(18) 001123 automatic       fixed bin(17,0)          array level 2 in structure "memo_number" packed
                                                                                  packed unaligned dcl 105 in procedure "memo" set
                                                                                  ref 566 611 613* 758*
finish                          000115 automatic       fixed bin(17,0)          dcl 526 in procedure "select_memos" set ref 566* 567
flags                     3            based           structure                array level 3 in structure "memo_segment" dcl 1-15
                                                                                  in procedure "memo" ref 586
flags                     1            based           structure                level 2 in structure "memo_segment_entry" dcl 1-23
                                                                                  in procedure "memo"
force_sw                        000157 automatic       bit(1)                   dcl 71 set ref 333* 800* 1107 1124 1354*
force_write               0(03) 000173 automatic       bit(1)                   level 2 packed packed unaligned dcl 83 set ref 1409*
from_time                       000202 automatic       fixed bin(71,0)          dcl 89 set ref 589 592* 850 856* 1018 1023 1023*
                                                                                  1026 1045 1127 1134 1360*
fs_mode                         000130 automatic       fixed bin(5,0)           dcl 61 set ref 221* 228 228 230 230 431* 437 437
                                                                                  1278* 1285 1285 1287 1287 1358*
have_read_access                000164 automatic       bit(1)                   dcl 76 set ref 228* 230* 233 1285* 1287* 1290 1363*
have_write_access               000165 automatic       bit(1)                   dcl 76 set ref 228* 268* 324 344 395 437* 454* 1285*
                                                                                  1362* 1390
hbound                                                 builtin function         dcl 181 ref 749 750 750 952 953 953 972 973 973
hcs_$fs_get_mode                000176 constant        entry                    external dcl 142 ref 221 431 1278
hcs_$get_uid_seg                000200 constant        entry                    external dcl 143 ref 1238 1274
hcs_$initiate_count             000202 constant        entry                    external dcl 144 ref 213 1260
hcs_$make_seg                   000204 constant        entry                    external dcl 145 ref 1263
hcs_$set_bc_seg                 000206 constant        entry                    external dcl 146 ref 1391
header                                 based           structure                level 2 dcl 1-15
idx                             000100 automatic       fixed bin(17,0)          dcl 493 in procedure "select_mature_memos" set ref
                                                                                  498* 499 499 499 503*
idx                             000111 automatic       fixed bin(17,0)          dcl 524 in procedure "select_memos" set ref 551* 552
                                                                                  553 554 555* 564* 565 566 570 570* 583* 584 586
                                                                                  591 592 593 596 600 603* 609* 610 611 611 611 613
                                                                                  613* 638* 639*
idx                             000106 automatic       fixed bin(17,0)          dcl 470 in procedure "select_all_memos" set ref 475*
                                                                                  476 478*
idx                             000121 automatic       fixed bin(17,0)          dcl 57 in procedure "memo" set ref 286* 287 288*
                                                                                  288* 305* 306 309 311* 331* 332 333* 351* 352 353*
immature_sw                     000151 automatic       bit(1)                   dcl 68 set ref 1045 1127 1361*
index                                                  builtin function         dcl 181 ref 554 717
invisible_sw                    000140 automatic       bit(1)                   dcl 66 set ref 369 578 596 803* 1045 1350*
ioa_                            000210 constant        entry                    external dcl 147 ref 251 253 257 288 302 1266
ioa_$ioa_switch                 000212 constant        entry                    external dcl 148 ref 271 281
iox_$control                    000214 constant        entry                    external dcl 149 ref 458
iox_$error_output               000250 external static pointer                  dcl 164 set ref 271* 281*
iox_$user_io                    000246 external static pointer                  dcl 163 set ref 458*
jdx                             000112 automatic       fixed bin(17,0)          dcl 524 set ref 553* 554* 567* 568 569*
length                                                 builtin function         dcl 181 ref 308 762 769
list_sw                         000131 automatic       bit(1)                   dcl 64 set ref 294 697 817* 879 900 923 1029 1131
                                                                                  1155 1342* 1426 1426
ltrim                                                  builtin function         dcl 181 ref 301 309 405
match_string                    000352 automatic       varying char(32)         array dcl 103 set ref 554 965 966 966 972 973 973
                                                                                  979*
matched                         000113 automatic       bit(1)                   dcl 525 set ref 585* 586* 590* 591* 592* 593* 596*
                                                                                  600* 603
mature_sw                       000150 automatic       bit(1)                   dcl 68 set ref 1045 1127 1361*
maturity_time                   000200 automatic       fixed bin(71,0)          dcl 88 set ref 369* 371 371* 374* 383 384* 390 402*
                                                                                  402* 823 830* 832* 833* 844 846* 1018 1019 1020*
                                                                                  1045 1134 1347*
max_number_used           1            based           fixed bin(35,0)          level 3 dcl 1-15 set ref 253* 286 305 331 351 475
                                                                                  498 518 519 520 551 565 566 583 638 1391 1391
maxlength                                              builtin function         dcl 181 ref 762 763 763 885 886 886 946 947 947 965
                                                                                  966 966
memo_bits                       001675 automatic       bit(1)                   array packed unaligned dcl 113 set ref 268* 287 306
                                                                                  332 352 454* 473* 478* 496* 503* 622* 623* 623
                                                                                  625* 625 630* 631* 631 635* 639 1333*
memo_delete_                    000216 constant        entry                    external dcl 150 ref 333
memo_entry                2            based           structure                array level 2 dcl 1-15
memo_invocation_count           000120 internal static fixed bin(17,0)          initial dcl 122 set ref 192* 192 442* 442 1396* 1396
                                                                                  1397 1397* 1399 1421*
memo_list_                      000220 constant        entry                    external dcl 151 ref 311
memo_list_$format_time          000222 constant        entry                    external dcl 152 ref 384
memo_match_count                001674 automatic       fixed bin(17,0)          dcl 111 set ref 266 280 297 301 302* 322 342 452
                                                                                  472* 477* 477 495* 502* 502 637* 639* 639
memo_number                     001123 automatic       structure                array level 1 dcl 105 set ref 749 750 750
memo_process_memos_             000224 constant        entry                    external dcl 153 ref 268 454
memo_segment                           based           structure                level 1 dcl 1-15
memo_segment_entry                     based           structure                level 1 dcl 1-23 ref 1391 1391
memo_segment_header                    based           structure                level 1 dcl 1-19 ref 1391 1391
memo_segment_modified           000163 automatic       bit(1)                   dcl 75 set ref 188* 267* 329* 349* 400* 453* 1337*
                                                                                  1391
memo_segment_ptr                001704 automatic       pointer                  dcl 1-8 set ref 199* 209* 213* 214 221* 240 268* 286
                                                                                  288 305 311* 331 333* 351 353 402* 444* 445 454*
                                                                                  475 476 498 499 499 499 518 519 520 551 552 554
                                                                                  565 566 568 583 584 586 591 592 593 596 638 1338*
                                                                                  1391 1391* 1391 1391 1411*
memo_set_                       000226 constant        entry                    external dcl 154 ref 402
memo_text                       000225 automatic       varying char(132)        dcl 97 set ref 402 762 762 763 763 769 769* 769 771*
                                                                                  771 1339*
memo_time                       000100 automatic       fixed bin(35,0)          dcl 1375 set ref 1377* 1379
memo_time_now                   000172 automatic       fixed bin(35,0)          dcl 81 set ref 268* 454* 499 1335*
memo_timer_set_                 000230 constant        entry                    external dcl 155 ref 1399
memo_timers_enabled             000117 internal static bit(1)                   initial dcl 121 set ref 257* 410* 412* 1074* 1399
                                                                                  1420*
memo_upgrade_memo_segment_      000232 constant        entry                    external dcl 156 ref 1297
memo_util_$end_of_time          000234 constant        entry                    external dcl 157 ref 1318
might_set_sw                    000120 automatic       bit(1)                   dcl 660 set ref 686* 698* 707* 772* 824* 837* 871*
                                                                                  886* 931* 984* 999* 1007* 1161* 1175* 1186* 1200*
min                                                    builtin function         dcl 181 ref 565 566
month_value                     000124 automatic       fixed bin(17,0)          dcl 59 set ref 832* 833*
multiply                                               builtin function         dcl 181 ref 1391 1391
n1                              000110 automatic       fixed bin(35,0)          dcl 657 set ref 708* 709 717* 718 726 726 730 731
n2                              000111 automatic       fixed bin(35,0)          dcl 657 set ref 720* 720 722 730* 730 734 742 757
n3                              000112 automatic       fixed bin(35,0)          dcl 657 set ref 722* 731* 731 734 758
n_class_names                   001433 automatic       fixed bin(17,0)          dcl 108 set ref 952 958* 958 959 1149 1341*
n_match_strings                 000351 automatic       fixed bin(17,0)          dcl 102 set ref 535 542 549 553 623 629 972 978* 978
                                                                                  979 1045 1146 1340*
n_memo_numbers                  001122 automatic       fixed bin(17,0)          dcl 104 set ref 521 535 542 563 564 608 609 621 749
                                                                                  756* 756 757 758 1146 1340*
nargs                           000101 automatic       fixed bin(17,0)          dcl 47 set ref 667* 693 786 879 900 923 1152 1174
                                                                                  1199 1365* 1426 1426
null                                                   builtin function         dcl 181 ref 203 214 251 253 445 458 1237 1248 1252
                                                                                  1262 1265 1271 1327 1329 1338 1388 1391 1399 1417
option_count                    000117 automatic       fixed bin(17,0)          dcl 659 set ref 1045* 1054 1065 1071 1078
pad1                      0(08) 000176 automatic       bit(28)                  level 2 packed packed unaligned dcl 86 set ref 580*
per_process               0(07) 000174 automatic       bit(1)                   level 2 packed packed unaligned dcl 84 set ref 1043*
per_process_sw                  000142 automatic       bit(1)                   dcl 66 set ref 806* 1043 1140 1350*
person                          001744 automatic       char(32)                 packed unaligned dcl 1315 set ref 1320* 1321
postpone_sw                     000134 automatic       bit(1)                   dcl 64 set ref 339 534 697 814* 879 900 923 1029
                                                                                  1124 1342*
postpone_time                   000206 automatic       fixed bin(71,0)          dcl 90 set ref 353* 811*
print                           000175 automatic       bit(1)                   level 2 packed packed unaligned dcl 85 set ref 362*
                                                                                  366*
print_sw                        000132 automatic       bit(1)                   dcl 64 set ref 277 543 697 818* 879 900 923 1029
                                                                                  1342* 1426 1426
process_memos_sw                000160 automatic       bit(1)                   dcl 72 set ref 263 543 697 820* 1029 1080* 1343*
project                         001754 automatic       char(32)                 packed unaligned dcl 1315 set ref 1320* 1322
range_match_bits                000110 automatic       bit(1)                   array packed unaligned dcl 519 set ref 530* 569* 622
range_match_count               000110 automatic       fixed bin(17,0)          array dcl 521 set ref 532* 570* 570 610
real_action_count               000116 automatic       fixed bin(17,0)          dcl 659 set ref 1062* 1067* 1075* 1078 1083
remains                   0(05) 000174 automatic       bit(1)                   level 2 packed packed unaligned dcl 84 set ref 1039*
remains_sw                      000145 automatic       bit(1)                   dcl 66 set ref 807* 1039 1137 1350*
repeat_count                    000220 automatic       fixed bin(17,0)          dcl 92 set ref 907* 907 910 1045 1349*
repeat_count_sw                 000147 automatic       bit(1)                   dcl 66 set ref 898* 1350*
repeat_string                   000210 automatic       char(32)                 packed unaligned dcl 91 set ref 402* 885 886 886
                                                                                  892* 1091* 1093* 1101* 1109* 1348*
repeat_sw                       000143 automatic       bit(1)                   dcl 66 set ref 870 877* 1037 1090 1140 1350*
repeat_time                     000122 automatic       fixed bin(71,0)          dcl 662 set ref 1091* 1100 1107
repeatsw                  0(03) 000174 automatic       bit(1)                   level 2 packed packed unaligned dcl 84 set ref 1037*
rs                                     based           varying char             dcl 50 set ref 301* 308 308* 308 309* 309 405* 671*
rsl                             000104 automatic       fixed bin(21,0)          dcl 49 set ref 301 308 309 405 667* 671
rsp                             000102 automatic       pointer                  dcl 48 set ref 301 308 308 308 309 309 405 667* 671
rtrim                                                  builtin function         dcl 181 ref 1321 1322
select_flags                    000176 automatic       structure                level 1 dcl 86 set ref 577* 578 579* 586
select_options_specified_sw     000161 automatic       bit(1)                   dcl 73 set ref 542 576 625 631 1054* 1346*
set_bc                    0(01) 000173 automatic       bit(1)                   level 2 packed packed unaligned dcl 83 set ref 1407*
set_flags                       000175 automatic       structure                level 1 dcl 85 set ref 361*
set_memo_sw                     000135 automatic       bit(1)                   dcl 65 set ref 360 773* 1018 1029 1093* 1101* 1107
                                                                                  1124 1127 1131 1137 1140 1143 1146 1149 1219*
                                                                                  1344*
set_pathname_sw                 000136 automatic       bit(1)                   dcl 65 set ref 202 1073* 1345* 1426 1426
single                    0(06) 000174 automatic       bit(1)                   level 2 packed packed unaligned dcl 84 set ref 1038*
single_sw                       000146 automatic       bit(1)                   dcl 66 set ref 808* 1038 1350*
size                                                   builtin function         dcl 1386 in procedure "clean_things_up" ref 1391
                                                                                  1391 1391 1391
size                            000000 stack reference condition                dcl 179 in procedure "memo" ref 719 721 729 732 906
                                                                                  908
start                           000114 automatic       fixed bin(17,0)          dcl 526 in procedure "select_memos" set ref 565* 567
start                           001123 automatic       fixed bin(17,0)          array level 2 in structure "memo_number" packed
                                                                                  packed unaligned dcl 105 in procedure "memo" set
                                                                                  ref 565 611 611* 613* 757*
static_dname                    000034 internal static char(168)                initial packed unaligned dcl 118 set ref 204* 251*
                                                                                  1240* 1246* 1253 1254* 1256 1260* 1263* 1266*
                                                                                  1291* 1301* 1427* 1430*
static_ename                    000106 internal static char(32)                 initial packed unaligned dcl 119 set ref 205* 251*
                                                                                  1240* 1246* 1255* 1257 1260* 1263* 1266* 1291*
                                                                                  1301* 1427* 1431*
static_initialized              000030 internal static bit(1)                   initial dcl 115 set ref 1317 1324* 1418*
static_person                   000125 internal static varying char(32)         initial dcl 125 set ref 993 1255 1321* 1424*
static_pointer                  000032 internal static pointer                  initial dcl 117 set ref 199 203* 209 251 251* 253
                                                                                  253 253 431* 444 1237 1238* 1248* 1252 1260* 1262
                                                                                  1263* 1265 1268 1271 1274* 1278* 1297 1297* 1300
                                                                                  1388 1399 1399* 1417*
static_project                  000136 internal static varying char(32)         initial dcl 126 set ref 1322* 1425*
static_uid                      000116 internal static bit(36)                  initial dcl 120 set ref 206* 251* 1245 1274* 1419*
status_sw                       000154 automatic       bit(1)                   dcl 70 set ref 250 801* 1152 1359*
string                                                 builtin function         dcl 181 set ref 402 402 473* 496* 529* 530* 531* 578
                                                                                  579* 586 586 622* 622 623* 623 623 625* 625 625
                                                                                  630* 630 631* 631 631 635* 635 1036* 1045 1411
                                                                                  1411
string_match_bits               000110 automatic       bit(1)                   array packed unaligned dcl 518 set ref 529* 553 555*
                                                                                  600 623 630
substr                                                 builtin function         dcl 181 ref 702 730 731
sys_info$time_correction_constant
                                000252 external static fixed bin(71,0)          dcl 165 ref 1377
taken                     2            based           bit(36)                  array level 3 dcl 1-15 ref 476 499 552 568 584
temp1                           000120 automatic       fixed bin(17,0)          dcl 56 set ref 402* 405
temp_date                       000122 automatic       fixed bin(71,0)          dcl 58 set ref 929*
temp_time                       000150 automatic       fixed bin(71,0)          dcl 1172 set ref 1184* 1191
temp_uid                        001734 automatic       bit(36)                  dcl 1235 set ref 1238* 1245
term_switch                     000173 automatic       structure                level 1 dcl 83 set ref 1411 1411
terminate                 0(02) 000173 automatic       bit(1)                   level 2 packed packed unaligned dcl 83 set ref 1408*
terminate_file_                 000240 constant        entry                    external dcl 159 ref 1411
terminate_file_switches                based           structure                level 1 packed packed unaligned dcl 3-4
time                      5            based           fixed bin(35,0)          array level 3 dcl 1-15 set ref 353* 499 591 592 593
                                                                                  596
time_now                        000170 automatic       fixed bin(71,0)          dcl 80 set ref 371 1091* 1100 1107 1334* 1335*
timer_manager_$reset_alarm_call 000236 constant        entry                    external dcl 158 ref 1330
to_time                         000204 automatic       fixed bin(71,0)          dcl 89 set ref 593* 860 866* 1018 1019* 1023 1026
                                                                                  1026* 1360*
total_string_match_count        000110 automatic       fixed bin(17,0)          dcl 523 set ref 550* 556* 556
totals_sw                       000156 automatic       bit(1)                   dcl 71 set ref 300 797* 1155 1355*
truncate                        000173 automatic       bit(1)                   level 2 packed packed unaligned dcl 83 set ref 1406*
turn_timer_off_sw               000153 automatic       bit(1)                   dcl 69 set ref 410 799* 1059 1064 1356*
turn_timer_on_sw                000152 automatic       bit(1)                   dcl 69 set ref 412 798* 1059 1064 1079* 1356*
type_match_bits                 000110 automatic       bit(1)                   array packed unaligned dcl 520 set ref 531* 603* 625
                                                                                  631 635
user_info_                      000242 constant        entry                    external dcl 160 ref 1320
user_info_$homedir              000244 constant        entry                    external dcl 161 ref 992 1323
verify                                                 builtin function         dcl 181 ref 708
version                                based           fixed bin(35,0)          level 3 dcl 1-15 set ref 240 253* 1268* 1297 1300
year_value                      000126 automatic       fixed bin(17,0)          dcl 59 set ref 832* 833*
zone_value                      000127 automatic       char(3)                  dcl 60 set ref 832* 833*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 2-33
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 2-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 2-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 2-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 2-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
R_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 2-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 2-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 2-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 2-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 2-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
TERM_FILE_BC                           internal static bit(2)                   initial packed unaligned dcl 3-12
TERM_FILE_DELETE                       internal static bit(5)                   initial packed unaligned dcl 3-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial packed unaligned dcl 3-16
TERM_FILE_TERM                         internal static bit(3)                   initial packed unaligned dcl 3-14
TERM_FILE_TRUNC                        internal static bit(1)                   initial packed unaligned dcl 3-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial packed unaligned dcl 3-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial packed unaligned dcl 3-15
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11

NAMES DECLARED BY EXPLICIT CONTEXT.
ALREADY_HAVE_DATE               007061 constant        label                    dcl 824 ref 844
BADOPT                          010607 constant        label                    dcl 1007 ref 897 943
BAD_CONVERSION                  011752 constant        label                    dcl 1160 set ref 906
BAD_MEMO_NUMBER                 005766 constant        label                    dcl 710 set ref 719 726 729
BAD_REPEAT_COUNT                011756 constant        label                    dcl 1161 ref 910
END_ARGUMENT_LOOP               010653 constant        label                    dcl 1012 ref 879 900 923
LOOP_THROUGH_ARGUMENTS          005665 constant        label                    dcl 693
MAIN_RETURN                     004125 constant        label                    dcl 415 ref 217 225 237 244 259 283 326 346 380 387
                                                                                  397 538 616 682 714 738 746 753 766 783 789 827
                                                                                  839 853 863 874 889 918 935 949 955 969 975 986
                                                                                  1001 1009 1087 1097 1104 1114 1165 1178 1188 1202
                                                                                  1221 1242 1282 1294 1303
MEMO_SEG_ERROR                  012421 constant        label                    dcl 1240 ref 1265 1271 1275
NO_MEMOS_SELECTED               003007 constant        label                    dcl 281 ref 297 322 342
clean_things_up                 013454 constant        entry                    internal dcl 1383 ref 190 415 440 460
from_gmt                        013435 constant        entry                    internal dcl 1372 ref 353 402 402 592 593 1319 1335
get_default_memo_seg            012377 constant        entry                    internal dcl 1231 ref 198 208
get_next_date_arg               012022 constant        entry                    internal dcl 1168 ref 811 830 846 856 866
get_next_string_arg             012225 constant        entry                    internal dcl 1195 ref 883 904 927 944 963 989
inconsistent                    012321 constant        entry                    internal dcl 1213 ref 1059 1065 1071 1121 1124 1127
                                                                                  1131 1134 1137 1140 1143 1146 1149 1152 1155
initialize_memo                 013161 constant        entry                    internal dcl 1311 ref 186 427
memo                            002166 constant        entry                    external dcl 37
memo$alarm_entry                004133 constant        entry                    external dcl 423 ref 1330 1330 1399 1399
process_args                    005566 constant        entry                    internal dcl 648 ref 195
select_all_memos                004430 constant        entry                    internal dcl 466 ref 545
select_mature_memos             004470 constant        entry                    internal dcl 487 ref 450 543
select_memos                    004552 constant        entry                    internal dcl 512 ref 264 278 295 320 340

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     15132       15426   14312       15142
Length     16044   14312       274         402     617         140

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
memo                               1228 external procedure  is an external procedure.  
on unit on line 190                  64 on unit               
on unit on line 440                  64 on unit               
select_all_memos                        internal procedure  shares stack frame of internal procedure select_memos.  
select_mature_memos                  68 internal procedure  is called by several nonquick procedures.  
select_memos                        184 internal procedure  uses auto adjustable storage, and is declared options(non_quick).  
process_args                        462 internal procedure  enables or reverts conditions.  
on unit on line 719                  64 on unit               
on unit on line 729                  64 on unit               
on unit on line 906                  64 on unit               
get_next_date_arg                       internal procedure  shares stack frame of internal procedure process_args.  
get_next_string_arg                     internal procedure  shares stack frame of internal procedure process_args.  
inconsistent                            internal procedure  shares stack frame of internal procedure process_args.  
get_default_memo_seg                    internal procedure  shares stack frame of external procedure memo.  
initialize_memo                         internal procedure  shares stack frame of external procedure memo.  
from_gmt                             65 internal procedure  is called during a stack extension.  
clean_things_up                     124 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 default_memo_directory      memo
000030 static_initialized          memo
000032 static_pointer              memo
000034 static_dname                memo
000106 static_ename                memo
000116 static_uid                  memo
000117 memo_timers_enabled         memo
000120 memo_invocation_count       memo
000122 end_of_time                 memo
000124 end_of_memo_time            memo
000125 static_person               memo
000136 static_project              memo

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
from_gmt                 000100 memo_time                   from_gmt
memo                     000100 code                        memo
                         000101 nargs                       memo
                         000102 rsp                         memo
                         000104 rsl                         memo
                         000106 P_arg_list                  memo
                         000110 P_expiration_string         memo
                         000112 L_expiration_string         memo
                         000114 complain                    memo
                         000120 temp1                       memo
                         000121 idx                         memo
                         000122 temp_date                   memo
                         000124 month_value                 memo
                         000125 day_of_month                memo
                         000126 year_value                  memo
                         000127 zone_value                  memo
                         000130 fs_mode                     memo
                         000131 list_sw                     memo
                         000132 print_sw                    memo
                         000133 delete_sw                   memo
                         000134 postpone_sw                 memo
                         000135 set_memo_sw                 memo
                         000136 set_pathname_sw             memo
                         000137 alarm_sw                    memo
                         000140 invisible_sw                memo
                         000141 call_sw                     memo
                         000142 per_process_sw              memo
                         000143 repeat_sw                   memo
                         000144 expires_sw                  memo
                         000145 remains_sw                  memo
                         000146 single_sw                   memo
                         000147 repeat_count_sw             memo
                         000150 mature_sw                   memo
                         000151 immature_sw                 memo
                         000152 turn_timer_on_sw            memo
                         000153 turn_timer_off_sw           memo
                         000154 status_sw                   memo
                         000155 brief_sw                    memo
                         000156 totals_sw                   memo
                         000157 force_sw                    memo
                         000160 process_memos_sw            memo
                         000161 select_options_specified_sw memo
                         000162 af_sw                       memo
                         000163 memo_segment_modified       memo
                         000164 have_read_access            memo
                         000165 have_write_access           memo
                         000166 complained                  memo
                         000170 time_now                    memo
                         000172 memo_time_now               memo
                         000173 term_switch                 memo
                         000174 arg_flags                   memo
                         000175 set_flags                   memo
                         000176 select_flags                memo
                         000200 maturity_time               memo
                         000202 from_time                   memo
                         000204 to_time                     memo
                         000206 postpone_time               memo
                         000210 repeat_string               memo
                         000220 repeat_count                memo
                         000222 expiration_time             memo
                         000224 expiration_delta            memo
                         000225 memo_text                   memo
                         000267 dname                       memo
                         000341 ename                       memo
                         000351 n_match_strings             memo
                         000352 match_string                memo
                         001122 n_memo_numbers              memo
                         001123 memo_number                 memo
                         001433 n_class_names               memo
                         001434 class_name                  memo
                         001674 memo_match_count            memo
                         001675 memo_bits                   memo
                         001704 memo_segment_ptr            memo
                         001734 temp_uid                    get_default_memo_seg
                         001744 person                      initialize_memo
                         001754 project                     initialize_memo
process_args             000100 argno                       process_args
                         000101 al                          process_args
                         000102 al1                         process_args
                         000104 ap                          process_args
                         000106 ap1                         process_args
                         000110 n1                          process_args
                         000111 n2                          process_args
                         000112 n3                          process_args
                         000113 collecting_memo_sw          process_args
                         000114 collecting_numbers_sw       process_args
                         000115 action_count                process_args
                         000116 real_action_count           process_args
                         000117 option_count                process_args
                         000120 might_set_sw                process_args
                         000121 answer                      process_args
                         000122 repeat_time                 process_args
                         000150 temp_time                   get_next_date_arg
select_mature_memos      000100 idx                         select_mature_memos
select_memos             000106 idx                         select_all_memos
                         000110 type_match_bits             select_memos
                         000110 string_match_bits           select_memos
                         000110 total_string_match_count    select_memos
                         000110 range_match_count           select_memos
                         000110 range_match_bits            select_memos
                         000111 idx                         select_memos
                         000112 jdx                         select_memos
                         000113 matched                     select_memos
                         000114 start                       select_memos
                         000115 finish                      select_memos

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              r_ne_as             alloc_char_temp     alloc_bit_temp      call_ent_var_desc
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          tra_ext_1
alloc_auto_adj      mpfx2               enable_op           shorten_stack       ext_entry           int_entry
set_chars_eis       index_chars_eis     any_to_any_truncate_divide_fx3          clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
active_fnc_err_               com_err_                      command_query_$yes_no         convert_date_to_binary_
convert_date_to_binary_$relative                            cu_$af_return_arg_rel         cu_$arg_list_ptr
cu_$arg_ptr_rel               decode_clock_value_           encode_clock_value_           expand_pathname_$add_suffix
hcs_$fs_get_mode              hcs_$get_uid_seg              hcs_$initiate_count           hcs_$make_seg
hcs_$set_bc_seg               ioa_                          ioa_$ioa_switch               iox_$control
memo_delete_                  memo_list_                    memo_list_$format_time        memo_process_memos_
memo_set_                     memo_timer_set_               memo_upgrade_memo_segment_    memo_util_$end_of_time
terminate_file_               timer_manager_$reset_alarm_call                             user_info_
user_info_$homedir

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_conversion   error_table_$badopt           error_table_$inconsistent     error_table_$no_r_permission
error_table_$no_w_permission  error_table_$noarg            error_table_$noentry          error_table_$not_act_fnc
iox_$error_output             iox_$user_io                  sys_info$time_correction_constant




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     77 002133       113 002134       268 002143       454 002153        37 002165       186 002174       188 002175
    190 002176       192 002220       193 002222       195 002230       197 002234       198 002240       199 002241
    200 002244       202 002245       203 002247       204 002252       205 002255       206 002260       208 002261
    209 002262       210 002265       213 002266       214 002331       215 002335       216 002367       217 002371
    221 002372       222 002405       223 002407       224 002440       225 002442       228 002443       230 002460
    233 002467       234 002471       236 002524       237 002526       240 002527       241 002532       243 002565
    244 002567       250 002570       251 002572       253 002637       257 002667       258 002707       259 002711
    263 002712       264 002714       266 002720       267 002722       268 002724       269 002751       271 002752
    273 002776       277 002777       278 003001       280 003005       281 003007       282 003034       283 003036
    286 003037       287 003047       288 003054       290 003104       291 003106       294 003107       295 003111
    297 003115       300 003121       301 003123       302 003157       303 003177       305 003200       306 003211
    307 003216       308 003220       309 003232       310 003271       311 003272       313 003313       314 003315
    319 003316       320 003320       322 003324       324 003326       325 003331       326 003364       329 003365
    331 003367       332 003377       333 003404       335 003417       336 003421       339 003422       340 003424
    342 003430       344 003432       345 003435       346 003470       349 003471       351 003473       352 003503
    353 003510       355 003522       356 003524       360 003525       361 003530       362 003532       364 003534
    365 003536       366 003540       369 003542       371 003547       373 003556       374 003560       377 003607
    378 003611       379 003643       380 003645       383 003646       384 003651       386 003721       387 003723
    390 003724       391 003731       393 003732       395 003733       396 003736       397 003771       400 003772
    402 003774       405 004060       410 004114       412 004120       415 004125       418 004131       423 004132
    427 004141       429 004142       431 004147       432 004161       433 004163       434 004214       437 004215
    440 004225       442 004247       444 004251       445 004253       446 004257       447 004303       450 004304
    452 004314       453 004316       454 004320       455 004345       456 004346       458 004372       460 004423
    462 004427       466 004430       472 004431       473 004433       475 004440       476 004451       477 004456
    478 004457       480 004464       482 004466       487 004467       495 004475       496 004477       498 004504
    499 004515       502 004540       503 004541       505 004546       507 004550       512 004551       518 004557
    519 004570       520 004577       521 004606       529 004612       530 004617       531 004624       532 004631
    534 004643       535 004650       536 004654       537 004700       538 004703       542 004706       543 004714
    545 004732       546 004733       549 004734       550 004736       551 004737       552 004747       553 004754
    554 004771       555 005007       556 005012       558 005013       560 005015       563 005017       564 005022
    565 005031       566 005050       567 005057       568 005065       569 005072       570 005077       572 005102
    573 005104       576 005106       577 005111       578 005113       579 005117       580 005121       583 005123
    584 005133       585 005140       586 005141       589 005147       590 005154       591 005156       592 005165
    593 005206       596 005231       600 005243       603 005253       605 005257       608 005261       609 005264
    610 005273       611 005276       613 005341       615 005377       616 005402       618 005405       621 005407
    622 005412       623 005421       625 005445       627 005472       629 005474       630 005476       631 005505
    633 005531       635 005533       637 005542       638 005543       639 005553       641 005562       643 005564
    648 005565       667 005573       668 005612       669 005615       670 005617       671 005624       672 005625
    674 005626       675 005631       676 005632       677 005636       680 005637       681 005653       682 005656
    686 005661       687 005663       688 005664       693 005665       696 005675       697 005716       698 005727
    699 005730       702 005732       703 005741       706 005747       707 005751       708 005752       709 005765
    710 005766       711 005772       713 006024       714 006027       717 006032       718 006044       719 006045
    720 006071       721 006101       722 006103       723 006105       726 006106       729 006112       730 006136
    731 006147       732 006162       734 006164       735 006167       737 006223       738 006226       742 006231
    743 006233       745 006260       746 006263       749 006266       750 006272       752 006324       753 006327
    756 006332       757 006333       758 006340       759 006343       761 006344       762 006346       763 006353
    765 006405       766 006410       769 006413       771 006424       772 006436       773 006440       776 006441
    778 006442       779 006447       780 006451       782 006475       783 006500       786 006503       787 006506
    788 006532       789 006535       792 006540       793 006542       795 006543       796 006556       797 006570
    798 006607       799 006616       800 006625       801 006640       803 006653       804 006666       805 006701
    806 006710       807 006723       808 006736       810 006751       811 006761       813 006767       814 006771
    815 006773       817 006774       818 007007       819 007022       820 007035       822 007044       823 007054
    824 007061       826 007112       827 007115       830 007120       832 007126       833 007155       836 007217
    837 007222       838 007260       839 007263       841 007266       843 007267       844 007277       846 007304
    847 007312       849 007313       850 007323       851 007330       852 007354       853 007357       856 007362
    857 007370       859 007371       860 007375       861 007402       862 007426       863 007431       866 007434
    867 007442       869 007443       870 007457       871 007461       873 007511       874 007514       877 007517
    879 007521       883 007526       885 007527       886 007532       888 007571       889 007574       892 007577
    893 007604       896 007605       897 007611       898 007613       900 007614       904 007621       906 007622
    907 007646       908 007657       910 007661       911 007665       913 007666       914 007706       915 007710
    917 007734       918 007737       921 007742       923 007744       927 007751       929 007752       930 007777
    931 010002       934 010047       935 010052       938 010055       939 010057       940 010061       942 010062
    943 010066       944 010070       946 010071       947 010074       948 010127       949 010132       952 010135
    953 010141       954 010173       955 010176       958 010201       959 010202       960 010212       962 010213
    963 010217       965 010220       966 010223       968 010256       969 010261       972 010264       973 010270
    974 010322       975 010325       978 010330       979 010331       980 010346       982 010347       983 010367
    984 010373       985 010423       986 010426       989 010431       991 010432       992 010444       993 010456
    994 010476       997 010500       998 010537       999 010542      1000 010600      1001 010603      1004 010606
   1007 010607      1008 010645      1009 010650      1012 010653      1018 010655      1019 010675      1020 010677
   1023 010701      1026 010712      1029 010724      1036 010753      1037 010754      1038 010761      1039 010766
   1040 010773      1041 011000      1042 011005      1043 011012      1045 011017      1054 011072      1059 011074
   1062 011111      1064 011113      1065 011121      1067 011131      1070 011133      1071 011142      1073 011152
   1074 011155      1075 011157      1078 011161      1079 011165      1080 011170      1081 011171      1083 011172
   1084 011174      1086 011221      1087 011224      1090 011227      1091 011232      1092 011256      1093 011261
   1096 011313      1097 011316      1100 011321      1101 011324      1103 011357      1104 011362      1107 011365
   1109 011402      1111 011442      1112 011445      1113 011475      1114 011500      1121 011503      1124 011514
   1127 011535      1131 011560      1134 011576      1137 011617      1140 011635      1143 011653      1146 011667
   1149 011705      1152 011722      1155 011736      1158 011751      1160 011752      1161 011756      1164 012014
   1165 012017      1168 012022      1174 012024      1175 012030      1177 012067      1178 012072      1181 012075
   1182 012076      1184 012116      1185 012143      1186 012146      1187 012213      1188 012216      1191 012221
   1195 012225      1199 012226      1200 012232      1201 012271      1202 012274      1205 012277      1206 012300
   1208 012320      1213 012321      1219 012332      1220 012371      1221 012374      1231 012377      1237 012400
   1238 012405      1239 012417      1240 012421      1241 012453      1242 012455      1245 012456      1246 012462
   1248 012515      1252 012520      1253 012524      1254 012530      1255 012533      1256 012551      1257 012555
   1260 012560      1262 012622      1263 012632      1265 012670      1266 012675      1268 012726      1271 012731
   1274 012735      1275 012747      1278 012751      1279 012764      1280 012766      1281 013017      1282 013021
   1285 013022      1287 013037      1290 013046      1291 013050      1294 013103      1297 013104      1300 013116
   1301 013122      1302 013155      1303 013157      1306 013160      1311 013161      1317 013162      1318 013165
   1319 013173      1320 013204      1321 013224      1322 013245      1323 013265      1324 013275      1327 013300
   1328 013302      1329 013303      1330 013304      1332 013316      1333 013317      1334 013333      1335 013335
   1337 013345      1338 013346      1339 013350      1340 013351      1341 013353      1342 013354      1343 013360
   1344 013361      1345 013362      1346 013363      1347 013364      1348 013366      1349 013371      1350 013373
   1352 013404      1353 013412      1354 013413      1355 013414      1356 013415      1357 013417      1358 013420
   1359 013421      1360 013422      1361 013425      1362 013427      1363 013430      1364 013431      1365 013432
   1367 013433      1372 013434      1377 013442      1379 013451      1383 013453      1388 013461      1390 013465
   1391 013473      1396 013525      1397 013530      1399 013533      1403 013560      1406 013561      1407 013563
   1408 013565      1409 013567      1410 013571      1411 013573      1413 013623      1417 013661      1418 013664
   1419 013665      1420 013666      1421 013667      1422 013670      1423 013672      1424 013674      1425 013675
   1426 013676      1427 013723      1430 013755      1431 013761      1434 013764


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
