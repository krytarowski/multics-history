	COMPILATION LISTING OF SEGMENT overlay
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 02/02/88  1649.4 mst Tue
	    Options: optimize map

        1 /* ******************************************************
        2*   *                                                    *
        3*   *                                                    *
        4*   * Copyright (c) 1972 by Massachusetts Institute of   *
        5*   * Technology and Honeywell Information Systems, Inc. *
        6*   *                                                    *
        7*   *                                                    *
        8*   ****************************************************** */
        9 
       10 overlay: ov: proc;
       11 
       12 /* OVERLAY - overlay multiple segments.
       13*
       14*   THVV */
       15 /* Usage message with no args; reject bad control args 08/14/80 S. Herbst */
       16 /* Change -in to -ind, add clean_up handler, rename variables 02/18/82 L. Baldwin */
       17 /* Change to allow the archive convention.  07/08/84 R. Roach */
       18 
  1     1 
  1     2 /* BEGIN INCLUDE FILE ... prt_conv_info.incl.pl1 */
  1     3 /* Modified: 12 September 1980 by G. Palter */
  1     4 
  1     5 
  1     6 /****^  HISTORY COMMENTS:
  1     7*  1) change(87-05-10,Gilcrease), approve(87-07-31,MCR7686),
  1     8*     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
  1     9*     Add modes.line_nbrs, flags.(eol eof)  bits for eor -nb.
  1    10*                                                   END HISTORY COMMENTS */
  1    11 
  1    12 
  1    13 dcl  pcip ptr;					/* pointer to conversion info structure */
  1    14 
  1    15 dcl 1 pci based (pcip) aligned,			/* printer conversion info structure */
  1    16     2 cv_proc ptr,					/* pointer to character conversion procedure */
  1    17     2 lmarg fixed bin,				/* left margin indentation */
  1    18     2 rmarg fixed bin,				/* right margin limit */
  1    19     2 page_length fixed bin,				/* number of lines on page */
  1    20     2 phys_line_length fixed bin,			/* physical width of paper */
  1    21     2 phys_page_length fixed bin,			/* physical length of paper */
  1    22     2 lpi fixed bin,				/* lines per inch */
  1    23     2 sheets_per_page fixed bin,			/* sheets of paper per logical page */
  1    24     2 line_count fixed bin,				/* count of converted lines */
  1    25     2 page_count fixed bin,				/* count of converted pages */
  1    26     2 func fixed bin,				/* special conversion function */
  1    27 						/* 0 => normal conversion */
  1    28 						/* 1 => change NL to FF */
  1    29 						/* 2 => change NL to top inside page */
  1    30 						/* 3 => change NL to end of page */
  1    31                                                             /* 4 => change NL to top of outside page */
  1    32     (2 modes,					/* conversion modes */
  1    33      3 overflow_off bit (1),				/* "1"b to suppress end of page overflow */
  1    34       3 single_space bit (1),				/* "1"b to change all forms advance chars to NL */
  1    35       3 non_edited bit (1),				/* "1"b to print ASCII control chars */
  1    36       3 truncate bit (1),				/* "1"b to truncate lines that are too long */
  1    37       3 esc bit (1),				/* "1"b to process ESC character */
  1    38       3 ctl_char bit (1),				/* "1"b to output control characters */
  1    39       3 line_nbrs bit (1),				/* "1"b to output line numbers */
  1    40       3 pci_pad bit (5),
  1    41     2 flags,					/* flags internal to prt_conv_ */
  1    42       3 ignore_next_ff bit (1),			/* ON => prt_conv_ just output a FF; ignore next character if
  1    43*						   it's a FF */
  1    44       3 eol bit (1),				/* "1"b = end-of-line encountered */
  1    45       3 eof bit (1),				/* "1"b = end-of-segment encountered */
  1    46       3 flags_pad bit (3),
  1    47     2 coroutine_modes,
  1    48       3 upper_case bit(1),				/* "1"b to convert to upper case */
  1    49       3 ht bit(1),					/* "1"b to skip tab conversion */
  1    50       3 coroutine_pad bit(13),
  1    51       3 slew_table_idx bit(3) ) unal,			/* slew table index */
  1    52     2 top_label_line char (136),			/* contains an optional top of page label */
  1    53     2 bot_label_line char (136),			/* contains an optional bottom of page label */
  1    54     2 top_label_length fixed bin,			/* length of top label line */
  1    55     2 bot_label_length fixed bin,			/* length of bottom label line */
  1    56     2 form_stops (256) unal,				/* logical form stops */
  1    57       3 lbits bit (9),				/* leftmost bits */
  1    58       3 rbits bit (9),				/* rightmost bits */
  1    59 
  1    60 /* The following items are for internal use by the print conversion procedure.
  1    61*   They should be zeroed once and then never referenced again.		*/
  1    62 
  1    63     2 level fixed bin,				/* overstrike level */
  1    64     2 pos fixed bin,				/* print position at end of incomplete line */
  1    65     2 line fixed bin,				/* current line number */
  1    66     2 slew_residue fixed bin,				/* number of lines remaining to be slewed */
  1    67     2 label_nelem fixed bin,				/* characters remaining in label */
  1    68     2 label_wksp ptr,				/* pointer to label being processed */
  1    69     2 sav_pos fixed bin,				/* position saved during label processing */
  1    70     2 esc_state fixed bin,				/* state of ESC processing */
  1    71     2 esc_num fixed bin,				/* number following ESC sequence */
  1    72     2 temp bit (36);				/* conversion proc temporary */
  1    73 
  1    74 /* End of include file ...... prt_conv_info.incl.pl1 */
  1    75 
       19 
  2     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  2     2*
  2     3*   Values for the "access mode" argument so often used in hardcore
  2     4*   James R. Davis 26 Jan 81  MCR 4844
  2     5*   Added constants for SM access 4/28/82 Jay Pattin
  2     6*   Added text strings 03/19/85 Chris Jones
  2     7**/
  2     8 
  2     9 
  2    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  2    11 dcl	(
  2    12 	N_ACCESS		   init ("000"b),
  2    13 	R_ACCESS		   init ("100"b),
  2    14 	E_ACCESS		   init ("010"b),
  2    15 	W_ACCESS		   init ("001"b),
  2    16 	RE_ACCESS		   init ("110"b),
  2    17 	REW_ACCESS	   init ("111"b),
  2    18 	RW_ACCESS		   init ("101"b),
  2    19 	S_ACCESS		   init ("100"b),
  2    20 	M_ACCESS		   init ("010"b),
  2    21 	A_ACCESS		   init ("001"b),
  2    22 	SA_ACCESS		   init ("101"b),
  2    23 	SM_ACCESS		   init ("110"b),
  2    24 	SMA_ACCESS	   init ("111"b)
  2    25 	)		   bit (3) internal static options (constant);
  2    26 
  2    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  2    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  2    29 
  2    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  2    31 			   static options (constant);
  2    32 
  2    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  2    34 			   static options (constant);
  2    35 
  2    36 dcl	(
  2    37 	N_ACCESS_BIN	   init (00000b),
  2    38 	R_ACCESS_BIN	   init (01000b),
  2    39 	E_ACCESS_BIN	   init (00100b),
  2    40 	W_ACCESS_BIN	   init (00010b),
  2    41 	RW_ACCESS_BIN	   init (01010b),
  2    42 	RE_ACCESS_BIN	   init (01100b),
  2    43 	REW_ACCESS_BIN	   init (01110b),
  2    44 	S_ACCESS_BIN	   init (01000b),
  2    45 	M_ACCESS_BIN	   init (00010b),
  2    46 	A_ACCESS_BIN	   init (00001b),
  2    47 	SA_ACCESS_BIN	   init (01001b),
  2    48 	SM_ACCESS_BIN	   init (01010b),
  2    49 	SMA_ACCESS_BIN	   init (01011b)
  2    50 	)		   fixed bin (5) internal static options (constant);
  2    51 
  2    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
       20 
       21 
       22 dcl  BEAD_COUNT fixed bin;
       23 dcl  NL char (1) int static options (constant) init ("
       24 "),
       25      NLVTFF char (3) int static options (constant) init ("
       26 "),
       27      SP char (1) int static options (constant) init (" "),
       28      BS char (1) int static options (constant) init (""),
       29      VT char (1) int static options (constant) init (""),
       30      FF char (1) int static options (constant) init ("");
       31 
       32 dcl  obuf char (BEAD_COUNT+1) based (obuf_ptr) aligned;
       33 dcl  system_area area (1024) based (area_ptr);
       34 dcl 1 bead (BEAD_COUNT) based (bead_ptr) aligned,
       35     2 loc fixed bin (26) unal,
       36     2 char char (1) unal;
       37 dcl  seg char (curr_seg_len) based (curr_seg_ptr) aligned;
       38 dcl  arg char (arg_len) based (arg_ptr) unaligned;
       39 
       40 dcl  slew char (1);
       41 dcl  cpt char (32);
       42 dcl  en char (32);
       43 dcl  dn char (168);
       44 dcl  obuf_storage char (513);
       45 dcl  output char (4096);
       46 
       47 dcl  eof (10) bit (1);
       48 
       49 dcl (area_ptr, arg_ptr, bead_ptr, obuf_ptr, curr_ptr, curr_seg_ptr) ptr;
       50 dcl  info_ptr (10) ptr;
       51 dcl  seg_ptr (10) ptr init ((10) null);
       52 dcl (temp_ptr, temp1_ptr) ptr init (null);
       53 
       54 dcl (arg_count, arg_no, arg_len) fixed bin;
       55 dcl (i, ii, j, k, m, n) fixed bin;
       56 dcl  nchars fixed bin;
       57 dcl (next_line, curr_line) fixed bin;
       58 dcl  neof fixed bin;
       59 dcl  file_count fixed bin;
       60 dcl  col_no fixed bin;
       61 dcl  nxline (10) fixed bin init ((10)0);
       62 dcl  ocount fixed bin;
       63 dcl  offset (10) fixed bin;
       64 dcl  page_len fixed bin init (60);
       65 dcl  storage (512) fixed bin;
       66 
       67 dcl  io fixed bin (21);
       68 dcl  curr_seg_len fixed bin (21);
       69 dcl  seg_len (10) fixed bin (21);
       70 dcl  line_no (10) fixed bin (21);
       71 dcl  bit_count fixed bin (24);
       72 dcl  code fixed bin (35);
       73 
       74 dcl  error_table_$badopt fixed bin (35) ext;
       75 dcl  iox_$user_output ptr ext;
       76 dcl  print_conv_$print_conv_ ext;
       77 
       78 dcl (com_err_, com_err_$suppress_name) entry options (variable);
       79 dcl  cu_$arg_count entry (fixed bin, fixed bin (35));
       80 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
       81 dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin);
       82 dcl  expand_pathname_$component entry (char(*), char(*), char(*), char(*), fixed bin(35));
       83 dcl  get_system_free_area_ entry () returns (ptr);
       84 dcl  hcs_$terminate_noname entry (ptr, fixed bin (35));
       85 dcl  initiate_file_$component entry (char(*), char(*), char(*), bit(*), ptr, fixed bin(24), fixed bin(35));
       86 dcl  iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35));
       87 dcl  prt_conv_ entry (ptr, fixed bin, ptr, fixed bin, ptr);
       88 
       89 dcl (addr, divide, hbound, length, min, mod, null, search, string, substr, unspec) builtin;
       90 dcl  cleanup condition;
       91 
       92 /* ======================================================= */
       93 
       94 	area_ptr = get_system_free_area_ ();
       95 
       96 	file_count = 0;
       97 	BEAD_COUNT = hbound (storage, 1);		/* set the initial values */
       98 	bead_ptr = addr (storage);
       99 	obuf_ptr = addr (obuf_storage);
      100 
      101 	call cu_$arg_count (arg_count, code);
      102 	if code ^= 0 then do;
      103 	     call com_err_ (code, "overlay");
      104 	     return;
      105 	end;
      106 	if arg_count = 0 then do;
      107 	     call com_err_$suppress_name (0, "overlay", "Usage:  overlay paths {-control_args}");
      108 	     return;
      109 	end;
      110 
      111 	do arg_no = 1 to arg_count;
      112 	     call cu_$arg_ptr (arg_no, arg_ptr, arg_len, code);
      113 	     if arg = "-page_length" | arg = "-pl" then do;
      114 		arg_no = arg_no + 1;
      115 		call cu_$arg_ptr (arg_no, arg_ptr, arg_len, code);
      116 		if code ^= 0 then do;
      117 ERROR:		     call com_err_ (code, "overlay", "^a", arg);
      118 		     return;
      119 		end;
      120 		page_len = cv_dec_check_ (arg, code);
      121 		if code ^= 0 then do;
      122 		     call com_err_ (0, "overlay", "Invalid integer argument ^a for -page_length", arg);
      123 		     return;
      124 		end;
      125 	     end;
      126 	     else if arg = "-indent" | arg = "-ind" | arg = "-in" then do;
      127 		arg_no = arg_no + 1;
      128 		call cu_$arg_ptr (arg_no, arg_ptr, arg_len, code);
      129 		if code ^= 0 then go to ERROR;
      130 		offset (file_count) = cv_dec_check_ (arg, code);
      131 		if code ^= 0 then do;
      132 		     call com_err_ (0, "overlay", "Invalid integer argument ^a for -indent", arg);
      133 		     return;
      134 		end;
      135 	     end;
      136 	     else if substr (arg, 1, 1) = "-" then do;
      137 		code = error_table_$badopt;
      138 		go to ERROR;
      139 	     end;
      140 	     else do;
      141 		file_count = file_count + 1;
      142 		if file_count > hbound (seg_ptr, 1) then do;
      143 		     call com_err_ (0, "overlay", "Number of files exceeds implementation maximum of ^d", hbound (seg_ptr, 1));
      144 		     return;
      145 		end;
      146 
      147 		call expand_pathname_$component (arg, dn, en, cpt, code);
      148 		if code ^= 0 then go to ERROR;
      149 
      150 		allocate pci set (info_ptr (file_count)) in (system_area);
      151 		call init_pci (info_ptr (file_count));
      152 
      153 		offset (file_count) = 0;
      154 		line_no (file_count) = 1;
      155 		seg_ptr (file_count) = null;
      156 
      157 		call initiate_file_$component (dn, en, cpt, R_ACCESS, seg_ptr (file_count), bit_count, code);
      158 		if code ^= 0 then go to ERROR;
      159 		seg_len (file_count) = divide (bit_count, 9, 17, 0);
      160 	     end;
      161 	end;
      162 
      163 	if file_count = 0 then do;
      164 	     call com_err_$suppress_name (0, "overlay", "Usage:  overlay paths {-control_args}");
      165 	     return;
      166 	end;
      167 
      168 	on cleanup call clean_up;
      169 
      170 	do i = 1 to file_count;
      171 	     info_ptr (i) -> pci.page_length = page_len;
      172 	     info_ptr (i) -> pci.phys_page_length = page_len;
      173 	     info_ptr (i) -> pci.overflow_off = "0"b;
      174 	end;
      175 
      176 	neof = 0;					/* Initialize counters */
      177 	curr_line = 1;
      178 	eof (*) = "0"b;
      179 
      180 	do while (neof < file_count);			/* Stop when end of all input */
      181 
      182 	     nchars = 0;				/* number of chars in this line */
      183 	     next_line = 1 + page_len * divide (curr_line+page_len-1, page_len, 17, 0);
      184 
      185 	     do i = 1 to file_count;			/* Take input from all segs */
      186 		if eof (i) then go to SKIP;
      187 		if curr_line < nxline (i) then go to SKIP;
      188 
      189 		curr_seg_len = seg_len (i);		/* Get input seg length */
      190 		curr_seg_ptr = seg_ptr (i);		/* .. ptr */
      191 		curr_ptr = addr (substr (seg, line_no (i), 1)); /* .. ptr to current loc */
      192 		n = search (substr (seg, line_no (i)), NLVTFF); /* .. loc of end of input line */
      193 		if n = 0 then n = seg_len (i) - line_no (i);
      194 		line_no (i) = line_no (i) + n;
      195 		if line_no (i) >= seg_len (i) then do;
      196 		     eof (i) = "1"b;		/* ignore this seg from now on */
      197 		     neof = neof + 1;
      198 		end;
      199 
      200 		do while (n > 0);			/* Normalize line */
      201 		     call prt_conv_ (curr_ptr, n, addr (obuf), ocount, info_ptr (i));
      202 		     do j = 1 to ocount-1;
      203 			if substr (obuf, j, 1) ^= " " then do;
      204 			     nchars = nchars + 1;	/* Save each character */
      205 			     if nchars > BEAD_COUNT then call MORE_ROOM;
      206 			     bead (nchars).char = substr (obuf, j, 1);
      207 			     bead (nchars).loc = j + offset (i);
      208 			end;
      209 		     end;
      210 		end;
      211 
      212 		slew = substr (obuf, ocount, 1);	/* Deal with slew */
      213 		if slew = FF then do;
      214 		     nxline (i) = 1 + page_len * divide (curr_line+page_len-1, page_len, 17, 0);
      215 		end;
      216 		else if slew = VT then do;
      217 		     nxline (i) = 1 + 10 * divide (curr_line+9, 10, 17, 0);
      218 		end;
      219 		else if slew = NL then do;		/* Can reach vertical tabstop via NL's */
      220 		     nxline (i) = curr_line+1;
      221 		end;
      222 		next_line = min (next_line, nxline (i));
      223 SKIP:	     end;					/* End loop on input files. one line assembled */
      224 	     call sort;				/* Order chars on line */
      225 	     io = 0;				/* output counter */
      226 	     col_no = 1;				/* column */
      227 	     do k = 1 to nchars;			/* put out all chars */
      228 		m = bead (k).loc - col_no;		/* compute white space */
      229 		if m > 0 then do ii = 1 to m;		/* if going right */
      230 		     io = io + 1;
      231 		     substr (output, io, 1) = SP;
      232 		end;
      233 		if m < 0 then do;			/* if going left (should be only one) */
      234 		     io = io + 1;
      235 		     substr (output, io, 1) = BS;
      236 		end;
      237 		io = io + 1;			/* Now put out char */
      238 		substr (output, io, 1) = bead (k).char;
      239 		col_no = bead (k).loc + 1;		/* remember last used column */
      240 	     end;
      241 	     io = io + 1;				/* output slew char */
      242 	     if next_line = curr_line+1 then substr (output, io, 1) = NL;
      243 	     else if mod (next_line-1, page_len) = 0 then substr (output, io, 1) = FF;
      244 	     else substr (output, io, 1) = VT;
      245 	     call iox_$put_chars (iox_$user_output, addr (output), io, (0));
      246 	     curr_line = next_line;
      247 
      248 	end;
      249 
      250 	call clean_up;
      251 	return;
      252 
      253 /* ------------------------------------------------------- */
      254 
      255 sort:	proc;
      256 
      257 dcl  temp fixed bin;
      258 dcl  swaps fixed bin;
      259 dcl  d fixed bin;
      260 dcl  i fixed bin;
      261 
      262 dcl  vec (BEAD_COUNT) fixed bin based (bead_ptr);
      263 
      264 	     d = nchars;
      265 PASS:	     swaps = 0;
      266 	     d = divide (d + 1, 2, 17, 0);
      267 	     do i = 1 to nchars - d;
      268 		if vec (i) > vec (i+d) then do;
      269 		     swaps = swaps + 1;
      270 		     temp = vec (i);
      271 		     vec (i) = vec (i+d);
      272 		     vec (i+d) = temp;
      273 		end;
      274 	     end;
      275 	     if d > 1 then go to PASS;
      276 	     if swaps > 0 then go to PASS;
      277 
      278 	end sort;
      279 
      280 init_pci:	proc (p);
      281 
      282 dcl  p ptr;
      283 
      284 	     unspec (p -> pci) = "0"b;		/* clear everything */
      285 	     p -> pci.cv_proc = addr (print_conv_$print_conv_);
      286 	     p -> pci.level = 0;
      287 	     p -> pci.pos = 0;
      288 	     p -> pci.lmarg = 0;
      289 	     p -> pci.rmarg = length (obuf) - 1;
      290 	     p -> pci.phys_line_length = length (obuf) - 1;
      291 	     p -> pci.page_length = 60;
      292 	     p -> pci.phys_page_length = 66;
      293 	     p -> pci.lpi = 6;
      294 	     p -> pci.sheets_per_page = 1;
      295 	     p -> pci.line_count = 0;
      296 	     p -> pci.page_count = 0;
      297 	     string (p -> pci.modes) = ""b;
      298 	     p -> pci.top_label_line = "";
      299 	     p -> pci.bot_label_line = "";
      300 	     p -> pci.top_label_length = 0;
      301 	     p -> pci.bot_label_length = 0;
      302 	     p -> pci.line = 1;
      303 	     p -> pci.slew_residue = 0;
      304 	     p -> pci.label_nelem = 0;
      305 	     p -> pci.sav_pos = 0;
      306 	     p -> pci.func = 0;
      307 	     p -> pci.temp = "0"b;
      308 	     p -> pci.overflow_off = "1"b;
      309 
      310 	end init_pci;
      311 
      312 MORE_ROOM: proc;
      313 
      314 dcl  k fixed bin;
      315 
      316 	     k = BEAD_COUNT;
      317 	     BEAD_COUNT = 2*BEAD_COUNT;
      318 	     allocate bead set (temp_ptr) in (system_area);
      319 	     allocate obuf set (temp1_ptr) in (system_area);
      320 	     BEAD_COUNT = k;
      321 	     temp_ptr -> bead = bead;
      322 	     temp1_ptr -> obuf = obuf;
      323 	     if bead_ptr ^= addr (storage) then free bead;
      324 	     if obuf_ptr ^= addr (obuf_storage) then free obuf;
      325 	     BEAD_COUNT = 2*BEAD_COUNT;
      326 	     bead_ptr = temp_ptr;
      327 	     obuf_ptr = temp1_ptr;
      328 
      329 	end MORE_ROOM;
      330 
      331 clean_up:	proc;
      332 
      333 	     do i = 1 to file_count;
      334 		if seg_ptr (i) ^= null then call hcs_$terminate_noname (seg_ptr (i), code);
      335 		free info_ptr (i) -> pci;
      336 	     end;
      337 	     if temp_ptr ^= null then free bead;
      338 	     if temp1_ptr ^= null then free obuf;
      339 
      340 	end clean_up;
      341 
      342      end overlay;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    02/02/88  1540.0  overlay.pl1                       >special_ldd>install>MR12.2-1019>overlay.pl1
19           1    02/02/88  1529.2  prt_conv_info.incl.pl1            >special_ldd>install>MR12.2-1019>prt_conv_info.incl.pl1
20           2    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BEAD_COUNT                      000100 automatic       fixed bin(17,0)          dcl 22 set ref 97* 201 201 203 205 206 212 289 290
                                                                                  316 317* 317 318 319 319 320* 321 322 322 323 324
                                                                                  324 325* 325 337 338 338
BS                                     constant        char(1)                  initial unaligned dcl 23 ref 235
FF                                     constant        char(1)                  initial unaligned dcl 23 ref 213 243
NL                                     constant        char(1)                  initial unaligned dcl 23 ref 219 242
NLVTFF                          000000 constant        char(3)                  initial unaligned dcl 23 ref 192
R_ACCESS                        000001 constant        bit(3)                   initial unaligned dcl 2-11 set ref 157*
SP                                     constant        char(1)                  initial unaligned dcl 23 ref 231
VT                                     constant        char(1)                  initial unaligned dcl 23 ref 216 244
addr                                                   builtin function         dcl 89 ref 98 99 191 201 201 245 245 285 323 324
area_ptr                        002376 automatic       pointer                  dcl 49 set ref 94* 150 318 319
arg                                    based           char                     unaligned dcl 38 set ref 113 113 117* 120* 122* 126
                                                                                  126 126 130* 132* 136 147*
arg_count                       002466 automatic       fixed bin(17,0)          dcl 54 set ref 101* 106 111
arg_len                         002470 automatic       fixed bin(17,0)          dcl 54 set ref 112* 113 113 115* 117 117 120 120 122
                                                                                  122 126 126 126 128* 130 130 132 132 136 147 147
arg_no                          002467 automatic       fixed bin(17,0)          dcl 54 set ref 111* 112* 114* 114 115* 127* 127 128*
arg_ptr                         002400 automatic       pointer                  dcl 49 set ref 112* 113 113 115* 117 120 122 126 126
                                                                                  126 128* 130 132 136 147
bead                                   based           structure                array level 1 dcl 34 set ref 318 321* 321 323 337
bead_ptr                        002402 automatic       pointer                  dcl 49 set ref 98* 206 207 228 238 239 268 268 270
                                                                                  271 271 272 321 323 323 326* 337
bit_count                       003561 automatic       fixed bin(24,0)          dcl 71 set ref 157* 159
bot_label_length        122            based           fixed bin(17,0)          level 2 dcl 1-15 set ref 301*
bot_label_line           57            based           char(136)                level 2 dcl 1-15 set ref 299*
char                      0(27)        based           char(1)                  array level 2 packed unaligned dcl 34 set ref 206*
                                                                                  238
cleanup                         003564 stack reference condition                dcl 90 ref 168
code                            003562 automatic       fixed bin(35,0)          dcl 72 set ref 101* 102 103* 112* 115* 116 117* 120*
                                                                                  121 128* 129 130* 131 137* 147* 148 157* 158 334*
col_no                          002504 automatic       fixed bin(17,0)          dcl 60 set ref 226* 228 239*
com_err_                        000016 constant        entry                    external dcl 78 ref 103 117 122 132 143
com_err_$suppress_name          000020 constant        entry                    external dcl 78 ref 107 164
cpt                             000102 automatic       char(32)                 unaligned dcl 41 set ref 147* 157*
cu_$arg_count                   000022 constant        entry                    external dcl 79 ref 101
cu_$arg_ptr                     000024 constant        entry                    external dcl 80 ref 112 115 128
curr_line                       002501 automatic       fixed bin(17,0)          dcl 57 set ref 177* 183 187 214 217 220 242 246*
curr_ptr                        002406 automatic       pointer                  dcl 49 set ref 191* 201*
curr_seg_len                    003534 automatic       fixed bin(21,0)          dcl 68 set ref 189* 191 192
curr_seg_ptr                    002410 automatic       pointer                  dcl 49 set ref 190* 191 192
cv_dec_check_                   000026 constant        entry                    external dcl 81 ref 120 130
cv_proc                                based           pointer                  level 2 dcl 1-15 set ref 285*
d                               003616 automatic       fixed bin(17,0)          dcl 259 set ref 264* 266* 266 267 268 271 272 275
divide                                                 builtin function         dcl 89 ref 159 183 214 217 266
dn                              000122 automatic       char(168)                unaligned dcl 43 set ref 147* 157*
en                              000112 automatic       char(32)                 unaligned dcl 42 set ref 147* 157*
eof                             002375 automatic       bit(1)                   array unaligned dcl 47 set ref 178* 186 196*
error_table_$badopt             000010 external static fixed bin(35,0)          dcl 74 ref 137
expand_pathname_$component      000030 constant        entry                    external dcl 82 ref 147
file_count                      002503 automatic       fixed bin(17,0)          dcl 59 set ref 96* 130 141* 141 142 150 151 153 154
                                                                                  155 157 159 163 170 180 185 333
func                     13            based           fixed bin(17,0)          level 2 dcl 1-15 set ref 306*
get_system_free_area_           000032 constant        entry                    external dcl 83 ref 94
hbound                                                 builtin function         dcl 89 ref 97 142 143 143
hcs_$terminate_noname           000034 constant        entry                    external dcl 84 ref 334
i                               002471 automatic       fixed bin(17,0)          dcl 55 in procedure "ov" set ref 170* 171 172 173*
                                                                                  185* 186 187 189 190 191 192 193 193 194 194 195
                                                                                  195 196 201 207 214 217 220 222* 333* 334 334 335*
i                               003617 automatic       fixed bin(17,0)          dcl 260 in procedure "sort" set ref 267* 268 268 270
                                                                                  271 271 272*
ii                              002472 automatic       fixed bin(17,0)          dcl 55 set ref 229*
info_ptr                        002412 automatic       pointer                  array dcl 50 set ref 150* 151* 171 172 173 201* 335
initiate_file_$component        000036 constant        entry                    external dcl 85 ref 157
io                              003533 automatic       fixed bin(21,0)          dcl 67 set ref 225* 230* 230 231 234* 234 235 237*
                                                                                  237 238 241* 241 242 243 244 245*
iox_$put_chars                  000040 constant        entry                    external dcl 86 ref 245
iox_$user_output                000012 external static pointer                  dcl 75 set ref 245*
j                               002473 automatic       fixed bin(17,0)          dcl 55 set ref 202* 203 206 207*
k                               002474 automatic       fixed bin(17,0)          dcl 55 in procedure "ov" set ref 227* 228 238 239*
k                               003636 automatic       fixed bin(17,0)          dcl 314 in procedure "MORE_ROOM" set ref 316* 320
label_nelem             327            based           fixed bin(17,0)          level 2 dcl 1-15 set ref 304*
length                                                 builtin function         dcl 89 ref 289 290
level                   323            based           fixed bin(17,0)          level 2 dcl 1-15 set ref 286*
line                    325            based           fixed bin(17,0)          level 2 dcl 1-15 set ref 302*
line_count               11            based           fixed bin(17,0)          level 2 dcl 1-15 set ref 295*
line_no                         003547 automatic       fixed bin(21,0)          array dcl 70 set ref 154* 191 192 193 194* 194 195
lmarg                     2            based           fixed bin(17,0)          level 2 dcl 1-15 set ref 288*
loc                                    based           fixed bin(26,0)          array level 2 packed unaligned dcl 34 set ref 207*
                                                                                  228 239
lpi                       7            based           fixed bin(17,0)          level 2 dcl 1-15 set ref 293*
m                               002475 automatic       fixed bin(17,0)          dcl 55 set ref 228* 229 229 233
min                                                    builtin function         dcl 89 ref 222
mod                                                    builtin function         dcl 89 ref 243
modes                    14            based           structure                level 2 packed unaligned dcl 1-15 set ref 297*
n                               002476 automatic       fixed bin(17,0)          dcl 55 set ref 192* 193 193* 194 200 201*
nchars                          002477 automatic       fixed bin(17,0)          dcl 56 set ref 182* 204* 204 205 206 207 227 264 267
neof                            002502 automatic       fixed bin(17,0)          dcl 58 set ref 176* 180 197* 197
next_line                       002500 automatic       fixed bin(17,0)          dcl 57 set ref 183* 222* 222 242 243 246
null                                                   builtin function         dcl 89 ref 51 52 52 155 334 337 338
nxline                          002505 automatic       fixed bin(17,0)          initial array dcl 61 set ref 61* 187 214* 217* 220*
                                                                                  222
obuf                                   based           char                     dcl 32 set ref 201 201 203 206 212 289 290 319 322*
                                                                                  322 324 338
obuf_ptr                        002404 automatic       pointer                  dcl 49 set ref 99* 201 201 203 206 212 289 290 322
                                                                                  324 324 327* 338
obuf_storage                    000174 automatic       char(513)                unaligned dcl 44 set ref 99 324
ocount                          002517 automatic       fixed bin(17,0)          dcl 62 set ref 201* 202 212
offset                          002520 automatic       fixed bin(17,0)          array dcl 63 set ref 130* 153* 207
output                          000375 automatic       char(4096)               unaligned dcl 45 set ref 231* 235* 238* 242* 243*
                                                                                  244* 245 245
overflow_off             14            based           bit(1)                   level 3 packed unaligned dcl 1-15 set ref 173* 308*
p                                      parameter       pointer                  dcl 282 ref 280 284 285 286 287 288 289 290 291 292
                                                                                  293 294 295 296 297 298 299 300 301 302 303 304
                                                                                  305 306 307 308
page_count               12            based           fixed bin(17,0)          level 2 dcl 1-15 set ref 296*
page_len                        002532 automatic       fixed bin(17,0)          initial dcl 64 set ref 64* 120* 171 172 183 183 183
                                                                                  214 214 214 243
page_length               4            based           fixed bin(17,0)          level 2 dcl 1-15 set ref 171* 291*
pci                                    based           structure                level 1 dcl 1-15 set ref 150 284* 335
phys_line_length          5            based           fixed bin(17,0)          level 2 dcl 1-15 set ref 290*
phys_page_length          6            based           fixed bin(17,0)          level 2 dcl 1-15 set ref 172* 292*
pos                     324            based           fixed bin(17,0)          level 2 dcl 1-15 set ref 287*
print_conv_$print_conv_         000014 external static fixed bin(17,0)          dcl 76 set ref 285
prt_conv_                       000042 constant        entry                    external dcl 87 ref 201
rmarg                     3            based           fixed bin(17,0)          level 2 dcl 1-15 set ref 289*
sav_pos                 332            based           fixed bin(17,0)          level 2 dcl 1-15 set ref 305*
search                                                 builtin function         dcl 89 ref 192
seg                                    based           char                     dcl 37 set ref 191 192
seg_len                         003535 automatic       fixed bin(21,0)          array dcl 69 set ref 159* 189 193 195
seg_ptr                         002436 automatic       pointer                  initial array dcl 51 set ref 51* 142 143 143 155*
                                                                                  157* 190 334 334*
sheets_per_page          10            based           fixed bin(17,0)          level 2 dcl 1-15 set ref 294*
slew                            000101 automatic       char(1)                  unaligned dcl 40 set ref 212* 213 216 219
slew_residue            326            based           fixed bin(17,0)          level 2 dcl 1-15 set ref 303*
storage                         002533 automatic       fixed bin(17,0)          array dcl 65 set ref 97 98 323
string                                                 builtin function         dcl 89 set ref 297*
substr                                                 builtin function         dcl 89 set ref 136 191 192 203 206 212 231* 235*
                                                                                  238* 242* 243* 244*
swaps                           003615 automatic       fixed bin(17,0)          dcl 258 set ref 265* 269* 269 276
system_area                            based           area(1024)               dcl 33 ref 150 318 319
temp                            003614 automatic       fixed bin(17,0)          dcl 257 in procedure "sort" set ref 270* 272
temp                    335            based           bit(36)                  level 2 in structure "pci" dcl 1-15 in procedure
                                                                                  "ov" set ref 307*
temp1_ptr                       002464 automatic       pointer                  initial dcl 52 set ref 52* 319* 322 327 338
temp_ptr                        002462 automatic       pointer                  initial dcl 52 set ref 52* 318* 321 326 337
top_label_length        121            based           fixed bin(17,0)          level 2 dcl 1-15 set ref 300*
top_label_line           15            based           char(136)                level 2 dcl 1-15 set ref 298*
unspec                                                 builtin function         dcl 89 set ref 284*
vec                                    based           fixed bin(17,0)          array dcl 262 set ref 268 268 270 271* 271 272*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 2-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 2-33
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 2-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 2-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 2-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 2-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 2-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 2-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
RW_ACCESS                              internal static bit(3)                   initial unaligned dcl 2-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 2-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 2-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 2-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 2-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 2-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 2-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 2-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
pcip                                   automatic       pointer                  dcl 1-13

NAMES DECLARED BY EXPLICIT CONTEXT.
ERROR                           000352 constant        label                    dcl 117 ref 129 138 148 158
MORE_ROOM                       001721 constant        entry                    internal dcl 312 ref 205
PASS                            001571 constant        label                    dcl 265 ref 275 276
SKIP                            001415 constant        label                    dcl 223 ref 186 187
clean_up                        002016 constant        entry                    internal dcl 331 ref 168 250
init_pci                        001635 constant        entry                    internal dcl 280 ref 151
ov                              000154 constant        entry                    external dcl 10
overlay                         000164 constant        entry                    external dcl 10
sort                            001566 constant        entry                    internal dcl 255 ref 224

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2530        2574    2315        2540
Length      3034    2315        44         223     213           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ov                                 2068 external procedure  is an external procedure.  
on unit on line 168                  64 on unit               
sort                                    internal procedure  shares stack frame of external procedure ov.  
init_pci                                internal procedure  shares stack frame of external procedure ov.  
MORE_ROOM                               internal procedure  shares stack frame of external procedure ov.  
clean_up                             72 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ov                       000100 BEAD_COUNT                  ov
                         000101 slew                        ov
                         000102 cpt                         ov
                         000112 en                          ov
                         000122 dn                          ov
                         000174 obuf_storage                ov
                         000375 output                      ov
                         002375 eof                         ov
                         002376 area_ptr                    ov
                         002400 arg_ptr                     ov
                         002402 bead_ptr                    ov
                         002404 obuf_ptr                    ov
                         002406 curr_ptr                    ov
                         002410 curr_seg_ptr                ov
                         002412 info_ptr                    ov
                         002436 seg_ptr                     ov
                         002462 temp_ptr                    ov
                         002464 temp1_ptr                   ov
                         002466 arg_count                   ov
                         002467 arg_no                      ov
                         002470 arg_len                     ov
                         002471 i                           ov
                         002472 ii                          ov
                         002473 j                           ov
                         002474 k                           ov
                         002475 m                           ov
                         002476 n                           ov
                         002477 nchars                      ov
                         002500 next_line                   ov
                         002501 curr_line                   ov
                         002502 neof                        ov
                         002503 file_count                  ov
                         002504 col_no                      ov
                         002505 nxline                      ov
                         002517 ocount                      ov
                         002520 offset                      ov
                         002532 page_len                    ov
                         002533 storage                     ov
                         003533 io                          ov
                         003534 curr_seg_len                ov
                         003535 seg_len                     ov
                         003547 line_no                     ov
                         003561 bit_count                   ov
                         003562 code                        ov
                         003614 temp                        sort
                         003615 swaps                       sort
                         003616 d                           sort
                         003617 i                           sort
                         003636 k                           MORE_ROOM

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          mdfx1
enable_op           ext_entry           int_entry           op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      com_err_$suppress_name        cu_$arg_count                 cu_$arg_ptr
cv_dec_check_                 expand_pathname_$component    get_system_free_area_         hcs_$terminate_noname
initiate_file_$component      iox_$put_chars                prt_conv_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           iox_$user_output              print_conv_$print_conv_




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     51 000114        52 000132        61 000135        64 000147        10 000153        94 000172        96 000201
     97 000202        98 000204        99 000206       101 000210       102 000221       103 000223       104 000242
    106 000243       107 000245       108 000274       111 000275       112 000303       113 000320       114 000332
    115 000333       116 000350       117 000352       118 000406       120 000407       121 000433       122 000435
    123 000473       125 000474       126 000475       127 000511       128 000512       129 000527       130 000531
    131 000556       132 000560       133 000616       135 000617       136 000620       137 000624       138 000627
    141 000630       142 000631       143 000634       144 000671       147 000672       148 000725       150 000727
    151 000740       153 000750       154 000752       155 000754       157 000761       158 001021       159 001023
    161 001027       163 001031       164 001033       165 001062       168 001063       170 001105       171 001115
    172 001122       173 001123       174 001125       176 001127       177 001130       178 001132       180 001144
    182 001147       183 001150       185 001161       186 001171       187 001175       189 001201       190 001203
    191 001207       192 001214       193 001234       194 001240       195 001241       196 001244       197 001247
    200 001250       201 001252       202 001275       203 001305       204 001312       205 001313       206 001317
    207 001331       209 001340       210 001342       212 001343       213 001351       214 001354       215 001366
    216 001367       217 001371       218 001400       219 001401       220 001403       222 001407       223 001415
    224 001417       225 001420       226 001421       227 001423       228 001433       229 001440       230 001447
    231 001450       232 001454       233 001456       234 001460       235 001461       237 001465       238 001466
    239 001477       240 001504       241 001506       242 001507       243 001520       244 001532       245 001536
    246 001556       248 001560       250 001561       251 001565       255 001566       264 001567       265 001571
    266 001572       267 001576       268 001607       269 001617       270 001620       271 001621       272 001623
    274 001625       275 001627       276 001632       278 001634       280 001635       284 001637       285 001644
    286 001647       287 001652       288 001653       289 001654       290 001661       291 001664       292 001666
    293 001670       294 001672       295 001674       296 001675       297 001676       298 001700       299 001703
    300 001706       301 001707       302 001710       303 001711       304 001712       305 001713       306 001714
    307 001715       308 001716       310 001720       312 001721       316 001722       317 001724       318 001726
    319 001733       320 001743       321 001745       322 001753       323 001761       324 001772       325 002005
    326 002010       327 002012       329 002014       331 002015       333 002023       334 002034       335 002054
    336 002062       337 002065       338 002073       340 002107


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
