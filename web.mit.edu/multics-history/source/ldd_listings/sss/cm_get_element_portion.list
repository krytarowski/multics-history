	COMPILATION LISTING OF SEGMENT cm_get_element_portion
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  0952.7 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* DESCRIPTION
        9*
       10*   This module implements collection_manager_$get_portion 
       11*   (cm_get_element_portion$cm_get_element_portion) and the not-yet-used
       12*   collection_manager_$get_portion_exclusive (cm_get_element_portion$exclusive)
       13*
       14*   This module gets an element or element portion located at (p_element_id
       15*   + p_position elements). The data is returned in the buffer located at
       16*   p_buffer_ptr (if it fits). p_buffer_length is the bit length of
       17*   that caller-supplied buffer. If the buffer is too small to hold the data
       18*   or the requested element is an overlength element, space is allocated in
       19*   the provided area and the data is returned there.
       20*
       21*   p_portion_beginning_index is a 1-origined index of the bit in the element
       22*   which is the first bit of the portion.  At this time only portions at the
       23*   head of the element can be retrieved (p_portion_beginning_index equal to 1).
       24*   
       25*   p_portion_length is the length in bits of the portion.  A value of -1
       26*   indicates that the portion runs on to the end of the element.
       27**/
       28 
       29 /* HISTORY:
       30*Written by Matthew Pierret, 07/10/82.
       31*Modified:
       32*09/02/82 by Matthew Pierret:  To do forward and backward positioning.
       33*10/19/82 by Matthew Pierret:  Added check for free datum slot.
       34*            Changed to use dm_error_$no_element.
       35*10/20/82 by Matthew Pierret:  Converted to use file_manager_.
       36*11/10/82 by Matthew Pierret:  Added multi-datum support.
       37*01/27/83 by Matthew Pierret:  Changed to initialize p_new_buffer_was_allocated
       38*            to "0"b. Removed get_element_portion entry name.
       39*            Fixed to use a local buffer when getting the first datum of a
       40*            general multi-datum get. Changed to return error in the case where
       41*            the supplied buffer is too small, no area was supplied and the
       42*            element is multi-datum. Added more extensive error reporting.
       43*            Added checks for consistency of each datum in multi-datum element.
       44*            Changed to detect errors occurring on continuation datums which
       45*            indicate internal inconsistency.
       46*02/07/83 by Matthew Pierret: Changed to use cm_get_id$header_return_slot to
       47*            position to an element.  Added the $info* entries.
       48*04/29/83 by Matthew Pierret: Changed to use addcharno instead of addr(substr))
       49*            and dm_error_$long_return_element isntead of $long_element.
       50*05/05/83 by Matthew Pierret: Fixed use of addcharno. Was adding one char too
       51*            many.
       52*07/14/83 by Matthew Pierret: Added ERROR_RETURN routine. This routine is called
       53*            whenever an error is encountered to set p_code and return from
       54*            the main procedure. Changed to disallow specifying an
       55*            elemenet_id.index equal to 0 without also specifying non-zero
       56*            positioning.
       57*10/14/83 by Lindsey L. Spratt:  CHanged to use the
       58*            cm_get_id$info_header_return_slot entry instead of then
       59*            cm_get_id$header_return_slot entry.
       60*02/13/84 by Matthew Pierret:  Changed to use file_manager_$get_ci_ptr to get a
       61*            pointer to a control interval and directly access the data in it.
       62*            Also changed to use new entry cm_get_id$ptr, which makes use of
       63*            this same mechansim for accessing control intervals.
       64*03/15/84 by Lindsey L. Spratt:  Fixed MULTI_DATUM_GET to set the
       65*            cd_datum_header.  (Matt and Lee B.)
       66*03/16/84 by Matthew Pierret:  Changed to special case
       67*            dm_error_$ci_not_allocated when returned from fm_$get_ci_ptr.
       68*05/09/84 by Matthew Pierret:  Changed to allocate output buffers on even word
       69*            boundaries.
       70*07/18/84 by Matthew Pierret:  Changed to return dm_error_$ci_not_in_collection
       71*            instead of calling sub_err_ if the first control interval gotten
       72*            is not in the specified collection.
       73*10/01/84 by Matthew Pierret:  Changed to base all datum structures on datum_ptr
       74*            and datum_contents_length_in_bits.  Changed to use
       75*            bytes = divide (bits + BITS_PER_BYTE -1, BITS_PER_BYTE, 17, 0)
       76*            to convert bits to bytes more efficiently. This is only used in
       77*            the critical path (SIMPLE_GET).
       78*12/03/84 by Matthew Pierret:  Added the local cd_datum_header which was
       79*            removed from dm_cm_datum.incl.pl1.
       80**/
       81 
       82 /* format: style2,ind3,ll79,^indprocbody */
       83 
       84 cm_get_element_portion:
       85    proc (p_file_opening_id, p_collection_id, p_element_id, p_position,
       86         p_buffer_ptr, p_buffer_length, p_area_ptr, p_portion_beginning_index,
       87         p_portion_length, p_new_buffer_was_allocated, p_element_ptr,
       88         p_element_length, p_code);
       89 
       90 /* START OF DECLARATIONS */
       91 /* Parameter */
       92 
       93    dcl	 p_file_opening_id	    bit (36) aligned;
       94    dcl	 p_collection_id	    bit (36) aligned;
       95    dcl	 p_element_id	    bit (36) aligned;
       96    dcl	 p_position	    fixed bin (17);
       97    dcl	 p_buffer_ptr	    ptr;
       98    dcl	 p_buffer_length	    fixed bin (35);
       99    dcl	 p_area_ptr	    ptr;
      100    dcl	 p_portion_beginning_index
      101 			    fixed bin (35);
      102    dcl	 p_portion_length	    fixed bin (35);
      103    dcl	 p_new_buffer_was_allocated
      104 			    bit (1) aligned;
      105    dcl	 p_element_ptr	    ptr;
      106    dcl	 p_element_length	    fixed bin (35);
      107    dcl	 p_code		    fixed bin (35);
      108 
      109 /* Automatic */
      110 
      111    dcl	 (file_opening_id, collection_id)
      112 			    bit (36) aligned;
      113    dcl	 (continuation_datum_id_string, continued_datum_id_string)
      114 			    init ("0"b) bit (36) aligned;
      115 
      116    dcl	 code		    fixed bin (35) init (0);
      117    dcl	 buffer_length_in_bits  fixed bin (35) init (0);
      118    dcl	 buffer_length_in_double_words
      119 			    fixed bin (35) init (0);
      120    dcl	 datum_contents_length_in_bytes
      121 			    fixed bin (17) init (0);
      122    dcl	 portion_length_in_bits fixed bin (35) init (0);
      123    dcl	 portion_length_in_bytes
      124 			    fixed bin (17) init (0);
      125    dcl	 position_from_specified_element
      126 			    fixed bin (17) init (0);
      127    dcl	 remaining_portion_length_in_bytes
      128 			    fixed bin (17) init (0);
      129 
      130    dcl	 exclusive_get	    bit (1) aligned init ("0"b);
      131 
      132    dcl	 ci_ptr		    ptr init (null);
      133    dcl	 work_area_ptr	    ptr init (null);
      134    dcl	 buffer_ptr	    ptr init (null);
      135    dcl	 current_buffer_ptr	    ptr init (null);
      136    dcl	 datum_contents_ptr	    ptr init (null);
      137 
      138    dcl	 1 cd_datum_header	    aligned like continued_datum.header;
      139 
      140 /* Based */
      141 
      142    dcl	 1 continued_datum_id   aligned like datum_id
      143 			    based (addr (continued_datum_id_string));
      144    dcl	 1 continuation_datum_id
      145 			    aligned like datum_id
      146 			    based (addr (continuation_datum_id_string));
      147    dcl	 work_area	    area based (work_area_ptr);
      148    dcl	 buffer		    (buffer_length_in_double_words) fixed
      149 			    bin (71) based (buffer_ptr);
      150    dcl	 datum_contents_string  char (datum_contents_length_in_bytes) based;
      151 
      152 /* Builtin */
      153 
      154    dcl	 (addr, addcharno, ceil, divide, length, min, null, unspec)
      155 			    builtin;
      156 
      157 /* Condition */
      158 
      159    dcl	 cleanup		    condition;
      160 
      161 /* Constant */
      162 
      163    dcl	 myname		    init ("cm_put_element_portion")
      164 			    char (32) varying internal static
      165 			    options (constant);
      166    dcl	 (
      167 	 BITS_PER_BYTE	    init (9) fixed bin,
      168 	 BYTES_PER_DOUBLE_WORD  init (8) fixed bin,
      169 	 THIS_IS_FIRST_CI_SEEN  init ("1"b) bit (1) aligned,
      170 	 THIS_IS_NOT_FIRST_CI_SEEN
      171 			    init ("1"b) bit (1) aligned,
      172 	 TO_END_OF_ELEMENT	    init (-1) fixed bin (35)
      173 	 )		    internal static options (constant);
      174 
      175 /* Entry */
      176 
      177    dcl	 file_manager_$get_ci_ptr
      178 			    entry (bit (36) aligned, uns fixed bin (24),
      179 			    ptr, fixed bin (35));
      180    dcl	 sub_err_		    entry () options (variable);
      181 
      182 /* External */
      183 
      184    dcl	 (
      185 	 error_table_$bad_arg,
      186 	 error_table_$unimplemented_version
      187 	 )		    fixed bin (35) ext;
      188    dcl	 (
      189 	 dm_error_$ci_not_allocated,
      190 	 dm_error_$ci_not_in_collection,
      191 	 dm_error_$no_element,
      192 	 dm_error_$programming_error,
      193 	 dm_error_$long_return_element
      194 	 )		    fixed bin (35) ext;
      195 
      196 /* END OF DECLARATIONS */
      197 
      198    exclusive_get = "0"b;
      199    goto JOIN;
      200 
      201 exclusive:
      202    entry (p_file_opening_id, p_collection_id, p_element_id, p_position,
      203         p_buffer_ptr, p_buffer_length, p_area_ptr, p_portion_beginning_index,
      204         p_portion_length, p_new_buffer_was_allocated, p_element_ptr,
      205         p_element_length, p_code);
      206 
      207 /* This entry is not actually implemented.  What is needed to implement
      208*   it fully is a file_manager_$get_ci_ptr_exclusive entry. */
      209 
      210    exclusive_get = "1"b;
      211    goto JOIN;
      212 
      213 
      214 /* format: ^indblkcom,indcomtxt */
      215 /* format: equalind25 */
      216 JOIN:
      217    p_code		        = 0;
      218    p_new_buffer_was_allocated
      219 		        = "0"b;
      220    file_opening_id	        = p_file_opening_id;
      221    collection_id	        = p_collection_id;
      222    position_from_specified_element
      223 		        = p_position;
      224    portion_length_in_bits   = p_portion_length;
      225    element_id_string        = p_element_id;
      226    buffer_ptr	        = p_buffer_ptr;		/* format: equalind0 */
      227 
      228 
      229    if buffer_ptr = null
      230    then buffer_length_in_bits = -1;			/* no buffer */
      231    else buffer_length_in_bits = p_buffer_length;
      232 
      233    if position_from_specified_element = 0
      234    then
      235       do;
      236          if element_id.index <= 0
      237          then call ERROR_RETURN (dm_error_$no_element);
      238          call GET_CI_PTR (THIS_IS_FIRST_CI_SEEN, file_opening_id,
      239 	    collection_id, (element_id.control_interval_id), ci_ptr);
      240          if element_id.index
      241 	    > ci_ptr -> basic_control_interval.header.number_of_datums
      242          then call ERROR_RETURN (dm_error_$no_element);
      243       end;
      244    else
      245       do;
      246          call cm_get_id$ptr (file_opening_id, collection_id,
      247 	    (element_id_string), position_from_specified_element,
      248 	    (element_id_string = "0"b), (null) /* input ci_ptr */, ci_ptr,
      249 	    element_id_string, code);
      250          if code ^= 0
      251          then call ERROR_RETURN (code);
      252       end;
      253 
      254 /*** Set pointer to datum_slot instead of accessing ci_ptr->bci.dpt(ei.i)
      255*     for efficiency. */
      256 
      257    datum_slot_ptr =
      258         addr (ci_ptr
      259         -> basic_control_interval.datum_position_table (element_id.index));
      260 
      261 /*** If no element corresponds to this datum slot, report to caller that
      262*     the element could not be found. */
      263 
      264    if datum_slot.offset_in_bytes = FREE_SLOT /* no datum here */
      265         | datum_slot.flags.is_continuation		/* this datum is not the start of an element */
      266    then call ERROR_RETURN (dm_error_$no_element);
      267 
      268 
      269 
      270 /*** Report if caller supplied an invalid p_portion_length argument.  The
      271*     portion length must be positive or a special value. */
      272 
      273    if portion_length_in_bits < 1 & portion_length_in_bits ^= TO_END_OF_ELEMENT
      274    then call ERROR_RETURN (error_table_$bad_arg);
      275 
      276    datum_ptr = addcharno (ci_ptr, datum_slot.offset_in_bytes);
      277 
      278    if ^datum_slot.flags.is_continued
      279    then
      280 SIMPLE_GET:
      281       do;
      282 
      283       /*** The datum described by datum_slot is the entire element.  Get the datum
      284*	 portion and return. */
      285 
      286          datum_contents_ptr = addr (datum.contents);	/* Points to the datum contents in the control interval. */
      287 						/* This should one day be changed to point at the start  */
      288 						/* of an element portion. */
      289 
      290          if portion_length_in_bits = TO_END_OF_ELEMENT
      291          then datum_contents_length_in_bits = datum_slot.length_in_bits;
      292          else datum_contents_length_in_bits =
      293 	         min (portion_length_in_bits, datum_slot.length_in_bits);
      294 
      295          datum_contents_length_in_bytes =
      296 	    ceil (
      297 	    divide (datum_contents_length_in_bits, BITS_PER_BYTE, 35, 18));
      298 
      299          if datum_contents_length_in_bytes * BITS_PER_BYTE
      300 	    > buffer_length_in_bits			/* datum_contents_length_in_bytes * BITS_PER_BYTE is used */
      301 						/* in this test instead of datum_slot.length_in_bits      */
      302 						/* because the buffer must be large enough to fit the     */
      303 						/* contents when copied in bytes.                         */
      304          then
      305 SG_ALLOC_BUFFER:
      306 	  do;					/* Buffer is too small. Try allocating a buffer in the work area. */
      307 	     work_area_ptr = p_area_ptr;
      308 	     if work_area_ptr = null
      309 	     then
      310 	        do;
      311 		 p_element_length =
      312 		      datum_contents_length_in_bytes * BITS_PER_BYTE;
      313 						/* Not the actual length of the element, but the minimum */
      314 						/* size a buffer must be to hold the element. */
      315 		 call ERROR_RETURN (dm_error_$long_return_element);
      316 	        end;
      317 	     else
      318 	        do;				/* Allocate the buffer. */
      319 		 buffer_length_in_double_words =
      320 		      ceil (
      321 		      divide (datum_contents_length_in_bytes,
      322 		      BYTES_PER_DOUBLE_WORD, 35, 18));
      323 		 on cleanup call FINISH ();
      324 		 alloc buffer in (work_area);
      325 		 p_new_buffer_was_allocated = "1"b;
      326 	        end;
      327 	  end SG_ALLOC_BUFFER;
      328 
      329       /*** Now, copy the datum contents into the buffer. */
      330 
      331          buffer_ptr -> datum_contents_string =
      332 	    datum_contents_ptr -> datum_contents_string;
      333 
      334          p_element_ptr = buffer_ptr;
      335          p_element_length = datum_slot.length_in_bits;
      336 
      337       end SIMPLE_GET;
      338 
      339    else if portion_length_in_bits ^= TO_END_OF_ELEMENT
      340 	   & portion_length_in_bits
      341 	   <= (datum_slot.length_in_bits - CD_DATUM_HEADER_LENGTH_IN_BITS)
      342    then
      343 SIMPLE_MULTI_DATUM_GET:
      344       do;
      345 
      346       /*** The element consists of more than one datum, but the retreival
      347*	 can be satisfied by using only the first datum. This do-group is almost
      348*	 identical to the SIMPLE_GET do-group. */
      349 
      350          datum_contents_ptr = addr (continued_datum.contents);
      351 						/* Points to the datum contents in the control interval. */
      352 
      353          if portion_length_in_bits = TO_END_OF_ELEMENT
      354          then datum_contents_length_in_bits =
      355 	         datum_slot.length_in_bits - CD_DATUM_HEADER_LENGTH_IN_BITS;
      356          else datum_contents_length_in_bits =
      357 	         min (portion_length_in_bits,
      358 	         datum_slot.length_in_bits - CD_DATUM_HEADER_LENGTH_IN_BITS);
      359 
      360          datum_contents_length_in_bytes =
      361 	    ceil (
      362 	    divide (datum_contents_length_in_bits, BITS_PER_BYTE, 35, 18));
      363 
      364          if datum_contents_length_in_bytes * BITS_PER_BYTE
      365 	    > buffer_length_in_bits			/* datum_contents_length_in_bytes * BITS_PER_BYTE is used */
      366 						/* in this test instead of datum_slot.length_in_bits      */
      367 						/* because the buffer must be large enough to fit the     */
      368 						/* contents when copied in bytes.                         */
      369          then
      370 SMG_ALLOC_BUFFER:
      371 	  do;					/* Buffer is too small. Try allocating a buffer in the work area. */
      372 	     work_area_ptr = p_area_ptr;
      373 	     if work_area_ptr = null
      374 	     then
      375 	        do;
      376 		 p_element_length =
      377 		      datum_contents_length_in_bytes * BITS_PER_BYTE;
      378 						/* Not the actual length of the element, but the minimum */
      379 						/* size a buffer must be to hold the element. */
      380 		 call ERROR_RETURN (dm_error_$long_return_element);
      381 	        end;
      382 	     else
      383 	        do;				/* Allocate the buffer. */
      384 		 buffer_length_in_double_words =
      385 		      ceil (
      386 		      divide (datum_contents_length_in_bytes,
      387 		      BYTES_PER_DOUBLE_WORD, 35, 18));
      388 		 on cleanup call FINISH ();
      389 		 alloc buffer in (work_area);
      390 		 p_new_buffer_was_allocated = "1"b;
      391 	        end;
      392 	  end SMG_ALLOC_BUFFER;
      393 
      394       /*** Now, copy the datum contents into the buffer. */
      395 
      396          buffer_ptr -> datum_contents_string =
      397 	    datum_contents_ptr -> datum_contents_string;
      398 
      399          p_element_ptr = buffer_ptr;
      400          p_element_length = datum_contents_length_in_bits;
      401 
      402       end SIMPLE_MULTI_DATUM_GET;
      403 
      404    else call MULTI_DATUM_GET ();
      405 
      406    if p_element_id ^= element_id_string
      407    then p_element_id = element_id_string;
      408 
      409 MAIN_RETURN:
      410    return;
      411 
      412 FINISH:
      413    proc ();
      414 
      415    if buffer_ptr ^= p_buffer_ptr & buffer_ptr ^= null
      416    then
      417       do;
      418          free buffer in (work_area);
      419          p_new_buffer_was_allocated = "0"b;
      420       end;
      421 
      422    call TERMINATE_CI_PTR (ci_ptr);
      423 
      424    end FINISH;
      425 
      426 
      427 ERROR_RETURN:
      428    proc (er_code);
      429 
      430    dcl	 er_code		    fixed bin (35);
      431 
      432    p_code = er_code;
      433    call FINISH ();
      434    goto MAIN_RETURN;
      435 
      436    end ERROR_RETURN;
      437 
      438 CHECK_CI_LAYOUT:
      439    proc (ccl_p_ci_layout);
      440    dcl	 ccl_p_ci_layout	    char (4) aligned;
      441 
      442    if ccl_p_ci_layout ^= BASIC_CI_LAYOUT_1
      443    then call sub_err_ (error_table_$unimplemented_version, myname,
      444 	   ACTION_CANT_RESTART, null, 0,
      445 	   "^/Expected a version ^a control interval. Received version ^a instead."
      446 	   , BASIC_CI_LAYOUT_1, ccl_p_ci_layout);
      447 
      448    end CHECK_CI_LAYOUT;
      449 
      450 GET_CI_PTR:
      451    proc (gcp_p_this_is_first_ci_seen, gcp_p_foid, gcp_p_collection_id,
      452         gcp_p_ci_id, gcp_p_ci_ptr);
      453 
      454    dcl	 gcp_p_this_is_first_ci_seen
      455 			    bit (1) aligned;
      456    dcl	 gcp_p_foid	    bit (36) aligned;
      457    dcl	 gcp_p_collection_id    bit (36) aligned;
      458    dcl	 gcp_p_ci_id	    fixed bin (24) unsigned;
      459    dcl	 gcp_p_ci_ptr	    ptr;
      460    dcl	 gcp_code		    fixed bin (35);
      461 
      462 
      463    if gcp_p_ci_ptr ^= null
      464    then call TERMINATE_CI_PTR (gcp_p_ci_ptr);
      465 
      466    call file_manager_$get_ci_ptr (gcp_p_foid, (gcp_p_ci_id), gcp_p_ci_ptr,
      467         gcp_code);
      468    if gcp_code ^= 0
      469    then if gcp_code ^= dm_error_$ci_not_allocated
      470         then call ERROR_RETURN (gcp_code);
      471         else if continuation_datum_id_string = "0"b
      472         then call ERROR_RETURN (dm_error_$no_element);	/* First datum of element. No CI means no element. */
      473 						/* A continuation datum of a multi-datum element. No CI means an improperly formed conntinued datum. */
      474         else call sub_err_ (gcp_code, myname, ACTION_CANT_RESTART, null, 0,
      475 	        "^/Control interval ^d was expected to hold the continuation of ^/the datum at slot ^d of control interval ^d."
      476 	        , gcp_p_ci_id, continued_datum_id.index,
      477 	        continued_datum_id.control_interval_id);
      478 
      479 
      480    call CHECK_CI_LAYOUT ((gcp_p_ci_ptr -> bci_header.layout_type));
      481 
      482    if gcp_p_ci_ptr -> bci_header.collection_id ^= gcp_p_collection_id
      483    then
      484       do;
      485          if gcp_p_this_is_first_ci_seen
      486          then call ERROR_RETURN (dm_error_$ci_not_in_collection);
      487          else call sub_err_ (dm_error_$programming_error, myname,
      488 	         ACTION_CANT_RESTART, null, 0,
      489 	         "^/Control interval ^d is in collection ^3bo but was expected to^/be in collection ^3bo."
      490 	         , gcp_p_ci_id, gcp_p_ci_ptr -> bci_header.collection_id,
      491 	         gcp_p_collection_id);
      492       end;
      493 
      494    return;
      495 
      496    end GET_CI_PTR;
      497 
      498 TERMINATE_CI_PTR:
      499    proc (tcp_p_ci_ptr);
      500 
      501    dcl	 tcp_p_ci_ptr	    ptr;
      502 
      503    tcp_p_ci_ptr = null;
      504 
      505    return;
      506 
      507    end TERMINATE_CI_PTR;
      508 
      509 MULTI_DATUM_GET:
      510    proc ();
      511 
      512 
      513 /*** The datum is by definition a "continued" datum, described by the
      514*     continued_datum structure.  Set a pointer to the beginning of that structure,
      515*     extract header information and datum contents from it. */
      516 
      517    datum_contents_length_in_bits =
      518         datum_slot.length_in_bits - CD_DATUM_HEADER_LENGTH_IN_BITS;
      519 						/* Length of the datum contents in bits. */
      520    datum_contents_ptr = addr (continued_datum.contents);	/* Points to beginning of datum contents. */
      521    datum_contents_length_in_bytes =
      522         ceil (divide (datum_contents_length_in_bits, BITS_PER_BYTE, 35, 18));
      523 
      524    if portion_length_in_bits = TO_END_OF_ELEMENT
      525    then portion_length_in_bits = continued_datum.header.full_length;
      526    else portion_length_in_bits =
      527 	   min (portion_length_in_bits, continued_datum.header.full_length);
      528 
      529    portion_length_in_bytes =
      530         ceil (divide (portion_length_in_bits, BITS_PER_BYTE, 71, 18));
      531 						/* This length can be very large. */
      532 
      533    if portion_length_in_bytes * BITS_PER_BYTE > buffer_length_in_bits
      534 						/* portion_length_in_bytes * BITS_PER_BYTE is used in this        */
      535 						/* test instead of datum_slot.length_in_bits because the buffer   */
      536 						/* must be large enough to fit the contents when copied in bytes. */
      537    then
      538 MG_ALLOC_BUFFER:
      539       do;						/* Buffer is too small. Try allocating a buffer in the work area. */
      540          work_area_ptr = p_area_ptr;
      541          if work_area_ptr = null
      542          then
      543 	  do;
      544 	     p_element_length = portion_length_in_bytes * BITS_PER_BYTE;
      545 						/* Not the actual length of the portion, but the minimum size a  */
      546 						/* buffer must be to hold the portion. */
      547 	     call ERROR_RETURN (dm_error_$long_return_element);
      548 	  end;
      549          else
      550 	  do;					/* Allocate the buffer. */
      551 	     buffer_length_in_double_words =
      552 		ceil (
      553 		divide (portion_length_in_bytes, BYTES_PER_DOUBLE_WORD, 35,
      554 		18));
      555 	     on cleanup call FINISH ();
      556 	     alloc buffer in (work_area);
      557 	     p_new_buffer_was_allocated = "1"b;
      558 	  end;
      559       end MG_ALLOC_BUFFER;
      560 
      561    if datum_contents_length_in_bytes <= 0
      562    then
      563       do;
      564          current_buffer_ptr = buffer_ptr;
      565          remaining_portion_length_in_bytes = portion_length_in_bytes;
      566       end;
      567    else
      568       do;
      569          buffer_ptr -> datum_contents_string =
      570 	    datum_contents_ptr -> datum_contents_string;
      571          current_buffer_ptr =
      572 	    addcharno (buffer_ptr, datum_contents_length_in_bytes);
      573          remaining_portion_length_in_bytes =
      574 	    portion_length_in_bytes - datum_contents_length_in_bytes;
      575 						/* This is to indicate how much is left to be gotten. */
      576       end;
      577 
      578    continued_datum_id_string = element_id_string;		/* datum id of the continued datum, i.e., the the datum most recently */
      579 						/* copied.  The element is continued in another datum. */
      580    cd_datum_header = continued_datum.header;
      581 
      582    continuation_datum_id = cd_datum_header.continuation;	/* datum id of the datum which is the continuation of the continued datum. */
      583 
      584 GET_EACH_DATUM_LOOP:
      585    do while (continuation_datum_id_string ^= "0"b
      586         & remaining_portion_length_in_bytes > 0);
      587 
      588       call GET_CI_PTR (THIS_IS_NOT_FIRST_CI_SEEN, file_opening_id,
      589 	 collection_id, (continuation_datum_id.control_interval_id), ci_ptr);
      590 
      591       if continuation_datum_id.index
      592 	 > ci_ptr -> basic_control_interval.header.number_of_datums
      593       then call sub_err_ (dm_error_$programming_error, myname,
      594 	      ACTION_CANT_RESTART, null, 0,
      595 	      "^/There is no datum at slot ^d of control interval ^d.  A continuation^/of the datum at slot ^d of control interval ^d was expected to be there."
      596 	      , continuation_datum_id.index,
      597 	      continuation_datum_id.control_interval_id,
      598 	      continued_datum_id.index,
      599 	      continued_datum_id.control_interval_id);
      600 
      601       datum_slot_ptr =
      602 	 addr (ci_ptr
      603 	 -> basic_control_interval
      604 	 .datum_position_table (continuation_datum_id.index));
      605 
      606       datum_ptr = addcharno (ci_ptr, datum_slot.offset_in_bytes);
      607 
      608       if datum_slot.is_continued
      609       then
      610          do;
      611 	  datum_contents_length_in_bits =
      612 	       datum_slot.length_in_bits
      613 	       - length (unspec (continued_continuation_datum.header));
      614 	  datum_contents_length_in_bytes =
      615 	       ceil (
      616 	       divide (datum_contents_length_in_bits, BITS_PER_BYTE, 35, 18))
      617 	       ;
      618 	  datum_contents_ptr = addr (continued_continuation_datum.contents);
      619 
      620 	  continued_datum_id_string = continuation_datum_id_string;
      621 	  continuation_datum_id =
      622 	       continued_continuation_datum.header.continuation;
      623          end;
      624       else
      625          do;
      626 	  datum_contents_length_in_bytes =
      627 	       ceil (
      628 	       divide (datum_slot.length_in_bits, BITS_PER_BYTE, 35, 18));
      629 	  datum_contents_ptr = addr (continuation_datum.contents);
      630 
      631 	  continuation_datum_id_string = "0"b;
      632          end;
      633 
      634       datum_contents_length_in_bytes =
      635 	 min (datum_contents_length_in_bytes,
      636 	 remaining_portion_length_in_bytes);
      637 
      638       current_buffer_ptr -> datum_contents_string =
      639 	 datum_contents_ptr -> datum_contents_string;
      640 
      641       current_buffer_ptr =
      642 	 addcharno (current_buffer_ptr, datum_contents_length_in_bytes);
      643 
      644       remaining_portion_length_in_bytes =
      645 	 remaining_portion_length_in_bytes - datum_contents_length_in_bytes;
      646 
      647    end GET_EACH_DATUM_LOOP;
      648 
      649    if remaining_portion_length_in_bytes > 0
      650    then call sub_err_ (dm_error_$programming_error, myname,
      651 	   ACTION_CANT_RESTART, null, 0,
      652 	   "^/The length of the element at slot ^d of control interval ^d is^/recorded as ^d bits.  The actual length is ^d bits."
      653 	   , element_id.index, element_id.control_interval_id,
      654 	   portion_length_in_bits,
      655 	   (portion_length_in_bits
      656 	   - remaining_portion_length_in_bytes * BITS_PER_BYTE));
      657 
      658    p_element_ptr = buffer_ptr;
      659    p_element_length = cd_datum_header.full_length;
      660 
      661    end MULTI_DATUM_GET;
      662 
  1     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*        The collection_manager_ manages the structure of the addressable
  1     6*   portion of a control interval.  The addressable portion is that portion of
  1     7*   a control interval which the file_manager_ will allow the
  1     8*   collection_manager_ to address.  In this description control interval will
  1     9*   be used to mean the addressable portion of a control interval.
  1    10*   
  1    11*        A control interval is divided into four parts: the header, the datum
  1    12*   position table (also known as the slot table or slots), un-used space and
  1    13*   used space.  The beginning of the header is at offset 0, and the end of the
  1    14*   used space is at the end of the control interval (curently offset 4072).
  1    15*   Pictoriarly, a control interval is structured as follows:
  1    16*   
  1    17*   ----------------------------------------------------------------------
  1    18*   |        || | | | | | ||               ||   | / / |       |/|   |    |
  1    19*   | Header || | slot  | || un-used space ||   |/ / /|       |/|   |    |
  1    20*   |        || | table | ||               ||   | / / |       |/|   |    |
  1    21*   |        || | | | | | ||               ||   |/ / /|       |/|   |    |
  1    22*   ----------------------------------------------------------------------
  1    23*                                           ^ ^    ^      ^    ^  ^   ^
  1    24*                                           | |    |      |    |  |   |
  1    25*                                           | |...........|.......|...|
  1    26*                        start of used space|      |           |      |
  1    27*                                                  |           |  each|
  1    28*                                          scattered free space|  is a used
  1    29*                                                                 datum
  1    30*   
  1    31*      The basic_control_interval structure describes the header
  1    32*   (basic_control_interval.header, bci_header) and the slots
  1    33*   (basic_control_interval.datum_position_table, datum_slot for one only).
  1    34*   Each datum_slot contains the offset (in bytes) and the length (in bits) of
  1    35*   a datum in the used space.  If the offset is equal to FREE_SLOT (declared
  1    36*   in dm_cm_basic_ci_const.incl.pl1), the slot is un-used.  The slot also
  1    37*   contains flags describing the type of datum (see dm_cm_datum.incl.pl1).
  1    38**/
  1    39 
  1    40 /* HISTORY:
  1    41*Written by Matthew Pierret, 02/07/82.
  1    42*Modified:
  1    43*03/25/82 by Matthew Pierret: Fixed alignment differences basic_control_interval
  1    44*            and its sub-structures.
  1    45*06/14/82 by Matthew Pierret: Removed common header and buffers. Changed
  1    46*            basic_ci_header to bci_header. Added previous_control_interval.
  1    47*07/12/82 by Matthew Pierret: Changed collection_id to be bit (36) aligned.
  1    48*10/29/82 by Matthew Pierret: Added flags to datum slots. 
  1    49*11/10/82 by Matthew Pierret: Removed continued_datum_is_present flag, as it
  1    50*            is not used.
  1    51*03/28/84 by Matthew Pierret: Added the constants BCI_HEADER_LENGTH_IN_BYTES
  1    52*            and DATUM_POSITION_TABLE_OFFSET_IN_BYTES.
  1    53**/
  1    54 
  1    55 /* format: style2 */
  1    56      dcl	   1 basic_control_interval
  1    57 			      aligned based (basic_control_interval_ptr),
  1    58 	     2 header	      like bci_header,
  1    59 	     2 datum_position_table
  1    60 			      (0 refer (basic_control_interval.number_of_datums)) like datum_slot;
  1    61 
  1    62 
  1    63      dcl	   1 bci_header	      aligned based (bci_header_ptr),
  1    64 	     2 layout_type	      char (4) aligned,
  1    65 	     2 collection_id      bit (36) aligned,
  1    66 	     2 next_control_interval
  1    67 			      fixed bin (24) uns unal,
  1    68 	     2 previous_control_interval
  1    69 			      fixed bin (24) uns unal,
  1    70 	     2 flags	      unal,
  1    71 	       3 continuation_datum_is_present
  1    72 			      bit (1) unal,
  1    73 	       3 free_slot_is_present
  1    74 			      bit (1) unal,
  1    75 	       3 must_be_zero     bit (4) unal,		/* reserved */
  1    76 	     2 scattered_free_space
  1    77 			      fixed bin (17) unal,
  1    78 	     2 start_of_used_space
  1    79 			      fixed bin (17) unal,
  1    80 	     2 number_of_datums   fixed bin (17) unal;
  1    81 
  1    82      dcl	   1 datum_slot	      aligned based (datum_slot_ptr),
  1    83 	     2 flags	      unal,
  1    84 	       3 special_format_datum
  1    85 			      bit (1) unal,		/* reserved */
  1    86 	       3 is_continued     bit (1) unal,
  1    87 	       3 is_continuation  bit (1) unal,
  1    88 	       3 mbz	      bit (1) unal,		/* reserved */
  1    89 	     2 offset_in_bytes    fixed bin (15) uns unal,
  1    90 	     2 length_in_bits     fixed bin (17) uns unal;
  1    91 
  1    92      dcl	   basic_control_interval_ptr
  1    93 			      ptr;
  1    94      dcl	   bci_header_ptr	      ptr;
  1    95      dcl	   datum_slot_ptr	      ptr;
  1    96 
  1    97      dcl	   BASIC_CI_LAYOUT_1      char (4) aligned init ("bci1") internal static options (constant);
  1    98 
  1    99 /* END INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
      663 
      664 
  2     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci_const.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*   Contains constants useful in describing parts of a basic control interval.
  2     6**/
  2     7 
  2     8 /* HISTORY:
  2     9*Written by Matthew Pierret, 09/20/84.
  2    10*Modified:
  2    11**/
  2    12 
  2    13      dcl	   FREE_SLOT	      init (0) fixed bin (15) uns internal static options (constant);
  2    14      dcl	   BCI_HEADER_LENGTH_IN_BYTES
  2    15 			      init (20) fixed bin internal static options (constant);
  2    16      dcl	   DATUM_POSITION_TABLE_OFFSET_IN_BYTES
  2    17 			      init (20) fixed bin internal static options (constant);
  2    18 
  2    19 
  2    20 /* END INCLUDE FILE dm_cm_basic_ci_const.incl.pl1 */
      665 
      666 
  3     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*
  3     5*        Contains the declaration of an element identifier.  Element
  3     6*   identifiers consist of two parts, the id (number) of the control interval
  3     7*   in which the element resides, and the index into the slot table of
  3     8*   the element in the control interval.  The declaration of the element_id 
  3     9*   structure reflects this division of the element identifier.  The structure 
  3    10*   is based on the automatic bit string element_id_string because programs
  3    11*   generally pass bit strings (element_id_string) to each other, then 
  3    12*   interpret the bit string by overlaying the element_id structure ony if
  3    13*   it is necessary to access the parts of the id.  Basing element_id on
  3    14*   addr(element_id_string) instead of on a pointer removes the necessity
  3    15*   for always setting that pointer explicitly and guarantees that changes
  3    16*   made to the string or structure do not get inconsistent.
  3    17*
  3    18*   Changes made to element_id must also be made to datum_id, declared in 
  3    19*   dm_cm_datum.incl.pl1.
  3    20**/
  3    21 
  3    22 /* HISTORY:
  3    23*Written by Matthew Pierret, 04/01/82.
  3    24*Modified:
  3    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  3    26**/
  3    27 
  3    28 /* format: style2,ind3,ll79 */
  3    29 
  3    30      dcl	   element_id_string      bit (36) aligned;
  3    31 
  3    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  3    33 	     2 control_interval_id
  3    34 			      fixed bin (24) unal unsigned,
  3    35 	     2 index	      fixed bin (12) unal unsigned;
  3    36 
  3    37 
  3    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      667 
      668 
  4     1 /* BEGIN INCLUDE FILE dm_cm_datum.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*        This include file contains the declarations of datum structures.
  4     5*   There are four tyes of datums: your ordinary, run-of-the-mill datum
  4     6*   (Datum); a continuation datum (CN Datum), which is a continuation of
  4     7*   another datum; a continued datum (CD Datum), which is continued (has a
  4     8*   continuation datum) but is not a continuation itself; and a continued
  4     9*   continuation datum (CDCN Datum), which is both continued and is a
  4    10*   continuation.  To illustrate, datums can be pieced combined in the
  4    11*   following ways:
  4    12*   
  4    13*   1) Datum alone.
  4    14*   
  4    15*   2) CD Datum -> CN Datum.
  4    16*   
  4    17*   3) CD Datum -> CDCN Datum {-> CDCN Datum -> ...-> CDCN Datum} -> CN Datum.
  4    18*
  4    19*   continued_datum and continued_continuation_datum each contains a header
  4    20*   which includes the identifier of the datum which is its continuation.
  4    21*   continued_datum.header.full_length is the length in bits of the entire
  4    22*   element, i.e., the addition of the length of contents structure component
  4    23*   of all of the datums from CD Datum to CN Datum.
  4    24**/
  4    25 
  4    26 /* HISTORY:
  4    27*Written by Matthew Pierret, 02/07/82.
  4    28*Modified:
  4    29*03/25/82 by Matthew Pierret: Changed all datum structures to be unaligned.
  4    30*06/14/82 by Matthew Pierret: Added DATUM_HEADER_LENGTH_IN_BYTES.
  4    31*08/04/82 by Matthew Pierret: Added DATUM_HEADER_LENGTH_IN_BITS.
  4    32*10/20/82 by Matthew Pierret:  Split into two include files, this one and
  4    33*            dm_cm_datum_constants.  The latter holds only and all constants
  4    34*            formerly in this include file.
  4    35*10/29/82 by Matthew Pierret:  Removed datum headers.
  4    36*09/18/84 by Matthew Pierret:  Added DESCRIPTION section.  Added datum and
  4    37*            continuation_datum (mainly for illustration).
  4    38*12/03/84 by Matthew Pierret:  Removed the non-based structures
  4    39*            (cd cdcn)_datum_headers.
  4    40**/
  4    41 
  4    42 /* format: style2,ll79,ind3 */
  4    43 
  4    44      dcl	   1 datum	      unaligned based (datum_ptr),
  4    45 	     2 contents	      bit (datum_contents_length_in_bits);
  4    46 
  4    47      dcl	   1 continuation_datum   unaligned based (datum_ptr),
  4    48 	     2 contents	      bit (datum_contents_length_in_bits);
  4    49 
  4    50      dcl	   1 continued_datum      unaligned based (datum_ptr),
  4    51 	     2 header,
  4    52 	       3 full_length      fixed bin (35),
  4    53 	       3 continuation     like datum_id,
  4    54 	     2 contents	      bit (datum_contents_length_in_bits);
  4    55 
  4    56      dcl	   1 continued_continuation_datum
  4    57 			      unaligned based (datum_ptr),
  4    58 	     2 header,
  4    59 	       3 continuation     like datum_id,
  4    60 	     2 contents	      bit (datum_contents_length_in_bits);
  4    61 
  4    62      dcl	   1 datum_id	      aligned based (datum_id_ptr),
  4    63 	     2 control_interval_id
  4    64 			      fixed bin (24) unal uns,
  4    65 	     2 index	      fixed bin (12) unal uns;
  4    66 
  4    67      dcl	   datum_ptr	      ptr init (null ());
  4    68      dcl	   datum_id_ptr	      ptr init (null ());
  4    69      dcl	   datum_contents_length_in_bits
  4    70 			      fixed bin (35) init (-1);
  4    71 
  4    72 
  4    73 
  4    74 /* END INCLUDE FILE dm_cm_datum.incl.pl1 */
      669 
      670 
  5     1 /* BEGIN INCLUDE FILE dm_cm_datum_constants.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*        Contains constants describing the extents of datums and datum
  5     5*   headers.  The datum headers are described in dm_cm_datum.incl.pl1.
  5     6*   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES is the byte length of the largest
  5     7*   datum that can be stored in a control interval, allowing for the largest
  5     8*   possibledatum header. MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS is the same
  5     9*   in bits instead of bytes.  MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
  5    10*   is the smallest length in bits which requires 
  5    11*   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES bytes to store.
  5    12**/
  5    13 
  5    14 /*
  5    15*HISTORY:
  5    16*Written by Matthew Pierret, 02/07/82.
  5    17*Modified:
  5    18*10/29/82 by Matthew Pierret:  Removed DATUM_HEADER*.
  5    19*11/02/82 by Matthew Pierret:  Added maximum datum contents lengths.
  5    20*12/01/82 by Lindsey Spratt:   Corrected values for datum header lengths.
  5    21*09/18/84 by Matthew Pierret:  Corrected values for maximum lengths. Added
  5    22*            MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS.  Added
  5    23*            DESCRIPTION section.
  5    24**/
  5    25 
  5    26 /* format: style2,ind3,ll79 */
  5    27      dcl	   CD_DATUM_HEADER_LENGTH_IN_BYTES
  5    28 			      fixed bin init (8) internal static
  5    29 			      options (constant);
  5    30 
  5    31      dcl	   CD_DATUM_HEADER_LENGTH_IN_BITS
  5    32 			      fixed bin init (72) internal static
  5    33 			      options (constant);
  5    34 
  5    35      dcl	   CDCN_DATUM_HEADER_LENGTH_IN_BYTES
  5    36 			      init (4) fixed bin int static
  5    37 			      options (constant);
  5    38 
  5    39      dcl	   CDCN_DATUM_HEADER_LENGTH_IN_BITS
  5    40 			      init (36) fixed bin int static
  5    41 			      options (constant);
  5    42 
  5    43      dcl	   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
  5    44 			      init (36360) fixed bin (35) internal
  5    45 			      static options (constant);
  5    46 
  5    47      dcl	   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES
  5    48 			      init (4040) fixed bin (35) internal
  5    49 			      static options (constant);
  5    50 
  5    51      dcl	   MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
  5    52 			      init (36352) fixed bin (35) internal
  5    53 			      static options (constant);
  5    54 
  5    55 /* END INCLUDE FILE dm_cm_datum.incl.pl1 */
      671 
      672 
  6     1 /*  BEGIN INCLUDE FILE:  dm_ci_parts.incl.pl1  */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*
  6     5*        This include file contains the ci_parts structure.  This structure
  6     6*   is used across the file_manager_ interface to specify the parts of a
  6     7*   control interval to get or put.  If the number_of parts is equal to 0,
  6     8*   modules which take ci_parts interpret this case to mean to do everything
  6     9*   except the actual requested operation, i.e., lock the control interval
  6    10*   but don't get anything.  offset_in_bytes is the 0-originned offset in
  6    11*   bytes from the beginning of the addressable portion of the control interval.
  6    12*   An offset_in_bytes which is in the addressable portion is in error.
  6    13*   Likewise, if offset_in_bytes + length_in_bytes is outside of the addressable
  6    14*   portion, it is in error.
  6    15**/
  6    16 
  6    17 /* HISTORY:
  6    18*Written by Matthew Pierret, 01/28/82.
  6    19*  (01/28/82 Andre Bensoussan, Design.)
  6    20*Modified:
  6    21*11/07/84 by Matthew Pierret:  To add must_be_zero, initial attributes on
  6    22*            automatic storge.
  6    23**/
  6    24 
  6    25 /* format: style2,ind3 */
  6    26 
  6    27      dcl	   1 ci_parts	      aligned based (ci_parts_ptr),
  6    28 	     2 number_of_parts    fixed bin (17),
  6    29 	     2 must_be_zero	      fixed bin,
  6    30 	     2 part	      (cip_number_of_parts refer (ci_parts.number_of_parts)),
  6    31 	       3 offset_in_bytes  fixed bin (17),
  6    32 	       3 length_in_bytes  fixed bin (17),
  6    33 	       3 local_ptr	      ptr;
  6    34 
  6    35      dcl	   ci_parts_ptr	      ptr init (null ());
  6    36      dcl	   cip_number_of_parts    fixed bin (17) init (0);
  6    37 
  6    38 
  6    39 /*  BEGIN INCLUDE FILE:   dm_ci_parts.incl.pl1   */
      673 
      674 
  7     1 /* BEGIN INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*
  7     5*   Contains entry declarations of internally available collection_manager_
  7     6*   entries.  Entries which are only available via the collection_manager_
  7     7*   transfer vector are not included here, but are declared instead in 
  7     8*   dm_collmgr_entry_dcls.incl.pl1.
  7     9**/
  7    10 
  7    11 /* HISTORY:
  7    12*Written by Mathew Pierret, 04/01/82.
  7    13*Modified:
  7    14*09/21/82 by Lindsey Spratt:  Added the cm_compact$replacement entry.
  7    15*10/29/82 by Matthew Pierret:  Added cm_find_free_slot, cm_determine_free_space,
  7    16*            cm_find_ci_to_alloc_datum, cm_recursive_put.
  7    17*            Added cm_get_element$info*, $header*.  The former is used when
  7    18*            the caller has a cm_info structure already; the latter is used to
  7    19*            get collection headers.
  7    20*            Added cm_opening_info$get. Removed cm_add_ci_(part thread).
  7    21*            Added cm_allocate_element$info.
  7    22*11/09/82 by Matthew Pierret:  Added argument to cm_allocate_ordered_element
  7    23*            calling sequence for returning free space.
  7    24*            Added cm_free_cn_datum("" $header).
  7    25*01/07/83 by Matthew Pierret:  Added:
  7    26*            cm_allocate_element$buffered("" _info);
  7    27*            cm_put_element$buffered("" _info);
  7    28*            cm_put_datum_in_place$buffered("" _continued);
  7    29*            cm_put_datum_in_pool$buffered("" _continued);
  7    30*            cm_compact$buffered.
  7    31*01/26/83 by Matthew Pierret: Replaced cm_get_header_and_slot with
  7    32*            cm_get_bci_header$slot and added cm_get_bci_header$slot_exclusive.
  7    33*            Added cm_opening_info$get_storage_record.
  7    34*            Added a bit(36)aligned argument to cm_recursive_put to hold the
  7    35*            id of the previous datum.
  7    36*02/02/83 by Matthew Pierret: Added fixed bin (17) argument to cm_find_free_slot
  7    37*            which is for the number of slots after allocation.
  7    38*02/07/83 by Matthew Pierret: Added cm_get_id$(id info info_return_slot
  7    39*            header header_return_slot).
  7    40*            Added cm_get_element_portion$(exclusive info info_exclusive).
  7    41*            Added cm_get_element$bypass_info.
  7    42*03/25/83 by Matthew Pierret: Added cm_free_element$info and
  7    43*            cm_free_opening_info.
  7    44*04/29/83 by Matthew Pierret: Added cm_put_element$unprotected_info
  7    45*08/04/83 by Matthew Pierret:  Added the entries $does_new_datum_fit and
  7    46*            $does_replacement_fit to cm_determine_free_space.  These entries
  7    47*            return flags indicating if a datum fits in the ci and the pool.
  7    48*            Added a bit(1)aligned parameter to cm_find_free_slot in which is
  7    49*            returned the new value of bci_header.free_slot_is_present.
  7    50*02/07/84 by Matthew Pierret:  Added cm_get_id$ptr.  Removed all cm_get_id
  7    51*            modules except cm_get_id$id.  Removed all cm_get_element$info*
  7    52*            entries.  Changed cm_get_element_$bypass_info to have the same
  7    53*            calling sequence as other cm_get_element entries.
  7    54*06/12/84 by Matthew Pierret:  Changed cm_put_element to cm_modify
  7    55*            and cm_allocate_element to cm_put.
  7    56*            Switched the element_length/element_ptr parameter pair to be
  7    57*            element_ptr/element_length in cm_modify and cm_put.
  7    58*07/24/84 by Matthew Pierret:  Added cm_free_ci$raw_return_prev_next.
  7    59*09/24/84 by Matthew Pierret:  Added trace_thread_modifications_(on off)
  7    60*            entries to cm_free_ci and cm_replace_buffered_ci, 
  7    61*            cm_allocate_ci$info_header, cm_opening_info$opening_table_ptr.
  7    62*            Removed cm_find_free_space. Commented out un-used entries.
  7    63*            Re-named allocate  entries to put entries, except for allocate_ci.
  7    64*            Re-named free element and free datum entries to use delete instead
  7    65*            of free, and cm_recursive_put to cm_recursive_modify.
  7    66*            Removed cm_get_element$bypass_info.
  7    67*02/27/85 by Matthew C. Pierret:  Re-added cm_compact$buffered_replacement now
  7    68*            that cm_modify$buffered uses it.
  7    69*03/07/85 by R. Michael Tague:  Added cm_postcommit_increment.
  7    70**/
  7    71 
  7    72 /* format: style2,ind3 */
  7    73 
  7    74 
  7    75      dcl	   cm_allocate_ci	      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  7    76      dcl	   cm_allocate_ci$info    entry (ptr, fixed bin (24) unsigned, fixed bin (35));
  7    77      dcl	   cm_allocate_ci$info_header
  7    78 			      entry (ptr, fixed bin (24) unsigned, ptr, fixed bin (35));
  7    79 
  7    80 
  7    81      dcl	   cm_compact	      entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
  7    82      dcl	   cm_compact$buffered    entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
  7    83      dcl	   cm_compact$replacement entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
  7    84      dcl	   cm_compact$buffered_replacement
  7    85 			      entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
  7    86 
  7    87      dcl	   cm_delete_cn_datum     entry (ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
  7    88 
  7    89      dcl	   cm_delete_cn_datum$header
  7    90 			      entry (ptr, ptr, ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
  7    91 
  7    92      dcl	   cm_delete	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  7    93 			      fixed bin (35));
  7    94      dcl	   cm_delete$info	      entry (ptr, bit (36) aligned, bit (1) aligned, fixed bin (35));
  7    95 
  7    96      dcl	   cm_determine_free_space$all
  7    97 			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35));
  7    98      dcl	   cm_determine_free_space$effective
  7    99 			      entry (ptr, fixed bin (35), bit (1) aligned, bit (1) aligned, fixed bin (35),
  7   100 			      fixed bin (35));
  7   101      dcl	   cm_determine_free_space$does_new_datum_fit
  7   102 			      entry (ptr, fixed bin (35), fixed bin (35), bit (1) aligned, bit (1) aligned,
  7   103 			      bit (1) aligned, bit (1) aligned, fixed bin (35));
  7   104 
  7   105 /**** Not yet used *********************************************************
  7   106*     dcl	   cm_determine_free_space$does_replacement_fit
  7   107*			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35), bit (1) aligned,
  7   108*			      bit (1) aligned, bit (1) aligned, bit (1) aligned, fixed bin (35)); 
  7   109*************************************************************************** */
  7   110 
  7   111      dcl	   cm_find_ci_to_alloc_datum
  7   112 			      entry (ptr, fixed bin (35), fixed bin (24) uns, bit (1) aligned, bit (1) aligned, ptr,
  7   113 			      fixed bin (24) uns, fixed bin (35));
  7   114 
  7   115      dcl	   cm_find_free_slot      entry (bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (17), fixed bin (17),
  7   116 			      bit (1) aligned, fixed bin (35));
  7   117 
  7   118      dcl	   cm_free_ci$info	      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (35));
  7   119      dcl	   cm_free_ci$raw_return_prev_next
  7   120 			      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (24) uns,
  7   121 			      fixed bin (24) uns, fixed bin (35));
  7   122      dcl	   cm_free_ci$trace_thread_modifications_on
  7   123 			      entry ();
  7   124      dcl	   cm_free_ci$trace_thread_modifications_off
  7   125 			      entry ();
  7   126 
  7   127 
  7   128      dcl	   cm_free_opening_info   entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  7   129 
  7   130      dcl	   cm_get_bci_header      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
  7   131      dcl	   cm_get_bci_header$exclusive
  7   132 			      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
  7   133      dcl	   cm_get_bci_header$slot entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  7   134 
  7   135 /**** Not yet used ********************************************************
  7   136*     dcl	   cm_get_bci_header$slot_exclusive
  7   137*			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  7   138*************************************************************************** */
  7   139 
  7   140      dcl	   cm_get_element	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  7   141 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  7   142      dcl	   cm_get_element$exclusive
  7   143 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  7   144 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  7   145 
  7   146      dcl	   cm_get_element_portion entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  7   147 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  7   148 			      fixed bin (35), fixed bin (35));
  7   149 
  7   150 /**** Not yet used ********************************************************
  7   151*     dcl	   cm_get_element_portion$exclusive
  7   152*			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  7   153*			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  7   154*			      fixed bin (35), fixed bin (35));
  7   155*************************************************************************** */
  7   156 
  7   157      dcl	   cm_get_id$id	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
  7   158 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  7   159      dcl	   cm_get_id$ptr	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
  7   160 			      bit (1) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  7   161 
  7   162      dcl	   cm_modify	      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   163 			      fixed bin (35), fixed bin (35));
  7   164      dcl	   cm_modify$buffered     entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   165 			      fixed bin (35), fixed bin (35));
  7   166 
  7   167 /******* Not yet used *****************************************************
  7   168*     dcl	   cm_modify$buffered_info
  7   169*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
  7   170*			      fixed bin (35));
  7   171*****************************************************************************/
  7   172 
  7   173      dcl	   cm_modify$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  7   174      dcl	   cm_modify$unprotected_info
  7   175 			      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  7   176 
  7   177 
  7   178 /******* Not yet used *****************************************************
  7   179*     dcl	   cm_modify_portion entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35),
  7   180*			      fixed bin (35), ptr, bit (36) aligned, fixed bin (35), fixed bin (35));
  7   181*****************************************************************************/
  7   182 
  7   183 
  7   184      dcl	   cm_opening_info$get    entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  7   185      dcl	   cm_opening_info$get_storage_record
  7   186 			      entry (ptr, fixed bin (35));
  7   187      dcl	   cm_opening_info$full_get
  7   188 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  7   189      dcl	   cm_opening_info$opening_table_ptr
  7   190 			      entry () returns (ptr);
  7   191 
  7   192      dcl	   cm_postcommit_increment
  7   193 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  7   194 
  7   195      dcl	   cm_put		      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   196 			      fixed bin (35), fixed bin (35));
  7   197      dcl	   cm_put$buffered	      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   198 			      fixed bin (35), fixed bin (35));
  7   199 
  7   200 /******* Not yet used *****************************************************
  7   201*     dcl	   cm_put$buffered_info
  7   202*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
  7   203*			      fixed bin (35));
  7   204*****************************************************************************/
  7   205 
  7   206      dcl	   cm_put$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  7   207 
  7   208      dcl	   cm_put_basic_element   entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  7   209 			      fixed bin (35));
  7   210 
  7   211      dcl	   cm_put_cn_datum	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, bit (36) aligned, fixed bin (35));
  7   212 
  7   213      dcl	   cm_put_datum_in_place  entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  7   214 			      fixed bin (35));
  7   215      dcl	   cm_put_datum_in_place$buffered
  7   216 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  7   217      dcl	   cm_put_datum_in_place$buffered_continued
  7   218 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
  7   219 			      fixed bin (35));
  7   220      dcl	   cm_put_datum_in_place$continued
  7   221 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  7   222 			      fixed bin (35), bit (36) aligned, fixed bin (35));
  7   223 
  7   224      dcl	   cm_put_datum_in_pool   entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  7   225 			      fixed bin (35));
  7   226      dcl	   cm_put_datum_in_pool$buffered
  7   227 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  7   228      dcl	   cm_put_datum_in_pool$buffered_continued
  7   229 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
  7   230 			      fixed bin (35));
  7   231      dcl	   cm_put_datum_in_pool$continued
  7   232 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  7   233 			      fixed bin (35), bit (36) aligned, fixed bin (35));
  7   234 
  7   235      dcl	   cm_put_ordered_element entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  7   236 			      fixed bin (35));
  7   237      dcl	   cm_put_ordered_element$buffered
  7   238 			      entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  7   239 			      fixed bin (35));
  7   240 
  7   241      dcl	   cm_put_overlength_tail entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35));
  7   242 
  7   243      dcl	   cm_recursive_modify    entry (ptr, bit (36) aligned, ptr, fixed bin (35), fixed bin (35), bit (36) aligned,
  7   244 			      fixed bin (35));
  7   245 
  7   246 
  7   247      dcl	   cm_replace_buffered_ci$trace_thread_modifications_on
  7   248 			      entry ();
  7   249      dcl	   cm_replace_buffered_ci$trace_thread_modifications_off
  7   250 			      entry ();
  7   251 
  7   252 /* END INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
      675 
      676 
  8     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  8     2 /* format: style3 */
  8     3 
  8     4 /* These constants are to be used for the flags argument of sub_err_ */
  8     5 /* They are just "string (condition_info_header.action_flags)" */
  8     6 
  8     7 declare	(
  8     8 	ACTION_CAN_RESTART	init (""b),
  8     9 	ACTION_CANT_RESTART init ("1"b),
  8    10 	ACTION_DEFAULT_RESTART
  8    11 			init ("01"b),
  8    12 	ACTION_QUIET_RESTART
  8    13 			init ("001"b),
  8    14 	ACTION_SUPPORT_SIGNAL
  8    15 			init ("0001"b)
  8    16 	)		bit (36) aligned internal static options (constant);
  8    17 
  8    18 /* End include file */
      677 
      678 
      679    end cm_get_element_portion;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0912.7  cm_get_element_portion.pl1        >spec>on>7192.pbf-04/04/85>cm_get_element_portion.pl1
663          1    01/07/85  0858.0  dm_cm_basic_ci.incl.pl1           >ldd>include>dm_cm_basic_ci.incl.pl1
665          2    01/07/85  0858.1  dm_cm_basic_ci_const.incl.pl1     >ldd>include>dm_cm_basic_ci_const.incl.pl1
667          3    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
669          4    01/07/85  0901.2  dm_cm_datum.incl.pl1              >ldd>include>dm_cm_datum.incl.pl1
671          5    01/07/85  0858.2  dm_cm_datum_constants.incl.pl1    >ldd>include>dm_cm_datum_constants.incl.pl1
673          6    01/07/85  0900.8  dm_ci_parts.incl.pl1              >ldd>include>dm_ci_parts.incl.pl1
675          7    04/04/85  0819.0  dm_cm_entry_dcls.incl.pl1         >spec>on>7192.pbf-04/04/85>dm_cm_entry_dcls.incl.pl1
677          8    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000026 constant        bit(36)                  initial dcl 8-7 set ref 442* 474* 487* 591* 649*
BASIC_CI_LAYOUT_1               000000 constant        char(4)                  initial dcl 1-97 set ref 442 442*
BITS_PER_BYTE                   002266 constant        fixed bin(17,0)          initial dcl 166 ref 295 299 311 360 364 376 521 529
                                                                                  533 544 614 626 649
BYTES_PER_DOUBLE_WORD           002265 constant        fixed bin(17,0)          initial dcl 166 ref 319 384 551
CD_DATUM_HEADER_LENGTH_IN_BITS         constant        fixed bin(17,0)          initial dcl 5-31 ref 339 353 356 517
FREE_SLOT                              constant        fixed bin(15,0)          initial unsigned dcl 2-13 ref 264
THIS_IS_FIRST_CI_SEEN           000026 constant        bit(1)                   initial dcl 166 set ref 238*
THIS_IS_NOT_FIRST_CI_SEEN       000026 constant        bit(1)                   initial dcl 166 set ref 588*
TO_END_OF_ELEMENT               002264 constant        fixed bin(35,0)          initial dcl 166 ref 273 290 339 353 524
addcharno                                              builtin function         dcl 154 ref 276 571 606 641
addr                                                   builtin function         dcl 154 ref 236 238 240 257 257 286 350 474 474 520
                                                                                  582 588 591 591 591 591 591 601 601 618 621 629
                                                                                  649 649
basic_control_interval                 based           structure                level 1 dcl 1-56
bci_header                             based           structure                level 1 dcl 1-63
buffer                                 based           fixed bin(71,0)          array dcl 148 ref 324 389 418 556
buffer_length_in_bits           000105 automatic       fixed bin(35,0)          initial dcl 117 set ref 117* 229* 231* 299 364 533
buffer_length_in_double_words   000106 automatic       fixed bin(35,0)          initial dcl 118 set ref 118* 319* 324 384* 389 418
                                                                                  551* 556
buffer_ptr                      000122 automatic       pointer                  initial dcl 134 set ref 134* 226* 229 324* 331 334
                                                                                  389* 396 399 415 415 418 556* 564 569 571 658
ccl_p_ci_layout                        parameter       char(4)                  dcl 440 set ref 438 442 442*
cd_datum_header                 000130 automatic       structure                level 1 dcl 138 set ref 580*
ceil                                                   builtin function         dcl 154 ref 295 319 360 384 521 529 551 614 626
ci_parts_ptr                    000152 automatic       pointer                  initial dcl 6-35 set ref 6-35*
ci_ptr                          000116 automatic       pointer                  initial dcl 132 set ref 132* 238* 240 246* 257 276
                                                                                  422* 588* 591 601 606
cip_number_of_parts             000154 automatic       fixed bin(17,0)          initial dcl 6-36 set ref 6-36*
cleanup                         000132 stack reference condition                dcl 159 ref 323 388 555
cm_get_id$ptr                   000032 constant        entry                    external dcl 7-159 ref 246
code                            000104 automatic       fixed bin(35,0)          initial dcl 116 set ref 116* 246* 250 250*
collection_id                   000101 automatic       bit(36)                  dcl 111 in procedure "cm_get_element_portion" set
                                                                                  ref 221* 238* 246* 588*
collection_id             1            based           bit(36)                  level 2 in structure "bci_header" dcl 1-63
                                                                                  in procedure "cm_get_element_portion" set ref 482
                                                                                  487*
contents                               based           bit                      level 2 in structure "continuation_datum" packed
                                                                                  unaligned dcl 4-47 in procedure
                                                                                  "cm_get_element_portion" set ref 629
contents                               based           bit                      level 2 in structure "datum" packed unaligned
                                                                                  dcl 4-44 in procedure "cm_get_element_portion" set
                                                                                  ref 286
contents                  1            based           bit                      level 2 in structure "continued_continuation_datum"
                                                                                  packed unaligned dcl 4-56 in procedure
                                                                                  "cm_get_element_portion" set ref 618
contents                  2            based           bit                      level 2 in structure "continued_datum" packed
                                                                                  unaligned dcl 4-50 in procedure
                                                                                  "cm_get_element_portion" set ref 350 520
continuation                           based           structure                level 3 in structure "continued_continuation_datum"
                                                                                  packed unaligned dcl 4-56 in procedure
                                                                                  "cm_get_element_portion" ref 621
continuation              1     000130 automatic       structure                level 2 in structure "cd_datum_header" dcl 138
                                                                                  in procedure "cm_get_element_portion" set ref 582
continuation_datum                     based           structure                level 1 packed unaligned dcl 4-47
continuation_datum_id                  based           structure                level 1 dcl 144 set ref 582* 621*
continuation_datum_id_string    000102 automatic       bit(36)                  initial dcl 113 set ref 113* 471 582 584 588 591 591
                                                                                  591 601 620 621 631*
continued_continuation_datum           based           structure                level 1 packed unaligned dcl 4-56
continued_datum                        based           structure                level 1 packed unaligned dcl 4-50
continued_datum_id                     based           structure                level 1 dcl 142
continued_datum_id_string       000103 automatic       bit(36)                  initial dcl 113 set ref 113* 474 474 578* 591 591
                                                                                  620*
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "continued_datum_id" packed
                                                                                  unsigned unaligned dcl 142 in procedure
                                                                                  "cm_get_element_portion" set ref 474* 591*
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "continuation_datum_id" packed
                                                                                  unsigned unaligned dcl 144 in procedure
                                                                                  "cm_get_element_portion" set ref 588 591*
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "element_id" packed unsigned
                                                                                  unaligned dcl 3-32 in procedure
                                                                                  "cm_get_element_portion" set ref 238 649*
current_buffer_ptr              000124 automatic       pointer                  initial dcl 135 set ref 135* 564* 571* 638 641* 641
datum                                  based           structure                level 1 packed unaligned dcl 4-44
datum_contents_length_in_bits   000150 automatic       fixed bin(35,0)          initial dcl 4-69 set ref 286 290* 292* 295 350 353*
                                                                                  356* 360 400 4-69* 517* 520 521 611* 614 618 629
datum_contents_length_in_bytes  000107 automatic       fixed bin(17,0)          initial dcl 120 set ref 120* 295* 299 311 319 331
                                                                                  331 360* 364 376 384 396 396 521* 561 569 569 571
                                                                                  573 614* 626* 634* 634 638 638 641 644
datum_contents_ptr              000126 automatic       pointer                  initial dcl 136 set ref 136* 286* 331 350* 396 520*
                                                                                  569 618* 629* 638
datum_contents_string                  based           char                     unaligned dcl 150 set ref 331* 331 396* 396 569* 569
                                                                                  638* 638
datum_id                               based           structure                level 1 dcl 4-62
datum_id_ptr                    000146 automatic       pointer                  initial dcl 4-68 set ref 4-68*
datum_position_table      5            based           structure                array level 2 dcl 1-56 set ref 257 601
datum_ptr                       000144 automatic       pointer                  initial dcl 4-67 set ref 276* 286 350 4-67* 520 524
                                                                                  526 580 606* 611 618 621 629
datum_slot                             based           structure                level 1 dcl 1-82
datum_slot_ptr                  000140 automatic       pointer                  dcl 1-95 set ref 257* 264 264 276 278 290 292 335
                                                                                  339 353 356 517 601* 606 608 611 626
divide                                                 builtin function         dcl 154 ref 295 319 360 384 521 529 551 614 626
dm_error_$ci_not_allocated      000020 external static fixed bin(35,0)          dcl 188 ref 468
dm_error_$ci_not_in_collection  000022 external static fixed bin(35,0)          dcl 188 set ref 485*
dm_error_$long_return_element   000030 external static fixed bin(35,0)          dcl 188 set ref 315* 380* 547*
dm_error_$no_element            000024 external static fixed bin(35,0)          dcl 188 set ref 236* 240* 264* 471*
dm_error_$programming_error     000026 external static fixed bin(35,0)          dcl 188 set ref 487* 591* 649*
element_id                             based           structure                level 1 dcl 3-32
element_id_string               000142 automatic       bit(36)                  dcl 3-30 set ref 225* 236 238 240 246 246 246* 257
                                                                                  406 406 578 649 649
er_code                                parameter       fixed bin(35,0)          dcl 430 ref 427 432
error_table_$bad_arg            000014 external static fixed bin(35,0)          dcl 184 set ref 273*
error_table_$unimplemented_version
                                000016 external static fixed bin(35,0)          dcl 184 set ref 442*
exclusive_get                   000114 automatic       bit(1)                   initial dcl 130 set ref 130* 198* 210*
file_manager_$get_ci_ptr        000010 constant        entry                    external dcl 177 ref 466
file_opening_id                 000100 automatic       bit(36)                  dcl 111 set ref 220* 238* 246* 588*
flags                                  based           structure                level 2 packed unaligned dcl 1-82
full_length                     000130 automatic       fixed bin(35,0)          level 2 in structure "cd_datum_header" dcl 138
                                                                                  in procedure "cm_get_element_portion" set ref 659
full_length                            based           fixed bin(35,0)          level 3 in structure "continued_datum" packed
                                                                                  unaligned dcl 4-50 in procedure
                                                                                  "cm_get_element_portion" ref 524 526
gcp_code                        000106 automatic       fixed bin(35,0)          dcl 460 set ref 466* 468 468 468* 474*
gcp_p_ci_id                            parameter       fixed bin(24,0)          unsigned dcl 458 set ref 450 466 474* 487*
gcp_p_ci_ptr                           parameter       pointer                  dcl 459 set ref 450 463 463* 466* 480 482 487
gcp_p_collection_id                    parameter       bit(36)                  dcl 457 set ref 450 482 487*
gcp_p_foid                             parameter       bit(36)                  dcl 456 set ref 450 466*
gcp_p_this_is_first_ci_seen            parameter       bit(1)                   dcl 454 ref 450 485
header                                 based           structure                level 2 in structure "basic_control_interval"
                                                                                  dcl 1-56 in procedure "cm_get_element_portion"
header                                 based           structure                level 2 in structure "continued_continuation_datum"
                                                                                  packed unaligned dcl 4-56 in procedure
                                                                                  "cm_get_element_portion" ref 611
header                                 based           structure                level 2 in structure "continued_datum" packed
                                                                                  unaligned dcl 4-50 in procedure
                                                                                  "cm_get_element_portion" ref 580
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "continued_datum_id" packed
                                                                                  unsigned unaligned dcl 142 in procedure
                                                                                  "cm_get_element_portion" set ref 474* 591*
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "element_id" packed unsigned
                                                                                  unaligned dcl 3-32 in procedure
                                                                                  "cm_get_element_portion" set ref 236 240 257 649*
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "continuation_datum_id" packed
                                                                                  unsigned unaligned dcl 144 in procedure
                                                                                  "cm_get_element_portion" set ref 591 591* 601
is_continuation           0(02)        based           bit(1)                   level 3 packed unaligned dcl 1-82 ref 264
is_continued              0(01)        based           bit(1)                   level 3 packed unaligned dcl 1-82 ref 278 608
layout_type                            based           char(4)                  level 2 dcl 1-63 ref 480
length                                                 builtin function         dcl 154 ref 611
length_in_bits            0(19)        based           fixed bin(17,0)          level 2 packed unsigned unaligned dcl 1-82 ref 290
                                                                                  292 335 339 353 356 517 611 626
min                                                    builtin function         dcl 154 ref 292 356 526 634
myname                          000001 constant        varying char(32)         initial dcl 163 set ref 442* 474* 487* 591* 649*
null                                                   builtin function         dcl 154 ref 132 133 134 135 136 229 246 308 373 4-67
                                                                                  4-68 6-35 415 442 442 463 474 474 487 487 503 541
                                                                                  591 591 649 649
number_of_datums          4(18)        based           fixed bin(17,0)          level 3 packed unaligned dcl 1-56 ref 240 591
offset_in_bytes           0(04)        based           fixed bin(15,0)          level 2 packed unsigned unaligned dcl 1-82 ref 264
                                                                                  276 606
p_area_ptr                             parameter       pointer                  dcl 99 ref 84 201 307 372 540
p_buffer_length                        parameter       fixed bin(35,0)          dcl 98 ref 84 201 231
p_buffer_ptr                           parameter       pointer                  dcl 97 ref 84 201 226 415
p_code                                 parameter       fixed bin(35,0)          dcl 107 set ref 84 201 216* 432*
p_collection_id                        parameter       bit(36)                  dcl 94 ref 84 201 221
p_element_id                           parameter       bit(36)                  dcl 95 set ref 84 201 225 406 406*
p_element_length                       parameter       fixed bin(35,0)          dcl 106 set ref 84 201 311* 335* 376* 400* 544* 659*
p_element_ptr                          parameter       pointer                  dcl 105 set ref 84 201 334* 399* 658*
p_file_opening_id                      parameter       bit(36)                  dcl 93 ref 84 201 220
p_new_buffer_was_allocated             parameter       bit(1)                   dcl 103 set ref 84 201 218* 325* 390* 419* 557*
p_portion_beginning_index              parameter       fixed bin(35,0)          dcl 100 ref 84 201
p_portion_length                       parameter       fixed bin(35,0)          dcl 102 ref 84 201 224
p_position                             parameter       fixed bin(17,0)          dcl 96 ref 84 201 222
portion_length_in_bits          000110 automatic       fixed bin(35,0)          initial dcl 122 set ref 122* 224* 273 273 290 292
                                                                                  339 339 353 356 524 524* 526* 526 529 649* 649
portion_length_in_bytes         000111 automatic       fixed bin(17,0)          initial dcl 123 set ref 123* 529* 533 544 551 565
                                                                                  573
position_from_specified_element 000112 automatic       fixed bin(17,0)          initial dcl 125 set ref 125* 222* 233 246*
remaining_portion_length_in_bytes
                                000113 automatic       fixed bin(17,0)          initial dcl 127 set ref 127* 565* 573* 584 634 644*
                                                                                  644 649 649
sub_err_                        000012 constant        entry                    external dcl 180 ref 442 474 487 591 649
tcp_p_ci_ptr                           parameter       pointer                  dcl 501 set ref 498 503*
unspec                                                 builtin function         dcl 154 ref 611
work_area                              based           area(1024)               dcl 147 ref 324 389 418 556
work_area_ptr                   000120 automatic       pointer                  initial dcl 133 set ref 133* 307* 308 324 372* 373
                                                                                  389 418 540* 541 556

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 8-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 8-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 8-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 8-7
BCI_HEADER_LENGTH_IN_BYTES             internal static fixed bin(17,0)          initial dcl 2-14
CDCN_DATUM_HEADER_LENGTH_IN_BITS       internal static fixed bin(17,0)          initial dcl 5-39
CDCN_DATUM_HEADER_LENGTH_IN_BYTES      internal static fixed bin(17,0)          initial dcl 5-35
CD_DATUM_HEADER_LENGTH_IN_BYTES        internal static fixed bin(17,0)          initial dcl 5-27
DATUM_POSITION_TABLE_OFFSET_IN_BYTES   internal static fixed bin(17,0)          initial dcl 2-16
MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS  internal static fixed bin(35,0)          initial dcl 5-43
MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES internal static fixed bin(35,0)          initial dcl 5-47
MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
                                       internal static fixed bin(35,0)          initial dcl 5-51
basic_control_interval_ptr             automatic       pointer                  dcl 1-92
bci_header_ptr                         automatic       pointer                  dcl 1-94
ci_parts                               based           structure                level 1 dcl 6-27
cm_allocate_ci                  000000 constant        entry                    external dcl 7-75
cm_allocate_ci$info             000000 constant        entry                    external dcl 7-76
cm_allocate_ci$info_header      000000 constant        entry                    external dcl 7-77
cm_compact                      000000 constant        entry                    external dcl 7-81
cm_compact$buffered             000000 constant        entry                    external dcl 7-82
cm_compact$buffered_replacement 000000 constant        entry                    external dcl 7-84
cm_compact$replacement          000000 constant        entry                    external dcl 7-83
cm_delete                       000000 constant        entry                    external dcl 7-92
cm_delete$info                  000000 constant        entry                    external dcl 7-94
cm_delete_cn_datum              000000 constant        entry                    external dcl 7-87
cm_delete_cn_datum$header       000000 constant        entry                    external dcl 7-89
cm_determine_free_space$all     000000 constant        entry                    external dcl 7-96
cm_determine_free_space$does_new_datum_fit
                                000000 constant        entry                    external dcl 7-101
cm_determine_free_space$effective
                                000000 constant        entry                    external dcl 7-98
cm_find_ci_to_alloc_datum       000000 constant        entry                    external dcl 7-111
cm_find_free_slot               000000 constant        entry                    external dcl 7-115
cm_free_ci$info                 000000 constant        entry                    external dcl 7-118
cm_free_ci$raw_return_prev_next 000000 constant        entry                    external dcl 7-119
cm_free_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 7-124
cm_free_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 7-122
cm_free_opening_info            000000 constant        entry                    external dcl 7-128
cm_get_bci_header               000000 constant        entry                    external dcl 7-130
cm_get_bci_header$exclusive     000000 constant        entry                    external dcl 7-131
cm_get_bci_header$slot          000000 constant        entry                    external dcl 7-133
cm_get_element                  000000 constant        entry                    external dcl 7-140
cm_get_element$exclusive        000000 constant        entry                    external dcl 7-142
cm_get_element_portion          000000 constant        entry                    external dcl 7-146
cm_get_id$id                    000000 constant        entry                    external dcl 7-157
cm_modify                       000000 constant        entry                    external dcl 7-162
cm_modify$buffered              000000 constant        entry                    external dcl 7-164
cm_modify$info                  000000 constant        entry                    external dcl 7-173
cm_modify$unprotected_info      000000 constant        entry                    external dcl 7-174
cm_opening_info$full_get        000000 constant        entry                    external dcl 7-187
cm_opening_info$get             000000 constant        entry                    external dcl 7-184
cm_opening_info$get_storage_record
                                000000 constant        entry                    external dcl 7-185
cm_opening_info$opening_table_ptr
                                000000 constant        entry                    external dcl 7-189
cm_postcommit_increment         000000 constant        entry                    external dcl 7-192
cm_put                          000000 constant        entry                    external dcl 7-195
cm_put$buffered                 000000 constant        entry                    external dcl 7-197
cm_put$info                     000000 constant        entry                    external dcl 7-206
cm_put_basic_element            000000 constant        entry                    external dcl 7-208
cm_put_cn_datum                 000000 constant        entry                    external dcl 7-211
cm_put_datum_in_place           000000 constant        entry                    external dcl 7-213
cm_put_datum_in_place$buffered  000000 constant        entry                    external dcl 7-215
cm_put_datum_in_place$buffered_continued
                                000000 constant        entry                    external dcl 7-217
cm_put_datum_in_place$continued 000000 constant        entry                    external dcl 7-220
cm_put_datum_in_pool            000000 constant        entry                    external dcl 7-224
cm_put_datum_in_pool$buffered   000000 constant        entry                    external dcl 7-226
cm_put_datum_in_pool$buffered_continued
                                000000 constant        entry                    external dcl 7-228
cm_put_datum_in_pool$continued  000000 constant        entry                    external dcl 7-231
cm_put_ordered_element          000000 constant        entry                    external dcl 7-235
cm_put_ordered_element$buffered 000000 constant        entry                    external dcl 7-237
cm_put_overlength_tail          000000 constant        entry                    external dcl 7-241
cm_recursive_modify             000000 constant        entry                    external dcl 7-243
cm_replace_buffered_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 7-249
cm_replace_buffered_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 7-247

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_CI_LAYOUT                 001143 constant        entry                    internal dcl 438 ref 480
ERROR_RETURN                    001121 constant        entry                    internal dcl 427 ref 236 240 250 264 273 315 380 468
                                                                                  471 485 547
FINISH                          001062 constant        entry                    internal dcl 412 ref 323 388 433 555
GET_CI_PTR                      001225 constant        entry                    internal dcl 450 ref 238 588
GET_EACH_DATUM_LOOP             001730 constant        label                    dcl 584
JOIN                            000335 constant        label                    dcl 216 ref 199 211
MAIN_RETURN                     001060 constant        label                    dcl 409 ref 434
MG_ALLOC_BUFFER                 001576 constant        label                    dcl 533
MULTI_DATUM_GET                 001520 constant        entry                    internal dcl 509 ref 404
SG_ALLOC_BUFFER                 000610 constant        label                    dcl 299
SIMPLE_GET                      000561 constant        label                    dcl 278
SIMPLE_MULTI_DATUM_GET          000722 constant        label                    dcl 339
SMG_ALLOC_BUFFER                000747 constant        label                    dcl 364
TERMINATE_CI_PTR                001506 constant        entry                    internal dcl 498 ref 422 463
cm_get_element_portion          000312 constant        entry                    external dcl 84
exclusive                       000324 constant        entry                    external dcl 201

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2532        2566    2267        2542
Length      3162    2267        34         360     243           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cm_get_element_portion              154 external procedure  is an external procedure.  
on unit on line 323                  64 on unit               
on unit on line 388                  64 on unit               
FINISH                               70 internal procedure  is called by several nonquick procedures.  
ERROR_RETURN                         64 internal procedure  is called by several nonquick procedures.  
CHECK_CI_LAYOUT                         internal procedure  shares stack frame of internal procedure GET_CI_PTR.  
GET_CI_PTR                          212 internal procedure  is called by several nonquick procedures.  
TERMINATE_CI_PTR                     64 internal procedure  is called by several nonquick procedures.  
MULTI_DATUM_GET                     174 internal procedure  enables or reverts conditions.  
on unit on line 555                  64 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
GET_CI_PTR               000106 gcp_code                    GET_CI_PTR
cm_get_element_portion   000100 file_opening_id             cm_get_element_portion
                         000101 collection_id               cm_get_element_portion
                         000102 continuation_datum_id_string
                                                            cm_get_element_portion
                         000103 continued_datum_id_string   cm_get_element_portion
                         000104 code                        cm_get_element_portion
                         000105 buffer_length_in_bits       cm_get_element_portion
                         000106 buffer_length_in_double_words
                                                            cm_get_element_portion
                         000107 datum_contents_length_in_bytes
                                                            cm_get_element_portion
                         000110 portion_length_in_bits      cm_get_element_portion
                         000111 portion_length_in_bytes     cm_get_element_portion
                         000112 position_from_specified_element
                                                            cm_get_element_portion
                         000113 remaining_portion_length_in_bytes
                                                            cm_get_element_portion
                         000114 exclusive_get               cm_get_element_portion
                         000116 ci_ptr                      cm_get_element_portion
                         000120 work_area_ptr               cm_get_element_portion
                         000122 buffer_ptr                  cm_get_element_portion
                         000124 current_buffer_ptr          cm_get_element_portion
                         000126 datum_contents_ptr          cm_get_element_portion
                         000130 cd_datum_header             cm_get_element_portion
                         000140 datum_slot_ptr              cm_get_element_portion
                         000142 element_id_string           cm_get_element_portion
                         000144 datum_ptr                   cm_get_element_portion
                         000146 datum_id_ptr                cm_get_element_portion
                         000150 datum_contents_length_in_bits
                                                            cm_get_element_portion
                         000152 ci_parts_ptr                cm_get_element_portion
                         000154 cip_number_of_parts         cm_get_element_portion

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return
tra_ext             enable              ext_entry           int_entry           ceil_fx1            ceil_fx2
divide_fx1          alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cm_get_id$ptr                 file_manager_$get_ci_ptr      sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$ci_not_allocated    dm_error_$ci_not_in_collection                              dm_error_$long_return_element
dm_error_$no_element          dm_error_$programming_error   error_table_$bad_arg
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    113 000247       116 000251       117 000252       118 000253       120 000254       122 000255       123 000256
    125 000257       127 000260       130 000261       132 000262       133 000264       134 000265       135 000266
    136 000267    4   67 000270    4   68 000271    4   69 000272    6   35 000274    6   36 000276        84 000301
    198 000320       199 000321       201 000322       210 000332       211 000334       216 000335       218 000337
    220 000340       221 000342       222 000344       224 000346       225 000350       226 000352       229 000355
    231 000364       233 000366       236 000370       238 000402       240 000423       243 000443       246 000444
    250 000501       257 000511       264 000516       273 000534       276 000550       278 000556       286 000561
    290 000562       292 000571       295 000577       299 000605       307 000610       308 000614       311 000620
    315 000623       316 000632       319 000633       323 000641       324 000663       325 000671       331 000674
    334 000702       335 000704       337 000707       339 000710       350 000722       353 000724       356 000732
    360 000736       364 000744       372 000747       373 000753       376 000757       380 000762       381 000771
    384 000772       388 001000       389 001022       390 001030       396 001033       399 001041       400 001043
    402 001045       404 001046       406 001052       409 001060       412 001061       415 001067       418 001101
    419 001105       422 001110       424 001117       427 001120       432 001126       433 001133       434 001140
    438 001143       442 001145       448 001223       450 001224       463 001232       466 001246       468 001266
    471 001303       474 001316       480 001377       482 001405       485 001413       487 001427       494 001504
    498 001505       503 001513       505 001516       509 001517       517 001525       520 001532       521 001535
    524 001543       526 001555       529 001566       533 001573       540 001576       541 001602       544 001606
    547 001611       548 001620       551 001621       555 001627       556 001651       557 001661       561 001664
    564 001667       565 001671       566 001673       569 001674       571 001701       573 001704       578 001707
    580 001711       582 001726       584 001730       588 001735       591 001757       601 002055       606 002063
    608 002071       611 002074       614 002100       618 002106       620 002111       621 002113       623 002121
    626 002122       629 002132       631 002134       634 002135       638 002141       641 002145       644 002147
    647 002151       649 002152       658 002250       659 002255       661 002257


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
