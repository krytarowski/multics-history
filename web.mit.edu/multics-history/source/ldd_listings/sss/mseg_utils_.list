	COMPILATION LISTING OF SEGMENT mseg_utils_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 05/22/85  0651.7 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1985 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* Utilities used by the message segment primitive operations (mseg_) */
        8 
        9 /* Created:  April 1985 by G. Palter based upon mseg_, mseg_error_, mseg_convert_, ms_salvager_, and ms_salv_util_ */
       10 /* Modified: 20 May 1985 by G. Palter to avoid spurious RQOs while salvaging */
       11 
       12 /* format: style3,linecom */
       13 
       14 mseg_utils_:
       15      procedure ();
       16 
       17 	return;					/* not an entrypoint */
       18 
       19 
       20 /* Parameters */
       21 
       22 dcl	P_mseg_operation_ptr
       23 			pointer parameter;
       24 
       25 dcl	P_code		fixed binary (35) parameter;	/* begin_operation: indicates whether we setup OK (Output);
       26*						   salvage_for_cause: why we must salvage (Input) */
       27 
       28 dcl	P_operation_id	bit (36) aligned parameter;	/* begin_operation: the operation to be started */
       29 dcl	P_operation_name	character (*) parameter;	/* begin_operation: set to the name of the operation */
       30 dcl	P_mseg_dir_name	character (*) parameter;	/* begin_operation: set to segment's parent if known */
       31 dcl	P_mseg_entryname	character (*) parameter;	/* begin_operation: set to segment' entryname if known */
       32 dcl	P_mseg_ptr	pointer parameter;		/* begin_operation: set -> the segment if available */
       33 dcl	P_rqo_detected	bit (1) aligned parameter;	/* begin_operation: set ON => an RQO occured while locking */
       34 
       35 
       36 /* Local copies of parameters */
       37 
       38 dcl	operation_name	character (64);
       39 
       40 dcl	mseg_dir_name	character (168);
       41 dcl	mseg_entryname	character (32);
       42 
       43 dcl	rqo_detected	bit (1) aligned;
       44 
       45 dcl	code		fixed binary (35);
       46 
       47 
       48 /* Remaining declarations */
       49 
       50 dcl	1 mseg_segment_header
       51 			aligned based (mseg_ptr) like mseg_segment.header;
       52 
       53 dcl	1 long_status	aligned like status_branch;
       54 
       55 dcl	test_lock		bit (36) aligned;
       56 
       57 dcl	salvage_for_cause_arguments
       58 			pointer;
       59 
       60 dcl	path_code		fixed binary (35);
       61 dcl	(salvage_report_text_lth, callers_report_text_lth)
       62 			fixed binary (21);
       63 dcl	(mseg_max_length, mseg_cur_length)
       64 			fixed binary (19);
       65 dcl	(n_header_blocks, n_possible_messages, n_messages_recovered)
       66 			fixed binary (18);
       67 dcl	(n_arguments, prefix_lth)
       68 			fixed binary;
       69 
       70 dcl	MSEG_UTILS_	character (32) static options (constant) initial ("mseg_utils_");
       71 
       72 /* format: off */
       73 
       74 dcl	SALVAGER_AND_UPGRADING_ACTIONS
       75 	     (0:9) character (64) varying static options (constant) initial ("",
       76 		"Call to hcs_$get_access_info_seg failed",
       77 		"Call to hcs_$get_max_length_seg failed",
       78 		"Unable to compute size for allocating message blocks",
       79 		"Trying to locate upgrade support procedure",
       80 		"Unable to salvage the segment prior to upgrading it",
       81 		"Initializing the temporary upgraded segment in [pd]",
       82 		"Copying messages into the temporary upgraded segment in [pd]",
       83 		"Call to hcs_$status_long failed",
       84 		"Rebuilding the contents of the message segment");
       85 
       86 dcl      (CALL_GET_ACCESS_INFO	initial (1),
       87 	CALL_GET_MAX_LENGTH		initial (2),
       88 	COMPUTING_BLOCK_SIZE	initial (3),
       89 	FINDING_SUPPORT_PROCEDURE	initial (4),
       90 	SALVAGING_ORIGINAL_SEGMENT	initial (5),
       91 	PREPARING_UPGRADED_TEMPORARY	initial (6),
       92 	CREATING_UPGRADED_TEMPORARY	initial (7),
       93 	CALL_STATUS_LONG		initial (8),
       94 	REBUILDING_SEGMENT		initial (9)
       95 	)		fixed binary static options (constant);
       96 
       97 dcl      (error_table_$bad_segment, error_table_$bad_subr_arg, error_table_$bigarg, error_table_$improper_data_format,
       98 	error_table_$invalid_max_length, error_table_$lock_wait_time_exceeded, error_table_$no_message,
       99 	error_table_$no_s_permission, error_table_$not_seg_type, error_table_$notalloc, error_table_$null_info_ptr,
      100 	error_table_$rqover, error_table_$seg_busted, error_table_$segfault, error_table_$unimplemented_version)
      101 			fixed binary (35) external;
      102 
      103 /* format: on */
      104 
      105 dcl	sys_info$ring1_privilege
      106 			bit (36) aligned external;
      107 
      108 dcl	admin_gate_$guaranteed_eligibility_off
      109 			entry ();
      110 dcl	admin_gate_$guaranteed_eligibility_on
      111 			entry ();
      112 dcl	admin_gate_$syserr_error_code
      113 			entry (/* fixed binary, fixed binary (35), character (*) */) options (variable);
      114 dcl	aim_check_$greater_or_equal
      115 			entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      116 dcl	aim_check_$in_range entry (bit (72) aligned, (2) bit (72) aligned) returns (bit (1) aligned);
      117 dcl	aim_util_$get_privileges
      118 			entry (bit (72) aligned) returns (bit (36) aligned);
      119 dcl	cu_$arg_count	entry (fixed binary, fixed binary (35));
      120 dcl	cu_$arg_list_ptr	entry () returns (pointer);
      121 dcl	find_condition_info_
      122 			entry (pointer, pointer, fixed binary (35));
      123 dcl	get_group_id_	entry () returns (character (32));
      124 dcl	get_lock_id_	entry () returns (bit (36) aligned);
      125 dcl	get_process_max_authorization_
      126 			entry () returns (bit (72) aligned);
      127 dcl	get_ring_		entry () returns (fixed binary (3));
      128 dcl	get_system_free_area_
      129 			entry () returns (pointer);
      130 dcl	get_temp_segment_	entry (character (*), pointer, fixed binary (35));
      131 dcl	hcs_$fs_get_path_name
      132 			entry (pointer, character (*), fixed binary, character (*), fixed binary (35));
      133 dcl	hcs_$get_access_info_seg
      134 			entry (pointer, pointer, fixed binary (35));
      135 dcl	hcs_$get_max_length_seg
      136 			entry (pointer, fixed binary (19), fixed binary (35));
      137 dcl	hcs_$make_entry	entry (pointer, character (*), character (*), entry, fixed binary (35));
      138 dcl	hcs_$set_damaged_sw_seg
      139 			entry (pointer, bit (1) aligned, fixed binary (35));
      140 dcl	hcs_$status_long	entry (character (*), character (*), fixed binary (1), pointer, pointer, fixed binary (35));
      141 dcl	hcs_$truncate_seg	entry (ptr, fixed bin (19), fixed bin (35));
      142 dcl	ioa_$general_rs	entry (pointer, fixed binary, fixed binary, character (*), fixed binary (21),
      143 			bit (1) aligned, bit (1) aligned);
      144 dcl	ioa_$rsnpnnl	entry () options (variable);
      145 dcl	mseg_message_$add_message_for_mseg
      146 			entry (pointer, character (*), fixed binary (35));
      147 dcl	mseg_utils_$salvage_for_cause
      148 			entry (/* pointer, fixed binary (35) */) options (variable);
      149 dcl	pathname_		entry (character (*), character (*)) returns (character (168));
      150 dcl	release_temp_segment_
      151 			entry (character (*), pointer, fixed binary (35));
      152 dcl	set_lock_$lock	entry (bit (36) aligned, fixed binary, fixed binary (35));
      153 dcl	set_lock_$unlock	entry (bit (36) aligned, fixed binary (35));
      154 dcl	sort_items_indirect_$bit
      155 			entry (pointer, pointer, fixed binary (24));
      156 dcl	sub_err_		entry () options (variable);
      157 
      158 dcl	(addr, clock, codeptr, copy, convert, currentsize, divide, fixed, hbound, index, lbound, length, max, mod, null,
      159 	rtrim, setwordno, stacq, string, substr, unspec, wordno)
      160 			builtin;
      161 
      162 dcl	(cleanup, record_quota_overflow, seg_fault_error)
      163 			condition;
      164 
      165 /* Initialize the perprocess values in mseg_data_ */
      166 
      167 mseg_utils_$initialize:
      168      entry ();
      169 
      170 	mseg_data_$group_id = get_group_id_ ();
      171 	mseg_data_$lock_id = get_lock_id_ ();
      172 	mseg_data_$process_max_authorization = get_process_max_authorization_ ();
      173 
      174 	mseg_data_$execution_ring = get_ring_ ();	/* this is OK as static data is per ring ... */
      175 
      176 	return;
      177 
      178 /* Begin an operation -- First, we verify that the supplied mseg_operation includes the fields required for the operation.
      179*   We then guarantee elibility, if possible, and perform the actions requested by the operation's begin flags, if any. */
      180 
      181 mseg_utils_$begin_operation:
      182      entry (P_operation_id, P_mseg_operation_ptr, P_operation_name, P_mseg_dir_name, P_mseg_entryname, P_mseg_ptr,
      183 	P_rqo_detected, P_code);
      184 
      185 	mseg_operation_data_ptr = addr (P_operation_id);
      186 	if (mseg_operation_data.operation_id < lbound (mseg_operations_$names, 1))
      187 	     | (mseg_operation_data.operation_id > hbound (mseg_operations_$names, 1))
      188 	then call sub_err_ (error_table_$bad_subr_arg, MSEG_UTILS_, ACTION_CANT_RESTART, null (), 0,
      189 		"Operation ID = ^12.3b", P_operation_id);
      190 
      191 	operation_name = mseg_operations_$names (mseg_operation_data.operation_id);
      192 
      193 	mseg_operation_ptr = P_mseg_operation_ptr;
      194 
      195 	if mseg_operation_ptr = null ()
      196 	then call sub_err_ (error_table_$null_info_ptr, operation_name, ACTION_CANT_RESTART, null (), 0);
      197 
      198 	if mseg_operation.version ^= MSEG_OPERATION_VERSION_1
      199 	then call sub_err_ (error_table_$unimplemented_version, operation_name, ACTION_CANT_RESTART, null (), 0,
      200 		"mseg_operation.version = ^d.", mseg_operation.version);
      201 
      202 	mseg_operation.operation = P_operation_id;	/* set the operation code */
      203 	mseg_operation_data_ptr = addr (mseg_operation.operation);
      204 
      205 	mseg_dir_name = "";				/* initialize output values */
      206 	mseg_entryname = "";
      207 	mseg_ptr = null ();
      208 	rqo_detected = "0"b;
      209 	code = 0;
      210 
      211 	mseg_operation_data.already_salvaged,		/* for cleanup handlers and the like */
      212 	     mseg_operation_data.unlock_segment = "0"b;
      213 
      214 
      215 	/*** Check that required data is present -- In the current implementation, all operations require either the
      216*	     pathname or mseg_ptr.  Of the remaining fields in an mseg_operation, the primitives will only occasionally
      217*	     use the access_info, message_info, and wakeup_state structures.  */
      218 
      219 	if mseg_operation_data.required_data.pathname & mseg_operation_data.required_data.mseg_ptr
      220 	then do;	/*** Either the pathname or mseg_ptr or both may be used */
      221 		if ^mseg_operation.mseg_pathname_valid & ^mseg_operation.mseg_ptr_valid
      222 		then call sub_err_ (error_table_$bad_subr_arg, operation_name, ACTION_CANT_RESTART, null (), 0,
      223 			"The mseg_operation does not include either a valid pathname or a valid mseg_ptr.");
      224 		if mseg_operation.access_info_valid
      225 		then do;				/* always give preference to the pathname derived in ring 0 */
      226 			mseg_dir_name = mseg_operation.access_info.dir_name;
      227 			mseg_entryname = mseg_operation.access_info.entryname;
      228 		     end;
      229 		else if mseg_operation.mseg_pathname_valid
      230 		then do;				/* caller has supplied the pathname */
      231 			mseg_dir_name = mseg_operation.dir_name;
      232 			mseg_entryname = mseg_operation.entryname;
      233 		     end;
      234 		if mseg_operation.mseg_ptr_valid	/* caller has also supplied an mseg_ptr */
      235 		then mseg_ptr = mseg_operation.mseg_ptr;
      236 	     end;
      237 
      238 	else if mseg_operation_data.required_data.pathname
      239 	then /*** This operation requires a valid pathname */
      240 	     if mseg_operation.access_info_valid
      241 	     then do;				/* always give preference to the pathname derived in ring 0 */
      242 		     mseg_dir_name = mseg_operation.access_info.dir_name;
      243 		     mseg_entryname = mseg_operation.access_info.entryname;
      244 		end;
      245 	     else if mseg_operation.mseg_pathname_valid
      246 	     then do;				/* caller has supplied the pathname */
      247 		     mseg_dir_name = mseg_operation.dir_name;
      248 		     mseg_entryname = mseg_operation.entryname;
      249 		end;
      250 	     else call sub_err_ (error_table_$bad_subr_arg, operation_name, ACTION_CANT_RESTART, null (), 0,
      251 		     "The mseg_operation does not include a valid pathname.");
      252 
      253 	else if mseg_operation_data.required_data.mseg_ptr
      254 	then /*** This operation requires a valid mseg_ptr */
      255 	     if mseg_operation.mseg_ptr_valid
      256 	     then mseg_ptr = mseg_operation.mseg_ptr;
      257 	     else call sub_err_ (error_table_$bad_subr_arg, operation_name, ACTION_CANT_RESTART, null (), 0,
      258 		     "The mseg_operation does not include a valid mseg_ptr.");
      259 
      260 	else call sub_err_ (error_table_$bad_subr_arg, operation_name, ACTION_CANT_RESTART, null (), 0,
      261 		"mseg_operation.operation does not request either the pathname or mseg_ptr.");
      262 
      263 	if mseg_operation_data.required_data.access_info
      264 	then if ^mseg_operation.suppress_access_checks	/* we'll only actually need it if checking access */
      265 	     then if mseg_operation.access_info_valid
      266 		then if mseg_operation.access_info.version ^= ENTRY_ACCESS_INFO_VERSION_1
      267 		     then call sub_err_ (error_table_$unimplemented_version, operation_name, ACTION_CANT_RESTART,
      268 			     null (), 0, "mseg_operation.access_info.version = ""^a"".",
      269 			     mseg_operation.access_info.version);
      270 		     else ;
      271 		else call sub_err_ (error_table_$bad_subr_arg, operation_name, ACTION_CANT_RESTART, null (), 0,
      272 			"The mseg_operation does not include a valid access_info structure.");
      273 
      274 	if mseg_operation_data.required_data.message_info
      275 	then if mseg_operation.message_info_valid
      276 	     then if mseg_operation.message_info.version ^= MSEG_MESSAGE_INFO_V1
      277 		then call sub_err_ (error_table_$unimplemented_version, operation_name, ACTION_CANT_RESTART, null (),
      278 			0, "mseg_operation.message_info.version = ""^a"".", mseg_operation.message_info.version);
      279 		else ;
      280 	     else call sub_err_ (error_table_$bad_subr_arg, operation_name, ACTION_CANT_RESTART, null (), 0,
      281 		     "The mseg_operation does not include a valid message_info structure.");
      282 
      283 	if mseg_operation_data.required_data.wakeup_state
      284 	then if mseg_operation.wakeup_state_valid
      285 	     then if mseg_operation.wakeup_state.version ^= MSEG_WAKEUP_STATE_VERSION_1
      286 		then call sub_err_ (error_table_$unimplemented_version, operation_name, ACTION_CANT_RESTART, null (),
      287 			0, "mseg_operation.wakeup_state.version = ""^a"".", mseg_operation.message_info.version);
      288 		else ;
      289 	     else call sub_err_ (error_table_$bad_subr_arg, operation_name, ACTION_CANT_RESTART, null (), 0,
      290 		     "The mseg_operation does not include a valid wakeup_state structure.");
      291 
      292 	if mseg_operation_data.required_data.wakeup_state_version
      293 	then if mseg_operation.wakeup_state.version ^= MSEG_WAKEUP_STATE_VERSION_1
      294 	     then call sub_err_ (error_table_$unimplemented_version, operation_name, ACTION_CANT_RESTART, null (), 0,
      295 		     "mseg_operation.wakeup_state.version = ""^a"".", mseg_operation.message_info.version);
      296 
      297 
      298 	/*** Guarantee eligibility if running in the admin ring (ring 1) */
      299 
      300 	if mseg_operation.call_admin_gate
      301 	then call admin_gate_$guaranteed_eligibility_on ();
      302 
      303 
      304 	/*** Lock the segment if requested */
      305 
      306 	if mseg_operation_data.begin_flags.lock_segment
      307 	then do;
      308 
      309 		on seg_fault_error call seg_fault_handler ();
      310 		on record_quota_overflow
      311 		     begin;
      312 			rqo_detected = "1"b;	/* let the caller handle RQOs */
      313 			go to RETURN_FROM_BEGIN_OPERATION;
      314 		     end;				/* ... avoids making return_from_begin_operation nonquick */
      315 
      316 		if stacq (mseg_segment.lock, mseg_data_$lock_id, (36)"0"b)
      317 		then code = 0;
      318 		else call set_lock_$lock (mseg_segment.lock, 20, code);
      319 
      320 		revert record_quota_overflow;
      321 		revert seg_fault_error;
      322 
      323 		if mseg_operation_data.begin_flags.dont_check_lock_results
      324 		then call return_from_begin_operation (code);
      325 						/* our caller handles the lock non-standardly */
      326 
      327 		else if code = 0			/* we've locked it */
      328 		then mseg_operation_data.finish_flags.unlock_segment = "1"b;
      329 
      330 		else if code = error_table_$lock_wait_time_exceeded
      331 		then call return_from_begin_operation (code);
      332 						/* some other process is using the segment */
      333 
      334 		else call salvage_and_return_from_begin (code);
      335 	     end;					/* invalid_lock_reset or locked_by_this_process */
      336 
      337 
      338 	else call return_from_begin_operation (0);	/* don't try anything else if we can't lock the segment */
      339 
      340 
      341 	/*** Check the header for consistency and initialize it if requested */
      342 
      343 	if mseg_operation_data.begin_flags.check_header_consistency
      344 	then if (mseg_segment.sentinel = ""b) & (mseg_segment.header.version = 0)
      345 	     then if mseg_operation_data.begin_flags.initialize_header
      346 		then do;	/*** This segment does not have a header -- However, the operation about to be performed
      347*			     needs the header to behave properly.  Therefore, we must initialize the header now. */
      348 
      349 			mseg_segment.sentinel = MSEG_SEGMENT_SENTINEL;
      350 			mseg_segment.header.version = MSEG_SEGMENT_VERSION_5;
      351 
      352 			call hcs_$get_max_length_seg (mseg_ptr, mseg_max_length, code);
      353 			if code ^= 0
      354 			then call return_from_begin_operation (code);
      355 
      356 			/*** Compute the number of available blocks in the segment based on its max length. */
      357 			mseg_segment.block_size = mseg_data_$block_size;
      358 			mseg_segment.n_blocks_allocated = divide (mseg_max_length, mseg_segment.block_size, 18, 0);
      359 						/* format: off */
      360 			n_header_blocks =
      361 			     divide ((currentsize (mseg_segment_header)
      362 				    + divide ((mseg_segment.n_blocks_allocated + 35), 36, 18, 0)
      363 				    + mseg_segment.block_size - 1),
      364 				   mseg_segment.block_size, 18, 0);
      365 						/* format: on */
      366 			if mseg_segment.n_blocks_allocated <= n_header_blocks
      367 			then /*** The segment doesn't have room for any messages. */
      368 			     call return_from_begin_operation (error_table_$invalid_max_length);
      369 			mseg_segment.n_blocks_unused = mseg_segment.n_blocks_allocated - n_header_blocks;
      370 
      371 			/*** Record that the header has been allocated. */
      372 			mseg_segment.block_map.map = copy ("1"b, n_header_blocks);
      373 		     end;
      374 
      375 
      376 		else /*** This segment does not have a header -- Fortunately, the operation about to be performed
      377*			doesn't require the header for to behave properly so we needn't do anything more. */
      378 		     ;
      379 
      380 
      381 	     else do;  /*** This segment appears to have a header -- Perform automatic conversion if necessary and then
      382*			make the minimal consistency checks on the header. */
      383 
      384 		     if mseg_segment.header.version ^= MSEG_SEGMENT_VERSION_5
      385 		     then if (mseg_segment.header.version >= 2)
      386 			     & (mseg_segment.header.version < MSEG_SEGMENT_VERSION_5)
      387 			then call upgrade_seg ();
      388 			else call salvage_and_return_from_begin (mseg_format_errors_$bad_mseg_version);
      389 
      390 		     if mseg_segment.sentinel ^= MSEG_SEGMENT_SENTINEL
      391 		     then call salvage_and_return_from_begin (mseg_format_errors_$bad_mseg_sentinel);
      392 
      393 		     if mseg_segment.modification_in_progress
      394 		     then call salvage_and_return_from_begin (mseg_format_errors_$modification_in_progress);
      395 
      396 		     if mseg_segment.salvage_in_progress
      397 		     then call salvage_and_return_from_begin (mseg_format_errors_$salvage_in_progress);
      398 		end;
      399 
      400 
      401 	else call return_from_begin_operation (0);	/* don't check count&chains without checking the header */
      402 
      403 
      404 	/*** Check the message count and message chain for consistency if requested */
      405 
      406 	if mseg_operation_data.begin_flags.check_count_consistency
      407 	then if mseg_segment.n_messages = 0
      408 	     then if (mseg_segment.message_chain.first_message ^= 0) | (mseg_segment.message_chain.last_message ^= 0)
      409 		then call salvage_and_return_from_begin (mseg_format_errors_$inconsistent_message_count);
      410 		else ;				/* no messages and no message chain */
      411 
      412 	     else if mseg_segment.n_messages < 0
      413 	     then call salvage_and_return_from_begin (mseg_format_errors_$negative_message_count);
      414 
      415 	     else /*** if mseg_segment.n_messages > 0 then */
      416 		if (mseg_segment.message_chain.first_message = 0) | (mseg_segment.message_chain.last_message = 0)
      417 	     then call salvage_and_return_from_begin (mseg_format_errors_$inconsistent_message_count);
      418 
      419 
      420 	/*** All done */
      421 
      422 RETURN_FROM_BEGIN_OPERATION:
      423 	P_operation_name = operation_name;
      424 	P_mseg_dir_name = mseg_dir_name;
      425 	P_mseg_entryname = mseg_entryname;
      426 	P_mseg_ptr = mseg_ptr;
      427 	P_rqo_detected = rqo_detected;
      428 
      429 	P_code = code;
      430 
      431 	return;
      432 
      433 
      434 
      435 /* Return upon completion of the begin_operation entrypoint */
      436 
      437 return_from_begin_operation:
      438      procedure (p_code);
      439 
      440 dcl	p_code		fixed binary (35) parameter;
      441 
      442 	code = p_code;				/* set the result code */
      443 	go to RETURN_FROM_BEGIN_OPERATION;
      444 
      445      end return_from_begin_operation;
      446 
      447 
      448 
      449 /* Salvage the message segment due to internal inconsistencies and return error_table_$bad_segment to our caller */
      450 
      451 salvage_and_return_from_begin:
      452      procedure (p_format_error);
      453 
      454 dcl	p_format_error	fixed binary (35) parameter;
      455 
      456 	call mseg_utils_$salvage_for_cause (mseg_operation_ptr, p_format_error);
      457 
      458 	call return_from_begin_operation (error_table_$bad_segment);
      459 
      460      end salvage_and_return_from_begin;
      461 
      462 /* Finish an operation -- This entrypoint completes the normal processing of an operation whether or not said operation
      463*   will return a non-zero status code to its caller.  This entrypoint will, under control of the finish flags embedded in
      464*   mseg_operation.operation, truncate the segment if its empty and then unlock it.  However, if this operation doesn't
      465*   hold the lock on the segment, this entrypoint will not even perform these actions as some other process may be using
      466*   the segment or it may have been deleted if this is the delete_seg operation.  In any case, however, we turn off
      467*   guaranteed eligibility if we had turned it on earlier.
      468*
      469*   WARNING -- Do not call this entrypoint in a cleanup handler.  A cleanup handler must call abort_operation, instead. */
      470 
      471 mseg_utils_$finish_operation:
      472      entry (P_mseg_operation_ptr);
      473 
      474 	mseg_operation_ptr = P_mseg_operation_ptr;
      475 	mseg_operation_data_ptr = addr (mseg_operation.operation);
      476 
      477 	if ^mseg_operation_data.finish_flags.unlock_segment
      478 	then return;
      479 
      480 	mseg_ptr = mseg_operation.mseg_ptr;
      481 
      482 	if mseg_operation_data.finish_flags.truncate_if_possible
      483 	then if (mseg_segment.n_messages = 0)		/* truncate only if no messages ... */
      484 		& ^mseg_segment.flags.wakeup_state_set	/* ... and no one is accepting wakeups ... */
      485 		& ^mseg_segment.flags.salvaged	/* ... and it wasn't salvaged */
      486 	     then call hcs_$truncate_seg (mseg_ptr, 1, (0));
      487 
      488 	if ^stacq (mseg_segment.lock, (36)"0"b, mseg_data_$lock_id)
      489 	then call set_lock_$unlock (mseg_segment.lock, (0));
      490 
      491 	mseg_operation_data.finish_flags.unlock_segment = "0"b;
      492 
      493 	if mseg_operation.call_admin_gate
      494 	then call admin_gate_$guaranteed_eligibility_off ();
      495 
      496 	return;
      497 
      498 /* Abort an operation -- This entrypoint aborts the currently running operation.  If the operation had locked the message
      499*   segment, this entrypoint will salvage and unlock the segment as it is possible that it has been left in an inconsistent
      500*   state by whatever event has caused the operation to be unwound.  However, this entrypoint will not take these actions
      501*   unless the current operation actually locked the segment; otherwise, we might salvage the segment while it was being
      502*   used by another process.  In any case, however, we turn off guaranteed eligibility if we had turned it on earlier.
      503*
      504*   WARNING -- Do not call this entrypoint except in a cleanup handler.  Use finish_operation, instead, for all other
      505*   circumstances. */
      506 
      507 mseg_utils_$abort_operation:
      508      entry (P_mseg_operation_ptr);
      509 
      510 	mseg_operation_ptr = P_mseg_operation_ptr;
      511 
      512 	if mseg_operation_ptr = null ()		/* caller hasn't even got an mseg_operation yet */
      513 	then return;
      514 
      515 	if ^mseg_operation.mseg_ptr_valid		/* no mseg_ptr -- a file system operation, no doubt */
      516 	then return;
      517 
      518 	if mseg_operation.mseg_ptr = null ()		/* delete_seg operation will null pointer if successful */
      519 	then return;
      520 
      521 	mseg_ptr = mseg_operation.mseg_ptr;
      522 	mseg_operation_data_ptr = addr (mseg_operation.operation);
      523 
      524 	if ^mseg_operation_data.finish_flags.unlock_segment
      525 	then return;				/* we dare not do anything if we don't have it locked */
      526 
      527 	if ^mseg_operation_data.finish_flags.already_salvaged
      528 	then call mseg_utils_$salvage_for_cause (mseg_operation_ptr, 0, "The operation was terminated abnormally.");
      529 
      530 	if ^stacq (mseg_segment.lock, (36)"0"b, mseg_data_$lock_id)
      531 	then call set_lock_$unlock (mseg_segment.lock, (0));
      532 
      533 	mseg_operation_data.finish_flags.unlock_segment = "0"b;
      534 
      535 	if mseg_operation.call_admin_gate
      536 	then call admin_gate_$guaranteed_eligibility_off ();
      537 
      538 	return;
      539 
      540 /* "Queue" to unlock the segment -- This entrypoint is used by those operations which manage the message segment's lock on
      541*   their own when said operation determines that it has locked the segment and that it should, therefore, be unlocked when
      542*   the operation finishes.  (At present, the only operation which uses this protocol is delete_seg.) */
      543 
      544 mseg_utils_$request_unlock_on_finish:
      545      entry (P_mseg_operation_ptr);
      546 
      547 	mseg_operation_ptr = P_mseg_operation_ptr;
      548 	mseg_operation_data_ptr = addr (mseg_operation.operation);
      549 
      550 	if mseg_operation_data.finish_flags.unlock_segment
      551 	then return;				/* it's already going to be unlocked */
      552 
      553 	mseg_ptr = mseg_operation.mseg_ptr;
      554 
      555 	/*** Don't bother to "queue" to unlock the segment unless we already hold the lock */
      556 
      557 	test_lock = mseg_segment.lock;
      558 	if stacq (test_lock, (36)"0"b, mseg_data_$lock_id)
      559 	then mseg_operation_data.finish_flags.unlock_segment = "1"b;
      560 
      561 	return;
      562 
      563 /* Salvage a message segment due to inconsistencies detected by our caller -- Before salvaging, an error report is
      564*   constructed from our caller's error code and, optional, ioa_ control string and arguments.  If we are running in the
      565*   adminitrative ring (ring 1), the report is placed in the SYSERR log; otherwise, it is displayed via sub_err_. */
      566 
      567 mseg_utils_$salvage_for_cause:
      568      entry (P_mseg_operation_ptr, P_code) options (variable);
      569 
      570 	mseg_operation_ptr = P_mseg_operation_ptr;
      571 	mseg_operation_data_ptr = addr (mseg_operation.operation);
      572 
      573 	if mseg_operation_data.finish_flags.already_salvaged
      574 	then return;				/* don't try to salvage more than once per operation */
      575 
      576 	mseg_operation_data.finish_flags.already_salvaged = "1"b;
      577 
      578 	mseg_ptr = mseg_operation.mseg_ptr;
      579 
      580 	if (mseg_operation_data.operation_id < lbound (mseg_operations_$names, 1))
      581 	     | (mseg_operation_data.operation_id > hbound (mseg_operations_$names, 1))
      582 	then operation_name = "mseg_$unknown_operation";
      583 	else operation_name = mseg_operations_$names (mseg_operation_data.operation_id);
      584 
      585 
      586 	/*** Determine the segment's pathname, minimum and maximum access classes, max length, and current length --
      587*	     These data are required for proper operation of the salvager.  (Actually, the pathname isn't required but
      588*	     is determined by the same call used to get the access classes.) */
      589 
      590 	if mseg_operation.access_info_valid
      591 	then do;					/* we already have the pathname and access classes */
      592 		mseg_dir_name = mseg_operation.access_info.dir_name;
      593 		mseg_entryname = mseg_operation.access_info.entryname;
      594 	     end;
      595 
      596 	else do;					/* we must get the pathname and access classes from ring-0 */
      597 		mseg_operation.access_info.version = ENTRY_ACCESS_INFO_VERSION_1;
      598 		call hcs_$get_access_info_seg (mseg_ptr, addr (mseg_operation.access_info), code);
      599 		if code ^= 0			/* can't get the info we need: try for pathname for error */
      600 		then do;
      601 			call hcs_$fs_get_path_name (mseg_ptr, mseg_dir_name, (0), mseg_entryname, path_code);
      602 			call abort_salvage_for_cause ((path_code = 0), CALL_GET_ACCESS_INFO);
      603 		     end;
      604 		mseg_operation.access_info_valid = "1"b;
      605 		mseg_dir_name = mseg_operation.access_info.dir_name;
      606 		mseg_entryname = mseg_operation.access_info.entryname;
      607 	     end;
      608 
      609 	call hcs_$get_max_length_seg (mseg_ptr, mseg_max_length, code);
      610 	if code ^= 0
      611 	then call abort_salvage_for_cause ("1"b, CALL_GET_MAX_LENGTH);
      612 
      613 	call hcs_$status_long (mseg_dir_name, mseg_entryname, 0b, addr (long_status), null (), code);
      614 	if (code ^= 0) & (code ^= error_table_$no_s_permission)
      615 	then call abort_salvage_for_cause ("1"b, CALL_STATUS_LONG);
      616 	if long_status.type ^= Segment
      617 	then do;
      618 		code = error_table_$not_seg_type;
      619 		call abort_salvage_for_cause ("1"b, CALL_STATUS_LONG);
      620 	     end;
      621 	mseg_cur_length = min ((1024 * long_status.current_length), mseg_max_length);
      622 
      623 
      624 	/*** Format and log/print the error report */
      625 
      626 	prefix_lth = length (rtrim (operation_name)) + length (": ");
      627 
      628 	call cu_$arg_count (n_arguments, (0));
      629 	salvage_for_cause_arguments = cu_$arg_list_ptr ();
      630 
      631 	begin options (non_quick);
      632 
      633 dcl	1 salvage_report	unaligned,
      634 	  2 prefix	character (prefix_lth) unaligned,
      635 	  2 text		character (1024 - prefix_lth) unaligned;
      636 
      637 	     salvage_report.prefix = rtrim (operation_name) || ": ";
      638 
      639 	     call ioa_$rsnpnnl ("Beginning salvage of ^a for ^a.^[^/^5x^]", salvage_report.text,
      640 		salvage_report_text_lth, pathname_ (mseg_dir_name, mseg_entryname), mseg_operation.caller.group_id,
      641 		(n_arguments > 2));
      642 
      643 	     if n_arguments > 2			/* caller has supplied additional information */
      644 	     then do;
      645 		     begin;
      646 dcl	rest_of_salvage_report_text
      647 			character (length (salvage_report.text) - salvage_report_text_lth) unaligned
      648 			defined (salvage_report.text) position (salvage_report_text_lth + 1);
      649 			call ioa_$general_rs (salvage_for_cause_arguments, 3, 4, rest_of_salvage_report_text,
      650 			     callers_report_text_lth, "0"b, "0"b);
      651 		     end;
      652 		     salvage_report_text_lth = salvage_report_text_lth + callers_report_text_lth;
      653 		end;
      654 
      655 	     if mseg_operation.call_admin_gate
      656 	     then begin;				/* report via SYSERR -- include entrypoint name in the text */
      657 dcl	salvage_report_text character (prefix_lth + salvage_report_text_lth) unaligned defined (salvage_report)
      658 			position (1);
      659 		     call admin_gate_$syserr_error_code ((SYSERR_LOG_OR_DISCARD + SYSERR_RING1_ERROR), P_code,
      660 			"^a^[^/^5x^]", salvage_report_text, (P_code ^= 0));
      661 		end;
      662 
      663 	     else begin;
      664 dcl	salvage_report_text character (salvage_report_text_lth) unaligned defined (salvage_report.text);
      665 		     call sub_err_ (P_code, operation_name, ACTION_DEFAULT_RESTART, null (), 0, "^[^/^]^a",
      666 			(P_code ^= 0), salvage_report_text);
      667 		end;
      668 	end;
      669 
      670 
      671 	/*** Actually salvage the segment and report the results */
      672 
      673 	code = 0;
      674 
      675 	call salvage_seg (n_possible_messages, n_messages_recovered);
      676 
      677 	if mseg_operation.call_admin_gate
      678 	then call admin_gate_$syserr_error_code ((SYSERR_LOG_OR_DISCARD + SYSERR_RING1_ERROR), 0,
      679 		"^a: Completed salvage of ^a for ^a.^/^5x^d^[ out of ^d possible^;^s^] message^[s^] recovered.",
      680 		operation_name, pathname_ (mseg_dir_name, mseg_entryname), mseg_operation.caller.group_id,
      681 		n_messages_recovered, (n_messages_recovered ^= n_possible_messages), n_possible_messages,
      682 		((n_messages_recovered ^= 1) | (n_possible_messages ^= 1)));
      683 
      684 	else call sub_err_ (0, operation_name, ACTION_DEFAULT_RESTART, null (), 0,
      685 		"Completed salvage of ^a for ^a.^/^5x^d^[ out of ^d possible^;^s^] message^[s^] recovered.",
      686 		pathname_ (mseg_dir_name, mseg_entryname), mseg_operation.caller.group_id, n_messages_recovered,
      687 		(n_messages_recovered ^= n_possible_messages), n_possible_messages,
      688 		((n_messages_recovered ^= 1) | (n_possible_messages ^= 1)));
      689 
      690 RETURN_FROM_SALVAGE_FOR_CAUSE:
      691 	return;
      692 
      693 
      694 
      695 /* Report our failure to salvage the segment and return to our caller */
      696 
      697 abort_salvage_for_cause:
      698      procedure (p_have_pathname, p_failed_action);
      699 
      700 dcl	p_have_pathname	bit (1) aligned parameter;
      701 dcl	p_failed_action	fixed binary parameter;
      702 
      703 	if mseg_operation.call_admin_gate
      704 	then call admin_gate_$syserr_error_code ((SYSERR_LOG_OR_DISCARD + SYSERR_RING1_ERROR), code,
      705 		"^a: Unable to salvage ^[^a^s^;^s^p (pathname unknown)^] for ^a.^/^5x^a^[ --^/^5x^]", operation_name,
      706 		p_have_pathname, pathname_ (mseg_dir_name, mseg_entryname), mseg_ptr, mseg_operation.caller.group_id,
      707 		SALVAGER_AND_UPGRADING_ACTIONS (p_failed_action), (code ^= 0));
      708 
      709 	else call sub_err_ (code, operation_name, ACTION_DEFAULT_RESTART, null (), 0,
      710 		"^[^/^5x^]^a.^/^5xUnable to salvage ^[^a^s^;^s^p (pathname unknown)^] for ^a.", (code ^= 0),
      711 		SALVAGER_AND_UPGRADING_ACTIONS (p_failed_action), p_have_pathname,
      712 		pathname_ (mseg_dir_name, mseg_entryname), mseg_ptr, mseg_operation.caller.group_id);
      713 
      714 	go to RETURN_FROM_SALVAGE_FOR_CAUSE;
      715 
      716      end abort_salvage_for_cause;
      717 
      718 /* Handle a segment fault while trying to lock the message segment -- If the fault occured because the segment is damaged,
      719*   reset the damaged switch, salvage, and retry the locking operation.  If the fault occured for some other reason (e.g.,
      720*   a connection failure), simply abort the attempt to lock the segment and return the reason to our caller. */
      721 
      722 seg_fault_handler:
      723      procedure ();
      724 
      725 dcl	1 local_ci	aligned like condition_info;
      726 dcl	local_code	fixed binary (35);
      727 
      728 	code = error_table_$segfault;			/* in case we can't determine the actual reason */
      729 
      730 	unspec (local_ci) = ""b;
      731 	local_ci.version = condition_info_version_1;
      732 
      733 	call find_condition_info_ (null (), addr (local_ci), local_code);
      734 
      735 	if local_code = 0				/* found the fault frame ... */
      736 	then if local_ci.mc_ptr ^= null ()		/* ... and the machine conditions ... */
      737 	     then if local_ci.mc_ptr -> mc.errcode ^= 0	/* ... and they provide specific details */
      738 		then code = local_ci.mc_ptr -> mc.errcode;
      739 
      740 	if (code = error_table_$seg_busted) & ^mseg_operation_data.begin_flags.dont_check_lock_results
      741 	     & ^mseg_operation_data.finish_flags.already_salvaged
      742 	then do;	/*** The segment is damaged and we haven't already tried to salvage it. */
      743 		call hcs_$set_damaged_sw_seg (mseg_ptr, "0"b, (0));
      744 		call mseg_utils_$salvage_for_cause (mseg_operation_ptr, code);
      745 		if ^stacq (mseg_segment.lock, (36)"0"b, mseg_data_$lock_id)
      746 		then call set_lock_$unlock (mseg_segment.lock, (0));
      747 		return;				/* retry */
      748 	     end;
      749 
      750 	else do;	/*** Either it's some other form of segfault or we've already tried to fix it once -- Inform the user
      751*		     that we can't access the segment.  He can either try to fix the segment or delete it. */
      752 		mseg_operation_data.unlock_segment = "0"b;
      753 		mseg_operation_data.truncate_if_possible = "0"b;
      754 		go to RETURN_FROM_BEGIN_OPERATION;
      755 	     end;
      756 
      757      end seg_fault_handler;
      758 
      759 /* Upgrade an old format message segment to the current format -- We are always called with the segment locked. */
      760 
      761 upgrade_seg:
      762      procedure () options (non_quick);
      763 
      764 dcl	1 original_mseg_segment_header
      765 			aligned based (original_mseg_ptr) like mseg_segment.header;
      766 dcl	original_mseg_ptr	pointer;
      767 
      768 dcl	1 upgraded_mseg_segment_header
      769 			aligned based (upgraded_mseg_ptr) like mseg_segment.header;
      770 dcl	upgraded_mseg_ptr	pointer;
      771 
      772 dcl	original_mseg_message_bits
      773 			bit (original_operation.message_info.ms_len) aligned
      774 			based (original_operation.message_info.ms_ptr);
      775 
      776 dcl	upgraded_segment	(upgraded_size) bit (36) aligned based;
      777 
      778 dcl	system_area	area based (system_area_ptr);
      779 dcl	system_area_ptr	pointer;
      780 
      781 dcl	1 original_operation
      782 			aligned like mseg_operation;
      783 dcl	1 upgraded_operation
      784 			aligned like mseg_operation;
      785 
      786 dcl	upgrade_procedure_name
      787 			character (32);
      788 dcl	salvage_old_segment entry (pointer, bit (1) aligned) variable;
      789 dcl	get_old_wakeup_state
      790 			entry (pointer) variable;
      791 dcl	read_old_message	entry (pointer, pointer, fixed binary (35)) variable;
      792 
      793 dcl	(original_mseg_dir_name, upgraded_mseg_dir_name)
      794 			character (168);
      795 dcl	(original_mseg_entryname, upgraded_mseg_entryname)
      796 			character (32);
      797 dcl	original_version_picture
      798 			picture "9";
      799 
      800 dcl	(salvage_completed, rqo_detected)
      801 			bit (1) aligned;
      802 
      803 dcl	path_code		fixed binary (35);
      804 dcl	upgraded_size	fixed binary (19);
      805 dcl	(n_upgraded_blocks_allocated, n_upgraded_header_blocks, n_messages_discarded)
      806 			fixed binary (18);
      807 dcl	original_version	fixed binary;
      808 
      809 
      810 	mseg_operation_data.finish_flags.already_salvaged = "1"b;
      811 						/* prevent the current salvager from destroying the segment */
      812 
      813 	original_operation.message_info.ms_ptr,		/* for cleanup handler */
      814 	     upgraded_mseg_ptr = null ();
      815 
      816 	on cleanup call cleanup_after_upgrade_seg ();
      817 
      818 	code = 0;
      819 
      820 
      821 	/*** Determine the segment's pathname, minimum and maximum access classes, and max length -- These data are
      822*	     required for proper upgrading of the segment.  (Actually, the pathname isn't required but is determined by
      823*	     the same call used to get the access classes.) */
      824 
      825 	original_operation = mseg_operation;		/* we dare not change our caller's operation */
      826 	original_mseg_ptr = original_operation.mseg_ptr;
      827 
      828 	if original_operation.access_info_valid
      829 	then do;					/* we already have the pathname and access classes */
      830 		original_mseg_dir_name = original_operation.access_info.dir_name;
      831 		original_mseg_entryname = original_operation.access_info.entryname;
      832 	     end;
      833 
      834 	else do;					/* we must get the pathname and access classes from ring-0 */
      835 		original_operation.access_info.version = ENTRY_ACCESS_INFO_VERSION_1;
      836 		call hcs_$get_access_info_seg (original_mseg_ptr, addr (original_operation.access_info), code);
      837 		if code ^= 0			/* can't get the info we need: try for pathname for error */
      838 		then do;
      839 			call hcs_$fs_get_path_name (original_mseg_ptr, original_mseg_dir_name, (0),
      840 			     original_mseg_entryname, path_code);
      841 			call abort_upgrade_seg ((path_code = 0), CALL_GET_ACCESS_INFO);
      842 		     end;
      843 		original_operation.access_info_valid = "1"b;
      844 		original_mseg_dir_name = original_operation.access_info.dir_name;
      845 		original_mseg_entryname = original_operation.access_info.entryname;
      846 	     end;
      847 
      848 	call hcs_$get_max_length_seg (original_mseg_ptr, mseg_max_length, code);
      849 	if code ^= 0
      850 	then call abort_upgrade_seg ("1"b, CALL_GET_MAX_LENGTH);
      851 
      852 
      853 	/*** Compute the size of the upgraded segment's header and block map and verify that there will be room in the
      854*	     segment for at least one message */
      855 
      856 	n_upgraded_blocks_allocated = divide (mseg_max_length, mseg_data_$block_size, 18, 0);
      857 
      858 	n_upgraded_header_blocks =
      859 	     divide
      860 	     ((currentsize (upgraded_mseg_segment_header) + divide ((n_upgraded_blocks_allocated + 35), 36, 18, 0)
      861 	     + mseg_data_$block_size - 1), mseg_data_$block_size, 18, 0);
      862 
      863 	if n_upgraded_blocks_allocated < n_upgraded_header_blocks
      864 	then do;
      865 		code = error_table_$invalid_max_length;
      866 		call abort_upgrade_seg ("1"b, 0);
      867 	     end;
      868 
      869 
      870 	/*** Find the proper support procedure -- A procedure named "mseg_upgrade_from_vN_", where N is a version
      871*	     number, exists for any older version of message segment which can be upgraded to the current version.  This
      872*	     procedure contains the three entrypoints which are required to upgrade that version of message segment --
      873*	     salvage, get_wakeup_state, and read_message. */
      874 
      875 	original_version = original_mseg_segment_header.version;
      876 
      877 	upgrade_procedure_name = "mseg_upgrade_from_v" || convert (original_version_picture, original_version) || "_";
      878 
      879 	call hcs_$make_entry (codeptr (upgrade_seg), upgrade_procedure_name, "salvage", salvage_old_segment, code);
      880 	if code ^= 0
      881 	then call abort_upgrade_seg ("1"b, FINDING_SUPPORT_PROCEDURE);
      882 
      883 	call hcs_$make_entry (codeptr (upgrade_seg), upgrade_procedure_name, "get_wakeup_state", get_old_wakeup_state,
      884 	     code);
      885 	if code ^= 0
      886 	then call abort_upgrade_seg ("1"b, FINDING_SUPPORT_PROCEDURE);
      887 
      888 	call hcs_$make_entry (codeptr (upgrade_seg), upgrade_procedure_name, "read_message", read_old_message, code);
      889 	if code ^= 0
      890 	then call abort_upgrade_seg ("1"b, FINDING_SUPPORT_PROCEDURE);
      891 
      892 
      893 	/*** Salvage the segment using its version's salvager */
      894 
      895 	call salvage_old_segment (addr (original_operation), salvage_completed);
      896 
      897 	if ^salvage_completed
      898 	then do;
      899 		code = 0;				/* the salvager hasalready given a detailed accouting ... */
      900 		call abort_upgrade_seg ("1"b, SALVAGING_ORIGINAL_SEGMENT);
      901 	     end;
      902 
      903 
      904 	/*** Initialize the upgraded message segment -- This message segment is actually a temporary in the process
      905*	     directory with an associated mseg_operation that will satisfy mseg_message_$add_message_for_mseg. */
      906 
      907 	on record_quota_overflow
      908 	     begin;
      909 		/*** Any RQO that occurs between now and the completion of the message copying loop is considered
      910*		     fatal to the conversion process.  This decision is proper as the only possible RQOs are either
      911*		     while reading the original segment or writing into the upgraded segment.  As the upgraded segment
      912*		     is in the process directory, an RQO writing into it is clearly fatal.  An RQO while reading the
      913*		     original segment is fatal as, after the above salvaging, the original can not contain any message
      914*		     which tries to reference a block which is in a page of zeroes because only a zero page can cause
      915*		     an RQO while reading. */
      916 		code = error_table_$rqover;
      917 		call abort_upgrade_seg ("1"b, CREATING_UPGRADED_TEMPORARY);
      918 	     end;
      919 
      920 	upgraded_operation = original_operation;
      921 	upgraded_operation.mseg_ptr_valid,		/* the original segment is never the upgraded one ... */
      922 	     upgraded_operation.access_info_valid = "0"b; /* ... and its access info doesn't apply either */
      923 	upgraded_operation.suppress_access_checks = "1"b; /* must be able to copy all messages */
      924 
      925 	call get_temp_segment_ (operation_name, upgraded_mseg_ptr, code);
      926 	if code ^= 0
      927 	then call abort_upgrade_seg ("1"b, PREPARING_UPGRADED_TEMPORARY);
      928 
      929 	upgraded_operation.mseg_ptr = upgraded_mseg_ptr;
      930 	upgraded_operation.mseg_ptr_valid = "1"b;
      931 
      932 	call mseg_utils_$begin_operation (mseg_operations_$copy_seg_target, addr (upgraded_operation), ((64)" "),
      933 	     upgraded_mseg_dir_name, upgraded_mseg_entryname, upgraded_mseg_ptr, rqo_detected, code);
      934 	if rqo_detected
      935 	then code = error_table_$rqover;
      936 	if code ^= 0
      937 	then call abort_upgrade_seg ("1"b, PREPARING_UPGRADED_TEMPORARY);
      938 
      939 	upgraded_mseg_segment_header.n_messages, upgraded_mseg_segment_header.date_time_last_salvaged = 0;
      940 	unspec (upgraded_mseg_segment_header.message_chain) = ""b;
      941 	string (upgraded_mseg_segment_header.flags) = ""b;
      942 	unspec (upgraded_mseg_segment_header.hash_table) = ""b;
      943 
      944 	upgraded_mseg_segment_header.sentinel = MSEG_SEGMENT_SENTINEL;
      945 	upgraded_mseg_segment_header.version = MSEG_SEGMENT_VERSION_5;
      946 
      947 	upgraded_mseg_segment_header.block_size = mseg_data_$block_size;
      948 	upgraded_mseg_segment_header.n_blocks_allocated = n_upgraded_blocks_allocated;
      949 	upgraded_mseg_segment_header.n_blocks_unused = n_upgraded_blocks_allocated - n_upgraded_header_blocks;
      950 
      951 	upgraded_mseg_ptr -> mseg_segment.block_map.map = copy ("1"b, n_upgraded_header_blocks);
      952 
      953 
      954 	/*** Upgrade the segment's wakeup acceptance state */
      955 
      956 	unspec (upgraded_mseg_segment_header.wakeup_state) = ""b;
      957 
      958 	call get_old_wakeup_state (addr (original_operation));
      959 
      960 	if original_operation.wakeup_state_valid
      961 	then do;
      962 		upgraded_mseg_segment_header.wakeup_state_set = "1"b;
      963 		upgraded_mseg_segment_header.wakeup_state.state = original_operation.wakeup_state;
      964 	     end;
      965 
      966 
      967 	/*** Upgrade the messages -- A message is upgraded by reading it from the original segment and adding it to the
      968*	     upgraded segment in the process directory.  If we can't read a message, we consider this to be a fatal
      969*	     error in the conversion process.  If we can't add a message because it's too large, we remember the event
      970*	     but continue copying.  We must continue copying because subsequent messages may be small enough to fit in
      971*	     the upgraded segment.  Our final report when the upgrade is complete will report any lost messages. */
      972 
      973 	original_operation.suppress_access_checks,	/* insure that all messages are copied */
      974 	     upgraded_operation.suppress_access_checks = "1"b;
      975 	upgraded_operation.add_message_info_all_valid = "1"b;
      976 
      977 	n_messages_discarded = 0;
      978 
      979 	original_operation.message_info.version = MSEG_MESSAGE_INFO_V1;
      980 	string (original_operation.message_info.control_flags) = ""b;
      981 	original_operation.message_info.ms_ptr = null ();
      982 
      983 	system_area_ptr = get_system_free_area_ ();
      984 
      985 	original_operation.message_info.message_code = MSEG_READ_FIRST;
      986 	call read_old_message (addr (original_operation), system_area_ptr, code);
      987 
      988 	do while (code = 0);
      989 
      990 	     upgraded_operation.message_info = original_operation.message_info;
      991 	     substr (upgraded_operation.message_info.ms_id, 1, 18) = ""b;
      992 
      993 	     call mseg_message_$add_message_for_mseg (addr (upgraded_operation), operation_name, code);
      994 	     if (code = error_table_$bigarg) | (code = error_table_$notalloc)
      995 	     then n_messages_discarded = n_messages_discarded + 1;
      996 	     else if code ^= 0
      997 	     then call abort_upgrade_seg ("1"b, CREATING_UPGRADED_TEMPORARY);
      998 
      999 	     if original_operation.message_info.ms_ptr ^= null ()
     1000 	     then do;
     1001 		     free original_mseg_message_bits in (system_area);
     1002 		     original_operation.message_info.ms_ptr = null ();
     1003 		end;
     1004 
     1005 	     original_operation.message_info.message_code = MSEG_READ_AFTER_SPECIFIED;
     1006 	     call read_old_message (addr (original_operation), system_area_ptr, code);
     1007 	end;
     1008 
     1009 	if code ^= error_table_$no_message		/* we were unable to read a message */
     1010 	then call abort_upgrade_seg ("1"b, CREATING_UPGRADED_TEMPORARY);
     1011 
     1012 	revert record_quota_overflow;
     1013 
     1014 	code = 0;					/* message copying succeeded! */
     1015 
     1016 
     1017 	/*** Copy the upgraded segment into place -- If an RQO occurs while moving the segment back into place, we will
     1018*	     consider the conversion completed but we will also salvage the segment with the current salvager to discard
     1019*	     any incomplete messages. */
     1020 
     1021 	upgraded_size =
     1022 	     upgraded_mseg_segment_header.block_size
     1023 	     * (upgraded_mseg_segment_header.n_blocks_allocated - upgraded_mseg_segment_header.n_blocks_unused);
     1024 
     1025 	call hcs_$truncate_seg (original_mseg_ptr, upgraded_size, (0));
     1026 
     1027 	on record_quota_overflow
     1028 	     begin;
     1029 		mseg_operation_data.finish_flags.already_salvaged = "0"b;
     1030 		call mseg_utils_$salvage_for_cause (mseg_operation_ptr, error_table_$rqover,
     1031 		     "Some messages will be lost as a result of upgrading this segment.");
     1032 		go to COMPLETE_UPGRADE_AFTER_RQO;
     1033 	     end;
     1034 
     1035 	original_mseg_ptr -> upgraded_segment = upgraded_mseg_ptr -> upgraded_segment;
     1036 
     1037 	revert record_quota_overflow;
     1038 
     1039 COMPLETE_UPGRADE_AFTER_RQO:
     1040 	call cleanup_after_upgrade_seg ();
     1041 
     1042 
     1043 	/*** The segment has been upgraded -- Display a report only if we were forced to discard any messages */
     1044 
     1045 	if n_messages_discarded > 0
     1046 	then if original_operation.call_admin_gate
     1047 	     then call admin_gate_$syserr_error_code ((SYSERR_LOG_OR_DISCARD + SYSERR_RING1_ERROR), 0,
     1048 		     "^a: Upgraded ^a from version ^d to version ^d for ^a.^/^5x^d message^[s^] were deleted.",
     1049 		     operation_name, pathname_ (original_mseg_dir_name, original_mseg_entryname), original_version,
     1050 		     MSEG_SEGMENT_VERSION_5, original_operation.caller.group_id, n_messages_discarded,
     1051 		     (n_messages_discarded ^= 1));
     1052 
     1053 	     else call sub_err_ (0, operation_name, ACTION_DEFAULT_RESTART, null (), 0,
     1054 		     "Upgraded ^a from version ^d to version ^d for ^a.^/^5x^d message^[s^] were deleted.",
     1055 		     pathname_ (original_mseg_dir_name, original_mseg_entryname), original_version,
     1056 		     MSEG_SEGMENT_VERSION_5, original_operation.caller.group_id, n_messages_discarded,
     1057 		     (n_messages_discarded ^= 1));
     1058 
     1059 	mseg_operation_data.finish_flags.already_salvaged = "0"b;
     1060 						/* new problems during the operation should force a salvage */
     1061 
     1062 	return;
     1063 
     1064 
     1065 
     1066 /* Cleanup after upgrading a message segment */
     1067 
     1068 cleanup_after_upgrade_seg:
     1069      procedure ();
     1070 
     1071 	if original_operation.message_info.ms_ptr ^= null ()
     1072 	then do;
     1073 		free original_mseg_message_bits in (system_area);
     1074 		original_operation.message_info.ms_ptr = null ();
     1075 	     end;
     1076 
     1077 	if upgraded_mseg_ptr ^= null ()
     1078 	then do;
     1079 		call release_temp_segment_ (operation_name, upgraded_mseg_ptr, (0));
     1080 		upgraded_mseg_ptr = null ();
     1081 	     end;
     1082 
     1083 	return;
     1084 
     1085      end cleanup_after_upgrade_seg;
     1086 
     1087 
     1088 
     1089 /* Abort the attempt to upgrade a message segment -- We must report the failure and then return
     1090*   error_table_$improper_data_format to the caller of mseg_utils_$begin_operation. */
     1091 
     1092 abort_upgrade_seg:
     1093      procedure (p_have_pathname, p_failed_action);
     1094 
     1095 dcl	p_have_pathname	bit (1) aligned parameter;
     1096 dcl	p_failed_action	fixed binary parameter;
     1097 
     1098 	if original_operation.call_admin_gate
     1099 	then call admin_gate_$syserr_error_code ((SYSERR_LOG_OR_DISCARD + SYSERR_RING1_ERROR), code,
     1100 		"^a: Unable to upgrade ^[^a^s^;^s^p (pathname unknown)^] from version ^d to version ^d for ^a.^/^5x^[^a^[ --^/^5x^]^;^s^[^/^5x^]^]",
     1101 		operation_name, p_have_pathname, pathname_ (original_mseg_dir_name, original_mseg_entryname),
     1102 		original_mseg_ptr, original_version, MSEG_SEGMENT_VERSION_5, original_operation.caller.group_id,
     1103 		(p_failed_action ^= 0), SALVAGER_AND_UPGRADING_ACTIONS (p_failed_action), (code ^= 0));
     1104 
     1105 	else call sub_err_ (code, operation_name, ACTION_DEFAULT_RESTART, null (), 0,
     1106 		"^[^[^/^5x^]^a.^;^s^s^]^/^5xUnable to upgrade ^[^a^s^;^s^p (pathname unknown)^] from version ^d to version ^d for ^a.",
     1107 		(p_failed_action ^= 0), (code ^= 0), SALVAGER_AND_UPGRADING_ACTIONS (p_failed_action),
     1108 		p_have_pathname, pathname_ (original_mseg_dir_name, original_mseg_entryname), original_mseg_ptr,
     1109 		original_version, MSEG_SEGMENT_VERSION_5, original_operation.caller.group_id);
     1110 
     1111 	code = error_table_$improper_data_format;
     1112 
     1113 	go to RETURN_FROM_BEGIN_OPERATION;
     1114 
     1115      end abort_upgrade_seg;
     1116 
     1117      end upgrade_seg;
     1118 
     1119 /* Salvage a message segment */
     1120 
     1121 salvage_seg:
     1122      procedure (p_n_possible_messages, p_n_messages_recovered) options (non_quick);
     1123 
     1124 dcl	(p_n_possible_messages, p_n_messages_recovered)
     1125 			fixed binary (18);
     1126 dcl	(n_possible_messages, n_messages_recovered)
     1127 			fixed binary (18);
     1128 
     1129 /* format: idind30 */
     1130 
     1131 dcl	1 local_mseg_segment_header	aligned like mseg_segment.header;
     1132 
     1133 dcl	1 local_message_block	aligned,
     1134 	  2 header		aligned like message_block_header,
     1135 	  2 data_space,
     1136 	    3 data		bit (324) unaligned,
     1137 	  2 descriptor		aligned like message_descriptor;
     1138 
     1139 dcl	1 local_wakeup_state	aligned like mseg_wakeup_state;
     1140 
     1141 dcl	1 old_wakeup_state		aligned,
     1142 	  2 state,
     1143 	    3 switches		aligned,
     1144 	      4 allow_normal	bit (1) unaligned,
     1145 	      4 allow_urgent	bit (1) unaligned,
     1146 	      4 pad		bit (34) unaligned,
     1147 	    3 lock_id		bit (36) aligned,
     1148 	    3 event_channel		fixed bin (71),
     1149 	    3 process_id		bit (36) aligned,
     1150 	  2 pad			(64 - 5) bit (36) aligned;
     1151 
     1152 /* format: idind20 */
     1153 
     1154 dcl	mseg_segment_blocks (n_blocks_available) bit (36 * probable_block_size) aligned based (mseg_ptr);
     1155 
     1156 dcl	prev_md_ptr	pointer;
     1157 
     1158 dcl	mseg_segment_aim_range
     1159 			(2) bit (72) aligned;
     1160 
     1161 dcl	block_size_unknown	bit (1) aligned;
     1162 
     1163 dcl	(probable_block_size, n_blocks_available, n_header_blocks, last_used_block, max_blocks_per_message,
     1164 	n_blocks_recovered, last_recovered_block, block_id, n_message_blocks, message_block_idx, message_block_id,
     1165 	last_block_checked, next_unused_block, message_index)
     1166 			fixed binary (18);
     1167 dcl	(max_bits_in_first_block, max_bits_in_other_blocks)
     1168 			fixed binary;
     1169 dcl	hash_idx		fixed binary (9);
     1170 
     1171 
     1172 	/*** All RQOs are fatal -- Clearly any RQO while touching a page with data in it will prevent us from
     1173*	     successully salvaging the segment.  Further, if we touch a zero page that causes an RQO, we will have
     1174*	     increased the records used value and, as a result, we'll loop with an RQO until that page is flushed which
     1175*	     may be a very long time.  Therefore, we'll abort the salvage rather than loop. */
     1176 
     1177 	on record_quota_overflow
     1178 	     begin;
     1179 		code = error_table_$rqover;
     1180 		call abort_salvage_for_cause ("1"b, REBUILDING_SEGMENT);
     1181 	     end;
     1182 
     1183 
     1184 	/*** Force the segment lock to insure that no one can get at the segment while we salvage it */
     1185 
     1186 	mseg_segment.lock = mseg_data_$lock_id;
     1187 	mseg_operation_data.finish_flags.unlock_segment = "1"b;
     1188 
     1189 	mseg_segment.salvage_in_progress = "1"b;
     1190 
     1191 	mseg_segment_aim_range (1) = mseg_operation.access_info.parent_access_class;
     1192 	mseg_segment_aim_range (2) = mseg_operation.access_info.access_class;
     1193 
     1194 
     1195 	/*** Determine the block size used for this segment -- If the block size in the header does not yield the
     1196*	     correct number of available blocks (i.e., more blocks than are occupied by the header and block map), we
     1197*	     will assume that the segment uses the default block size.  If the default block size also fails, we will
     1198*	     abort our attempts at salvaging the segment. */
     1199 
     1200 	block_size_unknown = "1"b;			/* ... really need do until */
     1201 
     1202 	do probable_block_size = mseg_segment.block_size repeat (mseg_data_$block_size) while (block_size_unknown);
     1203 
     1204 	     if (probable_block_size > (currentsize (message_block_header) + currentsize (message_descriptor)))
     1205 		& (probable_block_size < mseg_max_length)
     1206 	     then do;				/* this block size is large enough for proper operation */
     1207 
     1208 		     n_blocks_available = divide (mseg_max_length, probable_block_size, 18, 0);
     1209 						/* format: off */
     1210 		     n_header_blocks =
     1211 			divide ((currentsize (mseg_segment_header) + divide ((n_blocks_available + 35), 36, 18, 0)
     1212 			         + probable_block_size - 1),
     1213 			        probable_block_size, 18, 0);
     1214 						/* format: on */
     1215 		     if (n_blocks_available > n_header_blocks) | (probable_block_size = mseg_data_$block_size)
     1216 		     then block_size_unknown = "0"b;	/* stop when the blocksize is OK or the default */
     1217 		end;
     1218 	end;
     1219 
     1220 	if n_blocks_available <= n_header_blocks	/* couldn't get a workable block size */
     1221 	then call abort_salvage_for_cause ("1"b, COMPUTING_BLOCK_SIZE);
     1222 
     1223 	max_blocks_per_message = divide (mseg_data_$max_message_size, probable_block_size, 18, 0);
     1224 
     1225 
     1226 	/*** Find the last non-zero block in the segment -- By definition, the messages in a correctly formatted message
     1227*	     segment will never contain a block which is entirely zeroes.  Therefore, the last non-zero block in the
     1228*	     segment is the upper bound of the blocks which we must examine for valid messages.  (The lower bound, of
     1229*	     course, is the first block after the block map.) */
     1230 
     1231 	last_used_block = divide (mseg_cur_length, probable_block_size, 18, 0);
     1232 						/* hcs_$status_long has told us in which page to find it */
     1233 
     1234 
     1235 	/*** Compute the maximum amount of data which will fit into the first block and all subsequent blocks of a
     1236*	     message -- PL/I can perform this computation for us provided that we have valid values for
     1237*	     mseg_segment.block_size and message_block_header.data_lth.  Because we don't want to actually change the
     1238*	     segment until we've completed recovering messages, we temporarily use automatic copies of a message segment
     1239*	     header and a message block to perform these computations. */
     1240 
     1241 	mseg_ptr = addr (local_mseg_segment_header);
     1242 	mseg_segment.block_size = probable_block_size;
     1243 
     1244 	mb_ptr = addr (local_message_block);
     1245 	message_block_header.data_lth = 0;
     1246 
     1247 	max_bits_in_first_block = length (first_message_block.pad);
     1248 	max_bits_in_other_blocks = length (other_message_block.pad);
     1249 
     1250 	mseg_ptr = mseg_operation.mseg_ptr;
     1251 
     1252 
     1253 /* Begin the actual reconstruction of the segment */
     1254 
     1255 RECONSTRUCT_THE_SEGMENT:
     1256 	begin;
     1257 
     1258 dcl	1 new_block_map	aligned,
     1259 	  2 map		bit (n_blocks_available) unaligned;
     1260 
     1261 dcl	1 nonzero_block_map aligned,
     1262 	  2 map		bit (n_blocks_available) unaligned;
     1263 
     1264 dcl	1 message_id_ptrs	aligned,
     1265 	  2 n_ptrs	fixed binary (18),
     1266 	  2 ptrs		(n_blocks_available) pointer unaligned;
     1267 
     1268 dcl	1 sorted_message_indeces
     1269 			aligned,
     1270 	  2 n_indeces	fixed binary (18),
     1271 	  2 indeces	(n_blocks_available) fixed binary (18);
     1272 
     1273 dcl	message_offsets	(n_blocks_available) fixed binary (18) unsigned;
     1274 dcl	message_ids	(n_blocks_available) bit (72) aligned;
     1275 dcl	block_offsets	(max_blocks_per_message) fixed binary (18) unsigned;
     1276 
     1277 	     new_block_map.map = copy ("1"b, n_header_blocks);
     1278 	     nonzero_block_map.map = copy ("1"b, n_header_blocks);
     1279 
     1280 	     n_blocks_recovered, last_recovered_block = n_header_blocks;
     1281 
     1282 
     1283 	     /*** Examine the message blocks -- We check each message block individually to see if it might be the first
     1284*		block of a message.  If it passes the preliminary test, we assume it is the beginning of a message and
     1285*		we then carefully check the entire possible message for validity.  If it passes all of our checks, we
     1286*		record it as a recovered message and mark all of its blocks allocated. */
     1287 
     1288 	     n_possible_messages, n_messages_recovered = 0;
     1289 
     1290 	     do block_id = (n_header_blocks + 1) to last_used_block;
     1291 
     1292 		substr (nonzero_block_map.map, block_id, 1) = (mseg_segment_blocks (block_id) ^= ""b);
     1293 
     1294 		if possible_message (block_id)
     1295 		then do;
     1296 
     1297 			n_possible_messages = n_possible_messages + 1;
     1298 
     1299 			if valid_message (block_id)
     1300 			then do;
     1301 
     1302 				n_messages_recovered = n_messages_recovered + 1;
     1303 
     1304 				message_offsets (n_messages_recovered) = block_offsets (1);
     1305 				message_ids (n_messages_recovered) = message_descriptor.ms_id;
     1306 
     1307 				do message_block_idx = 1 to n_message_blocks;
     1308 				     message_block_id =
     1309 					divide (block_offsets (message_block_idx), probable_block_size, 18, 0)
     1310 					+ 1;
     1311 				     substr (new_block_map.map, message_block_id, 1) = "1"b;
     1312 				     n_blocks_recovered = n_blocks_recovered + 1;
     1313 				     last_recovered_block = max (last_recovered_block, message_block_id);
     1314 				end;
     1315 			     end;
     1316 		     end;
     1317 	     end;
     1318 
     1319 
     1320 	     /*** Zero the unused blocks -- We can easily zero those unused blocks beyond the last block recovered by
     1321*		truncation.  The intervening unused blocks, however, must be zeroed individually. */
     1322 
     1323 	     call hcs_$truncate_seg (mseg_ptr, (last_recovered_block * probable_block_size), (0));
     1324 
     1325 	     last_block_checked = n_header_blocks;	/* nothing in the header/block map is unused */
     1326 
     1327 	     do while (last_block_checked < last_recovered_block);
     1328 
     1329 		begin;
     1330 dcl	rest_of_block_map	bit (last_recovered_block - last_block_checked) unaligned
     1331 			defined (new_block_map.map) position (last_block_checked + 1);
     1332 		     next_unused_block = index (rest_of_block_map, "0"b);
     1333 		end;
     1334 
     1335 		if next_unused_block = 0
     1336 		then last_block_checked = last_recovered_block;
     1337 
     1338 		else do;
     1339 			last_block_checked = last_block_checked + next_unused_block;
     1340 			begin;
     1341 dcl	nonzero_indicator	bit (1) unaligned defined (nonzero_block_map.map) position (last_block_checked);
     1342 dcl	the_block		bit (36 * probable_block_size) aligned defined (mseg_segment_blocks (last_block_checked));
     1343 			     if nonzero_indicator
     1344 			     then the_block = ""b;
     1345 			end;
     1346 		     end;
     1347 	     end;
     1348 
     1349 
     1350 	     /*** Reconstruct the message chains -- Sort the recovered messages by their IDs before building the chains
     1351*		to insure that reading forward/backward will work properly. */
     1352 
     1353 	     message_id_ptrs.n_ptrs, sorted_message_indeces.n_indeces = n_messages_recovered;
     1354 
     1355 	     do message_index = 1 to n_messages_recovered;
     1356 		message_id_ptrs.ptrs (message_index) = addr (message_ids (message_index));
     1357 		sorted_message_indeces.indeces (message_index) = message_index;
     1358 	     end;
     1359 
     1360 	     call sort_items_indirect_$bit (addr (message_id_ptrs), addr (sorted_message_indeces),
     1361 		length (message_ids (1)));
     1362 
     1363 	     unspec (mseg_segment.message_chain) = ""b;
     1364 	     unspec (mseg_segment.hash_table) = ""b;
     1365 
     1366 	     prev_md_ptr = null ();
     1367 
     1368 	     do message_index = 1 to n_messages_recovered;
     1369 
     1370 		mb_ptr = setwordno (mseg_ptr, message_offsets (sorted_message_indeces.indeces (message_index)));
     1371 		md_ptr = addr (first_message_block.descriptor);
     1372 
     1373 		message_descriptor.message_chain.prev_message = mseg_segment.message_chain.last_message;
     1374 		message_descriptor.message_chain.next_message = 0;
     1375 
     1376 		if mseg_segment.message_chain.first_message = 0
     1377 		then mseg_segment.message_chain.first_message = wordno (mb_ptr);
     1378 		else prev_md_ptr -> message_descriptor.message_chain.next_message = wordno (mb_ptr);
     1379 
     1380 		mseg_segment.message_chain.last_message = wordno (mb_ptr);
     1381 
     1382 		hash_idx = fixed (substr (message_descriptor.ms_id, 64, 9), 9, 0);
     1383 		message_descriptor.prev_message_in_hash_chain = mseg_segment.hash_table.last_message (hash_idx);
     1384 		mseg_segment.hash_table.last_message (hash_idx) = wordno (mb_ptr);
     1385 
     1386 		prev_md_ptr = md_ptr;
     1387 	     end;
     1388 
     1389 
     1390 	     /*** Reconstruct the wakeup state */
     1391 
     1392 	     if mseg_segment.wakeup_state_set		/* segment claims to have a wakeup state */
     1393 	     then if mseg_segment.wakeup_state.version = MSEG_WAKEUP_STATE_VERSION_1
     1394 		then				/* ... which appears to be the new style */
     1395 		     local_wakeup_state = mseg_segment.wakeup_state.state;
     1396 
     1397 		else do;				/* ... which appears to be the old style */
     1398 			unspec (old_wakeup_state) = unspec (header_msg);
     1399 			local_wakeup_state.version = MSEG_WAKEUP_STATE_VERSION_1;
     1400 			string (local_wakeup_state.flags) = string (old_wakeup_state.switches);
     1401 			local_wakeup_state.event_channel = old_wakeup_state.event_channel;
     1402 			local_wakeup_state.access_class = header_msg_access_class;
     1403 			local_wakeup_state.process_id = old_wakeup_state.process_id;
     1404 			local_wakeup_state.lock_id = old_wakeup_state.lock_id;
     1405 		     end;
     1406 
     1407 	     else local_wakeup_state.version = "";	/* no wakeup state is present */
     1408 
     1409 	     if local_wakeup_state.version ^= MSEG_WAKEUP_STATE_VERSION_1
     1410 	     then do;
     1411 RESET_SEGMENT_WAKEUP_STATE:
     1412 		     mseg_segment.wakeup_state_set = "0"b;
     1413 		     unspec (mseg_segment.wakeup_state) = ""b;
     1414 		end;
     1415 
     1416 	     else if (local_wakeup_state.process_id = ""b) | (local_wakeup_state.lock_id = ""b)
     1417 	     then go to RESET_SEGMENT_WAKEUP_STATE;
     1418 
     1419 	     else if ^aim_check_$in_range (local_wakeup_state.access_class, mseg_segment_aim_range)
     1420 	     then go to RESET_SEGMENT_WAKEUP_STATE;
     1421 
     1422 	     else do;				/* wakeup state looks OK: put it back into the segment */
     1423 		     mseg_segment.wakeup_state_set = "1"b;
     1424 		     mseg_segment.wakeup_state.state = local_wakeup_state;
     1425 		     mseg_segment.header.wakeup_state.pad = ""b;
     1426 		end;
     1427 
     1428 
     1429 /* Complete reconstruction of the header and block map and then return to our caller */
     1430 
     1431 	     p_n_possible_messages = max (n_possible_messages, mseg_segment.n_messages);
     1432 	     p_n_messages_recovered = n_messages_recovered;
     1433 
     1434 	     mseg_segment.n_messages = n_messages_recovered;
     1435 
     1436 	     mseg_segment.block_size = probable_block_size;
     1437 	     mseg_segment.n_blocks_allocated = n_blocks_available;
     1438 	     mseg_segment.n_blocks_unused = n_blocks_available - n_blocks_recovered;
     1439 
     1440 	     mseg_segment.block_map.map = new_block_map.map;
     1441 
     1442 	     mseg_segment.modification_in_progress, mseg_segment.salvage_in_progress = "0"b;
     1443 	     mseg_segment.salvaged = "1"b;
     1444 
     1445 	     mseg_segment.sentinel = MSEG_SEGMENT_SENTINEL;
     1446 	     mseg_segment.header.version = MSEG_SEGMENT_VERSION_5;
     1447 
     1448 	     mseg_segment.date_time_last_salvaged = clock ();
     1449 
     1450 	     return;
     1451 
     1452 /* Determine if the specified block might be the first block of a message */
     1453 
     1454 possible_message:
     1455      procedure (p_block_id) returns (bit (1) aligned);
     1456 
     1457 dcl	p_block_id	fixed binary (18) parameter;
     1458 
     1459 	if substr (new_block_map.map, p_block_id, 1) = "1"b
     1460 	then call not_a_message ();			/* this block is already used by another message */
     1461 
     1462 	mb_ptr = setwordno (mseg_ptr, (p_block_id - 1) * probable_block_size);
     1463 
     1464 	if ^first_message_block.descriptor_present	/* there's no descriptor in this block */
     1465 	then call not_a_message ();
     1466 
     1467 	md_ptr = addr (first_message_block.descriptor);
     1468 
     1469 	if message_descriptor.sentinel ^= MESSAGE_DESCRIPTOR_SENTINEL
     1470 	then call not_a_message ();			/* the descriptor isn't properly formatted */
     1471 
     1472 	if message_descriptor.ms_id = ""b		/* the "message" doesn't have a valid message ID */
     1473 	then call not_a_message ();
     1474 
     1475 	do message_index = 1 to n_messages_recovered;
     1476 	     if message_ids (message_index) = message_descriptor.ms_id
     1477 	     then call not_a_message ();		/* the "message" has a duplicate message ID */
     1478 	end;
     1479 
     1480 	if (message_descriptor.ms_len < 0) | (message_descriptor.ms_len > (36 * mseg_data_$max_message_size))
     1481 	then call not_a_message ();			/* the "message" is too small or too large to be real */
     1482 
     1483 	if ^aim_check_$in_range (message_descriptor.ms_access_class, mseg_segment_aim_range)
     1484 	then call not_a_message ();			/* message with this access class can't be in this segment */
     1485 
     1486 	if ^aim_check_$greater_or_equal (message_descriptor.ms_access_class, message_descriptor.sender_authorization)
     1487 	then if (aim_util_$get_privileges (message_descriptor.sender_authorization) & sys_info$ring1_privilege) = ""b
     1488 	     then call not_a_message ();		/* sender couldn't add it without privileges he didn't have */
     1489 
     1490 	/*** Control arrives here only if this block contains a plausible message */
     1491 
     1492 	return ("1"b);
     1493 
     1494 
     1495 /* Control arrives here if the block does not contain a plausible message */
     1496 
     1497 not_a_message:
     1498      procedure ();
     1499 
     1500 	go to RETURN_NOT_A_MESSAGE;
     1501 
     1502      end not_a_message;
     1503 
     1504 RETURN_NOT_A_MESSAGE:
     1505 	return ("0"b);
     1506 
     1507      end possible_message;
     1508 
     1509 /* Validate that a probable message is, in fact, a real message -- We must check all the blocks which are claimed to be
     1510*   part of this message for validity.  We don't have to check the message descriptor itself, however, as that has already
     1511*   been done for us by the possible_message internal procedure and, in fact, md_ptr still locates the descriptor. */
     1512 
     1513 valid_message:
     1514      procedure (p_block_id) returns (bit (1) aligned);
     1515 
     1516 dcl	p_block_id	fixed binary (18) parameter;
     1517 
     1518 dcl	first_block	bit (1) aligned;
     1519 dcl	actual_ms_len	fixed binary (24);
     1520 dcl	block_offset	fixed binary (18) unsigned;
     1521 
     1522 	block_offset = (p_block_id - 1) * probable_block_size;
     1523 
     1524 	first_block = "1"b;				/* this is the first block */
     1525 	n_message_blocks = 0;			/* nothing valid yet */
     1526 	actual_ms_len = 0;
     1527 
     1528 	do while (block_offset ^= 0);
     1529 
     1530 	     if mod (block_offset, probable_block_size) ^= 0
     1531 	     then call not_a_message ();		/* it's not a valid block offset */
     1532 
     1533 	     message_block_id = divide (block_offset, probable_block_size, 18, 0) + 1;
     1534 
     1535 	     if (message_block_id <= n_header_blocks) | (message_block_id > n_blocks_available)
     1536 	     then call not_a_message ();		/* this block is not within the segment */
     1537 
     1538 	     if substr (new_block_map.map, message_block_id, 1) = "1"b
     1539 	     then call not_a_message ();		/* this block is already in use in another message */
     1540 
     1541 	     do message_block_idx = 1 to n_message_blocks;
     1542 		if block_offsets (message_block_idx) = block_offset
     1543 		then call not_a_message ();		/* this block is already in this message */
     1544 	     end;
     1545 
     1546 	     if n_message_blocks = max_blocks_per_message
     1547 	     then call not_a_message ();		/* this "message" has too many blocks */
     1548 
     1549 	     n_message_blocks = n_message_blocks + 1;
     1550 	     block_offsets (n_message_blocks) = block_offset;
     1551 
     1552 	     mb_ptr = setwordno (mseg_ptr, block_offset);
     1553 
     1554 	     if message_block_header.data_lth < 0	/* a block can't have a negative length! */
     1555 	     then call not_a_message ();
     1556 
     1557 	     if first_block
     1558 	     then do;				/* the first block -- just check its length */
     1559 		     if message_block_header.data_lth > max_bits_in_first_block
     1560 		     then call not_a_message ();	/* too many bits to fit in the block */
     1561 		     if message_block_header.next_block ^= 0
     1562 		     then if message_block_header.data_lth ^= max_bits_in_first_block
     1563 			then call not_a_message ();	/* there's more to come but this block's not full */
     1564 		end;
     1565 
     1566 	     else do;				/* all other blocks ... */
     1567 		     if message_block_header.descriptor_present
     1568 		     then call not_a_message ();	/* a descriptor when there shouldn't be one */
     1569 		     if message_block_header.data_lth > max_bits_in_other_blocks
     1570 		     then call not_a_message ();	/* too many bits to fit in the block */
     1571 		     if message_block_header.next_block ^= 0
     1572 		     then if message_block_header.data_lth ^= max_bits_in_other_blocks
     1573 			then call not_a_message ();	/* there's more to come but this block's not full */
     1574 		end;
     1575 
     1576 	     actual_ms_len = actual_ms_len + message_block_header.data_lth;
     1577 	     if actual_ms_len > message_descriptor.ms_len
     1578 	     then call not_a_message ();		/* we've found more bits than supposedly are in the message */
     1579 
     1580 	     block_offset = message_block_header.next_block;
     1581 	     first_block = "0"b;
     1582 	end;
     1583 
     1584 	if actual_ms_len < message_descriptor.ms_len
     1585 	then call not_a_message ();			/* the message isn't as long as it should be */
     1586 
     1587 	/*** Control arrives here only if the message is valid */
     1588 
     1589 	return ("1"b);
     1590 
     1591 
     1592 /* Control arrives here if the message is not valid */
     1593 
     1594 not_a_message:
     1595      procedure ();
     1596 
     1597 	go to RETURN_NOT_A_MESSAGE;
     1598 
     1599      end not_a_message;
     1600 
     1601 RETURN_NOT_A_MESSAGE:
     1602 	return ("0"b);
     1603 
     1604      end valid_message;
     1605 
     1606 	end RECONSTRUCT_THE_SEGMENT;
     1607 
     1608 /* format: off */
     1609  /* BEGIN INCLUDE FILE ... mseg_message.incl.pl1 */
  1     2 /* Created:  April 1985 by G. Palter from ms_block_hdr.incl.pl1 and ms_block_trailer.incl.pl1 */
  1     3 
  1     4 /* format: style3,linecom */
  1     5 
  1     6 /* NOTE: This include file references components of the mseg_segment structure which is defined separately in
  1     7*   mseg_segment.incl.pl1.  Programs which use this include file must also include mseg_segment.incl.pl1 to prevent
  1     8*   compilation errors. */
  1     9 
  1    10 
  1    11 /* Definition of the structure of a message stored in a message segment --
  1    12*
  1    13*   When a message is added to a message segment, it is split into one or more fixed sized blocks.  These blocks are then
  1    14*   allocated in the blocks space of the message segment.  (See mseg_message.incl.pl1 and mseg_message_.pl1 for more
  1    15*   information).  Each block includes a header which records where the next block of the message, if any, resides and how
  1    16*   many bits of data is actually recorded in the block.
  1    17*
  1    18*   In addition, the first block allocated for a message always includes a message descriptor.  This descriptor includes
  1    19*   various pieces of information about the message such as its total length, access class, author, etc. */
  1    20 
  1    21 
  1    22 /* Definition of the header found in all message blocks */
  1    23 
  1    24 declare	1 message_block_header
  1    25 			aligned based (mb_ptr),
  1    26 	  2 next_block	fixed binary (18) unaligned unsigned,
  1    27 	  2 descriptor_present			/* ON => a descriptor is in the last 22 words of the block */
  1    28 			bit (1) unaligned,
  1    29 	  2 data_lth				/* ... in bits */
  1    30 			fixed binary (17) unaligned unsigned;
  1    31 
  1    32 declare	mb_ptr		pointer;
  1    33 
  1    34 
  1    35 /* Definition of the descriptor for a message recorded in the first block of the message */
  1    36 
  1    37 declare	1 message_descriptor
  1    38 			aligned based (md_ptr),
  1    39 	  2 sentinel	bit (36) aligned,		/* proves that this is a message descriptor */
  1    40 	  2 message_chain,				/* the chronological chain of messages in the segment */
  1    41 	    3 next_message	fixed binary (18) unaligned unsigned,
  1    42 	    3 prev_message	fixed binary (18) unaligned unsigned,
  1    43 	  2 sender_level	fixed binary (3) unaligned unsigned,
  1    44 	  2 pad1		bit (5) unaligned,
  1    45 	  2 prev_message_in_hash_chain
  1    46 			fixed binary (18) unaligned unsigned,
  1    47 	  2 pad2		bit (10) unaligned,
  1    48 	  2 ms_id		bit (72) aligned,
  1    49 	  2 ms_len	fixed binary (24) unaligned unsigned,
  1    50 	  2 pad3		bit (12) unaligned,
  1    51 	  2 sender_id	char (32) aligned,
  1    52 	  2 sender_authorization
  1    53 			bit (72) aligned,
  1    54 	  2 ms_access_class bit (72) aligned,
  1    55 	  2 sender_max_authorization
  1    56 			bit (72) aligned,
  1    57 	  2 sender_process_id
  1    58 			bit (36) aligned,
  1    59 	  2 sender_audit	bit (36) aligned;
  1    60 
  1    61 declare	md_ptr		pointer;
  1    62 
  1    63 declare	MESSAGE_DESCRIPTOR_SENTINEL
  1    64 			bit (36) aligned static options (constant) initial ("777777777777"b3);
  1    65 
  1    66 
  1    67 /* Definition of the first block allocated for a message in a message segment */
  1    68 
  1    69 declare	1 first_message_block
  1    70 			aligned based (mb_ptr),
  1    71 	  2 header	aligned like message_block_header,
  1    72 	  2 data_space,
  1    73 	    3 data	bit (0 refer (first_message_block.data_lth)) unaligned,
  1    74 	    3 pad		bit (36
  1    75 			* (mseg_segment.block_size - currentsize (message_block_header)
  1    76 			- currentsize (message_descriptor)) - first_message_block.data_lth) unaligned,
  1    77 	  2 descriptor	aligned like message_descriptor;
  1    78 
  1    79 
  1    80 /* Definition of all but the first block allocated for a message in a message segment */
  1    81 
  1    82 declare	1 other_message_block
  1    83 			aligned based (mb_ptr),
  1    84 	  2 header	aligned like message_block_header,
  1    85 	  2 data_space,
  1    86 	    3 data	bit (0 refer (other_message_block.data_lth)) unaligned,
  1    87 	    3 pad		bit (36 * (mseg_segment.block_size - currentsize (message_block_header))
  1    88 			- other_message_block.data_lth) unaligned;
  1    89 
  1    90 /* END INCLUDE FILE ... mseg_message.incl.pl1 */
     1609 
     1610 /* format: on */
     1611 
     1612      end salvage_seg;
     1613 
     1614 /* format: off */
     1615  /* Begin include file mseg_data_.incl.pl1 BIM 1985-04-15 */
  2     2 /* format: style4 */
  2     3 
  2     4 declare  mseg_data_$lock_id bit (72) aligned external;
  2     5 declare  mseg_data_$block_size fixed bin (35) ext static;
  2     6 declare  mseg_data_$max_message_size fixed bin (35) ext static;
  2     7 declare  mseg_data_$template_operation bit (36) aligned external static; /* like mseg_operation */
  2     8 declare  mseg_data_$admin_ring fixed binary (3) external;
  2     9 declare  mseg_data_$execution_ring fixed bin (3) ext static;
  2    10 declare  mseg_data_$process_max_authorization bit (72) aligned ext static;
  2    11 declare  mseg_data_$group_id char (32) unaligned external static;
  2    12 
  2    13 /* End include file mseg_data_.incl.pl1 */
     1615 
     1616  /* BEGIN INCLUDE FILE ... mseg_segment.incl.pl1 */
  3     2 /* Created:  April 1985 by G. Palter from msg_hdr.incl.pl1 */
  3     3 
  3     4 /* format: style3,linecom */
  3     5 
  3     6 /* NOTE: This include file references the mseg_wakeup_state structure which is defined separately in
  3     7*   mseg_wakeup_state.incl.pl1.  Programs which use this include file must also include mseg_wakeup_state.incl.pl1 to
  3     8*   prevent compilation errors. */
  3     9 
  3    10 
  3    11 /* Definition of the structure of a message segment --
  3    12*
  3    13*   A message segment is composed of three sections -- the header, the block map, and the blocks space.
  3    14*
  3    15*   In addition to the message ID hash table and the head&tail of the chronological message chain, the message header also
  3    16*   contains the state of wakeup acceptance for this segment.  In order to maintain compatibility with early version 5
  3    17*   message segments, the wakeup state is maintained in a 64 word area of the header which had been known as the "header
  3    18*   message".  See mseg_wakeup_state.incl.pl1 for additional information.
  3    19*
  3    20*   The entire message segment, including the header and block map, is treated as an array of fixed size blocks.  The block
  3    21*   map contains a bit for each block in the message which indicates whether that block is in use.  (The blocks which
  3    22*   overlay the header and block map are always marked as being in use).  The size of the block map is based on the
  3    23*   maxlength of the message segment in order to provide more free space in very small message segments.
  3    24*
  3    25*   When a message is added to a message segment, its content is split into blocks which are allocated in the blocks space.
  3    26*   The blocks space starts with the first block after the block map and occupies the remainder of the segment. */
  3    27 
  3    28 declare	1 mseg_segment	aligned based (mseg_ptr),
  3    29 	  2 header	aligned,
  3    30 	    3 lock	bit (36) aligned,
  3    31 	    3 sentinel	bit (36) aligned,		/* proves that this segment is a message segment */
  3    32 	    3 reserved	bit (72) aligned,		/* ... for compatibility with early version 5 segments */
  3    33 	    3 date_time_last_salvaged
  3    34 			fixed binary (71),
  3    35 	    3 pad		(2) bit (36) aligned,
  3    36 	    3 message_chain,			/* the chronological chain of messages in the segment ... */
  3    37 	      4 first_message			/* ... the first (oldest) message */
  3    38 			fixed binary (18) unaligned unsigned,
  3    39 	      4 pad1	bit (18) unaligned,
  3    40 	      4 last_message			/* ... the last (youngest) message */
  3    41 			fixed binary (18) unaligned unsigned,
  3    42 	      4 pad2	bit (18) unaligned,
  3    43 	    3 n_blocks_allocated			/* total # of blocks available in this message segment ... */
  3    44 			fixed binary (18),		/* ... including space occupied by the header and block map */
  3    45 	    3 n_blocks_unused
  3    46 			fixed binary (18),
  3    47 	    3 n_messages	fixed binary (18),
  3    48 	    3 block_size	fixed binary,		/* ... in words */
  3    49 	    3 flags,
  3    50 	      4 modification_in_progress
  3    51 			bit (1) unaligned,
  3    52 	      4 salvaged	bit (1) unaligned,		/* ON => the message segment had been salvaged earlier */
  3    53 	      4 wakeup_state_set
  3    54 			bit (1) unaligned,
  3    55 	      4 salvage_in_progress
  3    56 			bit (1) unaligned,
  3    57 	      4 pad	bit (32) unaligned,
  3    58 	    3 version	fixed binary,
  3    59 	    3 wakeup_state	aligned,
  3    60 	      4 state	aligned like mseg_wakeup_state,
  3    61 	      4 pad	(64 - 10) bit (36) aligned,	/* ... for compatibility with early version 5 segments */
  3    62 	    3 hash_table	aligned,			/* ... based on the low order 9 bits of the message ID */
  3    63 	      4 last_message
  3    64 			(0:511) fixed binary (18) unaligned unsigned,
  3    65 	  2 block_map	aligned,			/* ON => the block is in use */
  3    66 	    3 map		bit (0 refer (mseg_segment.n_blocks_allocated)) unaligned;
  3    67 
  3    68 declare	mseg_ptr		pointer;
  3    69 
  3    70 declare	MSEG_SEGMENT_VERSION_5			/* presently supported version */
  3    71 			fixed binary static options (constant) initial (5);
  3    72 
  3    73 declare	MSEG_SEGMENT_SENTINEL
  3    74 			bit (36) aligned static options (constant) initial ("252525252525"b3);
  3    75 
  3    76 
  3    77 /* Redefinitions required to access the wakeup_state of the segment in early version 5 message segments */
  3    78 
  3    79 declare	header_msg_access_class
  3    80 			bit (72) aligned defined (mseg_segment.reserved);
  3    81 
  3    82 declare	header_msg_present	bit (1) unaligned defined (mseg_segment.wakeup_state_set);
  3    83 
  3    84 declare	header_msg	(64) bit (36) aligned based (addr (mseg_segment.wakeup_state));
  3    85 
  3    86 /* END INCLUDE FILE ... mseg_segment.incl.pl1 */
     1616 
     1617  /* BEGIN INCLUDE FILE ... mseg_wakeup_state.incl.pl1 */
  4     2 /* Created:  April 1985 by G. Palter */
  4     3 
  4     4 /* format: style3,linecom */
  4     5 
  4     6 /* Description of the wakeup state of a message segment --
  4     7*
  4     8*   The wakeup state defines which process, if any, is willing to receive normal or urgent IPC wakeups when a message which
  4     9*   requests such a wakeup is added to a message segment.  The process is allowed to separately accept or defer normal and
  4    10*   urgent wakeups.  Note that deferring a wakeup is not the same as not accepting wakeups.  A process is not allowed to
  4    11*   stop accepting wakeups once it has accepted them as to do so would introduce a relatively high badnwidth covert
  4    12*   channel.  (In the present implementation, urgent wakeups are really no different from normal wakeups.  Eventually,
  4    13*   urgent wakeups should be implemented using an IPS signal along with the IPC wakeup).
  4    14*
  4    15*   mseg_$get_wakeup_state_seg requires that the caller supply the proper value for mseg_wakeup_state.version in the
  4    16*   mseg_operation.  If there is no wakeup state recorded in the message segment, mseg_$get_wakeup_state_seg will return
  4    17*   the status code error_table_$messages_off.
  4    18*
  4    19*   mseg_$set_wakeup_state_seg ignores the values of the access_class, process_id, and lock_id elements supplied by the
  4    20*   caller in the mseg_operation.  mseg_$set_wakeup_state_seg will, instead, furnish the values of the process making the
  4    21*   call for these elements and will return these values to its caller.  In other words, mseg_$set_wakeup_state_seg can not
  4    22*   be used by one process to accept/defer wakeups on behalf of another process. */
  4    23 
  4    24 declare	1 mseg_wakeup_state aligned based (mseg_wakeup_state_ptr),
  4    25 	  2 version	character (8) unaligned,
  4    26 	  2 flags		aligned,
  4    27 	    3 accepting_normal_wakeups		/* ON => process has accepted normal wakeups */
  4    28 			bit (1) unaligned,		/* OFF => process has deferred normal wakeups */
  4    29 	    3 accepting_urgent_wakeups		/* ON => process has accepted urgent wakeups */
  4    30 			bit (1) unaligned,		/* OFF => process has deferred urgent wakeups */
  4    31 	    3 pad		bit (34) unaligned,
  4    32 	  2 pad		bit (36) aligned,
  4    33 	  2 event_channel	fixed binary (71),		/* IPC event channel on which to send normal/urgent wakeups */
  4    34 	  2 access_class	bit (72) aligned,		/* AIM access class of the process accepting wakeups */
  4    35 	  2 process_id	bit (36) aligned,		/* ID of the process accepting wakeups */
  4    36 	  2 lock_id	bit (36) aligned;		/* lock ID used to test if said process is still alive */
  4    37 
  4    38 declare	mseg_wakeup_state_ptr
  4    39 			pointer;
  4    40 
  4    41 declare	MSEG_WAKEUP_STATE_VERSION_1
  4    42 			character (8) static options (constant) initial ("msegwkp1");
  4    43 
  4    44 /* END INCLUDE FILE ... mseg_wakeup_state.incl.pl1 */
     1617 
     1618  /* BEGIN INCLUDE FILE ... mseg_operation.incl.pl1 */
  5     2 
  5     3 /* format: style3,idind30,linecom */
  5     4 
  5     5 /**** Created 1985-04-16, BIM: from Pandolf's  mseg_access_operation */
  5     6 
  5     7 /**** NOTES:
  5     8*      The caller of mseg_ must set mseg_operation.access_operation to record
  5     9*      the type of access checking it has performed and which mseg_ should
  5    10*      perform when needed (i.e., for those entrypoints which operate on
  5    11*      messages like mseg_$read_message).
  5    12*
  5    13*      mseg_operation.operation is reserved explicitly for use by mseg_ and
  5    14*      its underlying modules.
  5    15*
  5    16*      You must also include entry_access_info, mseg_message_info, and
  5    17*      mbx_wakeup_state along with this include file. */
  5    18 
  5    19 dcl	mseg_operation_ptr		pointer;
  5    20 dcl	MSEG_OPERATION_VERSION_1	fixed bin internal static options (constant) init (1);
  5    21 dcl	MSEG_TYPE_MBX		fixed bin init (1) internal static options (constant);
  5    22 dcl	MSEG_TYPE_MS		fixed bin init (2) internal static options (constant);
  5    23 
  5    24 dcl	1 mseg_operation		based (mseg_operation_ptr) aligned,
  5    25 	  2 version		fixed binary,	/* current version is MSEG_OPERATION_VERSION_1 */
  5    26 	  2 type			fixed binary,	/* MBX or MS */
  5    27 	  2 access_operation	fixed binary,	/* type of access checks required for the operation */
  5    28 	  2 operation		bit (36) aligned,	/* for use by mseg_ and underlying modules */
  5    29 	  2 caller		aligned,		/* always collected in gate target */
  5    30 	    3 validation_level	fixed bin (3),
  5    31 	    3 privileges		bit (18) aligned,	/* factored for speed */
  5    32 	    3 pad_align_double	fixed bin (71),	/* just to force alignment */
  5    33 	    3 authorization		bit (72) aligned,	/* must be 2word aligned */
  5    34 	    3 max_authorization	bit (72) aligned,
  5    35 	    3 group_id		char (32) unaligned,
  5    36 	  2 flags			aligned,
  5    37 	    3 mseg_pathname_valid	bit (1) unaligned,
  5    38 	    3 mseg_ptr_valid	bit (1) unaligned,
  5    39 	    3 mseg_index_valid	bit (1) unaligned,
  5    40 	    3 access_info_valid	bit (1) unaligned,
  5    41 	    3 md_ptr_valid		bit (1) unaligned,
  5    42 	    3 message_info_valid	bit (1) unaligned,	/* note -- for some operations not all fields are used */
  5    43 	    3 wakeup_state_valid	bit (1) unaligned,
  5    44 	    3 suppress_access_checks	bit (1) unaligned,	/* set by privileged interfaces, suppresses ALL access checking */
  5    45 	    3 call_admin_gate	bit (1) unaligned,	/* we is in ring 1, boss */
  5    46 	    3 only_own_access	bit (1) unaligned,	/* the user had o rather than r/d */
  5    47 	    3 add_message_info_all_valid
  5    48 				bit (1) unaligned,	/* Believe ALL the fields in message info on an add */
  5    49 	    3 pad			bit (24) unaligned,
  5    50 	  2 dir_name		char (168) unaligned,
  5    51 	  2 entryname		char (32) unaligned,
  5    52 	  2 mseg_ptr		pointer,
  5    53 	  2 md_ptr		pointer,		/* message descriptor */
  5    54 	  2 mseg_index		fixed bin,
  5    55 	  2 access_info		aligned like entry_access_info,
  5    56 	  2 message_info		aligned like mseg_message_info,
  5    57 	  2 wakeup_state		aligned like mseg_wakeup_state;
  5    58 
  5    59 /* END INCLUDE FILE ... mseg_operation.incl.pl1 */
     1618 
     1619  /* BEGIN INCLUDE FILE ... mseg_operation_data.incl.pl1 */
  6     2 /* Created:  April 1985 by G. Palter */
  6     3 
  6     4 /* format: style3,linecom */
  6     5 
  6     6 
  6     7 /* Description of a message segment primitive operation (mseg_) */
  6     8 
  6     9 declare	1 mseg_operation_data
  6    10 			aligned based (mseg_operation_data_ptr),
  6    11 	  2 operation_id				/* identifies which operation is being performed */
  6    12 			fixed binary (9) unaligned unsigned,
  6    13 	  2 required_data	unaligned,		/* which parts of mseg_operation must the caller supply */
  6    14 	    3 pathname	bit (1) unaligned,
  6    15 	    3 mseg_ptr	bit (1) unaligned,
  6    16 	    3 mseg_index	bit (1) unaligned,
  6    17 	    3 access_info	bit (1) unaligned,
  6    18 	    3 md_ptr	bit (1) unaligned,
  6    19 	    3 message_info	bit (1) unaligned,
  6    20 	    3 wakeup_state	bit (1) unaligned,
  6    21 	    3 wakeup_state_version
  6    22 			bit (1) unaligned,
  6    23 	    3 pad		bit (1) unaligned,
  6    24 	  2 begin_flags	unaligned,		/* controls mseg_utils_$begin_operation ... */
  6    25 	    3 lock_segment	bit (1) unaligned,		/* ON => lock the segment */
  6    26 	    3 dont_check_lock_results			/* ON => caller (delete_seg) will check that the lock is OK */
  6    27 			bit (1) unaligned,
  6    28 	    3 check_header_consistency		/* ON => check that the header looks OK */
  6    29 			bit (1) unaligned,
  6    30 	    3 initialize_header			/* ON => initialize the header if the segment's empty */
  6    31 			bit (1) unaligned,
  6    32 	    3 check_count_consistency			/* ON => check that the message count and chains are OK */
  6    33 			bit (1) unaligned,
  6    34 	    3 pad		bit (4) unaligned,
  6    35 	  2 finish_flags	unaligned,		/* controls mseg_utils_$(finish abort)_operation */
  6    36 	    3 truncate_if_possible			/* ON => truncate if the segment is empty */
  6    37 			bit (1) unaligned,
  6    38 	    3 already_salvaged			/* ON => we've already tried to salvage this segment once */
  6    39 			bit (1) unaligned,
  6    40 	    3 unlock_segment			/* ON => unlock the segment */
  6    41 			bit (1) unaligned,
  6    42 	    3 pad		bit (6) unaligned;
  6    43 
  6    44 declare	mseg_operation_data_ptr
  6    45 			pointer;
  6    46 
  6    47 
  6    48 /* Data in mseg_operations_ used only by mseg_utils_ */
  6    49 
  6    50 declare	mseg_operations_$names
  6    51 			(26) character (64) varying external;
  6    52 
  6    53 /* Named constants used in mseg_operations_.cds to build the above data structures */
  6    54 
  6    55 /* format: idind31 */
  6    56 
  6    57 declare	(
  6    58      /*** Individual required fields */
  6    59 	MSEG_REQUIRE_PATHNAME	 initial ("400"b3),
  6    60 	MSEG_REQUIRE_MSEG_PTR	 initial ("200"b3),
  6    61 	MSEG_REQUIRE_MSEG_INDEX	 initial ("100"b3),
  6    62 	MSEG_REQUIRE_ACCESS_INFO	 initial ("040"b3),
  6    63 	MSEG_REQUIRE_MD_PTR		 initial ("020"b3),
  6    64 	MSEG_REQUIRE_MESSAGE_INFO	 initial ("010"b3),
  6    65 	MSEG_REQUIRE_WAKEUP_STATE	 initial ("004"b3),
  6    66 	MSEG_REQUIRE_WAKEUP_STATE_VERSION
  6    67 				 initial ("002"b3)
  6    68 	)			 bit (9) aligned static options (constant);
  6    69 
  6    70 declare	(
  6    71      /*** Commonly used groupings of required fields */
  6    72 	MSEG_REQUIRED_FOR_MESSAGE	 initial ("250"b3), /* mseg_ptr, access_info, message_info */
  6    73 	MSEG_REQUIRED_FOR_SEGMENT	 initial ("200"b3), /* mseg_ptr */
  6    74 	MSEG_REQUIRED_FOR_FS_INTERFACE initial ("400"b3)	/* pathname */
  6    75 	)			 bit (9) aligned static options (constant);
  6    76 
  6    77 declare	(
  6    78      /*** Individual begin_operation flags */
  6    79 	MSEG_LOCK_SEGMENT		 initial ("400"b3),
  6    80 	MSEG_DONT_CHECK_LOCK_RESULTS	 initial ("200"b3),
  6    81 	MSEG_CHECK_HEADER_CONSISTENCY	 initial ("100"b3),
  6    82 	MSEG_INITIALIZE_HEADER	 initial ("040"b3),
  6    83 	MSEG_CHECK_COUNT_CONSISTENCY	 initial ("020"b3)
  6    84 	)			 bit (9) aligned static options (constant);
  6    85 
  6    86 declare	(
  6    87      /*** Commonly used groupings of begin_operation flags */
  6    88 	MSEG_BEGIN_FOR_MESSAGE	 initial ("520"b3), /* lock, check header, check count */
  6    89 	MSEG_BEGIN_FOR_SEGMENT	 initial ("500"b3), /* lock, check header */
  6    90 	MSEG_BEGIN_FOR_FS_INTERFACE	 initial ("000"b3)	/* no actions need be taken */
  6    91 	)			 bit (9) aligned static options (constant);
  6    92 
  6    93 declare	(
  6    94      /*** Individual finish_operation flags */
  6    95 	MSEG_TRUNCATE_IF_POSSIBLE	 initial ("400"b3),
  6    96 	MSEG_ALREADY_SALVAGED	 initial ("200"b3),
  6    97 	MSEG_UNLOCK_SEGMENT		 initial ("100"b3)
  6    98 	)			 bit (9) aligned static options (constant);
  6    99 
  6   100 declare	(
  6   101      /*** Commonly used groupings of finish_operation flags */
  6   102 	MSEG_FINISH_FOR_MESSAGE	 initial ("400"b3), /* truncate if possible */
  6   103 	MSEG_FINISH_FOR_SEGMENT	 initial ("400"b3), /* truncate if possible */
  6   104 	MSEG_FINISH_FOR_FS_INTERFACE	 initial ("000"b3)	/* no actions need be taken */
  6   105 	)			 bit (9) aligned static options (constant);
  6   106 
  6   107 /* END INCLUDE FILE ... mseg_operation_data.incl.pl1 */
     1619 
     1620  /* BEGIN INCLUDE FILE ... mseg_operations_.incl.pl1 */
  7     2 /* Created:  April 1985 by G. Palter */
  7     3 
  7     4 /* format: style3,linecom */
  7     5 
  7     6 /* The defined message segment primitive operations (mseg_) */
  7     7 
  7     8 declare	(
  7     9 	mseg_operations_$add_acl_entries_seg,
  7    10 	mseg_operations_$add_message,
  7    11 	mseg_operations_$chname_seg,
  7    12 	mseg_operations_$close_seg,
  7    13 	mseg_operations_$compact_seg,
  7    14 	mseg_operations_$copy_seg_source,
  7    15 	mseg_operations_$copy_seg_target,
  7    16 	mseg_operations_$count_messages,
  7    17 	mseg_operations_$create_seg,
  7    18 	mseg_operations_$delete_acl_entries_seg,
  7    19 	mseg_operations_$delete_message,
  7    20 	mseg_operations_$delete_seg,
  7    21 	mseg_operations_$get_salvaged_flag_seg,
  7    22 	mseg_operations_$get_wakeup_state_seg,
  7    23 	mseg_operations_$initiate_seg,
  7    24 	mseg_operations_$list_acl_seg,
  7    25 	mseg_operations_$list_acl_entries_seg,
  7    26 	mseg_operations_$open_seg,
  7    27 	mseg_operations_$read_message,
  7    28 	mseg_operations_$replace_acl_seg,
  7    29 	mseg_operations_$reset_salvaged_flag_seg,
  7    30 	mseg_operations_$reset_wakeup_state_seg,
  7    31 	mseg_operations_$set_max_length_seg,
  7    32 	mseg_operations_$set_safety_switch_seg,
  7    33 	mseg_operations_$set_wakeup_state_seg,
  7    34 	mseg_operations_$update_message
  7    35 	)		bit (36) aligned external;
  7    36 
  7    37 /* END INCLUDE FILE ... mseg_operations_.incl.pl1 */
     1620 
     1621  /* BEGIN INCLUDE FILE . . . mseg_message_info.incl.pl1 BIM 1984-10-10 */
  8     2 /* format: style3,idind30 */
  8     3 
  8     4 /* structure returned when message is read from a message segment */
  8     5 
  8     6 
  8     7 dcl	mseg_message_info_ptr	pointer;
  8     8 
  8     9 dcl	1 mseg_message_info		based (mseg_message_info_ptr) aligned,
  8    10 	  2 version		char (8) aligned,
  8    11 	  2 message_code		fixed bin,
  8    12 	  2 control_flags		unaligned,
  8    13 	    3 own			bit (1),
  8    14 	    3 delete		bit (1),
  8    15 	    3 pad			bit (34),
  8    16 	  2 ms_ptr		ptr,		/* pointer to message */
  8    17 	  2 ms_len		fixed bin (24),	/* length of message  in bits */
  8    18 	  2 ms_id			bit (72),		/* unique ID of message */
  8    19 						/* input in some cases */
  8    20 	  2 ms_access_class		bit (72),		/* message access class */
  8    21 	  2 sender_id		char (32) unaligned,/* process-group ID of sender */
  8    22 	  2 sender_process_id	bit (36) aligned,	/* if nonzero, process that sent */
  8    23 	  2 sender_level		fixed bin,	/* validation level of sender */
  8    24 	  2 sender_authorization	bit (72),		/* access authorization of message sender */
  8    25 	  2 sender_max_authorization	bit (72),		/* max authorization of sending process */
  8    26 	  2 sender_audit		bit (36) aligned;   /* audit flags */
  8    27 
  8    28 declare	MSEG_MESSAGE_INFO_V1	char (8) aligned init ("msegmi01") int static options (constant);
  8    29 
  8    30 declare	(
  8    31 	MSEG_READ_FIRST		init (1),
  8    32 	MSEG_READ_LAST		init (2),
  8    33 	MSEG_READ_SPECIFIED		init (3),
  8    34 	MSEG_READ_BEFORE_SPECIFIED	init (4),
  8    35 	MSEG_READ_AFTER_SPECIFIED	init (5))
  8    36 	fixed bin int static options (constant);
  8    37 
  8    38 declare  (MSEG_READ_OWN		init ("1"b),
  8    39 	MSEG_READ_DELETE		init ("01"b)
  8    40 	)			bit (36) aligned internal static options (constant);
  8    41 
  8    42 /* END INCLUDE FILE . . . mseg_message_info.incl.pl1 */
     1621 
     1622  /* BEGIN INCLUDE FILE ... entry_access_info.incl.pl1 */
  9     2 
  9     3 /*
  9     4*   Written  03/22/85 by M. Pandolf
  9     5*   Modified 1985-04-19, BIM: added parent access class.
  9     6**/
  9     7 
  9     8 dcl  entry_access_info_ptr pointer;
  9     9 dcl  ENTRY_ACCESS_INFO_VERSION_1 char (8) internal static options (constant)
  9    10      init ("eainf001");
  9    11 
  9    12 dcl 1 entry_access_info aligned based (entry_access_info_ptr),
  9    13     2 version char (8),				/* = ENTRY_ACCESS_INFO_VERSION_1 */
  9    14     2 type fixed bin,				/* see status_structures.incl.pl1 */
  9    15     2 dir_name char (168) unaligned,			/* parent of this entry */
  9    16     2 entryname char (32) unaligned,			/* primary name of this entry */
  9    17     2 uid bit (36) aligned,				
  9    18     2 ring_brackets (3) fixed bin (3),			/* for dirs, the dir ring brackets are here */
  9    19     2 extended_ring_brackets (3) fixed bin (3),		/* not-yet-implemented x-rb's */
  9    20     2 effective_access_modes bit (36) aligned,		/* for dirs, dir mode is here */
  9    21     2 extended_access_modes bit (36) aligned,		/* always null for dirs */
  9    22     2 access_class bit (72) aligned,			/* for multiclass, max access class */
  9    23     2 parent_access_class bit (72) aligned,		/* for multiclass, this is effectively the min access class */
  9    24     2 multiclass bit (1) aligned;
  9    25 
  9    26 /* END INCLUDE FILE ... entry_access_info.incl.pl1 */
     1622 
     1623  /* BEGIN INCLUDE FILE ... mseg_format_errors_.incl.pl1 */
 10     2 /* Created:  April 1985 by G. Palter */
 10     3 
 10     4 /* format: style3,linecom */
 10     5 
 10     6 /* Standard system status codes corresponding to the possible errors which the message segment primitives can detect in
 10     7*   the format of a message segment -- These errors are implemented as status codes to permit the use of
 10     8*   admin_gate_$syserr_error_code to actually record the errors in the syserr log. */
 10     9 
 10    10 declare	(
 10    11 	mseg_format_errors_$bad_descriptor_sentinel,
 10    12 	mseg_format_errors_$bad_mseg_sentinel,
 10    13 	mseg_format_errors_$bad_mseg_version,
 10    14 	mseg_format_errors_$circular_hash_chain,
 10    15 	mseg_format_errors_$circular_message_blocks,
 10    16 	mseg_format_errors_$circular_message_chain,
 10    17 	mseg_format_errors_$descriptor_in_other_block,
 10    18 	mseg_format_errors_$inconsistent_backward_chain,
 10    19 	mseg_format_errors_$inconsistent_block_map,
 10    20 	mseg_format_errors_$inconsistent_forward_chain,
 10    21 	mseg_format_errors_$inconsistent_hash_chain,
 10    22 	mseg_format_errors_$inconsistent_message_count,
 10    23 	mseg_format_errors_$inconsistent_message_length,
 10    24 	mseg_format_errors_$invalid_message_block_offset,
 10    25 	mseg_format_errors_$modification_in_progress,
 10    26 	mseg_format_errors_$negative_message_count,
 10    27 	mseg_format_errors_$no_descriptor_in_first_block,
 10    28 	mseg_format_errors_$salvage_in_progress,
 10    29 	mseg_format_errors_$unused_block_in_message
 10    30 	)		fixed binary (35) external;
 10    31 
 10    32 /* END INCLUDE FILE ... mseg_format_errors_.incl.pl1 */
     1623 
     1624  /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
 11     2 /* format: style3 */
 11     3 
 11     4 /* These constants are to be used for the flags argument of sub_err_ */
 11     5 /* They are just "string (condition_info_header.action_flags)" */
 11     6 
 11     7 declare	(
 11     8 	ACTION_CAN_RESTART	init (""b),
 11     9 	ACTION_CANT_RESTART init ("1"b),
 11    10 	ACTION_DEFAULT_RESTART
 11    11 			init ("01"b),
 11    12 	ACTION_QUIET_RESTART
 11    13 			init ("001"b),
 11    14 	ACTION_SUPPORT_SIGNAL
 11    15 			init ("0001"b)
 11    16 	)		bit (36) aligned internal static options (constant);
 11    17 
 11    18 /* End include file */
     1624 
     1625  /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
 12     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
 12     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
 12     4 
 12     5 /* This include file has an ALM version.  Keep 'em in sync! */
 12     6 
 12     7 dcl (
 12     8 
 12     9 /* The following constants define the message action codes.  This indicates
 12    10*how a message is to be handled.  */
 12    11 
 12    12      SYSERR_CRASH_SYSTEM	init (1),			
 12    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
 12    14 
 12    15      SYSERR_TERMINATE_PROCESS	init (2),
 12    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
 12    17 
 12    18      SYSERR_PRINT_WITH_ALARM	init (3),
 12    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
 12    20 
 12    21      SYSERR_PRINT_ON_CONSOLE	init (0),
 12    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
 12    23 
 12    24      SYSERR_LOG_OR_PRINT	init (4),
 12    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
 12    26 
 12    27      SYSERR_LOG_OR_DISCARD	init (5),
 12    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
 12    29 
 12    30 
 12    31 /* The following constants are added to the normal severities to indicate
 12    32*different sorting classes of messages.  */
 12    33 
 12    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
 12    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
 12    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
 12    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
 12    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
 12    39 	) fixed bin internal static options (constant);
 12    40 
 12    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
     1625 
     1626  /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
 13     2 
 13     3 /* Structure for find_condition_info_.
 13     4*
 13     5*   Written 1-Mar-79 by M. N. Davidoff.
 13     6**/
 13     7 
 13     8 /* automatic */
 13     9 
 13    10      declare condition_info_ptr     pointer;
 13    11 
 13    12 /* based */
 13    13 
 13    14      declare 1 condition_info	      aligned based (condition_info_ptr),
 13    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
 13    16 	     2 version	      fixed binary,		/* Must be 1 */
 13    17 	     2 condition_name     char (32) varying,	/* name of condition */
 13    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
 13    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
 13    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
 13    21 	     2 flags	      unaligned,
 13    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
 13    23 	       3 pad1	      bit (35),
 13    24 	     2 pad2	      bit (36),
 13    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
 13    26 	     2 pad3	      (4) bit (36);
 13    27 
 13    28 /* internal static */
 13    29 
 13    30      declare condition_info_version_1
 13    31 			      fixed binary internal static options (constant) initial (1);
 13    32 
 13    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
     1626 

     1627  /*  */
 14     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
 14     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
 14     4 /* Modified 07/07/76 by Morris for fault register data */
 14     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
 14     6 /* Modified '82 to make values constant */
 14     7 
 14     8 /* words 0-15 pointer registers */
 14     9 
 14    10 dcl  mcp ptr;
 14    11 
 14    12 dcl 1 mc based (mcp) aligned,
 14    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
 14    14    (2 regs,					/* registers */
 14    15       3 x (0:7) bit (18),				/* index registers */
 14    16       3 a bit (36),					/* accumulator */
 14    17       3 q bit (36),					/* q-register */
 14    18       3 e bit (8),					/* exponent */
 14    19       3 pad1 bit (28),
 14    20       3 t bit (27),					/* timer register */
 14    21       3 pad2 bit (6),
 14    22       3 ralr bit (3),				/* ring alarm register */
 14    23 
 14    24     2 scu (0:7) bit (36),
 14    25 
 14    26     2 mask bit (72),				/* mem controller mask at time of fault */
 14    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
 14    28     2 errcode fixed bin (35),				/* fault handler's error code */
 14    29     2 fim_temp,
 14    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
 14    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
 14    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
 14    33     2 fault_reg bit (36),				/* fault register */
 14    34     2 pad2 bit (1),
 14    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
 14    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
 14    37     2 fault_time bit (54),				/* time of fault */
 14    38 
 14    39     2 eis_info (0:7) bit (36)) unaligned;
 14    40 
 14    41 
 14    42 dcl (apx fixed bin init (0),
 14    43      abx fixed bin init (1),
 14    44      bpx fixed bin init (2),
 14    45      bbx fixed bin init (3),
 14    46      lpx fixed bin init (4),
 14    47      lbx fixed bin init (5),
 14    48      spx fixed bin init (6),
 14    49      sbx fixed bin init (7)) internal static options (constant);
 14    50 
 14    51 
 14    52 
 14    53 
 14    54 dcl  scup ptr;
 14    55 
 14    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
 14    57 
 14    58 
 14    59 /*	WORD (0)		*/
 14    60 
 14    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
 14    62       3 prr bit (3),				/* procedure ring register */
 14    63       3 psr bit (15),				/* procedure segment register */
 14    64       3 p bit (1),					/* procedure privileged bit */
 14    65 
 14    66     2 apu,					/* APPENDING UNIT STATUS */
 14    67       3 xsf bit (1),				/* ext seg flag - IT modification */
 14    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
 14    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
 14    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
 14    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
 14    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
 14    73       3 dsptw bit (1),				/* Fetch of DSPTW */
 14    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
 14    75       3 sdwp bit (1),				/* Fetch of SDW paged */
 14    76       3 ptw bit (1),				/* Fetch of PTW */
 14    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
 14    78       3 fap bit (1),				/* Fetch of final address paged */
 14    79       3 fanp bit (1),				/* Fetch of final address non-paged */
 14    80       3 fabs bit (1),				/* Fetch of final address absolute */
 14    81 
 14    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
 14    83 
 14    84 
 14    85 /*	WORD (1)		*/
 14    86 
 14    87     2 fd,						/* FAULT  DATA */
 14    88       3 iro bit (1),				/* illegal ring order */
 14    89       3 oeb bit (1),				/* out of execute bracket */
 14    90       3 e_off bit (1),				/* no execute */
 14    91       3 orb bit (1),				/* out of read bracket */
 14    92       3 r_off bit (1),				/* no read */
 14    93       3 owb bit (1),				/* out of write bracket */
 14    94       3 w_off bit (1),				/* no write */
 14    95       3 no_ga bit (1),				/* not a gate */
 14    96       3 ocb bit (1),				/* out of call bracket */
 14    97       3 ocall bit (1),				/* outward call */
 14    98       3 boc bit (1),				/* bad outward call */
 14    99       3 inret bit (1),				/* inward return */
 14   100       3 crt bit (1),				/* cross ring transfer */
 14   101       3 ralr bit (1),				/* ring alarm register */
 14   102       3 am_er bit (1),				/* associative memory fault */
 14   103       3 oosb bit (1),				/* out of segment bounds */
 14   104       3 paru bit (1),				/* processor parity upper */
 14   105       3 parl bit (1),				/* processor parity lower */
 14   106       3 onc_1 bit (1),				/* op not complete type 1 */
 14   107       3 onc_2 bit (1),				/* op not complete type 2 */
 14   108 
 14   109     2 port_stat,					/* PORT  STATUS */
 14   110       3 ial bit (4),				/* illegal action lines */
 14   111       3 iac bit (3),				/* illegal action channel */
 14   112       3 con_chan bit (3),				/* connect channel */
 14   113 
 14   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
 14   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
 14   116 
 14   117 
 14   118 /*	WORD (2)		*/
 14   119 
 14   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
 14   121       3 trr bit (3),				/* temporary ring register */
 14   122       3 tsr bit (15),				/* temporary segment register */
 14   123 
 14   124     2 pad2 bit (9),
 14   125 
 14   126     2 cpu_no bit (3),				/* CPU number */
 14   127 
 14   128     2 delta bit (6),				/* tally modification DELTA */
 14   129 
 14   130 
 14   131 /*	WORD (3)		*/
 14   132 
 14   133     2 word3 bit (18),
 14   134 
 14   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
 14   136       3 tsna,					/* Word 1 status */
 14   137         4 prn bit (3),				/* Word 1  PR  number */
 14   138         4 prv bit (1),				/* Word 1  PR  valid bit */
 14   139       3 tsnb,					/* Word 2  status */
 14   140         4 prn bit (3),				/* Word 2  PR  number */
 14   141         4 prv bit (1),				/* Word 2  PR  valid bit */
 14   142       3 tsnc,					/* Word 3  status */
 14   143         4 prn bit (3),				/* Word 3  PR  number */
 14   144         4 prv bit (1),				/* Word 3  PR  valid bit */
 14   145 
 14   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
 14   147 
 14   148 
 14   149 /* 	WORD (4)		*/
 14   150 
 14   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
 14   152 
 14   153     2 ir,						/* INDICATOR  REGISTERS */
 14   154       3 zero bit (1),				/* zero indicator */
 14   155       3 neg bit (1),				/* negative indicator */
 14   156       3 carry bit (1),				/* carryry indicator */
 14   157       3 ovfl bit (1),				/* overflow indicator */
 14   158       3 eovf bit (1),				/* eponent overflow */
 14   159       3 eufl bit (1),				/* exponent underflow */
 14   160       3 oflm bit (1),				/* overflow mask */
 14   161       3 tro bit (1),				/* tally runout */
 14   162       3 par bit (1),				/* parity error */
 14   163       3 parm bit (1),				/* parity mask */
 14   164       3 bm bit (1),					/* ^bar mode */
 14   165       3 tru bit (1),				/* truncation mode */
 14   166       3 mif bit (1),				/* multi-word instruction mode */
 14   167       3 abs bit (1),				/* absolute mode */
 14   168       3 hex bit (1),				/* hexadecimal exponent mode */
 14   169       3 pad bit (3),
 14   170 
 14   171 
 14   172 /*	WORD (5)		*/
 14   173 
 14   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
 14   175 
 14   176     2 cu,						/* CONTROL UNIT STATUS */
 14   177       3 rf bit (1),					/* on first cycle of repeat instr */
 14   178       3 rpt bit (1),				/* repeat instruction */
 14   179       3 rd bit (1),					/* repeat double instruction */
 14   180       3 rl bit (1),					/* repeat link instruciton */
 14   181       3 pot bit (1),				/* IT  modification */
 14   182       3 pon bit (1),				/* return type instruction */
 14   183       3 xde bit (1),				/* XDE from Even location */
 14   184       3 xdo bit (1),				/* XDE from Odd  location */
 14   185       3 poa bit (1),				/* operation preparation */
 14   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
 14   187       3 its bit (1),				/* ITS modification */
 14   188       3 if bit (1),					/* fault occured during instruction fetch */
 14   189 
 14   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
 14   191 
 14   192 
 14   193 /*	WORDS (6,7)	*/
 14   194 
 14   195     2 even_inst bit (36),				/* even instruction of faulting pair */
 14   196 
 14   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
 14   198 
 14   199 
 14   200 
 14   201 
 14   202 
 14   203 
 14   204 /*	ALTERNATE   SCU  DECLARATION		*/
 14   205 
 14   206 
 14   207 dcl 1 scux based (scup) aligned,
 14   208 
 14   209    (2 pad0 bit (36),
 14   210 
 14   211     2 fd,						/* GROUP II  FAULT DATA */
 14   212       3 isn bit (1),				/* illegal segment number */
 14   213       3 ioc bit (1),				/* illegal op  code  */
 14   214       3 ia_am bit (1),				/* illegal address - modifier */
 14   215       3 isp bit (1),				/* illegal slave  procedure */
 14   216       3 ipr bit (1),				/* illegal procedure */
 14   217       3 nea bit (1),				/* non existent address */
 14   218       3 oobb bit (1),				/* out of bounds */
 14   219       3 pad bit (29),
 14   220 
 14   221     2 pad2 bit (36),
 14   222 
 14   223     2 pad3a bit (18),
 14   224 
 14   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
 14   226       3 prn bit (3),				/* PR  number */
 14   227       3 prv bit (1),				/* PR  valid bit */
 14   228 
 14   229     2 pad3b bit (6)) unaligned,
 14   230 
 14   231     2 pad45 (0:1) bit (36),
 14   232 
 14   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
 14   234 
 14   235 
 14   236 
 14   237 /*  END INCLUDE FILE   mc.incl.pl1 */
     1627 
     1628  /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
 15     2 
 15     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
 15     4 
 15     5 /* This include file contains branch and link structures returned by
 15     6*   hcs_$status_ and hcs_$status_long. */
 15     7 
 15     8 dcl 1 status_branch aligned based (status_ptr),
 15     9     2 short aligned,
 15    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
 15    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
 15    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
 15    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
 15    14       3 dtu bit (36) unaligned,			/* date/time last used */
 15    15       3 mode bit (5) unaligned,			/* caller's effective access */
 15    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
 15    17       3 pad1 bit (8) unaligned,
 15    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
 15    19 
 15    20 /* Limit of information returned by hcs_$status_ */
 15    21 
 15    22     2 long aligned,
 15    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
 15    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
 15    25       3 lvid bit (36) unaligned,			/* logical volume ID */
 15    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
 15    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
 15    28       3 pad2 bit (8) unaligned,
 15    29       3 copy_switch bit (1) unaligned,			/* copy switch */
 15    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
 15    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
 15    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
 15    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
 15    34       3 pad3 bit (5) unaligned,
 15    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
 15    36       3 uid bit (36) unaligned;			/* unique ID */
 15    37 
 15    38 dcl 1 status_link aligned based (status_ptr),
 15    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
 15    40     2 nnames fixed bin (16) unaligned unsigned,
 15    41     2 names_relp bit (18) unaligned,
 15    42     2 dtem bit (36) unaligned,
 15    43     2 dtd bit (36) unaligned,
 15    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
 15    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
 15    46 
 15    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
 15    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
 15    49 						/* array of names returned */
 15    50      status_pathname character (status_link.pathname_length) aligned
 15    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
 15    52 						/* link target path */
 15    53      status_area_ptr pointer,
 15    54      status_ptr pointer;
 15    55 
 15    56 dcl (Link initial (0),
 15    57      Segment initial (1),
 15    58      Directory initial (2)) fixed bin internal static options (constant);
 15    59 						/* values for type fields declared above */
 15    60 
 15    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
     1628 
     1629 
     1630 
     1631 /* BEGIN MESSAGE DOCUMENTATION
     1632*
     1633*
     1634*   Message:
     1635*   mseg_$OPERATION: Beginning salvage of PATH for USER_ID.  REASON
     1636*
     1637*   S:	$log
     1638*
     1639*   T:	$run
     1640*
     1641*   M:	The message segment primitives operation OPERATION detected an
     1642*	internal inconsistency in the message segment or mailbox PATH and
     1643*	has requested that the segment be salvaged.  REASON provides an
     1644*	explanation of why the operation invoked the salvager.
     1645*
     1646*   A:	$ignore
     1647*
     1648*
     1649*   Message:
     1650*   mseg_$OPERATION: Completed salvage of PATH for USER_ID.
     1651*	N {out of M possible} messages recovered.
     1652*
     1653*   S:	$log
     1654*
     1655*   T:	$run
     1656*
     1657*   M:	The salvage of the message segment or mailbox PATH requested by the
     1658*	message segment primitives operation OPERATION has been completed.
     1659*	Of the M messages which might have been in the segment, only N could
     1660*	be recovered; the others have been deleted.  If all possible
     1661*	messages were recovered, the "out of M possible" phrase is omitted
     1662*	from the message.
     1663*
     1664*   A:	$inform_sa
     1665*	The administrator may wish to notify the owner of the segment that
     1666*	some of his messages have been lost.
     1667*
     1668*
     1669*   Message:
     1670*   mseg_$OPERATION: Unable to salvage PTR (pathname unknown) for USER_ID.
     1671*	Call to hcs_$get_access_info_seg failed.  REASON
     1672*
     1673*   S:	$log
     1674*
     1675*   T:	$run
     1676*
     1677*   M:	$err
     1678*	OPERATION identifies the message segment primitives operation which
     1679*	provoked the attempted salvage.  PTR is USER_ID's pointer to the
     1680*	message segment or mailbox which could not be salvaged.  REASON
     1681*	provides additional information about the failure of the call to
     1682*	hcs_$get_access_info_seg.
     1683*
     1684*   A:	$inform
     1685*
     1686*
     1687*   Message:
     1688*   mseg_$OPERATION: Unable to salvage PATH for USER_ID.  Rebuilding the
     1689*	contents of the message segment -- Record quota overflow.
     1690*
     1691*   S:	$log
     1692*
     1693*   T:	$run
     1694*
     1695*   M:	The salvage of the message segment or mailbox PATH requested by the
     1696*	message segment primitives operation OPERATION failed due to a lack
     1697*	of quota.  The segment in question will remain inaccessible until
     1698*	the salvage can be successfully completed.
     1699*
     1700*   A:	$inform_sa
     1701*	In order to make the message segment or mailbox accessible again,
     1702*	the administrator must increase the quota available to the segment
     1703*	to any value greater than the current length of the segment.  The
     1704*	administrator should then attempt to use the segment to allow the
     1705*	salvager to be run to completion.
     1706*
     1707*
     1708*   Message:
     1709*   mseg_$OPERATION: Unable to salvage PATH for USER_ID.  REASON
     1710*
     1711*   S:	$log
     1712*
     1713*   T:	$run
     1714*
     1715*   M:	$err
     1716*	OPERATION identifies the message segment primitives operation which
     1717*	provoked the attempted salvage.  PATH is the pathname of the message
     1718*	segment or mailbox which could not be salvaged.  REASON provides
     1719*	additional information about the failure of the attempted salvage.
     1720*
     1721*   A:	$inform
     1722*
     1723*
     1724*   Message:
     1725*   mseg_$OPERATION: Upgraded PATH from version N to version 5 for USER_ID.
     1726*	M messages were deleted.
     1727*
     1728*   S:	$log
     1729*
     1730*   T:	$run
     1731*
     1732*   M:	The format of the message segment or mailbox PATH was upgraded from
     1733*	the old format known as "version N" to the latest format.  However,
     1734*	M messages in the segment could not be upgraded to the current
     1735*	format because there was no room for them in the segment.  As a
     1736*	consequence, these messages were deleted.  OPERATION identifies the
     1737*	message segment primitives operation which required that the segment
     1738*	be upgraded.
     1739*
     1740*   A:	$inform_sa
     1741*	The administrator may wish to notify the owner of the segment that
     1742*	some of his messages have been lost.
     1743*
     1744*
     1745*   Message:
     1746*   mseg_$OPERATION: Unable to upgrade PTR (pathname unknown) from version N
     1747*	to version 5 for USER_ID.  Call to hcs_$get_access_info_seg failed.
     1748*	REASON
     1749*
     1750*   S:	$log
     1751*
     1752*   T:	$run
     1753*
     1754*   M:	$err
     1755*	OPERATION identifies the message segment primitives operation which
     1756*	required that the segment be upgraded.  PTR is USER_ID's pointer to
     1757*	the message segment or mailbox which could not be upgraded.  REASON
     1758*	provides additional information about the failure of the call to
     1759*	hcs_$get_access_info_seg.
     1760*
     1761*   A:	$inform
     1762*
     1763*
     1764*   Message:
     1765*   mseg_$OPERATION: Unable to upgrade PATH from version N to version 5 for
     1766*	USER_ID.  REASON
     1767*
     1768*   S:	$log
     1769*
     1770*   T:	$run
     1771*
     1772*   M:	$err
     1773*	OPERATION identifies the message segment primitives operation which
     1774*	required that the segment be upgraded.  PATH is the pathname of the
     1775*	message segment or mailbox which could not be upgraded.  REASON
     1776*	provides additional information about the failure of the attempted
     1777*	upgrade.
     1778*
     1779*   A:	$inform
     1780*
     1781*
     1782*   END MESSAGE DOCUMENTATION */
     1783 
     1784 /* format: on */
     1785 
     1786      end mseg_utils_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/22/85  0649.2  mseg_utils_.pl1                   >spec>online>pbf-05/22/85>mseg_utils_.pl1
1609         1    05/17/85  0615.6  mseg_message.incl.pl1             >ldd>include>mseg_message.incl.pl1
1615         2    05/17/85  0619.0  mseg_data_.incl.pl1               >ldd>include>mseg_data_.incl.pl1
1616         3    05/17/85  0615.7  mseg_segment.incl.pl1             >ldd>include>mseg_segment.incl.pl1
1617         4    05/17/85  0615.7  mseg_wakeup_state.incl.pl1        >ldd>include>mseg_wakeup_state.incl.pl1
1618         5    05/17/85  0615.6  mseg_operation.incl.pl1           >ldd>include>mseg_operation.incl.pl1
1619         6    05/17/85  0615.6  mseg_operation_data.incl.pl1      >ldd>include>mseg_operation_data.incl.pl1
1620         7    05/17/85  0615.7  mseg_operations_.incl.pl1         >ldd>include>mseg_operations_.incl.pl1
1621         8    01/10/85  2002.8  mseg_message_info.incl.pl1        >ldd>include>mseg_message_info.incl.pl1
1622         9    05/17/85  0615.5  entry_access_info.incl.pl1        >ldd>include>entry_access_info.incl.pl1
1623        10    05/17/85  0615.6  mseg_format_errors_.incl.pl1      >ldd>include>mseg_format_errors_.incl.pl1
1624        11    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
1625        12    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
1626        13    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
1627        14    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
1628        15    11/22/82  0955.7  status_structures.incl.pl1        >ldd>include>status_structures.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000321 constant        bit(36)                  initial dcl 11-7 set ref 186* 195* 198* 221* 250*
                                                                                  257* 260* 263* 271* 274* 280* 283* 289* 292*
ACTION_DEFAULT_RESTART          000000 constant        bit(36)                  initial dcl 11-7 set ref 665* 684* 709* 1053* 1105*
CALL_GET_ACCESS_INFO            000354 constant        fixed bin(17,0)          initial dcl 86 set ref 602* 841*
CALL_GET_MAX_LENGTH             000344 constant        fixed bin(17,0)          initial dcl 86 set ref 610* 849*
CALL_STATUS_LONG                000337 constant        fixed bin(17,0)          initial dcl 86 set ref 614* 619*
COMPUTING_BLOCK_SIZE            000353 constant        fixed bin(17,0)          initial dcl 86 set ref 1220*
CREATING_UPGRADED_TEMPORARY     000345 constant        fixed bin(17,0)          initial dcl 86 set ref 917* 996* 1009*
ENTRY_ACCESS_INFO_VERSION_1     000002 constant        char(8)                  initial unaligned dcl 9-9 ref 263 597 835
FINDING_SUPPORT_PROCEDURE       000351 constant        fixed bin(17,0)          initial dcl 86 set ref 880* 885* 889*
MESSAGE_DESCRIPTOR_SENTINEL     011466 constant        bit(36)                  initial dcl 1-63 ref 1469
MSEG_MESSAGE_INFO_V1            000004 constant        char(8)                  initial dcl 8-28 ref 274 979
MSEG_OPERATION_VERSION_1               constant        fixed bin(17,0)          initial dcl 5-20 ref 198
MSEG_READ_AFTER_SPECIFIED              constant        fixed bin(17,0)          initial dcl 8-30 ref 1005
MSEG_READ_FIRST                        constant        fixed bin(17,0)          initial dcl 8-30 ref 985
MSEG_SEGMENT_SENTINEL           000010 constant        bit(36)                  initial dcl 3-73 ref 349 390 944 1445
MSEG_SEGMENT_VERSION_5          000350 constant        fixed bin(17,0)          initial dcl 3-70 set ref 350 384 384 945 1045* 1053*
                                                                                  1098* 1105* 1446
MSEG_UTILS_                     000263 constant        char(32)                 initial unaligned dcl 70 set ref 186*
MSEG_WAKEUP_STATE_VERSION_1     000006 constant        char(8)                  initial unaligned dcl 4-41 ref 283 292 1392 1399
                                                                                  1409
PREPARING_UPGRADED_TEMPORARY    000347 constant        fixed bin(17,0)          initial dcl 86 set ref 926* 936*
P_code                                 parameter       fixed bin(35,0)          dcl 25 set ref 181 429* 567 659* 659 665* 665
P_mseg_dir_name                        parameter       char                     unaligned dcl 30 set ref 181 424*
P_mseg_entryname                       parameter       char                     unaligned dcl 31 set ref 181 425*
P_mseg_operation_ptr                   parameter       pointer                  dcl 22 ref 181 193 471 474 507 510 544 547 567 570
P_mseg_ptr                             parameter       pointer                  dcl 32 set ref 181 426*
P_operation_id                         parameter       bit(36)                  dcl 28 set ref 181 185 186* 202
P_operation_name                       parameter       char                     unaligned dcl 29 set ref 181 422*
P_rqo_detected                         parameter       bit(1)                   dcl 33 set ref 181 427*
REBUILDING_SEGMENT              000360 constant        fixed bin(17,0)          initial dcl 86 set ref 1180*
SALVAGER_AND_UPGRADING_ACTIONS  000011 constant        varying char(64)         initial array dcl 74 set ref 703* 709* 1098* 1105*
SALVAGING_ORIGINAL_SEGMENT      000350 constant        fixed bin(17,0)          initial dcl 86 set ref 900*
SYSERR_LOG_OR_DISCARD                  constant        fixed bin(17,0)          initial dcl 12-7 ref 659 677 703 1045 1098
SYSERR_RING1_ERROR                     constant        fixed bin(17,0)          initial dcl 12-7 ref 659 677 703 1045 1098
Segment                                constant        fixed bin(17,0)          initial dcl 15-56 ref 616
access_class              6     000662 automatic       bit(72)                  level 2 in structure "local_wakeup_state" dcl 1139
                                                                                  in procedure "salvage_seg" set ref 1402* 1419*
access_class            213            based           bit(72)                  level 3 in structure "mseg_operation" dcl 5-24
                                                                                  in procedure "mseg_utils_" set ref 1192
access_info             115            based           structure                level 2 in structure "mseg_operation" dcl 5-24
                                                                                  in procedure "mseg_utils_" set ref 598 598
access_info             115     000106 automatic       structure                level 2 in structure "original_operation" dcl 781
                                                                                  in procedure "upgrade_seg" set ref 836 836
access_info               0(12)        based           bit(1)                   level 3 in structure "mseg_operation_data" packed
                                                                                  unaligned dcl 6-9 in procedure "mseg_utils_" ref
                                                                                  263
access_info_valid        24(03) 000106 automatic       bit(1)                   level 3 in structure "original_operation" packed
                                                                                  unaligned dcl 781 in procedure "upgrade_seg" set
                                                                                  ref 828 843*
access_info_valid        24(03) 000372 automatic       bit(1)                   level 3 in structure "upgraded_operation" packed
                                                                                  unaligned dcl 783 in procedure "upgrade_seg" set
                                                                                  ref 921*
access_info_valid        24(03)        based           bit(1)                   level 3 in structure "mseg_operation" packed
                                                                                  unaligned dcl 5-24 in procedure "mseg_utils_" set
                                                                                  ref 224 238 263 590 604*
actual_ms_len                   000161 automatic       fixed bin(24,0)          dcl 1519 set ref 1526* 1576* 1576 1577 1584
add_message_info_all_valid
                         24(10) 000372 automatic       bit(1)                   level 3 packed unaligned dcl 783 set ref 975*
addr                                                   builtin function         dcl 158 ref 185 203 475 522 548 571 598 598 613 613
                                                                                  733 733 836 836 895 895 932 932 958 958 986 986
                                                                                  993 993 1006 1006 1241 1244 1356 1360 1360 1360
                                                                                  1360 1371 1398 1467
admin_gate_$guaranteed_eligibility_off
                                000050 constant        entry                    external dcl 108 ref 493 535
admin_gate_$guaranteed_eligibility_on
                                000052 constant        entry                    external dcl 110 ref 300
admin_gate_$syserr_error_code   000054 constant        entry                    external dcl 112 ref 659 677 703 1045 1098
aim_check_$greater_or_equal     000056 constant        entry                    external dcl 114 ref 1486
aim_check_$in_range             000060 constant        entry                    external dcl 116 ref 1419 1483
aim_util_$get_privileges        000062 constant        entry                    external dcl 117 ref 1486
already_salvaged          0(28)        based           bit(1)                   level 3 packed unaligned dcl 6-9 set ref 211* 527
                                                                                  573 576* 740 810* 1029* 1059*
begin_flags               0(18)        based           structure                level 2 packed unaligned dcl 6-9
block_id                        001012 automatic       fixed bin(18,0)          dcl 1163 set ref 1290* 1292 1292 1294* 1299*
block_map               520            based           structure                level 2 dcl 3-28
block_offset                    000162 automatic       fixed bin(18,0)          unsigned dcl 1520 set ref 1522* 1528 1530 1533 1542
                                                                                  1550 1552 1580*
block_offsets                   000100 automatic       fixed bin(18,0)          array unsigned dcl 1275 set ref 1304 1308 1542 1550*
block_size               15            based           fixed bin(17,0)          level 2 in structure "upgraded_mseg_segment_header"
                                                                                  dcl 768 in procedure "upgrade_seg" set ref 947*
                                                                                  1021
block_size               15            based           fixed bin(17,0)          level 3 in structure "mseg_segment" dcl 3-28
                                                                                  in procedure "mseg_utils_" set ref 357* 358 360
                                                                                  360 1202 1242* 1247 1248 1371 1436* 1467
block_size_unknown              001002 automatic       bit(1)                   dcl 1161 set ref 1200* 1202 1215*
call_admin_gate          24(08)        based           bit(1)                   level 3 in structure "mseg_operation" packed
                                                                                  unaligned dcl 5-24 in procedure "mseg_utils_" ref
                                                                                  300 493 535 655 677 703
call_admin_gate          24(08) 000106 automatic       bit(1)                   level 3 in structure "original_operation" packed
                                                                                  unaligned dcl 781 in procedure "upgrade_seg" set
                                                                                  ref 1045 1098
caller                    4     000106 automatic       structure                level 2 in structure "original_operation" dcl 781
                                                                                  in procedure "upgrade_seg"
caller                    4            based           structure                level 2 in structure "mseg_operation" dcl 5-24
                                                                                  in procedure "mseg_utils_"
callers_report_text_lth         000224 automatic       fixed bin(21,0)          dcl 61 set ref 649* 652
check_count_consistency
                          0(22)        based           bit(1)                   level 3 packed unaligned dcl 6-9 ref 406
check_header_consistency
                          0(20)        based           bit(1)                   level 3 packed unaligned dcl 6-9 ref 343
cleanup                         000000 stack reference condition                dcl 162 ref 816
clock                                                  builtin function         dcl 158 ref 1448
code                            000203 automatic       fixed bin(35,0)          dcl 45 set ref 209* 316* 318* 323* 327 330 330* 334*
                                                                                  352* 353 353* 429 442* 598* 599 609* 610 613* 614
                                                                                  614 618* 673* 703* 703 709* 709 728* 735* 740 744*
                                                                                  818* 836* 837 848* 849 865* 879* 880 883* 885 888*
                                                                                  889 899* 916* 925* 926 932* 934* 936 986* 988 993*
                                                                                  994 994 996 1006* 1009 1014* 1098* 1098 1105* 1105
                                                                                  1111* 1179*
codeptr                                                builtin function         dcl 158 ref 879 879 883 883 888 888
condition_info                         based           structure                level 1 dcl 13-14
condition_info_version_1               constant        fixed bin(17,0)          initial dcl 13-30 ref 731
control_flags           223     000106 automatic       structure                level 3 packed unaligned dcl 781 set ref 980*
convert                                                builtin function         dcl 158 ref 877
copy                                                   builtin function         dcl 158 ref 372 951 1277 1278
cu_$arg_count                   000064 constant        entry                    external dcl 119 ref 628
cu_$arg_list_ptr                000066 constant        entry                    external dcl 120 ref 629
current_length            7     000204 automatic       fixed bin(12,0)          level 3 packed unsigned unaligned dcl 53 set ref 621
currentsize                                            builtin function         dcl 158 ref 360 858 1204 1204 1210 1247 1247 1248
                                                                                  1371 1371 1467 1467
data_lth                  0(19)        based           fixed bin(17,0)          level 3 in structure "other_message_block" packed
                                                                                  unsigned unaligned dcl 1-82 in procedure
                                                                                  "salvage_seg" ref 1248 1248
data_lth                  0(19)        based           fixed bin(17,0)          level 2 in structure "message_block_header" packed
                                                                                  unsigned unaligned dcl 1-24 in procedure
                                                                                  "salvage_seg" set ref 1245* 1554 1559 1561 1569
                                                                                  1571 1576
data_lth                  0(19)        based           fixed bin(17,0)          level 3 in structure "first_message_block" packed
                                                                                  unsigned unaligned dcl 1-69 in procedure
                                                                                  "salvage_seg" ref 1247 1247 1371 1371 1467 1467
data_space                1            based           structure                level 2 in structure "first_message_block" dcl 1-69
                                                                                  in procedure "salvage_seg"
data_space                1            based           structure                level 2 in structure "other_message_block" dcl 1-82
                                                                                  in procedure "salvage_seg"
date_time_last_salvaged
                          4            based           fixed bin(71,0)          level 2 in structure "upgraded_mseg_segment_header"
                                                                                  dcl 768 in procedure "upgrade_seg" set ref 939*
date_time_last_salvaged
                          4            based           fixed bin(71,0)          level 3 in structure "mseg_segment" dcl 3-28
                                                                                  in procedure "mseg_utils_" set ref 1448*
descriptor                             based           structure                level 2 dcl 1-69 set ref 1371 1467
descriptor_present        0(18)        based           bit(1)                   level 2 in structure "message_block_header" packed
                                                                                  unaligned dcl 1-24 in procedure "salvage_seg" ref
                                                                                  1567
descriptor_present        0(18)        based           bit(1)                   level 3 in structure "first_message_block" packed
                                                                                  unaligned dcl 1-69 in procedure "salvage_seg" ref
                                                                                  1464
dir_name                120            based           char(168)                level 3 in structure "mseg_operation" packed
                                                                                  unaligned dcl 5-24 in procedure "mseg_utils_" set
                                                                                  ref 226 242 592 605
dir_name                 25            based           char(168)                level 2 in structure "mseg_operation" packed
                                                                                  unaligned dcl 5-24 in procedure "mseg_utils_" ref
                                                                                  231 247
dir_name                120     000106 automatic       char(168)                level 3 in structure "original_operation" packed
                                                                                  unaligned dcl 781 in procedure "upgrade_seg" set
                                                                                  ref 830 844
divide                                                 builtin function         dcl 158 ref 358 360 360 856 858 858 1208 1210 1210
                                                                                  1223 1231 1308 1533
dont_check_lock_results
                          0(19)        based           bit(1)                   level 3 packed unaligned dcl 6-9 ref 323 740
entry_access_info                      based           structure                level 1 dcl 9-12
entryname                77            based           char(32)                 level 2 in structure "mseg_operation" packed
                                                                                  unaligned dcl 5-24 in procedure "mseg_utils_" ref
                                                                                  232 248
entryname               172            based           char(32)                 level 3 in structure "mseg_operation" packed
                                                                                  unaligned dcl 5-24 in procedure "mseg_utils_" set
                                                                                  ref 227 243 593 606
entryname               172     000106 automatic       char(32)                 level 3 in structure "original_operation" packed
                                                                                  unaligned dcl 781 in procedure "upgrade_seg" set
                                                                                  ref 831 845
errcode                  43            based           fixed bin(35,0)          level 2 packed unaligned dcl 14-12 ref 735 735
error_table_$bad_segment        000010 external static fixed bin(35,0)          dcl 97 set ref 458*
error_table_$bad_subr_arg       000012 external static fixed bin(35,0)          dcl 97 set ref 186* 221* 250* 257* 260* 271* 280*
                                                                                  289*
error_table_$bigarg             000014 external static fixed bin(35,0)          dcl 97 ref 994
error_table_$improper_data_format
                                000016 external static fixed bin(35,0)          dcl 97 ref 1111
error_table_$invalid_max_length 000020 external static fixed bin(35,0)          dcl 97 set ref 366* 865
error_table_$lock_wait_time_exceeded
                                000022 external static fixed bin(35,0)          dcl 97 ref 330
error_table_$no_message         000024 external static fixed bin(35,0)          dcl 97 ref 1009
error_table_$no_s_permission    000026 external static fixed bin(35,0)          dcl 97 ref 614
error_table_$not_seg_type       000030 external static fixed bin(35,0)          dcl 97 ref 618
error_table_$notalloc           000032 external static fixed bin(35,0)          dcl 97 ref 994
error_table_$null_info_ptr      000034 external static fixed bin(35,0)          dcl 97 set ref 195*
error_table_$rqover             000036 external static fixed bin(35,0)          dcl 97 set ref 916 934 1030* 1179
error_table_$seg_busted         000040 external static fixed bin(35,0)          dcl 97 ref 740
error_table_$segfault           000042 external static fixed bin(35,0)          dcl 97 ref 728
error_table_$unimplemented_version
                                000044 external static fixed bin(35,0)          dcl 97 set ref 198* 263* 274* 283* 292*
event_channel             4     000662 automatic       fixed bin(71,0)          level 2 in structure "local_wakeup_state" dcl 1139
                                                                                  in procedure "salvage_seg" set ref 1401*
event_channel             2     000674 automatic       fixed bin(71,0)          level 3 in structure "old_wakeup_state" dcl 1141
                                                                                  in procedure "salvage_seg" set ref 1401
find_condition_info_            000070 constant        entry                    external dcl 121 ref 733
finish_flags              0(27)        based           structure                level 2 packed unaligned dcl 6-9
first_block                     000160 automatic       bit(1)                   dcl 1518 set ref 1524* 1557 1581*
first_message            10            based           fixed bin(18,0)          level 4 packed unsigned unaligned dcl 3-28 set ref
                                                                                  406 415 1376 1376*
first_message_block                    based           structure                level 1 dcl 1-69
fixed                                                  builtin function         dcl 158 ref 1382
flags                    24     000372 automatic       structure                level 2 in structure "upgraded_operation" dcl 783
                                                                                  in procedure "upgrade_seg"
flags                     2     000662 automatic       structure                level 2 in structure "local_wakeup_state" dcl 1139
                                                                                  in procedure "salvage_seg" set ref 1400*
flags                    16            based           structure                level 2 in structure "upgraded_mseg_segment_header"
                                                                                  dcl 768 in procedure "upgrade_seg" set ref 941*
flags                    24     000106 automatic       structure                level 2 in structure "original_operation" dcl 781
                                                                                  in procedure "upgrade_seg"
flags                    16            based           structure                level 3 in structure "mseg_segment" dcl 3-28
                                                                                  in procedure "mseg_utils_"
flags                    24            based           structure                level 2 in structure "mseg_operation" dcl 5-24
                                                                                  in procedure "mseg_utils_"
get_group_id_                   000072 constant        entry                    external dcl 123 ref 170
get_lock_id_                    000074 constant        entry                    external dcl 124 ref 171
get_old_wakeup_state            000672 automatic       entry variable           dcl 789 set ref 883* 958
get_process_max_authorization_  000076 constant        entry                    external dcl 125 ref 172
get_ring_                       000100 constant        entry                    external dcl 127 ref 174
get_system_free_area_           000102 constant        entry                    external dcl 128 ref 983
get_temp_segment_               000104 constant        entry                    external dcl 130 ref 925
group_id                 14     000106 automatic       char(32)                 level 3 in structure "original_operation" packed
                                                                                  unaligned dcl 781 in procedure "upgrade_seg" set
                                                                                  ref 1045* 1053* 1098* 1105*
group_id                 14            based           char(32)                 level 3 in structure "mseg_operation" packed
                                                                                  unaligned dcl 5-24 in procedure "mseg_utils_" set
                                                                                  ref 639* 677* 684* 703* 709*
hash_idx                        001023 automatic       fixed bin(9,0)           dcl 1169 set ref 1382* 1383 1384
hash_table              120            based           structure                level 3 in structure "mseg_segment" dcl 3-28
                                                                                  in procedure "mseg_utils_" set ref 1364*
hash_table              120            based           structure                level 2 in structure "upgraded_mseg_segment_header"
                                                                                  dcl 768 in procedure "upgrade_seg" set ref 942*
hbound                                                 builtin function         dcl 158 ref 186 580
hcs_$fs_get_path_name           000106 constant        entry                    external dcl 131 ref 601 839
hcs_$get_access_info_seg        000110 constant        entry                    external dcl 133 ref 598 836
hcs_$get_max_length_seg         000112 constant        entry                    external dcl 135 ref 352 609 848
hcs_$make_entry                 000114 constant        entry                    external dcl 137 ref 879 883 888
hcs_$set_damaged_sw_seg         000116 constant        entry                    external dcl 138 ref 743
hcs_$status_long                000120 constant        entry                    external dcl 140 ref 613
hcs_$truncate_seg               000122 constant        entry                    external dcl 141 ref 482 1025 1323
header                                 based           structure                level 2 in structure "first_message_block" dcl 1-69
                                                                                  in procedure "salvage_seg"
header                                 based           structure                level 2 in structure "mseg_segment" dcl 3-28
                                                                                  in procedure "mseg_utils_"
header                                 based           structure                level 2 in structure "other_message_block" dcl 1-82
                                                                                  in procedure "salvage_seg"
header_msg                             based           bit(36)                  array dcl 3-84 ref 1398
header_msg_access_class                defined         bit(72)                  dcl 3-79 ref 1402
indeces                   1     000100 automatic       fixed bin(18,0)          array level 2 dcl 1268 set ref 1357* 1370
index                                                  builtin function         dcl 158 ref 1332
initialize_header         0(21)        based           bit(1)                   level 3 packed unaligned dcl 6-9 ref 343
ioa_$general_rs                 000124 constant        entry                    external dcl 142 ref 649
ioa_$rsnpnnl                    000126 constant        entry                    external dcl 144 ref 639
last_block_checked              001016 automatic       fixed bin(18,0)          dcl 1163 set ref 1325* 1327 1330 1332 1335* 1339*
                                                                                  1339 1343 1343
last_message            120            based           fixed bin(18,0)          array level 4 in structure "mseg_segment" packed
                                                                                  unsigned unaligned dcl 3-28 in procedure
                                                                                  "mseg_utils_" set ref 1383 1384*
last_message             11            based           fixed bin(18,0)          level 4 in structure "mseg_segment" packed unsigned
                                                                                  unaligned dcl 3-28 in procedure "mseg_utils_" set
                                                                                  ref 406 415 1373 1380*
last_recovered_block            001011 automatic       fixed bin(18,0)          dcl 1163 set ref 1280* 1313* 1313 1323 1327 1330
                                                                                  1335
last_used_block                 001006 automatic       fixed bin(18,0)          dcl 1163 set ref 1231* 1290
lbound                                                 builtin function         dcl 158 ref 186 580
length                                                 builtin function         dcl 158 ref 626 626 646 1247 1248 1360 1360
local_ci                        000106 automatic       structure                level 1 dcl 725 set ref 730* 733 733
local_code                      000140 automatic       fixed bin(35,0)          dcl 726 set ref 733* 735
local_message_block             000622 automatic       structure                level 1 dcl 1133 set ref 1244
local_mseg_segment_header       000102 automatic       structure                level 1 dcl 1131 set ref 1241
local_wakeup_state              000662 automatic       structure                level 1 dcl 1139 set ref 1392* 1424
lock                                   based           bit(36)                  level 3 dcl 3-28 set ref 316 318* 488 488* 530 530*
                                                                                  557 745 745* 1186*
lock_id                   1     000674 automatic       bit(36)                  level 3 in structure "old_wakeup_state" dcl 1141
                                                                                  in procedure "salvage_seg" set ref 1404
lock_id                  11     000662 automatic       bit(36)                  level 2 in structure "local_wakeup_state" dcl 1139
                                                                                  in procedure "salvage_seg" set ref 1404* 1416
lock_segment              0(18)        based           bit(1)                   level 3 packed unaligned dcl 6-9 ref 306
long                      4     000204 automatic       structure                level 2 dcl 53
long_status                     000204 automatic       structure                level 1 dcl 53 set ref 613 613
map                             000100 automatic       bit                      level 2 in structure "new_block_map" packed
                                                                                  unaligned dcl 1258 in begin block on line 1255 set
                                                                                  ref 1277* 1311* 1332 1332 1440 1459 1538
map                             000100 automatic       bit                      level 2 in structure "nonzero_block_map" packed
                                                                                  unaligned dcl 1261 in begin block on line 1255 set
                                                                                  ref 1278* 1292* 1343 1343
map                     520            based           bit                      level 3 in structure "mseg_segment" packed unaligned
                                                                                  dcl 3-28 in procedure "mseg_utils_" set ref 372*
                                                                                  951* 1440*
max                                                    builtin function         dcl 158 ref 1313 1431
max_bits_in_first_block         001021 automatic       fixed bin(17,0)          dcl 1167 set ref 1247* 1559 1561
max_bits_in_other_blocks        001022 automatic       fixed bin(17,0)          dcl 1167 set ref 1248* 1569 1571
max_blocks_per_message          001007 automatic       fixed bin(18,0)          dcl 1163 set ref 1223* 1275 1546
mb_ptr                          001024 automatic       pointer                  dcl 1-32 set ref 1204 1244* 1245 1247 1247 1247 1248
                                                                                  1248 1248 1370* 1371 1371 1371 1376 1378 1380 1384
                                                                                  1462* 1464 1467 1467 1467 1552* 1554 1559 1561
                                                                                  1561 1567 1569 1571 1571 1576 1580
mc                                     based           structure                level 1 dcl 14-12
mc_ptr                          000106 automatic       pointer                  level 2 dcl 725 set ref 735 735 735
md_ptr                          001026 automatic       pointer                  dcl 1-61 set ref 1204 1247 1305 1371* 1371 1373 1374
                                                                                  1382 1383 1386 1467* 1467 1469 1472 1476 1480 1480
                                                                                  1483 1486 1486 1486 1577 1584
message_block_header                   based           structure                level 1 dcl 1-24 set ref 1204 1247 1248 1371 1467
message_block_id                001015 automatic       fixed bin(18,0)          dcl 1163 set ref 1308* 1311 1313 1533* 1535 1535
                                                                                  1538
message_block_idx               001014 automatic       fixed bin(18,0)          dcl 1163 set ref 1307* 1308* 1541* 1542*
message_chain            10            based           structure                level 2 in structure "upgraded_mseg_segment_header"
                                                                                  dcl 768 in procedure "upgrade_seg" set ref 940*
message_chain             1            based           structure                level 2 in structure "message_descriptor" dcl 1-37
                                                                                  in procedure "salvage_seg"
message_chain            10            based           structure                level 3 in structure "mseg_segment" dcl 3-28
                                                                                  in procedure "mseg_utils_" set ref 1363*
message_code            222     000106 automatic       fixed bin(17,0)          level 3 dcl 781 set ref 985* 1005*
message_descriptor                     based           structure                level 1 dcl 1-37 set ref 1204 1247 1371 1467
message_id_ptrs                 000100 automatic       structure                level 1 dcl 1264 set ref 1360 1360
message_ids                     000100 automatic       bit(72)                  array dcl 1274 set ref 1305* 1356 1360 1360 1476
message_index                   001020 automatic       fixed bin(18,0)          dcl 1163 set ref 1355* 1356 1356 1357 1357* 1368*
                                                                                  1370* 1475* 1476*
message_info              0(14)        based           bit(1)                   level 3 in structure "mseg_operation_data" packed
                                                                                  unaligned dcl 6-9 in procedure "mseg_utils_" ref
                                                                                  274
message_info            220     000372 automatic       structure                level 2 in structure "upgraded_operation" dcl 783
                                                                                  in procedure "upgrade_seg" set ref 990*
message_info            220            based           structure                level 2 in structure "mseg_operation" dcl 5-24
                                                                                  in procedure "mseg_utils_"
message_info            220     000106 automatic       structure                level 2 in structure "original_operation" dcl 781
                                                                                  in procedure "upgrade_seg" set ref 990
message_info_valid       24(05)        based           bit(1)                   level 3 packed unaligned dcl 5-24 ref 274
message_offsets                 000100 automatic       fixed bin(18,0)          array unsigned dcl 1273 set ref 1304* 1370
mod                                                    builtin function         dcl 158 ref 1530
modification_in_progress
                         16            based           bit(1)                   level 4 packed unaligned dcl 3-28 set ref 393 1442*
ms_access_class          20            based           bit(72)                  level 2 dcl 1-37 set ref 1483* 1486*
ms_id                   227     000372 automatic       bit(72)                  level 3 in structure "upgraded_operation" dcl 783
                                                                                  in procedure "upgrade_seg" set ref 991*
ms_id                     3            based           bit(72)                  level 2 in structure "message_descriptor" dcl 1-37
                                                                                  in procedure "salvage_seg" ref 1305 1382 1472 1476
ms_len                  226     000106 automatic       fixed bin(24,0)          level 3 in structure "original_operation" dcl 781
                                                                                  in procedure "upgrade_seg" set ref 1001 1001 1073
                                                                                  1073
ms_len                    5            based           fixed bin(24,0)          level 2 in structure "message_descriptor" packed
                                                                                  unsigned unaligned dcl 1-37 in procedure
                                                                                  "salvage_seg" ref 1480 1480 1577 1584
ms_ptr                  224     000106 automatic       pointer                  level 3 dcl 781 set ref 813* 981* 999 1001 1002*
                                                                                  1071 1073 1074*
mseg_cur_length                 000226 automatic       fixed bin(19,0)          dcl 63 set ref 621* 1231
mseg_data_$block_size           000152 external static fixed bin(35,0)          dcl 2-5 ref 357 856 858 858 947 1215 1218
mseg_data_$execution_ring       000156 external static fixed bin(3,0)           dcl 2-9 set ref 174*
mseg_data_$group_id             000162 external static char(32)                 unaligned dcl 2-11 set ref 170*
mseg_data_$lock_id              000150 external static bit(72)                  dcl 2-4 set ref 171* 316 488 530 558 745 1186
mseg_data_$max_message_size     000154 external static fixed bin(35,0)          dcl 2-6 ref 1223 1480
mseg_data_$process_max_authorization
                                000160 external static bit(72)                  dcl 2-10 set ref 172*
mseg_dir_name                   000120 automatic       char(168)                unaligned dcl 40 set ref 205* 226* 231* 242* 247*
                                                                                  424 592* 601* 605* 613* 639* 639* 677* 677* 684*
                                                                                  684* 703* 703* 709* 709*
mseg_entryname                  000172 automatic       char(32)                 unaligned dcl 41 set ref 206* 227* 232* 243* 248*
                                                                                  425 593* 601* 606* 613* 639* 639* 677* 677* 684*
                                                                                  684* 703* 703* 709* 709*
mseg_format_errors_$bad_mseg_sentinel
                                000170 external static fixed bin(35,0)          dcl 10-10 set ref 390*
mseg_format_errors_$bad_mseg_version
                                000172 external static fixed bin(35,0)          dcl 10-10 set ref 388*
mseg_format_errors_$inconsistent_message_count
                                000174 external static fixed bin(35,0)          dcl 10-10 set ref 406* 415*
mseg_format_errors_$modification_in_progress
                                000176 external static fixed bin(35,0)          dcl 10-10 set ref 393*
mseg_format_errors_$negative_message_count
                                000200 external static fixed bin(35,0)          dcl 10-10 set ref 412*
mseg_format_errors_$salvage_in_progress
                                000202 external static fixed bin(35,0)          dcl 10-10 set ref 396*
mseg_max_length                 000225 automatic       fixed bin(19,0)          dcl 63 set ref 352* 358 609* 621 848* 856 1204 1208
mseg_message_$add_message_for_mseg
                                000130 constant        entry                    external dcl 145 ref 993
mseg_message_info                      based           structure                level 1 dcl 8-9
mseg_operation                         based           structure                level 1 dcl 5-24 set ref 825
mseg_operation_data                    based           structure                level 1 dcl 6-9
mseg_operation_data_ptr         000254 automatic       pointer                  dcl 6-44 set ref 185* 186 186 191 203* 211 211 219
                                                                                  219 238 253 263 274 283 292 306 323 327 343 343
                                                                                  406 475* 477 482 491 522* 524 527 533 548* 550 558
                                                                                  571* 573 576 580 580 583 740 740 752 753 810 1029
                                                                                  1059 1187
mseg_operation_ptr              000252 automatic       pointer                  dcl 5-19 set ref 193* 195 198 198 202 203 221 221
                                                                                  224 226 227 229 231 232 234 234 238 242 243 245
                                                                                  247 248 253 253 263 263 263 263 274 274 274 283
                                                                                  283 283 292 292 300 456* 474* 475 480 493 510* 512
                                                                                  515 518 521 522 527* 535 547* 548 553 570* 571 578
                                                                                  590 592 593 597 598 598 604 605 606 639 655 677
                                                                                  677 684 703 703 709 744* 825 1030* 1191 1192 1250
mseg_operations_$copy_seg_target
                                000166 external static bit(36)                  dcl 7-8 set ref 932*
mseg_operations_$names          000164 external static varying char(64)         array dcl 6-50 ref 186 186 191 580 580 583
mseg_pathname_valid      24            based           bit(1)                   level 3 packed unaligned dcl 5-24 ref 221 229 245
mseg_ptr                  0(10)        based           bit(1)                   level 3 in structure "mseg_operation_data" packed
                                                                                  unaligned dcl 6-9 in procedure "mseg_utils_" ref
                                                                                  219 253
mseg_ptr                        000250 automatic       pointer                  dcl 3-68 in procedure "mseg_utils_" set ref 207*
                                                                                  234* 253* 316 318 343 343 349 350 352* 357 358 358
                                                                                  360 360 360 360 366 369 369 372 384 384 384 390
                                                                                  393 396 406 406 406 412 415 415 426 480* 482 482
                                                                                  482 482* 488 488 521* 530 530 553* 557 578* 598*
                                                                                  601* 609* 703* 709* 743* 745 745 1186 1189 1202
                                                                                  1210 1241* 1242 1247 1248 1250* 1292 1323* 1343
                                                                                  1363 1364 1370 1371 1373 1376 1376 1380 1383 1384
                                                                                  1392 1392 1392 1398 1402 1411 1413 1423 1424 1425
                                                                                  1431 1434 1436 1437 1438 1440 1442 1442 1443 1445
                                                                                  1446 1448 1462 1467 1552
mseg_ptr                110            based           pointer                  level 2 in structure "mseg_operation" dcl 5-24
                                                                                  in procedure "mseg_utils_" ref 234 253 480 518 521
                                                                                  553 578 1250
mseg_ptr                110     000372 automatic       pointer                  level 2 in structure "upgraded_operation" dcl 783
                                                                                  in procedure "upgrade_seg" set ref 929*
mseg_ptr                110     000106 automatic       pointer                  level 2 in structure "original_operation" dcl 781
                                                                                  in procedure "upgrade_seg" set ref 826
mseg_ptr_valid           24(01) 000372 automatic       bit(1)                   level 3 in structure "upgraded_operation" packed
                                                                                  unaligned dcl 783 in procedure "upgrade_seg" set
                                                                                  ref 921* 930*
mseg_ptr_valid           24(01)        based           bit(1)                   level 3 in structure "mseg_operation" packed
                                                                                  unaligned dcl 5-24 in procedure "mseg_utils_" ref
                                                                                  221 234 253 515
mseg_segment                           based           structure                level 1 dcl 3-28
mseg_segment_aim_range          000776 automatic       bit(72)                  array dcl 1158 set ref 1191* 1192* 1419* 1483*
mseg_segment_blocks                    based           bit                      array dcl 1154 set ref 1292 1343* 1343
mseg_segment_header                    based           structure                level 1 dcl 50 ref 360 1210
mseg_utils_$salvage_for_cause   000132 constant        entry                    external dcl 147 ref 456 527 744 1030
mseg_wakeup_state                      based           structure                level 1 dcl 4-24
n_arguments                     000232 automatic       fixed bin(17,0)          dcl 67 set ref 628* 639 643
n_blocks_allocated       12            based           fixed bin(18,0)          level 2 in structure "upgraded_mseg_segment_header"
                                                                                  dcl 768 in procedure "upgrade_seg" set ref 948*
                                                                                  1021
n_blocks_allocated       12            based           fixed bin(18,0)          level 3 in structure "mseg_segment" dcl 3-28
                                                                                  in procedure "mseg_utils_" set ref 358* 360 366
                                                                                  369 372 951 1437* 1440
n_blocks_available              001004 automatic       fixed bin(18,0)          dcl 1163 set ref 1208* 1210 1215 1220 1258 1261 1264
                                                                                  1268 1273 1274 1277 1278 1292 1311 1332 1343 1437
                                                                                  1438 1440 1459 1535 1538
n_blocks_recovered              001010 automatic       fixed bin(18,0)          dcl 1163 set ref 1280* 1312* 1312 1438
n_blocks_unused          13            based           fixed bin(18,0)          level 2 in structure "upgraded_mseg_segment_header"
                                                                                  dcl 768 in procedure "upgrade_seg" set ref 949*
                                                                                  1021
n_blocks_unused          13            based           fixed bin(18,0)          level 3 in structure "mseg_segment" dcl 3-28
                                                                                  in procedure "mseg_utils_" set ref 369* 1438*
n_header_blocks                 001005 automatic       fixed bin(18,0)          dcl 1163 in procedure "salvage_seg" set ref 1210*
                                                                                  1215 1220 1277 1278 1280 1290 1325 1535
n_header_blocks                 000227 automatic       fixed bin(18,0)          dcl 65 in procedure "mseg_utils_" set ref 360* 366
                                                                                  369 372
n_indeces                       000100 automatic       fixed bin(18,0)          level 2 dcl 1268 set ref 1353*
n_message_blocks                001013 automatic       fixed bin(18,0)          dcl 1163 set ref 1307 1525* 1541 1546 1549* 1549
                                                                                  1550
n_messages               14            based           fixed bin(18,0)          level 2 in structure "upgraded_mseg_segment_header"
                                                                                  dcl 768 in procedure "upgrade_seg" set ref 939*
n_messages               14            based           fixed bin(18,0)          level 3 in structure "mseg_segment" dcl 3-28
                                                                                  in procedure "mseg_utils_" set ref 406 412 482
                                                                                  1431 1434*
n_messages_discarded            001054 automatic       fixed bin(18,0)          dcl 805 set ref 977* 994* 994 1045 1045* 1045 1053*
                                                                                  1053
n_messages_recovered            000101 automatic       fixed bin(18,0)          dcl 1126 in procedure "salvage_seg" set ref 1288*
                                                                                  1302* 1302 1304 1305 1353 1355 1368 1432 1434 1475
n_messages_recovered            000231 automatic       fixed bin(18,0)          dcl 65 in procedure "mseg_utils_" set ref 675* 677*
                                                                                  677 677 684* 684 684
n_possible_messages             000230 automatic       fixed bin(18,0)          dcl 65 in procedure "mseg_utils_" set ref 675* 677
                                                                                  677* 677 684 684* 684
n_possible_messages             000100 automatic       fixed bin(18,0)          dcl 1126 in procedure "salvage_seg" set ref 1288*
                                                                                  1297* 1297 1431
n_ptrs                          000100 automatic       fixed bin(18,0)          level 2 dcl 1264 set ref 1353*
n_upgraded_blocks_allocated     001052 automatic       fixed bin(18,0)          dcl 805 set ref 856* 858 863 948 949
n_upgraded_header_blocks        001053 automatic       fixed bin(18,0)          dcl 805 set ref 858* 863 949 951
new_block_map                   000100 automatic       structure                level 1 dcl 1258
next_block                             based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 1-24 ref 1561
                                                                                  1571 1580
next_message              1            based           fixed bin(18,0)          level 3 packed unsigned unaligned dcl 1-37 set ref
                                                                                  1374* 1378*
next_unused_block               001017 automatic       fixed bin(18,0)          dcl 1163 set ref 1332* 1335 1339
nonzero_block_map               000100 automatic       structure                level 1 dcl 1261
nonzero_indicator                      defined         bit(1)                   unaligned dcl 1341 ref 1343
null                                                   builtin function         dcl 158 ref 186 186 195 195 195 198 198 207 221 221
                                                                                  250 250 257 257 260 260 263 263 271 271 274 274
                                                                                  280 280 283 283 289 289 292 292 512 518 613 613
                                                                                  665 665 684 684 709 709 733 733 735 813 981 999
                                                                                  1002 1053 1053 1071 1074 1077 1080 1105 1105 1366
old_wakeup_state                000674 automatic       structure                level 1 dcl 1141 set ref 1398*
operation                 3            based           bit(36)                  level 2 dcl 5-24 set ref 202* 203 475 522 548 571
operation_id                           based           fixed bin(9,0)           level 2 packed unsigned unaligned dcl 6-9 ref 186
                                                                                  186 191 580 580 583
operation_name                  000100 automatic       char(64)                 unaligned dcl 38 set ref 191* 195* 198* 221* 250*
                                                                                  257* 260* 263* 271* 274* 280* 283* 289* 292* 422
                                                                                  580* 583* 626 637 665* 677* 684* 703* 709* 925*
                                                                                  993* 1045* 1053* 1079* 1098* 1105*
original_mseg_dir_name          000702 automatic       char(168)                unaligned dcl 793 set ref 830* 839* 844* 1045* 1045*
                                                                                  1053* 1053* 1098* 1098* 1105* 1105*
original_mseg_entryname         001026 automatic       char(32)                 unaligned dcl 795 set ref 831* 839* 845* 1045* 1045*
                                                                                  1053* 1053* 1098* 1098* 1105* 1105*
original_mseg_message_bits             based           bit                      dcl 772 ref 1001 1073
original_mseg_ptr               000100 automatic       pointer                  dcl 766 set ref 826* 836* 839* 848* 875 1025* 1035
                                                                                  1098* 1105*
original_mseg_segment_header           based           structure                level 1 dcl 764
original_operation              000106 automatic       structure                level 1 dcl 781 set ref 825* 895 895 920 958 958 986
                                                                                  986 1006 1006
original_version                001055 automatic       fixed bin(17,0)          dcl 807 set ref 875* 877 1045* 1053* 1098* 1105*
original_version_picture               automatic       picture(1)               unaligned dcl 797 ref 877
other_message_block                    based           structure                level 1 dcl 1-82
p_block_id                             parameter       fixed bin(18,0)          dcl 1516 in procedure "valid_message" ref 1513 1522
p_block_id                             parameter       fixed bin(18,0)          dcl 1457 in procedure "possible_message" ref 1454
                                                                                  1459 1462
p_code                                 parameter       fixed bin(35,0)          dcl 440 ref 437 442
p_failed_action                        parameter       fixed bin(17,0)          dcl 1096 in procedure "abort_upgrade_seg" ref 1092
                                                                                  1098 1098 1105 1105
p_failed_action                        parameter       fixed bin(17,0)          dcl 701 in procedure "abort_salvage_for_cause" ref
                                                                                  697 703 709
p_format_error                         parameter       fixed bin(35,0)          dcl 454 set ref 451 456*
p_have_pathname                        parameter       bit(1)                   dcl 700 in procedure "abort_salvage_for_cause" set
                                                                                  ref 697 703* 709*
p_have_pathname                        parameter       bit(1)                   dcl 1095 in procedure "abort_upgrade_seg" set ref
                                                                                  1092 1098* 1105*
p_n_messages_recovered                 parameter       fixed bin(18,0)          dcl 1124 set ref 1121 1432*
p_n_possible_messages                  parameter       fixed bin(18,0)          dcl 1124 set ref 1121 1431*
pad                      32            based           bit(36)                  array level 4 in structure "mseg_segment" dcl 3-28
                                                                                  in procedure "mseg_utils_" set ref 1425*
pad                                    based           bit                      level 3 in structure "first_message_block" packed
                                                                                  unaligned dcl 1-69 in procedure "salvage_seg" ref
                                                                                  1247
pad                                    based           bit                      level 3 in structure "other_message_block" packed
                                                                                  unaligned dcl 1-82 in procedure "salvage_seg" ref
                                                                                  1248
parent_access_class     215            based           bit(72)                  level 3 dcl 5-24 set ref 1191
path_code                       000222 automatic       fixed bin(35,0)          dcl 60 in procedure "mseg_utils_" set ref 601* 602
path_code                       001050 automatic       fixed bin(35,0)          dcl 803 in procedure "upgrade_seg" set ref 839* 841
pathname                  0(09)        based           bit(1)                   level 3 packed unaligned dcl 6-9 ref 219 238
pathname_                       000134 constant        entry                    external dcl 149 ref 639 639 677 677 684 684 703 703
                                                                                  709 709 1045 1045 1053 1053 1098 1098 1105 1105
prefix                          000100 automatic       char                     level 2 packed unaligned dcl 633 set ref 637*
prefix_lth                      000233 automatic       fixed bin(17,0)          dcl 67 set ref 626* 633 633 637 639 639 639 646 646
                                                                                  649 649 657 665 665
prev_md_ptr                     000774 automatic       pointer                  dcl 1156 set ref 1366* 1378 1386*
prev_message              1(18)        based           fixed bin(18,0)          level 3 packed unsigned unaligned dcl 1-37 set ref
                                                                                  1373*
prev_message_in_hash_chain
                          2(08)        based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 1-37 set ref
                                                                                  1383*
probable_block_size             001003 automatic       fixed bin(18,0)          dcl 1163 set ref 1202* 1204 1204 1208 1210 1210
                                                                                  1215* 1223 1231 1242 1292 1292 1292 1308 1323 1342
                                                                                  1343 1343 1343 1436 1462 1522 1530 1533
process_id                4     000674 automatic       bit(36)                  level 3 in structure "old_wakeup_state" dcl 1141
                                                                                  in procedure "salvage_seg" set ref 1403
process_id               10     000662 automatic       bit(36)                  level 2 in structure "local_wakeup_state" dcl 1139
                                                                                  in procedure "salvage_seg" set ref 1403* 1416
ptrs                      1     000100 automatic       pointer                  array level 2 packed unaligned dcl 1264 set ref
                                                                                  1356*
read_old_message                000676 automatic       entry variable           dcl 791 set ref 888* 986 1006
record_quota_overflow           000234 stack reference condition                dcl 162 ref 310 320 907 1012 1027 1037 1177
release_temp_segment_           000136 constant        entry                    external dcl 150 ref 1079
required_data             0(09)        based           structure                level 2 packed unaligned dcl 6-9
reserved                  2            based           bit(72)                  level 3 dcl 3-28 ref 1402 1402
rest_of_block_map                      defined         bit                      unaligned dcl 1330 ref 1332
rest_of_salvage_report_text            defined         char                     unaligned dcl 646 set ref 649*
rqo_detected                    000202 automatic       bit(1)                   dcl 43 in procedure "mseg_utils_" set ref 208* 312*
                                                                                  427
rqo_detected                    001047 automatic       bit(1)                   dcl 800 in procedure "upgrade_seg" set ref 932* 934
rtrim                                                  builtin function         dcl 158 ref 626 637
salvage_completed               001046 automatic       bit(1)                   dcl 800 set ref 895* 897
salvage_for_cause_arguments     000220 automatic       pointer                  dcl 57 set ref 629* 649*
salvage_in_progress      16(03)        based           bit(1)                   level 4 packed unaligned dcl 3-28 set ref 396 1189*
                                                                                  1442*
salvage_old_segment             000666 automatic       entry variable           dcl 788 set ref 879* 895
salvage_report                  000100 automatic       structure                level 1 packed unaligned dcl 633 set ref 659 659
salvage_report_text                    defined         char                     unaligned dcl 664 in begin block on line 663 set ref
                                                                                  665*
salvage_report_text                    defined         char                     unaligned dcl 657 in begin block on line 655 set ref
                                                                                  659*
salvage_report_text_lth         000223 automatic       fixed bin(21,0)          dcl 61 set ref 639* 646 649 652* 652 657 664
salvaged                 16(01)        based           bit(1)                   level 4 packed unaligned dcl 3-28 set ref 482 1443*
seg_fault_error                 000242 stack reference condition                dcl 162 ref 309 321
sender_authorization     16            based           bit(72)                  level 2 dcl 1-37 set ref 1486* 1486*
sentinel                  1            based           bit(36)                  level 2 in structure "upgraded_mseg_segment_header"
                                                                                  dcl 768 in procedure "upgrade_seg" set ref 944*
sentinel                  1            based           bit(36)                  level 3 in structure "mseg_segment" dcl 3-28
                                                                                  in procedure "mseg_utils_" set ref 343 349* 390
                                                                                  1445*
sentinel                               based           bit(36)                  level 2 in structure "message_descriptor" dcl 1-37
                                                                                  in procedure "salvage_seg" ref 1469
set_lock_$lock                  000140 constant        entry                    external dcl 152 ref 318
set_lock_$unlock                000142 constant        entry                    external dcl 153 ref 488 530 745
setwordno                                              builtin function         dcl 158 ref 1370 1462 1552
short                           000204 automatic       structure                level 2 dcl 53
sort_items_indirect_$bit        000144 constant        entry                    external dcl 154 ref 1360
sorted_message_indeces          000100 automatic       structure                level 1 dcl 1268 set ref 1360 1360
stacq                                                  builtin function         dcl 158 ref 316 488 530 558 745
state                    20            based           structure                level 4 in structure "mseg_segment" dcl 3-28
                                                                                  in procedure "mseg_utils_" set ref 1392 1424*
state                    20            based           structure                level 3 in structure "upgraded_mseg_segment_header"
                                                                                  dcl 768 in procedure "upgrade_seg" set ref 963*
state                           000674 automatic       structure                level 2 in structure "old_wakeup_state" dcl 1141
                                                                                  in procedure "salvage_seg"
status_branch                          based           structure                level 1 dcl 15-8
string                                                 builtin function         dcl 158 set ref 941* 980* 1400* 1400
sub_err_                        000146 constant        entry                    external dcl 156 ref 186 195 198 221 250 257 260 263
                                                                                  271 274 280 283 289 292 665 684 709 1053 1105
substr                                                 builtin function         dcl 158 set ref 991* 1292* 1311* 1382 1459 1538
suppress_access_checks
                         24(07) 000372 automatic       bit(1)                   level 3 in structure "upgraded_operation" packed
                                                                                  unaligned dcl 783 in procedure "upgrade_seg" set
                                                                                  ref 923* 973*
suppress_access_checks
                         24(07)        based           bit(1)                   level 3 in structure "mseg_operation" packed
                                                                                  unaligned dcl 5-24 in procedure "mseg_utils_" ref
                                                                                  263
suppress_access_checks
                         24(07) 000106 automatic       bit(1)                   level 3 in structure "original_operation" packed
                                                                                  unaligned dcl 781 in procedure "upgrade_seg" set
                                                                                  ref 973*
switches                        000674 automatic       structure                level 3 dcl 1141 set ref 1400
sys_info$ring1_privilege        000046 external static bit(36)                  dcl 105 ref 1486
system_area                            based           area(1024)               dcl 778 ref 1001 1073
system_area_ptr                 000104 automatic       pointer                  dcl 779 set ref 983* 986* 1001 1006* 1073
test_lock                       000216 automatic       bit(36)                  dcl 55 set ref 557* 558
text                            000100 automatic       char                     level 2 packed unaligned dcl 633 set ref 639* 646
                                                                                  649 649 665 665
the_block                              defined         bit                      dcl 1342 set ref 1343*
truncate_if_possible      0(27)        based           bit(1)                   level 3 packed unaligned dcl 6-9 set ref 482 753*
type                            000204 automatic       fixed bin(2,0)           level 3 packed unsigned unaligned dcl 53 set ref 616
unlock_segment            0(29)        based           bit(1)                   level 3 packed unaligned dcl 6-9 set ref 211* 327*
                                                                                  477 491* 524 533* 550 558* 752* 1187*
unspec                                                 builtin function         dcl 158 set ref 730* 940* 942* 956* 1363* 1364*
                                                                                  1398* 1398 1413*
upgrade_procedure_name          000656 automatic       char(32)                 unaligned dcl 786 set ref 877* 879* 883* 888*
upgraded_mseg_dir_name          000754 automatic       char(168)                unaligned dcl 793 set ref 932*
upgraded_mseg_entryname         001036 automatic       char(32)                 unaligned dcl 795 set ref 932*
upgraded_mseg_ptr               000102 automatic       pointer                  dcl 770 set ref 813* 858 925* 929 932* 939 939 940
                                                                                  941 942 944 945 947 948 949 951 956 962 963 1021
                                                                                  1021 1021 1035 1077 1079* 1080*
upgraded_mseg_segment_header           based           structure                level 1 dcl 768 set ref 858
upgraded_operation              000372 automatic       structure                level 1 dcl 783 set ref 920* 932 932 993 993
upgraded_segment                       based           bit(36)                  array dcl 776 set ref 1035* 1035
upgraded_size                   001051 automatic       fixed bin(19,0)          dcl 804 set ref 1021* 1025* 1035
version                  17            based           fixed bin(17,0)          level 3 in structure "mseg_segment" dcl 3-28
                                                                                  in procedure "mseg_utils_" set ref 343 350* 384
                                                                                  384 384 1446*
version                 115            based           char(8)                  level 3 in structure "mseg_operation" dcl 5-24
                                                                                  in procedure "mseg_utils_" set ref 263 263* 597*
version                   2     000106 automatic       fixed bin(17,0)          level 2 in structure "local_ci" dcl 725 in procedure
                                                                                  "seg_fault_handler" set ref 731*
version                 220     000106 automatic       char(8)                  level 3 in structure "original_operation" dcl 781
                                                                                  in procedure "upgrade_seg" set ref 979*
version                  17            based           fixed bin(17,0)          level 2 in structure "original_mseg_segment_header"
                                                                                  dcl 764 in procedure "upgrade_seg" ref 875
version                                based           fixed bin(17,0)          level 2 in structure "mseg_operation" dcl 5-24
                                                                                  in procedure "mseg_utils_" set ref 198 198*
version                 220            based           char(8)                  level 3 in structure "mseg_operation" dcl 5-24
                                                                                  in procedure "mseg_utils_" set ref 274 274* 283*
                                                                                  292*
version                 252            based           char(8)                  level 3 in structure "mseg_operation" packed
                                                                                  unaligned dcl 5-24 in procedure "mseg_utils_" ref
                                                                                  283 292
version                  20            based           char(8)                  level 5 in structure "mseg_segment" packed unaligned
                                                                                  dcl 3-28 in procedure "mseg_utils_" set ref 1392
version                 115     000106 automatic       char(8)                  level 3 in structure "original_operation" dcl 781
                                                                                  in procedure "upgrade_seg" set ref 835*
version                  17            based           fixed bin(17,0)          level 2 in structure "upgraded_mseg_segment_header"
                                                                                  dcl 768 in procedure "upgrade_seg" set ref 945*
version                         000662 automatic       char(8)                  level 2 in structure "local_wakeup_state" packed
                                                                                  unaligned dcl 1139 in procedure "salvage_seg" set
                                                                                  ref 1399* 1407* 1409
wakeup_state             20            based           structure                level 3 in structure "mseg_segment" dcl 3-28
                                                                                  in procedure "mseg_utils_" set ref 1398 1413*
wakeup_state            252     000106 automatic       structure                level 2 in structure "original_operation" dcl 781
                                                                                  in procedure "upgrade_seg" set ref 963
wakeup_state             20            based           structure                level 2 in structure "upgraded_mseg_segment_header"
                                                                                  dcl 768 in procedure "upgrade_seg" set ref 956*
wakeup_state              0(15)        based           bit(1)                   level 3 in structure "mseg_operation_data" packed
                                                                                  unaligned dcl 6-9 in procedure "mseg_utils_" ref
                                                                                  283
wakeup_state            252            based           structure                level 2 in structure "mseg_operation" dcl 5-24
                                                                                  in procedure "mseg_utils_"
wakeup_state_set         16(02)        based           bit(1)                   level 3 in structure "upgraded_mseg_segment_header"
                                                                                  packed unaligned dcl 768 in procedure
                                                                                  "upgrade_seg" set ref 962*
wakeup_state_set         16(02)        based           bit(1)                   level 4 in structure "mseg_segment" packed unaligned
                                                                                  dcl 3-28 in procedure "mseg_utils_" set ref 482
                                                                                  1392 1411* 1423*
wakeup_state_valid       24(06)        based           bit(1)                   level 3 in structure "mseg_operation" packed
                                                                                  unaligned dcl 5-24 in procedure "mseg_utils_" ref
                                                                                  283
wakeup_state_valid       24(06) 000106 automatic       bit(1)                   level 3 in structure "original_operation" packed
                                                                                  unaligned dcl 781 in procedure "upgrade_seg" set
                                                                                  ref 960
wakeup_state_version      0(16)        based           bit(1)                   level 3 packed unaligned dcl 6-9 ref 292
wordno                                                 builtin function         dcl 158 ref 1376 1378 1380 1384

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 11-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 11-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 11-7
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 12-7
BEEP                                   internal static fixed bin(17,0)          initial dcl 12-7
CRASH                                  internal static fixed bin(17,0)          initial dcl 12-7
Directory                              internal static fixed bin(17,0)          initial dcl 15-56
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 12-7
LOG                                    internal static fixed bin(17,0)          initial dcl 12-7
Link                                   internal static fixed bin(17,0)          initial dcl 15-56
MSEG_ALREADY_SALVAGED                  internal static bit(9)                   initial dcl 6-93
MSEG_BEGIN_FOR_FS_INTERFACE            internal static bit(9)                   initial dcl 6-86
MSEG_BEGIN_FOR_MESSAGE                 internal static bit(9)                   initial dcl 6-86
MSEG_BEGIN_FOR_SEGMENT                 internal static bit(9)                   initial dcl 6-86
MSEG_CHECK_COUNT_CONSISTENCY           internal static bit(9)                   initial dcl 6-77
MSEG_CHECK_HEADER_CONSISTENCY          internal static bit(9)                   initial dcl 6-77
MSEG_DONT_CHECK_LOCK_RESULTS           internal static bit(9)                   initial dcl 6-77
MSEG_FINISH_FOR_FS_INTERFACE           internal static bit(9)                   initial dcl 6-100
MSEG_FINISH_FOR_MESSAGE                internal static bit(9)                   initial dcl 6-100
MSEG_FINISH_FOR_SEGMENT                internal static bit(9)                   initial dcl 6-100
MSEG_INITIALIZE_HEADER                 internal static bit(9)                   initial dcl 6-77
MSEG_LOCK_SEGMENT                      internal static bit(9)                   initial dcl 6-77
MSEG_READ_BEFORE_SPECIFIED             internal static fixed bin(17,0)          initial dcl 8-30
MSEG_READ_DELETE                       internal static bit(36)                  initial dcl 8-38
MSEG_READ_LAST                         internal static fixed bin(17,0)          initial dcl 8-30
MSEG_READ_OWN                          internal static bit(36)                  initial dcl 8-38
MSEG_READ_SPECIFIED                    internal static fixed bin(17,0)          initial dcl 8-30
MSEG_REQUIRED_FOR_FS_INTERFACE         internal static bit(9)                   initial dcl 6-70
MSEG_REQUIRED_FOR_MESSAGE              internal static bit(9)                   initial dcl 6-70
MSEG_REQUIRED_FOR_SEGMENT              internal static bit(9)                   initial dcl 6-70
MSEG_REQUIRE_ACCESS_INFO               internal static bit(9)                   initial dcl 6-57
MSEG_REQUIRE_MD_PTR                    internal static bit(9)                   initial dcl 6-57
MSEG_REQUIRE_MESSAGE_INFO              internal static bit(9)                   initial dcl 6-57
MSEG_REQUIRE_MSEG_INDEX                internal static bit(9)                   initial dcl 6-57
MSEG_REQUIRE_MSEG_PTR                  internal static bit(9)                   initial dcl 6-57
MSEG_REQUIRE_PATHNAME                  internal static bit(9)                   initial dcl 6-57
MSEG_REQUIRE_WAKEUP_STATE              internal static bit(9)                   initial dcl 6-57
MSEG_REQUIRE_WAKEUP_STATE_VERSION      internal static bit(9)                   initial dcl 6-57
MSEG_TRUNCATE_IF_POSSIBLE              internal static bit(9)                   initial dcl 6-93
MSEG_TYPE_MBX                          internal static fixed bin(17,0)          initial dcl 5-21
MSEG_TYPE_MS                           internal static fixed bin(17,0)          initial dcl 5-22
MSEG_UNLOCK_SEGMENT                    internal static bit(9)                   initial dcl 6-93
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 12-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 12-7
abx                                    internal static fixed bin(17,0)          initial dcl 14-42
apx                                    internal static fixed bin(17,0)          initial dcl 14-42
bbx                                    internal static fixed bin(17,0)          initial dcl 14-42
bpx                                    internal static fixed bin(17,0)          initial dcl 14-42
condition_info_ptr                     automatic       pointer                  dcl 13-10
entry_access_info_ptr                  automatic       pointer                  dcl 9-8
header_msg_present                     defined         bit(1)                   unaligned dcl 3-82
lbx                                    internal static fixed bin(17,0)          initial dcl 14-42
lpx                                    internal static fixed bin(17,0)          initial dcl 14-42
mcp                                    automatic       pointer                  dcl 14-10
mseg_data_$admin_ring                  external static fixed bin(3,0)           dcl 2-8
mseg_data_$template_operation          external static bit(36)                  dcl 2-7
mseg_format_errors_$bad_descriptor_sentinel
                                       external static fixed bin(35,0)          dcl 10-10
mseg_format_errors_$circular_hash_chain
                                       external static fixed bin(35,0)          dcl 10-10
mseg_format_errors_$circular_message_blocks
                                       external static fixed bin(35,0)          dcl 10-10
mseg_format_errors_$circular_message_chain
                                       external static fixed bin(35,0)          dcl 10-10
mseg_format_errors_$descriptor_in_other_block
                                       external static fixed bin(35,0)          dcl 10-10
mseg_format_errors_$inconsistent_backward_chain
                                       external static fixed bin(35,0)          dcl 10-10
mseg_format_errors_$inconsistent_block_map
                                       external static fixed bin(35,0)          dcl 10-10
mseg_format_errors_$inconsistent_forward_chain
                                       external static fixed bin(35,0)          dcl 10-10
mseg_format_errors_$inconsistent_hash_chain
                                       external static fixed bin(35,0)          dcl 10-10
mseg_format_errors_$inconsistent_message_length
                                       external static fixed bin(35,0)          dcl 10-10
mseg_format_errors_$invalid_message_block_offset
                                       external static fixed bin(35,0)          dcl 10-10
mseg_format_errors_$no_descriptor_in_first_block
                                       external static fixed bin(35,0)          dcl 10-10
mseg_format_errors_$unused_block_in_message
                                       external static fixed bin(35,0)          dcl 10-10
mseg_message_info_ptr                  automatic       pointer                  dcl 8-7
mseg_operations_$add_acl_entries_seg   external static bit(36)                  dcl 7-8
mseg_operations_$add_message           external static bit(36)                  dcl 7-8
mseg_operations_$chname_seg            external static bit(36)                  dcl 7-8
mseg_operations_$close_seg             external static bit(36)                  dcl 7-8
mseg_operations_$compact_seg           external static bit(36)                  dcl 7-8
mseg_operations_$copy_seg_source       external static bit(36)                  dcl 7-8
mseg_operations_$count_messages        external static bit(36)                  dcl 7-8
mseg_operations_$create_seg            external static bit(36)                  dcl 7-8
mseg_operations_$delete_acl_entries_seg
                                       external static bit(36)                  dcl 7-8
mseg_operations_$delete_message        external static bit(36)                  dcl 7-8
mseg_operations_$delete_seg            external static bit(36)                  dcl 7-8
mseg_operations_$get_salvaged_flag_seg external static bit(36)                  dcl 7-8
mseg_operations_$get_wakeup_state_seg  external static bit(36)                  dcl 7-8
mseg_operations_$initiate_seg          external static bit(36)                  dcl 7-8
mseg_operations_$list_acl_entries_seg  external static bit(36)                  dcl 7-8
mseg_operations_$list_acl_seg          external static bit(36)                  dcl 7-8
mseg_operations_$open_seg              external static bit(36)                  dcl 7-8
mseg_operations_$read_message          external static bit(36)                  dcl 7-8
mseg_operations_$replace_acl_seg       external static bit(36)                  dcl 7-8
mseg_operations_$reset_salvaged_flag_seg
                                       external static bit(36)                  dcl 7-8
mseg_operations_$reset_wakeup_state_seg
                                       external static bit(36)                  dcl 7-8
mseg_operations_$set_max_length_seg    external static bit(36)                  dcl 7-8
mseg_operations_$set_safety_switch_seg external static bit(36)                  dcl 7-8
mseg_operations_$set_wakeup_state_seg  external static bit(36)                  dcl 7-8
mseg_operations_$update_message        external static bit(36)                  dcl 7-8
mseg_wakeup_state_ptr                  automatic       pointer                  dcl 4-38
sbx                                    internal static fixed bin(17,0)          initial dcl 14-42
scu                                    based           structure                level 1 dcl 14-56
scup                                   automatic       pointer                  dcl 14-54
scux                                   based           structure                level 1 dcl 14-207
spx                                    internal static fixed bin(17,0)          initial dcl 14-42
status_area_ptr                        automatic       pointer                  dcl 15-47
status_entry_names                     based           char(32)                 array dcl 15-47
status_link                            based           structure                level 1 dcl 15-38
status_pathname                        based           char                     dcl 15-47
status_ptr                             automatic       pointer                  dcl 15-47

NAMES DECLARED BY EXPLICIT CONTEXT.
COMPLETE_UPGRADE_AFTER_RQO      007010 constant        label                    dcl 1039 set ref 1032
RECONSTRUCT_THE_SEGMENT         010061 constant        label                    dcl 1255
RESET_SEGMENT_WAKEUP_STATE      010656 constant        label                    dcl 1411 ref 1416 1419
RETURN_FROM_BEGIN_OPERATION     003226 constant        label                    dcl 422 ref 313 443 754 1113
RETURN_FROM_SALVAGE_FOR_CAUSE   005006 constant        label                    dcl 690 ref 714
RETURN_NOT_A_MESSAGE            011222 constant        label                    dcl 1504 in procedure "possible_message" ref 1500
RETURN_NOT_A_MESSAGE            011437 constant        label                    dcl 1601 in procedure "valid_message" ref 1597
abort_salvage_for_cause         005045 constant        entry                    internal dcl 697 ref 602 610 614 619 1180 1220
abort_upgrade_seg               007332 constant        entry                    internal dcl 1092 ref 841 849 866 880 885 889 900
                                                                                  917 926 936 996 1009
cleanup_after_upgrade_seg       007254 constant        entry                    internal dcl 1068 ref 816 1039
mseg_utils_                     001245 constant        entry                    external dcl 14
mseg_utils_$abort_operation     003365 constant        entry                    external dcl 507
mseg_utils_$begin_operation     001332 constant        entry                    external dcl 181 ref 932
mseg_utils_$finish_operation    003260 constant        entry                    external dcl 471
mseg_utils_$initialize          001254 constant        entry                    external dcl 167
mseg_utils_$request_unlock_on_finish
                                003507 constant        entry                    external dcl 544
mseg_utils_$salvage_for_cause   003550 constant        entry                    external dcl 567
not_a_message                   011225 constant        entry                    internal dcl 1497 in procedure "possible_message"
                                                                                  ref 1459 1464 1469 1472 1476 1480 1483 1486
not_a_message                   011442 constant        entry                    internal dcl 1594 in procedure "valid_message" ref
                                                                                  1530 1535 1538 1542 1546 1554 1559 1561 1567 1569
                                                                                  1571 1577 1584
possible_message                011002 constant        entry                    internal dcl 1454 ref 1294
return_from_begin_operation     005007 constant        entry                    internal dcl 437 ref 323 330 338 353 366 401 458
salvage_and_return_from_begin   005014 constant        entry                    internal dcl 451 ref 334 388 390 393 396 406 412 415
salvage_seg                     007645 constant        entry                    internal dcl 1121 ref 675
seg_fault_handler               005317 constant        entry                    internal dcl 722 ref 309
upgrade_seg                     005456 constant        entry                    internal dcl 761 ref 384 879 879 883 883 888 888
valid_message                   011227 constant        entry                    internal dcl 1513 ref 1299

NAME DECLARED BY CONTEXT OR IMPLICATION.
min                                                    builtin function         ref 621

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     13020       13224   11511       13030
Length     14156   11511       204         716    1307           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mseg_utils_                         416 external procedure  is an external procedure.  
on unit on line 309                 122 on unit               
on unit on line 310                  64 on unit               
return_from_begin_operation             internal procedure  shares stack frame of external procedure mseg_utils_.  
salvage_and_return_from_begin           internal procedure  shares stack frame of external procedure mseg_utils_.  
begin block on line 631             272 begin block         uses auto adjustable storage, and is declared options(non_quick).  
begin block on line 645                 begin block         shares stack frame of begin block on line 631.  
begin block on line 655                 begin block         shares stack frame of begin block on line 631.  
begin block on line 663                 begin block         shares stack frame of begin block on line 631.  
abort_salvage_for_cause             238 internal procedure  is called by several nonquick procedures.  
seg_fault_handler                       internal procedure  shares stack frame of on unit on line 309.  
upgrade_seg                         776 internal procedure  enables or reverts conditions, and is declared options(non_quick).  
on unit on line 816                  64 on unit               
on unit on line 907                  74 on unit               
on unit on line 1027                 96 on unit               
cleanup_after_upgrade_seg            80 internal procedure  is called by several nonquick procedures.  
abort_upgrade_seg                   276 internal procedure  is called by several nonquick procedures.  
salvage_seg                         552 internal procedure  enables or reverts conditions, and is declared options(non_quick).  
on unit on line 1177                 74 on unit               
begin block on line 1255            150 begin block         uses auto adjustable storage.  
begin block on line 1329                begin block         shares stack frame of begin block on line 1255.  
begin block on line 1340                begin block         shares stack frame of begin block on line 1255.  
possible_message                        internal procedure  shares stack frame of begin block on line 1255.  
not_a_message                           internal procedure  shares stack frame of begin block on line 1255.  
valid_message                           internal procedure  shares stack frame of begin block on line 1255.  
not_a_message                           internal procedure  shares stack frame of begin block on line 1255.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 1255 000100 sorted_message_indeces      begin block on line 1255
                         000100 nonzero_block_map           begin block on line 1255
                         000100 message_id_ptrs             begin block on line 1255
                         000100 block_offsets               begin block on line 1255
                         000100 new_block_map               begin block on line 1255
                         000100 message_offsets             begin block on line 1255
                         000100 message_ids                 begin block on line 1255
                         000160 first_block                 valid_message
                         000161 actual_ms_len               valid_message
                         000162 block_offset                valid_message
begin block on line 631  000100 salvage_report              begin block on line 631
mseg_utils_              000100 operation_name              mseg_utils_
                         000120 mseg_dir_name               mseg_utils_
                         000172 mseg_entryname              mseg_utils_
                         000202 rqo_detected                mseg_utils_
                         000203 code                        mseg_utils_
                         000204 long_status                 mseg_utils_
                         000216 test_lock                   mseg_utils_
                         000220 salvage_for_cause_arguments mseg_utils_
                         000222 path_code                   mseg_utils_
                         000223 salvage_report_text_lth     mseg_utils_
                         000224 callers_report_text_lth     mseg_utils_
                         000225 mseg_max_length             mseg_utils_
                         000226 mseg_cur_length             mseg_utils_
                         000227 n_header_blocks             mseg_utils_
                         000230 n_possible_messages         mseg_utils_
                         000231 n_messages_recovered        mseg_utils_
                         000232 n_arguments                 mseg_utils_
                         000233 prefix_lth                  mseg_utils_
                         000250 mseg_ptr                    mseg_utils_
                         000252 mseg_operation_ptr          mseg_utils_
                         000254 mseg_operation_data_ptr     mseg_utils_
on unit on line 309      000106 local_ci                    seg_fault_handler
                         000140 local_code                  seg_fault_handler
salvage_seg              000100 n_possible_messages         salvage_seg
                         000101 n_messages_recovered        salvage_seg
                         000102 local_mseg_segment_header   salvage_seg
                         000622 local_message_block         salvage_seg
                         000662 local_wakeup_state          salvage_seg
                         000674 old_wakeup_state            salvage_seg
                         000774 prev_md_ptr                 salvage_seg
                         000776 mseg_segment_aim_range      salvage_seg
                         001002 block_size_unknown          salvage_seg
                         001003 probable_block_size         salvage_seg
                         001004 n_blocks_available          salvage_seg
                         001005 n_header_blocks             salvage_seg
                         001006 last_used_block             salvage_seg
                         001007 max_blocks_per_message      salvage_seg
                         001010 n_blocks_recovered          salvage_seg
                         001011 last_recovered_block        salvage_seg
                         001012 block_id                    salvage_seg
                         001013 n_message_blocks            salvage_seg
                         001014 message_block_idx           salvage_seg
                         001015 message_block_id            salvage_seg
                         001016 last_block_checked          salvage_seg
                         001017 next_unused_block           salvage_seg
                         001020 message_index               salvage_seg
                         001021 max_bits_in_first_block     salvage_seg
                         001022 max_bits_in_other_blocks    salvage_seg
                         001023 hash_idx                    salvage_seg
                         001024 mb_ptr                      salvage_seg
                         001026 md_ptr                      salvage_seg
upgrade_seg              000100 original_mseg_ptr           upgrade_seg
                         000102 upgraded_mseg_ptr           upgrade_seg
                         000104 system_area_ptr             upgrade_seg
                         000106 original_operation          upgrade_seg
                         000372 upgraded_operation          upgrade_seg
                         000656 upgrade_procedure_name      upgrade_seg
                         000666 salvage_old_segment         upgrade_seg
                         000672 get_old_wakeup_state        upgrade_seg
                         000676 read_old_message            upgrade_seg
                         000702 original_mseg_dir_name      upgrade_seg
                         000754 upgraded_mseg_dir_name      upgrade_seg
                         001026 original_mseg_entryname     upgrade_seg
                         001036 upgraded_mseg_entryname     upgrade_seg
                         001046 salvage_completed           upgrade_seg
                         001047 rqo_detected                upgrade_seg
                         001050 path_code                   upgrade_seg
                         001051 upgraded_size               upgrade_seg
                         001052 n_upgraded_blocks_allocated upgrade_seg
                         001053 n_upgraded_header_blocks    upgrade_seg
                         001054 n_messages_discarded        upgrade_seg
                         001055 original_version            upgrade_seg

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              r_ne_as             alloc_cs            alloc_bs            cat_realloc_cs
enter_begin         leave_begin         call_var            call_ext_in_desc    call_ext_out_desc   call_ext_out
call_int_this       call_int_other      begin_return        return              tra_ext             alloc_auto_adj
mod_fx1             enable              shorten_stack       ext_entry           ext_entry_desc      int_entry
index_bs_1_eis      divide_fx3          free_based          stacq               clock

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
admin_gate_$guaranteed_eligibility_off                      admin_gate_$guaranteed_eligibility_on
admin_gate_$syserr_error_code aim_check_$greater_or_equal   aim_check_$in_range           aim_util_$get_privileges
cu_$arg_count                 cu_$arg_list_ptr              find_condition_info_          get_group_id_
get_lock_id_                  get_process_max_authorization_                              get_ring_
get_system_free_area_         get_temp_segment_             hcs_$fs_get_path_name         hcs_$get_access_info_seg
hcs_$get_max_length_seg       hcs_$make_entry               hcs_$set_damaged_sw_seg       hcs_$status_long
hcs_$truncate_seg             ioa_$general_rs               ioa_$rsnpnnl
mseg_message_$add_message_for_mseg                          mseg_utils_$salvage_for_cause pathname_
release_temp_segment_         set_lock_$lock                set_lock_$unlock              sort_items_indirect_$bit
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_segment      error_table_$bad_subr_arg     error_table_$bigarg
error_table_$improper_data_format                           error_table_$invalid_max_length
error_table_$lock_wait_time_exceeded                        error_table_$no_message       error_table_$no_s_permission
error_table_$not_seg_type     error_table_$notalloc         error_table_$null_info_ptr    error_table_$rqover
error_table_$seg_busted       error_table_$segfault         error_table_$unimplemented_version
mseg_data_$block_size         mseg_data_$execution_ring     mseg_data_$group_id           mseg_data_$lock_id
mseg_data_$max_message_size   mseg_data_$process_max_authorization
mseg_format_errors_$bad_mseg_sentinel                       mseg_format_errors_$bad_mseg_version
mseg_format_errors_$inconsistent_message_count              mseg_format_errors_$modification_in_progress
mseg_format_errors_$negative_message_count                  mseg_format_errors_$salvage_in_progress
mseg_operations_$copy_seg_target                            mseg_operations_$names        sys_info$ring1_privilege




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     14 001244        17 001252       167 001253       170 001261       171 001270       172 001305       174 001313
    176 001322       181 001323       185 001364       186 001367       191 001444       193 001456       195 001461
    198 001520       202 001572       203 001576       205 001600       206 001603       207 001606       208 001610
    209 001611       211 001612       219 001616       221 001631       224 001677       226 001703       227 001706
    228 001711       229 001712       231 001715       232 001720       234 001723       236 001730       238 001731
    242 001736       243 001741       244 001744       245 001745       247 001750       248 001753       249 001756
    250 001757       253 002023       257 002033       260 002077       263 002142       270 002227       271 002230
    274 002273       279 002355       280 002356       283 002421       288 002503       289 002504       292 002547
    300 002626       306 002637       309 002642       310 002660       312 002674       313 002677       316 002702
    318 002714       320 002730       321 002731       323 002732       327 002740       330 002745       334 002753
    335 002755       338 002756       343 002761       349 002774       350 002776       352 003000       353 003013
    357 003017       358 003023       360 003026       366 003035       369 003045       372 003051       373 003062
    376 003063       384 003064       388 003100       390 003107       393 003122       396 003135       398 003150
    401 003151       406 003154       410 003177       412 003200       415 003211       422 003226       424 003234
    425 003241       426 003246       427 003250       429 003252       431 003254       471 003255       474 003270
    475 003273       477 003275       480 003300       482 003302       488 003330       491 003347       493 003351
    496 003362       507 003363       510 003375       512 003400       515 003404       518 003407       521 003413
    522 003415       524 003417       527 003422       530 003452       533 003471       535 003473       538 003504
    544 003505       547 003517       548 003522       550 003524       553 003527       557 003531       558 003533
    561 003543       567 003544       570 003562       571 003565       573 003567       576 003572       578 003574
    580 003576       583 003611       590 003621       592 003624       593 003627       594 003632       597 003633
    598 003636       599 003653       601 003655       602 003707       604 003722       605 003725       606 003730
    609 003733       610 003746       613 003762       614 004023       616 004042       618 004046       619 004051
    621 004063       626 004072       628 004105       629 004117       631 004126       633 004131       639 004142
    637 004145       639 004175       643 004266       646 004272       649 004300       652 004353       655 004356
    657 004362       659 004366       655 004433       664 004434       665 004437       668 004522       673 004523
    675 004524       677 004534       684 004657       690 005006       437 005007       442 005011       443 005013
    451 005014       456 005016       458 005034       460 005043       697 005044       703 005052       709 005171
    714 005314       722 005317       728 005320       730 005324       731 005327       733 005331       735 005347
    740 005362       743 005372       744 005407       745 005425       747 005445       752 005446       753 005450
    754 005452       761 005455       810 005463       813 005466       816 005471       818 005513       825 005515
    826 005521       828 005523       830 005526       831 005531       832 005534       835 005535       836 005540
    837 005555       839 005560       841 005612       843 005625       844 005627       845 005632       848 005635
    849 005651       856 005666       858 005673       863 005710       865 005712       866 005714       875 005727
    877 005732       879 005762       880 006021       883 006036       885 006076       888 006113       889 006153
    895 006170       897 006202       899 006205       900 006207       907 006221       916 006235       917 006241
    918 006254       920 006255       921 006260       923 006264       925 006266       926 006310       929 006325
    930 006327       932 006331       934 006403       936 006412       939 006427       940 006433       941 006436
    942 006437       944 006442       945 006444       947 006446       948 006451       949 006453       951 006455
    956 006466       958 006472       960 006502       962 006505       963 006510       973 006513       975 006517
    977 006521       979 006522       980 006524       981 006525       983 006527       985 006536       986 006540
    988 006555       990 006561       991 006564       993 006566       994 006611       996 006622       999 006636
   1001 006642      1002 006647      1005 006651      1006 006653      1007 006670      1009 006671      1012 006706
   1014 006707      1021 006711      1025 006716      1027 006732      1029 006746      1030 006752      1032 006775
   1035 007000      1037 007007      1039 007010      1045 007014      1053 007130      1059 007247      1062 007252
   1068 007253      1071 007261      1073 007266      1074 007273      1077 007276      1079 007302      1080 007325
   1083 007330      1092 007331      1098 007337      1105 007472      1111 007634      1113 007641      1121 007644
   1177 007652      1179 007666      1180 007672      1181 007705      1186 007706      1187 007712      1189 007714
   1191 007717      1192 007723      1200 007726      1202 007730      1204 007734      1208 007743      1210 007746
   1215 007755      1218 007764      1220 007770      1223 010006      1231 010012      1241 010016      1242 010020
   1244 010022      1245 010024      1247 010030      1248 010047      1250 010056      1255 010061      1258 010064
   1261 010073      1264 010076      1268 010103      1273 010106      1274 010112      1275 010120      1277 010124
   1278 010136      1280 010147      1288 010152      1290 010154      1292 010166      1294 010214      1297 010227
   1299 010231      1302 010244      1304 010246      1305 010252      1307 010263      1308 010274      1311 010301
   1312 010305      1313 010306      1314 010312      1317 010314      1323 010317      1325 010337      1327 010342
   1330 010346      1332 010352      1335 010360      1339 010364      1342 010365      1343 010371      1347 010417
   1353 010420      1355 010423      1356 010432      1357 010437      1358 010441      1360 010443      1363 010464
   1364 010472      1366 010475      1368 010500      1370 010510      1371 010517      1373 010541      1374 010544
   1376 010546      1378 010556      1380 010563      1382 010570      1383 010574      1384 010600      1386 010607
   1387 010610      1392 010612      1398 010627      1399 010632      1400 010634      1401 010636      1402 010640
   1403 010643      1404 010645      1405 010647      1407 010650      1409 010653      1411 010656      1413 010663
   1414 010666      1416 010667      1419 010673      1423 010711      1424 010716      1425 010722      1431 010735
   1432 010744      1434 010746      1436 010747      1437 010751      1438 010753      1440 010755      1442 010763
   1443 010767      1445 010771      1446 010773      1448 010775      1450 010777      1606 011001      1454 011002
   1459 011004      1462 011013      1464 011024      1467 011030      1469 011055      1472 011061      1475 011070
   1476 011102      1478 011114      1480 011117      1483 011135      1486 011156      1492 011216      1504 011222
   1497 011225      1500 011226      1513 011227      1522 011231      1524 011236      1525 011240      1526 011241
   1528 011242      1530 011244      1533 011251      1535 011256      1538 011263      1541 011273      1542 011304
   1544 011311      1546 011314      1549 011320      1550 011322      1552 011326      1554 011332      1557 011336
   1559 011340      1561 011346      1564 011357      1567 011360      1569 011365      1571 011373      1576 011404
   1577 011410      1580 011416      1581 011422      1582 011423      1584 011424      1589 011433      1601 011437
   1594 011442      1597 011443      1612 011444


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
