	COMPILATION LISTING OF SEGMENT rlm_general_search
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1138.23_Tue_mdt
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION:
        8*
        9*         This   module   searches   through  a  relation,  using  either  the
       10*     record_manager_ or the  index_manager_,  returning  either  an  arbitrary
       11*     subset  of  the  attributes  of  the  tuples  found  (as specified by the
       12*     attribute id_list), or a list of element ids (which identify  the  tuples
       13*     found).
       14**/
       15 
       16 /* HISTORY:
       17*
       18*Written by Lindsey L. Spratt, 09/23/82.
       19*Modified:
       20*11/12/82 by Lindsey Spratt: Changed to use version 3 of the
       21*	  search_specification.  This means using the interval_list
       22*	  structure which the index_manager_ may return in calls to the
       23*	  record_manager_, and doing the conversion of the
       24*	  search_specification field_ids to support search specs with
       25*	  constraints on fields not present in the index being searched.
       26*11/22/82 by Lindsey Spratt:  Added the get_array_by_spec entry and changed the
       27*	  get_by_spec entry to be get_list_by_spec.
       28*12/06/82 by Lindsey Spratt:  Fixed get_duplicate_key_count to a largely
       29*	  "independent" entry, since it is the only entry which does not use
       30*	  a specification.Also, changed code to allow for the
       31*	  specification_ptr being null.  Changed to convert record_not_found
       32*	  and key_not_found errors to mdbm_error_$tuple_not_found error
       33*	  codes.
       34*12/16/82 by Matthew Pierret:  Made to set p_element_id_list_ptr to null.
       35*01/18/83 by Matthew Pierret:  
       36*            Changed to not pass p_code to vector_util_$free_typed_vector_array
       37*            in the finish procedure. It would reset p_code to 0.
       38*02/07/83 by Lindsey Spratt:  Changed to not allocate anything but final
       39*	  results in the caller-provided area, and to never free from the
       40*	  caller's area.  This requires doing a full copy of the resulting
       41*	  typed_vector_array or element_id_list.  The work_area is the
       42*	  dm_data_$area_ptr area.
       43*02/28/83 by Lindsey Spratt:  Changed to use version 3 index_cursor.
       44*03/04/83 by Matthew Pierret: Changed to use the structures attribute_info,
       45*            relation_opening_info, and index_attribute_map instead of the
       46*            previously kept relation_info structure. Changed CHECK_VERSION
       47*            CHECK_VERSION_FB, and added a new CHECK_VERSION which checks
       48*            char(8)aligned versions. Removed references to dm_data$area_ptr.
       49*            The work_area_ptr is now gotten using get_dm_free_area_ ().
       50*            Changed work_area_ptr to be "internal static init (null)" so that
       51*            only one call to get_dm_free_area_ need be made per process.
       52*03/11/83 by Matthew Pierret: Changed to use mrds_error_ instead of mdbm_error_.
       53*04/01/83 by Matthew Pierret: Changed to use dm_error_$tuple_not_found instead
       54*            of mrds_error_$==. Added the entries $get_list_and_ids and
       55*            $get_array_and_ids. Added use of CV_ERROR_TO_TUPLE_NOT_FOUND_RETURN
       56*            to translate appropriate error codes to dm_error_$tuple_not_found,
       57*            clean up and return. Added record_manager_ $get_records_and_ids
       58*            and $get_records_and_ids_by_interval. Changed 
       59*            record_field_is_in_index to all_desired_fields_are_in_index.
       60*            Upper-cased finish. Added format comment after declarations which
       61*            allows for comments to start at one indentation level before the
       62*            current indentation level.
       63*            Removed the check to see if a record_cursor was supplied
       64*            via the $get_duplicate_key_count entry in the SEARCH_RECORDS
       65*            do-group.  It is impossible to reach this point in the code
       66*            when called through $get_duplicate_key_count.
       67*05/05/83 by Matthew Pierret:  Changed entries which return a p_element_id_list
       68*            to not allocate a new structure if p_element_id_list_ptr is not
       69*            null.  Rather, just set the number of elements and fill in the
       70*            identifiers.  It is not assumed that the value of
       71*            peil.number_of_elements constitutes an upper bound.
       72*05/31/83 by Matthew Pierret:  Added CV_V3_TO_V4_SPEC as a temporary means of
       73*            converting the version 3 specifications passed in by MRDS to 
       74*            the version 4 specifications used by index/record_managers.
       75*06/07/83 by Lindsey L. Spratt:  Fixed the initialization of the value_field_id
       76*            to -1 to only be done when the number of and groups is > 0.  This
       77*            was overwriting the storage of the following allocation when the
       78*            noag = 0, since PL1 assumes that there is always at least 1
       79*            element in an array (even if its a 0-refer-extent based array).
       80*06/08/83 by Matthew Pierret: Changed to support relation_cursors and
       81*            relation_specifications. Removed the temporary CV_V3_TO_V4_SPEC.
       82*            Changed interfaces as follows:
       83*            - moved p_id_list_ptr immediately before p_caller_area_ptr in all
       84*            calling sequences which have these two parameters;
       85*            - added p_index_collection_id parameter to $get_duplicate_key_count
       86*            to determine the index on which to operate (this determination
       87*            previously was made by checking the cursor supplied);
       88*            - moved p_relation_cursor_ptr to the beginning of all calling
       89*            sequences for consistency.
       90*            Added dm_specification_head.incl.pl1, dm_range_constants.incl.pl1.
       91*            Changed basic searching technology with respect as follows:
       92*            - each and-group is processed as a separate index and/or record
       93*            search;
       94*            - search_specifications are modified so as to exclude tuples found
       95*            in previous and-group searches by toggling the NOT bit in the 
       96*            operator codes;
       97*            - if the desired number of tuples are found before the end of the
       98*            relation is reached, the specification and cursor currently being
       99*            used to search an index or record collection is maintained in the
      100*            relation_cursor.
      101*06/13/83 by Matthew Pierret:  Changed record_manager_$*_by_intervals to
      102*            correctly be =$=_by_interval.
      103*06/20/83 by Matthew Pierret:  Fixed incorrect ordering of arguments to
      104*            record_manager_$get_ids_by_interval.
      105*06/22/83 by Lindsey L. Spratt:  Moved SEARCH_RECORD_COLLECTION and
      106*            SEARCH_INDEX into internal procedures.  Fixed AND_GROUP_LOOP to
      107*            continue searching with the next and_group if the current
      108*            and_group selects no tuples.
      109*06/23/83 by Lindsey L. Spratt:  Fixed $get_duplicate_key_count to recognize
      110*            p_number_of_duplicate_fields = -1 as a request for a count of all
      111*            of the keys (available as the 0-th element in the
      112*            key_count_array).  Also, changed myname to "rlm_general_search".
      113*            Changed to handle relative searches better.  The search_spec was
      114*            being re-used without paying attention to whether the field_ids
      115*            were left set up for an index search or a record search.  This
      116*            caused problems with a relative search which involved an index
      117*            (whether or not there was also a record search).
      118*07/30/83 by Matthew Pierret:  Made to free the old internal specification
      119*            when resetting the cursor. Changed to allocate and copy the values
      120*            in the relation_search_specification for use by the internal
      121*            search_specification, rather than just making ss.value_ptr
      122*            point to the same place as rss.value_ptr.  This is because the 
      123*            values are used accross calls, and the caller might free the values
      124*            and allocate new ones between calls.
      125*08/11/83 by Matthew Pierret:  Removed the SET_CURRENT_NUMBER_OF_AND_GROUPS
      126*            subroutine, replacing it with all 3 lines in-line.
      127*            Made to free values copied for the internal search_specification.
      128*            Removed attempts to not return data from the same tuple more than
      129*            once.  Right now MRDS doesn't assume that we do, so why bother?
      130*            ****                                                         ****
      131*            **** Later, we will have to change this to strip duplicates. ****
      132*            ****                                                         ****
      133*            Changed to not copy specification values until the cursor is reset.
      134*            This eliminates unnecessray copying. Changed SEARCH_INDEX and
      135*            SEARCH_RECORD_COLLECTION to use a local code. Changed to allow
      136*            an internal search_specification to have 0 and-groups.
      137*09/13/83 by Matthew Pierret:  Removed $get_duplicate_key_count (moved it to
      138*            rlm_get_approximate_count)
      139*09/16/83 by Matthew Pierret:  Added frees of typed_vector_arrays and
      140*            element_id_lists throughout much of the code.  Failure to free
      141*            these structures and the structures to which they point was
      142*            causing a great deal of extra space to hang around past its
      143*            welcome. Added frees of interval_lists.            
      144*01/19/84 by Matthew Pierret:  Changed FINISH to never free constraint values
      145*            in the internal_specification because these values are actually
      146*            the values pointed to by the caller's
      147*            relation_search_specification.  These constraint values are only
      148*            copied into the relation_manager_'s work area when resetting the
      149*            cursor.
      150*01/23/84 by Matthew Pierret:  Changed FINISH to correctly null
      151*            return_eil_or_tva_array.ptr instead of return_eil_or_tva_array_ptr
      152*            after freeing each typed_vector_array.
      153*04/13/84 by Lee Baldwin:  Some of the record_manager_ entrypoints have been
      154*            renamed, and their calling sequences changed (*): get_records_by_id_list(*),
      155*            get_records_and_ids_by_spec(*), get_records_by_spec(*), get_record_ids_by_spec,
      156*            get_record_ids_by_interval.
      157*04/27/84 by Lee Baldwin:  Changed the calling sequence of
      158*            record_manager_$get_record_bount_by_interval which no longer takes
      159*            a work_area_ptr.  
      160*05/02/84 by Lee Baldwin:  Changed name of index_manager_$get_count to 
      161*            $get_key_count_by_spec.
      162*05/08/84 by Matthew Pierret:  Changed to free typed_vector_arrays with the
      163*            internal procedure FREE_TYPED_VECTOR_ARRAY.
      164*05/29/84 by Matthew Pierret:  Changed to use RELATION_HEADER_VERSION_3.  Made
      165*            temporary fix to restrict the maximum number of tuples to accept
      166*            to that which can be held in a fixed bin (17) value.  This should
      167*            be changed to fixed bin (35) by changing the declaration of
      168*            range.size and range_size in the specification structures.
      169*06/07/84 by Lee Baldwin:  Renamed dm_error_$rel_cursor_pos_bad to
      170*            $bad_rel_cursor_pos.
      171*10/28/84 by Lindsey L. Spratt:  Changed to use version 2 interval_list, and to
      172*            check the version of this structure.
      173*11/02/84 by Stanford S.  Cox: MAIN: Added version check of relation_cursor,
      174*            chg to copy parameters.  FINISH: Chg to call FREE_SPEC*, add free
      175*            of structures alloc in RETURN*.  FREE_SPEC*: Chg to also free
      176*            numeric specs.  COPY_VALUE: Removed based clause from
      177*            cv_value_string dcl.  SETUP_INT_SPEC: Asgn. MAX_FB35_VALUE to
      178*            max_#_tuples.  RTVL: Chg.  typed_vector_list_ptr check to be an
      179*            if-then-else, moved typed_vector_list to MAIN.  RTVA: Chg.
      180*            typed_vector_array_ptr check to be an if-then-else, added
      181*            typed_vector_array version check, chg.  tva to use explicit ptr
      182*            refs so local tva not reqd.  REIL: Chg.  element_id_list check to
      183*            be an if-then-else, chg.  eil to use explicit ptr refs so local
      184*            eil not reqd.  
      185*11/30/84 by Stanford S. Cox: RECORD_DATA: Chg nested if structure which calls
      186*	  RECORD*RETURN. FTVA: Chg to return if tva_ptr is null. SI: Chg to
      187*	  free eil. SIC: Chg to delete sic_cursor_ptr if ^null. RTVA: Add
      188*	  call to sub_err.
      189*12/02/84 by Lindsey L. Spratt:  Changed to use dm_vector_util_ instead of
      190*            vector_util_.
      191*12/08/84 by Lindsey L. Spratt:  Renamed dm_error_$rel_cursor_pos_bad to
      192*            $bad_rel_cursor_pos.
      193*01/17/84 by Stanford S. Cox: FINISH: Chg to free internal spec instead of
      194*	  calling FREE_SPECIFICATION.
      195*03/01/85 by S. Cox: Removed declared & unreferenced variables.
      196*03/10/85 by Lindsey Spratt: Fixed to FINISH to check
      197*	  local_typed_vector_array_ptr ^= null (instead of
      198*	  local_typed_vector_list_ptr ^= null) before freeing
      199*	  the local_typed_vector_array.
      200*03/11/85 by Lindsey L. Spratt:  Fixed RETURN_TYPED_VECTOR_ARRAY to set the
      201*            number_of_vectors in the output tva (pointed at by
      202*            rtva_typed_vector_array_ptr).
      203*03/19/85 by Lindsey L. Spratt:  Fixed to handle the TUPLE_ID_FIELD_ID when
      204*            doing a get for which all of the desired fields are in the index
      205*            being searched.
      206**/
      207 
      208 /* format: style2,ind3 */
      209 
      210 rlm_general_search:
      211    proc ();
      212       return;					/* Not a legal entry. */
      213 
      214 /* START OF DECLARATIONS */
      215 /* Parameter */
      216 
      217       dcl	    p_specification_ptr    ptr parameter;
      218       dcl	    p_caller_area_ptr      ptr parameter;
      219       dcl	    p_id_list_ptr	       ptr parameter;
      220       dcl	    p_relation_cursor_ptr  ptr parameter;
      221       dcl	    p_element_id_list_ptr  ptr parameter;
      222       dcl	    p_typed_vector_array_ptr
      223 			       ptr parameter;
      224       dcl	    p_typed_vector_list_ptr
      225 			       ptr parameter;
      226       dcl	    p_tuple_count	       fixed bin (35) parameter;
      227       dcl	    p_code	       fixed bin (35) parameter;
      228 
      229 /* Automatic */
      230 
      231       dcl	    (local_typed_vector_list_ptr, local_typed_vector_array_ptr, local_element_id_list_ptr)
      232 			       ptr;
      233 
      234       dcl	    (caller_area_ptr, interval_element_id_list_ptr, old_search_specification_ptr, internal_specification_ptr,
      235 	    internal_cursor_ptr, internal_record_cursor_ptr, return_eil_or_tva_array_ptr, return_tva_array_ptr)
      236 			       ptr init (null);
      237 
      238       dcl	    (current_collection_id, previous_collection_id)
      239 			       bit (36) aligned init ("0"b);
      240 
      241       dcl	    (current_index_idx, record_id_idx, index_id_idx, element_idx, current_and_group_idx, and_group_idx,
      242 	    return_structure_idx)  fixed bin;
      243 
      244       dcl	    (maximum_number_of_tuples_to_accept, number_of_and_groups, number_of_tuples_accepted,
      245 	    number_of_tuples_accepted_by_this_and_group, reota_number_of_entries, rta_number_of_entries)
      246 			       fixed bin (35) init (0);
      247 
      248       dcl	    (all_desired_fields_are_in_index, get_id, get_typed_vector_list, get_tuple, get_tuples_and_ids, get_count,
      249 	    search_records, is_search_specification, is_numeric_specification, is_relative_specification, found_tuple)
      250 			       bit (1) aligned init ("0"b);
      251 
      252       dcl	    1 local_relation_cursor
      253 			       aligned like relation_cursor;
      254 
      255       dcl	    1 local_id_list,
      256 	      2 version	       fixed bin (35),
      257 	      2 number_of_ids      fixed bin (17),
      258 	      2 id	       (1) fixed bin (17);
      259 
      260       dcl	    1 local_return_eil_or_tva_entry
      261 			       (1) like return_eil_or_tva_array;
      262 						/* used if only 1 entry of return= needed */
      263 
      264       dcl	    1 local_return_tva_entry
      265 			       (1) like return_tva_array;
      266 						/* used if only 1 entry of return= needed */
      267 
      268 /* Based */
      269 
      270       dcl	    work_area	       area (1024) based (work_area_ptr);
      271       dcl	    caller_area	       area (1024) based (caller_area_ptr);
      272       dcl	    based_bit_36_aligned   bit (36) aligned based;
      273       dcl	    1 return_eil_or_tva_array
      274 			       (reota_number_of_entries) aligned based (return_eil_or_tva_array_ptr),
      275 	      2 flags	       unal,
      276 	        3 is_element_id_list
      277 			       bit (1) unal,
      278 	        3 mbz	       bit (71) unal,
      279 	      2 ptr	       ptr;
      280 
      281       dcl	    1 return_tva_array     (rta_number_of_entries) aligned based (return_tva_array_ptr),
      282 	      2 ptr	       ptr;
      283 
      284 /* Builtin */
      285 
      286       dcl	    (addr, hbound, max, min, null, unspec)
      287 			       builtin;
      288 
      289 /* Condition */
      290 
      291       dcl	    cleanup	       condition;
      292 
      293 /* Constant */
      294 
      295       dcl	    (
      296 	    myname	       init ("rlm_general_search") char (32) varying,
      297 	    BITS_PER_BYTE	       init (9) fixed bin,
      298 	    BITS_PER_WORD	       init (36) fixed bin,
      299 	    MAX_FB17_VALUE	       init (131071) fixed bin,
      300 	    MAXIMUM_FB35_VALUE     init (3e10) fixed bin (35),
      301 	    TUPLE_ID_FIELD_ID      init (-1) fixed bin (35)
      302 	    )		       internal static options (constant);
      303       dcl	    (
      304 	    IS_ELEMENT_ID_LIST     init ("1"b),
      305 	    IS_TYPED_VECTOR_ARRAY  init ("0"b),
      306 	    IS_RECORD_COLLECTION   init ("1"b),
      307 	    IS_INDEX_COLLECTION    init ("0"b),
      308 	    USE_RELATION_CURSOR    init ("1"b),
      309 	    USE_PREVIOUS_CURSOR    init ("0"b)
      310 	    )		       bit (1) aligned internal static options (constant);
      311 
      312 /* Entry */
      313 
      314       dcl	    get_dm_free_area_      entry () returns (ptr);
      315       dcl	    rlm_opening_info$get   entry (bit (36) aligned, ptr, fixed bin (35));
      316       dcl	    sub_err_	       entry () options (variable);
      317       dcl	    dm_vector_util_$copy_typed_vector
      318 			       entry (ptr, ptr, ptr, ptr, fixed bin (35));
      319 
      320 /* External */
      321 
      322       dcl	    (
      323 	    dm_error_$bad_rel_cursor_pos,
      324 	    dm_error_$index_not_in_relation,
      325 	    dm_error_$key_not_found,
      326 	    dm_error_$programming_error,
      327 	    dm_error_$record_not_found,
      328 	    dm_error_$rel_cursor_spec_mismatch,
      329 	    dm_error_$tuple_not_found,
      330 	    error_table_$unimplemented_version
      331 	    )		       fixed bin (35) ext;
      332 
      333 /* Static */
      334 
      335       dcl	    work_area_ptr	       ptr init (null) internal static;
      336 
      337 /* END OF DECLARATIONS */
      338 
      339 /* format: ^indblkcom,indcomtxt */
      340 
      341 get_list_by_spec:
      342    entry (p_relation_cursor_ptr, p_specification_ptr, p_id_list_ptr, p_caller_area_ptr, p_typed_vector_list_ptr, p_code);
      343       get_tuple = "1"b;
      344       get_typed_vector_list = "1"b;
      345       caller_area_ptr = p_caller_area_ptr;
      346       local_typed_vector_list_ptr = p_typed_vector_list_ptr;
      347       if p_id_list_ptr ^= null
      348       then call CHECK_VERSION_FB ("id_list", p_id_list_ptr -> id_list.version, (ID_LIST_VERSION_1));
      349       goto JOIN;
      350 
      351 get_array_by_spec:
      352    entry (p_relation_cursor_ptr, p_specification_ptr, p_id_list_ptr, p_caller_area_ptr, p_typed_vector_array_ptr, p_code);
      353       get_tuple = "1"b;
      354       get_typed_vector_list = "0"b;
      355       caller_area_ptr = p_caller_area_ptr;
      356       local_typed_vector_array_ptr = p_typed_vector_array_ptr;
      357       if p_id_list_ptr ^= null
      358       then call CHECK_VERSION_FB ("id_list", p_id_list_ptr -> id_list.version, (ID_LIST_VERSION_1));
      359       goto JOIN;
      360 
      361 
      362 get_id:
      363    entry (p_relation_cursor_ptr, p_specification_ptr, p_caller_area_ptr, p_element_id_list_ptr, p_code);
      364       get_id = "1"b;
      365       caller_area_ptr = p_caller_area_ptr;
      366       local_element_id_list_ptr = p_element_id_list_ptr;
      367       if p_element_id_list_ptr ^= null
      368       then call CHECK_VERSION_FB ("element_id_list", p_element_id_list_ptr -> element_id_list.version,
      369 	      ELEMENT_ID_LIST_VERSION_1);
      370       goto JOIN;
      371 
      372 get_count:
      373    entry (p_relation_cursor_ptr, p_specification_ptr, p_tuple_count, p_code);
      374       get_count = "1"b;
      375       caller_area_ptr = null;
      376       goto JOIN;
      377 
      378 get_list_and_ids:
      379    entry (p_relation_cursor_ptr, p_specification_ptr, p_id_list_ptr, p_caller_area_ptr, p_element_id_list_ptr,
      380         p_typed_vector_list_ptr, p_code);
      381 
      382       get_tuples_and_ids = "1"b;
      383       get_typed_vector_list = "1"b;
      384       caller_area_ptr = p_caller_area_ptr;
      385       local_typed_vector_list_ptr = p_typed_vector_list_ptr;
      386       local_element_id_list_ptr = p_element_id_list_ptr;
      387       if p_id_list_ptr ^= null
      388       then call CHECK_VERSION_FB ("id_list", p_id_list_ptr -> id_list.version, (ID_LIST_VERSION_1));
      389       if p_element_id_list_ptr ^= null
      390       then call CHECK_VERSION_FB ("element_id_list", p_element_id_list_ptr -> element_id_list.version,
      391 	      ELEMENT_ID_LIST_VERSION_1);
      392       goto JOIN;
      393 
      394 get_array_and_ids:
      395    entry (p_relation_cursor_ptr, p_specification_ptr, p_id_list_ptr, p_caller_area_ptr, p_element_id_list_ptr,
      396         p_typed_vector_array_ptr, p_code);
      397 
      398       get_tuples_and_ids = "1"b;
      399       get_typed_vector_list = "0"b;
      400       caller_area_ptr = p_caller_area_ptr;
      401       local_typed_vector_array_ptr = p_typed_vector_array_ptr;
      402       local_element_id_list_ptr = p_element_id_list_ptr;
      403       if p_id_list_ptr ^= null
      404       then call CHECK_VERSION_FB ("id_list", p_id_list_ptr -> id_list.version, (ID_LIST_VERSION_1));
      405       if p_element_id_list_ptr ^= null
      406       then call CHECK_VERSION_FB ("element_id_list", p_element_id_list_ptr -> element_id_list.version,
      407 	      ELEMENT_ID_LIST_VERSION_1);
      408 
      409       goto JOIN;
      410 
      411 JOIN:
      412       relation_cursor_ptr = p_relation_cursor_ptr;
      413       call CHECK_VERSION ("relation_cursor", relation_cursor.version, RELATION_CURSOR_VERSION_2);
      414       if work_area_ptr = null
      415       then work_area_ptr = get_dm_free_area_ ();
      416 
      417       id_list_ptr, element_id_list_ptr, typed_vector_array_ptr, relation_search_specification_ptr,
      418 	 search_specification_ptr, relation_numeric_specification_ptr, numeric_specification_ptr,
      419 	 internal_specification_ptr, internal_cursor_ptr = null;
      420 
      421       specification_head_ptr = p_specification_ptr;
      422       if specification_head_ptr ^= null
      423       then
      424          do;
      425 	  call CHECK_VERSION_FB ("specification", specification_head.version, SPECIFICATION_VERSION_4);
      426 
      427 
      428 	  if specification_head.type = ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
      429 	       | specification_head.type = RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
      430 	  then
      431 	     do;
      432 	        is_search_specification = "1"b;
      433 	        relation_search_specification_ptr = specification_head_ptr;
      434 	     end;
      435 	  else if specification_head.type = ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
      436 	       | specification_head.type = RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
      437 	  then
      438 	     do;
      439 	        is_numeric_specification = "1"b;
      440 	        relation_numeric_specification_ptr = specification_head_ptr;
      441 	     end;
      442 
      443 	  if specification_head.type = RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
      444 	       | specification_head.type = RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
      445 	  then is_relative_specification = "1"b;
      446          end;
      447 
      448 /**** Set up opening information structures. */
      449 
      450       call rlm_opening_info$get (relation_cursor.file_opening_id, relation_opening_info_ptr, p_code);
      451       if p_code ^= 0
      452       then call ERROR_RETURN (p_code);
      453 
      454       call CHECK_VERSION ("relation_opening_info", relation_opening_info.version, RELATION_OPENING_INFO_VERSION_2);
      455 
      456       relation_header_ptr = relation_opening_info.relation_header_ptr;
      457       call CHECK_VERSION ("relation_header", relation_header.version, RELATION_HEADER_VERSION_3);
      458 
      459       attribute_info_ptr = relation_opening_info.attribute_info_ptr;
      460       call CHECK_VERSION ("attribute_info", attribute_info.version, ATTRIBUTE_INFO_VERSION_1);
      461 
      462       index_attribute_map_ptr = relation_opening_info.index_attribute_map_ptr;
      463       call CHECK_VERSION ("index_attribute_map", index_attribute_map.version, INDEX_ATTRIBUTE_MAP_VERSION_2);
      464 
      465 /**** Set up current state of search. */
      466 
      467       if is_search_specification
      468       then number_of_and_groups = relation_search_specification.number_of_and_groups;
      469       else number_of_and_groups = 1;
      470 
      471       call CHECK_CURSOR_STATE (is_relative_specification, is_search_specification, is_numeric_specification,
      472 	 current_and_group_idx);			/* Also returns current_and_group_idx */
      473 
      474       on cleanup call FINISH ();
      475 
      476       call SETUP_INTERNAL_SPECIFICATION (is_search_specification, is_numeric_specification, is_relative_specification,
      477 	 internal_specification_ptr, maximum_number_of_tuples_to_accept);
      478 						/* Returns internal_specification_ptr, maximum...accept */
      479       call SETUP_RETURN_STRUCTURES (max (1, number_of_and_groups), (get_id | get_tuples_and_ids),
      480 	 (get_tuple | get_tuples_and_ids), return_eil_or_tva_array_ptr, return_tva_array_ptr);
      481 
      482 AND_GROUP_LOOP:
      483       do and_group_idx = current_and_group_idx to number_of_and_groups
      484 	 while (number_of_tuples_accepted < maximum_number_of_tuples_to_accept);
      485 
      486       /*** Satisfy the constraints of each and-group. */
      487 
      488          search_records = "0"b;
      489 
      490          previous_collection_id = current_collection_id;
      491          call SET_CURRENT_COLLECTION_ID (is_search_specification, is_numeric_specification, and_group_idx,
      492 	    current_collection_id, current_index_idx);	/* Set the collection_id from the specification. */
      493 
      494          if is_relative_specification & and_group_idx = current_and_group_idx
      495          then
      496 	  do;
      497 
      498 	  /*** This is the first and-group of a relative specification to be processed.
      499*	       Use the internal cursor already present in the relation_cursor. */
      500 
      501 	     call SETUP_INTERNAL_CURSOR (USE_RELATION_CURSOR, (current_index_idx = -1), current_collection_id, ("0"b),
      502 		internal_cursor_ptr);
      503 	  end;
      504          else
      505 	  do;
      506 
      507 	  /*** This is not a relative search, or this is not the first and-group processed.
      508*	       Setup a cursor and a specification to satisfy the constraints of this and-group.
      509*	       Re-use the previous internal cursor if the same collection is being searched. */
      510 
      511 	     call SETUP_INTERNAL_CURSOR (USE_PREVIOUS_CURSOR, (current_index_idx = -1), current_collection_id,
      512 		previous_collection_id, internal_cursor_ptr);
      513 						/* Get an index or record cursor for the current collection. */
      514 
      515 	     call SETUP_INTERNAL_SPECIFICATION_FOR_THIS_AND_GROUP (internal_specification_ptr, and_group_idx,
      516 		is_search_specification, is_numeric_specification,
      517 		(maximum_number_of_tuples_to_accept - number_of_tuples_accepted));
      518 						/* Convert this and-group into a proper internal specification. */
      519 	  end;
      520 
      521          if current_index_idx = -1
      522          then call SEARCH_RECORD_COLLECTION (found_tuple);
      523          else call SEARCH_INDEX (found_tuple);
      524 
      525          if found_tuple
      526          then
      527 RECORD_DATA:
      528 	  do;
      529 	     return_structure_idx = max (1, and_group_idx);
      530 
      531 	     if get_id
      532 	     then if search_records
      533 		then call RECORD_IDS_TO_RETURN (IS_ELEMENT_ID_LIST, return_structure_idx, element_id_list_ptr,
      534 			number_of_tuples_accepted_by_this_and_group);
      535 		else if get_tuples_and_ids
      536 		then call RECORD_IDS_TO_RETURN (IS_ELEMENT_ID_LIST, return_structure_idx, element_id_list_ptr,
      537 			number_of_tuples_accepted_by_this_and_group);
      538 		else call RECORD_IDS_TO_RETURN (IS_TYPED_VECTOR_ARRAY, return_structure_idx, typed_vector_array_ptr,
      539 			number_of_tuples_accepted_by_this_and_group);
      540 	     else if get_tuple
      541 	     then call RECORD_TUPLES_TO_RETURN (return_structure_idx, typed_vector_array_ptr,
      542 		     number_of_tuples_accepted_by_this_and_group);
      543 	     else if get_tuples_and_ids
      544 	     then
      545 	        do;
      546 		 if search_records
      547 		 then call RECORD_IDS_TO_RETURN (IS_ELEMENT_ID_LIST, return_structure_idx, element_id_list_ptr,
      548 			 number_of_tuples_accepted_by_this_and_group);
      549 		 else if get_tuples_and_ids
      550 		 then call RECORD_IDS_TO_RETURN (IS_ELEMENT_ID_LIST, return_structure_idx, element_id_list_ptr,
      551 			 number_of_tuples_accepted_by_this_and_group);
      552 		 else call RECORD_IDS_TO_RETURN (IS_TYPED_VECTOR_ARRAY, return_structure_idx, typed_vector_array_ptr,
      553 			 number_of_tuples_accepted_by_this_and_group);
      554 		 call RECORD_TUPLES_TO_RETURN (return_structure_idx, typed_vector_array_ptr,
      555 		      number_of_tuples_accepted_by_this_and_group);
      556 	        end;
      557 
      558 	     number_of_tuples_accepted = number_of_tuples_accepted + number_of_tuples_accepted_by_this_and_group;
      559 	  end RECORD_DATA;
      560 
      561       end AND_GROUP_LOOP;
      562 
      563       and_group_idx = and_group_idx - 1;
      564 
      565       if ^get_count
      566       then if number_of_tuples_accepted = 0
      567 	 then p_code = dm_error_$tuple_not_found;
      568 	 else
      569 	    do;
      570 	       if get_tuple | get_tuples_and_ids
      571 	       then if get_typed_vector_list
      572 		  then call RETURN_TYPED_VECTOR_LIST (number_of_tuples_accepted, local_typed_vector_list_ptr);
      573 		  else call RETURN_TYPED_VECTOR_ARRAY (number_of_tuples_accepted, local_typed_vector_array_ptr);
      574 
      575 	       if get_id | get_tuples_and_ids
      576 	       then call RETURN_ELEMENT_ID_LIST (number_of_tuples_accepted, local_element_id_list_ptr);
      577 
      578 	       call RESET_CURSOR (and_group_idx, current_collection_id, internal_specification_ptr, search_records,
      579 		  internal_cursor_ptr, is_search_specification);
      580 	    end;
      581 
      582       if get_typed_vector_list
      583       then p_typed_vector_list_ptr = local_typed_vector_list_ptr;
      584       if get_id | get_tuples_and_ids
      585       then p_element_id_list_ptr = local_element_id_list_ptr;
      586       if (get_tuple | get_tuples_and_ids) & ^get_typed_vector_list
      587       then p_typed_vector_array_ptr = local_typed_vector_array_ptr;
      588       call FINISH;
      589 RETURN:
      590       return;
      591 
      592 FINISH:
      593    proc;
      594 
      595       dcl	    f_tva_idx	       fixed bin;
      596 
      597       if get_typed_vector_list
      598       then if p_typed_vector_list_ptr = null & local_typed_vector_list_ptr ^= null
      599 	 then free local_typed_vector_list_ptr -> typed_vector_list;
      600       if get_id | get_tuples_and_ids
      601       then if p_element_id_list_ptr = null & local_element_id_list_ptr ^= null
      602 	 then free local_element_id_list_ptr -> element_id_list;
      603       if (get_tuple | get_tuples_and_ids) & ^get_typed_vector_list
      604       then if p_typed_vector_array_ptr = null & local_typed_vector_array_ptr ^= null
      605 	 then free local_typed_vector_array_ptr -> typed_vector_array;
      606 
      607       if typed_vector_array_ptr ^= null
      608       then call FREE_TYPED_VECTOR_ARRAY (typed_vector_array_ptr);
      609 
      610       if id_list_ptr ^= null & id_list_ptr ^= addr (local_id_list) & id_list_ptr ^= p_id_list_ptr
      611       then free id_list in (work_area);
      612 
      613       if element_id_list_ptr ^= null
      614       then free element_id_list in (work_area);
      615 
      616       if interval_element_id_list_ptr ^= null
      617       then free interval_element_id_list_ptr -> element_id_list in (work_area);
      618 
      619       if interval_list_ptr ^= null
      620       then call FREE_INTERVAL_LIST (interval_list_ptr);
      621 
      622       if relation_cursor.flags.current_state_is_consistent
      623       then
      624          do;
      625 	  if internal_specification_ptr ^= null
      626 	       & internal_specification_ptr ^= relation_cursor.current.specification_ptr
      627 	  then if is_numeric_specification
      628 	       then free internal_specification_ptr -> numeric_specification in (work_area);
      629 	       else free internal_specification_ptr -> search_specification;
      630 
      631 	  if internal_cursor_ptr ^= null & internal_cursor_ptr ^= relation_cursor.current.cursor_ptr
      632 	  then if current_collection_id = relation_header.record_collection_id
      633 	       then call record_manager_$destroy_cursor (internal_cursor_ptr, (0));
      634 	       else call index_manager_$destroy_cursor (internal_cursor_ptr, (0));
      635          end;
      636 
      637       if internal_record_cursor_ptr ^= null & internal_record_cursor_ptr ^= relation_cursor.current.cursor_ptr
      638       then call record_manager_$destroy_cursor (internal_record_cursor_ptr, (0));
      639 
      640       if return_tva_array_ptr ^= null
      641       then
      642          do;
      643 	  do f_tva_idx = 1 to hbound (return_tva_array, 1);
      644 	     if return_tva_array (f_tva_idx).ptr ^= null
      645 	     then call FREE_TYPED_VECTOR_ARRAY (return_tva_array (f_tva_idx).ptr);
      646 	  end;
      647 	  if return_tva_array_ptr ^= addr (local_return_tva_entry)
      648 	  then free return_tva_array in (work_area);
      649          end;
      650 
      651       if return_eil_or_tva_array_ptr ^= null
      652       then
      653          do;
      654 	  do f_tva_idx = 1 to hbound (return_eil_or_tva_array, 1);
      655 	     if return_eil_or_tva_array (f_tva_idx).ptr ^= null
      656 	     then if return_eil_or_tva_array (f_tva_idx).flags.is_element_id_list
      657 		then free return_eil_or_tva_array (f_tva_idx).ptr -> element_id_list;
      658 		else call FREE_TYPED_VECTOR_ARRAY (return_eil_or_tva_array (f_tva_idx).ptr);
      659 	  end;
      660 	  if return_eil_or_tva_array_ptr ^= addr (local_return_eil_or_tva_entry)
      661 	  then free return_eil_or_tva_array in (work_area);
      662 	  else return_eil_or_tva_array_ptr = null;
      663          end;
      664 
      665    end FINISH;
      666 
      667 ERROR_RETURN:
      668    proc (er_code);
      669 
      670       dcl	    er_code	       fixed bin (35);
      671 
      672       p_code = er_code;
      673       call FINISH;
      674       goto RETURN;
      675 
      676 
      677    end ERROR_RETURN;
      678 
      679 CHECK_VERSION:
      680    proc (cv_structure_name, cv_received_version, cv_expected_version);
      681       dcl	    cv_received_version    char (8) aligned;
      682       dcl	    cv_expected_version    char (8) aligned;
      683       dcl	    cv_structure_name      char (*);
      684 
      685       if cv_received_version ^= cv_expected_version
      686       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      687 	      "^/Expected version ^8a of the ^a structure.
      688 Received version ^8a instead.", cv_expected_version, cv_structure_name, cv_received_version);
      689 
      690    end CHECK_VERSION;
      691 
      692 
      693 CHECK_VERSION_FB:
      694    proc (cvf_structure_name, cvf_received_version, cvf_expected_version);
      695       dcl	    cvf_received_version   fixed bin (35);
      696       dcl	    cvf_expected_version   fixed bin (35);
      697       dcl	    cvf_structure_name     char (*);
      698 
      699       if cvf_received_version ^= cvf_expected_version
      700       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      701 	      "^/Expected version ^d of the ^a structure.
      702 Received version ^d instead.", cvf_expected_version, cvf_structure_name, cvf_received_version);
      703 
      704    end CHECK_VERSION_FB;
      705 
      706 CHECK_CURSOR_STATE:
      707    proc (ccs_is_relative_specification, ccs_is_search_specification, ccs_is_numeric_specification, ccs_and_group_idx);
      708 
      709       dcl	    ccs_and_group_idx      fixed bin;
      710       dcl	    ccs_is_relative_specification
      711 			       bit (1) aligned;
      712       dcl	    ccs_is_search_specification
      713 			       bit (1) aligned;
      714       dcl	    ccs_is_numeric_specification
      715 			       bit (1) aligned;
      716 
      717       call CHECK_VERSION ("relation_cursor", relation_cursor.version, RELATION_CURSOR_VERSION_2);
      718 
      719       if ccs_is_relative_specification
      720       then
      721 CCS_RELATIVE_CURSOR_CHECK:
      722          do;
      723 	  if ^relation_cursor.flags.current_state_is_consistent
      724 	  then call sub_err_ (dm_error_$bad_rel_cursor_pos, myname, ACTION_CANT_RESTART, null, 0,
      725 		  "^/The relative specification cannot be satisfied because the relation cursor^/does not completely describe a current position."
      726 		  );
      727 
      728 	  if relation_cursor.current.cursor_ptr = null
      729 	  then call sub_err_ (dm_error_$bad_rel_cursor_pos, myname, ACTION_CANT_RESTART, null, 0,
      730 		  "^/The relative specification cannot be satisfied because the relation cursor^/does not completely describe a current position."
      731 		  );
      732 
      733 	  if ccs_is_numeric_specification
      734 	  then
      735 	     do;
      736 	        if relation_cursor.current.specification_ptr = null
      737 	        then call sub_err_ (dm_error_$rel_cursor_spec_mismatch, myname, ACTION_CANT_RESTART, null, 0,
      738 		        "^/Expected a numeric specification; received a null specification.");
      739 	        if relation_cursor.current.specification_ptr -> specification_head.type
      740 		   ^= ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
      741 		   & relation_cursor.current.specification_ptr -> specification_head.type
      742 		   ^= RELATIVE_NUMERIC_SPECIFICATION_TYPE
      743 	        then call sub_err_ (dm_error_$rel_cursor_spec_mismatch, myname, ACTION_CANT_RESTART, null, 0,
      744 		        "^/Expected a search specification; received a numeric specification.");
      745 	        if relation_numeric_specification.collection_id ^= relation_cursor.current.collection_id
      746 	        then call sub_err_ (dm_error_$rel_cursor_spec_mismatch, myname, ACTION_CANT_RESTART, null, 0,
      747 		        "^/Expected a specification for collection ^.3bo; received one for ^.3bo.",
      748 		        relation_cursor.current.collection_id, relation_numeric_specification.collection_id);
      749 	     end;
      750 	  else if ccs_is_search_specification
      751 	  then
      752 	     do;
      753 	        if relation_cursor.current.specification_ptr = null
      754 	        then call sub_err_ (dm_error_$rel_cursor_spec_mismatch, myname, ACTION_CANT_RESTART, null, 0,
      755 		        "^/Expected a search specification; received a null specification.");
      756 	        if relation_cursor.current.specification_ptr -> specification_head.type
      757 		   ^= ABSOLUTE_SEARCH_SPECIFICATION_TYPE
      758 		   & relation_cursor.current.specification_ptr -> specification_head.type
      759 		   ^= RELATIVE_SEARCH_SPECIFICATION_TYPE
      760 	        then call sub_err_ (dm_error_$rel_cursor_spec_mismatch, myname, ACTION_CANT_RESTART, null, 0,
      761 		        "^/Expected a numeric specification; received a search specification.");
      762 	        if (relation_search_specification.number_of_and_groups > 0 & relation_cursor.current.and_group_idx < 1)
      763 		   | relation_cursor.current.and_group_idx > relation_search_specification.number_of_and_groups
      764 	        then call sub_err_ (dm_error_$rel_cursor_spec_mismatch, myname, ACTION_CANT_RESTART, null, 0,
      765 		        "^/The current and-group is ^d; the given search specification has^/^[no^s^;^d^] and-group^[s^].",
      766 		        relation_cursor.current.and_group_idx,
      767 		        (relation_search_specification.number_of_and_groups = 0),
      768 		        relation_search_specification.number_of_and_groups,
      769 		        (relation_search_specification.number_of_and_groups ^= 1));
      770 	        ;
      771 	        if relation_search_specification.and_group (relation_cursor.current.and_group_idx).flags
      772 		   .collection_id_supplied
      773 	        then if relation_search_specification.and_group (relation_cursor.current.and_group_idx)
      774 		        .search_collection_id ^= relation_cursor.current.collection_id
      775 		   then call sub_err_ (dm_error_$rel_cursor_spec_mismatch, myname, ACTION_CANT_RESTART, null, 0,
      776 			   "^/Expected a specification for collection ^.3bo; received one for ^.3bo.",
      777 			   relation_cursor.current.collection_id,
      778 			   relation_search_specification.and_group (relation_cursor.current.and_group_idx)
      779 			   .search_collection_id);
      780 		   else ;
      781 	        else if relation_cursor.current.collection_id ^= relation_header.record_collection_id
      782 	        then call sub_err_ (dm_error_$rel_cursor_spec_mismatch, myname, ACTION_CANT_RESTART, null, 0,
      783 		        "^/Expected a specification for collection ^.3bo; received on with no^/collection specified.",
      784 		        relation_cursor.current.collection_id);
      785 	     end;
      786 	  else if relation_cursor.current.specification_ptr ^= null
      787 	  then call sub_err_ (dm_error_$rel_cursor_spec_mismatch, myname, ACTION_CANT_RESTART, null, 0,
      788 		  "^/Expected a non-null specification; received a null specification.");
      789 
      790 	  ccs_and_group_idx = relation_cursor.current.and_group_idx;
      791          end CCS_RELATIVE_CURSOR_CHECK;
      792       else if ccs_is_search_specification
      793       then ccs_and_group_idx = min (1, relation_search_specification.number_of_and_groups);
      794       else ccs_and_group_idx = 1;
      795 
      796       return;
      797 
      798    end CHECK_CURSOR_STATE;
      799 
      800 CV_SEARCH_SPECIFICATION_FOR_INDEX:
      801    proc (cssfi_number_of_fields, cssfi_index_idx, cssfi_search_specification_ptr, cssfi_search_records);
      802 
      803 /* This subroutine converts the attribute_ids in the internal specification
      804*   into field_ids for the given index.  If an attribute is not a field in a
      805*   key, the attribute_id is negated.  This tells inex_manager_ to ignore
      806*   the constraint.  If constraint.value_field_id is -1 (indicating no
      807*   value_field_id) or if value_field_id and field_id are in the index, then
      808*   both are translated.  Otherwise, the value of value_field_id is left
      809*   unchanged and the value of field_id is negated.  Reference is made to
      810*   and_group (1) since an internal_specification contains only one and group.
      811*
      812*   As a side-effect, this subroutine also
      813*   determines if the search can be satisfied entirely by searching the index,
      814*   or if it is necessry to also search the records. */
      815 
      816       dcl	    cssfi_number_of_fields fixed bin parameter;
      817       dcl	    cssfi_index_idx	       fixed bin parameter;
      818       dcl	    cssfi_search_specification_ptr
      819 			       ptr parameter;
      820       dcl	    cssfi_search_records   bit (1) aligned parameter;
      821 
      822       dcl	    cssfi_field_map	       (cssfi_number_of_fields) fixed bin;
      823       dcl	    (cssfi_field_id, cssfi_value_field_id, cssfi_temp_value_field_id)
      824 			       fixed bin init (0);
      825       dcl	    (cssfi_field_idx, cssfi_constraint_idx, cssfi_index_field_idx)
      826 			       fixed bin;
      827 
      828       search_specification_ptr = cssfi_search_specification_ptr;
      829 
      830       do cssfi_field_idx = 1 to cssfi_number_of_fields;
      831          cssfi_field_map (cssfi_field_idx) = -cssfi_field_idx;
      832       end;
      833 
      834       do cssfi_index_field_idx = 1 to index_attribute_map.index (cssfi_index_idx).number_of_attributes;
      835          cssfi_field_map (index_attribute_map.index (cssfi_index_idx).attribute_id (cssfi_index_field_idx)) =
      836 	    cssfi_index_field_idx;
      837       end;
      838 
      839       cssfi_search_records = "0"b;
      840 
      841       do cssfi_constraint_idx = 1 to search_specification.and_group (1).number_of_constraints;
      842          cssfi_field_id = cssfi_field_map (search_specification.and_group (1).constraint (cssfi_constraint_idx).field_id);
      843          cssfi_value_field_id = search_specification.and_group (1).constraint (cssfi_constraint_idx).value_field_id;
      844 
      845          if cssfi_value_field_id <= 0
      846          then
      847 	  do;
      848 	     search_specification.and_group (1).constraint (cssfi_constraint_idx).field_id = cssfi_field_id;
      849 	     if cssfi_field_id < 0
      850 	     then cssfi_search_records = "1"b;
      851 	  end;
      852          else
      853 	  do;
      854 	     cssfi_temp_value_field_id = cssfi_field_map (cssfi_value_field_id);
      855 	     if cssfi_temp_value_field_id > 0 & cssfi_field_id > 0
      856 	     then
      857 	        do;
      858 		 search_specification.and_group (1).constraint (cssfi_constraint_idx).field_id = cssfi_field_id;
      859 		 search_specification.and_group (1).constraint (cssfi_constraint_idx).value_field_id =
      860 		      cssfi_temp_value_field_id;
      861 	        end;
      862 	     else
      863 	        do;
      864 		 search_specification.and_group (1).constraint (cssfi_constraint_idx).field_id =
      865 		      -(search_specification.and_group (1).constraint (cssfi_constraint_idx).field_id);
      866 		 cssfi_search_records = "1"b;
      867 	        end;
      868 	  end;
      869       end;
      870 
      871    end CV_SEARCH_SPECIFICATION_FOR_INDEX;
      872 
      873 CV_SEARCH_SPECIFICATION_FOR_RECORDS:
      874    proc (cssfr_search_specification_ptr);
      875 
      876 /* This routine converts the field_ids in the internal specification into
      877*   field_ids of record.  This routine is called to undo the effects of
      878*   CV_SEARCH_SPECIFICATION_FOR_INDEX by simply negating the field_ids.
      879*   On input, the constraints which were not satisfied by the index search
      880*   have negative field_ids; those that were have positive field_ids.
      881*   This routine switches the sign of the field_ids so that those constraints
      882*   that were satisfied by the index search will be ignored, and those that
      883*   were previously ignored will be satisfied.  value_field_ids are not changed
      884*   because value_field_ids for un-satisfied constraints were never negated. */
      885 
      886       dcl	    cssfr_search_specification_ptr
      887 			       ptr parameter;
      888 
      889       dcl	    cssfr_constraint_idx   fixed bin;
      890 
      891 INVERT_SEARCH_SPECIFICATION:
      892    entry (cssfr_search_specification_ptr);
      893 
      894       do cssfr_constraint_idx = 1
      895 	 to cssfr_search_specification_ptr -> search_specification.and_group (1).number_of_constraints;
      896          cssfr_search_specification_ptr -> search_specification.and_group (1).constraint (cssfr_constraint_idx).field_id =
      897 	    -cssfr_search_specification_ptr
      898 	    -> search_specification.and_group (1).constraint (cssfr_constraint_idx).field_id;
      899       end;
      900 
      901    end CV_SEARCH_SPECIFICATION_FOR_RECORDS;
      902 
      903 COPY_VALUE:
      904    proc (cv_arg_descriptor_ptr, cv_source_value_ptr, cv_target_value_ptr);
      905 
      906       dcl	    cv_arg_descriptor_ptr  ptr parameter;
      907       dcl	    cv_source_value_ptr    ptr parameter;
      908       dcl	    cv_target_value_ptr    ptr parameter;
      909       dcl	    cv_value_string_size   fixed bin (35) init (0);
      910       dcl	    cv_value_string	       bit (cv_value_string_size) based;
      911       dcl	    cv_based_real_fix_bin_1u
      912 			       fixed bin (35) unal based;
      913       dcl	    cv_code	       fixed bin (35) init (0);
      914 
      915       dcl	    data_format_util_$get_data_bit_length
      916 			       entry (bit (36) aligned, fixed bin (35), fixed bin (35));
      917 
      918       arg_descriptor_ptr = cv_arg_descriptor_ptr;
      919       if arg_descriptor.type = varying_char_dtype
      920       then cv_value_string_size = cv_source_value_ptr -> cv_based_real_fix_bin_1u * BITS_PER_BYTE + BITS_PER_WORD;
      921       else if arg_descriptor.type = varying_bit_dtype
      922       then cv_value_string_size = cv_source_value_ptr -> cv_based_real_fix_bin_1u + BITS_PER_WORD;
      923       else call data_format_util_$get_data_bit_length (unspec (arg_descriptor), cv_value_string_size, cv_code);
      924       if cv_code ^= 0
      925       then call ERROR_RETURN (cv_code);
      926       alloc cv_value_string in (relation_cursor.work_area_ptr -> work_area) set (cv_target_value_ptr);
      927       cv_target_value_ptr -> cv_value_string = cv_source_value_ptr -> cv_value_string;
      928 
      929       return;
      930 
      931 
  1     1 /* BEGIN INCLUDE FILE ... std_descriptor_types.incl.pl1 */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
  1     6*     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1208):
  1     7*     Added pascal_string_type_dtype descriptor type.  Its number is 87.
  1     8*     Objects of this type are PASCAL string types.
  1     9*  2) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  1    10*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  1    11*     Added the new C types.
  1    12*                                                   END HISTORY COMMENTS */
  1    13 
  1    14 /* This include file defines mnemonic names for the Multics
  1    15*   standard descriptor types, using both pl1 and cobol terminology.
  1    16*   PG 780613
  1    17*   JRD 790530
  1    18*   JRD 791016
  1    19*   MBW 810731
  1    20*   TGO 830614 Add hex types.
  1    21*   Modified June 83 JMAthane to add PASCAL data types
  1    22*   TGO 840120 Add float dec extended and generic, float binary generic
  1    23**/
  1    24 
  1    25      dcl	   (real_fix_bin_1_dtype  init (1),
  1    26 	   real_fix_bin_2_dtype   init (2),
  1    27 	   real_flt_bin_1_dtype   init (3),
  1    28 	   real_flt_bin_2_dtype   init (4),
  1    29 	   cplx_fix_bin_1_dtype   init (5),
  1    30 	   cplx_fix_bin_2_dtype   init (6),
  1    31 	   cplx_flt_bin_1_dtype   init (7),
  1    32 	   cplx_flt_bin_2_dtype   init (8),
  1    33 	   real_fix_dec_9bit_ls_dtype init (9),
  1    34 	   real_flt_dec_9bit_dtype init (10),
  1    35 	   cplx_fix_dec_9bit_ls_dtype init (11),
  1    36 	   cplx_flt_dec_9bit_dtype init (12),
  1    37 	   pointer_dtype	      init (13),
  1    38 	   offset_dtype	      init (14),
  1    39 	   label_dtype	      init (15),
  1    40 	   entry_dtype	      init (16),
  1    41 	   structure_dtype	      init (17),
  1    42 	   area_dtype	      init (18),
  1    43 	   bit_dtype	      init (19),
  1    44 	   varying_bit_dtype      init (20),
  1    45 	   char_dtype	      init (21),
  1    46 	   varying_char_dtype     init (22),
  1    47 	   file_dtype	      init (23),
  1    48 	   real_fix_dec_9bit_ls_overp_dtype init (29),
  1    49 	   real_fix_dec_9bit_ts_overp_dtype init (30),
  1    50 	   real_fix_bin_1_uns_dtype init (33),
  1    51 	   real_fix_bin_2_uns_dtype init (34),
  1    52 	   real_fix_dec_9bit_uns_dtype init (35),
  1    53 	   real_fix_dec_9bit_ts_dtype init (36),
  1    54 	   real_fix_dec_4bit_uns_dtype init (38),	/* digit-aligned */
  1    55 	   real_fix_dec_4bit_ts_dtype init (39),	/* byte-aligned */
  1    56 	   real_fix_dec_4bit_bytealigned_uns_dtype init (40), /* COBOL */
  1    57 	   real_fix_dec_4bit_ls_dtype init (41),	/* digit-aligned */
  1    58 	   real_flt_dec_4bit_dtype init (42),		/* digit-aligned */
  1    59 	   real_fix_dec_4bit_bytealigned_ls_dtype init (43),
  1    60 	   real_flt_dec_4bit_bytealigned_dtype init (44),
  1    61 	   cplx_fix_dec_4bit_bytealigned_ls_dtype init (45),
  1    62 	   cplx_flt_dec_4bit_bytealigned_dtype init (46),
  1    63 	   real_flt_hex_1_dtype   init (47),
  1    64 	   real_flt_hex_2_dtype   init (48),
  1    65 	   cplx_flt_hex_1_dtype   init (49),
  1    66 	   cplx_flt_hex_2_dtype   init (50),
  1    67 	   c_typeref_dtype        init (54),
  1    68 	   c_enum_dtype           init (55),
  1    69              c_enum_const_dtype     init (56),
  1    70 	   c_union_dtype          init (57),
  1    71 	   algol68_straight_dtype init (59),
  1    72 	   algol68_format_dtype   init (60),
  1    73 	   algol68_array_descriptor_dtype init (61),
  1    74 	   algol68_union_dtype    init (62),
  1    75 
  1    76 	   cobol_comp_6_dtype     init (1),
  1    77 	   cobol_comp_7_dtype     init (1),
  1    78 	   cobol_display_ls_dtype init (9),
  1    79 	   cobol_structure_dtype  init (17),
  1    80 	   cobol_char_string_dtype init (21),
  1    81 	   cobol_display_ls_overp_dtype init (29),
  1    82 	   cobol_display_ts_overp_dtype init (30),
  1    83 	   cobol_display_uns_dtype init (35),
  1    84 	   cobol_display_ts_dtype init (36),
  1    85 	   cobol_comp_8_uns_dtype init (38),		/* digit aligned */
  1    86 	   cobol_comp_5_ts_dtype  init (39),		/* byte aligned */
  1    87 	   cobol_comp_5_uns_dtype init (40),
  1    88 	   cobol_comp_8_ls_dtype  init (41),		/* digit aligned */
  1    89 	   real_flt_dec_extended_dtype init (81),	/* 9-bit exponent */
  1    90 	   cplx_flt_dec_extended_dtype init (82),	/* 9-bit exponent */
  1    91 	   real_flt_dec_generic_dtype init (83),	/* generic float decimal */
  1    92 	   cplx_flt_dec_generic_dtype init (84),
  1    93 	   real_flt_bin_generic_dtype init (85),	/* generic float binary */
  1    94 	   cplx_flt_bin_generic_dtype init (86)) fixed bin internal static options (constant);
  1    95 
  1    96      dcl	   (ft_integer_dtype      init (1),
  1    97 	   ft_real_dtype	      init (3),
  1    98 	   ft_double_dtype	      init (4),
  1    99 	   ft_complex_dtype	      init (7),
  1   100 	   ft_complex_double_dtype init (8),
  1   101 	   ft_external_dtype      init (16),
  1   102 	   ft_logical_dtype	      init (19),
  1   103 	   ft_char_dtype	      init (21),
  1   104 	   ft_hex_real_dtype      init (47),
  1   105 	   ft_hex_double_dtype    init (48),
  1   106 	   ft_hex_complex_dtype   init (49),
  1   107 	   ft_hex_complex_double_dtype init (50)
  1   108 	   )		      fixed bin internal static options (constant);
  1   109 
  1   110      dcl	   (algol68_short_int_dtype init (1),
  1   111 	   algol68_int_dtype      init (1),
  1   112 	   algol68_long_int_dtype init (2),
  1   113 	   algol68_real_dtype     init (3),
  1   114 	   algol68_long_real_dtype init (4),
  1   115 	   algol68_compl_dtype    init (7),
  1   116 	   algol68_long_compl_dtype init (8),
  1   117 	   algol68_bits_dtype     init (19),
  1   118 	   algol68_bool_dtype     init (19),
  1   119 	   algol68_char_dtype     init (21),
  1   120 	   algol68_byte_dtype     init (21),
  1   121 	   algol68_struct_struct_char_dtype init (22),
  1   122 	   algol68_struct_struct_bool_dtype init (20)
  1   123 	   )		      fixed bin internal static options (constant);
  1   124 
  1   125      dcl	   (label_constant_runtime_dtype init (24),
  1   126 	   int_entry_runtime_dtype init (25),
  1   127 	   ext_entry_runtime_dtype init (26),
  1   128 	   ext_procedure_runtime_dtype init (27),
  1   129 	   picture_runtime_dtype  init (63)
  1   130 	   )		      fixed bin internal static options (constant);
  1   131 
  1   132      dcl	   (pascal_integer_dtype  init (1),
  1   133 	   pascal_real_dtype      init (4),
  1   134 	   pascal_label_dtype     init (24),
  1   135 	   pascal_internal_procedure_dtype init (25),
  1   136 	   pascal_exportable_procedure_dtype init (26),
  1   137 	   pascal_imported_procedure_dtype init (27),
  1   138 	   pascal_typed_pointer_type_dtype init (64),
  1   139 	   pascal_char_dtype      init (65),
  1   140 	   pascal_boolean_dtype   init (66),
  1   141 	   pascal_record_file_type_dtype init (67),
  1   142 	   pascal_record_type_dtype init (68),
  1   143 	   pascal_set_dtype	      init (69),
  1   144 	   pascal_enumerated_type_dtype init (70),
  1   145 	   pascal_enumerated_type_element_dtype init (71),
  1   146 	   pascal_enumerated_type_instance_dtype init (72),
  1   147 	   pascal_user_defined_type_dtype init (73),
  1   148 	   pascal_user_defined_type_instance_dtype init (74),
  1   149 	   pascal_text_file_dtype init (75),
  1   150 	   pascal_procedure_type_dtype init (76),
  1   151 	   pascal_variable_formal_parameter_dtype init (77),
  1   152 	   pascal_value_formal_parameter_dtype init (78),
  1   153 	   pascal_entry_formal_parameter_dtype init (79),
  1   154 	   pascal_parameter_procedure_dtype init (80),
  1   155 	   pascal_string_type_dtype init (87)) fixed bin int static options (constant);
  1   156 
  1   157 
  1   158 /* END INCLUDE FILE ... std_descriptor_types.incl.pl1 */
      932 
  2     1 /* BEGIN INCLUDE FILE ... arg_descriptor.incl.pl1
  2     2*
  2     3*   James R. Davis 1 Mar 79 */
  2     4 /* Modified June 83 JMAthane for extended arg descriptor format */
  2     5 
  2     6      dcl	   1 arg_descriptor	      based (arg_descriptor_ptr) aligned,
  2     7 	     2 flag	      bit (1) unal,
  2     8 	     2 type	      fixed bin (6) unsigned unal,
  2     9 	     2 packed	      bit (1) unal,
  2    10 	     2 number_dims	      fixed bin (4) unsigned unal,
  2    11 	     2 size	      fixed bin (24) unsigned unal;
  2    12 
  2    13      dcl	   1 fixed_arg_descriptor based (arg_descriptor_ptr) aligned,
  2    14 	     2 flag	      bit (1) unal,
  2    15 	     2 type	      fixed bin (6) unsigned unal,
  2    16 	     2 packed	      bit (1) unal,
  2    17 	     2 number_dims	      fixed bin (4) unsigned unal,
  2    18 	     2 scale	      fixed bin (11) unal,
  2    19 	     2 precision	      fixed bin (12) unsigned unal;
  2    20 
  2    21      dcl	   1 extended_arg_descriptor based (arg_descriptor_ptr) aligned,
  2    22 	     2 flag	      bit (1) unal,		/* = "1"b */
  2    23 	     2 type	      fixed bin (6) unsigned unal, /* = 58 */
  2    24 	     2 packed	      bit (1) unal,		/* significant if number_dims ^= 0 */
  2    25 	     2 number_dims	      fixed (4) unsigned unal,/* number of variable dimensions */
  2    26 	     2 size	      bit (24) unal,
  2    27 	     2 dims	      (0 refer (extended_arg_descriptor.number_dims)), /* part referenced by called generated code */
  2    28 	       3 low	      fixed bin (35),
  2    29 	       3 high	      fixed bin (35),
  2    30 	       3 multiplier	      fixed bin (35),	/* in bits if packed, in words if not */
  2    31 	     2 real_type	      fixed bin (18) unsigned unal,
  2    32 	     2 type_offset	      fixed bin (18) unsigned unal; /* offset rel to symbol tree to symbol node for type, if any */
  2    33 
  2    34      dcl	   arg_descriptor_ptr     ptr;
  2    35 
  2    36      dcl	   extended_arg_type      fixed bin init (58);
  2    37 
  2    38 /* END INCLUDE file .... arg_descriptor.incl.pl1  */
      933 
      934 
      935    end COPY_VALUE;
      936 
      937 FREE_INTERVAL_LIST:
      938    proc (fil_p_interval_list_ptr);
      939 
      940       dcl	    fil_p_interval_list_ptr
      941 			       ptr;
      942       dcl	    fil_interval_idx       fixed bin;
      943 
      944       if fil_p_interval_list_ptr ^= null
      945       then
      946          do;
      947 	  do fil_interval_idx = 1 to hbound (fil_p_interval_list_ptr -> interval_list.interval, 1);
      948 	     if fil_p_interval_list_ptr -> interval_list.interval (fil_interval_idx).and_group_id_list_ptr ^= null
      949 	     then free fil_p_interval_list_ptr -> interval_list.interval (fil_interval_idx).and_group_id_list_ptr
      950 		     -> id_list;
      951 	  end;
      952 	  free fil_p_interval_list_ptr -> interval_list;
      953          end;
      954 
      955       return;
      956 
      957    end FREE_INTERVAL_LIST;
      958 
      959 FREE_SPECIFICATION:
      960    proc (fs_specification_ptr);
      961 
      962       dcl	    fs_specification_ptr   ptr parameter;
      963       dcl	    fs_and_group_idx       fixed bin init (-1);
      964       dcl	    fs_constraint_idx      fixed bin init (-1);
      965       dcl	    fs_dummy_value	       bit (1) based;
      966 
      967       if fs_specification_ptr -> specification_head.type = ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
      968 	 | fs_specification_ptr -> specification_head.type = RELATIVE_NUMERIC_SPECIFICATION_TYPE
      969       then free fs_specification_ptr -> numeric_specification;
      970       else if fs_specification_ptr -> specification_head.type = ABSOLUTE_SEARCH_SPECIFICATION_TYPE
      971 	 | fs_specification_ptr -> specification_head.type = RELATIVE_SEARCH_SPECIFICATION_TYPE
      972       then
      973          do;
      974 	  do fs_and_group_idx = 1 to fs_specification_ptr -> search_specification.number_of_and_groups;
      975 	     do fs_constraint_idx = 1
      976 		to fs_specification_ptr -> search_specification.and_group (fs_and_group_idx).number_of_constraints;
      977 	        free fs_specification_ptr
      978 		   -> search_specification.and_group (fs_and_group_idx).constraint (fs_constraint_idx).value_ptr
      979 		   -> fs_dummy_value;
      980 	     end;
      981 	  end;
      982          end;
      983       return;
      984 
      985    end FREE_SPECIFICATION;
      986 
      987 FREE_TYPED_VECTOR_ARRAY:
      988    proc (ftva_typed_vector_array_ptr);
      989 
      990       dcl	    ftva_typed_vector_array_ptr
      991 			       ptr parameter;
      992       dcl	    ftva_vector_ptr	       ptr;
      993       dcl	    ftva_vector_idx	       fixed bin;
      994       dcl	    ftva_value_idx	       fixed bin;
      995       dcl	    ftva_dummy_value       bit (1) based;
      996 
      997       if ftva_typed_vector_array_ptr ^= null ()
      998       then
      999          do;
     1000 	  do ftva_vector_idx = 1 to ftva_typed_vector_array_ptr -> typed_vector_array.number_of_vectors;
     1001 	     if ftva_typed_vector_array_ptr -> typed_vector_array.vector_slot (ftva_vector_idx) ^= null
     1002 	     then
     1003 	        do;
     1004 		 ftva_vector_ptr = ftva_typed_vector_array_ptr -> typed_vector_array.vector_slot (ftva_vector_idx);
     1005 		 if ftva_vector_ptr -> simple_typed_vector.type = SIMPLE_TYPED_VECTOR_TYPE
     1006 		 then
     1007 		    do;
     1008 		       do ftva_value_idx = 1 to ftva_vector_ptr -> simple_typed_vector.number_of_dimensions;
     1009 			if ftva_vector_ptr -> simple_typed_vector.value_ptr (ftva_value_idx) ^= null
     1010 			then
     1011 			   do;
     1012 			      free ftva_vector_ptr -> simple_typed_vector.value_ptr (ftva_value_idx)
     1013 				 -> ftva_dummy_value;
     1014 			      ftva_vector_ptr -> simple_typed_vector.value_ptr (ftva_value_idx) = null;
     1015 			   end;
     1016 		       end;
     1017 
     1018 		       free ftva_vector_ptr -> simple_typed_vector;
     1019 		       ftva_typed_vector_array_ptr -> typed_vector_array.vector_slot (ftva_vector_idx) = null;
     1020 		    end;
     1021 	        end;
     1022 	  end;
     1023 
     1024 	  free ftva_typed_vector_array_ptr -> typed_vector_array;
     1025 	  ftva_typed_vector_array_ptr = null;
     1026 
     1027 	  return;
     1028          end;
     1029 
     1030    end FREE_TYPED_VECTOR_ARRAY;
     1031 
     1032 RECORD_IDS_TO_RETURN:
     1033    proc (ritr_is_element_id_list, ritr_and_group_idx, ritr_eil_or_tva_ptr, ritr_number_of_tuple_ids);
     1034 
     1035 /* This subroutine records the location of a data structure containing
     1036*   the tuple ids found by a particular and-group. The data structure is
     1037*   either an element_id_list or a typed_vector_array containing simple_typed_vectors of a single dimension. */
     1038 
     1039       dcl	    ritr_is_element_id_list
     1040 			       bit (1) aligned;
     1041       dcl	    ritr_and_group_idx     fixed bin;
     1042       dcl	    ritr_eil_or_tva_ptr    ptr;
     1043       dcl	    ritr_number_of_tuple_ids
     1044 			       fixed bin (35);
     1045 
     1046       return_eil_or_tva_array (ritr_and_group_idx).flags.is_element_id_list = ritr_is_element_id_list;
     1047       return_eil_or_tva_array (ritr_and_group_idx).ptr = ritr_eil_or_tva_ptr;
     1048 
     1049       if ritr_is_element_id_list
     1050       then ritr_number_of_tuple_ids = ritr_eil_or_tva_ptr -> element_id_list.number_of_elements;
     1051       else ritr_number_of_tuple_ids = ritr_eil_or_tva_ptr -> typed_vector_array.number_of_vectors;
     1052 
     1053       ritr_eil_or_tva_ptr = null;
     1054 
     1055       return;
     1056 
     1057    end RECORD_IDS_TO_RETURN;
     1058 
     1059 RECORD_TUPLES_TO_RETURN:
     1060    proc (rttr_and_group_idx, rttr_tva_ptr, rttr_number_of_tuples);
     1061 
     1062 /* This subroutine records the location of typed_vector_array containing
     1063*   the tuples found by a particular and-group. */
     1064 
     1065       dcl	    rttr_and_group_idx     fixed bin;
     1066       dcl	    rttr_tva_ptr	       ptr;
     1067       dcl	    rttr_number_of_tuples  fixed bin (35);
     1068 
     1069 
     1070       return_tva_array (rttr_and_group_idx).ptr = rttr_tva_ptr;
     1071 
     1072       rttr_number_of_tuples = rttr_tva_ptr -> typed_vector_array.number_of_vectors;
     1073 
     1074       rttr_tva_ptr = null;
     1075 
     1076       return;
     1077 
     1078    end RECORD_TUPLES_TO_RETURN;
     1079 
     1080 RESET_CURSOR:
     1081    proc (rc_and_group_idx, rc_collection_id, rc_specification_ptr, rc_search_records, rc_cursor_ptr,
     1082         rc_is_search_specification);
     1083 
     1084 /* This subroutine destroys information kept to maintain the previous
     1085*   current state, replacing with information about the new current state.
     1086**/
     1087 
     1088       dcl	    rc_and_group_idx       fixed bin parameter;
     1089       dcl	    rc_collection_id       bit (36) aligned parameter;
     1090       dcl	    rc_specification_ptr   ptr parameter;
     1091       dcl	    rc_search_records      bit (1) aligned parameter;
     1092       dcl	    rc_cursor_ptr	       ptr parameter;
     1093       dcl	    rc_is_search_specification
     1094 			       bit (1) aligned parameter;
     1095       dcl	    rc_constraint_idx      fixed bin init (-1);
     1096       dcl	    rc_value_ptr	       ptr init (null);
     1097       dcl	    rc_code	       fixed bin (35) init (0);
     1098 
     1099       relation_cursor.flags.current_state_is_consistent = "0"b;
     1100 
     1101       if relation_cursor.current.cursor_ptr ^= null
     1102       then if relation_cursor.current.cursor_ptr ^= rc_cursor_ptr
     1103 	 then if relation_cursor.current.collection_id = relation_header.record_collection_id
     1104 	      then call record_manager_$destroy_cursor (relation_cursor.current.cursor_ptr, rc_code);
     1105 	      else call index_manager_$destroy_cursor (relation_cursor.current.cursor_ptr, rc_code);
     1106 
     1107       if relation_cursor.current.specification_ptr ^= null
     1108       then if rc_specification_ptr ^= relation_cursor.current.specification_ptr
     1109 	 then call FREE_SPECIFICATION (relation_cursor.current.specification_ptr);
     1110 
     1111       relation_cursor.current.and_group_idx = rc_and_group_idx;
     1112       relation_cursor.current.collection_id = rc_collection_id;
     1113       relation_cursor.current.specification_ptr = rc_specification_ptr;
     1114       relation_cursor.current.search_index_and_record_collection = rc_search_records;
     1115       relation_cursor.current.cursor_ptr = rc_cursor_ptr;
     1116 
     1117       if rc_specification_ptr ^= null & rc_is_search_specification & rc_and_group_idx > 0
     1118       then
     1119          do;
     1120 
     1121          /*** Copy values from relation_search_specification to internal specification. */
     1122 
     1123 	  do rc_constraint_idx = 1 to relation_search_specification.and_group (rc_and_group_idx).number_of_constraints;
     1124 	     call COPY_VALUE (
     1125 		addr (attribute_info
     1126 		.
     1127 		attribute (relation_search_specification.and_group (rc_and_group_idx).constraint (rc_constraint_idx)
     1128 		.field_id).descriptor),
     1129 		relation_search_specification.and_group (rc_and_group_idx).constraint (rc_constraint_idx).value_ptr,
     1130 		rc_value_ptr);
     1131 	     rc_specification_ptr -> search_specification.and_group (1).constraint (rc_constraint_idx).value_ptr =
     1132 		rc_value_ptr;
     1133 	  end;
     1134          end;
     1135 
     1136       rc_cursor_ptr, rc_specification_ptr = null;
     1137 
     1138       if rc_code = 0
     1139       then relation_cursor.flags.current_state_is_consistent = "1"b;
     1140 
     1141       return;
     1142 
     1143    end RESET_CURSOR;
     1144 
     1145 SEARCH_INDEX:
     1146    proc (si_p_found_tuple);
     1147 
     1148       dcl	    si_p_found_tuple       bit (1) aligned parameter;
     1149       dcl	    si_code	       fixed bin (35) init (0);
     1150 
     1151    /*** An index collection was specified. As much of the internal specification as possible
     1152*        will be satisfied by searching the index. If fields are constrained which
     1153*        are not in the index, then the record collection will also be searched. */
     1154 
     1155 
     1156 
     1157       if is_search_specification & internal_specification_ptr ^= null
     1158       then if is_relative_specification & and_group_idx = current_and_group_idx
     1159 	 then
     1160 	    do;
     1161 	       search_records = relation_cursor.current.search_index_and_record_collection;
     1162 	       if search_records
     1163 	       then call INVERT_SEARCH_SPECIFICATION (internal_specification_ptr);
     1164 						/* The search_spec was set up for use with */
     1165 						/* the record_collection by the previous */
     1166 						/* invocation.  Inverting the field ids */
     1167 						/* make the ones for the indexed fields */
     1168 						/* positive and the ones for the record */
     1169 						/* collection negative. */
     1170 	    end;
     1171 	 else call CV_SEARCH_SPECIFICATION_FOR_INDEX ((attribute_info.number_of_attributes), current_index_idx,
     1172 		 internal_specification_ptr, search_records);
     1173 
     1174 
     1175       call TRANSLATE_ID_LIST ();			/* Sets id_list_ptr and all_desired_fields_are_in_index. */
     1176 
     1177       if get_count & ^search_records
     1178       then
     1179          do;
     1180 	  call index_manager_$get_key_count_by_spec (internal_specification_ptr, internal_cursor_ptr, p_tuple_count,
     1181 	       si_code);
     1182 	  if si_code ^= 0
     1183 	  then call SI_ERROR_RETURN (si_code, dm_error_$key_not_found);
     1184          end;
     1185       else
     1186          do;
     1187 	  call index_manager_$get_key (internal_specification_ptr, id_list_ptr, work_area_ptr, internal_cursor_ptr,
     1188 	       typed_vector_array_ptr, interval_list_ptr, si_code);
     1189 	  if si_code ^= 0
     1190 	  then call SI_ERROR_RETURN (si_code, dm_error_$key_not_found);
     1191 	  call CHECK_VERSION ("interval_list", interval_list.version, INTERVAL_LIST_VERSION_2);
     1192          end;
     1193 
     1194       if search_records
     1195       then
     1196 SEARCH_RECORDS:
     1197          do;
     1198 
     1199          /*** The index search did not satisfy all of the constraints of the specification.
     1200*	    Set up an interval_element_id_list and use it in searching the tuple records
     1201*	    associated with the keys which were selected by the index search. */
     1202 
     1203 	  call CV_SEARCH_SPECIFICATION_FOR_RECORDS (internal_specification_ptr);
     1204 	  eil_number_of_elements = typed_vector_array.number_of_vectors;
     1205 	  element_id_list_ptr = null;
     1206 	  alloc element_id_list in (work_area) set (interval_element_id_list_ptr);
     1207 	  interval_element_id_list_ptr -> element_id_list.version = ELEMENT_ID_LIST_VERSION_1;
     1208 
     1209 	  do element_idx = 1 to typed_vector_array.number_of_vectors;
     1210 	     interval_element_id_list_ptr -> element_id_list.id (element_idx) =
     1211 		typed_vector_array.vector_slot (element_idx) -> simple_typed_vector.value_ptr (1)
     1212 		-> based_bit_36_aligned;
     1213 	  end;
     1214 
     1215 	  call FREE_TYPED_VECTOR_ARRAY (typed_vector_array_ptr);
     1216 
     1217 	  if internal_record_cursor_ptr = null
     1218 	  then call SETUP_INTERNAL_CURSOR (USE_PREVIOUS_CURSOR, IS_RECORD_COLLECTION,
     1219 		  relation_header.record_collection_id, ("0"b), internal_record_cursor_ptr);
     1220 
     1221 	  if get_id
     1222 	  then call record_manager_$get_record_ids_by_interval (interval_element_id_list_ptr,
     1223 		  internal_specification_ptr, interval_list_ptr, work_area_ptr, internal_record_cursor_ptr,
     1224 		  element_id_list_ptr, si_code);
     1225 	  else if get_tuple
     1226 	  then call record_manager_$get_records_by_interval (interval_element_id_list_ptr, p_id_list_ptr,
     1227 		  internal_specification_ptr, interval_list_ptr, work_area_ptr, (TYPED_VECTOR_ARRAY_VERSION_2),
     1228 		  internal_record_cursor_ptr, typed_vector_array_ptr, si_code);
     1229 	  else if get_tuples_and_ids
     1230 	  then call record_manager_$get_records_and_ids_by_interval (interval_element_id_list_ptr, p_id_list_ptr,
     1231 		  internal_specification_ptr, interval_list_ptr, work_area_ptr, (TYPED_VECTOR_ARRAY_VERSION_2),
     1232 		  internal_record_cursor_ptr, element_id_list_ptr, typed_vector_array_ptr, si_code);
     1233 	  else call record_manager_$get_record_count_by_interval (interval_element_id_list_ptr,
     1234 		  internal_specification_ptr, interval_list_ptr, internal_record_cursor_ptr, p_tuple_count, si_code);
     1235 
     1236 	  if si_code ^= 0
     1237 	  then call SI_ERROR_RETURN (si_code, dm_error_$record_not_found);
     1238 	  free interval_element_id_list_ptr -> element_id_list;
     1239          end SEARCH_RECORDS;
     1240       else if ^all_desired_fields_are_in_index & (get_tuple | get_tuples_and_ids)
     1241       then
     1242 GET_DATA_FROM_RECORD_COLLECTION:
     1243          do;
     1244 	  eil_number_of_elements = typed_vector_array.number_of_vectors;
     1245 	  alloc element_id_list in (work_area);
     1246 	  element_id_list.version = ELEMENT_ID_LIST_VERSION_1;
     1247 
     1248 	  do element_idx = 1 to typed_vector_array.number_of_vectors;
     1249 	     element_id_list.id (element_idx) =
     1250 		typed_vector_array.vector_slot (element_idx) -> simple_typed_vector.value_ptr (1)
     1251 		-> based_bit_36_aligned;
     1252 	  end;
     1253 
     1254 	  call FREE_TYPED_VECTOR_ARRAY (typed_vector_array_ptr);
     1255 
     1256 	  call record_manager_$get_records_by_id_list (element_id_list_ptr, p_id_list_ptr, work_area_ptr,
     1257 	       (relation_opening_info.per_process.record_cursor_ptr), typed_vector_array_ptr, si_code);
     1258 	  if si_code ^= 0
     1259 	  then call ERROR_RETURN (si_code);
     1260 
     1261          end GET_DATA_FROM_RECORD_COLLECTION;
     1262 
     1263 SI_MAIN_RETURN:
     1264       si_p_found_tuple = (si_code = 0);
     1265 
     1266       call FREE_INTERVAL_LIST (interval_list_ptr);
     1267 
     1268       return;
     1269 
     1270 SI_ERROR_RETURN:
     1271    proc (ser_code, ser_non_fatal_code);
     1272 
     1273       dcl	    (ser_code, ser_non_fatal_code)
     1274 			       fixed bin (35);
     1275 
     1276       if ser_code ^= ser_non_fatal_code & ser_code ^= 0
     1277       then call ERROR_RETURN (ser_code);
     1278 
     1279       goto SI_MAIN_RETURN;
     1280 
     1281    end SI_ERROR_RETURN;
     1282 
     1283    end SEARCH_INDEX;
     1284 
     1285 SEARCH_RECORD_COLLECTION:
     1286    proc (src_p_found_tuple);
     1287 
     1288       dcl	    src_p_found_tuple      bit (1) aligned parameter;
     1289       dcl	    src_code	       fixed bin (35) init (0);
     1290 
     1291    /*** The caller specified the record collection should be used to
     1292*        satisfy the constraints of this and group.
     1293*        All searching will be done on the record collection directly. */
     1294 
     1295       search_records = "1"b;
     1296 
     1297       if get_id
     1298       then call record_manager_$get_record_ids_by_spec (internal_specification_ptr, work_area_ptr, internal_cursor_ptr,
     1299 	      element_id_list_ptr, src_code);
     1300       else if get_tuple
     1301       then call record_manager_$get_records_by_spec (internal_specification_ptr, p_id_list_ptr, work_area_ptr,
     1302 	      internal_cursor_ptr, typed_vector_array_ptr, src_code);
     1303       else if get_tuples_and_ids
     1304       then call record_manager_$get_records_and_ids_by_spec (internal_specification_ptr, p_id_list_ptr, work_area_ptr,
     1305 	      internal_cursor_ptr, element_id_list_ptr, typed_vector_array_ptr, src_code);
     1306 
     1307       else if get_count
     1308       then call record_manager_$get_record_count (internal_specification_ptr, internal_cursor_ptr, p_tuple_count,
     1309 	      src_code);
     1310       if src_code ^= 0
     1311       then if src_code ^= dm_error_$record_not_found
     1312 	 then call ERROR_RETURN (src_code);
     1313 
     1314       src_p_found_tuple = (src_code = 0);
     1315       return;
     1316    end SEARCH_RECORD_COLLECTION;
     1317 
     1318 SET_CURRENT_COLLECTION_ID:
     1319    proc (scci_is_search_specification, scci_is_numeric_specification, scci_and_group_idx, scci_collection_id,
     1320         scci_index_idx);
     1321 
     1322 /* This subroutine returns the value of the collection_id specified by the caller
     1323*   for this and-group or for this numeric specification, or, if none
     1324*   is specified, returns the record_collection_id. The element in the index attribute
     1325*   map containing the index collection, or -1 if collection is not an index, is returned.
     1326**/
     1327 
     1328       dcl	    scci_is_search_specification
     1329 			       bit (1) aligned;
     1330       dcl	    scci_is_numeric_specification
     1331 			       bit (1) aligned;
     1332       dcl	    scci_and_group_idx     fixed bin;
     1333       dcl	    scci_collection_id     bit (36) aligned;
     1334       dcl	    scci_index_idx	       fixed bin;
     1335 
     1336       if scci_is_search_specification
     1337       then if relation_search_specification.number_of_and_groups <= 0
     1338 	 then scci_collection_id = relation_header.record_collection_id;
     1339 	 else if relation_search_specification.and_group (scci_and_group_idx).flags.collection_id_supplied
     1340 	 then scci_collection_id = relation_search_specification.and_group (scci_and_group_idx).search_collection_id;
     1341 	 else scci_collection_id = relation_header.record_collection_id;
     1342       else if scci_is_numeric_specification
     1343       then scci_collection_id = relation_numeric_specification.collection_id;
     1344       else scci_collection_id = relation_header.record_collection_id;
     1345 
     1346       if scci_collection_id = relation_header.record_collection_id
     1347       then scci_index_idx = -1;
     1348       else
     1349          do;
     1350 	  do scci_index_idx = 1 to hbound (index_attribute_map.index, 1)
     1351 	       while (index_attribute_map.index (scci_index_idx).collection_id ^= scci_collection_id);
     1352 	  end;
     1353 	  if scci_index_idx > hbound (index_attribute_map.index, 1)
     1354 	  then call ERROR_RETURN (dm_error_$index_not_in_relation);
     1355          end;
     1356 
     1357       return;
     1358 
     1359    end SET_CURRENT_COLLECTION_ID;
     1360 
     1361 SETUP_INTERNAL_CURSOR:
     1362    proc (sic_from_relation_cursor, sic_is_record_collection, sic_collection_id, sic_previous_collection_id,
     1363         sic_cursor_ptr);
     1364 
     1365 /* This subroutine function creates a cursor for the given collection, returning
     1366*   a pointer to the cursor. */
     1367 
     1368       dcl	    (sic_collection_id, sic_previous_collection_id)
     1369 			       bit (36) aligned;
     1370       dcl	    (sic_from_relation_cursor, sic_is_record_collection)
     1371 			       bit (1) aligned;
     1372       dcl	    sic_code	       fixed bin (35);
     1373       dcl	    sic_cursor_ptr	       ptr;
     1374 
     1375       if sic_from_relation_cursor
     1376       then
     1377          do;
     1378 
     1379          /*** If the relation_cursor already has a cursor for this collection, use it
     1380*	    rather than create a new one. */
     1381 
     1382 	  if relation_cursor.current.collection_id = sic_collection_id & relation_cursor.current.cursor_ptr ^= null
     1383 	  then sic_cursor_ptr = relation_cursor.current.cursor_ptr;
     1384 	  else
     1385 	     do;
     1386 	        if relation_cursor.current.collection_id ^= sic_collection_id
     1387 	        then call DESTROY_CURSOR;
     1388 	        call CREATE_CURSOR;
     1389 	     end;
     1390          end;
     1391       else
     1392          do;
     1393 	  if sic_cursor_ptr = null
     1394 	  then call CREATE_CURSOR;
     1395 	  else if sic_collection_id ^= sic_previous_collection_id
     1396 	  then
     1397 	     do;
     1398 	        call DESTROY_CURSOR;
     1399 	        call CREATE_CURSOR;
     1400 	     end;
     1401          end;
     1402 
     1403       return;					/* Effective end of SETUP_INTERNAL_CURSOR */
     1404 
     1405 
     1406 
     1407 /**** Subroutines of SETUP_INTERNAL_CURSOR follow. ****/
     1408 
     1409 /**** Begin subroutines of SETUP_INTERNAL_CURSOR. ****/
     1410 
     1411 CREATE_CURSOR:
     1412    proc ();
     1413 
     1414       if sic_is_record_collection
     1415       then call record_manager_$create_cursor (relation_cursor.file_opening_id, sic_collection_id,
     1416 	      relation_cursor.work_area_ptr, sic_cursor_ptr, sic_code);
     1417       else call index_manager_$create_cursor (relation_cursor.file_opening_id, sic_collection_id,
     1418 	      relation_cursor.work_area_ptr, sic_cursor_ptr, sic_code);
     1419       if sic_code ^= 0
     1420       then call ERROR_RETURN (sic_code);
     1421 
     1422    end CREATE_CURSOR;
     1423 
     1424 DESTROY_CURSOR:
     1425    proc ();
     1426 
     1427       if sic_is_record_collection
     1428       then call record_manager_$destroy_cursor (sic_cursor_ptr, sic_code);
     1429       else call index_manager_$destroy_cursor (sic_cursor_ptr, sic_code);
     1430       if sic_code ^= 0
     1431       then call ERROR_RETURN (sic_code);
     1432 
     1433    end DESTROY_CURSOR;
     1434 
     1435 /**** End of subroutines of SETUP_INTERNAL_CURSOR. ****/
     1436 
     1437    end SETUP_INTERNAL_CURSOR;
     1438 
     1439 SETUP_INTERNAL_SPECIFICATION:
     1440    proc (sis_is_search_specification, sis_is_numeric_specification, sis_is_relative_specification, sis_specification_ptr,
     1441         sis_maximum_number_of_tuples_to_accept);
     1442 
     1443       dcl	    sis_is_search_specification
     1444 			       bit (1) aligned;
     1445       dcl	    sis_is_numeric_specification
     1446 			       bit (1) aligned;
     1447       dcl	    sis_is_relative_specification
     1448 			       bit (1) aligned;
     1449       dcl	    sis_specification_ptr  ptr;
     1450       dcl	    sis_maximum_number_of_tuples_to_accept
     1451 			       fixed bin (35);
     1452 
     1453       if sis_is_relative_specification
     1454       then
     1455          do;
     1456 	  sis_specification_ptr = relation_cursor.current.specification_ptr;
     1457 
     1458 	  if sis_is_numeric_specification
     1459 	  then
     1460 	     do;
     1461 	        sis_specification_ptr -> numeric_specification.type = RELATIVE_NUMERIC_SPECIFICATION_TYPE;
     1462 	        sis_specification_ptr -> numeric_specification.range_size = relation_numeric_specification.range_size;
     1463 	        sis_specification_ptr -> numeric_specification.position_number =
     1464 		   relation_numeric_specification.position_number;
     1465 	     end;
     1466 	  else if sis_is_search_specification
     1467 	  then
     1468 	     do;
     1469 	        sis_specification_ptr -> search_specification.head.type = RELATIVE_SEARCH_SPECIFICATION_TYPE;
     1470 	        sis_specification_ptr -> search_specification.range.size = relation_search_specification.range.size;
     1471 	     end;
     1472          end;
     1473       else if sis_is_search_specification
     1474       then
     1475          do;
     1476 	  ss_number_of_and_groups = max (0, min (1, relation_search_specification.number_of_and_groups));
     1477 	  ss_maximum_number_of_constraints = relation_search_specification.maximum_number_of_constraints;
     1478 	  alloc search_specification in (relation_cursor.work_area_ptr -> work_area) set (sis_specification_ptr);
     1479 	  sis_specification_ptr -> search_specification.head = relation_search_specification.head;
     1480 	  sis_specification_ptr -> search_specification.head.type = ABSOLUTE_SEARCH_SPECIFICATION_TYPE;
     1481 	  sis_specification_ptr -> search_specification.range = relation_search_specification.range;
     1482 
     1483 	  if sis_specification_ptr -> search_specification.number_of_and_groups > 0
     1484 	  then sis_specification_ptr -> search_specification.and_group (1).number_of_constraints = 0;
     1485          end;
     1486       else if sis_is_numeric_specification
     1487       then
     1488          do;
     1489 	  alloc numeric_specification in (relation_cursor.work_area_ptr -> work_area) set (sis_specification_ptr);
     1490 	  sis_specification_ptr -> numeric_specification.head = relation_numeric_specification.head;
     1491 	  sis_specification_ptr -> numeric_specification.head.type = ABSOLUTE_NUMERIC_SPECIFICATION_TYPE;
     1492 	  sis_specification_ptr -> numeric_specification.position_number =
     1493 	       relation_numeric_specification.position_number;
     1494 	  sis_specification_ptr -> numeric_specification.range_size = relation_numeric_specification.range_size;
     1495 	  sis_specification_ptr -> numeric_specification.pad = "0"b;
     1496          end;
     1497       else sis_specification_ptr = null;
     1498 
     1499       if sis_is_search_specification
     1500       then if relation_search_specification.range.type ^= ALL_RANGE_TYPE
     1501 	 then sis_maximum_number_of_tuples_to_accept = relation_search_specification.range.size;
     1502 	 else sis_maximum_number_of_tuples_to_accept = MAXIMUM_FB35_VALUE;
     1503       else if sis_is_numeric_specification
     1504       then sis_maximum_number_of_tuples_to_accept = relation_numeric_specification.range_size;
     1505       else sis_maximum_number_of_tuples_to_accept = MAXIMUM_FB35_VALUE;
     1506 
     1507       return;
     1508 
     1509    end SETUP_INTERNAL_SPECIFICATION;
     1510 
     1511 SETUP_INTERNAL_SPECIFICATION_FOR_THIS_AND_GROUP:
     1512    proc (sisftag_specification_ptr, sisftag_and_group_idx, sisftag_is_search_specification,
     1513         sisftag_is_numeric_specification, sisftag_maximum_number_of_tuples_to_accept);
     1514 
     1515       dcl	    sisftag_specification_ptr
     1516 			       ptr;
     1517       dcl	    sisftag_is_search_specification
     1518 			       bit (1) aligned;
     1519       dcl	    sisftag_is_numeric_specification
     1520 			       bit (1) aligned;
     1521       dcl	    sisftag_maximum_number_of_tuples_to_accept
     1522 			       fixed bin (35);
     1523       dcl	    sisftag_total_number_of_constraints
     1524 			       fixed bin init (0);
     1525       dcl	    (sisftag_constraint_idx, sisftag_and_group_idx)
     1526 			       fixed bin;
     1527 
     1528       if sisftag_is_numeric_specification
     1529       then sisftag_specification_ptr -> numeric_specification.range_size =
     1530 	      min (MAX_FB17_VALUE, sisftag_maximum_number_of_tuples_to_accept);
     1531 
     1532       else if sisftag_is_search_specification
     1533       then
     1534          do;
     1535 	  sisftag_specification_ptr -> search_specification.range.size =
     1536 	       min (MAX_FB17_VALUE, sisftag_maximum_number_of_tuples_to_accept);
     1537 
     1538 	  if sisftag_specification_ptr -> search_specification.number_of_and_groups > 0
     1539 	  then
     1540 	     do;
     1541 	        sisftag_specification_ptr -> search_specification.and_group (1).number_of_constraints =
     1542 		   relation_search_specification.and_group (sisftag_and_group_idx).number_of_constraints;
     1543 	        do sisftag_constraint_idx = 1
     1544 		   to relation_search_specification.and_group (sisftag_and_group_idx).number_of_constraints;
     1545 
     1546 	        /*** Copy the constraints for this and group from the relation specification to
     1547*		   the internal specification. */
     1548 
     1549 		 sisftag_specification_ptr -> search_specification.and_group (1).constraint (sisftag_constraint_idx) =
     1550 		      relation_search_specification.and_group (sisftag_and_group_idx)
     1551 		      .constraint (sisftag_constraint_idx);
     1552 	        end;
     1553 
     1554 	     end;
     1555          end;
     1556 
     1557       return;
     1558 
     1559 
     1560    end SETUP_INTERNAL_SPECIFICATION_FOR_THIS_AND_GROUP;
     1561 
     1562 SETUP_RETURN_STRUCTURES:
     1563    proc (srs_maximum_number_of_return_structures, srs_setup_for_ids, srs_setup_for_tuples,
     1564         srs_return_eil_or_tva_array_ptr, srs_return_tva_array_ptr);
     1565 
     1566 /* This subroutine sets up two arrays of pointers to return structures,
     1567*   element_id_lists or typed_vector_arrays, for those entries that return
     1568*   such data.  In each array, there is one entry for each and group.
     1569*   If more than one and-group is specified, the array is allocated. If only one
     1570*   and-group is specified, or if a numeric or null specification is specified,
     1571*   an automatic one element array is used. */
     1572 
     1573       dcl	    srs_maximum_number_of_return_structures
     1574 			       fixed bin (35);
     1575       dcl	    srs_setup_for_ids      bit (1) aligned;
     1576       dcl	    srs_setup_for_tuples   bit (1) aligned;
     1577       dcl	    srs_return_eil_or_tva_array_ptr
     1578 			       ptr;
     1579       dcl	    srs_return_tva_array_ptr
     1580 			       ptr;
     1581 
     1582       if srs_setup_for_ids
     1583       then
     1584          do;
     1585 	  reota_number_of_entries = max (1, srs_maximum_number_of_return_structures);
     1586 
     1587 	  if srs_maximum_number_of_return_structures <= 1
     1588 	  then srs_return_eil_or_tva_array_ptr = addr (local_return_eil_or_tva_entry);
     1589 	  else
     1590 	     do;
     1591 	        alloc return_eil_or_tva_array in (work_area);
     1592 	        srs_return_eil_or_tva_array_ptr = return_eil_or_tva_array_ptr;
     1593 	     end;
     1594 
     1595 	  unspec (srs_return_eil_or_tva_array_ptr -> return_eil_or_tva_array) = ""b;
     1596 	  srs_return_eil_or_tva_array_ptr -> return_eil_or_tva_array (*).flags.is_element_id_list = "0"b;
     1597 	  srs_return_eil_or_tva_array_ptr -> return_eil_or_tva_array (*).flags.mbz = "0"b;
     1598 	  srs_return_eil_or_tva_array_ptr -> return_eil_or_tva_array (*).ptr = null;
     1599          end;
     1600 
     1601       if srs_setup_for_tuples
     1602       then
     1603          do;
     1604 	  rta_number_of_entries = max (1, srs_maximum_number_of_return_structures);
     1605 
     1606 	  if srs_maximum_number_of_return_structures <= 1
     1607 	  then srs_return_tva_array_ptr = addr (local_return_tva_entry);
     1608 	  else
     1609 	     do;
     1610 	        alloc return_tva_array in (work_area);
     1611 	        srs_return_tva_array_ptr = return_tva_array_ptr;
     1612 	     end;
     1613 
     1614 	  unspec (srs_return_tva_array_ptr -> return_tva_array) = ""b;
     1615 	  srs_return_tva_array_ptr -> return_tva_array (*).ptr = null;
     1616          end;
     1617 
     1618       return;
     1619 
     1620    end SETUP_RETURN_STRUCTURES;
     1621 
     1622 TRANSLATE_ID_LIST:
     1623    proc ();
     1624 
     1625 
     1626       if get_id | get_tuples_and_ids | (get_count & search_records)
     1627       then
     1628          do;
     1629 
     1630          /*** Tuple_ids are needed to return to the caller or to be used in
     1631*	    getting tuples from the record collection. Get the tuple_ids of keys
     1632*	    which match the specification in a typed_vector_array. This typed_vector_array
     1633*	    must be converted to an element_id_list later. */
     1634 
     1635 	  all_desired_fields_are_in_index = "0"b;
     1636 	  local_id_list.id (1) = index_attribute_map.index (current_index_idx).number_of_attributes + 1;
     1637 	  local_id_list.version = ID_LIST_VERSION_1;
     1638 	  local_id_list.number_of_ids = 1;
     1639 	  id_list_ptr = addr (local_id_list);
     1640          end;
     1641       else if get_tuple
     1642       then
     1643          do;
     1644 	  all_desired_fields_are_in_index = "0"b;
     1645 	  id_list_ptr = null;
     1646 	  if ^search_records
     1647 	  then
     1648 	     do;
     1649 
     1650 	     /*** The specification can be satisfied completely by searching the index.
     1651*		Determine if all fields to be returned to the caller are also in the index,
     1652*		and build an id_list that identifies the desired fields in the key (the fields
     1653*		in the key may have different ids than the fields in the tuple). */
     1654 
     1655 	        all_desired_fields_are_in_index = "1"b;
     1656 
     1657 	        if p_id_list_ptr ^= null
     1658 	        then
     1659 TRANSLATE_SPECIFIED_ID_LIST:				/* Translate the tuple field ids to key field ids. */
     1660 		 do;
     1661 		    il_number_of_ids = p_id_list_ptr -> id_list.number_of_ids;
     1662 		    alloc id_list in (work_area);
     1663 		    id_list.version = ID_LIST_VERSION_1;
     1664 
     1665 RECORD_ID_LOOP:
     1666 		    do record_id_idx = 1 to id_list.number_of_ids while (all_desired_fields_are_in_index);
     1667 
     1668 		       if p_id_list_ptr -> id_list.id (record_id_idx) = TUPLE_ID_FIELD_ID
     1669 		       then id_list.id (record_id_idx) =
     1670 			       index_attribute_map.index (current_index_idx).number_of_attributes + 1;
     1671 		       else
     1672 			do;
     1673 INDEX_ID_LOOP:
     1674 			   do index_id_idx = 1
     1675 			        to index_attribute_map.index (current_index_idx).number_of_attributes
     1676 			        while (p_id_list_ptr -> id_list.id (record_id_idx)
     1677 			        ^= index_attribute_map.index (current_index_idx).attribute_id (index_id_idx));
     1678 			   end INDEX_ID_LOOP;
     1679 			   if index_id_idx <= index_attribute_map.index (current_index_idx).number_of_attributes
     1680 			   then id_list.id (record_id_idx) = index_id_idx;
     1681 			   else all_desired_fields_are_in_index = "0"b;
     1682 						/* This tuple field is not present in the key. */
     1683 			end;
     1684 		    end RECORD_ID_LOOP;
     1685 
     1686 		 end TRANSLATE_SPECIFIED_ID_LIST;
     1687 	        else if attribute_info.number_of_attributes
     1688 		   = index_attribute_map.index (current_index_idx).number_of_attributes
     1689 	        then
     1690 TRANSLATE_DEFAULT_ID_LIST:				/* The key contains all tuple fields. */
     1691 		 do;
     1692 		    all_desired_fields_are_in_index = "1"b;
     1693 		    il_number_of_ids = attribute_info.number_of_attributes;
     1694 		    alloc id_list in (work_area);
     1695 		    id_list.version = ID_LIST_VERSION_1;
     1696 		    do index_id_idx = 1 to il_number_of_ids;
     1697 		       id_list.id (index_attribute_map.index (current_index_idx).attribute_id (index_id_idx)) =
     1698 			  index_id_idx;
     1699 		    end;
     1700 
     1701 		 end TRANSLATE_DEFAULT_ID_LIST;
     1702 	        else
     1703 		 do;
     1704 		    id_list_ptr = null;
     1705 		    all_desired_fields_are_in_index = "0"b;
     1706 		 end;
     1707 	     end;
     1708 	  if ^all_desired_fields_are_in_index
     1709 	  then
     1710 	     do;
     1711 
     1712 	     /*** There exists at least one desired field which is not in the index.
     1713*		Getting this field will require getting the tuple record from the record collection,
     1714*		so there is no need to get fields from the index.
     1715*		Set up an id_list which will retrieve only the tuple_id field from keys.
     1716*		Free any id_list that was created
     1717*		previously, as it won't be needed after all. */
     1718 
     1719 	        local_id_list.id (1) = index_attribute_map.index (current_index_idx).number_of_attributes + 1;
     1720 	        local_id_list.number_of_ids = 1;
     1721 	        local_id_list.version = ID_LIST_VERSION_1;
     1722 	        if id_list_ptr ^= null
     1723 	        then free id_list in (work_area);
     1724 	        id_list_ptr = addr (local_id_list);
     1725 	     end;
     1726          end;
     1727 
     1728       return;
     1729 
     1730    end TRANSLATE_ID_LIST;
     1731 
     1732 RETURN_TYPED_VECTOR_LIST:
     1733    proc (rtvl_number_of_vectors, rtvl_typed_vector_list_ptr);
     1734 
     1735 
     1736    /*** The caller expects the tuples to be returned in a typed_vector_list.
     1737*        Convert the typed_vector_array in the work_area to a typed_vector_list
     1738*        in the caller_area. */
     1739 
     1740       dcl	    rtvl_number_of_vectors fixed bin (35);	/* total number of vectors in return typed_vector_list */
     1741       dcl	    rtvl_typed_vector_list_ptr
     1742 			       ptr;
     1743       dcl	    rtvl_code	       fixed bin (35);
     1744       dcl	    rtvl_tva_idx	       fixed bin;		/* index into return_tva_array */
     1745       dcl	    rtvl_vector_idx	       fixed bin;		/* index into current typed_vector_array */
     1746       dcl	    rtvl_return_vector_idx fixed bin;		/* index into typed_vector_list */
     1747 
     1748       if rtvl_number_of_vectors <= 0
     1749       then return;
     1750 
     1751       if rtvl_typed_vector_list_ptr ^= null
     1752       then
     1753          do;
     1754 
     1755          /*** The caller provided a typed_vector_list. Do not allocate a new one. */
     1756 
     1757 	  typed_vector_list_ptr = rtvl_typed_vector_list_ptr;
     1758          end;
     1759       else
     1760          do;
     1761 
     1762          /*** The caller did not provide a typed_vector_list.
     1763*	    Allocate a new one. */
     1764 
     1765 	  tvl_maximum_number_of_vectors = rtvl_number_of_vectors;
     1766 	  alloc typed_vector_list in (caller_area);	/* freed in FINISH if necessary */
     1767 	  typed_vector_list.version = TYPED_VECTOR_LIST_VERSION_1;
     1768 	  typed_vector_list.pad = 0;
     1769          end;
     1770 
     1771       typed_vector_list.number_of_vectors = rtvl_number_of_vectors;
     1772 
     1773       rtvl_return_vector_idx = 1;
     1774       do rtvl_tva_idx = 1 to hbound (return_tva_array, 1) while (rtvl_return_vector_idx <= rtvl_number_of_vectors);
     1775 
     1776          if return_tva_array (rtvl_tva_idx).ptr ^= null
     1777          then
     1778 	  do;
     1779 	     do rtvl_vector_idx = 1 to return_tva_array (rtvl_tva_idx).ptr -> typed_vector_array.number_of_vectors;
     1780 
     1781 	        call dm_vector_util_$copy_typed_vector (caller_area_ptr, return_tva_array (rtvl_tva_idx).ptr,
     1782 		   return_tva_array (rtvl_tva_idx).ptr -> typed_vector_array.vector_slot (rtvl_vector_idx),
     1783 		   typed_vector_list.vector_ptr (rtvl_return_vector_idx), rtvl_code);
     1784 	        if rtvl_code ^= 0
     1785 	        then call ERROR_RETURN (rtvl_code);
     1786 	        rtvl_return_vector_idx = rtvl_return_vector_idx + 1;
     1787 	     end;
     1788 
     1789 	     call FREE_TYPED_VECTOR_ARRAY (return_tva_array (rtvl_tva_idx).ptr);
     1790 
     1791 	  end;
     1792       end;
     1793 
     1794       rtvl_typed_vector_list_ptr = typed_vector_list_ptr;
     1795 
     1796       return;
     1797 
     1798    end RETURN_TYPED_VECTOR_LIST;
     1799 
     1800 RETURN_TYPED_VECTOR_ARRAY:
     1801    proc (rtva_number_of_vectors, rtva_typed_vector_array_ptr);
     1802 
     1803 /* Allocate a typed_vector_array in the caller's area and copy the
     1804*   vectors in the various temporary typed_vector_arrays from the
     1805*   work_area to the caller's area. */
     1806 
     1807       dcl	    rtva_number_of_vectors fixed bin (35);
     1808       dcl	    rtva_typed_vector_array_ptr
     1809 			       ptr;
     1810       dcl	    dm_vector_util_$init_typed_vector_array
     1811 			       entry options (variable);
     1812       dcl	    rtva_code	       fixed bin (35) init (0);
     1813       dcl	    (
     1814 	    rtva_dimension_idx,			/* index into dimension_table */
     1815 	    rtva_return_vector_idx,			/* index into return typed_vector_array */
     1816 	    rtva_tva_idx,				/* index into return_tva_array */
     1817 	    rtva_vector_idx				/* index into current typed_vector_array */
     1818 	    )		       fixed bin;
     1819 
     1820       if rtva_number_of_vectors <= 0
     1821       then return;
     1822 
     1823       do rtva_tva_idx = 1 to hbound (return_tva_array, 1) while (return_tva_array (rtva_tva_idx).ptr = null);
     1824       end;
     1825       if rtva_tva_idx > hbound (return_tva_array, 1)
     1826       then call sub_err_ (dm_error_$programming_error, myname, ACTION_CANT_RESTART, null, 0,
     1827 	      "There are ^d tuples to return, but no vector structure has been allocated.", rtva_number_of_vectors);
     1828 
     1829       if rtva_typed_vector_array_ptr ^= null
     1830       then
     1831         /*** The caller supplied a typed_vector_array. Do not allocate a new one. */
     1832 	 rtva_typed_vector_array_ptr -> typed_vector_array.number_of_vectors = rtva_number_of_vectors;
     1833       else
     1834          do;
     1835 
     1836          /*** The caller did not provide a typed_vector_array. Allocate one in the
     1837*	    caller_area. */
     1838 
     1839 	  call dm_vector_util_$init_typed_vector_array (caller_area_ptr, rtva_number_of_vectors,
     1840 	       return_tva_array (rtva_tva_idx).ptr -> typed_vector_array.number_of_dimensions,
     1841 	       return_tva_array (rtva_tva_idx).ptr -> typed_vector_array.maximum_dimension_name_length,
     1842 	       rtva_typed_vector_array_ptr, rtva_code);
     1843 	  if rtva_code ^= 0
     1844 	  then call ERROR_RETURN (rtva_code);
     1845 	  call CHECK_VERSION_FB ("typed_vector_array", rtva_typed_vector_array_ptr -> typed_vector_array.version,
     1846 	       (TYPED_VECTOR_ARRAY_VERSION_2));
     1847 
     1848 	  unspec (rtva_typed_vector_array_ptr -> typed_vector_array.dimension_table) = ""b;
     1849 
     1850 	  do rtva_dimension_idx = 1 to rtva_typed_vector_array_ptr -> typed_vector_array.number_of_dimensions;
     1851 (nosubrg):
     1852 	     rtva_typed_vector_array_ptr -> typed_vector_array.dimension_table (rtva_dimension_idx) =
     1853 		return_tva_array (rtva_tva_idx).ptr -> typed_vector_array.dimension_table (rtva_dimension_idx);
     1854 	  end;
     1855          end;
     1856 
     1857       rtva_typed_vector_array_ptr -> typed_vector_array.number_of_vectors = rtva_number_of_vectors;
     1858       rtva_return_vector_idx = 1;
     1859       do rtva_tva_idx = rtva_tva_idx to hbound (return_tva_array, 1)
     1860 	 while (rtva_return_vector_idx <= rtva_number_of_vectors);
     1861 
     1862          if return_tva_array (rtva_tva_idx).ptr ^= null
     1863          then
     1864 	  do;
     1865 	     do rtva_vector_idx = 1 to return_tva_array (rtva_tva_idx).ptr -> typed_vector_array.number_of_vectors;
     1866 
     1867 	        call dm_vector_util_$copy_typed_vector (caller_area_ptr, return_tva_array (rtva_tva_idx).ptr,
     1868 		   return_tva_array (rtva_tva_idx).ptr -> typed_vector_array.vector_slot (rtva_vector_idx),
     1869 		   rtva_typed_vector_array_ptr -> typed_vector_array.vector_slot (rtva_return_vector_idx), rtva_code);
     1870 	        if rtva_code ^= 0
     1871 	        then call ERROR_RETURN (rtva_code);
     1872 	        rtva_return_vector_idx = rtva_return_vector_idx + 1;
     1873 	     end;
     1874 	     call FREE_TYPED_VECTOR_ARRAY (return_tva_array (rtva_tva_idx).ptr);
     1875 	  end;
     1876       end;
     1877 
     1878       return;
     1879 
     1880    end RETURN_TYPED_VECTOR_ARRAY;
     1881 
     1882 RETURN_ELEMENT_ID_LIST:
     1883    proc (reil_number_of_ids, reil_element_id_list_ptr);
     1884 
     1885 /* This subroutine allocates an element_id_list in the caller's area large
     1886*   enough to hold all of the ids to be returned.  It is referenced by explicit
     1887*   ptr to prevent conflict with element_id_lists alloc when processing the search.
     1888*   Ids are copied from the element_id_lists and typed_vector_arrays (holding
     1889*   simple_typed_vectors with a single value, a tuple id) recorded in the
     1890*   return_eil_or_tva_array. */
     1891 
     1892       dcl	    reil_number_of_ids     fixed bin (35);
     1893       dcl	    reil_element_id_list_ptr
     1894 			       ptr;
     1895       dcl	    (
     1896 	    reil_eil_or_tva_idx,			/* index into return_eil_or_tva_array */
     1897 	    reil_return_id_idx,			/* index into return element_id_list */
     1898 	    reil_id_idx				/* index into current eil or tva */
     1899 	    )		       fixed bin;
     1900       dcl	    reil_code	       fixed bin (35) init (0);
     1901       dcl	    reil_based_b36a	       bit (36) aligned based;/* for element_id */
     1902 
     1903       if reil_number_of_ids <= 0
     1904       then return;					/* No tuples found. */
     1905       if reil_element_id_list_ptr ^= null
     1906       then
     1907         /*** The caller supplied an element_id_list. Do not allocate a new one. */
     1908 	 reil_element_id_list_ptr -> element_id_list.number_of_elements = reil_number_of_ids;
     1909       else
     1910          do;
     1911          /*** The caller did not supply an element_id_list. Allocate one in the
     1912*	    caller area. */
     1913 
     1914 	  eil_number_of_elements = reil_number_of_ids;
     1915 	  alloc element_id_list in (caller_area) set (reil_element_id_list_ptr);
     1916 						/* freed in FINISH if necessary */
     1917 	  reil_element_id_list_ptr -> element_id_list.version = ELEMENT_ID_LIST_VERSION_1;
     1918          end;
     1919 
     1920       reil_return_id_idx = 0;
     1921 
     1922       do reil_eil_or_tva_idx = 1 to hbound (return_eil_or_tva_array, 1);
     1923 
     1924          if return_eil_or_tva_array (reil_eil_or_tva_idx).ptr ^= null
     1925          then
     1926 	  do;
     1927 	     if return_eil_or_tva_array (reil_eil_or_tva_idx).is_element_id_list
     1928 	     then
     1929 	        do;
     1930 		 do reil_id_idx = 1
     1931 		      to return_eil_or_tva_array (reil_eil_or_tva_idx).ptr -> element_id_list.number_of_elements;
     1932 		    reil_return_id_idx = reil_return_id_idx + 1;
     1933 		    reil_element_id_list_ptr -> element_id_list.id (reil_return_id_idx) =
     1934 		         return_eil_or_tva_array (reil_eil_or_tva_idx).ptr -> element_id_list.id (reil_id_idx);
     1935 		 end;
     1936 		 free return_eil_or_tva_array (reil_eil_or_tva_idx).ptr -> element_id_list;
     1937 		 return_eil_or_tva_array (reil_eil_or_tva_idx).ptr = null;
     1938 	        end;
     1939 	     else
     1940 	        do;
     1941 		 do reil_id_idx = 1
     1942 		      to return_eil_or_tva_array (reil_eil_or_tva_idx).ptr -> typed_vector_array.number_of_vectors;
     1943 		    ;
     1944 		    reil_return_id_idx = reil_return_id_idx + 1;
     1945 		    reil_element_id_list_ptr -> element_id_list.id (reil_return_id_idx) =
     1946 		         return_eil_or_tva_array (reil_eil_or_tva_idx).ptr
     1947 		         -> typed_vector_array.vector_slot (reil_id_idx) -> simple_typed_vector.value_ptr (1)
     1948 		         -> reil_based_b36a;
     1949 		 end;
     1950 		 call FREE_TYPED_VECTOR_ARRAY (return_eil_or_tva_array (reil_eil_or_tva_idx).ptr);
     1951 	        end;
     1952 
     1953 	  end;
     1954       end;
     1955 
     1956       return;
     1957 
     1958    end RETURN_ELEMENT_ID_LIST;
     1959 
  3     1 /* BEGIN INCLUDE FILE dm_rlm_cursor.incl.pl1 */
  3     2 
  3     3 /* HISTORY:
  3     4*
  3     5*Written by Matthew Pierret, 05/19/83. 
  3     6*Modified:
  3     7*06/24/83 by Lindsey L. Spratt:  Changed to version 2.  Added the current.flags
  3     8*            structure, to add the search_index_and_record_collection flag.
  3     9*            This flag is only meaningful when doing a relative search.  It is
  3    10*            used by rlm_general_search to know what state the
  3    11*            internal_search_specification was left in (suitable for searching
  3    12*            the index or suitable for searching the records).
  3    13*10/29/84 by Stanford S. Cox:  Changed to not init version.
  3    14*02/12/85 by S. Cox:  Chg and_group_idx to fb17, current.flags.mbz to bit35.
  3    15**/
  3    16 
  3    17 /* format: style2,ind3 */
  3    18      dcl	   1 relation_cursor      aligned based (relation_cursor_ptr),
  3    19 	     2 version	      char (8),		/* version of this structure */
  3    20 	     2 work_area_ptr      ptr init (null),	/* points to area in which cursor is allocated. */
  3    21 	     2 file_opening_id    bit (36) aligned init ("0"b),
  3    22 						/* opening id of file in which relation resides */
  3    23 	     2 flags	      aligned,
  3    24 	       3 current_state_is_consistent
  3    25 			      bit (1) unal init ("0"b),
  3    26 						/* On if all values in current are insynch */
  3    27 	       3 mbz	      bit (35) unal init ("0"b),
  3    28 						/* must be zero */
  3    29 	     2 current,				/* current position in search */
  3    30 	       3 and_group_idx    fixed bin (17) aligned init (0),
  3    31 						/* in relation_search_specification */
  3    32 	       3 flags	      aligned,
  3    33 	         4 search_index_and_record_collection
  3    34 			      bit (1) unal init ("0"b),
  3    35 	         4 mbz	      bit (35) unal init ("0"b),
  3    36 	       3 collection_id    bit (36) aligned init ("0"b),
  3    37 						/* that cursor is define over */
  3    38 	       3 specification_ptr
  3    39 			      ptr init (null),	/* points to index or record specification */
  3    40 	       3 cursor_ptr	      ptr init (null);	/* points to index or record cursor */
  3    41 
  3    42      dcl	   relation_cursor_ptr    ptr init (null);
  3    43      dcl	   RELATION_CURSOR_VERSION_2
  3    44 			      init ("relcrs02") char (8) aligned internal static options (constant);
  3    45 
  3    46 /* END INCLUDE FILE dm_rlm_cursor.incl.pl1 */
     1960 
     1961 
  4     1 /* BEGIN INCLUDE FILE - dm_rlm_opening_info.incl.pl1 */
  4     2 
  4     3 /* Written by Matthew Pierret, 09/08/82. 
  4     4*Modified:
  4     5*01/18/83 by Matthew Pierret:  Changed version to be char (8). Added 
  4     6*            transaction_id.
  4     7*02/25/83 by Matthew Pierret:  Changed to relation_opening_info (from
  4     8*            relation_info).
  4     9*10/29/84 by Stanford S. Cox:  Changed to not init version.
  4    10**/
  4    11 
  4    12 
  4    13 /* format: style2,ind3 */
  4    14 
  4    15      dcl	   1 relation_opening_info
  4    16 			      aligned based (relation_opening_info_ptr),
  4    17 	     2 version	      char (8),
  4    18 	     2 per_process,
  4    19 	       3 current_transaction_id
  4    20 			      bit (36) aligned init ("0"b),
  4    21 	       3 current_rollback_count
  4    22 			      fixed bin (35) init (0),
  4    23 	       3 file_opening_id  bit (36) aligned init ("0"b),
  4    24 	       3 number_of_openings
  4    25 			      fixed bin (17) aligned init (0),
  4    26 	       3 lock_advice      aligned,
  4    27 	         4 this_process   bit (2) unaligned init ("0"b),
  4    28 	         4 other_processes
  4    29 			      bit (2) unaligned init ("0"b),
  4    30 	         4 mbz1	      bit (32) unaligned init ("0"b),
  4    31 	       3 record_cursor_ptr
  4    32 			      ptr init (null),
  4    33 	       3 index_cursor_array_ptr
  4    34 			      ptr init (null),
  4    35 	     2 relation_header_ptr
  4    36 			      ptr init (null),
  4    37 	     2 attribute_info_ptr ptr init (null),
  4    38 	     2 index_attribute_map_ptr
  4    39 			      ptr init (null);
  4    40 
  4    41      dcl	   relation_opening_info_ptr
  4    42 			      ptr;
  4    43      dcl	   RELATION_OPENING_INFO_VERSION_2
  4    44 			      init ("rlmopen2") char (8) aligned internal static options (constant);
  4    45 
  4    46 
  4    47 /* END INCLUDE FILE - dm_rlm_opening_info.incl.pl1 */
     1962 
     1963 
  5     1 /* BEGIN INCLUDE FILE - dm_rlm_header.incl.pl1 */
  5     2 
  5     3 /* HISTORY:
  5     4*Written by Matthew Pierret, 1982.
  5     5*Modified:
  5     6*02/25/83 by Matthew Pierret: Added attribute_info_element_id, 
  5     7*            header_info_update_count, RELATION_HEADER_VERSION_2.
  5     8*05/29/84 by Matthew Pierret: Added caller_header_element_id, 
  5     9*            RELATION_HEADER_VERSION_3.
  5    10*10/29/84 by Stanford S. Cox:  Changed to not init version.
  5    11**/
  5    12 
  5    13 /* format: style2,ind3 */
  5    14 
  5    15      dcl	   1 relation_header      aligned based (relation_header_ptr),
  5    16 	     2 version	      char (8),
  5    17 	     2 header_info_update_count
  5    18 			      fixed bin (35) aligned init (0),
  5    19 	     2 record_collection_id
  5    20 			      bit (36) aligned init ("0"b),
  5    21 	     2 cluster_index_id   bit (36) aligned init ("0"b),
  5    22 	     2 attribute_info_element_id
  5    23 			      bit (36) aligned init ("0"b),
  5    24 	     2 index_attribute_map_element_id
  5    25 			      bit (36) aligned init ("0"b),
  5    26 	     2 caller_header_element_id
  5    27 			      bit (36) aligned init ("0"b);
  5    28 
  5    29      dcl	   relation_header_ptr    ptr init (null);
  5    30      dcl	   RELATION_HEADER_VERSION_3
  5    31 			      init ("RelHdr 3") char (8) aligned internal static options (constant);
  5    32 
  5    33 /* END INCLUDE FILE - dm_rlm_header.incl.pl1 */
     1964 
     1965 
  6     1 /* BEGIN INCLUDE FILE dm_rlm_attribute_info.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION
  6     4*        
  6     5*   Relation attributes descriptor and name.  This info is kept in the header
  6     6*   collection of existing files, therefore this incl should not be changed.
  6     7**/
  6     8 
  6     9 /* HISTORY:
  6    10*Written by Matthew Pierret, 02/25/83.
  6    11*Modified:
  6    12*10/29/84 by Stanford S. Cox:  Changed to not init version.
  6    13*12/14/84 by Stanford S. Cox:  Backed out previous structure alignment changes
  6    14*   which were incompatible with existing DM files.        
  6    15**/
  6    16 
  6    17 /* format: style2,ind3 */
  6    18      dcl	   1 attribute_info	      aligned based (attribute_info_ptr),
  6    19 	     2 version	      char (8),
  6    20 	     2 number_of_attributes
  6    21 			      fixed bin (17) unal,
  6    22 	     2 maximum_attribute_name_length
  6    23 			      fixed bin (17) unal,
  6    24 	     2 attribute	      (ai_number_of_attributes refer (attribute_info.number_of_attributes)),
  6    25 	       3 descriptor	      bit (36) aligned,
  6    26 	       3 name	      char (ai_maximum_attribute_name_length
  6    27 			      refer (attribute_info.maximum_attribute_name_length)) varying;
  6    28 
  6    29      dcl	   attribute_info_ptr     ptr init (null);
  6    30      dcl	   ai_maximum_attribute_name_length
  6    31 			      fixed bin (17);
  6    32      dcl	   ai_number_of_attributes
  6    33 			      fixed bin (17);
  6    34      dcl	   ATTRIBUTE_INFO_VERSION_1
  6    35 			      init ("attrinf1") char (8) aligned internal static options (constant);
  6    36 
  6    37 /* END INCLUDE FILE dm_rlm_attribute_info.incl.pl1 */
  6    38 
     1966 
     1967 
  7     1 /* BEGIN INCLUDE FILE - dm_rlm_index_attr_map.incl.pl1 */
  7     2 
  7     3 /* DESCRIPTION
  7     4*        
  7     5*   Relation index components.  This info is kept in the header
  7     6*   collection of existing files, therefore this incl should not be changed.
  7     7**/
  7     8 
  7     9 /* HISTORY:
  7    10*Written by Matthew Pierret, 01/15/83.
  7    11*Modified:
  7    12*10/29/84 by Stanford S. Cox: Changed to not init version.
  7    13*12/14/84 by Stanford S. Cox:  Backed out previous structure alignment changes
  7    14*   which were incompatible with existing DM files.        
  7    15**/
  7    16 
  7    17 /* format: style2,ind3 */
  7    18      dcl	   1 index_attribute_map  aligned based (index_attribute_map_ptr),
  7    19 	     2 version	      char (8),
  7    20 	     2 number_of_indices  fixed bin (17) unal init (0),
  7    21 	     2 maximum_number_of_indices
  7    22 			      fixed bin (17) unal,
  7    23 	     2 maximum_number_of_attributes_per_index
  7    24 			      fixed bin (17) unal,
  7    25 	     2 mbz	      fixed bin (17) unal,
  7    26 	     2 index	      (iam_maximum_number_of_indices refer (index_attribute_map.maximum_number_of_indices)),
  7    27 	       3 collection_id    bit (36) aligned,
  7    28 	       3 style	      fixed bin (17) unal,
  7    29 	       3 number_of_duplication_fields
  7    30 			      fixed bin (17) unal,
  7    31 	       3 number_of_attributes
  7    32 			      fixed bin (17) unal,
  7    33 	       3 attribute_id     (iam_maximum_number_of_attributes_per_index
  7    34 			      refer (index_attribute_map.maximum_number_of_attributes_per_index)) fixed
  7    35 			      bin (17) unal;
  7    36 
  7    37      dcl	   index_attribute_map_ptr
  7    38 			      ptr init (null);
  7    39      dcl	   iam_maximum_number_of_indices
  7    40 			      fixed bin (17);
  7    41      dcl	   iam_maximum_number_of_attributes_per_index
  7    42 			      fixed bin (17);
  7    43      dcl	   INDEX_ATTRIBUTE_MAP_VERSION_2
  7    44 			      init ("idx_map2") char (8) aligned internal static options (constant);
  7    45      dcl	   INITIAL_NUMBER_OF_INDICES
  7    46 			      init (5) fixed bin (17);
  7    47      dcl	   UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
  7    48 			      init (0) fixed bin (17);
  7    49 
  7    50 /* END INCLUDE FILE - dm_rlm_index_attr_map.incl.pl1 */
     1968 
     1969 
  8     1 /* BEGIN INCLUDE FILE dm_relation_spec.incl.pl1 */
  8     2 
  8     3 /* HISTORY:
  8     4*Written by Matthew Pierret, 05/10/83.
  8     5*Modified:
  8     6**/
  8     7 
  8     8 /* format: style2,ind3 */
  8     9      dcl	   1 relation_search_specification
  8    10 			      aligned based (relation_search_specification_ptr),
  8    11 	     2 head	      like specification_head,
  8    12 	     2 maximum_number_of_constraints
  8    13 			      fixed bin (17) unal,
  8    14 	     2 number_of_and_groups
  8    15 			      fixed bin (17) unal,
  8    16 	     2 flags	      unal,
  8    17 	       3 return_unique_tuples
  8    18 			      bit (1) unal,
  8    19 	       3 mbz	      bit (35) unal,
  8    20 	     2 range,
  8    21 	       3 type	      fixed bin (17),
  8    22 	       3 size	      fixed bin (17),
  8    23 	     2 and_group	      (rss_number_of_and_groups refer (relation_search_specification.number_of_and_groups)),
  8    24 	       3 search_collection_id
  8    25 			      bit (36) aligned,
  8    26 	       3 flags	      unal,
  8    27 	         4 collection_id_supplied
  8    28 			      bit (1) unal,
  8    29 	         4 mbz	      bit (17) unal,
  8    30 	       3 number_of_constraints
  8    31 			      fixed bin (17) unal,
  8    32 	       3 constraint	      (rss_maximum_number_of_constraints
  8    33 			      refer (relation_search_specification.maximum_number_of_constraints)),
  8    34 	         4 field_id	      fixed bin (17) unal,
  8    35 	         4 operator_code  fixed bin (17) unal,
  8    36 	         4 value_field_id fixed bin (17) unal,
  8    37 	         4 mbz	      bit (18) unal,
  8    38 	         4 value_ptr      ptr;
  8    39 
  8    40 
  8    41      dcl	   1 relation_numeric_specification
  8    42 			      aligned based (relation_numeric_specification_ptr),
  8    43 	     2 head	      like specification_head,
  8    44 	     2 collection_id      bit (36) aligned,
  8    45 	     2 range_size	      fixed bin (35),
  8    46 	     2 position_number    fixed bin (17) unal,
  8    47 	     2 pad	      bit (18) unal;
  8    48 
  8    49 
  8    50      dcl	   (relation_search_specification_ptr, relation_numeric_specification_ptr)
  8    51 			      ptr init (null);
  8    52      dcl	   (rss_number_of_and_groups, rss_maximum_number_of_constraints)
  8    53 			      fixed bin (17) init (0);
  8    54 
  8    55 
  8    56 
  8    57 /* END INCLUDE FILE dm_relation_spec.incl.pl1 */
     1970 
     1971 
  9     1 /* BEGIN INCLUDE FILE dm_specification_head.incl.pl1 */
  9     2 
  9     3 /* HISTORY:
  9     4*Written by Matthew Pierret, 05/11/83. (Extracted from dm_specification.incl.pl1)
  9     5*Modified:
  9     6*05/20/83 by Matthew Pierret: Changed to use version 4.
  9     7**/
  9     8 
  9     9 /* format: style2,ind3 */
  9    10      dcl	   1 specification_head   based (specification_head_ptr),
  9    11 	     2 version	      fixed bin (35),
  9    12 	     2 type	      fixed bin (17) unal,
  9    13 	     2 pad	      bit (18) unal,
  9    14 	     2 subset_specification_ptr
  9    15 			      ptr;
  9    16 
  9    17 
  9    18      dcl	   specification_head_ptr ptr;
  9    19      dcl	   SPECIFICATION_VERSION_4
  9    20 			      init (4) fixed bin (35) internal static options (constant);
  9    21 
  9    22      dcl	   (
  9    23 	   SEARCH_SPECIFICATION_TYPE
  9    24 			      init (1),
  9    25 	   ABSOLUTE_SEARCH_SPECIFICATION_TYPE
  9    26 			      init (1),
  9    27 	   NUMERIC_SPECIFICATION_TYPE
  9    28 			      init (2),
  9    29 	   ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
  9    30 			      init (2),
  9    31 	   RELATIVE_SEARCH_SPECIFICATION_TYPE
  9    32 			      init (3),
  9    33 	   RELATIVE_NUMERIC_SPECIFICATION_TYPE
  9    34 			      init (4),
  9    35 	   ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
  9    36 			      init (5),
  9    37 	   RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
  9    38 			      init (6),
  9    39 	   ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
  9    40 			      init (7),
  9    41 	   RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
  9    42 			      init (8)
  9    43 	   )		      fixed bin (17) internal static options (constant);
  9    44 
  9    45 
  9    46 /* END INCLUDE FILE dm_specification_head.incl.pl1 */
     1972 
     1973 
 10     1 /* ***********************************************************
 10     2*   *                                                         *
 10     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
 10     4*   *                                                         *
 10     5*   *********************************************************** */
 10     6 /* BEGIN INCLUDE FILE vu_typed_vector_array.incl.pl1 */
 10     7 
 10     8 /* Written by Lindsey Spratt, 03/04/82.
 10     9*Modified:
 10    10*06/23/82 by Lindsey Spratt: Changed to version 2.  The cv entry declarations
 10    11*	  were altered.  cv_to_typed now takes ptr to the descriptor, ptr to
 10    12*	  the print_vector value (char varying), ptr to the typed_vector
 10    13*	  value location, and a code. cv_to_print now takes ptr to the
 10    14*	  descriptor, ptr to the typed_vector value, the print_vector value
 10    15*	  (char(*) varying), the maximum allowed length for the print_vector
 10    16*	  value, a temp_seg to put the value in if its to big to fit into
 10    17*	  the print_vector, and a code.
 10    18**/
 10    19 
 10    20 /* format: style2,ind3 */
 10    21      dcl	   1 typed_vector_array   based (typed_vector_array_ptr) aligned,
 10    22 	     2 version	      fixed bin (35),
 10    23 	     2 number_of_dimensions
 10    24 			      fixed bin (17),
 10    25 	     2 number_of_vectors  fixed bin (17),
 10    26 	     2 number_of_vector_slots
 10    27 			      fixed bin (17),
 10    28 	     2 maximum_dimension_name_length
 10    29 			      fixed bin (17),
 10    30 	     2 dimension_table    (tva_number_of_dimensions refer (typed_vector_array.number_of_dimensions)),
 10    31 	       3 name	      char (tva_maximum_dimension_name_length
 10    32 			      refer (typed_vector_array.maximum_dimension_name_length)) varying,
 10    33 	       3 descriptor_ptr   ptr,		/* call cv_to_print (descriptor_ptr, typed_value_ptr, */
 10    34 						/* temp_seg_ptr, max_length_for_print_value, */
 10    35 						/* print_value, code) */
 10    36 	       3 cv_to_print      entry (ptr, ptr, ptr, fixed bin (35), char (*) varying, fixed bin (35)),
 10    37 						/* call cv_to_typed (descriptor_ptr, area_ptr, */
 10    38 						/* print_value_ptr, typed_value_ptr, code) */
 10    39 	       3 cv_to_typed      entry (ptr, ptr, ptr, ptr, fixed bin (35)),
 10    40 	     2 vector_slot	      (tva_number_of_vector_slots refer (typed_vector_array.number_of_vector_slots))
 10    41 			      pointer;
 10    42 
 10    43      dcl	   typed_vector_array_ptr ptr;
 10    44      dcl	   tva_number_of_vector_slots
 10    45 			      fixed bin;
 10    46      dcl	   tva_number_of_dimensions
 10    47 			      fixed bin;
 10    48      dcl	   tva_maximum_dimension_name_length
 10    49 			      fixed bin;
 10    50      dcl	   TYPED_VECTOR_ARRAY_VERSION_2
 10    51 			      fixed bin (35) int static options (constant) init (2);
 10    52 
 10    53 /* END INCLUDE FILE vu_typed_vector_array.incl.pl1 */
     1974 
     1975 
 11     1 /* ***********************************************************
 11     2*   *                                                         *
 11     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
 11     4*   *                                                         *
 11     5*   *********************************************************** */
 11     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
 11     7 
 11     8 /* Written by Lindsey Spratt, 04/02/82.
 11     9*Modified:
 11    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
 11    11*	  unaligned.  Changed the type number of the simple_typed_vector to
 11    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
 11    13*	  type.
 11    14**/
 11    15 
 11    16 /* format: style2,ind3 */
 11    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
 11    18 	     2 type	      fixed bin (17) unal,
 11    19 	     2 number_of_dimensions
 11    20 			      fixed bin (17) unal,
 11    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
 11    22 	       3 value_ptr	      ptr unaligned;
 11    23 
 11    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
 11    25 	     2 type	      fixed bin (17) unal,
 11    26 	     2 number_of_dimensions
 11    27 			      fixed bin (17) unal,
 11    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
 11    29 	       3 identifier	      fixed bin (17) unal,
 11    30 	       3 pad	      bit (18) unal,
 11    31 	       3 value_ptr	      ptr unal;
 11    32 
 11    33      dcl	   simple_typed_vector_ptr
 11    34 			      ptr;
 11    35      dcl	   stv_number_of_dimensions
 11    36 			      fixed bin (17);
 11    37 
 11    38      dcl	   general_typed_vector_ptr
 11    39 			      ptr;
 11    40      dcl	   gtv_number_of_dimensions
 11    41 			      fixed bin (17);
 11    42 
 11    43      dcl	   (
 11    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
 11    45 			      init (1),		/* value_ptr was aligned. */
 11    46 	   GENERAL_TYPED_VECTOR_TYPE
 11    47 			      init (2),
 11    48 	   SIMPLE_TYPED_VECTOR_TYPE
 11    49 			      init (3)
 11    50 	   )		      fixed bin (17) internal static options (constant);
 11    51 
 11    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
     1976 
     1977 
 12     1 /* BEGIN INCLUDE FILE - dm_id_list.incl.pl1 */
 12     2 
 12     3 /* DESCRIPTION
 12     4*        The id_list structure is used to identify attributes, fields and
 12     5*   dimensions by various modules of the Data Management System.
 12     6**/
 12     7 
 12     8 /* HISTORY:
 12     9*Written by Matthew Pierret, '82.
 12    10*Modified:
 12    11*08/17/83 by Matthew Pierret: Made version constant 'internal static options
 12    12*            (constant)' and to initialize automatic variables.
 12    13**/
 12    14 
 12    15 /* format: style2,ind3 */
 12    16      dcl	   1 id_list	      aligned based (id_list_ptr),
 12    17 	     2 version	      fixed bin (35),
 12    18 	     2 number_of_ids      fixed bin (17),
 12    19 	     2 id		      (il_number_of_ids refer (id_list.number_of_ids)) fixed bin (17);
 12    20 
 12    21      dcl	   id_list_ptr	      ptr init (null);
 12    22      dcl	   il_number_of_ids	      fixed bin (17) init (-1);
 12    23      dcl	   ID_LIST_VERSION_1      fixed bin (17) init (1) internal static options (constant);
 12    24 
 12    25 /* END INCLUDE FILE - dm_id_list.incl.pl1 */
     1978 
     1979 
 13     1 /* BEGIN INCLUDE FILE  - dm_element_id_list.incl.pl1 */
 13     2 
 13     3 /* DESCRIPTION:
 13     4*          The element_id_list structure contains an array of element 
 13     5*     identifiers.  These identifiers are used as tuple, record or 
 13     6*     element identifiers.  This structure is used across the relation_manager_,
 13     7*     record_manager_ and index_manager_ interfaces.  At some time the 
 13     8*     version should be changed to be char(8)aligned, when such a conversion
 13     9*     can be coordinated with the other structures used at these interfaces.
 13    10**/
 13    11 
 13    12 /* HISTORY:
 13    13*Written by Matthew Pierret, 06/06/82.
 13    14*Modified:
 13    15*12/16/82 by Roger Lackey:  Changed number_of_elements to fixed bin (35).
 13    16*            Did not change version.
 13    17*02/11/85 by Matthew Pierret:  Added DESCRIPTION, Written by.
 13    18**/
 13    19 
 13    20 /* format: style2,ind3 */
 13    21      dcl	   1 element_id_list      aligned based (element_id_list_ptr),
 13    22 	     2 version	      fixed bin (35),
 13    23 	     2 number_of_elements fixed bin (35),
 13    24 	     2 id		      (eil_number_of_elements refer (element_id_list.number_of_elements)) bit (36) aligned;
 13    25 
 13    26      dcl	   element_id_list_ptr    ptr;
 13    27      dcl	   eil_number_of_elements fixed bin (35);
 13    28      dcl	   ELEMENT_ID_LIST_VERSION_1
 13    29 			      init (1) fixed bin (35);
 13    30 
 13    31 
 13    32 /* END INCLUDE FILE  - dm_element_id_list.incl.pl1 */
     1980 
     1981 
 14     1 /* BEGIN INCLUDE FILE - dm_interval_list.incl.pl1 */
 14     2 
 14     3 /* DESCRIPTION:
 14     4*
 14     5*          The interval_list structure is used to describe a number of
 14     6*     intervals of keys in an associated typed_vector_array.  With each
 14     7*     interval is a list of the and_groups from the search_specification used
 14     8*     to find those keys.  All of the constraints on fields which are specified
 14     9*     in the and_groups associated with an interval and are in the keys are
 14    10*     completely satisfied by the keys in the interval.
 14    11**/
 14    12 
 14    13 /* HISTORY:
 14    14*
 14    15*Written by Lindsey Spratt, 11/09/82.
 14    16*Modified:
 14    17**/
 14    18 
 14    19 /* format: style2,ind3 */
 14    20      dcl	   1 interval_list	      based (interval_list_ptr) aligned,
 14    21 	     2 version	      char (8),		/* Must be set to INTERVAL_LIST_VERSION_2. */
 14    22 	     2 number_of_intervals
 14    23 			      fixed bin (17) unal,
 14    24 	     2 pad	      bit (18) unal,
 14    25 	     2 interval	      (intl_number_of_intervals refer (interval_list.number_of_intervals)),
 14    26 	       3 low_vector_idx   fixed bin (35),	/* The first vector in the associated typed_vector_array for this interval. */
 14    27 	       3 high_vector_idx  fixed bin (35),	/* The last vector for this interval. */
 14    28 	       3 and_group_id_list_ptr
 14    29 			      ptr;		/* points to an id_list which identifies the */
 14    30 						/* and_groups in the associated search_specification */
 14    31 						/* which apply to the vectors in this interval. */
 14    32 
 14    33      dcl	   interval_list_ptr      ptr init (null);
 14    34      dcl	   INTERVAL_LIST_VERSION_2
 14    35 			      init ("IntLst 2") char (8) aligned internal static options (constant);
 14    36      dcl	   intl_number_of_intervals
 14    37 			      fixed bin init (0);
 14    38 
 14    39 /* END INCLUDE FILE dm_interval_list.incl.pl1 */
     1982 
     1983 
 15     1 /* BEGIN INCLUDE FILE - dm_specification.incl.pl1 */
 15     2 
 15     3 /* DESCRIPTION:
 15     4*
 15     5*          The specification structure is used to identify sets items based on
 15     6*     the value of some of the contents of the items (the
 15     7*     search_specification), or based on the ordinal position (the
 15     8*     numeric_specification) of the first or last item in the desired set of
 15     9*     items in the set of all possible items.  It is used with the relation,
 15    10*     index and record managers.  The items for these three managers are
 15    11*     tuples, keys and records, respectively.  The sets of "all possible
 15    12*     items", for determination of ordinal position for these three managers
 15    13*     are: a relation, an index, and a record collection, respectively.
 15    14*     
 15    15*          The specification_head structure, in dm_specification_head.incl.pl1,
 15    16*     must be included in any program which uses this (the
 15    17*     dm_specification.incl.pl1) include file.
 15    18**/
 15    19 
 15    20 /* HISTORY:
 15    21*
 15    22*Written by Lindsey Spratt, 05/19/82.
 15    23*Modified:
 15    24*08/17/82 by Matthew Pierret:  Added all specification type constants.
 15    25*09/24/82 by Ronald Harvey: Changed version and added and_groups.
 15    26*10/22/82 by Lindsey Spratt:  Added the range_size to the numeric_specification.
 15    27*	  Changed the version to 3.
 15    28*05/11/83 by Matthew Pierret: Moved specification_head and and type constants
 15    29*            to dm_specification_head.incl.pl1. Added constraint.value_field_id.
 15    30*            Moved range type constants into dm_range_constants.incl.pl1.
 15    31*05/20/83 by Matthew Pierret: Added constraint.value_field_id for specifying
 15    32*            intra-key/record compares.
 15    33*10/02/84 by Lindsey L. Spratt:  Moved a misplaced journalization comment.
 15    34*            Added a DESCRIPTION comment.
 15    35**/
 15    36 
 15    37 /* format: style2,ind3 */
 15    38      dcl	   1 search_specification based (search_specification_ptr),
 15    39 	     2 head	      like specification_head,
 15    40 	     2 maximum_number_of_constraints
 15    41 			      fixed bin (17) unal,
 15    42 	     2 number_of_and_groups
 15    43 			      fixed bin (17) unal,
 15    44 	     2 range	      unal,
 15    45 	       3 type	      fixed bin (17),
 15    46 	       3 size	      fixed bin (17),
 15    47 	     2 and_group	      (ss_number_of_and_groups refer (search_specification.number_of_and_groups)),
 15    48 	       3 number_of_constraints
 15    49 			      fixed bin (17) unal,
 15    50 	       3 constraint	      (ss_maximum_number_of_constraints
 15    51 			      refer (search_specification.maximum_number_of_constraints)),
 15    52 	         4 field_id	      fixed bin (17) unal,
 15    53 	         4 operator_code  fixed bin (17) unal,
 15    54 	         4 value_field_id fixed bin (17) unal,
 15    55 	         4 pad	      bit (18) unal,
 15    56 	         4 value_ptr      ptr unal;
 15    57 
 15    58      dcl	   search_specification_ptr
 15    59 			      ptr;
 15    60      dcl	   (ss_number_of_and_groups, ss_maximum_number_of_constraints)
 15    61 			      fixed bin (17);
 15    62 
 15    63      dcl	   1 numeric_specification
 15    64 			      based (numeric_specification_ptr),
 15    65 	     2 head	      like specification_head,
 15    66 	     2 range_size	      fixed bin (35) aligned,
 15    67 	     2 position_number    fixed bin (17) unal,
 15    68 	     2 pad	      bit (18) unal;
 15    69 
 15    70      dcl	   numeric_specification_ptr
 15    71 			      ptr;
 15    72 
 15    73 /* END INCLUDE FILE - dm_specification.incl.pl1 */
     1984 
     1985 
 16     1 /* BEGIN INCLUDE FILE dm_range_constants.incl.pl1. */
 16     2 
 16     3 /* HISTORY:
 16     4*Written by Matthew Pierret, 05/27/83.
 16     5*Modified:
 16     6**/
 16     7 
 16     8      dcl	   (
 16     9 	   ALL_RANGE_TYPE	      init (1),
 16    10 	   LOW_RANGE_TYPE	      init (2),
 16    11 	   HIGH_RANGE_TYPE	      init (3)
 16    12 	   )		      fixed bin internal static options (constant);
 16    13 
 16    14 
 16    15 /* END INCLUDE FILE dm_range_constants.incl.pl1. */
     1986 
     1987 
 17     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
 17     2 /* format: style3 */
 17     3 
 17     4 /* These constants are to be used for the flags argument of sub_err_ */
 17     5 /* They are just "string (condition_info_header.action_flags)" */
 17     6 
 17     7 declare	(
 17     8 	ACTION_CAN_RESTART	init (""b),
 17     9 	ACTION_CANT_RESTART init ("1"b),
 17    10 	ACTION_DEFAULT_RESTART
 17    11 			init ("01"b),
 17    12 	ACTION_QUIET_RESTART
 17    13 			init ("001"b),
 17    14 	ACTION_SUPPORT_SIGNAL
 17    15 			init ("0001"b)
 17    16 	)		bit (36) aligned internal static options (constant);
 17    17 
 17    18 /* End include file */
     1988 
     1989 
 18     1 /* BEGIN INCLUDE FILE dm_rcdmgr_entry_dcls.incl.pl1 */
 18     2 
 18     3 /* This include file contains declarations of record_manager_ entry points. */
 18     4 
 18     5 /* HISTORY:
 18     6*Written by Matthew Pierret 05/12/82.
 18     7*Modified:
 18     8*12/14/82 by Matthew Pierret: Changed $get_ids to $get_id.
 18     9*04/01/83 by Matthew Pierret: Added $get_records_and_ids and
 18    10*            $get_records_and_ids_by_interval.
 18    11*04/04/83 by Matthew Pierret: Added $destroy_collection and $destroy_cursor.
 18    12*05/24/83 by Matthew Pierret: Corrected mis-spelling of "manger" for
 18    13*            rcm_$destroy_cursor.
 18    14*06/06/83 by Matthew Pierret: Corrected rcm_$get_record_count_by_intervals -
 18    15*            added a ptr parameter. 
 18    16*06/13/83 by Matthew Pierret:  Changed rcm_$*_by_intervals to correctly be
 18    17*            rcm_$=_by_interval.
 18    18*04/12/84 by Lee Baldwin:  Renamed some of the entry points (see 
 18    19*            record_manager_.alm) and changed the declarations of
 18    20*            those that used to pass a typed_vector_type and a
 18    21*            typed_vector_array_version.
 18    22*04/26/84 by Lee Baldwin:  Changed the arg list of
 18    23*            $get_record_count_by_interval to not take a work_area_ptr.
 18    24**/
 18    25 
 18    26 /* format: style2,ind3 */
 18    27      dcl	   record_manager_$create_collection
 18    28 			      entry (bit (36) aligned, ptr, ptr, ptr, bit (36) aligned, fixed bin (35));
 18    29      dcl	   record_manager_$create_cursor
 18    30 			      entry (bit (36) aligned, bit (36) aligned, ptr, ptr, fixed bin (35));
 18    31      dcl	   record_manager_$destroy_collection
 18    32 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
 18    33      dcl	   record_manager_$destroy_cursor
 18    34 			      entry (ptr, fixed bin (35));
 18    35 
 18    36      dcl	   record_manager_$get_record_by_id
 18    37 			      entry (bit (36) aligned, ptr, ptr, ptr, ptr, fixed bin (35));
 18    38      dcl	   record_manager_$get_records_by_id_list
 18    39 			      entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35));
 18    40      dcl	   record_manager_$get_records_by_spec
 18    41 			      entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35));
 18    42      dcl	   record_manager_$get_records_by_interval
 18    43 			      entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35), ptr, ptr, fixed bin (35));
 18    44      dcl	   record_manager_$get_records_and_ids_by_spec
 18    45 			      entry (ptr, ptr, ptr, ptr, ptr, ptr, fixed bin (35));
 18    46      dcl	   record_manager_$get_records_and_ids_by_interval
 18    47 			      entry (ptr, ptr, ptr, ptr, ptr, fixed bin (17), ptr, ptr, ptr, fixed bin (35));
 18    48      dcl	   record_manager_$get_record_ids_by_spec
 18    49                                     entry (ptr, ptr, ptr, ptr, fixed bin (35));
 18    50      dcl	   record_manager_$get_record_ids_by_interval
 18    51 			      entry (ptr, ptr, ptr, ptr, ptr, ptr, fixed bin (35));
 18    52      dcl	   record_manager_$get_record_count
 18    53 			      entry (ptr, ptr, fixed bin (35), fixed bin (35));
 18    54      dcl	   record_manager_$get_record_count_by_interval
 18    55 			      entry (ptr, ptr, ptr, ptr, fixed bin (35), fixed bin (35));
 18    56 
 18    57      dcl	   record_manager_$put_record_by_id
 18    58 			      entry (bit (36) aligned, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35));
 18    59 
 18    60      dcl	   record_manager_$put_records_by_id
 18    61 			      entry (bit (36) aligned, ptr, fixed bin (35), ptr, ptr, fixed bin (35));
 18    62 
 18    63      dcl	   record_manager_$delete_record_by_id
 18    64 			      entry (bit (36) aligned, ptr, fixed bin (35));
 18    65 
 18    66      dcl	   record_manager_$delete_records_by_id_list
 18    67 			      entry (ptr, ptr, fixed bin (35), fixed bin (35));
 18    68 
 18    69      dcl	   record_manager_$delete_records_by_spec
 18    70 			      entry (ptr, ptr, fixed bin (35), fixed bin (35));
 18    71 
 18    72      dcl	   record_manager_$modify_record_by_id
 18    73 			      entry (bit (36) aligned, ptr, ptr, fixed bin (35));
 18    74 
 18    75      dcl	   record_manager_$modify_records_by_id_list
 18    76 			      entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35));
 18    77 
 18    78      dcl	   record_manager_$modify_records_by_spec
 18    79 			      entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35));
 18    80 
 18    81 /* END INCLUDE FILE dm_rcdmgr_entry_dcls.incl.pl1 */
     1990 
     1991 
 19     1 /* BEGIN INCLUDE FILE - dm_idxmgr_entry_dcls.incl.pl1 */
 19     2 
 19     3 /* DESCRIPTION:
 19     4*
 19     5*          This include file has all of the declarations for the index_manager_
 19     6*     external interface.  It is useful for programs which are making extensive
 19     7*     use of the index_manager_ to include this include file rather than
 19     8*     individually declaring each of the entries.
 19     9*     
 19    10**/
 19    11 
 19    12 /* HISTORY:
 19    13*
 19    14*Written by Lindsey Spratt, 06/25/82.
 19    15*Modified:
 19    16*07/28/82 by Lindsey Spratt: Extended the create_collection entry calling
 19    17*	  sequence to include the number_of_duplication_fields.
 19    18*08/10/82 by Matthew Pierret: Changed the create_collection entry calling 
 19    19*            sequence to return a "bit (36) aligned" collection id instead of
 19    20*            "fixed bin (17)".  Changed create_cursor calling sequence likewise.
 19    21*08/19/82 by Lindsey Spratt:  Renamed create_collection to create_index. Added
 19    22*	  the put_key_array entry.  Added the id_list_ptr to the get_key
 19    23*	  entry.  Added the create_subset_index entry.
 19    24*08/23/82 by Lindsey Spratt:  Added the position_cursor entry.
 19    25*09/27/82 by Lindsey Spratt:  Added the get_count and get_duplicate_key_count
 19    26*	  entries.
 19    27*11/09/82 by Lindsey Spratt:  Added ptr to get_key for the interval_list.
 19    28*	  Changed get_duplicate_key_count to get_key_count_array.
 19    29*05/31/83 by Matthew Pierret: Added $destroy_index and $destroy_cursor.
 19    30*05/02/84 by Lee Baldwin:  Renamed $get_count to $get_key_count_by_spec.
 19    31*10/23/84 by Lindsey L. Spratt:  Addressed auditing comments - alphabetized
 19    32*            entries, fixed $create_index to use "fixed bin (17)" instead of
 19    33*            just "fixed bin", added a description section.
 19    34**/
 19    35 
 19    36 /* format: style2,ind3 */
 19    37 
 19    38      dcl	   index_manager_$create_cursor entry (bit (36) aligned, bit (36) aligned, ptr, ptr, fixed bin (35));
 19    39      dcl	   index_manager_$create_index entry (bit (36) aligned, ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
 19    40      dcl	   index_manager_$create_subset_index entry (ptr, bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
 19    41      dcl	   index_manager_$delete_key entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35));
 19    42      dcl	   index_manager_$destroy_cursor entry (ptr, fixed bin (35));
 19    43      dcl	   index_manager_$destroy_index entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
 19    44      dcl	   index_manager_$get_key entry (ptr, ptr, ptr, ptr, ptr, ptr, fixed bin (35));
 19    45      dcl	   index_manager_$get_key_count_array entry (ptr, ptr, ptr, fixed bin (35));
 19    46      dcl	   index_manager_$get_key_count_by_spec entry (ptr, ptr, fixed bin (35), fixed bin (35));
 19    47      dcl	   index_manager_$position_cursor entry (ptr, ptr, ptr, fixed bin (35));
 19    48      dcl	   index_manager_$put_key entry (ptr, ptr, fixed bin (35));
 19    49      dcl	   index_manager_$put_key_array entry (ptr, ptr, fixed bin (35));
 19    50 
 19    51 /* END INCLUDE FILE - dm_idxmgr_entry_dcls.incl.pl1 */
     1992 
     1993 
 20     1 /*  BEGIN INCLUDE	dm_typed_vector_list.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 20     2 
 20     3 /* Written by R. Harvey, 09/24/82 
 20     4*Modified:
 20     5*09/27/82 by Matthew Pierret:  Changed "max" to "maximum", tvl_number_of_vectors
 20     6*            to tvl_maximum_number_of_vectors.
 20     7**/
 20     8 
 20     9 /* format: style2,ind3 */
 20    10      dcl	   1 typed_vector_list    aligned based (typed_vector_list_ptr),
 20    11 	     2 version	      fixed bin (17),
 20    12 	     2 maximum_number_of_vectors
 20    13 			      fixed bin (35),	/* vectors available */
 20    14 	     2 number_of_vectors  fixed bin (35),	/* number of vector_ptrs used */
 20    15 	     2 pad	      fixed bin (35),	/* (even word boundary) */
 20    16 	     2 vector_ptr	      (tvl_maximum_number_of_vectors refer (typed_vector_list.maximum_number_of_vectors)) ptr;
 20    17 
 20    18      dcl	   typed_vector_list_ptr  ptr;
 20    19      dcl	   TYPED_VECTOR_LIST_VERSION_1
 20    20 			      fixed bin (17) int static options (constant) init (1);
 20    21      dcl	   tvl_maximum_number_of_vectors  fixed bin (35);
 20    22 
 20    23 /*  END INCLUDE	dm_typed_vector_list.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1994 
     1995 
     1996    end rlm_general_search;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1138.2  rlm_general_search.pl1            >udd>sm>ds>w>ml>rlm_general_search.pl1
932          1    10/26/88  1355.5  std_descriptor_types.incl.pl1     >ldd>incl>std_descriptor_types.incl.pl1
933          2    11/02/83  1945.0  arg_descriptor.incl.pl1           >ldd>incl>arg_descriptor.incl.pl1
1960         3    03/06/85  1131.5  dm_rlm_cursor.incl.pl1            >ldd>incl>dm_rlm_cursor.incl.pl1
1962         4    01/07/85  0959.6  dm_rlm_opening_info.incl.pl1      >ldd>incl>dm_rlm_opening_info.incl.pl1
1964         5    01/07/85  0959.4  dm_rlm_header.incl.pl1            >ldd>incl>dm_rlm_header.incl.pl1
1966         6    01/07/85  1001.7  dm_rlm_attribute_info.incl.pl1    >ldd>incl>dm_rlm_attribute_info.incl.pl1
1968         7    01/07/85  1001.7  dm_rlm_index_attr_map.incl.pl1    >ldd>incl>dm_rlm_index_attr_map.incl.pl1
1970         8    10/14/83  1709.1  dm_relation_spec.incl.pl1         >ldd>incl>dm_relation_spec.incl.pl1
1972         9    10/14/83  1709.1  dm_specification_head.incl.pl1    >ldd>incl>dm_specification_head.incl.pl1
1974        10    10/14/83  1709.1  vu_typed_vector_array.incl.pl1    >ldd>incl>vu_typed_vector_array.incl.pl1
1976        11    10/14/83  1709.1  vu_typed_vector.incl.pl1          >ldd>incl>vu_typed_vector.incl.pl1
1978        12    10/14/83  1709.1  dm_id_list.incl.pl1               >ldd>incl>dm_id_list.incl.pl1
1980        13    03/06/85  1131.5  dm_element_id_list.incl.pl1       >ldd>incl>dm_element_id_list.incl.pl1
1982        14    01/07/85  0959.0  dm_interval_list.incl.pl1         >ldd>incl>dm_interval_list.incl.pl1
1984        15    01/07/85  0959.8  dm_specification.incl.pl1         >ldd>incl>dm_specification.incl.pl1
1986        16    10/14/83  1709.1  dm_range_constants.incl.pl1       >ldd>incl>dm_range_constants.incl.pl1
1988        17    04/16/82  1058.1  sub_err_flags.incl.pl1            >ldd>incl>sub_err_flags.incl.pl1
1990        18    01/07/85  0959.3  dm_rcdmgr_entry_dcls.incl.pl1     >ldd>incl>dm_rcdmgr_entry_dcls.incl.pl1
1992        19    01/07/85  0958.8  dm_idxmgr_entry_dcls.incl.pl1     >ldd>incl>dm_idxmgr_entry_dcls.incl.pl1
1994        20    10/14/83  1709.1  dm_typed_vector_list.incl.pl1     >ldd>incl>dm_typed_vector_list.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ABSOLUTE_NUMERIC_SPECIFICATION_TYPE    constant        fixed bin(17,0)          initial dcl 9-22 ref 739 967 1491
ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       constant        fixed bin(17,0)          initial dcl 9-22 ref 435
ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       constant        fixed bin(17,0)          initial dcl 9-22 ref 428
ABSOLUTE_SEARCH_SPECIFICATION_TYPE     constant        fixed bin(17,0)          initial dcl 9-22 ref 756 970 1480
ACTION_CANT_RESTART             000061 constant        bit(36)                  initial dcl 17-7 set ref 685* 699* 723* 728* 736*
                                                                                  739* 745* 753* 756* 762* 771* 781* 786* 1825*
ALL_RANGE_TYPE                         constant        fixed bin(17,0)          initial dcl 16-8 ref 1499
ATTRIBUTE_INFO_VERSION_1        000004 constant        char(8)                  initial dcl 6-34 set ref 460*
BITS_PER_BYTE                          constant        fixed bin(17,0)          initial dcl 295 ref 919
BITS_PER_WORD                          constant        fixed bin(17,0)          initial dcl 295 ref 919 921
ELEMENT_ID_LIST_VERSION_1       000253 automatic       fixed bin(35,0)          initial dcl 13-28 set ref 367* 389* 405* 13-28* 1207
                                                                                  1246 1917
ID_LIST_VERSION_1                      constant        fixed bin(17,0)          initial dcl 12-23 ref 347 357 387 403 1637 1663 1695
                                                                                  1721
INDEX_ATTRIBUTE_MAP_VERSION_2   000002 constant        char(8)                  initial dcl 7-43 set ref 463*
INITIAL_NUMBER_OF_INDICES       000230 automatic       fixed bin(17,0)          initial dcl 7-45 set ref 7-45*
INTERVAL_LIST_VERSION_2         000000 constant        char(8)                  initial dcl 14-34 set ref 1191*
IS_ELEMENT_ID_LIST                     constant        bit(1)                   initial dcl 303 set ref 531* 535* 546* 549*
IS_RECORD_COLLECTION            000061 constant        bit(1)                   initial dcl 303 set ref 1217*
IS_TYPED_VECTOR_ARRAY                  constant        bit(1)                   initial dcl 303 set ref 538* 552*
MAXIMUM_FB35_VALUE              000014 constant        fixed bin(35,0)          initial dcl 295 ref 1502 1505
MAX_FB17_VALUE                         constant        fixed bin(17,0)          initial dcl 295 ref 1528 1535
RELATION_CURSOR_VERSION_2       000012 constant        char(8)                  initial dcl 3-43 set ref 413* 717*
RELATION_HEADER_VERSION_3       000006 constant        char(8)                  initial dcl 5-30 set ref 457*
RELATION_OPENING_INFO_VERSION_2 000010 constant        char(8)                  initial dcl 4-43 set ref 454*
RELATIVE_NUMERIC_SPECIFICATION_TYPE    constant        fixed bin(17,0)          initial dcl 9-22 ref 739 967 1461
RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       constant        fixed bin(17,0)          initial dcl 9-22 ref 435 443
RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       constant        fixed bin(17,0)          initial dcl 9-22 ref 428 443
RELATIVE_SEARCH_SPECIFICATION_TYPE     constant        fixed bin(17,0)          initial dcl 9-22 ref 756 970 1469
SIMPLE_TYPED_VECTOR_TYPE               constant        fixed bin(17,0)          initial dcl 11-43 ref 1005
SPECIFICATION_VERSION_4         000062 constant        fixed bin(35,0)          initial dcl 9-19 set ref 425*
TUPLE_ID_FIELD_ID               011771 constant        fixed bin(35,0)          initial dcl 295 ref 1668
TYPED_VECTOR_ARRAY_VERSION_2           constant        fixed bin(35,0)          initial dcl 10-50 ref 1225 1229 1845
TYPED_VECTOR_LIST_VERSION_1            constant        fixed bin(17,0)          initial dcl 20-19 ref 1767
UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
                                000231 automatic       fixed bin(17,0)          initial dcl 7-47 set ref 7-47*
USE_PREVIOUS_CURSOR             000057 constant        bit(1)                   initial dcl 303 set ref 511* 1217*
USE_RELATION_CURSOR                    constant        bit(1)                   initial dcl 303 set ref 501*
addr                                                   builtin function         dcl 286 ref 610 647 660 1124 1124 1587 1606 1639
                                                                                  1724
all_desired_fields_are_in_index 000145 automatic       bit(1)                   initial dcl 248 set ref 248* 1240 1635* 1644* 1655*
                                                                                  1665 1681* 1692* 1705* 1708
and_group                10            based           structure                array level 2 in structure
                                                                                  "relation_search_specification" dcl 8-9
                                                                                  in procedure "rlm_general_search"
and_group                 6            based           structure                array level 2 in structure "search_specification"
                                                                                  packed packed unaligned dcl 15-38 in procedure
                                                                                  "rlm_general_search"
and_group_id_list_ptr
                          6            based           pointer                  array level 3 dcl 14-20 ref 948 948
and_group_idx                   000135 automatic       fixed bin(17,0)          dcl 241 in procedure "rlm_general_search" set ref
                                                                                  482* 491* 494 515* 529* 563* 563 578* 1157
and_group_idx             6            based           fixed bin(17,0)          initial level 3 in structure "relation_cursor"
                                                                                  dcl 3-18 in procedure "rlm_general_search" set ref
                                                                                  762 762 762* 771 771 771 790 1111*
and_group_idx             6     000160 automatic       fixed bin(17,0)          initial level 3 in structure "local_relation_cursor"
                                                                                  dcl 252 in procedure "rlm_general_search" set ref
                                                                                  252*
arg_descriptor                         based           structure                level 1 dcl 2-6 ref 923 923
arg_descriptor_ptr              000400 automatic       pointer                  dcl 2-34 set ref 918* 919 921 923 923
attribute                 3            based           structure                array level 2 dcl 6-18
attribute_id              6(18)        based           fixed bin(17,0)          array level 3 packed packed unaligned dcl 7-18 ref
                                                                                  835 1673 1697
attribute_info                         based           structure                level 1 dcl 6-18
attribute_info_ptr       16            based           pointer                  initial level 2 in structure "relation_opening_info"
                                                                                  dcl 4-15 in procedure "rlm_general_search" ref 459
attribute_info_ptr              000224 automatic       pointer                  initial dcl 6-29 in procedure "rlm_general_search"
                                                                                  set ref 459* 460 6-29* 1124 1124 1171 1687 1693
based_bit_36_aligned                   based           bit(36)                  dcl 272 ref 1210 1249
caller_area                            based           area(1024)               dcl 271 ref 1766 1915
caller_area_ptr                 000106 automatic       pointer                  initial dcl 234 set ref 234* 345* 355* 365* 375*
                                                                                  384* 400* 1766 1781* 1839* 1867* 1915
ccs_and_group_idx                      parameter       fixed bin(17,0)          dcl 709 set ref 706 790* 792* 794*
ccs_is_numeric_specification           parameter       bit(1)                   dcl 714 ref 706 733
ccs_is_relative_specification          parameter       bit(1)                   dcl 710 ref 706 719
ccs_is_search_specification            parameter       bit(1)                   dcl 712 ref 706 750 792
cleanup                         000210 stack reference condition                dcl 291 ref 474
collection_id            10            based           bit(36)                  initial level 3 in structure "relation_cursor"
                                                                                  dcl 3-18 in procedure "rlm_general_search" set ref
                                                                                  745 745* 771 771* 781 781* 1101 1112* 1382 1386
collection_id             4            based           bit(36)                  array level 3 in structure "index_attribute_map"
                                                                                  dcl 7-18 in procedure "rlm_general_search" ref
                                                                                  1350
collection_id            10     000160 automatic       bit(36)                  initial level 3 in structure "local_relation_cursor"
                                                                                  dcl 252 in procedure "rlm_general_search" set ref
                                                                                  252*
collection_id             4            based           bit(36)                  level 2 in structure
                                                                                  "relation_numeric_specification" dcl 8-41
                                                                                  in procedure "rlm_general_search" set ref 745 745*
                                                                                  1342
collection_id_supplied
                         11            based           bit(1)                   array level 4 packed packed unaligned dcl 8-9 ref
                                                                                  771 1339
constraint                6(18)        based           structure                array level 3 in structure "search_specification"
                                                                                  packed packed unaligned dcl 15-38 in procedure
                                                                                  "rlm_general_search" set ref 1549*
constraint               12            based           structure                array level 3 in structure
                                                                                  "relation_search_specification" dcl 8-9
                                                                                  in procedure "rlm_general_search" set ref 1549
cssfi_constraint_idx            000104 automatic       fixed bin(17,0)          dcl 825 set ref 841* 842 843 848 858 859 864 864*
cssfi_field_id                  000100 automatic       fixed bin(17,0)          initial dcl 823 set ref 823* 842* 848 849 855 858
cssfi_field_idx                 000103 automatic       fixed bin(17,0)          dcl 825 set ref 830* 831 831*
cssfi_field_map                 000100 automatic       fixed bin(17,0)          array dcl 822 set ref 831* 835* 842 854
cssfi_index_field_idx           000105 automatic       fixed bin(17,0)          dcl 825 set ref 834* 835 835*
cssfi_index_idx                        parameter       fixed bin(17,0)          dcl 817 ref 800 834 835
cssfi_number_of_fields                 parameter       fixed bin(17,0)          dcl 816 ref 800 822 830
cssfi_search_records                   parameter       bit(1)                   dcl 820 set ref 800 839* 849* 866*
cssfi_search_specification_ptr         parameter       pointer                  dcl 818 ref 800 828
cssfi_temp_value_field_id       000102 automatic       fixed bin(17,0)          initial dcl 823 set ref 823* 854* 855 859
cssfi_value_field_id            000101 automatic       fixed bin(17,0)          initial dcl 823 set ref 823* 843* 845 854
cssfr_constraint_idx            000344 automatic       fixed bin(17,0)          dcl 889 set ref 894* 896 896*
cssfr_search_specification_ptr         parameter       pointer                  dcl 886 ref 873 891 894 896 896
current                   6            based           structure                level 2 in structure "relation_cursor" dcl 3-18
                                                                                  in procedure "rlm_general_search"
current                   6     000160 automatic       structure                level 2 in structure "local_relation_cursor" dcl 252
                                                                                  in procedure "rlm_general_search"
current_and_group_idx           000134 automatic       fixed bin(17,0)          dcl 241 set ref 471* 482 494 1157
current_collection_id           000126 automatic       bit(36)                  initial dcl 238 set ref 238* 490 491* 501* 511* 578*
                                                                                  631
current_index_idx               000130 automatic       fixed bin(17,0)          dcl 241 set ref 491* 501 511 521 1171* 1636 1668
                                                                                  1673 1673 1679 1687 1697 1719
current_state_is_consistent
                          5            based           bit(1)                   initial level 3 in structure "relation_cursor"
                                                                                  packed packed unaligned dcl 3-18 in procedure
                                                                                  "rlm_general_search" set ref 622 723 1099* 1138*
current_state_is_consistent
                          5     000160 automatic       bit(1)                   initial level 3 in structure "local_relation_cursor"
                                                                                  packed packed unaligned dcl 252 in procedure
                                                                                  "rlm_general_search" set ref 252*
cursor_ptr               14     000160 automatic       pointer                  initial level 3 in structure "local_relation_cursor"
                                                                                  dcl 252 in procedure "rlm_general_search" set ref
                                                                                  252*
cursor_ptr               14            based           pointer                  initial level 3 in structure "relation_cursor"
                                                                                  dcl 3-18 in procedure "rlm_general_search" set ref
                                                                                  631 637 728 1101 1101 1101* 1105* 1115* 1382 1382
cv_arg_descriptor_ptr                  parameter       pointer                  dcl 906 ref 903 918
cv_based_real_fix_bin_1u               based           fixed bin(35,0)          packed unaligned dcl 911 ref 919 921
cv_code                         000377 automatic       fixed bin(35,0)          initial dcl 913 set ref 913* 923* 924 924*
cv_expected_version                    parameter       char(8)                  dcl 682 set ref 679 685 685*
cv_received_version                    parameter       char(8)                  dcl 681 set ref 679 685 685*
cv_source_value_ptr                    parameter       pointer                  dcl 907 ref 903 919 921 927
cv_structure_name                      parameter       char                     packed unaligned dcl 683 set ref 679 685*
cv_target_value_ptr                    parameter       pointer                  dcl 908 set ref 903 926* 927
cv_value_string                        based           bit                      packed unaligned dcl 910 set ref 926 927* 927
cv_value_string_size            000376 automatic       fixed bin(35,0)          initial dcl 909 set ref 909* 919* 921* 923* 926 926
                                                                                  927 927
cvf_expected_version                   parameter       fixed bin(35,0)          dcl 696 set ref 693 699 699*
cvf_received_version                   parameter       fixed bin(35,0)          dcl 695 set ref 693 699 699*
cvf_structure_name                     parameter       char                     packed unaligned dcl 697 set ref 693 699*
data_format_util_$get_data_bit_length
                                000100 constant        entry                    external dcl 915 ref 923
descriptor                3            based           bit(36)                  array level 3 dcl 6-18 set ref 1124 1124
dimension                 1            based           structure                array level 2 packed packed unaligned dcl 11-17
dimension_table           6            based           structure                array level 2 dcl 10-21 set ref 1848* 1851* 1851
dm_error_$bad_rel_cursor_pos    000022 external static fixed bin(35,0)          dcl 322 set ref 723* 728*
dm_error_$index_not_in_relation 000024 external static fixed bin(35,0)          dcl 322 set ref 1353*
dm_error_$key_not_found         000026 external static fixed bin(35,0)          dcl 322 set ref 1182* 1189*
dm_error_$programming_error     000030 external static fixed bin(35,0)          dcl 322 set ref 1825*
dm_error_$record_not_found      000032 external static fixed bin(35,0)          dcl 322 set ref 1236* 1310
dm_error_$rel_cursor_spec_mismatch
                                000034 external static fixed bin(35,0)          dcl 322 set ref 736* 739* 745* 753* 756* 762* 771*
                                                                                  781* 786*
dm_error_$tuple_not_found       000036 external static fixed bin(35,0)          dcl 322 ref 565
dm_vector_util_$copy_typed_vector
                                000020 constant        entry                    external dcl 317 ref 1781 1867
dm_vector_util_$init_typed_vector_array
                                000102 constant        entry                    external dcl 1810 ref 1839
eil_number_of_elements          000252 automatic       fixed bin(35,0)          dcl 13-27 set ref 1204* 1206 1206 1244* 1245 1245
                                                                                  1914* 1915 1915
element_id_list                        based           structure                level 1 dcl 13-21 set ref 600 613 616 655 1206 1238
                                                                                  1245 1915 1936
element_id_list_ptr             000250 automatic       pointer                  dcl 13-26 set ref 417* 531* 535* 546* 549* 613 613
                                                                                  1205* 1221* 1229* 1245* 1246 1249 1256* 1297*
                                                                                  1303*
element_idx                     000133 automatic       fixed bin(17,0)          dcl 241 set ref 1209* 1210 1210* 1248* 1249 1249*
er_code                                parameter       fixed bin(35,0)          dcl 670 ref 667 672
error_table_$unimplemented_version
                                000040 external static fixed bin(35,0)          dcl 322 set ref 685* 699*
extended_arg_type               000402 automatic       fixed bin(17,0)          initial dcl 2-36 set ref 2-36*
f_tva_idx                       000100 automatic       fixed bin(17,0)          dcl 595 set ref 643* 644 644* 654* 655 655 655 658*
field_id                  6(18)        based           fixed bin(17,0)          array level 4 in structure "search_specification"
                                                                                  packed packed unaligned dcl 15-38 in procedure
                                                                                  "rlm_general_search" set ref 842 848* 858* 864*
                                                                                  864 896* 896
field_id                 12            based           fixed bin(17,0)          array level 4 in structure
                                                                                  "relation_search_specification" packed packed
                                                                                  unaligned dcl 8-9 in procedure
                                                                                  "rlm_general_search" ref 1124 1124
fil_interval_idx                000100 automatic       fixed bin(17,0)          dcl 942 set ref 947* 948 948*
fil_p_interval_list_ptr                parameter       pointer                  dcl 940 ref 937 944 947 948 948 952
file_opening_id           4            based           bit(36)                  initial level 2 in structure "relation_cursor"
                                                                                  dcl 3-18 in procedure "rlm_general_search" set ref
                                                                                  450* 1414* 1417*
file_opening_id           4     000160 automatic       bit(36)                  initial level 2 in structure "local_relation_cursor"
                                                                                  dcl 252 in procedure "rlm_general_search" set ref
                                                                                  252*
flags                                  based           structure                array level 2 in structure "return_eil_or_tva_array"
                                                                                  packed packed unaligned dcl 273 in procedure
                                                                                  "rlm_general_search"
flags                     5     000160 automatic       structure                level 2 in structure "local_relation_cursor" dcl 252
                                                                                  in procedure "rlm_general_search"
flags                     7     000160 automatic       structure                level 3 in structure "local_relation_cursor" dcl 252
                                                                                  in procedure "rlm_general_search"
flags                    11            based           structure                array level 3 in structure
                                                                                  "relation_search_specification" packed packed
                                                                                  unaligned dcl 8-9 in procedure
                                                                                  "rlm_general_search"
flags                     5            based           structure                level 2 in structure "relation_cursor" dcl 3-18
                                                                                  in procedure "rlm_general_search"
flags                     7            based           structure                level 3 in structure "relation_cursor" dcl 3-18
                                                                                  in procedure "rlm_general_search"
found_tuple                     000157 automatic       bit(1)                   initial dcl 248 set ref 248* 521* 523* 525
fs_and_group_idx                000412 automatic       fixed bin(17,0)          initial dcl 963 set ref 963* 974* 975 977*
fs_constraint_idx               000413 automatic       fixed bin(17,0)          initial dcl 964 set ref 964* 975* 977*
fs_dummy_value                         based           bit(1)                   packed unaligned dcl 965 ref 977
fs_specification_ptr                   parameter       pointer                  dcl 962 ref 959 967 967 967 970 970 974 975 977
ftva_dummy_value                       based           bit(1)                   packed unaligned dcl 995 ref 1012
ftva_typed_vector_array_ptr            parameter       pointer                  dcl 990 set ref 987 997 1000 1001 1004 1019 1024
                                                                                  1025*
ftva_value_idx                  000103 automatic       fixed bin(17,0)          dcl 994 set ref 1008* 1009 1012 1014*
ftva_vector_idx                 000102 automatic       fixed bin(17,0)          dcl 993 set ref 1000* 1001 1004 1019*
ftva_vector_ptr                 000100 automatic       pointer                  dcl 992 set ref 1004* 1005 1008 1009 1012 1014 1018
get_count                       000152 automatic       bit(1)                   initial dcl 248 set ref 248* 374* 565 1177 1307 1626
get_dm_free_area_               000012 constant        entry                    external dcl 314 ref 414
get_id                          000146 automatic       bit(1)                   initial dcl 248 set ref 248* 364* 479 531 575 584
                                                                                  600 1221 1297 1626
get_tuple                       000150 automatic       bit(1)                   initial dcl 248 set ref 248* 343* 353* 479 540 570
                                                                                  586 603 1225 1240 1300 1641
get_tuples_and_ids              000151 automatic       bit(1)                   initial dcl 248 set ref 248* 382* 398* 479 479 535
                                                                                  543 549 570 575 584 586 600 603 1229 1240 1303
                                                                                  1626
get_typed_vector_list           000147 automatic       bit(1)                   initial dcl 248 set ref 248* 344* 354* 383* 399* 570
                                                                                  582 586 597 603
hbound                                                 builtin function         dcl 286 ref 643 654 947 1350 1353 1774 1823 1825
                                                                                  1859 1922
head                                   based           structure                level 2 in structure "relation_search_specification"
                                                                                  dcl 8-9 in procedure "rlm_general_search" ref 1479
head                                   based           structure                level 2 in structure
                                                                                  "relation_numeric_specification" dcl 8-41
                                                                                  in procedure "rlm_general_search" ref 1490
head                                   based           structure                level 2 in structure "search_specification"
                                                                                  unaligned dcl 15-38 in procedure
                                                                                  "rlm_general_search" set ref 1479*
head                                   based           structure                level 2 in structure "numeric_specification"
                                                                                  unaligned dcl 15-63 in procedure
                                                                                  "rlm_general_search" set ref 1490*
id                        2     000176 automatic       fixed bin(17,0)          array level 2 in structure "local_id_list" dcl 255
                                                                                  in procedure "rlm_general_search" set ref 1636*
                                                                                  1719*
id                        2            based           fixed bin(17,0)          array level 2 in structure "id_list" dcl 12-16
                                                                                  in procedure "rlm_general_search" set ref 1668
                                                                                  1668* 1673 1679* 1697*
id                        2            based           bit(36)                  array level 2 in structure "element_id_list"
                                                                                  dcl 13-21 in procedure "rlm_general_search" set
                                                                                  ref 1210* 1249* 1933* 1933 1945*
id_list                                based           structure                level 1 dcl 12-16 set ref 610 948 1662 1694 1722
id_list_ptr                     000244 automatic       pointer                  initial dcl 12-21 set ref 417* 12-21* 610 610 610
                                                                                  610 1187* 1639* 1645* 1662* 1663 1665 1668 1679
                                                                                  1694* 1695 1697 1704* 1722 1722 1724*
il_number_of_ids                000246 automatic       fixed bin(17,0)          initial dcl 12-22 set ref 12-22* 1661* 1662 1662
                                                                                  1693* 1694 1694 1696
index                     4            based           structure                array level 2 dcl 7-18 ref 1350 1353
index_attribute_map                    based           structure                level 1 dcl 7-18
index_attribute_map_ptr
                         20            based           pointer                  initial level 2 in structure "relation_opening_info"
                                                                                  dcl 4-15 in procedure "rlm_general_search" ref 462
index_attribute_map_ptr         000226 automatic       pointer                  initial dcl 7-37 in procedure "rlm_general_search"
                                                                                  set ref 462* 463 7-37* 834 835 1350 1350 1353 1636
                                                                                  1668 1673 1673 1679 1687 1697 1719
index_id_idx                    000132 automatic       fixed bin(17,0)          dcl 241 set ref 1673* 1673* 1679 1679 1696* 1697
                                                                                  1697*
index_manager_$create_cursor    000070 constant        entry                    external dcl 19-38 ref 1417
index_manager_$destroy_cursor   000072 constant        entry                    external dcl 19-42 ref 634 1105 1429
index_manager_$get_key          000074 constant        entry                    external dcl 19-44 ref 1187
index_manager_$get_key_count_by_spec
                                000076 constant        entry                    external dcl 19-46 ref 1180
internal_cursor_ptr             000116 automatic       pointer                  initial dcl 234 set ref 234* 417* 501* 511* 578* 631
                                                                                  631 631* 634* 1180* 1187* 1297* 1300* 1303* 1307*
internal_record_cursor_ptr      000120 automatic       pointer                  initial dcl 234 set ref 234* 637 637 637* 1217 1217*
                                                                                  1221* 1225* 1229* 1233*
internal_specification_ptr      000114 automatic       pointer                  initial dcl 234 set ref 234* 417* 476* 515* 578* 625
                                                                                  625 625 629 1157 1162* 1171* 1180* 1187* 1203*
                                                                                  1221* 1225* 1229* 1233* 1297* 1300* 1303* 1307*
interval                  4            based           structure                array level 2 dcl 14-20 ref 947
interval_element_id_list_ptr    000110 automatic       pointer                  initial dcl 234 set ref 234* 616 616 1206* 1207 1210
                                                                                  1221* 1225* 1229* 1233* 1238
interval_list                          based           structure                level 1 dcl 14-20 set ref 952
interval_list_ptr               000254 automatic       pointer                  initial dcl 14-33 set ref 14-33* 619 619* 1187* 1191
                                                                                  1221* 1225* 1229* 1233* 1266*
intl_number_of_intervals        000256 automatic       fixed bin(17,0)          initial dcl 14-36 set ref 14-36*
is_element_id_list                     based           bit(1)                   array level 3 packed packed unaligned dcl 273 set
                                                                                  ref 655 1046* 1596* 1927
is_numeric_specification        000155 automatic       bit(1)                   initial dcl 248 set ref 248* 439* 471* 476* 491*
                                                                                  515* 625
is_relative_specification       000156 automatic       bit(1)                   initial dcl 248 set ref 248* 443* 471* 476* 494 1157
is_search_specification         000154 automatic       bit(1)                   initial dcl 248 set ref 248* 432* 467 471* 476* 491*
                                                                                  515* 578* 1157
local_element_id_list_ptr       000104 automatic       pointer                  dcl 231 set ref 366* 386* 402* 575* 584 600 600
local_id_list                   000176 automatic       structure                level 1 unaligned dcl 255 set ref 610 1639 1724
local_relation_cursor           000160 automatic       structure                level 1 dcl 252
local_return_eil_or_tva_entry   000202 automatic       structure                array level 1 unaligned dcl 260 set ref 660 1587
local_return_tva_entry          000206 automatic       structure                array level 1 unaligned dcl 264 set ref 647 1606
local_typed_vector_array_ptr    000102 automatic       pointer                  dcl 231 set ref 356* 401* 573* 586 603 603
local_typed_vector_list_ptr     000100 automatic       pointer                  dcl 231 set ref 346* 385* 570* 582 597 597
max                                                    builtin function         dcl 286 ref 479 479 529 1476 1585 1604
maximum_attribute_name_length
                          2(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-18 ref 1124
                                                                                  1124 1124 1124
maximum_dimension_name_length
                          4            based           fixed bin(17,0)          level 2 dcl 10-21 set ref 603 1001 1004 1019 1024
                                                                                  1210 1249 1781 1839* 1848 1851 1851 1851 1851 1851
                                                                                  1867 1867 1945
maximum_number_of_attributes_per_index
                          3            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 7-18 ref 834 834
                                                                                  835 835 1350 1350 1636 1636 1668 1668 1673 1673
                                                                                  1673 1673 1679 1679 1687 1687 1697 1697 1719 1719
maximum_number_of_constraints
                          4            based           fixed bin(17,0)          level 2 in structure "search_specification" packed
                                                                                  packed unaligned dcl 15-38 in procedure
                                                                                  "rlm_general_search" set ref 629 841 841 842 842
                                                                                  843 843 848 848 858 858 859 859 864 864 864 864
                                                                                  894 894 896 896 896 896 975 975 977 977 1131 1131
                                                                                  1478* 1483 1483 1541 1541 1549 1549 1549 1549 1549
                                                                                  1549 1549 1549 1549 1549
maximum_number_of_constraints
                          4            based           fixed bin(17,0)          level 2 in structure "relation_search_specification"
                                                                                  packed packed unaligned dcl 8-9 in procedure
                                                                                  "rlm_general_search" ref 771 771 771 771 771 771
                                                                                  1123 1123 1124 1124 1124 1124 1124 1124 1339 1339
                                                                                  1339 1339 1477 1541 1541 1543 1543 1549 1549 1549
                                                                                  1549 1549 1549 1549 1549 1549 1549
maximum_number_of_indices
                          2(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 7-18 ref 1350
                                                                                  1353
maximum_number_of_tuples_to_accept
                                000137 automatic       fixed bin(35,0)          initial dcl 244 set ref 244* 476* 482 515
maximum_number_of_vectors
                          1            based           fixed bin(35,0)          level 2 dcl 20-10 set ref 597 1766*
mbz                       0(01)        based           bit(71)                  array level 3 in structure "return_eil_or_tva_array"
                                                                                  packed packed unaligned dcl 273 in procedure
                                                                                  "rlm_general_search" set ref 1597*
mbz                       5(01) 000160 automatic       bit(35)                  initial level 3 in structure "local_relation_cursor"
                                                                                  packed packed unaligned dcl 252 in procedure
                                                                                  "rlm_general_search" set ref 252*
mbz                       7(01) 000160 automatic       bit(35)                  initial level 4 in structure "local_relation_cursor"
                                                                                  packed packed unaligned dcl 252 in procedure
                                                                                  "rlm_general_search" set ref 252*
min                                                    builtin function         dcl 286 ref 792 1476 1528 1535
myname                          000015 constant        varying char(32)         initial dcl 295 set ref 685* 699* 723* 728* 736*
                                                                                  739* 745* 753* 756* 762* 771* 781* 786* 1825*
null                                                   builtin function         dcl 286 ref 234 234 234 234 234 234 234 234 252 252
                                                                                  252 347 357 367 375 387 389 403 405 414 417 422
                                                                                  3-42 5-29 6-29 7-37 8-50 8-50 12-21 14-33 597 597
                                                                                  600 600 603 603 607 610 613 616 619 625 631 637
                                                                                  640 644 651 655 662 685 685 699 699 723 723 728
                                                                                  728 728 736 736 736 739 739 745 745 753 753 753
                                                                                  756 756 762 762 771 771 781 781 786 786 786 944
                                                                                  948 997 1001 1009 1014 1019 1025 1053 1074 1096
                                                                                  1101 1107 1117 1136 1157 1205 1217 1382 1393 1497
                                                                                  1598 1615 1645 1657 1704 1722 1751 1776 1823 1825
                                                                                  1825 1829 1862 1905 1924 1937
number_of_and_groups      4(18)        based           fixed bin(17,0)          level 2 in structure "relation_search_specification"
                                                                                  packed packed unaligned dcl 8-9 in procedure
                                                                                  "rlm_general_search" set ref 467 762 762 762 762*
                                                                                  762 792 1336 1476
number_of_and_groups            000140 automatic       fixed bin(35,0)          initial dcl 244 in procedure "rlm_general_search"
                                                                                  set ref 244* 467* 469* 479 479 482
number_of_and_groups      4(18)        based           fixed bin(17,0)          level 2 in structure "search_specification" packed
                                                                                  packed unaligned dcl 15-38 in procedure
                                                                                  "rlm_general_search" set ref 629 974 1478* 1483
                                                                                  1538
number_of_attributes      6            based           fixed bin(17,0)          array level 3 in structure "index_attribute_map"
                                                                                  packed packed unaligned dcl 7-18 in procedure
                                                                                  "rlm_general_search" ref 834 1636 1668 1673 1679
                                                                                  1687 1719
number_of_attributes      2            based           fixed bin(17,0)          level 2 in structure "attribute_info" packed packed
                                                                                  unaligned dcl 6-18 in procedure
                                                                                  "rlm_general_search" ref 1171 1687 1693
number_of_constraints
                          6            based           fixed bin(17,0)          array level 3 in structure "search_specification"
                                                                                  packed packed unaligned dcl 15-38 in procedure
                                                                                  "rlm_general_search" set ref 841 894 975 1483*
                                                                                  1541*
number_of_constraints
                         11(18)        based           fixed bin(17,0)          array level 3 in structure
                                                                                  "relation_search_specification" packed packed
                                                                                  unaligned dcl 8-9 in procedure
                                                                                  "rlm_general_search" ref 1123 1541 1543
number_of_dimensions      0(18)        based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  packed unaligned dcl 11-17 in procedure
                                                                                  "rlm_general_search" ref 1008 1018
number_of_dimensions      1            based           fixed bin(17,0)          level 2 in structure "typed_vector_array" dcl 10-21
                                                                                  in procedure "rlm_general_search" set ref 603 1001
                                                                                  1004 1019 1024 1210 1249 1781 1839* 1848 1850 1867
                                                                                  1867 1945
number_of_elements        1            based           fixed bin(35,0)          level 2 dcl 13-21 set ref 600 613 616 655 1049 1206*
                                                                                  1238 1245* 1905* 1915* 1930 1936
number_of_ids             1     000176 automatic       fixed bin(17,0)          level 2 in structure "local_id_list" dcl 255
                                                                                  in procedure "rlm_general_search" set ref 1638*
                                                                                  1720*
number_of_ids             1            based           fixed bin(17,0)          level 2 in structure "id_list" dcl 12-16
                                                                                  in procedure "rlm_general_search" set ref 610 948
                                                                                  1661 1662* 1665 1694* 1722
number_of_intervals       2            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 14-20 ref 947
                                                                                  952
number_of_tuples_accepted       000141 automatic       fixed bin(35,0)          initial dcl 244 set ref 244* 482 515 558* 558 565
                                                                                  570* 573* 575*
number_of_tuples_accepted_by_this_and_group
                                000142 automatic       fixed bin(35,0)          initial dcl 244 set ref 244* 531* 535* 538* 540*
                                                                                  546* 549* 552* 554* 558
number_of_vector_slots
                          3            based           fixed bin(17,0)          level 2 dcl 10-21 ref 603 1024
number_of_vectors         2            based           fixed bin(17,0)          level 2 in structure "typed_vector_array" dcl 10-21
                                                                                  in procedure "rlm_general_search" set ref 1000
                                                                                  1051 1072 1204 1209 1244 1248 1779 1829* 1857*
                                                                                  1865 1941
number_of_vectors         2            based           fixed bin(35,0)          level 2 in structure "typed_vector_list" dcl 20-10
                                                                                  in procedure "rlm_general_search" set ref 1771*
numeric_specification                  based           structure                level 1 unaligned dcl 15-63 set ref 625 967 1489
numeric_specification_ptr       000264 automatic       pointer                  dcl 15-70 set ref 417*
old_search_specification_ptr    000112 automatic       pointer                  initial dcl 234 set ref 234*
p_caller_area_ptr                      parameter       pointer                  dcl 218 ref 341 345 351 355 362 365 378 384 394 400
p_code                                 parameter       fixed bin(35,0)          dcl 227 set ref 341 351 362 372 378 394 450* 451
                                                                                  451* 565* 672*
p_element_id_list_ptr                  parameter       pointer                  dcl 221 set ref 362 366 367 367 378 386 389 389 394
                                                                                  402 405 405 584* 600
p_id_list_ptr                          parameter       pointer                  dcl 219 set ref 341 347 347 351 357 357 378 387 387
                                                                                  394 403 403 610 1225* 1229* 1256* 1300* 1303* 1657
                                                                                  1661 1668 1673
p_relation_cursor_ptr                  parameter       pointer                  dcl 220 ref 341 351 362 372 378 394 411
p_specification_ptr                    parameter       pointer                  dcl 217 ref 341 351 362 372 378 394 421
p_tuple_count                          parameter       fixed bin(35,0)          dcl 226 set ref 372 1180* 1233* 1307*
p_typed_vector_array_ptr               parameter       pointer                  dcl 222 set ref 351 356 394 401 586* 603
p_typed_vector_list_ptr                parameter       pointer                  dcl 224 set ref 341 346 378 385 582* 597
pad                       5(18)        based           bit(18)                  level 2 in structure "numeric_specification" packed
                                                                                  packed unaligned dcl 15-63 in procedure
                                                                                  "rlm_general_search" set ref 1495*
pad                       3            based           fixed bin(35,0)          level 2 in structure "typed_vector_list" dcl 20-10
                                                                                  in procedure "rlm_general_search" set ref 1768*
per_process               2            based           structure                level 2 dcl 4-15
position_number           5            based           fixed bin(17,0)          level 2 in structure "numeric_specification" packed
                                                                                  packed unaligned dcl 15-63 in procedure
                                                                                  "rlm_general_search" set ref 1463* 1492*
position_number           6            based           fixed bin(17,0)          level 2 in structure
                                                                                  "relation_numeric_specification" packed packed
                                                                                  unaligned dcl 8-41 in procedure
                                                                                  "rlm_general_search" ref 1463 1492
previous_collection_id          000127 automatic       bit(36)                  initial dcl 238 set ref 238* 490* 511*
ptr                                    based           pointer                  array level 2 in structure "return_tva_array"
                                                                                  dcl 281 in procedure "rlm_general_search" set ref
                                                                                  644 644* 1070* 1615* 1776 1779 1781* 1781 1789*
                                                                                  1823 1839 1839 1851 1862 1865 1867* 1867 1874*
ptr                       2            based           pointer                  array level 2 in structure "return_eil_or_tva_array"
                                                                                  dcl 273 in procedure "rlm_general_search" set ref
                                                                                  655 655 658* 1047* 1598* 1924 1930 1933 1936 1937*
                                                                                  1941 1945 1950*
range                     6            based           structure                level 2 in structure "relation_search_specification"
                                                                                  dcl 8-9 in procedure "rlm_general_search" ref 1481
range                     5            based           structure                level 2 in structure "search_specification" packed
                                                                                  packed unaligned dcl 15-38 in procedure
                                                                                  "rlm_general_search" set ref 1481*
range_size                4            based           fixed bin(35,0)          level 2 in structure "numeric_specification"
                                                                                  dcl 15-63 in procedure "rlm_general_search" set
                                                                                  ref 1462* 1494* 1528*
range_size                5            based           fixed bin(35,0)          level 2 in structure
                                                                                  "relation_numeric_specification" dcl 8-41
                                                                                  in procedure "rlm_general_search" ref 1462 1494
                                                                                  1503
rc_and_group_idx                       parameter       fixed bin(17,0)          dcl 1088 ref 1080 1111 1117 1123 1124 1124 1124
rc_code                         000506 automatic       fixed bin(35,0)          initial dcl 1097 set ref 1097* 1101* 1105* 1138
rc_collection_id                       parameter       bit(36)                  dcl 1089 ref 1080 1112
rc_constraint_idx               000502 automatic       fixed bin(17,0)          initial dcl 1095 set ref 1095* 1123* 1124 1124 1124
                                                                                  1131*
rc_cursor_ptr                          parameter       pointer                  dcl 1092 set ref 1080 1101 1115 1136*
rc_is_search_specification             parameter       bit(1)                   dcl 1093 ref 1080 1117
rc_search_records                      parameter       bit(1)                   dcl 1091 ref 1080 1114
rc_specification_ptr                   parameter       pointer                  dcl 1090 set ref 1080 1107 1113 1117 1131 1136*
rc_value_ptr                    000504 automatic       pointer                  initial dcl 1096 set ref 1096* 1124* 1131
record_collection_id      3            based           bit(36)                  initial level 2 dcl 5-15 set ref 631 781 1101 1217*
                                                                                  1336 1341 1344 1346
record_cursor_ptr        10            based           pointer                  initial level 3 dcl 4-15 ref 1256
record_id_idx                   000131 automatic       fixed bin(17,0)          dcl 241 set ref 1665* 1668 1668 1673 1679*
record_manager_$create_cursor   000042 constant        entry                    external dcl 18-29 ref 1414
record_manager_$destroy_cursor  000044 constant        entry                    external dcl 18-33 ref 631 637 1101 1427
record_manager_$get_record_count
                                000064 constant        entry                    external dcl 18-52 ref 1307
record_manager_$get_record_count_by_interval
                                000066 constant        entry                    external dcl 18-54 ref 1233
record_manager_$get_record_ids_by_interval
                                000062 constant        entry                    external dcl 18-50 ref 1221
record_manager_$get_record_ids_by_spec
                                000060 constant        entry                    external dcl 18-48 ref 1297
record_manager_$get_records_and_ids_by_interval
                                000056 constant        entry                    external dcl 18-46 ref 1229
record_manager_$get_records_and_ids_by_spec
                                000054 constant        entry                    external dcl 18-44 ref 1303
record_manager_$get_records_by_id_list
                                000046 constant        entry                    external dcl 18-38 ref 1256
record_manager_$get_records_by_interval
                                000052 constant        entry                    external dcl 18-42 ref 1225
record_manager_$get_records_by_spec
                                000050 constant        entry                    external dcl 18-40 ref 1300
reil_based_b36a                        based           bit(36)                  dcl 1901 ref 1945
reil_code                       000765 automatic       fixed bin(35,0)          initial dcl 1900 set ref 1900*
reil_eil_or_tva_idx             000762 automatic       fixed bin(17,0)          dcl 1895 set ref 1922* 1924 1927 1930 1933 1936 1937
                                                                                  1941 1945 1950*
reil_element_id_list_ptr               parameter       pointer                  dcl 1893 set ref 1882 1905 1905 1915* 1917 1933 1945
reil_id_idx                     000764 automatic       fixed bin(17,0)          dcl 1895 set ref 1930* 1933* 1941* 1945*
reil_number_of_ids                     parameter       fixed bin(35,0)          dcl 1892 ref 1882 1903 1905 1914
reil_return_id_idx              000763 automatic       fixed bin(17,0)          dcl 1895 set ref 1920* 1932* 1932 1933 1944* 1944
                                                                                  1945
relation_cursor                        based           structure                level 1 dcl 3-18
relation_cursor_ptr             000216 automatic       pointer                  initial dcl 3-42 set ref 411* 413 450 3-42* 622 625
                                                                                  631 637 717 723 728 736 739 739 745 745 753 756
                                                                                  756 762 762 762 771 771 771 771 771 781 781 786
                                                                                  790 926 1099 1101 1101 1101 1101 1105 1107 1107
                                                                                  1107 1111 1112 1113 1114 1115 1138 1161 1382 1382
                                                                                  1382 1386 1414 1414 1417 1417 1456 1478 1489
relation_header                        based           structure                level 1 dcl 5-15
relation_header_ptr      14            based           pointer                  initial level 2 in structure "relation_opening_info"
                                                                                  dcl 4-15 in procedure "rlm_general_search" ref 456
relation_header_ptr             000222 automatic       pointer                  initial dcl 5-29 in procedure "rlm_general_search"
                                                                                  set ref 456* 457 5-29* 631 781 1101 1217 1336 1341
                                                                                  1344 1346
relation_numeric_specification         based           structure                level 1 dcl 8-41
relation_numeric_specification_ptr
                                000234 automatic       pointer                  initial dcl 8-50 set ref 417* 440* 8-50* 745 745
                                                                                  1342 1462 1463 1490 1492 1494 1503
relation_opening_info                  based           structure                level 1 dcl 4-15
relation_opening_info_ptr       000220 automatic       pointer                  dcl 4-41 set ref 450* 454 456 459 462 1256
relation_search_specification          based           structure                level 1 dcl 8-9
relation_search_specification_ptr
                                000232 automatic       pointer                  initial dcl 8-50 set ref 417* 433* 467 8-50* 762 762
                                                                                  762 762 762 771 771 771 792 1123 1124 1124 1124
                                                                                  1336 1339 1339 1470 1476 1477 1479 1481 1499 1499
                                                                                  1541 1543 1549
reota_number_of_entries         000143 automatic       fixed bin(35,0)          initial dcl 244 set ref 244* 654 660 1585* 1591 1595
                                                                                  1596 1597 1598 1922
return_eil_or_tva_array                based           structure                array level 1 dcl 273 set ref 654 660 1591 1595*
                                                                                  1922
return_eil_or_tva_array_ptr     000122 automatic       pointer                  initial dcl 234 set ref 234* 479* 651 654 655 655
                                                                                  655 658 660 660 662* 1046 1047 1591* 1592 1922
                                                                                  1924 1927 1930 1933 1936 1937 1941 1945 1950
return_structure_idx            000136 automatic       fixed bin(17,0)          dcl 241 set ref 529* 531* 535* 538* 540* 546* 549*
                                                                                  552* 554*
return_tva_array                       based           structure                array level 1 dcl 281 set ref 643 647 1610 1614*
                                                                                  1774 1823 1825 1859
return_tva_array_ptr            000124 automatic       pointer                  initial dcl 234 set ref 234* 479* 640 643 644 644
                                                                                  647 647 1070 1610* 1611 1774 1776 1779 1781 1781
                                                                                  1789 1823 1823 1825 1839 1839 1851 1859 1862 1865
                                                                                  1867 1867 1874
ritr_and_group_idx                     parameter       fixed bin(17,0)          dcl 1041 ref 1032 1046 1047
ritr_eil_or_tva_ptr                    parameter       pointer                  dcl 1042 set ref 1032 1047 1049 1051 1053*
ritr_is_element_id_list                parameter       bit(1)                   dcl 1039 ref 1032 1046 1049
ritr_number_of_tuple_ids               parameter       fixed bin(35,0)          dcl 1043 set ref 1032 1049* 1051*
rlm_opening_info$get            000014 constant        entry                    external dcl 315 ref 450
rss_maximum_number_of_constraints
                                000237 automatic       fixed bin(17,0)          initial dcl 8-52 set ref 8-52*
rss_number_of_and_groups        000236 automatic       fixed bin(17,0)          initial dcl 8-52 set ref 8-52*
rta_number_of_entries           000144 automatic       fixed bin(35,0)          initial dcl 244 set ref 244* 643 647 1604* 1610 1614
                                                                                  1615 1774 1823 1825 1859
rttr_and_group_idx                     parameter       fixed bin(17,0)          dcl 1065 ref 1059 1070
rttr_number_of_tuples                  parameter       fixed bin(35,0)          dcl 1067 set ref 1059 1072*
rttr_tva_ptr                           parameter       pointer                  dcl 1066 set ref 1059 1070 1072 1074*
rtva_code                       000742 automatic       fixed bin(35,0)          initial dcl 1812 set ref 1812* 1839* 1843 1843*
                                                                                  1867* 1870 1870*
rtva_dimension_idx              000743 automatic       fixed bin(17,0)          dcl 1813 set ref 1850* 1851 1851*
rtva_number_of_vectors                 parameter       fixed bin(35,0)          dcl 1807 set ref 1800 1820 1825* 1829 1839* 1857
                                                                                  1859
rtva_return_vector_idx          000744 automatic       fixed bin(17,0)          dcl 1813 set ref 1858* 1859 1867 1872* 1872
rtva_tva_idx                    000745 automatic       fixed bin(17,0)          dcl 1813 set ref 1823* 1823* 1825 1839 1839 1851
                                                                                  1859* 1859* 1862 1865 1867 1867 1874*
rtva_typed_vector_array_ptr            parameter       pointer                  dcl 1808 set ref 1800 1829 1829 1839* 1845 1848 1850
                                                                                  1851 1857 1867
rtva_vector_idx                 000746 automatic       fixed bin(17,0)          dcl 1813 set ref 1865* 1867*
rtvl_code                       000726 automatic       fixed bin(35,0)          dcl 1743 set ref 1781* 1784 1784*
rtvl_number_of_vectors                 parameter       fixed bin(35,0)          dcl 1740 ref 1732 1748 1765 1771 1774
rtvl_return_vector_idx          000731 automatic       fixed bin(17,0)          dcl 1746 set ref 1773* 1774 1781 1786* 1786
rtvl_tva_idx                    000727 automatic       fixed bin(17,0)          dcl 1744 set ref 1774* 1776 1779 1781 1781 1789*
rtvl_typed_vector_list_ptr             parameter       pointer                  dcl 1741 set ref 1732 1751 1757 1794*
rtvl_vector_idx                 000730 automatic       fixed bin(17,0)          dcl 1745 set ref 1779* 1781*
scci_and_group_idx                     parameter       fixed bin(17,0)          dcl 1332 ref 1318 1339 1339
scci_collection_id                     parameter       bit(36)                  dcl 1333 set ref 1318 1336* 1339* 1341* 1342* 1344*
                                                                                  1346 1350
scci_index_idx                         parameter       fixed bin(17,0)          dcl 1334 set ref 1318 1346* 1350* 1350* 1353
scci_is_numeric_specification          parameter       bit(1)                   dcl 1330 ref 1318 1342
scci_is_search_specification           parameter       bit(1)                   dcl 1328 ref 1318 1336
search_collection_id     10            based           bit(36)                  array level 3 dcl 8-9 set ref 771 771* 1339
search_index_and_record_collection
                          7            based           bit(1)                   initial level 4 in structure "relation_cursor"
                                                                                  packed packed unaligned dcl 3-18 in procedure
                                                                                  "rlm_general_search" set ref 1114* 1161
search_index_and_record_collection
                          7     000160 automatic       bit(1)                   initial level 4 in structure "local_relation_cursor"
                                                                                  packed packed unaligned dcl 252 in procedure
                                                                                  "rlm_general_search" set ref 252*
search_records                  000153 automatic       bit(1)                   initial dcl 248 set ref 248* 488* 531 546 578* 1161*
                                                                                  1162 1171* 1177 1194 1295* 1626 1646
search_specification                   based           structure                level 1 unaligned dcl 15-38 set ref 629 1478
search_specification_ptr        000260 automatic       pointer                  dcl 15-58 set ref 417* 828* 841 842 843 848 858 859
                                                                                  864 864
ser_code                               parameter       fixed bin(35,0)          dcl 1273 set ref 1270 1276 1276 1276*
ser_non_fatal_code                     parameter       fixed bin(35,0)          dcl 1273 ref 1270 1276
si_code                         000540 automatic       fixed bin(35,0)          initial dcl 1149 set ref 1149* 1180* 1182 1182*
                                                                                  1187* 1189 1189* 1221* 1225* 1229* 1233* 1236
                                                                                  1236* 1256* 1258 1258* 1263
si_p_found_tuple                       parameter       bit(1)                   dcl 1148 set ref 1145 1263*
sic_code                        000600 automatic       fixed bin(35,0)          dcl 1372 set ref 1414* 1417* 1419 1419* 1427* 1429*
                                                                                  1430 1430*
sic_collection_id                      parameter       bit(36)                  dcl 1368 set ref 1361 1382 1386 1395 1414* 1417*
sic_cursor_ptr                         parameter       pointer                  dcl 1373 set ref 1361 1382* 1393 1414* 1417* 1427*
                                                                                  1429*
sic_from_relation_cursor               parameter       bit(1)                   dcl 1370 ref 1361 1375
sic_is_record_collection               parameter       bit(1)                   dcl 1370 ref 1361 1414 1427
sic_previous_collection_id             parameter       bit(36)                  dcl 1368 ref 1361 1395
simple_typed_vector                    based           structure                level 1 packed packed unaligned dcl 11-17 set ref
                                                                                  1018
sis_is_numeric_specification           parameter       bit(1)                   dcl 1445 ref 1439 1458 1486 1503
sis_is_relative_specification          parameter       bit(1)                   dcl 1447 ref 1439 1453
sis_is_search_specification            parameter       bit(1)                   dcl 1443 ref 1439 1466 1473 1499
sis_maximum_number_of_tuples_to_accept parameter       fixed bin(35,0)          dcl 1450 set ref 1439 1499* 1502* 1503* 1505*
sis_specification_ptr                  parameter       pointer                  dcl 1449 set ref 1439 1456* 1461 1462 1463 1469 1470
                                                                                  1478* 1479 1480 1481 1483 1483 1489* 1490 1491
                                                                                  1492 1494 1495 1497*
sisftag_and_group_idx                  parameter       fixed bin(17,0)          dcl 1525 ref 1511 1541 1543 1549 1549 1549 1549 1549
sisftag_constraint_idx          000633 automatic       fixed bin(17,0)          dcl 1525 set ref 1543* 1549 1549 1549 1549 1549 1549
                                                                                  1549 1549 1549 1549*
sisftag_is_numeric_specification       parameter       bit(1)                   dcl 1519 ref 1511 1528
sisftag_is_search_specification        parameter       bit(1)                   dcl 1517 ref 1511 1532
sisftag_maximum_number_of_tuples_to_accept
                                       parameter       fixed bin(35,0)          dcl 1521 ref 1511 1528 1535
sisftag_specification_ptr              parameter       pointer                  dcl 1515 ref 1511 1528 1535 1538 1541 1549
sisftag_total_number_of_constraints
                                000632 automatic       fixed bin(17,0)          initial dcl 1523 set ref 1523*
size                      7            based           fixed bin(17,0)          level 3 in structure "relation_search_specification"
                                                                                  dcl 8-9 in procedure "rlm_general_search" ref 1470
                                                                                  1499
size                      5(18)        based           fixed bin(17,0)          level 3 in structure "search_specification" packed
                                                                                  packed unaligned dcl 15-38 in procedure
                                                                                  "rlm_general_search" set ref 1470* 1535*
specification_head                     based           structure                level 1 unaligned dcl 9-10
specification_head_ptr          000240 automatic       pointer                  dcl 9-18 set ref 421* 422 425 428 428 433 435 435
                                                                                  440 443 443
specification_ptr        12     000160 automatic       pointer                  initial level 3 in structure "local_relation_cursor"
                                                                                  dcl 252 in procedure "rlm_general_search" set ref
                                                                                  252*
specification_ptr        12            based           pointer                  initial level 3 in structure "relation_cursor"
                                                                                  dcl 3-18 in procedure "rlm_general_search" set ref
                                                                                  625 736 739 739 753 756 756 786 1107 1107 1107*
                                                                                  1113* 1456
src_code                        000560 automatic       fixed bin(35,0)          initial dcl 1289 set ref 1289* 1297* 1300* 1303*
                                                                                  1307* 1310 1310 1310* 1314
src_p_found_tuple                      parameter       bit(1)                   dcl 1288 set ref 1285 1314*
srs_maximum_number_of_return_structures
                                       parameter       fixed bin(35,0)          dcl 1573 ref 1562 1585 1587 1604 1606
srs_return_eil_or_tva_array_ptr        parameter       pointer                  dcl 1577 set ref 1562 1587* 1592* 1595 1596 1597
                                                                                  1598
srs_return_tva_array_ptr               parameter       pointer                  dcl 1579 set ref 1562 1606* 1611* 1614 1615
srs_setup_for_ids                      parameter       bit(1)                   dcl 1575 ref 1562 1582
srs_setup_for_tuples                   parameter       bit(1)                   dcl 1576 ref 1562 1601
ss_maximum_number_of_constraints
                                000263 automatic       fixed bin(17,0)          dcl 15-60 set ref 1477* 1478 1478
ss_number_of_and_groups         000262 automatic       fixed bin(17,0)          dcl 15-60 set ref 1476* 1478 1478
sub_err_                        000016 constant        entry                    external dcl 316 ref 685 699 723 728 736 739 745 753
                                                                                  756 762 771 781 786 1825
tvl_maximum_number_of_vectors   000270 automatic       fixed bin(35,0)          dcl 20-21 set ref 1765* 1766 1766
type                      1            based           fixed bin(17,0)          level 3 in structure "search_specification" packed
                                                                                  packed unaligned dcl 15-38 in procedure
                                                                                  "rlm_general_search" set ref 1469* 1480*
type                                   based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  packed unaligned dcl 11-17 in procedure
                                                                                  "rlm_general_search" ref 1005
type                      1            based           fixed bin(17,0)          level 3 in structure "numeric_specification" packed
                                                                                  packed unaligned dcl 15-63 in procedure
                                                                                  "rlm_general_search" set ref 1461* 1491*
type                      6            based           fixed bin(17,0)          level 3 in structure "relation_search_specification"
                                                                                  dcl 8-9 in procedure "rlm_general_search" ref 1499
type                      0(01)        based           fixed bin(6,0)           level 2 in structure "arg_descriptor" packed packed
                                                                                  unsigned unaligned dcl 2-6 in procedure
                                                                                  "COPY_VALUE" ref 919 921
type                      1            based           fixed bin(17,0)          level 2 in structure "specification_head" packed
                                                                                  packed unaligned dcl 9-10 in procedure
                                                                                  "rlm_general_search" ref 428 428 435 435 443 443
                                                                                  739 739 756 756 967 967 970 970
typed_vector_array                     based           structure                level 1 dcl 10-21 set ref 603 1024
typed_vector_array_ptr          000242 automatic       pointer                  dcl 10-43 set ref 417* 538* 540* 552* 554* 607 607*
                                                                                  1187* 1204 1209 1210 1215* 1225* 1229* 1244 1248
                                                                                  1249 1254* 1256* 1300* 1303*
typed_vector_list                      based           structure                level 1 dcl 20-10 set ref 597 1766
typed_vector_list_ptr           000266 automatic       pointer                  dcl 20-18 set ref 1757* 1766* 1767 1768 1771 1781
                                                                                  1794
unspec                                                 builtin function         dcl 286 set ref 923 923 1595* 1614* 1848*
value_field_id            7(18)        based           fixed bin(17,0)          array level 4 packed packed unaligned dcl 15-38 set
                                                                                  ref 843 859*
value_ptr                10(18)        based           pointer                  array level 4 in structure "search_specification"
                                                                                  packed packed unaligned dcl 15-38 in procedure
                                                                                  "rlm_general_search" set ref 977 1131*
value_ptr                 1            based           pointer                  array level 3 in structure "simple_typed_vector"
                                                                                  packed packed unaligned dcl 11-17 in procedure
                                                                                  "rlm_general_search" set ref 1009 1012 1014* 1210
                                                                                  1249 1945
value_ptr                14            based           pointer                  array level 4 in structure
                                                                                  "relation_search_specification" dcl 8-9
                                                                                  in procedure "rlm_general_search" set ref 1124*
varying_bit_dtype                      constant        fixed bin(17,0)          initial dcl 1-25 ref 921
varying_char_dtype                     constant        fixed bin(17,0)          initial dcl 1-25 ref 919
vector_ptr                4            based           pointer                  array level 2 dcl 20-10 set ref 1781*
vector_slot                            based           pointer                  array level 2 dcl 10-21 set ref 1001 1004 1019* 1210
                                                                                  1249 1781* 1867* 1867* 1945
version                                based           fixed bin(35,0)          level 2 in structure "typed_vector_array" dcl 10-21
                                                                                  in procedure "rlm_general_search" set ref 1845*
version                                based           fixed bin(17,0)          level 2 in structure "typed_vector_list" dcl 20-10
                                                                                  in procedure "rlm_general_search" set ref 1767*
version                                based           char(8)                  level 2 in structure "interval_list" dcl 14-20
                                                                                  in procedure "rlm_general_search" set ref 1191*
version                                based           fixed bin(35,0)          level 2 in structure "id_list" dcl 12-16
                                                                                  in procedure "rlm_general_search" set ref 347*
                                                                                  357* 387* 403* 1663* 1695*
version                                based           char(8)                  level 2 in structure "relation_header" dcl 5-15
                                                                                  in procedure "rlm_general_search" set ref 457*
version                                based           char(8)                  level 2 in structure "relation_opening_info"
                                                                                  dcl 4-15 in procedure "rlm_general_search" set ref
                                                                                  454*
version                         000176 automatic       fixed bin(35,0)          level 2 in structure "local_id_list" dcl 255
                                                                                  in procedure "rlm_general_search" set ref 1637*
                                                                                  1721*
version                                based           fixed bin(35,0)          level 2 in structure "element_id_list" dcl 13-21
                                                                                  in procedure "rlm_general_search" set ref 367*
                                                                                  389* 405* 1207* 1246* 1917*
version                                based           char(8)                  level 2 in structure "relation_cursor" dcl 3-18
                                                                                  in procedure "rlm_general_search" set ref 413*
                                                                                  717*
version                                based           char(8)                  level 2 in structure "index_attribute_map" dcl 7-18
                                                                                  in procedure "rlm_general_search" set ref 463*
version                                based           fixed bin(35,0)          level 2 in structure "specification_head" dcl 9-10
                                                                                  in procedure "rlm_general_search" set ref 425*
version                                based           char(8)                  level 2 in structure "attribute_info" dcl 6-18
                                                                                  in procedure "rlm_general_search" set ref 460*
work_area                              based           area(1024)               dcl 270 ref 610 613 616 625 647 660 926 1206 1245
                                                                                  1478 1489 1591 1610 1662 1694 1722
work_area_ptr                   000010 internal static pointer                  initial dcl 335 in procedure "rlm_general_search"
                                                                                  set ref 414 414* 610 613 616 625 647 660 1187*
                                                                                  1206 1221* 1225* 1229* 1245 1256* 1297* 1300*
                                                                                  1303* 1591 1610 1662 1694 1722
work_area_ptr             2     000160 automatic       pointer                  initial level 2 in structure "local_relation_cursor"
                                                                                  dcl 252 in procedure "rlm_general_search" set ref
                                                                                  252*
work_area_ptr             2            based           pointer                  initial level 2 in structure "relation_cursor"
                                                                                  dcl 3-18 in procedure "rlm_general_search" set ref
                                                                                  926 1414* 1417* 1478 1489

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 17-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 17-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 17-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 17-7
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 11-43
HIGH_RANGE_TYPE                        internal static fixed bin(17,0)          initial dcl 16-8
IS_INDEX_COLLECTION                    internal static bit(1)                   initial dcl 303
LOW_RANGE_TYPE                         internal static fixed bin(17,0)          initial dcl 16-8
NUMERIC_SPECIFICATION_TYPE             internal static fixed bin(17,0)          initial dcl 9-22
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 11-43
SEARCH_SPECIFICATION_TYPE              internal static fixed bin(17,0)          initial dcl 9-22
ai_maximum_attribute_name_length       automatic       fixed bin(17,0)          dcl 6-30
ai_number_of_attributes                automatic       fixed bin(17,0)          dcl 6-32
algol68_array_descriptor_dtype         internal static fixed bin(17,0)          initial dcl 1-25
algol68_bits_dtype                     internal static fixed bin(17,0)          initial dcl 1-110
algol68_bool_dtype                     internal static fixed bin(17,0)          initial dcl 1-110
algol68_byte_dtype                     internal static fixed bin(17,0)          initial dcl 1-110
algol68_char_dtype                     internal static fixed bin(17,0)          initial dcl 1-110
algol68_compl_dtype                    internal static fixed bin(17,0)          initial dcl 1-110
algol68_format_dtype                   internal static fixed bin(17,0)          initial dcl 1-25
algol68_int_dtype                      internal static fixed bin(17,0)          initial dcl 1-110
algol68_long_compl_dtype               internal static fixed bin(17,0)          initial dcl 1-110
algol68_long_int_dtype                 internal static fixed bin(17,0)          initial dcl 1-110
algol68_long_real_dtype                internal static fixed bin(17,0)          initial dcl 1-110
algol68_real_dtype                     internal static fixed bin(17,0)          initial dcl 1-110
algol68_short_int_dtype                internal static fixed bin(17,0)          initial dcl 1-110
algol68_straight_dtype                 internal static fixed bin(17,0)          initial dcl 1-25
algol68_struct_struct_bool_dtype       internal static fixed bin(17,0)          initial dcl 1-110
algol68_struct_struct_char_dtype       internal static fixed bin(17,0)          initial dcl 1-110
algol68_union_dtype                    internal static fixed bin(17,0)          initial dcl 1-25
area_dtype                             internal static fixed bin(17,0)          initial dcl 1-25
bit_dtype                              internal static fixed bin(17,0)          initial dcl 1-25
c_enum_const_dtype                     internal static fixed bin(17,0)          initial dcl 1-25
c_enum_dtype                           internal static fixed bin(17,0)          initial dcl 1-25
c_typeref_dtype                        internal static fixed bin(17,0)          initial dcl 1-25
c_union_dtype                          internal static fixed bin(17,0)          initial dcl 1-25
char_dtype                             internal static fixed bin(17,0)          initial dcl 1-25
cobol_char_string_dtype                internal static fixed bin(17,0)          initial dcl 1-25
cobol_comp_5_ts_dtype                  internal static fixed bin(17,0)          initial dcl 1-25
cobol_comp_5_uns_dtype                 internal static fixed bin(17,0)          initial dcl 1-25
cobol_comp_6_dtype                     internal static fixed bin(17,0)          initial dcl 1-25
cobol_comp_7_dtype                     internal static fixed bin(17,0)          initial dcl 1-25
cobol_comp_8_ls_dtype                  internal static fixed bin(17,0)          initial dcl 1-25
cobol_comp_8_uns_dtype                 internal static fixed bin(17,0)          initial dcl 1-25
cobol_display_ls_dtype                 internal static fixed bin(17,0)          initial dcl 1-25
cobol_display_ls_overp_dtype           internal static fixed bin(17,0)          initial dcl 1-25
cobol_display_ts_dtype                 internal static fixed bin(17,0)          initial dcl 1-25
cobol_display_ts_overp_dtype           internal static fixed bin(17,0)          initial dcl 1-25
cobol_display_uns_dtype                internal static fixed bin(17,0)          initial dcl 1-25
cobol_structure_dtype                  internal static fixed bin(17,0)          initial dcl 1-25
cplx_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 1-25
cplx_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 1-25
cplx_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 1-25
cplx_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 1-25
cplx_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 1-25
cplx_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 1-25
cplx_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 1-25
cplx_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 1-25
cplx_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 1-25
cplx_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 1-25
cplx_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 1-25
cplx_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 1-25
cplx_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 1-25
entry_dtype                            internal static fixed bin(17,0)          initial dcl 1-25
ext_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 1-125
ext_procedure_runtime_dtype            internal static fixed bin(17,0)          initial dcl 1-125
extended_arg_descriptor                based           structure                level 1 dcl 2-21
file_dtype                             internal static fixed bin(17,0)          initial dcl 1-25
fixed_arg_descriptor                   based           structure                level 1 dcl 2-13
ft_char_dtype                          internal static fixed bin(17,0)          initial dcl 1-96
ft_complex_double_dtype                internal static fixed bin(17,0)          initial dcl 1-96
ft_complex_dtype                       internal static fixed bin(17,0)          initial dcl 1-96
ft_double_dtype                        internal static fixed bin(17,0)          initial dcl 1-96
ft_external_dtype                      internal static fixed bin(17,0)          initial dcl 1-96
ft_hex_complex_double_dtype            internal static fixed bin(17,0)          initial dcl 1-96
ft_hex_complex_dtype                   internal static fixed bin(17,0)          initial dcl 1-96
ft_hex_double_dtype                    internal static fixed bin(17,0)          initial dcl 1-96
ft_hex_real_dtype                      internal static fixed bin(17,0)          initial dcl 1-96
ft_integer_dtype                       internal static fixed bin(17,0)          initial dcl 1-96
ft_logical_dtype                       internal static fixed bin(17,0)          initial dcl 1-96
ft_real_dtype                          internal static fixed bin(17,0)          initial dcl 1-96
general_typed_vector                   based           structure                level 1 packed packed unaligned dcl 11-24
general_typed_vector_ptr               automatic       pointer                  dcl 11-38
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 11-40
iam_maximum_number_of_attributes_per_index
                                       automatic       fixed bin(17,0)          dcl 7-41
iam_maximum_number_of_indices          automatic       fixed bin(17,0)          dcl 7-39
index_manager_$create_index     000000 constant        entry                    external dcl 19-39
index_manager_$create_subset_index
                                000000 constant        entry                    external dcl 19-40
index_manager_$delete_key       000000 constant        entry                    external dcl 19-41
index_manager_$destroy_index    000000 constant        entry                    external dcl 19-43
index_manager_$get_key_count_array
                                000000 constant        entry                    external dcl 19-45
index_manager_$position_cursor  000000 constant        entry                    external dcl 19-47
index_manager_$put_key          000000 constant        entry                    external dcl 19-48
index_manager_$put_key_array    000000 constant        entry                    external dcl 19-49
int_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 1-125
label_constant_runtime_dtype           internal static fixed bin(17,0)          initial dcl 1-125
label_dtype                            internal static fixed bin(17,0)          initial dcl 1-25
offset_dtype                           internal static fixed bin(17,0)          initial dcl 1-25
pascal_boolean_dtype                   internal static fixed bin(17,0)          initial dcl 1-132
pascal_char_dtype                      internal static fixed bin(17,0)          initial dcl 1-132
pascal_entry_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 1-132
pascal_enumerated_type_dtype           internal static fixed bin(17,0)          initial dcl 1-132
pascal_enumerated_type_element_dtype   internal static fixed bin(17,0)          initial dcl 1-132
pascal_enumerated_type_instance_dtype  internal static fixed bin(17,0)          initial dcl 1-132
pascal_exportable_procedure_dtype      internal static fixed bin(17,0)          initial dcl 1-132
pascal_imported_procedure_dtype        internal static fixed bin(17,0)          initial dcl 1-132
pascal_integer_dtype                   internal static fixed bin(17,0)          initial dcl 1-132
pascal_internal_procedure_dtype        internal static fixed bin(17,0)          initial dcl 1-132
pascal_label_dtype                     internal static fixed bin(17,0)          initial dcl 1-132
pascal_parameter_procedure_dtype       internal static fixed bin(17,0)          initial dcl 1-132
pascal_procedure_type_dtype            internal static fixed bin(17,0)          initial dcl 1-132
pascal_real_dtype                      internal static fixed bin(17,0)          initial dcl 1-132
pascal_record_file_type_dtype          internal static fixed bin(17,0)          initial dcl 1-132
pascal_record_type_dtype               internal static fixed bin(17,0)          initial dcl 1-132
pascal_set_dtype                       internal static fixed bin(17,0)          initial dcl 1-132
pascal_string_type_dtype               internal static fixed bin(17,0)          initial dcl 1-132
pascal_text_file_dtype                 internal static fixed bin(17,0)          initial dcl 1-132
pascal_typed_pointer_type_dtype        internal static fixed bin(17,0)          initial dcl 1-132
pascal_user_defined_type_dtype         internal static fixed bin(17,0)          initial dcl 1-132
pascal_user_defined_type_instance_dtype
                                       internal static fixed bin(17,0)          initial dcl 1-132
pascal_value_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 1-132
pascal_variable_formal_parameter_dtype internal static fixed bin(17,0)          initial dcl 1-132
picture_runtime_dtype                  internal static fixed bin(17,0)          initial dcl 1-125
pointer_dtype                          internal static fixed bin(17,0)          initial dcl 1-25
real_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 1-25
real_fix_bin_1_uns_dtype               internal static fixed bin(17,0)          initial dcl 1-25
real_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 1-25
real_fix_bin_2_uns_dtype               internal static fixed bin(17,0)          initial dcl 1-25
real_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 1-25
real_fix_dec_4bit_bytealigned_uns_dtype
                                       internal static fixed bin(17,0)          initial dcl 1-25
real_fix_dec_4bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 1-25
real_fix_dec_4bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 1-25
real_fix_dec_4bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 1-25
real_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 1-25
real_fix_dec_9bit_ls_overp_dtype       internal static fixed bin(17,0)          initial dcl 1-25
real_fix_dec_9bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 1-25
real_fix_dec_9bit_ts_overp_dtype       internal static fixed bin(17,0)          initial dcl 1-25
real_fix_dec_9bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 1-25
real_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 1-25
real_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 1-25
real_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 1-25
real_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 1-25
real_flt_dec_4bit_dtype                internal static fixed bin(17,0)          initial dcl 1-25
real_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 1-25
real_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 1-25
real_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 1-25
real_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 1-25
real_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 1-25
record_manager_$create_collection
                                000000 constant        entry                    external dcl 18-27
record_manager_$delete_record_by_id
                                000000 constant        entry                    external dcl 18-63
record_manager_$delete_records_by_id_list
                                000000 constant        entry                    external dcl 18-66
record_manager_$delete_records_by_spec
                                000000 constant        entry                    external dcl 18-69
record_manager_$destroy_collection
                                000000 constant        entry                    external dcl 18-31
record_manager_$get_record_by_id
                                000000 constant        entry                    external dcl 18-36
record_manager_$modify_record_by_id
                                000000 constant        entry                    external dcl 18-72
record_manager_$modify_records_by_id_list
                                000000 constant        entry                    external dcl 18-75
record_manager_$modify_records_by_spec
                                000000 constant        entry                    external dcl 18-78
record_manager_$put_record_by_id
                                000000 constant        entry                    external dcl 18-57
record_manager_$put_records_by_id
                                000000 constant        entry                    external dcl 18-60
simple_typed_vector_ptr                automatic       pointer                  dcl 11-33
structure_dtype                        internal static fixed bin(17,0)          initial dcl 1-25
stv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 11-35
tva_maximum_dimension_name_length      automatic       fixed bin(17,0)          dcl 10-48
tva_number_of_dimensions               automatic       fixed bin(17,0)          dcl 10-46
tva_number_of_vector_slots             automatic       fixed bin(17,0)          dcl 10-44

NAMES DECLARED BY EXPLICIT CONTEXT.
AND_GROUP_LOOP                  001747 constant        label                    dcl 482
CCS_RELATIVE_CURSOR_CHECK       003161 constant        label                    dcl 719
CHECK_CURSOR_STATE              003130 constant        entry                    internal dcl 706 ref 471
CHECK_VERSION                   002732 constant        entry                    internal dcl 679 ref 413 454 457 460 463 717 1191
CHECK_VERSION_FB                003034 constant        entry                    internal dcl 693 ref 347 357 367 387 389 403 405 425
                                                                                  1845
COPY_VALUE                      004520 constant        entry                    internal dcl 903 ref 1124
CREATE_CURSOR                   007016 constant        entry                    internal dcl 1411 ref 1388 1393 1399
CV_SEARCH_SPECIFICATION_FOR_INDEX
                                004215 constant        entry                    internal dcl 800 ref 1171
CV_SEARCH_SPECIFICATION_FOR_RECORDS
                                004453 constant        entry                    internal dcl 873 ref 1203
DESTROY_CURSOR                  007071 constant        entry                    internal dcl 1424 ref 1386 1398
ERROR_RETURN                    002721 constant        entry                    internal dcl 667 ref 451 924 1258 1276 1310 1353
                                                                                  1419 1430 1784 1843 1870
FINISH                          002205 constant        entry                    internal dcl 592 ref 474 588 673
FREE_INTERVAL_LIST              004632 constant        entry                    internal dcl 937 ref 619 1266
FREE_SPECIFICATION              004712 constant        entry                    internal dcl 959 ref 1107
FREE_TYPED_VECTOR_ARRAY         005035 constant        entry                    internal dcl 987 ref 607 644 658 1215 1254 1789 1874
                                                                                  1950
GET_DATA_FROM_RECORD_COLLECTION 006306 constant        label                    dcl 1240
INDEX_ID_LOOP                   010125 constant        label                    dcl 1673
INVERT_SEARCH_SPECIFICATION     004456 constant        entry                    internal dcl 891 ref 1162
JOIN                            001355 constant        label                    dcl 411 ref 349 359 370 376 392 409
RECORD_DATA                     002037 constant        label                    dcl 525
RECORD_IDS_TO_RETURN            005255 constant        entry                    internal dcl 1032 ref 531 535 538 546 549 552
RECORD_ID_LOOP                  010064 constant        label                    dcl 1665
RECORD_TUPLES_TO_RETURN         005312 constant        entry                    internal dcl 1059 ref 540 554
RESET_CURSOR                    005331 constant        entry                    internal dcl 1080 ref 578
RETURN                          002203 constant        label                    dcl 589 ref 674
RETURN_ELEMENT_ID_LIST          011270 constant        entry                    internal dcl 1882 ref 575
RETURN_TYPED_VECTOR_ARRAY       010600 constant        entry                    internal dcl 1800 ref 573
RETURN_TYPED_VECTOR_LIST        010404 constant        entry                    internal dcl 1732 ref 570
SEARCH_INDEX                    005575 constant        entry                    internal dcl 1145 ref 523
SEARCH_RECORDS                  005771 constant        label                    dcl 1194
SEARCH_RECORD_COLLECTION        006457 constant        entry                    internal dcl 1285 ref 521
SETUP_INTERNAL_CURSOR           006754 constant        entry                    internal dcl 1361 ref 501 511 1217
SETUP_INTERNAL_SPECIFICATION    007126 constant        entry                    internal dcl 1439 ref 476
SETUP_INTERNAL_SPECIFICATION_FOR_THIS_AND_GROUP
                                007347 constant        entry                    internal dcl 1511 ref 515
SETUP_RETURN_STRUCTURES         007564 constant        entry                    internal dcl 1562 ref 479
SET_CURRENT_COLLECTION_ID       006616 constant        entry                    internal dcl 1318 ref 491
SI_ERROR_RETURN                 006441 constant        entry                    internal dcl 1270 ref 1182 1189 1236
SI_MAIN_RETURN                  006426 constant        label                    dcl 1263 ref 1279
TRANSLATE_DEFAULT_ID_LIST       010262 constant        label                    dcl 1687
TRANSLATE_ID_LIST               007765 constant        entry                    internal dcl 1622 ref 1175
TRANSLATE_SPECIFIED_ID_LIST     010045 constant        label                    dcl 1657
get_array_and_ids               001240 constant        entry                    external dcl 394
get_array_by_spec               000726 constant        entry                    external dcl 351
get_count                       001075 constant        entry                    external dcl 372
get_id                          001013 constant        entry                    external dcl 362
get_list_and_ids                001121 constant        entry                    external dcl 378
get_list_by_spec                000644 constant        entry                    external dcl 341
rlm_general_search              000627 constant        entry                    external dcl 210

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     12544       12650   11772       12554
Length     13566   11772       104         702     552           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rlm_general_search                 1096 external procedure  is an external procedure.  
on unit on line 474                  64 on unit               
FINISH                               80 internal procedure  is called by several nonquick procedures.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure rlm_general_search.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure rlm_general_search.  
CHECK_VERSION_FB                        internal procedure  shares stack frame of external procedure rlm_general_search.  
CHECK_CURSOR_STATE                      internal procedure  shares stack frame of external procedure rlm_general_search.  
CV_SEARCH_SPECIFICATION_FOR_INDEX
                                    114 internal procedure  uses auto adjustable storage.  
CV_SEARCH_SPECIFICATION_FOR_RECORDS
                                        internal procedure  shares stack frame of external procedure rlm_general_search.  
COPY_VALUE                              internal procedure  shares stack frame of external procedure rlm_general_search.  
FREE_INTERVAL_LIST                   67 internal procedure  is called by several nonquick procedures.  
FREE_SPECIFICATION                      internal procedure  shares stack frame of external procedure rlm_general_search.  
FREE_TYPED_VECTOR_ARRAY              90 internal procedure  is called by several nonquick procedures.  
RECORD_IDS_TO_RETURN                    internal procedure  shares stack frame of external procedure rlm_general_search.  
RECORD_TUPLES_TO_RETURN                 internal procedure  shares stack frame of external procedure rlm_general_search.  
RESET_CURSOR                            internal procedure  shares stack frame of external procedure rlm_general_search.  
SEARCH_INDEX                            internal procedure  shares stack frame of external procedure rlm_general_search.  
SI_ERROR_RETURN                         internal procedure  shares stack frame of external procedure rlm_general_search.  
SEARCH_RECORD_COLLECTION                internal procedure  shares stack frame of external procedure rlm_general_search.  
SET_CURRENT_COLLECTION_ID               internal procedure  shares stack frame of external procedure rlm_general_search.  
SETUP_INTERNAL_CURSOR                   internal procedure  shares stack frame of external procedure rlm_general_search.  
CREATE_CURSOR                           internal procedure  shares stack frame of external procedure rlm_general_search.  
DESTROY_CURSOR                          internal procedure  shares stack frame of external procedure rlm_general_search.  
SETUP_INTERNAL_SPECIFICATION            internal procedure  shares stack frame of external procedure rlm_general_search.  
SETUP_INTERNAL_SPECIFICATION_FOR_THIS_AND_GROUP
                                        internal procedure  shares stack frame of external procedure rlm_general_search.  
SETUP_RETURN_STRUCTURES                 internal procedure  shares stack frame of external procedure rlm_general_search.  
TRANSLATE_ID_LIST                       internal procedure  shares stack frame of external procedure rlm_general_search.  
RETURN_TYPED_VECTOR_LIST                internal procedure  shares stack frame of external procedure rlm_general_search.  
RETURN_TYPED_VECTOR_ARRAY               internal procedure  shares stack frame of external procedure rlm_general_search.  
RETURN_ELEMENT_ID_LIST                  internal procedure  shares stack frame of external procedure rlm_general_search.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 work_area_ptr               rlm_general_search

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
CV_SEARCH_SPECIFICATION_FOR_INDEX
                         000100 cssfi_field_map             CV_SEARCH_SPECIFICATION_FOR_INDEX
                         000100 cssfi_field_id              CV_SEARCH_SPECIFICATION_FOR_INDEX
                         000101 cssfi_value_field_id        CV_SEARCH_SPECIFICATION_FOR_INDEX
                         000102 cssfi_temp_value_field_id   CV_SEARCH_SPECIFICATION_FOR_INDEX
                         000103 cssfi_field_idx             CV_SEARCH_SPECIFICATION_FOR_INDEX
                         000104 cssfi_constraint_idx        CV_SEARCH_SPECIFICATION_FOR_INDEX
                         000105 cssfi_index_field_idx       CV_SEARCH_SPECIFICATION_FOR_INDEX
FINISH                   000100 f_tva_idx                   FINISH
FREE_INTERVAL_LIST       000100 fil_interval_idx            FREE_INTERVAL_LIST
FREE_TYPED_VECTOR_ARRAY  000100 ftva_vector_ptr             FREE_TYPED_VECTOR_ARRAY
                         000102 ftva_vector_idx             FREE_TYPED_VECTOR_ARRAY
                         000103 ftva_value_idx              FREE_TYPED_VECTOR_ARRAY
rlm_general_search       000100 local_typed_vector_list_ptr rlm_general_search
                         000102 local_typed_vector_array_ptr
                                                            rlm_general_search
                         000104 local_element_id_list_ptr   rlm_general_search
                         000106 caller_area_ptr             rlm_general_search
                         000110 interval_element_id_list_ptr
                                                            rlm_general_search
                         000112 old_search_specification_ptr
                                                            rlm_general_search
                         000114 internal_specification_ptr  rlm_general_search
                         000116 internal_cursor_ptr         rlm_general_search
                         000120 internal_record_cursor_ptr  rlm_general_search
                         000122 return_eil_or_tva_array_ptr rlm_general_search
                         000124 return_tva_array_ptr        rlm_general_search
                         000126 current_collection_id       rlm_general_search
                         000127 previous_collection_id      rlm_general_search
                         000130 current_index_idx           rlm_general_search
                         000131 record_id_idx               rlm_general_search
                         000132 index_id_idx                rlm_general_search
                         000133 element_idx                 rlm_general_search
                         000134 current_and_group_idx       rlm_general_search
                         000135 and_group_idx               rlm_general_search
                         000136 return_structure_idx        rlm_general_search
                         000137 maximum_number_of_tuples_to_accept
                                                            rlm_general_search
                         000140 number_of_and_groups        rlm_general_search
                         000141 number_of_tuples_accepted   rlm_general_search
                         000142 number_of_tuples_accepted_by_this_and_group
                                                            rlm_general_search
                         000143 reota_number_of_entries     rlm_general_search
                         000144 rta_number_of_entries       rlm_general_search
                         000145 all_desired_fields_are_in_index
                                                            rlm_general_search
                         000146 get_id                      rlm_general_search
                         000147 get_typed_vector_list       rlm_general_search
                         000150 get_tuple                   rlm_general_search
                         000151 get_tuples_and_ids          rlm_general_search
                         000152 get_count                   rlm_general_search
                         000153 search_records              rlm_general_search
                         000154 is_search_specification     rlm_general_search
                         000155 is_numeric_specification    rlm_general_search
                         000156 is_relative_specification   rlm_general_search
                         000157 found_tuple                 rlm_general_search
                         000160 local_relation_cursor       rlm_general_search
                         000176 local_id_list               rlm_general_search
                         000202 local_return_eil_or_tva_entry
                                                            rlm_general_search
                         000206 local_return_tva_entry      rlm_general_search
                         000216 relation_cursor_ptr         rlm_general_search
                         000220 relation_opening_info_ptr   rlm_general_search
                         000222 relation_header_ptr         rlm_general_search
                         000224 attribute_info_ptr          rlm_general_search
                         000226 index_attribute_map_ptr     rlm_general_search
                         000230 INITIAL_NUMBER_OF_INDICES   rlm_general_search
                         000231 UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
                                                            rlm_general_search
                         000232 relation_search_specification_ptr
                                                            rlm_general_search
                         000234 relation_numeric_specification_ptr
                                                            rlm_general_search
                         000236 rss_number_of_and_groups    rlm_general_search
                         000237 rss_maximum_number_of_constraints
                                                            rlm_general_search
                         000240 specification_head_ptr      rlm_general_search
                         000242 typed_vector_array_ptr      rlm_general_search
                         000244 id_list_ptr                 rlm_general_search
                         000246 il_number_of_ids            rlm_general_search
                         000250 element_id_list_ptr         rlm_general_search
                         000252 eil_number_of_elements      rlm_general_search
                         000253 ELEMENT_ID_LIST_VERSION_1   rlm_general_search
                         000254 interval_list_ptr           rlm_general_search
                         000256 intl_number_of_intervals    rlm_general_search
                         000260 search_specification_ptr    rlm_general_search
                         000262 ss_number_of_and_groups     rlm_general_search
                         000263 ss_maximum_number_of_constraints
                                                            rlm_general_search
                         000264 numeric_specification_ptr   rlm_general_search
                         000266 typed_vector_list_ptr       rlm_general_search
                         000270 tvl_maximum_number_of_vectors
                                                            rlm_general_search
                         000344 cssfr_constraint_idx        CV_SEARCH_SPECIFICATION_FOR_RECORDS
                         000376 cv_value_string_size        COPY_VALUE
                         000377 cv_code                     COPY_VALUE
                         000400 arg_descriptor_ptr          COPY_VALUE
                         000402 extended_arg_type           COPY_VALUE
                         000412 fs_and_group_idx            FREE_SPECIFICATION
                         000413 fs_constraint_idx           FREE_SPECIFICATION
                         000502 rc_constraint_idx           RESET_CURSOR
                         000504 rc_value_ptr                RESET_CURSOR
                         000506 rc_code                     RESET_CURSOR
                         000540 si_code                     SEARCH_INDEX
                         000560 src_code                    SEARCH_RECORD_COLLECTION
                         000600 sic_code                    SETUP_INTERNAL_CURSOR
                         000632 sisftag_total_number_of_constraints
                                                            SETUP_INTERNAL_SPECIFICATION_FOR_THIS_AND_GROUP
                         000633 sisftag_constraint_idx      SETUP_INTERNAL_SPECIFICATION_FOR_THIS_AND_GROUP
                         000726 rtvl_code                   RETURN_TYPED_VECTOR_LIST
                         000727 rtvl_tva_idx                RETURN_TYPED_VECTOR_LIST
                         000730 rtvl_vector_idx             RETURN_TYPED_VECTOR_LIST
                         000731 rtvl_return_vector_idx      RETURN_TYPED_VECTOR_LIST
                         000742 rtva_code                   RETURN_TYPED_VECTOR_ARRAY
                         000743 rtva_dimension_idx          RETURN_TYPED_VECTOR_ARRAY
                         000744 rtva_return_vector_idx      RETURN_TYPED_VECTOR_ARRAY
                         000745 rtva_tva_idx                RETURN_TYPED_VECTOR_ARRAY
                         000746 rtva_vector_idx             RETURN_TYPED_VECTOR_ARRAY
                         000762 reil_eil_or_tva_idx         RETURN_ELEMENT_ID_LIST
                         000763 reil_return_id_idx          RETURN_ELEMENT_ID_LIST
                         000764 reil_id_idx                 RETURN_ELEMENT_ID_LIST
                         000765 reil_code                   RETURN_ELEMENT_ID_LIST

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          alloc_auto_adj      enable_op           ext_entry           int_entry           op_alloc_
op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
data_format_util_$get_data_bit_length                       dm_vector_util_$copy_typed_vector
dm_vector_util_$init_typed_vector_array                     get_dm_free_area_             index_manager_$create_cursor
index_manager_$destroy_cursor index_manager_$get_key        index_manager_$get_key_count_by_spec
record_manager_$create_cursor record_manager_$destroy_cursor
record_manager_$get_record_count                            record_manager_$get_record_count_by_interval
record_manager_$get_record_ids_by_interval                  record_manager_$get_record_ids_by_spec
record_manager_$get_records_and_ids_by_interval             record_manager_$get_records_and_ids_by_spec
record_manager_$get_records_by_id_list                      record_manager_$get_records_by_interval
record_manager_$get_records_by_spec                         rlm_opening_info$get          sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bad_rel_cursor_pos  dm_error_$index_not_in_relation                             dm_error_$key_not_found
dm_error_$programming_error   dm_error_$record_not_found    dm_error_$rel_cursor_spec_mismatch
dm_error_$tuple_not_found     error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    234 000525       238 000536       244 000540       248 000546       252 000561    3   42 000577    5   29 000601
 6   29 000602    7   37 000603    7   45 000604    7   47 000606    8   50 000607    8   52 000612   12   21 000614
12   22 000615   13   28 000617   14   33 000621   14   36 000623       210 000626       212 000635       341 000636
    343 000661       344 000663       345 000664       346 000667       347 000672       349 000723       351 000724
    353 000743       354 000745       355 000746       356 000751       357 000754       359 001005       362 001006
    364 001030       365 001032       366 001035       367 001040       370 001067       372 001070       374 001106
    375 001110       376 001112       378 001113       382 001140       383 001142       384 001143       385 001146
    386 001151       387 001154       389 001205       392 001235       394 001236       398 001257       399 001261
    400 001262       401 001265       402 001270       403 001273       405 001324       409 001354       411 001355
    413 001361       414 001404       417 001417       421 001431       422 001435       425 001441       428 001464
    432 001476       433 001500       434 001501       435 001502       439 001506       440 001510       443 001511
    450 001517       451 001533       454 001543       456 001570       457 001573       459 001616       460 001621
    462 001644       463 001647       467 001671       469 001702       471 001704       474 001706       476 001730
    479 001732       482 001747       488 001762       490 001763       491 001765       494 001767       501 001775
    503 002005       511 002006       515 002014       521 002024       523 002032       525 002034       529 002037
    531 002044       535 002054       538 002061       540 002064       543 002071       546 002073       549 002101
    552 002106       554 002110       558 002112       561 002116       563 002120       565 002122       570 002132
    573 002143       575 002145       578 002153       582 002155       584 002161       586 002167       588 002177
    589 002203       592 002204       597 002212       600 002233       603 002256       607 002321       610 002335
    613 002362       616 002375       619 002410       622 002424       625 002431       629 002447       631 002467
    634 002520       637 002532       640 002556       643 002563       644 002573       646 002613       647 002615
    651 002631       654 002636       655 002645       658 002670       659 002677       660 002701       662 002716
    665 002720       667 002721       672 002723       673 002725       674 002731       679 002732       685 002743
    690 003033       693 003034       699 003045       704 003127       706 003130       717 003132       719 003155
    723 003161       728 003230       733 003300       736 003304       739 003354       745 003427       749 003505
    750 003506       753 003511       756 003561       762 003634       771 003744       780 004044       781 004045
    785 004117       786 004120       790 004170       791 004174       792 004175       794 004211       796 004213
    800 004214       822 004222       823 004227       828 004232       830 004236       831 004245       832 004251
    834 004253       835 004301       837 004333       839 004335       841 004337       842 004351       843 004366
    845 004375       848 004376       849 004405       851 004412       854 004413       855 004415       858 004420
    859 004426       861 004435       864 004436       866 004445       869 004450       871 004452       873 004453
    891 004455       894 004460       896 004473       899 004515       901 004517       903 004520       909 004522
    913 004523    2   36 004524       918 004526       919 004531       921 004552       923 004570       924 004605
    926 004611       927 004622       929 004630       937 004631       944 004637       947 004644       948 004657
    951 004676       952 004700       955 004711       959 004712       963 004714       964 004716       967 004717
    970 004733       974 004737       975 004751       977 005001       980 005027       981 005031       983 005033
    987 005034       997 005042      1000 005047      1001 005061      1004 005107      1005 005112      1008 005121
   1009 005135      1012 005145      1014 005151      1016 005160      1018 005162      1019 005173      1022 005220
   1024 005222      1025 005250      1027 005253      1030 005254      1032 005255      1046 005257      1047 005271
   1049 005274      1051 005303      1053 005307      1055 005311      1059 005312      1070 005314      1072 005322
   1074 005326      1076 005330      1080 005331      1095 005333      1096 005335      1097 005337      1099 005340
   1101 005343      1105 005371      1107 005402      1111 005422      1112 005426      1113 005430      1114 005433
   1115 005437      1117 005442      1123 005453      1124 005477      1131 005547      1133 005561      1136 005563
   1138 005567      1141 005574      1145 005575      1149 005577      1157 005600      1161 005615      1162 005621
   1170 005624      1171 005625      1175 005645      1177 005646      1180 005653      1182 005671      1184 005704
   1187 005705      1189 005730      1191 005743      1194 005766      1203 005771      1204 005773      1205 005776
   1206 006000      1207 006012      1209 006014      1210 006025      1213 006055      1215 006057      1217 006065
   1221 006112      1225 006140      1229 006175      1233 006234      1236 006256      1238 006271      1239 006277
   1240 006300      1244 006306      1245 006311      1246 006323      1248 006325      1249 006335      1252 006365
   1254 006367      1256 006375      1258 006422      1263 006426      1266 006432      1268 006440      1270 006441
   1276 006443      1279 006456      1285 006457      1289 006461      1295 006462      1297 006464      1300 006506
   1303 006533      1307 006562      1310 006602      1314 006611      1315 006615      1318 006616      1336 006620
   1339 006634      1341 006655      1342 006661      1344 006670      1346 006673      1350 006702      1352 006734
   1353 006736      1357 006753      1361 006754      1375 006756      1382 006761      1386 006774      1388 007000
   1390 007001      1393 007002      1395 007010      1398 007013      1399 007014      1403 007015      1411 007016
   1414 007017      1417 007044      1419 007064      1422 007070      1424 007071      1427 007072      1429 007110
   1430 007121      1433 007125      1439 007126      1453 007130      1456 007133      1458 007136      1461 007141
   1462 007143      1463 007146      1465 007150      1466 007151      1469 007154      1470 007156      1472 007161
   1473 007162      1476 007165      1477 007200      1478 007203      1479 007226      1480 007237      1481 007243
   1483 007250      1485 007256      1486 007257      1489 007262      1490 007271      1491 007302      1492 007306
   1494 007310      1495 007312      1496 007314      1497 007315      1499 007317      1502 007332      1503 007335
   1505 007344      1507 007346      1511 007347      1523 007351      1528 007352      1532 007365      1535 007370
   1538 007377      1541 007403      1543 007420      1549 007443      1552 007561      1557 007563      1562 007564
   1582 007566      1585 007571      1587 007576      1591 007604      1592 007613      1595 007615      1596 007630
   1597 007645      1598 007665      1601 007704      1604 007710      1606 007715      1610 007723      1611 007732
   1614 007734      1615 007746      1618 007764      1622 007765      1626 007766      1635 007777      1636 010000
   1637 010017      1638 010021      1639 010023      1640 010025      1641 010026      1644 010030      1645 010031
   1646 010033      1655 010036      1657 010040      1661 010045      1662 010051      1663 010062      1665 010064
   1668 010075      1673 010125      1678 010203      1679 010205      1681 010232      1684 010233      1686 010235
   1687 010236      1693 010262      1694 010264      1695 010275      1696 010277      1697 010307      1699 010337
   1701 010341      1705 010342      1708 010343      1719 010345      1720 010364      1721 010366      1722 010370
   1724 010401      1728 010403      1732 010404      1748 010406      1751 010411      1757 010415      1758 010420
   1765 010421      1766 010423      1767 010434      1768 010436      1771 010437      1773 010443      1774 010445
   1776 010461      1779 010471      1781 010503      1784 010552      1786 010556      1787 010557      1789 010561
   1792 010572      1794 010574      1796 010577      1800 010600      1812 010602      1820 010603      1823 010606
   1824 010623      1825 010625      1829 010677      1839 010711      1843 010747      1845 010753      1848 011004
   1850 011027      1851 011037      1854 011111      1857 011113      1858 011120      1859 011122      1862 011135
   1865 011145      1867 011157      1870 011245      1872 011251      1873 011252      1874 011254      1876 011265
   1878 011267      1882 011270      1900 011272      1903 011273      1905 011276      1914 011307      1915 011311
   1917 011323      1920 011325      1922 011326      1924 011335      1927 011344      1930 011350      1932 011361
   1933 011362      1935 011375      1936 011377      1937 011412      1938 011416      1941 011417      1944 011427
   1945 011430      1949 011467      1950 011471      1954 011502      1956 011504


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
