	COMPILATION LISTING OF SEGMENT cm_get_element_buffered
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  0952.5 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 
        9 /* DESCRIPTION
       10*
       11*   This module implements collection_manager_$get_from_ci_buffer
       12*   (cm_get_element_buffered$whole) and 
       13*   collection_manager_$get_portion_from_ci_buffer 
       14*   (cm_get_element_buffered$portion).
       15*
       16*   This module gets the specified element.  The location of the element
       17*   is p_position elements from p_element_id.  The data is returned in the
       18*   buffer located at p_buffer_ptr (if it fits).  p_buffer_length is the
       19*   bit length of that caller-supplied buffer.  If the buffer is too small
       20*   to hold the data or the requested element is an overlength element,
       21*   space is allocated in the provided area and the data is returned
       22*   there.
       23**/
       24 
       25 /* HISTORY:
       26*Written by Matthew Pierret, 11/15/82.
       27*Modified:
       28*01/27/83 by Matthew Pierret: Enhanced error reporting ability. Added 
       29*            consistency checks for multi-datum elements and changed to report
       30*            certain errors getting continuation datums via sub_err_, as they
       31*            indicate an inconsistency internal to the collection.
       32*            Changed to use dm_error_$unimplemented_ci_version.
       33*04/29/83 by Matthew Pierret: Changed to use addcharno instead of addr(substr())
       34*            and dm_error_$long_return_element instead of $long_element.
       35*            Also changed to use ERROR_RETURN routine for all error returns.
       36*05/04/83 by Matthew Pierret:  Fixed used of addcharno.  Was adding byte too
       37*            many on each use of addcharno. Changed to use 
       38*            dm_error_$programming_error instead of $col_is_inconsistent.
       39*11/07/83 by Matthew Pierret: Added $whole and $portion. $whole is the old
       40*            behavior - return whole element. $portion returns a portion of the
       41*            element.  Disallowed specifying element_id.index of zero.
       42*11/17/83 by Lindsey L. Spratt:  Fixed to use the
       43*            datum_contents_length_in_(bits bytes) in the SIMPLE_GET do-group,
       44*            rather than referring back to datum_slot_table.length_in_bits,
       45*            which is incorrect (too large) when doing a get_element_portion.
       46*04/13/84 by Matthew Pierret:  Changed names of variable which contained
       47*            "buffered_ci" to contain "ci_buffer" instead to conform with
       48*            documentation.
       49*05/09/84 by Matthew Pierret:  Changed to align allocated buffers on even word
       50*            boundaries.
       51*07/23/84 by Matthew Pierret:  Changed declaration of buffer to be fixed bin(71)
       52*            instead allowing it to default to fixed bin (17).  Also changed
       53*            the FINISH procedure to check buffer_ptr instead of
       54*            p_new_buffer_was_allocated to determine if buffer should be freed.
       55*10/01/84 by Matthew Pierret:  Changed to base all datum structures on datum_ptr
       56*            and datum_contents_length_in_bits.  Changed to use 
       57*            bytes = divide (bits+BITS_PER_BYTE-1, BITS_PER_BYTE, 17, 0)
       58*            to convert bits to bytes more efficiently.  This is only used in 
       59*            the critical path, SIMPLE_GET.
       60*12/03/84 by Matthew Pierret:  Added the local cdcn_datum_header, which was 
       61*            removed from dm_cm_datum.incl.pl1.
       62**/
       63 
       64 /* format: style2,ind3 */
       65 
       66 cm_get_element_buffered:
       67    proc ();
       68       call sub_err_ (dm_error_$programming_error, myname, ACTION_CAN_RESTART, null, 0, "This is not a valid entry point.")
       69 	 ;
       70 
       71 /* START OF DECLARATIONS */
       72 /* Parameter */
       73 
       74       dcl	    p_ci_buffer_ptr	       ptr;
       75       dcl	    p_file_opening_id      bit (36) aligned;
       76       dcl	    p_collection_id	       bit (36) aligned;
       77       dcl	    p_element_id	       bit (36) aligned;
       78       dcl	    p_buffer_ptr	       ptr;
       79       dcl	    p_buffer_length	       fixed bin (35);
       80       dcl	    p_area_ptr	       ptr;
       81       dcl	    p_new_buffer_was_allocated
       82 			       bit (1) aligned;
       83       dcl	    p_element_ptr	       ptr;
       84       dcl	    p_element_length       fixed bin (35);
       85       dcl	    p_portion_beginning_index
       86 			       fixed bin (35);
       87       dcl	    p_portion_length       fixed bin (35);
       88       dcl	    p_code	       fixed bin (35);
       89 
       90 /* Automatic */
       91 
       92       dcl	    1 automatic_bci_header aligned like bci_header;
       93       dcl	    1 automatic_datum_slot aligned like datum_slot;
       94       dcl	    automatic_cip_buffer   (8) fixed bin (71) init (0, 0, 0, 0, 0, 0, 0, 0);
       95       dcl	    (continuation_datum_id_string, continued_datum_id_string)
       96 			       bit (36) aligned;
       97       dcl	    buffer_length_in_bytes fixed bin (17) init (0);
       98       dcl	    ci_buffer_length_in_bytes
       99 			       fixed bin (17) init (0);
      100       dcl	    datum_contents_length_in_bytes
      101 			       fixed bin (17) init (0);
      102       dcl	    datum_contents_offset_in_bytes
      103 			       fixed bin (17) init (0);
      104       dcl	    datum_header_length_in_bytes
      105 			       fixed bin (17) init (0);
      106       dcl	    element_length_in_bytes
      107 			       fixed bin (17) init (0);
      108       dcl	    old_buffer_length_in_bytes
      109 			       fixed bin (17) init (0);
      110       dcl	    slot_idx	       fixed bin (17) init (0);
      111 
      112       dcl	    new_buffer_allowed     bit (1) aligned init ("0"b);
      113       dcl	    use_supplied_buffer    bit (1) aligned init ("0"b);
      114       dcl	    get_whole_element      bit (1) aligned;
      115 
      116       dcl	    work_area_ptr	       ptr init (null);
      117       dcl	    buffer_ptr	       ptr init (null);
      118       dcl	    ci_buffer_ptr	       ptr init (null);
      119       dcl	    current_buffer_ptr     ptr init (null);
      120 
      121       dcl	    1 cdcn_datum_header    aligned like continued_continuation_datum.header;
      122 
      123 /* Based */
      124 
      125       dcl	    1 continuation_datum_id
      126 			       aligned like datum_id based (addr (continuation_datum_id_string));
      127       dcl	    datum_contents_string  char (datum_contents_length_in_bytes) based;
      128       dcl	    work_area	       area based (work_area_ptr);
      129       dcl	    buffer	       (buffer_length_in_bytes / BYTES_PER_DOUBLE_WORD + 1) fixed bin (71)
      130 			       based (buffer_ptr);
      131 
      132 /* Builtin */
      133 
      134       dcl	    (addcharno, addr, ceil, divide, floor, min, null, unspec)
      135 			       builtin;
      136 
      137 /* Condition */
      138 
      139       dcl	    cleanup	       condition;
      140 
      141 /* Constant */
      142 
      143       dcl	    myname	       init ("cm_get_element_buffered") char (32) varying internal static
      144 			       options (constant);
      145       dcl	    BYTES_PER_DOUBLE_WORD  init (8) fixed bin int static options (constant);
      146       dcl	    BITS_PER_BYTE	       init (9) fixed bin int static options (constant);
      147 
      148 /* Entry */
      149 
      150       dcl	    file_manager_$get      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
      151       dcl	    sub_err_	       entry () options (variable);
      152 
      153 /* External */
      154 
      155       dcl	    (
      156 	    dm_error_$ci_not_in_collection,
      157 	    dm_error_$ci_not_allocated,
      158 	    dm_error_$no_element,
      159 	    dm_error_$no_output_buffer,
      160 	    dm_error_$misformatted_ci,
      161 	    dm_error_$programming_error,
      162 	    dm_error_$long_return_element,
      163 	    error_table_$bad_arg
      164 	    )		       fixed bin (35) ext;
      165 
      166 /* END OF DECLARATIONS */
      167 
      168 whole:
      169    entry (p_ci_buffer_ptr, p_file_opening_id, p_collection_id, p_element_id, p_buffer_ptr, p_buffer_length, p_area_ptr,
      170         p_new_buffer_was_allocated, p_element_ptr, p_element_length, p_code);
      171 
      172       get_whole_element = "1"b;
      173       goto JOIN;
      174 
      175 portion:
      176    entry (p_ci_buffer_ptr, p_file_opening_id, p_collection_id, p_element_id, p_buffer_ptr, p_buffer_length, p_area_ptr,
      177         p_portion_beginning_index, p_portion_length, p_new_buffer_was_allocated, p_element_ptr, p_element_length, p_code);
      178 
      179       get_whole_element = "0"b;
      180       if p_portion_length < 1 | p_portion_beginning_index ^= 1
      181       then call ERROR_RETURN (error_table_$bad_arg);
      182       goto JOIN;
      183 
      184 
      185 JOIN:
      186       p_code = 0;
      187 
      188       element_id_string = p_element_id;
      189 
      190       if element_id.control_interval_id = 0
      191       then ci_buffer_length_in_bytes = CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES;
      192       else ci_buffer_length_in_bytes = CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES;
      193 
      194       basic_control_interval_ptr, ci_buffer_ptr = p_ci_buffer_ptr;
      195 
      196       call CHECK_CI_VERSION (basic_control_interval.header.layout_type);
      197 
      198       if basic_control_interval.header.collection_id ^= p_collection_id
      199       then call ERROR_RETURN (dm_error_$ci_not_in_collection);
      200 
      201 
      202       if element_id_string = "0"b | element_id.index > basic_control_interval.header.number_of_datums
      203       then call ERROR_RETURN (dm_error_$no_element);
      204 
      205 
      206 /*
      207*     Verify the existence of an output buffer and record its length.
      208*     If no buffer is supplied, check for an area. If no area is supplied,
      209*     the call is in error.
      210**/
      211 
      212       if p_buffer_ptr ^= null
      213       then
      214          do;
      215 	  buffer_ptr = p_buffer_ptr;
      216 	  buffer_length_in_bytes = floor (divide (p_buffer_length, BITS_PER_BYTE, 35, 18));
      217 	  use_supplied_buffer = "1"b;
      218          end;
      219 
      220       if p_area_ptr ^= null
      221       then
      222          do;
      223 	  work_area_ptr = p_area_ptr;
      224 	  new_buffer_allowed = "1"b;
      225          end;
      226 
      227       if ^use_supplied_buffer & ^new_buffer_allowed
      228       then call ERROR_RETURN (dm_error_$no_output_buffer);
      229 
      230 
      231 /*
      232*     If no element corresponds to this datum slot, report to caller that
      233*     the element could not be found.
      234**/
      235 
      236       if basic_control_interval.datum_position_table (element_id.index).offset_in_bytes = FREE_SLOT
      237 	 | basic_control_interval.datum_position_table (element_id.index).flags.is_continuation
      238       then call ERROR_RETURN (dm_error_$no_element);
      239 
      240 
      241       if ^basic_control_interval.datum_position_table (element_id.index).flags.is_continued
      242       then
      243 SIMPLE_GET:
      244          do;
      245 
      246 /*
      247*     The datum described by the datum slot is the entire element.  Get the 
      248*     datum and return.
      249**/
      250 
      251 	  if get_whole_element
      252 	  then datum_contents_length_in_bits =
      253 		  basic_control_interval.datum_position_table (element_id.index).length_in_bits;
      254 	  else datum_contents_length_in_bits =
      255 		  min (p_portion_length,
      256 		  basic_control_interval.datum_position_table (element_id.index).length_in_bits);
      257 	  datum_contents_length_in_bytes =
      258 	       divide (datum_contents_length_in_bits + BITS_PER_BYTE - 1, BITS_PER_BYTE, 17, 0);
      259 
      260 	  if ^use_supplied_buffer | (use_supplied_buffer & datum_contents_length_in_bytes > buffer_length_in_bytes)
      261 	  then if new_buffer_allowed
      262 	       then
      263 		do;
      264 		   buffer_length_in_bytes = datum_contents_length_in_bytes;
      265 		   on cleanup call FINISH ();
      266 		   alloc buffer in (work_area);
      267 		   p_new_buffer_was_allocated = "1"b;
      268 		end;
      269 	       else
      270 		do;
      271 		   p_element_length = datum_contents_length_in_bytes * BITS_PER_BYTE;
      272 		   call ERROR_RETURN (dm_error_$long_return_element);
      273 		end;
      274 
      275 
      276 /*
      277*     The buffer is set up and can hold the datum. Move the datum from the 
      278*     ci_buffer to the buffer.
      279**/
      280 
      281 	  datum_contents_offset_in_bytes =
      282 	       basic_control_interval.datum_position_table (element_id.index).offset_in_bytes;
      283 
      284 	  buffer_ptr -> datum_contents_string =
      285 	       addcharno (ci_buffer_ptr, datum_contents_offset_in_bytes) -> datum_contents_string;
      286 
      287 	  p_element_ptr = buffer_ptr;
      288 	  p_element_length = datum_contents_length_in_bits;
      289 
      290          end SIMPLE_GET;
      291 
      292       else
      293 MULTI_DATUM_GET:
      294          do;
      295 
      296 /*
      297*     The element consists of more than one datum.
      298**/
      299 
      300 	  datum_ptr =
      301 	       addcharno (ci_buffer_ptr, basic_control_interval.datum_position_table (element_id.index).offset_in_bytes)
      302 	       ;
      303 
      304 	  element_length_in_bytes = ceil (divide (continued_datum.header.full_length, BITS_PER_BYTE, 35, 18));
      305 
      306 	  if use_supplied_buffer
      307 	  then if element_length_in_bytes > buffer_length_in_bytes
      308 	       then use_supplied_buffer = "0"b;
      309 
      310 	  if ^use_supplied_buffer
      311 	  then if new_buffer_allowed
      312 	       then
      313 		do;
      314 
      315 /*
      316*     A buffer must be allocated in the area to hold the element.  This may be 
      317*     because no buffer was supplied or because the supplied buffer is too
      318*     small to hold the entire element.
      319**/
      320 
      321 		   buffer_length_in_bytes = element_length_in_bytes;
      322 		   on cleanup call FINISH ();
      323 		   alloc buffer in (work_area);
      324 		   p_new_buffer_was_allocated = "1"b;
      325 
      326 		end;
      327 	       else
      328 		do;
      329 		   p_element_length = datum_contents_length_in_bytes * BITS_PER_BYTE;
      330 		   call ERROR_RETURN (dm_error_$long_return_element);
      331 		end;
      332 
      333 /*
      334*     buffer_ptr points to an appropriately sized buffer.  Copy the initial
      335*     datum contents into the buffer. Set current_buffer_ptr to point to the end
      336*     of the datum contents in the buffer, i.e., the place to put the next
      337*     datum. Get the continuation datums and
      338*     append them to the end of the retrieved element (at current_buffer_ptr).
      339**/
      340 
      341 	  datum_contents_length_in_bytes =
      342 	       ceil (
      343 	       divide (basic_control_interval.datum_position_table (element_id.index).length_in_bits, BITS_PER_BYTE, 35,
      344 	       18));
      345 
      346 	  datum_contents_offset_in_bytes =
      347 	       basic_control_interval.datum_position_table (element_id.index).offset_in_bytes;
      348 
      349 	  buffer_ptr -> datum_contents_string =
      350 	       addcharno (ci_buffer_ptr, datum_contents_offset_in_bytes) -> datum_contents_string;
      351 
      352 	  current_buffer_ptr = addcharno (buffer_ptr, datum_contents_length_in_bytes);
      353 
      354 	  continued_datum_id_string = element_id_string;
      355 	  continuation_datum_id_string = unspec (continued_datum.header.continuation);
      356 
      357 	  unspec (automatic_bci_header) = "0"b;
      358 	  unspec (automatic_datum_slot) = "0"b;
      359 
      360 	  bci_header_ptr = addr (automatic_bci_header);
      361 	  datum_slot_ptr = addr (automatic_datum_slot);
      362 
      363 	  ci_parts_ptr = addr (automatic_cip_buffer);
      364 
      365 GET_EACH_DATUM_LOOP:
      366 	  do while (continuation_datum_id_string ^= "0"b & element_length_in_bytes > 0);
      367 
      368 	     unspec (cdcn_datum_header.continuation) = "0"b;
      369 
      370 	     call cm_get_bci_header$slot (p_file_opening_id, bci_header_ptr, datum_slot_ptr,
      371 		continuation_datum_id_string, p_code);
      372 	     if p_code ^= 0
      373 	     then if p_code = dm_error_$no_element | p_code = dm_error_$ci_not_allocated
      374 		     | p_code = dm_error_$misformatted_ci
      375 		then call REPORT_MULTI_DATUM_INCONSISTENCY (addr (continued_datum_id_string)
      376 			-> element_id.control_interval_id, addr (continued_datum_id_string) -> element_id.index,
      377 			continuation_datum_id.control_interval_id, continuation_datum_id.index, p_code);
      378 		else call ERROR_RETURN (p_code);
      379 
      380 
      381 	     call VERIFY_MULTI_DATUM_CONSISTENCY (addr (continued_datum_id_string) -> element_id.control_interval_id,
      382 		addr (continued_datum_id_string) -> element_id.index, p_collection_id,
      383 		continuation_datum_id.control_interval_id, continuation_datum_id.index, bci_header.collection_id,
      384 		(datum_slot.offset_in_bytes = FREE_SLOT), (^datum_slot.flags.is_continuation));
      385 
      386 	     if datum_slot.flags.is_continued
      387 	     then datum_header_length_in_bytes = CDCN_DATUM_HEADER_LENGTH_IN_BYTES;
      388 	     else datum_header_length_in_bytes = 0;
      389 
      390 	     datum_contents_length_in_bytes =
      391 		ceil (divide (datum_slot.length_in_bits, BITS_PER_BYTE, 35, 18)) - datum_header_length_in_bytes;
      392 
      393 	     ci_parts.number_of_parts = 1;
      394 
      395 	     ci_parts.part (1).offset_in_bytes = datum_slot.offset_in_bytes + datum_header_length_in_bytes;
      396 	     ci_parts.part (1).length_in_bytes = datum_contents_length_in_bytes;
      397 	     ci_parts.part (1).local_ptr = current_buffer_ptr;
      398 
      399 	     if datum_slot.flags.is_continued
      400 	     then
      401 	        do;
      402 
      403 		 ci_parts.number_of_parts = 2;
      404 		 ci_parts.part (2).offset_in_bytes = datum_slot.offset_in_bytes;
      405 		 ci_parts.part (2).length_in_bytes = CDCN_DATUM_HEADER_LENGTH_IN_BYTES;
      406 		 ci_parts.part (2).local_ptr = addr (cdcn_datum_header);
      407 
      408 	        end;
      409 
      410 	     call file_manager_$get (p_file_opening_id, (continuation_datum_id.control_interval_id), ci_parts_ptr,
      411 		p_code);
      412 	     if p_code ^= 0
      413 	     then call ERROR_RETURN (p_code);
      414 
      415 
      416 	     current_buffer_ptr = addcharno (current_buffer_ptr, datum_contents_length_in_bytes);
      417 
      418 	     element_length_in_bytes = element_length_in_bytes - datum_contents_length_in_bytes;
      419 
      420 	     continued_datum_id_string = continuation_datum_id_string;
      421 	     continuation_datum_id = cdcn_datum_header.continuation;
      422 
      423 	  end GET_EACH_DATUM_LOOP;
      424 
      425 
      426 	  p_element_ptr = buffer_ptr;
      427 	  p_element_length = continued_datum.header.full_length;
      428 
      429          end MULTI_DATUM_GET;
      430 
      431 
      432 RETURN:
      433       return;
      434 
      435 FINISH:
      436    proc ();
      437 
      438       if buffer_ptr ^= null & buffer_ptr ^= p_buffer_ptr & buffer_ptr ^= p_element_ptr
      439       then
      440          do;
      441 	  free buffer in (work_area);
      442 	  p_new_buffer_was_allocated = "0"b;
      443          end;
      444 
      445    end FINISH;
      446 
      447 ERROR_RETURN:
      448    proc (er_p_code);
      449 
      450       dcl	    er_p_code	       fixed bin (35);
      451 
      452       p_code = er_p_code;
      453       call FINISH ();
      454       goto RETURN;
      455 
      456    end ERROR_RETURN;
      457 
      458 CHECK_CI_VERSION:
      459    proc (ccv_p_given_version);
      460 
      461       dcl	    ccv_p_given_version    char (4) aligned;
      462       dcl	    dm_error_$unimplemented_ci_version
      463 			       ext fixed bin (35);
      464 
      465       if ccv_p_given_version ^= BASIC_CI_LAYOUT_1
      466       then call sub_err_ (dm_error_$unimplemented_ci_version, myname, "s", null, 0,
      467 	      "^/Expected version ""^4a"" control interval; received ""^4a"".", BASIC_CI_LAYOUT_1, ccv_p_given_version);
      468 
      469       return;
      470 
      471    end CHECK_CI_VERSION;
      472 
      473 REPORT_MULTI_DATUM_INCONSISTENCY:
      474    proc (rmdi_p_cd_ci, rmdi_p_cd_index, rmdi_p_cn_ci, rmdi_p_cn_index, rmdi_p_code);
      475 
      476       dcl	    (rmdi_p_cd_ci, rmdi_p_cn_ci)
      477 			       fixed bin (24) unsigned unaligned;
      478       dcl	    (rmdi_p_cd_index, rmdi_p_cn_index)
      479 			       fixed bin (12) unsigned unaligned;
      480       dcl	    rmdi_p_code	       fixed bin (35);
      481 
      482       call sub_err_ (rmdi_p_code, ACTION_CANT_RESTART, null, 0,
      483 	 "^/The element in control interval ^d, slot ^d claims to be continued at^/control interval ^d, slot ^d. ^[^s^a^;^[^a^s^;^s^a^]"
      484 	 , rmdi_p_cd_ci, rmdi_p_cd_index, rmdi_p_cn_ci, rmdi_p_cn_index, (rmdi_p_code = dm_error_$no_element),
      485 	 (rmdi_p_code = dm_error_$ci_not_allocated), "That slot is a free slot.",
      486 	 "That control interval is not allocated for use.", "That control interval is incorrectly formatted.");
      487 
      488    end REPORT_MULTI_DATUM_INCONSISTENCY;
      489 
      490 VERIFY_MULTI_DATUM_CONSISTENCY:
      491    proc (vmdi_p_cd_ci, vmdi_p_cd_index, vmdi_p_cd_collection_id, vmdi_p_cn_ci, vmdi_p_cn_index, vmdi_p_cn_collection_id,
      492         vmdi_p_cn_slot_is_free, vmdi_p_cn_slot_is_not_continuation);
      493 
      494       dcl	    (vmdi_p_cd_ci, vmdi_p_cn_ci)
      495 			       fixed bin (24) unsigned unaligned;
      496       dcl	    (vmdi_p_cd_index, vmdi_p_cn_index)
      497 			       fixed bin (12) unsigned unaligned;
      498       dcl	    (vmdi_p_cd_collection_id, vmdi_p_cn_collection_id)
      499 			       bit (36) aligned;
      500       dcl	    (vmdi_p_cn_slot_is_free, vmdi_p_cn_slot_is_not_continuation)
      501 			       bit (1) aligned;
      502 
      503       if vmdi_p_cn_collection_id ^= vmdi_p_cd_collection_id
      504       then call sub_err_ (dm_error_$programming_error, ACTION_CANT_RESTART, null, 0,
      505 	      "^/The element in control interval ^d, slot ^d claims to be continued at^/control interval ^d, slot ^d, but the two are in different collections.^/The former is in collection ^3bo;^/the latter is in collection ^3bo."
      506 	      , vmdi_p_cd_ci, vmdi_p_cd_index, vmdi_p_cn_ci, vmdi_p_cn_index, vmdi_p_cd_collection_id,
      507 	      vmdi_p_cn_collection_id);
      508       else if vmdi_p_cn_slot_is_free | vmdi_p_cn_slot_is_not_continuation
      509       then call sub_err_ (dm_error_$programming_error, ACTION_CANT_RESTART, null, 0,
      510 	      "^/The element in control interval ^d, slot ^d claims to be continued at^/control interval ^d, slot ^d. ^[^That slot ^[is free^;is not a continuation datum^]."
      511 	      , vmdi_p_cd_ci, vmdi_p_cd_index, vmdi_p_cn_ci, vmdi_p_cn_index, vmdi_p_cn_slot_is_free);
      512 
      513    end VERIFY_MULTI_DATUM_CONSISTENCY;
      514 
  1     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*        The collection_manager_ manages the structure of the addressable
  1     6*   portion of a control interval.  The addressable portion is that portion of
  1     7*   a control interval which the file_manager_ will allow the
  1     8*   collection_manager_ to address.  In this description control interval will
  1     9*   be used to mean the addressable portion of a control interval.
  1    10*   
  1    11*        A control interval is divided into four parts: the header, the datum
  1    12*   position table (also known as the slot table or slots), un-used space and
  1    13*   used space.  The beginning of the header is at offset 0, and the end of the
  1    14*   used space is at the end of the control interval (curently offset 4072).
  1    15*   Pictoriarly, a control interval is structured as follows:
  1    16*   
  1    17*   ----------------------------------------------------------------------
  1    18*   |        || | | | | | ||               ||   | / / |       |/|   |    |
  1    19*   | Header || | slot  | || un-used space ||   |/ / /|       |/|   |    |
  1    20*   |        || | table | ||               ||   | / / |       |/|   |    |
  1    21*   |        || | | | | | ||               ||   |/ / /|       |/|   |    |
  1    22*   ----------------------------------------------------------------------
  1    23*                                           ^ ^    ^      ^    ^  ^   ^
  1    24*                                           | |    |      |    |  |   |
  1    25*                                           | |...........|.......|...|
  1    26*                        start of used space|      |           |      |
  1    27*                                                  |           |  each|
  1    28*                                          scattered free space|  is a used
  1    29*                                                                 datum
  1    30*   
  1    31*      The basic_control_interval structure describes the header
  1    32*   (basic_control_interval.header, bci_header) and the slots
  1    33*   (basic_control_interval.datum_position_table, datum_slot for one only).
  1    34*   Each datum_slot contains the offset (in bytes) and the length (in bits) of
  1    35*   a datum in the used space.  If the offset is equal to FREE_SLOT (declared
  1    36*   in dm_cm_basic_ci_const.incl.pl1), the slot is un-used.  The slot also
  1    37*   contains flags describing the type of datum (see dm_cm_datum.incl.pl1).
  1    38**/
  1    39 
  1    40 /* HISTORY:
  1    41*Written by Matthew Pierret, 02/07/82.
  1    42*Modified:
  1    43*03/25/82 by Matthew Pierret: Fixed alignment differences basic_control_interval
  1    44*            and its sub-structures.
  1    45*06/14/82 by Matthew Pierret: Removed common header and buffers. Changed
  1    46*            basic_ci_header to bci_header. Added previous_control_interval.
  1    47*07/12/82 by Matthew Pierret: Changed collection_id to be bit (36) aligned.
  1    48*10/29/82 by Matthew Pierret: Added flags to datum slots. 
  1    49*11/10/82 by Matthew Pierret: Removed continued_datum_is_present flag, as it
  1    50*            is not used.
  1    51*03/28/84 by Matthew Pierret: Added the constants BCI_HEADER_LENGTH_IN_BYTES
  1    52*            and DATUM_POSITION_TABLE_OFFSET_IN_BYTES.
  1    53**/
  1    54 
  1    55 /* format: style2 */
  1    56      dcl	   1 basic_control_interval
  1    57 			      aligned based (basic_control_interval_ptr),
  1    58 	     2 header	      like bci_header,
  1    59 	     2 datum_position_table
  1    60 			      (0 refer (basic_control_interval.number_of_datums)) like datum_slot;
  1    61 
  1    62 
  1    63      dcl	   1 bci_header	      aligned based (bci_header_ptr),
  1    64 	     2 layout_type	      char (4) aligned,
  1    65 	     2 collection_id      bit (36) aligned,
  1    66 	     2 next_control_interval
  1    67 			      fixed bin (24) uns unal,
  1    68 	     2 previous_control_interval
  1    69 			      fixed bin (24) uns unal,
  1    70 	     2 flags	      unal,
  1    71 	       3 continuation_datum_is_present
  1    72 			      bit (1) unal,
  1    73 	       3 free_slot_is_present
  1    74 			      bit (1) unal,
  1    75 	       3 must_be_zero     bit (4) unal,		/* reserved */
  1    76 	     2 scattered_free_space
  1    77 			      fixed bin (17) unal,
  1    78 	     2 start_of_used_space
  1    79 			      fixed bin (17) unal,
  1    80 	     2 number_of_datums   fixed bin (17) unal;
  1    81 
  1    82      dcl	   1 datum_slot	      aligned based (datum_slot_ptr),
  1    83 	     2 flags	      unal,
  1    84 	       3 special_format_datum
  1    85 			      bit (1) unal,		/* reserved */
  1    86 	       3 is_continued     bit (1) unal,
  1    87 	       3 is_continuation  bit (1) unal,
  1    88 	       3 mbz	      bit (1) unal,		/* reserved */
  1    89 	     2 offset_in_bytes    fixed bin (15) uns unal,
  1    90 	     2 length_in_bits     fixed bin (17) uns unal;
  1    91 
  1    92      dcl	   basic_control_interval_ptr
  1    93 			      ptr;
  1    94      dcl	   bci_header_ptr	      ptr;
  1    95      dcl	   datum_slot_ptr	      ptr;
  1    96 
  1    97      dcl	   BASIC_CI_LAYOUT_1      char (4) aligned init ("bci1") internal static options (constant);
  1    98 
  1    99 /* END INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
      515 
      516 
  2     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci_const.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*   Contains constants useful in describing parts of a basic control interval.
  2     6**/
  2     7 
  2     8 /* HISTORY:
  2     9*Written by Matthew Pierret, 09/20/84.
  2    10*Modified:
  2    11**/
  2    12 
  2    13      dcl	   FREE_SLOT	      init (0) fixed bin (15) uns internal static options (constant);
  2    14      dcl	   BCI_HEADER_LENGTH_IN_BYTES
  2    15 			      init (20) fixed bin internal static options (constant);
  2    16      dcl	   DATUM_POSITION_TABLE_OFFSET_IN_BYTES
  2    17 			      init (20) fixed bin internal static options (constant);
  2    18 
  2    19 
  2    20 /* END INCLUDE FILE dm_cm_basic_ci_const.incl.pl1 */
      517 
      518 
  3     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*
  3     5*        Contains the declaration of an element identifier.  Element
  3     6*   identifiers consist of two parts, the id (number) of the control interval
  3     7*   in which the element resides, and the index into the slot table of
  3     8*   the element in the control interval.  The declaration of the element_id 
  3     9*   structure reflects this division of the element identifier.  The structure 
  3    10*   is based on the automatic bit string element_id_string because programs
  3    11*   generally pass bit strings (element_id_string) to each other, then 
  3    12*   interpret the bit string by overlaying the element_id structure ony if
  3    13*   it is necessary to access the parts of the id.  Basing element_id on
  3    14*   addr(element_id_string) instead of on a pointer removes the necessity
  3    15*   for always setting that pointer explicitly and guarantees that changes
  3    16*   made to the string or structure do not get inconsistent.
  3    17*
  3    18*   Changes made to element_id must also be made to datum_id, declared in 
  3    19*   dm_cm_datum.incl.pl1.
  3    20**/
  3    21 
  3    22 /* HISTORY:
  3    23*Written by Matthew Pierret, 04/01/82.
  3    24*Modified:
  3    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  3    26**/
  3    27 
  3    28 /* format: style2,ind3,ll79 */
  3    29 
  3    30      dcl	   element_id_string      bit (36) aligned;
  3    31 
  3    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  3    33 	     2 control_interval_id
  3    34 			      fixed bin (24) unal unsigned,
  3    35 	     2 index	      fixed bin (12) unal unsigned;
  3    36 
  3    37 
  3    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      519 
      520 
  4     1 /* BEGIN INCLUDE FILE dm_cm_datum.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*        This include file contains the declarations of datum structures.
  4     5*   There are four tyes of datums: your ordinary, run-of-the-mill datum
  4     6*   (Datum); a continuation datum (CN Datum), which is a continuation of
  4     7*   another datum; a continued datum (CD Datum), which is continued (has a
  4     8*   continuation datum) but is not a continuation itself; and a continued
  4     9*   continuation datum (CDCN Datum), which is both continued and is a
  4    10*   continuation.  To illustrate, datums can be pieced combined in the
  4    11*   following ways:
  4    12*   
  4    13*   1) Datum alone.
  4    14*   
  4    15*   2) CD Datum -> CN Datum.
  4    16*   
  4    17*   3) CD Datum -> CDCN Datum {-> CDCN Datum -> ...-> CDCN Datum} -> CN Datum.
  4    18*
  4    19*   continued_datum and continued_continuation_datum each contains a header
  4    20*   which includes the identifier of the datum which is its continuation.
  4    21*   continued_datum.header.full_length is the length in bits of the entire
  4    22*   element, i.e., the addition of the length of contents structure component
  4    23*   of all of the datums from CD Datum to CN Datum.
  4    24**/
  4    25 
  4    26 /* HISTORY:
  4    27*Written by Matthew Pierret, 02/07/82.
  4    28*Modified:
  4    29*03/25/82 by Matthew Pierret: Changed all datum structures to be unaligned.
  4    30*06/14/82 by Matthew Pierret: Added DATUM_HEADER_LENGTH_IN_BYTES.
  4    31*08/04/82 by Matthew Pierret: Added DATUM_HEADER_LENGTH_IN_BITS.
  4    32*10/20/82 by Matthew Pierret:  Split into two include files, this one and
  4    33*            dm_cm_datum_constants.  The latter holds only and all constants
  4    34*            formerly in this include file.
  4    35*10/29/82 by Matthew Pierret:  Removed datum headers.
  4    36*09/18/84 by Matthew Pierret:  Added DESCRIPTION section.  Added datum and
  4    37*            continuation_datum (mainly for illustration).
  4    38*12/03/84 by Matthew Pierret:  Removed the non-based structures
  4    39*            (cd cdcn)_datum_headers.
  4    40**/
  4    41 
  4    42 /* format: style2,ll79,ind3 */
  4    43 
  4    44      dcl	   1 datum	      unaligned based (datum_ptr),
  4    45 	     2 contents	      bit (datum_contents_length_in_bits);
  4    46 
  4    47      dcl	   1 continuation_datum   unaligned based (datum_ptr),
  4    48 	     2 contents	      bit (datum_contents_length_in_bits);
  4    49 
  4    50      dcl	   1 continued_datum      unaligned based (datum_ptr),
  4    51 	     2 header,
  4    52 	       3 full_length      fixed bin (35),
  4    53 	       3 continuation     like datum_id,
  4    54 	     2 contents	      bit (datum_contents_length_in_bits);
  4    55 
  4    56      dcl	   1 continued_continuation_datum
  4    57 			      unaligned based (datum_ptr),
  4    58 	     2 header,
  4    59 	       3 continuation     like datum_id,
  4    60 	     2 contents	      bit (datum_contents_length_in_bits);
  4    61 
  4    62      dcl	   1 datum_id	      aligned based (datum_id_ptr),
  4    63 	     2 control_interval_id
  4    64 			      fixed bin (24) unal uns,
  4    65 	     2 index	      fixed bin (12) unal uns;
  4    66 
  4    67      dcl	   datum_ptr	      ptr init (null ());
  4    68      dcl	   datum_id_ptr	      ptr init (null ());
  4    69      dcl	   datum_contents_length_in_bits
  4    70 			      fixed bin (35) init (-1);
  4    71 
  4    72 
  4    73 
  4    74 /* END INCLUDE FILE dm_cm_datum.incl.pl1 */
      521 
      522 
  5     1 /* BEGIN INCLUDE FILE dm_cm_datum_constants.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*        Contains constants describing the extents of datums and datum
  5     5*   headers.  The datum headers are described in dm_cm_datum.incl.pl1.
  5     6*   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES is the byte length of the largest
  5     7*   datum that can be stored in a control interval, allowing for the largest
  5     8*   possibledatum header. MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS is the same
  5     9*   in bits instead of bytes.  MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
  5    10*   is the smallest length in bits which requires 
  5    11*   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES bytes to store.
  5    12**/
  5    13 
  5    14 /*
  5    15*HISTORY:
  5    16*Written by Matthew Pierret, 02/07/82.
  5    17*Modified:
  5    18*10/29/82 by Matthew Pierret:  Removed DATUM_HEADER*.
  5    19*11/02/82 by Matthew Pierret:  Added maximum datum contents lengths.
  5    20*12/01/82 by Lindsey Spratt:   Corrected values for datum header lengths.
  5    21*09/18/84 by Matthew Pierret:  Corrected values for maximum lengths. Added
  5    22*            MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS.  Added
  5    23*            DESCRIPTION section.
  5    24**/
  5    25 
  5    26 /* format: style2,ind3,ll79 */
  5    27      dcl	   CD_DATUM_HEADER_LENGTH_IN_BYTES
  5    28 			      fixed bin init (8) internal static
  5    29 			      options (constant);
  5    30 
  5    31      dcl	   CD_DATUM_HEADER_LENGTH_IN_BITS
  5    32 			      fixed bin init (72) internal static
  5    33 			      options (constant);
  5    34 
  5    35      dcl	   CDCN_DATUM_HEADER_LENGTH_IN_BYTES
  5    36 			      init (4) fixed bin int static
  5    37 			      options (constant);
  5    38 
  5    39      dcl	   CDCN_DATUM_HEADER_LENGTH_IN_BITS
  5    40 			      init (36) fixed bin int static
  5    41 			      options (constant);
  5    42 
  5    43      dcl	   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
  5    44 			      init (36360) fixed bin (35) internal
  5    45 			      static options (constant);
  5    46 
  5    47      dcl	   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES
  5    48 			      init (4040) fixed bin (35) internal
  5    49 			      static options (constant);
  5    50 
  5    51      dcl	   MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
  5    52 			      init (36352) fixed bin (35) internal
  5    53 			      static options (constant);
  5    54 
  5    55 /* END INCLUDE FILE dm_cm_datum.incl.pl1 */
      523 
      524 
  6     1 /* BEGIN INCLUDE FILE dm_ci_lengths.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*       This include file contains constants which are the length in bytes
  6     5*   of the addressable portion of a control interval.  The addressable portion
  6     6*   is that part of the control interval which callers of file_manager_
  6     7*   may access, specifically, everything between the end of the control
  6     8*   interval header (ci_header) and the control interval trailer (ci_trailer).
  6     9*   Control interval 0 is slightly different, as it also contains an 
  6    10*   unaddressable portion in which it maintains the file attributes.  For
  6    11*   control interval 0 the addressable portion is everything between the end
  6    12*   of the control interval header and the beginning of the file attributes.
  6    13**/
  6    14 
  6    15 /* HISTORY:
  6    16*Written by Matthew Pierret, 11/02/84.
  6    17*Modified:
  6    18**/
  6    19 
  6    20 /* format: style2,ind3 */
  6    21 
  6    22      dcl	   CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
  6    23 			      fixed bin (17) init (4072) int static options (constant);
  6    24 
  6    25      dcl	   CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
  6    26 			      fixed bin (17) init (3176) int static options (constant);
  6    27 
  6    28 
  6    29      dcl	   CI_ADDRESSABLE_LENGTH  fixed bin (17) init (4072) int static options (constant);
  6    30 
  6    31      dcl	   CI_0_ADDRESSABLE_LENGTH
  6    32 			      fixed bin (17) init (3176) int static options (constant);
  6    33 
  6    34 /* END INCLUDE FILE dm_ci_lengths.incl.pl1 */
      525 
      526 
  7     1 /*  BEGIN INCLUDE FILE:  dm_ci_parts.incl.pl1  */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*
  7     5*        This include file contains the ci_parts structure.  This structure
  7     6*   is used across the file_manager_ interface to specify the parts of a
  7     7*   control interval to get or put.  If the number_of parts is equal to 0,
  7     8*   modules which take ci_parts interpret this case to mean to do everything
  7     9*   except the actual requested operation, i.e., lock the control interval
  7    10*   but don't get anything.  offset_in_bytes is the 0-originned offset in
  7    11*   bytes from the beginning of the addressable portion of the control interval.
  7    12*   An offset_in_bytes which is in the addressable portion is in error.
  7    13*   Likewise, if offset_in_bytes + length_in_bytes is outside of the addressable
  7    14*   portion, it is in error.
  7    15**/
  7    16 
  7    17 /* HISTORY:
  7    18*Written by Matthew Pierret, 01/28/82.
  7    19*  (01/28/82 Andre Bensoussan, Design.)
  7    20*Modified:
  7    21*11/07/84 by Matthew Pierret:  To add must_be_zero, initial attributes on
  7    22*            automatic storge.
  7    23**/
  7    24 
  7    25 /* format: style2,ind3 */
  7    26 
  7    27      dcl	   1 ci_parts	      aligned based (ci_parts_ptr),
  7    28 	     2 number_of_parts    fixed bin (17),
  7    29 	     2 must_be_zero	      fixed bin,
  7    30 	     2 part	      (cip_number_of_parts refer (ci_parts.number_of_parts)),
  7    31 	       3 offset_in_bytes  fixed bin (17),
  7    32 	       3 length_in_bytes  fixed bin (17),
  7    33 	       3 local_ptr	      ptr;
  7    34 
  7    35      dcl	   ci_parts_ptr	      ptr init (null ());
  7    36      dcl	   cip_number_of_parts    fixed bin (17) init (0);
  7    37 
  7    38 
  7    39 /*  BEGIN INCLUDE FILE:   dm_ci_parts.incl.pl1   */
      527 
      528 
  8     1 /* BEGIN INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
  8     2 
  8     3 /* DESCRIPTION:
  8     4*
  8     5*   Contains entry declarations of internally available collection_manager_
  8     6*   entries.  Entries which are only available via the collection_manager_
  8     7*   transfer vector are not included here, but are declared instead in 
  8     8*   dm_collmgr_entry_dcls.incl.pl1.
  8     9**/
  8    10 
  8    11 /* HISTORY:
  8    12*Written by Mathew Pierret, 04/01/82.
  8    13*Modified:
  8    14*09/21/82 by Lindsey Spratt:  Added the cm_compact$replacement entry.
  8    15*10/29/82 by Matthew Pierret:  Added cm_find_free_slot, cm_determine_free_space,
  8    16*            cm_find_ci_to_alloc_datum, cm_recursive_put.
  8    17*            Added cm_get_element$info*, $header*.  The former is used when
  8    18*            the caller has a cm_info structure already; the latter is used to
  8    19*            get collection headers.
  8    20*            Added cm_opening_info$get. Removed cm_add_ci_(part thread).
  8    21*            Added cm_allocate_element$info.
  8    22*11/09/82 by Matthew Pierret:  Added argument to cm_allocate_ordered_element
  8    23*            calling sequence for returning free space.
  8    24*            Added cm_free_cn_datum("" $header).
  8    25*01/07/83 by Matthew Pierret:  Added:
  8    26*            cm_allocate_element$buffered("" _info);
  8    27*            cm_put_element$buffered("" _info);
  8    28*            cm_put_datum_in_place$buffered("" _continued);
  8    29*            cm_put_datum_in_pool$buffered("" _continued);
  8    30*            cm_compact$buffered.
  8    31*01/26/83 by Matthew Pierret: Replaced cm_get_header_and_slot with
  8    32*            cm_get_bci_header$slot and added cm_get_bci_header$slot_exclusive.
  8    33*            Added cm_opening_info$get_storage_record.
  8    34*            Added a bit(36)aligned argument to cm_recursive_put to hold the
  8    35*            id of the previous datum.
  8    36*02/02/83 by Matthew Pierret: Added fixed bin (17) argument to cm_find_free_slot
  8    37*            which is for the number of slots after allocation.
  8    38*02/07/83 by Matthew Pierret: Added cm_get_id$(id info info_return_slot
  8    39*            header header_return_slot).
  8    40*            Added cm_get_element_portion$(exclusive info info_exclusive).
  8    41*            Added cm_get_element$bypass_info.
  8    42*03/25/83 by Matthew Pierret: Added cm_free_element$info and
  8    43*            cm_free_opening_info.
  8    44*04/29/83 by Matthew Pierret: Added cm_put_element$unprotected_info
  8    45*08/04/83 by Matthew Pierret:  Added the entries $does_new_datum_fit and
  8    46*            $does_replacement_fit to cm_determine_free_space.  These entries
  8    47*            return flags indicating if a datum fits in the ci and the pool.
  8    48*            Added a bit(1)aligned parameter to cm_find_free_slot in which is
  8    49*            returned the new value of bci_header.free_slot_is_present.
  8    50*02/07/84 by Matthew Pierret:  Added cm_get_id$ptr.  Removed all cm_get_id
  8    51*            modules except cm_get_id$id.  Removed all cm_get_element$info*
  8    52*            entries.  Changed cm_get_element_$bypass_info to have the same
  8    53*            calling sequence as other cm_get_element entries.
  8    54*06/12/84 by Matthew Pierret:  Changed cm_put_element to cm_modify
  8    55*            and cm_allocate_element to cm_put.
  8    56*            Switched the element_length/element_ptr parameter pair to be
  8    57*            element_ptr/element_length in cm_modify and cm_put.
  8    58*07/24/84 by Matthew Pierret:  Added cm_free_ci$raw_return_prev_next.
  8    59*09/24/84 by Matthew Pierret:  Added trace_thread_modifications_(on off)
  8    60*            entries to cm_free_ci and cm_replace_buffered_ci, 
  8    61*            cm_allocate_ci$info_header, cm_opening_info$opening_table_ptr.
  8    62*            Removed cm_find_free_space. Commented out un-used entries.
  8    63*            Re-named allocate  entries to put entries, except for allocate_ci.
  8    64*            Re-named free element and free datum entries to use delete instead
  8    65*            of free, and cm_recursive_put to cm_recursive_modify.
  8    66*            Removed cm_get_element$bypass_info.
  8    67*02/27/85 by Matthew C. Pierret:  Re-added cm_compact$buffered_replacement now
  8    68*            that cm_modify$buffered uses it.
  8    69*03/07/85 by R. Michael Tague:  Added cm_postcommit_increment.
  8    70**/
  8    71 
  8    72 /* format: style2,ind3 */
  8    73 
  8    74 
  8    75      dcl	   cm_allocate_ci	      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  8    76      dcl	   cm_allocate_ci$info    entry (ptr, fixed bin (24) unsigned, fixed bin (35));
  8    77      dcl	   cm_allocate_ci$info_header
  8    78 			      entry (ptr, fixed bin (24) unsigned, ptr, fixed bin (35));
  8    79 
  8    80 
  8    81      dcl	   cm_compact	      entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
  8    82      dcl	   cm_compact$buffered    entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
  8    83      dcl	   cm_compact$replacement entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
  8    84      dcl	   cm_compact$buffered_replacement
  8    85 			      entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
  8    86 
  8    87      dcl	   cm_delete_cn_datum     entry (ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
  8    88 
  8    89      dcl	   cm_delete_cn_datum$header
  8    90 			      entry (ptr, ptr, ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
  8    91 
  8    92      dcl	   cm_delete	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  8    93 			      fixed bin (35));
  8    94      dcl	   cm_delete$info	      entry (ptr, bit (36) aligned, bit (1) aligned, fixed bin (35));
  8    95 
  8    96      dcl	   cm_determine_free_space$all
  8    97 			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35));
  8    98      dcl	   cm_determine_free_space$effective
  8    99 			      entry (ptr, fixed bin (35), bit (1) aligned, bit (1) aligned, fixed bin (35),
  8   100 			      fixed bin (35));
  8   101      dcl	   cm_determine_free_space$does_new_datum_fit
  8   102 			      entry (ptr, fixed bin (35), fixed bin (35), bit (1) aligned, bit (1) aligned,
  8   103 			      bit (1) aligned, bit (1) aligned, fixed bin (35));
  8   104 
  8   105 /**** Not yet used *********************************************************
  8   106*     dcl	   cm_determine_free_space$does_replacement_fit
  8   107*			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35), bit (1) aligned,
  8   108*			      bit (1) aligned, bit (1) aligned, bit (1) aligned, fixed bin (35)); 
  8   109*************************************************************************** */
  8   110 
  8   111      dcl	   cm_find_ci_to_alloc_datum
  8   112 			      entry (ptr, fixed bin (35), fixed bin (24) uns, bit (1) aligned, bit (1) aligned, ptr,
  8   113 			      fixed bin (24) uns, fixed bin (35));
  8   114 
  8   115      dcl	   cm_find_free_slot      entry (bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (17), fixed bin (17),
  8   116 			      bit (1) aligned, fixed bin (35));
  8   117 
  8   118      dcl	   cm_free_ci$info	      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (35));
  8   119      dcl	   cm_free_ci$raw_return_prev_next
  8   120 			      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (24) uns,
  8   121 			      fixed bin (24) uns, fixed bin (35));
  8   122      dcl	   cm_free_ci$trace_thread_modifications_on
  8   123 			      entry ();
  8   124      dcl	   cm_free_ci$trace_thread_modifications_off
  8   125 			      entry ();
  8   126 
  8   127 
  8   128      dcl	   cm_free_opening_info   entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  8   129 
  8   130      dcl	   cm_get_bci_header      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
  8   131      dcl	   cm_get_bci_header$exclusive
  8   132 			      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
  8   133      dcl	   cm_get_bci_header$slot entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  8   134 
  8   135 /**** Not yet used ********************************************************
  8   136*     dcl	   cm_get_bci_header$slot_exclusive
  8   137*			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  8   138*************************************************************************** */
  8   139 
  8   140      dcl	   cm_get_element	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  8   141 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  8   142      dcl	   cm_get_element$exclusive
  8   143 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  8   144 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  8   145 
  8   146      dcl	   cm_get_element_portion entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  8   147 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  8   148 			      fixed bin (35), fixed bin (35));
  8   149 
  8   150 /**** Not yet used ********************************************************
  8   151*     dcl	   cm_get_element_portion$exclusive
  8   152*			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  8   153*			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  8   154*			      fixed bin (35), fixed bin (35));
  8   155*************************************************************************** */
  8   156 
  8   157      dcl	   cm_get_id$id	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
  8   158 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  8   159      dcl	   cm_get_id$ptr	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
  8   160 			      bit (1) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  8   161 
  8   162      dcl	   cm_modify	      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   163 			      fixed bin (35), fixed bin (35));
  8   164      dcl	   cm_modify$buffered     entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   165 			      fixed bin (35), fixed bin (35));
  8   166 
  8   167 /******* Not yet used *****************************************************
  8   168*     dcl	   cm_modify$buffered_info
  8   169*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
  8   170*			      fixed bin (35));
  8   171*****************************************************************************/
  8   172 
  8   173      dcl	   cm_modify$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  8   174      dcl	   cm_modify$unprotected_info
  8   175 			      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  8   176 
  8   177 
  8   178 /******* Not yet used *****************************************************
  8   179*     dcl	   cm_modify_portion entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35),
  8   180*			      fixed bin (35), ptr, bit (36) aligned, fixed bin (35), fixed bin (35));
  8   181*****************************************************************************/
  8   182 
  8   183 
  8   184      dcl	   cm_opening_info$get    entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  8   185      dcl	   cm_opening_info$get_storage_record
  8   186 			      entry (ptr, fixed bin (35));
  8   187      dcl	   cm_opening_info$full_get
  8   188 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  8   189      dcl	   cm_opening_info$opening_table_ptr
  8   190 			      entry () returns (ptr);
  8   191 
  8   192      dcl	   cm_postcommit_increment
  8   193 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  8   194 
  8   195      dcl	   cm_put		      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   196 			      fixed bin (35), fixed bin (35));
  8   197      dcl	   cm_put$buffered	      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   198 			      fixed bin (35), fixed bin (35));
  8   199 
  8   200 /******* Not yet used *****************************************************
  8   201*     dcl	   cm_put$buffered_info
  8   202*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
  8   203*			      fixed bin (35));
  8   204*****************************************************************************/
  8   205 
  8   206      dcl	   cm_put$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  8   207 
  8   208      dcl	   cm_put_basic_element   entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  8   209 			      fixed bin (35));
  8   210 
  8   211      dcl	   cm_put_cn_datum	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, bit (36) aligned, fixed bin (35));
  8   212 
  8   213      dcl	   cm_put_datum_in_place  entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  8   214 			      fixed bin (35));
  8   215      dcl	   cm_put_datum_in_place$buffered
  8   216 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  8   217      dcl	   cm_put_datum_in_place$buffered_continued
  8   218 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
  8   219 			      fixed bin (35));
  8   220      dcl	   cm_put_datum_in_place$continued
  8   221 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  8   222 			      fixed bin (35), bit (36) aligned, fixed bin (35));
  8   223 
  8   224      dcl	   cm_put_datum_in_pool   entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  8   225 			      fixed bin (35));
  8   226      dcl	   cm_put_datum_in_pool$buffered
  8   227 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  8   228      dcl	   cm_put_datum_in_pool$buffered_continued
  8   229 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
  8   230 			      fixed bin (35));
  8   231      dcl	   cm_put_datum_in_pool$continued
  8   232 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  8   233 			      fixed bin (35), bit (36) aligned, fixed bin (35));
  8   234 
  8   235      dcl	   cm_put_ordered_element entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  8   236 			      fixed bin (35));
  8   237      dcl	   cm_put_ordered_element$buffered
  8   238 			      entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  8   239 			      fixed bin (35));
  8   240 
  8   241      dcl	   cm_put_overlength_tail entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35));
  8   242 
  8   243      dcl	   cm_recursive_modify    entry (ptr, bit (36) aligned, ptr, fixed bin (35), fixed bin (35), bit (36) aligned,
  8   244 			      fixed bin (35));
  8   245 
  8   246 
  8   247      dcl	   cm_replace_buffered_ci$trace_thread_modifications_on
  8   248 			      entry ();
  8   249      dcl	   cm_replace_buffered_ci$trace_thread_modifications_off
  8   250 			      entry ();
  8   251 
  8   252 /* END INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
      529 
      530 
  9     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  9     2 /* format: style3 */
  9     3 
  9     4 /* These constants are to be used for the flags argument of sub_err_ */
  9     5 /* They are just "string (condition_info_header.action_flags)" */
  9     6 
  9     7 declare	(
  9     8 	ACTION_CAN_RESTART	init (""b),
  9     9 	ACTION_CANT_RESTART init ("1"b),
  9    10 	ACTION_DEFAULT_RESTART
  9    11 			init ("01"b),
  9    12 	ACTION_QUIET_RESTART
  9    13 			init ("001"b),
  9    14 	ACTION_SUPPORT_SIGNAL
  9    15 			init ("0001"b)
  9    16 	)		bit (36) aligned internal static options (constant);
  9    17 
  9    18 /* End include file */
      531 
      532 
      533    end cm_get_element_buffered;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0912.6  cm_get_element_buffered.pl1       >spec>on>7192.pbf-04/04/85>cm_get_element_buffered.pl1
515          1    01/07/85  0858.0  dm_cm_basic_ci.incl.pl1           >ldd>include>dm_cm_basic_ci.incl.pl1
517          2    01/07/85  0858.1  dm_cm_basic_ci_const.incl.pl1     >ldd>include>dm_cm_basic_ci_const.incl.pl1
519          3    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
521          4    01/07/85  0901.2  dm_cm_datum.incl.pl1              >ldd>include>dm_cm_datum.incl.pl1
523          5    01/07/85  0858.2  dm_cm_datum_constants.incl.pl1    >ldd>include>dm_cm_datum_constants.incl.pl1
525          6    01/07/85  0900.7  dm_ci_lengths.incl.pl1            >ldd>include>dm_ci_lengths.incl.pl1
527          7    01/07/85  0900.8  dm_ci_parts.incl.pl1              >ldd>include>dm_ci_parts.incl.pl1
529          8    04/04/85  0819.0  dm_cm_entry_dcls.incl.pl1         >spec>on>7192.pbf-04/04/85>dm_cm_entry_dcls.incl.pl1
531          9    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000024 constant        bit(36)                  initial dcl 9-7 set ref 482* 503* 508*
ACTION_CAN_RESTART              000030 constant        bit(36)                  initial dcl 9-7 set ref 68*
BASIC_CI_LAYOUT_1               000000 constant        char(4)                  initial dcl 1-97 set ref 465 465*
BITS_PER_BYTE                   002265 constant        fixed bin(17,0)          initial dcl 146 ref 216 257 257 271 304 329 341 390
BYTES_PER_DOUBLE_WORD           002266 constant        fixed bin(17,0)          initial dcl 145 ref 266 323 441
CDCN_DATUM_HEADER_LENGTH_IN_BYTES      constant        fixed bin(17,0)          initial dcl 5-35 ref 386 405
CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
                                       constant        fixed bin(17,0)          initial dcl 6-22 ref 192
CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
                                       constant        fixed bin(17,0)          initial dcl 6-25 ref 190
FREE_SLOT                              constant        fixed bin(15,0)          initial unsigned dcl 2-13 ref 236 381
addcharno                                              builtin function         dcl 134 ref 284 300 349 352 416
addr                                                   builtin function         dcl 134 ref 190 202 236 236 241 251 254 281 300 341
                                                                                  346 360 361 363 372 372 372 372 381 381 381 381
                                                                                  406 410 421
automatic_bci_header            000100 automatic       structure                level 1 dcl 92 set ref 357* 360
automatic_cip_buffer            000106 automatic       fixed bin(71,0)          initial array dcl 94 set ref 94* 94* 94* 94* 94* 94*
                                                                                  94* 94* 363
automatic_datum_slot            000105 automatic       structure                level 1 dcl 93 set ref 358* 361
basic_control_interval                 based           structure                level 1 dcl 1-56
basic_control_interval_ptr      000164 automatic       pointer                  dcl 1-92 set ref 194* 196 198 202 236 236 241 251
                                                                                  254 281 300 341 346
bci_header                             based           structure                level 1 dcl 1-63
bci_header_ptr                  000166 automatic       pointer                  dcl 1-94 set ref 360* 370* 381
buffer                                 based           fixed bin(71,0)          array dcl 129 ref 266 323 441
buffer_length_in_bytes          000130 automatic       fixed bin(17,0)          initial dcl 97 set ref 97* 216* 260 264* 266 306
                                                                                  321* 323 441
buffer_ptr                      000146 automatic       pointer                  initial dcl 117 set ref 117* 215* 266* 284 287 323*
                                                                                  349 352 426 438 438 438 441
ccv_p_given_version                    parameter       char(4)                  dcl 461 set ref 458 465 465*
cdcn_datum_header               000154 automatic       structure                level 1 dcl 121 set ref 406
ceil                                                   builtin function         dcl 134 ref 304 341 390
ci_buffer_length_in_bytes       000131 automatic       fixed bin(17,0)          initial dcl 98 set ref 98* 190* 192*
ci_buffer_ptr                   000150 automatic       pointer                  initial dcl 118 set ref 118* 194* 284 300 349
ci_parts                               based           structure                level 1 dcl 7-27
ci_parts_ptr                    000202 automatic       pointer                  initial dcl 7-35 set ref 363* 393 395 396 397 403
                                                                                  404 405 406 410* 7-35*
cip_number_of_parts             000204 automatic       fixed bin(17,0)          initial dcl 7-36 set ref 7-36*
cleanup                         000156 stack reference condition                dcl 139 ref 265 322
cm_get_bci_header$slot          000034 constant        entry                    external dcl 8-133 ref 370
collection_id             1            based           bit(36)                  level 2 in structure "bci_header" dcl 1-63
                                                                                  in procedure "cm_get_element_buffered" set ref
                                                                                  381*
collection_id             1            based           bit(36)                  level 3 in structure "basic_control_interval"
                                                                                  dcl 1-56 in procedure "cm_get_element_buffered"
                                                                                  ref 198
continuation                    000154 automatic       structure                level 2 in structure "cdcn_datum_header" dcl 121
                                                                                  in procedure "cm_get_element_buffered" set ref
                                                                                  368* 421
continuation              1            based           structure                level 3 in structure "continued_datum" packed
                                                                                  unaligned dcl 4-50 in procedure
                                                                                  "cm_get_element_buffered" ref 355
continuation_datum_id                  based           structure                level 1 dcl 125 set ref 421*
continuation_datum_id_string    000126 automatic       bit(36)                  dcl 95 set ref 355* 365 370* 372 372 381 381 410 420
                                                                                  421
continued_continuation_datum           based           structure                level 1 packed unaligned dcl 4-56
continued_datum                        based           structure                level 1 packed unaligned dcl 4-50
continued_datum_id_string       000127 automatic       bit(36)                  dcl 95 set ref 354* 372 372 381 381 420*
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "element_id" packed unsigned
                                                                                  unaligned dcl 3-32 in procedure
                                                                                  "cm_get_element_buffered" set ref 190 372* 381*
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "continuation_datum_id" packed
                                                                                  unsigned unaligned dcl 125 in procedure
                                                                                  "cm_get_element_buffered" set ref 372* 381* 410
current_buffer_ptr              000152 automatic       pointer                  initial dcl 119 set ref 119* 352* 397 416* 416
datum_contents_length_in_bits   000200 automatic       fixed bin(35,0)          initial dcl 4-69 set ref 251* 254* 257 288 4-69*
datum_contents_length_in_bytes  000132 automatic       fixed bin(17,0)          initial dcl 100 set ref 100* 257* 260 264 271 284
                                                                                  284 329 341* 349 349 352 390* 396 416 418
datum_contents_offset_in_bytes  000133 automatic       fixed bin(17,0)          initial dcl 102 set ref 102* 281* 284 346* 349
datum_contents_string                  based           char                     unaligned dcl 127 set ref 284* 284 349* 349
datum_header_length_in_bytes    000134 automatic       fixed bin(17,0)          initial dcl 104 set ref 104* 386* 388* 390 395
datum_id                               based           structure                level 1 dcl 4-62
datum_id_ptr                    000176 automatic       pointer                  initial dcl 4-68 set ref 4-68*
datum_position_table      5            based           structure                array level 2 dcl 1-56
datum_ptr                       000174 automatic       pointer                  initial dcl 4-67 set ref 300* 304 355 427 4-67*
datum_slot                             based           structure                level 1 dcl 1-82
datum_slot_ptr                  000170 automatic       pointer                  dcl 1-95 set ref 361* 370* 381 381 386 390 395 399
                                                                                  404
divide                                                 builtin function         dcl 134 ref 216 257 304 341 390
dm_error_$ci_not_allocated      000016 external static fixed bin(35,0)          dcl 155 ref 372 482
dm_error_$ci_not_in_collection  000014 external static fixed bin(35,0)          dcl 155 set ref 198*
dm_error_$long_return_element   000030 external static fixed bin(35,0)          dcl 155 set ref 272* 330*
dm_error_$misformatted_ci       000024 external static fixed bin(35,0)          dcl 155 ref 372
dm_error_$no_element            000020 external static fixed bin(35,0)          dcl 155 set ref 202* 236* 372 482
dm_error_$no_output_buffer      000022 external static fixed bin(35,0)          dcl 155 set ref 227*
dm_error_$programming_error     000026 external static fixed bin(35,0)          dcl 155 set ref 68* 503* 508*
dm_error_$unimplemented_ci_version
                                000036 external static fixed bin(35,0)          dcl 462 set ref 465*
element_id                             based           structure                level 1 dcl 3-32
element_id_string               000172 automatic       bit(36)                  dcl 3-30 set ref 188* 190 202 202 236 236 241 251
                                                                                  254 281 300 341 346 354
element_length_in_bytes         000135 automatic       fixed bin(17,0)          initial dcl 106 set ref 106* 304* 306 321 365 418*
                                                                                  418
er_p_code                              parameter       fixed bin(35,0)          dcl 450 ref 447 452
error_table_$bad_arg            000032 external static fixed bin(35,0)          dcl 155 set ref 180*
file_manager_$get               000010 constant        entry                    external dcl 150 ref 410
flags                     5            based           structure                array level 3 in structure "basic_control_interval"
                                                                                  packed unaligned dcl 1-56 in procedure
                                                                                  "cm_get_element_buffered"
flags                                  based           structure                level 2 in structure "datum_slot" packed unaligned
                                                                                  dcl 1-82 in procedure "cm_get_element_buffered"
floor                                                  builtin function         dcl 134 ref 216
full_length                            based           fixed bin(35,0)          level 3 packed unaligned dcl 4-50 ref 304 427
get_whole_element               000142 automatic       bit(1)                   dcl 114 set ref 172* 179* 251
header                                 based           structure                level 2 in structure "basic_control_interval"
                                                                                  dcl 1-56 in procedure "cm_get_element_buffered"
header                                 based           structure                level 2 in structure "continued_continuation_datum"
                                                                                  packed unaligned dcl 4-56 in procedure
                                                                                  "cm_get_element_buffered"
header                                 based           structure                level 2 in structure "continued_datum" packed
                                                                                  unaligned dcl 4-50 in procedure
                                                                                  "cm_get_element_buffered"
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "element_id" packed unsigned
                                                                                  unaligned dcl 3-32 in procedure
                                                                                  "cm_get_element_buffered" set ref 202 236 236 241
                                                                                  251 254 281 300 341 346 372* 381*
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "continuation_datum_id" packed
                                                                                  unsigned unaligned dcl 125 in procedure
                                                                                  "cm_get_element_buffered" set ref 372* 381*
is_continuation           0(02)        based           bit(1)                   level 3 in structure "datum_slot" packed unaligned
                                                                                  dcl 1-82 in procedure "cm_get_element_buffered"
                                                                                  ref 381
is_continuation           5(02)        based           bit(1)                   array level 4 in structure "basic_control_interval"
                                                                                  packed unaligned dcl 1-56 in procedure
                                                                                  "cm_get_element_buffered" ref 236
is_continued              0(01)        based           bit(1)                   level 3 in structure "datum_slot" packed unaligned
                                                                                  dcl 1-82 in procedure "cm_get_element_buffered"
                                                                                  ref 386 399
is_continued              5(01)        based           bit(1)                   array level 4 in structure "basic_control_interval"
                                                                                  packed unaligned dcl 1-56 in procedure
                                                                                  "cm_get_element_buffered" ref 241
layout_type                            based           char(4)                  level 3 dcl 1-56 set ref 196*
length_in_bits            5(19)        based           fixed bin(17,0)          array level 3 in structure "basic_control_interval"
                                                                                  packed unsigned unaligned dcl 1-56 in procedure
                                                                                  "cm_get_element_buffered" ref 251 254 341
length_in_bits            0(19)        based           fixed bin(17,0)          level 2 in structure "datum_slot" packed unsigned
                                                                                  unaligned dcl 1-82 in procedure
                                                                                  "cm_get_element_buffered" ref 390
length_in_bytes           3            based           fixed bin(17,0)          array level 3 dcl 7-27 set ref 396* 405*
local_ptr                 4            based           pointer                  array level 3 dcl 7-27 set ref 397* 406*
min                                                    builtin function         dcl 134 ref 254
myname                          000001 constant        varying char(32)         initial dcl 143 set ref 68* 465*
new_buffer_allowed              000140 automatic       bit(1)                   initial dcl 112 set ref 112* 224* 227 260 310
null                                                   builtin function         dcl 134 ref 68 68 116 117 118 119 212 220 4-67 4-68
                                                                                  7-35 438 465 465 482 482 503 503 508 508
number_of_datums          4(18)        based           fixed bin(17,0)          level 3 packed unaligned dcl 1-56 ref 202
number_of_parts                        based           fixed bin(17,0)          level 2 dcl 7-27 set ref 393* 403*
offset_in_bytes           2            based           fixed bin(17,0)          array level 3 in structure "ci_parts" dcl 7-27
                                                                                  in procedure "cm_get_element_buffered" set ref
                                                                                  395* 404*
offset_in_bytes           0(04)        based           fixed bin(15,0)          level 2 in structure "datum_slot" packed unsigned
                                                                                  unaligned dcl 1-82 in procedure
                                                                                  "cm_get_element_buffered" ref 381 395 404
offset_in_bytes           5(04)        based           fixed bin(15,0)          array level 3 in structure "basic_control_interval"
                                                                                  packed unsigned unaligned dcl 1-56 in procedure
                                                                                  "cm_get_element_buffered" ref 236 281 300 346
old_buffer_length_in_bytes      000136 automatic       fixed bin(17,0)          initial dcl 108 set ref 108*
p_area_ptr                             parameter       pointer                  dcl 80 ref 168 175 220 223
p_buffer_length                        parameter       fixed bin(35,0)          dcl 79 ref 168 175 216
p_buffer_ptr                           parameter       pointer                  dcl 78 ref 168 175 212 215 438
p_ci_buffer_ptr                        parameter       pointer                  dcl 74 ref 168 175 194
p_code                                 parameter       fixed bin(35,0)          dcl 88 set ref 168 175 185* 370* 372 372 372 372
                                                                                  372* 378* 410* 412 412* 452*
p_collection_id                        parameter       bit(36)                  dcl 76 set ref 168 175 198 381*
p_element_id                           parameter       bit(36)                  dcl 77 ref 168 175 188
p_element_length                       parameter       fixed bin(35,0)          dcl 84 set ref 168 175 271* 288* 329* 427*
p_element_ptr                          parameter       pointer                  dcl 83 set ref 168 175 287* 426* 438
p_file_opening_id                      parameter       bit(36)                  dcl 75 set ref 168 175 370* 410*
p_new_buffer_was_allocated             parameter       bit(1)                   dcl 81 set ref 168 175 267* 324* 442*
p_portion_beginning_index              parameter       fixed bin(35,0)          dcl 85 ref 175 180
p_portion_length                       parameter       fixed bin(35,0)          dcl 87 ref 175 180 254
part                      2            based           structure                array level 2 dcl 7-27
rmdi_p_cd_ci                           parameter       fixed bin(24,0)          unsigned unaligned dcl 476 set ref 473 482*
rmdi_p_cd_index                        parameter       fixed bin(12,0)          unsigned unaligned dcl 478 set ref 473 482*
rmdi_p_cn_ci                           parameter       fixed bin(24,0)          unsigned unaligned dcl 476 set ref 473 482*
rmdi_p_cn_index                        parameter       fixed bin(12,0)          unsigned unaligned dcl 478 set ref 473 482*
rmdi_p_code                            parameter       fixed bin(35,0)          dcl 480 set ref 473 482* 482 482
slot_idx                        000137 automatic       fixed bin(17,0)          initial dcl 110 set ref 110*
sub_err_                        000012 constant        entry                    external dcl 151 ref 68 465 482 503 508
unspec                                                 builtin function         dcl 134 set ref 355 357* 358* 368*
use_supplied_buffer             000141 automatic       bit(1)                   initial dcl 113 set ref 113* 217* 227 260 260 306
                                                                                  306* 310
vmdi_p_cd_ci                           parameter       fixed bin(24,0)          unsigned unaligned dcl 494 set ref 490 503* 508*
vmdi_p_cd_collection_id                parameter       bit(36)                  dcl 498 set ref 490 503 503*
vmdi_p_cd_index                        parameter       fixed bin(12,0)          unsigned unaligned dcl 496 set ref 490 503* 508*
vmdi_p_cn_ci                           parameter       fixed bin(24,0)          unsigned unaligned dcl 494 set ref 490 503* 508*
vmdi_p_cn_collection_id                parameter       bit(36)                  dcl 498 set ref 490 503 503*
vmdi_p_cn_index                        parameter       fixed bin(12,0)          unsigned unaligned dcl 496 set ref 490 503* 508*
vmdi_p_cn_slot_is_free                 parameter       bit(1)                   dcl 500 set ref 490 508 508*
vmdi_p_cn_slot_is_not_continuation     parameter       bit(1)                   dcl 500 ref 490 508
work_area                              based           area(1024)               dcl 128 ref 266 323 441
work_area_ptr                   000144 automatic       pointer                  initial dcl 116 set ref 116* 223* 266 323 441

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 9-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 9-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 9-7
BCI_HEADER_LENGTH_IN_BYTES             internal static fixed bin(17,0)          initial dcl 2-14
CDCN_DATUM_HEADER_LENGTH_IN_BITS       internal static fixed bin(17,0)          initial dcl 5-39
CD_DATUM_HEADER_LENGTH_IN_BITS         internal static fixed bin(17,0)          initial dcl 5-31
CD_DATUM_HEADER_LENGTH_IN_BYTES        internal static fixed bin(17,0)          initial dcl 5-27
CI_0_ADDRESSABLE_LENGTH                internal static fixed bin(17,0)          initial dcl 6-31
CI_ADDRESSABLE_LENGTH                  internal static fixed bin(17,0)          initial dcl 6-29
DATUM_POSITION_TABLE_OFFSET_IN_BYTES   internal static fixed bin(17,0)          initial dcl 2-16
MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS  internal static fixed bin(35,0)          initial dcl 5-43
MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES internal static fixed bin(35,0)          initial dcl 5-47
MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
                                       internal static fixed bin(35,0)          initial dcl 5-51
cm_allocate_ci                  000000 constant        entry                    external dcl 8-75
cm_allocate_ci$info             000000 constant        entry                    external dcl 8-76
cm_allocate_ci$info_header      000000 constant        entry                    external dcl 8-77
cm_compact                      000000 constant        entry                    external dcl 8-81
cm_compact$buffered             000000 constant        entry                    external dcl 8-82
cm_compact$buffered_replacement 000000 constant        entry                    external dcl 8-84
cm_compact$replacement          000000 constant        entry                    external dcl 8-83
cm_delete                       000000 constant        entry                    external dcl 8-92
cm_delete$info                  000000 constant        entry                    external dcl 8-94
cm_delete_cn_datum              000000 constant        entry                    external dcl 8-87
cm_delete_cn_datum$header       000000 constant        entry                    external dcl 8-89
cm_determine_free_space$all     000000 constant        entry                    external dcl 8-96
cm_determine_free_space$does_new_datum_fit
                                000000 constant        entry                    external dcl 8-101
cm_determine_free_space$effective
                                000000 constant        entry                    external dcl 8-98
cm_find_ci_to_alloc_datum       000000 constant        entry                    external dcl 8-111
cm_find_free_slot               00000                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ifications_off
                                000000 constant        entry                    external dcl 8-249
cm_replace_buffered_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 8-247
continuation_datum                     based           structure                level 1 packed unaligned dcl 4-47
datum                                  based           structure                level 1 packed unaligned dcl 4-44

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_CI_VERSION                001674 constant        entry                    internal dcl 458 ref 196
ERROR_RETURN                    001663 constant        entry                    internal dcl 447 ref 180 198 202 227 236 272 330 378
                                                                                  412
FINISH                          001615 constant        entry                    internal dcl 435 ref 265 322 453
GET_EACH_DATUM_LOOP             001333 constant        label                    dcl 365
JOIN                            000617 constant        label                    dcl 185 ref 173 182
MULTI_DATUM_GET                 001143 constant        label                    dcl 292
REPORT_MULTI_DATUM_INCONSISTENCY
                                001757 constant        entry                    internal dcl 473 ref 372
RETURN                          001613 constant        label                    dcl 432 ref 454
SIMPLE_GET                      001002 constant        label                    dcl 241
VERIFY_MULTI_DATUM_CONSISTENCY  002102 constant        entry                    internal dcl 490 ref 381
cm_get_element_buffered         000443 constant        entry                    external dcl 66
portion                         000560 constant        entry                    external dcl 175
whole                           000525 constant        entry                    external dcl 168

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2516        2556    2267        2526
Length      3166    2267        40         373     226           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cm_get_element_buffered             494 external procedure  is an external procedure.  
on unit on line 265                  64 on unit               
on unit on line 322                  64 on unit               
FINISH                               66 internal procedure  is called by several nonquick procedures.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure cm_get_element_buffered.  
CHECK_CI_VERSION                        internal procedure  shares stack frame of external procedure cm_get_element_buffered.  
REPORT_MULTI_DATUM_INCONSISTENCY
                                        internal procedure  shares stack frame of external procedure cm_get_element_buffered.  
VERIFY_MULTI_DATUM_CONSISTENCY
                                        internal procedure  shares stack frame of external procedure cm_get_element_buffered.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cm_get_element_buffered  000100 automatic_bci_header        cm_get_element_buffered
                         000105 automatic_datum_slot        cm_get_element_buffered
                         000106 automatic_cip_buffer        cm_get_element_buffered
                         000126 continuation_datum_id_string
                                                            cm_get_element_buffered
                         000127 continued_datum_id_string   cm_get_element_buffered
                         000130 buffer_length_in_bytes      cm_get_element_buffered
                         000131 ci_buffer_length_in_bytes   cm_get_element_buffered
                         000132 datum_contents_length_in_bytes
                                                            cm_get_element_buffered
                         000133 datum_contents_offset_in_bytes
                                                            cm_get_element_buffered
                         000134 datum_header_length_in_bytes
                                                            cm_get_element_buffered
                         000135 element_length_in_bytes     cm_get_element_buffered
                         000136 old_buffer_length_in_bytes  cm_get_element_buffered
                         000137 slot_idx                    cm_get_element_buffered
                         000140 new_buffer_allowed          cm_get_element_buffered
                         000141 use_supplied_buffer         cm_get_element_buffered
                         000142 get_whole_element           cm_get_element_buffered
                         000144 work_area_ptr               cm_get_element_buffered
                         000146 buffer_ptr                  cm_get_element_buffered
                         000150 ci_buffer_ptr               cm_get_element_buffered
                         000152 current_buffer_ptr          cm_get_element_buffered
                         000154 cdcn_datum_header           cm_get_element_buffered
                         000164 basic_control_interval_ptr  cm_get_element_buffered
                         000166 bci_header_ptr              cm_get_element_buffered
                         000170 datum_slot_ptr              cm_get_element_buffered
                         000172 element_id_string           cm_get_element_buffered
                         000174 datum_ptr                   cm_get_element_buffered
                         000176 datum_id_ptr                cm_get_element_buffered
                         000200 datum_contents_length_in_bits
                                                            cm_get_element_buffered
                         000202 ci_parts_ptr                cm_get_element_buffered
                         000204 cip_number_of_parts         cm_get_element_buffered

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return
mpfx2               enable              ext_entry           int_entry           trunc_fx2           ceil_fx1
floor_fx1           divide_fx1          divide_fx3          alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cm_get_bci_header$slot        file_manager_$get             sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$ci_not_allocated    dm_error_$ci_not_in_collection                              dm_error_$long_return_element
dm_error_$misformatted_ci     dm_error_$no_element          dm_error_$no_output_buffer    dm_error_$programming_error
dm_error_$unimplemented_ci_version                          error_table_$bad_arg




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     94 000331        97 000412        98 000413       100 000414       102 000415       104 000416       106 000417
    108 000420       110 000421       112 000422       113 000423       116 000424       117 000426       118 000427
    119 000430    4   67 000431    4   68 000432    4   69 000433    7   35 000435    7   36 000437        66 000442
     68 000451       168 000514       172 000544       173 000546       175 000547       179 000577       180 000600
    182 000616       185 000617       188 000620       190 000623       192 000631       194 000633       196 000637
    198 000645       202 000661       212 000703       215 000710       216 000713       217 000722       220 000724
    223 000730       224 000733       227 000735       236 000750       241 000773       251 001002       254 001010
    257 001017       260 001031       264 001040       265 001041       266 001063       267 001105       268 001107
    271 001110       272 001112       281 001121       284 001130       287 001137       288 001140       290 001142
    300 001143       304 001151       306 001164       310 001171       321 001175       322 001176       323 001220
    324 001242       326 001244       329 001245       330 001250       341 001257       346 001274       349 001300
    352 001307       354 001313       355 001315       357 001321       358 001324       360 001325       361 001327
    363 001331       365 001333       368 001340       370 001341       372 001361       378 001414       381 001422
    386 001465       388 001475       390 001476       393 001507       395 001511       396 001520       397 001522
    399 001524       403 001526       404 001530       405 001532       406 001534       410 001536       412 001557
    416 001567       418 001573       420 001575       421 001577       423 001601       426 001602       427 001604
    432 001613       435 001614       438 001622       441 001640       442 001660       445 001662       447 001663
    452 001665       453 001667       454 001673       458 001674       465 001676       469 001756       473 001757
    482 001761       488 002101       490 002102       503 002104       508 002174       513 002264


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
