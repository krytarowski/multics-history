	COMPILATION LISTING OF SEGMENT mrds_dsl_search
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1325.4 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 mrds_dsl_search: proc (dbcb_ptr, area_ptr, code);
       19 
       20 /*
       21*   .                        BEGIN_DESCRIPTION
       22*   This  is the procedure which directs the searching of the database to locate
       23*   the  next  tuple satisfying the selection expression.  Search is implemented
       24*   as  a  finite  state  machine  which  recognizes  six op codes, namely:
       25*
       26*   (1) initialize tuple variable ranges,
       27*
       28*   (2) move comparison values,
       29*
       30*   (3) select next tuple,
       31*
       32*   (4) return information,
       33*
       34*   (5) return null.
       35*
       36*   (6) initialize the search_vars structure
       37*
       38*   The  search_vars  and  search_ops  structures  must be in existence prior to
       39*   calling mrds_dsl_search.
       40*
       41*   .    State 6 is executed first and initiates the  search_vars
       42*   .    structure. Among other things this structure will keep a
       43*   .    pointer to the tid list.
       44*
       45*   .    State 2 (move) is executed next. This state  moves  into
       46*   .    locations  known  to state 3 values that will be used to
       47*   .    locate tuples using key searchs. It will also encode the
       48*   .    values if need be.
       49*
       50*   .    State  1  (init)  is now executed.  It merely  marks the
       51*   .    search as .  starting at the top of the relation.
       52*
       53*   .    State  3  (select)  is now executed,  it selects a tuple
       54*   .    based  on  the search specification  and the rest of the
       55*   .    conditions on    the tuple.  mu_retrieve does the actual
       56*   .    retrieveal.
       57*
       58*   .    State 4 is the normal return  case,  it  sets  the  next
       59*   .    state to be executed back to 3 and returns.
       60*
       61*   .    State  5  is  the  error  case  it  sets  the  code   to
       62*   .    tuple_not_found and returns.
       63*
       64*   Note  that  for  more  complex   SEs   there   may   be   several
       65*   move-init-select  loops but the function of each loop remains the
       66*   same.
       67*   .                           END_DESCRIPTION
       68*
       69**/
       70 
       71 
       72 /* MRDS_DEGUG_TOOL SWITCHES:
       73*
       74*   bit 1 = display each tuple located.
       75*   bits 2 thru 9 = not used.
       76*
       77**/
       78 
       79 /* HISTORY:
       80*
       81*   76-01-01 O.  D.  Friesen: Pre-MR7.0 version written.
       82*
       83*   78-09-01 J.  A.  Weeldreyer: Completely rewritten for MR7.0.
       84*
       85*   79-05-17 Al Kepner: Modified to add entries db_on and db_off.
       86*
       87*   79-06-18   Al   Kepner:   Modified   to   interpret  error_table_$no_key  as
       88*   tuple_not_found.
       89*
       90*   79-07-03 Al Kepner: Modified to use mu_convert$convert_data and to eliminate
       91*   code  for  setting the bit length of a varying character string.  The length
       92*   of  a  varying  character string will now be stored in the db as a character
       93*   count.
       94*
       95*   79-07-31 Al Kepner: Modified to make -current work correctly.
       96*
       97*   79-08-30 Davids: Modified to handle the where clause ((r.i > 4) & (r.i < 6))
       98*   where i is a secondary index.
       99*
      100*   79-09-06  Davids:  Modified  to  accommodate  a  new  calling  sequence  for
      101*   mu_encd_key  .  Also
      102*   inclusion   of   mdbm_ind_sel_info.incl.pl1.    Note:   move_data.t_ptr  and
      103*   init_info.val_ptr  both  point  to  a ind_sel_info structure - hopefully the
      104*   same one.
      105*
      106*   79-10-01 Jim Gray: Modified to correct clean up handler.
      107*
      108*   79-11-14   Rickie   E.    Brinegar:  Modified  to  use  mrds_debug_tool  and
      109*   db_mrds_dsl_search   instead   of   entry   points   db_on  and  db_off  and
      110*   debug_switch.
      111*
      112*   79-11-14 Rickie E.  Brinegar: Modified to allocate tid_array and tid_list in
      113*   select_area, an area which is never freed.
      114*
      115*   79-12-21  Jim  Paradise:  Modified  to  dimension  data_array  starting at 0
      116*   instead of 1 (got a subscriptrange error).
      117*
      118*   80-02-04  Rickie  E.   Brinegar: Modified to keep the intersection code from
      119*   leaving the tl_ptr pointing to a useless tid_list.
      120*
      121*   80-02-05  Jim  Gray:  Modified  to add area_ptr parameter, for passing on to
      122*   mu_retrieve, and mrds_dsl_eval_expr.
      123*
      124*   80-02-15  Davids: corrected indexing into data_array so that element zero is
      125*   never  referenced.  redeclared data_array to start will element 1.  Modified
      126*   mu_retrieve  interface  so  that it accepts an output variable which
      127*   points  to  tuple.data of the current tuple.  corrected handling of code for
      128*   extracting values of varying attributes for key head types.
      129*
      130*   80-08-01  E Brunelle: Modified to use temp segments as opposed to allocating
      131*   storage in search_area.
      132*
      133*   80-10-20  Jim  Gray: Modified to put calls to temp seg manager in mdbm_util_
      134*   format   for   naming   conventions,   and   add   db_index   parameter   to
      135*   get_temp_segment entries.  This allows the opening resultant dir to be used.
      136*
      137*   80-10-22  Jim Gray: Modified to fix bug from brunelle's change, he felt that
      138*   union  and  differ  operators  in  the  init_range  operation would not work
      139*   properly  unless  all of the init operation were allowed to complete, rather
      140*   than  doing  an err_xfer immediately.  The operand_error routine was written
      141*   for  this,  but has now be commented out.  The error introduced was that the
      142*   error_table_$no_key  condition  was  no  longer  captured  in the code for a
      143*   unique  index  operand  in  init_range.   It  was discovered that unions and
      144*   differs  can not be generated by mrds_dsl_srch_prog, so that Brunelles worry
      145*   was  unfounded,  at least for now.  Several initializations for ta_nids that
      146*   were removed were added back, and the same for some tid_list.ta_ptr nulling.
      147*
      148*   80-10-23 Davids: Modified d_ptr to be an array (data_ptrs) with an extent of
      149*   mrds_data_$max_tup_var.   This  allows multiple retrieve operations in a row
      150*   without  lossing  the first d_ptr values.  It is assumed (I cannot prove it,
      151*   but  it  looks this way) that the multiple retrieve operations will all deal
      152*   with  different tuple variables.  The d_ptr is used only when moving varying
      153*   length attributes.  This fixes TR7675.
      154*
      155*   80-10-24  Jim  Gray:  Modified  to allow tid_lists to freed when they are no
      156*   longer  needed,  (otherwise  the growth of space usage is exponential in the
      157*   number  of  move-init-select  triples being executed on the number of tuples
      158*   involved  at each level.) This reduces the actual storage need to the number
      159*   of  move-init-select  triples  needed  to implement the selction expression.
      160*   The  area  for  freeing  them is managed as an internal static area, that is
      161*   emptied  whenever  a new selection expression is started.  This required the
      162*   new dbcb.new_select_expr bit in the mrds_dbcb.incl include file.
      163*
      164*   80-10-25  Jim Gray: Modified to correct logic in init_range/unique_index, so
      165*   that  when no_key is found, the ntids is set to 0, and the init_info loop is
      166*   exited   normally,  rather  than  taking  an  immediate  err_xfer,  so  that
      167*   search_vars  is  properly  set up to free the tid_array temp segment, and so
      168*   that  the  tid_list  is  freed.   Previously, one un-freed temp segment (and
      169*   tid_list)  was  left  around every time the no_key condition happened, which
      170*   would eventually blow out the static_area.
      171*
      172*   81-03-11 Rickie E.  Brinegar: Modified the index range code to behave in the
      173*   same  manner  as  the  unique index code works in regards to getting back an
      174*   error  code  which  is  not  zero from the indexing routine.  The error code
      175*   error_table_$no_record  is  now  treated as a good transfer instead of as an
      176*   error  transfer  for  the  case of the index range.  This permits the proper
      177*   freeing of tid_list structures.
      178*
      179*   81-03-27  Jim  Gray  :  changed  dbi  parameter  in   mu_pos_rel,
      180*   mu_get_tid$get_tid_key,    get_tid_hash,    get_index_tids,   and
      181*   retrieve to dbcb_ptr  as  part  of  getting  rid  of  mus_ptr_man
      182*   module.
      183*
      184*   81-04-25 Jim Gray : changed length declarations of  dbi_pic,  and
      185*   mrds_data_$temp_seg_name, to allow three digit db_index values as
      186*   part of increasing from 64 to 128 possible database openings.
      187*
      188*   81-05-01 Jim Gray : commented out call to mu_hash_key, so  module
      189*   mu_hash_key  could  be  removed,  since  blocked  files  are  not
      190*   implemented.
      191*
      192*   81-05-01 Jim Gray : extended tid_list  structure  to  contain  an
      193*   extended  file_id,  and  added comparison of file_id's to current
      194*   tid  comparison  in  the  init  section  for   the   intersection
      195*   operation.  This  was  not  done  for  union  and  difference, as
      196*   gen_srch_prog can not currently generate these operators.
      197*
      198*
      199*   81-05-22 Jim Gray : added error message to give  details  when  a
      200*   conversion  type move_info failed in it's call to mu_convert. The
      201*   data types, and the source data value are displayed.  Also  added
      202*   conversion  of move_info.s_ptr from the tuple.var_offset array to
      203*   the current offset, for varying attrs, prior to this conversion.
      204*
      205*   81-06-01 Jim Gray :  changed  to  use  new  resultant  structure.
      206*   Blocked  file  code  removed,  and code never referenced removed.
      207*   This included for the init operation, the  difference  and  union
      208*   operations  (gen_srch_prog  never  genrates any but intersection)
      209*   and the hash, link chain type of operand location mechanisms. The
      210*   move_info foreign key, and encode_attr options were removed also.
      211*
      212*   81-06-12 Jim Gray : removed extra assignment of  tid_list.fwd_thd
      213*   pointer  for  the  case  of  init_info  operator with null second
      214*   operand. This assignment is taken care of  by  the  free_tid_list
      215*   routine,  and this extra code was accidentally left in during the
      216*   addition of this routine.
      217*
      218*   81-06-17  Jim  Gray   :   added   iocb   ptr   index   param   to
      219*   mu_get_tid$get_tid_key so that retrieves would not be required to
      220*   use the dedicated update iocb.
      221*
      222*   81-06-30 Jim Gray : added a second key  value  parameter  to  the
      223*   call  to  get  tuple  id's on a key head or index, so that ranges
      224*   like 10 < x < 20 could be handled in one call  to  vfile  select,
      225*   instead of two.
      226*
      227*   81-07-01 Jim Gray : changed call to mu_pos_rel into a direct call
      228*   to  iox_$position to avoid un-needed overhead. mu_pos_rel used to
      229*   call iox_$control "seek_head", but that is  un-necessary  without
      230*   blocked files, and position is needed for mu_scan_records to work
      231*   properly. Also added call to  mu_scan_records$init  for  retrieve
      232*   only openings, so that the EOF indicator would be reset.
      233*
      234*   81-07-18  Jim  Gray  :  changed  to  handled  new  encodings   of
      235*   init_info.op_type for the new access methods.
      236*
      237*   81-07-22 Jim Gray  :  added  logic  to  allow  vfile  to  do  the
      238*   intersection  of  tid lists whenever possible, rather than having
      239*   mrds do it, as vfile can do it faster  on  a  previously  defined
      240*   subset, using less space than the mrds method.
      241*
      242*   82-06-07 Davids: expanded the description at the begining of the
      243*   source.
      244*
      245*   82-09-02 Mike Kubicar : made the changes necessary to use the simple
      246*   vector structure instead of the tuple structure.
      247*
      248*   82-0-21 Davids: changed references to search_vars.info.iocb_ind (vi) to
      249*   search_vars.info.cursor_ptr (vi) (this changes the calling parameters of
      250*   mu_get_tid$get_tid_key and $key_index_tids. Also removed the call to
      251*   iox_$control (select control order) which was used to overcome a bug
      252*   with record status and the calls to iox_$position and mu_scan_records$init
      253*   which were used to initialize the position when the entire relation is to
      254*   be retrieved.
      255*
      256*   82-10-01 Davids: removed references to move_info.encd_index and
      257*   mu_encd_key$encd_key since this is no longer done by mrds (its
      258*   done by the relation manager).
      259*
      260*   82-10-05 Davids: changed calling sequences of mu_get_tid entries
      261*
      262*   82-10-13 Davids: Changes to get the module to compile. Removed the
      263*   the references to rm_rel_info.file_id and tid_list.file_id which
      264*   was assigned from rm_rel;_info.file_id. tid_list.file_id was
      265*   used in the intersection merge loop.
      266*
      267*   82-10-22 D. Woodka : Changed to set search_vars.info.first_seq_io
      268*   if the range is unrestricted.
      269*
      270*   82-10-22 Davids: Updated the parameter list of mu_retrieve, removed
      271*   data_ptrs parameter. 
      272*
      273*   82-10-28 Davids:Modified the call to mu_get_tid$get_tid_key to use
      274*   the select_area instead of the area input as a parameter (area_ptr).
      275*   The call to mu_get_tid$get_index_tids does not need to be modified since
      276*   it uses an area set up spefically to hold tids.
      277*
      278*   82-10-29 Davids: Modified so that move_info.s_ptr is now used for the
      279*   pointer to the source data instead of using s_ptr to point to an offset
      280*   in the tuple for the data when the source is a varying string.
      281*
      282*   82-11-10 Davids: all calls to mu_temp_segments$free_temp_segment were
      283*   modified to pass pointer (ta_ptr, 0) instead of just a ta_ptr. It used
      284*   to be that the tid_array (based off of ta_ptr) was just overlayed on the
      285*   temp segment with conversion to the relation manager the temp segment
      286*   has become an area and the tid_array allocated in that area. The ta_ptr
      287*   therefore no longer points to the base of the segment. The call to the
      288*   pointer function corrects that. This modification has also been made
      289*   to the assignment of the ta_ptr from tid_list.ta_ptr when a previous subset
      290*   is to be used.
      291*
      292*   82-12-21 Davids: Modified the internal proc combine_opnds to also copy the
      293*   value of the non_standard_vfile_descriptor element of the tid_list to keep
      294*   from using the last subset incorrectly. TR14389
      295*
      296*   83-01-14 Davids: Modified the internal proc free_tid_list to correctly
      297*   handle the case of removing the second element from the tid list. It was
      298*   incorrectly changing the value of stack_ptr (pointer to the first element
      299*   on the list) if the value of stack_ptr and last_tl_ptr (pointer to the
      300*   parent of the element to be deleted) where equal, i.e. the element to be
      301*   deleted was the second element on the list. It now changes the value of 
      302*   stack_ptr only if stack_ptr and tl_ptr (pointer to the element to be
      303*   deleted) are equal, i.e. the element to be deleted is the first first
      304*   element on the list.
      305*
      306*   83-04-04 Davids: Explicitly declared the builtins fixed, pointer, rel.
      307*   Removed declarations to BIT_VAR, data_array, offset.
      308*
      309*   83-04-22 Mike Kubicar : Removed most of the code for the init operation
      310*   since all this is now handled by relation manager.  A select with the
      311*   proper search specification does the same thing.  Also, the init_info
      312*   structure no longer exists.  Finally, the calling sequence for mu_retrieve
      313*   has changed.
      314*
      315*   83-05-18 Ron Harvey : Changed calling sequence of mu_retrieve in order to
      316*   accommodate a 'shortened' simple_typed_vector.
      317*
      318*   83-05-21 Mike Kubicar : Updated to use new search specification
      319*
      320*   84-10-21 John Hergert: added initialization of search_vars.info.ntids. Also
      321*   removed duplicate initialization of search_vars.info.first_seq_io.
      322*
      323**/
      324 
      325 	dbi_pic = dbcb.dbi;				/* convert dbi to 3 chars */
      326 	temp_seg_name = mrds_data_$temp_seg_name || dbi_pic; /* make unique name for temp segs for this dbi */
      327 	stack_ptr = null;				/* initiallize */
      328 	display_tuples = "0"b;
      329 
      330 /*	display_tuples = substr (db_mrds_dsl_search, 1, 1);   Removered for performance */
      331 
      332 	icode = 0;
      333 	on cleanup call tidy_up;
      334 	sv_ptr = dbcb.sv_ptr;
      335 	so_ptr = dbcb.so_ptr;
      336 	ti_ptr = dbcb.ti_ptr;
      337 	select_area_ptr = dbcb.select_area_ptr;
      338 	range_ptr = dbcb.range_ptr;			/* to obtain tuple variable name for debugging. */
      339 
      340 next:	;					/* main loop */
      341 	go to operation (search_ops.op.code (search_ops.ic));
      342 
      343 operation (1): ;					/* initialize variable range */
      344 
      345 	vi = search_ops.op.var_ind (search_ops.ic);	/* var index */
      346 	rmri_ptr = search_vars.info.ri_ptr (vi);	/* point to rel_info */
      347 	search_vars.info.ntids (vi) = 0;
      348 	search_vars.info.first_seq_io (vi) = "1"b;	/* indicate that the first sequential i/o is to be done */
      349 	search_ops.ic = search_ops.ic + search_ops.op.good_xfer (search_ops.ic);
      350 	go to next;
      351 
      352 operation (2): ;					/* move values required for init. or select */
      353 
      354 	mi_ptr = search_ops.op.info_ptr (search_ops.ic);	/* pick up move info */
      355 	vi = search_ops.op.var_ind (search_ops.ic);
      356 	rmri_ptr = search_vars.info.ri_ptr (vi);
      357 
      358 	do while (mi_ptr ^= null);			/* move each item in list, in turn */
      359 
      360 	     if move_info.extr_attr
      361 	     then move_info.s_ptr = tuple_info.tuple
      362 		     (move_info.tuple_var_index).tuple_ptr
      363 		     -> simple_typed_vector
      364 		     .dimension (move_info.tuple_attr_index).value_ptr;
      365 	     if move_info.var_ind > 0 then /* if db. */
      366 		if search_vars.new_val (move_info.var_ind, vi) then /* if new value */
      367 		     must_move = "1"b;
      368 		else must_move = "0"b;		/* if have moved this before */
      369 	     else must_move = "1"b;
      370 	     if must_move then do;
      371 
      372 		     if move_info.bit_move then /* if straight bit move */
      373 			targ_string = src_string;
      374 		     else if move_info.var_move then do;/* is variable len field */
      375 			     true_len = move_info.s_ptr -> fb35u;
      376 			     if addr (move_info.s_desc) -> descriptor.type = CHAR_VAR
      377 			     then true_len = true_len * 9 + 36;
      378 			     else true_len = true_len + 36;
      379 			     ts_ptr = move_info.t_ptr;
      380 			     true_string = move_info.s_ptr -> true_string;
      381 			end;
      382 		     else if move_info.expr then do;	/* if expression */
      383 			     call mrds_dsl_eval_expr (area_ptr, move_info.s_ptr,
      384 				search_vars.info.ri_ptr (move_info.var_ind),
      385 				tuple_info.tuple (move_info
      386 				.tuple_var_index).tuple_ptr, icode);
      387 			     if icode ^= 0 then call error (icode);
      388 			end;
      389 		     else do;			/* is straight assign_ conversion */
      390 			     temp_s_ptr = move_info.s_ptr;
      391 			     call mu_convert$convert_data (temp_s_ptr, addr (move_info.s_desc),
      392 				move_info.t_ptr, addr (move_info.t_desc), icode);
      393 			     if icode ^= 0 then do;
      394 				     call sub_err_ (icode, caller_name, continue, info_ptr, return_value,
      395 					"^/^a^a^a^a^a",
      396 					"Unable to convert a """, mu_display_descriptor (addr (move_info.s_desc)),
      397 					""" into a """, mu_display_descriptor (addr (move_info.t_desc)),
      398 					""" data type, during the search operation.");
      399 
      400 				     call mdb_display_data_value$ptr (temp_s_ptr, addr (move_info.s_desc));
      401 
      402 				     call error (icode);
      403 
      404 				end;
      405 
      406 			end;
      407 		end;				/* if must move */
      408 
      409 	     mi_ptr = move_info.fwd_thd;
      410 
      411 	end;					/* move loop */
      412 
      413 	do i = 1 to search_vars.nvars;		/* remember all vals moved for this var. */
      414 	     search_vars.new_val (i, search_ops.op.var_ind (search_ops.ic)) = "0"b;
      415 	end;
      416 
      417 	search_ops.ic = search_ops.ic + search_ops.op.good_xfer (search_ops.ic);
      418 	go to next;
      419 
      420 operation (3): ;					/* select next tuple */
      421 
      422 	seli_ptr = search_ops.op.info_ptr (search_ops.ic);/* pick up select info */
      423 
      424 	if dbcb.current_flag then icode = 0;		/* -current so no need to retrieve */
      425 	else call mu_retrieve (dbcb_ptr, area_ptr,
      426 		addr (search_vars.info (search_ops.op.var_ind (search_ops.ic))),
      427 		select_info.relation_search_specification_ptr,
      428 		select_info.cvla_ptr, select_info.tid_ptr,
      429 		(range.tup_var.name (search_ops.op.var_ind (search_ops.ic))),
      430 		tuple_info.tuple (select_info.tuple_info_index).tuple_ptr,
      431 		range.tup_var.stv_ptr (select_info.tuple_info_index),
      432 		range.tup_var.idl_ptr (select_info.tuple_info_index),
      433 		icode);				/* retrieve the tuple */
      434 	if icode ^= 0 then
      435 	     if icode ^= mrds_error_$no_tuple
      436 		& icode ^= error_table_$no_record then call error (icode);
      437 	     else search_ops.ic = search_ops.ic + search_ops.op.err_xfer (search_ops.ic);
      438 	else do;
      439 		do i = 1 to search_vars.nvars;	/* tell that we have new set ov vals to move */
      440 		     search_vars.new_val (search_ops.op.var_ind (search_ops.ic), i) = "1"b;
      441 		end;
      442 		if display_tuples then do;
      443 			temp_rti_ptr = addr (search_vars.info (search_ops.op.var_ind (search_ops.ic)));
      444 			temp_rmri_ptr = temp_rti_ptr -> rtrv_info.ri_ptr;
      445 			call mdb_display_tuple_$data (
      446 			     tuple_info.tuple (select_info
      447 			     .tuple_info_index).tuple_ptr,
      448 			     temp_rmri_ptr, iox_$user_output, icode);
      449 			call ioa_ ("Tuple Accepted for ""^a""",
      450 			     rtrim (range.tup_var.name (search_ops.op.var_ind (search_ops.ic))));
      451 			if icode ^= 0 then call error (icode);
      452 			call ioa_ ("TID = ^w", select_info.tid_ptr -> b36);
      453 		     end;
      454 		search_ops.ic = search_ops.ic + search_ops.op.good_xfer (search_ops.ic);
      455 	     end;
      456 	go to next;
      457 
      458 operation (4): ;					/* return data */
      459 
      460 	search_ops.ic = search_ops.ic + search_ops.op.good_xfer (search_ops.ic);
      461 	code = 0;
      462 exit:	;
      463 	return;
      464 
      465 operation (5): ;					/* return null */
      466 	code = mrds_error_$tuple_not_found;
      467 	go to exit;
      468 
      469 operation (6): ;					/* pickup svp */
      470 
      471 	dbcb.sv_ptr,
      472 	     sv_ptr = search_ops.op.info_ptr (search_ops.ic);
      473 	do i = 1 to search_vars.nvars;		/* init move flags */
      474 	     do j = 1 to search_vars.nvars;
      475 		search_vars.new_val (i, j) = "1"b;
      476 	     end;
      477 	end;
      478 	search_ops.ic = search_ops.ic + search_ops.op.good_xfer (search_ops.ic);
      479 	go to next;
      480 
      481 error: proc (cd);
      482 
      483 /* Error Procedure */
      484 
      485 	dcl     cd		 fixed bin (35);
      486 
      487 	if cd = mrds_error_$no_tuple
      488 	     | cd = error_table_$no_record
      489 	     | cd = mrds_error_$tuple_not_found then do;	/* if normal termination */
      490 		search_ops.ic = search_ops.ic + search_ops.op.err_xfer (search_ops.ic);
      491 		go to next;
      492 	     end;
      493 	else do;					/* if true error */
      494 		code = cd;
      495 		call tidy_up;
      496 		go to exit;
      497 	     end;
      498 
      499      end error;
      500 
      501 tidy_up: proc;
      502 
      503 /* Cleanup Procedure */
      504 
      505 	dcl     temp_tl		 ptr init (null);
      506 
      507 	tl_ptr = stack_ptr;
      508 	do while (tl_ptr ^= null);
      509 	     temp_tl = tid_list.fwd_thd;
      510 	     if tid_list.free_array then do;
      511 		     ta_nids = tid_list.nids;
      512 		     ta_ptr = tid_list.ta_ptr;
      513 		     call mu_temp_segments$free_temp_segment (temp_seg_name, pointer (ta_ptr, 0), icode);
      514 		     tid_list.free_array = "0"b;
      515 		end;
      516 	     free tl_ptr -> tid_list in (internal_static_area);
      517 	     tl_ptr = temp_tl;
      518 	end;
      519 
      520 	stack_ptr = null ();
      521 
      522      end tidy_up;
      523 
      524 	dcl     (code,				/* Output: status code */
      525 	        icode,				/* internal status code */
      526 	        true_len)		 fixed bin (35);	/* true length of variable len attr. */
      527 
      528 	dcl     CHAR_VAR		 fixed bin (5) int static options (constant) init (22);
      529 
      530 	dcl     (i,				/* internal index */
      531 	        j,
      532 	        vi)		 fixed bin;	/* var. index */
      533 
      534 	dcl     (d_ptr		 init (null),	/* to tuple.data */
      535 	        es_ptr		 init (null),
      536 	        opnd1p		 init (null),	/* pointers to tid_lists in stack */
      537 	        opnd2p		 init (null),
      538 	        stack_ptr		 init (null),	/* to head of stack of tid_lists */
      539 	        tl_ptr		 init (null),	/* to tid list */
      540 	        ts_ptr		 init (null)) ptr;	/* to variable string */
      541 
      542 	dcl     (display_tuples,
      543 	        must_move)		 bit (1);
      544 
      545 	dcl     b36		 bit (36) based;
      546 	dcl     fb35u		 fixed bin (35) unal based;
      547 	dcl     src_string		 bit (move_info.sbit_len) based (move_info.s_ptr);
      548 	dcl     targ_string		 bit (move_info.tbit_len) based (move_info.t_ptr);
      549 	dcl     true_string		 bit (true_len) based (ts_ptr);
      550 
      551 	dcl     data_ptrs		 (mrds_data_$max_tup_var) ptr init (null ());
      552 	dcl     mrds_data_$max_tup_var fixed bin (35) external static;
      553 
      554 	dcl     1 tid_list		 aligned based (tl_ptr), /* structure for stacking up tuple ids */
      555 		2 fwd_thd		 ptr,
      556 		2 free_array	 bit (1) unal,	/* if array needs to be freed */
      557 		2 non_standard_vfile_descriptor bit (1),/* on => secondary index type desc */
      558 		2 reserved	 bit (34) unal,
      559 		2 tup_var_index	 fixed bin,	/* tup var iocb identifier */
      560 		2 nids		 fixed bin (35),	/* no. ids in array */
      561 		2 ta_ptr		 ptr;		/* pointer to array of tuple ids */
      562 
      563 	dcl     dbi_pic		 pic "999";
      564 	dcl     temp_seg_name	 char (26);
      565 
      566 	dcl     (error_table_$no_record,
      567 	        mrds_error_$no_tuple,
      568 	        mrds_data_$max_id_len,
      569 	        mrds_error_$tuple_not_found,
      570 	        sys_info$max_seg_size) ext fixed bin (35);
      571 
      572 	dcl     (addr,
      573 	        fixed,
      574 	        null,
      575 	        pointer,
      576 	        rel,
      577 	        rtrim
      578 	        /*	        substr     */
      579 	        )			 builtin;
      580 
      581 	dcl     cleanup		 condition;
      582 
      583 	dcl     ioa_		 entry options (variable);
      584 	dcl     iox_$user_output	 ptr ext;
      585 	dcl     mdb_display_tuple_$data entry (ptr, ptr, ptr, fixed bin (35));
      586 	dcl     mrds_dsl_eval_expr	 entry (ptr, ptr, ptr, ptr, fixed bin (35));
      587 	dcl     mu_convert$convert_data entry (ptr, ptr, ptr, ptr, fixed bin (35));
      588 	dcl     mu_retrieve		 entry (ptr, ptr, ptr, ptr, ptr, ptr, char (*), ptr, ptr, ptr, fixed bin (35));
      589 	dcl     mu_temp_segments$free_temp_segment entry (char (*), ptr, fixed bin (35));
      590 
      591 	dcl     (temp_rti_ptr,
      592 	        temp_rmri_ptr)	 ptr;		/* temp ptrs for mdb_display_tuple_ */
      593 
      594 	dcl     area_ptr		 ptr;
      595 
      596 	dcl     mrds_data_$max_attributes fixed bin (35) ext static;
      597 	dcl     mrds_data_$temp_seg_name char (23) ext;	/* common name for temp segments */
      598 
      599 	dcl     internal_static_area	 area (1024) int static; /* space for tid list managment */
      600 	declare sub_err_		 entry options (variable); /* reports error details */
      601 	declare continue		 char (1) init ("c") int static options (constant); /* dont stop after printing error */
      602 	declare info_ptr		 ptr init (null ());/* dummy arg */
      603 	declare caller_name		 char (32) init ("mrds_dsl_search") int static options (constant); /* name of calling routine */
      604 	declare return_value	 fixed bin (35) init (0); /* dummy arg */
      605 	declare mu_display_descriptor	 entry (ptr) returns (char (120) varying); /* gets char form of descriptor */
      606 	declare mdb_display_data_value$ptr entry (ptr, ptr); /* outputs char form of data value */
      607 	declare temp_s_ptr		 ptr;		/* temp, so that mvoe_info.s_ptr doesn't get changed */
      608 	declare 1 reset_info	 aligned,		/* does reset of subset number */
      609 		2 words		 (4) fixed bin (35) init (0, 0, 0, 0),
      610 		2 dap		 ptr init (null ());
      611 
  1     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  1     9*     Nguyen. The scopes_changed flag was added to make checking for this
  1    10*     more efficient (mrds error list #137).
  1    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  1    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  1    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  1    14*     care if multiple txns use the same selection_expression. (mrds #156)
  1    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  1    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  1    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  1    18*                                                   END HISTORY COMMENTS */
  1    19 
  1    20 
  1    21 /* WARNING
  1    22*          If the dbcb structure is changed then the mrds_data_
  1    23*          item saved_res_version MUST be incremented to invalidate all
  1    24*          existing saved resultants
  1    25**/
  1    26 
  1    27 /* HISTORY :
  1    28*
  1    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  1    30*   tid_list management
  1    31*
  1    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  1    33*   phony resultant in mu_database_index, without having the area dcl
  1    34*   included.
  1    35*
  1    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  1    37*   mrds_dsl_store
  1    38*
  1    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  1    40*   switches
  1    41*
  1    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  1    43*   expression,  so  that relation statistics can be updated relative
  1    44*   to number of selection expressions seem. Also  removed  init  for
  1    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  1    46*   mrds_dsl_init_res.
  1    47*
  1    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  1    49*
  1    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  1    51*   for the conversion to the relation manager.
  1    52*
  1    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  1    54*   substructures so that the entries and costs can change
  1    55*   depending on the type of database that is opened.
  1    56*
  1    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  1    58*   since modify uses a different vector type (general) than does store.
  1    59*
  1    60*   82-09-20 Davids: changed names of (store modify)_vector to
  1    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  1    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  1    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  1    64*   during the first call.
  1    65*
  1    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  1    67*   since it deals with the pointers to the cursors and not the cursors
  1    68*   themelves and added the element cursor_storage_area_ptr which points
  1    69*   to the area where the cursors are kept.
  1    70*
  1    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  1    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  1    73*   anything.
  1    74*
  1    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  1    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  1    77*   by mrds_dsl_define_temp_rel.
  1    78*
  1    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  1    80*   is needed by mu_store.
  1    81*
  1    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  1    83*   bin to float bin since the values are not integers.
  1    84*
  1    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  1    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  1    87*   added to the end of the structure to allow modules that don't use
  1    88*   the element to continue to reference the dbcb structure without recompiling.
  1    89*
  1    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  1    91*   are needed so that temp rels can be created with the same file attributes
  1    92*   as the permanent relations.
  1    93*
  1    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  1    95*   added the resultant_in_pdir bit.
  1    96*
  1    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  1    98*   added the res_already_made element.
  1    99*
  1   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  1   101*
  1   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  1   103*   one of the unused pointers.
  1   104*
  1   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  1   106*
  1   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  1   108*   leaving unused_ptrs(1).
  1   109*
  1   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  1   111*   unused_ptrs (1).
  1   112*
  1   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  1   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  1   115*   spare ptrs, entries and reserved storages for future enhancement, since
  1   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  1   117*
  1   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  1   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  1   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  1   121**/
  1   122 
  1   123 
  1   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  1   125*   that constitutes the non-secure portion of the resultant model that is
  1   126*   created during the opening of a database. it contains variables that
  1   127*   are used during the runtime access of the database, and an area
  1   128*   for evaluation of requests. it points to four other
  1   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  1   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  1   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  1   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  1   133*   used in the elimination of duplicate tuples during a retrieve.
  1   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  1   135*   that is used when the database is using the file scope mechanism
  1   136*   for concurrency control over file readying. the segment overlayed via
  1   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  1   138*   across database openings. the pointer to this dbcb structure is kept in a table
  1   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  1   140*   opening instances of resultant models. (see mu_database_index routine) */
  1   141 
  1   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  1   143 	     2 data	      like dbcb_data,
  1   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  1   145 
  1   146      dcl	   dbcb_ptr	      ptr;
  1   147 
  1   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  1   149*						   like references can avoid getting the area declaration */
  1   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  1   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  1   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  1   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  1   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  1   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  1   156 	     2 lit_ptr	      ptÿÿÿÖ  šKokol                 Office              Ráu£n   0=     0>     <0/ìÿÿÿÖ  ›Kokol                 Office              RáuR^h   0M     0O     0(0 ÿÿÿÖ  œWillott               Office              Rá‚£ö   0W     
0Z     90<0ÿÿÿÖ  Willott               Office              RáƒM©Í   0i     0m     X0P0(ÿÿÿÖ  žHoover                Multics             RâZm"   0ƒ     0ˆ     '0d0<ÿÿÿÖ  ŸHoover                Multics             Rã:4“i   0’     0–     0x0PÿÿÿÖ   Willott               Office              RãÙ>¥   0ž     	0¡     "0Œ0dÿÿÿÖ  ¡Miko                  Multics             Rãœ™(H   0ª     #0³     0 0xÿÿÿÖ  ¢Kokol                 Office              RãÅ”Jï   0¹     0»     (0´0ŒÿÿÿÖ  £Hoover                Multics             Rä¼w,   0Å     0É     0È0 ÿÿÿÖ  ¤Gee                   Multics             RåLÀhp   0Ñ     
0Ô      0Ü0´ÿÿÿÖ  ¥Mabey                 Multics        0@   RåÃWùv   0Ü     0ä     .0ð0ÈÿÿÿÖ  ¦Hoover                Multics             RæGx£   0ð     0ô     00ÜÿÿÿÖ  §Falck                 Office              Ræ\(¸X   0ü     0     †00ðÿÿÿÖ  ¨Palmer                Multics             Ræ•gÈ   0#     0*     ‘0,0ÿÿÿÖ  ©Hinatsu               Multics             Ræ§è`ù   0O     0T     0@0ÿÿÿÖ  ªMiko                  Multics      0Ü10   Ré·Ïm   0[     #0d     10T0,ÿÿÿÖ  «Kokol                 Office              RéåXXù   0q     0s     0h0@ÿÿÿÖ  ¬Kokol                 Office              RéåÆk   0z     0{     >0|0TÿÿÿÖ  ­Hoover                Multics             Réèæ   0‹     0     %00hÿÿÿÖ  ®Swanson               Multics             Rê Ã©   0š     0     &0¤0|ÿÿÿÖ  ¯Willott               Office              Rêtr¸ô   0§     0¬     0¸0ÿÿÿÖ  °Hoover                Multics             RëN!ò¿   0´     0¹     %0Ì0¤ÿÿÿÖ  ±Kokol                 Office              RëyÒ¾   0Ã     0Å     0à0¸ÿÿÿÖ  ²Kokol                 Office              Rë‘ëÐõ   0Ì     0Î     0ô0ÌÿÿÿÖ  ³Hoover                Multics             RìßÇ„R   0Ö     0Ú     10àÿÿÿÖ  ´Kokol                 Office              Rìü×[è   0â     0ä     10ôÿÿÿÖ  µHoover                Multics             Ríi¹èl   0ì     0ñ     101ÿÿÿÖ  ¶Miko                  Multics      0@     Ríq³JÁ   0ù     #1     q1D1ÿÿÿÖ  ·Kokol                 Office              Rív®{-   1     
1"     #1X10ÿÿÿÖ  ¸Kokol                 Office              Rí–…èâ   1+     1-     1l1DÿÿÿÖ  ¹Huen                  Multics             Rî)fË"   15     17     21€1XÿÿÿÖ  ºDurand                Multics             Rî[n}a   1D     *1O     +1”1lÿÿÿÖ  »Hoover                Multics             RîÝˆh‘   1Z     1_     1¨1€ÿÿÿÖ  ¼Hinatsu               Multics             Rï–¯…   1g     1m     21¼1”ÿÿÿÖ  ½Willott               Office              Rï‰g   1z     1     „1Ð1¨ÿÿÿÖ  ¾Kokol                 Office              RïKš´   1      1¢     1ä1¼ÿÿÿÖ  ¿Miko                  Multics             Rï8¹ôg   1©      1±     1ø1ÐÿÿÿÖ  ÀSmith                 CDC                 Rï=íâ   1µ     1¼     11äÿÿÿÖ  ÁSchroth               SysMaint            Rðöè–Ã   1Á     1È     f1 1øÿÿÿÖ  ÂHoover                Multics             Rò|ê·k   1â     1ç     141ÿÿÿÖ  ÃKokol                 Office              Rò‡ë]¢   1ï     1ñ     ;1H1 ÿÿÿÖ  ÄKokol                 Office              Ròˆt·ú   1      1     ;1\14ÿÿÿÖ  ÅKokol                 Office              RòŠ!²Ì   1     1     1p1HÿÿÿÖ  ÆKokol                 Office              RòüÒb   1     1     $1„1\ÿÿÿÖ  ÇHoover                Multics             RóêÏ   1%     1*     1˜1pÿÿÿÖ  ÈKokol                 Office              Rô”­   12     14     ‡1¬1„ÿÿÿÖ  ÉRosin                 Operator            Rô+ì Ø   1V     1[     1À1˜ÿÿÿÖ  ÊVu                    Multics             Rõ¨-¶   1a     	1d     )1Ô1¬ÿÿÿÖ  ËMQuintin              CDC                 RõÝ@\·   1o     	1r     1è1ÀÿÿÿÖ  ÌElliott               Multics             Rõkûû   1z     1‚     "1ü1ÔÿÿÿÖ  ÍHindbo  earch_order bit (1) unal,		/*  On => print the search order */
  1   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  1   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  1   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  1   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  1   207*						   inside a sequence of -another selection expression. */
  1   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  1   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  1   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  1   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  1   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  1   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  1   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  1   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  1   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  1   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  1   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  1   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  1   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  1   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  1   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  1   223 	     2 relmgr_entries,			/* relation manager entries */
  1   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  1   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  1   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  1   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  1   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  1   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  1   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  1   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  1   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  1   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  1   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  1   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  1   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  1   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  1   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  1   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  1   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  1   241 	       3 reserved_entries (5) entry (),
  1   242 	     2 access_costs,			/* access costs for permute */
  1   243 	       3 total_primary_key_cost float bin,
  1   244 	       3 access_cost      float bin,
  1   245 	       3 access_overhead  float bin,
  1   246 	       3 us_access_cost   float bin,
  1   247 	       3 os_access_cost   float bin,
  1   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  1   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  1   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  1   251 
  1   252 /* END mrds_dbcb.incl.pl1 */
  1   253 
  1   254 
      612 
      613 
  2     1 /* BEGIN mrds_search_ops.incl.pl1 -- 2/23/79 */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*   81-06-01 Jim Gray : removed assn_type and len from the  move_info
  2     6*   structure, since these are not used with the advent of mu_covert.
  2     7*
  2     8*   81-06-30 Jim Gray : added range_val_ptr to  init_info  structure,
  2     9*   so  that  ranges  (10  <  x < 20) could be handled in one call to
  2    10*   vfile select, instead of two. Also added range bit to  show  when
  2    11*   usable.
  2    12*
  2    13*   81-07-06 Jim Gray : changed init_info op type encodings for those
  2    14*   access  methods  currently available in mrds, plus added bits for
  2    15*   whether mrds or vfile needs to  do  tid  list  intersection,  and
  2    16*   whether an unordered, faster sequential search can be done.
  2    17*
  2    18*   81-07-18 Jim Gray : added many comments, after changing the named
  2    19*   constants to refer to the new access methods.
  2    20*
  2    21*   82-09-01 Mike Kubicar : converted from tuple structure to vector
  2    22*   structure.  This meant changing fields which pointed directly to
  2    23*   tuple space to use indices into the tuple_info structure instead.
  2    24*
  2    25*   82-10-01 Davids: removed the encd_hash flag from move_info since it
  2    26*   is never used and removed the encd_index flag from move_info since
  2    27*   changes to mrds_dsl_gen_srch_prog have rendered it obsolute. Increased
  2    28*   size of the reserved element from 28 to 30 bits.
  2    29*
  2    30*   83-04-04 Mike Kubicar : Removed init_info.unordered.  It is no longer
  2    31*   used.
  2    32*
  2    33*   83-04-22 Mike Kubicar : Added search_specification_ptr to select_info.
  2    34*   This is the search spec to be used when retrieving tuple from a relation.
  2    35*   Also deleted the init_info strucuture and associated constants.  It is no
  2    36*   longer used.
  2    37*
  2    38*   83-05-31 Mike Kubicar : Renamed search_specification_ptr to
  2    39*   relation_search_specification_ptr.
  2    40*
  2    41**/
  2    42 
  2    43 
  2    44 /* DESCRIPTION:
  2    45*
  2    46*		      BEGIN_DESCRIPTION
  2    47*
  2    48*   The search ops structure holds the  operations  to  be  performed
  2    49*   during   a   search   of  the  database.  It  is  a  step-by-step
  2    50*   actuallization of the selection expression specified by the user.
  2    51*   For each tuple variable, there will be an move-init-select set of
  2    52*   operations. The first operations is always an initizization~  one
  2    53*   called  PICKUP_SVP,  The  last  operation  is always a case for a
  2    54*   failure condition called RETNUL, to return  tuple_not_found.  The
  2    55*   move_init_select groups each have their own RETVAl step to return
  2    56*   a tuple, if they succeed in finding an acceptable tuple. If there
  2    57*   are multiple tuple variables, each T.V. group calls the move step
  2    58*   of the next group once it has found an acceptable tuple in  order
  2    59*   to  satisfy  all conditions of the and group. Multiple and groups
  2    60*   are processed until they exhaust all  possible  tuple  variables,
  2    61*   before the mini-search for the next and group is called.
  2    62*
  2    63*		       END_DESCRIPTION
  2    64**/
  2    65 
  2    66 dcl 1 search_ops aligned based (so_ptr),		/* the search "program" */
  2    67     2 ic fixed bin,					/* index to next instruction */
  2    68     2 nops fixed bin,				/* no. of operations in list */
  2    69     2 op (so_nops_init refer (search_              Multics             Rö`Ø†â   1‹     1     y21èÿÿÿÖ  ÎGoutier               Multics             Rö~8W   1¯     1±     !2$1üÿÿÿÖ  ÏKokol                 Office              RöÔ‹Õ©   1º     1¼     282ÿÿÿÖ  ÐKokol                 Office              RöÕ1·Á   1Ä     1Æ     #2L2$ÿÿÿÖ  ÑDonaldson             Multics             Röä Š£   1Ï     1Ö     {2`28ÿÿÿÖ  ÒThompson              Multics             R÷v‰   1õ     1ù     2t2LÿÿÿÖ  ÓHoover                Multics             R÷ŽJr   2;     2A     %2ˆ2`ÿÿÿÖ  ÔAWTaylor              Multics        2   R÷™Èñ	   2K     2R     q2œ2tÿÿÿÖ  ÕWillott               Office              R÷­¯ÿì   2o     2t     Œ2°2ˆÿÿÿÖ  ÖMulhaupt              Multics             RøJd_   2—     2     92Ä2œÿÿÿÖ  ×Rosin                 Operator            Røaÿz   2¬     2³     2Ø2°ÿÿÿÖ  ØMiko                  Multics             Røkz‰   2º     2Á     52ì2ÄÿÿÿÖ  ÙMcRory                CDC                 Røz¶ãS   2Ï     2×     (2 2ØÿÿÿÖ  ÚZimmerman             Multics             Rø€rP1   2á     2æ     à22ìÿÿÿÖ  ÛAWTaylor              Multics      2ˆ     Rúýc¶   2     2&     72(2 ÿÿÿÖ  ÜHuen                  Multics             Rú“8ß‘   24     2;     B2<2ÿÿÿÖ  ÝHinatsu               Multics             Rûß3«   2L     2Q      2P2(ÿÿÿÖ  ÞHinatsu               Multics             Rû>”P   2Y     2]     2d2<ÿÿÿÖ  ßHinatsu               Multics             Rû¬Šö   2e     2j     &2x2PÿÿÿÖ  àHoover                Multics             Rû2ÌÝÂ   2t     2y     +2Œ2dÿÿÿÖ  áKokol                 Office              Rû5]   2„     2†     J2 2xÿÿÿÖ  âHindbo                Multics             Rûhv°J   2™     '2£     A2´2ŒÿÿÿÖ  ãVu                    Multics             RûØ±g   2´     2¹     2È2 ÿÿÿÖ  äKokol                 Office              RüÛ¬G   2¿     2Á     2Ü2´ÿÿÿÖ  åPalmer                Multics             Rüì¶M   2É     2Ð     «2ð2ÈÿÿÿÖ  æHinatsu               Multics             RüöÁ   2û     3      g32ÜÿÿÿÖ  çKokol                 Office              RýE–‘ò   3     3     k32ðÿÿÿÖ  èKramer                Multics             RýYsmU   39     3;     73,3ÿÿÿÖ  éHenry                 Multics             Rýt‹¶C   3I     3P     Ž3@3ÿÿÿÖ  êANeal                 Multics             RþC šT   3t     3{     m3T3,ÿÿÿÖ  ëThompson              Multics             RþL);   3—     3     {3h3@ÿÿÿÖ  ìGee                   Multics             RþM(÷W   3¼     3Â     n3|3TÿÿÿÖ  íElliott               Multics             Rþ¨\€ö   3Þ     3ã     !33hÿÿÿÖ  îElliott               Multics             Rþ© ª!   3ì     3ò     Š3¤3|ÿÿÿÖ  ïMQuintin              CDC                 RþÊØ    3     	3     :3¸3ÿÿÿÖ  ðPost                  Multics        3Ì   RþóÄ{   3'     
3*     f3Ì3¤ÿÿÿÖ  ñLyttle                Multics      3¸     RÿÂ“W   3D     3H     ”3à3¸ÿÿÿÖ  òFudge                 SysAdmin     &Ô     R=SÝ/   3m     3q     ƒ3ô3ÌÿÿÿÖ  óKokol                 Office              R†¨»   3’     3”     .33àÿÿÿÖ  ôAWTaylor              Multics             R¼¢Œ    3      3¤     I33ôÿÿÿÖ  õHoover                Multics             R×JØí   3·     3¼     '303ÿÿÿÖ  öHoover                Multics             R[æ§   3Æ     3Ì     '3D3ÿÿÿÖ  ÷Kokol                 Office              RVÏ¥G   3Ö     3×     .3X30ÿÿÿÖ  øHoover                Multics             R×~¼×   3ã     3è     '3l3DÿÿÿÖ  ùKokol                 Office              RÜîþê   3ò     3õ     ,3€3XÿÿÿÖ  úWillott               Office              Rçiê¾   4      4     '3”3lÿÿÿÖ  ûWright                Multics        3Ð   Rú“óª   4     
4     83¨3€ÿÿÿÖ  üFalck                 Office              RTÂd+   4     
4!     83¼3”ÿÿÿÖ  ýHoover                Multics             R^†,   4/     44     '3Ð3¨ÿÿÿÖ  þAWTaylor              Multics      3”     Ra”‘ì   4>     4B     {3ä3¼ÿÿÿÖ  ÿThompson              Multics             Rxâ-   4a     4f     o3ø3ÐÿÿÿÖ   Palmer                Muned based (ti_ptr),
  3    11     2 num_tuples fixed bin,				/* no. of tuples for which info given */
  3    12     2 tuple (ti_ntuples_init refer (tuple_info.num_tuples)),
  3    13       3 tuple_ptr ptr,				/* pointer to found tuple */
  3    14       3 tuple_id bit (36) aligned,			/* tuple id for  found tuple */
  3    15       3 var_index fixed bin;				/* index to tuple variable  */
  3    16 
  3    17 dcl  ti_ptr ptr;
  3    18 dcl  ti_ntuples_init fixed bin;
  3    19 
  3    20 /* END mrds_tuple_info.incl.pl1 */
  3    21 
      616 
      617 
  4     1 /* BEGIN mrds_search_vars.incl.pl1 -- jaw, 2/26/79 */
  4     2 
  4     3 dcl 1 search_vars aligned based (sv_ptr),		/* info on all variables */
  4     4     2 nvars fixed bin,				/* number of variables */
  4     5     2 new_val (sv_nvars_init refer (search_vars.nvars),	/* indicates new values to be moved */
  4     6      sv_nvars_init refer (search_vars.nvars)) bit (1) unal,
  4     7     2 info (sv_nvars_init refer (search_vars.nvars)) like rtrv_info; /* data for each var. */
  4     8 
  4     9 dcl  sv_ptr ptr;
  4    10 dcl  sv_nvars_init fixed bin;
  4    11 
  4    12 /* END mrds_search_vars.incl.pl1 */
  4    13 
      618 
      619 
  5     1 /* BEGIN mdbm_rtrv_info.incl.pl1 -- jaw, 3/15/79 */
  5     2 
  5     3 /*
  5     4*   HISTORY
  5     5*
  5     6*   82-09-21 Davids: removed reference to the iocb_ind element which was the
  5     7*   index in the rm_rel_info.iocb_ptr array of the iocb to be used and added
  5     8*   the cursor_ptr element.
  5     9*   
  5    10*   82-10-1  Woodka: changed tid_array to be bit (36) aligned instead of 
  5    11*   bit (36) unaligned. 
  5    12*
  5    13*   82-10-22 Woodka : added first_seq_io bit and changed reserved to bit 32.
  5    14*
  5    15*   82-10-26 Davids: added the record_collection_cursor_ptr element. This is
  5    16*   needed because the relation manager get_tuple_by_id entry requires a 
  5    17*   record collection cursor.
  5    18*
  5    19*   83-05-03 Mike Kubicar : deleted the unused fields: thd_type, seq_io,
  5    20*   seed_id, link_io, free_array and thd_ptr.  Added the maxtids field.
  5    21*
  5    22*   83-05-31 Mike Kubicar : got rid of cursor_ptr and
  5    23*   record_collection_cursor_ptr.  Inserted the field relation_cursor_ptr.
  5    24*
  5    25**/
  5    26 
  5    27 dcl 1 rtrv_info aligned based (rti_ptr),		/* info needed to retrieve a tuple */
  5    28     2 ri_ptr ptr,					/* to rel_info */
  5    29     2 relation_cursor_ptr ptr,                              /* pointer to cursor to use */
  5    30     2 ntids fixed bin,				/* no of tuple ids in list */
  5    31     2 ctid fixed bin,				/* current position in list */
  5    32     2 maxtids fixed bin,				/* Maximum number of tids to search for */
  5    33     2 first_seq_io bit (1) unal,			/* on if first sequential i/o is to be done */
  5    34     2 reserved bit (35) unal,
  5    35     2 ta_ptr ptr;					/* to array of tuple ids */
  5    36 
  5    37 dcl  rti_ptr ptr;
  5    38 
  5    39 dcl  tid_array (ta_nids) bit (36) aligned  based (ta_ptr);	/* array of tuple ids */
  5    40 
  5    41 dcl  ta_nids fixed bin;
  5    42 dcl  ta_ptr ptr;
  5    43 
  5    44 /* END mdbm_rtrv_info.incl.pl1 */
  5    45 
      620 
      621 
  6     1 /* BEGIN mrds_range.incl.pl1 -- jaw, 10/20/78 */
  6     2 
  6     3 /* Modified 83-04-22 by R. Harvey to add needed_bits */
  6     4 
  6     5 dcl 1 range aligned based (range_ptr),
  6     6     2 num_vars fixed bin,				/* number of tuple variables */
  6     7     2 tup_var (mrds_data_$max_tup_var refer (range.num_vars)), /* info for each tuple variable */
  6     8       3 name char (mrds_data_$max_id_len),		/* name of tuple variable */
  6     9       3 temp_rel bit (1) unal,			/* on if temporary relation */
  6    10       3 used bit (1) unal,				/* 1 => this tuple variable is referenced by
  6    11*						   a -select clause. */
  6    12       3 whole_tuple_selected bit (1) unal,		/* the whole tuple variable is referenced in the select clause */
  6    13       3 copy_for_current bit (1) unal,			/* -current requests attributes not previously retrieved */
  6    14       3 copied_for_current bit (1) unal,		/* tuple copied during previous -current */
  6    15       3 reserved bit (31) unal,			/* reserved for future use */
  6    16       3 rel_index fixed bin,				/* index to assoc. relation */
  6    17       3 stv_ptr ptr,				/* simple typed vector */
  6    18       3 idl_ptr ptr,				/* id_list ptr */
  6    19       3 needed_bits aligned,
  6    20         4 attr (mrds_data_$max_attributes) bit (1) unal,
  6    21       3 ri_ptr ptr;					/* pointer to rel info for assoc. relation */
  6    22 
  6    23 dcl  range_ptr ptr;
  6    24 
  6    25 /* END mrds_range.incl.pl1 */
  6    26 
      622 
      623 
  7     1 /* BEGIN mdbm_rm_rel_info.incl.pl1 -- jaw, 11/16/78 */
  7     2 
  7     3 /* WARNING
  7     4*          If the rm_rel_info structure is changed then the mrds_data_
  7     5*          item saved_res_version MUST be incremented to invalidate all
  7     6*          existing saved resultants
  7     7**/
  7     8 
  7     9 /* HISTORY:
  7    10*
  7    11*   Modified by Jim Gray - - May 1980, to  include  model  number  of
  7    12*   attributes,   and   varying  attributes,  so  that  partial  view
  7    13*   submodels will have the  info  needed  to  properly  set  up  the
  7    14*   varying length array headers in the tuple structure.
  7    15*
  7    16*   Modified  by  Jim  Gray  -  -  80-11-06,  to  rename   r_perm   =
  7    17*   status_perm,     s_perm    =    append_tuple_perm,    d_perm    =
  7    18*   delete_tuple_perm, and make m_perm = unused_perm.
  7    19*
  7    20*   81-01-23 Jim Gray : added bit to indicate whether the last  model
  7    21*   view attribute was varying character or bit, since a partial view
  7    22*   submodel will not have this information in the resultant, and  it
  7    23*   is  needed for determining the new tuple length in mus_mod_ubtup,
  7    24*   since with exact length storage  of  varying  length  attributes,
  7    25*   each  tuple  can  be  a  different  length,  which is can only be
  7    26*   determined by examining the tuple itself.
  7    27*
  7    28*   81-01-29 Jim Gray : added curent  tuple  count,  to  provide  for
  7    29*   interface  to  allow  temp  rel  population  to  be known, and to
  7    30*   provide a more efficient means of finding an approx. current perm
  7    31*   relation population.
  7    32*
  7    33*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  7    34*   blocked  files, foreign keys, and ids procedures. Also set number
  7    35*   of files per rel to a constant of 1.
  7    36*
  7    37*   81-05-28 Jim Gray : combined data  from  rm_file_info  into  this
  7    38*   structure so that only one structure per relation is needed.
  7    39*
  7    40*   81-07-02 Jim Gray : added total_key and dup_key vfile  statistics
  7    41*   counts.   Also  added  number  of  operations  count  since  last
  7    42*   statistics update, and a time  since  the  statistics  were  last
  7    43*   updated.
  7    44*
  7    45*   81-07-06 Jim Gray :  added  a  per  selection  expression  update
  7    46*   identifier so that small relations could be updated on a per S.E.
  7    47*   basis
  7    48*
  7    49*   82-04-21 R. Lackey : Added number_selected (ri_niocbs_init refer (rm_rel_info.niocbs)) fixed bin (35)
  7    50*   to end of structure   TR 12205 (Suggestion).
  7    51*   
  7    52*   82-08-19 D. Woodka :  Removed  rm_rel_info.max_data_len  field for
  7    53*   the DMS conversion. 
  7    54*
  7    55*   82-08-30 Davids: added the opening_id element and removed the iocb
  7    56*   array and the niocb element for DMS conversion. Also removed the
  7    57*   number_selected array (and ri_niocbs_init) since subsets are not
  7    58*   going to be used.
  7    59*
  7    60*   82-09-20 Mike Kubicar : changed rm_rel_info.rel_id to bit (36) aligned
  7    61*   so that it can be used with relation manager.  Also added
  7    62*   rm_rel_info.primary_key_index_id for relation manager.
  7    63*
  7    64*   82-09-22 Mike Kubicar : Removed the, now useless, fields var_attr_ptrs,
  7    65*   nvar_atts, model_nvar_atts.
  7    66*
  7    67*   82-09-24 Davids: Removed current_key_count and current_dup_key_count
  7    68*   since the duplicate key count for each secondary index is now being
  7    69*   kept in the attr_info structure and key_count was only needed to
  7    70*   help in calculating the average selectivity of each index which
  7    71*   can now be gotten directly from each index's dup key count. Also
  7    72*   removed the file_id element since it is no longer needed for
  7    73*   anything.
  7    74*
  7    75*   82-09-27 Mike Kubicar : removed file_id_len for the same reason file_id
  7    76*   was removed.
  7    77*
  7    78*   82-11-05 Mike Kubicar : added a pointer to an id_list structure to be
  7    79*   used when retrieving tuples from this relation.
  7    80*
  7    81*   83-04-06 Davids: Added the scope_flags_ptr which points to the scope_flags structure
  7    82*   for the relation. Note that this structure is part of the resultant NOT
  7    83*   part of the db.control structure. The scopes are duplicated in the resultant
  7    84*   to reduce contention for the db.control structure. Note also that the pointer
  7    85*   will always point to a scope_flags structure even if no scopes have been
  7    86*   set on the relation, the structure is allocated when the db is opened.
  7    87**/
  7    88 
  7    89 
  7    90 /* DESCRIPTION:
  7    91*
  7    92*   This structure is allocated in the area part of the structure  in
  7    93*   mdbm_rm_db_info.incl.pl1  as  part of the resultant model created
  7    94*   at open  time  for  a  database.  There  will  be  one  of  these
  7    95*   rm_rel_info   structures  for  each  relation  appearing  in  the
  7    96*   database view (there may be less than the total in  the  database
  7    97*   for  a  submodel  openings).  There  will  also  be  one for each
  7    98*   temporary relation currently defined for that opening.
  7    99*
  7   100*   The structure in mdbm_rm_rel_array.incl.pl1 contains pointers  to
  7   101*   all  rm_rel_info  structures  allocated. It is used for searching
  7   102*   for the appropriate  structure.  This  array  is  pointed  to  by
  7   103*   rm_db_info. There are two arrays, one for perm rels, one for temp
  7   104*   rels.
  7   105*
  7   106*   The      rm_rel_info      structure      points      to       the
  7   107*   mdbm_rm_attr_info.incl.pl1  structures,  one  for  each attribute
  7   108*   appearing in this view of the relation. Each  of  these  in  turn
  7   109*   point  to a mdbm_rm_domain_info.incl.pl1 structure for the domain
  7   110*   info for each attr.
  7   111*
  7   112*   Most of the other information here deals with  specifics  of  the
  7   113*   relation's  logical  definition,  such as key and secondary index
  7   114*   attribute inidicators, security permissions, and  tuple  physical
  7   115*   construction details.
  7   116*
  7   117**/
  7   118 
  7   119      dcl	   1 rm_rel_info	      aligned based (rmri_ptr), /* relation information */
  7   120 	     2 name	      char (32),		/* from submodel */
  7   121 	     2 model_name	      char (30),		/* from model */
  7   122 	     2 rel_id	      bit (36) aligned,	/* unique id. */
  7   123 	     2 retrieve	      bit (1) unal,		/* operations allowed by this view */
  7   124 	     2 modify	      bit (1) unal,
  7   125 	     2 delete	      bit (1) unal,
  7   126 	     2 store	      bit (1) unal,
  7   127 	     2 total_key	      bit (1) unal,		/* on if view includes full primary key */
  7   128 	     2 indexed	      bit (1) unal,		/* on if exists sec. index */
  7   129 	     2 mdbm_secured	      bit (1) unal,		/* on if mdbm must check security */
  7   130 	     2 status_perm	      bit (1) unal,		/* if user has status. perm. */
  7   131 	     2 append_tuple_perm  bit (1) unal,		/* if user has store perm. */
  7   132 	     2 delete_tuple_perm  bit (1) unal,		/* if user has del. perm. */
  7   133 	     2 unused_perm	      bit (1) unal,		/* for future use. */
  7   134 	     2 last_model_attr_char_var bit (1) unal,	/* on => last model varying attr is char */
  7   135 	     2 reserved	      bit (24) unal,	/* for future use */
  7   136 	     2 num_attr	      fixed bin,		/* total no. of attr. in rel. */
  7   137 	     2 model_num_attr     fixed bin,		/* total attrs in model relation */
  7   138 	     2 nkey_attr	      fixed bin,		/* no. of key attr. */
  7   139 	     2 model_nkey_attr    fixed bin,		/* total number of keys in model */
  7   140 	     2 primary_key_index_id bit (36) aligned,     /* Index id of relation's primary key */
  7   141 	     2 nsec_inds	      fixed bin,		/* no. sec. indexes */
  7   142 	     2 max_key_len	      fixed bin (35),	/* max length (chars) of primary key */
  7   143 	     2 current_tuple_population fixed bin (35),	/* last known total  tuple count for this relation */
  7   144 	     2 last_statistics_update_count fixed bin,	/* number of operations's, since this rels stats were updated */
  7   145 	     2 last_statistics_update_time fixed bin (71),/* last time this rels stats were updated */
  7   146 	     2 last_statistics_update_s_e_ref_num fixed bin (35), /* last select expr ID that updated this rels stats */
  7   147 	     2 ready_mode	      fixed bin,		/* 1 => r, 2 => mr, 3 => u, 4 => l, 5 => sr, 6 => su */
  7   148 	     2 file_type	      fixed bin,		/* 1 => unblocked, 2 => blocked, 3 => temporary */
  7   149 	     2 tuple_id_len	      fixed bin,		/* no. bits in local tuple id */
  7   150 	     2 opening_id	      bit (36) aligned,	/* relation manager opening is */
  7   151 	     2 key_attr_ptrs      (nkey_attr_init refer (rm_rel_info.nkey_attr)) ptr, /* ptrs to key attr. */
  7   152 	     2 attr_ptrs	      (natts_init refer (rm_rel_info.num_attr)) ptr, /* ptrs to all attr. */
  7   153 	     2 id_list_ptr        ptr,		/* Id list for retrieves from the relation */
  7   154                2 scope_flags_ptr    ptr;                    /* pointer to the scope_flags structure for the rel */
  7   155 
  7   156      dcl	   rmri_ptr	      ptr;
  7   157      dcl	   (nkey_attr_init,
  7   158 	   natts_init,
  7   159 	   nvar_atts_init)	      fixed bin;
  7   160 
  7   161 /* END mdbm_rm_rel_info.incl.pl1 */
  7   162 
  7   163 
      624 
      625 
  8     1 /* BEGIN mdbm_descriptor.incl.pl1 -- jaw 5/31/78 */
  8     2 /* modified by Jim Gray - - Nov. 1979, to change type from fixed bin(5) to
  8     3*   unsigned fixed bin(6), so new packed decimal data types could be handled.
  8     4*   also the duplicate mrds_descriptor.incl.pl1 was eliminated. */
  8     5 
  8     6 dcl 1 descriptor based (desc_ptr),			/* map of Multics descriptor */
  8     7     2 version bit (1) unal,				/* DBM handles vers. 1 only */
  8     8     2 type unsigned fixed bin (6) unal,			/* data type */
  8     9     2 packed bit (1) unal,				/* on if data item is packed */
  8    10     2 number_dims bit (4) unal,			/* dimensions */
  8    11     2 size,					/* size for string data */
  8    12       3 scale bit (12) unal,				/* scale for num. data */
  8    13       3 precision bit (12) unal,			/* prec. for num. data */
  8    14     2 array_info (num_dims),
  8    15       3 lower_bound fixed bin (35),			/* lower bound of dimension */
  8    16       3 upper_bound fixed bin (35),			/* upper bound of dimension */
  8    17       3 multiplier fixed bin (35);			/*  element separation */
  8    18 
  8    19 dcl  desc_ptr ptr;
  8    20 dcl  num_dims fixed bin init (0) ;			/* more useful form of number_dims */
  8    21 
  8    22 /* END mdbm_descriptor.incl.pl1 */
  8    23 
  8    24 
      626 
      627 
  9     1 /* BEGIN mdbm_ind_sel_info.incl.pl1 -- jaw, 2/23/79 */
  9     2 
  9     3 /* 6-sep-79 Davids: key_bit_len added */
  9     4 
  9     5 dcl 1 ind_sel_info aligned based (isi_ptr),		/* info reqired for initind index range */
  9     6     2 op_code fixed bin,				/* comparison operator,
  9     7*						   1 => =
  9     8*						   2 => ^=
  9     9*						   3 => <
  9    10*						   4 => <=
  9    11*						   5 => >
  9    12*						   6 => >= */
  9    13     2 key char (256) var,
  9    14     2 key_bit_len fixed bin (35);			/* actual number of bits used in key */
  9    15 
  9    16 dcl  isi_ptr ptr;
  9    17 
  9    18 /* END mdbm_ind_sel_info.incl.pl1 */
  9    19 
  9    20 
      628 
      629 
 10     1 /* BEGIN INCLUDE FILE mdbm_seg_area.incl.pl1 - - Jim Gray 2/19/79 */
 10     2 
 10     3 /* these structures provide a standard for
 10     4*   1) using an entire segment as an area, managed by the area manager
 10     5*   2) a constant header, that has an offset to the major common structure in the area
 10     6*   the pointer to that structure is obtained via pointer(model_seg_ptr, model_seg.offset)
 10     7*   the model_area_ptr is obtained via pointer(model_seg_ptr, size(model_seg)) */
 10     8 
 10     9 declare 1 model_seg aligned based (model_seg_ptr),	/* segment header, not to be changed */
 10    10         2 struct_offset bit (18),			/* offset to major structure allocated in area */
 10    11         2 padding (3) fixed bin ;			/* to set up four word boundary */
 10    12 
 10    13 declare  model_seg_ptr ptr int automatic init (null ());
 10    14 
 10    15 
 10    16 declare  model_area area (sys_info$max_seg_size - size (model_seg)) based (model_area_ptr) ; /* segment area */
 10    17 
 10    18 declare  model_area_ptr ptr int automatic init (null ());
 10    19 
 10    20 dcl size builtin;
 10    21 
 10    22 /* END INCLUDE FILE mdbm_seg_area.incl.pl1 */
 10    23 
      630 
      631 
 11     1 /* BEGIN INCLUDE FILE mrds_select_area.incl.pl1   (Kepner Multics)  05/29/79 1736.1 mst Tue */
 11     2 dcl 1 select_area_struct aligned based (select_area_struct_ptr), /* major structure in segment for current selection expression allocations */
 11     3     2 version fixed bin,
 11     4     2 dbcb_ptr ptr;					/* ptr ptr to dbcb */
 11     5 
 11     6 dcl  select_area_struct_ptr ptr int automatic init (null ());
 11     7 
 11     8 dcl  select_area area (sys_info$max_seg_size - size(model_seg)) based (select_area_ptr);
 11     9 
 11    10 dcl  select_area_ptr ptr int automatic init (null ());
 11    11 						/*   END INCLUDE FILE mrds_select_area.incl.pl1 */
 11    12 
      632 
      633 
 12     1 /* BEGIN INCLUDE FILE mrds_debug_names.incl.pl1     Jim Gray 8/7/79 */
 12     2 
 12     3 /* this include file associates module names with debug switches
 12     4*   that are stored in the data segment mrds_debug_
 12     5*   each module has it's own bit(9) debug switch, to define for various
 12     6*   debug actions, with new module names to be added to the end
 12     7*   of this list using the next in order array index in mrds_debug_
 12     8*   the convention for naming is db_{module's full name}
 12     9*   for the defined declaration over mrds_debug_$switch.
 12    10*   module.name array is then changed to reflect the new
 12    11*   number of modules, with the full module name added to the bottom
 12    12*   of the initialize list for the name array.
 12    13*   the module name array is used by the command level interface that sets/resets
 12    14*   the current status of the debug switches for each module.
 12    15*   the modules themselves use the db_{module name} declared variable for
 12    16*   that module to interagate the bits for proper debug action to take.
 12    17*   the definition of the meaning of the 9-bits is up to each individual module's
 12    18*   designer. */
 12    19 
 12    20 
 12    21 /*
 12    22*   HISTORY
 12    23*
 12    24*   80-11-12 Davids: added db_mus_mod_ubtup
 12    25*
 12    26*   80-11-13 Davids: added db_mu_sec_get_tuple and db_mu_sec_get_tid
 12    27*
 12    28*   80-12-15 Jim Gray :  added  mrds_dsl_set_fscope  to  display  non
 12    29*   error  info  about  being queued, and request being granted after
 12    30*   being queued.
 12    31*
 12    32*   81-01-15 Jim Gray : added  mu_concurrency_control  bit  to  allow
 12    33*   running  MR8  and  MR9 mrds against the same database at the same
 12    34*   time.
 12    35*
 12    36*   81-02-02  Jim  Gray  :  added  bit  for  mrds_rst_dmdm  to  allow
 12    37*   displaying internal tuple format bit offset, rather than the user
 12    38*   view.
 12    39*
 12    40*   81-02-06 Jim Gray : added bit for  new  mu_open_name_manager,  to
 12    41*   dump  an  element  from  the  list, when display_open_names entry
 12    42*   called with switch set.
 12    43*
 12    44*   81-05-20 Jim Gray : added bit for  mrds_dsl_where_clause  display
 12    45*   of sub_err_ messages, when cross domain compare occurs.
 12    46*
 12    47*   81-06-17 Jim Gray : added bit for mu_open_iocb_manager to display
 12    48*   iocb slot and rel name.
 12    49*
 12    50*   81-07-08 Jim Gray : added comment for bit 4 in mrds_dsl_permute
 12    51*
 12    52*   81-07-17 Jim Gray : added comment for bit 5 in mrds_dsl_permute
 12    53*
 12    54*   81-07-18 Jim Gray : added bit 1 for  mrds_dsl_gen_srch_prog  that
 12    55*   allows  key  searches, other than than specified by permute to be
 12    56*   done as comparisons instead.
 12    57*
 12    58*   81-07-22  Jim   Gray   :   added   comment   about   bit   2   in
 12    59*   mrds_dsl_gen_srch_prog
 12    60**/
 12    61 
 12    62 declare (
 12    63          db_mrds_dsl_eval_expr bit (9) unal defined (mrds_debug_$switch (1)),
 12    64          db_mrds_dsl_get_token bit (9) unal defined (mrds_debug_$switch (2)),
 12    65          db_mrds_dsl_permute bit (9) unal defined (mrds_debug_$switch (3)),
 12    66          db_mrds_dsl_optimize bit (9) unal defined (mrds_debug_$switch (4)),
 12    67          db_mrds_dsl_search bit (9) unal defined (mrds_debug_$switch (5)),
 12    68          db_mrds_dsl_translate bit (9) unal defined (mrds_debug_$switch (6)),
 12    69          db_mu_retrieve bit (9) unal defined (mrds_debug_$switch (7)),
 12    70          db_mrds_dsl_open bit (9) unal defined (mrds_debug_$switch (8)),
 12    71          db_mrds_dsl_close bit (9) unal defined (mrds_debug_$switch (9)),
 12    72          db_mrds_dsl_init_res bit (9) unal defined (mrds_debug_$switch (10)),
 12    73          db_mu_sec_init_res bit (9) unal defined (mrds_debug_$switch (11)),
 12    74          db_mus_mod_ubtup bit (9) unal defined (mrds_debug_$switch (12)),
 12    75          db_mu_sec_get_tuple bit (9) unal defined (mrds_debug_$switch (13)),
 12    76          db_mu_sec_get_tid bit (9) unal defined (mrds_debug_$switch (14)),
 12    77          db_mrds_dsl_set_fscope bit (9) unal defined (mrds_debug_$switch (15)),
 12    78          db_mu_concurrency_control bit (9) unal defined (mrds_debug_$switch (16)),
 12    79          db_mrds_rst_dmdm bit (9) unal defined (mrds_debug_$switch (17)),
 12    80          db_mu_open_name_manager bit (9) unal defined (mrds_debug_$switch (18)),
 12    81          db_mrds_dsl_where_clause bit (9) unal defined (mrds_debug_$switch (19)),
 12    82          db_mu_open_iocb_manager bit (9) unal defined (mrds_debug_$switch (20)),
 12    83          db_mrds_dsl_gen_srch_prog bit (9) unal defined (mrds_debug_$switch (21))
 12    84          ) ;
 12    85 
 12    86 /* list of known module names, with index into name array
 12    87*   the same as that into mrds_debug_$switch,
 12    88*   number is the current count of defined module names,
 12    89*   name is the modules full name. */
 12    90 
 12    91 declare 1 module options (constant) internal static,
 12    92         2 number fixed bin init (21),
 12    93         2 name char (32) dimension (21) init (
 12    94          "mrds_dsl_eval_expr",			/* 1 => display value of each expression */
 12    95          "mrds_dsl_get_token",			/* 1 => display the current token */
 12    96          "mrds_dsl_permute",				/* each 1 => lost cost path found,
 12    97*						   2 => reverse partial path
 12    98*						   3 => use range order for path
 12    99*						   4 => display access method costs
 12   100*						   5 => display details of final low cost path */
 12   ltics             Ry5Ëf   4‚     4„     =43äÿÿÿÖ  Stadie                Multics             R2¢Ú   4”     4˜     o4 3øÿÿÿÖ  Hoover                Multics             Rcš   4´     4¸     444ÿÿÿÖ  Maryniuk              Multics             R%D6S   4À     $4É     $4H4 ÿÿÿÖ  Stadie                Multics             RýqJ)   4Ò     4Ø     {4\44ÿÿÿÖ  Willott               Office              R!(“Ì   4÷     4ú     K4p4HÿÿÿÖ  Schroth               SysMaint            RKbÒ$   4     4     *4„4\ÿÿÿÖ  Hoover                Multics             Rr¼Î©   4     4"     '4˜4pÿÿÿÖ  Elliott               Multics             R²ùÆ   4,     41     N4¬4„ÿÿÿÖ  	Lyttle                Multics             R‘ìP   4E     4H     m4À4˜ÿÿÿÖ  
Hoover                Multics             Rj‰ë   4d     4j     %4Ô4¬ÿÿÿÖ  Vu                    Multics             RûÚV    4t     	4w     14è4ÀÿÿÿÖ  Hoover                Multics             RÖØ]5   4„     4‰     4ü4ÔÿÿÿÖ  Kokol                 Office              R•Ëd   4‘     4’     44èÿÿÿÖ  Willott               Office              R&ª‰È   4š     4      ¨4$4üÿÿÿÖ  Gray                  Multics             R(ízË   4Ê     4Ñ     Z484ÿÿÿÖ  Gee                   Multics             R)þeb   4è     4ï     >4L4$ÿÿÿÖ  McGirr                Multics             R8‘H   4ÿ     5     *4`48ÿÿÿÖ  ANeal                 Multics             R[­Ô   5     5     W4t4LÿÿÿÖ  Hoover                Multics             R_’*å   5+     50     4ˆ4`ÿÿÿÖ  MQuintin              CDC            4œ   RQ&ž   58     	5;     ;4œ4tÿÿÿÖ  MQuintin              CDC          4ˆ4°   Ryyûð   5J     5N     44°4ˆÿÿÿÖ  Flegel                Multics      4œ     Rì®’ã   5[     5_     P4Ä4œÿÿÿÖ  Wright                Multics             R×¹ò   5s     5u     44Ø4°ÿÿÿÖ  Zimmerman             Multics             RÙql   5‚     #5‹     w4ì4ÄÿÿÿÖ  Kokol                 Office              RÑå¶   5©     5«     5 4ØÿÿÿÖ  Hoover                Multics             RúÙ	ê   5³     5¹     '54ìÿÿÿÖ  Flegel                Multics             Rùª   5Ã     5Ä      5(5 ÿÿÿÖ  Miko                  Multics             Rd6.p   5Ì     "5Õ     5<5ÿÿÿÖ  Hoover                Multics             Röp„   5Ú     5ß     5P5(ÿÿÿÖ  Hoover                Multics             R!¿™ƒ   5ç     5ì     5d5<ÿÿÿÖ  Willott               Office              R!…«šØ   5ô     5ú     65x5PÿÿÿÖ   Willott               Office              R!†{‡   5     5     ¿5Œ5dÿÿÿÖ  !Swanson               Multics             R!Œ2æ   5;     5A     y5 5xÿÿÿÖ  "Willott               Office              R!Ä™½   5`     5c     V5´5ŒÿÿÿÖ  #Gratton               Office              R!Æ«‚   5y     5{     .5È5 ÿÿÿÖ  $Gray                  Multics             R!íøY    5‡     5     j5Ü5´ÿÿÿÖ  %Hoover                Multics             R"
êá   5¨     5­     5ð5ÈÿÿÿÖ  &Smith                 CDC                 R"z€   5µ     5¼     55ÜÿÿÿÖ  'Kokol                 Office              R"&F»¹   5Ã     5Ä     255ðÿÿÿÖ  (MQuintin              CDC                 R"±¹s²   5Ñ     	5Ô     65,5ÿÿÿÖ  )Lyttle                Multics             R#’(!³   5â     5è     B5@5ÿÿÿÖ  *Hoover                Multics             R#“òá†   5ù     5ÿ     $5T5,ÿÿÿÖ  +Mabey                 Multics             R#Ç.Ã   6     6     L5h5@ÿÿÿÖ  ,NMills                Multics             R#õä\   6"     	6%     F5|5TÿÿÿÖ  -Hoover                Multics             R$#Ã   67     6=     '55hÿÿÿÖ  .ANeal                 Multics             R$")rl   6G     6O     C5¤5|ÿÿÿÖ  /Schroth               SysMaint            R$tNþU   6`     6e     5¸5ÿÿÿÖ  0Wright                Multics             R%‡q­   6j     6r     a5Ì5¤ÿÿÿÖ  1Hoover                Multics             R' Ÿ²9   6‹     6     5à5¸ÿÿÿÖ  2Kokol                 Office              R'o`ÚÊ   6˜     6š     F5ô5ÌÿÿÿÖ  3AWTaylor              Multics           r (general_typed_vector.number_of_dimensions)),
 13    29 	       3 identifier	      fixed bin (17) unal,
 13    30 	       3 pad	      bit (18) unal,
 13    31 	       3 value_ptr	      ptr unal;
 13    32 
 13    33      dcl	   simple_typed_vector_ptr
 13    34 			      ptr;
 13    35      dcl	   stv_number_of_dimensions
 13    36 			      fixed bin (17);
 13    37 
 13    38      dcl	   general_typed_vector_ptr
 13    39 			      ptr;
 13    40      dcl	   gtv_number_of_dimensions
 13    41 			      fixed bin (17);
 13    42 
 13    43      dcl	   (
 13    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
 13    45 			      init (1),		/* value_ptr was aligned. */
 13    46 	   GENERAL_TYPED_VECTOR_TYPE
 13    47 			      init (2),
 13    48 	   SIMPLE_TYPED_VECTOR_TYPE
 13    49 			      init (3)
 13    50 	   )		      fixed bin (17) internal static options (constant);
 13    51 
 13    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
      636 
      637 
      638      end mrds_dsl_search;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1315.0  mrds_dsl_search.pl1               >special_ldd>install>MR12.2-1073>mrds_dsl_search.pl1
612          1    08/01/88  1300.0  mrds_dbcb.incl.pl1                >special_ldd>install>MR12.2-1073>mrds_dbcb.incl.pl1
614          2    10/14/83  1609.1  mrds_search_ops.incl.pl1          >ldd>include>mrds_search_ops.incl.pl1
616          3    10/14/83  1609.0  mrds_tuple_info.incl.pl1          >ldd>include>mrds_tuple_info.incl.pl1
618          4    10/14/83  1608.9  mrds_search_vars.incl.pl1         >ldd>include>mrds_search_vars.incl.pl1
620          5    10/14/83  1609.1  mdbm_rtrv_info.incl.pl1           >ldd>include>mdbm_rtrv_info.incl.pl1
622          6    10/14/83  1609.1  mrds_range.incl.pl1               >ldd>include>mrds_range.incl.pl1
624          7    10/14/83  1609.1  mdbm_rm_rel_info.incl.pl1         >ldd>include>mdbm_rm_rel_info.incl.pl1
626          8    10/14/83  1608.6  mdbm_descriptor.incl.pl1          >ldd>include>mdbm_descriptor.incl.pl1
628          9    10/14/83  1608.6  mdbm_ind_sel_info.incl.pl1        >ldd>include>mdbm_ind_sel_info.incl.pl1
630         10    10/14/83  1608.6  mdbm_seg_area.incl.pl1            >ldd>include>mdbm_seg_area.incl.pl1
632         11    10/14/83  1608.6  mrds_select_area.incl.pl1         >ldd>include>mrds_select_area.incl.pl1
634         12    10/14/83  1609.0  mrds_debug_names.incl.pl1         >ldd>include>mrds_debug_names.incl.pl1
636         13    10/14/83  1609.1  vu_typed_vector.incl.pl1          >ldd>include>vu_typed_vector.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CHAR_VAR                               constant        fixed bin(5,0)           initial dcl 528 ref 376
addr                                                   builtin function         dcl 572 ref 376 391 391 391 391 394 394 394 394 400
                                                                                  400 425 425 443
area_ptr                               parameter       pointer                  dcl 594 set ref 18 383* 425*
b36                                    based           bit(36)                  packed unaligned dcl 545 set ref 452*
bit_move                               based           bit(1)                   level 2 packed packed unaligned dcl 2-98 ref 372
caller_name                     000006 constant        char(32)                 initial packed unaligned dcl 603 set ref 394*
cd                                     parameter       fixed bin(35,0)          dcl 485 ref 481 487 487 487 494
cleanup                         000136 stack reference condition                dcl 581 ref 333
code                      2            based           fixed bin(17,0)          array level 3 in structure "search_ops" dcl 2-66
                                                                                  in procedure "mrds_dsl_search" ref 341
code                                   parameter       fixed bin(35,0)          dcl 524 in procedure "mrds_dsl_search" set ref 18
                                                                                  461* 466* 494*
continue                        000016 constant        char(1)                  initial packed unaligned dcl 601 set ref 394*
current_flag            106(01)        based           bit(1)                   level 3 packed packed unaligned dcl 1-142 ref 424
cvla_ptr                  6            based           pointer                  level 2 dcl 2-129 set ref 425*
d_ptr                           000106 automatic       pointer                  initial dcl 534 set ref 534*
dap                       4     000156 automatic       pointer                  initial level 2 dcl 608 set ref 608*
data                                   based           structure                level 2 dcl 1-142
data_ptrs                       000126 automatic       pointer                  initial array dcl 551 set ref 551*
dbcb                                   based           structure                level 1 dcl 1-142
dbcb_data                              based           structure                level 1 unaligned dcl 1-148
dbcb_ptr                               parameter       pointer                  dcl 1-146 set ref 18 325 334 335 336 337 338 424
                                                                                  425* 471
dbi                     114            based           fixed bin(35,0)          level 3 dcl 1-142 ref 325
dbi_pic                         000126 automatic       picture(3)               packed unaligned dcl 563 set ref 325* 326
descriptor                             based           structure                level 1 unaligned dcl 8-6
dimension                 1            based           structure                array level 2 packed packed unaligned dcl 13-17
display_tuples                  000124 automatic       bit(1)                   packed unaligned dcl 542 set ref 328* 442
err_xfer                  5            based           fixed bin(17,0)          array level 3 dcl 2-66 ref 437 490
error_table_$no_record          002012 external static fixed bin(35,0)          dcl 566 ref 434 487
es_ptr                          000110 automatic       pointer                  initial dcl 534 set ref 534*
expr                      0(03)        based           bit(1)                   level 2 packed packed unaligned dcl 2-98 ref 382
extr_attr                 0(05)        based           bit(1)                   level 2 packed packed unaligned dcl 2-98 ref 360
fb35u                                  based           fixed bin(35,0)          packed unaligned dcl 546 ref 375
first_seq_io                           based           bit(1)                   array level 3 packed packed unaligned dcl 4-3 set
                                                                                  ref 348*
free_array                2            based           bit(1)                   level 2 packed packed unaligned dcl 554 set ref 510
                                                                                  514*
fwd_thd                                based           pointer                  level 2 in structure "tid_list" dcl 554 in procedure
                                                                                  "mrds_dsl_search" ref 509
fwd_thd                  16            based           pointer                  level 2 in structure "move_info" dcl 2-98
                                                                                  in procedure "mrds_dsl_search" ref 409
good_xfer                 4            based           fixed bin(17,0)          array level 3 dcl 2-66 ref 349 417 454 460 478
i                               000102 automatic       fixed bin(17,0)          dcl 530 set ref 413* 414* 439* 440* 473* 475*
ic                                     based           fixed bin(17,0)          level 2 dcl 2-66 set ref 341 345 349* 349 349 354
                                                                                  355 414 417* 417 417 422 425 425 425 437* 437 437
                                                                                  440 443 449 449 454* 454 454 460* 460 460 471 478*
                                                                                  478 478 490* 490 490
icode                           000100 automatic       fixed bin(35,0)          dcl 524 set ref 332* 383* 387 387* 391* 393 394*
                                                                                  402* 424* 425* 434 434 434 434* 445* 451 451* 513*
idl_ptr                                based           pointer                  array level 3 dcl 6-5 set ref 425*
info                                   based           structure                array level 2 dcl 4-3 set ref 425 425 443
info_ptr                        000150 automatic       pointer                  initial dcl 602 in procedure "mrds_dsl_search" set
                                                                                  ref 394* 602*
info_ptr                  6            based           pointer                  array level 3 in structure "search_ops" dcl 2-66
                                                                                  in procedure "mrds_dsl_search" ref 354 422 471
internal_static_area            000010 internal static area(1024)               dcl 599 ref 516
ioa_                            002022 constant        entry                    external dcl 583 ref 449 452
iox_$user_output                002024 external static pointer                  dcl 584 set ref 445*
j                               000103 automatic       fixed bin(17,0)          dcl 530 set ref 474* 475*
mdb_display_data_value$ptr      002050 constant        entry                    external dcl 606 ref 400
mdb_display_tuple_$data         002026 constant        entry                    external dcl 585 ref 445
mi_ptr                          000166 automatic       pointer                  dcl 2-120 set ref 354* 358 360 360 360 360 365 365
                                                                                  372 372 372 372 372 374 375 376 379 380 382 383
                                                                                  383 383 390 391 391 391 391 391 394 394 394 394
                                                                                  400 400 409* 409
model_area_ptr                  000212 automatic       pointer                  initial dcl 10-18 set ref 10-18*
model_seg_ptr                   000210 automatic       pointer                  initial dcl 10-13 set ref 10-13*
move_info                              based           structure                level 1 dcl 2-98
mrds_data_$max_attributes       002040 external static fixed bin(35,0)          dcl 596 ref 425 425 425 425 425 425 449 449 449 449
mrds_data_$max_id_len           002016 external static fixed bin(35,0)          dcl 566 ref 425 425 425 425 425 425 425 425 425 449
                                                                                  449 449 449 449 449
mrds_data_$max_tup_var          002010 external static fixed bin(35,0)          dcl 552 ref 551
mrds_data_$temp_seg_name        002042 external static char(23)                 packed unaligned dcl 597 ref 326
mrds_dsl_eval_expr              002030 constant        entry                    external dcl 586 ref 383
mrds_error_$no_tuple            002014 external static fixed bin(35,0)          dcl 566 ref 434 487
mrds_error_$tuple_not_found     002020 external static fixed bin(35,0)          dcl 566 ref 466 487
mu_convert$convert_data         002032 constant        entry                    external dcl 587 ref 391
mu_display_descriptor           002046 constant        entry                    external dcl 605 ref 394 394
mu_retrieve                     002034 constant        entry                    external dcl 588 ref 425
mu_temp_segments$free_temp_segment
                                002036 constant        entry                    external dcl 589 ref 513
must_move                       000125 automatic       bit(1)                   packed unaligned dcl 542 set ref 365* 368* 369* 370
name                      2            based           char                     array level 3 dcl 6-5 ref 425 449 449
new_val                   1            based           bit(1)                   array level 2 packed packed unaligned dcl 4-3 set
                                                                                  ref 365 414* 440* 475*
nids                      6            based           fixed bin(35,0)          level 2 dcl 554 ref 511
ntids                                  based           fixed bin(17,0)          array level 3 dcl 4-3 set ref 347*
null                                                   builtin function         dcl 572 ref 327 358 534 534 534 534 534 534 534 551
                                                                                  602 608 10-13 10-18 11-6 11-10 505 508 520
num_dims                        000206 automatic       fixed bin(17,0)          initial dcl 8-20 set ref 8-20*
nvars                                  based           fixed bin(17,0)          level 2 dcl 4-3 ref 346 346 347 347 348 348 356 356
                                                                                  365 365 383 383 413 414 414 425 425 425 425 439
                                                                                  440 440 443 443 473 474 475 475
op                        2            based           structure                array level 2 dcl 2-66
opnd1p                          000112 automatic       pointer                  initial dcl 534 set ref 534*
opnd2p                          000114 automatic       pointer                  initial dcl 534 set ref 534*
pointer                                                builtin function         dcl 572 ref 513 513
range                                  based           structure                level 1 dcl 6-5
range_ptr                       000202 automatic       pointer                  dcl 6-23 in procedure "mrds_dsl_search" set ref 338*
                                                                                  425 425 425 449 449
range_ptr                 2            based           pointer                  level 3 in structure "dbcb" dcl 1-142 in procedure
                                                                                  "mrds_dsl_search" ref 338
relation_search_specification_ptr
                          4            based           pointer                  level 2 dcl 2-129 set ref 425*
reset_info                      000156 automatic       structure                level 1 dcl 608
return_value                    000152 automatic       fixed bin(35,0)          initial dcl 604 set ref 394* 604*
ri_ptr                                 based           pointer                  array level 3 in structure "search_vars" dcl 4-3
                                                                                  in procedure "mrds_dsl_search" set ref 346 356
                                                                                  383*
ri_ptr                                 based           pointer                  level 2 in structure "rtrv_info" dcl 5-27
                                                                                  in procedure "mrds_dsl_search" ref 444
rmri_ptr                        000204 automatic       pointer                  dcl 7-156 set ref 346* 356*
rtrim                                                  builtin function         dcl 572 ref 449 449
rtrv_info                              based           structure                level 1 dcl 5-27
s_desc                   12            based           bit(36)                  level 2 dcl 2-98 set ref 376 391 391 394 394 400 400
s_ptr                     4            based           pointer                  level 2 dcl 2-98 set ref 360* 372 375 380 383* 390
sbit_len                 10            based           fixed bin(35,0)          level 2 dcl 2-98 ref 372
search_ops                             based           structure                level 1 dcl 2-66
search_vars                            based           structure                level 1 dcl 4-3
select_area_ptr          36            based           pointer                  level 3 in structure "dbcb" dcl 1-142 in procedure
                                                                                  "mrds_dsl_search" ref 337
select_area_ptr                 000216 automatic       pointer                  initial dcl 11-10 in procedure "mrds_dsl_search" set
                                                                                  ref 337* 11-10*
select_area_struct_ptr          000214 automatic       pointer                  initial dcl 11-6 set ref 11-6*
select_info                            based           structure                level 1 dcl 2-129
seli_ptr                        000170 automatic       pointer                  dcl 2-135 set ref 422* 425 425 425 425 425 425 445
                                                                                  452
simple_typed_vector                    based           structure                level 1 packed packed unaligned dcl 13-17
so_ptr                   10            based           pointer                  level 3 in structure "dbcb" dcl 1-142 in procedure
                                                                                  "mrds_dsl_search" ref 335
so_ptr                          000164 automatic       pointer                  dcl 2-82 in procedure "mrds_dsl_search" set ref 335*
                                                                                  341 341 345 345 349 349 349 349 354 354 355 355
                                                                                  414 414 417 417 417 417 422 422 425 425 425 425
                                                                                  425 425 437 437 437 437 440 440 443 443 449 449
                                                                                  449 449 454 454 454 454 460 460 460 460 471 471
                                                                                  478 478 478 478 490 490 490 490
src_string                             based           bit                      packed unaligned dcl 547 ref 372
stack_ptr                       000116 automatic       pointer                  initial dcl 534 set ref 327* 507 520* 534*
stv_ptr                                based           pointer                  array level 3 dcl 6-5 set ref 425*
sub_err_                        002044 constant        entry                    external dcl 600 ref 394
sv_ptr                    6            based           pointer                  level 3 in structure "dbcb" dcl 1-142 in procedure
                                                                                  "mrds_dsl_search" set ref 334 471*
sv_ptr                          000174 automatic       pointer                  dcl 4-9 in procedure "mrds_dsl_search" set ref 334*
                                                                                  346 347 348 356 365 383 413 414 425 425 439 440
                                                                                  443 471* 473 474 475
t_desc                   13            based           bit(36)                  level 2 dcl 2-98 set ref 391 391 394 394
t_ptr                     6            based           pointer                  level 2 dcl 2-98 set ref 372 379 391*
ta_nids                         000176 automatic       fixed bin(17,0)          dcl 5-41 set ref 511*
ta_ptr                   10            based           pointer                  level 2 in structure "tid_list" dcl 554 in procedure
                                                                                  "mrds_dsl_search" ref 512
ta_ptr                          000200 automatic       pointer                  dcl 5-42 in procedure "mrds_dsl_search" set ref 512*
                                                                                  513 513
targ_string                            based           bit                      packed unaligned dcl 548 set ref 372*
tbit_len                 11            based           fixed bin(35,0)          level 2 dcl 2-98 ref 372
temp_rmri_ptr                   000146 automatic       pointer                  dcl 591 set ref 444* 445*
temp_rti_ptr                    000144 automatic       pointer                  dcl 591 set ref 443* 444
temp_s_ptr                      000154 automatic       pointer                  dcl 607 set ref 390* 391* 400*
temp_seg_name                   000127 automatic       char(26)                 packed unaligned dcl 564 set ref 326* 513*
temp_tl                         000100 automatic       pointer                  initial dcl 505 set ref 505* 509* 517
ti_ptr                          000172 automatic       pointer                  dcl 3-17 in procedure "mrds_dsl_search" set ref 336*
                                                                                  360 383 425 445
ti_ptr                   12            based           pointer                  level 3 in structure "dbcb" dcl 1-142 in procedure
                                                                                  "mrds_dsl_search" ref 336
tid_list                               based           structure                level 1 dcl 554 set ref 516
tid_ptr                   2            based           pointer                  level 2 dcl 2-129 set ref 425* 452
tl_ptr                          000120 automatic       pointer                  initial dcl 534 set ref 507* 508 509 510 511 512 514
                                                                                  516 517* 534*
true_len                        000101 automatic       fixed bin(35,0)          dcl 524 set ref 375* 376* 376 378* 378 380 380
true_string                            based           bit                      packed unaligned dcl 549 set ref 380* 380
ts_ptr                          000122 automatic       pointer                  initial dcl 534 set ref 379* 380 534*
tup_var                   2            based           structure                array level 2 dcl 6-5
tuple                     2            based           structure                array level 2 dcl 3-10
tuple_attr_index          3            based           fixed bin(17,0)          level 2 dcl 2-98 ref 360
tuple_info                             based           structure                level 1 dcl 3-10
tuple_info_index                       based           fixed bin(17,0)          level 2 dcl 2-129 ref 425 425 425 445
tuple_ptr                 2            based           pointer                  array level 3 dcl 3-10 set ref 360 383* 425* 445*
tuple_var_index           2            based           fixed bin(17,0)          level 2 dcl 2-98 ref 360 383
type                      0(01)        based           fixed bin(6,0)           level 2 packed packed unsigned unaligned dcl 8-6 ref
                                                                                  376
value_ptr                 1            based           pointer                  array level 3 packed packed unaligned dcl 13-17 ref
                                                                                  360
var_ind                   1            based           fixed bin(17,0)          level 2 in structure "move_info" dcl 2-98
                                                                                  in procedure "mrds_dsl_search" ref 365 365 383
var_ind                   3            based           fixed bin(17,0)          array level 3 in structure "search_ops" dcl 2-66
                                                                                  in procedure "mrds_dsl_search" ref 345 355 414 425
                                                                                  425 425 440 443 449 449
var_move                  0(01)        based           bit(1)                   level 2 packed packed unaligned dcl 2-98 ref 374
vi                              000104 automatic       fixed bin(17,0)          dcl 530 set ref 345* 346 347 348 355* 356 365
words                           000156 automatic       fixed bin(35,0)          initial array level 2 dcl 608 set ref 608* 608* 608*
                                                                                  608*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 13-43
INIT                                   internal static fixed bin(17,0)          initial dcl 2-85
MOVE                                   internal static fixed bin(17,0)          initial dcl 2-85
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 13-43
PICKUP_SVP                             internal static fixed bin(17,0)          initial dcl 2-85
RETNUL                                 internal static fixed bin(17,0)          initial dcl 2-85
RETVAL                                 internal static fixed bin(17,0)          initial dcl 2-85
SEL                                    internal static fixed bin(17,0)          initial dcl 2-85
SIMPLE_TYPED_VECTOR_TYPE               internal static fixed bin(17,0)          initial dcl 13-43
db_mrds_dsl_close                      defined         bit(9)                   packed unaligned dcl 12-62
db_mrds_dsl_eval_expr                  defined         bit(9)                   packed unaligned dcl 12-62
db_mrds_dsl_gen_srch_prog              defined         bit(9)                   packed unaligned dcl 12-62
db_mrds_dsl_get_token                  defined         bit(9)                   packed unaligned dcl 12-62
db_mrds_dsl_init_res                   defined         bit(9)                   packed unaligned dcl 12-62
db_mrds_dsl_open                       defined         bit(9)                   packed unaligned dcl 12-62
db_mrds_dsl_optimize                   defined         bit(9)                   packed unaligned dcl 12-62
db_mrds_dsl_permute                    defined         bit(9)                   packed unaligned dcl 12-62
db_mrds_dsl_search                     defined         bit(9)                   packed unaligned dcl 12-62
db_mrds_dsl_set_fscope                 defined         bit(9)                   packed unaligned dcl 12-62
db_mrds_dsl_translate                  defined         bit(9)                   packed unaligned dcl 12-62
db_mrds_dsl_where_clause               defined         bit(9)                   packed unaligned dcl 12-62
db_mrds_rst_dmdm                       defined         bit(9)                   packed unaligned dcl 12-62
db_mu_concurrency_control              defined         bit(9)                   packed unaligned dcl 12-62
db_mu_open_iocb_manager                defined         bit(9)                   packed unaligned dcl 12-62
db_mu_open_name_manager                defined         bit(9)                   packed unaligned dcl 12-62
db_mu_retrieve                         defined         bit(9)                   packed unaligned dcl 12-62
db_mu_sec_get_tid                      defined         bit(9)                   packed unaligned dcl 12-62
db_mu_sec_get_tuple                    defined         bit(9)                   packed unaligned dcl 12-62
db_mu_sec_init_res                     defined         bit(9)                   packed unaligned dcl 12-62
db_mus_mod_ubtup                       defined         bit(9)                   packed unaligned dcl 12-62
desc_ptr                               automatic       pointer                  dcl 8-19
fixed                                                  builtin function         dcl 572
general_typed_vector                   based           structure                level 1 packed packed unaligned dcl 13-24
general_typed_vector_ptr               automatic       pointer                  dcl 13-38
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 13-40
ind_sel_info                           based           structure                level 1 dcl 9-5
isi_ptr                                automatic       pointer                  dcl 9-16
mi_nitems_init                         automatic       fixed bin(17,0)          dcl 2-121
model_area                             based           area                     dcl 10-16
model_seg                              based           structure                level 1 dcl 10-9
module                                 internal static structure                level 1 unaligned dcl 12-91
mrds_debug_$switch                     external static bit(9)                   array packed unaligned dcl 12-135
natts_init                             automatic       fixed bin(17,0)          dcl 7-157
nkey_attr_init                         automatic       fixed bin(17,0)          dcl 7-157
nvar_atts_init                         automatic       fixed bin(17,0)          dcl 7-157
rel                                                    builtin function         dcl 572
rm_rel_info                            based           structure                level 1 dcl 7-119
rti_ptr                                automatic       pointer                  dcl 5-37
select_area                            based           area                     dcl 11-8
select_area_struct                     based           structure                level 1 dcl 11-2
simple_typed_vector_ptr                automatic       pointer                  dcl 13-33
size                                                   builtin function         dcl 10-20
so_nops_init                           automatic       fixed bin(17,0)          dcl 2-83
stv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 13-35
sv_nvars_init                          automatic       fixed bin(17,0)          dcl 4-10
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 566
ti_ntuples_init                        automatic       fixed bin(17,0)          dcl 3-18
tid_array                              based           bit(36)                  array dcl 5-39

NAMES DECLARED BY EXPLICIT CONTEXT.
error                           001563 constant        entry                    internal dcl 481 ref 387 402 434 451
exit                            001502 constant        label                    dcl 462 ref 467 496
mrds_dsl_search                 000105 constant        entry                    external dcl 18
next                            000247 constant        label                    dcl 340 set ref 350 418 456 479 491
operation                       000000 constant        label                    array(6) dcl 343 ref 341
tidy_up                         001613 constant        entry                    internal dcl 501 ref 333 495

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2166        4240    1711        2176
Length      4740    1711      2052         463     254        2000

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_dsl_search                     322 external procedure  is an external procedure.  
on unit on line 333                  64 on unit               
error                                   internal procedure  shares stack frame of external procedure mrds_dsl_search.  
tidy_up                              82 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 internal_static_area        mrds_dsl_search

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_dsl_search          000100 icode                       mrds_dsl_search
                         000101 true_len                    mrds_dsl_search
                         000102 i                           mrds_dsl_search
                         000103 j                           mrds_dsl_search
                         000104 vi                          mrds_dsl_search
                         000106 d_ptr                       mrds_dsl_search
                         000110 es_ptr                      mrds_dsl_search
                         000112 opnd1p                      mrds_dsl_search
                         000114 opnd2p                      mrds_dsl_search
                         000116 stack_ptr                   mrds_dsl_search
                         000120 tl_ptr                      mrds_dsl_search
                         000122 ts_ptr                      mrds_dsl_search
                         000124 display_tuples              mrds_dsl_search
                         000125 must_move                   mrds_dsl_search
                         000126 data_ptrs                   mrds_dsl_search
                         000126 dbi_pic                     mrds_dsl_search
                         000127 temp_seg_name               mrds_dsl_search
                         000144 temp_rti_ptr                mrds_dsl_search
                         000146 temp_rmri_ptr               mrds_dsl_search
                         000150 info_ptr                    mrds_dsl_search
                         000152 return_value                mrds_dsl_search
                         000154 temp_s_ptr                  mrds_dsl_search
                         000156 reset_info                  mrds_dsl_search
                         000164 so_ptr                      mrds_dsl_search
                         000166 mi_ptr                      mrds_dsl_search
                         000170 seli_ptr                    mrds_dsl_search
                         000172 ti_ptr                      mrds_dsl_search
                         000174 sv_ptr                      mrds_dsl_search
                         000176 ta_nids                     mrds_dsl_search
                         000200 ta_ptr                      mrds_dsl_search
                         000202 range_ptr                   mrds_dsl_search
                         000204 rmri_ptr                    mrds_dsl_search
                         000206 num_dims                    mrds_dsl_search
                         000210 model_seg_ptr               mrds_dsl_search
                         000212 model_area_ptr              mrds_dsl_search
                         000214 select_area_struct_ptr      mrds_dsl_search
                         000216 select_area_ptr             mrds_dsl_search
tidy_up                  000100 temp_tl                     tidy_up

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac
alloc_auto_adj      mpfx2               enable_op           shorten_stack       ext_entry           int_entry
op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_                          mdb_display_data_value$ptr    mdb_display_tuple_$data       mrds_dsl_eval_expr
mu_convert$convert_data       mu_display_descriptor         mu_retrieve
mu_temp_segments$free_temp_segment                          sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$no_record        iox_$user_output              mrds_data_$max_attributes     mrds_data_$max_id_len
mrds_data_$max_tup_var        mrds_data_$temp_seg_name      mrds_error_$no_tuple          mrds_error_$tuple_not_found




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     18 000101       534 000112       551 000122       602 000137       604 000140       608 000141    8   20 000157
10   13 000160   10   18 000161   11    6 000162   11   10 000163       325 000164       326 000177       328 000206
    332 000207       333 000210       334 000232       335 000237       336 000241       337 000243       338 000245
    340 000247       341 000250       343 000256       345 000257       346 000261       347 000301       348 000306
    349 000323       350 000327       352 000330       354 000331       355 000333       356 000335       358 000354
    360 000360       365 000377       368 000415       369 000417       370 000421       372 000423       374 000436
    375 000441       376 000450       378 000462       379 000466       380 000470       381 000473       382 000474
    383 000477       387 000541       388 000545       390 000546       391 000550       393 000573       394 000575
    400 000726       402 000742       409 000744       411 000747       413 000750       414 000757       415 000773
    417 000775       418 001002       420 001003       422 001004       424 001006       425 001016       434 001204
    437 001217       439 001225       440 001235       441 001251       442 001253       443 001255       444 001300
    445 001302       449 001322       451 001442       452 001447       454 001467       456 001474       458 001475
    460 001476       461 001500       462 001502       463 001503       465 001504       466 001505       467 001511
    469 001512       471 001513       473 001521       474 001531       475 001541       476 001551       477 001553
    478 001555       479 001562       481 001563       487 001565       490 001575       491 001602       494 001603
    495 001605       496 001611       501 001612       505 001620       507 001622       508 001626       509 001633
    510 001636       511 001641       512 001643       513 001645       514 001670       516 001673       517 001675
    518 001700       520 001701       522 001703


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
