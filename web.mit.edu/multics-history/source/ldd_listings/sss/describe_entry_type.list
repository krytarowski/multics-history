	COMPILATION LISTING OF SEGMENT describe_entry_type
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 05/31/88  1405.8 mst Tue
	    Options: optimize map

        1 /****^  **************************************************************
        2*        *                                                            *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                   *
        4*        *                                                            *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984    *
        6*        *                                                            *
        7*        * Copyright, (C) Massachusetts Institute of Technology, 1983 *
        8*        *                                                            *
        9*        ************************************************************** */
       10 
       11 /* format: style3 */
       12 
       13 describe_entry_type:
       14 dset:
       15      procedure () options (variable);
       16 
       17 /* describe_entry_type: Command/AF to show information about an entry type.
       18*   list_entry_type: Command/AF to list all suffix_XXX_ that can be found by search rules.
       19*
       20*   Jay Pattin 7/2/83 as describe_object_type
       21*   1984.03.20 MAP to use fs_util_
       22*   1984.07.23 MAP to become "entry " instead of "object"
       23*   1984.11.08 MAP general cleanup to prepare for installation
       24**/
       25 
       26 
       27 /****^  HISTORY COMMENTS:
       28*  1) change(88-01-01,Gilcrease), approve(88-05-05,MCR7835),
       29*     audit(88-05-05,Dupuis), install(88-05-31,MR12.2-1049):
       30*               Correct to allow dm_file, and improve output.
       31*                                                   END HISTORY COMMENTS */
       32 
       33 
       34 declare	active_function	bit (1) aligned,
       35 	(all, attributes, brief, default, info_path, info_path_given, name,
       36 	 plural, modes, xacl, switches, explicit_switches)
       37 			bit (1) aligned,
       38 	area_ptr		ptr,
       39 	arg_count		fixed bin,
       40 	arg_idx		fixed bin,
       41 	arg_len		fixed bin (21),
       42 	arg_ptr		ptr,
       43 	arg		char (arg_len) based (arg_ptr),
       44 	buffer		char (128) varying,
       45 	code		fixed bin (35),
       46 	complain		entry options (variable) variable,
       47 	dir		char (168),
       48 	display_name	char (32),
       49 	(high, low)	fixed bin,
       50 	looking_for_types	bit (1) aligned,
       51 	(idx, name_idx, rule)
       52 			fixed bin,
       53 	entry		char (32),
       54 	ref_name		char (32),
       55 	ret_len		fixed bin (21),
       56 	ret_ptr		ptr,
       57 	ret_str		char (ret_len) varying based (ret_ptr),
       58 	switch_name	char (32) aligned,
       59 	type		char (32),
       60 	type_count	fixed bin,
       61 	type_name		(100) char (32),
       62 	type_no		fixed bin,
       63 	whoami		char (32);
       64 
       65 declare	1 si		aligned like suffix_info;
       66 declare	1 search_rules	aligned,
       67 	  2 number	fixed bin,
       68 	  2 names		(20) char (168) aligned;
       69 
       70 declare	ATTRIBUTE_NAMES	(8) char (32) varying internal static options (constant)
       71 			init ("names", "ACL", "ring brackets", "max length", "copy switch", "safety switch",
       72 			"dumper switches", "entry bound");
       73 declare  THIRTY_TWO_SPACES    char (32) internal static options (constant)
       74 			init ((32)" ");
       75 
       76 declare	(addr, baseptr, hbound, length, ltrim, max, null, reverse, rtrim, search, string, substr, sum)
       77 			builtin,
       78 	cleanup		condition;
       79 
       80 declare	(
       81 	error_table_$bad_arg,
       82 	error_table_$badopt,
       83 	error_table_$inconsistent,
       84 	error_table_$noarg,
       85 	error_table_$nomatch,
       86 	error_table_$not_act_fnc
       87 	)		fixed bin (35) external;
       88 
       89 declare	(
       90 	active_fnc_err_,
       91 	active_fnc_err_$suppress_name,
       92 	com_err_,
       93 	com_err_$suppress_name
       94 	)		entry options (variable),
       95 	cu_$af_return_arg	entry (fixed bin, ptr, fixed bin (21), fixed bin (35)),
       96 	cu_$arg_ptr	entry (fixed bin, ptr, fixed bin (21), fixed bin (35)),
       97 	expand_pathname_	entry (char (*), char (*), char (*), fixed bin (35)),
       98 	get_system_free_area_
       99 			entry returns (ptr),
      100 	get_wdir_		entry returns (char (168)),
      101 	hcs_$fs_get_ref_name
      102 			entry (ptr, fixed bin, char (*), fixed bin (35)),
      103 	hcs_$get_search_rules
      104 			entry (ptr),
      105 	hcs_$high_low_seg_count
      106 			entry (fixed bin, fixed bin),
      107 	hcs_$star_	entry (char (*), char (*), fixed bin (2), ptr, fixed bin, ptr, ptr, fixed bin (35)),
      108 	hcs_$status_minf	entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24), fixed bin (35)),
      109 	ioa_		entry options (variable),
      110 	fs_util_$list_switches_for_type
      111 			entry (char (*), char (*), ptr, ptr, fixed bin (35)),
      112 	fs_util_$suffix_info_for_type
      113 			entry (char (*), ptr, fixed bin (35)),
      114 	fs_util_$make_entry_for_type
      115 			entry (char (*), char (*), entry, fixed bin (35)),
      116 	requote_string_	entry (char (*) aligned) returns (char (*)),
      117 	search_paths_$find_dir
      118 			entry (char (*), ptr, char (*), char (*), char (*), fixed bin (35));
      119 
  1     1 /* BEGIN INCLUDE FILE: suffix_info.incl.pl1 */
  1     2 /* format: style3,indcomtxt,idind30 */
  1     3 /**** Jay Pattin 2/13/83
  1     4*      M. Pandolf 1984.11.30 to set FS_OBJECT_TYPE_MSF to -multisegment_file
  1     5*
  1     6*      The include file copy_flags.incl.pl1 must be included in any program using this include file.
  1     7*
  1     8*      This structure is returned by the suffix_XXX_$suffix_info subroutines */
  1     9 
  1    10 declare   suffix_info_ptr               ptr;
  1    11 
  1    12 declare   1 suffix_info                 aligned based (suffix_info_ptr),
  1    13             2 version                   char (8),
  1    14             2 type                      char (32) unaligned,
  1    15             2 type_name                 char (32) unaligned,          /* Singular name of the object type, e.g. "mailbox" */
  1    16             2 plural_name               char (32) unaligned,          /* Plural of above, e.g. "mailboxes" */
  1    17             2 flags                     unaligned,
  1    18               3 standard_object         bit (1) unaligned,  /* ON if not an extended object (no suffix_XXX_) */
  1    19               3 extended_acl            bit (1) unaligned,  /* ON if uses extended ACLs, off if regular ACLs */
  1    20               3 has_switches            bit (1) unaligned,  /* ON if supports switches for objects */
  1    21               3 mbz1                    bit (33) unaligned,
  1    22             2 modes                     char (36),          /* correspondence between bits and chars for extended modes */
  1    23             2 max_mode_len              fixed bin,          /* maximum number of modes on an object */
  1    24             2 num_ring_brackets         fixed bin,          /* number of ring brackets on object */
  1    25             2 copy_flags                like copy_flags,    /* See copy_flags.incl.pl1 */
  1    26             2 info_pathname             char (168) unaligned;
  1    27                                                             /* pathname of info segment containing more info */
  1    28 
  1    29 declare   SUFFIX_INFO_VERSION_1         char (8) static options (constant) init ("SUFFIX01");
  1    30 
  1    31 /* This information is returned by the suffix_XXX_$list_switches subroutines */
  1    32 
  1    33 declare   switch_list_ptr               ptr,
  1    34           alloc_switch_count            fixed bin,
  1    35           alloc_switch_name_count       fixed bin;
  1    36 
  1    37 declare   1 switch_list                 aligned based (switch_list_ptr),
  1    38             2 version                   char (8),           /* SWITCH_LIST_VERSION_1 */
  1    39             2 switch_count              fixed bin,          /* total number of switches */
  1    40             2 switch_name_count         fixed bin,          /* total number of names */
  1    41             2 switches                  (alloc_switch_count refer (switch_list.switch_count)),
  1    42               3 name_index              fixed bin,          /* index of first name for this switch */
  1    43               3 name_count              fixed bin,          /* number of names for this switch */
  1    44               3 default_value           bit (1) aligned,    /* default setting for this switch */
  1    45               3 mbz1                    bit (36) aligned,   /* reserved for future use */
  1    46             2 names                     (alloc_switch_name_count refer (switch_list.switch_name_count)) char (32);
  1    47 
  1    48 declare   SWITCH_LIST_VERSION_1         char (8) static options (constant) init ("SWLIST01");
  1    49 
  1    50 declare   (
  1    51           FS_OBJECT_TYPE_SEGMENT        init ("-segment"),
  1    52           FS_OBJECT_TYPE_DIRECTORY      init ("-directory"),
  1    53           FS_OBJECT_TYPE_MSF            init ("-multisegment_file"),
  1    54           FS_OBJECT_TYPE_DM_FILE        init ("-dm_file"),
  1    55           FS_OBJECT_TYPE_LINK           init ("-link")
  1    56           )                             char (32) unaligned int static options (constant);
  1    57 
  1    58 /* END INCLUDE FILE: suffix_info.incl.pl1 */
      120 
      121 
  2     1 /* BEGIN INCLUDE FILE:  copy_flags.incl.pl1 */
  2     2 
  2     3 /* Flags for attributes that should/may be copied by the copy_ subroutine. This include file is
  2     4*   required by suffix_info.incl.pl1 and copy_options.incl.pl1
  2     5*
  2     6*   Jay Pattin 6/23/83 */
  2     7 
  2     8 declare   1 copy_flags                  aligned based,      /* ON means that this attribute may be copied by copy_ */
  2     9           2 names                       bit (1) unaligned,
  2    10           2 acl                         bit (1) unaligned,
  2    11           2 ring_brackets               bit (1) unaligned,
  2    12           2 max_length                  bit (1) unaligned,
  2    13           2 copy_switch                 bit (1) unaligned,
  2    14           2 safety_switch               bit (1) unaligned,
  2    15           2 dumper_switches             bit (1) unaligned,
  2    16           2 entry_bound                 bit (1) unaligned,  /* only for vanilla object segments */
  2    17           2 extend                      bit (1) unaligned,  /* copy_ may append to end of existing object */
  2    18           2 update                      bit (1) unaligned,  /* copy_ may replace contents of existing object */
  2    19           2 mbz                         bit (26) unaligned;
  2    20 
  2    21 /* END INCLUDE FILE:  copy_flags.incl.pl1 */
      122 
      123 
  3     1 /* BEGIN INCLUDE FILE . . . star_structures.incl.pl1 */
  3     2 
  3     3 /* This include file contains structures for the hcs_$star_,
  3     4*   hcs_$star_list_ and hcs_$star_dir_list_ entry points.
  3     5*
  3     6*   Written 23 October 1978 by Monte Davidoff.
  3     7*   Modified January 1979 by Michael R. Jordan to use unsigned and different pointers for different structures.
  3     8*   Modified June 1981 by C. Hornig to count link pathnames more efficiently.
  3     9**/
  3    10 
  3    11 /* automatic */
  3    12 
  3    13 declare  star_branch_count fixed binary;		/* hcs_$star_list_, hcs_$star_dir_list_: matching branch count */
  3    14 declare  star_entry_count fixed binary;			/* hcs_$star_: number of matching entries */
  3    15 declare  star_entry_ptr pointer;			/* hcs_$star_: pointer to array of entry information */
  3    16 declare  star_list_branch_ptr pointer;			/* hcs_$star_list_, hcs_$star_dir_list_: ptr to array of info */
  3    17 declare  star_link_count fixed binary;			/* hcs_$star_list_, hcs_$star_dir_list_: matching link count */
  3    18 declare  star_linkx fixed binary;			/* hcs_$star_list_, hcs_$star_dir_list_: index into star_links */
  3    19 declare  star_names_ptr pointer;			/* hcs_$star_: pointer to array of entry names */
  3    20 declare  star_list_names_ptr pointer;			/* hcs_$star_list_, hcs_$star_dir_list_: ptr to entry names */
  3    21 declare  star_select_sw fixed binary (3);		/* hcs_$star_list_, hcs_$star_dir_list_: what info to return */
  3    22 
  3    23 /* based */
  3    24 
  3    25 /* hcs_$star_ entry structure */
  3    26 
  3    27 declare 1 star_entries (star_entry_count) aligned based (star_entry_ptr),
  3    28         2 type fixed binary (2) unsigned unaligned,
  3    29 						/* storage system type */
  3    30         2 nnames fixed binary (16) unsigned unaligned,
  3    31 						/* number of names of entry that match star_name */
  3    32         2 nindex fixed binary (18) unsigned unaligned;
  3    33 						/* index of first name in star_names */
  3    34 
  3    35 /* hcs_$star_ name structure */
  3    36 
  3    37 declare  star_names (sum (star_entries (*).nnames)) char (32) based (star_names_ptr);
  3    38 
  3    39 /* hcs_$star_list_ branch structure */
  3    40 
  3    41 declare 1 star_list_branch (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
  3    42         2 type fixed binary (2) unsigned unaligned,
  3    43 						/* storage system type */
  3    44         2 nnames fixed binary (16) unsigned unaligned,
  3    45 						/* number of names of entry that match star_name */
  3    46         2 nindex fixed binary (18) unsigned unaligned,
  3    47 						/* index of first name in star_list_names */
  3    48         2 dtcm bit (36) unaligned,			/* date-time contents of branch were last modified */
  3    49         2 dtu bit (36) unaligned,			/* date-time branch was last used */
  3    50         2 mode bit (5) unaligned,			/* user's access mode to the branch */
  3    51         2 raw_mode bit (5) unaligned,			/* user's ACL access mode */
  3    52         2 master_dir bit (1) unaligned,			/* is branch a master directory */
  3    53         2 pad bit (7) unaligned,
  3    54         2 records fixed binary (18) unsigned unaligned;
  3    55 						/* records used by branch */
  3    56 
  3    57 /* hcs_$star_dir_list_ branch structure */
  3    58 
  3    59 declare 1 star_dir_list_branch (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
  3    60         2 type fixed binary (2) unsigned unaligned,
  3    61 						/* storage system type */
  3    62         2 nnames fixed binary (16) unsigned unaligned,
  3    63 						/* number of names of entry that match star_name */
  3    64         2 nindex fixed binary (18) unsigned unaligned,
  3    65 						/* index of first name in star_list_names */
  3    66         2 dtem bit (36) unaligned,			/* date-time directory entry of branch was last modified */
  3    67         2 pad bit (36) unaligned,
  3    68         2 mode bit (5) unaligned,			/* user's access mode to the branch */
  3    69         2 raw_mode bit (5) unaligned,			/* user's ACL access mode */
  3    70         2 master_dir bit (1) unaligned,			/* is branch a master directory */
  3    71         2 bit_count fixed binary (24) unaligned;
  3    72 						/* bit count of the branch */
  3    73 
  3    74 /* hcs_$star_list_ and hcs_$star_dir_list_ link structure */
  3    75 
  3    76 declare 1 star_links (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
  3    77         2 type fixed binary (2) unsigned unaligned,
  3    78 						/* storage system type */
  3    79         2 nnames fixed binary (16) unsigned unaligned,
  3    80 						/* number of names of entry that match star_name */
  3    81         2 nindex fixed binary (18) unsigned unaligned,
  3    82 						/* index of first name in star_list_names */
  3    83         2 dtem bit (36) unaligned,			/* date-time link was last modified */
  3    84         2 dtd bit (36) unaligned,			/* date-time the link was last dumped */
  3    85         2 pathname_len fixed binary (18) unsigned unaligned,
  3    86 						/* length of the pathname of the link */
  3    87         2 pathname_index fixed binary (18) unsigned unaligned;
  3    88 						/* index of start of pathname in star_list_names */
  3    89 
  3    90 /* hcs_$star_list_ and hcs_$star_dir_list_ name array */
  3    91 
  3    92 declare  star_list_names char (32) based (star_list_names_ptr)
  3    93 	dimension (star_links (star_branch_count + star_link_count).nindex
  3    94 	 + star_links (star_branch_count + star_link_count).nnames
  3    95 	 + divide (star_links (star_branch_count + star_link_count).pathname_len + 31, 32, 17, 0)
  3    96 	   * binary (
  3    97 	     (star_links (star_branch_count + star_link_count).type = star_LINK)
  3    98 	     & (star_select_sw >= star_LINKS_ONLY_WITH_LINK_PATHS), 1));
  3    99 
  3   100 /* hcs_$star_list_ and hcs_$star_dir_list_ link pathname */
  3   101 
  3   102 declare  star_link_pathname char (star_links (star_linkx).pathname_len)
  3   103          based (addr (star_list_names (star_links (star_linkx).pathname_index)));
  3   104 
  3   105 /* internal static */
  3   106 
  3   107 /* star_select_sw values */
  3   108 
  3   109 declare  star_LINKS_ONLY fixed binary (2) internal static options (constant) initial (1);
  3   110 declare  star_BRANCHES_ONLY fixed binary (2) internal static options (constant) initial (2);
  3   111 declare  star_ALL_ENTRIES fixed binary (2) internal static options (constant) initial (3);
  3   112 declare  star_LINKS_ONLY_WITH_LINK_PATHS
  3   113          fixed binary (3) internal static options (constant) initial (5);
  3   114 declare  star_ALL_ENTRIES_WITH_LINK_PATHS
  3   115          fixed binary (3) internal static options (constant) initial (7);
  3   116 
  3   117 /* storage system types */
  3   118 
  3   119 declare  star_LINK fixed binary (2) unsigned internal static options (constant) initial (0);
  3   120 declare  star_SEGMENT fixed binary (2) unsigned internal static options (constant) initial (1);
  3   121 declare  star_DIRECTORY fixed binary (2) unsigned internal static options (constant) initial (2);
  3   122 
  3   123 /* END INCLUDE FILE . . . star_structures.incl.pl1 */
      124 
      125 
      126 
      127 	whoami = "describe_entry_type";
      128 
      129 	call cu_$af_return_arg (arg_count, ret_ptr, ret_len, code);
      130 	call setup (code, DSET_EXIT);
      131 
      132 	if arg_count = 0 | (arg_count = 1 & active_function)
      133 	then do;
      134 		if active_function
      135 		then call active_fnc_err_$suppress_name (0, whoami, "Usage:  [dset suffix -control_args]");
      136 		else call com_err_$suppress_name (0, whoami, "Usage:  dset suffix {-control_args}");
      137 		return;
      138 	     end;
      139 
      140 	all, attributes, brief, default, info_path, info_path_given, name,
      141 	     plural, modes, xacl, switches, explicit_switches = "0"b;
      142 
      143 /* process the arguments */
      144 
      145 	type_count = 0;
      146 	looking_for_types = "1"b;
      147 
      148 	do arg_idx = 1 to arg_count;
      149 
      150 	     call cu_$arg_ptr (arg_idx, arg_ptr, arg_len, code);
      151 	     if (code ^= 0) | (arg_len < 1)
      152 	     then do;
      153 BADARG:
      154 		if code = 0
      155 		then code = error_table_$bad_arg;
      156 		     call complain (code, whoami, "Argument number ^d.", arg_idx);
      157 		     return;
      158 		end;
      159 
      160 	     if (substr (arg, 1, 1) = "-") & looking_for_types
      161 	     then looking_for_types = "0"b;
      162 
      163 	     if looking_for_types
      164 	     then do;
      165 		     type_count = type_count + 1;
      166 		     if arg = "segment"
      167 		     then type_name (type_count) = FS_OBJECT_TYPE_SEGMENT;
      168 		     else if arg = "directory"
      169 		     then type_name (type_count) = FS_OBJECT_TYPE_DIRECTORY;
      170 		     else if arg = "msf"
      171 		     then type_name (type_count) = FS_OBJECT_TYPE_MSF;
      172 		     else if arg = "dm_file"
      173 		     then type_name (type_count) = FS_OBJECT_TYPE_DM_FILE;
      174 		     else if arg = "link"
      175 		     then type_name (type_count) = FS_OBJECT_TYPE_LINK;
      176 		     else type_name (type_count) = arg;
      177 		end;
      178 	     else do;
      179 
      180 		     if ^active_function & (arg = "-all" | arg = "-a")
      181 		     then all = "1"b;
      182 		     else if arg = "-attributes" | arg = "-attr"
      183 		     then attributes = "1"b;
      184 		     else if arg = "-info_pathname" | arg = "-ipn"
      185 		     then info_path, info_path_given = "1"b;
      186 		     else if arg = "-modes"
      187 		     then modes = "1"b;
      188 		     else if arg = "-name" | arg = "-nm"
      189 		     then name = "1"b;
      190 		     else if arg = "-plural_name" | arg = "-plnm"
      191 		     then plural = "1"b;
      192 		     else if arg = "-switches"
      193 		     then switches, explicit_switches = "1"b;
      194 		     else if active_function & (arg = "-extended_acl" | arg = "-xacl")
      195 		     then xacl = "1"b;
      196 		     else if arg = "-default"
      197 		     then do;
      198 			     if arg_count = arg_idx
      199 			     then do;
      200 				     call complain (error_table_$noarg, whoami, "Following ^a.", arg);
      201 				     return;
      202 				end;
      203 			     if default
      204 			     then do;
      205 				     call complain (0, whoami, "Only one -default may be given.");
      206 				     return;
      207 				end;
      208 			     arg_idx = arg_idx + 1;
      209 			     call cu_$arg_ptr (arg_idx, arg_ptr, arg_len, code);
      210 			     if code ^= 0
      211 			     then goto BADARG;
      212 
      213 			     switch_name = arg;
      214 			     default = "1"b;
      215 			end;
      216 		     else do;
      217 BADOPT:
      218 			     call complain (error_table_$badopt, whoami, "^a", arg);
      219 			     return;
      220 			end;
      221 		end;
      222 
      223 	end;
      224 
      225 	if type_count = 0
      226 	then do;
      227 		call complain (error_table_$noarg, whoami, "^/A type name must be specified.");
      228 		return;
      229 	     end;
      230 
      231 	if default & (all | switches)
      232 	then do;
      233 		call complain (error_table_$inconsistent, whoami, "-default may not be used with -all or -switches");
      234 		return;
      235 	     end;
      236 
      237 	if active_function &
      238 	     (arg_count - type_count > 2) &
      239 	     ^((arg_count - type_count = 2) & default)
      240 	then do;
      241 		call complain (0, whoami, "Only one attribute may be returned.");
      242 		return;
      243 	     end;
      244 
      245 	do type_no = 1 to type_count;
      246 
      247 	     type = type_name (type_no);
      248 
      249 	     si.version = SUFFIX_INFO_VERSION_1;
      250 	     call fs_util_$suffix_info_for_type (type, addr (si), code);
      251 	     if code ^= 0
      252 	     then do;
      253 		     call complain (0, whoami, "There is no extended entry type with the suffix ""^a"".", type);
      254 		     return;
      255 		end;
      256 
      257 	     if si.standard_object
      258 	     then if ^(active_function | brief)
      259 		then call ioa_ ("""^a"" is a standard entry type.", substr (type, 2));
      260 
      261 	     switch_list_ptr = null ();
      262 	     on cleanup
      263 		begin;
      264 		     if switch_list_ptr ^= null ()
      265 		     then free switch_list;
      266 		end;
      267 
      268 	     if all | (arg_count - type_count = 0)	/* defaults */
      269 	     then attributes, switches, name, info_path, plural, modes = "1"b;
      270 	     else if (arg_count - type_count = 1)
      271 		then brief = "1"b;
      272 
      273 	     if switches | switch_name ^= ""
      274 	     then do;
      275 		     area_ptr = get_system_free_area_ ();
      276 		     call fs_util_$list_switches_for_type (type, SWITCH_LIST_VERSION_1, area_ptr, switch_list_ptr,
      277 			(0));
      278 		end;
      279 
      280 	     if default
      281 	     then if ^si.has_switches
      282 		then do;
      283 		     if ^active_function
      284 			& ^all & (arg_count > 1)  /* by explicit request for switches */
      285 		     then call ioa_ ("The ^a entry type does not support any switches.", si.type_name);
      286 		     else if active_function
      287 		     then ret_str = "";
      288 		end;
      289 
      290 	     else do;
      291 		     idx = 0;
      292 		     do arg_idx = 1 to switch_list.switch_count while (idx = 0);
      293 			do name_idx = 0 to switch_list.name_count (arg_idx) - 1 while (idx = 0);
      294 			     if switch_list.names (arg_idx + name_idx) = switch_name
      295 			     then idx = arg_idx;
      296 			end;
      297 		     end;
      298 		     if name_idx = 0
      299 		     then do;
      300 			     call complain (0, whoami, "The ^a type does not support the ^a switch.", si.type_name,
      301 				switch_name);
      302 			     free switch_list;
      303 			     return;
      304 			end;
      305 		end;
      306 
      307 	     if name then do;
      308 		display_name = si.type_name;
      309 		if display_name = "multi-segment file" then display_name = "multisegment file";
      310 		if display_name = "DM file" then display_name = "data management file";
      311 	          if active_function
      312 		then ret_str = requote_string_ ((display_name));
      313 		else call ioa_ ("^[Name:^24t^]^a", ^brief, display_name);
      314 	     end;
      315 
      316 	     if plural then do;
      317 		display_name = si.plural_name;
      318 		if display_name = "multi-segment files" then display_name = "multisegment files";
      319 		if display_name = "DM files" then display_name = "data management files";
      320 	          if active_function
      321 		then ret_str = requote_string_ ((display_name));
      322 		else call ioa_ ("^[Plural name:^24t^]^a", ^brief, display_name);
      323 	     end;
      324 
      325 	     if modes
      326 	     then do;
      327 		     if active_function
      328 		     then ret_str = requote_string_ (si.modes);
      329 		     else call ioa_ ("^[Access modes:^24t^]^a", ^brief, si.modes);
      330 		end;
      331 
      332 	     if xacl
      333 	     then if si.extended_acl
      334 		then ret_str = "true";
      335 		else ret_str = "false";
      336 
      337 	     if attributes
      338 	     then do;
      339 		     if active_function
      340 		     then ret_str = "";
      341 		     else buffer = "";
      342 		     do idx = 1 to hbound (ATTRIBUTE_NAMES, 1);
      343 			if substr (string (si.copy_flags), idx, 1)
      344 			then if active_function
      345 			     then ret_str = ret_str || requote_string_ ((ATTRIBUTE_NAMES (idx))) || " ";
      346 			     else if buffer = ""
      347 			     then buffer = ATTRIBUTE_NAMES (idx);
      348 			     else buffer = buffer || ", " || ATTRIBUTE_NAMES (idx);
      349 		     end;
      350 		     if ^active_function
      351 		     then do;
      352 			     if buffer ^= ""
      353 			     then call ioa_ ("^[Supported attributes:^24t^]^a", ^brief, buffer);
      354 			     if si.extend | si.update
      355 			     then call ioa_ ("^a may be ^[updated^]^[ and ^]^[extended^] by the copy command",
      356 				     si.plural_name, si.update, (si.update & si.extend), si.extend);
      357 			end;
      358 		end;
      359 
      360 	     if default & si.has_switches
      361 		then if active_function
      362 		     then if switch_list.default_value (idx)
      363 		          then ret_str = "on";
      364 		          else ret_str = "off";
      365 		else call ioa_ ("^[^s^;^a defaults to ^]^[on^;off^]", brief, switch_name, switch_list.default_value (idx));
      366 
      367 	     if switches
      368 	     then if ^si.has_switches
      369 		then do;
      370 		     if ^active_function & explicit_switches
      371 		     then call ioa_ ("The ^a entry type does not support any switches.", si.type_name);
      372 		     else if active_function
      373 		     then ret_str = "";
      374 		end;
      375 		else do;
      376 		     arg_idx = 18;
      377 		     if ^active_function
      378 		     then do;
      379 			call ioa_ ("Switches:");
      380 			do idx = 1 to switch_list.switch_name_count;
      381 			     arg_idx = max (arg_idx, length (rtrim (switch_list.names (idx))));
      382 			end;
      383 		     end;
      384 		     arg_idx = arg_idx + 6;
      385 
      386 		     do idx = 1 to switch_list.switch_count;
      387 			switch_name = switch_list.names (switch_list.name_index (idx));
      388 			if active_function
      389 			then ret_str = ret_str || requote_string_ (switch_name) || " ";
      390 			else do;
      391 				call ioa_ ("^3x^a:^vt^[on^;off^]", switch_name, arg_idx,
      392 				     switch_list.default_value (idx));
      393 				if all
      394 				then do name_idx = 1 to switch_list.name_count (idx) - 1;
      395 					call ioa_ ("^6x^a",
      396 					     switch_list.names (switch_list.name_index (idx) + name_idx));
      397 				     end;
      398 			     end;
      399 		     end;
      400 		end;
      401 
      402 	     if switch_list_ptr ^= null ()
      403 	     then free switch_list;
      404 
      405 	     if info_path
      406 	     then do;
      407 		     if si.info_pathname = ""
      408 		     then do;
      409 NO_INFO:
      410 			     if active_function | info_path_given
      411 			     then call complain (0, whoami, "No info segment available for ^a.", si.plural_name);
      412 			end;
      413 		     else do;
      414 			     if search (si.info_pathname, "<>") > 0
      415 			     then do;		/* pathname given */
      416 				     call expand_pathname_ (si.info_pathname, dir, entry, code);
      417 				     if code ^= 0
      418 				     then goto NO_INFO;
      419 
      420 				     call hcs_$status_minf (dir, entry, 1, (0), (0), code);
      421 				     if code ^= 0
      422 				     then goto NO_INFO;
      423 				end;
      424 			     else do;		/* entryname only, use search list */
      425 				     call search_paths_$find_dir ("info", null (), si.info_pathname, "", dir,
      426 					code);
      427 				     if code ^= 0
      428 				     then goto NO_INFO;
      429 				end;
      430 			     if active_function
      431 			     then ret_str = si.info_pathname;
      432 			     else call ioa_ ("Type ""help ^a"" for more information on ^a.", si.info_pathname,
      433 				     si.plural_name);
      434 			end;
      435 		end;
      436 
      437 	     if type_count > 1
      438 	     then if ^active_function
      439 		then call ioa_ ("");
      440 
      441 	end;
      442 
      443 DSET_EXIT:
      444 	return;
      445 
      446 
      447 
      448 list_entry_types:
      449 lset:
      450      entry () options (variable);
      451 
      452 	whoami = "list_entry_types";
      453 	call cu_$af_return_arg (arg_count, ret_ptr, ret_len, code);
      454 	call setup (code, LSET_EXIT);
      455 	area_ptr = get_system_free_area_ ();
      456 
      457 	if arg_count ^= 0
      458 	then do;
      459 		if active_function
      460 		then call active_fnc_err_$suppress_name (0, whoami, "Usage:  [lset]");
      461 		else call com_err_$suppress_name (0, whoami, "Usage:  lset");
      462 		return;
      463 	     end;
      464 
      465 	call hcs_$high_low_seg_count (high, low);
      466 	high = high + low;
      467 	call hcs_$get_search_rules (addr (search_rules));
      468 
      469 	type_count = 0;
      470 	star_entry_ptr, star_names_ptr = null ();
      471 	on cleanup
      472 	     begin;
      473 		if star_entry_ptr ^= null ()
      474 		then free star_entries;
      475 		if star_names_ptr ^= null ()
      476 		then free star_names;
      477 	     end;
      478 
      479 	do rule = 1 to search_rules.number;
      480 	     if search_rules.names (rule) = "initiated_segments"
      481 	     then do;
      482 		     do idx = low to high;
      483 			code = 0;
      484 			do name_idx = 1 repeat name_idx + 1 while (code = 0);
      485 			     call hcs_$fs_get_ref_name (baseptr (idx), name_idx, ref_name, code);
      486 			     if code = 0
      487 			     then if substr (ref_name, 1, 7) = "suffix_"
      488 				then call check_name (ref_name);
      489 			end;
      490 		     end;
      491 		end;
      492 	     else if search_rules.names (rule) = "referencing_dir"
      493 	     then ;				/* IGNORE */
      494 	     else if search_rules.names (rule) = "working_dir"
      495 	     then do;
      496 		     dir = get_wdir_ ();
      497 		     goto STAR_JOIN;
      498 		end;
      499 	     else if substr (search_rules.names (rule), 1, 1) ^= ">"
      500 	     then call complain (0, whoami, "Unknown search rule ^a.", search_rules.names (rule));
      501 	     else do;
      502 		     dir = search_rules.names (rule);
      503 STAR_JOIN:
      504 		     call hcs_$star_ (dir, "suffix_*", star_ALL_ENTRIES, area_ptr, star_entry_count, star_entry_ptr,
      505 			star_names_ptr, code);
      506 		     if code ^= 0
      507 		     then if code ^= error_table_$nomatch
      508 			then call complain (code, whoami, "Listing ^a.", search_rules.names (rule));
      509 			else ;
      510 		     else do;
      511 			     do idx = 1 to hbound (star_names, 1);
      512 				call check_name (star_names (idx));
      513 			     end;
      514 			     free star_names;
      515 			     free star_entries;
      516 			end;
      517 		end;
      518 	end;
      519 
      520 /* The standard names are few, relatively stable, and therefore hardcoded */
      521 
      522 	call check_name (FS_OBJECT_TYPE_SEGMENT);
      523 	call check_name (FS_OBJECT_TYPE_DIRECTORY);
      524 	call check_name (FS_OBJECT_TYPE_MSF);
      525 	call check_name (FS_OBJECT_TYPE_DM_FILE);
      526 	call check_name (FS_OBJECT_TYPE_LINK);
      527 
      528 LSET_EXIT:
      529 	return;
      530 
      531 
      532 
      533 check_name:
      534      proc (name);
      535 
      536 declare	name		char (*),
      537 	a_type_name	char (32),
      538 	display_type	char (32),
      539 	display_select	char (32),
      540 	idx		fixed bin,
      541 	info_entry	entry variable options (variable);
      542 
      543 	if substr (name, 1, 1) ^= "-"
      544 	then if substr (name, length (rtrim (name)), 1) ^= "_"
      545 	     then return;
      546 
      547 	do idx = 1 to type_count;
      548 	     if type_name (idx) = name
      549 	     then return;
      550 	end;
      551 
      552 	if substr (name, 1, 1) = "-"
      553 	then a_type_name = name;
      554 	else do;
      555 	     a_type_name = reverse (rtrim (substr (name, 8)));
      556 	     a_type_name = reverse (ltrim (a_type_name, "_"));
      557 	end;
      558 	call fs_util_$make_entry_for_type (ltrim (a_type_name), "suffix_info", info_entry, code);
      559 	if code ^= 0
      560 	then return;
      561 
      562 	si.version = SUFFIX_INFO_VERSION_1;
      563 	call info_entry (addr (si));
      564 	display_type = si.type_name;
      565 	if display_type = "DM file" then display_type = "data management file";
      566 	if display_type = "multi-segment file" then display_type = "multisegment file";
      567 	if active_function
      568 	then ret_str = ret_str || requote_string_ ((display_type)) || " ";
      569 	else if si.standard_object
      570 	     then do;
      571 		     if si.type = FS_OBJECT_TYPE_LINK
      572 		     then a_type_name = "link";
      573 		     else if si.type = FS_OBJECT_TYPE_SEGMENT
      574 		     then a_type_name = "segment";
      575 		     else if si.type = FS_OBJECT_TYPE_DIRECTORY
      576 		     then a_type_name = "directory";
      577 		     else if si.type = FS_OBJECT_TYPE_MSF
      578 		     then a_type_name = "msf";
      579 		     else if si.type = FS_OBJECT_TYPE_DM_FILE
      580 		     then a_type_name = "dm_file";
      581 
      582 		     call ioa_ ("The standard type ""^a"", which doesn't require a suffix,^/^5xis selected by using the string ""^a"".",
      583 			display_type, a_type_name);
      584 		end;
      585 	     else call ioa_ ("The extended type ""^a"", which uses the ""^a"" suffix,^/^5xis selected by using the string ""^a"".",
      586 		si.type_name, si.type, si.type);
      587 
      588 	type_count = type_count + 1;
      589 	type_name (type_count) = name;
      590 
      591 	return;
      592      end check_name;
      593 
      594 setup:
      595      proc (status, error_exit);
      596 
      597 dcl	status		fixed bin (35) parameter;
      598 dcl  error_exit label parameter;
      599 
      600 	if status = 0
      601 	then do;
      602 		active_function = "1"b;
      603 		complain = active_fnc_err_;
      604 		ret_str = "";
      605 	     end;
      606 	else if status = error_table_$not_act_fnc
      607 	then do;
      608 		active_function = "0"b;
      609 		complain = com_err_;
      610 	     end;
      611 	else do;
      612 		call com_err_ (status, whoami);
      613 		goto error_exit;
      614 	     end;
      615 
      616 	return;
      617      end setup;
      618 
      619      end describe_entry_type;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/31/88  1405.8  describe_entry_type.pl1           >spec>install>1049>describe_entry_type.pl1
120          1    03/05/85  1807.3  suffix_info.incl.pl1              >ldd>include>suffix_info.incl.pl1
122          2    10/14/83  1606.7  copy_flags.incl.pl1               >ldd>include>copy_flags.incl.pl1
124          3    06/10/82  1045.5  star_structures.incl.pl1          >ldd>include>star_structures.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ATTRIBUTE_NAMES                 000056 constant        varying char(32)         initial array dcl 70 ref 342 343 346 348
FS_OBJECT_TYPE_DIRECTORY        000031 constant        char(32)                 initial packed unaligned dcl 1-50 set ref 168 523*
                                                                                  575
FS_OBJECT_TYPE_DM_FILE          000011 constant        char(32)                 initial packed unaligned dcl 1-50 set ref 172 525*
                                                                                  579
FS_OBJECT_TYPE_LINK             000001 constant        char(32)                 initial packed unaligned dcl 1-50 set ref 174 526*
                                                                                  571
FS_OBJECT_TYPE_MSF              000021 constant        char(32)                 initial packed unaligned dcl 1-50 set ref 170 524*
                                                                                  577
FS_OBJECT_TYPE_SEGMENT          000041 constant        char(32)                 initial packed unaligned dcl 1-50 set ref 166 522*
                                                                                  573
SUFFIX_INFO_VERSION_1           000054 constant        char(8)                  initial packed unaligned dcl 1-29 ref 249 562
SWITCH_LIST_VERSION_1           000052 constant        char(8)                  initial packed unaligned dcl 1-48 set ref 276*
a_type_name                     003702 automatic       char(32)                 packed unaligned dcl 536 set ref 552* 555* 556* 556
                                                                                  558 558 571* 573* 575* 577* 579* 582*
active_fnc_err_                 000024 constant        entry                    external dcl 89 ref 603
active_fnc_err_$suppress_name   000026 constant        entry                    external dcl 89 ref 134 459
active_function                 000100 automatic       bit(1)                   dcl 34 set ref 132 134 180 194 237 257 283 286 311
                                                                                  320 327 339 343 350 360 370 372 377 388 409 430
                                                                                  437 459 567 602* 608*
addr                                                   builtin function         dcl 76 ref 250 250 467 467 563 563
all                             000101 automatic       bit(1)                   dcl 34 set ref 140* 180* 231 268 283 393
area_ptr                        000116 automatic       pointer                  dcl 34 set ref 275* 276* 455* 503*
arg                                    based           char                     packed unaligned dcl 34 set ref 160 166 168 170 172
                                                                                  174 176 180 180 182 182 184 184 186 188 188 190
                                                                                  190 192 194 194 196 200* 213 217*
arg_count                       000120 automatic       fixed bin(17,0)          dcl 34 set ref 129* 132 132 148 198 237 237 268 270
                                                                                  283 453* 457
arg_idx                         000121 automatic       fixed bin(17,0)          dcl 34 set ref 148* 150* 156* 198 208* 208 209* 292*
                                                                                  293 294 294* 376* 381* 381 384* 384 391*
arg_len                         000122 automatic       fixed bin(21,0)          dcl 34 set ref 150* 151 160 166 168 170 172 174 176
                                                                                  180 180 182 182 184 184 186 188 188 190 190 192
                                                                                  194 194 196 200 200 209* 213 217 217
arg_ptr                         000124 automatic       pointer                  dcl 34 set ref 150* 160 166 168 170 172 174 176 180
                                                                                  180 182 182 184 184 186 188 188 190 190 192 194
                                                                                  194 196 200 209* 213 217
attributes                      000102 automatic       bit(1)                   dcl 34 set ref 140* 182* 268* 337
baseptr                                                builtin function         dcl 76 ref 485 485
brief                           000103 automatic       bit(1)                   dcl 34 set ref 140* 257 270* 313 322 329 352 365*
buffer                          000126 automatic       varying char(128)        dcl 34 set ref 341* 346 346* 348* 348 352 352*
cleanup                         003634 stack reference condition                dcl 76 ref 262 471
code                            000167 automatic       fixed bin(35,0)          dcl 34 set ref 129* 130* 150* 151 153 153* 156* 209*
                                                                                  210 250* 251 416* 417 420* 421 425* 427 453* 454*
                                                                                  483* 484 485* 486 503* 506 506 506* 558* 559
com_err_                        000030 constant        entry                    external dcl 89 ref 609 612
com_err_$suppress_name          000032 constant        entry                    external dcl 89 ref 136 461
complain                        000170 automatic       entry variable           dcl 34 set ref 156 200 205 217 227 233 241 253 300
                                                                                  409 499 506 603* 609*
copy_flags               46     002002 automatic       structure                level 2 in structure "si" dcl 65 in procedure "dset"
                                                                                  set ref 343
copy_flags                             based           structure                level 1 dcl 2-8 in procedure "dset"
cu_$af_return_arg               000034 constant        entry                    external dcl 89 ref 129 453
cu_$arg_ptr                     000036 constant        entry                    external dcl 89 ref 150 209
default                         000104 automatic       bit(1)                   dcl 34 set ref 140* 203 214* 231 237 280 360
default_value             6            based           bit(1)                   array level 3 dcl 1-37 set ref 360 365* 391*
dir                             000174 automatic       char(168)                packed unaligned dcl 34 set ref 416* 420* 425* 496*
                                                                                  502* 503*
display_name                    000246 automatic       char(32)                 packed unaligned dcl 34 set ref 308* 309 309* 310
                                                                                  310* 311 313* 317* 318 318* 319 319* 320 322*
display_type                    003712 automatic       char(32)                 packed unaligned dcl 536 set ref 564* 565 565* 566
                                                                                  566* 567 582*
entry                           000264 automatic       char(32)                 packed unaligned dcl 34 set ref 416* 420*
error_exit                             parameter       label variable           dcl 598 ref 594 613
error_table_$bad_arg            000010 external static fixed bin(35,0)          dcl 80 ref 153
error_table_$badopt             000012 external static fixed bin(35,0)          dcl 80 set ref 217*
error_table_$inconsistent       000014 external static fixed bin(35,0)          dcl 80 set ref 233*
error_table_$noarg              000016 external static fixed bin(35,0)          dcl 80 set ref 200* 227*
error_table_$nomatch            000020 external static fixed bin(35,0)          dcl 80 ref 506
error_table_$not_act_fnc        000022 external static fixed bin(35,0)          dcl 80 ref 606
expand_pathname_                000040 constant        entry                    external dcl 89 ref 416
explicit_switches               000114 automatic       bit(1)                   dcl 34 set ref 140* 192* 370
extend                   46(08) 002002 automatic       bit(1)                   level 3 packed packed unaligned dcl 65 set ref 354
                                                                                  354 354*
extended_acl             32(01) 002002 automatic       bit(1)                   level 3 packed packed unaligned dcl 65 set ref 332
flags                    32     002002 automatic       structure                level 2 packed packed unaligned dcl 65
fs_util_$list_switches_for_type 000062 constant        entry                    external dcl 89 ref 276
fs_util_$make_entry_for_type    000066 constant        entry                    external dcl 89 ref 558
fs_util_$suffix_info_for_type   000064 constant        entry                    external dcl 89 ref 250
get_system_free_area_           000042 constant        entry                    external dcl 89 ref 275 455
get_wdir_                       000044 constant        entry                    external dcl 89 ref 496
has_switches             32(02) 002002 automatic       bit(1)                   level 3 packed packed unaligned dcl 65 set ref 280
                                                                                  360 367
hbound                                                 builtin function         dcl 76 ref 342 511
hcs_$fs_get_ref_name            000046 constant        entry                    external dcl 89 ref 485
hcs_$get_search_rules           000050 constant        entry                    external dcl 89 ref 467
hcs_$high_low_seg_count         000052 constant        entry                    external dcl 89 ref 465
hcs_$star_                      000054 constant        entry                    external dcl 89 ref 503
hcs_$status_minf                000056 constant        entry                    external dcl 89 ref 420
high                            000256 automatic       fixed bin(17,0)          dcl 34 set ref 465* 466* 466 482
idx                             000261 automatic       fixed bin(17,0)          dcl 34 in procedure "dset" set ref 291* 292 293 294*
                                                                                  342* 343 343 346 348* 360 365 380* 381* 386* 387
                                                                                  391 393 395* 482* 485 485* 511* 512*
idx                             003722 automatic       fixed bin(17,0)          dcl 536 in procedure "check_name" set ref 547* 548*
info_entry                      003724 automatic       entry variable           dcl 536 set ref 558* 563
info_path                       000105 automatic       bit(1)                   dcl 34 set ref 140* 184* 268* 405
info_path_given                 000106 automatic       bit(1)                   dcl 34 set ref 140* 184* 409
info_pathname            47     002002 automatic       char(168)                level 2 packed packed unaligned dcl 65 set ref 407
                                                                                  414 416* 425* 430 432*
ioa_                            000060 constant        entry                    external dcl 89 ref 257 283 313 322 329 352 354 365
                                                                                  370 379 391 395 432 437 582 585
length                                                 builtin function         dcl 76 ref 381 543
looking_for_types               000260 automatic       bit(1)                   dcl 34 set ref 146* 160 160* 163
low                             000257 automatic       fixed bin(17,0)          dcl 34 set ref 465* 466 482
ltrim                                                  builtin function         dcl 76 ref 556 558 558
max                                                    builtin function         dcl 76 ref 381
modes                           000111 automatic       bit(1)                   dcl 34 in procedure "dset" set ref 140* 186* 268*
                                                                                  325
modes                    33     002002 automatic       char(36)                 level 2 in structure "si" dcl 65 in procedure "dset"
                                                                                  set ref 327* 329*
name                                   parameter       char                     packed unaligned dcl 536 in procedure "check_name"
                                                                                  ref 533 543 543 543 548 552 552 555 589
name                            000107 automatic       bit(1)                   dcl 34 in procedure "dset" set ref 140* 188* 268*
                                                                                  307
name_count                5            based           fixed bin(17,0)          array level 3 dcl 1-37 ref 293 393
name_idx                        000262 automatic       fixed bin(17,0)          dcl 34 set ref 293* 294* 298 393* 395* 484* 485*
                                                                                  489*
name_index                4            based           fixed bin(17,0)          array level 3 dcl 1-37 ref 387 395
names                     1     002123 automatic       char(168)                array level 2 in structure "search_rules" dcl 66
                                                                                  in procedure "dset" set ref 480 492 494 499 499*
                                                                                  502 506*
names                                  based           char(32)                 array level 2 in structure "switch_list" dcl 1-37
                                                                                  in procedure "dset" set ref 294 381 387 395*
nnames                    0(02)        based           fixed bin(16,0)          array level 2 packed packed unsigned unaligned
                                                                                  dcl 3-27 ref 475 511 514
null                                                   builtin function         dcl 76 ref 261 264 402 425 425 470 473 475
number                          002123 automatic       fixed bin(17,0)          level 2 dcl 66 set ref 479
plural                          000110 automatic       bit(1)                   dcl 34 set ref 140* 190* 268* 316
plural_name              22     002002 automatic       char(32)                 level 2 packed packed unaligned dcl 65 set ref 317
                                                                                  354* 409* 432*
ref_name                        000274 automatic       char(32)                 packed unaligned dcl 34 set ref 485* 486 486*
requote_string_                 000070 constant        entry                    external dcl 89 ref 311 320 327 343 388 567
ret_len                         000304 automatic       fixed bin(21,0)          dcl 34 set ref 129* 286 311 320 327 332 335 339 343
                                                                                  360 364 372 388 430 453* 567 604
ret_ptr                         000306 automatic       pointer                  dcl 34 set ref 129* 286 311 320 327 332 335 339 343
                                                                                  343 360 364 372 388 388 430 453* 567 567 604
ret_str                                based           varying char             dcl 34 set ref 286* 311* 320* 327* 332* 335* 339*
                                                                                  343* 343 360* 364* 372* 388* 388 430* 567* 567
                                                                                  604*
reverse                                                builtin function         dcl 76 ref 555 556
rtrim                                                  builtin function         dcl 76 ref 381 543 555
rule                            000263 automatic       fixed bin(17,0)          dcl 34 set ref 479* 480 492 494 499 499 502 506*
search                                                 builtin function         dcl 76 ref 414
search_paths_$find_dir          000072 constant        entry                    external dcl 89 ref 425
search_rules                    002123 automatic       structure                level 1 dcl 66 set ref 467 467
si                              002002 automatic       structure                level 1 dcl 65 set ref 250 250 563 563
standard_object          32     002002 automatic       bit(1)                   level 3 packed packed unaligned dcl 65 set ref 257
                                                                                  569
star_ALL_ENTRIES                000000 constant        fixed bin(2,0)           initial dcl 3-111 set ref 503*
star_entries                           based           structure                array level 1 dcl 3-27 ref 473 515
star_entry_count                003644 automatic       fixed bin(17,0)          dcl 3-14 set ref 473 475 503* 511 514 515
star_entry_ptr                  003646 automatic       pointer                  dcl 3-15 set ref 470* 473 473 475 503* 511 514 515
star_names                             based           char(32)                 array packed unaligned dcl 3-37 set ref 475 511 512*
                                                                                  514
star_names_ptr                  003650 automatic       pointer                  dcl 3-19 set ref 470* 475 475 503* 511 512 514
status                                 parameter       fixed bin(35,0)          dcl 597 set ref 594 600 606 612*
string                                                 builtin function         dcl 76 ref 343
substr                                                 builtin function         dcl 76 ref 160 257 257 343 486 499 543 543 552 555
suffix_info                            based           structure                level 1 dcl 1-12
sum                                                    builtin function         dcl 76 ref 475 511 514
switch_count              2            based           fixed bin(17,0)          level 2 dcl 1-37 ref 264 292 294 302 381 386 387 395
                                                                                  402
switch_list                            based           structure                level 1 dcl 1-37 set ref 264 302 402
switch_list_ptr                 003642 automatic       pointer                  dcl 1-33 set ref 261* 264 264 276* 292 293 294 302
                                                                                  360 365 380 381 386 387 387 391 393 395 395 402
                                                                                  402
switch_name                     000310 automatic       char(32)                 dcl 34 set ref 213* 273 294 300* 365* 387* 388* 391*
switch_name_count         3            based           fixed bin(17,0)          level 2 dcl 1-37 ref 264 302 380 402
switches                        000113 automatic       bit(1)                   dcl 34 in procedure "dset" set ref 140* 192* 231
                                                                                  268* 273 367
switches                  4            based           structure                array level 2 in structure "switch_list" dcl 1-37
                                                                                  in procedure "dset"
type                      2     002002 automatic       char(32)                 level 2 in structure "si" packed packed unaligned
                                                                                  dcl 65 in procedure "dset" set ref 571 573 575 577
                                                                                  579 585* 585*
type                            000320 automatic       char(32)                 packed unaligned dcl 34 in procedure "dset" set ref
                                                                                  247* 250* 253* 257 257 276*
type_count                      000330 automatic       fixed bin(17,0)          dcl 34 set ref 145* 165* 165 166 168 170 172 174 176
                                                                                  225 237 237 245 268 270 437 469* 547 588* 588 589
type_name                12     002002 automatic       char(32)                 level 2 in structure "si" packed packed unaligned
                                                                                  dcl 65 in procedure "dset" set ref 283* 300* 308
                                                                                  370* 564 585*
type_name                       000331 automatic       char(32)                 array packed unaligned dcl 34 in procedure "dset"
                                                                                  set ref 166* 168* 170* 172* 174* 176* 247 548 589*
type_no                         001771 automatic       fixed bin(17,0)          dcl 34 set ref 245* 247*
update                   46(09) 002002 automatic       bit(1)                   level 3 packed packed unaligned dcl 65 set ref 354
                                                                                  354* 354
version                         002002 automatic       char(8)                  level 2 dcl 65 set ref 249* 562*
whoami                          001772 automatic       char(32)                 packed unaligned dcl 34 set ref 127* 134* 136* 156*
                                                                                  200* 205* 217* 227* 233* 241* 253* 300* 409* 452*
                                                                                  459* 461* 499* 506* 612*
xacl                            000112 automatic       bit(1)                   dcl 34 set ref 140* 194* 332

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
THIRTY_TWO_SPACES                      internal static char(32)                 initial packed unaligned dcl 73
alloc_switch_count                     automatic       fixed bin(17,0)          dcl 1-33
alloc_switch_name_count                automatic       fixed bin(17,0)          dcl 1-33
display_select                         automatic       char(32)                 packed unaligned dcl 536
star_ALL_ENTRIES_WITH_LINK_PATHS       internal static fixed bin(3,0)           initial dcl 3-114
star_BRANCHES_ONLY                     internal static fixed bin(2,0)           initial dcl 3-110
star_DIRECTORY                         internal static fixed bin(2,0)           initial unsigned dcl 3-121
star_LINK                              internal static fixed bin(2,0)           initial unsigned dcl 3-119
star_LINKS_ONLY                        internal static fixed bin(2,0)           initial dcl 3-109
star_LINKS_ONLY_WITH_LINK_PATHS        internal static fixed bin(3,0)           initial dcl 3-112
star_SEGMENT                           internal static fixed bin(2,0)           initial unsigned dcl 3-120
star_branch_count                      automatic       fixed bin(17,0)          dcl 3-13
star_dir_list_branch                   based           structure                array level 1 dcl 3-59
star_link_count                        automatic       fixed bin(17,0)          dcl 3-17
star_link_pathname                     based           char                     packed unaligned dcl 3-102
star_links                             based           structure                array level 1 dcl 3-76
star_linkx                             automatic       fixed bin(17,0)          dcl 3-18
star_list_branch                       based           structure                array level 1 dcl 3-41
star_list_branch_ptr                   automatic       pointer                  dcl 3-16
star_list_names                        based           char(32)                 array packed unaligned dcl 3-92
star_list_names_ptr                    automatic       pointer                  dcl 3-20
star_select_sw                         automatic       fixed bin(3,0)           dcl 3-21
suffix_info_ptr                        automatic       pointer                  dcl 1-10

NAMES DECLARED BY EXPLICIT CONTEXT.
BADARG                          001223 constant        label                    dcl 153 ref 210
BADOPT                          001650 constant        label                    dcl 217
DSET_EXIT                       004341 constant        label                    dcl 443 ref 130 130
LSET_EXIT                       005225 constant        label                    dcl 528 ref 454 454
NO_INFO                         004057 constant        label                    dcl 409 ref 417 421 427
STAR_JOIN                       004776 constant        label                    dcl 503 ref 497
check_name                      005226 constant        entry                    internal dcl 533 ref 486 512 522 523 524 525 526
describe_entry_type             001036 constant        entry                    external dcl 13
dset                            001027 constant        entry                    external dcl 13
list_entry_types                004352 constant        entry                    external dcl 448
lset                            004343 constant        entry                    external dcl 448
setup                           005735 constant        entry                    internal dcl 594 ref 130 454

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6642        6736    6266        6652
Length      7256    6266        74         304     353           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
dset                               2250 external procedure  is an external procedure.  
on unit on line 262                  65 on unit               
on unit on line 471                  64 on unit               
check_name                              internal procedure  shares stack frame of external procedure dset.  
setup                                   internal procedure  shares stack frame of external procedure dset.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
dset                     000100 active_function             dset
                         000101 all                         dset
                         000102 attributes                  dset
                         000103 brief                       dset
                         000104 default                     dset
                         000105 info_path                   dset
                         000106 info_path_given             dset
                         000107 name                        dset
                         000110 plural                      dset
                         000111 modes                       dset
                         000112 xacl                        dset
                         000113 switches                    dset
                         000114 explicit_switches           dset
                         000116 area_ptr                    dset
                         000120 arg_count                   dset
                         000121 arg_idx                     dset
                         000122 arg_len                     dset
                         000124 arg_ptr                     dset
                         000126 buffer                      dset
                         000167 code                        dset
                         000170 complain                    dset
                         000174 dir                         dset
                         000246 display_name                dset
                         000256 high                        dset
                         000257 low                         dset
                         000260 looking_for_types           dset
                         000261 idx                         dset
                         000262 name_idx                    dset
                         000263 rule                        dset
                         000264 entry                       dset
                         000274 ref_name                    dset
                         000304 ret_len                     dset
                         000306 ret_ptr                     dset
                         000310 switch_name                 dset
                         000320 type                        dset
                         000330 type_count                  dset
                         000331 type_name                   dset
                         001771 type_no                     dset
                         001772 whoami                      dset
                         002002 si                          dset
                         002123 search_rules                dset
                         003642 switch_list_ptr             dset
                         003644 star_entry_count            dset
                         003646 star_entry_ptr              dset
                         003650 star_names_ptr              dset
                         003702 a_type_name                 check_name
                         003712 display_type                check_name
                         003722 idx                         check_name
                         003724 info_entry                  check_name

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ent_var_desc   call_ext_out_desc   call_ext_out        return_mac
tra_ext_2           mpfx2               enable_op           shorten_stack       ext_entry           int_entry
reverse_cs          set_chars_eis       op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
active_fnc_err_               active_fnc_err_$suppress_name com_err_                      com_err_$suppress_name
cu_$af_return_arg             cu_$arg_ptr                   expand_pathname_
fs_util_$list_switches_for_type                             fs_util_$make_entry_for_type  fs_util_$suffix_info_for_type
get_system_free_area_         get_wdir_                     hcs_$fs_get_ref_name          hcs_$get_search_rules
hcs_$high_low_seg_count       hcs_$star_                    hcs_$status_minf              ioa_
requote_string_               search_paths_$find_dir

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$badopt           error_table_$inconsistent     error_table_$noarg
error_table_$nomatch          error_table_$not_act_fnc




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     13 001026       127 001043       129 001046       130 001062       132 001067       134 001075       136 001125
    137 001152       140 001153       145 001167       146 001170       148 001172       150 001201       151 001216
    153 001223       156 001230       157 001262       160 001263       163 001273       165 001275       166 001276
    168 001311       170 001324       172 001337       174 001352       176 001365       177 001374       180 001375
    182 001412       184 001425       186 001441       188 001450       190 001463       192 001476       194 001506
    196 001523       198 001527       200 001532       201 001570       203 001571       205 001573       206 001617
    208 001620       209 001621       210 001636       213 001640       214 001645       215 001647       217 001650
    219 001701       223 001702       225 001704       227 001706       228 001732       231 001733       233 001741
    234 001765       237 001766       241 002000       242 002024       245 002025       247 002035       249 002042
    250 002044       251 002067       253 002071       254 002120       257 002121       261 002154       262 002156
    264 002172       266 002211       268 002212       270 002231       273 002235       275 002243       276 002252
    280 002303       283 002310       286 002340       288 002343       291 002344       292 002345       293 002357
    294 002373       296 002413       297 002415       298 002417       300 002421       302 002454       303 002466
    307 002467       308 002471       309 002474       310 002503       311 002512       313 002552       316 002606
    317 002610       318 002613       319 002622       320 002631       322 002671       325 002725       327 002727
    329 002764       332 003020       335 003037       337 003050       339 003052       341 003056       342 003057
    343 003065       346 003167       348 003206       349 003246       350 003251       352 003253       354 003310
    360 003365       364 003414       365 003426       367 003463       370 003470       372 003515       374 003520
    376 003521       377 003523       379 003525       380 003542       381 003553       382 003601       384 003603
    386 003605       387 003615       388 003633       390 003716       391 003717       393 003755       395 003773
    397 004027       399 004031       402 004033       405 004051       407 004053       409 004057       412 004112
    414 004113       416 004125       417 004151       420 004153       421 004214       423 004216       425 004217
    427 004257       430 004261       432 004275       437 004321       441 004337       443 004341       448 004342
    452 004357       453 004362       454 004377       455 004404       457 004413       459 004415       461 004450
    462 004477       465 004500       466 004511       467 004513       469 004524       470 004525       471 004530
    473 004544       475 004553       477 004607       479 004610       480 004617       482 004626       483 004635
    484 004636       485 004642       486 004673       489 004704       490 004706       491 004710       492 004711
    494 004716       496 004722       497 004731       499 004732       502 004773       503 004776       506 005043
    509 005103       511 005104       512 005135       513 005152       514 005154       515 005202       518 005204
    522 005206       523 005211       524 005214       525 005217       526 005222       528 005225       533 005226
    543 005237       547 005263       548 005273       550 005305       552 005307       555 005322       556 005350
    557 005374       558 005375       559 005447       562 005453       563 005455       564 005467       565 005472
    566 005501       567 005510       569 005576       571 005602       573 005612       575 005622       577 005632
    579 005642       582 005651       584 005674       585 005675       588 005722       589 005723       591 005734
    594 005735       600 005737       602 005741       603 005743       604 005750       605 005751       606 005752
    608 005755       609 005756       610 005762       612 005763       613 005777       616 006002


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
