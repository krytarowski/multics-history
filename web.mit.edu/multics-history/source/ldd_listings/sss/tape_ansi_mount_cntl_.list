	COMPILATION LISTING OF SEGMENT tape_ansi_mount_cntl_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 12/17/86  0851.4 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(86-08-18,GWMay), approve(), audit(), install():
       13*     old history comments:
       14*     0) Created:  09/25/74 by Ross E. Klinger
       15*     1) Modified: 11/06/74 by Ross E. Klinger
       16*     2) Modified: 10/26/76 by Janice B. Phillipps
       17*     3) Modified: 04/05/77 by Janice B. Phillipps
       18*     4) Modified: 04/11/78 by C. D. Tavares
       19*     5) Modified: 04/28/78 by Michael R. Jordan
       20*     6) Modified: 4/79     by R.J.C. Kissel
       21*     7) Modified: 4/82     by J. A. Bush for block sizes > 8192 bytes
       22*     8) Modified: 9/83     by J. A. Bush to compile with modified include
       23*                                files, (ansi ibm)_vol1.incl.pl1
       24*  2) change(86-08-18,GWMay), approve(86-09-09,MCR7536), audit(86-09-17,Dupuis),
       25*     install(86-09-24,MR12.0-1162):
       26*     Changed the use of the cseg.wait_switch array.  Rather than assigning the
       27*     6th and 7th chars of the tape device name as an index into the array, the
       28*     index will be set to the index of the cseg.vl array which is a one to one
       29*     correspondence.
       30*                                                   END HISTORY COMMENTS */
       31 
       32 
       33 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       34 /*                                                                       */
       35 /*  N__a_m_e:  tape_ansi_mount_cntl_                                                */
       36 /*                                                                       */
       37 /*       This module performs the following functions:                   */
       38 /*  1)  mount - assigns drive and mounts volume;                         */
       39 /*  2)  remount - demounts volume, mounts new volume on assigned drive;  */
       40 /*  3)  free - unassigns a drive, demounting volume (if any);            */
       41 /*  4)  insert_rings - inserts write rings in every mounted volume;      */
       42 /*  5)  write_protect - sets every active drive to inhibit writing;      */
       43 /*  6)  write_permit - sets every active drive w/ring to permit writing  */
       44 /*                                                                       */
       45 /*  U__s_a_g_e                                                                */
       46 /*                                                                       */
       47 /* dcl tape_ansi_mount_cntl_$mount ext entry                             */
       48 /*                           (ptr, fixed bin, fixed bin (35)),           */
       49 /*     tape_ansi_mount_cntl_$remount ext entry                           */
       50 /*                           (ptr, ptr, fixed bin, fixed bin (35)),      */
       51 /*     tape_ansi_mount_cntl_$free ext entry                              */
       52 /*                           (ptr, fixed bin, fixed bin (35)),           */
       53 /*     tape_ansi_mount_cntl_$insert_rings ext entry                      */
       54 /*                           (ptr, fixed bin (35)),                      */
       55 /*     tape_ansi_mount_cntl_$write_protect ext entry                     */
       56 /*                           (ptr, fixed bin (35)),                      */
       57 /*     tape_ansi_mount_cntl_$write_permit ext entry                      */
       58 /*                           (ptr, fixed bin (35));                      */
       59 /*                                                                       */
       60 /*       call tape_ansi_mount_cntl_$mount (cP, vlX, code);               */
       61 /*       call tape_ansi_mount_cntl_$remount (cP, down_vlX, vlX, code);   */
       62 /*       call tape_ansi_mount_cntl_$free (cP, vlX, code);                */
       63 /*       call tape_ansi_mount_cntl_$insert_rings (cP, code);             */
       64 /*       call tape_ansi_mount_cntl_$write_protect (cP, code);            */
       65 /*       call tape_ansi_mount_cntl_$write_permit (cP, code);             */
       66 /*                                                                       */
       67 /*  1) cP        is a pointer to tape_ansi_cseg.  (Input)                */
       68 /*                                                                       */
       69 /*  2) vlX       is the index of the volume link array element of the    */
       70 /*               volume to be mounted or freed.  (Input)                 */
       71 /*                                                                       */
       72 /*  3) down_vlX  is the index of the volume link of the volume to be     */
       73 /*               dismounted.  (Input)                                    */
       74 /*                                                                       */
       75 /*  4) code      is a standard Multics status code.  (Output)            */
       76 /*                                                                       */
       77 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       78 
       79 /* format: style4,delnl,insnl,indattr,ifthen,dclind9 */
       80 tape_ansi_mount_cntl_:
       81      procedure;
       82 
       83 /* parameters */
       84 dcl      vlX		  fixed bin,
       85          down_vlX		  fixed bin,
       86          code		  fixed bin (35);
       87 
  1     1 /*  BEGIN INCLUDE FILE:  tape_ansi_cseg.incl.pl1            */
  1     2 /*						*/
  1     3 /*  1) Modified: 12/01/75 by Ross E. Klinger  --  to allow  */
  1     4 /*     for allocation of the attach and open descriptions   */
  1     5 /*     within the cseg structure.			*/
  1     6 /*  2) Modified for resource management.			*/
  1     7 /*  3) Modified 9/79 by R.J.C. Kissel to handle the new tseg.	*/
  1     8 /*  4) Modified 4/82 by J.A. Bush for block sizes > 8192 bytes	*/
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind9 */
  1    11 dcl      cP		  ptr;			/* pointer on which cseg structure is based */
  1    12 dcl      cseg_tseg_version_2	  fixed bin internal static options (constant) init (2);
  1    13 
  1    14 dcl      1 cseg		  based (cP),		/* control structure */
  1    15 	 2 file_set_lock	  bit (1) aligned,		/* "1"b if file set in use */
  1    16 	 2 invalid	  bit (1) aligned,		/* invalid cseg - delete at detach time bit */
  1    17 	 2 standard	  fixed bin,		/* label standard */
  1    18 						/* 1 - ANSI standard */
  1    19 						/* 2 - IBM/OS-VS */
  1    20 						/* 3 - IBM/DOS-VM */
  1    21 	 2 attach_description,			/* iox_ attach description */
  1    22 	   3 length	  fixed bin (17),		/* actual length of string */
  1    23 	   3 string	  char (256),		/* maximum is 256 characters */
  1    24 	 2 open_description,			/* iox_ open description */
  1    25 	   3 length	  fixed bin (17),		/* actual length of string */
  1    26 	   3 string	  char (32),		/* maximum is 32 */
  1    27 	 2 module		  char (12) varying,	/* IO module name */
  1    28 	 2 ndrives	  fixed bin,		/* maximum number of drives to be used */
  1    29 	 2 nactive	  fixed bin,		/* number of drives actually in use */
  1    30 	 2 write_ring	  bit (1) aligned,		/* volumes mounted with write rings */
  1    31 	 2 protect	  bit (1) aligned,		/* volumes have rings, but are hardware protected */
  1    32 	 2 density	  fixed bin,		/* file set recording density */
  1    33 						/* 2 - 800 bpi NRZI */
  1    34 						/* 3 - 1600 bpi PE  */
  1    35 	 2 vcN		  fixed bin,		/* number of links in volume chain */
  1    36 	 2 fcP		  ptr,			/* file chain pointer */
  1    37 	 2 flP		  ptr,			/* pointer to file link of current file */
  1    38 	 2 hdw_status,				/* hardware status structure */
  1    39 	   3 bits		  bit (72) aligned,		/* IOM status */
  1    40 	   3 no_minor	  fixed bin,		/* number of minor status codes */
  1    41 	   3 major	  fixed bin (35),		/* major status */
  1    42 	   3 minor	  (10) fixed bin (35),	/* minor status */
  1    43 	 2 lbl_buf	  char (80),		/* label I/O buffer */
  1    44 	 2 open_mode	  fixed bin,		/* opening mode */
  1    45 						/* 4 - sequential_input */
  1    46 						/* 5 - sequential_output */
  1    47 	 2 close_rewind	  bit (1) aligned,		/* rewind volume at next close */
  1    48 	 2 force		  bit (1) aligned,		/* force file overwrite switch */
  1    49 	 2 user_labels	  bit (1) aligned,		/* process user labels switch */
  1    50 	 2 no_labels	  bit (1) aligned,		/* "1"b if volume has no labels */
  1    51 	 2 output_mode	  fixed bin,		/* 0 - input */
  1    52 						/* 1 - extend */
  1    53 						/* 2 - modify */
  1    54 						/* 3 - write */
  1    55 						/* 4 - create */
  1    56 	 2 replace_id	  char (17),		/* replace file identifier */
  1    57 	 2 retain		  fixed bin,		/* 0 - default to rcp_ defaults */
  1    58 						/* 1 - unassign drives and volumes */
  1    59 						/* 2 - retain drives, unassign volumes */
  1    60 						/* 3 - unassign drives, retain volumes */
  1    61 						/* 4 - retain drives and volumes */
  1    62 	 2 lrec,					/* logical record IO control data */
  1    63 	   3 bufP		  ptr,			/* pointer to current processing buffer */
  1    64 	   3 nc_buf	  fixed bin,		/* number of characters in buffer */
  1    65 	   3 offset	  fixed bin,		/* current processing offset within buffer */
  1    66 	   3 saveP	  ptr,			/* pointer to current D/V format RCW/RDW */
  1    67 	   3 file_lock	  bit (1) aligned,		/* "1"b if file in use */
  1    68 	   3 blkcnt	  fixed bin (35),		/* physical block count */
  1    69 	   3 reccnt	  fixed bin (35),		/* logical record count (not presently used) */
  1    70 	   3 code		  fixed bin (35),		/* lrec_io_ non-restartable error code */
  1    71 	 2 read_length,				/* read_length control data */
  1    72 	   3 rlP		  ptr,			/* pointer to read_length segment */
  1    73 	   3 rlN		  fixed bin (21),		/* number of characters in segment */
  1    74 	 2 user_label_routine (6) variable entry (char (80), bit (1)),
  1    75 						/* 1 - read UHL */
  1    76 						/* 2 - write UHL */
  1    77 						/* 3 - read UTL */
  1    78 						/* 4 - write UTL */
  1    79 						/* 5 - read UVL */
  1    80 						/* 6 - write UVL */
  1    81 						/* THE FOLLOWING IS NEEDED ONLY WHILE TAPEIO_ / TDCM IS THE IO PROCEDURE */
  1    82 	 2 syncP		  ptr,			/* pointer to synchronous IO buffer */
  1    83 	 2 mode		  fixed bin,		/* 0 = binary -- 1 = 9 mode */
  1    84 	 2 soft_status,				/* software status structure */
  1    85 	   3 nbuf		  fixed bin,		/* number of suspended buffers */
  1    86 	   3 buf		  (2),
  1    87 	     4 bufP	  ptr,			/* pointer to buffer */
  1    88 	     4 count	  fixed bin,		/* buffer character count */
  1    89 	 2 (
  1    90 	 free_list,
  1    91 	 busy_list,
  1    92 	 chain		  (3),
  1    93 	 bufct		  (3)
  1    94 	 )		  fixed bin,		/* buffer management variables */
  1    95 	 2 wait_switch	  (1:63) bit (1) unaligned,	/* per-drive event wait switches */
  1    96 	 2 buf_size	  fixed bin,		/* size of each tseg buffer in chars (bytes) */
  1    97 	 2 tseg		  aligned,
  1    98 	   3 version_num	  fixed bin,
  1    99 	   3 areap	  ptr,			/* pointer to DSM area */
  1   100 	   3 ev_chan	  fixed bin (71),		/* event channel number */
  1   101 	   3 write_sw	  fixed bin (1),		/* 0 = read, 1 = write */
  1   102 	   3 sync		  fixed bin (1),		/* non-zero for synchronous i/o */
  1   103 	   3 get_size	  fixed bin (1),		/* ON for record sizes to be returned */
  1   104 	   3 ws_segno	  bit (18),		/* rcp_ kluge */
  1   105 	   3 drive_name	  char (32),
  1   106 	   3 tracks	  fixed bin,
  1   107 	   3 density	  bit (36),
  1   108 	   3 speed	  bit (36),		/* bits are 75, 125, 200 ips respectively */
  1   109 	   3 pad99 bit (36),			/* see tseg.incl.pl1 */
  1   110 	   3 buffer_offset	  fixed bin (12),		/* offset of first buffer to be processed */
  1   111 	   3 buffer_count	  fixed bin (12),		/* number of buffers to be processed */
  1   112 	   3 completion_status
  1   113 			  fixed bin (2),		/* 0 = no pending i/o or no status */
  1   114 						/* 1 = normal termination of i/o */
  1   115 						/* 2 = non-zero major status from previous i/o */
  1   116 	   3 hardware_status  bit (36) aligned,		/* major and sub-status */
  1   117 	   3 error_buffer	  fixed bin (12),		/* buffer in which i/o error occurred */
  1   118 	   3 command_count	  fixed bin (12),		/* number of non-data commands to execute */
  1   119 	   3 command_queue	  (10) fixed bin (6) aligned, /* non-data-transfer commands */
  1   120 	   3 bufferptr	  (12) fixed bin (18) aligned,/* relative ptrs to buffers */
  1   121 	   3 buffer_size	  (12) fixed bin (18) aligned,/* size of buffer */
  1   122 	   3 mode		  (12) fixed bin (2) aligned, /* 0 = bin, 1 = bcd, 2 = 9 track */
  1   123 	   3 buffer	  (4) char (cseg.buf_size) aligned,
  1   124 						/* data buffers */
  1   125 						/*  END OF TAPEIO_ / TDCM DATA */
  1   126 	 2 vl		  (63),			/* volume chain link */
  1   127 	   3 position,				/* volume position */
  1   128 	     4 fflX	  fixed bin unal,		/* index of first file link on volume */
  1   129 	     4 cflX	  fixed bin unal,		/* index of current file link */
  1   130 	     4 pos	  fixed bin unal,		/* intra-file position code */
  1   131 						/*  0 = in HDR group                          */
  1   132 						/*  1 - in data / passed HDR TM               */
  1   133 						/*  2 = in EOx group / passed data TM         */
  1   134 	     4 lflX	  fixed bin unal,		/* index of last file link on volume */
  1   135 	   3 vol_data,
  1   136 	     4 volname	  char (32),		/* volume name */
  1   137 	     4 canonical_volname
  1   138 			  char (6),		/* volume name as appears on label */
  1   139 	     4 comment	  char (64) varying,	/* mount comment */
  1   140 	     4 auth_code	  char (3) aligned,		/* authentication code for this volume */
  1   141 	     4 rcp_id	  fixed bin (6),		/* TDCM DUMMY - CHANGE TO BIT (36) ALIGNED */
  1   142 	     4 event_chan	  fixed bin (71),		/* rcp_ attach event channel */
  1   143 	     4 tape_drive	  char (32),		/* name of tape drive */
  1   144 	     4 ws_segno	  bit (18),		/* segno of IOI workspace (per drive) */
  1   145 	     4 write_VOL1	  fixed bin,		/* 0 - correct VOL1 label */
  1   146 						/* 1 - blank tape */
  1   147 						/* 2 - can't read 1st block */
  1   148 						/* 3 - 1st block not VOL1 label */
  1   149 						/* 4 - valid VOL1 label but wrong volume ID (Obsolete) */
  1   150 						/* 5 - correct VOL1 label, but wrong density */
  1   151 						/* 6 - invalid file-set format (Obsolete) */
  1   152 						/* -1 - correct VOL1 label of an earlier format */
  1   153 						/* (no authentication code) */
  1   154 	     4 ioi_index	  fixed bin,		/* ioi_ index for IO */
  1   155 	   3 reg_data,				/* registration data */
  1   156 	     4 tracks	  fixed bin unal,		/* number of tracks */
  1   157 	     4 density	  fixed bin unal,		/* density code */
  1   158 	     4 label_type	  fixed bin unal,		/* volume format */
  1   159 	     4 usage_count	  fixed bin unal,		/* number of attachment to this volume */
  1   160 	     4 read_errors	  fixed bin unal,		/* number of read errors */
  1   161 	     4 write_errors	  fixed bin unal,		/* number of write errors */
  1   162 	 2 chain_area	  area;			/* file chain allocation area */
  1   163 
  1   164 /*  END INCLUDE FILE:  tape_ansi_cseg.incl.pl1              */
       88 
       89 
  2     1 /*  BEGIN INCLUDE FILE:  ibm_vol1.incl.pl1                  */
  2     2 /*  Modified by J. A. Bush 11/06/82 for use by mtape_ */
  2     3 /*  format: style4 */
  2     4 
  2     5 dcl  ibm_vol1P ptr;					/* pointer on which ibm_vol1 is based */
  2     6 
  2     7 dcl  1 ibm_vol1 unaligned based (ibm_vol1P),
  2     8        2 label_id char (4),				/* VOL1 */
  2     9        2 volume_serial char (6),			/* volume serial number (can be alphameric) */
  2    10        2 reserved1 char (1),				/* "0" */
  2    11        2 VTOC_pointer char (10),			/* " " */
  2    12        2 reserved2 char (20),				/* " " */
  2    13        2 owner_id,					/* Owner identifier field (10 characters) */
  2    14          3 auth_code char (3),			/* Multics stores authentication code here */
  2    15          3 mult_id char (7),				/* Inited with MULTICS_IBM_VERSION */
  2    16        2 reserved3 char (29);				/* " " */
  2    17 
  2    18 dcl  IBM_VOL1 char (4) int static options (constant) init ("VOL1");
  2    19 dcl  MULTICS_IBM_VERSION char (7) int static options (constant) /* current mtape_/IBM version */
  2    20 	init ("MULT001");				/* goes in the owner_id2 field */
  2    21 
  2    22 /*  END INCLUDE FILE:  ibm_vol1.incl.pl1                    */
       90 
       91 
  3     1 /*  BEGIN INCLUDE FILE:  ansi_vol1.incl.pl1                 */
  3     2 /*  Modified by J. A. Bush 11/06/82 for use by mtape_ */
  3     3 /*  format: style4 */
  3     4 
  3     5 dcl  ansi_vol1P ptr;				/* pointer on which ansi_vol1 is based */
  3     6 
  3     7 dcl  1 ansi_vol1 unaligned based (ansi_vol1P),		/* ANSI VOL1 label */
  3     8        2 label_id char (4),				/* "VOL1" */
  3     9        2 volume_id char (6),				/* volume identifier */
  3    10        2 access char (1),				/* " " if unlimited */
  3    11        2 reserved1 char (26),				/* blanks */
  3    12        2 owner_id,					/* Owner Identifier field (14 characters) */
  3    13          3 auth_code char (3),			/* Multics stores authenication code here */
  3    14          3 mult_id char (7),				/* inited with MULTICS_ANSI_VERSION */
  3    15          3 owner_id_pad char (4),			/* blanks */
  3    16        2 reserved2 char (28),				/* blanks */
  3    17        2 label_version char (1);			/* label standard version */
  3    18 
  3    19 dcl  ANSI_VOL1 char (4) int static options (constant) init ("VOL1");
  3    20 dcl  LABEL_STANDARD_VERSION char (1) int static options (constant) /* Label standard supported */
  3    21 	init ("3");				/* (currently to ANSI x3.27-1978) */
  3    22 dcl  MULTICS_ANSI_VERSION char (7) int static options (constant) /* current mtape_/ANSI version */
  3    23 	init ("MULT001");				/* goes in the owner_id2 field */
  3    24 
  3    25 /*  END INCLUDE FILE:  ansi_vol1.incl.pl1                   */
       92 
       93 
  4     1 /* --------------- BEGIN include file rcp_volume_formats.incl.pl1 --------------- */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(86-12-08,GWMay), approve(86-12-08,PBF7552),
  4     7*     audit(86-12-08,Martinson), install(86-12-17,MR12.0-1250):
  4     8*     added array entry 0 to the volume format types to indicate that the tape
  4     9*     volume was not authenticated by rcp.
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /* General volume types */
  4    14 
  4    15 dcl (Volume_unauthenticated initial (0),
  4    16      Volume_blank initial (1),
  4    17      Volume_unknown_format initial (6),
  4    18      Volume_unreadable initial (7),
  4    19 
  4    20 /* Tape volume types */
  4    21 
  4    22      Volume_multics_tape initial (2),
  4    23      Volume_gcos_tape initial (3),
  4    24      Volume_ibm_tape initial (4),
  4    25      Volume_ansi_tape initial (5)) fixed bin static options (constant);
  4    26 
  4    27 /* Printable descriptions of volume types */
  4    28 
  4    29 dcl  Tape_volume_types (0:7) char (16) static options (constant) initial
  4    30     ("unauthenticated",
  4    31      "blank",
  4    32      "Multics",
  4    33      "GCOS",
  4    34      "IBM",
  4    35      "ANSI",
  4    36      "unrecognizable",
  4    37      "unreadable");
  4    38 
  4    39 /* ---------------- END include file rcp_volume_formats.incl.pl1 ---------------- */
       94 
       95 
  5     1 /*	Begin include file ... rcp_resource_types.incl.pl1
  5     2*   *
  5     3*   *	Created 3/79 by Michael R. Jordan for MR7.0R
  5     4*   *
  5     5*   *	This include file defines the official RCP resource types.
  5     6*   *	The array of names is indexed by the corresponding device type.
  5     7*   *      MOD by RAF for MCA
  5     8**/
  5     9 
  5    10 
  5    11 
  5    12 /****^  HISTORY COMMENTS:
  5    13*  1) change(85-09-09,Fawcett), approve(85-09-09,MCR6979),
  5    14*     audit(85-12-09,CLJones), install(86-03-21,MR12.0-1033):
  5    15*     Support of MCA.
  5    16*                                                   END HISTORY COMMENTS */
  5    17 
  5    18 dcl  DEVICE_TYPE (8) char (32)
  5    19 	internal static options (constant)
  5    20 	init ("tape_drive", "disk_drive", "console", "printer", "punch", "reader", "special", "mca");
  5    21 
  5    22 dcl  NUM_QUALIFIERS (8) fixed bin			/* Number of qualifiers for each device type. */
  5    23 	internal static init (3, 0, 0, 2, 0, 0, 0, 0);
  5    24 
  5    25 dcl  VOLUME_TYPE (8) char (32)
  5    26 	internal static options (constant)
  5    27 	init ("tape_vol", "disk_vol", "", "", "", "", "", "");
  5    28 
  5    29 dcl  TAPE_DRIVE_DTYPEX fixed bin static internal options (constant) init (1);
  5    30 dcl  DISK_DRIVE_DTYPEX fixed bin static internal options (constant) init (2);
  5    31 dcl  CONSOLE_DTYPEX fixed bin static internal options (constant) init (3);
  5    32 dcl  PRINTER_DTYPEX fixed bin static internal options (constant) init (4);
  5    33 dcl  PUNCH_DTYPEX fixed bin static internal options (constant) init (5);
  5    34 dcl  READER_DTYPEX fixed bin static internal options (constant) init (6);
  5    35 dcl  SPECIAL_DTYPEX fixed bin static internal options (constant) init (7);
  5    36 dcl  MCA_DTYPEX fixed bin static internal options (constant) init (8);
  5    37 dcl  TAPE_VOL_VTYPEX fixed bin static internal options (constant) init (1);
  5    38 dcl  DISK_VOL_VTYPEX fixed bin static internal options (constant) init (2);
  5    39 
  5    40 
  5    41 /*	End include file ... rcp_resource_types.incl.pl1 */
       96 
       97 
       98 
       99 /* automatic storage */
      100 
      101 dcl      can_retry		  bit (1) init ("1"b),
      102          den		  fixed bin,		/* density code for tape_ansi_tape_io_$order */
      103          drive_name		  char (32),		/* drive name for user mount message */
      104          i		  fixed bin,		/* label length */
      105          op		  char (3),		/* operation for protect/permit entries */
      106          part		  char (2) varying,		/* particle for user mount message */
      107          vX		  fixed bin;		/* index of current volume link */
      108 
      109 /* based storage */
      110 dcl      VOL1_label_id	  char (4) based (addr (cseg.lbl_buf));
      111 						/* label identifier of VOL1 label (ANSI or IBM) */
      112 
      113 dcl      VOL1_80th_char	  char (1) based (addr (substr (cseg.lbl_buf, 80)));
      114 						/* 80th character of VOL1 label */
      115 
      116 /* conditions */
      117 dcl      cleanup		  condition;
      118 
      119 /* builtin functions */
      120 dcl      (addr, before, binary, divide, rtrim, substr)
      121 			  builtin;
      122 
      123 /* external procedures */
      124 dcl      authenticate_	  ext entry (char (*)) returns (char (3) aligned),
      125          cv_dec_check_	  ext entry (char (*), fixed bin (35)) returns (fixed bin (35)),
      126          canon_for_volume_label_
      127 			  entry (char (*), char (*), char (*), fixed bin, fixed bin (35)),
      128          ebcdic_to_ascii_	  ext entry (char (*), char (*)),
      129          ioa_		  ext entry options (variable),
      130          ipc_$block		  ext entry (ptr, ptr, fixed bin (35)),
      131          ipc_$create_ev_chn	  ext entry (fixed bin (71), fixed bin (35)),
      132          ipc_$delete_ev_chn	  ext entry (fixed bin (71), fixed bin (35)),
      133          tape_ansi_tape_io_$order
      134 			  ext entry (ptr, char (3), fixed bin, fixed bin (35)),
      135          tape_ansi_tape_io_$sync_read
      136 			  ext entry (ptr, fixed bin, fixed bin (35)),
      137          tdcm_$tdcm_attach	  ext entry (ptr, fixed bin (35)),
      138          tdcm_$tdcm_set_buf_size
      139 			  ext entry (ptr, fixed bin, fixed bin (35)),
      140          tdcm_$tdcm_detach	  ext entry (ptr, fixed bin (35)),
      141          tdcm_$tdcm_iocall	  ext entry (ptr, fixed bin (35)),
      142          tdcm_$tdcm_message	  ext entry (ptr, char (*), fixed bin, fixed bin (35)),
      143          tdcm_$tdcm_reset_signal
      144 			  ext entry (ptr, fixed bin (35)),
      145          tdcm_$tdcm_set_signal  ext entry (ptr, fixed bin (35));
      146 
      147 /* external static */
      148 dcl      (
      149          error_table_$bad_mount_request,
      150          error_table_$eof_record,
      151          error_table_$blank_tape
      152          )		  ext static fixed bin (35);
      153 
      154 mount:
      155      entry (cP, vlX, code);				/* assign a drive and mount a volume */
      156 
      157 	vX = vlX;					/* set index of current volume link */
      158 
      159 	on cleanup call cleaner;			/* don't leave event channels or drives */
      160 
      161 	call ipc_$create_ev_chn (tseg.ev_chan, code);	/* get an event channel */
      162 	if code ^= 0 then
      163 	     return;
      164 
      165 	tseg.version_num = cseg_tseg_version_2;
      166 	tseg.tracks = 0;				/* nine-track drive */
      167 
      168 	tseg.speed = cseg.speed;
      169 
      170 	if cseg.density = -1 then do;
      171 	     if cseg.standard = 1 then
      172 		tseg.density = "00100"b;		/* 800 bpi */
      173 	     else tseg.density = "00010"b;		/* 1600 bpi */
      174 	end;
      175 
      176 	else do;
      177 	     if cseg.density = 2 then
      178 		tseg.density = "00100"b;		/* 800 bpi */
      179 	     else if cseg.density = 3 then
      180 		tseg.density = "00010"b;		/* 1600 bpi */
      181 	     else if cseg.density = 4 then
      182 		tseg.density = "00001"b;		/* 6250 bpi */
      183 	     else tseg.density = "00100"b;		/* 800 bpi */
      184 	end;
      185 
      186 	tseg.buffer_count = 0;			/* attach call */
      187 	tseg.get_size = 1;				/* all IO to return block lengths */
      188 	call tdcm_$tdcm_attach (addr (tseg), code);	/* assign a drive */
      189 	if code ^= 0 then
      190 	     go to er_exit;				/* trouble */
      191 	else cseg.nactive = cseg.nactive + 1;		/* ok - up active count */
      192 	if cseg.buf_size > 8192 then do;		/* if user requesting large block size... */
      193 	     call tdcm_$tdcm_set_buf_size (addr (tseg), divide (cseg.buf_size, 4, 17, 0), code);
      194 	     if code ^= 0 then			/* if could'nt assign it.. */
      195 		go to er_exit;
      196 	end;
      197 
      198 up:
      199 	call mount_request;				/* issue message to operator and wait */
      200 
      201 	vl (vX).rcp_id = vX;                              /* fill volume link */
      202 
      203 	vl (vX).tape_drive = tseg.drive_name;
      204 	vl (vX).event_chan = tseg.ev_chan;
      205 	vl (vX).ws_segno = tseg.ws_segno;		/* save IOI wks segno */
      206 	vl (vX).cflX = 0;
      207 
      208 	call VOL1_check (code);			/* verify status of VOL1 label */
      209 	if code ^= 0 then
      210 	     go to er_exit;				/* trouble */
      211 
      212 /* only if VOL label looks good do we check the file labels for valid standard */
      213 /*
      214*   if vl (vX).write_VOL1 = 0 then call hdr_eox_check (code);
      215**/
      216 	if code ^= 0 then do;
      217 	     vl (vX).write_VOL1 = 6;			/* not standard file set */
      218 	     code = 0;
      219 	end;
      220 
      221 	return;
      222 
      223 remount:
      224      entry (cP, down_vlX, vlX, code);			/* switches volumes on an active drive */
      225 
      226 	vX = down_vlX;				/* first work with down volume */
      227 
      228 	tseg.drive_name = vl (vX).tape_drive;		/* set tseg to use this drive */
      229 	tseg.ev_chan = vl (vX).event_chan;
      230 	tseg.ws_segno = vl (vX).ws_segno;
      231 
      232 	on cleanup call cleaner;			/* exit with consistency */
      233 
      234 	vl (vX).cflX = 0;				/* invalidate position */
      235 	call unload;
      236 
      237 	vl (vX).rcp_id = 0;				/* invalidate volume link */
      238 
      239 	vX = vlX;					/* now work with volume to go up */
      240 
      241 	go to up;					/* mount the new volume */
      242 
      243 insert_rings:
      244      entry (cP, code);				/* dismount, insert rings, and remount */
      245 
      246 	on cleanup call cleaner;			/* don't leave event channel or drive */
      247 	cseg.write_ring = "1"b;			/* rings will be in */
      248 	do vX = 1 to cseg.vcN;			/* test each volume */
      249 	     if vl (vX).rcp_id ^= 0 then do;		/* mounted */
      250 		tseg.drive_name = vl (vX).tape_drive;	/* set-up for insertion */
      251 		tseg.ev_chan = vl (vX).event_chan;
      252 		tseg.ws_segno = vl (vX).ws_segno;
      253 		vl (vX).cflX = 0;			/* invalidate position */
      254 		call unload;
      255 		call mount_request;			/* tell operator to mount */
      256 	     end;
      257 	end;
      258 
      259 	return;
      260 
      261 write_protect:
      262      entry (cP, code);				/* set file protect */
      263 
      264 	op = "pro";				/* operatio is file _p_r_otect */
      265 	cseg.protect = "1"b;
      266 	go to com;
      267 
      268 write_permit:
      269      entry (cP, code);				/* set file permit */
      270 
      271 	op = "per";				/* operation is _p_e_rmit */
      272 	cseg.protect = "0"b;
      273 
      274 com:
      275 	on cleanup call cleaner;			/* maintain consistency */
      276 	do vX = 1 to cseg.vcN;			/* test each volume */
      277 	     if vl (vX).rcp_id ^= 0 then do;		/* mounted */
      278 		tseg.drive_name = vl (vX).tape_drive;	/* set-up to use this volume */
      279 		tseg.ws_segno = vl (vX).ws_segno;
      280 		tseg.ev_chan = vl (vX).event_chan;
      281 		call tape_ansi_tape_io_$order (cP, op, 0, code);
      282 						/* set protect or permit */
      283 		if code ^= 0 then
      284 		     go to er_exit;
      285 	     end;
      286 	end;
      287 
      288 	return;
      289 
      290 
      291 
      292 
      293 free:
      294      entry (cP, vlX, code);				/* unassign a drive */
      295 
      296 	vX = vlX;					/* copy index of current volume link */
      297 
      298 	tseg.drive_name = vl (vX).tape_drive;		/* set-up for detach */
      299 	tseg.ev_chan = vl (vX).event_chan;
      300 	tseg.ws_segno = vl (vX).ws_segno;
      301 	vl (vX).cflX = 0;				/* invalidate volume position */
      302 	on cleanup call cleaner;			/* don't leave event channel or drive */
      303 
      304 	call tdcm_$tdcm_reset_signal (addr (tseg), 0);
      305 	cseg.wait_switch (vl (vX).rcp_id) = "0"b;
      306 	call tdcm_$tdcm_detach (addr (tseg), code);	/* unassign the drive */
      307 	vl (vX).tape_drive = "";
      308 	vl (vX).rcp_id = 0;
      309 	vl (vX).ws_segno = "0"b;
      310 	if code ^= 0 then
      311 	     go to er_exit;				/* trouble */
      312 	else cseg.nactive = cseg.nactive - 1;		/* ok - down active count */
      313 
      314 	call ipc_$delete_ev_chn (tseg.ev_chan, code);	/* delete event channel */
      315 	if code ^= 0 then
      316 	     go to er_exit;				/* trouble */
      317 	vl (vX).event_chan = 0;
      318 	tseg.ev_chan = 0;
      319 
      320 	return;
      321 
      322 er_exit:
      323 	call cleaner;				/* cleanup if error */
      324 	code = error_table_$bad_mount_request;
      325 	return;
      326 
      327 
      328 cleaner:
      329      procedure;					/* cleanup and error exit procedure */
      330 dcl      ecode		  fixed bin (35);
      331 
      332 	if tseg.drive_name ^= "" then do;		/* detach drive if attached */
      333 	     call tdcm_$tdcm_reset_signal (addr (tseg), 0);
      334 	     cseg.wait_switch (vl (vX).rcp_id) = "0"b;
      335 	     call tdcm_$tdcm_detach (addr (tseg), ecode);
      336 	     if ecode = 0 then
      337 		cseg.nactive = cseg.nactive - 1;	/* down active count */
      338 	     tseg.drive_name = "";
      339 	     vl (vX).ws_segno = "0"b;
      340 	     vl (vX).tape_drive = "";
      341 	     vl (vX).rcp_id = 0;
      342 	end;
      343 	if tseg.ev_chan ^= 0 then do;			/* delete event channel if created */
      344 	     call ipc_$delete_ev_chn (tseg.ev_chan, 0);
      345 	     tseg.ev_chan = 0;
      346 	     vl (vX).event_chan = 0;
      347 	end;
      348 	vl (vX).cflX = 0;
      349 	return;
      350      end cleaner;
      351 
      352 wait:
      353      procedure (ecode);				/* waits for tdcm_ interrupt */
      354 dcl      ecode		  fixed bin (35);
      355 dcl      1 wait_list,				/* ipc_$block parameters */
      356 	 2 n		  fixed bin,
      357 	 2 chn		  fixed bin (71);
      358 dcl      1 message,
      359 	 2 channel	  fixed bin (71),
      360 	 2 msg		  fixed bin (71),
      361 	 2 sender		  bit (36),
      362 	 2 origin,
      363 	   3 dev_sig	  bit (18) unaligned,
      364 	   3 ring		  bit (18) unaligned,
      365 	 2 channel_index	  fixed bin;
      366 
      367 again:
      368 	wait_list.n = 1;				/* waiting for only 1 interrupt */
      369 	wait_list.chn = tseg.ev_chan;			/* set ID */
      370 
      371 	call ipc_$block (addr (wait_list), addr (message), ecode);
      372 						/* wait */
      373 	if ecode ^= 0 then
      374 	     go to reset;				/* always reset the signal */
      375 
      376 	tseg.sync = 1;				/* do a synchronous reset status */
      377 	tseg.command_count = 1;
      378 	tseg.buffer_count = 0;
      379 	tseg.command_queue (1) = 100000b;
      380 	call tdcm_$tdcm_iocall (addr (tseg), ecode);
      381 
      382 	if tseg.completion_status ^= 1 then
      383 	     go to again;
      384 
      385 reset:
      386 	call tdcm_$tdcm_reset_signal (addr (tseg), 0);	/* no more signalling */
      387 	if vl (vX).rcp_id ^= 0 then
      388 	     cseg.wait_switch (vl (vX).rcp_id) = "0"b;
      389 
      390 	return;
      391 
      392      end wait;
      393 
      394 VOL1_check:
      395      procedure (ecode);				/* verify VOL1 label */
      396 dcl      ecode		  fixed bin (35),
      397          data		  char (80) unaligned based (cseg.syncP);
      398 						/* 80 characters of synchronous IO buffer */
      399 
      400 	do den = 2 to 4;				/* try to read at 800, 1600, or 6250 bpi */
      401 	     call tape_ansi_tape_io_$order (cP, "rew", 0, ecode);
      402 	     if ecode ^= 0 then
      403 		return;
      404 	     call tape_ansi_tape_io_$order (cP, "sdn", den, ecode);
      405 						/* set density */
      406 	     if ecode = 0				/* if read ok, then ... */
      407 	     then do;
      408 		call tape_ansi_tape_io_$sync_read (cP, i, ecode);
      409 						/* try to read VOL1 label */
      410 		if ecode = 0 then do;		/* read was uneventful */
      411 		     if i >= 80 then do;		/* could be a label */
      412 			if cseg.standard = 1 then
      413 			     cseg.lbl_buf = data;	/* ascii - put in lbl_buf */
      414 			else call ebcdic_to_ascii_ (data, cseg.lbl_buf);
      415 						/* ebcdic - convert move to lbl_buf */
      416 			go to got_it;		/* check whatever we got */
      417 		     end;
      418 		     else do;			/* can't be a VOL1 label */
      419 invalid_VOL1:
      420 			vl (vX).write_VOL1 = 3;	/* indicate not valid VOL1 label */
      421 			go to wvol1;
      422 		     end;
      423 		end;
      424 		else if ecode = error_table_$eof_record then
      425 		     goto invalid_VOL1;
      426 		else if ecode = error_table_$blank_tape then do;
      427 						/* tape is blank */
      428 		     vl (vX).write_VOL1 = 1;		/* indicate blank tape */
      429 		     go to wvol1;
      430 		end;
      431 	     end;
      432 	end;
      433 	vl (vX).write_VOL1 = 2;			/* can't read it (error or 200 or 556 bpi) */
      434 
      435 wvol1:
      436 	if cseg.density = -1 then do;			/* no density specified */
      437 	     if cseg.standard = 1 then
      438 		cseg.density = 2;			/* ANSI default is 800 cpi */
      439 	     else cseg.density = 3;			/* IBM default is 1600 bpi */
      440 	end;
      441 	if cseg.density ^= den then do;		/* must set density again */
      442 	     call tape_ansi_tape_io_$order (cP, "rew", 0, ecode);
      443 						/* rewind to set density */
      444 	     if ecode ^= 0 then
      445 		return;
      446 	     call tape_ansi_tape_io_$order (cP, "sdn", (cseg.density), ecode);
      447 						/* set density) */
      448 	end;
      449 	else ecode = 0;
      450 	return;
      451 
      452 got_it:
      453 	if VOL1_label_id ^= "VOL1" then
      454 	     go to invalid_VOL1;			/* not VOL1 label */
      455 
      456 	if cseg.standard = 1 then do;			/* ANSI - test 80th character */
      457 	     i = cv_dec_check_ (VOL1_80th_char, ecode);	/* convert to binary */
      458 	     if ecode ^= 0 then
      459 		go to invalid_VOL1;			/* not number - invalid */
      460 	     if i < 1 then
      461 		go to invalid_VOL1;			/* must be 1 <_ i <_ 3 */
      462 	     if i > 3 then
      463 		go to invalid_VOL1;
      464 	end;
      465 
      466 /*
      467*   if VOL1_volume_id ^= vl (vX).canonical_volname then do; /* identifiers don't match * /
      468*   vl (vX).write_VOL1 = 4;		/* indicate wrong volume identifier * /
      469*   go to wvol1;
      470*   end;
      471**/
      472 
      473 	if (cseg.density = -1) | (cseg.density = den) then do;
      474 						/* all seems well */
      475 	     cseg.density = den;			/* set it to that of the tape */
      476 
      477 /* check the format of the VOL1 label for earlier Multics format */
      478 
      479 	     ibm_vol1P, ansi_vol1P = addr (cseg.lbl_buf);
      480 	     vl (vX).auth_code = authenticate_ (vl (vX).volname);
      481 
      482 	     if cseg.standard = 1 then
      483 		if ansi_vol1.owner_id.auth_code = vl (vX).auth_code then
      484 		     vl (vX).write_VOL1 = 0;
      485 		else vl (vX).write_VOL1 = -1;
      486 	     else if ibm_vol1.owner_id.auth_code = vl (vX).auth_code then
      487 		vl (vX).write_VOL1 = 0;
      488 	     else vl (vX).write_VOL1 = -1;
      489 
      490 	     ecode = 0;				/* and no errors */
      491 	     return;				/* so just exit */
      492 	end;
      493 
      494 	vl (vX).write_VOL1 = 5;			/* density doesn't match */
      495 	go to wvol1;				/* change tape density to specified value */
      496 
      497      end VOL1_check;
      498 
      499 /*
      500*   hdr_eox_check: procedure (ecode);
      501*
      502*   dcl  label_id char (4) based (addr (cseg.lbl_buf));
      503*
      504*
      505*   dcl  data char (80) unaligned based (cseg.syncP),
      506*   i fixed bin,
      507*   j fixed bin,
      508*   ecode fixed bin (35),
      509*   nchar fixed bin;
      510*
      511*
      512*   /* Enter here after successfully read and verified the VOL1 label. * /
      513*   /* check for file header and trailer labels to complete the tape verification for the ANSI standard * /
      514*
      515*
      516*   ecode = 0;				/* initialize * /
      517*
      518*
      519*   do j = 1 to 2;				/* read an 80 char label synchronously: 1st HDR1 then EOX1 * /
      520*   call tape_ansi_tape_io_$sync_read (cP, nchar, ecode); /* read a block looking for HDR1 * /
      521*   if ecode ^= 0 then go to non_standard;	/* trouble already * /
      522*   else do;				/* read was uneventful * /
      523*   if nchar < 80 then go to non_standard; /* definitely not a label * /
      524*   else do;
      525*   if cseg.standard = 1 then cseg.lbl_buf = data; /* move into buffer * /
      526*   else call ebcdic_to_ascii_ (data, cseg.lbl_buf); /* translate to ascii * /
      527*   end;
      528*   if j = 1 then do;		/* looking for HDR1 * /
      529*   if label_id ^= "HDR1" then go to non_standard;
      530*   do i = 1 to 2;		/* get to trailer label position * /
      531*   call tape_ansi_tape_io_$order (cP, "fsf", 0, ecode);
      532*   /* 1st space past header labels; then past file * /
      533*   if ecode ^= 0 then do;
      534*   /* might be eof: that's ok * /
      535*
      536*
      537*   end;
      538*   end;
      539*   end;
      540*   end;
      541*
      542*   end;
      543*   if label_id = "EOF1" | label_id = "EOV1" then return;
      544*   non_standard:  ecode = error_table_$invalid_file_set_format;
      545*   return;
      546*
      547*   end hdr_eox_check;
      548**/
      549 
      550 mount_request:
      551      procedure;					/* issues mount message to operator and waits */
      552 dcl      msg_temp		  char (66) varying,
      553          (tdcm_reel_name, save_tdcm_reel_name)
      554 			  char (168),		/* reel name)to/from tdcm_$tdcm_message */
      555          canon_std		  (2) fixed bin initial (Volume_ansi_tape, Volume_ibm_tape);
      556 
      557 once_again:
      558 	call tdcm_$tdcm_set_signal (addr (tseg), code);	/* interrupt when mounted */
      559 	if code ^= 0 then
      560 	     go to er_exit;				/* trouble */
      561 	if cseg.write_ring then
      562 	     part = "a";
      563 	else part = "no";
      564 	call ioa_ ("Mounting volume ^a with ^a write ring.",
      565 						/* write message to user */
      566 	     vl (vX).volname, part);
      567 	if vl (vX).comment = "" then
      568 	     msg_temp = "";
      569 	else msg_temp = ",*" || vl (vX).comment;
      570 	save_tdcm_reel_name, tdcm_reel_name = rtrim (vl (vX).volname) || msg_temp;
      571 	call tdcm_$tdcm_message (addr (tseg), tdcm_reel_name, binary (cseg.write_ring, 17), code);
      572 	if code ^= 0 then
      573 	     go to er_exit;				/* trouble */
      574 
      575 	if save_tdcm_reel_name ^= tdcm_reel_name then do;
      576 	     vl (vX).volname = before (tdcm_reel_name, ",");
      577 	     call canon_for_volume_label_ (VOLUME_TYPE (TAPE_VOL_VTYPEX), vl (vX).volname, vl (vX).canonical_volname,
      578 		canon_std (standard), code);
      579 	     if code ^= 0 then
      580 		goto er_exit;
      581 	end;
      582 
      583 	call wait (code);				/* wait for mount */
      584 	if code ^= 0 then
      585 	     go to er_exit;				/* trouble */
      586 	if cseg.write_ring then
      587 	     call ring_check;			/* did ring get in?? */
      588 	drive_name = tseg.drive_name;
      589 	call ioa_ ("^a mounted on ^a.",		/* inform user */
      590 	     vl (vX).volname, drive_name);
      591 
      592 	return;
      593 
      594 
      595 ring_check:
      596 	procedure;				/* insures that ring is in tape */
      597 
      598 /* reset status op in wait procedure set status bits */
      599 	     if substr (hardware_status, 3, 4) = "0000"b then
      600 		if substr (hardware_status, 12, 1) = "1"b then do;
      601 						/* if write protected still... */
      602 		     if can_retry then do;		/* try to remount with ring only once */
      603 			can_retry = "0"b;
      604 			call ioa_ ("^a mounted without ring - retrying.",
      605 						/* tell user */
      606 			     vl (vX).volname);
      607 			call unload;
      608 			go to once_again;		/* retry the mount */
      609 		     end;
      610 		     else do;			/* 2nd try failed as well */
      611 			code = error_table_$bad_mount_request;
      612 			go to er_exit;
      613 		     end;
      614 		end;
      615 
      616 	     return;				/* ring is in tape */
      617 
      618 	end ring_check;
      619 
      620      end mount_request;
      621 
      622 
      623 
      624 unload:
      625      procedure;					/* unloads a drive */
      626 
      627 	call tape_ansi_tape_io_$order (cP, "run", 0, code);
      628 						/* will wait for, but not set, signal */
      629 	if code ^= 0 then
      630 	     go to er_exit;
      631 
      632 	call tdcm_$tdcm_reset_signal (addr (tseg), 0);	/* redundant, but just in case... */
      633 	cseg.wait_switch (vl (vX).rcp_id) = "0"b;
      634 
      635 	return;
      636 
      637      end unload;
      638 
      639 
      640      end tape_ansi_mount_cntl_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/17/86  0829.4  tape_ansi_mount_cntl_.pl1         >special_ldd>install>MR12.0-1250>tape_ansi_mount_cntl_.pl1
88           1    06/10/82  1045.3  tape_ansi_cseg.incl.pl1           >ldd>include>tape_ansi_cseg.incl.pl1
90           2    10/06/83  1413.5  ibm_vol1.incl.pl1                 >ldd>include>ibm_vol1.incl.pl1
92           3    10/06/83  1413.4  ansi_vol1.incl.pl1                >ldd>include>ansi_vol1.incl.pl1
94           4    12/17/86  0758.3  rcp_volume_formats.incl.pl1       >special_ldd>install>MR12.0-1250>rcp_volume_formats.incl.pl1
96           5    03/27/86  1120.0  rcp_resource_types.incl.pl1       >ldd>include>rcp_resource_types.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
TAPE_VOL_VTYPEX                        constant        fixed bin(17,0)          initial dcl 5-37 ref 577
VOL1_80th_char                         based           char(1)                  unaligned dcl 113 set ref 457*
VOL1_label_id                          based           char(4)                  unaligned dcl 110 ref 452
VOLUME_TYPE                     000000 constant        char(32)                 initial array unaligned dcl 5-25 set ref 577*
Volume_ansi_tape                       constant        fixed bin(17,0)          initial dcl 4-15 ref 552
Volume_ibm_tape                        constant        fixed bin(17,0)          initial dcl 4-15 ref 552
addr                                                   builtin function         dcl 120 ref 188 188 193 193 304 304 306 306 333 333
                                                                                  335 335 371 371 371 371 380 380 385 385 452 457
                                                                                  479 557 557 571 571 632 632
ansi_vol1                              based           structure                level 1 packed unaligned dcl 3-7
ansi_vol1P                      000102 automatic       pointer                  dcl 3-5 set ref 479* 482
auth_code                12(09)        based           char(3)                  level 3 in structure "ibm_vol1" packed unaligned
                                                                                  dcl 2-7 in procedure "tape_ansi_mount_cntl_" ref
                                                                                  486
auth_code                11(09)        based           char(3)                  level 3 in structure "ansi_vol1" packed unaligned
                                                                                  dcl 3-7 in procedure "tape_ansi_mount_cntl_" ref
                                                                                  482
auth_code                              based           char(3)                  array level 4 in structure "cseg" dcl 1-14
                                                                                  in procedure "tape_ansi_mount_cntl_" set ref 480*
                                                                                  482 486
authenticate_                   000010 constant        entry                    external dcl 124 ref 480
before                                                 builtin function         dcl 120 ref 576
binary                                                 builtin function         dcl 120 ref 571 571
buf_size                310            based           fixed bin(17,0)          level 2 dcl 1-14 ref 192 193 193 201 203 204 205 206
                                                                                  217 228 229 230 234 237 249 250 251 252 253 277
                                                                                  278 279 280 298 299 300 301 305 307 308 309 317
                                                                                  334 339 340 341 346 348 387 387 419 428 433 480
                                                                                  480 482 482 485 486 486 488 494 564 567 569 570
                                                                                  576 577 577 589 604 633
buffer_count            341            based           fixed bin(12,0)          level 3 dcl 1-14 set ref 186* 378*
cP                                     parameter       pointer                  dcl 1-11 set ref 154 161 165 166 168 168 170 171 171
                                                                                  173 177 177 179 179 181 181 183 186 187 188 188
                                                                                  191 191 192 193 193 193 193 201 201 203 203 203
                                                                                  204 204 204 205 205 205 206 206 217 217 223 228
                                                                                  228 228 229 229 229 230 230 230 234 234 237 237
                                                                                  243 247 248 249 249 250 250 250 251 251 251 252
                                                                                  252 252 253 253 261 265 268 272 276 277 277 278
                                                                                  278 278 279 279 279 280 280 280 281* 293 298 298
                                                                                  298 299 299 299 300 300 300 301 301 304 304 305
                                                                                  305 305 306 306 307 307 308 308 309 309 312 312
                                                                                  314 317 317 318 332 333 333 334 334 334 335 335
                                                                                  336 336 338 339 339 340 340 341 341 343 344 345
                                                                                  346 346 348 348 369 376 377 378 379 380 380 382
                                                                                  385 385 387 387 387 387 387 401* 404* 408* 412 412
                                                                                  412 414 414 419 419 428 428 433 433 435 437 437
                                                                                  439 441 442* 446* 446 452 456 457 473 473 475 479
                                                                                  480 480 480 480 482 482 482 482 482 485 485 486
                                                                                  486 486 486 488 488 494 494 557 557 561 564 564
                                                                                  567 567 569 569 570 570 571 571 571 571 576 576
                                                                                  577 577 577 577 577 586 588 589 589 599 599 604
                                                                                  604 627* 632 632 633 633 633
can_retry                       000104 automatic       bit(1)                   initial unaligned dcl 101 set ref 101* 602 603*
canon_for_volume_label_         000014 constant        entry                    external dcl 124 ref 577
canon_std                       000344 automatic       fixed bin(17,0)          initial array dcl 552 set ref 552* 552* 577*
canonical_volname                      based           char(6)                  array level 4 packed unaligned dcl 1-14 set ref 577*
cflX                                   based           fixed bin(17,0)          array level 4 packed unaligned dcl 1-14 set ref 206*
                                                                                  234* 253* 301* 348*
chn                       2     000146 automatic       fixed bin(71,0)          level 2 dcl 355 set ref 369*
cleanup                         000124 stack reference condition                dcl 117 ref 159 232 246 274 302
code                                   parameter       fixed bin(35,0)          dcl 84 set ref 154 161* 162 188* 189 193* 194 208*
                                                                                  209 216 218* 223 243 261 268 281* 283 293 306* 310
                                                                                  314* 315 324* 557* 559 571* 572 577* 579 583* 584
                                                                                  611* 627* 629
command_count           345            based           fixed bin(12,0)          level 3 dcl 1-14 set ref 377*
command_queue           346            based           fixed bin(6,0)           array level 3 dcl 1-14 set ref 379*
comment                                based           varying char(64)         array level 4 dcl 1-14 ref 567 569
completion_status       342            based           fixed bin(2,0)           level 3 dcl 1-14 set ref 382
cseg                                   based           structure                level 1 unaligned dcl 1-14
cseg_tseg_version_2                    constant        fixed bin(17,0)          initial dcl 1-12 ref 165
cv_dec_check_                   000012 constant        entry                    external dcl 124 ref 457
data                                   based           char(80)                 unaligned dcl 396 set ref 412 414*
den                             000105 automatic       fixed bin(17,0)          dcl 101 set ref 400* 404* 441 473 475
density                 125            based           fixed bin(17,0)          level 2 in structure "cseg" dcl 1-14 in procedure
                                                                                  "tape_ansi_mount_cntl_" set ref 170 177 179 181
                                                                                  435 437* 439* 441 446 473 473 475*
density                 335            based           bit(36)                  level 3 in structure "cseg" dcl 1-14 in procedure
                                                                                  "tape_ansi_mount_cntl_" set ref 171* 173* 177*
                                                                                  179* 181* 183*
divide                                                 builtin function         dcl 120 ref 193 193
down_vlX                               parameter       fixed bin(17,0)          dcl 84 ref 223 226
drive_name              324            based           char(32)                 level 3 in structure "cseg" dcl 1-14 in procedure
                                                                                  "tape_ansi_mount_cntl_" set ref 203 228* 250* 278*
                                                                                  298* 332 338* 588
drive_name                      000106 automatic       char(32)                 unaligned dcl 101 in procedure
                                                                                  "tape_ansi_mount_cntl_" set ref 588* 589*
ebcdic_to_ascii_                000016 constant        entry                    external dcl 124 ref 414
ecode                                  parameter       fixed bin(35,0)          dcl 396 in procedure "VOL1_check" set ref 394 401*
                                                                                  402 404* 406 408* 410 424 426 442* 444 446* 449*
                                                                                  457* 458 490*
ecode                           000100 automatic       fixed bin(35,0)          dcl 330 in procedure "cleaner" set ref 335* 336
ecode                                  parameter       fixed bin(35,0)          dcl 354 in procedure "wait" set ref 352 371* 373
                                                                                  380*
error_table_$bad_mount_request  000052 external static fixed bin(35,0)          dcl 148 ref 324 611
error_table_$blank_tape         000056 external static fixed bin(35,0)          dcl 148 ref 426
error_table_$eof_record         000054 external static fixed bin(35,0)          dcl 148 ref 424
ev_chan                 316            based           fixed bin(71,0)          level 3 dcl 1-14 set ref 161* 204 229* 251* 280*
                                                                                  299* 314* 318* 343 344* 345* 369
event_chan                             based           fixed bin(71,0)          array level 4 dcl 1-14 set ref 204* 229 251 280 299
                                                                                  317* 346*
get_size                322            based           fixed bin(1,0)           level 3 dcl 1-14 set ref 187*
hardware_status         343            based           bit(36)                  level 3 dcl 1-14 set ref 599 599
i                               000116 automatic       fixed bin(17,0)          dcl 101 set ref 408* 411 457* 460 462
ibm_vol1                               based           structure                level 1 packed unaligned dcl 2-7
ibm_vol1P                       000100 automatic       pointer                  dcl 2-5 set ref 479* 486
ioa_                            000020 constant        entry                    external dcl 124 ref 564 589 604
ipc_$block                      000022 constant        entry                    external dcl 124 ref 371
ipc_$create_ev_chn              000024 constant        entry                    external dcl 124 ref 161
ipc_$delete_ev_chn              000026 constant        entry                    external dcl 124 ref 314 344
lbl_buf                 152            based           char(80)                 level 2 packed unaligned dcl 1-14 set ref 412* 414*
                                                                                  452 457 479
message                         000152 automatic       structure                level 1 unaligned dcl 358 set ref 371 371
msg_temp                        000176 automatic       varying char(66)         dcl 552 set ref 567* 569* 570
n                               000146 automatic       fixed bin(17,0)          level 2 dcl 355 set ref 367*
nactive                 122            based           fixed bin(17,0)          level 2 dcl 1-14 set ref 191* 191 312* 312 336* 336
op                              000117 automatic       char(3)                  unaligned dcl 101 set ref 264* 271* 281*
owner_id                 11(09)        based           structure                level 2 in structure "ansi_vol1" packed unaligned
                                                                                  dcl 3-7 in procedure "tape_ansi_mount_cntl_"
owner_id                 12(09)        based           structure                level 2 in structure "ibm_vol1" packed unaligned
                                                                                  dcl 2-7 in procedure "tape_ansi_mount_cntl_"
part                            000120 automatic       varying char(2)          dcl 101 set ref 561* 563* 564*
position                               based           structure                array level 3 packed unaligned dcl 1-14
protect                 124            based           bit(1)                   level 2 dcl 1-14 set ref 265* 272*
rcp_id                                 based           fixed bin(6,0)           array level 4 dcl 1-14 set ref 201* 237* 249 277 305
                                                                                  308* 334 341* 387 387 633
rtrim                                                  builtin function         dcl 120 ref 570
save_tdcm_reel_name             000272 automatic       char(168)                unaligned dcl 552 set ref 570* 575
speed                   336            based           bit(36)                  level 3 dcl 1-14 set ref 168* 168
standard                  2            based           fixed bin(17,0)          level 2 dcl 1-14 ref 171 412 437 456 482 577
substr                                                 builtin function         dcl 120 ref 457 599 599
sync                    321            based           fixed bin(1,0)           level 3 dcl 1-14 set ref 376*
syncP                   260            based           pointer                  level 2 dcl 1-14 ref 412 414
tape_ansi_tape_io_$order        000030 constant        entry                    external dcl 124 ref 281 401 404 442 446 627
tape_ansi_tape_io_$sync_read    000032 constant        entry                    external dcl 124 ref 408
tape_drive                             based           char(32)                 array level 4 packed unaligned dcl 1-14 set ref 203*
                                                                                  228 250 278 298 307* 340*
tdcm_$tdcm_attach               000034 constant        entry                    external dcl 124 ref 188
tdcm_$tdcm_detach               000040 constant        entry                    external dcl 124 ref 306 335
tdcm_$tdcm_iocall               000042 constant        entry                    external dcl 124 ref 380
tdcm_$tdcm_message              000044 constant        entry                    external dcl 124 ref 571
tdcm_$tdcm_reset_signal         000046 constant        entry                    external dcl 124 ref 304 333 385 632
tdcm_$tdcm_set_buf_size         000036 constant        entry                    external dcl 124 ref 193
tdcm_$tdcm_set_signal           000050 constant        entry                    external dcl 124 ref 557
tdcm_reel_name                  000220 automatic       char(168)                unaligned dcl 552 set ref 570* 571* 575 576
tracks                  334            based           fixed bin(17,0)          level 3 dcl 1-14 set ref 166*
tseg                    312            based           structure                level 2 dcl 1-14 set ref 188 188 193 193 304 304 306
                                                                                  306 333 333 335 335 380 380 385 385 557 557 571
                                                                                  571 632 632
vX                              000122 automatic       fixed bin(17,0)          dcl 101 set ref 157* 201 201 203 204 205 206 217
                                                                                  226* 228 229 230 234 237 239* 248* 249 250 251 252
                                                                                  253* 276* 277 278 279 280* 296* 298 299 300 301
                                                                                  305 307 308 309 317 334 339 340 341 346 348 387
                                                                                  387 419 428 433 480 480 482 482 485 486 486 488
                                                                                  494 564 567 569 570 576 577 577 589 604 633
vcN                     126            based           fixed bin(17,0)          level 2 dcl 1-14 ref 248 276
version_num             312            based           fixed bin(17,0)          level 3 dcl 1-14 set ref 165*
vl                                     based           structure                array level 2 unaligned dcl 1-14
vlX                                    parameter       fixed bin(17,0)          dcl 84 ref 154 157 223 239 293 296
vol_data                               based           structure                array level 3 unaligned dcl 1-14
volname                                based           char(32)                 array level 4 packed unaligned dcl 1-14 set ref 480*
                                                                                  564* 570 576* 577* 589* 604*
wait_list                       000146 automatic       structure                level 1 unaligned dcl 355 set ref 371 371
wait_switch             306            based           bit(1)                   array level 2 packed unaligned dcl 1-14 set ref 305*
                                                                                  334* 387* 633*
write_VOL1                             based           fixed bin(17,0)          array level 4 dcl 1-14 set ref 217* 419* 428* 433*
                                                                                  482* 485* 486* 488* 494*
write_ring              123            based           bit(1)                   level 2 dcl 1-14 set ref 247* 561 571 571 586
ws_segno                               based           bit(18)                  array level 4 in structure "cseg" packed unaligned
                                                                                  dcl 1-14 in procedure "tape_ansi_mount_cntl_" set
                                                                                  ref 205* 230 252 279 300 309* 339*
ws_segno                323            based           bit(18)                  level 3 in structure "cseg" dcl 1-14 in procedure
                                                                                  "tape_ansi_mount_cntl_" set ref 205 230* 252* 279*
                                                                                  300*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANSI_VOL1                              internal static char(4)                  initial unaligned dcl 3-19
CONSOLE_DTYPEX                         internal static fixed bin(17,0)          initial dcl 5-31
DEVICE_TYPE                            internal static char(32)                 initial array unaligned dcl 5-18
DISK_DRIVE_DTYPEX                      internal static fixed bin(17,0)          initial dcl 5-30
DISK_VOL_VTYPEX                        internal static fixed bin(17,0)          initial dcl 5-38
IBM_VOL1                               internal static char(4)                  initial unaligned dcl 2-18
LABEL_STANDARD_VERSION                 internal static char(1)                  initial unaligned dcl 3-20
MCA_DTYPEX                             internal static fixed bin(17,0)          initial dcl 5-36
MULTICS_ANSI_VERSION                   internal static char(7)                  initial unaligned dcl 3-22
MULTICS_IBM_VERSION                    internal static char(7)                  initial unaligned dcl 2-19
NUM_QUALIFIERS                         internal static fixed bin(17,0)          initial array dcl 5-22
PRINTER_DTYPEX                         internal static fixed bin(17,0)          initial dcl 5-32
PUNCH_DTYPEX                           internal static fixed bin(17,0)          initial dcl 5-33
READER_DTYPEX                          internal static fixed bin(17,0)          initial dcl 5-34
SPECIAL_DTYPEX                         internal static fixed bin(17,0)          initial dcl 5-35
TAPE_DRIVE_DTYPEX                      internal static fixed bin(17,0)          initial dcl 5-29
Tape_volume_types                      internal static char(16)                 initial array unaligned dcl 4-29
Volume_blank                           internal static fixed bin(17,0)          initial dcl 4-15
Volume_gcos_tape                       internal static fixed bin(17,0)          initial dcl 4-15
Volume_multics_tape                    internal static fixed bin(17,0)          initial dcl 4-15
Volume_unauthenticated                 internal static fixed bin(17,0)          initial dcl 4-15
Volume_unknown_format                  internal static fixed bin(17,0)          initial dcl 4-15
Volume_unreadable                      internal static fixed bin(17,0)          initial dcl 4-15

NAMES DECLARED BY EXPLICIT CONTEXT.
VOL1_check                      002101 constant        entry                    internal dcl 394 ref 208
again                           001747 constant        label                    dcl 367 ref 382
cleaner                         001515 constant        entry                    internal dcl 328 ref 159 232 246 274 302 322
com                             001066 constant        label                    dcl 274 ref 266
er_exit                         001504 constant        label                    dcl 322 ref 189 194 209 283 310 315 559 572 579 584
                                                                                  612 629
free                            001214 constant        entry                    external dcl 293
got_it                          002431 constant        label                    dcl 452 ref 416
insert_rings                    000666 constant        entry                    external dcl 243
invalid_VOL1                    002234 constant        label                    dcl 419 ref 424 452 458 460 462
mount                           000201 constant        entry                    external dcl 154
mount_request                   002652 constant        entry                    internal dcl 550 ref 198 255
once_again                      002664 constant        label                    dcl 557 ref 608
remount                         000521 constant        entry                    external dcl 223
reset                           002034 constant        label                    dcl 385 ref 373
ring_check                      003331 constant        entry                    internal dcl 595 ref 586
tape_ansi_mount_cntl_           000166 constant        entry                    external dcl 80
unload                          003413 constant        entry                    internal dcl 624 ref 235 254 607
up                              000373 constant        label                    dcl 198 ref 241
wait                            001745 constant        entry                    internal dcl 352 ref 583
write_permit                    001047 constant        entry                    external dcl 268
write_protect                   001024 constant        entry                    external dcl 261
wvol1                           002333 constant        label                    dcl 435 ref 421 429 495

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4070        4150    3506        4100
Length      4522    3506        60         335     361           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
tape_ansi_mount_cntl_               428 external procedure  is an external procedure.  
on unit on line 159                  64 on unit               
on unit on line 232                  64 on unit               
on unit on line 246                  64 on unit               
on unit on line 274                  64 on unit               
on unit on line 302                  64 on unit               
cleaner                              75 internal procedure  is called by several nonquick procedures.  
wait                                    internal procedure  shares stack frame of external procedure tape_ansi_mount_cntl_.  
VOL1_check                              internal procedure  shares stack frame of external procedure tape_ansi_mount_cntl_.  
mount_request                           internal procedure  shares stack frame of external procedure tape_ansi_mount_cntl_.  
ring_check                              internal procedure  shares stack frame of external procedure tape_ansi_mount_cntl_.  
unload                                  internal procedure  shares stack frame of external procedure tape_ansi_mount_cntl_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cleaner                  000100 ecode                       cleaner
tape_ansi_mount_cntl_    000100 ibm_vol1P                   tape_ansi_mount_cntl_
                         000102 ansi_vol1P                  tape_ansi_mount_cntl_
                         000104 can_retry                   tape_ansi_mount_cntl_
                         000105 den                         tape_ansi_mount_cntl_
                         000106 drive_name                  tape_ansi_mount_cntl_
                         000116 i                           tape_ansi_mount_cntl_
                         000117 op                          tape_ansi_mount_cntl_
                         000120 part                        tape_ansi_mount_cntl_
                         000122 vX                          tape_ansi_mount_cntl_
                         000146 wait_list                   wait
                         000152 message                     wait
                         000176 msg_temp                    mount_request
                         000220 tdcm_reel_name              mount_request
                         000272 save_tdcm_reel_name         mount_request
                         000344 canon_std                   mount_request

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac
enable_op           shorten_stack       ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
authenticate_                 canon_for_volume_label_       cv_dec_check_                 ebcdic_to_ascii_
ioa_                          ipc_$block                    ipc_$create_ev_chn            ipc_$delete_ev_chn
tape_ansi_tape_io_$order      tape_ansi_tape_io_$sync_read  tdcm_$tdcm_attach             tdcm_$tdcm_detach
tdcm_$tdcm_iocall             tdcm_$tdcm_message            tdcm_$tdcm_reset_signal       tdcm_$tdcm_set_buf_size
tdcm_$tdcm_set_signal

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_mount_request                              error_table_$blank_tape       error_table_$eof_record




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    101 000161        80 000165       154 000174       157 000214       159 000216       161 000240       162 000254
    165 000256       166 000263       168 000264       170 000266       171 000271       173 000277       174 000301
    177 000302       179 000307       181 000314       183 000321       186 000323       187 000324       188 000326
    189 000341       191 000343       192 000347       193 000352       194 000371       198 000373       201 000374
    203 000421       204 000430       205 000436       206 000444       208 000457       209 000465       216 000467
    217 000470       218 000512       221 000513       223 000514       226 000534       228 000537       229 000563
    230 000570       232 000576       234 000620       235 000636       237 000637       239 000657       241 000661
    243 000662       246 000677       247 000721       248 000726       249 000735       250 000760       251 000767
    252 000774       253 001002       254 001015       255 001016       257 001017       259 001021       261 001022
    264 001035       265 001037       266 001044       268 001045       271 001060       272 001062       274 001066
    276 001110       277 001123       278 001145       279 001154       280 001162       281 001167       283 001205
    286 001207       288 001211       293 001212       296 001227       298 001231       299 001256       300 001263
    301 001271       302 001304       304 001326       305 001345       306 001370       307 001403       308 001430
    309 001434       310 001441       312 001443       314 001445       315 001456       317 001460       318 001502
    320 001503       322 001504       324 001510       325 001513       328 001514       332 001522       333 001532
    334 001545       335 001571       336 001604       338 001614       339 001623       340 001643       341 001652
    343 001656       344 001662       345 001674       346 001702       348 001721       349 001744       352 001745
    367 001747       369 001751       371 001756       373 001776       376 002001       377 002006       378 002010
    379 002011       380 002013       382 002026       385 002034       387 002053       390 002100       394 002101
    400 002103       401 002111       402 002133       404 002137       406 002157       408 002162       410 002176
    411 002201       412 002204       414 002217       416 002233       419 002234       421 002256       424 002257
    426 002262       428 002264       429 002306       432 002307       433 002311       435 002333       437 002341
    439 002347       441 002351       442 002354       444 002375       446 002401       448 002425       449 002426
    450 002430       452 002431       456 002437       457 002442       458 002467       460 002472       462 002475
    473 002477       475 002507       479 002511       480 002515       482 002554       485 002600       486 002607
    488 002621       490 002627       491 002631       494 002632       495 002651       550 002652       552 002653
    557 002664       559 002702       561 002704       563 002716       564 002722       567 002762       569 003013
    570 003035       571 003107       572 003142       575 003144       576 003150       577 003202       579 003240
    583 003242       584 003250       586 003252       588 003260       589 003266       592 003330       595 003331
    599 003332       602 003345       603 003347       604 003350       607 003404       608 003405       611 003406
    612 003411       616 003412       624 003413       627 003414       629 003435       632 003437       633 003456
    635 003501


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
