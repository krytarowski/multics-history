	COMPILATION LISTING OF SEGMENT tape_io_interpret_
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 04/19/88  0824.5 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(87-04-13,TLNguyen), approve(87-04-13,MCR7664),
       12*     audit(87-06-08,GWMay), install(87-07-15,MR12.1-1040):
       13*     make tape_in able to read imcomplete ANSI tapes.
       14*  2) change(88-02-03,GWMay), approve(88-02-03,MCR7837), audit(88-04-12,Farley),
       15*     install(88-04-19,MR12.2-1039):
       16*     Reformatted and simplified error messages.
       17*     changed to pass the value of abort_sw to the close_tape_file
       18*     routine.
       19*                                                   END HISTORY COMMENTS */
       20 
       21 
       22 tape_io_interpret_: proc (arg_tape_io_data_ptr);
       23 
       24 /* format: style4 */
       25 /* tape_io_interpret_ - This module interprets the Volume Control Blocks (VCBs)
       26*   and File Control Blocks (FCBs) created from the tcl file by tape_io.rd (with
       27*   the aid of the reduction compiler package), and does the actual tape to SS file
       28*   (tape_in) or SS file to tape (tape_out) I/O.
       29*
       30*   Modification History:
       31*   Created circa 1979 by M. R. Jordan by extracting required functionality from tape_io.rd
       32*   Completed and extensively modified 4/82 by J. A. Bush for understandability and
       33*   to make it easier to convert to future improved tape software.
       34*   Modfied 10/26/82 by J. A. Bush to fix bugs (phx10501, phx13989)
       35**/
       36 
       37 /* PARAMETERS */
       38 
       39 dcl  arg_tape_io_data_ptr ptr;
       40 
       41 
       42 /* BASED STORAGE */
       43 
       44 dcl  1 input_record based (wt_ptr) unaligned,		/* template for writing input record */
       45        2 cw char (amrl),				/* number of chars to write */
       46        2 next_char bit (0);				/* to allow setting ptr to end of last record */
       47 
       48 /* AUTOMATIC STORAGE */
       49 
       50 dcl  1 ads like device_status;			/* auto copy of device_status structure */
       51 dcl  1 atfs like tape_file_status;			/* auto copy of tape_file_status structure */
       52 
       53 dcl  1 tape_attach_descp aligned,			/* iox_ attachment descption structure for tape */
       54        2 vol_string char (256) varying,			/* volume portion of attach desc */
       55        2 file_string char (256) varying,		/* file portion of attach desc */
       56        2 string char (512) varying;			/* full attach description */
       57 
       58 dcl  1 vfile_info aligned,				/* structure for vfile_status_ */
       59        2 info_version fixed,
       60        2 type fixed,
       61        2 records fixed (34),
       62        2 flags aligned,
       63          3 lock_status bit (2) unaligned,
       64          3 pad bit (34) unaligned,
       65        2 version fixed,
       66        2 action fixed,
       67        2 max_rec_len fixed (21);
       68 
       69 /* automatic storage */
       70 dcl  add_specified_attributes bit (1);
       71 dcl  abort_sw bit (1) aligned;
       72 dcl  amrl fixed bin (21);				/* number of chars requested/transmitted per io xfer */
       73 dcl  answer char (128) varying;
       74 dcl  blkl picture "zzzzzzz9";
       75 dcl  recl picture "zzzzzzz9";
       76 dcl  secq picture "zzz9";
       77 dcl  blockl fixed bin (21);
       78 dcl  char_cnt fixed bin (21);				/* number of characters transferred per fcb io action */
       79 dcl  code fixed bin (35);				/* error code */
       80 dcl  cont_sw bit (1);
       81 dcl  control_sw bit (1);
       82 dcl  db_sw bit (1) init ("0"b);
       83 dcl  end_of_data bit (1);				/* EOD detected bit */
       84 dcl  end_of_tape bit (1);				/* EOT detected bit */
       85 dcl  file_count fixed bin;
       86 dcl  fileid char (17) varying;
       87 dcl  fnbr fixed bin;
       88 dcl  i fixed bin;					/* temporary storage */
       89 dcl  longinfo char (100) aligned;
       90 dcl  name char (8) varying;				/* command name */
       91 dcl  pathname char (168) varying;
       92 dcl  rcode fixed bin (35);
       93 dcl  ring_sw bit (1);				/* switch to make sure a ring gets in tape mounted for sqi */
       94 dcl  (blen, rlen, wlen, b_offset) fixed bin (21);
       95 dcl  wt_ptr ptr;
       96 dcl  shortinfo char (8) aligned;
       97 dcl  ss_atd char (256);
       98 dcl  ss_iocbp ptr initial (null);
       99 dcl  ss_open_mode fixed bin;
      100 dcl  ss_switch char (26);				/* file switch name */
      101 dcl  tape_iocbp ptr;
      102 dcl  tape_switch char (26);				/* tape_switch name */
      103 dcl  tstring char (256) varying;
      104 dcl  vol_init bit (1);				/* ON => develop volume portion of attach desc */
      105 dcl  writeff_sw bit (1);
      106 dcl  zlck bit (1) aligned;
      107 dcl  cant_cont bit (1) aligned;
      108 dcl  output bit (1) aligned;				/* shorter form of tape_io_data.control.writing */
      109 dcl  io_started bit (1) aligned;
      110 
      111 /* CONSTANTS */
      112 
      113 dcl  IBMNL fixed bin internal static options (constant) init (3);
      114 dcl  IBMDOS fixed bin internal static options (constant) init (4);
      115 dcl  q_mess1 char (57) int static options (constant) init
      116 	("ride the control file and read the storage system file as");
      117 dcl  q_mess2 char (56) int static options (constant) init
      118 	("write this storage system file by changing its format to");
      119 dcl  DENSITY (4) char (4) varying internal static options (constant) init ("", "800", "1600", "6250");
      120 dcl  FORMAT (11) char (3) varying internal static options (constant) init
      121 	("u", "f", "d", "v", "fb", "db", "vb", "s", "sb", "vs", "vbs");
      122 dcl  MODE (3) char (8) varying internal static options (constant) init
      123 	("ascii", "ebcdic", "binary");
      124 dcl  IO_MODULE_NAME (4) char (12) varying internal static options (constant) init
      125 	("tape_ansi_", "tape_ibm_", "tape_ibm_", "tape_ibm_");
      126 dcl  OUTPUT_MODE (4) char (12) varying internal static options (constant) init
      127 	(" -extend ", " -modify ", " -generate ", " -create ");
      128 dcl  sys_info$max_seg_size fixed bin (35) external static;	/* maximum segment size in words */
      129 dcl  wks_ptr ptr int static init (null);		/* I/O buffer pointer */
      130 dcl  (tape_attached, tape_opened, ss_file_attached, ss_file_opened) bit (1) aligned int static init ("0"b);
      131 dcl  cleanup condition;
      132 
      133 /* ERROR CODES */
      134 
      135 dcl  error_table_$dirseg fixed bin (35) ext static;
      136 dcl  error_table_$end_of_info fixed bin (35) ext static;
      137 dcl  error_table_$eov_on_write fixed bin (35) ext static;
      138 dcl  error_table_$file_busy fixed bin (35) ext static;
      139 dcl  error_table_$insufficient_open fixed bin (35) ext static;
      140 dcl  error_table_$moderr fixed bin (35) ext static;
      141 dcl  error_table_$no_file fixed bin (35) ext static;
      142 dcl  error_table_$noentry fixed bin (35) ext static;
      143 dcl  error_table_$short_record fixed bin (35) ext static;
      144 
      145 
      146 /* BUILTIN FUNCTIONS */
      147 
      148 dcl  addr builtin;
      149 dcl  fixed builtin;
      150 dcl  ltrim builtin;
      151 dcl  min builtin;
      152 dcl  null builtin;
      153 dcl  rtrim builtin;
      154 dcl  substr builtin;
      155 
      156 
      157 /* EXTERNAL PROCEDURES */
      158 
      159 dcl  com_err_ ext entry options (variable);
      160 dcl  command_query_ ext entry options (variable);
      161 dcl  convert_status_code_ ext entry (fixed bin (35), char (8) aligned, char (100) aligned);
      162 dcl  cu_$cl entry;
      163 dcl  ioa_ ext entry options (variable);
      164 dcl  get_temp_segment_ entry (char (*), ptr, fixed bin (35));
      165 dcl  release_temp_segment_ entry (char (*), ptr, fixed bin (35));
      166 dcl  iox_$attach_name entry (char (*), ptr, char (*), ptr, fixed bin (35));
      167 dcl  iox_$close entry (ptr, fixed bin (35));
      168 dcl  iox_$control entry (ptr, char (*), ptr, fixed bin (35));
      169 dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
      170 dcl  iox_$open entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
      171 dcl  iox_$read_record entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
      172 dcl  iox_$write_record entry (ptr, ptr, fixed bin (21), fixed bin (35));
      173 dcl  requote_string_ entry (char (*)) returns (char (*));
      174 dcl  vfile_status_ entry (char (*), char (*), ptr, fixed (35));
      175 
      176 	tape_io_data_ptr = arg_tape_io_data_ptr;	/* copy arg */
      177 	output = tape_io_data.control.writing_tape;	/* makes program easier to read */
      178 	if output then				/* if writing tape, this is tape_out */
      179 	     name = "tape_out";
      180 	else name = "tape_in";
      181 
      182 	call get_temp_segment_ ((name), wks_ptr, code);	/* get a buffer segment */
      183 	if code ^= 0 then do;
      184 	     call com_err_ (code, name, "Attempting to get tape I/O buffer segment");
      185 	     return;
      186 	end;
      187 	query_info.version = query_info_version_4;	/* set version number */
      188 	vfile_info.info_version = 1;			/* set vfile_status_ info structure version */
      189 	file_count = 0;
      190 	ss_switch = name || "_" || "ss_file";		/* initialize the SS file switch */
      191 	abort_sw, writeff_sw = "0"b;
      192 	ss_iocbp, tape_iocbp = null;
      193 	blen = sys_info$max_seg_size * 4;		/* set buffer size to max */
      194 	ring_sw = output | tape_io_data.control.ring;
      195 	on cleanup call Cleaner ();			/* establish cleanup handler */
      196 
      197 	do vcb_ptr = first_vcb_ptr repeat vcb.next_vcb_ptr while (vcb_ptr ^= null () & ^abort_sw);
      198 	     vol_init = "1"b;			/* set the init flag for each volume-group */
      199 	     fnbr = 0;				/* reset the file number */
      200 	     tape_switch = name || "_" || vcb.volid (1);
      201 	     do fcb_ptr = vcb.first_fcb_ptr repeat fcb.next_fcb_ptr while (fcb_ptr ^= null () & ^abort_sw);
      202 		call fcb_worker;			/* perform requested io */
      203 	     end;
      204 	end;
      205 
      206 	if ^abort_sw then
      207 	     call ioa_ ("^/^a: Completed processing of  ^a>^a: ^d ^[file^;files^] transferred.", name,
      208 		tape_io_data.source.dirname, tape_io_data.source.ename, file_count, (file_count = 1));
      209 
      210 	call Cleaner ();				/* close and detach resources still opened or attached */
      211 
      212 	return;
      213 
      214 fcb_worker: procedure;				/* performs io */
      215 
      216 	char_cnt, blockl = 0;
      217 	end_of_data, abort_sw, control_sw, cont_sw = "0"b;/* (re-) set  */
      218 	if fcb.tape.file_id ^= "*" then		/* set fileid for error msg */
      219 	     fileid = rtrim (fcb.tape.file_id);
      220 	else do;					/* if name = * then use  file number for error msg */
      221 	     secq = fixed (fcb.tape.sequence);
      222 	     fileid = "#" || ltrim (secq);
      223 	end;
      224 	goto FORMAT (fcb.tape.format);		/* dispatch on format */
      225 FORMAT (0):					/* not specified */
      226 	amrl = sys_info$max_seg_size * 4;		/* assume the worst */
      227 	goto COMMON_WORK;
      228 
      229 FORMAT (1):					/* U */
      230 	amrl = fcb.tape.blklen;			/* U - try to get blklen characters */
      231 	goto COMMON_WORK;
      232 
      233 FORMAT (2):					/* F */
      234 FORMAT (5):					/* FB */
      235 	amrl = fcb.tape.reclen;			/* F or FB - try to get reclen characters */
      236 	goto COMMON_WORK;
      237 
      238 FORMAT (3):					/* D */
      239 FORMAT (4):					/* V */
      240 FORMAT (6):					/* DB */
      241 FORMAT (7):					/* VB */
      242 	amrl = fcb.tape.reclen - 4;			/* D, V, DB or VB - try to get reclen - rcw/rdw characters */
      243 	goto COMMON_WORK;
      244 
      245 FORMAT (8):					/* S */
      246 FORMAT (9):					/* SB */
      247 FORMAT (10):					/* VS */
      248 FORMAT (11):					/* VBS */
      249 	amrl = min (fcb.tape.reclen, sys_info$max_seg_size * 4);
      250 
      251 COMMON_WORK:
      252 	if fcb.segment.dirname = ">" then		/* special case the root dir */
      253 	     pathname = ">" || fcb.segment.ename;
      254 	else pathname = rtrim (fcb.segment.dirname) || ">" || fcb.segment.ename;
      255 	if output then
      256 	     call write_tape ();			/* tape write logic */
      257 	else call read_tape ();			/* tape read logic */
      258 	if char_cnt = 0 & io_started then		/* if no date xfered, tell user */
      259 	     if output then
      260 		call ioa_ ("^a: Storage system file ""^a"", transfer to tape file ^a of volume-set ^a has zero length.",
      261 		     name, pathname, fcb.tape.file_id, vcb.volid (1));
      262 	     else call ioa_ ("^a: Tape file ""^a"" transfer to storage system file ""^a"" has zero length.",
      263 		     name, fileid, pathname);
      264 
      265 	return;					/* exit */
      266 
      267 
      268      end fcb_worker;
      269 
      270 /* read_tape - subroutine to read tape file into SS file */
      271 
      272 read_tape: proc;
      273 
      274 	call check_ss_file;				/* check SS file for access and consistency */
      275 	call build_tape_attach;			/* create tape attach description */
      276 	call open_tape_file;			/* attach and open tape file */
      277 	call open_ss_file;				/* attach  and open SS file */
      278 
      279 /* main processing loop, read tape/write ss file */
      280 
      281 	do while (^end_of_data & ^abort_sw & ^cont_sw);	/* do until no more data */
      282 	     call iox_$read_record (tape_iocbp, wks_ptr, blen, rlen, code);
      283 	     if code = error_table_$end_of_info then	/* EOF detected */
      284 		end_of_data = "1"b;			/* set terminate condition */
      285 	     else if code ^= 0 then			/* we have a real  tape error */
      286 		call check_tape_status;		/* go report it, and determine what to do */
      287 	     else do;				/* good read, write the data into SS file */
      288 		wt_ptr = wks_ptr;			/* start at beginning of buffer */
      289 		b_offset = 0;
      290 		if rlen = 0 then			/* special case for zero length records */
      291 		     zlck = "1"b;
      292 		else zlck = "0"b;			/* not a zero length record */
      293 		do while ((b_offset < rlen | zlck) & ^abort_sw & ^cont_sw); /* do while data to write */
      294 		     zlck = "0"b;			/* only one iteration for zero length records */
      295 		     wlen = min (amrl, rlen - b_offset);/* set length of record to write */
      296 ss_wrt_retry:
      297 		     call iox_$write_record (ss_iocbp, wt_ptr, wlen, code); /* write the SS file record */
      298 		     if code ^= 0 then do;		/* if error writing to SS file */
      299 			call check_ss_file_status;	/* go report it and determine what to do */
      300 			if control_sw then		/* if user fixed problem */
      301 			     go to ss_wrt_retry;
      302 		     end;
      303 		     else do;			/* no error */
      304 			char_cnt = char_cnt + wlen;	/* increment file character count */
      305 			if fcb.segment.truncate_lines = 2 then /* if user want to chop of line.. */
      306 			     b_offset = rlen;	/* set so we only go through once */
      307 			else b_offset = b_offset + wlen; /* increment input record char offset */
      308 			wt_ptr = addr (input_record.next_char); /* increment input data ptr */
      309 		     end;
      310 		end;
      311 
      312 	     end;
      313 	end;
      314 	call close_ss_file;				/* close and detach SS file */
      315 	call close_tape_file (abort_sw);		/* close and detach tape file */
      316 
      317      end read_tape;
      318 
      319 /* write_tape - subroutine to write tape file from SS file */
      320 
      321 write_tape: proc;
      322 
      323 	call check_ss_file;				/* check SS file for access and consistency */
      324 	if fcb.tape.sequence = -1 then do;		/* if "tape_extend" was specified */
      325 	     if fnbr = 0 then			/* and this is the first attachment for this volume */
      326 		call position_to_end;		/* position tape to end of last file on tape */
      327 	     else do;				/* otherwise increment the file number */
      328 		fnbr = fnbr + 1;
      329 		fcb.tape.sequence = fnbr;		/* set the valid sequence number */
      330 	     end;
      331 	end;
      332 	else fnbr = fnbr + 1;
      333 	call build_tape_attach;			/* create tape attach description */
      334 	call open_tape_file;			/* attach and open tape file */
      335 	call open_ss_file;				/* attach  and open SS file */
      336 
      337 /* main processing loop, read SS file/write tape */
      338 
      339 	do while (^end_of_data & ^abort_sw & ^cont_sw);	/* do until no more data */
      340 ss_rd_retry:
      341 	     call iox_$read_record (ss_iocbp, wks_ptr, blen, rlen, code);
      342 	     if code = error_table_$end_of_info then	/* EOF detected */
      343 		end_of_data = "1"b;			/* set terminate condition */
      344 	     else if code ^= 0 & code ^= error_table_$short_record then do; /* if some error.. */
      345 		call check_ss_file_status;		/* go report it, and determine what to do */
      346 		if control_sw then			/* if user fixed problem */
      347 		     go to ss_rd_retry;		/* go retry read */
      348 	     end;
      349 	     else do;				/* good read, write the date into the tape file */
      350 		wt_ptr = wks_ptr;			/* start at beginning of buffer */
      351 		b_offset = 0;
      352 		if rlen = 0 then			/* special case for zero length records */
      353 		     zlck = "1"b;
      354 		else zlck = "0"b;			/* not a zero length record */
      355 		do while ((b_offset < rlen | zlck) & ^abort_sw & ^cont_sw); /* do while data to write */
      356 		     zlck = "0"b;			/* only one iteration for zero length records */
      357 		     wlen = min (amrl, rlen - b_offset);/* set length of record to write */
      358 		     call iox_$write_record (tape_iocbp, wt_ptr, wlen, code); /* write the tape record */
      359 		     if code ^= 0 then		/* if error writing to tape file */
      360 			call check_tape_status;	/* go report it and determine what to do */
      361 		     else do;			/* no error */
      362 			char_cnt = char_cnt + wlen;	/* increment file character count */
      363 			if fcb.segment.truncate_lines = 2 then /* if user want to chop of line.. */
      364 			     b_offset = rlen;	/* set so we only go through once */
      365 			else b_offset = b_offset + wlen; /* increment input record char offset */
      366 			wt_ptr = addr (input_record.next_char); /* increment input data ptr */
      367 		     end;
      368 		end;
      369 	     end;
      370 	end;
      371 	call close_ss_file;				/* close and detach SS file */
      372 	call close_tape_file (abort_sw);		/* close and detach tape file */
      373 
      374      end write_tape;
      375 
      376 /* open_tape_file - procedure to attach and open tape file */
      377 
      378 open_tape_file: proc;
      379 
      380 	if abort_sw | cont_sw then return;		/* if a bad error has already ocurred, bail out */
      381 
      382 	code = 0;
      383 	do while (code = 0 & ^tape_opened);
      384 	     call iox_$attach_name (tape_switch, tape_iocbp,
      385 		(tape_attach_descp.string), null, code);
      386 
      387 	     if code ^= 0 then do;			/* attach failed */
      388 		call com_err_ (code, name, "
      389 Unable to attach tape file ^a of volume-set ^a.
      390 Attach description is: ""^a""",
      391 		     fileid, vcb.volid (1), tape_attach_descp.string);
      392 		call cntl_cont_abort ("0"b);
      393 		return;
      394 	     end;
      395 
      396 	     tape_attached = "1"b;			/* set flag for cleanup handler */
      397 
      398 	     if output then				/* tape_out command: users want to write to the tape */
      399 		call iox_$open (tape_iocbp, Sequential_output, "0"b, code); /* open for output */
      400 	     else					/* tape_in command: users want to read from tape files */
      401 		call iox_$open (tape_iocbp, Sequential_input, "0"b, code); /* open for input */
      402 
      403 	     if code = 0 then
      404 		tape_opened = "1"b;			/* set flag for cleanup handler */
      405 	     else do;				/* open failed */
      406 		if code = error_table_$insufficient_open then do; /* special case of tape_in command. */
      407 
      408 		     if add_specified_attributes then do; /* because the tape doesn't contain info,  */
      409 						/* so add info from TCL file.  Then try to attach and open again */
      410 			call iox_$detach_iocb (tape_iocbp, (0));
      411 
      412 			call ioa_ ("
      413 tape_in:  WARNING because the volume name ""^a"" cannot be read as recorded,
      414 the structure attributes specified in the TCL file will be used.",
      415 			     vcb.volid (1));
      416 
      417 			recl = fixed (fcb.tape.reclen);
      418 			tape_attach_descp.string = tape_attach_descp.string
      419 			     || " -record " || ltrim (recl)
      420 			     || " -block " || ltrim (blkl)
      421 			     || " -format " || FORMAT (fcb.tape.format);
      422 
      423 			add_specified_attributes = "0"b;
      424 			code = 0;
      425 		     end;
      426 		end;
      427 
      428 		if code ^= 0 then do;
      429 		     call com_err_ (code, name, "
      430 Unable to open tape file ^a of volume-set ^a for ^[output^;input^].
      431 Attach description is: ""^a""",
      432 			fileid, vcb.volid (1), output, tape_attach_descp.string);
      433 		     call cntl_cont_abort ("0"b);
      434 		     return;
      435 		end;
      436 	     end;
      437 	end;
      438      end open_tape_file;
      439 
      440 /* close_tape_file - procedure to close and detach tape file */
      441 
      442 close_tape_file: proc (force_detach);
      443 
      444 dcl  force_detach bit (1) aligned;
      445 
      446 	if tape_opened then do;			/* if the tape was opened, close it */
      447 
      448 /* see if any more <file-groups> this volume. If not, or if cleanup, take down tape */
      449 
      450 	     if fcb.next_fcb_ptr = null | force_detach then
      451 		call iox_$control (tape_iocbp, "retain_none", null, (0)); /* cause tape to be demounted */
      452 	     call iox_$close (tape_iocbp, (0));		/* close the file */
      453 	     tape_opened = "0"b;			/* reset flag */
      454 	end;
      455 	if tape_attached then do;			/* if the tape was attached, detach it */
      456 	     call iox_$detach_iocb (tape_iocbp, (0));
      457 	     file_count = file_count + 1;		/* increment file count */
      458 	     tape_attached = "0"b;			/* reset flag */
      459 	end;
      460 
      461      end close_tape_file;
      462 
      463 /* open_ss_file - procedure to attach and open storage system file */
      464 
      465 open_ss_file: proc;
      466 
      467 	if abort_sw | cont_sw then return;		/* if a bad error has already ocurred, bail out */
      468 	if fcb.segment.format = 1 then		/* if stream file, use record_stream_ */
      469 	     ss_atd = "record_stream_ -target vfile_ " || pathname; /* to convert stream <--> record */
      470 	else ss_atd = "vfile_ " || pathname;		/* structured file, attach vfile_ directly */
      471 	if fcb.segment.extend = 2 then		/* if extending existing SS file */
      472 	     ss_atd = rtrim (ss_atd) || " -extend";	/* put it in attach desc */
      473 	control_sw = "1"b;				/* allow at least one iteration */
      474 	do while (control_sw);
      475 	     control_sw = "0"b;
      476 	     call close_ss_file;			/* make sure file switch is closed/detached first */
      477 	     call iox_$attach_name (ss_switch, ss_iocbp, ss_atd, null, code); /* attach SS file */
      478 	     if code ^= 0 then do;
      479 		call com_err_ (code, name, "
      480 Unable to attach storage system file ""^a"" for ^[input^;output^]
      481 (file ^a of volume-set ^a).
      482 Attach description is: ""^a"".",
      483 		     pathname, output, fileid, vcb.volid (1), ss_atd);
      484 		call cntl_cont_abort ("1"b);		/* go ask user what to do */
      485 		if ^control_sw then return;		/* give up */
      486 	     end;
      487 	     else do;				/* attempt opening if no errors */
      488 		ss_file_attached = "1"b;		/* set flag for cleanup handler */
      489 		if output then			/* if writing tape/reading ss file */
      490 		     ss_open_mode = Sequential_input;
      491 		else ss_open_mode = Sequential_output;	/* reading tape/writing ss file */
      492 		call iox_$open (ss_iocbp, ss_open_mode, "0"b, code); /* open storage file for write */
      493 		if code ^= 0 then do;
      494 		     call com_err_ (code, name, "
      495 Unable to open storage system file ""^a"" for ^a
      496 (file ^a on volume-set ^a).
      497 Attach description is: ""^a"".",
      498 			pathname, iox_modes (ss_open_mode), fileid,
      499 			vcb.volid (1), ss_atd);
      500 		     call cntl_cont_abort ("1"b);
      501 		     if ^control_sw then return;
      502 		end;
      503 		else do;
      504 		     ss_file_opened = "1"b;		/* set flag for cleanup handler, if no errors */
      505 		     io_started = "1"b;		/* I/O ready to start */
      506 		end;
      507 
      508 	     end;
      509 	end;
      510 
      511      end open_ss_file;
      512 
      513 /* check_ss_file - procedure to check storage system file for access etc. */
      514 
      515 check_ss_file: proc;
      516 
      517 	io_started = "0"b;				/* No I/O started yet */
      518 	control_sw = "1"b;				/* allow at least one iteration */
      519 	do while (control_sw);
      520 	     control_sw = "0"b;
      521 	     query_info.yes_or_no_sw = "1"b;
      522 	     call vfile_status_ ((fcb.segment.dirname), (fcb.segment.ename), addr (vfile_info), code);
      523 	     if code ^= 0 then do;
      524 		if code = error_table_$moderr then
      525 		     call com_err_ (code, name, "
      526 Storage system file ""^a"" has incorrect access for status check.",
      527 			pathname);
      528 		else if code = error_table_$dirseg then
      529 		     call com_err_ (code, name, "
      530 Storage system file ""^a"" is a directory.",
      531 			pathname);
      532 		else if code = error_table_$noentry then/* if file does not exist */
      533 		     if output then			/* if writing tape/reading ss file */
      534 			call com_err_ (code, name, "
      535 Storage system file ""^a"" does not already exist.",
      536 			     pathname);
      537 		     else if fcb.segment.extend = 2 then/* cannot extend non-existant file */
      538 			call com_err_ (code, name, "
      539 Cannot extend storage system file, ""^a"", as it does not already exist.",
      540 			     pathname);
      541 		     else return;			/* return, no problems */
      542 		else call com_err_ (code, name, "
      543 Cannot get status of storage system file ""^a"".",
      544 			pathname);
      545 		go to ask_user;			/* see what user wants to do */
      546 	     end;
      547 	     if ^output & fcb.segment.extend ^= 2 then do;/* reading tape/writing SS file */
      548 		call command_query_ (addr (query_info), answer, name,
      549 		     "Storage system file ""^a"" already exists.^/Do you wish to overwrite it? ",
      550 		     pathname);
      551 		if answer = "no" then
      552 		     go to ask_user;		/* go ask user what to do */
      553 	     end;
      554 	     if vfile_info.type = 1 then do;		/* unstructured file */
      555 		if fcb.segment.format = 2 then do;	/* error if specified structured file */
      556 		     call ioa_ ("^a: Storage system file ""^a"" exists as an unstructured file.",
      557 			name, pathname);
      558 		     call command_query_ (addr (query_info), answer, name,
      559 			"Do you wish to over^[^a unstructured^s^;^s^a structured^]? ",
      560 			output, q_mess1, q_mess2);
      561 		     if answer = "yes" then do;
      562 			if output then		/* if writing tape/reading SS file */
      563 			     fcb.segment.format = 1;
      564 			else if fcb.segment.extend = 2 then /* if reading tape/writing SS file */
      565 			     fcb.segment.extend = 1;	/* change file format by creating new file */
      566 		     end;
      567 		     else go to ask_user;		/* no, go see what user wants to do */
      568 		end;
      569 	     end;
      570 	     else if vfile_info.type = 2 then do;	/* sequential file */
      571 		if vfile_info.flags.lock_status ^= "00"b then do;
      572 		     code = error_table_$file_busy;
      573 		     call com_err_ (code, name, "
      574 Storage system file, ""^a"", is locked.",
      575 			pathname);
      576 		     go to ask_user;		/* go see what user wants to do */
      577 		end;
      578 		if fcb.segment.format ^= 2 then do;	/* error if specified unstructured file */
      579 		     call ioa_ ("^a: Storage system file ""^a"" already exists as a sequential file.",
      580 			name, pathname);
      581 		     call command_query_ (addr (query_info), answer, name,
      582 			"Do you wish to over^[^a sequential^s^;^s^a unstructured^]? ",
      583 			output, q_mess1, q_mess2);
      584 		     if answer = "yes" then do;
      585 			if output then		/* if writing tape/reading SS file */
      586 			     fcb.segment.format = 2;
      587 			else if fcb.segment.extend = 2 then /* if reading tape/writing SS file */
      588 			     fcb.segment.extend = 1;	/* change file format by creating new file */
      589 		     end;
      590 		     else go to ask_user;		/* no, go see what user wants to do */
      591 		end;
      592 	     end;
      593 	     else do;				/* error-- no other types supproted */
      594 		call com_err_ (0, name, "
      595 Storage system file ""^a"" is not unstructured or sequential.",
      596 		     pathname);
      597 ask_user:
      598 		call cntl_cont_abort ("1"b);		/* see what user wnats to do */
      599 		if ^control_sw then return;
      600 	     end;
      601 	end;
      602 
      603      end check_ss_file;
      604 
      605 /* Cleaner - procedure to close and detach resources when processing completed  or on a cleanup condition */
      606 
      607 Cleaner: proc;
      608 
      609 	if wks_ptr ^= null then do;			/* if we have a buffer segment assigned.. */
      610 	     call release_temp_segment_ ((name), wks_ptr, (0)); /* release it */
      611 	     wks_ptr = null;			/* reset the ptr */
      612 	end;
      613 	call close_ss_file;				/* close and detach Storage system file */
      614 	call close_tape_file ("1"b);			/* close and demount tape volume */
      615 
      616      end Cleaner;
      617 
      618 
      619 /* close_ss_file - procedure to close and detach storage system file */
      620 
      621 close_ss_file: proc;
      622 
      623 	if ss_file_opened then do;			/* if the file is opened.. */
      624 	     call iox_$close (ss_iocbp, (0));		/* close it unconditionaly */
      625 	     ss_file_opened = "0"b;			/* and reset flag */
      626 	end;
      627 	if ss_file_attached then do;			/* if the file is attached.. */
      628 	     call iox_$detach_iocb (ss_iocbp, (0));	/* detach it unconditionaly */
      629 	     ss_file_attached = "0"b;			/* and reset flag */
      630 	end;
      631 
      632      end close_ss_file;
      633 
      634 /* check_ss_file_status - procedure to  check storage system file status errors */
      635 
      636 check_ss_file_status: proc;
      637 
      638 	call com_err_ (code, name, "
      639 Error ^[reading from^;writing to^] storage system file ""^a""
      640 (file ^a of volume-set ^a).",
      641 	     output, pathname, fileid, vcb.volid (1));
      642 
      643 	call cntl_cont_abort ("1"b);
      644 
      645      end check_ss_file_status;
      646 
      647 
      648 /* check_tape_status - procedure to check tape errors */
      649 
      650 check_tape_status: proc;
      651 
      652 	end_of_data = "1"b;				/* Will not continue I/O  on this tape volume */
      653 	call iox_$control (tape_iocbp, "file_status", addr (atfs), rcode);
      654 	if atfs.state > 0 then
      655 	     blockl = atfs.cur_blkcnt;
      656 	if code = error_table_$eov_on_write then do;	/* End-of-Tape has been detected */
      657 	     char_cnt = char_cnt + rlen;		/* add chars which were output to total count.	*/
      658 	     call com_err_ (0, name, "
      659 End-of-Tape detected while writing tape file ^a of volume-set ^a
      660 (storage system file ""^a"").
      661 ^d characters have been written to ^d blocks.",
      662 		fileid, vcb.volid (1), pathname, char_cnt, blockl);
      663 	     end_of_tape = "1"b;			/* indicate we had EOT condition */
      664 	end;
      665 						/* format: off */
      666 	else call com_err_ (code, name, "
      667 Error while ^[writing^;reading^] tape file ^a of volume set ^a
      668 (storage system file ""^a"").
      669 ^d characters have been ^[written to^;read from^] ^d blocks.
      670 The volume-set will be detached.",
      671 		output, fileid, vcb.volid (1), pathname, char_cnt,
      672 		output, blockl);
      673 /* format: on */
      674 	call error_report;				/* go give the user the real status */
      675 	call cntl_cont_abort ("0"b);			/* ask user what he wants to do */
      676 
      677      end check_tape_status;
      678 
      679 /* internal procedure to move tape to end of files for appending a new file */
      680 /* enter here if fcb.tape.sequence = -1 and fnbr = 0 */
      681 
      682 position_to_end: procedure;
      683 
      684 	if abort_sw | cont_sw then return;		/* if a bad error has already ocurred, bail out */
      685 	do fnbr = 1 by 1;
      686 	     secq = fixed (fnbr);			/* file number as char string */
      687 	     call build_tape_attach;			/* go build positioning attach desc */
      688 	     if writeff_sw then
      689 		writeff_sw = "0"b;			/* cant write 1st file as file 1 in append mode */
      690 
      691 	     call iox_$attach_name (tape_switch, tape_iocbp, (tape_attach_descp.string), null, rcode);
      692 	     if rcode ^= 0 then do;			/* unable to attach tape file  */
      693 bad_position:
      694 		call com_err_ (rcode, name, "
      695 Error while positioning to append to volume-set.
      696 Attach description is: ""^a""",
      697 		     tape_attach_descp.string);
      698 		call error_report;
      699 		call cntl_cont_abort ("0"b);
      700 		fnbr = 0;
      701 		return;
      702 	     end;
      703 	     call iox_$open (tape_iocbp, Sequential_input, "0"b, rcode); /* open tape file for read */
      704 	     if rcode = error_table_$no_file then
      705 		fcb.tape.sequence = fnbr;		/* this is the file number we will use to append as */
      706 	     else if rcode ^= 0 then
      707 		goto bad_position;
      708 	     call iox_$close (tape_iocbp, rcode);	/* close the tape file */
      709 	     call iox_$detach_iocb (tape_iocbp, rcode);
      710 	     if rcode ^= 0 then			/* error closing or detaching */
      711 		go to bad_position;
      712 	     if fcb.tape.sequence ^= -1 then do;
      713 		rcode = 0;
      714 		call ioa_ ("^a: Tape file ""^a"" will be appended as file #^d", name, fileid, fnbr);
      715 		return;
      716 	     end;
      717 	end;
      718 
      719      end position_to_end;
      720 
      721 /* error_report - procedure to report the hardware status in English */
      722 
      723 error_report: proc;
      724 
      725 	call iox_$control (tape_iocbp, "status", addr (ads), code);
      726 	if code = 0 then do;
      727 	     call ioa_ ("^/^a: Description of error follows: ^/", name);
      728 	     do i = 1 to ads.n_minor;			/* loop and print all minor status codes */
      729 		call convert_status_code_ (ads.minor (i), shortinfo, longinfo);
      730 		call ioa_ ("^a^/", longinfo);
      731 	     end;
      732 	end;
      733      end error_report;
      734 
      735 build_tape_attach: procedure;
      736 	add_specified_attributes = "1"b;
      737 	if abort_sw | cont_sw then return;		/* if a bad error has already ocurred, bail out */
      738 	tstring = "";				/* initialize  */
      739 	if vol_init then do;			/* only do this once per <volume-group> */
      740 	     if output then
      741 		if fcb.tape.sequence = 0 then
      742 		     writeff_sw = "1"b;
      743 	     tstring = IO_MODULE_NAME (vcb.tape_type);
      744 	     do i = 1 to vcb.nvols;			/* up to vcb.nvols volumes per set allowed */
      745 		if substr (vcb.volid (i), 1, 1) = "-" then do;
      746 		     tstring = tstring || " " || "-volume " || rtrim (vcb.volid (i));
      747 		end;
      748 		else tstring = tstring || " " || rtrim (vcb.volid (i));
      749 		if vcb.comment (i) ^= " " then
      750 		     tstring = tstring || " -comment " ||
      751 			requote_string_ (rtrim (vcb.comment (i)));
      752 	     end;
      753 	     tstring = tstring || " -density " || DENSITY (vcb.density);
      754 	     if vcb.tape_type = IBMNL then
      755 		tstring = tstring || " -no_labels";
      756 	     else if vcb.tape_type = IBMDOS then
      757 		tstring = tstring || " -dos";
      758 	     vol_init = "0"b;			/* reset for rest of <volume-group> */
      759 	     tape_attach_descp.vol_string = tstring;	/* copy volume  portion of attach desc. */
      760 	end;
      761 
      762 	tstring = " -retain all";			/* keep volume mounted between attachments */
      763 	if writeff_sw then do;			/* set up so 1st file written will be file 1 on the tape */
      764 	     fcb.tape.sequence = 1;			/* will start at file 1 on tape */
      765 	     secq = fixed (fcb.tape.sequence);
      766 	     writeff_sw = "0"b;			/* reset so we don't come back */
      767 	end;
      768 	if ring_sw then				/* if writing or "-ring" control arg */
      769 	     tstring = tstring || " -ring";
      770 	if fcb.tape.sequence = -1 then		/* if tape positioning required.. */
      771 	     tstring = tstring || " -number " || secq;
      772 	else do;					/* no tape positioning required */
      773 	     if fcb.tape.cmode > 0 then
      774 		tstring = tstring || " -mode " || MODE (fcb.tape.cmode);
      775 	     if fcb.tape.file_id ^= "*" then		/* start options check now */
      776 		tstring = tstring || " -name " || rtrim (fcb.tape.file_id);
      777 	     if fcb.tape.sequence > 0 then do;
      778 		secq = fixed (fcb.tape.sequence);
      779 		tstring = tstring || " -number " || ltrim (secq);
      780 	     end;
      781 	     blkl = fixed (fcb.tape.blklen);		/* convert block length to char data */
      782 	     if output | vcb.tape_type = IBMNL | vcb.tape_type = IBMDOS then do; /* don't set for input on SL tapes */
      783 
      784 		if fcb.tape.reclen > 0 then do;	/* set up the real attach desc. */
      785 		     recl = fixed (fcb.tape.reclen);
      786 		     tstring = tstring || " -record " || ltrim (recl);
      787 		end;
      788 		if fcb.tape.blklen > 0 then
      789 		     tstring = tstring || " -block " || ltrim (blkl);
      790 		if fcb.tape.format > 0 then
      791 		     tstring = tstring || " -format " || FORMAT (fcb.tape.format);
      792 		add_specified_attributes = "0"b;
      793 	     end;
      794 	     else if fcb.tape.blklen > 8192 then	/* unless large block wanted */
      795 		tstring = tstring || " -block " || ltrim (blkl);
      796 	     if output then do;			/* only add output options if writing tape */
      797 		if tape_io_data.control.force then
      798 		     tstring = tstring || " -force ";
      799 		if fcb.tape.expiration ^= "" then
      800 		     tstring = tstring || " -expires " || fcb.tape.expiration;
      801 		if fcb.tape.replace_id ^= "" then
      802 		     tstring = tstring || " -replace " || fcb.tape.replace_id;
      803 		if fcb.tape.output_mode > 0 then
      804 		     tstring = tstring || OUTPUT_MODE (fcb.tape.output_mode);
      805 	     end;
      806 	end;
      807 	tape_attach_descp.file_string = tstring;
      808 	tape_attach_descp.string = tape_attach_descp.vol_string || tape_attach_descp.file_string;
      809 	if db_sw then
      810 	     call ioa_ ("Attach desc: ""^a""", tape_attach_descp.string);
      811 
      812      end build_tape_attach;
      813 
      814 /* internal procedure to help user direct the processing of his control file
      815*   after the occurrence of an error or other interruption in execution. */
      816 
      817 cntl_cont_abort: procedure (idx);
      818 
      819 dcl  idx bit (1) aligned;
      820 
      821 	query_info.yes_or_no_sw = "0"b;		/* not looking for yes or no answer */
      822 	abort_sw, control_sw, cont_sw = "0"b;		/* reset switches */
      823 	cant_cont = (fcb.next_fcb_ptr = null & vcb.next_vcb_ptr = null); /* determine if continuation is possible */
      824 	if ^idx then				/* if not control option and */
      825 	     if cant_cont then do;			/* no file/volume groups left to process */
      826 		abort_sw = "1"b;			/* the only possible action is to abort */
      827 		call ioa_ ("^a: Control file exhausted, aborting.", name);
      828 		return;
      829 	     end;
      830 	call ioa_ ("^a: Do you wish to ^[^a^[,^] ^;^2s^]^[^[^/^-^]^a ^]or abort the control file?",
      831 	     name, idx, "control the process", (idx & ^cant_cont), ^cant_cont,
      832 	     (idx & ^cant_cont), "continue to the next <file-group>");
      833 ASK1:
      834 	call command_query_ (addr (query_info), answer, name,
      835 	     "Please answer either ^[""control"", ^]^[""continue"", ^]or ""abort"":", idx, ^cant_cont);
      836 
      837 	if answer = "control" & idx then do;
      838 	     call ioa_ ("^a: You may now take action to correct the problem.^/^a",
      839 		name, "Type ""start"" (or ""sr""), when you are ready to resume operations.");
      840 	     control_sw = "1"b;
      841 	     call cu_$cl ();			/* pass control to get_to_cl_$unclaimed_signal */
      842 	end;
      843 	else if answer = "continue" & ^cant_cont then
      844 	     cont_sw = "1"b;
      845 	else if answer = "abort" then
      846 	     abort_sw = "1"b;
      847 	else go to ASK1;
      848 
      849      end cntl_cont_abort;
      850 
  1     1 /*  BEGIN INCLUDE FILE:  tape_file_status.incl.pl1         */
  1     2 
  1     3 dcl  tfstat_ptr pointer;
  1     4 
  1     5 dcl 1 tape_file_status based (tfstat_ptr),
  1     6     2 state fixed bin,	         /* 0 - no information available */
  1     7 			         /* 1 - file not open            */
  1     8 			         /* 2 - file open (unlocked)     */
  1     9 			         /* 3 - file open (event locked) */
  1    10     2 event_code fixed bin (35),       /* 0 if file_status.state ^= 3  */
  1    11 			         /* otherwise, an error code     */
  1    12     2 file_id char (17),	         /* file identifier              */
  1    13     2 file_seq fixed bin,	         /* file sequence number         */
  1    14     2 cur_section fixed bin,	         /* file section number of current or */
  1    15 			         /* last file section processed       */
  1    16     2 cur_volume char (6),	         /* volume name of volume on which current */
  1    17 			         /* or last file section processed resides */
  1    18     2 generation fixed bin,	         /* generation number                 */
  1    19     2 version fixed bin,	         /* generation version number         */
  1    20     2 creation char (5),	         /* creation date in Julian form (yyddd) */
  1    21     2 expiration char (5),	         /* expiration date in Julian form */
  1    22     2 format_code fixed bin,	         /* 1 - undefined records          */
  1    23 			         /* 2 - fixed-length records       */
  1    24 			         /* 3 - variable-length records    */
  1    25 			         /* 4 - spanned records            */
  1    26     2 blklen fixed bin,	         /* actual or maximum block length */
  1    27     2 reclen fixed bin (21),	         /* actual or maximum record length */
  1    28     2 blocked bit (1),	         /* "0"b - unblocked records */
  1    29 			         /* "1"b - blocked records   */
  1    30     2 mode fixed bin,	         /* 1 - ASCII  */
  1    31 			         /* 2 - EBCDIC */
  1    32 			         /* 3 - binary */
  1    33     2 cur_blkcnt fixed bin (35);       /* current or total number of blocks */
  1    34 			         /* read or written                   */
  1    35 
  1    36 /*  END INCLUDE FILE:  tape_file_status.incl.pl1             */
      851 
      852 
  2     1 /*	BEGIN INCLUDE FILE tape_io_data.incl.pl1 ... Michael R. Jordan 3/81 */
  2     2 
  2     3 dcl (fcb_ptr, vcb_ptr, tape_io_data_ptr) ptr;
  2     4 
  2     5 dcl 1 tape_io_data aligned based (tape_io_data_ptr),
  2     6     2 temp (3) ptr,					/* (1) -> code to interpret; (2) -> lex temp; (3) -> buffer */
  2     7     2 first_vcb_ptr ptr,				/* ptr to first vcb */
  2     8     2 source,					/* info about source file */
  2     9       3 dirname char (168) unal,
  2    10       3 ename char (32) unal,
  2    11       3 ptr ptr,
  2    12     2 control,					/* control flags */
  2    13       3 ck bit (1),					/* ON => -check specified */
  2    14       3 force bit (1),				/* ON => -force specified */
  2    15       3 ring bit (1),				/* ON => -ring specified */
  2    16       3 writing_tape bit (1),				/* ON => tape_out, OFF => tape_in */
  2    17       3 max_severity fixed bin;			/* maximum error severity to be printed */
  2    18 
  2    19 dcl 1 fcb aligned based (fcb_ptr),			/* file control block - governs file i/o */
  2    20     2 file_token_ptr ptr,				/* ptr to "File" token */
  2    21     2 next_fcb_ptr ptr,				/* pointer to next block, if any */
  2    22     2 prev_fcb_ptr ptr,				/* pointer to previous fcb */
  2    23     2 default_fcb_ptr ptr,				/* pointer to last default fcb */
  2    24     2 segment,					/* storage system data */
  2    25       3 dirname char (168),				/* directory name of file to be read/written */
  2    26       3 ename char (32),				/* entry name of file to be read/written */
  2    27       3 format fixed bin,				/* 0 = not specified; 1 = unstructured; 2 = sequential */
  2    28       3 extend fixed bin,				/* 0 = not specified; 1 = truncate (^extend); 2 = extend */
  2    29       3 truncate_lines fixed bin,			/* 0 = not specified; 1 = fold or; 2 = truncate long lines */
  2    30     2 tape,					/* tape file data */
  2    31       3 cmode fixed bin,				/* 0 = not specified; 1 = ASCII; 2 = EBCDIC; 3 = BINARY */
  2    32       3 format fixed bin,				/* 0 = not specified; 1 = Undefined; 2 = Fixed; 3 = D */
  2    33 						/* 4 = Variable; 5 = Fixed Blocked; 6 = DB */
  2    34 						/* 7 = Variable Blocked; 8 = Spanned; 9 = Spanned Blocked */
  2    35 						/* 10 = Variable Spanned; 11 = Variable Spanned Blocked */
  2    36       3 output_mode fixed bin,			/* 0 = not specified; 1 = extend; 2 = modify */
  2    37 						/* 3 = generate; 4 = create or replace */
  2    38       3 file_id char (17),				/* file identifier; "*" => no file name */
  2    39       3 replace_id char (17),				/* replace file ID; "" =>  create new file */
  2    40       3 expiration char (16),				/* expiration date, "" => immediate expiration */
  2    41       3 sequence fixed bin,				/* file seq. #; -1 = append to file-set; 0 = not specified */
  2    42       3 blklen fixed bin,				/* physical block length */
  2    43       3 reclen fixed bin (21);			/* logical record length */
  2    44 
  2    45 dcl 1 vcb aligned based (vcb_ptr),			/* volume control block - governs volume attachment */
  2    46     2 volume_token_ptr ptr,				/* ptr to Volume token for this volume group */
  2    47     2 next_vcb_ptr ptr,				/* pointer to next block, if any */
  2    48     2 first_fcb_ptr ptr,				/* first fcb for this volume set */
  2    49     2 first_default_fcb_ptr ptr,			/* first default fcb for this volume-set */
  2    50     2 nvols fixed bin,				/* number of volumes in current volume-set */
  2    51     2 volid (64) char (32),				/* volume identification string (serial number) */
  2    52     2 comment (64) char (64),
  2    53     2 tape_type fixed bin,				/* 0 = not specified; 1 = ANSI; 2 = IBMSL */
  2    54 						/* 3 = IBMNL; 4 = IBMDOS */
  2    55     2 density fixed bin;				/* 0 = not specified; 2 = 800; 3 = 1600; 4 = 6250 (BPI) */
  2    56 
  2    57 /*	END INCLUDE FILE tape_io_data.incl.pl1 */
      853 
      854 
  3     1 /*  BEGIN INCLUDE FILE:  device_status.incl.pl1                 */
  3     2 
  3     3 dcl  dstat_ptr pointer;
  3     4 
  3     5 dcl 1 device_status based (dstat_ptr),
  3     6     2 IOM_bits bit (72) aligned,          /* IOM status bits              */
  3     7     2 n_minor fixed bin,                  /* number of minor status codes */
  3     8     2 major fixed bin (35),               /* major status code            */
  3     9     2 minor (10) fixed bin (35);          /* minor status codes           */
  3    10 
  3    11 /*  END INCLUDE FILE:  device_status.incl.pl1                   */
      855 
      856 
  4     1 /* Begin include file ..... iox_modes.incl.pl1 */
  4     2 
  4     3 /* Written by C. D. Tavares, 03/17/75 */
  4     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  4     5 
  4     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  4     7     ("stream_input", "stream_output", "stream_input_output",
  4     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  4     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  4    10      "direct_input", "direct_output", "direct_update");
  4    11 
  4    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  4    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  4    14 
  4    15 dcl (Stream_input initial (1),
  4    16      Stream_output initial (2),
  4    17      Stream_input_output initial (3),
  4    18      Sequential_input initial (4),
  4    19      Sequential_output initial (5),
  4    20      Sequential_input_output initial (6),
  4    21      Sequential_update initial (7),
  4    22      Keyed_sequential_input initial (8),
  4    23      Keyed_sequential_output initial (9),
  4    24      Keyed_sequential_update initial (10),
  4    25      Direct_input initial (11),
  4    26      Direct_output initial (12),
  4    27      Direct_update initial (13)) fixed bin int static options (constant);
  4    28 
  4    29 /* End include file ..... iox_modes.incl.pl1 */
      857 
      858 
  5     1 /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
  5     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
  5     3 /*	version number changed to 4, 08/10/78 WOS */
  5     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
  5     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
  5     6 
  5     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
  5     8     2 version fixed bin,				/* version of this structure - must be set, see below */
  5     9     2 switches aligned,                                     /* various bit switch values */
  5    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
  5    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
  5    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
  5    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
  5    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
  5    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
  5    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
  5    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
  5    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
  5    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
  5    20 
  5    21 /*  Limit of data defined for version 2 */
  5    22 
  5    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
  5    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
  5    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
  5    26 						/* minimum of 30 seconds required for repeat */
  5    27 						/* otherwise, no repeat will occur */
  5    28 /* Limit of data defined for version 4 */
  5    29 
  5    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
  5    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
  5    32 
  5    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
  5    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
  5    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
  5    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
  5    37 
  5    38 /*	END INCLUDE FILE query_info.incl.pl1 */
      859 
      860 
      861      end tape_io_interpret_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/19/88  0824.0  tape_io_interpret_.pl1            >spec>install>1039>tape_io_interpret_.pl1
851          1    08/27/75  1703.2  tape_file_status.incl.pl1         >ldd>include>tape_file_status.incl.pl1
853          2    06/10/82  1045.3  tape_io_data.incl.pl1             >ldd>include>tape_io_data.incl.pl1
855          3    08/27/75  1703.2  device_status.incl.pl1            >ldd>include>device_status.incl.pl1
857          4    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
859          5    03/11/83  1204.3  query_info_.incl.pl1              >ldd>include>query_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DENSITY                         000231 constant        varying char(4)          initial array dcl 119 ref 753
FORMAT                          000203 constant        varying char(3)          initial array dcl 120 ref 418 790
IBMDOS                                 constant        fixed bin(17,0)          initial dcl 114 ref 756 782
IBMNL                                  constant        fixed bin(17,0)          initial dcl 113 ref 754 782
IO_MODULE_NAME                  000152 constant        varying char(12)         initial array dcl 124 ref 743
MODE                            000172 constant        varying char(8)          initial array dcl 122 ref 773
OUTPUT_MODE                     000132 constant        varying char(12)         initial array dcl 126 ref 803
Sequential_input                000362 constant        fixed bin(17,0)          initial dcl 4-15 set ref 400* 489 703*
Sequential_output               000172 constant        fixed bin(17,0)          initial dcl 4-15 set ref 398* 491
abort_sw                        000557 automatic       bit(1)                   dcl 71 set ref 191* 197 201 206 217* 281 293 315*
                                                                                  339 355 372* 380 467 684 737 822* 826* 845*
add_specified_attributes        000556 automatic       bit(1)                   packed unaligned dcl 70 set ref 408 423* 736* 792*
addr                                                   builtin function         dcl 148 ref 308 366 522 522 548 548 558 558 581 581
                                                                                  653 653 725 725 833 833
ads                             000100 automatic       structure                level 1 unaligned dcl 50 set ref 725 725
amrl                            000560 automatic       fixed bin(21,0)          dcl 72 set ref 225* 229* 233* 238* 245* 295 308 357
                                                                                  366
answer                          000561 automatic       varying char(128)        dcl 73 set ref 548* 551 558* 561 581* 584 833* 837
                                                                                  843 845
answer_iocbp              6     001240 automatic       pointer                  initial level 2 dcl 5-7 set ref 5-7*
arg_tape_io_data_ptr                   parameter       pointer                  dcl 39 ref 22 176
atfs                            000116 automatic       structure                level 1 unaligned dcl 51 set ref 653 653
b_offset                        000764 automatic       fixed bin(21,0)          dcl 94 set ref 289* 293 295 305* 307* 307 351* 355
                                                                                  357 363* 365* 365
blen                            000761 automatic       fixed bin(21,0)          dcl 94 set ref 193* 282* 340*
blkl                            000622 automatic       picture(8)               packed unaligned dcl 74 set ref 418 781* 788 794
blklen                  117            based           fixed bin(17,0)          level 3 dcl 2-19 ref 229 781 788 794
blockl                          000627 automatic       fixed bin(21,0)          dcl 77 set ref 216* 654* 658* 666*
cant_cont                       001221 automatic       bit(1)                   dcl 107 set ref 823* 824 830 830 830 833 843
char_cnt                        000630 automatic       fixed bin(21,0)          dcl 78 set ref 216* 258 304* 304 362* 362 657* 657
                                                                                  658* 666*
cleanup                         001224 stack reference condition                dcl 131 ref 195
cmode                    75            based           fixed bin(17,0)          level 3 dcl 2-19 ref 773 773
code                            000631 automatic       fixed bin(35,0)          dcl 79 set ref 182* 183 184* 282* 283 285 296* 298
                                                                                  340* 342 344 344 358* 359 382* 383 384* 387 388*
                                                                                  398* 400* 403 406 424* 428 429* 477* 478 479* 492*
                                                                                  493 494* 522* 523 524 524* 528 528* 532 532* 537*
                                                                                  542* 572* 573* 638* 656 666* 725* 726
com_err_                        000042 constant        entry                    external dcl 159 ref 184 388 429 479 494 524 528 532
                                                                                  537 542 573 594 638 658 666 693
command_query_                  000044 constant        entry                    external dcl 160 ref 548 558 581 833
comment                1011            based           char(64)                 array level 2 dcl 2-45 ref 749 749 749
cont_sw                         000632 automatic       bit(1)                   packed unaligned dcl 80 set ref 217* 281 293 339 355
                                                                                  380 467 684 737 822* 843*
control                  74            based           structure                level 2 dcl 2-5
control_sw                      000633 automatic       bit(1)                   packed unaligned dcl 81 set ref 217* 300 346 473*
                                                                                  474 475* 485 501 518* 519 520* 599 822* 840*
convert_status_code_            000046 constant        entry                    external dcl 161 ref 729
cp_escape_control         1(02) 001240 automatic       bit(2)                   initial level 3 packed packed unaligned dcl 5-7 set
                                                                                  ref 5-7*
cu_$cl                          000050 constant        entry                    external dcl 162 ref 841
cur_blkcnt               25     000116 automatic       fixed bin(35,0)          level 2 dcl 51 set ref 654
db_sw                           000634 automatic       bit(1)                   initial packed unaligned dcl 82 set ref 82* 809
density                3012            based           fixed bin(17,0)          level 2 dcl 2-45 ref 753
device_status                          based           structure                level 1 unaligned dcl 3-5
dirname                  10            based           char(168)                level 3 in structure "tape_io_data" packed packed
                                                                                  unaligned dcl 2-5 in procedure
                                                                                  "tape_io_interpret_" set ref 206*
dirname                  10            based           char(168)                level 3 in structure "fcb" dcl 2-19 in procedure
                                                                                  "tape_io_interpret_" ref 251 254 522
ename                    62            based           char(32)                 level 3 in structure "fcb" dcl 2-19 in procedure
                                                                                  "tape_io_interpret_" ref 251 254 522
ename                    62            based           char(32)                 level 3 in structure "tape_io_data" packed packed
                                                                                  unaligned dcl 2-5 in procedure
                                                                                  "tape_io_interpret_" set ref 206*
end_of_data                     000635 automatic       bit(1)                   packed unaligned dcl 83 set ref 217* 281 283* 339
                                                                                  342* 652*
end_of_tape                     000636 automatic       bit(1)                   packed unaligned dcl 84 set ref 663*
error_table_$dirseg             000020 external static fixed bin(35,0)          dcl 135 ref 528
error_table_$end_of_info        000022 external static fixed bin(35,0)          dcl 136 ref 283 342
error_table_$eov_on_write       000024 external static fixed bin(35,0)          dcl 137 ref 656
error_table_$file_busy          000026 external static fixed bin(35,0)          dcl 138 ref 572
error_table_$insufficient_open  000030 external static fixed bin(35,0)          dcl 139 ref 406
error_table_$moderr             000032 external static fixed bin(35,0)          dcl 140 ref 524
error_table_$no_file            000034 external static fixed bin(35,0)          dcl 141 ref 704
error_table_$noentry            000036 external static fixed bin(35,0)          dcl 142 ref 532
error_table_$short_record       000040 external static fixed bin(35,0)          dcl 143 ref 344
expiration              112            based           char(16)                 level 3 dcl 2-19 ref 799 799
explanation_len          14     001240 automatic       fixed bin(21,0)          initial level 2 dcl 5-7 set ref 5-7*
explanation_ptr          12     001240 automatic       pointer                  initial level 2 dcl 5-7 set ref 5-7*
extend                   73            based           fixed bin(17,0)          level 3 dcl 2-19 set ref 471 537 547 564 564* 587
                                                                                  587*
fcb                                    based           structure                level 1 dcl 2-19
fcb_ptr                         001232 automatic       pointer                  dcl 2-3 set ref 201* 201* 203 218 218 221 224 229
                                                                                  233 238 245 251 251 254 254 258 305 324 329 363
                                                                                  417 418 450 468 471 522 522 537 547 555 562 564
                                                                                  564 578 585 587 587 704 712 740 764 765 770 773
                                                                                  773 775 775 777 778 781 784 785 788 790 790 794
                                                                                  799 799 801 801 803 803 823
file_count                      000637 automatic       fixed bin(17,0)          dcl 85 set ref 189* 206* 206 457* 457
file_id                 100            based           char(17)                 level 3 dcl 2-19 set ref 218 218 258* 775 775
file_string             101     000144 automatic       varying char(256)        level 2 dcl 53 set ref 807* 808
fileid                          000640 automatic       varying char(17)         dcl 86 set ref 218* 222* 262* 388* 429* 479* 494*
                                                                                  638* 658* 666* 714*
first_fcb_ptr             4            based           pointer                  level 2 dcl 2-45 ref 201
first_vcb_ptr             6            based           pointer                  level 2 dcl 2-5 ref 197
fixed                                                  builtin function         dcl 149 ref 221 417 686 765 778 781 785
flags                     3     000547 automatic       structure                level 2 dcl 58
fnbr                            000646 automatic       fixed bin(17,0)          dcl 87 set ref 199* 325 328* 328 329 332* 332 685*
                                                                                  686 700* 704 714*
force                    75            based           bit(1)                   level 3 dcl 2-5 ref 797
force_detach                           parameter       bit(1)                   dcl 444 ref 442 450
format                   76            based           fixed bin(17,0)          level 3 in structure "fcb" dcl 2-19 in procedure
                                                                                  "tape_io_interpret_" ref 224 418 790 790
format                   72            based           fixed bin(17,0)          level 3 in structure "fcb" dcl 2-19 in procedure
                                                                                  "tape_io_interpret_" set ref 468 555 562* 578 585*
get_temp_segment_               000054 constant        entry                    external dcl 164 ref 182
i                               000647 automatic       fixed bin(17,0)          dcl 88 set ref 728* 729* 744* 745 746 748 749 749
                                                                                  749*
idx                                    parameter       bit(1)                   dcl 819 set ref 817 824 830* 830 830 833* 837
info_version                    000547 automatic       fixed bin(17,0)          level 2 dcl 58 set ref 188*
input_record                           based           structure                level 1 packed packed unaligned dcl 44
io_started                      001223 automatic       bit(1)                   dcl 109 set ref 258 505* 517*
ioa_                            000052 constant        entry                    external dcl 163 ref 206 258 262 412 556 579 714 727
                                                                                  730 809 827 830 838
iox_$attach_name                000060 constant        entry                    external dcl 166 ref 384 477 691
iox_$close                      000062 constant        entry                    external dcl 167 ref 452 624 708
iox_$control                    000064 constant        entry                    external dcl 168 ref 450 653 725
iox_$detach_iocb                000066 constant        entry                    external dcl 169 ref 410 456 628 709
iox_$open                       000070 constant        entry                    external dcl 170 ref 398 400 492 703
iox_$read_record                000072 constant        entry                    external dcl 171 ref 282 340
iox_$write_record               000074 constant        entry                    external dcl 172 ref 296 358
iox_modes                       000014 constant        char(24)                 initial array dcl 4-6 set ref 494*
literal_sw                1(05) 001240 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 5-7 set
                                                                                  ref 5-7*
lock_status               3     000547 automatic       bit(2)                   level 3 packed packed unaligned dcl 58 set ref 571
longinfo                        000650 automatic       char(100)                dcl 89 set ref 729* 730*
ltrim                                                  builtin function         dcl 150 ref 222 418 418 779 786 788 794
min                                                    builtin function         dcl 151 ref 245 295 357
minor                     4     000100 automatic       fixed bin(35,0)          array level 2 dcl 50 set ref 729*
n_minor                   2     000100 automatic       fixed bin(17,0)          level 2 dcl 50 set ref 728
name                            000701 automatic       varying char(8)          dcl 90 set ref 178* 180* 182 184* 190 200 206* 258*
                                                                                  262* 388* 429* 479* 494* 524* 528* 532* 537* 542*
                                                                                  548* 556* 558* 573* 579* 581* 594* 610 638* 658*
                                                                                  666* 693* 714* 727* 827* 830* 833* 838*
next_char                              based           bit                      level 2 packed packed unaligned dcl 44 set ref 308
                                                                                  366
next_fcb_ptr              2            based           pointer                  level 2 dcl 2-19 ref 203 450 823
next_vcb_ptr              2            based           pointer                  level 2 dcl 2-45 ref 204 823
null                                                   builtin function         dcl 152 ref 98 192 197 201 5-7 5-7 5-7 384 384 450
                                                                                  450 450 477 477 609 611 691 691 823 823
nvols                    10            based           fixed bin(17,0)          level 2 dcl 2-45 ref 744
output                          001222 automatic       bit(1)                   dcl 108 set ref 177* 178 194 255 258 398 429* 479*
                                                                                  489 532 547 558* 562 581* 585 638* 666* 666* 740
                                                                                  782 796
output_mode              77            based           fixed bin(17,0)          level 3 dcl 2-19 ref 803 803
padding                   1(07) 001240 automatic       bit(29)                  initial level 3 packed packed unaligned dcl 5-7 set
                                                                                  ref 5-7*
pathname                        000704 automatic       varying char(168)        dcl 91 set ref 251* 254* 258* 262* 468 470 479* 494*
                                                                                  524* 528* 532* 537* 542* 548* 556* 573* 579* 594*
                                                                                  638* 658* 666*
prompt_after_explanation
                          1(06) 001240 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 5-7 set
                                                                                  ref 5-7*
q_mess1                         000257 constant        char(57)                 initial packed unaligned dcl 115 set ref 558* 581*
q_mess2                         000241 constant        char(56)                 initial packed unaligned dcl 117 set ref 558* 581*
query_code                3     001240 automatic       fixed bin(35,0)          initial level 2 dcl 5-7 set ref 5-7*
query_info                      001240 automatic       structure                level 1 dcl 5-7 set ref 548 548 558 558 581 581 833
                                                                                  833
query_info_version_4                   constant        fixed bin(17,0)          initial dcl 5-34 ref 187
question_iocbp            4     001240 automatic       pointer                  initial level 2 dcl 5-7 set ref 5-7*
rcode                           000757 automatic       fixed bin(35,0)          dcl 92 set ref 653* 691* 692 693* 703* 704 706 708*
                                                                                  709* 710 713*
recl                            000624 automatic       picture(8)               packed unaligned dcl 75 set ref 417* 418 785* 786
reclen                  120            based           fixed bin(21,0)          level 3 dcl 2-19 ref 233 238 245 417 784 785
release_temp_segment_           000056 constant        entry                    external dcl 165 ref 610
repeat_time              10     001240 automatic       fixed bin(71,0)          initial level 2 dcl 5-7 set ref 5-7*
replace_id              105            based           char(17)                 level 3 dcl 2-19 ref 801 801
requote_string_                 000076 constant        entry                    external dcl 173 ref 749
ring                     76            based           bit(1)                   level 3 dcl 2-5 ref 194
ring_sw                         000760 automatic       bit(1)                   packed unaligned dcl 93 set ref 194* 768
rlen                            000762 automatic       fixed bin(21,0)          dcl 94 set ref 282* 290 293 295 305 340* 352 355 357
                                                                                  363 657
rtrim                                                  builtin function         dcl 153 ref 218 254 471 746 748 749 749 775
secq                            000626 automatic       picture(4)               packed unaligned dcl 76 set ref 221* 222 686* 765*
                                                                                  770 778* 779
segment                  10            based           structure                level 2 dcl 2-19
sequence                116            based           fixed bin(17,0)          level 3 dcl 2-19 set ref 221 324 329* 704* 712 740
                                                                                  764* 765 770 777 778
shortinfo                       000770 automatic       char(8)                  dcl 96 set ref 729*
source                   10            based           structure                level 2 dcl 2-5
ss_atd                          000772 automatic       char(256)                packed unaligned dcl 97 set ref 468* 470* 471* 471
                                                                                  477* 479* 494*
ss_file_attached                000014 internal static bit(1)                   initial dcl 130 set ref 488* 627 629*
ss_file_opened                  000015 internal static bit(1)                   initial dcl 130 set ref 504* 623 625*
ss_iocbp                        001072 automatic       pointer                  initial dcl 98 set ref 98* 192* 296* 340* 477* 492*
                                                                                  624* 628*
ss_open_mode                    001074 automatic       fixed bin(17,0)          dcl 99 set ref 489* 491* 492* 494
ss_switch                       001075 automatic       char(26)                 packed unaligned dcl 100 set ref 190* 477*
state                           000116 automatic       fixed bin(17,0)          level 2 dcl 51 set ref 654
status_code               2     001240 automatic       fixed bin(35,0)          initial level 2 dcl 5-7 set ref 5-7*
string                  202     000144 automatic       varying char(512)        level 2 dcl 53 set ref 384 388* 418* 418 429* 691
                                                                                  693* 808* 809*
substr                                                 builtin function         dcl 154 ref 745
suppress_name_sw          1(01) 001240 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 5-7 set
                                                                                  ref 5-7*
suppress_spacing          1(04) 001240 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 5-7 set
                                                                                  ref 5-7*
switches                  1     001240 automatic       structure                level 2 dcl 5-7
sys_info$max_seg_size           000016 external static fixed bin(35,0)          dcl 128 ref 193 225 245
tape                     75            based           structure                level 2 dcl 2-19
tape_attach_descp               000144 automatic       structure                level 1 dcl 53
tape_attached                   000012 internal static bit(1)                   initial dcl 130 set ref 396* 455 458*
tape_file_status                       based           structure                level 1 unaligned dcl 1-5
tape_io_data                           based           structure                level 1 dcl 2-5
tape_io_data_ptr                001236 automatic       pointer                  dcl 2-3 set ref 176* 177 194 197 206 206 797
tape_iocbp                      001104 automatic       pointer                  dcl 101 set ref 192* 282* 358* 384* 398* 400* 410*
                                                                                  450* 452* 456* 653* 691* 703* 708* 709* 725*
tape_opened                     000013 internal static bit(1)                   initial dcl 130 set ref 383 403* 446 453*
tape_switch                     001106 automatic       char(26)                 packed unaligned dcl 102 set ref 200* 384* 691*
tape_type              3011            based           fixed bin(17,0)          level 2 dcl 2-45 ref 743 754 756 782 782
truncate_lines           74            based           fixed bin(17,0)          level 3 dcl 2-19 ref 305 363
tstring                         001115 automatic       varying char(256)        dcl 103 set ref 738* 743* 746* 746 748* 748 749* 749
                                                                                  753* 753 754* 754 756* 756 759 762* 768* 768 770*
                                                                                  770 773* 773 775* 775 779* 779 786* 786 788* 788
                                                                                  790* 790 794* 794 797* 797 799* 799 801* 801 803*
                                                                                  803 807
type                      1     000547 automatic       fixed bin(17,0)          level 2 dcl 58 set ref 554 570
vcb                                    based           structure                level 1 dcl 2-45
vcb_ptr                         001234 automatic       pointer                  dcl 2-3 set ref 197* 197* 200 201* 204 258 388 412
                                                                                  429 479 494 638 658 666 743 744 745 746 748 749
                                                                                  749 749 753 754 756 782 782 823
version                         001240 automatic       fixed bin(17,0)          level 2 dcl 5-7 set ref 187*
vfile_info                      000547 automatic       structure                level 1 dcl 58 set ref 522 522
vfile_status_                   000100 constant        entry                    external dcl 174 ref 522
vol_init                        001216 automatic       bit(1)                   packed unaligned dcl 104 set ref 198* 739 758*
vol_string                      000144 automatic       varying char(256)        level 2 dcl 53 set ref 759* 808
volid                    11            based           char(32)                 array level 2 dcl 2-45 set ref 200 258* 388* 412*
                                                                                  429* 479* 494* 638* 658* 666* 745 746 748
wks_ptr                         000010 internal static pointer                  initial dcl 129 set ref 182* 282* 288 340* 350 609
                                                                                  610* 611*
wlen                            000763 automatic       fixed bin(21,0)          dcl 94 set ref 295* 296* 304 307 357* 358* 362 365
writeff_sw                      001217 automatic       bit(1)                   packed unaligned dcl 105 set ref 191* 688 688* 740*
                                                                                  763 766*
writing_tape             77            based           bit(1)                   level 3 dcl 2-5 ref 177
wt_ptr                          000766 automatic       pointer                  dcl 95 set ref 288* 296* 308* 308 350* 358* 366* 366
yes_or_no_sw              1     001240 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 5-7 set
                                                                                  ref 5-7* 521* 821*
zlck                            001220 automatic       bit(1)                   dcl 106 set ref 290* 292* 293 294* 352* 354* 355
                                                                                  356*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Direct_input                           internal static fixed bin(17,0)          initial dcl 4-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 4-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 4-15
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 4-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 4-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 4-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 4-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 4-15
Stream_input                           internal static fixed bin(17,0)          initial dcl 4-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 4-15
Stream_output                          internal static fixed bin(17,0)          initial dcl 4-15
dstat_ptr                              automatic       pointer                  dcl 3-3
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 5-33
query_info_version_5                   internal static fixed bin(17,0)          initial dcl 5-35
query_info_version_6                   internal static fixed bin(17,0)          initial dcl 5-36
short_iox_modes                        internal static char(4)                  initial array dcl 4-12
tfstat_ptr                             automatic       pointer                  dcl 1-3

NAMES DECLARED BY EXPLICIT CONTEXT.
ASK1                            010100 constant        label                    dcl 833 ref 845
COMMON_WORK                     002421 constant        label                    dcl 251 ref 227 231 236 243
Cleaner                         005255 constant        entry                    internal dcl 607 ref 195 210
FORMAT                          000000 constant        label                    array(0:11) dcl 225 ref 224
ask_user                        005243 constant        label                    dcl 597 ref 545 551 561 576 584
bad_position                    005762 constant        label                    dcl 693 ref 706 710
build_tape_attach               006256 constant        entry                    internal dcl 735 ref 275 333 687
check_ss_file                   004352 constant        entry                    internal dcl 515 ref 274 323
check_ss_file_status            005406 constant        entry                    internal dcl 636 ref 299 345
check_tape_status               005461 constant        entry                    internal dcl 650 ref 285 359
close_ss_file                   005344 constant        entry                    internal dcl 621 ref 314 371 476 613
close_tape_file                 003664 constant        entry                    internal dcl 442 ref 315 372 614
cntl_cont_abort                 007734 constant        entry                    internal dcl 817 ref 392 433 484 500 597 643 675 699
error_report                    006136 constant        entry                    internal dcl 723 ref 674 698
fcb_worker                      002264 constant        entry                    internal dcl 214 ref 202
open_ss_file                    003775 constant        entry                    internal dcl 465 ref 277 335
open_tape_file                  003175 constant        entry                    internal dcl 378 ref 276 334
position_to_end                 005670 constant        entry                    internal dcl 682 ref 325
read_tape                       002614 constant        entry                    internal dcl 272 ref 257
ss_rd_retry                     003027 constant        label                    dcl 340 ref 346
ss_wrt_retry                    002715 constant        label                    dcl 296 ref 300
tape_io_interpret_              001660 constant        entry                    external dcl 22
write_tape                      002775 constant        entry                    internal dcl 321 ref 255

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     10650       10752   10314       10660
Length     11344   10314       102         356     334           6

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
tape_io_interpret_                 1610 external procedure  is an external procedure.  
on unit on line 195                  64 on unit               
fcb_worker                              internal procedure  shares stack frame of external procedure tape_io_interpret_.  
read_tape                               internal procedure  shares stack frame of external procedure tape_io_interpret_.  
write_tape                              internal procedure  shares stack frame of external procedure tape_io_interpret_.  
open_tape_file                          internal procedure  shares stack frame of external procedure tape_io_interpret_.  
close_tape_file                      88 internal procedure  is called by several nonquick procedures.  
open_ss_file                            internal procedure  shares stack frame of external procedure tape_io_interpret_.  
check_ss_file                           internal procedure  shares stack frame of external procedure tape_io_interpret_.  
Cleaner                              82 internal procedure  is called by several nonquick procedures.  
close_ss_file                        72 internal procedure  is called by several nonquick procedures.  
check_ss_file_status                    internal procedure  shares stack frame of external procedure tape_io_interpret_.  
check_tape_status                       internal procedure  shares stack frame of external procedure tape_io_interpret_.  
position_to_end                         internal procedure  shares stack frame of external procedure tape_io_interpret_.  
error_report                            internal procedure  shares stack frame of external procedure tape_io_interpret_.  
build_tape_attach                       internal procedure  shares stack frame of external procedure tape_io_interpret_.  
cntl_cont_abort                         internal procedure  shares stack frame of external procedure tape_io_interpret_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 wks_ptr                     tape_io_interpret_
000012 tape_attached               tape_io_interpret_
000013 tape_opened                 tape_io_interpret_
000014 ss_file_attached            tape_io_interpret_
000015 ss_file_opened              tape_io_interpret_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
tape_io_interpret_       000100 ads                         tape_io_interpret_
                         000116 atfs                        tape_io_interpret_
                         000144 tape_attach_descp           tape_io_interpret_
                         000547 vfile_info                  tape_io_interpret_
                         000556 add_specified_attributes    tape_io_interpret_
                         000557 abort_sw                    tape_io_interpret_
                         000560 amrl                        tape_io_interpret_
                         000561 answer                      tape_io_interpret_
                         000622 blkl                        tape_io_interpret_
                         000624 recl                        tape_io_interpret_
                         000626 secq                        tape_io_interpret_
                         000627 blockl                      tape_io_interpret_
                         000630 char_cnt                    tape_io_interpret_
                         000631 code                        tape_io_interpret_
                         000632 cont_sw                     tape_io_interpret_
                         000633 control_sw                  tape_io_interpret_
                         000634 db_sw                       tape_io_interpret_
                         000635 end_of_data                 tape_io_interpret_
                         000636 end_of_tape                 tape_io_interpret_
                         000637 file_count                  tape_io_interpret_
                         000640 fileid                      tape_io_interpret_
                         000646 fnbr                        tape_io_interpret_
                         000647 i                           tape_io_interpret_
                         000650 longinfo                    tape_io_interpret_
                         000701 name                        tape_io_interpret_
                         000704 pathname                    tape_io_interpret_
                         000757 rcode                       tape_io_interpret_
                         000760 ring_sw                     tape_io_interpret_
                         000761 blen                        tape_io_interpret_
                         000762 rlen                        tape_io_interpret_
                         000763 wlen                        tape_io_interpret_
                         000764 b_offset                    tape_io_interpret_
                         000766 wt_ptr                      tape_io_interpret_
                         000770 shortinfo                   tape_io_interpret_
                         000772 ss_atd                      tape_io_interpret_
                         001072 ss_iocbp                    tape_io_interpret_
                         001074 ss_open_mode                tape_io_interpret_
                         001075 ss_switch                   tape_io_interpret_
                         001104 tape_iocbp                  tape_io_interpret_
                         001106 tape_switch                 tape_io_interpret_
                         001115 tstring                     tape_io_interpret_
                         001216 vol_init                    tape_io_interpret_
                         001217 writeff_sw                  tape_io_interpret_
                         001220 zlck                        tape_io_interpret_
                         001221 cant_cont                   tape_io_interpret_
                         001222 output                      tape_io_interpret_
                         001223 io_started                  tape_io_interpret_
                         001232 fcb_ptr                     tape_io_interpret_
                         001234 vcb_ptr                     tape_io_interpret_
                         001236 tape_io_data_ptr            tape_io_interpret_
                         001240 query_info                  tape_io_interpret_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this
call_int_other      return_mac          enable_op           shorten_stack       ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      command_query_                convert_status_code_          cu_$cl
get_temp_segment_             ioa_                          iox_$attach_name              iox_$close
iox_$control                  iox_$detach_iocb              iox_$open                     iox_$read_record
iox_$write_record             release_temp_segment_         requote_string_               vfile_status_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$dirseg           error_table_$end_of_info      error_table_$eov_on_write     error_table_$file_busy
error_table_$insufficient_open                              error_table_$moderr           error_table_$no_file
error_table_$noentry          error_table_$short_record     sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     22 001655        82 001665        98 001666    5    7 001670       176 001717       177 001723       178 001725
    180 001733       182 001737       183 001767       184 001772       185 002016       187 002017       188 002021
    189 002023       190 002024       191 002053       192 002056       193 002061       194 002065       195 002072
    197 002114       198 002131       199 002133       200 002134       201 002164       202 002177       203 002200
    204 002204       206 002210       210 002257       212 002263       214 002264       216 002265       217 002267
    218 002273       221 002321       222 002330       223 002365       224 002366       225 002370       227 002374
    229 002375       231 002377       233 002400       236 002402       238 002403       243 002406       245 002407
    251 002421       254 002442       255 002506       257 002514       258 002515       262 002563       265 002613
    272 002614       274 002615       275 002616       276 002617       277 002620       281 002621       282 002631
    283 002650       285 002657       288 002663       289 002665       290 002666       292 002673       293 002674
    294 002706       295 002707       296 002715       298 002732       299 002734       300 002735       302 002737
    304 002740       305 002742       307 002751       308 002753       310 002760       313 002761       314 002762
    315 002766       317 002774       321 002775       323 002776       324 002777       325 003003       328 003007
    329 003010       331 003012       332 003013       333 003014       334 003015       335 003016       339 003017
    340 003027       342 003046       344 003055       345 003061       346 003062       348 003064       350 003065
    351 003067       352 003070       354 003075       355 003076       356 003110       357 003111       358 003117
    359 003134       362 003140       363 003142       365 003151       366 003153       368 003160       370 003161
    371 003162       372 003166       374 003174       378 003175       380 003176       382 003204       383 003205
    384 003213       387 003254       388 003257       392 003320       393 003324       396 003325       398 003330
    400 003352       403 003370       406 003376       408 003401       410 003403       412 003414       417 003435
    418 003445       423 003602       424 003604       428 003605       429 003607       433 003654       434 003660
    437 003661       438 003662       442 003663       446 003671       450 003673       452 003737       453 003752
    455 003754       456 003756       457 003770       458 003772       461 003774       465 003775       467 003776
    468 004004       470 004026       471 004044       473 004076       474 004101       475 004104       476 004105
    477 004111       478 004143       479 004145       484 004216       485 004222       486 004225       488 004226
    489 004231       491 004237       492 004241       493 004257       494 004261       500 004334       501 004340
    502 004343       504 004344       505 004347       509 004350       511 004351       515 004352       517 004353
    518 004354       519 004356       520 004360       521 004361       522 004363       523 004421       524 004423
    528 004456       532 004510       537 004545       541 004601       542 004603       545 004632       547 004633
    548 004642       551 004700       554 004705       555 004710       556 004714       558 004740       561 005006
    562 005013       564 005022       569 005030       570 005031       571 005033       572 005036       573 005041
    576 005070       578 005071       579 005075       581 005121       584 005167       585 005174       587 005203
    592 005211       594 005212       597 005243       599 005247       601 005252       603 005253       607 005254
    609 005262       610 005266       611 005320       613 005324       614 005331       616 005342       621 005343
    623 005351       624 005353       625 005365       627 005367       628 005371       629 005403       632 005405
    636 005406       638 005407       643 005454       645 005460       650 005461       652 005462       653 005464
    654 005517       656 005523       657 005527       658 005531       663 005601       664 005603       666 005604
    674 005662       675 005663       677 005667       682 005670       684 005671       685 005677       686 005702
    687 005711       688 005712       691 005715       692 005757       693 005762       698 006012       699 006013
    700 006017       701 006020       703 006021       704 006040       706 006050       708 006052       709 006062
    710 006073       712 006075       713 006101       714 006102       715 006132       717 006133       719 006135
    723 006136       725 006137       726 006167       727 006171       728 006211       729 006221       730 006234
    731 006253       733 006255       735 006256       736 006257       737 006261       738 006267       739 006270
    740 006272       743 006302       744 006314       745 006323       746 006332       747 006416       748 006420
    749 006474       752 006607       753 006612       754 006654       756 006673       758 006707       759 006710
    762 006715       763 006722       764 006724       765 006727       766 006736       768 006737       770 006753
    772 007013       773 007014       775 007056       777 007131       778 007134       779 007143       780 007214
    781 007215       782 007224       784 007235       785 007237       786 007246       787 007317       788 007320
    790 007373       792 007436       793 007440       794 007441       796 007515       797 007521       799 007536
    801 007575       803 007635       807 007655       808 007662       809 007705       812 007733       817 007734
    821 007736       822 007740       823 007743       824 007760       826 007766       827 007770       828 010010
    830 010011       833 010100       837 010145       838 010156       840 010205       841 010207       842 010214
    843 010215       845 010227       849 010236


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
