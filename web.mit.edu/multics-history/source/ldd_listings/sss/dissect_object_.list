	COMPILATION LISTING OF SEGMENT dissect_object_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/20/86  1221.8 mst Thu
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 
       12 /****^  HISTORY COMMENTS:
       13*  1) change(85-09-24,Elhard), approve(85-09-24,MCR7198),
       14*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
       15*     Changed errname to use caller supplied name instead of "binder_", improved
       16*     documentation and readability, deleted obsolete nonstandard object
       17*     support, and added code to create the link_regeneration_table.
       18*  2) change(86-07-02,Elhard), approve(86-07-02,MCR7284),
       19*     audit(86-07-23,JRGray), install(86-08-06,MR12.0-1119):
       20*     Modified to not use segname definitions already in the component as search
       21*     names for resolving intercomponent calls.
       22*                                                   END HISTORY COMMENTS */
       23 
       24 /**********************************************************************/
       25 /*							*/
       26 /*	Name:	dissect_object_				*/
       27 /*	Input:	compent_ptr				*/
       28 /*	Function:	breaks down the object segment specified by the	*/
       29 /*		component table entry pointed to by compent and	*/
       30 /*		fills in the rest of the component table entry.	*/
       31 /*		This procedure is also responsible for the	*/
       32 /*		following:				*/
       33 /*		  1) copying the component's text section into	*/
       34 /*		     the new object	segment, padding the end of	*/
       35 /*		     the the previous text section if required	*/
       36 /*		     to get the proper text section alignment,	*/
       37 /*		     and calculating the new text section	*/
       38 /*		     relocation counter.			*/
       39 /*		  2) calculate the relocation counter for the	*/
       40 /*		     internal static section and pad the static	*/
       41 /*		     section of the previous component if reqd	*/
       42 /*		     to align the current component's static	*/
       43 /*		     section on the proper boundary.		*/
       44 /*		  3) the segname table is updated to include the	*/
       45 /*		     new component.				*/
       46 /*		  4) copy the definition section into the insym	*/
       47 /*		     table.				*/
       48 /*		  5) determine the number of symbol blocks that	*/
       49 /*		     are present in the object segment.		*/
       50 /*		  6) allocate the link_regeneration_table for the	*/
       51 /*		     component.				*/
       52 /*	Output:	none					*/
       53 /*							*/
       54 /**********************************************************************/
       55 
       56 /* Designed and initially coded by Michael J. Spier, August 20, 1970	*/
       57 /* modified 75.06.20 by M. Weaver for separate static		*/
       58 
       59 /* format: style3,^indnoniterdo */
       60 dissect_object_:
       61      procedure (compent_ptr);
       62 
       63 declare	compent_ptr	pointer;
       64 
       65 
       66 
       67 /* DECLARATION OF EXTERNAL ENTRIES */
       68 
       69 declare	decode_definition_$full
       70 			external entry (pointer, pointer, pointer) returns (bit (1) aligned);
       71 declare	object_info_$long	external entry (pointer, fixed bin (24), pointer, fixed bin (35));
       72 declare	com_err_		external entry options (variable);
       73 declare	ioa_		external entry options (variable);
       74 declare	temp_mgr_$allocate	external entry (fixed bin);
       75 declare	temp_mgr_$reserve	external entry (pointer);
       76 
       77 /* DECLARATION OF EXTERNAL STATIC */
       78 
       79 declare	error_table_$bad_segment
       80 			external fixed bin (35);
       81 declare	error_table_$unimplemented_version
       82 			external fixed bin (35);
       83 
       84 /* DECLARATION OF INTERNAL STATIC VARIABLES */
       85 
       86 declare	last_insym	pointer internal static initial (null);
       87 declare	(text_relc, is_relc)
       88 			fixed bin internal static initial (0);
       89 declare	errname		char (16) aligned internal static;
       90 
       91 /* DECLARATION OF AUTOMATIC STORAGE VARIABLES */
       92 
       93 declare	i		fixed bin;
       94 declare	(def_begin, def_offset, val, lng)
       95 			fixed bin (18);
       96 declare	code		fixed bin (35);
       97 declare	(p, sblkp, ddp, oip)
       98 			pointer;
       99 declare	(defp, insymp, insymep)
      100 			pointer;
      101 declare	type_string	char (5) aligned;
      102 declare	link_start	fixed bin (18) unsigned;
      103 declare	link_end		fixed bin (18) unsigned;
      104 declare	lrt_len		fixed bin;
      105 declare	lrt_word_count	fixed bin;
      106 
      107 declare	1 dd		aligned,			/* output structure for decode_definition_ */
      108 	  2 next_def	pointer,
      109 	  2 last_def	pointer,
      110 	  2 block_ptr	pointer,
      111 	  2 section	char (4) aligned,
      112 	  2 value		fixed bin (18),
      113 	  2 entrypoint	fixed bin,
      114 	  2 symbol	char (256) aligned,
      115 	  2 symbol_lng	fixed bin,		/* actual length of symbol */
      116 	  2 flags,
      117 	    3 new_format	bit (1) unaligned,
      118 	    3 ignore	bit (1) unaligned,		/* def is to be ignored but will be regenerated */
      119 	    3 entrypoint	bit (1) unaligned,		/* def is for entrypoint */
      120 	    3 retain	bit (1) unaligned,
      121 	    3 arg_count	bit (1) unaligned,		/* there is an arg count for entry */
      122 	    3 descr_sw	bit (1) unaligned,		/* there are descriptors for entry */
      123 	    3 unused	bit (13) unaligned,
      124 	  2 n_args	fixed bin,		/* no of args entry expects */
      125 	  2 descr_ptr	ptr;			/* ptr to array of rel ptrs to descriptors in def section */
      126 
      127 /* DECLARATION OF BUILTIN FUNCTIONS */
      128 
      129 declare	(addr, addrel, bin, bit, divide, fixed, min, null, ptr, rel, substr, trunc)
      130 			builtin;
      131 
      132 /* DECLARATION OF BASED STRUCTURES */
      133 
      134 declare	1 insyme		aligned like is based (insymep);
      135 declare	1 symbol_acc	aligned based (addr (insyme.symbol)),
      136 	  2 len		fixed bin (9) unsigned unaligned,
      137 	  2 text		char (32 refer (symbol_acc.len)) unaligned;
      138 declare	1 rhb		based aligned,
      139 	  2 dum		bit (35) unaligned,
      140 	  2 odd		bit (1) unaligned;		/* to determine if a value is even/odd */
      141 
      142 declare	textsection	(lng) fixed bin based (p);
      143 
      144 /*  */
      145 
  1     1 /****  START OF:	bindext.incl.pl1			 *  *  *  *  *  */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(86-06-14,Elhard), approve(86-06-14,MCR7198),
  1     6*     audit(86-06-30,Weaver):
  1     7*     Added declarations for bx_$caller and bx_$temp_bsegp.
  1     8*                                                   END HISTORY COMMENTS */
  1     9 
  1    10 /* DECLARATION OF BINDER'S MAIN DATABASE */
  1    11 
  1    12 /* include file bindext.incl.pl1 */
  1    13 
  1    14 /* Modified Sept 1978 by David Spector for using "get_temp_segment_" in temp_mgr_ */
  1    15 /* Modified Dec 1978 by David Spector for making repatch table automatically extensible */
  1    16 /* Modified 01/15/81 W. Olin Sibert for new options */
  1    17 
  1    18 declare  bx_$vers_name char (168) aligned external;	/* ASCII version name, in ACC form */
  1    19 declare  bx_$vers_number fixed bin external;		/* integer part of version number */
  1    20 declare  bx_$size fixed bin external;			/* size of main data base, for resetting */
  1    21 declare  bx_$snt_limit fixed bin external;		/* preset limit for segname table */
  1    22 declare  bx_$oddname_limit fixed bin external;		/* preset limit for oddname table */
  1    23 declare  bx_$stringmap_limit fixed bin external;		/* preset limit for stringmap table */
  1    24 declare  bx_$addname_limit fixed bin external;		/* preset limit for addname table */
  1    25 declare  bx_$area_begin fixed bin (18) external;		/* beginning of main data base */
  1    26 declare  bx_$ctp pointer external;			/* pointer to component table */
  1    27 declare  bx_$freep pointer external;			/* pointer to beginning of free area */
  1    28 declare  bx_$isp pointer external;			/* pointer to first insym table */
  1    29 declare  bx_$inpp pointer external;			/* pointer to binder's input structure */
  1    30 declare  bx_$bsegp pointer external;			/* pointer to base of new object segment */
  1    31 declare  bx_$temp pointer external;			/* pointer to threaded list of temp segments */
  1    32 declare  bx_$optp pointer external;			/* pointer to options table */
  1    33 declare  bx_$odnp pointer external;			/* pointer to oddname table */
  1    34 declare  bx_$first_rptp pointer external;		/* pointer to first chunk of repatch table */
  1    35 declare  bx_$last_rptp pointer external;		/* pointer to current chunk of threaded repatch table */
  1    36 declare  bx_$adnp pointer external;			/* pointer to addname table */
  1    37 declare  bx_$bindmap_def pointer external;		/* pointer to new object's "bind_map" definition */
  1    38 declare  bx_$bdefp pointer external;			/* pointer to new object's definition section */
  1    39 declare  bx_$bstatp pointer external;			/* pointer to new object's static section */
  1    40 declare  bx_$blnkp pointer external;			/* pointer to new object's linkage section */
  1    41 declare  bx_$bsymp pointer external;			/* pointer to new object's symbol section */
  1    42 declare  bx_$sntp pointer external;			/* pointer to segname table */
  1    43 declare  bx_$tdefp pointer external;			/* pointer to temporary new definition section */
  1    44 declare  bx_$tintp pointer external;			/* pointer to temporary new internal static */
  1    45 declare  bx_$tlinkp pointer external;			/* pointer to temporary new linkage section */
  1    46 declare  bx_$strmp pointer external;			/*  pointer to stringmap table */
  1    47 declare  bx_$n_firstrefs fixed bin external;		/* count of components with firstref traps */
  1    48 declare  bx_$bound_segname char (32) aligned external;	/* name of new bound object */
  1    49 declare  bx_$fatal_error fixed bin external;		/* 1 -> fatal error was detected */
  1    50 declare  bx_$bseg_acinfop pointer external;		/* new object's acinfop for "tssi_" */
  1    51 declare  bx_$bseg_bitcount fixed bin (24) external;	/* new object's bitcount */
  1    52 declare  bx_$o_lng fixed bin (19) external;		/* length of new bound object */
  1    53 declare  bx_$t_lng fixed bin (18) external;		/* length of new text section */
  1    54 declare  bx_$d_lng fixed bin (18) external;		/* length of new definition section */
  1    55 declare  bx_$i_lng fixed bin external;			/* length of new static section */
  1    56 declare  bx_$l_lng fixed bin external;			/* length of new linkage section */
  1    57 declare  bx_$s_lng fixed bin (18) external;		/* length of new symbol section */
  1    58 declare  bx_$addname fixed bin external;		/* 1 -> addname option specified */
  1    59 declare  bx_$debug fixed bin external;			/* 1 -> debug option was specified */
  1    60 declare  bx_$brief fixed bin external;			/* 1 -> brief option was specified */
  1    61 declare  bx_$force_order fixed bin external;		/* 1 -> -force_order specified on command line */
  1    62 declare  bx_$has_sep_stat fixed bin external;		/* 1 -> a comp has nonzero sep static */
  1    63 declare  bx_$has_comb_stat fixed bin external;		/* 1 -> a comp has nonzero combined static */
  1    64 declare  bx_$bound_sep_stat fixed bin external;		/* 1 -> bound segment has separate static */
  1    65 declare  bx_$perprocess_static fixed bin external;	/* 1 -> bound segment has perprocess static switch on */
  1    66 declare  bx_$standard fixed bin external;		/* 1 -> bound seg is in standard format */
  1    67 declare  bx_$bproc fixed bin external;			/* 1 -> at least one component is a procedure */
  1    68 declare  bx_$textlng fixed bin (18) external;		/* length of new pure text portion */
  1    69 declare  bx_$curdeflng fixed bin (18) external;		/* current length of new definition section */
  1    70 declare  bx_$tintlng fixed bin external;		/* current length of new internal static */
  1    71 declare  bx_$maxlinklng fixed bin external;		/* maximum size linkage section may attain */
  1    72 declare  bx_$maxdeflng fixed bin (18) external;		/* maximum size definition section may attain */
  1    73 declare  bx_$tlinklng fixed bin external;		/* current size of linkage section */
  1    74 declare  bx_$ncomp fixed bin external;			/* number of component objects to be bound */
  1    75 declare  bx_$v_lng fixed bin external;			/* length of version name string */
  1    76 declare  bx_$n_lng fixed bin external;			/* length of bound segment name string */
  1    77 declare  bx_$nsymdefs fixed bin external;		/* count of non-null symbol definitions */
  1    78 declare  bx_$nsegdefs fixed bin external;		/* count of non-null segment name definitions */
  1    79 declare  bx_$temp_bsegp ptr external;			/* pointer to the temporary bound seg in the process dir */
  1    80 declare  bx_$caller char (32) aligned external;		/* name of the caller of bind_ for error messages */
  1    81 
  1    82 /****  END OF:	bindext.incl.pl1			 *  *  *  *  *  */
      146 
      147 
      148 /*  */
      149 
  2     1 	/* Include file comptbl.incl.pl1 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(85-09-24,Elhard), approve(85-09-24,MCR7198),
  2     6*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
  2     7*     added link_regeneration_table pointer (clrtp) to component structure.
  2     8*                                                   END HISTORY COMMENTS */
  2     9 
  2    10 declare	(ctp, ctep) pointer;
  2    11 
  2    12 declare	comp_tbl(1000) pointer based(ctp);
  2    13 
  2    14 
  2    15 
  2    16 declare	1 comp aligned based(ctep),		/* declaration of a component entry */
  2    17 	2 filename char(32) aligned,		/* object segment's file name */
  2    18 	2 compiler char(8) aligned,		/* name of compiler which produced this object */
  2    19 	2 format char(8) aligned,		/* format of object code (PL/1, ALM etc.)  */
  2    20 
  2    21 	2 ctxtp pointer,			/* pointer to base of text section */
  2    22 	2 cdefp pointer,			/* pointer to definitions */
  2    23 	2 cstatp pointer,			/* pointer to static section */
  2    24 	2 clnkp pointer,			/* pointer to head of linkage section */
  2    25 	2 csymp pointer,			/* pointer to symbol table */
  2    26 	2 cfrtp pointer,			/* pointer to first ref trap array */
  2    27 	2 crltp pointer,			/* pointer to rel-text */
  2    28 	2 crllp pointer,			/* pointer to rel-link */
  2    29 	2 crlsp pointer,			/* pointer to rel-symb */
  2    30 	2 insymentp pointer,		/* pointer to this component's insym table entry */
  2    31 	2 clrtp pointer,			/* pointer to link_regeneration_table */
  2    32 	2 unused_1 pointer,			/* reserve */
  2    33 	2 unused_2 pointer,			/* reserve */
  2    34 	2 unused_3 fixed bin,		/* reserve */
  2    35 	2 cindex fixed bin,			/* this entry's index in table */
  2    36 	2 standard_object fixed bin,		/* 1 -> this object has standard format */
  2    37 	2 defthread fixed bin,		/* beginning of comp's definition block */
  2    38 	2 fn_lng fixed bin,			/* length of filename string */
  2    39 	2 ignore fixed bin,			/* 1->ignore erroneous entry */
  2    40 	2 io_table fixed bin,		/* 1 -> symbol table needed for io */
  2    41 	2 table_deleted fixed bin,		/* 1 -> symbol table is being deleted */
  2    42 	2 separate_static fixed bin,		/* 1 -> component has nonzero separate static */
  2    43          (2 defblockp,			/* rel pointer to component's definition block */
  2    44 	2 current_def) bit(18) unaligned,	/* rel pointer to component's current def */
  2    45 	2 cbitcount fixed bin(24),		/* bitcount of component segment */
  2    46 	2 clngt fixed bin(18),		/* length of pure text section */
  2    47 	2 cpadt fixed bin,			/* number of added padwords for text */
  2    48 	2 clngd fixed bin(18),		/* length of definition section */
  2    49 	2 clngi fixed bin,			/* length of internal static */
  2    50 	2 cpadi fixed bin,			/* number of added padwords for internal static  */
  2    51 	2 clngs fixed bin(18),		/* length of original symbol table */
  2    52 	2 clngns fixed bin(18),		/* length of new symb section stripped of relbits */
  2    53 	2 clngss fixed bin(18),		/* length of symbol section minus relbits and table */
  2    54 	2 cpads fixed bin,			/* padding length if section length is odd */
  2    55 	2 n_sym_blks fixed bin,		/* number of symbol blocks */
  2    56 
  2    57 	2 crelt fixed bin,			/* relocation value for text */
  2    58 	2 creli fixed bin,			/* relocation value for internal static */
  2    59 	2 crels fixed bin,			/* relocation value for symbol section */
  2    60 	2 last_item fixed bin;		/*** MUST ALWAYS BE LAST IN STRUCTURE ***/
  2    61  
  2    62 
  2    63 
      150 
      151 
      152 /*  */
      153 
  3     1 	/* Include file bndtbl.incl.pl1 */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(85-09-24,Elhard), approve(85-09-24,MCR7198),
  3     6*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
  3     7*     Added link_regeneration_table and eliminated the use of "p" as a pointer
  3     8*     to base structures on..
  3     9*                                                   END HISTORY COMMENTS */
  3    10 
  3    11 	/* DIVERSE BINDER TABLES */
  3    12 
  3    13 	/* Modified Oct 1978 by David Spector for hash coding snt and strm */
  3    14 	/* Modified Dec 1978 by David Spector for making repatch table
  3    15*	   automatically extensible */
  3    16 	
  3    17 declare	(sntp, adnp, odnp, rptp, rptep, strmp, lrtp) pointer;
  3    18 
  3    19 	/* The SEGNAME table  -  segnames and synonyms of all components */
  3    20 
  3    21 declare	1 snt aligned based(sntp),
  3    22 	2 hash_table (0:210) unaligned ptr,	/* prime length */
  3    23 	2 max_size fixed bin,		/* size limit of allocated segname table */
  3    24 	2 n_names fixed bin,		/* number of segname-table entries used */
  3    25 	2 entry(1000) like seg;
  3    26 
  3    27 	/* declaration of a SEGNAME entry */
  3    28 
  3    29 declare	1 seg aligned based,		/* redeclaration of a single segname */
  3    30 	  2 name char(33) aligned,		/* segname in ACC string format */
  3    31 	  2 lng fixed bin,			/* length of segname, incl ACC count */
  3    32 	  2 addname fixed bin,		/* 1-> add name to bound segment */
  3    33 	  2 defrel bit(18),			/* offset in defs of new definition */
  3    34 	  2 comp pointer,			/* pointer to associated component table */
  3    35 	  2 hash_thread ptr;		/* thread to next "seg" in bucket */
  3    36 
  3    37 
  3    38 	/* the ADDNAME table  - list of names specified by "Addname" statement */
  3    39 
  3    40 declare	1 an aligned based(adnp),
  3    41 	2 max_size fixed bin,		/* size limit of addname table */
  3    42 	2 n_an fixed bin,			/* number of names to add */
  3    43 	2 syn(1000) char(32) aligned;		/* contains the names to be added */
  3    44 
  3    45 
  3    46 	/* The ODDNAME table  -  scratchpad memory to suppress redundant error messages */
  3    47 
  3    48 declare	1 od aligned based(odnp),
  3    49 	2 max_size fixed bin,		/* max size of table */
  3    50 	2 n_odds fixed bin,			/* current size of table */
  3    51 	2 entry(1000),
  3    52 	  3 name char(289) aligned;
  3    53 
  3    54 
  3    55 	/* The REPATCH table  -  of halfwords to be relocated at a later time */
  3    56 
  3    57 declare	1 rpt aligned based(rptp),
  3    58 	2 thread unaligned ptr,			/* To next rpt (null at end) */
  3    59 	2 npt fixed bin,
  3    60 	2 entry(1000) like rpte aligned;
  3    61 
  3    62 
  3    63 declare	1 rpte aligned based(rptep),		/* declaration of single repatch table entry */
  3    64 	2 poffset bit(18) unaligned,		/* offset into text of word to be patched */
  3    65 	2 pexpr bit(18) unaligned,		/* value to add to patched halfword */
  3    66 	2 halfword char(3) aligned,		/* designates wordhalf to be patched */
  3    67 	2 pbase char(1) unaligned,		/* section designator of word to be patched */
  3    68 	2 code char(1) unaligned;		/* code of section base to be used as patch value */
  3    69 
  3    70 
  3    71 	/* The STRINGMAP table - to avoid redundant strings in definition section */
  3    72 
  3    73 declare	1 strm aligned based(strmp),
  3    74 	2 hash_table (0:862) fixed bin(17),	/* prime length */
  3    75 	2 max_size fixed bin,
  3    76 	2 nstr fixed bin,
  3    77 	2 entry(2048) unaligned,
  3    78 	  3 map bit(18),			/* rel pointer to string in def section */
  3    79 	  3 hash_thread fixed bin(17);	/* index of next strm.entry in hash bucket */
  3    80 
  3    81 	/* The LINK_REGENERATION table - to flag links which have and  */
  3    82 	/* have not been regenerated to insure generation of all links */
  3    83 	
  3    84 declare	1 lrt		aligned based (lrtp),
  3    85 	  2 count		fixed bin,
  3    86 	  2 start_offset	fixed bin (18) unsigned,
  3    87 	  2 regenerated (0 refer (lrt.count))
  3    88 			bit (18) unaligned;
  3    89 
  3    90 declare	UNRESOLVED	bit (18) static options (constant) init ("000000"b3);
  3    91 declare	INTERNALLY_RESOLVED	bit (18) static options (constant) init ("777777"b3);
      154 
      155 
      156 /*  */
      157 
  4     1 	/* Include file insym.incl.pl1 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(86-06-14,Elhard), approve(86-06-14,MCR7198),
  4     6*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
  4     7*     Changed to eliminate the use of "p" as a pointer to base the structures
  4     8*     on.
  4     9*                                                   END HISTORY COMMENTS */
  4    10 
  4    11 
  4    12 declare	1 insym aligned based,		/* declaration of the INSYM structure */
  4    13 
  4    14 	2 thread pointer,			/* pointer to the next insym structure */
  4    15 	2 n_insyms fixed bin,		/* number of insym entries */
  4    16 	(2 retained,			/* def(s) have been retained for this component */
  4    17 	2 global_nolink) bit(1) unaligned,	/* don't prelink any reference to/from this object */
  4    18 	2 entry(1000) like is;
  4    19 
  4    20 declare	1 is aligned based,
  4    21          (2 next_ext_ptr bit(18),		/* thread to next def */
  4    22 	2 trap_ptr bit(18),			/* trap pointer */
  4    23 	2 value bit(18),			/* symbol's offset value */
  4    24 	2 class bit(18)) unaligned,		/* corresponding section of the object */
  4    25 	2 def_offset fixed bin(18),		/* offset of def in original def section */
  4    26 	2 symbol char(257) aligned,		/* the symbol in ACC string form */
  4    27 	2 lng fixed bin,			/* length in chars of ACC string (incl. ACC count) */
  4    28 	2 nargs fixed bin,			/* # of args expected by entry */
  4    29 	2 descr_ptr pointer,		/* ptr to descriptor ptr array */
  4    30          (2 null_entry,			/* 1->type 3 (seg|expr) entry, no insym symbol */
  4    31 	2 snapped,			/* 0->not referenced, 1->link snapped */
  4    32 	2 has_descr,			/* 1->entry has valid descriptors */
  4    33 	2 entrypoint,			/* 0->segdef, 1->entrypoint; meaningful only for standard */
  4    34 	2 retain_flag,			/* 1->turn on retain flag; was on in original */
  4    35 	2 delete,				/* 1->don't regenerate this def in any case */
  4    36 	2 ignore,				/* 1->regenerate but ignore */
  4    37 	2 regenerated,			/* this definition already regenerated */
  4    38 	2 retain,				/* 0->don't regenerate, 1->retain definition */
  4    39 	2 no_link,			/* don't prelink to this symbol */
  4    40 	2 duplicate) bit(1) unaligned,	/* this symbol name duplicated in another block */
  4    41 	2 defrel bit (18);			/* offset in defs of regenerated definition */
  4    42 
  4    43 
  4    44 
      158 
      159 
      160 /*  */
      161 
      162 declare	1 oi		aligned like object_info;
      163 
  5     1 /* BEGIN INCLUDE FILE ... object_info.incl.pl1
  5     2*coded February 8, 1972 by Michael J. Spier	*/
  5     3 /* modified May 26, 1972 by M. Weaver */
  5     4 /* modified 15 April, 1975 by M. Weaver */
  5     5 
  5     6 declare	1 object_info aligned based,		/* structure containing object info based, returned by object_info_ */
  5     7 	2 version_number fixed bin,		/* version number of current structure format (=2) */
  5     8 	2 textp pointer,			/* pointer to beginning of text section */
  5     9 	2 defp pointer,			/* pointer to beginning of definition section */
  5    10 	2 linkp pointer,			/* pointer to beginning of linkage section */
  5    11 	2 statp pointer,			/* pointer to beginning of static section */
  5    12 	2 symbp pointer,			/* pointer to beginning of symbol section */
  5    13 	2 bmapp pointer,			/* pointer to beginning of break map (may be null) */
  5    14 	2 tlng fixed bin,			/* length in words of text section */
  5    15 	2 dlng fixed bin,			/* length in words of definition section */
  5    16 	2 llng fixed bin,			/* length in words of linkage section */
  5    17 	2 ilng fixed bin,			/* length in words of static section */
  5    18 	2 slng fixed bin,			/* length in words of symbol section */
  5    19 	2 blng fixed bin,			/* length in words of break map */
  5    20 	2 format,				/* word containing bit flags about object type */
  5    21 	  3 old_format bit(1) unaligned,	/* on if segment isn't in new format, i.e. has old style object map */
  5    22 	  3 bound bit(1) unaligned,		/* on if segment is bound */
  5    23 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
  5    24 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
  5    25 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
  5    26 	  3 gate bit(1) unaligned,		/* on if segment is a gate */
  5    27 	  3 separate_static bit(1) unaligned,	/* on if static not in linkage */
  5    28 	  3 links_in_text bit(1) unaligned,	/* on if there are threaded links in text */
  5    29 	  3 perprocess_static bit (1) unaligned, /* on if static is not to be per run unit */
  5    30 	  3 pad bit(27) unaligned,
  5    31 	2 entry_bound fixed bin,		/* entry bound if segment is a gate */
  5    32 	2 textlinkp pointer,		/* ptr to first link in text */
  5    33 
  5    34 	/* LIMIT OF BRIEF STRUCTURE */
  5    35 
  5    36 	2 compiler char(8) aligned,		/* name of processor which generated segment */
  5    37 	2 compile_time fixed bin(71),		/* clock reading of date/time object was generated */
  5    38 	2 userid char(32) aligned,		/* standard Multics id of creator of object segment */
  5    39 	2 cvers aligned,			/* generator version name in printable char string form */
  5    40 	  3 offset bit(18) unaligned,		/* offset of name in words relative to base of symbol section */
  5    41 	  3 length bit(18) unaligned,		/* length of name in characters */
  5    42 	2 comment aligned,			/* printable comment concerning generator or generation of segment */
  5    43 	  3 offset bit(18) unaligned,		/* offset of comment in words relative to base of symbol section */
  5    44 	  3 length bit(18) unaligned,		/* length of comment in characters */
  5    45 	2 source_map fixed bin,		/* offset, relative to base of symbol section, of source map structure */
  5    46 
  5    47 	/* LIMIT OF DISPLAY STRUCTURE */
  5    48 
  5    49 	2 rel_text pointer,			/* pointer to text section relocation info */
  5    50 	2 rel_def pointer,			/* pointer to definition section relocation info */
  5    51 	2 rel_link pointer,			/* pointer to linkage section relocation info */
  5    52 	2 rel_static pointer,		/* pointer to static section relocation info */
  5    53 	2 rel_symbol pointer,		/* pointer to symbol section relocation info */
  5    54 	2 text_boundary fixed bin,		/* specifies mod  of text section base boundary */
  5    55 	2 static_boundary fixed bin,		/* specifies mod of internal static base boundary */
  5    56 					/* currently not used by system */
  5    57 	2 default_truncate fixed bin,		/* offset rel to symbp for binder to automatically trunc. symb sect. */
  5    58 	2 optional_truncate fixed bin;	/* offset rel to symbp for binder to optionally trunc. symb sect. */
  5    59 
  5    60 declare	object_info_version_2 fixed bin int static init(2);
  5    61 
  5    62 /* END INCLUDE FILE ... object_info.incl.pl1 */
      164 
      165 
      166 /*  */
      167 
  6     1 /* BEGIN INCLUDE FILE object_link_dcls.incl.pl1 BIM 1981 from linkdcl */
  6     2 
  6     3 
  6     4 /****^  HISTORY COMMENTS:
  6     5*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  6     6*     audit(86-11-18,Schroth), install(86-11-20,MR12.0-1222):
  6     7*     Modified to add partial_link structure for an object MSF partially snapped
  6     8*     link.
  6     9*  2) change(86-11-13,DGHowe), approve(86-11-13,MCR7391), audit(86-11-13,Zwick),
  6    10*     install(86-11-20,MR12.0-1222):
  6    11*     Added a declaration of FAULT_TAG_1, FAULT_TAG_2 and FAULT_TAG_3.
  6    12*                                                   END HISTORY COMMENTS */
  6    13 
  6    14 
  6    15 /* format: style3 */
  6    16 /* everything you ever wanted in a linkage section */
  6    17 
  6    18 /*
  6    19* Last Modified (Date and Reason):
  6    20*  15 Nov 1971 by C Garman 
  6    21*   6/75 by M.Weaver to add virgin_linkage_header declaration
  6    22*   6/75 by S.Webber to comment existing structures better
  6    23*   9/77 by M. Weaver to add run_depth to link
  6    24*   7/81 by B. Margulies for firstref structure, unsigned fixed bins.
  6    25*   3/83 by M. Weaver to add flags overlaying def_ptr
  6    26**/
  6    27 
  6    28 declare	1 object_link	based aligned,		/* link pair in linkage section */
  6    29 	  2 header_relp	fixed bin (17) unal,	/* rel pointer to beginning of linkage, always negative */
  6    30 	  2 ringno	fixed bin (3) unsigned unal,	/* MBZ */
  6    31 	  2 mbz		bit (6) unal,
  6    32 	  2 run_depth	fixed bin (2) unal,		/* run unit depth, filled when link is snapped */
  6    33 	  2 tag		bit (6) unal,		/* fault tag. 46(8) if not snapped, 43(8) if snapped */
  6    34 	  2 expression_relp fixed bin (18) unsigned unal, /* pointer (rel to defs) of expression word */
  6    35 	  2 mbz2		bit (12) unal,
  6    36 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  6    37 
  6    38 declare	1 partial_link	based aligned,		/* partially snapped link */
  6    39 	  2 type		fixed bin (3) unsigned unal,	/* target section of link */
  6    40 	  2 component	fixed bin (15) unsigned unal,	/* target component index */
  6    41 	  2 mbz1		bit (12) unal,
  6    42 	  2 tag		bit (6) unal,		/* fault tag 3 47(8), ITS 43(8) if snapped */
  6    43 	  
  6    44 	  2 offset	fixed bin (18) unsigned unal,	/* word offset of link */
  6    45 	  2 mbz2		bit (3) unal,
  6    46 	  2 bit_offset	fixed bin (6) unsigned unal,	/* bit offset (in practice, always 0) */
  6    47 	  2 mbz3		bit (3) unal,
  6    48 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  6    49 
  6    50 declare	1 linkage_header	based aligned,		/* linkage block header */
  6    51 	  2 def_ptr	ptr,			/* pointer to definition section */
  6    52 	  2 symbol_ptr	ptr unal,			/* pointer to symbol section in object segment */
  6    53 	  2 original_linkage_ptr
  6    54 			ptr unal,			/* pointer to linkage section in object segment */
  6    55 	  2 unused	bit (72),
  6    56 	  2 stats,
  6    57 	    3 begin_links	fixed bin (18) unsigned unal, /* offset (rel to this section) of first link */
  6    58 	    3 block_length	fixed bin (18) unsigned unal, /* number of words in this linkage section */
  6    59 	    3 segment_number
  6    60 			fixed bin (18) unsigned unal, /* text segment number associated with this section */
  6    61 	    3 static_length fixed bin (18) unsigned unal; /* number of words of static for this segment */
  6    62 
  6    63 declare	1 linkage_header_flags
  6    64 			aligned based,		/* overlay of def_ptr for flags */
  6    65 	  2 pad1		bit (28) unaligned,		/* flags are in first word */
  6    66 	  2 static_vlas	bit (1) unaligned,		/* static section "owns" some LA/VLA segments */
  6    67 	  2 perprocess_static
  6    68 			bit (1) unaligned,		/* 1 copy of static section is shared among all tasks/run units */
  6    69 	  2 pad2		bit (6) unaligned;
  6    70 
  6    71 declare	1 virgin_linkage_header
  6    72 			aligned based,		/* template for linkage header in object segment */
  6    73 	  2 pad		bit (30) unaligned,		/* is filled in by linker */
  6    74 	  2 defs_in_link	bit (6) unaligned,		/* =o20 if defs in linkage (nonstandard) */
  6    75 	  2 def_offset	fixed bin (18) unsigned unaligned,
  6    76 						/* offset of definition section */
  6    77 	  2 first_ref_relp	fixed bin (18) unsigned unaligned,
  6    78 						/* offset of trap-at-first-reference offset array */
  6    79 	  2 filled_in_later bit (144),
  6    80 	  2 link_begin	fixed bin (18) unsigned unaligned,
  6    81 						/* offset of first link */
  6    82 	  2 linkage_section_lng
  6    83 			fixed bin (18) unsigned unaligned,
  6    84 						/* length of linkage section */
  6    85 	  2 segno_pad	fixed bin (18) unsigned unaligned,
  6    86 						/* will be segment number of copied linkage */
  6    87 	  2 static_length	fixed bin (18) unsigned unaligned;
  6    88 						/* length of static section */
  6    89 
  6    90 declare	1 fr_traps	based aligned,		/* First Reference Trap Procedures */
  6    91 	  2 decl_vers	fixed bin,		/* version of this struc, value=1, ABS reloc */
  6    92 	  2 n_traps	fixed bin,		/* number of traps on this segment, ABS */
  6    93 	  2 trap_array	(n_fr_traps refer (fr_traps.n_traps)) aligned,
  6    94 	    3 call_relp	fixed bin (18) unsigned unaligned,
  6    95 						/* LINK18, offset of link defining procedure to call */
  6    96 	    3 info_relp	fixed bin (18) unsigned unaligned;
  6    97 						/* LINK18, offser of link defining argument list for trap proc */
  6    98 
  6    99 declare	FR_TRAPS_VERSION_1	init (1) fixed bin internal static options (constant);
  6   100 declare   FAULT_TAG_1	bit(6) unaligned init ("40"b3) static options (constant);
  6   101 declare   FAULT_TAG_2	bit(6) unaligned init ("46"b3) static options (constant);
  6   102 declare   FAULT_TAG_3	bit(6) unaligned init ("47"b3) static options (constant);
  6   103 
  6   104 /* END INCLUDE FILE object_link_dcls.incl.pl1 */
      168 
      169 
      170 /*  */
      171 
  7     1 /* BEGIN INCLUDE SEGMENT ... symbol_block.incl.pl1
  7     2*coded February 8, 1972 by Michael J. Spier	*/
  7     3 
  7     4 /* last modified may 3, 1972  by M. Weaver */
  7     5 
  7     6 declare	1 sb aligned based(sblkp),		/* structure describing a standard symbol block */
  7     7 	2 decl_vers fixed bin,		/* version number of current structure format */
  7     8 	2 identifier char(8) aligned,		/* symbolic code to define purpose of this symb block */
  7     9 	2 gen_version_number fixed bin,	/* positive integer designating version of object generator */
  7    10 	2 gen_creation_time fixed bin(71),	/* clock reading of date/time generator was created */
  7    11 	2 obj_creation_time fixed bin(71),	/* clock reading of date/time object was generated */
  7    12 	2 generator char(8) aligned,		/* name of processor which generated segment */
  7    13 	2 gen_name_offset bit(18) unaligned,	/* offset of generator name in words rel to base of symbol block */
  7    14 	2 gen_name_length bit(18) unaligned,	/* length of printable generator version name in characters */
  7    15 	2 uid_offset bit(18) unaligned,	/* offset of creator id in words rel to base of symbol block */
  7    16 	2 uid_length bit(18) unaligned,	/* length of standard Multics id of object creator in characters */
  7    17 	2 comment_offset bit(18) unaligned,	/* offset of comment in words relative to base of symbol block */
  7    18 	2 comment_length bit(18) unaligned,	/* length of printable generator comment in characters */
  7    19 	2 tbound bit(18) unaligned,		/* specifies mod of text section base boundary */
  7    20 	2 stat_bound bit(18) unaligned,	/* specifies mod of internal static base boundary */
  7    21 	2 source_map bit(18) unaligned,	/* offset relative to base of symbol block of source map structure */
  7    22 	2 area_ptr bit(18) unaligned,		/* offset of block info in words relative to base of symbol block */
  7    23 	2 symb_base bit(18) unaligned,	/* back pointer (rel to base of symb block) to base of symb section */
  7    24 	2 block_size bit(18) unaligned,	/* size in words of entire symbol block */
  7    25 	2 next_block bit(18) unaligned,	/* if ^= "0"b, is thread (rel to base of symb section) to next symb block */
  7    26 	2 rel_text bit(18) unaligned,		/* offset rel to base of symbol block of text sect relocation info */
  7    27 	2 rel_def bit(18) unaligned,		/* offset rel to base of symb block of def section relocation info */
  7    28 	2 rel_link bit(18) unaligned,		/* offset rel to base of symb block of link sect relocation info */
  7    29 	2 rel_symb bit(18) unaligned,		/* offset rel to base of symb block of symb sect relocation info */
  7    30 	2 default_truncate bit(18) unaligned,	/* offset RTBOSB for binder to automatically trunc. symb sect. */
  7    31 	2 optional_truncate bit(18) unaligned;	/* offset RTBOSB for binder to optionally truncate symb section */
  7    32 
  7    33 /* END INCLUDE SEGMENT ... symbol_block.incl.pl1 */
      172 
      173 
      174 
  8     1 dcl	1 pl1_symbol_block	aligned based,
  8     2 	2 version		fixed bin,
  8     3 	2 identifier	char(8),		/* must be "pl1info" */
  8     4 	2 flags,
  8     5 	  3 profile	bit(1) unal,
  8     6 	  3 table		bit(1) unal,
  8     7 	  3 map		bit(1) unal,
  8     8 	  3 flow		bit(1) unal,
  8     9 	  3 io		bit(1) unal,
  8    10 	  3 table_removed	bit(1) unal,
  8    11 	  3 long_profile	bit(1) unal,
  8    12 	  3 pad		bit(29) unal,
  8    13 	2 greatest_severity	fixed bin,
  8    14 	2 root		unal bit(18),
  8    15 	2 profile		unal bit(18),
  8    16 	2 map		unal,
  8    17 	  3 first		bit(18),
  8    18 	  3 last		bit(18),
  8    19 	2 segname		unaligned,
  8    20 	  3 offset	bit(18),
  8    21 	  3 size		bit(18);
      175 
      176 
      177 
      178 declare	1 firstref_block	aligned based,
      179 	  2 version	fixed bin,
      180 	  2 n_traps	fixed bin,
      181 	  2 traps		(0 refer (firstref_block.n_traps), 2) bit (18) unaligned;
      182 
      183 declare	1 lh		aligned based (oi.linkp),
      184 	  2 defseg	fixed bin,		/* 0->defs in text, 16->defs in link  */
      185 	  2 defptr	bit (18) unaligned,		/* offset of definition section */
      186 	  2 first_reference bit (18) unaligned,		/* offset of first ref trap array */
      187 	  2 fthread	pointer,			/* unused */
      188 	  2 bthread	pointer,			/* unused */
      189 	  2 link_begin	bit (18) unaligned,		/* offset in linkage section of linkage info */
      190 	  2 block_lng	bit (18) unaligned,
      191 	  2 dum2		bit (18) unaligned,
      192 	  2 linkage_lng	bit (18) unaligned;
      193 
      194 
      195 
      196 /*  */
      197 
      198 	ctep = compent_ptr;				/* copy pointer to component table entry */
      199 	sntp = bx_$sntp;				/* pointer to segname table */
      200 	oip = addr (oi);				/* initialize */
      201 
      202 	oi.version_number = object_info_version_2;
      203 	call object_info_$long (comp.ctxtp, comp.cbitcount, addr (oi), code);
      204 	if code ^= 0
      205 	then do;					/* bad object segment */
      206 faterr:
      207 	     call com_err_ (code, errname, comp.filename);
      208 	     bx_$fatal_error = 1;
      209 	     return;
      210 	end;
      211 
      212 	if ^oi.format.standard
      213 	then do;
      214 	     code = error_table_$bad_segment;		/* don't process non-standard new objects */
      215 	     go to faterr;				/* this is fatal */
      216 	end;
      217 
      218 	if oi.bmapp ^= null
      219 	then do;					/* also a no-no */
      220 	     call com_err_ (0, errname, "Component ^a has a break map.", comp.filename);
      221 	     bx_$fatal_error = 1;
      222 	     return;
      223 	end;
      224 
      225 	if ^oi.format.relocatable
      226 	then do;
      227 	     if oi.compiler = "binder  "
      228 	     then type_string = "bound";
      229 	     else type_string = "";
      230 	     call com_err_ (0, errname, "Component ^a is a nonrelocatable ^a segment.", comp.filename, type_string);
      231 	     bx_$fatal_error = 1;
      232 	     return;				/*  don't generate all those name  conflict messages  */
      233 	end;
      234 
      235 /* find the number of links to determine the size of the linke_regeneration table */
      236 /* and allocate it.							  */
      237 
      238 	if oi.linkp -> virgin_linkage_header.defs_in_link = "010000"b
      239 	then link_end = oi.linkp -> virgin_linkage_header.def_offset;
      240 	else link_end = oi.linkp -> virgin_linkage_header.linkage_section_lng;
      241 
      242 	if oi.linkp -> virgin_linkage_header.first_ref_relp ^= 0
      243 	then link_end = min (link_end, oi.linkp -> virgin_linkage_header.first_ref_relp);
      244 
      245 	link_start = oi.linkp -> virgin_linkage_header.link_begin;
      246 
      247 	lrt_len = (link_end - link_start) * 0.5;	/* calculate number of links */
      248 	lrt_word_count = trunc ((lrt_len + 1) * 0.5) + 2; /* calculate number of words reqd for table */
      249 	call temp_mgr_$allocate (lrt_word_count);	/* allocate the table */
      250 	lrtp, comp.clrtp = bx_$freep;
      251 	call temp_mgr_$reserve (addrel (lrtp, lrt_word_count));
      252 
      253 	lrt.count = lrt_len;			/* initialize lrt */
      254 	lrt.start_offset = link_start;
      255 	lrt.regenerated (*) = ""b;
      256 
      257 	comp.clngt, val = oi.tlng;			/* get length of pure-text section */
      258 	if addr (comp.clngt) -> rhb.odd
      259 	then comp.cpadt = 1;			/* if text length odd number, pad text with one word */
      260 	if oi.text_boundary ^= 2			/* text must sit on 4,8,16,64 boundary */
      261 	then if comp.cindex ^= 1			/* and this is not first entry */
      262 	     then do;
      263 		i = oi.text_boundary;		/* copy for convenience */
      264 		val = divide (text_relc + i - 1, i, 17, 0) * i;
      265 						/* compute new base */
      266 		i = val - text_relc;		/* get difference	*/
      267 		if i > 0
      268 		then /* there was a difference */
      269 		     do;
      270 		     p = bx_$ctp -> comp_tbl (comp.cindex - 1);
      271 						/* get previous entry */
      272 		     p -> comp.cpadt = p -> comp.cpadt + i;
      273 						/* extend previous pad */
      274 		     text_relc = val;		/* adjust new base address */
      275 		end;
      276 	     end;
      277 	comp.crelt = text_relc;			/* get relocation counter value for this text section */
      278 	i = comp.clngt + comp.cpadt;			/* compute effective length of text section */
      279 	bx_$textlng, text_relc = text_relc + i;		/* compute relocation value for next text section */
      280 
      281 	comp.cdefp = oi.defp;			/* pointer to definition section */
      282 	comp.clngd = oi.dlng;			/* length of definition section */
      283 
      284 	comp.csymp = oi.symbp;			/* pointer to symbol section */
      285 	comp.clngs = oi.slng;			/* length of symbol section */
      286 	comp.clngns = oi.default_truncate;		/* length of symbol section without relbits */
      287 	comp.clngss = oi.optional_truncate;		/* length of symbol section without relbits or table */
      288 
      289 /* if there is a symbol table and it is needed by v2pl1 io, we must make
      290*   a note of it so that we will not delete it later */
      291 	if oi.compiler = "v2pl1" | oi.compiler = "PL/I"	/* so far only compiler that can have this */
      292 	then if oi.standard				/* only std objs have the special flags */
      293 	     then if oi.symbp -> sb.area_ptr		/* there might be a symbol table */
      294 		then if addrel (oi.symbp, oi.symbp -> sb.area_ptr) -> pl1_symbol_block.flags.io
      295 		     then comp.io_table = 1;		/* table is needed by runtime io */
      296 
      297 	comp.clngi = oi.ilng;			/* length of internal static */
      298 	if addr (comp.clngi) -> rhb.odd
      299 	then comp.cpadi = 1;			/* if length of int static odd number, then pad */
      300 	if oi.static_boundary ^= 2
      301 	then /* if static must start at mod 4,8,16,64 */
      302 	     if comp.cindex ^= 1
      303 	     then /* if this is not first entry */
      304 		do;
      305 		i = oi.static_boundary;		/* copy for convenience */
      306 		val = divide (is_relc + i - 1, i, 17, 0) * i;
      307 		i = val - is_relc;			/* get difference */
      308 		if i > 0
      309 		then do;
      310 		     p = bx_$ctp -> comp_tbl (comp.cindex - 1);
      311 						/* pointer to previous entry */
      312 		     p -> comp.cpadi = p -> comp.cpadi + i;
      313 		     is_relc = is_relc + i;
      314 		end;
      315 	     end;
      316 	comp.creli = is_relc;			/* get relocation counter value for this internal static */
      317 	i = comp.clngi + comp.cpadi;			/* get effective length of static */
      318 	bx_$tintlng, is_relc = is_relc + i;
      319 	comp.clnkp = oi.linkp;			/* pointer to linkage section header */
      320 	comp.cstatp = oi.statp;
      321 	comp.separate_static = 0;			/* initialize */
      322 	if oi.ilng > 0
      323 	then do;					/* don't worry about 0 length static */
      324 	     if oi.format.separate_static
      325 	     then do;
      326 		bx_$has_sep_stat = 1;
      327 		comp.separate_static = 1;		/* this variable is needed by rebuild_object_ */
      328 	     end;
      329 	     else bx_$has_comb_stat = 1;
      330 	end;
      331 	bx_$maxlinklng = bx_$maxlinklng + oi.llng + (comp.separate_static * comp.clngi);
      332 						/*  vble used to allocate space for both  stat + link */
      333 	bx_$maxdeflng = bx_$maxdeflng + comp.clngd;	/* compute size of temporary for new linkage section */
      334 
      335 	comp.crltp = oi.rel_text;
      336 	comp.crllp = oi.rel_link;
      337 	comp.crlsp = oi.rel_symbol;			/* pointers to relocation information */
      338 
      339 	comp.standard_object = fixed (oi.format.standard, 1);
      340 						/* copy object format indicator */
      341 
      342 	dd.symbol = comp.filename;			/* put in structure for compatibility */
      343 	do i = 32 to 1 by -1 while (substr (comp.filename, i, 1) = " ");
      344 	end;
      345 	dd.symbol_lng = i;				/* fill in length too */
      346 	call update_segname_table;			/* put name in segment name table */
      347 
      348 /* scan definition section to buildup insym entry for this object segment */
      349 
      350 	insymp, comp.insymentp = bx_$freep;		/* get pointer to new area for insym entry */
      351 	if last_insym ^= null
      352 	then last_insym -> insym.thread = insymp;	/* thread insym entries together */
      353 	else bx_$isp = insymp;			/* remember beginning of insym-table */
      354 	last_insym = insymp;			/* remember pointer to current entry */
      355 	insymp -> insym.thread = null;		/* indicate this last entry */
      356 	defp, dd.next_def = oi.defp;			/* set up definition search */
      357 	def_begin = bin (rel (defp), 18);
      358 	ddp = addr (dd);				/* initialize before loop */
      359 
      360 follow_defs:					/* get offset of next def rel to defp */
      361 	def_offset = bin (rel (dd.next_def), 18) - def_begin;
      362 	if decode_definition_$full (dd.next_def, ddp, oip) = "1"b
      363 	then /* get next definition */
      364 	     do;					/* make a last null entry for type 3 links */
      365 	     insymp -> insym.n_insyms, i = insymp -> insym.n_insyms + 1;
      366 	     insymep = addr (insymp -> insym.entry (i));
      367 	     insyme.null_entry = "1"b;		/* set null entry indicator */
      368 	     goto identify_format;
      369 	end;
      370 
      371 	if dd.section = "segn"
      372 	then goto follow_defs;
      373 
      374 	insymp -> insym.n_insyms, i = insymp -> insym.n_insyms + 1;
      375 						/* get current insym-table index */
      376 	insymep = addr (insymp -> insym.entry (i));	/* and get pointer to next entry */
      377 	insyme.value = bit (bin (dd.value, 18), 18);
      378 	if dd.section = "link"
      379 	then insyme.class = "000000000000000001"b;
      380 	else if dd.section = "symb"
      381 	then insyme.class = "000000000000000010"b;
      382 	else if dd.section = "stat"
      383 	then insyme.class = "000000000000000100"b;
      384 	symbol_acc.len = dd.symbol_lng;		/* get ACC length */
      385 	symbol_acc.text = substr (dd.symbol, 1, dd.symbol_lng);
      386 	insyme.lng = symbol_lng + 1;
      387 	insyme.entrypoint = dd.flags.entrypoint;
      388 	insyme.ignore = dd.flags.ignore;		/* def is probably for unofficial entryname */
      389 	insyme.retain_flag = dd.flags.retain;
      390 	insyme.def_offset = def_offset;		/* keep track of loc so we can relocate later */
      391 	insyme.nargs = dd.n_args;
      392 	insyme.descr_ptr = dd.descr_ptr;		/* get ptr to descr ptr list */
      393 	insyme.has_descr = dd.flags.descr_sw;		/* copy switch indicating valid descriptors */
      394 	goto follow_defs;
      395 
      396 identify_format:
      397 	comp.compiler = oi.compiler;			/* get compiler name */
      398 	if comp.standard_object = 1
      399 	then do;
      400 standard_format:
      401 	     comp.format = "standard";
      402 	     if lh.first_reference
      403 	     then do;				/* have some traps to regenerate */
      404 		comp.cfrtp = addrel (oi.linkp, lh.first_reference);
      405 		if comp.cfrtp -> firstref_block.version ^= 1
      406 		then do;
      407 		     call com_err_ (error_table_$unimplemented_version, errname,
      408 			"A version ^d trap on first reference encountered.", comp.cfrtp -> firstref_block.version);
      409 		     bx_$fatal_error = 1;
      410 		end;
      411 		bx_$n_firstrefs = bx_$n_firstrefs + comp.cfrtp -> firstref_block.n_traps;
      412 	     end;
      413 	     else comp.cfrtp = null;
      414 	     if oi.format.procedure
      415 	     then bx_$bproc = 1;			/* for obj map--bound seg is part proc */
      416 	     go to block_number;			/* anything else will turn off standard flag */
      417 	end;
      418 	else do;
      419 	     call com_err_ (0, errname, "object ^a is not a standard object segment", comp.filename);
      420 	     bx_$fatal_error = 1;
      421 	end;
      422 
      423 	bx_$standard = 0;				/* at least one component is non-standard */
      424 
      425 /* find number of symbol blocks this component has */
      426 
      427 block_number:
      428 	comp.n_sym_blks = 1;			/* object has to have at least 1 */
      429 	sblkp = oi.symbp;				/* start with first block and thread */
      430 
      431 block_loop:
      432 	if sb.next_block = "0"b
      433 	then go to return;				/* no more blocks */
      434 	sblkp = addrel (oi.symbp, sb.next_block);	/* get ptr to next block */
      435 	comp.n_sym_blks = comp.n_sym_blks + 1;		/* found another one */
      436 	go to block_loop;				/* see if there are any more */
      437 
      438 return:
      439 	call temp_mgr_$reserve (addr (insymp -> insym.entry (insymp -> insym.n_insyms + 1)));
      440 						/* reserve area allocated for insym table */
      441 
      442 /* now copy text section into new bound object */
      443 
      444 	p = ptr (bx_$temp_bsegp, comp.crelt);		/* pointer to new text location */
      445 	lng = comp.clngt;
      446 	p -> textsection = oi.textp -> textsection;	/* and copy the stuff */
      447 
      448 	return;
      449 
      450 
      451 init:
      452      entry;
      453 
      454 /**********************************************************************/
      455 /*							*/
      456 /*	Name:	dissect_object_$init			*/
      457 /*	Input:	none					*/
      458 /*	Function:	initializes the static variables used by dissect	*/
      459 /*		object prior to the first invocation.  The text	*/
      460 /*		and static section relocation counters are	*/
      461 /*		cleared, and clear various external static flags	*/
      462 /*		and counters.				*/
      463 /*	Output:	none					*/
      464 /*							*/
      465 /**********************************************************************/
      466 
      467 	last_insym = null;				/* initialize INSYM thread */
      468 	text_relc, is_relc = 0;
      469 	bx_$maxlinklng = 128;			/* give it a small margin of safety */
      470 	bx_$n_firstrefs = 0;			/* so far, seen none */
      471 	bx_$bproc = 0;				/* turn on if any component is a proc */
      472 	bx_$standard = 1;				/* assume standard output; turn off if any component is not */
      473 	bx_$has_sep_stat, bx_$has_comb_stat = 0;	/* will count  only nonzero length static */
      474 	if bx_$debug = 1
      475 	then errname = "dissect_object_";
      476 	else errname = bx_$caller;
      477 	return;
      478 
      479 
      480 /*  */
      481 
      482 update_segname_table:
      483      procedure;
      484 
      485 declare	i		fixed bin;
      486 declare	sntep		ptr;
      487 declare	val		fixed bin;
      488 declare	acc_actual	char (33) aligned;
      489 declare	acc_overlay	bit (297) based (addr (acc_actual));
      490 declare	acc_str		char (val) based (addr (acc_actual));
      491 declare	01 acc		aligned based (addr (acc_actual)),
      492 	  02 len		fixed bin (9) unsigned unaligned,
      493 	  02 text		char (32 refer (acc.len)) unaligned;
      494 declare	01 snte		aligned based (sntep) like seg;
      495 
      496 	val = symbol_lng;
      497 	if symbol_lng > 32
      498 	then do;					/* not acceptable for segnames */
      499 	     call ioa_ (
      500 		"Warning: Segment name ^a^/in definitions for component ^a^/is being truncated to 32 characters.",
      501 		dd.symbol, comp.filename);
      502 	     val = 32;
      503 	end;
      504 	acc_overlay = "0"b;				/* pad ACC temporary with zeroes */
      505 	acc.len = val;
      506 	acc.text = substr (dd.symbol, 1, val);
      507 
      508 	val = val + 1;				/* adjust length to entire ACC string */
      509 	do i = 1 to snt.n_names;			/* lookup segment name table */
      510 	     sntep = addr (snt.entry (i));
      511 	     if acc_str = substr (snte.name, 1, val)
      512 	     then do;
      513 		if snte.comp = ctep
      514 		then return;			/* OK, its same component */
      515 		call com_err_ (0, errname, "Segment name ^a for component ^a^/^-already used for component ^a",
      516 		     dd.symbol, comp.filename, snte.comp -> comp.filename);
      517 		bx_$fatal_error = 1;
      518 		return;
      519 	     end;
      520 	end;
      521 	snt.n_names, i = snt.n_names + 1;
      522 	if i > snt.max_size
      523 	then do;
      524 	     call com_err_ (0, errname, "Segname table overflow; please contact maintenance");
      525 	     snt.n_names = 1;
      526 	     bx_$fatal_error = 1;
      527 	     return;
      528 	end;
      529 	sntep = addr (snt.entry (i));			/* pointer to new entry */
      530 	substr (snte.name, 1, val) = acc_str;
      531 	snte.lng = val;
      532 	snte.comp = ctep;
      533 
      534      end update_segname_table;
      535 
      536 
      537      end dissect_object_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/20/86  1145.0  dissect_object_.pl1               >special_ldd>install>MR12.0-1222>dissect_object_.pl1
146          1    07/16/86  1222.1  bindext.incl.pl1                  >ldd>include>bindext.incl.pl1
150          2    07/16/86  1222.1  comptbl.incl.pl1                  >ldd>include>comptbl.incl.pl1
154          3    07/16/86  1222.1  bndtbl.incl.pl1                   >ldd>include>bndtbl.incl.pl1
158          4    07/16/86  1222.1  insym.incl.pl1                    >ldd>include>insym.incl.pl1
164          5    08/05/77  1022.5  object_info.incl.pl1              >ldd>include>object_info.incl.pl1
168          6    11/20/86  1035.4  object_link_dcls.incl.pl1         >special_ldd>install>MR12.0-1222>object_link_dcls.incl.pl1
172          7    05/06/74  1752.6  symbol_block.incl.pl1             >ldd>include>symbol_block.incl.pl1
175          8    03/10/77  1345.4  pl1_symbol_block.incl.pl1         >ldd>include>pl1_symbol_block.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
acc                                    based           structure                level 1 dcl 491
acc_actual                      000361 automatic       char(33)                 dcl 488 set ref 504 505 506 511 530
acc_overlay                            based           bit(297)                 unaligned dcl 489 set ref 504*
acc_str                                based           char                     unaligned dcl 490 ref 511 530
addr                                                   builtin function         dcl 129 ref 200 203 203 258 298 358 366 376 384 385
                                                                                  438 438 504 505 506 510 511 529 530
addrel                                                 builtin function         dcl 129 ref 251 251 291 404 434
area_ptr                 16(18)        based           bit(18)                  level 2 packed unaligned dcl 7-6 ref 291 291
bin                                                    builtin function         dcl 129 ref 357 360 377
bit                                                    builtin function         dcl 129 ref 377
bmapp                    14     000256 automatic       pointer                  level 2 dcl 162 set ref 218
bx_$bproc                       000064 external static fixed bin(17,0)          dcl 1-67 set ref 414* 471*
bx_$caller                      000100 external static char(32)                 dcl 1-80 ref 476
bx_$ctp                         000040 external static pointer                  dcl 1-26 ref 270 310
bx_$debug                       000054 external static fixed bin(17,0)          dcl 1-59 ref 474
bx_$fatal_error                 000052 external static fixed bin(17,0)          dcl 1-49 set ref 208* 221* 231* 409* 420* 517* 526*
bx_$freep                       000042 external static pointer                  dcl 1-27 ref 250 350
bx_$has_comb_stat               000060 external static fixed bin(17,0)          dcl 1-63 set ref 329* 473*
bx_$has_sep_stat                000056 external static fixed bin(17,0)          dcl 1-62 set ref 326* 473*
bx_$isp                         000044 external static pointer                  dcl 1-28 set ref 353*
bx_$maxdeflng                   000074 external static fixed bin(18,0)          dcl 1-72 set ref 333* 333
bx_$maxlinklng                  000072 external static fixed bin(17,0)          dcl 1-71 set ref 331* 331 469*
bx_$n_firstrefs                 000050 external static fixed bin(17,0)          dcl 1-47 set ref 411* 411 470*
bx_$sntp                        000046 external static pointer                  dcl 1-42 ref 199
bx_$standard                    000062 external static fixed bin(17,0)          dcl 1-66 set ref 423* 472*
bx_$temp_bsegp                  000076 external static pointer                  dcl 1-79 ref 444
bx_$textlng                     000066 external static fixed bin(18,0)          dcl 1-68 set ref 279*
bx_$tintlng                     000070 external static fixed bin(17,0)          dcl 1-70 set ref 318*
cbitcount                60            based           fixed bin(24,0)          level 2 dcl 2-16 set ref 203*
cdefp                    16            based           pointer                  level 2 dcl 2-16 set ref 281*
cfrtp                    26            based           pointer                  level 2 dcl 2-16 set ref 404* 405 407 411 413*
cindex                   47            based           fixed bin(17,0)          level 2 dcl 2-16 ref 260 270 300 310
class                     1(18)        based           bit(18)                  level 2 packed unaligned dcl 134 set ref 378* 380*
                                                                                  382*
clngd                    63            based           fixed bin(18,0)          level 2 dcl 2-16 set ref 282* 333
clngi                    64            based           fixed bin(17,0)          level 2 dcl 2-16 set ref 297* 298 317 331
clngns                   67            based           fixed bin(18,0)          level 2 dcl 2-16 set ref 286*
clngs                    66            based           fixed bin(18,0)          level 2 dcl 2-16 set ref 285*
clngss                   70            based           fixed bin(18,0)          level 2 dcl 2-16 set ref 287*
clngt                    61            based           fixed bin(18,0)          level 2 dcl 2-16 set ref 257* 258 278 445
clnkp                    22            based           pointer                  level 2 dcl 2-16 set ref 319*
clrtp                    40            based           pointer                  level 2 dcl 2-16 set ref 250*
code                            000105 automatic       fixed bin(35,0)          dcl 96 set ref 203* 204 206* 214*
com_err_                        000024 constant        entry                    external dcl 72 ref 206 220 230 407 419 515 524
comp                     14            based           pointer                  level 2 in structure "snte" dcl 494 in procedure
                                                                                  "update_segname_table" set ref 513 515 532*
comp                                   based           structure                level 1 dcl 2-16 in procedure "dissect_object_"
comp_tbl                               based           pointer                  array dcl 2-12 ref 270 310
compent_ptr                            parameter       pointer                  dcl 63 ref 60 198
compiler                 30     000256 automatic       char(8)                  level 2 in structure "oi" dcl 162 in procedure
                                                                                  "dissect_object_" set ref 227 291 291 396
compiler                 10            based           char(8)                  level 2 in structure "comp" dcl 2-16 in procedure
                                                                                  "dissect_object_" set ref 396*
count                                  based           fixed bin(17,0)          level 2 dcl 3-84 set ref 253* 255
cpadi                    65            based           fixed bin(17,0)          level 2 dcl 2-16 set ref 298* 312* 312 317
cpadt                    62            based           fixed bin(17,0)          level 2 dcl 2-16 set ref 258* 272* 272 278
creli                    74            based           fixed bin(17,0)          level 2 dcl 2-16 set ref 316*
crelt                    73            based           fixed bin(17,0)          level 2 dcl 2-16 set ref 277* 444
crllp                    32            based           pointer                  level 2 dcl 2-16 set ref 336*
crlsp                    34            based           pointer                  level 2 dcl 2-16 set ref 337*
crltp                    30            based           pointer                  level 2 dcl 2-16 set ref 335*
cstatp                   20            based           pointer                  level 2 dcl 2-16 set ref 320*
csymp                    24            based           pointer                  level 2 dcl 2-16 set ref 284*
ctep                            000250 automatic       pointer                  dcl 2-10 set ref 198* 203 203 206 220 230 250 257
                                                                                  258 258 260 270 277 278 278 281 282 284 285 286
                                                                                  287 291 297 298 298 300 310 316 317 317 319 320
                                                                                  321 327 331 331 333 335 336 337 339 342 343 350
                                                                                  396 398 400 404 405 407 411 413 419 427 435 435
                                                                                  444 445 499 513 515 532
ctxtp                    14            based           pointer                  level 2 dcl 2-16 set ref 203*
dd                              000132 automatic       structure                level 1 dcl 107 set ref 358
ddp                             000112 automatic       pointer                  dcl 97 set ref 358* 362*
decode_definition_$full         000020 constant        entry                    external dcl 69 ref 362
def_begin                       000101 automatic       fixed bin(18,0)          dcl 94 set ref 357* 360
def_offset                1            based           fixed bin(18,0)          level 2 in structure "virgin_linkage_header" packed
                                                                                  unsigned unaligned dcl 6-71 in procedure
                                                                                  "dissect_object_" ref 238
def_offset                2            based           fixed bin(18,0)          level 2 in structure "insyme" dcl 134 in procedure
                                                                                  "dissect_object_" set ref 390*
def_offset                      000102 automatic       fixed bin(18,0)          dcl 94 in procedure "dissect_object_" set ref 360*
                                                                                  390
default_truncate         64     000256 automatic       fixed bin(17,0)          level 2 dcl 162 set ref 286
defp                            000116 automatic       pointer                  dcl 99 in procedure "dissect_object_" set ref 356*
                                                                                  357
defp                      4     000256 automatic       pointer                  level 2 in structure "oi" dcl 162 in procedure
                                                                                  "dissect_object_" set ref 281 356
defs_in_link              0(30)        based           bit(6)                   level 2 packed unaligned dcl 6-71 ref 238
descr_ptr               114     000132 automatic       pointer                  level 2 in structure "dd" dcl 107 in procedure
                                                                                  "dissect_object_" set ref 392
descr_ptr               106            based           pointer                  level 2 in structure "insyme" dcl 134 in procedure
                                                                                  "dissect_object_" set ref 392*
descr_sw                112(05) 000132 automatic       bit(1)                   level 3 packed unaligned dcl 107 set ref 393
divide                                                 builtin function         dcl 129 ref 264 306
dlng                     17     000256 automatic       fixed bin(17,0)          level 2 dcl 162 set ref 282
entry                     4            based           structure                array level 2 in structure "insym" dcl 4-12
                                                                                  in procedure "dissect_object_" set ref 366 376 438
                                                                                  438
entry                   326            based           structure                array level 2 in structure "snt" dcl 3-21
                                                                                  in procedure "dissect_object_" set ref 510 529
entrypoint              110(03)        based           bit(1)                   level 2 in structure "insyme" packed unaligned
                                                                                  dcl 134 in procedure "dissect_object_" set ref
                                                                                  387*
entrypoint              112(02) 000132 automatic       bit(1)                   level 3 in structure "dd" packed unaligned dcl 107
                                                                                  in procedure "dissect_object_" set ref 387
errname                         000014 internal static char(16)                 dcl 89 set ref 206* 220* 230* 407* 419* 474* 476*
                                                                                  515* 524*
error_table_$bad_segment        000034 external static fixed bin(35,0)          dcl 79 ref 214
error_table_$unimplemented_version
                                000036 external static fixed bin(35,0)          dcl 81 set ref 407*
filename                               based           char(32)                 level 2 dcl 2-16 set ref 206* 220* 230* 342 343 419*
                                                                                  499* 515* 515*
first_ref_relp            1(18)        based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 6-71 ref 242
                                                                                  242
first_reference           1(18)        based           bit(18)                  level 2 packed unaligned dcl 183 ref 402 404
firstref_block                         based           structure                level 1 dcl 178
fixed                                                  builtin function         dcl 129 ref 339
flags                     3            based           structure                level 2 in structure "pl1_symbol_block" dcl 8-1
                                                                                  in procedure "dissect_object_"
flags                   112     000132 automatic       structure                level 2 in structure "dd" dcl 107 in procedure
                                                                                  "dissect_object_"
format                   24     000256 automatic       structure                level 2 in structure "oi" dcl 162 in procedure
                                                                                  "dissect_object_"
format                   12            based           char(8)                  level 2 in structure "comp" dcl 2-16 in procedure
                                                                                  "dissect_object_" set ref 400*
has_descr               110(02)        based           bit(1)                   level 2 packed unaligned dcl 134 set ref 393*
i                               000100 automatic       fixed bin(17,0)          dcl 93 in procedure "dissect_object_" set ref 263*
                                                                                  264 264 264 266* 267 272 278* 279 305* 306 306 306
                                                                                  307* 308 312 313 317* 318 343* 343* 345 365* 366
                                                                                  374* 376
i                               000354 automatic       fixed bin(17,0)          dcl 485 in procedure "update_segname_table" set ref
                                                                                  509* 510* 521* 522 529
ignore                  110(06)        based           bit(1)                   level 2 in structure "insyme" packed unaligned
                                                                                  dcl 134 in procedure "dissect_object_" set ref
                                                                                  388*
ignore                  112(01) 000132 automatic       bit(1)                   level 3 in structure "dd" packed unaligned dcl 107
                                                                                  in procedure "dissect_object_" set ref 388
ilng                     21     000256 automatic       fixed bin(17,0)          level 2 dcl 162 set ref 297 322
insym                                  based           structure                level 1 dcl 4-12
insyme                                 based           structure                level 1 dcl 134
insymentp                36            based           pointer                  level 2 dcl 2-16 set ref 350*
insymep                         000122 automatic       pointer                  dcl 99 set ref 366* 367 376* 377 378 380 382 384 385
                                                                                  386 387 388 389 390 391 392 393
insymp                          000120 automatic       pointer                  dcl 99 set ref 350* 351 353 354 355 365 365 366 374
                                                                                  374 376 438 438 438 438
io                        3(04)        based           bit(1)                   level 3 packed unaligned dcl 8-1 ref 291
io_table                 54            based           fixed bin(17,0)          level 2 dcl 2-16 set ref 291*
ioa_                            000026 constant        entry                    external dcl 73 ref 499
is                                     based           structure                level 1 dcl 4-20
is_relc                         000013 internal static fixed bin(17,0)          initial dcl 87 set ref 306 307 313* 313 316 318 318*
                                                                                  468*
last_insym                      000010 internal static pointer                  initial dcl 86 set ref 351 351 354* 467*
len                                    based           fixed bin(9,0)           level 2 in structure "symbol_acc" packed unsigned
                                                                                  unaligned dcl 135 in procedure "dissect_object_"
                                                                                  set ref 384* 385
len                                    based           fixed bin(9,0)           level 2 in structure "acc" packed unsigned unaligned
                                                                                  dcl 491 in procedure "update_segname_table" set
                                                                                  ref 505* 506
lh                                     based           structure                level 1 dcl 183
link_begin                6            based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 6-71 ref 245
link_end                        000127 automatic       fixed bin(18,0)          unsigned dcl 103 set ref 238* 240* 242* 242 247
link_start                      000126 automatic       fixed bin(18,0)          unsigned dcl 102 set ref 245* 247 254
linkage_section_lng       6(18)        based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 6-71 ref 240
linkp                     6     000256 automatic       pointer                  level 2 dcl 162 set ref 238 238 240 242 242 245 319
                                                                                  402 404 404
llng                     20     000256 automatic       fixed bin(17,0)          level 2 dcl 162 set ref 331
lng                     104            based           fixed bin(17,0)          level 2 in structure "insyme" dcl 134 in procedure
                                                                                  "dissect_object_" set ref 386*
lng                      11            based           fixed bin(17,0)          level 2 in structure "snte" dcl 494 in procedure
                                                                                  "update_segname_table" set ref 531*
lng                             000104 automatic       fixed bin(18,0)          dcl 94 in procedure "dissect_object_" set ref 445*
                                                                                  446
lrt                                    based           structure                level 1 dcl 3-84
lrt_len                         000130 automatic       fixed bin(17,0)          dcl 104 set ref 247* 248 253
lrt_word_count                  000131 automatic       fixed bin(17,0)          dcl 105 set ref 248* 249* 251 251
lrtp                            000254 automatic       pointer                  dcl 3-17 set ref 250* 251 251 253 254 255
max_size                323            based           fixed bin(17,0)          level 2 dcl 3-21 ref 522
min                                                    builtin function         dcl 129 ref 242
n_args                  113     000132 automatic       fixed bin(17,0)          level 2 dcl 107 set ref 391
n_insyms                  2            based           fixed bin(17,0)          level 2 dcl 4-12 set ref 365 365* 374 374* 438 438
n_names                 324            based           fixed bin(17,0)          level 2 dcl 3-21 set ref 509 521 521* 525*
n_sym_blks               72            based           fixed bin(17,0)          level 2 dcl 2-16 set ref 427* 435* 435
n_traps                   1            based           fixed bin(17,0)          level 2 dcl 178 ref 411
name                                   based           char(33)                 level 2 dcl 494 set ref 511 530*
nargs                   105            based           fixed bin(17,0)          level 2 dcl 134 set ref 391*
next_block               20            based           bit(18)                  level 2 packed unaligned dcl 7-6 ref 431 434
next_def                        000132 automatic       pointer                  level 2 dcl 107 set ref 356* 360 362*
null                                                   builtin function         dcl 129 ref 218 351 355 413 467
null_entry              110            based           bit(1)                   level 2 packed unaligned dcl 134 set ref 367*
object_info                            based           structure                level 1 dcl 5-6
object_info_$long               000022 constant        entry                    external dcl 71 ref 203
object_info_version_2                  constant        fixed bin(17,0)          initial dcl 5-60 ref 202
odd                       0(35)        based           bit(1)                   level 2 packed unaligned dcl 138 ref 258 298
oi                              000256 automatic       structure                level 1 dcl 162 set ref 200 203 203
oip                             000114 automatic       pointer                  dcl 97 set ref 200* 362*
optional_truncate        65     000256 automatic       fixed bin(17,0)          level 2 dcl 162 set ref 287
p                               000106 automatic       pointer                  dcl 97 set ref 270* 272 272 310* 312 312 444* 446
pl1_symbol_block                       based           structure                level 1 dcl 8-1
procedure                24(03) 000256 automatic       bit(1)                   level 3 packed unaligned dcl 162 set ref 414
ptr                                                    builtin function         dcl 129 ref 444
regenerated               2            based           bit(18)                  array level 2 packed unaligned dcl 3-84 set ref 255*
rel                                                    builtin function         dcl 129 ref 357 360
rel_link                 54     000256 automatic       pointer                  level 2 dcl 162 set ref 336
rel_symbol               60     000256 automatic       pointer                  level 2 dcl 162 set ref 337
rel_text                 50     000256 automatic       pointer                  level 2 dcl 162 set ref 335
relocatable              24(02) 000256 automatic       bit(1)                   level 3 packed unaligned dcl 162 set ref 225
retain                  112(03) 000132 automatic       bit(1)                   level 3 packed unaligned dcl 107 set ref 389
retain_flag             110(04)        based           bit(1)                   level 2 packed unaligned dcl 134 set ref 389*
rhb                                    based           structure                level 1 dcl 138
rpte                                   based           structure                level 1 dcl 3-63
sb                                     based           structure                level 1 dcl 7-6
sblkp                           000110 automatic       pointer                  dcl 97 set ref 429* 431 434* 434
section                   6     000132 automatic       char(4)                  level 2 dcl 107 set ref 371 378 380 382
seg                                    based           structure                level 1 dcl 3-29
separate_static          56            based           fixed bin(17,0)          level 2 in structure "comp" dcl 2-16 in procedure
                                                                                  "dissect_object_" set ref 321* 327* 331
separate_static          24(06) 000256 automatic       bit(1)                   level 3 in structure "oi" packed unaligned dcl 162
                                                                                  in procedure "dissect_object_" set ref 324
slng                     22     000256 automatic       fixed bin(17,0)          level 2 dcl 162 set ref 285
snt                                    based           structure                level 1 dcl 3-21
snte                                   based           structure                level 1 dcl 494
sntep                           000356 automatic       pointer                  dcl 486 set ref 510* 511 513 515 529* 530 531 532
sntp                            000252 automatic       pointer                  dcl 3-17 set ref 199* 509 510 521 521 522 525 529
standard                 24(04) 000256 automatic       bit(1)                   level 3 packed unaligned dcl 162 set ref 212 291 339
standard_object          50            based           fixed bin(17,0)          level 2 dcl 2-16 set ref 339* 398
start_offset              1            based           fixed bin(18,0)          level 2 unsigned dcl 3-84 set ref 254*
static_boundary          63     000256 automatic       fixed bin(17,0)          level 2 dcl 162 set ref 300 305
statp                    10     000256 automatic       pointer                  level 2 dcl 162 set ref 320
substr                                                 builtin function         dcl 129 set ref 343 385 506 511 530*
symbol                    3            based           char(257)                level 2 in structure "insyme" dcl 134 in procedure
                                                                                  "dissect_object_" set ref 384 385
symbol                   11     000132 automatic       char(256)                level 2 in structure "dd" dcl 107 in procedure
                                                                                  "dissect_object_" set ref 342* 385 499* 506 515*
symbol_acc                             based           structure                level 1 dcl 135
symbol_lng              111     000132 automatic       fixed bin(17,0)          level 2 dcl 107 set ref 345* 384 385 386 496 497
symbp                    12     000256 automatic       pointer                  level 2 dcl 162 set ref 284 291 291 291 429 434
temp_mgr_$allocate              000030 constant        entry                    external dcl 74 ref 249
temp_mgr_$reserve               000032 constant        entry                    external dcl 75 ref 251 438
text                      0(09)        based           char                     level 2 in structure "symbol_acc" packed unaligned
                                                                                  dcl 135 in procedure "dissect_object_" set ref
                                                                                  385*
text                      0(09)        based           char                     level 2 in structure "acc" packed unaligned dcl 491
                                                                                  in procedure "update_segname_table" set ref 506*
text_boundary            62     000256 automatic       fixed bin(17,0)          level 2 dcl 162 set ref 260 263
text_relc                       000012 internal static fixed bin(17,0)          initial dcl 87 set ref 264 266 274* 277 279 279*
                                                                                  468*
textp                     2     000256 automatic       pointer                  level 2 dcl 162 set ref 446
textsection                            based           fixed bin(17,0)          array dcl 142 set ref 446* 446
thread                                 based           pointer                  level 2 dcl 4-12 set ref 351* 355*
tlng                     16     000256 automatic       fixed bin(17,0)          level 2 dcl 162 set ref 257
trunc                                                  builtin function         dcl 129 ref 248
type_string                     000124 automatic       char(5)                  dcl 101 set ref 227* 229* 230*
val                             000360 automatic       fixed bin(17,0)          dcl 487 in procedure "update_segname_table" set ref
                                                                                  496* 502* 505 506 508* 508 511 511 530 530 531
val                             000103 automatic       fixed bin(18,0)          dcl 94 in procedure "dissect_object_" set ref 257*
                                                                                  264* 266 274 306* 307
value                     7     000132 automatic       fixed bin(18,0)          level 2 in structure "dd" dcl 107 in procedure
                                                                                  "dissect_object_" set ref 377
value                     1            based           bit(18)                  level 2 in structure "insyme" packed unaligned
                                                                                  dcl 134 in procedure "dissect_object_" set ref
                                                                                  377*
version                                based           fixed bin(17,0)          level 2 dcl 178 set ref 405 407*
version_number                  000256 automatic       fixed bin(17,0)          level 2 dcl 162 set ref 202*
virgin_linkage_header                  based           structure                level 1 dcl 6-71

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
FAULT_TAG_1                            internal static bit(6)                   initial unaligned dcl 6-100
FAULT_TAG_2                            internal static bit(6)                   initial unaligned dcl 6-101
FAULT_TAG_3                            internal static bit(6)                   initial unaligned dcl 6-102
FR_TRAPS_VERSION_1                     internal static fixed bin(17,0)          initial dcl 6-99
INTERNALLY_RESOLVED                    internal static bit(18)                  initial unaligned dcl 3-91
UNRESOLVED                             internal static bit(18)                  initial unaligned dcl 3-90
adnp                                   automatic       pointer                  dcl 3-17
an                                     based           structure                level 1 dcl 3-40
bx_$addname                            external static fixed bin(17,0)          dcl 1-58
bx_$addname_limit                      external static fixed bin(17,0)          dcl 1-24
bx_$adnp                               external static pointer                  dcl 1-36
bx_$area_begin                         external static fixed bin(18,0)          dcl 1-25
bx_$bdefp                              external static pointer                  dcl 1-38
bx_$bindmap_def                        external static pointer                  dcl 1-37
bx_$blnkp                              external static pointer                  dcl 1-40
bx_$bound_segname                      external static char(32)                 dcl 1-48
bx_$bound_sep_stat                     external static fixed bin(17,0)          dcl 1-64
bx_$brief                              external static fixed bin(17,0)          dcl 1-60
bx_$bseg_acinfop                       external static pointer                  dcl 1-50
bx_$bseg_bitcount                      external static fixed bin(24,0)          dcl 1-51
bx_$bsegp                              external static pointer                  dcl 1-30
bx_$bstatp                             external static pointer                  dcl 1-39
bx_$bsymp                              external static pointer                  dcl 1-41
bx_$curdeflng                          external static fixed bin(18,0)          dcl 1-69
bx_$d_lng                              external static fixed bin(18,0)          dcl 1-54
bx_$first_rptp                         external static pointer                  dcl 1-34
bx_$force_order                        external static fixed bin(17,0)          dcl 1-61
bx_$i_lng                              external static fixed bin(17,0)          dcl 1-55
bx_$inpp                               external static pointer                  dcl 1-29
bx_$l_lng                              external static fixed bin(17,0)          dcl 1-56
bx_$last_rptp                          external static pointer                  dcl 1-35
bx_$n_lng                              external static fixed bin(17,0)          dcl 1-76
bx_$ncomp                              external static fixed bin(17,0)          dcl 1-74
bx_$nsegdefs                           external static fixed bin(17,0)          dcl 1-78
bx_$nsymdefs                           external static fixed bin(17,0)          dcl 1-77
bx_$o_lng                              external static fixed bin(19,0)          dcl 1-52
bx_$oddname_limit                      external static fixed bin(17,0)          dcl 1-22
bx_$odnp                               external static pointer                  dcl 1-33
bx_$optp                               external static pointer                  dcl 1-32
bx_$perprocess_static                  external static fixed bin(17,0)          dcl 1-65
bx_$s_lng                              external static fixed bin(18,0)          dcl 1-57
bx_$size                               external static fixed bin(17,0)          dcl 1-20
bx_$snt_limit                          external static fixed bin(17,0)          dcl 1-21
bx_$stringmap_limit                    external static fixed bin(17,0)          dcl 1-23
bx_$strmp                              external static pointer                  dcl 1-46
bx_$t_lng                              external static fixed bin(18,0)          dcl 1-53
bx_$tdefp                              external static pointer                  dcl 1-43
bx_$temp                               external static pointer                  dcl 1-31
bx_$tintp                              external static pointer                  dcl 1-44
bx_$tlinklng                           external static fixed bin(17,0)          dcl 1-73
bx_$tlinkp                             external static pointer                  dcl 1-45
bx_$v_lng                              external static fixed bin(17,0)          dcl 1-75
bx_$vers_name                          external static char(168)                dcl 1-18
bx_$vers_number                        external static fixed bin(17,0)          dcl 1-19
ctp                                    automatic       pointer                  dcl 2-10
fr_traps                               based           structure                level 1 dcl 6-90
linkage_header                         based           structure                level 1 dcl 6-50
linkage_header_flags                   based           structure                level 1 dcl 6-63
object_link                            based           structure                level 1 dcl 6-28
od                                     based           structure                level 1 dcl 3-48
odnp                                   automatic       pointer                  dcl 3-17
partial_link                           based           structure                level 1 dcl 6-38
rpt                                    based           structure                level 1 dcl 3-57
rptep                                  automatic       pointer                  dcl 3-17
rptp                                   automatic       pointer                  dcl 3-17
strm                                   based           structure                level 1 dcl 3-73
strmp                                  automatic       pointer                  dcl 3-17

NAMES DECLARED BY EXPLICIT CONTEXT.
block_loop                      001362 constant        label                    dcl 431 ref 436
block_number                    001355 constant        label                    dcl 427 ref 416
dissect_object_                 000212 constant        entry                    external dcl 60
faterr                          000253 constant        label                    dcl 206 ref 215
follow_defs                     001053 constant        label                    dcl 360 ref 371 394
identify_format                 001221 constant        label                    dcl 396 ref 368
init                            001431 constant        entry                    external dcl 451
return                          001375 constant        label                    dcl 438 ref 431
standard_format                 001230 constant        label                    dcl 400
update_segname_table            001472 constant        entry                    internal dcl 482 ref 346

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2204        2306    1714        2214
Length      2712    1714       102         370     267          10

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
dissect_object_                     384 external procedure  is an external procedure.  
update_segname_table                    internal procedure  shares stack frame of external procedure dissect_object_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 last_insym                  dissect_object_
000012 text_relc                   dissect_object_
000013 is_relc                     dissect_object_
000014 errname                     dissect_object_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
dissect_object_          000100 i                           dissect_object_
                         000101 def_begin                   dissect_object_
                         000102 def_offset                  dissect_object_
                         000103 val                         dissect_object_
                         000104 lng                         dissect_object_
                         000105 code                        dissect_object_
                         000106 p                           dissect_object_
                         000110 sblkp                       dissect_object_
                         000112 ddp                         dissect_object_
                         000114 oip                         dissect_object_
                         000116 defp                        dissect_object_
                         000120 insymp                      dissect_object_
                         000122 insymep                     dissect_object_
                         000124 type_string                 dissect_object_
                         000126 link_start                  dissect_object_
                         000127 link_end                    dissect_object_
                         000130 lrt_len                     dissect_object_
                         000131 lrt_word_count              dissect_object_
                         000132 dd                          dissect_object_
                         000250 ctep                        dissect_object_
                         000252 sntp                        dissect_object_
                         000254 lrtp                        dissect_object_
                         000256 oi                          dissect_object_
                         000354 i                           update_segname_table
                         000356 sntep                       update_segname_table
                         000360 val                         update_segname_table
                         000361 acc_actual                  update_segname_table

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry           trunc_fx1

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      decode_definition_$full       ioa_                          object_info_$long
temp_mgr_$allocate            temp_mgr_$reserve

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
bx_$bproc                     bx_$caller                    bx_$ctp                       bx_$debug
bx_$fatal_error               bx_$freep                     bx_$has_comb_stat             bx_$has_sep_stat
bx_$isp                       bx_$maxdeflng                 bx_$maxlinklng                bx_$n_firstrefs
bx_$sntp                      bx_$standard                  bx_$temp_bsegp                bx_$textlng
bx_$tintlng                   error_table_$bad_segment      error_table_$unimplemented_version


CONSTANTS
000000  aa     524000000062

000001  aa     524000000101

000002  aa     524000000400

000003  aa     524000000137

000004  aa     524000000052

000005  aa     404000000021

000006  aa     524000000061

000007  aa  163 164 141 164	stat

000010  aa  163 171 155 142	symb

000011  aa  154 151 156 153	link

000012  aa  163 145 147 156	segn

001713  aa  040 000 000 000	 

000013  aa  120 114 057 111	PL/I

000014  aa     524000000005

000015  aa     524000000054

000016  aa     524000000035

000017  aa     404000000005

000020  aa     524000000040

000021  aa     524000000020

000022  aa     404000000043

000023  aa     514000000001

000024  aa     464000000000

000026  aa  163 164 141 156	stan
000027  aa  144 141 162 144	dard

000030  aa  166 062 160 154	v2pl
000031  aa  061 000 000 000	1

000032  aa  040 040 040 040	    
000033  aa  040 000 000 000	 

000034  aa  142 157 165 156	boun
000035  aa  144 000 000 000	d

000036  aa  142 151 156 144	bind
000037  aa  145 162 040 040	er  

000040  aa     077777000043
000041  aa     000001000000

000042  aa  144 151 163 163	diss
000043  aa  145 143 164 137	ect_
000044  aa  157 142 152 145	obje
000045  aa  143 164 137 000	ct_

000046  aa  103 157 155 160	Comp
000047  aa  157 156 145 156	onen
000050  aa  164 040 136 141	t ^a
000051  aa  040 150 141 163	 has
000052  aa  040 141 040 142	 a b
000053  aa  162 145 141 153	reak
000054  aa  040 155 141 160	 map
000055  aa  056 000 000 000	.

000056  aa  157 142 152 145	obje
000057  aa  143 164 040 136	ct ^
000060  aa  141 040 151 163	a is
000061  aa  040 156 157 164	 not
000062  aa  040 141 040 163	 a s
000063  aa  164 141 156 144	tand
000064  aa  141 162 144 040	ard 
000065  aa  157 142 152 145	obje
000066  aa  143 164 040 163	ct s
000067  aa  145 147 155 145	egme
000070  aa  156 164 000 000	nt

000071  aa  103 157 155 160	Comp
000072  aa  157 156 145 156	onen
000073  aa  164 040 136 141	t ^a
000074  aa  040 151 163 040	 is 
000075  aa  141 040 156 157	a no
000076  aa  156 162 145 154	nrel
000077  aa  157 143 141 164	ocat
000100  aa  141 142 154 145	able
000101  aa  040 136 141 040	 ^a 
000102  aa  163 145 147 155	segm
000103  aa  145 156 164 056	ent.

000104  aa  123 145 147 156	Segn
000105  aa  141 155 145 040	ame 
000106  aa  164 141 142 154	tabl
000107  aa  145 040 157 166	e ov
000110  aa  145 162 146 154	erfl
000111  aa  157 167 073 040	ow; 
000112  aa  160 154 145 141	plea
000113  aa  163 145 040 143	se c
000114  aa  157 156 164 141	onta
000115  aa  143 164 040 155	ct m
000116  aa  141 151 156 164	aint
000117  aa  145 156 141 156	enan
000120  aa  143 145 000 000	ce

000121  aa  101 040 166 145	A ve
000122  aa  162 163 151 157	rsio
000123  aa  156 040 136 144	n ^d
000124  aa  040 164 162 141	 tra
000125  aa  160 040 157 156	p on
000126  aa  040 146 151 162	 fir
000127  aa  163 164 040 162	st r
000130  aa  145 146 145 162	efer
000131  aa  145 156 143 145	ence
000132  aa  040 145 156 143	 enc
000133  aa  157 165 156 164	ount
000134  aa  145 162 145 144	ered
000135  aa  056 000 000 000	.

000136  aa  123 145 147 155	Segm
000137  aa  145 156 164 040	ent 
000140  aa  156 141 155 145	name
000141  aa  040 136 141 040	 ^a 
000142  aa  146 157 162 040	for 
000143  aa  143 157 155 160	comp
000144  aa  157 156 145 156	onen
000145  aa  164 040 136 141	t ^a
000146  aa  136 057 136 055	^/^-
000147  aa  141 154 162 145	alre
000150  aa  141 144 171 040	ady 
000151  aa  165 163 145 144	used
000152  aa  040 146 157 162	 for
000153  aa  040 143 157 155	 com
000154  aa  160 157 156 145	pone
000155  aa  156 164 040 136	nt ^
000156  aa  141 000 000 000	a

000157  aa  127 141 162 156	Warn
000160  aa  151 156 147 072	ing:
000161  aa  040 123 145 147	 Seg
000162  aa  155 145 156 164	ment
000163  aa  040 156 141 155	 nam
000164  aa  145 040 136 141	e ^a
000165  aa  136 057 151 156	^/in
000166  aa  040 144 145 146	 def
000167  aa  151 156 151 164	init
000170  aa  151 157 156 163	ions
000171  aa  040 146 157 162	 for
000172  aa  040 143 157 155	 com
000173  aa  160 157 156 145	pone
000174  aa  156 164 040 136	nt ^
000175  aa  141 136 057 151	a^/i
000176  aa  163 040 142 145	s be
000177  aa  151 156 147 040	ing 
000200  aa  164 162 165 156	trun
000201  aa  143 141 164 145	cate
000202  aa  144 040 164 157	d to
000203  aa  040 063 062 040	 32 
000204  aa  143 150 141 162	char
000205  aa  141 143 164 145	acte
000206  aa  162 163 056 000	rs.

BEGIN PROCEDURE dissect_object_
ENTRY TO dissect_object_                                    STATEMENT 1 ON LINE 60
dissect_object_:
     procedure (compent_ptr);

000207  at     000001000024
000210  ta     000207000000
000211  da     000256300000
000212  aa   000600 6270 00	eax7 	384
000213  aa  7 00034 3521 20	epp2 	pr7|28,*
000214  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000215  aa     000002000000
000216  aa     000000000000
						STATEMENT 1 ON LINE 198
	ctep = compent_ptr;

000217  aa  6 00032 3735 20	epp7 	pr6|26,*
000220  aa  7 00002 3715 20	epp5 	pr7|2,*		compent_ptr
000221  aa  5 00000 3715 20	epp5 	pr5|0,*		compent_ptr
000222  aa  6 00250 6515 00	spri5	pr6|168		ctep
						STATEMENT 1 ON LINE 199
	sntp = bx_$sntp;

000223  la  4 00046 3535 20	epp3 	pr4|38,*		bx_$sntp
000224  aa  3 00000 3535 20	epp3 	pr3|0,*		bx_$sntp
000225  aa  6 00252 2535 00	spri3	pr6|170		sntp
						STATEMENT 1 ON LINE 200
	oip = addr (oi);

000226  aa  6 00256 3515 00	epp1 	pr6|174		oi
000227  aa  6 00114 2515 00	spri1	pr6|76		oip
						STATEMENT 1 ON LINE 202
	oi.version_number = object_info_version_2;

000230  aa   000002 2360 07	ldq  	2,dl
000231  aa  6 00256 7561 00	stq  	pr6|174		oi.version_number
						STATEMENT 1 ON LINE 203
	call object_info_$long (comp.ctxtp, comp.cbitcount, addr (oi), code);

000232  aa  6 00256 3715 00	epp5 	pr6|174		oi
000233  aa  6 00374 6515 00	spri5	pr6|252
000234  aa  6 00250 3535 20	epp3 	pr6|168,*		ctep
000235  aa  3 00014 3521 00	epp2 	pr3|12		comp.ctxtp
000236  aa  6 00400 2521 00	spri2	pr6|256
000237  aa  3 00060 3521 00	epp2 	pr3|48		comp.cbitcount
000240  aa  6 00402 2521 00	spri2	pr6|258
000241  aa  6 00374 3521 00	epp2 	pr6|252
000242  aa  6 00404 2521 00	spri2	pr6|260
000243  aa  6 00105 3521 00	epp2 	pr6|69		code
000244  aa  6 00406 2521 00	spri2	pr6|262
000245  aa  6 00376 6211 00	eax1 	pr6|254
000246  aa   020000 4310 07	fld  	8192,dl
000247  la  4 00022 3521 20	epp2 	pr4|18,*		object_info_$long
000250  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 204
	if code ^= 0
	then do;

000251  aa  6 00105 2361 00	ldq  	pr6|69		code
000252  aa   000026 6000 04	tze  	22,ic		000300
						STATEMENT 1 ON LINE 206
faterr:
	     call com_err_ (code, errname, comp.filename);

000253  aa  6 00105 3521 00	epp2 	pr6|69		code
000254  aa  6 00412 2521 00	spri2	pr6|266
000255  aa  6 00044 3701 20	epp4 	pr6|36,*
000256  ia  4 00014 3521 00	epp2 	pr4|12		errname
000257  aa  6 00414 2521 00	spri2	pr6|268
000260  aa  6 00250 3521 20	epp2 	pr6|168,*		comp.filename
000261  aa  6 00416 2521 00	spri2	pr6|270
000262  aa   777540 3520 04	epp2 	-160,ic		000022 = 404000000043
000263  aa  6 00420 2521 00	spri2	pr6|272
000264  aa   777535 3520 04	epp2 	-163,ic		000021 = 524000000020
000265  aa  6 00422 2521 00	spri2	pr6|274
000266  aa   777532 3520 04	epp2 	-166,ic		000020 = 524000000040
000267  aa  6 00424 2521 00	spri2	pr6|276
000270  aa  6 00410 6211 00	eax1 	pr6|264
000271  aa   014000 4310 07	fld  	6144,dl
000272  la  4 00024 3521 20	epp2 	pr4|20,*		com_err_
000273  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 208
	     bx_$fatal_error = 1;

000274  aa   000001 2360 07	ldq  	1,dl
000275  aa  6 00044 3701 20	epp4 	pr6|36,*
000276  la  4 00052 7561 20	stq  	pr4|42,*		bx_$fatal_error
						STATEMENT 1 ON LINE 209
	     return;

000277  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 210
	end;

						STATEMENT 1 ON LINE 212
	if ^oi.format.standard
	then do;

000300  aa  6 00302 2351 00	lda  	pr6|194		oi.standard
000301  aa   020000 3150 03	cana 	8192,du
000302  aa   000005 6010 04	tnz  	5,ic		000307
						STATEMENT 1 ON LINE 214
	     code = error_table_$bad_segment;

000303  aa  6 00044 3701 20	epp4 	pr6|36,*
000304  la  4 00034 2361 20	ldq  	pr4|28,*		error_table_$bad_segment
000305  aa  6 00105 7561 00	stq  	pr6|69		code
						STATEMENT 1 ON LINE 215
	     go to faterr;

000306  aa   777745 7100 04	tra  	-27,ic		000253
						STATEMENT 1 ON LINE 216
	end;

						STATEMENT 1 ON LINE 218
	if oi.bmapp ^= null
	then do;

000307  aa  6 00272 2371 00	ldaq 	pr6|186		oi.bmapp
000310  aa   777530 6770 04	eraq 	-168,ic		000040 = 077777000043 000001000000
000311  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000312  aa   000036 6000 04	tze  	30,ic		000350
						STATEMENT 1 ON LINE 220
	     call com_err_ (0, errname, "Component ^a has a break map.", comp.filename);

000313  aa  6 00373 4501 00	stz  	pr6|251
000314  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000315  aa   777532 00 0040	desc9a	-166,32		000046 = 103157155160
000316  aa  6 00376 00 0040	desc9a	pr6|254,32
000317  aa  6 00373 3521 00	epp2 	pr6|251
000320  aa  6 00430 2521 00	spri2	pr6|280
000321  aa  6 00044 3701 20	epp4 	pr6|36,*
000322  ia  4 00014 3521 00	epp2 	pr4|12		errname
000323  aa  6 00432 2521 00	spri2	pr6|282
000324  aa  6 00376 3521 00	epp2 	pr6|254
000325  aa  6 00434 2521 00	spri2	pr6|284
000326  aa  6 00250 3521 20	epp2 	pr6|168,*		comp.filename
000327  aa  6 00436 2521 00	spri2	pr6|286
000330  aa   777467 3520 04	epp2 	-201,ic		000017 = 404000000005
000331  aa  6 00440 2521 00	spri2	pr6|288
000332  aa   777467 3520 04	epp2 	-201,ic		000021 = 524000000020
000333  aa  6 00442 2521 00	spri2	pr6|290
000334  aa   777462 3520 04	epp2 	-206,ic		000016 = 524000000035
000335  aa  6 00444 2521 00	spri2	pr6|292
000336  aa   777462 3520 04	epp2 	-206,ic		000020 = 524000000040
000337  aa  6 00446 2521 00	spri2	pr6|294
000340  aa  6 00426 6211 00	eax1 	pr6|278
000341  aa   020000 4310 07	fld  	8192,dl
000342  la  4 00024 3521 20	epp2 	pr4|20,*		com_err_
000343  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 221
	     bx_$fatal_error = 1;

000344  aa   000001 2360 07	ldq  	1,dl
000345  aa  6 00044 3701 20	epp4 	pr6|36,*
000346  la  4 00052 7561 20	stq  	pr4|42,*		bx_$fatal_error
						STATEMENT 1 ON LINE 222
	     return;

000347  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 223
	end;

						STATEMENT 1 ON LINE 225
	if ^oi.format.relocatable
	then do;

000350  aa  6 00302 2351 00	lda  	pr6|194		oi.relocatable
000351  aa   100000 3150 03	cana 	32768,du
000352  aa   000052 6010 04	tnz  	42,ic		000424
						STATEMENT 1 ON LINE 227
	     if oi.compiler = "binder  "
	     then type_string = "bound";

000353  aa  6 00306 2371 00	ldaq 	pr6|198		oi.compiler
000354  aa   777462 1170 04	cmpaq	-206,ic		000036 = 142151156144 145162040040
000355  aa   000004 6010 04	tnz  	4,ic		000361
000356  aa   777456 2370 04	ldaq 	-210,ic		000034 = 142157165156 144000000000
000357  aa  6 00124 7571 00	staq 	pr6|84		type_string
000360  aa   000003 7100 04	tra  	3,ic		000363
						STATEMENT 1 ON LINE 229
	     else type_string = "";

000361  aa   777451 2370 04	ldaq 	-215,ic		000032 = 040040040040 040000000000
000362  aa  6 00124 7571 00	staq 	pr6|84		type_string
						STATEMENT 1 ON LINE 230
	     call com_err_ (0, errname, "Component ^a is a nonrelocatable ^a segment.", comp.filename, type_string);

000363  aa  6 00373 4501 00	stz  	pr6|251
000364  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000365  aa   777505 00 0054	desc9a	-187,44		000071 = 103157155160
000366  aa  6 00410 00 0054	desc9a	pr6|264,44
000367  aa  6 00373 3521 00	epp2 	pr6|251
000370  aa  6 00452 2521 00	spri2	pr6|298
000371  aa  6 00044 3701 20	epp4 	pr6|36,*
000372  ia  4 00014 3521 00	epp2 	pr4|12		errname
000373  aa  6 00454 2521 00	spri2	pr6|300
000374  aa  6 00410 3521 00	epp2 	pr6|264
000375  aa  6 00456 2521 00	spri2	pr6|302
000376  aa  6 00250 3521 20	epp2 	pr6|168,*		comp.filename
000377  aa  6 00460 2521 00	spri2	pr6|304
000400  aa  6 00124 3521 00	epp2 	pr6|84		type_string
000401  aa  6 00462 2521 00	spri2	pr6|306
000402  aa   777415 3520 04	epp2 	-243,ic		000017 = 404000000005
000403  aa  6 00464 2521 00	spri2	pr6|308
000404  aa   777415 3520 04	epp2 	-243,ic		000021 = 524000000020
000405  aa  6 00466 2521 00	spri2	pr6|310
000406  aa   777407 3520 04	epp2 	-249,ic		000015 = 524000000054
000407  aa  6 00470 2521 00	spri2	pr6|312
000410  aa   777410 3520 04	epp2 	-248,ic		000020 = 524000000040
000411  aa  6 00472 2521 00	spri2	pr6|314
000412  aa   777402 3520 04	epp2 	-254,ic		000014 = 524000000005
000413  aa  6 00474 2521 00	spri2	pr6|316
000414  aa  6 00450 6211 00	eax1 	pr6|296
000415  aa   024000 4310 07	fld  	10240,dl
000416  la  4 00024 3521 20	epp2 	pr4|20,*		com_err_
000417  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 231
	     bx_$fatal_error = 1;

000420  aa   000001 2360 07	ldq  	1,dl
000421  aa  6 00044 3701 20	epp4 	pr6|36,*
000422  la  4 00052 7561 20	stq  	pr4|42,*		bx_$fatal_error
						STATEMENT 1 ON LINE 232
	     return;

000423  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 233
	end;

						STATEMENT 1 ON LINE 238
	if oi.linkp -> virgin_linkage_header.defs_in_link = "010000"b
	then link_end = oi.linkp -> virgin_linkage_header.def_offset;

000424  aa  6 00264 2351 20	lda  	pr6|180,*		virgin_linkage_header.defs_in_link
000425  aa   000036 7350 00	als  	30
000426  aa   200000 1150 03	cmpa 	65536,du
000427  aa   000006 6010 04	tnz  	6,ic		000435
000430  aa  6 00264 3735 20	epp7 	pr6|180,*		oi.linkp
000431  aa  7 00001 2351 00	lda  	pr7|1		virgin_linkage_header.def_offset
000432  aa   000066 7730 00	lrl  	54
000433  aa  6 00127 7561 00	stq  	pr6|87		link_end
000434  aa   000005 7100 04	tra  	5,ic		000441
						STATEMENT 1 ON LINE 240
	else link_end = oi.linkp -> virgin_linkage_header.linkage_section_lng;

000435  aa  6 00264 3735 20	epp7 	pr6|180,*		oi.linkp
000436  aa  7 00006 2361 00	ldq  	pr7|6		virgin_linkage_header.linkage_section_lng
000437  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
000440  aa  6 00127 7561 00	stq  	pr6|87		link_end
						STATEMENT 1 ON LINE 242
	if oi.linkp -> virgin_linkage_header.first_ref_relp ^= 0
	then link_end = min (link_end, oi.linkp -> virgin_linkage_header.first_ref_relp);

000441  aa  7 00001 2361 00	ldq  	pr7|1		virgin_linkage_header.first_ref_relp
000442  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
000443  aa  6 00373 7561 00	stq  	pr6|251		virgin_linkage_header.first_ref_relp
000444  aa   000005 6000 04	tze  	5,ic		000451
000445  aa  6 00127 1161 00	cmpq 	pr6|87		link_end
000446  aa   000002 6040 04	tmi  	2,ic		000450
000447  aa  6 00127 2361 00	ldq  	pr6|87		link_end
000450  aa  6 00127 7561 00	stq  	pr6|87		link_end
						STATEMENT 1 ON LINE 245
	link_start = oi.linkp -> virgin_linkage_header.link_begin;

000451  aa  7 00006 2351 00	lda  	pr7|6		virgin_linkage_header.link_begin
000452  aa   000066 7730 00	lrl  	54
000453  aa  6 00126 7561 00	stq  	pr6|86		link_start
						STATEMENT 1 ON LINE 247
	lrt_len = (link_end - link_start) * 0.5;

000454  aa  6 00127 2361 00	ldq  	pr6|87		link_end
000455  aa  6 00126 1761 00	sbq  	pr6|86		link_start
000456  aa   000003 7360 00	qls  	3
000457  aa   000004 7220 07	lxl2 	4,dl
000460  aa  0 01114 7001 00	tsx0 	pr0|588		trunc_fx1
000461  aa  6 00130 7561 00	stq  	pr6|88		lrt_len
						STATEMENT 1 ON LINE 248
	lrt_word_count = trunc ((lrt_len + 1) * 0.5) + 2;

000462  aa   000001 0760 07	adq  	1,dl
000463  aa   000003 7360 00	qls  	3
000464  aa  0 01114 7001 00	tsx0 	pr0|588		trunc_fx1
000465  aa   000002 0760 07	adq  	2,dl
000466  aa  6 00131 7561 00	stq  	pr6|89		lrt_word_count
						STATEMENT 1 ON LINE 249
	call temp_mgr_$allocate (lrt_word_count);

000467  aa  6 00131 3521 00	epp2 	pr6|89		lrt_word_count
000470  aa  6 00400 2521 00	spri2	pr6|256
000471  aa  6 00376 6211 00	eax1 	pr6|254
000472  aa   004000 4310 07	fld  	2048,dl
000473  aa  6 00044 3701 20	epp4 	pr6|36,*
000474  la  4 00030 3521 20	epp2 	pr4|24,*		temp_mgr_$allocate
000475  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 250
	lrtp, comp.clrtp = bx_$freep;

000476  aa  6 00044 3701 20	epp4 	pr6|36,*
000477  la  4 00042 3735 20	epp7 	pr4|34,*		bx_$freep
000500  aa  7 00000 3735 20	epp7 	pr7|0,*		bx_$freep
000501  aa  6 00254 6535 00	spri7	pr6|172		lrtp
000502  aa  6 00250 3715 20	epp5 	pr6|168,*		ctep
000503  aa  5 00040 6535 00	spri7	pr5|32		comp.clrtp
						STATEMENT 1 ON LINE 251
	call temp_mgr_$reserve (addrel (lrtp, lrt_word_count));

000504  aa  6 00131 2361 00	ldq  	pr6|89		lrt_word_count
000505  aa  6 00254 3521 66	epp2 	pr6|172,*ql	lrtp
000506  aa   000000 0520 03	adwp2	0,du
000507  aa  6 00374 2521 00	spri2	pr6|252
000510  aa  6 00374 3521 00	epp2 	pr6|252
000511  aa  6 00400 2521 00	spri2	pr6|256
000512  aa  6 00376 6211 00	eax1 	pr6|254
000513  aa   004000 4310 07	fld  	2048,dl
000514  la  4 00032 3521 20	epp2 	pr4|26,*		temp_mgr_$reserve
000515  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 253
	lrt.count = lrt_len;

000516  aa  6 00130 2361 00	ldq  	pr6|88		lrt_len
000517  aa  6 00254 7561 20	stq  	pr6|172,*		lrt.count
						STATEMENT 1 ON LINE 254
	lrt.start_offset = link_start;

000520  aa  6 00126 2361 00	ldq  	pr6|86		link_start
000521  aa  6 00254 3735 20	epp7 	pr6|172,*		lrtp
000522  aa  7 00001 7561 00	stq  	pr7|1		lrt.start_offset
						STATEMENT 1 ON LINE 255
	lrt.regenerated (*) = ""b;

000523  aa   000001 2360 07	ldq  	1,dl
000524  aa  6 00344 7561 00	stq  	pr6|228
000525  aa   000000 0110 03	nop  	0,du
000526  aa  6 00344 2361 00	ldq  	pr6|228
000527  aa   000022 4020 07	mpy  	18,dl
000530  aa  6 00254 3735 20	epp7 	pr6|172,*		lrtp
000531  aa  003 106 060 400	csl  	(),(pr,ql),fill(0),bool(move)
000532  aa   000000 00 0000	descb	0,0
000533  aa  7 00001 40 0022	descb	pr7|1(18),18	lrt.regenerated
000534  aa  6 00344 2361 00	ldq  	pr6|228
000535  aa  6 00344 0541 00	aos  	pr6|228
000536  aa  7 00000 1161 00	cmpq 	pr7|0		lrt.count
000537  aa   777767 6040 04	tmi  	-9,ic		000526
						STATEMENT 1 ON LINE 257
	comp.clngt, val = oi.tlng;

000540  aa  6 00274 2361 00	ldq  	pr6|188		oi.tlng
000541  aa  6 00250 3715 20	epp5 	pr6|168,*		ctep
000542  aa  5 00061 7561 00	stq  	pr5|49		comp.clngt
000543  aa  6 00103 7561 00	stq  	pr6|67		val
						STATEMENT 1 ON LINE 258
	if addr (comp.clngt) -> rhb.odd
	then comp.cpadt = 1;

000544  aa  5 00061 2351 00	lda  	pr5|49		rhb.odd
000545  aa   000001 3150 07	cana 	1,dl
000546  aa   000003 6000 04	tze  	3,ic		000551
000547  aa   000001 2360 07	ldq  	1,dl
000550  aa  5 00062 7561 00	stq  	pr5|50		comp.cpadt
						STATEMENT 1 ON LINE 260
	if oi.text_boundary ^= 2			/* text must sit on 4,8,16,64 boundary */
	then if comp.cindex ^= 1			/* and this is not first entry */
	     then do;

000551  aa  6 00340 2361 00	ldq  	pr6|224		oi.text_boundary
000552  aa   000002 1160 07	cmpq 	2,dl
000553  aa   000031 6000 04	tze  	25,ic		000604
000554  aa  5 00047 2361 00	ldq  	pr5|39		comp.cindex
000555  aa   000001 1160 07	cmpq 	1,dl
000556  aa   000026 6000 04	tze  	22,ic		000604
						STATEMENT 1 ON LINE 263
		i = oi.text_boundary;

000557  aa  6 00340 2361 00	ldq  	pr6|224		oi.text_boundary
000560  aa  6 00100 7561 00	stq  	pr6|64		i
						STATEMENT 1 ON LINE 264
		val = divide (text_relc + i - 1, i, 17, 0) * i;

000561  aa  6 00044 3701 20	epp4 	pr6|36,*
000562  ia  4 00012 0761 00	adq  	pr4|10		text_relc
000563  aa   000001 1760 07	sbq  	1,dl
000564  aa  6 00100 5061 00	div  	pr6|64		i
000565  aa  6 00100 4021 00	mpy  	pr6|64		i
000566  aa  6 00103 7561 00	stq  	pr6|67		val
						STATEMENT 1 ON LINE 266
		i = val - text_relc;

000567  ia  4 00012 1761 00	sbq  	pr4|10		text_relc
000570  aa  6 00100 7561 00	stq  	pr6|64		i
						STATEMENT 1 ON LINE 267
		if i > 0
		then /* there was a difference */
		     do;

000571  aa   000013 6044 04	tmoz 	11,ic		000604
						STATEMENT 1 ON LINE 270
		     p = bx_$ctp -> comp_tbl (comp.cindex - 1);

000572  aa  5 00047 2361 00	ldq  	pr5|39		comp.cindex
000573  aa   000001 7360 00	qls  	1
000574  la  4 00040 3535 20	epp3 	pr4|32,*		bx_$ctp
000575  aa  3 00000 3535 20	epp3 	pr3|0,*		bx_$ctp
000576  aa  3 77774 3535 26	epp3 	pr3|-4,ql*	comp_tbl
000577  aa  6 00106 2535 00	spri3	pr6|70		p
						STATEMENT 1 ON LINE 272
		     p -> comp.cpadt = p -> comp.cpadt + i;

000600  aa  6 00100 2361 00	ldq  	pr6|64		i
000601  aa  3 00062 0561 00	asq  	pr3|50		comp.cpadt
						STATEMENT 1 ON LINE 274
		     text_relc = val;

000602  aa  6 00103 2361 00	ldq  	pr6|67		val
000603  ia  4 00012 7561 00	stq  	pr4|10		text_relc
						STATEMENT 1 ON LINE 275
		end;

						STATEMENT 1 ON LINE 276
	     end;

						STATEMENT 1 ON LINE 277
	comp.crelt = text_relc;

000604  aa  6 00044 3701 20	epp4 	pr6|36,*
000605  ia  4 00012 2361 00	ldq  	pr4|10		text_relc
000606  aa  5 00073 7561 00	stq  	pr5|59		comp.crelt
						STATEMENT 1 ON LINE 278
	i = comp.clngt + comp.cpadt;

000607  aa  5 00061 2361 00	ldq  	pr5|49		comp.clngt
000610  aa  5 00062 0761 00	adq  	pr5|50		comp.cpadt
000611  aa  6 00100 7561 00	stq  	pr6|64		i
						STATEMENT 1 ON LINE 279
	bx_$textlng, text_relc = text_relc + i;

000612  ia  4 00012 0761 00	adq  	pr4|10		text_relc
000613  la  4 00066 7561 20	stq  	pr4|54,*		bx_$textlng
000614  ia  4 00012 7561 00	stq  	pr4|10		text_relc
						STATEMENT 1 ON LINE 281
	comp.cdefp = oi.defp;

000615  aa  6 00262 3535 20	epp3 	pr6|178,*		oi.defp
000616  aa  5 00016 2535 00	spri3	pr5|14		comp.cdefp
						STATEMENT 1 ON LINE 282
	comp.clngd = oi.dlng;

000617  aa  6 00275 2361 00	ldq  	pr6|189		oi.dlng
000620  aa  5 00063 7561 00	stq  	pr5|51		comp.clngd
						STATEMENT 1 ON LINE 284
	comp.csymp = oi.symbp;

000621  aa  6 00270 3535 20	epp3 	pr6|184,*		oi.symbp
000622  aa  5 00024 2535 00	spri3	pr5|20		comp.csymp
						STATEMENT 1 ON LINE 285
	comp.clngs = oi.slng;

000623  aa  6 00300 2361 00	ldq  	pr6|192		oi.slng
000624  aa  5 00066 7561 00	stq  	pr5|54		comp.clngs
						STATEMENT 1 ON LINE 286
	comp.clngns = oi.default_truncate;

000625  aa  6 00342 2361 00	ldq  	pr6|226		oi.default_truncate
000626  aa  5 00067 7561 00	stq  	pr5|55		comp.clngns
						STATEMENT 1 ON LINE 287
	comp.clngss = oi.optional_truncate;

000627  aa  6 00343 2361 00	ldq  	pr6|227		oi.optional_truncate
000630  aa  5 00070 7561 00	stq  	pr5|56		comp.clngss
						STATEMENT 1 ON LINE 291
	if oi.compiler = "v2pl1" | oi.compiler = "PL/I"	/* so far only compiler that can have this */
	then if oi.standard				/* only std objs have the special flags */
	     then if oi.symbp -> sb.area_ptr		/* there might be a symbol table */
		then if addrel (oi.symbp, oi.symbp -> sb.area_ptr) -> pl1_symbol_block.flags.io
		     then comp.io_table = 1;

000631  aa   777177 2370 04	ldaq 	-385,ic		000030 = 166062160154 061000000000
000632  aa  0 00452 2771 00	oraq 	pr0|298		= 000000000000 000040040040
000633  aa  6 00306 1171 00	cmpaq	pr6|198		oi.compiler
000634  aa   000006 6000 04	tze  	6,ic		000642
000635  aa   777156 2350 04	lda  	-402,ic		000013 = 120114057111
000636  aa  0 00110 3771 00	anaq 	pr0|72		= 777777777777 000000000000
000637  aa  0 00450 2771 00	oraq 	pr0|296		= 000000000000 040040040040
000640  aa  6 00306 1171 00	cmpaq	pr6|198		oi.compiler
000641  aa   000020 6010 04	tnz  	16,ic		000661
000642  aa  6 00302 2351 00	lda  	pr6|194		oi.standard
000643  aa   020000 3150 03	cana 	8192,du
000644  aa   000015 6000 04	tze  	13,ic		000661
000645  aa  6 00270 3535 20	epp3 	pr6|184,*		oi.symbp
000646  aa  3 00016 2351 00	lda  	pr3|14		sb.area_ptr
000647  aa   000022 7350 00	als  	18
000650  aa  6 00373 7551 00	sta  	pr6|251		sb.area_ptr
000651  aa   000010 6000 04	tze  	8,ic		000661
000652  aa  3 00000 3521 01	epp2 	pr3|0,au
000653  aa   000000 0520 03	adwp2	0,du
000654  aa  2 00003 2351 00	lda  	pr2|3		pl1_symbol_block.io
000655  aa   020000 3150 03	cana 	8192,du
000656  aa   000003 6000 04	tze  	3,ic		000661
000657  aa   000001 2360 07	ldq  	1,dl
000660  aa  5 00054 7561 00	stq  	pr5|44		comp.io_table
						STATEMENT 1 ON LINE 297
	comp.clngi = oi.ilng;

000661  aa  6 00277 2361 00	ldq  	pr6|191		oi.ilng
000662  aa  5 00064 7561 00	stq  	pr5|52		comp.clngi
						STATEMENT 1 ON LINE 298
	if addr (comp.clngi) -> rhb.odd
	then comp.cpadi = 1;

000663  aa  5 00064 2351 00	lda  	pr5|52		rhb.odd
000664  aa   000001 3150 07	cana 	1,dl
000665  aa   000003 6000 04	tze  	3,ic		000670
000666  aa   000001 2360 07	ldq  	1,dl
000667  aa  5 00065 7561 00	stq  	pr5|53		comp.cpadi
						STATEMENT 1 ON LINE 300
	if oi.static_boundary ^= 2
	then /* if static must start at mod 4,8,16,64 */
	     if comp.cindex ^= 1
	     then /* if this is not first entry */
		do;

000670  aa  6 00341 2361 00	ldq  	pr6|225		oi.static_boundary
000671  aa   000002 1160 07	cmpq 	2,dl
000672  aa   000027 6000 04	tze  	23,ic		000721
000673  aa  5 00047 2361 00	ldq  	pr5|39		comp.cindex
000674  aa   000001 1160 07	cmpq 	1,dl
000675  aa   000024 6000 04	tze  	20,ic		000721
						STATEMENT 1 ON LINE 305
		i = oi.static_boundary;

000676  aa  6 00341 2361 00	ldq  	pr6|225		oi.static_boundary
000677  aa  6 00100 7561 00	stq  	pr6|64		i
						STATEMENT 1 ON LINE 306
		val = divide (is_relc + i - 1, i, 17, 0) * i;

000700  ia  4 00013 0761 00	adq  	pr4|11		is_relc
000701  aa   000001 1760 07	sbq  	1,dl
000702  aa  6 00100 5061 00	div  	pr6|64		i
000703  aa  6 00100 4021 00	mpy  	pr6|64		i
000704  aa  6 00103 7561 00	stq  	pr6|67		val
						STATEMENT 1 ON LINE 307
		i = val - is_relc;

000705  ia  4 00013 1761 00	sbq  	pr4|11		is_relc
000706  aa  6 00100 7561 00	stq  	pr6|64		i
						STATEMENT 1 ON LINE 308
		if i > 0
		then do;

000707  aa   000012 6044 04	tmoz 	10,ic		000721
						STATEMENT 1 ON LINE 310
		     p = bx_$ctp -> comp_tbl (comp.cindex - 1);

000710  aa  5 00047 2361 00	ldq  	pr5|39		comp.cindex
000711  aa   000001 7360 00	qls  	1
000712  la  4 00040 3535 20	epp3 	pr4|32,*		bx_$ctp
000713  aa  3 00000 3535 20	epp3 	pr3|0,*		bx_$ctp
000714  aa  3 77774 3535 26	epp3 	pr3|-4,ql*	comp_tbl
000715  aa  6 00106 2535 00	spri3	pr6|70		p
						STATEMENT 1 ON LINE 312
		     p -> comp.cpadi = p -> comp.cpadi + i;

000716  aa  6 00100 2361 00	ldq  	pr6|64		i
000717  aa  3 00065 0561 00	asq  	pr3|53		comp.cpadi
						STATEMENT 1 ON LINE 313
		     is_relc = is_relc + i;

000720  ia  4 00013 0561 00	asq  	pr4|11		is_relc
						STATEMENT 1 ON LINE 314
		end;

						STATEMENT 1 ON LINE 315
	     end;

						STATEMENT 1 ON LINE 316
	comp.creli = is_relc;

000721  ia  4 00013 2361 00	ldq  	pr4|11		is_relc
000722  aa  5 00074 7561 00	stq  	pr5|60		comp.creli
						STATEMENT 1 ON LINE 317
	i = comp.clngi + comp.cpadi;

000723  aa  5 00064 2361 00	ldq  	pr5|52		comp.clngi
000724  aa  5 00065 0761 00	adq  	pr5|53		comp.cpadi
000725  aa  6 00100 7561 00	stq  	pr6|64		i
						STATEMENT 1 ON LINE 318
	bx_$tintlng, is_relc = is_relc + i;

000726  ia  4 00013 0761 00	adq  	pr4|11		is_relc
000727  la  4 00070 7561 20	stq  	pr4|56,*		bx_$tintlng
000730  ia  4 00013 7561 00	stq  	pr4|11		is_relc
						STATEMENT 1 ON LINE 319
	comp.clnkp = oi.linkp;

000731  aa  6 00264 3535 20	epp3 	pr6|180,*		oi.linkp
000732  aa  5 00022 2535 00	spri3	pr5|18		comp.clnkp
						STATEMENT 1 ON LINE 320
	comp.cstatp = oi.statp;

000733  aa  6 00266 3535 20	epp3 	pr6|182,*		oi.statp
000734  aa  5 00020 2535 00	spri3	pr5|16		comp.cstatp
						STATEMENT 1 ON LINE 321
	comp.separate_static = 0;

000735  aa  5 00056 4501 00	stz  	pr5|46		comp.separate_static
						STATEMENT 1 ON LINE 322
	if oi.ilng > 0
	then do;

000736  aa  6 00277 2361 00	ldq  	pr6|191		oi.ilng
000737  aa   000012 6044 04	tmoz 	10,ic		000751
						STATEMENT 1 ON LINE 324
	     if oi.format.separate_static
	     then do;

000740  aa  6 00302 2351 00	lda  	pr6|194		oi.separate_static
000741  aa   004000 3150 03	cana 	2048,du
000742  aa   000005 6000 04	tze  	5,ic		000747
						STATEMENT 1 ON LINE 326
		bx_$has_sep_stat = 1;

000743  aa   000001 2360 07	ldq  	1,dl
000744  la  4 00056 7561 20	stq  	pr4|46,*		bx_$has_sep_stat
						STATEMENT 1 ON LINE 327
		comp.separate_static = 1;

000745  aa  5 00056 7561 00	stq  	pr5|46		comp.separate_static
						STATEMENT 1 ON LINE 328
	     end;

000746  aa   000003 7100 04	tra  	3,ic		000751
						STATEMENT 1 ON LINE 329
	     else bx_$has_comb_stat = 1;

000747  aa   000001 2360 07	ldq  	1,dl
000750  la  4 00060 7561 20	stq  	pr4|48,*		bx_$has_comb_stat
						STATEMENT 1 ON LINE 330
	end;

						STATEMENT 1 ON LINE 331
	bx_$maxlinklng = bx_$maxlinklng + oi.llng + (comp.separate_static * comp.clngi);

000751  aa  5 00056 2361 00	ldq  	pr5|46		comp.separate_static
000752  aa  5 00064 4021 00	mpy  	pr5|52		comp.clngi
000753  aa  6 00373 7561 00	stq  	pr6|251
000754  la  4 00072 2361 20	ldq  	pr4|58,*		bx_$maxlinklng
000755  aa  6 00276 0761 00	adq  	pr6|190		oi.llng
000756  aa   000044 7770 00	llr  	36
000757  aa   000044 7330 00	lrs  	36
000760  aa  6 00373 0331 00	adl  	pr6|251
000761  la  4 00072 7561 20	stq  	pr4|58,*		bx_$maxlinklng
						STATEMENT 1 ON LINE 333
	bx_$maxdeflng = bx_$maxdeflng + comp.clngd;

000762  aa  5 00063 2361 00	ldq  	pr5|51		comp.clngd
000763  la  4 00074 0561 20	asq  	pr4|60,*		bx_$maxdeflng
						STATEMENT 1 ON LINE 335
	comp.crltp = oi.rel_text;

000764  aa  6 00326 3535 20	epp3 	pr6|214,*		oi.rel_text
000765  aa  5 00030 2535 00	spri3	pr5|24		comp.crltp
						STATEMENT 1 ON LINE 336
	comp.crllp = oi.rel_link;

000766  aa  6 00332 3535 20	epp3 	pr6|218,*		oi.rel_link
000767  aa  5 00032 2535 00	spri3	pr5|26		comp.crllp
						STATEMENT 1 ON LINE 337
	comp.crlsp = oi.rel_symbol;

000770  aa  6 00336 3535 20	epp3 	pr6|222,*		oi.rel_symbol
000771  aa  5 00034 2535 00	spri3	pr5|28		comp.crlsp
						STATEMENT 1 ON LINE 339
	comp.standard_object = fixed (oi.format.standard, 1);

000772  aa  6 00302 2351 00	lda  	pr6|194		oi.standard
000773  aa   000004 7350 00	als  	4
000774  aa   000107 7730 00	lrl  	71
000775  aa  5 00050 7561 00	stq  	pr5|40		comp.standard_object
						STATEMENT 1 ON LINE 342
	dd.symbol = comp.filename;

000776  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
000777  aa  5 00000 00 0040	desc9a	pr5|0,32		comp.filename
001000  aa  6 00143 00 0400	desc9a	pr6|99,256	dd.symbol
						STATEMENT 1 ON LINE 343
	do i = 32 to 1 by -1 while (substr (comp.filename, i, 1) = " ");

001001  aa   000040 2360 07	ldq  	32,dl
001002  aa  6 00100 7561 00	stq  	pr6|64		i
001003  aa   000000 0110 03	nop  	0,du
001004  aa  6 00100 2361 00	ldq  	pr6|64		i
001005  aa   000001 1160 07	cmpq 	1,dl
001006  aa   000011 6040 04	tmi  	9,ic		001017
001007  aa  6 00250 3735 20	epp7 	pr6|168,*		ctep
001010  aa  040 004 106 506	cmpc 	(pr,ql),(ic),fill(040)
001011  aa  7 77777 60 0001	desc9a	pr7|-1(3),1	comp.filename
001012  aa   000703 00 0001	desc9a	451,1		001713 = 040000000000
001013  aa   000004 6010 04	tnz  	4,ic		001017
						STATEMENT 1 ON LINE 344
	end;

001014  aa   000001 3360 07	lcq  	1,dl
001015  aa  6 00100 0561 00	asq  	pr6|64		i
001016  aa   777766 7100 04	tra  	-10,ic		001004
						STATEMENT 1 ON LINE 345
	dd.symbol_lng = i;

001017  aa  6 00243 7561 00	stq  	pr6|163		dd.symbol_lng
						STATEMENT 1 ON LINE 346
	call update_segname_table;

001020  aa   000452 6700 04	tsp4 	298,ic		001472
						STATEMENT 1 ON LINE 350
	insymp, comp.insymentp = bx_$freep;

001021  aa  6 00044 3701 20	epp4 	pr6|36,*
001022  la  4 00042 3735 20	epp7 	pr4|34,*		bx_$freep
001023  aa  7 00000 3735 20	epp7 	pr7|0,*		bx_$freep
001024  aa  6 00120 6535 00	spri7	pr6|80		insymp
001025  aa  6 00250 3715 20	epp5 	pr6|168,*		ctep
001026  aa  5 00036 6535 00	spri7	pr5|30		comp.insymentp
						STATEMENT 1 ON LINE 351
	if last_insym ^= null
	then last_insym -> insym.thread = insymp;

001027  ia  4 00010 2371 00	ldaq 	pr4|8		last_insym
001030  aa   777010 6770 04	eraq 	-504,ic		000040 = 077777000043 000001000000
001031  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001032  aa   000004 6000 04	tze  	4,ic		001036
001033  aa  6 00120 3535 20	epp3 	pr6|80,*		insymp
001034  ia  4 00010 2535 20	spri3	pr4|8,*		insym.thread
001035  aa   000003 7100 04	tra  	3,ic		001040
						STATEMENT 1 ON LINE 353
	else bx_$isp = insymp;

001036  aa  6 00120 3535 20	epp3 	pr6|80,*		insymp
001037  la  4 00044 2535 20	spri3	pr4|36,*		bx_$isp
						STATEMENT 1 ON LINE 354
	last_insym = insymp;

001040  ia  4 00010 2535 00	spri3	pr4|8		last_insym
						STATEMENT 1 ON LINE 355
	insymp -> insym.thread = null;

001041  aa   776777 2370 04	ldaq 	-513,ic		000040 = 077777000043 000001000000
001042  aa  3 00000 7571 00	staq 	pr3|0		insym.thread
						STATEMENT 1 ON LINE 356
	defp, dd.next_def = oi.defp;

001043  aa  6 00262 3515 20	epp1 	pr6|178,*		oi.defp
001044  aa  6 00116 2515 00	spri1	pr6|78		defp
001045  aa  6 00132 2515 00	spri1	pr6|90		dd.next_def
						STATEMENT 1 ON LINE 357
	def_begin = bin (rel (defp), 18);

001046  aa  6 00116 6351 20	eaa  	pr6|78,*		defp
001047  aa   000066 7730 00	lrl  	54
001050  aa  6 00101 7561 00	stq  	pr6|65		def_begin
						STATEMENT 1 ON LINE 358
	ddp = addr (dd);

001051  aa  6 00132 3735 00	epp7 	pr6|90		dd
001052  aa  6 00112 6535 00	spri7	pr6|74		ddp
						STATEMENT 1 ON LINE 360
follow_defs:					/* get offset of next def rel to defp */
	def_offset = bin (rel (dd.next_def), 18) - def_begin;

001053  aa  6 00132 6351 20	eaa  	pr6|90,*		dd.next_def
001054  aa   000066 7730 00	lrl  	54
001055  aa  6 00101 1761 00	sbq  	pr6|65		def_begin
001056  aa  6 00102 7561 00	stq  	pr6|66		def_offset
						STATEMENT 1 ON LINE 362
	if decode_definition_$full (dd.next_def, ddp, oip) = "1"b
	then /* get next definition */
	     do;

001057  aa  6 00132 3521 00	epp2 	pr6|90		dd.next_def
001060  aa  6 00400 2521 00	spri2	pr6|256
001061  aa  6 00112 3521 00	epp2 	pr6|74		ddp
001062  aa  6 00402 2521 00	spri2	pr6|258
001063  aa  6 00114 3521 00	epp2 	pr6|76		oip
001064  aa  6 00404 2521 00	spri2	pr6|260
001065  aa  6 00373 3521 00	epp2 	pr6|251
001066  aa  6 00406 2521 00	spri2	pr6|262
001067  aa  6 00376 6211 00	eax1 	pr6|254
001070  aa   020000 4310 07	fld  	8192,dl
001071  aa  6 00044 3701 20	epp4 	pr6|36,*
001072  la  4 00020 3521 20	epp2 	pr4|16,*		decode_definition_$full
001073  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
001074  aa  6 00373 2351 00	lda  	pr6|251
001075  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
001076  aa   400000 1150 03	cmpa 	131072,du
001077  aa   000014 6010 04	tnz  	12,ic		001113
						STATEMENT 1 ON LINE 365
	     insymp -> insym.n_insyms, i = insymp -> insym.n_insyms + 1;

001100  aa  6 00120 3735 20	epp7 	pr6|80,*		insymp
001101  aa  7 00002 2361 00	ldq  	pr7|2		insym.n_insyms
001102  aa   000001 0760 07	adq  	1,dl
001103  aa  7 00002 7561 00	stq  	pr7|2		insym.n_insyms
001104  aa  6 00100 7561 00	stq  	pr6|64		i
						STATEMENT 1 ON LINE 366
	     insymep = addr (insymp -> insym.entry (i));

001105  aa   000112 4020 07	mpy  	74,dl
001106  aa  7 77672 3715 06	epp5 	pr7|-70,ql	insym.entry
001107  aa  6 00122 6515 00	spri5	pr6|82		insymep
						STATEMENT 1 ON LINE 367
	     insyme.null_entry = "1"b;

001110  aa   400000 2350 03	lda  	131072,du
001111  aa  5 00110 2551 00	orsa 	pr5|72		insyme.null_entry
						STATEMENT 1 ON LINE 368
	     goto identify_format;

001112  aa   000107 7100 04	tra  	71,ic		001221
						STATEMENT 1 ON LINE 369
	end;

						STATEMENT 1 ON LINE 371
	if dd.section = "segn"
	then goto follow_defs;

001113  aa  6 00140 2351 00	lda  	pr6|96		dd.section
001114  aa   776676 1150 04	cmpa 	-578,ic		000012 = 163145147156
001115  aa   777736 6000 04	tze  	-34,ic		001053
						STATEMENT 1 ON LINE 374
	insymp -> insym.n_insyms, i = insymp -> insym.n_insyms + 1;

001116  aa  6 00120 3735 20	epp7 	pr6|80,*		insymp
001117  aa  7 00002 2361 00	ldq  	pr7|2		insym.n_insyms
001120  aa   000001 0760 07	adq  	1,dl
001121  aa  7 00002 7561 00	stq  	pr7|2		insym.n_insyms
001122  aa  6 00100 7561 00	stq  	pr6|64		i
						STATEMENT 1 ON LINE 376
	insymep = addr (insymp -> insym.entry (i));

001123  aa   000112 4020 07	mpy  	74,dl
001124  aa  7 77672 3715 06	epp5 	pr7|-70,ql	insym.entry
001125  aa  6 00122 6515 00	spri5	pr6|82		insymep
						STATEMENT 1 ON LINE 377
	insyme.value = bit (bin (dd.value, 18), 18);

001126  aa  6 00141 2351 00	lda  	pr6|97		dd.value
001127  aa   000002 6050 04	tpl  	2,ic		001131
001130  aa   000000 5310 00	neg  	0
001131  aa   000022 7350 00	als  	18
001132  aa  5 00001 5511 60	stba 	pr5|1,60		insyme.value
						STATEMENT 1 ON LINE 378
	if dd.section = "link"
	then insyme.class = "000000000000000001"b;

001133  aa  6 00140 2351 00	lda  	pr6|96		dd.section
001134  aa   776655 1150 04	cmpa 	-595,ic		000011 = 154151156153
001135  aa   000004 6010 04	tnz  	4,ic		001141
001136  aa   000001 2350 07	lda  	1,dl
001137  aa  5 00001 5511 14	stba 	pr5|1,14		insyme.class
001140  aa   000012 7100 04	tra  	10,ic		001152
						STATEMENT 1 ON LINE 380
	else if dd.section = "symb"
	then insyme.class = "000000000000000010"b;

001141  aa   776647 1150 04	cmpa 	-601,ic		000010 = 163171155142
001142  aa   000004 6010 04	tnz  	4,ic		001146
001143  aa   000002 2350 07	lda  	2,dl
001144  aa  5 00001 5511 14	stba 	pr5|1,14		insyme.class
001145  aa   000005 7100 04	tra  	5,ic		001152
						STATEMENT 1 ON LINE 382
	else if dd.section = "stat"
	then insyme.class = "000000000000000100"b;

001146  aa   776641 1150 04	cmpa 	-607,ic		000007 = 163164141164
001147  aa   000003 6010 04	tnz  	3,ic		001152
001150  aa   000004 2350 07	lda  	4,dl
001151  aa  5 00001 5511 14	stba 	pr5|1,14		insyme.class
						STATEMENT 1 ON LINE 384
	symbol_acc.len = dd.symbol_lng;

001152  aa  6 00243 2361 00	ldq  	pr6|163		dd.symbol_lng
001153  aa   000077 7370 00	lls  	63
001154  aa  5 00003 5511 40	stba 	pr5|3,40		symbol_acc.len
						STATEMENT 1 ON LINE 385
	symbol_acc.text = substr (dd.symbol, 1, dd.symbol_lng);

001155  aa  5 00003 2351 00	lda  	pr5|3		symbol_acc.len
001156  aa   000077 7730 00	lrl  	63
001157  aa  6 00243 7271 00	lxl7 	pr6|163		dd.symbol_lng
001160  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
001161  aa  6 00143 00 0017	desc9a	pr6|99,x7		dd.symbol
001162  aa  5 00003 20 0006	desc9a	pr5|3(1),ql	symbol_acc.text
						STATEMENT 1 ON LINE 386
	insyme.lng = symbol_lng + 1;

001163  aa  6 00243 2361 00	ldq  	pr6|163		dd.symbol_lng
001164  aa   000001 0760 07	adq  	1,dl
001165  aa  5 00104 7561 00	stq  	pr5|68		insyme.lng
						STATEMENT 1 ON LINE 387
	insyme.entrypoint = dd.flags.entrypoint;

001166  aa  6 00244 2351 00	lda  	pr6|164		dd.entrypoint
001167  aa   000001 7710 00	arl  	1
001170  aa  5 00110 6751 00	era  	pr5|72		insyme.entrypoint
001171  aa   040000 3750 03	ana  	16384,du
001172  aa  5 00110 6551 00	ersa 	pr5|72		insyme.entrypoint
						STATEMENT 1 ON LINE 388
	insyme.ignore = dd.flags.ignore;

001173  aa  6 00244 2351 00	lda  	pr6|164		dd.ignore
001174  aa   000005 7710 00	arl  	5
001175  aa  5 00110 6751 00	era  	pr5|72		insyme.ignore
001176  aa   004000 3750 03	ana  	2048,du
001177  aa  5 00110 6551 00	ersa 	pr5|72		insyme.ignore
						STATEMENT 1 ON LINE 389
	insyme.retain_flag = dd.flags.retain;

001200  aa  6 00244 2351 00	lda  	pr6|164		dd.retain
001201  aa   000001 7710 00	arl  	1
001202  aa  5 00110 6751 00	era  	pr5|72		insyme.retain_flag
001203  aa   020000 3750 03	ana  	8192,du
001204  aa  5 00110 6551 00	ersa 	pr5|72		insyme.retain_flag
						STATEMENT 1 ON LINE 390
	insyme.def_offset = def_offset;

001205  aa  6 00102 2361 00	ldq  	pr6|66		def_offset
001206  aa  5 00002 7561 00	stq  	pr5|2		insyme.def_offset
						STATEMENT 1 ON LINE 391
	insyme.nargs = dd.n_args;

001207  aa  6 00245 2361 00	ldq  	pr6|165		dd.n_args
001210  aa  5 00105 7561 00	stq  	pr5|69		insyme.nargs
						STATEMENT 1 ON LINE 392
	insyme.descr_ptr = dd.descr_ptr;

001211  aa  6 00246 3535 20	epp3 	pr6|166,*		dd.descr_ptr
001212  aa  5 00106 2535 00	spri3	pr5|70		insyme.descr_ptr
						STATEMENT 1 ON LINE 393
	insyme.has_descr = dd.flags.descr_sw;

001213  aa  6 00244 2351 00	lda  	pr6|164		dd.descr_sw
001214  aa   000003 7350 00	als  	3
001215  aa  5 00110 6751 00	era  	pr5|72		insyme.has_descr
001216  aa   100000 3750 03	ana  	32768,du
001217  aa  5 00110 6551 00	ersa 	pr5|72		insyme.has_descr
						STATEMENT 1 ON LINE 394
	goto follow_defs;

001220  aa   777633 7100 04	tra  	-101,ic		001053
						STATEMENT 1 ON LINE 396
identify_format:
	comp.compiler = oi.compiler;

001221  aa  6 00306 2371 00	ldaq 	pr6|198		oi.compiler
001222  aa  6 00250 3535 20	epp3 	pr6|168,*		ctep
001223  aa  3 00010 7551 00	sta  	pr3|8		comp.compiler
001224  aa  3 00011 7561 00	stq  	pr3|9		comp.compiler
						STATEMENT 1 ON LINE 398
	if comp.standard_object = 1
	then do;

001225  aa  3 00050 2361 00	ldq  	pr3|40		comp.standard_object
001226  aa   000001 1160 07	cmpq 	1,dl
001227  aa   000071 6010 04	tnz  	57,ic		001320
						STATEMENT 1 ON LINE 400
standard_format:
	     comp.format = "standard";

001230  aa   776576 2370 04	ldaq 	-642,ic		000026 = 163164141156 144141162144
001231  aa  3 00012 7551 00	sta  	pr3|10		comp.format
001232  aa  3 00013 7561 00	stq  	pr3|11		comp.format
						STATEMENT 1 ON LINE 402
	     if lh.first_reference
	     then do;

001233  aa  6 00264 3515 20	epp1 	pr6|180,*		oi.linkp
001234  aa  1 00001 2351 00	lda  	pr1|1		lh.first_reference
001235  aa   000022 7350 00	als  	18
001236  aa  6 00373 7551 00	sta  	pr6|251		lh.first_reference
001237  aa   000050 6000 04	tze  	40,ic		001307
						STATEMENT 1 ON LINE 404
		comp.cfrtp = addrel (oi.linkp, lh.first_reference);

001240  aa  1 00000 3521 01	epp2 	pr1|0,au
001241  aa   000000 0520 03	adwp2	0,du
001242  aa  3 00026 2521 00	spri2	pr3|22		comp.cfrtp
						STATEMENT 1 ON LINE 405
		if comp.cfrtp -> firstref_block.version ^= 1
		then do;

001243  aa  2 00000 2361 00	ldq  	pr2|0		firstref_block.version
001244  aa   000001 1160 07	cmpq 	1,dl
001245  aa   000034 6000 04	tze  	28,ic		001301
						STATEMENT 1 ON LINE 407
		     call com_err_ (error_table_$unimplemented_version, errname,
			"A version ^d trap on first reference encountered.", comp.cfrtp -> firstref_block.version);

001246  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001247  aa   776653 00 0064	desc9a	-597,52		000121 = 101040166145
001250  aa  6 00410 00 0064	desc9a	pr6|264,52
001251  aa  6 00044 3701 20	epp4 	pr6|36,*
001252  la  4 00036 3521 20	epp2 	pr4|30,*		error_table_$unimplemented_version
001253  aa  6 00430 2521 00	spri2	pr6|280
001254  ia  4 00014 3521 00	epp2 	pr4|12		errname
001255  aa  6 00432 2521 00	spri2	pr6|282
001256  aa  6 00410 3521 00	epp2 	pr6|264
001257  aa  6 00434 2521 00	spri2	pr6|284
001260  aa  3 00026 3521 20	epp2 	pr3|22,*		firstref_block.version
001261  aa  6 00436 2521 00	spri2	pr6|286
001262  aa   776540 3520 04	epp2 	-672,ic		000022 = 404000000043
001263  aa  6 00440 2521 00	spri2	pr6|288
001264  aa   776535 3520 04	epp2 	-675,ic		000021 = 524000000020
001265  aa  6 00442 2521 00	spri2	pr6|290
001266  aa   776520 3520 04	epp2 	-688,ic		000006 = 524000000061
001267  aa  6 00444 2521 00	spri2	pr6|292
001270  aa   776515 3520 04	epp2 	-691,ic		000005 = 404000000021
001271  aa  6 00446 2521 00	spri2	pr6|294
001272  aa  6 00426 6211 00	eax1 	pr6|278
001273  aa   020000 4310 07	fld  	8192,dl
001274  la  4 00024 3521 20	epp2 	pr4|20,*		com_err_
001275  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 409
		     bx_$fatal_error = 1;

001276  aa   000001 2360 07	ldq  	1,dl
001277  aa  6 00044 3701 20	epp4 	pr6|36,*
001300  la  4 00052 7561 20	stq  	pr4|42,*		bx_$fatal_error
						STATEMENT 1 ON LINE 410
		end;

						STATEMENT 1 ON LINE 411
		bx_$n_firstrefs = bx_$n_firstrefs + comp.cfrtp -> firstref_block.n_traps;

001301  aa  6 00250 3735 20	epp7 	pr6|168,*		ctep
001302  aa  7 00026 3715 20	epp5 	pr7|22,*		comp.cfrtp
001303  aa  5 00001 2361 00	ldq  	pr5|1		firstref_block.n_traps
001304  aa  6 00044 3701 20	epp4 	pr6|36,*
001305  la  4 00050 0561 20	asq  	pr4|40,*		bx_$n_firstrefs
						STATEMENT 1 ON LINE 412
	     end;

001306  aa   000003 7100 04	tra  	3,ic		001311
						STATEMENT 1 ON LINE 413
	     else comp.cfrtp = null;

001307  aa   776531 2370 04	ldaq 	-679,ic		000040 = 077777000043 000001000000
001310  aa  3 00026 7571 00	staq 	pr3|22		comp.cfrtp
						STATEMENT 1 ON LINE 414
	     if oi.format.procedure
	     then bx_$bproc = 1;

001311  aa  6 00302 2351 00	lda  	pr6|194		oi.procedure
001312  aa   040000 3150 03	cana 	16384,du
001313  aa   000042 6000 04	tze  	34,ic		001355
001314  aa   000001 2360 07	ldq  	1,dl
001315  aa  6 00044 3701 20	epp4 	pr6|36,*
001316  la  4 00064 7561 20	stq  	pr4|52,*		bx_$bproc
						STATEMENT 1 ON LINE 416
	     go to block_number;

001317  aa   000036 7100 04	tra  	30,ic		001355
						STATEMENT 1 ON LINE 417
	end;

						STATEMENT 1 ON LINE 418
	else do;

						STATEMENT 1 ON LINE 419
	     call com_err_ (0, errname, "object ^a is not a standard object segment", comp.filename);

001320  aa  6 00373 4501 00	stz  	pr6|251
001321  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001322  aa   776535 00 0054	desc9a	-675,44		000056 = 157142152145
001323  aa  6 00410 00 0054	desc9a	pr6|264,44
001324  aa  6 00373 3521 00	epp2 	pr6|251
001325  aa  6 00430 2521 00	spri2	pr6|280
001326  aa  6 00044 3701 20	epp4 	pr6|36,*
001327  ia  4 00014 3521 00	epp2 	pr4|12		errname
001330  aa  6 00432 2521 00	spri2	pr6|282
001331  aa  6 00410 3521 00	epp2 	pr6|264
001332  aa  6 00434 2521 00	spri2	pr6|284
001333  aa  3 00000 3521 00	epp2 	pr3|0		comp.filename
001334  aa  6 00436 2521 00	spri2	pr6|286
001335  aa   776462 3520 04	epp2 	-718,ic		000017 = 404000000005
001336  aa  6 00440 2521 00	spri2	pr6|288
001337  aa   776462 3520 04	epp2 	-718,ic		000021 = 524000000020
001340  aa  6 00442 2521 00	spri2	pr6|290
001341  aa   776443 3520 04	epp2 	-733,ic		000004 = 524000000052
001342  aa  6 00444 2521 00	spri2	pr6|292
001343  aa   776455 3520 04	epp2 	-723,ic		000020 = 524000000040
001344  aa  6 00446 2521 00	spri2	pr6|294
001345  aa  6 00426 6211 00	eax1 	pr6|278
001346  aa   020000 4310 07	fld  	8192,dl
001347  la  4 00024 3521 20	epp2 	pr4|20,*		com_err_
001350  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 420
	     bx_$fatal_error = 1;

001351  aa   000001 2360 07	ldq  	1,dl
001352  aa  6 00044 3701 20	epp4 	pr6|36,*
001353  la  4 00052 7561 20	stq  	pr4|42,*		bx_$fatal_error
						STATEMENT 1 ON LINE 421
	end;

						STATEMENT 1 ON LINE 423
	bx_$standard = 0;

001354  la  4 00062 4501 20	stz  	pr4|50,*		bx_$standard
						STATEMENT 1 ON LINE 427
block_number:
	comp.n_sym_blks = 1;

001355  aa   000001 2360 07	ldq  	1,dl
001356  aa  6 00250 3735 20	epp7 	pr6|168,*		ctep
001357  aa  7 00072 7561 00	stq  	pr7|58		comp.n_sym_blks
						STATEMENT 1 ON LINE 429
	sblkp = oi.symbp;

001360  aa  6 00270 3715 20	epp5 	pr6|184,*		oi.symbp
001361  aa  6 00110 6515 00	spri5	pr6|72		sblkp
						STATEMENT 1 ON LINE 431
block_loop:
	if sb.next_block = "0"b
	then go to return;

001362  aa  6 00110 3735 20	epp7 	pr6|72,*		sblkp
001363  aa  7 00020 2351 00	lda  	pr7|16		sb.next_block
001364  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
001365  aa  6 00373 7551 00	sta  	pr6|251		sb.next_block
001366  aa   000007 6000 04	tze  	7,ic		001375
						STATEMENT 1 ON LINE 434
	sblkp = addrel (oi.symbp, sb.next_block);

001367  aa  6 00270 3521 61	epp2 	pr6|184,*au	oi.symbp
001370  aa   000000 0520 03	adwp2	0,du
001371  aa  6 00110 2521 00	spri2	pr6|72		sblkp
						STATEMENT 1 ON LINE 435
	comp.n_sym_blks = comp.n_sym_blks + 1;

001372  aa  6 00250 3735 20	epp7 	pr6|168,*		ctep
001373  aa  7 00072 0541 00	aos  	pr7|58		comp.n_sym_blks
						STATEMENT 1 ON LINE 436
	go to block_loop;

001374  aa   777766 7100 04	tra  	-10,ic		001362
						STATEMENT 1 ON LINE 438
return:
	call temp_mgr_$reserve (addr (insymp -> insym.entry (insymp -> insym.n_insyms + 1)));

001375  aa  6 00120 3715 20	epp5 	pr6|80,*		insymp
001376  aa  5 00002 2361 00	ldq  	pr5|2		insym.n_insyms
001377  aa   000112 4020 07	mpy  	74,dl
001400  aa  5 00004 3535 06	epp3 	pr5|4,ql		insym.entry
001401  aa  6 00374 2535 00	spri3	pr6|252
001402  aa  6 00374 3521 00	epp2 	pr6|252
001403  aa  6 00400 2521 00	spri2	pr6|256
001404  aa  6 00376 6211 00	eax1 	pr6|254
001405  aa   004000 4310 07	fld  	2048,dl
001406  aa  6 00044 3701 20	epp4 	pr6|36,*
001407  la  4 00032 3521 20	epp2 	pr4|26,*		temp_mgr_$reserve
001410  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 444
	p = ptr (bx_$temp_bsegp, comp.crelt);

001411  aa  6 00250 3735 20	epp7 	pr6|168,*		ctep
001412  aa  7 00073 2361 00	ldq  	pr7|59		comp.crelt
001413  aa  6 00044 3701 20	epp4 	pr6|36,*
001414  la  4 00076 3521 20	epp2 	pr4|62,*		bx_$temp_bsegp
001415  aa  2 00000 3521 20	epp2 	pr2|0,*		bx_$temp_bsegp
001416  aa   000000 3120 06	eawp2	0,ql
001417  aa  6 00106 2521 00	spri2	pr6|70		p
						STATEMENT 1 ON LINE 445
	lng = comp.clngt;

001420  aa  7 00061 2361 00	ldq  	pr7|49		comp.clngt
001421  aa  6 00104 7561 00	stq  	pr6|68		lng
						STATEMENT 1 ON LINE 446
	p -> textsection = oi.textp -> textsection;

001422  aa   000002 7360 00	qls  	2
001423  aa  6 00260 3715 20	epp5 	pr6|176,*		oi.textp
001424  aa  000 140 100 540	mlr  	(pr,rl),(pr,rl),fill(000)
001425  aa  5 00000 00 0006	desc9a	pr5|0,ql		textsection
001426  aa  2 00000 00 0006	desc9a	pr2|0,ql		textsection
						STATEMENT 1 ON LINE 448
	return;

001427  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO init                                               STATEMENT 1 ON LINE 451
init:
     entry;

001430  da     000263200000
001431  aa   000600 6270 00	eax7 	384
001432  aa  7 00034 3521 20	epp2 	pr7|28,*
001433  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001434  aa     000000000000
001435  aa     000000000000
						STATEMENT 1 ON LINE 467
	last_insym = null;

001436  aa   776402 2370 04	ldaq 	-766,ic		000040 = 077777000043 000001000000
001437  aa  6 00044 3701 20	epp4 	pr6|36,*
001440  ia  4 00010 7571 00	staq 	pr4|8		last_insym
						STATEMENT 1 ON LINE 468
	text_relc, is_relc = 0;

001441  ia  4 00012 4501 00	stz  	pr4|10		text_relc
001442  ia  4 00013 4501 00	stz  	pr4|11		is_relc
						STATEMENT 1 ON LINE 469
	bx_$maxlinklng = 128;

001443  aa   000200 2360 07	ldq  	128,dl
001444  la  4 00072 7561 20	stq  	pr4|58,*		bx_$maxlinklng
						STATEMENT 1 ON LINE 470
	bx_$n_firstrefs = 0;

001445  la  4 00050 4501 20	stz  	pr4|40,*		bx_$n_firstrefs
						STATEMENT 1 ON LINE 471
	bx_$bproc = 0;

001446  la  4 00064 4501 20	stz  	pr4|52,*		bx_$bproc
						STATEMENT 1 ON LINE 472
	bx_$standard = 1;

001447  aa   000001 2360 07	ldq  	1,dl
001450  la  4 00062 7561 20	stq  	pr4|50,*		bx_$standard
						STATEMENT 1 ON LINE 473
	bx_$has_sep_stat, bx_$has_comb_stat = 0;

001451  la  4 00056 4501 20	stz  	pr4|46,*		bx_$has_sep_stat
001452  la  4 00060 4501 20	stz  	pr4|48,*		bx_$has_comb_stat
						STATEMENT 1 ON LINE 474
	if bx_$debug = 1
	then errname = "dissect_object_";

001453  la  4 00054 2361 20	ldq  	pr4|44,*		bx_$debug
001454  aa   000001 1160 07	cmpq 	1,dl
001455  aa   000005 6010 04	tnz  	5,ic		001462
001456  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
001457  aa   776364 00 0017	desc9a	-780,15		000042 = 144151163163
001460  ia  4 00014 00 0020	desc9a	pr4|12,16		errname
001461  aa   000010 7100 04	tra  	8,ic		001471
						STATEMENT 1 ON LINE 476
	else errname = bx_$caller;

001462  la  4 00100 3735 20	epp7 	pr4|64,*		bx_$caller
001463  aa  7 00000 2351 00	lda  	pr7|0		bx_$caller
001464  aa  7 00001 2361 00	ldq  	pr7|1		bx_$caller
001465  ia  4 00014 7571 00	staq 	pr4|12		errname
001466  aa  7 00002 2351 00	lda  	pr7|2		bx_$caller
001467  aa  7 00003 2361 00	ldq  	pr7|3		bx_$caller
001470  ia  4 00016 7571 00	staq 	pr4|14		errname
						STATEMENT 1 ON LINE 477
	return;

001471  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 537
     end dissect_object_;

BEGIN PROCEDURE update_segname_table
ENTRY TO update_segname_table                               STATEMENT 1 ON LINE 482
update_segname_table:
     procedure;

001472  aa  6 00346 6501 00	spri4	pr6|230
						STATEMENT 1 ON LINE 496
	val = symbol_lng;

001473  aa  6 00243 2361 00	ldq  	pr6|163		dd.symbol_lng
001474  aa  6 00360 7561 00	stq  	pr6|240		val
						STATEMENT 1 ON LINE 497
	if symbol_lng > 32
	then do;

001475  aa   000040 1160 07	cmpq 	32,dl
001476  aa   000027 6044 04	tmoz 	23,ic		001525
						STATEMENT 1 ON LINE 499
	     call ioa_ (
		"Warning: Segment name ^a^/in definitions for component ^a^/is being truncated to 32 characters.",
		dd.symbol, comp.filename);

001477  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001500  aa   776460 00 0140	desc9a	-720,96		000157 = 127141162156
001501  aa  6 00476 00 0140	desc9a	pr6|318,96
001502  aa  6 00476 3521 00	epp2 	pr6|318
001503  aa  6 00530 2521 00	spri2	pr6|344
001504  aa  6 00143 3521 00	epp2 	pr6|99		dd.symbol
001505  aa  6 00532 2521 00	spri2	pr6|346
001506  aa  6 00250 3521 20	epp2 	pr6|168,*		comp.filename
001507  aa  6 00534 2521 00	spri2	pr6|348
001510  aa   776273 3520 04	epp2 	-837,ic		000003 = 524000000137
001511  aa  6 00536 2521 00	spri2	pr6|350
001512  aa   776270 3520 04	epp2 	-840,ic		000002 = 524000000400
001513  aa  6 00540 2521 00	spri2	pr6|352
001514  aa   776304 3520 04	epp2 	-828,ic		000020 = 524000000040
001515  aa  6 00542 2521 00	spri2	pr6|354
001516  aa  6 00526 6211 00	eax1 	pr6|342
001517  aa   014000 4310 07	fld  	6144,dl
001520  aa  6 00044 3701 20	epp4 	pr6|36,*
001521  la  4 00026 3521 20	epp2 	pr4|22,*		ioa_
001522  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 502
	     val = 32;

001523  aa   000040 2360 07	ldq  	32,dl
001524  aa  6 00360 7561 00	stq  	pr6|240		val
						STATEMENT 1 ON LINE 503
	end;

						STATEMENT 1 ON LINE 504
	acc_overlay = "0"b;

001525  aa  000 100 100 400	mlr  	(),(pr),fill(000)
001526  aa   000000 00 0000	desc9a	0,0
001527  aa  6 00361 00 0041	desc9a	pr6|241,33	acc_overlay
						STATEMENT 1 ON LINE 505
	acc.len = val;

001530  aa   000077 7370 00	lls  	63
001531  aa  6 00361 5511 40	stba 	pr6|241,40	acc.len
						STATEMENT 1 ON LINE 506
	acc.text = substr (dd.symbol, 1, val);

001532  aa  6 00361 2351 00	lda  	pr6|241		acc.len
001533  aa   000077 7730 00	lrl  	63
001534  aa  6 00360 7271 00	lxl7 	pr6|240		val
001535  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
001536  aa  6 00143 00 0017	desc9a	pr6|99,x7		dd.symbol
001537  aa  6 00361 20 0006	desc9a	pr6|241(1),ql	acc.text
						STATEMENT 1 ON LINE 508
	val = val + 1;

001540  aa  6 00360 0541 00	aos  	pr6|240		val
						STATEMENT 1 ON LINE 509
	do i = 1 to snt.n_names;

001541  aa  6 00252 3735 20	epp7 	pr6|170,*		sntp
001542  aa  7 00324 2361 00	ldq  	pr7|212		snt.n_names
001543  aa  6 00372 7561 00	stq  	pr6|250
001544  aa   000001 2360 07	ldq  	1,dl
001545  aa  6 00354 7561 00	stq  	pr6|236		i
001546  aa  6 00354 2361 00	ldq  	pr6|236		i
001547  aa  6 00372 1161 00	cmpq 	pr6|250
001550  aa   000065 6054 04	tpnz 	53,ic		001635
						STATEMENT 1 ON LINE 510
	     sntep = addr (snt.entry (i));

001551  aa   000004 7360 00	qls  	4
001552  aa  6 00252 3735 20	epp7 	pr6|170,*		sntp
001553  aa  7 00306 3735 06	epp7 	pr7|198,ql	snt.entry
001554  aa  6 00356 6535 00	spri7	pr6|238		sntep
						STATEMENT 1 ON LINE 511
	     if acc_str = substr (snte.name, 1, val)
	     then do;

001555  aa  6 00360 7271 00	lxl7 	pr6|240		val
001556  aa  040 140 106 540	cmpc 	(pr,rl),(pr,rl),fill(040)
001557  aa  6 00361 00 0017	desc9a	pr6|241,x7	acc_str
001560  aa  7 00000 00 0017	desc9a	pr7|0,x7		snte.name
001561  aa   000052 6010 04	tnz  	42,ic		001633
						STATEMENT 1 ON LINE 513
		if snte.comp = ctep
		then return;

001562  aa  7 00014 2371 00	ldaq 	pr7|12		snte.comp
001563  aa  6 00250 6771 00	eraq 	pr6|168		ctep
001564  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001565  aa   000002 6010 04	tnz  	2,ic		001567
001566  aa  6 00346 6101 00	rtcd 	pr6|230
						STATEMENT 1 ON LINE 515
		call com_err_ (0, errname, "Segment name ^a for component ^a^/^-already used for component ^a",
		     dd.symbol, comp.filename, snte.comp -> comp.filename);

001567  aa  6 00544 4501 00	stz  	pr6|356
001570  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001571  aa   776346 00 0104	desc9a	-794,68		000136 = 123145147155
001572  aa  6 00476 00 0104	desc9a	pr6|318,68
001573  aa  6 00544 3521 00	epp2 	pr6|356
001574  aa  6 00550 2521 00	spri2	pr6|360
001575  aa  6 00044 3701 20	epp4 	pr6|36,*
001576  ia  4 00014 3521 00	epp2 	pr4|12		errname
001577  aa  6 00552 2521 00	spri2	pr6|362
001600  aa  6 00476 3521 00	epp2 	pr6|318
001601  aa  6 00554 2521 00	spri2	pr6|364
001602  aa  6 00143 3521 00	epp2 	pr6|99		dd.symbol
001603  aa  6 00556 2521 00	spri2	pr6|366
001604  aa  6 00250 3521 20	epp2 	pr6|168,*		comp.filename
001605  aa  6 00560 2521 00	spri2	pr6|368
001606  aa  7 00014 3521 20	epp2 	pr7|12,*		comp.filename
001607  aa  6 00562 2521 00	spri2	pr6|370
001610  aa   776207 3520 04	epp2 	-889,ic		000017 = 404000000005
001611  aa  6 00564 2521 00	spri2	pr6|372
001612  aa   776207 3520 04	epp2 	-889,ic		000021 = 524000000020
001613  aa  6 00566 2521 00	spri2	pr6|374
001614  aa   776165 3520 04	epp2 	-907,ic		000001 = 524000000101
001615  aa  6 00570 2521 00	spri2	pr6|376
001616  aa   776164 3520 04	epp2 	-908,ic		000002 = 524000000400
001617  aa  6 00572 2521 00	spri2	pr6|378
001620  aa   776200 3520 04	epp2 	-896,ic		000020 = 524000000040
001621  aa  6 00574 2521 00	spri2	pr6|380
001622  aa  6 00576 2521 00	spri2	pr6|382
001623  aa  6 00546 6211 00	eax1 	pr6|358
001624  aa   030000 4310 07	fld  	12288,dl
001625  la  4 00024 3521 20	epp2 	pr4|20,*		com_err_
001626  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 517
		bx_$fatal_error = 1;

001627  aa   000001 2360 07	ldq  	1,dl
001630  aa  6 00044 3701 20	epp4 	pr6|36,*
001631  la  4 00052 7561 20	stq  	pr4|42,*		bx_$fatal_error
						STATEMENT 1 ON LINE 518
		return;

001632  aa  6 00346 6101 00	rtcd 	pr6|230
						STATEMENT 1 ON LINE 519
	     end;

						STATEMENT 1 ON LINE 520
	end;

001633  aa  6 00354 0541 00	aos  	pr6|236		i
001634  aa   777712 7100 04	tra  	-54,ic		001546
						STATEMENT 1 ON LINE 521
	snt.n_names, i = snt.n_names + 1;

001635  aa  6 00252 3735 20	epp7 	pr6|170,*		sntp
001636  aa  7 00324 2361 00	ldq  	pr7|212		snt.n_names
001637  aa   000001 0760 07	adq  	1,dl
001640  aa  7 00324 7561 00	stq  	pr7|212		snt.n_names
001641  aa  6 00354 7561 00	stq  	pr6|236		i
						STATEMENT 1 ON LINE 522
	if i > snt.max_size
	then do;

001642  aa  7 00323 1161 00	cmpq 	pr7|211		snt.max_size
001643  aa   000034 6044 04	tmoz 	28,ic		001677
						STATEMENT 1 ON LINE 524
	     call com_err_ (0, errname, "Segname table overflow; please contact maintenance");

001644  aa  6 00544 4501 00	stz  	pr6|356
001645  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001646  aa   776237 00 0064	desc9a	-865,52		000104 = 123145147156
001647  aa  6 00526 00 0064	desc9a	pr6|342,52
001650  aa  6 00544 3521 00	epp2 	pr6|356
001651  aa  6 00500 2521 00	spri2	pr6|320
001652  aa  6 00044 3701 20	epp4 	pr6|36,*
001653  ia  4 00014 3521 00	epp2 	pr4|12		errname
001654  aa  6 00502 2521 00	spri2	pr6|322
001655  aa  6 00526 3521 00	epp2 	pr6|342
001656  aa  6 00504 2521 00	spri2	pr6|324
001657  aa   776140 3520 04	epp2 	-928,ic		000017 = 404000000005
001660  aa  6 00506 2521 00	spri2	pr6|326
001661  aa   776140 3520 04	epp2 	-928,ic		000021 = 524000000020
001662  aa  6 00510 2521 00	spri2	pr6|328
001663  aa   776115 3520 04	epp2 	-947,ic		000000 = 524000000062
001664  aa  6 00512 2521 00	spri2	pr6|330
001665  aa  6 00476 6211 00	eax1 	pr6|318
001666  aa   014000 4310 07	fld  	6144,dl
001667  la  4 00024 3521 20	epp2 	pr4|20,*		com_err_
001670  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 525
	     snt.n_names = 1;

001671  aa   000001 2360 07	ldq  	1,dl
001672  aa  6 00252 3735 20	epp7 	pr6|170,*		sntp
001673  aa  7 00324 7561 00	stq  	pr7|212		snt.n_names
						STATEMENT 1 ON LINE 526
	     bx_$fatal_error = 1;

001674  aa  6 00044 3701 20	epp4 	pr6|36,*
001675  la  4 00052 7561 20	stq  	pr4|42,*		bx_$fatal_error
						STATEMENT 1 ON LINE 527
	     return;

001676  aa  6 00346 6101 00	rtcd 	pr6|230
						STATEMENT 1 ON LINE 528
	end;

						STATEMENT 1 ON LINE 529
	sntep = addr (snt.entry (i));

001677  aa   000004 7360 00	qls  	4
001700  aa  7 00306 3715 06	epp5 	pr7|198,ql	snt.entry
001701  aa  6 00356 6515 00	spri5	pr6|238		sntep
						STATEMENT 1 ON LINE 530
	substr (snte.name, 1, val) = acc_str;

001702  aa  6 00360 7271 00	lxl7 	pr6|240		val
001703  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
001704  aa  6 00361 00 0017	desc9a	pr6|241,x7	acc_str
001705  aa  5 00000 00 0017	desc9a	pr5|0,x7		snte.name
						STATEMENT 1 ON LINE 531
	snte.lng = val;

001706  aa  6 00360 2361 00	ldq  	pr6|240		val
001707  aa  5 00011 7561 00	stq  	pr5|9		snte.lng
						STATEMENT 1 ON LINE 532
	snte.comp = ctep;

001710  aa  6 00250 3535 20	epp3 	pr6|168,*		ctep
001711  aa  5 00014 2535 00	spri3	pr5|12		snte.comp
						STATEMENT 1 ON LINE 534
     end update_segname_table;

001712  aa  6 00346 6101 00	rtcd 	pr6|230
  END PROCEDURE update_segname_table
  END PROCEDURE dissect_object_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
