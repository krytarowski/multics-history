	COMPILATION LISTING OF SEGMENT cm_get_element
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  0952.2 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* DESCRIPTION:
        9*
       10*   This module implements collection_manager_$get 
       11*   (cm_get_element$cm_get_element), collection_manager_$get_exclusive
       12*   (cm_get_element$exclusive) and collection_manager_$get_by_ci_ptr
       13*   (cm_get_element$by_ci_ptr);
       14*
       15*   This module gets the specified element.  The location of the element
       16*   is p_position elements from p_element_id.  The data is returned in the
       17*   buffer located at p_buffer_ptr (if it fits).  p_buffer_length is the
       18*   bit length of that caller-supplied buffer.  If the buffer is too small
       19*   to hold the data, space is allocated in the provided area and the 
       20*   data is returned there.
       21**/
       22 
       23 /* HISTORY:
       24*
       25*Written 02/25/82 by Matthew Pierret.
       26*Modified:
       27*03/23/82 by Matthew Pierret: Changed to return dm_error_$invalid_element_id
       28*            if given a slot index of less-than 1.
       29*03/25/82 by Matthew Pierret: Fixed bug which improperly set p_element_ptr/length.
       30*04/07/82 by Matthew Pierret: Changed p_buffer_length to be a bit length.
       31*05/10/82 by Lindsey Spratt: Use the precision and scale of (35,18) when
       32*	  dividing to find the length in bytes from the length in bits.
       33*	  Also, subtract the datum header length when setting the returned
       34*	  element_length.
       35*06/09/82 by Matthew Pierret: Added code to support getting element portions
       36*            if portion_beginning_index is equal to 1. Added consistency check
       37*            to make sure that the control interval in which the element resides
       38*            belongs to the specified collection. 
       39*06/15/82 by Matthew Pierret: Changed to use bci_header, dm_cm_basic_ci.incl.pl1,
       40*            add_ci_part to cm_add_ci_part, ..BYTE_LENGTH to ..LENGTH_IN_BYTES,
       41*            calling sequence of cm_add_ci_part.
       42*07/09/82 by Matthew Pierret: Added exclusive entry. Replaced calls to 
       43*            cm_add_ci_part with in-line code.
       44*09/02/82 by Matthew Pierret:  Added ability to position forward or backward.
       45*            p_element_id is now an input/output parameter, as it is set to the
       46*            id of the element positioned to. 
       47*10/19/82 by Matthew Pierret:  Added check for free datum slot.
       48*            Changed to use dm_error_$no_element.
       49*10/20/82 by Matthew Pierret:  Converted to use file_manager_.
       50*11/08/82 by Matthew Pierret:  Changed to support multi-datum elements.
       51*12/01/82 by Lindsey Spratt: Changed to initialize p_new_buffer_was_allocated
       52*	  to "0"b.  Also, removed the get_element entry name.
       53*01/04/83 by Lindsey Spratt:  Fixed to use a local buffer when getting the
       54*	  first datum of a multi-datum element; also, to return an error
       55*	  code when the supplied buffer is too small, no area was supplied
       56*	  and the element is multi-datum.
       57*01/26/83 by Matthew Pierret: Changed to provide better error reporting.
       58*            Errors encountered getting continuation datums are reported via
       59*            sub_err_, as they represent inconsistencies in the collection's
       60*            data.
       61*02/07/83 by Matthew Pierret: Changed to use cm_get_id$header_return_slot to
       62*            position to an element.  Added the $info* entries.
       63*            Added $bypass_info. This entry is called by cm_opening_info$get.
       64*            It does not attempt to get cm_info. If it did, an infinite loop
       65*            would occur with cm_get_element and cm_opening_info calling each
       66*            repeatedly.
       67*04/03/83 by Lindsey L. Spratt:  Changed length variables to be declared fixed
       68*            bin (35) instead of fixed bin (17).
       69*04/03/83 by Lindsey L. Spratt:  Fixed to use a (71,18) when doing the division
       70*            to set the element_length_in_bytes in the multi-datum case.
       71*04/06/83 by Lindsey L. Spratt:  Fixed multi-datum case to subtract the initial
       72*            datum length from the element_length_in_bytes (which was already
       73*            being decremented for each of the other datums).  Added an error
       74*            check for the multi-datum length inconsistency.
       75*04/29/83 by Matthew Pierret: Changed to use addcharno instead of addr(substr())
       76*            and to use dm_error_$long_return_element.
       77*05/04/83 by Matthew Pierret:  Changed dm_error_$col_is_inconsistent to
       78*            $programming_error.
       79*07/14/83 by Matthew Pierret:  Changed to consider the case of an
       80*            element_id.index of 0 without intended positioning away to be in
       81*            error.  dm_error_$no_element is returned. Changed to allow an
       82*            element_id_string of "0"b if positioning is specified.
       83*10/13/83 by Lindsey L. Spratt:  Changed to not get the opening_info in the get
       84*            or exclusive_get entries.
       85*10/17/83 by Lindsey L. Spratt:  Fixed to properly copy the
       86*            position_from_specified_element value for the NO_INFO_JOIN
       87*            entries.
       88*01/24/84 by Matthew Pierret:  Fixed multi-datum gets to stop inadvertently
       89*            attempting to get two ci parts instead of one by forgetting to
       90*            reset ci_parts.number_of_parts to 1.
       91*02/07/84 by Matthew Pierret:  Changed to make use of the 
       92*            file_manager_$get_ci_ptr operation to reduce the number of calls
       93*            to file_manager_$get.  Added the p_position argument to the
       94*            $bypass_info entry so that it has the same calling sequence as
       95*            $cm_get_element and $exclusive, and removed all other entries.
       96*            A lot of extra code is generated by the compiler when a routine
       97*            has multiple entrypoints with the same arguments in different 
       98*            places.  This is no longer the case for cm_get_element.
       99*03/15/84 by Lindsey L. Spratt:  Fixed MULTI_DATUM_GET to set the
      100*            cd_datum_header.  (Matt and Lee B.  helped)
      101*03/16/84 by Matthew Pierret:  Changed to special case 
      102*            dm_error_$ci_not_allocated when returned from fm_$get_ci_ptr.
      103*05/09/84 by Matthew Pierret:  Changed the buffer used to be even word aligned.
      104*07/18/84 by Matthew Pierret:  Changed to return dm_error_$ci_not_in_collection
      105*            if the error is detected on the first control interval examined,
      106*            but to call sub_err_ on subsequent control intervals.  This is 
      107*            because the former indicates that the caller probably supplied
      108*            the wrong element id, while the latter indicates an inconsistency
      109*            in the collection.
      110*10/01/84 by Matthew Pierret:  Changed for the changes in datum structures
      111*            (they are all based on datum_ptr and datum_contents_length_in_bits)
      112*            Changed expression of converting bits to bytes for efficiency:
      113*            ceil (divide (bits ,BITS_PER_BYTE ,35 ,18)) is better as
      114*            divide (bits + BITS_PER_BYTE -1, BITS_PER_BYTE, 17, 0).
      115*            Added comment to explain why buffer_ptr=null need not be checked
      116*            when determining whether to allocate a new buffer.
      117*12/03/84 by Matthew Pierret:  Added the local cd_datum_header, which was 
      118*            removed from dm_cm_datum.incl.pl1.
      119**/
      120 
      121 /* format: style2,ind3,ll79 */
      122 
      123 cm_get_element:
      124    proc (p_file_opening_id, p_collection_id, p_element_id, p_position,
      125         p_buffer_ptr, p_buffer_length, p_area_ptr, p_new_buffer_was_allocated,
      126         p_element_ptr, p_element_length, p_code);
      127 
      128 /* START OF DECLARATIONS */
      129 /* Parameter */
      130 
      131       dcl	    p_file_opening_id      bit (36) aligned;
      132       dcl	    p_collection_id	       bit (36) aligned;
      133       dcl	    p_element_id	       bit (36) aligned;
      134       dcl	    p_position	       fixed bin (17);
      135       dcl	    p_buffer_ptr	       ptr;
      136       dcl	    p_buffer_length	       fixed bin (35);
      137       dcl	    p_area_ptr	       ptr;
      138       dcl	    p_new_buffer_was_allocated
      139 			       bit (1) aligned;
      140       dcl	    p_element_ptr	       ptr;
      141       dcl	    p_element_length       fixed bin (35);
      142       dcl	    p_code	       fixed bin (35);
      143       dcl	    p_input_ci_ptr	       ptr;
      144       dcl	    p_return_ci_ptr	       ptr;
      145 
      146 /* Automatic */
      147 
      148       dcl	    (file_opening_id, collection_id)
      149 			       bit (36) aligned;
      150       dcl	    (continuation_datum_id_string, continued_datum_id_string)
      151 			       init ("0"b) bit (36) aligned;
      152 
      153       dcl	    code		       fixed bin (35) init (0);
      154       dcl	    buffer_length_in_bits  fixed bin (35) init (0);
      155       dcl	    buffer_length_in_double_words
      156 			       fixed bin (17) init (0);
      157       dcl	    datum_contents_length_in_bytes
      158 			       fixed bin (17) init (0);
      159       dcl	    element_length_in_bits fixed bin (35) init (0);
      160       dcl	    element_length_in_bytes
      161 			       fixed bin (35) init (0);
      162       dcl	    remaining_element_length_in_bytes
      163 			       fixed bin (35) init (0);
      164       dcl	    position_from_specified_element
      165 			       fixed bin (17) init (0);
      166 						/* This should probably be 35, eventually. */
      167 
      168       dcl	    exclusive_get	       bit (1) aligned init ("0"b);
      169       dcl	    return_last_used_ci_ptr
      170 			       bit (1) aligned init ("0"b);
      171 
      172       dcl	    ci_ptr	       ptr init (null);
      173       dcl	    work_area_ptr	       ptr init (null);
      174       dcl	    buffer_ptr	       ptr init (null);
      175       dcl	    current_buffer_ptr     ptr init (null);
      176       dcl	    datum_contents_ptr     ptr init (null);
      177 
      178       dcl	    1 cd_datum_header      aligned like continued_datum.header;
      179 
      180 /* Based */
      181 
      182       dcl	    1 continued_datum_id   aligned like datum_id
      183 			       based (addr (continued_datum_id_string));
      184       dcl	    1 continuation_datum_id
      185 			       aligned like datum_id
      186 			       based (
      187 			       addr (continuation_datum_id_string));
      188       dcl	    work_area	       area based (work_area_ptr);
      189       dcl	    buffer	       (buffer_length_in_double_words) fixed
      190 			       bin (71) based (buffer_ptr);
      191       dcl	    datum_contents_string  char (datum_contents_length_in_bytes)
      192 			       based;
      193 
      194 /* Builtin */
      195 
      196       dcl	    (addr, addcharno, ceil, divide, length, null, unspec)
      197 			       builtin;
      198 
      199 /* Condition */
      200 
      201       dcl	    cleanup	       condition;
      202 
      203 /* Constant */
      204 
      205       dcl	    myname	       init ("cm_get_element") char (32)
      206 			       varying internal static
      207 			       options (constant);
      208       dcl	    (
      209 	    BITS_PER_BYTE	       init (9),
      210 	    BYTES_PER_DOUBLE_WORD  init (8)
      211 	    )		       fixed bin int static options (constant);
      212       dcl	    (
      213 	    THIS_IS_FIRST_CI_SEEN  init ("1"b),
      214 	    THIS_IS_NOT_FIRST_CI_SEEN
      215 			       init ("0"b)
      216 	    )		       bit (1) aligned internal static
      217 			       options (constant);
      218 
      219 /* Entry */
      220 
      221       dcl	    file_manager_$get_ci_ptr
      222 			       entry (bit (36) aligned, fixed bin (27),
      223 			       ptr, fixed bin (35));
      224       dcl	    sub_err_	       entry () options (variable);
      225 
      226 /* External */
      227 
      228       dcl	    (
      229 	    dm_error_$ci_not_allocated,
      230 	    dm_error_$ci_not_in_collection,
      231 	    dm_error_$no_element,
      232 	    dm_error_$long_return_element,
      233 	    dm_error_$programming_error
      234 	    )		       fixed bin (35) ext;
      235       dcl	    error_table_$unimplemented_version
      236 			       ext fixed bin (35);
      237 
      238 /* END OF DECLARATIONS */
      239 
      240       exclusive_get = "0"b;
      241       return_last_used_ci_ptr = "0"b;
      242       position_from_specified_element = p_position;
      243       ci_ptr = null ();
      244       go to JOIN;
      245 
      246 exclusive:
      247    entry (p_file_opening_id, p_collection_id, p_element_id, p_position,
      248         p_buffer_ptr, p_buffer_length, p_area_ptr, p_new_buffer_was_allocated,
      249         p_element_ptr, p_element_length, p_code);
      250 
      251       exclusive_get = "1"b;
      252       return_last_used_ci_ptr = "0"b;
      253       position_from_specified_element = p_position;
      254       ci_ptr = null ();
      255       go to JOIN;
      256 
      257 
      258 by_ci_ptr:
      259    entry (p_input_ci_ptr, p_file_opening_id, p_collection_id, p_element_id,
      260         p_position, p_buffer_ptr, p_buffer_length, p_area_ptr,
      261         p_new_buffer_was_allocated, p_element_ptr, p_element_length,
      262         p_return_ci_ptr, p_code);
      263 
      264       exclusive_get = "0"b;
      265       return_last_used_ci_ptr = "1"b;
      266       position_from_specified_element = p_position;
      267       ci_ptr = p_input_ci_ptr;
      268       go to JOIN;
      269 
      270 JOIN:
      271       p_code = 0;
      272       p_new_buffer_was_allocated = "0"b;
      273       file_opening_id = p_file_opening_id;
      274       collection_id = p_collection_id;
      275       element_id_string = p_element_id;
      276       buffer_ptr = p_buffer_ptr;			/* format: equalind0 */
      277 
      278       if buffer_ptr = null
      279       then buffer_length_in_bits = -1;			/* no buffer */
      280       else buffer_length_in_bits = p_buffer_length;
      281 
      282       if position_from_specified_element = 0
      283       then
      284          do;
      285 	  if element_id.index <= 0
      286 	  then call ERROR_RETURN (dm_error_$no_element);
      287 	  call GET_CI_PTR (THIS_IS_FIRST_CI_SEEN, file_opening_id,
      288 	       collection_id, (element_id.control_interval_id), ci_ptr);
      289 	  if element_id.index
      290 	       > ci_ptr -> basic_control_interval.header.number_of_datums
      291 	  then call ERROR_RETURN (dm_error_$no_element);
      292          end;
      293       else
      294          do;
      295 	  call cm_get_id$ptr (file_opening_id, collection_id,
      296 	       (element_id_string), position_from_specified_element,
      297 	       (element_id_string = "0"b), ci_ptr, ci_ptr, element_id_string,
      298 	       code);
      299 	  if code ^= 0
      300 	  then call ERROR_RETURN (code);
      301          end;
      302 
      303       /*** This is the control interval in which the elment to be retrieved lives.
      304*        Return it if it has been requested.  This is done here because ci_ptr may change
      305*        later on if the element is a multi-datum element, but we want to return
      306*        the ptr to the control interval in which the element starts. */
      307 
      308       if return_last_used_ci_ptr
      309       then p_return_ci_ptr = ci_ptr;
      310 
      311       /*** Copy datum slot into local storage for efficiency. */
      312 
      313       datum_slot_ptr =
      314 	 addr (ci_ptr
      315 	 -> basic_control_interval.datum_position_table (element_id.index));
      316 
      317       /*** If no element corresponds to this datum slot, report to caller that
      318*        the element could not be found. */
      319 
      320       if datum_slot.offset_in_bytes = FREE_SLOT /* no datum here */
      321 	 | datum_slot.flags.is_continuation		/* this datum is not the start of an element */
      322       then call ERROR_RETURN (dm_error_$no_element);
      323 
      324 
      325       if ^datum_slot.flags.is_continued
      326       then
      327 SIMPLE_GET:
      328          do;
      329 
      330 	  /*** The datum described by datum_slot is the entire element.  Get the datum
      331*in the supplied buffer or in the supplied work area if
      332*the the buffer is not supplied or is too small.
      333*There is no need to check to see if buffer_ptr is null,
      334*as if it is, buffer_length_in_bytes is -1, and so will
      335*always pass the test to see if the buffer is to small.. */
      336 
      337 	  datum_contents_ptr =
      338 	       addcharno (ci_ptr, datum_slot.offset_in_bytes);
      339 	  datum_contents_length_in_bytes =
      340 	       divide (datum_slot.length_in_bits + BITS_PER_BYTE - 1,
      341 	       BITS_PER_BYTE, 17, 0);
      342 
      343 	  if datum_contents_length_in_bytes * BITS_PER_BYTE
      344 	       > buffer_length_in_bits		/* datum_contents_length_in_bytes * BITS_PER_BYTE is used */
      345 						/* in this test instead of datum_slot.length_in_bits      */
      346 						/* because the buffer must be large enough to fit the     */
      347 						/* contents when copied in bytes.                         */
      348 	  then
      349 SG_ALLOC_BUFFER:
      350 	     do;					/* Buffer is too small. Try allocating a buffer in the work area. */
      351 	        work_area_ptr = p_area_ptr;
      352 	        if work_area_ptr = null
      353 	        then
      354 		 do;
      355 		    p_element_length =
      356 		         datum_contents_length_in_bytes * BITS_PER_BYTE;
      357 						/* Not the actual length of the element, but the minimum */
      358 						/* size a buffer must be to hold the element. */
      359 		    call ERROR_RETURN (dm_error_$long_return_element);
      360 		 end;
      361 	        else
      362 		 do;				/* Allocate the buffer. */
      363 		    buffer_length_in_double_words =
      364 		         divide (datum_contents_length_in_bytes,
      365 		         BYTES_PER_DOUBLE_WORD, 35, 0) + 1;
      366 		    on cleanup call FINISH ();
      367 		    alloc buffer in (work_area);
      368 		    p_new_buffer_was_allocated = "1"b;
      369 		 end;
      370 	     end SG_ALLOC_BUFFER;
      371 
      372 	  /*** Now, copy the datum contents into the buffer. */
      373 
      374 	  buffer_ptr -> datum_contents_string =
      375 	       datum_contents_ptr -> datum_contents_string;
      376 
      377 	  p_element_ptr = buffer_ptr;
      378 	  p_element_length = datum_slot.length_in_bits;
      379 
      380          end SIMPLE_GET;
      381 
      382       else call MULTI_DATUM_GET ();			/* The element consists of more than one datum. */
      383 
      384       if p_element_id ^= element_id_string
      385       then p_element_id = element_id_string;
      386 
      387 RETURN:
      388       return;
      389 
      390 FINISH:
      391    proc ();
      392 
      393       if buffer_ptr ^= p_buffer_ptr & buffer_ptr ^= null
      394       then
      395          do;
      396 	  p_new_buffer_was_allocated = "0"b;
      397 	  free buffer in (work_area);
      398          end;
      399 
      400    end FINISH;
      401 
      402 ERROR_RETURN:
      403    proc (er_code);
      404 
      405       dcl	    er_code	       fixed bin (35);
      406 
      407       p_code = er_code;
      408       call FINISH ();
      409       goto RETURN;
      410 
      411    end ERROR_RETURN;
      412 
      413 CHECK_CI_LAYOUT:
      414    proc (ccl_p_ci_layout);
      415       dcl	    ccl_p_ci_layout	       char (4) aligned;
      416 
      417       if ccl_p_ci_layout ^= BASIC_CI_LAYOUT_1
      418       then call sub_err_ (error_table_$unimplemented_version, myname,
      419 	      ACTION_CANT_RESTART, null, 0,
      420 	      "^/Expected a version ^a control interval. Received version ^a instead."
      421 	      , BASIC_CI_LAYOUT_1, ccl_p_ci_layout);
      422 
      423    end CHECK_CI_LAYOUT;
      424 
      425 GET_CI_PTR:
      426    proc (gcp_p_this_is_initial_ci, gcp_p_foid, gcp_p_collection_id,
      427         gcp_p_ci_id, gcp_p_ci_ptr);
      428 
      429       dcl	    gcp_p_this_is_initial_ci
      430 			       bit (1) aligned;
      431       dcl	    gcp_p_foid	       bit (36) aligned;
      432       dcl	    gcp_p_collection_id    bit (36) aligned;
      433       dcl	    gcp_p_ci_id	       fixed bin (24) unsigned;
      434       dcl	    gcp_p_ci_ptr	       ptr;
      435 
      436       if gcp_p_this_is_initial_ci = THIS_IS_FIRST_CI_SEEN
      437       then
      438          do;
      439 	  if gcp_p_ci_ptr = null ()
      440 	  then gcp_p_ci_ptr = REALLY_GET_CI_PTR (gcp_p_this_is_initial_ci);
      441 	  else /* gcp_p_ci_ptr = gcp_p_ci_ptr */
      442 	       ;
      443          end;
      444       else
      445          do;
      446 	  if gcp_p_ci_ptr = null
      447 	  then call sub_err_ (dm_error_$programming_error, myname,
      448 		  ACTION_CANT_RESTART, null (), 0, "^/^a ^d ^a,^/^a",
      449 		  "Control interval", gcp_p_ci_id,
      450 		  "was not the first one examined",
      451 		  "yet there is no previous control interval.");
      452 	  else gcp_p_ci_ptr = REALLY_GET_CI_PTR (gcp_p_this_is_initial_ci);
      453          end;
      454 
      455       call CHECK_CI_LAYOUT ((gcp_p_ci_ptr -> bci_header.layout_type));
      456 
      457       if gcp_p_ci_ptr -> bci_header.collection_id ^= gcp_p_collection_id
      458       then if gcp_p_this_is_initial_ci
      459 	 then call ERROR_RETURN (dm_error_$ci_not_in_collection);
      460 	 else call sub_err_ (dm_error_$programming_error, myname,
      461 		 ACTION_CANT_RESTART, null, 0,
      462 		 "^/^a ^d ^a ^3bo ^a^/^a ^3bo.", "Control interval",
      463 		 gcp_p_ci_id, "is in collection",
      464 		 gcp_p_ci_ptr -> bci_header.collection_id,
      465 		 "but was expected to", "be in collection",
      466 		 gcp_p_collection_id);
      467       else return;
      468 
      469 REALLY_GET_CI_PTR:
      470    proc (rgcp_p_is_initial_ci) returns (ptr);
      471 
      472       dcl	    rgcp_p_is_initial_ci   bit (1) aligned;
      473       dcl	    rgcp_ci_ptr	       ptr init (null ());
      474       dcl	    rgcp_code	       fixed bin (35) init (0);
      475 
      476       call file_manager_$get_ci_ptr (gcp_p_foid, (gcp_p_ci_id), rgcp_ci_ptr,
      477 	 rgcp_code);
      478       if rgcp_code ^= 0
      479       then if rgcp_code ^= dm_error_$ci_not_allocated
      480 	 then call ERROR_RETURN (rgcp_code);
      481 	 else if rgcp_p_is_initial_ci = THIS_IS_FIRST_CI_SEEN
      482 	 then call ERROR_RETURN (dm_error_$no_element);	/* First datum of element. */
      483 						/* No CI means no element. */
      484 	 else
      485 	    do;					/* Is a continuation datum. */
      486 						/* No CI means improperly formed continued datum. */
      487 	       call sub_err_ (rgcp_code, myname, ACTION_CANT_RESTART, null,
      488 		  0,
      489 		  "^/Control interval ^d was expected to hold the continuation of ^/the datum at slot ^d of control interval ^d."
      490 		  , gcp_p_ci_id, continued_datum_id.index,
      491 		  continued_datum_id.control_interval_id);
      492 	    end;
      493       else return (rgcp_ci_ptr);
      494 
      495 
      496    end REALLY_GET_CI_PTR;
      497 
      498    end GET_CI_PTR;
      499 
      500 MULTI_DATUM_GET:
      501    proc ();
      502 
      503 
      504       /*** The datum is by definition a "continued" datum, described by the
      505*        continued_datum structure.  Set a pointer to the beginning of that structure,
      506*        extract header information and datum contents from it. */
      507 
      508       datum_ptr = addcharno (ci_ptr, datum_slot.offset_in_bytes);
      509 						/* Points to beginning of continued_datum. */
      510       datum_contents_length_in_bits =
      511 	 datum_slot.length_in_bits - CD_DATUM_HEADER_LENGTH_IN_BITS;
      512       datum_contents_ptr = addr (continued_datum.contents);
      513       datum_contents_length_in_bytes =
      514 	 divide (datum_contents_length_in_bits + BITS_PER_BYTE - 1,
      515 	 BITS_PER_BYTE, 17, 0);
      516 
      517       element_length_in_bits = continued_datum.header.full_length;
      518 						/* Full length of element. */
      519       element_length_in_bytes =
      520 	 divide (element_length_in_bits + BITS_PER_BYTE - 1, BITS_PER_BYTE,
      521 	 35, 0);
      522 
      523       if element_length_in_bytes * BITS_PER_BYTE > buffer_length_in_bits
      524 						/* element_length_in_bytes * BITS_PER_BYTE is used in this        */
      525 						/* test instead of datum_slot.length_in_bits because the buffer   */
      526 						/* must be large enough to fit the contents when copied in bytes. */
      527       then
      528 MG_ALLOC_BUFFER:
      529          do;					/* Buffer is too small. Try allocating a buffer in the work area. */
      530 	  work_area_ptr = p_area_ptr;
      531 	  if work_area_ptr = null
      532 	  then
      533 	     do;
      534 	        p_element_length = element_length_in_bytes * BITS_PER_BYTE;
      535 						/* Not the actual length of the element, but the minimum size a  */
      536 						/* buffer must be to hold the element. */
      537 	        call ERROR_RETURN (dm_error_$long_return_element);
      538 	     end;
      539 	  else
      540 	     do;					/* Allocate the buffer. */
      541 	        buffer_length_in_double_words =
      542 		   divide (element_length_in_bytes, BYTES_PER_DOUBLE_WORD,
      543 		   17, 0) + 1;
      544 	        on cleanup call FINISH ();
      545 	        alloc buffer in (work_area);
      546 	        p_new_buffer_was_allocated = "1"b;
      547 	     end;
      548          end MG_ALLOC_BUFFER;
      549 
      550       if datum_contents_length_in_bytes <= 0
      551       then
      552          do;
      553 	  current_buffer_ptr = buffer_ptr;
      554 	  remaining_element_length_in_bytes = element_length_in_bytes;
      555          end;
      556       else
      557          do;
      558 	  buffer_ptr -> datum_contents_string =
      559 	       datum_contents_ptr -> datum_contents_string;
      560 	  current_buffer_ptr =
      561 	       addcharno (buffer_ptr, datum_contents_length_in_bytes);
      562 	  remaining_element_length_in_bytes =
      563 	       element_length_in_bytes - datum_contents_length_in_bytes;
      564 						/* This is to indicate how much is left to be gotten. */
      565          end;
      566 
      567       continued_datum_id_string = element_id_string;	/* datum id of the continued datum, i.e., the the datum most recently */
      568 						/* copied.  The element is continued in another datum. */
      569       cd_datum_header = continued_datum.header;
      570 
      571       continuation_datum_id = cd_datum_header.continuation; /* datum id of the datum which is the continuation of the continued datum. */
      572 
      573 GET_EACH_DATUM_LOOP:
      574       do while (continuation_datum_id_string ^= "0"b
      575 	 & remaining_element_length_in_bytes > 0);
      576 
      577          call GET_CI_PTR (THIS_IS_NOT_FIRST_CI_SEEN, file_opening_id,
      578 	    collection_id, (continuation_datum_id.control_interval_id),
      579 	    ci_ptr);
      580 
      581          if continuation_datum_id.index
      582 	    > ci_ptr -> basic_control_interval.header.number_of_datums
      583          then call sub_err_ (dm_error_$programming_error, myname,
      584 	         ACTION_CANT_RESTART, null, 0,
      585 	         "^/There is no datum at slot ^d of control interval ^d.  A continuation^/of the datum at slot ^d of control interval ^d was expected to be there."
      586 	         , continuation_datum_id.index,
      587 	         continuation_datum_id.control_interval_id,
      588 	         continued_datum_id.index,
      589 	         continued_datum_id.control_interval_id);
      590 
      591          datum_slot_ptr =
      592 	    addr (ci_ptr
      593 	    -> basic_control_interval
      594 	    .datum_position_table (continuation_datum_id.index));
      595          datum_ptr = addcharno (ci_ptr, datum_slot.offset_in_bytes);
      596          if datum_slot.is_continued
      597          then
      598 	  do;
      599 	     datum_contents_length_in_bits =
      600 		datum_slot.length_in_bits
      601 		- length (unspec (continued_continuation_datum.header));
      602 	     datum_contents_length_in_bytes =
      603 		divide (datum_contents_length_in_bits + BITS_PER_BYTE - 1,
      604 		BITS_PER_BYTE, 17, 0);
      605 	     datum_contents_ptr =
      606 		addr (continued_continuation_datum.contents);
      607 
      608 	     continued_datum_id_string = continuation_datum_id_string;
      609 	     continuation_datum_id =
      610 		continued_continuation_datum.header.continuation;
      611 	  end;
      612          else
      613 	  do;
      614 	     datum_contents_length_in_bytes =
      615 		divide (datum_slot.length_in_bits + BITS_PER_BYTE - 1,
      616 		BITS_PER_BYTE, 17, 0);
      617 	     datum_contents_ptr = addr (continuation_datum.contents);
      618 	     continuation_datum_id_string = "0"b;
      619 	  end;
      620 
      621          current_buffer_ptr -> datum_contents_string =
      622 	    datum_contents_ptr -> datum_contents_string;
      623 
      624          current_buffer_ptr =
      625 	    addcharno (current_buffer_ptr, datum_contents_length_in_bytes);
      626 
      627          remaining_element_length_in_bytes =
      628 	    remaining_element_length_in_bytes
      629 	    - datum_contents_length_in_bytes;
      630 
      631       end GET_EACH_DATUM_LOOP;
      632 
      633       if remaining_element_length_in_bytes > 0
      634       then call sub_err_ (dm_error_$programming_error, myname,
      635 	      ACTION_CANT_RESTART, null, 0,
      636 	      "^/The length of the element at slot ^d of control interval ^d is^/recorded as ^d bits.  The actual length is ^d bits."
      637 	      , element_id.index, element_id.control_interval_id,
      638 	      element_length_in_bits,
      639 	      (element_length_in_bits
      640 	      - remaining_element_length_in_bytes * BITS_PER_BYTE));
      641 
      642       p_element_ptr = buffer_ptr;
      643       p_element_length = cd_datum_header.full_length;
      644 
      645    end MULTI_DATUM_GET;
      646 
  1     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*        The collection_manager_ manages the structure of the addressable
  1     6*   portion of a control interval.  The addressable portion is that portion of
  1     7*   a control interval which the file_manager_ will allow the
  1     8*   collection_manager_ to address.  In this description control interval will
  1     9*   be used to mean the addressable portion of a control interval.
  1    10*   
  1    11*        A control interval is divided into four parts: the header, the datum
  1    12*   position table (also known as the slot table or slots), un-used space and
  1    13*   used space.  The beginning of the header is at offset 0, and the end of the
  1    14*   used space is at the end of the control interval (curently offset 4072).
  1    15*   Pictoriarly, a control interval is structured as follows:
  1    16*   
  1    17*   ----------------------------------------------------------------------
  1    18*   |        || | | | | | ||               ||   | / / |       |/|   |    |
  1    19*   | Header || | slot  | || un-used space ||   |/ / /|       |/|   |    |
  1    20*   |        || | table | ||               ||   | / / |       |/|   |    |
  1    21*   |        || | | | | | ||               ||   |/ / /|       |/|   |    |
  1    22*   ----------------------------------------------------------------------
  1    23*                                           ^ ^    ^      ^    ^  ^   ^
  1    24*                                           | |    |      |    |  |   |
  1    25*                                           | |...........|.......|...|
  1    26*                        start of used space|      |           |      |
  1    27*                                                  |           |  each|
  1    28*                                          scattered free space|  is a used
  1    29*                                                                 datum
  1    30*   
  1    31*      The basic_control_interval structure describes the header
  1    32*   (basic_control_interval.header, bci_header) and the slots
  1    33*   (basic_control_interval.datum_position_table, datum_slot for one only).
  1    34*   Each datum_slot contains the offset (in bytes) and the length (in bits) of
  1    35*   a datum in the used space.  If the offset is equal to FREE_SLOT (declared
  1    36*   in dm_cm_basic_ci_const.incl.pl1), the slot is un-used.  The slot also
  1    37*   contains flags describing the type of datum (see dm_cm_datum.incl.pl1).
  1    38**/
  1    39 
  1    40 /* HISTORY:
  1    41*Written by Matthew Pierret, 02/07/82.
  1    42*Modified:
  1    43*03/25/82 by Matthew Pierret: Fixed alignment differences basic_control_interval
  1    44*            and its sub-structures.
  1    45*06/14/82 by Matthew Pierret: Removed common header and buffers. Changed
  1    46*            basic_ci_header to bci_header. Added previous_control_interval.
  1    47*07/12/82 by Matthew Pierret: Changed collection_id to be bit (36) aligned.
  1    48*10/29/82 by Matthew Pierret: Added flags to datum slots. 
  1    49*11/10/82 by Matthew Pierret: Removed continued_datum_is_present flag, as it
  1    50*            is not used.
  1    51*03/28/84 by Matthew Pierret: Added the constants BCI_HEADER_LENGTH_IN_BYTES
  1    52*            and DATUM_POSITION_TABLE_OFFSET_IN_BYTES.
  1    53**/
  1    54 
  1    55 /* format: style2 */
  1    56      dcl	   1 basic_control_interval
  1    57 			      aligned based (basic_control_interval_ptr),
  1    58 	     2 header	      like bci_header,
  1    59 	     2 datum_position_table
  1    60 			      (0 refer (basic_control_interval.number_of_datums)) like datum_slot;
  1    61 
  1    62 
  1    63      dcl	   1 bci_header	      aligned based (bci_header_ptr),
  1    64 	     2 layout_type	      char (4) aligned,
  1    65 	     2 collection_id      bit (36) aligned,
  1    66 	     2 next_control_interval
  1    67 			      fixed bin (24) uns unal,
  1    68 	     2 previous_control_interval
  1    69 			      fixed bin (24) uns unal,
  1    70 	     2 flags	      unal,
  1    71 	       3 continuation_datum_is_present
  1    72 			      bit (1) unal,
  1    73 	       3 free_slot_is_present
  1    74 			      bit (1) unal,
  1    75 	       3 must_be_zero     bit (4) unal,		/* reserved */
  1    76 	     2 scattered_free_space
  1    77 			      fixed bin (17) unal,
  1    78 	     2 start_of_used_space
  1    79 			      fixed bin (17) unal,
  1    80 	     2 number_of_datums   fixed bin (17) unal;
  1    81 
  1    82      dcl	   1 datum_slot	      aligned based (datum_slot_ptr),
  1    83 	     2 flags	      unal,
  1    84 	       3 special_format_datum
  1    85 			      bit (1) unal,		/* reserved */
  1    86 	       3 is_continued     bit (1) unal,
  1    87 	       3 is_continuation  bit (1) unal,
  1    88 	       3 mbz	      bit (1) unal,		/* reserved */
  1    89 	     2 offset_in_bytes    fixed bin (15) uns unal,
  1    90 	     2 length_in_bits     fixed bin (17) uns unal;
  1    91 
  1    92      dcl	   basic_control_interval_ptr
  1    93 			      ptr;
  1    94      dcl	   bci_header_ptr	      ptr;
  1    95      dcl	   datum_slot_ptr	      ptr;
  1    96 
  1    97      dcl	   BASIC_CI_LAYOUT_1      char (4) aligned init ("bci1") internal static options (constant);
  1    98 
  1    99 /* END INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
      647 
      648 
  2     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci_const.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*   Contains constants useful in describing parts of a basic control interval.
  2     6**/
  2     7 
  2     8 /* HISTORY:
  2     9*Written by Matthew Pierret, 09/20/84.
  2    10*Modified:
  2    11**/
  2    12 
  2    13      dcl	   FREE_SLOT	      init (0) fixed bin (15) uns internal static options (constant);
  2    14      dcl	   BCI_HEADER_LENGTH_IN_BYTES
  2    15 			      init (20) fixed bin internal static options (constant);
  2    16      dcl	   DATUM_POSITION_TABLE_OFFSET_IN_BYTES
  2    17 			      init (20) fixed bin internal static options (constant);
  2    18 
  2    19 
  2    20 /* END INCLUDE FILE dm_cm_basic_ci_const.incl.pl1 */
      649 
      650 
  3     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*
  3     5*        Contains the declaration of an element identifier.  Element
  3     6*   identifiers consist of two parts, the id (number) of the control interval
  3     7*   in which the element resides, and the index into the slot table of
  3     8*   the element in the control interval.  The declaration of the element_id 
  3     9*   structure reflects this division of the element identifier.  The structure 
  3    10*   is based on the automatic bit string element_id_string because programs
  3    11*   generally pass bit strings (element_id_string) to each other, then 
  3    12*   interpret the bit string by overlaying the element_id structure ony if
  3    13*   it is necessary to access the parts of the id.  Basing element_id on
  3    14*   addr(element_id_string) instead of on a pointer removes the necessity
  3    15*   for always setting that pointer explicitly and guarantees that changes
  3    16*   made to the string or structure do not get inconsistent.
  3    17*
  3    18*   Changes made to element_id must also be made to datum_id, declared in 
  3    19*   dm_cm_datum.incl.pl1.
  3    20**/
  3    21 
  3    22 /* HISTORY:
  3    23*Written by Matthew Pierret, 04/01/82.
  3    24*Modified:
  3    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  3    26**/
  3    27 
  3    28 /* format: style2,ind3,ll79 */
  3    29 
  3    30      dcl	   element_id_string      bit (36) aligned;
  3    31 
  3    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  3    33 	     2 control_interval_id
  3    34 			      fixed bin (24) unal unsigned,
  3    35 	     2 index	      fixed bin (12) unal unsigned;
  3    36 
  3    37 
  3    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      651 
      652 
  4     1 /* BEGIN INCLUDE FILE dm_cm_datum.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*        This include file contains the declarations of datum structures.
  4     5*   There are four tyes of datums: your ordinary, run-of-the-mill datum
  4     6*   (Datum); a continuation datum (CN Datum), which is a continuation of
  4     7*   another datum; a continued datum (CD Datum), which is continued (has a
  4     8*   continuation datum) but is not a continuation itself; and a continued
  4     9*   continuation datum (CDCN Datum), which is both continued and is a
  4    10*   continuation.  To illustrate, datums can be pieced combined in the
  4    11*   following ways:
  4    12*   
  4    13*   1) Datum alone.
  4    14*   
  4    15*   2) CD Datum -> CN Datum.
  4    16*   
  4    17*   3) CD Datum -> CDCN Datum {-> CDCN Datum -> ...-> CDCN Datum} -> CN Datum.
  4    18*
  4    19*   continued_datum and continued_continuation_datum each contains a header
  4    20*   which includes the identifier of the datum which is its continuation.
  4    21*   continued_datum.header.full_length is the length in bits of the entire
  4    22*   element, i.e., the addition of the length of contents structure component
  4    23*   of all of the datums from CD Datum to CN Datum.
  4    24**/
  4    25 
  4    26 /* HISTORY:
  4    27*Written by Matthew Pierret, 02/07/82.
  4    28*Modified:
  4    29*03/25/82 by Matthew Pierret: Changed all datum structures to be unaligned.
  4    30*06/14/82 by Matthew Pierret: Added DATUM_HEADER_LENGTH_IN_BYTES.
  4    31*08/04/82 by Matthew Pierret: Added DATUM_HEADER_LENGTH_IN_BITS.
  4    32*10/20/82 by Matthew Pierret:  Split into two include files, this one and
  4    33*            dm_cm_datum_constants.  The latter holds only and all constants
  4    34*            formerly in this include file.
  4    35*10/29/82 by Matthew Pierret:  Removed datum headers.
  4    36*09/18/84 by Matthew Pierret:  Added DESCRIPTION section.  Added datum and
  4    37*            continuation_datum (mainly for illustration).
  4    38*12/03/84 by Matthew Pierret:  Removed the non-based structures
  4    39*            (cd cdcn)_datum_headers.
  4    40**/
  4    41 
  4    42 /* format: style2,ll79,ind3 */
  4    43 
  4    44      dcl	   1 datum	      unaligned based (datum_ptr),
  4    45 	     2 contents	      bit (datum_contents_length_in_bits);
  4    46 
  4    47      dcl	   1 continuation_datum   unaligned based (datum_ptr),
  4    48 	     2 contents	      bit (datum_contents_length_in_bits);
  4    49 
  4    50      dcl	   1 continued_datum      unaligned based (datum_ptr),
  4    51 	     2 header,
  4    52 	       3 full_length      fixed bin (35),
  4    53 	       3 continuation     like datum_id,
  4    54 	     2 contents	      bit (datum_contents_length_in_bits);
  4    55 
  4    56      dcl	   1 continued_continuation_datum
  4    57 			      unaligned based (datum_ptr),
  4    58 	     2 header,
  4    59 	       3 continuation     like datum_id,
  4    60 	     2 contents	      bit (datum_contents_length_in_bits);
  4    61 
  4    62      dcl	   1 datum_id	      aligned based (datum_id_ptr),
  4    63 	     2 control_interval_id
  4    64 			      fixed bin (24) unal uns,
  4    65 	     2 index	      fixed bin (12) unal uns;
  4    66 
  4    67      dcl	   datum_ptr	      ptr init (null ());
  4    68      dcl	   datum_id_ptr	      ptr init (null ());
  4    69      dcl	   datum_contents_length_in_bits
  4    70 			      fixed bin (35) init (-1);
  4    71 
  4    72 
  4    73 
  4    74 /* END INCLUDE FILE dm_cm_datum.incl.pl1 */
      653 
      654 
  5     1 /* BEGIN INCLUDE FILE dm_cm_datum_constants.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*        Contains constants describing the extents of datums and datum
  5     5*   headers.  The datum headers are described in dm_cm_datum.incl.pl1.
  5     6*   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES is the byte length of the largest
  5     7*   datum that can be stored in a control interval, allowing for the largest
  5     8*   possibledatum header. MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS is the same
  5     9*   in bits instead of bytes.  MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
  5    10*   is the smallest length in bits which requires 
  5    11*   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES bytes to store.
  5    12**/
  5    13 
  5    14 /*
  5    15*HISTORY:
  5    16*Written by Matthew Pierret, 02/07/82.
  5    17*Modified:
  5    18*10/29/82 by Matthew Pierret:  Removed DATUM_HEADER*.
  5    19*11/02/82 by Matthew Pierret:  Added maximum datum contents lengths.
  5    20*12/01/82 by Lindsey Spratt:   Corrected values for datum header lengths.
  5    21*09/18/84 by Matthew Pierret:  Corrected values for maximum lengths. Added
  5    22*            MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS.  Added
  5    23*            DESCRIPTION section.
  5    24**/
  5    25 
  5    26 /* format: style2,ind3,ll79 */
  5    27      dcl	   CD_DATUM_HEADER_LENGTH_IN_BYTES
  5    28 			      fixed bin init (8) internal static
  5    29 			      options (constant);
  5    30 
  5    31      dcl	   CD_DATUM_HEADER_LENGTH_IN_BITS
  5    32 			      fixed bin init (72) internal static
  5    33 			      options (constant);
  5    34 
  5    35      dcl	   CDCN_DATUM_HEADER_LENGTH_IN_BYTES
  5    36 			      init (4) fixed bin int static
  5    37 			      options (constant);
  5    38 
  5    39      dcl	   CDCN_DATUM_HEADER_LENGTH_IN_BITS
  5    40 			      init (36) fixed bin int static
  5    41 			      options (constant);
  5    42 
  5    43      dcl	   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
  5    44 			      init (36360) fixed bin (35) internal
  5    45 			      static options (constant);
  5    46 
  5    47      dcl	   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES
  5    48 			      init (4040) fixed bin (35) internal
  5    49 			      static options (constant);
  5    50 
  5    51      dcl	   MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
  5    52 			      init (36352) fixed bin (35) internal
  5    53 			      static options (constant);
  5    54 
  5    55 /* END INCLUDE FILE dm_cm_datum.incl.pl1 */
      655 
      656 
  6     1 /* BEGIN INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*
  6     5*   Contains entry declarations of internally available collection_manager_
  6     6*   entries.  Entries which are only available via the collection_manager_
  6     7*   transfer vector are not included here, but are declared instead in 
  6     8*   dm_collmgr_entry_dcls.incl.pl1.
  6     9**/
  6    10 
  6    11 /* HISTORY:
  6    12*Written by Mathew Pierret, 04/01/82.
  6    13*Modified:
  6    14*09/21/82 by Lindsey Spratt:  Added the cm_compact$replacement entry.
  6    15*10/29/82 by Matthew Pierret:  Added cm_find_free_slot, cm_determine_free_space,
  6    16*            cm_find_ci_to_alloc_datum, cm_recursive_put.
  6    17*            Added cm_get_element$info*, $header*.  The former is used when
  6    18*            the caller has a cm_info structure already; the latter is used to
  6    19*            get collection headers.
  6    20*            Added cm_opening_info$get. Removed cm_add_ci_(part thread).
  6    21*            Added cm_allocate_element$info.
  6    22*11/09/82 by Matthew Pierret:  Added argument to cm_allocate_ordered_element
  6    23*            calling sequence for returning free space.
  6    24*            Added cm_free_cn_datum("" $header).
  6    25*01/07/83 by Matthew Pierret:  Added:
  6    26*            cm_allocate_element$buffered("" _info);
  6    27*            cm_put_element$buffered("" _info);
  6    28*            cm_put_datum_in_place$buffered("" _continued);
  6    29*            cm_put_datum_in_pool$buffered("" _continued);
  6    30*            cm_compact$buffered.
  6    31*01/26/83 by Matthew Pierret: Replaced cm_get_header_and_slot with
  6    32*            cm_get_bci_header$slot and added cm_get_bci_header$slot_exclusive.
  6    33*            Added cm_opening_info$get_storage_record.
  6    34*            Added a bit(36)aligned argument to cm_recursive_put to hold the
  6    35*            id of the previous datum.
  6    36*02/02/83 by Matthew Pierret: Added fixed bin (17) argument to cm_find_free_slot
  6    37*            which is for the number of slots after allocation.
  6    38*02/07/83 by Matthew Pierret: Added cm_get_id$(id info info_return_slot
  6    39*            header header_return_slot).
  6    40*            Added cm_get_element_portion$(exclusive info info_exclusive).
  6    41*            Added cm_get_element$bypass_info.
  6    42*03/25/83 by Matthew Pierret: Added cm_free_element$info and
  6    43*            cm_free_opening_info.
  6    44*04/29/83 by Matthew Pierret: Added cm_put_element$unprotected_info
  6    45*08/04/83 by Matthew Pierret:  Added the entries $does_new_datum_fit and
  6    46*            $does_replacement_fit to cm_determine_free_space.  These entries
  6    47*            return flags indicating if a datum fits in the ci and the pool.
  6    48*            Added a bit(1)aligned parameter to cm_find_free_slot in which is
  6    49*            returned the new value of bci_header.free_slot_is_present.
  6    50*02/07/84 by Matthew Pierret:  Added cm_get_id$ptr.  Removed all cm_get_id
  6    51*            modules except cm_get_id$id.  Removed all cm_get_element$info*
  6    52*            entries.  Changed cm_get_element_$bypass_info to have the same
  6    53*            calling sequence as other cm_get_element entries.
  6    54*06/12/84 by Matthew Pierret:  Changed cm_put_element to cm_modify
  6    55*            and cm_allocate_element to cm_put.
  6    56*            Switched the element_length/element_ptr parameter pair to be
  6    57*            element_ptr/element_length in cm_modify and cm_put.
  6    58*07/24/84 by Matthew Pierret:  Added cm_free_ci$raw_return_prev_next.
  6    59*09/24/84 by Matthew Pierret:  Added trace_thread_modifications_(on off)
  6    60*            entries to cm_free_ci and cm_replace_buffered_ci, 
  6    61*            cm_allocate_ci$info_header, cm_opening_info$opening_table_ptr.
  6    62*            Removed cm_find_free_space. Commented out un-used entries.
  6    63*            Re-named allocate  entries to put entries, except for allocate_ci.
  6    64*            Re-named free element and free datum entries to use delete instead
  6    65*            of free, and cm_recursive_put to cm_recursive_modify.
  6    66*            Removed cm_get_element$bypass_info.
  6    67*02/27/85 by Matthew C. Pierret:  Re-added cm_compact$buffered_replacement now
  6    68*            that cm_modify$buffered uses it.
  6    69*03/07/85 by R. Michael Tague:  Added cm_postcommit_increment.
  6    70**/
  6    71 
  6    72 /* format: style2,ind3 */
  6    73 
  6    74 
  6    75      dcl	   cm_allocate_ci	      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  6    76      dcl	   cm_allocate_ci$info    entry (ptr, fixed bin (24) unsigned, fixed bin (35));
  6    77      dcl	   cm_allocate_ci$info_header
  6    78 			      entry (ptr, fixed bin (24) unsigned, ptr, fixed bin (35));
  6    79 
  6    80 
  6    81      dcl	   cm_compact	      entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
  6    82      dcl	   cm_compact$buffered    entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
  6    83      dcl	   cm_compact$replacement entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
  6    84      dcl	   cm_compact$buffered_replacement
  6    85 			      entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
  6    86 
  6    87      dcl	   cm_delete_cn_datum     entry (ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
  6    88 
  6    89      dcl	   cm_delete_cn_datum$header
  6    90 			      entry (ptr, ptr, ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
  6    91 
  6    92      dcl	   cm_delete	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  6    93 			      fixed bin (35));
  6    94      dcl	   cm_delete$info	      entry (ptr, bit (36) aligned, bit (1) aligned, fixed bin (35));
  6    95 
  6    96      dcl	   cm_determine_free_space$all
  6    97 			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35));
  6    98      dcl	   cm_determine_free_space$effective
  6    99 			      entry (ptr, fixed bin (35), bit (1) aligned, bit (1) aligned, fixed bin (35),
  6   100 			      fixed bin (35));
  6   101      dcl	   cm_determine_free_space$does_new_datum_fit
  6   102 			      entry (ptr, fixed bin (35), fixed bin (35), bit (1) aligned, bit (1) aligned,
  6   103 			      bit (1) aligned, bit (1) aligned, fixed bin (35));
  6   104 
  6   105 /**** Not yet used *********************************************************
  6   106*     dcl	   cm_determine_free_space$does_replacement_fit
  6   107*			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35), bit (1) aligned,
  6   108*			      bit (1) aligned, bit (1) aligned, bit (1) aligned, fixed bin (35)); 
  6   109*************************************************************************** */
  6   110 
  6   111      dcl	   cm_find_ci_to_alloc_datum
  6   112 			      entry (ptr, fixed bin (35), fixed bin (24) uns, bit (1) aligned, bit (1) aligned, ptr,
  6   113 			      fixed bin (24) uns, fixed bin (35));
  6   114 
  6   115      dcl	   cm_find_free_slot      entry (bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (17), fixed bin (17),
  6   116 			      bit (1) aligned, fixed bin (35));
  6   117 
  6   118      dcl	   cm_free_ci$info	      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (35));
  6   119      dcl	   cm_free_ci$raw_return_prev_next
  6   120 			      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (24) uns,
  6   121 			      fixed bin (24) uns, fixed bin (35));
  6   122      dcl	   cm_free_ci$trace_thread_modifications_on
  6   123 			      entry ();
  6   124      dcl	   cm_free_ci$trace_thread_modifications_off
  6   125 			      entry ();
  6   126 
  6   127 
  6   128      dcl	   cm_free_opening_info   entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  6   129 
  6   130      dcl	   cm_get_bci_header      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
  6   131      dcl	   cm_get_bci_header$exclusive
  6   132 			      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
  6   133      dcl	   cm_get_bci_header$slot entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  6   134 
  6   135 /**** Not yet used ********************************************************
  6   136*     dcl	   cm_get_bci_header$slot_exclusive
  6   137*			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  6   138*************************************************************************** */
  6   139 
  6   140      dcl	   cm_get_element	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  6   141 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  6   142      dcl	   cm_get_element$exclusive
  6   143 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  6   144 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  6   145 
  6   146      dcl	   cm_get_element_portion entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  6   147 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  6   148 			      fixed bin (35), fixed bin (35));
  6   149 
  6   150 /**** Not yet used ********************************************************
  6   151*     dcl	   cm_get_element_portion$exclusive
  6   152*			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  6   153*			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  6   154*			      fixed bin (35), fixed bin (35));
  6   155*************************************************************************** */
  6   156 
  6   157      dcl	   cm_get_id$id	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
  6   158 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  6   159      dcl	   cm_get_id$ptr	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
  6   160 			      bit (1) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  6   161 
  6   162      dcl	   cm_modify	      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  6   163 			      fixed bin (35), fixed bin (35));
  6   164      dcl	   cm_modify$buffered     entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  6   165 			      fixed bin (35), fixed bin (35));
  6   166 
  6   167 /******* Not yet used *****************************************************
  6   168*     dcl	   cm_modify$buffered_info
  6   169*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
  6   170*			      fixed bin (35));
  6   171*****************************************************************************/
  6   172 
  6   173      dcl	   cm_modify$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  6   174      dcl	   cm_modify$unprotected_info
  6   175 			      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  6   176 
  6   177 
  6   178 /******* Not yet used *****************************************************
  6   179*     dcl	   cm_modify_portion entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35),
  6   180*			      fixed bin (35), ptr, bit (36) aligned, fixed bin (35), fixed bin (35));
  6   181*****************************************************************************/
  6   182 
  6   183 
  6   184      dcl	   cm_opening_info$get    entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  6   185      dcl	   cm_opening_info$get_storage_record
  6   186 			      entry (ptr, fixed bin (35));
  6   187      dcl	   cm_opening_info$full_get
  6   188 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  6   189      dcl	   cm_opening_info$opening_table_ptr
  6   190 			      entry () returns (ptr);
  6   191 
  6   192      dcl	   cm_postcommit_increment
  6   193 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  6   194 
  6   195      dcl	   cm_put		      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  6   196 			      fixed bin (35), fixed bin (35));
  6   197      dcl	   cm_put$buffered	      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  6   198 			      fixed bin (35), fixed bin (35));
  6   199 
  6   200 /******* Not yet used *****************************************************
  6   201*     dcl	   cm_put$buffered_info
  6   202*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
  6   203*			      fixed bin (35));
  6   204*****************************************************************************/
  6   205 
  6   206      dcl	   cm_put$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  6   207 
  6   208      dcl	   cm_put_basic_element   entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  6   209 			      fixed bin (35));
  6   210 
  6   211      dcl	   cm_put_cn_datum	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, bit (36) aligned, fixed bin (35));
  6   212 
  6   213      dcl	   cm_put_datum_in_place  entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  6   214 			      fixed bin (35));
  6   215      dcl	   cm_put_datum_in_place$buffered
  6   216 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  6   217      dcl	   cm_put_datum_in_place$buffered_continued
  6   218 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
  6   219 			      fixed bin (35));
  6   220      dcl	   cm_put_datum_in_place$continued
  6   221 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  6   222 			      fixed bin (35), bit (36) aligned, fixed bin (35));
  6   223 
  6   224      dcl	   cm_put_datum_in_pool   entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  6   225 			      fixed bin (35));
  6   226      dcl	   cm_put_datum_in_pool$buffered
  6   227 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  6   228      dcl	   cm_put_datum_in_pool$buffered_continued
  6   229 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
  6   230 			      fixed bin (35));
  6   231      dcl	   cm_put_datum_in_pool$continued
  6   232 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  6   233 			      fixed bin (35), bit (36) aligned, fixed bin (35));
  6   234 
  6   235      dcl	   cm_put_ordered_element entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  6   236 			      fixed bin (35));
  6   237      dcl	   cm_put_ordered_element$buffered
  6   238 			      entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  6   239 			      fixed bin (35));
  6   240 
  6   241      dcl	   cm_put_overlength_tail entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35));
  6   242 
  6   243      dcl	   cm_recursive_modify    entry (ptr, bit (36) aligned, ptr, fixed bin (35), fixed bin (35), bit (36) aligned,
  6   244 			      fixed bin (35));
  6   245 
  6   246 
  6   247      dcl	   cm_replace_buffered_ci$trace_thread_modifications_on
  6   248 			      entry ();
  6   249      dcl	   cm_replace_buffered_ci$trace_thread_modifications_off
  6   250 			      entry ();
  6   251 
  6   252 /* END INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
      657 
      658 
  7     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  7     2 /* format: style3 */
  7     3 
  7     4 /* These constants are to be used for the flags argument of sub_err_ */
  7     5 /* They are just "string (condition_info_header.action_flags)" */
  7     6 
  7     7 declare	(
  7     8 	ACTION_CAN_RESTART	init (""b),
  7     9 	ACTION_CANT_RESTART init ("1"b),
  7    10 	ACTION_DEFAULT_RESTART
  7    11 			init ("01"b),
  7    12 	ACTION_QUIET_RESTART
  7    13 			init ("001"b),
  7    14 	ACTION_SUPPORT_SIGNAL
  7    15 			init ("0001"b)
  7    16 	)		bit (36) aligned internal static options (constant);
  7    17 
  7    18 /* End include file */
      659 
      660 
      661    end cm_get_element;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0912.6  cm_get_element.pl1                >spec>on>7192.pbf-04/04/85>cm_get_element.pl1
647          1    01/07/85  0858.0  dm_cm_basic_ci.incl.pl1           >ldd>include>dm_cm_basic_ci.incl.pl1
649          2    01/07/85  0858.1  dm_cm_basic_ci_const.incl.pl1     >ldd>include>dm_cm_basic_ci_const.incl.pl1
651          3    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
653          4    01/07/85  0901.2  dm_cm_datum.incl.pl1              >ldd>include>dm_cm_datum.incl.pl1
655          5    01/07/85  0858.2  dm_cm_datum_constants.incl.pl1    >ldd>include>dm_cm_datum_constants.incl.pl1
657          6    04/04/85  0819.0  dm_cm_entry_dcls.incl.pl1         >spec>on>7192.pbf-04/04/85>dm_cm_entry_dcls.incl.pl1
659          7    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000033 constant        bit(36)                  initial dcl 7-7 set ref 417* 446* 460* 487* 581*
                                                                                  633*
BASIC_CI_LAYOUT_1               000000 constant        char(4)                  initial dcl 1-97 set ref 417 417*
BITS_PER_BYTE                   002450 constant        fixed bin(17,0)          initial dcl 208 ref 339 339 343 355 513 513 519 519
                                                                                  523 534 602 602 614 614 633
BYTES_PER_DOUBLE_WORD                  constant        fixed bin(17,0)          initial dcl 208 ref 363 541
CD_DATUM_HEADER_LENGTH_IN_BITS         constant        fixed bin(17,0)          initial dcl 5-31 ref 510
FREE_SLOT                              constant        fixed bin(15,0)          initial unsigned dcl 2-13 ref 320
THIS_IS_FIRST_CI_SEEN           000033 constant        bit(1)                   initial dcl 212 set ref 287* 436 481
THIS_IS_NOT_FIRST_CI_SEEN       000034 constant        bit(1)                   initial dcl 212 set ref 577*
addcharno                                              builtin function         dcl 196 ref 337 508 560 595 624
addr                                                   builtin function         dcl 196 ref 285 287 289 313 313 487 487 512 571 577
                                                                                  581 581 581 581 581 591 591 605 609 617 633 633
basic_control_interval                 based           structure                level 1 dcl 1-56
bci_header                             based           structure                level 1 dcl 1-63
buffer                                 based           fixed bin(71,0)          array dcl 189 ref 367 397 545
buffer_length_in_bits           000105 automatic       fixed bin(35,0)          initial dcl 154 set ref 154* 278* 280* 343 523
buffer_length_in_double_words   000106 automatic       fixed bin(17,0)          initial dcl 155 set ref 155* 363* 367 397 541* 545
buffer_ptr                      000122 automatic       pointer                  initial dcl 174 set ref 174* 276* 278 367* 374 377
                                                                                  393 393 397 545* 553 558 560 642
ccl_p_ci_layout                        parameter       char(4)                  dcl 415 set ref 413 417 417*
cd_datum_header                 000130 automatic       structure                level 1 dcl 178 set ref 569*
ci_ptr                          000116 automatic       pointer                  initial dcl 172 set ref 172* 243* 254* 267* 287* 289
                                                                                  295* 295* 308 313 337 508 577* 581 591 595
cleanup                         000132 stack reference condition                dcl 201 ref 366 544
cm_get_id$ptr                   000030 constant        entry                    external dcl 6-159 ref 295
code                            000104 automatic       fixed bin(35,0)          initial dcl 153 set ref 153* 295* 299 299*
collection_id             1            based           bit(36)                  level 2 in structure "bci_header" dcl 1-63
                                                                                  in procedure "cm_get_element" set ref 457 460*
collection_id                   000101 automatic       bit(36)                  dcl 148 in procedure "cm_get_element" set ref 274*
                                                                                  287* 295* 577*
contents                  2            based           bit                      level 2 in structure "continued_datum" packed
                                                                                  unaligned dcl 4-50 in procedure "cm_get_element"
                                                                                  set ref 512
contents                               based           bit                      level 2 in structure "continuation_datum" packed
                                                                                  unaligned dcl 4-47 in procedure "cm_get_element"
                                                                                  set ref 617
contents                  1            based           bit                      level 2 in structure "continued_continuation_datum"
                                                                                  packed unaligned dcl 4-56 in procedure
                                                                                  "cm_get_element" set ref 605
continuation              1     000130 automatic       structure                level 2 in structure "cd_datum_header" dcl 178
                                                                                  in procedure "cm_get_element" set ref 571
continuation                           based           structure                level 3 in structure "continued_continuation_datum"
                                                                                  packed unaligned dcl 4-56 in procedure
                                                                                  "cm_get_element" ref 609
continuation_datum                     based           structure                level 1 packed unaligned dcl 4-47
continuation_datum_id                  based           structure                level 1 dcl 184 set ref 571* 609*
continuation_datum_id_string    000102 automatic       bit(36)                  initial dcl 150 set ref 150* 571 573 577 581 581 581
                                                                                  591 608 609 618*
continued_continuation_datum           based           structure                level 1 packed unaligned dcl 4-56
continued_datum                        based           structure                level 1 packed unaligned dcl 4-50
continued_datum_id                     based           structure                level 1 dcl 182
continued_datum_id_string       000103 automatic       bit(36)                  initial dcl 150 set ref 150* 487 487 567* 581 581
                                                                                  608*
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "continuation_datum_id" packed
                                                                                  unsigned unaligned dcl 184 in procedure
                                                                                  "cm_get_element" set ref 577 581*
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "continued_datum_id" packed
                                                                                  unsigned unaligned dcl 182 in procedure
                                                                                  "cm_get_element" set ref 487* 581*
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "element_id" packed unsigned
                                                                                  unaligned dcl 3-32 in procedure "cm_get_element"
                                                                                  set ref 287 633*
current_buffer_ptr              000124 automatic       pointer                  initial dcl 175 set ref 175* 553* 560* 621 624* 624
datum_contents_length_in_bits   000150 automatic       fixed bin(35,0)          initial dcl 4-69 set ref 4-69* 510* 512 513 599* 602
                                                                                  605 617
datum_contents_length_in_bytes  000107 automatic       fixed bin(17,0)          initial dcl 157 set ref 157* 339* 343 355 363 374
                                                                                  374 513* 550 558 558 560 562 602* 614* 621 621 624
                                                                                  627
datum_contents_ptr              000126 automatic       pointer                  initial dcl 176 set ref 176* 337* 374 512* 558 605*
                                                                                  617* 621
datum_contents_string                  based           char                     unaligned dcl 191 set ref 374* 374 558* 558 621* 621
datum_id                               based           structure                level 1 dcl 4-62
datum_id_ptr                    000146 automatic       pointer                  initial dcl 4-68 set ref 4-68*
datum_position_table      5            based           structure                array level 2 dcl 1-56 set ref 313 591
datum_ptr                       000144 automatic       pointer                  initial dcl 4-67 set ref 4-67* 508* 512 517 569 595*
                                                                                  599 605 609 617
datum_slot                             based           structure                level 1 dcl 1-82
datum_slot_ptr                  000140 automatic       pointer                  dcl 1-95 set ref 313* 320 320 325 337 339 378 508
                                                                                  510 591* 595 596 599 614
divide                                                 builtin function         dcl 196 ref 339 363 513 519 541 602 614
dm_error_$ci_not_allocated      000014 external static fixed bin(35,0)          dcl 228 ref 478
dm_error_$ci_not_in_collection  000016 external static fixed bin(35,0)          dcl 228 set ref 457*
dm_error_$long_return_element   000022 external static fixed bin(35,0)          dcl 228 set ref 359* 537*
dm_error_$no_element            000020 external static fixed bin(35,0)          dcl 228 set ref 285* 289* 320* 481*
dm_error_$programming_error     000024 external static fixed bin(35,0)          dcl 228 set ref 446* 460* 581* 633*
element_id                             based           structure                level 1 dcl 3-32
element_id_string               000142 automatic       bit(36)                  dcl 3-30 set ref 275* 285 287 289 295 295 295* 313
                                                                                  384 384 567 633 633
element_length_in_bits          000110 automatic       fixed bin(35,0)          initial dcl 159 set ref 159* 517* 519 633* 633
element_length_in_bytes         000111 automatic       fixed bin(35,0)          initial dcl 160 set ref 160* 519* 523 534 541 554
                                                                                  562
er_code                                parameter       fixed bin(35,0)          dcl 405 ref 402 407
error_table_$unimplemented_version
                                000026 external static fixed bin(35,0)          dcl 235 set ref 417*
exclusive_get                   000114 automatic       bit(1)                   initial dcl 168 set ref 168* 240* 251* 264*
file_manager_$get_ci_ptr        000010 constant        entry                    external dcl 221 ref 476
file_opening_id                 000100 automatic       bit(36)                  dcl 148 set ref 273* 287* 295* 577*
flags                                  based           structure                level 2 packed unaligned dcl 1-82
full_length                            based           fixed bin(35,0)          level 3 in structure "continued_datum" packed
                                                                                  unaligned dcl 4-50 in procedure "cm_get_element"
                                                                                  ref 517
full_length                     000130 automatic       fixed bin(35,0)          level 2 in structure "cd_datum_header" dcl 178
                                                                                  in procedure "cm_get_element" set ref 643
gcp_p_ci_id                            parameter       fixed bin(24,0)          unsigned dcl 433 set ref 425 446* 460* 476 487*
gcp_p_ci_ptr                           parameter       pointer                  dcl 434 set ref 425 439 439* 446 452* 455 457 460
gcp_p_collection_id                    parameter       bit(36)                  dcl 432 set ref 425 457 460*
gcp_p_foid                             parameter       bit(36)                  dcl 431 set ref 425 476*
gcp_p_this_is_initial_ci               parameter       bit(1)                   dcl 429 set ref 425 436 439* 452* 457
header                                 based           structure                level 2 in structure "continued_continuation_datum"
                                                                                  packed unaligned dcl 4-56 in procedure
                                                                                  "cm_get_element" ref 599
header                                 based           structure                level 2 in structure "basic_control_interval"
                                                                                  dcl 1-56 in procedure "cm_get_element"
header                                 based           structure                level 2 in structure "continued_datum" packed
                                                                                  unaligned dcl 4-50 in procedure "cm_get_element"
                                                                                  ref 569
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "continuation_datum_id" packed
                                                                                  unsigned unaligned dcl 184 in procedure
                                                                                  "cm_get_element" set ref 581 581* 591
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "continued_datum_id" packed
                                                                                  unsigned unaligned dcl 182 in procedure
                                                                                  "cm_get_element" set ref 487* 581*
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "element_id" packed unsigned
                                                                                  unaligned dcl 3-32 in procedure "cm_get_element"
                                                                                  set ref 285 289 313 633*
is_continuation           0(02)        based           bit(1)                   level 3 packed unaligned dcl 1-82 ref 320
is_continued              0(01)        based           bit(1)                   level 3 packed unaligned dcl 1-82 ref 325 596
layout_type                            based           char(4)                  level 2 dcl 1-63 ref 455
length                                                 builtin function         dcl 196 ref 599
length_in_bits            0(19)        based           fixed bin(17,0)          level 2 packed unsigned unaligned dcl 1-82 ref 339
                                                                                  378 510 599 614
myname                          000001 constant        varying char(32)         initial dcl 205 set ref 417* 446* 460* 487* 581*
                                                                                  633*
null                                                   builtin function         dcl 196 ref 172 173 174 175 176 243 254 278 352 4-67
                                                                                  4-68 393 417 417 439 446 446 446 460 460 473 487
                                                                                  487 531 581 581 633 633
number_of_datums          4(18)        based           fixed bin(17,0)          level 3 packed unaligned dcl 1-56 ref 289 581
offset_in_bytes           0(04)        based           fixed bin(15,0)          level 2 packed unsigned unaligned dcl 1-82 ref 320
                                                                                  337 508 595
p_area_ptr                             parameter       pointer                  dcl 137 ref 123 246 258 351 530
p_buffer_length                        parameter       fixed bin(35,0)          dcl 136 ref 123 246 258 280
p_buffer_ptr                           parameter       pointer                  dcl 135 ref 123 246 258 276 393
p_code                                 parameter       fixed bin(35,0)          dcl 142 set ref 123 246 258 270* 407*
p_collection_id                        parameter       bit(36)                  dcl 132 ref 123 246 258 274
p_element_id                           parameter       bit(36)                  dcl 133 set ref 123 246 258 275 384 384*
p_element_length                       parameter       fixed bin(35,0)          dcl 141 set ref 123 246 258 355* 378* 534* 643*
p_element_ptr                          parameter       pointer                  dcl 140 set ref 123 246 258 377* 642*
p_file_opening_id                      parameter       bit(36)                  dcl 131 ref 123 246 258 273
p_input_ci_ptr                         parameter       pointer                  dcl 143 ref 258 267
p_new_buffer_was_allocated             parameter       bit(1)                   dcl 138 set ref 123 246 258 272* 368* 396* 546*
p_position                             parameter       fixed bin(17,0)          dcl 134 ref 123 242 246 253 258 266
p_return_ci_ptr                        parameter       pointer                  dcl 144 set ref 258 308*
position_from_specified_element 000113 automatic       fixed bin(17,0)          initial dcl 164 set ref 164* 242* 253* 266* 282 295*
remaining_element_length_in_bytes
                                000112 automatic       fixed bin(35,0)          initial dcl 162 set ref 162* 554* 562* 573 627* 627
                                                                                  633 633
return_last_used_ci_ptr         000115 automatic       bit(1)                   initial dcl 169 set ref 169* 241* 252* 265* 308
rgcp_ci_ptr                     000114 automatic       pointer                  initial dcl 473 set ref 473* 476* 493
rgcp_code                       000116 automatic       fixed bin(35,0)          initial dcl 474 set ref 474* 476* 478 478 478* 487*
rgcp_p_is_initial_ci                   parameter       bit(1)                   dcl 472 ref 469 481
sub_err_                        000012 constant        entry                    external dcl 224 ref 417 446 460 487 581 633
unspec                                                 builtin function         dcl 196 ref 599
work_area                              based           area(1024)               dcl 188 ref 367 397 545
work_area_ptr                   000120 automatic       pointer                  initial dcl 173 set ref 173* 351* 352 367 397 530*
                                                                                  531 545

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 7-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 7-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 7-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 7-7
BCI_HEADER_LENGTH_IN_BYTES             internal static fixed bin(17,0)          initial dcl 2-14
CDCN_DATUM_HEADER_LENGTH_IN_BITS       internal static fixed bin(17,0)          initial dcl 5-39
CDCN_DATUM_HEADER_LENGTH_IN_BYTES      internal static fixed bin(17,0)          initial dcl 5-35
CD_DATUM_HEADER_LENGTH_IN_BYTES        internal static fixed bin(17,0)          initial dcl 5-27
DATUM_POSITION_TABLE_OFFSET_IN_BYTES   internal static fixed bin(17,0)          initial dcl 2-16
MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS  internal static fixed bin(35,0)          initial dcl 5-43
MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES internal static fixed bin(35,0)          initial dcl 5-47
MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
                                       internal static fixed bin(35,0)          initial dcl 5-51
basic_control_interval_ptr             automatic       pointer                  dcl 1-92
bci_header_ptr                         automatic       pointer                  dcl 1-94
ceil                                                   builtin function         dcl 196
cm_allocate_ci                  000000 constant        entry                    external dcl 6-75
cm_allocate_ci$info             000000 constant        entry                    external dcl 6-76
cm_allocate_ci$info_header      000000 constant        entry                    external dcl 6-77
cm_compact                      000000 constant        entry                    external dcl 6-81
cm_compact$buffered             000000 constant        entry                    external dcl 6-82
cm_compact$buffered_replacement 000000 constant        entry                    external dcl 6-84
cm_compact$replacement          000000 constant        entry                    external dcl 6-83
cm_delete                       000000 constant        entry                    external dcl 6-92
cm_delete$info                  000000 constant        entry                    external dcl 6-94
cm_delete_cn_datum              000000 constant        entry                    external dcl 6-87
cm_delete_cn_datum$header       000000 constant        entry                    external dcl 6-89
cm_determine_free_space$all     000000 constant        entry                    external dcl 6-96
cm_determine_free_space$does_new_datum_fit
                                000000 constant        entry                    external dcl 6-101
cm_determine_free_space$effective
                                000000 constant        entry                    external dcl 6-98
cm_find_ci_to_alloc_datum       000000 constant        entry                    external dcl 6-111
cm_find_free_slot               000000 constant        entry                    external dcl 6-115
cm_free_ci$info                 000000 constant        entry                    external dcl 6-118
cm_free_ci$raw_return_prev_next 000000 constant        entry                    external dcl 6-119
cm_free_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 6-124
cm_free_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 6-122
cm_free_opening_info            000000 constant        entry                    external dcl 6-128
cm_get_bci_header               000000 constant        entry                    external dcl 6-130
cm_get_bci_header$exclusive     000000 constant        entry                    external dcl 6-131
cm_get_bci_header$slot          000000 constant        entry                    external dcl 6-133
cm_get_element                  000000 constant        entry                    external dcl 6-140
cm_get_element$exclusive        000000 constant        entry                    external dcl 6-142
cm_get_element_portion          000000 constant        entry                    external dcl 6-146
cm_get_id$id                    000000 constant        entry                    external dcl 6-157
cm_modify                       000000 constant        entry                    external dcl 6-162
cm_modify$buffered              000000 constant        entry                    external dcl 6-164
cm_modify$info                  000000 constant        entry                    external dcl 6-173
cm_modify$unprotected_info      000000 constant        entry                    external dcl 6-174
cm_opening_info$full_get        000000 constant        entry                    external dcl 6-187
cm_opening_info$get             000000 constant        entry                    external dcl 6-184
cm_opening_info$get_storage_record
                                000000 constant        entry                    external dcl 6-185
cm_opening_info$opening_table_ptr
                                000000 constant        entry                    external dcl 6-189
cm_postcommit_increment         000000 constant        entry                    external dcl 6-192
cm_put                          000000 constant        entry                    external dcl 6-195
cm_put$buffered                 000000 constant        entry                    external dcl 6-197
cm_put$info                     000000 constant        entry                    external dcl 6-206
cm_put_basic_element            000000 constant        entry                    external dcl 6-208
cm_put_cn_datum                 000000 constant        entry                    external dcl 6-211
cm_put_datum_in_place           000000 constant        entry                    external dcl 6-213
cm_put_datum_in_place$buffered  000000 constant        entry                    external dcl 6-215
cm_put_datum_in_place$buffered_continued
                                000000 constant        entry                    external dcl 6-217
cm_put_datum_in_place$continued 000000 constant        entry                    external dcl 6-220
cm_put_datum_in_pool            000000 constant        entry                    external dcl 6-224
cm_put_datum_in_pool$buffered   000000 constant        entry                    external dcl 6-226
cm_put_datum_in_pool$buffered_continued
                                000000 constant        entry                    external dcl 6-228
cm_put_datum_in_pool$continued  000000 constant        entry                    external dcl 6-231
cm_put_ordered_element          000000 constant        entry                    external dcl 6-235
cm_put_ordered_element$buffered 000000 constant        entry                    external dcl 6-237
cm_put_overlength_tail          000000 constant        entry                    external dcl 6-241
cm_recursive_modify             000000 constant        entry                    external dcl 6-243
cm_replace_buffered_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 6-249
cm_replace_buffered_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 6-247
datum                                  based           structure                level 1 packed unaligned dcl 4-44

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_CI_LAYOUT                 001140 constant        entry                    internal dcl 413 ref 455
ERROR_RETURN                    001117 constant        entry                    internal dcl 402 ref 285 289 299 320 359 457 478 481
                                                                                  537
FINISH                          001072 constant        entry                    internal dcl 390 ref 366 408 544
GET_CI_PTR                      001222 constant        entry                    internal dcl 425 ref 287 577
GET_EACH_DATUM_LOOP             002120 constant        label                    dcl 573
JOIN                            000545 constant        label                    dcl 270 ref 244 255 268
MG_ALLOC_BUFFER                 001770 constant        label                    dcl 523
MULTI_DATUM_GET                 001706 constant        entry                    internal dcl 500 ref 382
REALLY_GET_CI_PTR               001533 constant        entry                    internal dcl 469 ref 439 452
RETURN                          001070 constant        label                    dcl 387 ref 409
SG_ALLOC_BUFFER                 000762 constant        label                    dcl 343
SIMPLE_GET                      000744 constant        label                    dcl 325
by_ci_ptr                       000476 constant        entry                    external dcl 258
cm_get_element                  000354 constant        entry                    external dcl 123
exclusive                       000420 constant        entry                    external dcl 246

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2676        2730    2451        2706
Length      3304    2451        32         337     224           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cm_get_element                      172 external procedure  is an external procedure.  
on unit on line 366                  64 on unit               
FINISH                               64 internal procedure  is called by several nonquick procedures.  
ERROR_RETURN                         64 internal procedure  is called by several nonquick procedures.  
CHECK_CI_LAYOUT                         internal procedure  shares stack frame of internal procedure GET_CI_PTR.  
GET_CI_PTR                          346 internal procedure  is called by several nonquick procedures.  
REALLY_GET_CI_PTR                       internal procedure  shares stack frame of internal procedure GET_CI_PTR.  
MULTI_DATUM_GET                     174 internal procedure  enables or reverts conditions.  
on unit on line 544                  64 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
GET_CI_PTR               000114 rgcp_ci_ptr                 REALLY_GET_CI_PTR
                         000116 rgcp_code                   REALLY_GET_CI_PTR
cm_get_element           000100 file_opening_id             cm_get_element
                         000101 collection_id               cm_get_element
                         000102 continuation_datum_id_string
                                                            cm_get_element
                         000103 continued_datum_id_string   cm_get_element
                         000104 code                        cm_get_element
                         000105 buffer_length_in_bits       cm_get_element
                         000106 buffer_length_in_double_words
                                                            cm_get_element
                         000107 datum_contents_length_in_bytes
                                                            cm_get_element
                         000110 element_length_in_bits      cm_get_element
                         000111 element_length_in_bytes     cm_get_element
                         000112 remaining_element_length_in_bytes
                                                            cm_get_element
                         000113 position_from_specified_element
                                                            cm_get_element
                         000114 exclusive_get               cm_get_element
                         000115 return_last_used_ci_ptr     cm_get_element
                         000116 ci_ptr                      cm_get_element
                         000120 work_area_ptr               cm_get_element
                         000122 buffer_ptr                  cm_get_element
                         000124 current_buffer_ptr          cm_get_element
                         000126 datum_contents_ptr          cm_get_element
                         000130 cd_datum_header             cm_get_element
                         000140 datum_slot_ptr              cm_get_element
                         000142 element_id_string           cm_get_element
                         000144 datum_ptr                   cm_get_element
                         000146 datum_id_ptr                cm_get_element
                         000150 datum_contents_length_in_bits
                                                            cm_get_element

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return
tra_ext             signal              enable              ext_entry           int_entry           divide_fx3
alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cm_get_id$ptr                 file_manager_$get_ci_ptr      sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$ci_not_allocated    dm_error_$ci_not_in_collection                              dm_error_$long_return_element
dm_error_$no_element          dm_error_$programming_error   error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    150 000314       153 000316       154 000317       155 000320       157 000321       159 000322       160 000323
    162 000324       164 000325       168 000326       169 000327       172 000330       173 000332       174 000333
    175 000334       176 000335    4   67 000336    4   68 000337    4   69 000340       123 000344       240 000411
    241 000412       242 000413       244 000415       246 000416       251 000455       252 000457       253 000460
    254 000462       255 000464       258 000465       264 000533       265 000534       266 000536       267 000540
    268 000544       270 000545       272 000546       273 000547       274 000551       275 000553       276 000555
    278 000560       280 000567       282 000571       285 000573       287 000605       289 000626       292 000646
    295 000647       299 000701       308 000711       313 000716       320 000723       325 000741       337 000744
    339 000752       343 000757       351 000762       352 000765       355 000771       359 000774       360 001003
    363 001004       366 001012       367 001034       368 001042       374 001044       377 001052       378 001053
    380 001056       382 001057       384 001063       387 001070       390 001071       393 001077       396 001110
    397 001111       400 001115       402 001116       407 001124       408 001130       409 001135       413 001140
    417 001142       423 001220       425 001221       436 001227       439 001234       443 001250       446 001251
    452 001353       455 001363       457 001371       460 001413       467 001531       498 001532       469 001533
    473 001535       474 001537       476 001540       478 001560       481 001575       487 001612       492 001674
    493 001675       496 001701       500 001705       508 001713       510 001722       512 001726       513 001730
    517 001742       519 001751       523 001762       530 001770       531 001773       534 001777       537 002001
    538 002010       541 002011       544 002015       545 002037       546 002047       550 002051       553 002054
    554 002056       555 002060       558 002061       560 002066       562 002071       567 002077       569 002101
    571 002116       573 002120       577 002125       581 002147       591 002245       595 002253       596 002261
    599 002264       602 002270       605 002302       608 002305       609 002307       611 002315       614 002316
    617 002323       618 002324       621 002325       624 002331       627 002333       631 002341       633 002342
    642 002434       643 002440       645 002442


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
