	COMPILATION LISTING OF SEGMENT mrds_dsl_modify
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 10/16/89  1244.0 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
       15*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
       16*     This entry is being made to cover the change made on 85-04-19 by Thanh
       17*     Nguyen. (see mrds #136)
       18*  2) change(87-01-22,Hergert), approve(88-07-11,MCR7903),
       19*     audit(88-07-06,Dupuis), install(88-08-01,MR12.2-1073):
       20*     Changed references of sel_ptr to select_list_ptr for new parser.
       21*  3) change(89-09-25,AWTaylor), approve(89-09-25,MCR8116),
       22*     audit(89-10-12,Hussein), install(89-10-16,MR12.3-1093):	
       23*     phx21249 - Created variable last_tuple_id to prevent redundant processing
       24*     in do while loop
       25*                                                   END HISTORY COMMENTS */
       26 
       27 
       28 mrds_dsl_modify: modify: proc;
       29 
       30 /* (database_index, selection_expression, values, code)
       31*
       32*   BEGIN_DESCRIPTION
       33*
       34*   The purpose of this procedure is to implement the dsl_$modify function.
       35*
       36*   This  procedure  calls  translate  with the selection expression then calls
       37*   search and mu_modify.
       38*
       39*
       40*
       41*   INPUT CONDITIONS:
       42*
       43*   database_index: is the index of the database the used wishes to modify.
       44*
       45*   selection_expression:  is the expression supplied by the user to select the
       46*   tuplies to be modified.
       47*
       48*   values: are any values used by the selection expression.
       49*
       50*
       51*
       52*   OUTPUT CONDITIONS:
       53*
       54*   If no errors are encountered the deletion was performed.
       55*
       56*   code = 0; If no errors are detected.
       57*
       58*   code  =  mrds_error_$invalid_db_index;  If  no  dbcb_ptr  was found for the
       59*   database index.
       60*
       61*   code  =  mrds_error_$tuple_not_found; If no tuples satisying the se.  expr.
       62*   were found.
       63*
       64*   code = something else; If some other error was detected;
       65*
       66*
       67*   If  less  then  3  arguments  were  passed  to this procedure the condition
       68*   arg_error will be signaled.
       69*   END_DESCRIPTION
       70*
       71*
       72*   HISTORY:
       73*
       74*   76-01-01 R. D. Lackey: Initially written.
       75*
       76*   78-10-01 J. A. Weeldreyer: Modified for MR7.0.
       77*
       78*   79-03-26 Al Kepner: Modified to add caller parameter to mrds_dsl_translate.
       79*
       80*   79-08-06  Al  Kepner:  Modified to pick up the correct var_index for tuples
       81*   being modified.
       82*
       83*   80-02-01  Jim Gray : Modified to put allocations in non-freeing, extensible
       84*   area managed by this routine.
       85*
       86*   80-06-01  Jim  Gray  :  Modified  to  add  first_time_flag  to  util modify
       87*   interface,  so  allocated  space  could  be  reused  for  large tuple count
       88*   modifies.
       89*
       90*   81-01-29 Jim Gray : removed references to mdbm_data_$current_version, using
       91*   a constant instead so that future db version expansion is possible.
       92*
       93*   81-03-24 Jim Gray : added capability for selection expression
       94*
       95*   81-03-27 Jim Gray : changed dbi parameter to mu_modify to dbcb_ptr, as part
       96*   of  removing  use  of  mus_ptr_man  to  be declared char varying as well as
       97*   nonvarying.
       98*
       99*   81-09-29  Rickie E.  Brinegar: fixed the setting of num_ptrs to come before
      100*   the referencing of any elements of the argument_list arrays which use it as
      101*   an array limit.
      102*
      103*   82-09-20 Davids: Modified for the new DMS interface. Removed call to
      104*   mu_modify and replaced in with calls to mu_cursor_manager_$get, and
      105*   dbcb.relmgr_entries.modify_tuples_by_id. Modify_tuples_by_id is called
      106*   with an array to 100 tuple_ids to reduce the number of calls. the checks
      107*   on ready_mode and scope were moved from mu_modify to this routine.
      108*
      109*   82-10-12 Davids: Modified so that module would compile. Used the new
      110*   names of cursor_ptrs_storage_ptr and cursor_storage_area_ptr in the
      111*   call to mu_cursor_manager_$get
      112*
      113*   82-11-29 Davids: Modified so that if the selection expression is a -current
      114*   then after the modify operation the copy of the tuple in the tuple_info
      115*   str is updated, this way modify -current; retrieve -current retrieves the
      116*   new values not the old values. Also corrected the loop that accumulates
      117*   100 tuples_ids to be modified for the -current case. For the current case
      118*   no looping is needed since only 1 tuple can be current.
      119*
      120*   82-12-07 Roger Lackey : Removed dcl mu_modify not referenced and
      121*                           added  dcl for addrel which was not declared.
      122*
      123*   83-01-24 Davids: added transaction code
      124*
      125*   83-05-04 Davids: Modified so that mu_define_area is called with a name
      126*   of MRDS || dbi_pic. This will allow closes to be faster since all
      127*   temp_segments with the name MRDS || dbi_pic can be deleted/freed in 1 call.
      128*   the variable dbi_pic was created as an easy way to convert from fixed bin
      129*   to character.
      130*
      131*   83-05-31 Mike Kubicar : Updated relation manager calling sequence.
      132*
      133*   83-06-20 Davids: Removed check for old version database and the call
      134*   to v1 code if it was an old version db (old version dbs can no longer
      135*   be opened)
      136*
      137*   85-01-15 Thanh Nguyen:  Added code to create a special work area using 
      138*   mu_define_area$define_spec_temp_dir_area.  For now, this work area is used
      139*   by mu_retrieve and mu_get_data to "allocate" value_for_db and value_for_user
      140*   thru function mrds_space_allocate and reinitialize the area thru subroutine
      141*   mrds_area_initialize.
      142**/
      143 
      144 	dbcb_ptr, area_ptr = null ();
      145 	mstxn_txn_id = "0"b;
      146 
      147 	call cu_$arg_list_ptr (al_ptr);		/* Get pointer to this proc arg list */
      148 	if al_ptr = null then
      149 	     signal arg_error;			/* This returns you to command level */
      150 
      151 	nargs = arg_list.arg_count / 2;		/* Get the number of arguments to this proc */
      152 	if nargs < 3 then
      153 	     signal arg_error;			/* This returns to command level */
      154 
      155 
      156 	call cu_$arg_ptr (nargs, cd_ptr, arg_len, icode); /* Get  pointer to callers return code */
      157 	if icode ^= 0 then
      158 	     signal arg_error;			/* This returns to command level */
      159 
      160 	call cu_$arg_ptr (1, dbi_ptr, arg_len, icode);	/* Get pointer to database index */
      161 	if icode ^= 0 then
      162 	     call error (icode);
      163 
      164 	call cu_$arg_ptr (2, se_ptr, se_len, icode);	/* Get pointer to selection expression */
      165 	if icode ^= 0 then
      166 	     call error (icode);
      167 
      168 /* BEGIN CHANGE 81-03-24 *************************************** */
      169 
      170 	if arg_list.code = 4 then do;
      171 		num_ptrs = arg_list.arg_count;	/* Determine number of ptrs in arg list */
      172 		desc_ptr = arg_list.arg_des_ptr (nargs + 2);
      173 		adpl_ptr = addr (arg_list.arg_des_ptr (nargs + 3));
      174 	     end;
      175 	else do;
      176 		num_ptrs = arg_list.arg_count + 1;
      177 		desc_ptr = arg_list.arg_des_ptr (nargs + 3);
      178 		adpl_ptr = addr (arg_list.arg_des_ptr (nargs + 4));
      179 	     end;
      180 
      181 	if descriptor.type = 22 then do;
      182 		se_len_ptr = addrel (se_ptr, -1);	/* get current length of varying string */
      183 		se_len = se_len_ptr -> se_len_ovrly;
      184 	     end;
      185 
      186 /* END CHANGE 81-03-24 **************************************** */
      187 
      188 
      189 	appl_ptr = addr (arg_list.arg_des_ptr (3));	/* Get pointer to the beginning  */
      190 						/*   of the arg_ptr_list for translate */
      191 						/* Now get pointer to beginning of descriptor */
      192 						/*   pointer list for translate */
      193 
      194 	num_args = nargs - 3;			/* Number of args passed to translate */
      195 
      196 	call
      197 	     mu_database_index$get_resultant_model_pointer (database_index,
      198 	     dbcb_ptr);				/* Get the dbcb pointer */
      199 	if dbcb_ptr = null then
      200 	     call error (mrds_error_$invalid_db_index);
      201 
      202 	mstxn_transactions_needed = dbcb.transactions_needed;
      203 
      204 	original_appl_ptr = appl_ptr;
      205 	original_adpl_ptr = adpl_ptr;
      206 	original_num_args = num_args;
      207 
      208 	on cleanup call mstxn_cleanup;
      209 
      210 	on any_other call mstxn_any_other;
      211 
  1     1 /* ====== BEGIN INCLUDE FILE	          mrds_start_transaction.incl.pl1 =========================== */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the changes made on 85-05-06 and
  1     9*     85-04-19 by Thanh Nguyen. The dependency on dbcb.user_started_transaction
  1    10*     was removed because not all modules need the dbcb, and the
  1    11*     user_transaction_id field was added for mrds_dsl_retrieve (mrds error
  1    12*     list #136).
  1    13*                                                   END HISTORY COMMENTS */
  1    14 
  1    15 
  1    16 /*
  1    17*                    BEGIN_DESCRIPTION
  1    18*
  1    19*   A generalized routine accessed by all MRDS modules (with the temporary 
  1    20*   (perhaps) exception of restructuring modules) that must start transactions 
  1    21*   if none are present.  The intent is that it be executed as inline code.
  1    22*   The variable mstxn_transactions_needed must be set prior to entering this
  1    23*   code.  In most cases a simple assignment from dbcb_data.transactions_needed
  1    24*   will suffice.  Included are procedures called mstxn_cleanup and 
  1    25*   mstxn_any_other.  These procedures must be called by cleanup and any_other 
  1    26*   handlers in the program.  Such handlers should be established just prior to
  1    27*   the inclusion of this code and disabled just following the inclusion of
  1    28*   mrds_finish_transaction.  Directly prior to establishing the handlers
  1    29*   mstxn_txn_id must be set to "0"b.  This must be done even though this 
  1    30*   include file does the same, because this code might not have been entered 
  1    31*   yet when the handler is invoked.  Directly following this include file the 
  1    32*   contents of mstxn_code should be examined.  If zero, then either the 
  1    33*   transaction was successfully started or no transaction was required.  If the
  1    34*   mrds_finish_transaction code is referenced in general error handling 
  1    35*   situations where the possibility exists that the code in this include file 
  1    36*   has not been executed, it is necessary to initialize mstxn_txn_id to "0"b at
  1    37*   the beginning of the program.
  1    38*
  1    39*                    END_DESCRIPTION
  1    40*
  1    41*   Written 82-09-28 by Paul W. Benjamin.
  1    42*   Modified 82-12-09 by PWB to include mstxn_any_other.
  1    43*   Modified 83-01-07 by PWB to not reference the dbcb.
  1    44*   Modified 83-01-10 by PWB to add a call to continue_to_signal_ to the
  1    45*		 any_other handler in situations where the module did
  1    46*		 not start the transaction.
  1    47*   Modified 83-05-05 by PWB to abandon when abort fails.
  1    48*   Modified 83-05-18 by PWB to use mstxn_temp_code in calls to abandon and
  1    49*		 and abort.
  1    50*   Modified 83-05-19 by PWB to handle transaction_deadlock and 
  1    51*		 transaction_bj_full conditions.
  1    52*   Modified 84-02-04 by PWB to add trailing underscores to the 2 conditions
  1    53*		 and to handle transaction_lock_timeout_.
  1    54*   Modified 85-04-14 by Thanh Nguyen: Added code to set the 
  1    55*                     dbcb.user_started_transaction flag.
  1    56*   Modified 85-04-19 by Thanh Nguyen to add user_started_transaction flag.
  1    57*   Modified 85-05-06 By Thanh Nguyen to synchronize this include file in the 
  1    58*                     directory >ldd>include and >exl>mrd>i
  1    59**/
  1    60 
  1    61 dcl continue_to_signal_ entry (fixed bin(35));
  1    62 dcl dm_error_$no_current_transaction fixed bin (35) ext static;
  1    63 dcl error_table_$null_info_ptr fixed bin(35) ext static;
  1    64 dcl find_condition_info_ entry (ptr, ptr, fixed bin(35));
  1    65 dcl mstxn_code fixed bin (35);
  1    66 dcl mstxn_retries fixed;
  1    67 dcl mstxn_temp_code fixed bin (35);
  1    68 dcl mstxn_transactions_needed bit (1) aligned;
  1    69 dcl user_started_transaction bit (1) aligned;
  1    70 dcl mstxn_txn_id bit (36) aligned;
  1    71 dcl user_transaction_id bit (36) aligned;
  1    72 dcl transaction_manager_$abandon_txn entry (bit (36) aligned, fixed bin (35));
  1    73 dcl transaction_manager_$abort_txn entry (bit (36) aligned, fixed bin (35));
  1    74 dcl transaction_manager_$begin_txn entry (fixed bin, fixed bin (35), bit (36) aligned, fixed bin (35));
  1    75 dcl transaction_manager_$get_current_txn_id entry (bit (36) aligned, fixed bin (35));
  1    76 dcl transaction_manager_$handle_conditions entry ();
  1    77 dcl 1 mstxn_condition_info like condition_info;
  1    78 
  2     1 /*  START OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*Designed by Matthew C. Pierret, 01/26/82.
  2     6*Coded by Jeffrey D. Ives, 04/30/82.
  2     7*Modified:
  2     8*10/18/82 by Steve Herbst: Names changed.
  2     9*01/19/83 by Steve Herbst: Added (LOWEST HIGHEST)_MODE.
  2    10**/
  2    11 
  2    12 dcl (LOWEST_MODE init (1),
  2    13      HIGHEST_MODE init (8)) fixed bin int static options (constant);
  2    14 
  2    15      dcl	   TM_NORMAL_MODE	      fixed bin static options (constant) init (1);
  2    16      dcl	   TM_STATISTICAL_MODE   fixed bin static options (constant) init (2);
  2    17      dcl	   TM_READ_ONLY_MODE     fixed bin static options (constant) init (3);
  2    18      dcl	   TM_NEVER_WRITE_MODE   fixed bin static options (constant) init (4);
  2    19      dcl	   TM_TEST_NORMAL_MODE   fixed bin static options (constant) init (5);
  2    20      dcl	   TM_TEST_STATISTICAL_MODE fixed bin static options (constant) init (6);
  2    21      dcl	   TM_TEST_READ_ONLY_MODE fixed bin static options (constant) init (7);
  2    22      dcl	   TM_TEST_NEVER_WRITE_MODE fixed bin static options (constant) init (8);
  2    23 
  2    24 /*  END OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    79 

  1    80 
  3     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  3     2 
  3     3 /* Structure for find_condition_info_.
  3     4*
  3     5*   Written 1-Mar-79 by M. N. Davidoff.
  3     6**/
  3     7 
  3     8 /* automatic */
  3     9 
  3    10      declare condition_info_ptr     pointer;
  3    11 
  3    12 /* based */
  3    13 
  3    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  3    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  3    16 	     2 version	      fixed binary,		/* Must be 1 */
  3    17 	     2 condition_name     char (32) varying,	/* name of condition */
  3    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  3    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  3    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  3    21 	     2 flags	      unaligned,
  3    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  3    23 	       3 pad1	      bit (35),
  3    24 	     2 pad2	      bit (36),
  3    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  3    26 	     2 pad3	      (4) bit (36);
  3    27 
  3    28 /* internal static */
  3    29 
  3    30      declare condition_info_version_1
  3    31 			      fixed binary internal static options (constant) initial (1);
  3    32 
  3    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
  1    81 
  1    82 
  1    83 	mstxn_code = 0;
  1    84 	mstxn_txn_id = "0"b;
  1    85 	
  1    86 	if ^mstxn_transactions_needed			/* only need transactions */
  1    87 	     then goto mstxn_exit;			/* for protected page files */
  1    88 	mstxn_retries = 0;
  1    89 	call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
  1    90 	if mstxn_code ^= dm_error_$no_current_transaction	/* and if none already in progress */
  1    91 	     then do;				
  1    92 	     user_started_transaction = "1"b;
  1    93 	     user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1    94 	     mstxn_txn_id = "0"b;			/* you didn't start it, it's none of your business */
  1    95 	     goto mstxn_exit;	
  1    96 	end;
  1    97 
  1    98 	user_started_transaction = "0"b;
  1    99 	call transaction_manager_$begin_txn (TM_NORMAL_MODE, 0, mstxn_txn_id, mstxn_code);
  1   100 	user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1   101 
  1   102 mstxn_cleanup:
  1   103 proc;
  1   104 
  1   105 /*  This procedure MUST be called by a cleanup handler. */
  1   106 
  1   107           if mstxn_txn_id ^= "0"b
  1   108           then do;
  1   109 	     call transaction_manager_$abort_txn (mstxn_txn_id, mstxn_temp_code);
  1   110 	     if mstxn_temp_code ^= 0
  1   111 		then call transaction_manager_$abandon_txn (mstxn_txn_id, mstxn_temp_code);
  1   112 	end;
  1   113 	
  1   114      end mstxn_cleanup;
  1   115 
  1   116 mstxn_any_other:
  1   117 proc;
  1   118 
  1   119 /*  This procedure MUST be called by an any_other handler. */
  1   120 
  1   121           if mstxn_txn_id ^= "0"b
  1   122           then do;
  1   123 	     call find_condition_info_ (null (), addr(mstxn_condition_info), mstxn_temp_code);
  1   124 	     if mstxn_condition_info.condition_name = "transaction_deadlock_"
  1   125 		then do;
  1   126 		mftxn_code = dm_error_$lock_deadlock;
  1   127 		goto mftxn_check_code;
  1   128 	     end;
  1   129 	     else if mstxn_condition_info.condition_name = "transaction_bj_full_"
  1   130 		| mstxn_condition_info.condition_name = "transaction_lock_timeout_"
  1   131 		then do;
  1   132 		mftxn_code = dm_error_$bj_journal_full;
  1   133 		goto mftxn_check_code;
  1   134 	     end;
  1   135 	     else call transaction_manager_$handle_conditions;
  1   136 	end;
  1   137 	else call continue_to_signal_ (mstxn_code);	/* code returned will always be zero */
  1   138      end mstxn_any_other;
  1   139      
  1   140 mstxn_exit:
  1   141      
  1   142 /* ------ END INCLUDE FILE	          mrds_start_transaction.incl.pl1 --------------------------- */
      212 
      213 
      214 	if mstxn_code ^= 0
      215 	then call error (mstxn_code);
      216 
      217 	dbcb.user_started_transaction = user_started_transaction;
      218 	dbi_pic = dbcb.dbi;
      219 	call
      220 	     mu_define_area$define_temp_dir_area (dbcb.modify_area_ptr, database_index, (sys_info$max_seg_size),
      221 	     "MRDS" || dbi_pic, "0"b /* not extensible */,
      222 	     "1"b /* no freeing */, "0"b, "0"b /* no zeroing */, icode);
      223 	if icode ^= 0 then
      224 	     call error (icode);
      225 	area_ptr = dbcb.modify_area_ptr;
      226 						/* Create a work area for mu_retrieve to allocate the value_for_users. */
      227 	call mu_define_area$define_spec_temp_dir_area (dbcb.work_area_ptr, database_index, "MRDS" || dbi_pic, icode);
      228 	if icode ^= 0 then call error (icode);
      229 
      230 	call
      231 	     mrds_dsl_translate (dbcb_ptr, area_ptr, mrds_data_$caller_modify,
      232 	     se_ptr, se_len, appl_ptr, adpl_ptr, num_args, icode);
      233 	if icode ^= 0 then
      234 	     call error (icode);
      235 	if ^dbcb.val_mod then
      236 	     call error (mrds_error_$inval_mod_expr);
      237 
      238 	ti_ptr = dbcb.ti_ptr;
      239 	range_ptr = dbcb.range_ptr;
      240 	if dbcb.current_flag then
      241 	     select_list_ptr = dbcb.current_ptr;
      242 	else select_list_ptr = dbcb.select_ptr;
      243 	vi = select_list.item (1).var_index;		/* Pick up var_index for tuples to be modified. */
      244 	rmri_ptr = range.tup_var.ri_ptr (vi);
      245 
      246 	if rm_rel_info.ready_mode ^= SCOPE_UPDATE	/* check opening mode and scope to */
      247 	then call error (mdbm_error_$inc_ready_mode);	/* be sure that the relation can be modified */
      248 	if ^rm_rel_info.modify
      249 	then call error (mdbm_error_$view_prevent);
      250 
      251 	ntuples_modified = 0;
      252 	done = "0"b;
      253 
      254 	collection_id = rm_rel_info.rel_id;
      255 	call mu_cursor_manager_$get (database_index, rmri_ptr, 0, collection_id,
      256 	     dbcb.relmgr_entries.create_cursor, dbcb.relmgr_entries.open,
      257 	     dbcb.cursor_ptrs_storage_ptr, dbcb.cursor_storage_area_ptr, cursor_ptr, icode);
      258 	if icode ^= 0
      259 	then call error (icode);
      260 
      261 	call mu_build_tuple (rmri_ptr, area_ptr, dbcb.modify_vector_ptr, move_list_array.ml_ptr (1), "1"b, icode);
      262 	if icode ^= 0
      263 	then call error (icode);
      264 	eil_number_of_elements = 100;
      265 	allocate element_id_list in (wa);
      266 	element_id_list.version = ELEMENT_ID_LIST_VERSION_1;
      267 
      268 /* phx21249, AWTaylor. Init last_tuple_id */
      269 
      270 	last_tuple_id = "0"b;
      271 
      272 	do while ((icode = 0) & ^(done));		/* while we are still finding tuples */
      273 	     if ^dbcb.current_flag			/* if selection expression is not -current */
      274 	     then do;
      275 		     element_id_list.number_of_elements = 0;
      276 		     do i = 1 to 100 while (icode = 0);
      277 			call mrds_dsl_search (dbcb_ptr, area_ptr, icode);
      278 			if icode = 0
      279 			then do;
      280 
      281 /* phx21249, AT. Added a check to skip over redundant tuples */
      282 
      283 			     if ((element_id_list.number_of_elements = 0) |
      284 
      285 			     (tuple_info.tuple_id(vi) ^= last_tuple_id)) then do;
      286 				element_id_list.number_of_elements = element_id_list.number_of_elements + 1;
      287 				element_id_list.id (element_id_list.number_of_elements) = tuple_info.tuple.tuple_id (vi);
      288 				end;
      289 				last_tuple_id = tuple_info.tuple.tuple_id(vi);
      290 			     end;
      291 		     end;
      292 		     if icode ^= mrds_error_$tuple_not_found & icode ^= 0
      293 		     then call error (icode);
      294 		     else if icode = mrds_error_$tuple_not_found
      295 		     then do;
      296 			     if (element_id_list.number_of_elements < 1) &
      297 				(ntuples_modified < 1)
      298 			     then call error (icode);
      299 			     icode = 0;
      300 			     done = "1"b;
      301 			end;
      302 		end;
      303 	     else do;				/* selection expression is -current */
      304 		     element_id_list.number_of_elements = 1;
      305 		     call mrds_dsl_search (dbcb_ptr, area_ptr, icode);
      306 		     if icode = 0
      307 		     then element_id_list.id (element_id_list.number_of_elements) = tuple_info.tuple.tuple_id (vi);
      308 		     else call error (icode);
      309 		     done = "1"b;
      310 		end;
      311 
      312 	     call dbcb.relmgr_entries.modify_tuples_by_id
      313 		(cursor_ptr, element_id_list_ptr, dbcb.modify_vector_ptr, number_of_tuples_modified, icode);
      314 	     if icode ^= 0
      315 	     then call error (icode);
      316 
      317 	     ntuples_modified = ntuples_modified + number_of_tuples_modified;
      318 	end;					/* modify loop */
      319 
      320 	if icode ^= 0 then
      321 	     call error (icode);
      322 	else if ntuples_modified < 1 then
      323 	     call error (icode);
      324 
      325 	code = 0;
      326 
      327 	if dbcb.current_flag			/* If this is -current, update the copy of the current */
      328 	then do;					/* tuple to what it looks like after the modify */
      329 		simple_typed_vector_ptr = tuple_info.tuple.tuple_ptr (vi);
      330 		general_typed_vector_ptr = dbcb.modify_vector_ptr;
      331 		do i = 1 to general_typed_vector.number_of_dimensions;
      332 		     attr_no = general_typed_vector.dimension (i).identifier;
      333 		     bit_length = rm_rel_info.attr_ptrs (attr_no) ->
      334 			rm_attr_info.bit_length;
      335 		     simple_typed_vector.dimension (attr_no).value_ptr -> bit_string =
      336 			general_typed_vector.dimension (i).value_ptr -> bit_string;
      337 		end;
      338 	     end;
      339 
      340 exit:
      341 	if dbcb_ptr = null () then
      342 	     ;
      343 	else if dbcb.modify_area_ptr ^= null then
      344 	     call mu_release_area (dbcb.modify_area_ptr);
      345 
      346 	if code = mrds_error_$tuple_not_found
      347 	then mftxn_code = 0;
      348 	else mftxn_code = code;
      349 
  4     1 /* ====== BEGIN INCLUDE FILE           mrds_finish_transaction.incl.pl1 =========================== */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  4     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  4     8*     This entry is being made to cover the change made on 85-05-06 by Thanh
  4     9*     Nguyen. The code now checks a local flag. (mrds error list #136).
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /*
  4    14*                    BEGIN_DESCRIPTION
  4    15*
  4    16*   A generalized routine accessed by all MRDS modules that begin and commit 
  4    17*   transactions.  The intent is that it be executed as inline code. It is 
  4    18*   assumed that mrds_start_transaction was executed previously in the 
  4    19*   procedure.  Prior to this include file the program should assign the value 
  4    20*   of its local error code to mftxn_code.  The program utilizing this
  4    21*   include file must supply a function labeled should_rollback that returns
  4    22*   bit (1).  This routine should examine the error code mftxn_code and whether
  4    23*   the transaction should be aborted or rolled back.  "0"b means abort and "1"b
  4    24*   means rollback.  This procedure may choose to simply return "0"b as it 
  4    25*   appears that MRDS will generally NOT rollback transactions.  This routine
  4    26*   does rollback and restart if the before journal is full but only attempts it
  4    27*   once.  A procedure labelled restore_significant_data must also be supplied, 
  4    28*   where any data that was saved prior to the transaction is restored.  A 
  4    29*   procedure consisting solely of a return statement can be supplied if 
  4    30*   necessary.  After execution of this include file, mftxn_code must be
  4    31*   examined.  If it was 0 before entering the code and is non-zero afterward,
  4    32*   then the commit has failed.  Otherwise it will be unchanged.
  4    33*
  4    34*                    END_DESCRIPTION
  4    35*
  4    36*   Written 82-09-30 by Paul W. Benjamin.
  4    37*   Modified 83-01-13 by PWB to add retry on deadlocks and to return a non-zero 
  4    38*                     error code only when the transaction is in an error state.
  4    39*   Modified 83-02-04 by PWB to reset transaction id to 0 upon completion.
  4    40*   Modified 83-05-05 by PWB to abort when rollback fails, abandon when abort
  4    41*		 fails, and to abort rather than rollback when bj is full.
  4    42*   Modified 83-05-18 by PWB to use mftxn_temp_code in calls to abandon, abort
  4    43*		 and rollback.
  4    44*   Modified 83-05-19 by PWB to add mftxn_check_code label.  It is transferred
  4    45*		 to by the mstxn_any_other procedure.
  4    46*   Modified 85-04-14 by Thanh Nguyen not to commit the transaction in case of
  4    47*                     the user already started his own transaction.
  4    48*   Modified 85-05-06 by Thanh Nguyen to synchronize this include file between
  4    49*                     the directory >ldd>include and >exl>mrd>i.
  4    50**/
  4    51 
  4    52 dcl dm_error_$bj_journal_full fixed bin(35) ext static;
  4    53 dcl dm_error_$lock_deadlock fixed bin(35) ext static;
  4    54 dcl mftxn_code fixed bin (35);
  4    55 dcl mftxn_temp_code fixed bin (35);
  4    56 dcl transaction_manager_$commit_txn entry (bit (36) aligned, fixed bin (35));
  4    57 dcl transaction_manager_$rollback_txn entry (bit (36) aligned, fixed bin (17), fixed bin (35));
  4    58 	
  4    59 
  4    60 	if mstxn_txn_id = "0"b | user_started_transaction = "1"b	/* No transaction or we did not started it */
  4    61 	     then do;
  4    62 	     mftxn_code = 0;
  4    63 	     goto mftxn_exit;
  4    64 	end;
  4    65 mftxn_check_code:
  4    66 	if mftxn_code = 0
  4    67 	     then do;
  4    68 	     call transaction_manager_$commit_txn (mstxn_txn_id, mftxn_code);
  4    69 	     if mftxn_code ^= 0
  4    70 		then do;
  4    71 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    72 		if mftxn_temp_code ^= 0
  4    73 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    74 	     end;
  4    75 	end;
  4    76 	else do;
  4    77 	     call restore_significant_data;
  4    78 	     if mftxn_code = dm_error_$lock_deadlock	/* retry just once if deadlock */
  4    79 		& mstxn_retries < 1		
  4    80 		then do;
  4    81 		     mstxn_retries = mstxn_retries + 1;
  4    82 		     call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    83 		     if mftxn_temp_code ^= 0
  4    84 			then do;
  4    85 			call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    86 			if mftxn_temp_code ^= 0
  4    87 			     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    88 		     end;
  4    89 		     else do;
  4    90 			mstxn_code = 0;
  4    91 			goto mstxn_exit;		/* go back and try again */
  4    92 		     end;
  4    93 		end;
  4    94 	     else if should_rollback ()		/* let the program decide */
  4    95 		then do;
  4    96 		call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    97 		if mftxn_temp_code ^= 0
  4    98 		     then do;
  4    99 		     call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   100 		     if mftxn_temp_code ^= 0
  4   101 			then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   102 		end;
  4   103 		else do;
  4   104 		     mstxn_code = 0;
  4   105 		     goto mstxn_exit;		/* go back and try again */
  4   106 		end;
  4   107 	     end;
  4   108 	     else do;
  4   109 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   110 		if mftxn_temp_code ^= 0
  4   111 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   112 	     end;
  4   113 	end;
  4   114 	mstxn_txn_id = "0"b;			/* should never be nonzero unless there is a txn */
  4   115 mftxn_exit:
  4   116      
  4   117 /* ------ END INCLUDE FILE	          mrds_finish_transaction.incl.pl1 --------------------------- */
      350 
      351 
      352 	if mftxn_code ^= 0
      353 	then code = mftxn_code;
      354 
      355 	return;					/* Return to the caller with a code */
      356 
      357 
      358 should_rollback: proc () returns (bit (1));
      359 
      360 	return ("0"b);
      361 
      362 /* No rollbacks requested by this module at this point in time. */
      363 
      364      end should_rollback;
      365 
      366 restore_significant_data: proc;
      367 
      368 	appl_ptr = original_appl_ptr;
      369 	adpl_ptr = original_adpl_ptr;
      370 	num_args = original_num_args;
      371 
      372 	if dbcb_ptr ^= null ()
      373 	then do;
      374 		if dbcb.modify_area_ptr ^= null ()
      375 		then do;
      376 			call mu_release_area (dbcb.modify_area_ptr);
      377 		     end;
      378 	     end;
      379 
      380 	return;
      381 
      382      end restore_significant_data;
      383 
      384 error:
      385      proc (cd);					/* Internal error  procedure */
      386 
      387 	dcl     cd		 fixed bin (35);
      388 
      389 	code = cd;				/* Return the error code to caller */
      390 	go to exit;
      391 
      392      end error;
      393 
      394 
  5     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  5     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  5     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  5     9*     Nguyen. The scopes_changed flag was added to make checking for this
  5    10*     more efficient (mrds error list #137).
  5    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  5    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  5    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  5    14*     care if multiple txns use the same selection_expression. (mrds #156)
  5    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  5    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  5    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  5    18*                                                   END HISTORY COMMENTS */
  5    19 
  5    20 
  5    21 /* WARNING
  5    22*          If the dbcb structure is changed then the mrds_data_
  5    23*          item saved_res_version MUST be incremented to invalidate all
  5    24*          existing saved resultants
  5    25**/
  5    26 
  5    27 /* HISTORY :
  5    28*
  5    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  5    30*   tid_list management
  5    31*
  5    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  5    33*   phony resultant in mu_database_index, without having the area dcl
  5    34*   included.
  5    35*
  5    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  5    37*   mrds_dsl_store
  5    38*
  5    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  5    40*   switches
  5    41*
  5    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  5    43*   expression,  so  that relation statistics can be updated relative
  5    44*   to number of selection expressions seem. Also  removed  init  for
  5    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  5    46*   mrds_dsl_init_res.
  5    47*
  5    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  5    49*
  5    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  5    51*   for the conversion to the relation manager.
  5    52*
  5    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  5    54*   substructures so that the entries and costs can change
  5    55*   depending on the type of database that is opened.
  5    56*
  5    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  5    58*   since modify uses a different vector type (general) than does store.
  5    59*
  5    60*   82-09-20 Davids: changed names of (store modify)_vector to
  5    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  5    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  5    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  5    64*   during the first call.
  5    65*
  5    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  5    67*   since it deals with the pointers to the cursors and not the cursors
  5    68*   themelves and added the element cursor_storage_area_ptr which points
  5    69*   to the area where the cursors are kept.
  5    70*
  5    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  5    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  5    73*   anything.
  5    74*
  5    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  5    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  5    77*   by mrds_dsl_define_temp_rel.
  5    78*
  5    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  5    80*   is needed by mu_store.
  5    81*
  5    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  5    83*   bin to float bin since the values are not integers.
  5    84*
  5    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  5    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  5    87*   added to the end of the structure to allow modules that don't use
  5    88*   the element to continue to reference the dbcb structure without recompiling.
  5    89*
  5    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  5    91*   are needed so that temp rels can be created with the same file attributes
  5    92*   as the permanent relations.
  5    93*
  5    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  5    95*   added the resultant_in_pdir bit.
  5    96*
  5    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  5    98*   added the res_already_made element.
  5    99*
  5   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  5   101*
  5   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  5   103*   one of the unused pointers.
  5   104*
  5   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  5   106*
  5   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  5   108*   leaving unused_ptrs(1).
  5   109*
  5   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  5   111*   unused_ptrs (1).
  5   112*
  5   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  5   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  5   115*   spare ptrs, entries and reserved storages for future enhancement, since
  5   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  5   117*
  5   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  5   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  5   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  5   121**/
  5   122 
  5   123 
  5   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  5   125*   that constitutes the non-secure portion of the resultant model that is
  5   126*   created during the opening of a database. it contains variables that
  5   127*   are used during the runtime access of the database, and an area
  5   128*   for evaluation of requests. it points to four other
  5   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  5   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  5   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  5   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  5   133*   used in the elimination of duplicate tuples during a retrieve.
  5   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  5   135*   that is used when the database is using the file scope mechanism
  5   136*   for concurrency control over file readying. the segment overlayed via
  5   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  5   138*   across database openings. the pointer to this dbcb structure is kept in a table
  5   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  5   140*   opening instances of resultant models. (see mu_database_index routine) */
  5   141 
  5   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  5   143 	     2 data	      like dbcb_data,
  5   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  5   145 
  5   146      dcl	   dbcb_ptr	      ptr;
  5   147 
  5   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  5   149*						   like references can avoid getting the area declaration */
  5   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  5   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  5   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  5   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  5   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  5   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  5   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  5   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  5   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  5   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  5   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  5   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  5   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  5   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  5   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  5   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  5   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  5   167*						   for eliminating duplicate tuples. */
  5   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  5   169*						   for eliminating duplicate tuples. */
  5   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  5   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  5   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  5   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  5   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  5   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  5   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  5   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  5   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  5   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  5   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  5   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  5   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  5   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  5   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  5   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  5   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  5   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  5   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  5   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  5   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  5   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  5   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  5   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  5   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  5   195 	     2 val_del	      bit (1) unal,		/* for delete */
  5   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  5   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  5   198*                                                                     not imply that the database is of type page_file */
  5   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  5   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  5   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  5   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  5   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  5   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  5   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  5   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  5   207*						   inside a sequence of -another selection expression. */
  5   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  5   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  5   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  5   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  5   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  5   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  5   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  5   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  5   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  5   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  5   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  5   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  5   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  5   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  5   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  5   223 	     2 relmgr_entries,			/* relation manager entries */
  5   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  5   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  5   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  5   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  5   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  5   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  5   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  5   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  5   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  5   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  5   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  5   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  5   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  5   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  5   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  5   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  5   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  5   241 	       3 reserved_entries (5) entry (),
  5   242 	     2 access_costs,			/* access costs for permute */
  5   243 	       3 total_primary_key_cost float bin,
  5   244 	       3 access_cost      float bin,
  5   245 	       3 access_overhead  float bin,
  5   246 	       3 us_access_cost   float bin,
  5   247 	       3 os_access_cost   float bin,
  5   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  5   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  5   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  5   251 
  5   252 /* END mrds_dbcb.incl.pl1 */
  5   253 
  5   254 
      395 
      396 
  6     1 /* BEGIN mdbm_rm_rel_info.incl.pl1 -- jaw, 11/16/78 */
  6     2 
  6     3 /* WARNING
  6     4*          If the rm_rel_info structure is changed then the mrds_data_
  6     5*          item saved_res_version MUST be incremented to invalidate all
  6     6*          existing saved resultants
  6     7**/
  6     8 
  6     9 /* HISTORY:
  6    10*
  6    11*   Modified by Jim Gray - - May 1980, to  include  model  number  of
  6    12*   attributes,   and   varying  attributes,  so  that  partial  view
  6    13*   submodels will have the  info  needed  to  properly  set  up  the
  6    14*   varying length array headers in the tuple structure.
  6    15*
  6    16*   Modified  by  Jim  Gray  -  -  80-11-06,  to  rename   r_perm   =
  6    17*   status_perm,     s_perm    =    append_tuple_perm,    d_perm    =
  6    18*   delete_tuple_perm, and make m_perm = unused_perm.
  6    19*
  6    20*   81-01-23 Jim Gray : added bit to indicate whether the last  model
  6    21*   view attribute was varying character or bit, since a partial view
  6    22*   submodel will not have this information in the resultant, and  it
  6    23*   is  needed for determining the new tuple length in mus_mod_ubtup,
  6    24*   since with exact length storage  of  varying  length  attributes,
  6    25*   each  tuple  can  be  a  different  length,  which is can only be
  6    26*   determined by examining the tuple itself.
  6    27*
  6    28*   81-01-29 Jim Gray : added curent  tuple  count,  to  provide  for
  6    29*   interface  to  allow  temp  rel  population  to  be known, and to
  6    30*   provide a more efficient means of finding an approx. current perm
  6    31*   relation population.
  6    32*
  6    33*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  6    34*   blocked  files, foreign keys, and ids procedures. Also set number
  6    35*   of files per rel to a constant of 1.
  6    36*
  6    37*   81-05-28 Jim Gray : combined data  from  rm_file_info  into  this
  6    38*   structure so that only one structure per relation is needed.
  6    39*
  6    40*   81-07-02 Jim Gray : added total_key and dup_key vfile  statistics
  6    41*   counts.   Also  added  number  of  operations  count  since  last
  6    42*   statistics update, and a time  since  the  statistics  were  last
  6    43*   updated.
  6    44*
  6    45*   81-07-06 Jim Gray :  added  a  per  selection  expression  update
  6    46*   identifier so that small relations could be updated on a per S.E.
  6    47*   basis
  6    48*
  6    49*   82-04-21 R. Lackey : Added number_selected (ri_niocbs_init refer (rm_rel_info.niocbs)) fixed bin (35)
  6    50*   to end of structure   TR 12205 (Suggestion).
  6    51*   
  6    52*   82-08-19 D. Woodka :  Removed  rm_rel_info.max_data_len  field for
  6    53*   the DMS conversion. 
  6    54*
  6    55*   82-08-30 Davids: added the opening_id element and removed the iocb
  6    56*   array and the niocb element for DMS conversion. Also removed the
  6    57*   number_selected array (and ri_niocbs_init) since subsets are not
  6    58*   going to be used.
  6    59*
  6    60*   82-09-20 Mike Kubicar : changed rm_rel_info.rel_id to bit (36) aligned
  6    61*   so that it can be used with relation manager.  Also added
  6    62*   rm_rel_info.primary_key_index_id for relation manager.
  6    63*
  6    64*   82-09-22 Mike Kubicar : Removed the, now useless, fields var_attr_ptrs,
  6    65*   nvar_atts, model_nvar_atts.
  6    66*
  6    67*   82-09-24 Davids: Removed current_key_count and current_dup_key_count
  6    68*   since the duplicate key count for each secondary index is now being
  6    69*   kept in the attr_info structure and key_count was only needed to
  6    70*   help in calculating the average selectivity of each index which
  6    71*   can now be gotten directly from each index's dup key count. Also
  6    72*   removed the file_id element since it is no longer needed for
  6    73*   anything.
  6    74*
  6    75*   82-09-27 Mike Kubicar : removed file_id_len for the same reason file_id
  6    76*   was removed.
  6    77*
  6    78*   82-11-05 Mike Kubicar : added a pointer to an id_list structure to be
  6    79*   used when retrieving tuples from this relation.
  6    80*
  6    81*   83-04-06 Davids: Added the scope_flags_ptr which points to the scope_flags structure
  6    82*   for the relation. Note that this structure is part of the resultant NOT
  6    83*   part of the db.control structure. The scopes are duplicated in the resultant
  6    84*   to reduce contention for the db.control structure. Note also that the pointer
  6    85*   will always point to a scope_flags structure even if no scopes have been
  6    86*   set on the relation, the structure is allocated when the db is opened.
  6    87**/
  6    88 
  6    89 
  6    90 /* DESCRIPTION:
  6    91*
  6    92*   This structure is allocated in the area part of the structure  in
  6    93*   mdbm_rm_db_info.incl.pl1  as  part of the resultant model created
  6    94*   at open  time  for  a  database.  There  will  be  one  of  these
  6    95*   rm_rel_info   structures  for  each  relation  appearing  in  the
  6    96*   database view (there may be less than the total in  the  database
  6    97*   for  a  submodel  openings).  There  will  also  be  one for each
  6    98*   temporary relation currently defined for that opening.
  6    99*
  6   100*   The structure in mdbm_rm_rel_array.incl.pl1 contains pointers  to
  6   101*   all  rm_rel_info  structures  allocated. It is used for searching
  6   102*   for the appropriate  structure.  This  array  is  pointed  to  by
  6   103*   rm_db_info. There are two arrays, one for perm rels, one for temp
  6   104*   rels.
  6   105*
  6   106*   The      rm_rel_info      structure      points      to       the
  6   107*   mdbm_rm_attr_info.incl.pl1  structures,  one  for  each attribute
  6   108*   appearing in this view of the relation. Each  of  these  in  turn
  6   109*   point  to a mdbm_rm_domain_info.incl.pl1 structure for the domain
  6   110*   info for each attr.
  6   111*
  6   112*   Most of the other information here deals with  specifics  of  the
  6   113*   relation's  logical  definition,  such as key and secondary index
  6   114*   attribute inidicators, security permissions, and  tuple  physical
  6   115*   construction details.
  6   116*
  6   117**/
  6   118 
  6   119      dcl	   1 rm_rel_info	      aligned based (rmri_ptr), /* relation information */
  6   120 	     2 name	      char (32),		/* from submodel */
  6   121 	     2 model_name	      char (30),		/* from model */
  6   122 	     2 rel_id	      bit (36) aligned,	/* unique id. */
  6   123 	     2 retrieve	      bit (1) unal,		/* operations allowed by this view */
  6   124 	     2 modify	      bit (1) unal,
  6   125 	     2 delete	      bit (1) unal,
  6   126 	     2 store	      bit (1) unal,
  6   127 	     2 total_key	      bit (1) unal,		/* on if view includes full primary key */
  6   128 	     2 indexed	      bit (1) unal,		/* on if exists sec. index */
  6   129 	     2 mdbm_secured	      bit (1) unal,		/* on if mdbm must check security */
  6   130 	     2 status_perm	      bit (1) unal,		/* if user has status. perm. */
  6   131 	     2 append_tuple_perm  bit (1) unal,		/* if user has store perm. */
  6   132 	     2 delete_tuple_perm  bit (1) unal,		/* if user has del. perm. */
  6   133 	     2 unused_perm	      bit (1) unal,		/* for future use. */
  6   134 	     2 last_model_attr_char_var bit (1) unal,	/* on => last model varying attr is char */
  6   135 	     2 reserved	      bit (24) unal,	/* for future use */
  6   136 	     2 num_attr	      fixed bin,		/* total no. of attr. in rel. */
  6   137 	     2 model_num_attr     fixed bin,		/* total attrs in model relation */
  6   138 	     2 nkey_attr	      fixed bin,		/* no. of key attr. */
  6   139 	     2 model_nkey_attr    fixed bin,		/* total number of keys in model */
  6   140 	     2 primary_key_index_id bit (36) aligned,     /* Index id of relation's primary key */
  6   141 	     2 nsec_inds	      fixed bin,		/* no. sec. indexes */
  6   142 	     2 max_key_len	      fixed bin (35),	/* max length (chars) of primary key */
  6   143 	     2 current_tuple_population fixed bin (35),	/* last known total  tuple count for this relation */
  6   144 	     2 last_statistics_update_count fixed bin,	/* number of operations's, since this rels stats were updated */
  6   145 	     2 last_statistics_update_time fixed bin (71),/* last time this rels stats were updated */
  6   146 	     2 last_statistics_update_s_e_ref_num fixed bin (35), /* last select expr ID that updated this rels stats */
  6   147 	     2 ready_mode	      fixed bin,		/* 1 => r, 2 => mr, 3 => u, 4 => l, 5 => sr, 6 => su */
  6   148 	     2 file_type	      fixed bin,		/* 1 => unblocked, 2 => blocked, 3 => temporary */
  6   149 	     2 tuple_id_len	      fixed bin,		/* no. bits in local tuple id */
  6   150 	     2 opening_id	      bit (36) aligned,	/* relation manager opening is */
  6   151 	     2 key_attr_ptrs      (nkey_attr_init refer (rm_rel_info.nkey_attr)) ptr, /* ptrs to key attr. */
  6   152 	     2 attr_ptrs	      (natts_init refer (rm_rel_info.num_attr)) ptr, /* ptrs to all attr. */
  6   153 	     2 id_list_ptr        ptr,		/* Id list for retrieves from the relation */
  6   154                2 scope_flags_ptr    ptr;                    /* pointer to the scope_flags structure for the rel */
  6   155 
  6   156      dcl	   rmri_ptr	      ptr;
  6   157      dcl	   (nkey_attr_init,
  6   158 	   natts_init,
  6   159 	   nvar_atts_init)	      fixed bin;
  6   160 
  6   161 /* END mdbm_rm_rel_info.incl.pl1 */
  6   162 
  6   163 
      397 
      398 
  7     1 /*  BEGIN  mdbm_rm_attr_info.incl.pl1  --  jaw,  11/16/78  */
  7     2 
  7     3 /* WARNING
  7     4*          If the rm_attr_info structure is changed then the mrds_data_
  7     5*          item saved_res_version MUST be incremented to invalidate all
  7     6*          existing saved resultants
  7     7**/
  7     8 
  7     9 /*
  7    10*
  7    11*   Modified  by  Jim  Gray - - 80-11-05, to add mdbm_secured bit, so
  7    12*   that rm_rel_info does not have to be checked
  7    13*
  7    14*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  7    15*   foreign keys.
  7    16*
  7    17*   82-08-19  D. Woodka : removed rm_attr_info.bit_offset for the DMS
  7    18*   conversion.
  7    19*
  7    20*   82-09-15 Davids: added the number_of_dups field.
  7    21*
  7    22*   82-09-20 Mike Kubicar : changed the index_id field to be bit (36)
  7    23*   aligned.  This is to conform with the new definition in the database
  7    24*   model.  Also removed the now useless field varying.
  7    25*
  7    26*   82-11-05 Davids: added the field model_defn_order and clarified the
  7    27*   comment for the field defn_order.
  7    28*
  7    29*   83-05-23 Mike Kubicar : changed number_of_dups to fixed bin (35) since
  7    30*   that's what relation manager returns.
  7    31*
  7    32**/
  7    33 
  7    34 
  7    35 /*
  7    36*   this   structure   is   allocated   in   the   static   area   of
  7    37*   mdbm_rm_db_info.incl.pl1  once for each attribute per relation in
  7    38*   a     readied     file.      it     in     turn     points     to
  7    39*   mdbm_rm_domain_info.incl.pl1  for  the  attributes  domain.   the
  7    40*   rm_attr_info  is  pointed  to  by mdbm_rm_rel_info.incl.pl1.  all
  7    41*   structures  are  in  the  rm_db_info  area.   the  attribute data
  7    42*   position  within  a  tuple as stored in the data file are kept in
  7    43*   this resultant model of the attribute.
  7    44* */
  7    45 
  7    46 dcl 1 rm_attr_info aligned based (rai_ptr),		/* resultant attr. info */
  7    47     2 name char (32),				/* from submodel */
  7    48     2 model_name char (32),				/* from model */
  7    49     2 key_attr bit (1) unal,				/* if key attribute */
  7    50     2 index_attr bit (1) unal,			/* if secondary index */
  7    51     2 read_perm bit (1) unal,				/* user has retr. permission */
  7    52     2 modify_perm bit (1) unal,			/* user has modify permission */
  7    53     2 mdbm_secured bit (1) unal,			/* on => database secured */
  7    54     2 reserved bit (30) unal,				/* for future use */
  7    55     2 index_id bit (36) aligned,			/* index id if index_attr */
  7    56     2 defn_order fixed bin,				/* relative order in which attr is defined in the view */
  7    57     2 key_order fixed bin,				/* relative order defined in prim. key */
  7    58     2 bit_length fixed bin (35),			/* length if fixed, max. len. if var. */
  7    59     2 domain_ptr ptr,				/* to domain info */
  7    60     2 number_of_dups fixed bin (35),                        /* if the attribute is indexed this will
  7    61*                                                               be the number of duplicate values, exact
  7    62*                                                               for a page_file database, an estimate for a vfile type */
  7    63     2 model_defn_order fixed bin;                           /* relative order in which attr is defined in the model */
  7    64 
  7    65 dcl  rai_ptr ptr int automatic init (null ());
  7    66 
  7    67 /* END mdbm_rm_attr_info.incl.pl1 */
  7    68 
  7    69 
      399 
      400 
  8     1 /* BEGIN mrds_range.incl.pl1 -- jaw, 10/20/78 */
  8     2 
  8     3 /* Modified 83-04-22 by R. Harvey to add needed_bits */
  8     4 
  8     5 dcl 1 range aligned based (range_ptr),
  8     6     2 num_vars fixed bin,				/* number of tuple variables */
  8     7     2 tup_var (mrds_data_$max_tup_var refer (range.num_vars)), /* info for each tuple variable */
  8     8       3 name char (mrds_data_$max_id_len),		/* name of tuple variable */
  8     9       3 temp_rel bit (1) unal,			/* on if temporary relation */
  8    10       3 used bit (1) unal,				/* 1 => this tuple variable is referenced by
  8    11*						   a -select clause. */
  8    12       3 whole_tuple_selected bit (1) unal,		/* the whole tuple variable is referenced in the select clause */
  8    13       3 copy_for_current bit (1) unal,			/* -current requests attributes not previously retrieved */
  8    14       3 copied_for_current bit (1) unal,		/* tuple copied during previous -current */
  8    15       3 reserved bit (31) unal,			/* reserved for future use */
  8    16       3 rel_index fixed bin,				/* index to assoc. relation */
  8    17       3 stv_ptr ptr,				/* simple typed vector */
  8    18       3 idl_ptr ptr,				/* id_list ptr */
  8    19       3 needed_bits aligned,
  8    20         4 attr (mrds_data_$max_attributes) bit (1) unal,
  8    21       3 ri_ptr ptr;					/* pointer to rel info for assoc. relation */
  8    22 
  8    23 dcl  range_ptr ptr;
  8    24 
  8    25 /* END mrds_range.incl.pl1 */
  8    26 
      401 
      402 
  9     1 /* BEGIN mrds_select_list.incl.pl1 -- jaw 10/20/78 */
  9     2 
  9     3 /* HISTORY:
  9     4*
  9     5*   81-06-01 Jim Gray : removed user len and type elements,
  9     6*   since mu_convert rather than assign_ is now used.
  9     7*
  9     8*   84-11-22 John Hergert: added fr_ptr
  9     9*
  9    10*/****^  HISTORY COMMENTS:
  9    11*  1) change(86-07-17,Dupuis), approve(86-08-05,MCR7491), audit(86-08-08,Blair),
  9    12*     install(86-08-15,MR12.0-1127):
  9    13*     85-11-22 Hergert: Added variable var_exists so that it may be kept
  9    14*     around per select expression (in sets) and when compiling. (mrds #158)
  9    15*  2) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  9    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  9    17*     For new parser, (and general readability) renamed sel_ptr to
  9    18*     select_list_ptr.
  9    19*                                                   END HISTORY COMMENTS */
  9    20 
  9    21 
  9    22 dcl 1 select_list based (select_list_ptr),			/* tabular representation of -select clause */
  9    23     2 num_vars fixed bin,				/* number of free variables */
  9    24     2 mla_ptr ptr,					/* pointer to array of move list pointers */
  9    25     2 fr_ptr ptr,                                           /* pointer to free_raltions struct in mrds_dsl_select_clause */
  9    26     2 num_items fixed bin,				/* number of attributes specified in select list */
  9    27     2 var_exists (36) bit(1),
  9    28     2 item (mrds_data_$max_select_items refer (select_list.num_items)),
  9    29       3 must_convert bit (1) unal,			/* on if conversion required */
  9    30       3 key bit (1) unal,				/* on if to be key attr. in temp. rel. */
  9    31       3 index bit (1) unal,				/* on if index attribute in temp rel */
  9    32       3 reserved bit (33) unal,			/* reserved for future use */
  9    33       3 var_index fixed bin,				/*  index of assoc. tuple variable */
  9    34       3 ai_ptr ptr,					/* ptr to attr_info */
  9    35       3 user_desc_ptr ptr,				/* to descriptor for user value */
  9    36       3 user_ptr ptr ;				/* pointer to user's area */
  9    37 
  9    38 dcl  select_list_ptr ptr int automatic init (null ());
  9    39 
  9    40 dcl 1 move_list_array (select_list.num_vars) based (select_list.mla_ptr),
  9    41     2 var_index fixed bin,
  9    42     2 ml_ptr ptr;
  9    43 
  9    44 /* END mrds_select_list.incl.pl1 */
  9    45 
      403 
      404 
 10     1 /* BEGIN mrds_tuple_info.incl.pl1 -- jaw 11/2/78 */
 10     2 
 10     3 /* HISTORY:
 10     4*
 10     5*   Modified in March 1977 by O Friesen to hold allocated ptr and length
 10     6*   82-10-29 Mike Kubicar : Made tuple_id aligned
 10     7*
 10     8**/
 10     9  
 10    10 dcl 1 tuple_info aligned based (ti_ptr),
 10    11     2 num_tuples fixed bin,				/* no. of tuples for which info given */
 10    12     2 tuple (ti_ntuples_init refer (tuple_info.num_tuples)),
 10    13       3 tuple_ptr ptr,				/* pointer to found tuple */
 10    14       3 tuple_id bit (36) aligned,			/* tuple id for  found tuple */
 10    15       3 var_index fixed bin;				/* index to tuple variable  */
 10    16 
 10    17 dcl  ti_ptr ptr;
 10    18 dcl  ti_ntuples_init fixed bin;
 10    19 
 10    20 /* END mrds_tuple_info.incl.pl1 */
 10    21 
      405 
      406 
 11     1 /* BEGIN mdbm_arg_list.incl.pl1 -- jaw 5/31/78 */
 11     2 /* the duplicate mrds_arg_list.incl.pl1 was eliminated by Jim Gray, Nov. 1979 */
 11     3 
 11     4 /* layout of argument list for IDS and DBM entries with options (variable) */
 11     5 
 11     6 dcl 1 arg_list based (al_ptr),
 11     7     2 arg_count fixed bin (17) unal,			/* 2 * no. of args. */
 11     8     2 code fixed bin (17) unal,			/* 4 => normal, 8 => special */
 11     9     2 desc_count fixed bin (17) unal,			/* 2 * no. of descriptors */
 11    10     2 pad fixed bin (17) unal,			/* must be 0 */
 11    11     2 arg_des_ptr (num_ptrs) ptr;			/* argument/descriptor pointer */
 11    12 
 11    13 dcl  al_ptr ptr;
 11    14 dcl  num_ptrs fixed bin;
 11    15 
 11    16 /* END mdbm_arg_list.incl.pl1  */
 11    17 
      407 
      408 
 12     1 /* BEGIN mdbm_descriptor.incl.pl1 -- jaw 5/31/78 */
 12     2 /* modified by Jim Gray - - Nov. 1979, to change type from fixed bin(5) to
 12     3*   unsigned fixed bin(6), so new packed decimal data types could be handled.
 12     4*   also the duplicate mrds_descriptor.incl.pl1 was eliminated. */
 12     5 
 12     6 dcl 1 descriptor based (desc_ptr),			/* map of Multics descriptor */
 12     7     2 version bit (1) unal,				/* DBM handles vers. 1 only */
 12     8     2 type unsigned fixed bin (6) unal,			/* data type */
 12     9     2 packed bit (1) unal,				/* on if data item is packed */
 12    10     2 number_dims bit (4) unal,			/* dimensions */
 12    11     2 size,					/* size for string data */
 12    12       3 scale bit (12) unal,				/* scale for num. data */
 12    13       3 precision bit (12) unal,			/* prec. for num. data */
 12    14     2 array_info (num_dims),
 12    15       3 lower_bound fixed bin (35),			/* lower bound of dimension */
 12    16       3 upper_bound fixed bin (35),			/* upper bound of dimension */
 12    17       3 multiplier fixed bin (35);			/*  element separation */
 12    18 
 12    19 dcl  desc_ptr ptr;
 12    20 dcl  num_dims fixed bin init (0) ;			/* more useful form of number_dims */
 12    21 
 12    22 /* END mdbm_descriptor.incl.pl1 */
 12    23 
 12    24 
      409 
      410 
 13     1 /* BEGIN INCLUDE FILE  - dm_element_id_list.incl.pl1 */
 13     2 
 13     3 /* DESCRIPTION:
 13     4*          The element_id_list structure contains an array of element 
 13     5*     identifiers.  These identifiers are used as tuple, record or 
 13     6*     element identifiers.  This structure is used across the relation_manager_,
 13     7*     record_manager_ and index_manager_ interfaces.  At some time the 
 13     8*     version should be changed to be char(8)aligned, when such a conversion
 13     9*     can be coordinated with the other structures used at these interfaces.
 13    10**/
 13    11 
 13    12 /* HISTORY:
 13    13*Written by Matthew Pierret, 06/06/82.
 13    14*Modified:
 13    15*12/16/82 by Roger Lackey:  Changed number_of_elements to fixed bin (35).
 13    16*            Did not change version.
 13    17*02/11/85 by Matthew Pierret:  Added DESCRIPTION, Written by.
 13    18**/
 13    19 
 13    20 /* format: style2,ind3 */
 13    21      dcl	   1 element_id_list      aligned based (element_id_list_ptr),
 13    22 	     2 version	      fixed bin (35),
 13    23 	     2 number_of_elements fixed bin (35),
 13    24 	     2 id		      (eil_number_of_elements refer (element_id_list.number_of_elements)) bit (36) aligned;
 13    25 
 13    26      dcl	   element_id_list_ptr    ptr;
 13    27      dcl	   eil_number_of_elements fixed bin (35);
 13    28      dcl	   ELEMENT_ID_LIST_VERSION_1
 13    29 			      init (1) fixed bin (35);
 13    30 
 13    31 
 13    32 /* END INCLUDE FILE  - dm_element_id_list.incl.pl1 */
      411 
      412 
 14     1 /* ***********************************************************
 14     2*   *                                                         *
 14     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
 14     4*   *                                                         *
 14     5*   *********************************************************** */
 14     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
 14     7 
 14     8 /* Written by Lindsey Spratt, 04/02/82.
 14     9*Modified:
 14    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
 14    11*	  unaligned.  Changed the type number of the simple_typed_vector to
 14    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
 14    13*	  type.
 14    14**/
 14    15 
 14    16 /* format: style2,ind3 */
 14    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
 14    18 	     2 type	      fixed bin (17) unal,
 14    19 	     2 number_of_dimensions
 14    20 			      fixed bin (17) unal,
 14    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
 14    22 	       3 value_ptr	      ptr unaligned;
 14    23 
 14    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
 14    25 	     2 type	      fixed bin (17) unal,
 14    26 	     2 number_of_dimensions
 14    27 			      fixed bin (17) unal,
 14    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
 14    29 	       3 identifier	      fixed bin (17) unal,
 14    30 	       3 pad	      bit (18) unal,
 14    31 	       3 value_ptr	      ptr unal;
 14    32 
 14    33      dcl	   simple_typed_vector_ptr
 14    34 			      ptr;
 14    35      dcl	   stv_number_of_dimensions
 14    36 			      fixed bin (17);
 14    37 
 14    38      dcl	   general_typed_vector_ptr
 14    39 			      ptr;
 14    40      dcl	   gtv_number_of_dimensions
 14    41 			      fixed bin (17);
 14    42 
 14    43      dcl	   (
 14    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
 14    45 			      init (1),		/* value_ptr was aligned. */
 14    46 	   GENERAL_TYPED_VECTOR_TYPE
 14    47 			      init (2),
 14    48 	   SIMPLE_TYPED_VECTOR_TYPE
 14    49 			      init (3)
 14    50 	   )		      fixed bin (17) internal static options (constant);
 14    51 
 14    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
      413 
      414 
      415 
      416 /* Multics subroutines */
      417 
      418 	dcl     cu_$arg_list_ptr	 entry (ptr);
      419 	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin, fixed bin (35));
      420 
      421 	dcl     sys_info$max_seg_size	 ext fixed bin;
      422 
      423 
      424 /*  DBM Routines */
      425 
      426 	dcl     mrds_dsl_search	 entry (ptr, ptr, fixed bin (35));
      427 	dcl     mrds_dsl_translate	 entry (ptr, ptr, fixed bin, ptr, fixed bin, ptr, ptr, fixed bin, fixed bin (35));
      428 	dcl     mu_build_tuple	 entry (ptr, ptr, ptr, ptr, bit (1) aligned, fixed bin (35));
      429 	dcl     mu_cursor_manager_$get entry (fixed bin (35), ptr, fixed bin (35), bit (36) aligned, entry, entry, ptr, ptr, ptr, fixed bin (35));
      430 	dcl     mu_database_index$get_resultant_model_pointer entry (fixed bin (35), ptr);
      431 
      432 
      433 	dcl     mrds_data_$caller_modify fixed bin (17) ext;
      434 	dcl     mrds_data_$max_attributes ext static fixed bin (35);
      435 	dcl     mrds_data_$max_id_len	 ext fixed bin (35);
      436 
      437 	dcl     (
      438 	        mdbm_error_$inc_ready_mode,
      439 	        mdbm_error_$view_prevent,
      440 	        mrds_error_$tuple_not_found,
      441 	        mrds_error_$inval_mod_expr,
      442 	        mrds_error_$invalid_db_index
      443 	        )			 ext fixed bin (35);
      444 
      445 /* Based variable */
      446 
      447 	dcl     code		 fixed bin (35) based (cd_ptr);
      448 	dcl     database_index	 fixed bin (35) based (dbi_ptr);
      449 	dcl     wa		 area (sys_info$max_seg_size) based (area_ptr);
      450 
      451 
      452 /* Pointers */
      453 
      454 	dcl     (
      455 	        cursor_ptr,				/* points to the cursor to be used for the modify */
      456 	        se_ptr,				/* Points to the selection expression */
      457 	        appl_ptr,				/* Points to the list of arg pointers for translate */
      458 	        adpl_ptr,				/* Points to the list of arg descriptors for translate */
      459 	        cd_ptr,				/* Points to callers return code */
      460 	        dbi_ptr
      461 	        )			 ptr;		/* Points to the database index */
      462 
      463 
      464 /* Others */
      465 
      466 	dcl     SCOPE_UPDATE           static fixed bin options (constant) init (6);
      467 						/* scope update ready mode */
      468 
      469 	dcl     (
      470 	        nargs,				/* Number of arguments passed to this proc */
      471 	        arg_len,
      472 	        se_len,				/* Selection expression length */
      473 	        vi,				/* index of tuple_variable for relation being modified. */
      474 	        num_args
      475 	        )			 fixed bin;	/* Number of args passed to translate */
      476 
      477 
      478 	dcl     icode		 fixed bin (35);	/* Internal error code */
      479 	dcl     ntuples_modified	 fixed bin (35);	/* modified tuple counter */
      480 
      481 	dcl     arg_error		 condition;	/* Condition signaled if less then 3 arguments
      482*						   were passed to this proc */
      483 
      484 	dcl     (addrel, null, addr, fixed, rel) builtin;
      485 	declare mu_define_area$define_temp_dir_area
      486 				 entry (ptr, fixed bin (35), fixed bin (18), char (11), bit (1) aligned,
      487 				 bit (1) aligned, bit (1) aligned, bit (1) aligned, fixed bin (35));
      488 	declare area_ptr		 ptr;
      489 	declare mu_release_area	 entry (ptr);
      490 	declare se_len_ptr		 ptr;		/* temp for getting varying se len */
      491 	declare se_len_ovrly	 fixed bin (35) based;
      492 	dcl     mu_define_area$define_spec_temp_dir_area entry (ptr, fixed bin (35), char (11), fixed bin (35));
      493 dcl  last_tuple_id bit (36) aligned; /* Last tuple id used to check for redundancy */
      494 	dcl     attr_no		 fixed bin;
      495 	dcl     bit_length		 fixed bin (35);
      496 	dcl     bit_string		 bit (bit_length) unal based;
      497 	dcl     done		 bit (1);		/* true => mrds_dsl_search found no more tuples */
      498 	dcl     i			 fixed bin;	/* loop counter */
      499 	dcl     number_of_tuples_modified fixed bin (35); /* number of tuples by the call to modify_tuples_by_id */
      500 	dcl     collection_id	 bit (36) aligned;	/* collection id with a declaration suitable for passing to mu_cursor_manager_ */
      501 
      502 	dcl     cleanup		 condition;
      503 	dcl     any_other		 condition;
      504 
      505 	dcl     original_appl_ptr	 ptr;		/* original values stored so that we can start over */
      506 	dcl     original_adpl_ptr	 ptr;		/* in case of rollback */
      507 	dcl     original_num_args	 fixed bin;
      508 	dcl     dbi_pic		 picture "999";
      509 
      510      end mrds_dsl_modify;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/16/89  1241.8  mrds_dsl_modify.pl1               >spec>install>1093>mrds_dsl_modify.pl1
212          1    02/05/86  1416.4  mrds_start_transaction.incl.pl1   >ldd>include>mrds_start_transaction.incl.pl1
1-79         2    01/07/85  0900.0  dm_tm_modes.incl.pl1              >ldd>include>dm_tm_modes.incl.pl1
1-81         3    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
350          4    02/05/86  1416.4  mrds_finish_transaction.incl.pl1  >ldd>include>mrds_finish_transaction.incl.pl1
395          5    08/04/88  2043.3  mrds_dbcb.incl.pl1                >ldd>include>mrds_dbcb.incl.pl1
397          6    10/14/83  1609.1  mdbm_rm_rel_info.incl.pl1         >ldd>include>mdbm_rm_rel_info.incl.pl1
399          7    10/14/83  1609.1  mdbm_rm_attr_info.incl.pl1        >ldd>include>mdbm_rm_attr_info.incl.pl1
401          8    10/14/83  1609.1  mrds_range.incl.pl1               >ldd>include>mrds_range.incl.pl1
403          9    08/04/88  2043.3  mrds_select_list.incl.pl1         >ldd>include>mrds_select_list.incl.pl1
405         10    10/14/83  1609.0  mrds_tuple_info.incl.pl1          >ldd>include>mrds_tuple_info.incl.pl1
407         11    10/14/83  1609.0  mdbm_arg_list.incl.pl1            >ldd>include>mdbm_arg_list.incl.pl1
409         12    10/14/83  1608.6  mdbm_descriptor.incl.pl1          >ldd>include>mdbm_descriptor.incl.pl1
411         13    03/06/85  1031.5  dm_element_id_list.incl.pl1       >ldd>include>dm_element_id_list.incl.pl1
413         14    10/14/83  1609.1  vu_typed_vector.incl.pl1          >ldd>include>vu_typed_vector.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ELEMENT_ID_LIST_VERSION_1       000173 automatic       fixed bin(35,0)          initial dcl 13-28 set ref 266 13-28*
SCOPE_UPDATE                           constant        fixed bin(17,0)          initial dcl 466 ref 246
TM_NORMAL_MODE                  000003 constant        fixed bin(17,0)          initial dcl 2-15 set ref 1-99*
addr                                                   builtin function         dcl 484 ref 173 178 189 1-123 1-123
addrel                                                 builtin function         dcl 484 ref 182
adpl_ptr                        000206 automatic       pointer                  dcl 454 set ref 173* 178* 205 230* 369*
al_ptr                          000160 automatic       pointer                  dcl 11-13 set ref 147* 148 151 170 171 172 173 176
                                                                                  177 178 189
any_other                       000254 stack reference condition                dcl 503 ref 210
appl_ptr                        000204 automatic       pointer                  dcl 454 set ref 189* 204 230* 368*
area_ptr                        000232 automatic       pointer                  dcl 488 set ref 144* 225* 230* 261* 265 277* 305*
arg_count                              based           fixed bin(17,0)          level 2 packed packed unaligned dcl 11-6 ref 151 171
                                                                                  176
arg_des_ptr               2            based           pointer                  array level 2 dcl 11-6 set ref 172 173 177 178 189
arg_error                       000224 stack reference condition                dcl 481 ref 148 152 157
arg_len                         000215 automatic       fixed bin(17,0)          dcl 469 set ref 156* 160*
arg_list                               based           structure                level 1 unaligned dcl 11-6
attr_no                         000237 automatic       fixed bin(17,0)          dcl 494 set ref 332* 333 335
attr_ptrs                              based           pointer                  array level 2 dcl 6-119 ref 333
bit_length               24            based           fixed bin(35,0)          level 2 in structure "rm_attr_info" dcl 7-46
                                                                                  in procedure "modify" ref 333
bit_length                      000240 automatic       fixed bin(35,0)          dcl 495 in procedure "modify" set ref 333* 335 335
bit_string                             based           bit                      packed unaligned dcl 496 set ref 335* 335
cd                                     parameter       fixed bin(35,0)          dcl 387 ref 384 389
cd_ptr                          000210 automatic       pointer                  dcl 454 set ref 156* 325 346 348 4-115 389
cleanup                         000246 stack reference condition                dcl 502 ref 208
code                      0(18)        based           fixed bin(17,0)          level 2 in structure "arg_list" packed packed
                                                                                  unaligned dcl 11-6 in procedure "modify" ref 170
code                                   based           fixed bin(35,0)          dcl 447 in procedure "modify" set ref 325* 346 348
                                                                                  4-115* 389*
collection_id                   000244 automatic       bit(36)                  dcl 500 set ref 254* 255*
condition_info                         based           structure                level 1 dcl 3-14
condition_name            3     000110 automatic       varying char(32)         level 2 dcl 1-77 set ref 1-124 1-129 1-129
continue_to_signal_             000010 constant        entry                    external dcl 1-61 ref 1-137
create_cursor           156            based           entry variable           level 4 dcl 5-142 set ref 255*
cu_$arg_list_ptr                000040 constant        entry                    external dcl 418 ref 147
cu_$arg_ptr                     000042 constant        entry                    external dcl 419 ref 156 160 164
current_flag            106(01)        based           bit(1)                   level 3 packed packed unaligned dcl 5-142 ref 240
                                                                                  273 327
current_ptr              16            based           pointer                  level 3 dcl 5-142 ref 240
cursor_ptr                      000200 automatic       pointer                  dcl 454 set ref 255* 312*
cursor_ptrs_storage_ptr
                        130            based           pointer                  level 3 dcl 5-142 set ref 255*
cursor_storage_area_ptr
                        132            based           pointer                  level 3 dcl 5-142 set ref 255*
data                                   based           structure                level 2 dcl 5-142
database_index                         based           fixed bin(35,0)          dcl 448 set ref 196* 219* 227* 255*
dbcb                                   based           structure                level 1 dcl 5-142
dbcb_data                              based           structure                level 1 unaligned dcl 5-148
dbcb_ptr                        000144 automatic       pointer                  dcl 5-146 set ref 144* 196* 199 202 217 218 219 225
                                                                                  227 230* 235 238 239 240 240 242 255 255 255 255
                                                                                  261 273 277* 305* 312 312 327 330 340 343 343 372
                                                                                  374 376
dbi                     114            based           fixed bin(35,0)          level 3 dcl 5-142 ref 218
dbi_pic                         000267 automatic       picture(3)               packed unaligned dcl 508 set ref 218* 219 227
dbi_ptr                         000212 automatic       pointer                  dcl 454 set ref 160* 196 219 227 255
desc_ptr                        000164 automatic       pointer                  dcl 12-19 set ref 172* 177* 181
descriptor                             based           structure                level 1 unaligned dcl 12-6
dimension                 1            based           structure                array level 2 in structure "general_typed_vector"
                                                                                  packed packed unaligned dcl 14-24 in procedure
                                                                                  "modify"
dimension                 1            based           structure                array level 2 in structure "simple_typed_vector"
                                                                                  packed packed unaligned dcl 14-17 in procedure
                                                                                  "modify"
dm_error_$bj_journal_full       000030 external static fixed bin(35,0)          dcl 4-52 ref 1-132
dm_error_$lock_deadlock         000032 external static fixed bin(35,0)          dcl 4-53 ref 4-78 1-126
dm_error_$no_current_transaction
                                000012 external static fixed bin(35,0)          dcl 1-62 ref 1-90
done                            000241 automatic       bit(1)                   packed unaligned dcl 497 set ref 252* 272 300* 309*
eil_number_of_elements          000172 automatic       fixed bin(35,0)          dcl 13-27 set ref 264* 265 265
element_id_list                        based           structure                level 1 dcl 13-21 set ref 265
element_id_list_ptr             000170 automatic       pointer                  dcl 13-26 set ref 265* 266 275 283 286 286 287 287
                                                                                  296 304 306 306 312*
find_condition_info_            000014 constant        entry                    external dcl 1-64 ref 1-123
general_typed_vector                   based           structure                level 1 packed packed unaligned dcl 14-24
general_typed_vector_ptr        000176 automatic       pointer                  dcl 14-38 set ref 330* 331 332 335
i                               000242 automatic       fixed bin(17,0)          dcl 498 set ref 276* 331* 332 335*
icode                           000221 automatic       fixed bin(35,0)          dcl 478 set ref 156* 157 160* 161 161* 164* 165 165*
                                                                                  219* 223 223* 227* 228 228* 230* 233 233* 255* 258
                                                                                  258* 261* 262 262* 272 276 277* 278 292 292 292*
                                                                                  294 296* 299* 305* 306 308* 312* 314 314* 320 320*
                                                                                  322*
id                        2            based           bit(36)                  array level 2 dcl 13-21 set ref 287* 306*
identifier                1            based           fixed bin(17,0)          array level 3 packed packed unaligned dcl 14-24 ref
                                                                                  332
item                     10            based           structure                array level 2 unaligned dcl 9-22
last_tuple_id                   000236 automatic       bit(36)                  dcl 493 set ref 270* 283 289*
mdbm_error_$inc_ready_mode      000066 external static fixed bin(35,0)          dcl 437 set ref 246*
mdbm_error_$view_prevent        000070 external static fixed bin(35,0)          dcl 437 set ref 248*
mftxn_code                      000142 automatic       fixed bin(35,0)          dcl 4-54 set ref 346* 348* 4-62* 4-65 4-68* 4-69
                                                                                  4-78 4-115 4-115 1-126* 1-132*
mftxn_temp_code                 000143 automatic       fixed bin(35,0)          dcl 4-55 set ref 4-71* 4-72 4-72* 4-82* 4-83 4-85*
                                                                                  4-86 4-86* 4-96* 4-97 4-99* 4-100 4-100* 4-109*
                                                                                  4-110 4-110*
ml_ptr                    2            based           pointer                  array level 2 dcl 9-40 set ref 261*
mla_ptr                   2            based           pointer                  level 2 dcl 9-22 ref 261
modify                   21(01)        based           bit(1)                   level 2 packed packed unaligned dcl 6-119 ref 248
modify_area_ptr          50            based           pointer                  level 3 dcl 5-142 set ref 219* 225 343 343* 374 376*
modify_tuples_by_id     176            based           entry variable           level 4 dcl 5-142 ref 312
modify_vector_ptr        62            based           pointer                  level 3 dcl 5-142 set ref 261* 312* 330
move_list_array                        based           structure                array level 1 unaligned dcl 9-40
mrds_data_$caller_modify        000060 external static fixed bin(17,0)          dcl 433 set ref 230*
mrds_data_$max_attributes       000062 external static fixed bin(35,0)          dcl 434 ref 244 244 244
mrds_data_$max_id_len           000064 external static fixed bin(35,0)          dcl 435 ref 244 244 244
mrds_dsl_search                 000046 constant        entry                    external dcl 426 ref 277 305
mrds_dsl_translate              000050 constant        entry                    external dcl 427 ref 230
mrds_error_$inval_mod_expr      000074 external static fixed bin(35,0)          dcl 437 set ref 235*
mrds_error_$invalid_db_index    000076 external static fixed bin(35,0)          dcl 437 set ref 199*
mrds_error_$tuple_not_found     000072 external static fixed bin(35,0)          dcl 437 ref 292 294 346
mstxn_code                      000100 automatic       fixed bin(35,0)          dcl 1-65 set ref 1-83* 1-89* 1-90 1-99* 1-140 1-140*
                                                                                  4-90* 4-104* 1-137*
mstxn_condition_info            000110 automatic       structure                level 1 unaligned dcl 1-77 set ref 1-123 1-123
mstxn_retries                   000101 automatic       fixed bin(17,0)          dcl 1-66 set ref 1-88* 4-78 4-81* 4-81
mstxn_temp_code                 000102 automatic       fixed bin(35,0)          dcl 1-67 set ref 1-109* 1-110 1-110* 1-123*
mstxn_transactions_needed       000103 automatic       bit(1)                   dcl 1-68 set ref 202* 1-86
mstxn_txn_id                    000105 automatic       bit(36)                  dcl 1-70 set ref 145* 1-84* 1-89* 1-93 1-94* 1-99*
                                                                                  1-100 4-60 4-68* 4-71* 4-72* 4-82* 4-85* 4-86*
                                                                                  4-96* 4-99* 4-100* 4-109* 4-110* 4-114* 1-107
                                                                                  1-109* 1-110* 1-121
mu_build_tuple                  000052 constant        entry                    external dcl 428 ref 261
mu_cursor_manager_$get          000054 constant        entry                    external dcl 429 ref 255
mu_database_index$get_resultant_model_pointer
                                000056 constant        entry                    external dcl 430 ref 196
mu_define_area$define_spec_temp_dir_area
                                000104 constant        entry                    external dcl 492 ref 227
mu_define_area$define_temp_dir_area
                                000100 constant        entry                    external dcl 485 ref 219
mu_release_area                 000102 constant        entry                    external dcl 489 ref 343 376
nargs                           000214 automatic       fixed bin(17,0)          dcl 469 set ref 151* 152 156* 172 173 177 178 194
nkey_attr                24            based           fixed bin(17,0)          level 2 dcl 6-119 ref 333
ntuples_modified                000222 automatic       fixed bin(35,0)          dcl 479 set ref 251* 296 317* 317 322
null                                                   builtin function         dcl 484 ref 144 148 199 340 343 7-65 9-38 1-123
                                                                                  1-123 372 374
num_args                        000220 automatic       fixed bin(17,0)          dcl 469 set ref 194* 206 230* 370*
num_dims                        000166 automatic       fixed bin(17,0)          initial dcl 12-20 set ref 12-20*
num_ptrs                        000162 automatic       fixed bin(17,0)          dcl 11-14 set ref 171* 176*
number_of_dimensions      0(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 14-24 ref 331
number_of_elements        1            based           fixed bin(35,0)          level 2 dcl 13-21 set ref 265* 275* 283 286* 286 287
                                                                                  296 304* 306
number_of_tuples_modified       000243 automatic       fixed bin(35,0)          dcl 499 set ref 312* 317
open                    146            based           entry variable           level 4 dcl 5-142 set ref 255*
original_adpl_ptr               000264 automatic       pointer                  dcl 506 set ref 205* 369
original_appl_ptr               000262 automatic       pointer                  dcl 505 set ref 204* 368
original_num_args               000266 automatic       fixed bin(17,0)          dcl 507 set ref 206* 370
rai_ptr                         000150 automatic       pointer                  initial dcl 7-65 set ref 7-65*
range                                  based           structure                level 1 dcl 8-5
range_ptr                 2            based           pointer                  level 3 in structure "dbcb" dcl 5-142 in procedure
                                                                                  "modify" ref 239
range_ptr                       000152 automatic       pointer                  dcl 8-23 in procedure "modify" set ref 239* 244
ready_mode               37            based           fixed bin(17,0)          level 2 dcl 6-119 ref 246
rel_id                   20            based           bit(36)                  level 2 dcl 6-119 ref 254
relmgr_entries          146            based           structure                level 3 dcl 5-142
ri_ptr                                 based           pointer                  array level 3 dcl 8-5 ref 244
rm_attr_info                           based           structure                level 1 dcl 7-46
rm_rel_info                            based           structure                level 1 dcl 6-119
rmri_ptr                        000146 automatic       pointer                  dcl 6-156 set ref 244* 246 248 254 255* 261* 333
se_len                          000216 automatic       fixed bin(17,0)          dcl 469 set ref 164* 183* 230*
se_len_ovrly                           based           fixed bin(35,0)          dcl 491 ref 183
se_len_ptr                      000234 automatic       pointer                  dcl 490 set ref 182* 183
se_ptr                          000202 automatic       pointer                  dcl 454 set ref 164* 182 230*
select_list                            based           structure                level 1 unaligned dcl 9-22
select_list_ptr                 000154 automatic       pointer                  initial dcl 9-38 set ref 240* 242* 243 261 9-38*
select_ptr                4            based           pointer                  level 3 dcl 5-142 ref 242
simple_typed_vector                    based           structure                level 1 packed packed unaligned dcl 14-17
simple_typed_vector_ptr         000174 automatic       pointer                  dcl 14-33 set ref 329* 335
sys_info$max_seg_size           000044 external static fixed bin(17,0)          dcl 421 ref 219
ti_ptr                   12            based           pointer                  level 3 in structure "dbcb" dcl 5-142 in procedure
                                                                                  "modify" ref 238
ti_ptr                          000156 automatic       pointer                  dcl 10-17 in procedure "modify" set ref 238* 283 287
                                                                                  289 306 329
transaction_manager_$abandon_txn
                                000016 constant        entry                    external dcl 1-72 ref 4-72 4-86 4-100 4-110 1-110
transaction_manager_$abort_txn  000020 constant        entry                    external dcl 1-73 ref 4-71 4-85 4-99 4-109 1-109
transaction_manager_$begin_txn  000022 constant        entry                    external dcl 1-74 ref 1-99
transaction_manager_$commit_txn 000034 constant        entry                    external dcl 4-56 ref 4-68
transaction_manager_$get_current_txn_id
                                000024 constant        entry                    external dcl 1-75 ref 1-89
transaction_manager_$handle_conditions
                                000026 constant        entry                    external dcl 1-76 ref 1-135
transaction_manager_$rollback_txn
                                000036 constant        entry                    external dcl 4-57 ref 4-82 4-96
transactions_needed     106(13)        based           bit(1)                   level 3 packed packed unaligned dcl 5-142 ref 202
tup_var                   2            based           structure                array level 2 dcl 8-5
tuple                     2            based           structure                array level 2 dcl 10-10
tuple_id                  4            based           bit(36)                  array level 3 dcl 10-10 ref 283 287 289 306
tuple_info                             based           structure                level 1 dcl 10-10
tuple_ptr                 2            based           pointer                  array level 3 dcl 10-10 ref 329
type                      0(01)        based           fixed bin(6,0)           level 2 packed packed unsigned unaligned dcl 12-6
                                                                                  ref 181
user_started_transaction
                        106(22)        based           bit(1)                   level 3 in structure "dbcb" packed packed unaligned
                                                                                  dcl 5-142 in procedure "modify" set ref 217*
user_started_transaction        000104 automatic       bit(1)                   dcl 1-69 in procedure "modify" set ref 1-92* 1-98*
                                                                                  217 4-60
user_transaction_id             000106 automatic       bit(36)                  dcl 1-71 set ref 1-93* 1-100*
val_mod                 106(10)        based           bit(1)                   level 3 packed packed unaligned dcl 5-142 ref 235
value_ptr                 2            based           pointer                  array level 3 in structure "general_typed_vector"
                                                                                  packed packed unaligned dcl 14-24 in procedure
                                                                                  "modify" ref 335
value_ptr                 1            based           pointer                  array level 3 in structure "simple_typed_vector"
                                                                                  packed packed unaligned dcl 14-17 in procedure
                                                                                  "modify" ref 335
var_index                11            based           fixed bin(17,0)          array level 3 dcl 9-22 ref 243
version                                based           fixed bin(35,0)          level 2 dcl 13-21 set ref 266*
vi                              000217 automatic       fixed bin(17,0)          dcl 469 set ref 243* 244 283 287 289 306 329
wa                                     based           area                     dcl 449 ref 265
work_area_ptr            70            based           pointer                  level 3 dcl 5-142 set ref 227*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 14-43
HIGHEST_MODE                           internal static fixed bin(17,0)          initial dcl 2-12
LOWEST_MODE                            internal static fixed bin(17,0)          initial dcl 2-12
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 14-43
SIMPLE_TYPED_VECTOR_TYPE               internal static fixed bin(17,0)          initial dcl 14-43
TM_NEVER_WRITE_MODE                    internal static fixed bin(17,0)          initial dcl 2-18
TM_READ_ONLY_MODE                      internal static fixed bin(17,0)          initial dcl 2-17
TM_STATISTICAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-16
TM_TEST_NEVER_WRITE_MODE               internal static fixed bin(17,0)          initial dcl 2-22
TM_TEST_NORMAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-19
TM_TEST_READ_ONLY_MODE                 internal static fixed bin(17,0)          initial dcl 2-21
TM_TEST_STATISTICAL_MODE               internal static fixed bin(17,0)          initial dcl 2-20
condition_info_ptr                     automatic       pointer                  dcl 3-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 3-30
error_table_$null_info_ptr             external static fixed bin(35,0)          dcl 1-63
fixed                                                  builtin function         dcl 484
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 14-40
natts_init                             automatic       fixed bin(17,0)          dcl 6-157
nkey_attr_init                         automatic       fixed bin(17,0)          dcl 6-157
nvar_atts_init                         automatic       fixed bin(17,0)          dcl 6-157
rel                                                    builtin function         dcl 484
stv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 14-35
ti_ntuples_init                        automatic       fixed bin(17,0)          dcl 10-18

NAMES DECLARED BY EXPLICIT CONTEXT.
error                           002034 constant        entry                    internal dcl 384 ref 161 165 199 1-140 223 228 233
                                                                                  235 246 248 258 262 292 296 308 314 320 322
exit                            001363 constant        label                    dcl 340 ref 390
mftxn_check_code                001422 constant        label                    dcl 4-65 ref 1-127 1-133
mftxn_exit                      001642 constant        label                    dcl 4-115 ref 4-63
modify                          000052 constant        entry                    external dcl 28
mrds_dsl_modify                 000062 constant        entry                    external dcl 28
mstxn_any_other                 001700 constant        entry                    internal dcl 1-116 ref 210
mstxn_cleanup                   001646 constant        entry                    internal dcl 1-102 ref 208
mstxn_exit                      000437 constant        label                    dcl 1-140 ref 1-86 1-95 4-91 4-105
restore_significant_data        002004 constant        entry                    internal dcl 366 ref 4-77
should_rollback                 001775 constant        entry                    internal dcl 358 ref 4-94

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2534        2642    2061        2544
Length      3402    2061       106         524     452           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
modify                              288 external procedure  is an external procedure.  
on unit on line 208                  76 on unit               
on unit on line 210                  82 on unit               
mstxn_cleanup                           internal procedure  shares stack frame of on unit on line 208.  
mstxn_any_other                         internal procedure  shares stack frame of on unit on line 210.  
should_rollback                         internal procedure  shares stack frame of external procedure modify.  
restore_significant_data                internal procedure  shares stack frame of external procedure modify.  
error                                   internal procedure  shares stack frame of external procedure modify.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
modify                   000100 mstxn_code                  modify
                         000101 mstxn_retries               modify
                         000102 mstxn_temp_code             modify
                         000103 mstxn_transactions_needed   modify
                         000104 user_started_transaction    modify
                         000105 mstxn_txn_id                modify
                         000106 user_transaction_id         modify
                         000110 mstxn_condition_info        modify
                         000142 mftxn_code                  modify
                         000143 mftxn_temp_code             modify
                         000144 dbcb_ptr                    modify
                         000146 rmri_ptr                    modify
                         000150 rai_ptr                     modify
                         000152 range_ptr                   modify
                         000154 select_list_ptr             modify
                         000156 ti_ptr                      modify
                         000160 al_ptr                      modify
                         000162 num_ptrs                    modify
                         000164 desc_ptr                    modify
                         000166 num_dims                    modify
                         000170 element_id_list_ptr         modify
                         000172 eil_number_of_elements      modify
                         000173 ELEMENT_ID_LIST_VERSION_1   modify
                         000174 simple_typed_vector_ptr     modify
                         000176 general_typed_vector_ptr    modify
                         000200 cursor_ptr                  modify
                         000202 se_ptr                      modify
                         000204 appl_ptr                    modify
                         000206 adpl_ptr                    modify
                         000210 cd_ptr                      modify
                         000212 dbi_ptr                     modify
                         000214 nargs                       modify
                         000215 arg_len                     modify
                         000216 se_len                      modify
                         000217 vi                          modify
                         000220 num_args                    modify
                         000221 icode                       modify
                         000222 ntuples_modified            modify
                         000232 area_ptr                    modify
                         000234 se_len_ptr                  modify
                         000236 last_tuple_id               modify
                         000237 attr_no                     modify
                         000240 bit_length                  modify
                         000241 done                        modify
                         000242 i                           modify
                         000243 number_of_tuples_modified   modify
                         000244 collection_id               modify
                         000262 original_appl_ptr           modify
                         000264 original_adpl_ptr           modify
                         000266 original_num_args           modify
                         000267 dbi_pic                     modify

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ent_var        call_ext_out        return_mac          tra_ext_1           signal_op           enable_op
ext_entry           int_entry           trunc_fx2           divide_fx1          op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
continue_to_signal_           cu_$arg_list_ptr              cu_$arg_ptr                   find_condition_info_
mrds_dsl_search               mrds_dsl_translate            mu_build_tuple                mu_cursor_manager_$get
mu_database_index$get_resultant_model_pointer               mu_define_area$define_spec_temp_dir_area
mu_define_area$define_temp_dir_area                         mu_release_area
transaction_manager_$abandon_txn                            transaction_manager_$abort_txn
transaction_manager_$begin_txn                              transaction_manager_$commit_txn
transaction_manager_$get_current_txn_id                     transaction_manager_$handle_conditions
transaction_manager_$rollback_txn

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bj_journal_full     dm_error_$lock_deadlock       dm_error_$no_current_transaction
mdbm_error_$inc_ready_mode    mdbm_error_$view_prevent      mrds_data_$caller_modify      mrds_data_$max_attributes
mrds_data_$max_id_len         mrds_error_$inval_mod_expr    mrds_error_$invalid_db_index  mrds_error_$tuple_not_found
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 7   65 000041    9   38 000043   12   20 000044   13   28 000045        28 000051       144 000070       145 000073
    147 000074       148 000103       151 000112       152 000122       156 000127       157 000144       160 000151
    161 000170       164 000174       165 000213       170 000217       171 000224       172 000227       173 000234
    174 000237       176 000240       177 000244       178 000251       181 000254       182 000261       183 000264
    189 000266       194 000271       196 000274       199 000305       202 000320       204 000325       205 000327
    206 000331       208 000333       210 000351    1   83 000367    1   84 000370    1   86 000371    1   88 000373
 1   89 000374    1   90 000405    1   92 000411    1   93 000413    1   94 000415    1   95 000416    1   98 000417
 1   99 000420    1  100 000435    1  140 000437       217 000443       218 000451       219 000461       223 000527
    225 000533       227 000536       228 000562       230 000566       233 000615       235 000621       238 000634
    239 000637       240 000642       242 000651       243 000653       244 000655       246 000715       248 000726
    251 000741       252 000742       254 000743       255 000746       258 001001       261 001005       262 001033
    264 001037       265 001041       266 001052       270 001054       272 001055       273 001062       275 001066
    276 001070       277 001077       278 001112       283 001114       286 001126       287 001132       289 001136
    291 001140       292 001142       294 001153       296 001155       299 001166       300 001167       302 001171
    304 001172       305 001175       306 001210       308 001221       309 001223       312 001225       314 001244
    317 001250       318 001254       320 001255       322 001262       325 001267       327 001270       329 001274
    330 001301       331 001303       332 001317       333 001331       335 001343       337 001361       340 001363
    343 001370       346 001404       348 001412    4   60 001413    4   62 001420    4   63 001421    4   65 001422
 4   68 001424    4   69 001435    4   71 001437    4   72 001450    4   75 001463    4   77 001464    4   78 001465
 4   81 001474    4   82 001475    4   83 001510    4   85 001512    4   86 001523    4   88 001536    4   90 001537
 4   91 001540    4   93 001541    4   94 001542    4   96 001547    4   97 001563    4   99 001565    4  100 001576
 4  102 001611    4  104 001612    4  105 001613    4  107 001614    4  109 001615    4  110 001626    4  114 001641
 4  115 001642       355 001645    1  102 001646    1  107 001647    1  109 001652    1  110 001663    1  114 001677
 1  116 001700    1  121 001701    1  123 001704    1  124 001723    1  126 001731    1  127 001734    1  129 001737
 1  132 001751    1  133 001754    1  135 001757    1  136 001764    1  137 001765    1  138 001774       358 001775
    360 001777       366 002004       368 002005       369 002007       370 002011       372 002013       374 002017
    376 002024       380 002033       384 002034       389 002036       390 002040


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
