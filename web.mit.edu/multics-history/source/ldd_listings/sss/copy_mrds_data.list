	COMPILATION LISTING OF SEGMENT copy_mrds_data
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1332.4 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 
        8 /****^  HISTORY COMMENTS:
        9*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
       10*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
       11*     This entry is being made to cover the change made on 85-04-19 by Thanh
       12*     Nguyen. (see mrds #136)
       13*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
       14*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
       15*     Set the bit dbcb.dont_check_txn_id to indicate that we will have multiple
       16*     txns across one selection_expression (because of transaction_group_size,
       17*     see mrds #156).
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 copy_mrds_data: cpmd: procedure ();
       22 
       23 /*
       24*   BEGIN_DESCRIPTION:
       25*
       26*   This command was written to assist in converting vfile_ databases
       27*   into DMS databases, with the least impact on existing user
       28*   application programs.  It has, however, been generalized so that
       29*   the input and output databases can each be either a vfile_
       30*   database or a DM database.  To copy a database, one must first
       31*   obtain a copy of the create_mrds_db source, using the 
       32*   display_mrds_dm command if neccessary to obtain the needed
       33*   information.  Using a new pathname, use create_mrds_db
       34*   to create a new database.  You now have an "unpopulated" 
       35*   database. To get the old data into the new database, use this
       36*   command, giving the old database pathname first, and the old
       37*   database pathname second.  This program will then retrieve the
       38*   data from the old database, and store it into the new database. 
       39*
       40*   END_DESCRIPTION
       41*
       42*
       43*   COMMAND ARGUMENTS
       44*
       45*   input_db_path   -  -  (input)  first argument, the pathname of the old
       46*   database that is to be copied.  
       47*
       48*   output_db_path   -  -  (input)  second argument, the pathname of the new
       49*   database.  
       50*
       51*   HISTORY:
       52*
       53*   Originally written by Donna Woodka, 82-08-23.
       54*   Modified 82-12-20 by PWB to remove restriction of the input having to be a
       55*            vfile_ database and the output having to be a FAMIS database.
       56*   Modified 83-07-20 by PWB to change the opening from exclusive update to:
       57*            input db:  open r, permit r, prevent dms
       58*            output db: open u, permit rs, prevent dms
       59*            and to add -input_prevent_ops, -output_prevent_ops & 
       60*            -transaction_group_size.
       61*   Modified 84-10-17 by PWB in an attempt to make it work with databases that
       62*            have been restructured in a nonstandard fashion.  If this journal
       63*            notice remains, it worked.
       64**/
       65 
       66 /* Area */
       67 
       68 	dcl     work_area		 area (sys_info$max_seg_size) based (temp_seg_ptr); /* space for tuple data */
       69 
       70 /* Automatic */
       71 
       72 	dcl     arg_length		 fixed bin (21);
       73 	dcl     arg_ptr		 ptr;
       74 	dcl     attr_bit_length	 fixed bin (35);
       75 	dcl     data_space_ptr_ptr	 ptr;		/* ptr to array of data space ptrs */
       76 	dcl     error_code		 fixed bin (35);	/* error status encoding */
       77 	dcl     finished		 bit (1);		/* set when no more tuples are to be retrieved */
       78 	dcl     first_retrieval	 bit (1);		/* on => first tuple retrieval for a relation */
       79 	dcl     found		 bit (1);		/* on => relation name in output model found in input model */
       80 	dcl     i			 fixed bin;	/* index thru all relations in output model */
       81 	dcl     input_abs_path	 char (168);	/* absolute version of input database path */
       82 	dcl     input_converted_time	 char (24);	/* character version of date/time */
       83 	dcl     input_db_uid	 bit (36);	/* unique id for input db dir */
       84 	dcl     input_dbi		 fixed bin (35);	/* DB index */
       85 	dcl     input_dm_ptr	 ptr;		/* ptr to data model */
       86 	dcl     input_dmh_ptr	 ptr;		/* points to header info */
       87 	dcl     input_path_len	 fixed bin (21);	/* in characters */
       88 	dcl     input_path_ptr	 ptr;
       89 	dcl     input_rd_ptr	 ptr;		/* pointer to relation description */
       90 	dcl     input_rel_missing	 bit (1);		/* the specified relation is missing in the input model */
       91 	dcl     j			 fixed bin;	/* index thru all relations in input model */
       92 	dcl     k			 fixed bin;	/* relation index for all data moves */
       93 	dcl     l			 fixed bin;	/* index thru all attributes in present input relation */
       94 	dcl     m			 fixed bin;	/* index thru all attributes in present output relation */
       95 	dcl     nargs		 fixed bin;	/* current argument count */
       96 	dcl     n			 fixed bin;	/* general index */
       97 	dcl     n_rels_to_be_copied	 fixed bin;	/* number of relations being copied */
       98 	dcl     op_num		 fixed bin;	/* character position within scope string */
       99 	dcl     output_abs_path	 char (168);	/* absolute version of input database path */
      100 	dcl     output_converted_time	 char (24);	/* character version of date/time */
      101 	dcl     output_db_uid	 bit (36);	/* unique id for output db dir */
      102 	dcl     output_dbcb_ptr	 ptr;		/* ptr to dbcb for output DB */
      103 	dcl     output_dbi		 fixed bin (35);	/* DB index */
      104 	dcl     output_dm_ptr	 ptr;		/* ptr to data model */
      105 	dcl     output_dmh_ptr	 ptr;		/* points to header info */
      106 	dcl     output_path_len	 fixed bin (21);	/* in characters */
      107 	dcl     output_path_ptr	 ptr;
      108 	dcl     output_rd_ptr	 ptr;		/* pointer to relation description */
      109 	dcl     rel_arg_length	 fixed bin (21);	/* length of -rel operand */
      110 	dcl     rel_arg_ptr		 ptr;		/* ptr to -rel operand */
      111 	dcl     retrieve_al_ptr	 ptr;		/* points to arg_list for retrieve */
      112 	dcl     retrieve_desc_index	 fixed bin;	/* array offset of descriptor pointers in arg_list */
      113 	dcl     retrieve_select_expr	 char (53) aligned; /* "select * from relname" */
      114 	dcl     rtbc_ptr		 ptr;		/* ptr to relations_to_be_copied structure */
      115 	dcl     single_relation	 bit (1);		/* copying only one relation */
      116 	dcl     specified_input_prevents
      117 				 fixed bin;	/* prevent ops for input relation */
      118 	dcl     specified_output_prevents
      119 				 fixed bin;	/* prevent ops for output relation */
      120 	dcl     store_al_ptr	 ptr;		/* points to arg_list for store */
      121 	dcl     store_select_expr	 char (32) aligned; /* relation name for doing mrds_dsl_store */
      122 	dcl     temp_seg_ptr	 ptr;		/* points to temp segment */
      123 	dcl     transaction_group_size fixed bin;	/* number of tuple to be in a transaction */
      124 						/* if = 0, don't generate transactions */
      125 	dcl     transaction_tuple_count
      126 				 fixed bin;	/* running count of tuples copied */
      127 	dcl     tuples_retrieved	 fixed bin (35);	/* number of tuples copied for a relation */
      128 
      129 /* Based */
      130 
      131 	dcl     arg		 char (arg_length) based (arg_ptr);
      132 	dcl     data_space		 bit (attr_bit_length) based; /* space to allocate for attribute data */
      133 	dcl     data_space_ptr	 (input_rd_ptr -> rel_desc.num_attr) ptr based (data_space_ptr_ptr);
      134 	dcl     output_path		 char (output_path_len) based (output_path_ptr); /* pathname of output DB */
      135 	dcl     input_path		 char (input_path_len) based (input_path_ptr); /* pathname of input database */
      136 	dcl     rel_arg		 char (rel_arg_length) based (rel_arg_ptr); /* operand of -rel argument */
      137 
      138 	dcl     1 relations_to_be_copied (n_rels_to_be_copied) based (rtbc_ptr),
      139 		2 input_rel_num	 fixed,
      140 		2 output_rel_num	 fixed,
      141 		2 rel_name	 char (32);
      142 
      143 /* Builtin */
      144 
      145 	dcl     (addr, addrel, empty, fixed, null, substr, rel, rtrim,
      146 	        search, verify)
      147 				 builtin;
      148 
      149 /* Condition */
      150 
      151 	dcl     (any_other, cleanup, sub_error_, transaction_deadlock)
      152 				 condition;
      153 
      154 /* Entry */
      155 
      156 	dcl     com_err_		 entry options (variable);
      157 	dcl     cu_$arg_count	 entry (fixed bin);
      158 	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
      159 	dcl     cu_$generate_call	 entry (entry, ptr);
      160 	dcl     date_time_		 entry (fixed bin (71), char (*));
      161 	dcl     expand_pathname_	 entry (char (*), char (*), char (*), fixed bin (35));
      162 	dcl     get_temp_segment_	 entry (char (*), ptr, fixed bin (35));
      163 	dcl     hcs_$status_long	 entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
      164 	dcl     ioa_		 entry options (variable);
      165 	dcl     mrds_dm_close	 entry (ptr, fixed bin (35));
      166 	dcl     mrds_dm_get_header	 entry (ptr, ptr, ptr, fixed bin (35));
      167 	dcl     mrds_dm_get_attributes entry (ptr, char (32), ptr, ptr, fixed bin (35));
      168 	dcl     mrds_dm_open	 entry (char (168), fixed bin, ptr, fixed bin (35));
      169 	dcl     mrds_dsl_close	 entry options (variable);
      170 	dcl     mrds_dsl_get_version$get_path_info entry (char (*), ptr, fixed bin, ptr, fixed bin (35));
      171 	dcl     mrds_dsl_open	 entry options (variable);
      172 	dcl     mrds_dsl_retrieve	 entry options (variable);
      173 	dcl     mrds_dsl_set_scope$dl_scope
      174 				 entry options (variable);
      175 	dcl     mrds_dsl_set_scope$set_scope
      176 				 entry options (variable);
      177 	dcl     mrds_dsl_store	 entry options (variable);
      178 	dcl     mu_data_class$varying	 entry (ptr) returns (bit (1) aligned);
      179 	dcl     mu_data_length	 entry (bit (36)) returns (fixed bin (35));
      180 	dcl     mu_database_index$get_resultant_model_pointer entry (fixed bin (35),
      181 				 ptr);
      182 	dcl     release_temp_segment_	 entry (char (*), ptr, fixed bin (35));
      183 
      184 /* External */
      185 
      186 	dcl     error_table_$bad_arg	 fixed bin (35) ext;
      187 	dcl     error_table_$badcall	 fixed bin (35) ext static;
      188 	dcl     error_table_$badopt	 fixed bin (35) ext static;
      189 	dcl     error_table_$noarg	 fixed bin (35) ext static;
      190 	dcl     error_table_$sameseg	 fixed bin (35) ext static;
      191 	dcl     mrds_error_$no_database fixed bin (35) ext static;
      192 	dcl     mrds_error_$no_model_submodel fixed bin (35) ext static;
      193 	dcl     mrds_error_$rst_wrong_command fixed bin (35) ext;
      194 	dcl     mrds_error_$tuple_not_found fixed bin (35) ext;
      195 	dcl     mrds_error_$undef_attr fixed bin (35) ext;
      196 	dcl     mrds_error_$unknown_relation_name fixed bin (35) ext;
      197 	dcl     mrds_error_$version_not_supported fixed bin (35) ext static;
      198 	dcl     sys_info$max_seg_size	 fixed bin (35) ext;
      199 
      200 /* Internal Static */
      201 
      202 	dcl     ANOTHER_RETRIEVAL_SELECT_EXPR char (8) aligned internal static options (constant)
      203 				 init ("-another"); /* for second until EOF retrievals */
      204 	dcl     CALLER_NAME		 char (15) internal static options (constant)
      205 				 init ("copy_mrds_data");
      206 	dcl     CHAR_8_DESCR	 bit (36) internal static options (constant)
      207 				 init ("101010100000000000000000000000001000"b);
      208 	dcl     CHAR_32_DESCR	 bit (36) internal static options (constant)
      209 				 init ("101010100000000000000000000000100000"b);
      210 	dcl     CHAR_53_DESCR	 bit (36) internal static options (constant)
      211 				 init ("101010100000000000000000000000110101"b);
      212 	dcl     FIXED_BIN_35_DESCR	 bit (36) internal static options (constant)
      213 				 init ("100000100000000000000000000000100011"b);
      214 	dcl     ON		 bit (1) internal static options (constant)
      215 				 init ("1"b);
      216 	dcl     OFF		 bit (1) internal static options (constant)
      217 				 init ("0"b);
      218 	dcl     PAREN_SELECT	 char (11) internal static options (constant)
      219 				 init (") -select x");
      220 	dcl     RANGE_PAREN		 char (10) internal static options (constant)
      221 				 init ("-range (x ");
      222 	dcl     RETRIEVAL_MODE	 fixed bin internal static options (constant)
      223 				 init (2);
      224 
      225 /* Include */
      226 
  1     1 /* BEGIN mdbm_arg_list.incl.pl1 -- jaw 5/31/78 */
  1     2 /* the duplicate mrds_arg_list.incl.pl1 was eliminated by Jim Gray, Nov. 1979 */
  1     3 
  1     4 /* layout of argument list for IDS and DBM entries with options (variable) */
  1     5 
  1     6 dcl 1 arg_list based (al_ptr),
  1     7     2 arg_count fixed bin (17) unal,			/* 2 * no. of args. */
  1     8     2 code fixed bin (17) unal,			/* 4 => normal, 8 => special */
  1     9     2 desc_count fixed bin (17) unal,			/* 2 * no. of descriptors */
  1    10     2 pad fixed bin (17) unal,			/* must be 0 */
  1    11     2 arg_des_ptr (num_ptrs) ptr;			/* argument/descriptor pointer */
  1    12 
  1    13 dcl  al_ptr ptr;
  1    14 dcl  num_ptrs fixed bin;
  1    15 
  1    16 /* END mdbm_arg_list.incl.pl1  */
  1    17 
      227 
      228 
  2     1 /* BEGIN mdbm_descriptor.incl.pl1 -- jaw 5/31/78 */
  2     2 /* modified by Jim Gray - - Nov. 1979, to change type from fixed bin(5) to
  2     3*   unsigned fixed bin(6), so new packed decimal data types could be handled.
  2     4*   also the duplicate mrds_descriptor.incl.pl1 was eliminated. */
  2     5 
  2     6 dcl 1 descriptor based (desc_ptr),			/* map of Multics descriptor */
  2     7     2 version bit (1) unal,				/* DBM handles vers. 1 only */
  2     8     2 type unsigned fixed bin (6) unal,			/* data type */
  2     9     2 packed bit (1) unal,				/* on if data item is packed */
  2    10     2 number_dims bit (4) unal,			/* dimensions */
  2    11     2 size,					/* size for string data */
  2    12       3 scale bit (12) unal,				/* scale for num. data */
  2    13       3 precision bit (12) unal,			/* prec. for num. data */
  2    14     2 array_info (num_dims),
  2    15       3 lower_bound fixed bin (35),			/* lower bound of dimension */
  2    16       3 upper_bound fixed bin (35),			/* upper bound of dimension */
  2    17       3 multiplier fixed bin (35);			/*  element separation */
  2    18 
  2    19 dcl  desc_ptr ptr;
  2    20 dcl  num_dims fixed bin init (0) ;			/* more useful form of number_dims */
  2    21 
  2    22 /* END mdbm_descriptor.incl.pl1 */
  2    23 
  2    24 
      229 
      230 
  3     1 /*  BEGIN  mdbm_rm_attr_info.incl.pl1  --  jaw,  11/16/78  */
  3     2 
  3     3 /* WARNING
  3     4*          If the rm_attr_info structure is changed then the mrds_data_
  3     5*          item saved_res_version MUST be incremented to invalidate all
  3     6*          existing saved resultants
  3     7**/
  3     8 
  3     9 /*
  3    10*
  3    11*   Modified  by  Jim  Gray - - 80-11-05, to add mdbm_secured bit, so
  3    12*   that rm_rel_info does not have to be checked
  3    13*
  3    14*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  3    15*   foreign keys.
  3    16*
  3    17*   82-08-19  D. Woodka : removed rm_attr_info.bit_offset for the DMS
  3    18*   conversion.
  3    19*
  3    20*   82-09-15 Davids: added the number_of_dups field.
  3    21*
  3    22*   82-09-20 Mike Kubicar : changed the index_id field to be bit (36)
  3    23*   aligned.  This is to conform with the new definition in the database
  3    24*   model.  Also removed the now useless field varying.
  3    25*
  3    26*   82-11-05 Davids: added the field model_defn_order and clarified the
  3    27*   comment for the field defn_order.
  3    28*
  3    29*   83-05-23 Mike Kubicar : changed number_of_dups to fixed bin (35) since
  3    30*   that's what relation manager returns.
  3    31*
  3    32**/
  3    33 
  3    34 
  3    35 /*
  3    36*   this   structure   is   allocated   in   the   static   area   of
  3    37*   mdbm_rm_db_info.incl.pl1  once for each attribute per relation in
  3    38*   a     readied     file.      it     in     turn     points     to
  3    39*   mdbm_rm_domain_info.incl.pl1  for  the  attributes  domain.   the
  3    40*   rm_attr_info  is  pointed  to  by mdbm_rm_rel_info.incl.pl1.  all
  3    41*   structures  are  in  the  rm_db_info  area.   the  attribute data
  3    42*   position  within  a  tuple as stored in the data file are kept in
  3    43*   this resultant model of the attribute.
  3    44* */
  3    45 
  3    46 dcl 1 rm_attr_info aligned based (rai_ptr),		/* resultant attr. info */
  3    47     2 name char (32),				/* from submodel */
  3    48     2 model_name char (32),				/* from model */
  3    49     2 key_attr bit (1) unal,				/* if key attribute */
  3    50     2 index_attr bit (1) unal,			/* if secondary index */
  3    51     2 read_perm bit (1) unal,				/* user has retr. permission */
  3    52     2 modify_perm bit (1) unal,			/* user has modify permission */
  3    53     2 mdbm_secured bit (1) unal,			/* on => database secured */
  3    54     2 reserved bit (30) unal,				/* for future use */
  3    55     2 index_id bit (36) aligned,			/* index id if index_attr */
  3    56     2 defn_order fixed bin,				/* relative order in which attr is defined in the view */
  3    57     2 key_order fixed bin,				/* relative order defined in prim. key */
  3    58     2 bit_length fixed bin (35),			/* length if fixed, max. len. if var. */
  3    59     2 domain_ptr ptr,				/* to domain info */
  3    60     2 number_of_dups fixed bin (35),                        /* if the attribute is indexed this will
  3    61*                                                               be the number of duplicate values, exact
  3    62*                                                               for a page_file database, an estimate for a vfile type */
  3    63     2 model_defn_order fixed bin;                           /* relative order in which attr is defined in the model */
  3    64 
  3    65 dcl  rai_ptr ptr int automatic init (null ());
  3    66 
  3    67 /* END mdbm_rm_attr_info.incl.pl1 */
  3    68 
  3    69 
      231 
      232 
  4     1 /* BEGIN mdbm_rm_db_info.incl.pl1 -- jaw, 11/7/78 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(86-08-13,Hergert),, approve(88-06-28,MCR7903),
  4     7*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  4     8*     Removed change of 84-11-02. i.e. replaced even_word_pad.
  4     9*                                                   END HISTORY COMMENTS */
  4    10 
  4    11 
  4    12 /* WARNING
  4    13*          If the rm_db_info structure is changed then the mrds_data_
  4    14*          item saved_res_version MUST be incremented to invalidate all
  4    15*          existing saved resultants
  4    16**/
  4    17 
  4    18 /*  DESCRIPTION:  This  structure   is   based   on   a   segment
  4    19*   {unique_name}.mrds.rdbi that represents the secure portion of the
  4    20*   resultant model that is created partially at database open  time,
  4    21*   (the rm_file_array, and rm_rel_array) and partially at ready_file
  4    22*   time,    (the    rm_file_info,     rm_rel_info,     rm_attr_info,
  4    23*   rm_domain_info, rm_plink_info and rm_clink_info). it's purpose is
  4    24*   to  provide  an  efficient  means  of  accessing  database  model
  4    25*   information, as seen from the possibly submodel view of the user,
  4    26*   and his current state of "files readied". it is the  secure  part
  4    27*   because  it  contains  the  model  information  which needs to be
  4    28*   protected  from  general  knowledge,  and   this   segment   will
  4    29*   eventually  be  capable  of  being in a lower ring. the structure
  4    30*   itself points to four arrays that are  allocated  in  it's  area,
  4    31*   that  in  turn point to the other structures mentions above, also
  4    32*   allocated in  the  rm_db_info.static_area.  the  arrays  are  the
  4    33*   rm_file_array,  and  rm_rel_array. their are a pair for temporary
  4    34*   relations,  initially  empty,  and  a  pair  for   normal   model
  4    35*   files/relations.  the  normal  rm_file_array  is initialized to a
  4    36*   list of all known file names, the rm_rel_array only gets relation
  4    37*   names   as   files  are  readied.  the  rm_file_array  points  to
  4    38*   rm_file_infos for each file (see mdbm_rm_file_info.incl.pl1)  and
  4    39*   the   rm_rel_array   points  to  rm_rel_info  for  each  relation
  4    40*   "readied". (see mdbm_rm_rel_info.incl.pl1). (the  arrays  are  in
  4    41*   mdbm_rm_file_array.incl.pl1  and mdbm_rm_rel_array.incl.pl1). the
  4    42*   file infos point to contained rel infos, the rel infos  point  to
  4    43*   contained  attr  infos,  and  those in turn to domain infos. (see
  4    44*   mdbm_rm_attr_info.incl.pl1   and    mdbm_rm_domain_info.incl.pl1)
  4    45*   foreign     keys    are    represented    by    the    structures
  4    46*   mdbm_rm_plink_info.incl.pl1, and mdbm_rm_clink_info.incl.pl1. the
  4    47*   pathnames  of the model and submodel, if any, are also maintained
  4    48*   in rm_db_info. the pointer to this rm_db_info segment is obtained
  4    49*   from  the  dbcb  segment tructure(see mrds_dbcb.incl.pl1) see the
  4    50*   individual include files for  further  organization  information,
  4    51*   and particular data structures.
  4    52*
  4    53*   HISTORY:
  4    54*
  4    55*   80-02-01 Jim Gray : Modified to put area on even  word  boundary,
  4    56*   so that define_area_ could be used to make it an extensible area
  4    57*
  4    58*   81-1-9 Jim  Gray  :  added  like  reference  to  make  the  phony
  4    59*   resultant in mu_database_index easier to keep, since no reference
  4    60*   to the area is needed.
  4    61*
  4    62*   81-1-12 Jim Gray : added version of submodel used in  opening  to
  4    63*   resultant.
  4    64*
  4    65*   81-05-13 Rickie E. Brinegar: added the administrator bit  to  the
  4    66*   structure.
  4    67*
  4    68*   81-05-28 Jim Gray : removed pointers to file_arrays,  since  they
  4    69*   are  now  combined  into  the rel_array. Removed the control file
  4    70*   info which was unused. Added pointer  to  head  of  domain  list,
  4    71*   which is to be used to insure only one copy of each domain info.
  4    72*
  4    73*   83-05-19 Davids: Added the  saved_res_version element.
  4    74*
  4    75*   84-11-02 Thanh Nguyen:   Replaced  the  even_word_pad   by   the 
  4    76*   ref_name_proc_ptr  to point  to list  of reference  name of  the
  4    77*   check, encode, or decode proc.
  4    78*
  4    79*   CAUTION: The structure entries from db_version to sm_path  should
  4    80*   not  be moved or have their declarations changed because they are
  4    81*   used in the handling of old version database openings.
  4    82*
  4    83*
  4    84**/
  4    85 
  4    86      dcl	   1 rm_db_info	      aligned based (rdbi_ptr), /* data base info, located at base of res. dm. seg. */
  4    87 	     2 data	      like rm_db_info_data,
  4    88 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (rm_db_info.static_area))));
  4    89 
  4    90      dcl	   rdbi_ptr	      ptr;
  4    91 
  4    92      declare 1 rm_db_info_data      based,		/* separate declaration of info, so others can use
  4    93*						   like reference to it without getting the area as well */
  4    94 	     2 db_version	      fixed bin,		/* version no. of db */
  4    95 	     2 sm_version	      fixed bin unal,	/* version of submodel used unal, 0 if model opening */
  4    96 	     2 val_level	      fixed bin unal,	/* validation level for this db. */
  4    97 	     2 db_path	      char (168),		/* abs. path of db. */
  4    98 	     2 sm_path	      char (168),		/* path of submodel or model */
  4    99 	     2 mdbm_secured	      bit (1) unal,		/* ON => database is secured */
  4   100 	     2 administrator      bit (1) unal,		/* ON => user is an administrator */
  4   101 	     2 pad	      bit (34) unal,	/* for future use */
  4   102 	     2 saved_res_version  char (8),		/* version of the saved resultant in the 
  4   103*                                                               dbcb and rdbi segments in the db dir */
  4   104 	     2 domain_list_ptr    ptr,		/* pointer to head of list of domain_info's */
  4   105 	     2 ra_ptr	      ptr,		/* pointer to rel. array */
  4   106 	     2 tra_ptr	      ptr,		/* to rel array for temp rels */
  4   107 	     2 even_word_pad      fixed bin (71) aligned; /* padding to put area on even word boundary */
  4   108 
  4   109 /* END mdbm_rm_db_info.incl.pl1 */
  4   110 
  4   111 
      233 
      234 
  5     1 /* BEGIN mdbm_rm_domain_info.incl.pl1 -- jaw, 9/26/78 */
  5     2 
  5     3 /* WARNING
  5     4*          If the rm_domain_info structure is changed then the mrds_data_
  5     5*          item saved_res_version MUST be incremented to invalidate all
  5     6*          existing saved resultants
  5     7**/
  5     8 
  5     9 /* DESCRIPTION:
  5    10*
  5    11*   This  structure  is  allocated  in  the  mdbm_rm_db_info.incl.pl1
  5    12*   static  area,  once per attribute used in a relation in a readied
  5    13*   file. it is pointed to by the mdbm_rm_attr_info.incl.pl1, and may
  5    14*   point  to  mdbm_rm_ck_and_group.incl.pl1  if  a  "-check"  option
  5    15*   boolean expression was declared for this domain. it contains  the
  5    16*   descriptor  for  this domain data type, and other resultant model
  5    17*   information.
  5    18*
  5    19*
  5    20*   HISTORY:
  5    21*
  5    22*   81-05-06  Rickie  E.  Brinegar:  Modified  ck_proc,  encode_proc,
  5    23*   decode_proc to be entry variables instead of entry pointers. This
  5    24*   allows these programs to be written in languages other than pl1.
  5    25*
  5    26*   81-05-28 Jim Gray : removed unused procedure points,  and  unused
  5    27*   check  stack  structure  elements.  Also made the descriptors bit
  5    28*   (36) in this structure, rather than pointers to  the  descriptors
  5    29*   elsewhere.  Also  removed un-needed redundant assign_ parameters,
  5    30*   that are actually available in the descriptors.
  5    31*
  5    32*
  5    33**/
  5    34 
  5    35 dcl 1 rm_domain_info aligned based (rdi_ptr),		/* domain information */
  5    36     2 name char (32),				/* domain name */
  5    37     2 db_desc bit (36),				/*  to desc. for db. */
  5    38     2 user_desc bit (36),				/* desc for user visible data */
  5    39     2 user_bit_len fixed bin,				/* storage length of users data */
  5    40     2 ck_proc_entry entry variable,			/* to check proc. entry */
  5    41     2 encd_proc_entry entry variable,			/* to encode proc entry */
  5    42     2 decd_proc_entry entry variable,			/* to decode proc entry */
  5    43     2 ck_proc bit (1) unal,				/* Is there a check proc */
  5    44     2 encd_proc bit (1) unal,				/* Is there an encode proc */
  5    45     2 decd_proc bit (1) unal,				/* Is there a decode proc */
  5    46     2 pad bit (33) unal,
  5    47     2 next_domain_ptr ptr ;				/* to next domain, in list of all domains */
  5    48 						/* to check stack and groups */
  5    49 
  5    50 
  5    51 dcl  rdi_ptr ptr int automatic init (null ());
  5    52 
  5    53 /* END mdbm_rm_domain_info.incl.pl1 */
  5    54 
  5    55 
      235 
      236 
  6     1 /* BEGIN mdbm_rm_rel_array.incl.pl1 -- jaw, 8/9/78 */
  6     2 
  6     3 /* WARNING
  6     4*          If the rm_rel_array structure is changed then the mrds_data_
  6     5*          item saved_res_version MUST be incremented to invalidate all
  6     6*          existing saved resultants
  6     7**/
  6     8 
  6     9 /* HISTORY:
  6    10*
  6    11*   81-05-28 Jim Gray : added  model_name  and  file_id  as  part  of
  6    12*   combining   funtions   of   file_array  and  rel_array  into  one
  6    13*   structure. This will only allow 1 relation per file model now.
  6    14*   Also changed structure to allow more efficient searching
  6    15*   via and index builtin, rather than a programmed loop.
  6    16*   Search is now I = index(string(rm_rel_array.name), "!" || in_name)
  6    17*   with I = ((I - 1) / 33) + 1 to convert from a char to array index.
  6    18*
  6    19**/
  6    20 
  6    21 
  6    22 /* this structure is allocated in the static are of the structure
  6    23*   in  mdbm_rm_db_info.incl.pl1,  the secure portion of the database
  6    24*   resultant  model  upon  opening  the  database.  two  copies  are
  6    25*   allocated,  one for temporary relations, initially empty, and one
  6    26*   for relations known to the opener, which has a length  sufficient
  6    27*   for  all  relations known to the user, but whose names, etc. will
  6    28*   not be filled  in  until  the  file  containing  that  particular
  6    29*   relation  is readied. the rm_db_info structure contains a pointer
  6    30*   to the rel_arrays, and the array entries, when  "readied",  point
  6    31*   to  the  mdbm_rm_rel_info.incl.pl1  structures  containing  model
  6    32*   information about the relation, it's attributes, etc. */
  6    33 
  6    34 dcl 1 rm_rel_array aligned based (rmra_ptr),		/* array of open relations */
  6    35     2 num_rels fixed bin,				/* no. rels in db. */
  6    36     2 name (1:rm_num_rels_init refer (rm_rel_array.num_rels)) unal,
  6    37       3 mark char (1) unal,				/* separator character = "!" */
  6    38       3 submodel char (32) unal,			/* name of relation is submodel view, model opening => model name */
  6    39     2 rel_data (rm_num_rels_init refer (rm_rel_array.num_rels)),
  6    40       3 model_name char (30),				/* name of relation in model */
  6    41       3 ri_ptr ptr unal ;				/* pointer to rm_rel_info */
  6    42 
  6    43 dcl  rmra_ptr ptr;
  6    44 dcl  rm_num_rels_init fixed bin;
  6    45 
  6    46 /* END mdbm_rm_rel_array.incl.pl1 */
  6    47 
  6    48 
      237 
      238 
  7     1 /* BEGIN mdbm_rm_rel_info.incl.pl1 -- jaw, 11/16/78 */
  7     2 
  7     3 /* WARNING
  7     4*          If the rm_rel_info structure is changed then the mrds_data_
  7     5*          item saved_res_version MUST be incremented to invalidate all
  7     6*          existing saved resultants
  7     7**/
  7     8 
  7     9 /* HISTORY:
  7    10*
  7    11*   Modified by Jim Gray - - May 1980, to  include  model  number  of
  7    12*   attributes,   and   varying  attributes,  so  that  partial  view
  7    13*   submodels will have the  info  needed  to  properly  set  up  the
  7    14*   varying length array headers in the tuple structure.
  7    15*
  7    16*   Modified  by  Jim  Gray  -  -  80-11-06,  to  rename   r_perm   =
  7    17*   status_perm,     s_perm    =    append_tuple_perm,    d_perm    =
  7    18*   delete_tuple_perm, and make m_perm = unused_perm.
  7    19*
  7    20*   81-01-23 Jim Gray : added bit to indicate whether the last  model
  7    21*   view attribute was varying character or bit, since a partial view
  7    22*   submodel will not have this information in the resultant, and  it
  7    23*   is  needed for determining the new tuple length in mus_mod_ubtup,
  7    24*   since with exact length storage  of  varying  length  attributes,
  7    25*   each  tuple  can  be  a  different  length,  which is can only be
  7    26*   determined by examining the tuple itself.
  7    27*
  7    28*   81-01-29 Jim Gray : added curent  tuple  count,  to  provide  for
  7    29*   interface  to  allow  temp  rel  population  to  be known, and to
  7    30*   provide a more efficient means of finding an approx. current perm
  7    31*   relation population.
  7    32*
  7    33*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  7    34*   blocked  files, foreign keys, and ids procedures. Also set number
  7    35*   of files per rel to a constant of 1.
  7    36*
  7    37*   81-05-28 Jim Gray : combined data  from  rm_file_info  into  this
  7    38*   structure so that only one structure per relation is needed.
  7    39*
  7    40*   81-07-02 Jim Gray : added total_key and dup_key vfile  statistics
  7    41*   counts.   Also  added  number  of  operations  count  since  last
  7    42*   statistics update, and a time  since  the  statistics  were  last
  7    43*   updated.
  7    44*
  7    45*   81-07-06 Jim Gray :  added  a  per  selection  expression  update
  7    46*   identifier so that small relations could be updated on a per S.E.
  7    47*   basis
  7    48*
  7    49*   82-04-21 R. Lackey : Added number_selected (ri_niocbs_init refer (rm_rel_info.niocbs)) fixed bin (35)
  7    50*   to end of structure   TR 12205 (Suggestion).
  7    51*   
  7    52*   82-08-19 D. Woodka :  Removed  rm_rel_info.max_data_len  field for
  7    53*   the DMS conversion. 
  7    54*
  7    55*   82-08-30 Davids: added the opening_id element and removed the iocb
  7    56*   array and the niocb element for DMS conversion. Also removed the
  7    57*   number_selected array (and ri_niocbs_init) since subsets are not
  7    58*   going to be used.
  7    59*
  7    60*   82-09-20 Mike Kubicar : changed rm_rel_info.rel_id to bit (36) aligned
  7    61*   so that it can be used with relation manager.  Also added
  7    62*   rm_rel_info.primary_key_index_id for relation manager.
  7    63*
  7    64*   82-09-22 Mike Kubicar : Removed the, now useless, fields var_attr_ptrs,
  7    65*   nvar_atts, model_nvar_atts.
  7    66*
  7    67*   82-09-24 Davids: Removed current_key_count and current_dup_key_count
  7    68*   since the duplicate key count for each secondary index is now being
  7    69*   kept in the attr_info structure and key_count was only needed to
  7    70*   help in calculating the average selectivity of each index which
  7    71*   can now be gotten directly from each index's dup key count. Also
  7    72*   removed the file_id element since it is no longer needed for
  7    73*   anything.
  7    74*
  7    75*   82-09-27 Mike Kubicar : removed file_id_len for the same reason file_id
  7    76*   was removed.
  7    77*
  7    78*   82-11-05 Mike Kubicar : added a pointer to an id_list structure to be
  7    79*   used when retrieving tuples from this relation.
  7    80*
  7    81*   83-04-06 Davids: Added the scope_flags_ptr which points to the scope_flags structure
  7    82*   for the relation. Note that this structure is part of the resultant NOT
  7    83*   part of the db.control structure. The scopes are duplicated in the resultant
  7    84*   to reduce contention for the db.control structure. Note also that the pointer
  7    85*   will always point to a scope_flags structure even if no scopes have been
  7    86*   set on the relation, the structure is allocated when the db is opened.
  7    87**/
  7    88 
  7    89 
  7    90 /* DESCRIPTION:
  7    91*
  7    92*   This structure is allocated in the area part of the structure  in
  7    93*   mdbm_rm_db_info.incl.pl1  as  part of the resultant model created
  7    94*   at open  time  for  a  database.  There  will  be  one  of  these
  7    95*   rm_rel_info   structures  for  each  relation  appearing  in  the
  7    96*   database view (there may be less than the total in  the  database
  7    97*   for  a  submodel  openings).  There  will  also  be  one for each
  7    98*   temporary relation currently defined for that opening.
  7    99*
  7   100*   The structure in mdbm_rm_rel_array.incl.pl1 contains pointers  to
  7   101*   all  rm_rel_info  structures  allocated. It is used for searching
  7   102*   for the appropriate  structure.  This  array  is  pointed  to  by
  7   103*   rm_db_info. There are two arrays, one for perm rels, one for temp
  7   104*   rels.
  7   105*
  7   106*   The      rm_rel_info      structure      points      to       the
  7   107*   mdbm_rm_attr_info.incl.pl1  structures,  one  for  each attribute
  7   108*   appearing in this view of the relation. Each  of  these  in  turn
  7   109*   point  to a mdbm_rm_domain_info.incl.pl1 structure for the domain
  7   110*   info for each attr.
  7   111*
  7   112*   Most of the other information here deals with  specifics  of  the
  7   113*   relation's  logical  definition,  such as key and secondary index
  7   114*   attribute inidicators, security permissions, and  tuple  physical
  7   115*   construction details.
  7   116*
  7   117**/
  7   118 
  7   119      dcl	   1 rm_rel_info	      aligned based (rmri_ptr), /* relation information */
  7   120 	     2 name	      char (32),		/* from submodel */
  7   121 	     2 model_name	      char (30),		/* from model */
  7   122 	     2 rel_id	      bit (36) aligned,	/* unique id. */
  7   123 	     2 retrieve	      bit (1) unal,		/* operations allowed by this view */
  7   124 	     2 modify	      bit (1) unal,
  7   125 	     2 delete	      bit (1) unal,
  7   126 	     2 store	      bit (1) unal,
  7   127 	     2 total_key	      bit (1) unal,		/* on if view includes full primary key */
  7   128 	     2 indexed	      bit (1) unal,		/* on if exists sec. index */
  7   129 	     2 mdbm_secured	      bit (1) unal,		/* on if mdbm must check security */
  7   130 	     2 status_perm	      bit (1) unal,		/* if user has status. perm. */
  7   131 	     2 append_tuple_perm  bit (1) unal,		/* if user has store perm. */
  7   132 	     2 delete_tuple_perm  bit (1) unal,		/* if user has del. perm. */
  7   133 	     2 unused_perm	      bit (1) unal,		/* for future use. */
  7   134 	     2 last_model_attr_char_var bit (1) unal,	/* on => last model varying attr is char */
  7   135 	     2 reserved	      bit (24) unal,	/* for future use */
  7   136 	     2 num_attr	      fixed bin,		/* total no. of attr. in rel. */
  7   137 	     2 model_num_attr     fixed bin,		/* total attrs in model relation */
  7   138 	     2 nkey_attr	      fixed bin,		/* no. of key attr. */
  7   139 	     2 model_nkey_attr    fixed bin,		/* total number of keys in model */
  7   140 	     2 primary_key_index_id bit (36) aligned,     /* Index id of relation's primary key */
  7   141 	     2 nsec_inds	      fixed bin,		/* no. sec. indexes */
  7   142 	     2 max_key_len	      fixed bin (35),	/* max length (chars) of primary key */
  7   143 	     2 current_tuple_population fixed bin (35),	/* last known total  tuple count for this relation */
  7   144 	     2 last_statistics_update_count fixed bin,	/* number of operations's, since this rels stats were updated */
  7   145 	     2 last_statistics_update_time fixed bin (71),/* last time this rels stats were updated */
  7   146 	     2 last_statistics_update_s_e_ref_num fixed bin (35), /* last select expr ID that updated this rels stats */
  7   147 	     2 ready_mode	      fixed bin,		/* 1 => r, 2 => mr, 3 => u, 4 => l, 5 => sr, 6 => su */
  7   148 	     2 file_type	      fixed bin,		/* 1 => unblocked, 2 => blocked, 3 => temporary */
  7   149 	     2 tuple_id_len	      fixed bin,		/* no. bits in local tuple id */
  7   150 	     2 opening_id	      bit (36) aligned,	/* relation manager opening is */
  7   151 	     2 key_attr_ptrs      (nkey_attr_init refer (rm_rel_info.nkey_attr)) ptr, /* ptrs to key attr. */
  7   152 	     2 attr_ptrs	      (natts_init refer (rm_rel_info.num_attr)) ptr, /* ptrs to all attr. */
  7   153 	     2 id_list_ptr        ptr,		/* Id list for retrieves from the relation */
  7   154                2 scope_flags_ptr    ptr;                    /* pointer to the scope_flags structure for the rel */
  7   155 
  7   156      dcl	   rmri_ptr	      ptr;
  7   157      dcl	   (nkey_attr_init,
  7   158 	   natts_init,
  7   159 	   nvar_atts_init)	      fixed bin;
  7   160 
  7   161 /* END mdbm_rm_rel_info.incl.pl1 */
  7   162 
  7   163 
      239 
      240 
  8     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  8     2 
  8     3 
  8     4 
  8     5 /****^  HISTORY COMMENTS:
  8     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  8     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  8     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  8     9*     Nguyen. The scopes_changed flag was added to make checking for this
  8    10*     more efficient (mrds error list #137).
  8    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  8    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  8    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  8    14*     care if multiple txns use the same selection_expression. (mrds #156)
  8    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  8    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  8    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  8    18*                                                   END HISTORY COMMENTS */
  8    19 
  8    20 
  8    21 /* WARNING
  8    22*          If the dbcb structure is changed then the mrds_data_
  8    23*          item saved_res_version MUST be incremented to invalidate all
  8    24*          existing saved resultants
  8    25**/
  8    26 
  8    27 /* HISTORY :
  8    28*
  8    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  8    30*   tid_list management
  8    31*
  8    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  8    33*   phony resultant in mu_database_index, without having the area dcl
  8    34*   included.
  8    35*
  8    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  8    37*   mrds_dsl_store
  8    38*
  8    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  8    40*   switches
  8    41*
  8    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  8    43*   expression,  so  that relation statistics can be updated relative
  8    44*   to number of selection expressions seem. Also  removed  init  for
  8    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  8    46*   mrds_dsl_init_res.
  8    47*
  8    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  8    49*
  8    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  8    51*   for the conversion to the relation manager.
  8    52*
  8    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  8    54*   substructures so that the entries and costs can change
  8    55*   depending on the type of database that is opened.
  8    56*
  8    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  8    58*   since modify uses a different vector type (general) than does store.
  8    59*
  8    60*   82-09-20 Davids: changed names of (store modify)_vector to
  8    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  8    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  8    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  8    64*   during the first call.
  8    65*
  8    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  8    67*   since it deals with the pointers to the cursors and not the cursors
  8    68*   themelves and added the element cursor_storage_area_ptr which points
  8    69*   to the area where the cursors are kept.
  8    70*
  8    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  8    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  8    73*   anything.
  8    74*
  8    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  8    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  8    77*   by mrds_dsl_define_temp_rel.
  8    78*
  8    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  8    80*   is needed by mu_store.
  8    81*
  8    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  8    83*   bin to float bin since the values are not integers.
  8    84*
  8    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  8    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  8    87*   added to the end of the structure to allow modules that don't use
  8    88*   the element to continue to reference the dbcb structure without recompiling.
  8    89*
  8    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  8    91*   are needed so that temp rels can be created with the same file attributes
  8    92*   as the permanent relations.
  8    93*
  8    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  8    95*   added the resultant_in_pdir bit.
  8    96*
  8    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  8    98*   added the res_already_made element.
  8    99*
  8   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  8   101*
  8   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  8   103*   one of the unused pointers.
  8   104*
  8   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  8   106*
  8   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  8   108*   leaving unused_ptrs(1).
  8   109*
  8   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  8   111*   unused_ptrs (1).
  8   112*
  8   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  8   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  8   115*   spare ptrs, entries and reserved storages for future enhancement, since
  8   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  8   117*
  8   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  8   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  8   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  8   121**/
  8   122 
  8   123 
  8   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  8   125*   that constitutes the non-secure portion of the resultant model that is
  8   126*   created during the opening of a database. it contains variables that
  8   127*   are used during the runtime access of the database, and an area
  8   128*   for evaluation of requests. it points to four other
  8   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  8   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  8   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  8   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  8   133*   used in the elimination of duplicate tuples during a retrieve.
  8   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  8   135*   that is used when the database is using the file scope mechanism
  8   136*   for concurrency control over file readying. the segment overlayed via
  8   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  8   138*   across database openings. the pointer to this dbcb structure is kept in a table
  8   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  8   140*   opening instances of resultant models. (see mu_database_index routine) */
  8   141 
  8   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  8   143 	     2 data	      like dbcb_data,
  8   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  8   145 
  8   146      dcl	   dbcb_ptr	      ptr;
  8   147 
  8   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  8   149*						   like references can avoid getting the area declaration */
  8   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  8   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  8   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  8   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  8   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  8   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  8   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  8   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  8   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  8   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  8   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  8   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  8   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  8   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  8   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  8   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  8   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  8   167*						   for eliminating duplicate tuples. */
  8   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  8   169*						   for eliminating duplicate tuples. */
  8   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  8   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  8   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  8   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  8   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  8   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  8   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  8   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  8   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  8   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  8   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  8   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  8   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  8   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  8   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  8   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  8   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  8   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  8   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  8   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  8   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  8   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  8   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  8   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  8   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  8   195 	     2 val_del	      bit (1) unal,		/* for delete */
  8   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  8   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  8   198*                                                                     not imply that the database is of type page_file */
  8   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  8   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  8   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  8   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  8   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  8   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  8   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  8   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  8   207*						   inside a sequence of -another selection expression. */
  8   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  8   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  8   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  8   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  8   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  8   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  8   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  8   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  8   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  8   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  8   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  8   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  8   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  8   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  8   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  8   223 	     2 relmgr_entries,			/* relation manager entries */
  8   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  8   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  8   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  8   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  8   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  8   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  8   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  8   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  8   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  8   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  8   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  8   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  8   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  8   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  8   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  8   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  8   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  8   241 	       3 reserved_entries (5) entry (),
  8   242 	     2 access_costs,			/* access costs for permute */
  8   243 	       3 total_primary_key_cost float bin,
  8   244 	       3 access_cost      float bin,
  8   245 	       3 access_overhead  float bin,
  8   246 	       3 us_access_cost   float bin,
  8   247 	       3 os_access_cost   float bin,
  8   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  8   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  8   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  8   251 
  8   252 /* END mrds_dbcb.incl.pl1 */
  8   253 
  8   254 
      241 
      242 
  9     1 /* BEGIN INCLUDE FILE mrds_path_info.incl.pl1 - -  Jim Gray 81-01-22 */
  9     2 
  9     3 /* HISTORY:
  9     4*
  9     5*   81-01-22 Jim Gray : originaly created for the dsl_$get_path_info interface,
  9     6*   a slight extension to the undocumented mrds_dsl_get_version$header.
  9     7*
  9     8**/
  9     9 
  9    10 /* DESCRIPTION:
  9    11*
  9    12*   This structure returns information about a relative pathname, given
  9    13*   to a pathname accepting mrds interface. The information returned
  9    14*   is the absolute pathname, plus in the case that
  9    15*   the relative path points to a mrds database or submodel
  9    16*   whether it is a model or a submodel, the mrds version of
  9    17*   the model or submodel, it's creator, and the time of creation.
  9    18*
  9    19**/
  9    20 
  9    21 
  9    22 declare 1 mrds_path_info aligned based (mrds_path_info_ptr),
  9    23         2 version fixed bin,				/* version number for this structure */
  9    24         2 absolute_path char (168),			/* the absolute path from the input relative path */
  9    25         2 type,
  9    26 	3 not_mrds bit (1) unal,			/* on => path not to model or submodel */
  9    27 	3 model bit (1) unal,			/* on => path to database model, thus possible .db suffix */
  9    28 	3 submodel bit (1) unal,			/* on => path to submodel, thus possible .dsm suffix */
  9    29 	3 mbz1 bit (33) unal,
  9    30         2 mrds_version fixed bin,			/* the mrds version number of the model or submodel */
  9    31         2 creator_id char (32),			/* the person.project.tag of the creator */
  9    32         2 creation_time fixed bin (71),			/* convert date to binary form of time model/submodel created */
  9    33         2 mbz2 bit (36) unal ;
  9    34 
  9    35 
  9    36 declare  mrds_path_info_ptr ptr ;
  9    37 
  9    38 declare  mrds_path_info_structure_version fixed bin init (1) int static options (constant) ;
  9    39 
  9    40 /* END  INCLUDE FILE mrds_path_info.incl.pl1 */
      243 
      244 
 10     1 /*	BEGIN INCLUDE FILE		mrds_dm_header.incl.pl1
 10     2*
 10     3*   Created October, 1975 for release in MR 4.0
 10     4*   Modified December, 1975 to provide more info.					*/
 10     5 
 10     6 dcl 1 dm_header based (dmh_ptr),			/* data model header */
 10     7     2 dm_header_id char (8),				/* identification as data model header */
 10     8     2 dmd_version fixed bin,				/* version number of dmd_ creating this model */
 10     9     2 creator_id char (32),				/* group id of creator */
 10    10     2 create_time fixed bin (71);			/* time of creation */
 10    11 
 10    12 dcl  dmh_ptr ptr;
 10    13 
 10    14 /*	END INCLUDE FILE		mrds_dm_header.incl.pl1				*/
 10    15 
      245 
      246 
 11     1 /*	BEGIN INCLUDE FILE		mrds_model_relations.incl.pl1
 11     2*
 11     3*   Created October, 1975 for release in MR 4.0					*/
 11     4 
 11     5 dcl 1 model_relations based (mr_ptr),			/* structure to return names of all relations in a model */
 11     6     2 nrels fixed bin (10),				/* number of relations */
 11     7     2 relation_name (num_relations_alloc refer (model_relations.nrels)) char (32); /* relation names */
 11     8 
 11     9 dcl  num_relations_alloc fixed bin (10);		/* number of relations in model for allocation purposes */
 11    10 
 11    11 dcl  mr_ptr ptr;
 11    12 
 11    13 /*	END INCLUDE FILE		mrds_model_relations.incl.pl1				*/
 11    14 
      247 
      248 
 12     1 /*	BEGIN INCLUDE FILE		mrds_rel_desc.incl.pl1	rgl, 03/31/76		*/
 12     2 
 12     3 /* 76-09-20 R. Lackey : modified to handle inverted attributes	
 12     4*
 12     5*   76-11-16 J. A. Weeldreyer : modified to add domain name 
 12     6*
 12     7*   82-08-19 D. Woodka : deleted rel_desc.attributes.bit_offset field
 12     8*   for the DMS conversion
 12     9*
 12    10**/
 12    11 
 12    12 dcl 1 rel_desc based (rd_ptr),			/* record description of relation records */
 12    13     2 num_attr fixed bin,				/* number of attributes in the model */
 12    14     2 key_length fixed bin (35),			/* length in bits of data portion of tuple */
 12    15     2 data_length fixed bin (35),			/* length in bits of data portion of tuple */
 12    16     2 num_keys fixed bin,				/* number of key attributes */
 12    17     2 inversion bit (1) unal,				/* On if this relation contains any inverted  attributes */
 12    18     2 reserved bit (35) unal,				/* Reserved for future use */
 12    19     2 attributes (num_attr_alloc refer (rel_desc.num_attr)),
 12    20       3 attribute_name char (32),			/* name of attribute  */
 12    21       3 domain_name char (32),			/* name of underlying domain */
 12    22       3 bit_length bit (18) unaligned,			/* length of data item in bits */
 12    23       3 key_flag bit (1) unaligned,			/* indicates whether attribute is part of primary key */
 12    24       3 inver_flag bit (1) unaligned,			/* On if this attribute is inverted */
 12    25       3 unused bit (34) unaligned,			/* reserved for expansion */
 12    26       3 key_attr_order fixed bin,			/* order num of this key attr */
 12    27       3 descriptor bit (36);				/* Multics descriptor for attribute */
 12    28 
 12    29 dcl  num_attr_alloc fixed bin (10);			/* Number of attributes in relation for allocation purposes */
 12    30 
 12    31 dcl  rd_ptr ptr;
 12    32 
 12    33 /*	END INCLUDE FILE		mrds_rel_desc.incl.pl1				*/
 12    34 
      249 
      250 
 13     1 /* START OF:	mrds_new_scope_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 13     2 
 13     3 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 13     4 /* 									*/
 13     5 /* Name:  mrds_new_scope_modes.incl.pl1						*/
 13     6 /* 									*/
 13     7 /*      This include file defines named constants which can be used to specify the MRDS	*/
 13     8 /* operations to be permitted and prevented in a call to dsl_$set_scope.		*/
 13     9 /* 									*/
 13    10 /* Status									*/
 13    11 /* 									*/
 13    12 /* 0)   Created on January 25, 1980 by Jim Gray          				*/
 13    13 /* 1)   80-12-10 Jim Gray : r-u scope modes changed to r-s-m-d type scope modes,          */
 13    14 /*    also, names were changed to agree with security acl modes in MRDS.	          */
 13    15 /*									*/
 13    16 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 13    17 
 13    18 dcl (NO_OP init (0),
 13    19      READ_ATTR init (1),
 13    20      APPEND_TUPLE init (2),
 13    21      DELETE_TUPLE init (4),
 13    22      MODIFY_ATTR init (8),
 13    23      UPDATE_OPS init (14),
 13    24      ALL_OPS init (15)) fixed bin int static options (constant);
 13    25 
 13    26 /* END OF:	mrds_new_scope_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      251 
      252 
 14     1 /* START OF:	mrds_opening_modes_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 14     2 
 14     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 14     4 	/*									*/
 14     5 	/* Name:  mrds_opening_modes_.incl.pl1						*/
 14     6 	/*									*/
 14     7 	/* Defines named constants which can be used in calls to dsl_$open when opening a MRDS	*/
 14     8 	/* data base.								*/
 14     9 	/*									*/
 14    10 	/* Status									*/
 14    11 	/* 0)  Created by:   Gary C. Dixon; January 22, 1979				*/
 14    12 	/*									*/
 14    13 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 14    14 
 14    15      dcl (RETRIEVAL			init(1),
 14    16 	UPDATE			init(2),
 14    17 	EXCLUSIVE_RETRIEVAL		init(3),
 14    18 	EXCLUSIVE_UPDATE		init(4)) fixed bin(35) int static options(constant);
 14    19 	
 14    20 /* END OF:	mrds_opening_modes_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 14    21 
      253 
      254 
 15     1 /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
 15     2 
 15     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
 15     4 
 15     5 /* This include file contains branch and link structures returned by
 15     6*   hcs_$status_ and hcs_$status_long. */
 15     7 
 15     8 dcl 1 status_branch aligned based (status_ptr),
 15     9     2 short aligned,
 15    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
 15    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
 15    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
 15    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
 15    14       3 dtu bit (36) unaligned,			/* date/time last used */
 15    15       3 mode bit (5) unaligned,			/* caller's effective access */
 15    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
 15    17       3 pad1 bit (8) unaligned,
 15    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
 15    19 
 15    20 /* Limit of information returned by hcs_$status_ */
 15    21 
 15    22     2 long aligned,
 15    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
 15    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
 15    25       3 lvid bit (36) unaligned,			/* logical volume ID */
 15    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
 15    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
 15    28       3 pad2 bit (8) unaligned,
 15    29       3 copy_switch bit (1) unaligned,			/* copy switch */
 15    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
 15    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
 15    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
 15    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
 15    34       3 pad3 bit (5) unaligned,
 15    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
 15    36       3 uid bit (36) unaligned;			/* unique ID */
 15    37 
 15    38 dcl 1 status_link aligned based (status_ptr),
 15    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
 15    40     2 nnames fixed bin (16) unaligned unsigned,
 15    41     2 names_relp bit (18) unaligned,
 15    42     2 dtem bit (36) unaligned,
 15    43     2 dtd bit (36) unaligned,
 15    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
 15    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
 15    46 
 15    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
 15    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
 15    49 						/* array of names returned */
 15    50      status_pathname character (status_link.pathname_length) aligned
 15    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
 15    52 						/* link target path */
 15    53      status_area_ptr pointer,
 15    54      status_ptr pointer;
 15    55 
 15    56 dcl (Link initial (0),
 15    57      Segment initial (1),
 15    58      Directory initial (2)) fixed bin internal static options (constant);
 15    59 						/* values for type fields declared above */
 15    60 
 15    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
      255 
      256 
      257 /* Program */
      258 
      259 
      260 /* set up the input and output reference names, and get temp storage */
      261 
      262 	call initialize;
      263 
      264 	on cleanup call clean_up;			/* establish cleanup handler */
      265 
      266 /* make sure the argument list is correct */
      267 
      268 	call check_args;
      269 
      270 /* check for duplicate pathnames */
      271 
      272 	if duplicate_paths ()			/* the pathnames are the same */
      273 	then call error (error_table_$sameseg, "");
      274 
      275 /* begin moving the data */
      276 
      277 	call copy_database_data ();			/* copy input data into the output database */
      278 
      279 	call clean_up;
      280 exit:	return;
      281 
      282 check_args: procedure;
      283 
      284 /* check_args is called by the main routine */
      285 
      286 	call cu_$arg_count (nargs);
      287 	if nargs < 2
      288 	then call error (error_table_$noarg,
      289 		"^/Usage: copy_mrds_data input_db_path output_db_path {-ctl_args}");
      290 
      291 /* get the input pathname argument */
      292 
      293 	call cu_$arg_ptr (1, input_path_ptr, input_path_len, error_code);
      294 	if error_code ^= 0
      295 	then call error (error_code, "Getting first argument.");
      296 
      297 	if substr (input_path, 1, 1) = "-"
      298 	then call error (error_table_$noarg, "^/First argument should be the input pathname.");
      299 
      300 /* check for correct input version */
      301 
      302 	call mrds_dsl_get_version$get_path_info (input_path, temp_seg_ptr,
      303 	     mrds_path_info_structure_version, mrds_path_info_ptr, error_code);
      304 	if mrds_path_info_ptr = null
      305 	then input_abs_path = input_path;
      306 	else input_abs_path = mrds_path_info.absolute_path;
      307 
      308 	if error_code ^= 0
      309 	then do;
      310 		if error_code = mrds_error_$no_model_submodel
      311 		then error_code = mrds_error_$no_database;
      312 
      313 		call error (error_code, "^/" || input_abs_path);
      314 	     end;
      315 	if mrds_path_info.mrds_version ^= 4
      316 	then call error (mrds_error_$version_not_supported, "/^The input database must be a version 4 database.");
      317 	if mrds_path_info.type.submodel
      318 	then call error (error_table_$badcall,
      319 		"^/Data submodels are not supported by this command.  " || input_abs_path);
      320 
      321 /* get the output pathname argument */
      322 
      323 	call cu_$arg_ptr (2, output_path_ptr, output_path_len, error_code);
      324 	if error_code ^= 0
      325 	then call error (error_code, "Getting second argument.");
      326 	if substr (output_path, 1, 1) = "-"
      327 	then call error (error_table_$noarg,
      328 		"^/Second argument should be the output pathname.");
      329 
      330 	call mrds_dsl_get_version$get_path_info (output_path, temp_seg_ptr,
      331 	     mrds_path_info_structure_version, mrds_path_info_ptr, error_code);
      332 	if mrds_path_info_ptr = null
      333 	then output_abs_path = output_path;
      334 	else output_abs_path = mrds_path_info.absolute_path;
      335 
      336 	if error_code ^= 0
      337 	then do;
      338 		if error_code = mrds_error_$no_model_submodel
      339 		then error_code = mrds_error_$no_database;
      340 
      341 		call error (error_code, "^/" || output_abs_path);
      342 	     end;
      343 
      344 	if mrds_path_info.type.submodel
      345 	then do;
      346 		call com_err_ (error_table_$badcall, CALLER_NAME,
      347 		     "^/Data submodels are not supported by this command.  ^a", input_abs_path);
      348 		call clean_up ();
      349 		goto exit;
      350 	     end;
      351 
      352 
      353 	do n = 3 to nargs;
      354 
      355 
      356 	     call cu_$arg_ptr (n, arg_ptr, arg_length, error_code);
      357 	     if error_code ^= 0
      358 	     then call error (error_code, "");
      359 	     else if substr (arg, 1, 1) ^= "-"
      360 	     then call error (error_table_$bad_arg, arg);
      361 	     else if arg = "-relation" | arg = "-rel"
      362 	     then do;
      363 		     if n = nargs
      364 		     then do;
      365 			     call com_err_ (error_table_$noarg, CALLER_NAME, "Following ^a.", arg);
      366 			     call clean_up;
      367 			     goto exit;
      368 			end;
      369 		     else n = n + 1;
      370 		     call cu_$arg_ptr (n, arg_ptr, arg_length, error_code);
      371 		     if error_code ^= 0
      372 		     then call error (error_code, "");
      373 		     single_relation = "1"b;
      374 		     rel_arg_ptr = arg_ptr;
      375 		     rel_arg_length = arg_length;
      376 		end;
      377 	     else if arg = "-input_prevent_ops"
      378 	     then do;
      379 		     if n = nargs
      380 		     then do;
      381 			     call com_err_ (error_table_$noarg, CALLER_NAME, "Following ^a.", arg);
      382 			     call clean_up;
      383 			     goto exit;
      384 			end;
      385 		     else n = n + 1;
      386 		     call cu_$arg_ptr (n, arg_ptr, arg_length, error_code);
      387 		     if error_code ^= 0
      388 		     then call error (error_code, "");
      389 		     specified_input_prevents = 0;
      390 		     if arg ^= "n" then do;		/* if non-null op. */
      391 			     op_num = verify (arg, "aursdm");
      392 			     if op_num ^= 0 then do;	/* invalid code */
      393 				     call com_err_ (error_table_$bad_arg, CALLER_NAME,
      394 					"Invalid scope code: ^a. ^/^-Valid codes are: n, r, a or s, d, m, and u = ""a+d+m""",
      395 					substr (arg, op_num, 1));
      396 				     call clean_up;
      397 				     goto exit;
      398 				end;
      399 			     if search (arg, "r") ^= 0
      400 			     then specified_input_prevents =
      401 				     specified_input_prevents + READ_ATTR; /* convert to number */
      402 			     if search (arg, "s") ^= 0 | search (arg, "a") ^= 0
      403 			     then specified_input_prevents =
      404 				     specified_input_prevents + APPEND_TUPLE;
      405 			     if search (arg, "d") ^= 0
      406 			     then specified_input_prevents =
      407 				     specified_input_prevents + DELETE_TUPLE;
      408 			     if search (arg, "m") ^= 0
      409 			     then specified_input_prevents =
      410 				     specified_input_prevents + MODIFY_ATTR;
      411 			     if search (arg, "u") ^= 0
      412 			     then specified_input_prevents =
      413 				     specified_input_prevents + UPDATE_OPS;
      414 			end;
      415 		end;
      416 	     else if arg = "-output_prevent_ops"
      417 	     then do;
      418 		     if n = nargs
      419 		     then do;
      420 			     call com_err_ (error_table_$noarg, CALLER_NAME, "Following ^a.", arg);
      421 			     call clean_up;
      422 			     goto exit;
      423 			end;
      424 		     else n = n + 1;
      425 		     call cu_$arg_ptr (n, arg_ptr, arg_length, error_code);
      426 		     if error_code ^= 0
      427 		     then call error (error_code, "");
      428 		     specified_output_prevents = 0;
      429 		     if arg ^= "n" then do;		/* if non-null op. */
      430 			     op_num = verify (arg, "aursdm");
      431 			     if op_num ^= 0 then do;	/* invalid code */
      432 				     call com_err_ (error_table_$bad_arg, CALLER_NAME,
      433 					"Invalid scope code: ^a. ^/^-Valid codes are: n, r, a or s, d, m, and u = ""a+d+m""",
      434 					substr (arg, op_num, 1));
      435 				     call clean_up;
      436 				     goto exit;
      437 				end;
      438 			     if search (arg, "r") ^= 0
      439 			     then specified_output_prevents =
      440 				     specified_output_prevents + READ_ATTR; /* convert to number */
      441 			     if search (arg, "s") ^= 0 | search (arg, "a") ^= 0
      442 			     then specified_output_prevents =
      443 				     specified_output_prevents + APPEND_TUPLE;
      444 			     if search (arg, "d") ^= 0
      445 			     then specified_output_prevents =
      446 				     specified_output_prevents + DELETE_TUPLE;
      447 			     if search (arg, "m") ^= 0
      448 			     then specified_output_prevents =
      449 				     specified_output_prevents + MODIFY_ATTR;
      450 			     if search (arg, "u") ^= 0
      451 			     then specified_output_prevents =
      452 				     specified_output_prevents + UPDATE_OPS;
      453 			end;
      454 		end;
      455 	     else if arg = "-transaction_group_size"
      456 	     then do;
      457 		     if n = nargs
      458 		     then do;
      459 			     call com_err_ (error_table_$noarg, CALLER_NAME, "Following ^a.", arg);
      460 			     call clean_up;
      461 			     goto exit;
      462 			end;
      463 		     else n = n + 1;
      464 		     call cu_$arg_ptr (n, arg_ptr, arg_length, error_code);
      465 		     if error_code ^= 0
      466 		     then call error (error_code, "");
      467 		     if verify (arg, "1234567890") ^= 0
      468 		     then call com_err_ (error_table_$bad_arg, "The operand to -transaction_group_size must be an integer.");
      469 		     transaction_group_size = fixed (arg);
      470 		end;
      471 	     else call error (error_table_$badopt, arg);
      472 	end;
      473 
      474 
      475      end check_args;
      476 
      477 duplicate_paths: procedure returns (bit (1));
      478 
      479 /* duplicate_paths is called by convert_database */
      480 
      481 /* this routine check to see if the input and output input paths
      482*   are to the same database. */
      483 
      484 	equal = ON;
      485 	call get_database_uid (output_abs_path, output_db_uid);
      486 	call get_database_uid (input_abs_path, input_db_uid);
      487 	if input_db_uid ^= output_db_uid
      488 	then equal = OFF;
      489 
      490 	return (equal);
      491 
      492 	dcl     equal		 bit (1);		/* on => same path for both db's */
      493 
      494      end duplicate_paths;
      495 
      496 initialize: procedure;
      497 
      498 /* called by main routine */
      499 
      500 /* initialize variables */
      501 
      502 	data_space_ptr_ptr, input_dm_ptr, input_dmh_ptr, output_dm_ptr,
      503 	     output_dmh_ptr, retrieve_al_ptr, rtbc_ptr, status_ptr,
      504 	     store_al_ptr, temp_seg_ptr = null ();
      505 
      506 	input_dbi, output_dbi, transaction_group_size = 0;
      507 
      508 	single_relation = "0"b;
      509 
      510 	specified_input_prevents, specified_output_prevents = UPDATE_OPS;
      511 
      512 /* get the temporary storage space */
      513 
      514 	call get_temp_segment_ (CALLER_NAME, temp_seg_ptr, error_code);
      515 	if error_code ^= 0
      516 	then call error (error_code, "");
      517 
      518 	work_area = empty ();			/* init work area in temp segment */
      519 
      520      end initialize;
      521 
      522 copy_database_data: procedure ();
      523 
      524 /* copy_database_data is called by main routine */
      525 
      526 /* copy data from a input  database, into a output database. */
      527 
      528 	on sub_error_ ;				/* ignore subroutine error messages */
      529 
      530 /* open the input and output databases and data models */
      531 
      532 	call open_input_db ();
      533 	call open_output_db ();
      534 
      535 /* make sure we aren't copying apples to oranges */
      536 
      537 	call compare_relations ();
      538 
      539 /* copy the input database data into the output database,
      540*   one relation at a time, checking for identical attribute
      541*   makeup of the input and output relations. */
      542 
      543 	call copy_relation_data ();
      544 
      545 	call ioa_ ("^/Update complete, closing data models.");
      546 
      547      end copy_database_data;
      548 
      549 open_input_db: procedure ();
      550 
      551 /* open the input database and datamodel using the supplied pathname,
      552*   and then output the header information for the datamodel */
      553 
      554 
      555 	call mrds_dsl_open (input_abs_path, input_dbi, RETRIEVAL, error_code);
      556 	if error_code ^= 0
      557 	then do;
      558 		input_dbi = 0;
      559 		call com_err_ (error_code, CALLER_NAME, "^/^a^a^a",
      560 		     "Unable to open """, input_abs_path, """.");
      561 		call clean_up;
      562 		goto exit;
      563 	     end;
      564 	call mrds_dm_open (input_abs_path, RETRIEVAL_MODE, input_dm_ptr, error_code);
      565 	if error_code ^= 0
      566 	then do;
      567 		input_dm_ptr = null ();
      568 		call com_err_ (error_code, CALLER_NAME, "^/^a^a^a",
      569 		     "Unable to open data model for """, input_abs_path, """.");
      570 		call clean_up;
      571 		goto exit;
      572 	     end;
      573 
      574 /* output the header information for each version model */
      575 
      576 	call mrds_dm_get_header (input_dm_ptr, temp_seg_ptr, input_dmh_ptr, error_code);
      577 	if error_code ^= 0
      578 	then call error (error_code, input_abs_path);
      579 	call date_time_ (input_dmh_ptr -> dm_header.create_time, input_converted_time);
      580 	call ioa_ ("^/Opening data model: ^a^/^5xCreated: ^a^/^5xVersion: ^d^/^5xBy: ^a",
      581 	     input_abs_path, input_converted_time,
      582 	     input_dmh_ptr -> dm_header.dmd_version, input_dmh_ptr -> dm_header.creator_id);
      583 
      584 	if input_dmh_ptr -> dm_header.dmd_version < 4
      585 	then call error (mrds_error_$rst_wrong_command, "The input database must be a version 4 database.");
      586 
      587      end open_input_db;
      588 
      589 open_output_db: procedure ();
      590 
      591 /* open the output database and datamodel using the supplied pathname,
      592*   and then output the header information for the datamodel */
      593 
      594 	call mrds_dsl_open (output_abs_path, output_dbi, UPDATE, error_code);
      595 	if error_code ^= 0
      596 	then do;
      597 		output_dbi = 0;
      598 		call com_err_ (error_code, CALLER_NAME, "^/^a^a^a",
      599 		     "Unable to open """, output_abs_path, """.");
      600 		call clean_up;
      601 		goto exit;
      602 	     end;
      603 
      604 	call mrds_dm_open (output_abs_path, RETRIEVAL_MODE, output_dm_ptr, error_code);
      605 	if error_code ^= 0
      606 	then do;
      607 		output_dm_ptr = null ();
      608 		call com_err_ (error_code, CALLER_NAME, "^/^a^a^a",
      609 		     "Unable to open the datamodel for """, output_abs_path, """.");
      610 		call clean_up;
      611 		goto exit;
      612 	     end;
      613 
      614 /* output the header information for each version model */
      615 
      616 	call mrds_dm_get_header (output_dm_ptr, temp_seg_ptr, output_dmh_ptr, error_code);
      617 	if error_code ^= 0
      618 	then call error (error_code, output_abs_path);
      619 
      620 	call date_time_ (output_dmh_ptr -> dm_header.create_time,
      621 	     output_converted_time);
      622 	call ioa_ ("^/Opening data model: ^a^/^5xCreated: ^a^/^5xVersion: ^d^/^5xBy: ^a^/",
      623 	     output_abs_path, output_converted_time,
      624 	     output_dmh_ptr -> dm_header.dmd_version,
      625 	     output_dmh_ptr -> dm_header.creator_id);
      626 
      627      end open_output_db;
      628 
      629 compare_relations: procedure ();
      630 
      631 /* make sure that the input and output databases have the same relations */
      632 
      633 	call mu_database_index$get_resultant_model_pointer (input_dbi, dbcb_ptr);
      634 	call mu_database_index$get_resultant_model_pointer (output_dbi, output_dbcb_ptr);
      635 
      636 /* first check that the number of relations match */
      637 
      638 	if ^single_relation &
      639 	     (dbcb.data.rdbi_ptr -> rm_db_info.data.ra_ptr -> rm_rel_array.num_rels ^=
      640 	     output_dbcb_ptr -> dbcb.data.rdbi_ptr -> rm_db_info.data.ra_ptr -> rm_rel_array.num_rels)
      641 	then call error (error_table_$badcall, "^/The 2 databases must have the same number of relations.");
      642 
      643 	if single_relation
      644 	then n_rels_to_be_copied = 1;
      645 	else n_rels_to_be_copied = dbcb.data.rdbi_ptr -> rm_db_info.data.ra_ptr -> rm_rel_array.num_rels;
      646 	allocate relations_to_be_copied in (work_area);
      647 
      648 	call match_relation_names ();			/* check for consistency */
      649 
      650      end compare_relations;
      651 
      652 match_relation_names: procedure ();
      653 
      654 /* compare the input relation list names to the output names */
      655 
      656 	if single_relation
      657 	then do;
      658 		found = OFF;
      659 		do i = 1 to dbcb.data.rdbi_ptr -> rm_db_info.data.ra_ptr -> rm_rel_array.num_rels while (^found);
      660 		     if dbcb.data.rdbi_ptr -> rm_db_info.data.ra_ptr -> rm_rel_array.rel_data.model_name (i) = rel_arg
      661 		     then do;
      662 			     found = ON;
      663 			     relations_to_be_copied.input_rel_num (1) = i;
      664 			end;
      665 		end;
      666 
      667 		if ^found
      668 		then do;
      669 			error_code = mrds_error_$unknown_relation_name;
      670 			input_rel_missing = ON;
      671 		     end;
      672 
      673 		else do;
      674 			found = OFF;
      675 			do i = 1 to output_dbcb_ptr -> dbcb.data.rdbi_ptr -> rm_db_info.data.ra_ptr -> rm_rel_array.num_rels while (^found);
      676 			     if output_dbcb_ptr -> dbcb.data.rdbi_ptr -> rm_db_info.data.ra_ptr -> rm_rel_array.rel_data.model_name (i) = rel_arg
      677 			     then do;
      678 				     found = ON;
      679 				     relations_to_be_copied.output_rel_num (1) = i;
      680 				     relations_to_be_copied.rel_name (1) = rel_arg;
      681 				end;
      682 			end;
      683 			if ^found
      684 			then do;
      685 				error_code = mrds_error_$unknown_relation_name;
      686 				input_rel_missing = OFF;
      687 			     end;
      688 		     end;
      689 		if ^found
      690 		then do;
      691 			call com_err_ (mrds_error_$unknown_relation_name,
      692 			     CALLER_NAME,
      693 			     "^/The relation ^a was specified but not found in the ^[input^;output^] model.",
      694 			     rel_arg,
      695 			     (input_rel_missing = ON));
      696 			call clean_up;
      697 			goto exit;
      698 		     end;
      699 	     end;
      700 	else do;
      701 
      702 
      703 		do i = 1 to dbcb.data.rdbi_ptr -> rm_db_info.data.ra_ptr -> rm_rel_array.num_rels while (error_code = 0);
      704 
      705 		     found = OFF;
      706 
      707 		     do j = 1 to dbcb.data.rdbi_ptr -> rm_db_info.data.ra_ptr -> rm_rel_array.num_rels while (^found & error_code = 0);
      708 
      709 			if output_dbcb_ptr -> dbcb.data.rdbi_ptr -> rm_db_info.data.ra_ptr -> rm_rel_array.rel_data.model_name (i) =
      710 			     dbcb.data.rdbi_ptr -> rm_db_info.data.ra_ptr -> rm_rel_array.rel_data.model_name (j)
      711 			then do;
      712 				found = ON;
      713 				relations_to_be_copied.input_rel_num (i) = j;
      714 				relations_to_be_copied.output_rel_num (i) = i;
      715 				relations_to_be_copied.rel_name (i) =
      716 				     output_dbcb_ptr ->
      717 				     dbcb.data.rdbi_ptr ->
      718 				     rm_db_info.data.ra_ptr ->
      719 				     rm_rel_array.rel_data.model_name (i);
      720 			     end;
      721 
      722 			else if j = dbcb.data.rdbi_ptr -> rm_db_info.data.ra_ptr -> rm_rel_array.num_rels
      723 			then error_code = mrds_error_$unknown_relation_name;
      724 		     end;
      725 
      726 		end;
      727 
      728 		if error_code ^= 0
      729 		then do;
      730 
      731 			call com_err_ (error_code,
      732 			     CALLER_NAME,
      733 			     "^/^a^a^a",
      734 			     "The relation """,
      735 			     output_dbcb_ptr ->
      736 			     dbcb.data.rdbi_ptr ->
      737 			     rm_db_info.data.ra_ptr ->
      738 			     rm_rel_array.rel_data.model_name (i - 1),
      739 			     """ was not found in the input datamodel, but was in the output model.");
      740 			call clean_up;
      741 			goto exit;
      742 		     end;
      743 	     end;
      744      end match_relation_names;
      745 
      746 copy_relation_data: procedure ();
      747 
      748 /* for each relation in the database, this routine will go through
      749*   one relation at a time, and copy all tuples for that relation
      750*   from the input database into the output database. */
      751 
      752 
      753 	do k = 1 to n_rels_to_be_copied while (error_code = 0);
      754 
      755 /* get the input and output data model attribute
      756*   descriptions and attribute make up for this relation */
      757 
      758 	     call set_scope;
      759 
      760 	     call get_relation_attributes ();
      761 
      762 /* make sure that the attribute make up of the relations agree */
      763 
      764 	     call compare_attributes ();
      765 
      766 /* make an argument structure for calls to mrds_dsl_retrieve */
      767 
      768 	     call build_retrieve_argument_list;
      769 
      770 /* make an argument structure for calls to mrds_dsl_store */
      771 
      772 	     call build_store_argument_list ();
      773 
      774 /* while their are tuples left, retrieve them from the
      775*   input database and store them into the output database */
      776 
      777 	     call copy_tuples ();
      778 
      779 /* free the space used for argument lists and attribute data space */
      780 
      781 	     call free_arg_lists ();
      782 
      783 	     call delete_scope;
      784 
      785 	end;
      786 
      787      end copy_relation_data;
      788 
      789 set_scope:
      790      procedure;
      791 
      792 /* for this current relation, set scope on both input and output */
      793 
      794 	call mrds_dsl_set_scope$set_scope (input_dbi, relations_to_be_copied.rel_name (k), READ_ATTR, specified_input_prevents, error_code);
      795 
      796 	if error_code ^= 0
      797 	then do;
      798 		call com_err_ (error_code, CALLER_NAME, "^/Setting scope on relation ^a of input database.", relations_to_be_copied.rel_name (k));
      799 		call clean_up;
      800 		goto exit;
      801 	     end;
      802 
      803 	call mrds_dsl_set_scope$set_scope (output_dbi, relations_to_be_copied.rel_name (k), APPEND_TUPLE, specified_output_prevents, error_code);
      804 
      805 	if error_code ^= 0
      806 	then do;
      807 		call com_err_ (error_code, CALLER_NAME, "^/Setting scope on relation ^a of output database.", relations_to_be_copied.rel_name (k));
      808 		call clean_up;
      809 		goto exit;
      810 	     end;
      811 
      812      end set_scope;
      813 
      814 get_relation_attributes: procedure ();
      815 
      816 /* for this current relation, get the attribute make up
      817*   and attribute descriptions for this relation */
      818 
      819 	call mrds_dm_get_attributes (input_dm_ptr, relations_to_be_copied.rel_name (k),
      820 	     temp_seg_ptr, input_rd_ptr, error_code);
      821 	if error_code ^= 0
      822 	then do;
      823 		call com_err_ (error_code, CALLER_NAME, "^/^a^a^a",
      824 		     "Getting attribute descriptions for input relation """,
      825 		     relations_to_be_copied.rel_name (k), """.");
      826 		call clean_up;
      827 		goto exit;
      828 	     end;
      829 
      830 	call mrds_dm_get_attributes (output_dm_ptr,
      831 	     relations_to_be_copied.rel_name (k),
      832 	     temp_seg_ptr, output_rd_ptr, error_code);
      833 	if error_code ^= 0
      834 	then do;
      835 		call com_err_ (error_code, CALLER_NAME, "^/^a^a^a",
      836 		     "Getting attribute descriptions for output relation """,
      837 		     relations_to_be_copied.rel_name (k), """.");
      838 		call clean_up;
      839 		goto exit;
      840 	     end;
      841 
      842      end get_relation_attributes;
      843 
      844 compare_attributes: procedure ();
      845 
      846 /* make sure the attribute descriptions still match,
      847*   first checking that attribute counts are equal, as well as key counts. */
      848 
      849 	if input_rd_ptr -> rel_desc.num_attr ^= output_rd_ptr -> rel_desc.num_attr |
      850 	     input_rd_ptr -> rel_desc.num_keys ^= output_rd_ptr -> rel_desc.num_keys
      851 	then do;
      852 		error_code = mrds_error_$rst_wrong_command;
      853 		call com_err_ (error_code, CALLER_NAME, "^/^a^a^a",
      854 		     "The number of attributes, or key attributes, for relation """,
      855 		     relations_to_be_copied.rel_name (k),
      856 		     """ are not the same in the output and input data model.");
      857 		call clean_up;
      858 		goto exit;
      859 	     end;
      860 
      861 
      862 /* go through all output attributes, making sure there is a corresponding input attribute */
      863 
      864 	do l = 1 to output_rd_ptr -> rel_desc.num_attr while (error_code = 0);
      865 	     found = OFF;
      866 	     m = 1;
      867 	     do m = 1 to input_rd_ptr -> rel_desc.num_attr while (^found & error_code = 0);
      868 
      869 /* see if this attribute has a matching name */
      870 
      871 		if input_rd_ptr -> rel_desc.attributes.attribute_name (m) =
      872 		     output_rd_ptr -> rel_desc.attributes.attribute_name (l)
      873 		then do;
      874 
      875 			found = ON;
      876 			if input_rd_ptr -> rel_desc.attributes.key_flag (m) ^=
      877 			     output_rd_ptr -> rel_desc.attributes.key_flag (l) &
      878 			     input_rd_ptr -> rel_desc.attributes.descriptor (m) ^=
      879 			     output_rd_ptr -> rel_desc.attributes.descriptor (l)
      880 			then do;
      881 				call com_err_ (error_code, CALLER_NAME, "^/^a^a^a^a^a^a",
      882 				     " The attribute """,
      883 				     output_rd_ptr -> rel_desc.attributes.attribute_name (l),
      884 				     """ in relation """, relations_to_be_copied.rel_name (k),
      885 				     """ does not agree in input and output datamodels as to being either a",
      886 				     "key attribute or its data type.");
      887 				call clean_up;
      888 				goto exit;
      889 			     end;
      890 		     end;
      891 
      892 		else if m = input_rd_ptr -> rel_desc.num_attr /* go on to next attribute */
      893 		then error_code = mrds_error_$undef_attr;
      894 	     end;
      895 
      896 /* report non-matching attribute name found, if necessary */
      897 
      898 	     if error_code = mrds_error_$undef_attr
      899 	     then do;
      900 		     call com_err_ (error_code, CALLER_NAME, "^/^a^a^a^a",
      901 			"The attribute """, output_rd_ptr -> rel_desc.attributes.attribute_name (l),
      902 			""" is not defined in the input relation """,
      903 			dbcb.data.rdbi_ptr ->
      904 			rm_db_info.data.ra_ptr ->
      905 			rm_rel_array.rel_data.model_name (k),
      906 			""" ");
      907 		     call clean_up;
      908 		     goto exit;
      909 		end;
      910 	end;
      911      end compare_attributes;
      912 
      913 build_retrieve_argument_list:
      914      proc ();
      915 
      916 /* this routine builds up an argument list for a call to mrds_dsl_retrieve
      917*   that makes it look like it was called thusly:
      918*
      919*   call mrds_dsl_retrieve (database_index, selection_expression, 
      920*		       value1, value1, ..., valueN, code);
      921**/
      922 
      923 	retrieve_desc_index = input_rd_ptr -> rel_desc.num_attr + 3;
      924 
      925 	num_ptrs = retrieve_desc_index * 2;
      926 
      927 	allocate arg_list set (retrieve_al_ptr) in (work_area);
      928 
      929 	retrieve_al_ptr -> arg_list.code = 4;
      930 
      931 	retrieve_al_ptr -> arg_list.arg_count = num_ptrs;
      932 
      933 	retrieve_al_ptr -> arg_list.desc_count = num_ptrs;
      934 
      935 	retrieve_al_ptr -> arg_des_ptr (1) = addr (input_dbi);
      936 
      937 	retrieve_al_ptr -> arg_des_ptr (1 + retrieve_desc_index) = addr (FIXED_BIN_35_DESCR);
      938 
      939 	retrieve_select_expr = RANGE_PAREN || relations_to_be_copied.rel_name (k);
      940 
      941 	retrieve_select_expr = rtrim (retrieve_select_expr) || PAREN_SELECT;
      942 
      943 	retrieve_al_ptr -> arg_des_ptr (2) = addr (retrieve_select_expr);
      944 
      945 	retrieve_al_ptr -> arg_des_ptr (2 + retrieve_desc_index) = addr (CHAR_53_DESCR);
      946 
      947 	allocate data_space_ptr in (work_area);
      948 
      949 	do n = 3 to retrieve_desc_index - 1;
      950 	     attr_bit_length =
      951 		mu_data_length (
      952 		(dbcb.data.rdbi_ptr
      953 		-> rm_db_info.data.ra_ptr
      954 		-> rm_rel_array.rel_data.ri_ptr (relations_to_be_copied.input_rel_num (k))
      955 		-> rm_rel_info.attr_ptrs (n - 2)
      956 		-> rm_attr_info.domain_ptr
      957 		-> rm_domain_info.user_desc));
      958 	     allocate data_space set (data_space_ptr (n - 2)) in (work_area);
      959 
      960 	     if mu_data_class$varying (addr
      961 		(dbcb.data.rdbi_ptr
      962 		-> rm_db_info.data.ra_ptr
      963 		-> rm_rel_array.rel_data.ri_ptr (relations_to_be_copied.input_rel_num (k))
      964 		-> rm_rel_info.attr_ptrs (n - 2)
      965 		-> rm_attr_info.domain_ptr
      966 		-> rm_domain_info.user_desc))
      967 	     then retrieve_al_ptr -> arg_des_ptr (n) = addrel (data_space_ptr (n - 2), 1);
      968 	     else retrieve_al_ptr -> arg_des_ptr (n) = data_space_ptr (n - 2);
      969 
      970 	     retrieve_al_ptr -> arg_des_ptr (n + retrieve_desc_index) =
      971 		addr (dbcb.data.rdbi_ptr
      972 		-> rm_db_info.data.ra_ptr
      973 		-> rm_rel_array.rel_data.ri_ptr (relations_to_be_copied.input_rel_num (k))
      974 		-> rm_rel_info.attr_ptrs (n - 2)
      975 		-> rm_attr_info.domain_ptr
      976 		-> rm_domain_info.user_desc);		/* whew! */
      977 	end;
      978 
      979 	retrieve_al_ptr -> arg_des_ptr (retrieve_desc_index) = addr (error_code);
      980 	retrieve_al_ptr -> arg_des_ptr (2 * retrieve_desc_index) = addr (FIXED_BIN_35_DESCR);
      981      end build_retrieve_argument_list;
      982 
      983 build_store_argument_list: procedure ();
      984 
      985 /* this routine builds up an argument list for a call to mrds_dsl_store
      986*   that makes it look like it was called with the arguments
      987*   call mrds_dsl_store(database_index, relation_expression, attribute_1, ..., attribute_n, error_code)
      988*   for all attributes in the current relation, and with relation expression
      989*   being the current relation name, so successive tuples my be stored. */
      990 
      991 	allocate arg_list set (store_al_ptr) in (work_area);
      992 
      993 	store_al_ptr -> arg_list = retrieve_al_ptr -> arg_list;
      994 
      995 /* only the database index, and selection expression arguments differ
      996*   between the retrieve and store argument lists */
      997 
      998 	store_al_ptr -> arg_list.arg_des_ptr (1) = addr (output_dbi);
      999 
     1000 	store_al_ptr -> arg_list.arg_des_ptr (2) = addr (store_select_expr);
     1001 
     1002 	store_al_ptr -> arg_list.arg_des_ptr (retrieve_desc_index + 2) = addr (CHAR_32_DESCR);
     1003 
     1004 	store_select_expr = relations_to_be_copied.rel_name (k);
     1005 
     1006      end;
     1007 
     1008 copy_tuples: procedure ();
     1009 
     1010 /* this routine uses the argument lists built for the retrieve and store,
     1011*   with its use of cu_$generate_call to mrds_dsl_retrieve, and mrds_dsl_store,
     1012*   to sucessively retrieve tuples from the input datbase, and store them into 
     1013*   the output database, until all tuples for this relation have been copied. */
     1014 
     1015 	tuples_retrieved, mftxn_code = 0;
     1016 	first_retrieval = ON;
     1017 	finished = OFF;
     1018 	transaction_tuple_count = transaction_group_size;
     1019 	if transaction_group_size ^= 0		/* user wants us to handle transactions */
     1020 	then do;
     1021 	          dbcb.data.dont_check_txn_id = "1"b;
     1022 		if dbcb.data.transactions_needed	/* see if input db is protected */
     1023 		then mstxn_transactions_needed = "1"b;
     1024 		else do;				/* if not, check output db */
     1025 			call mu_database_index$get_resultant_model_pointer (output_dbi, output_dbcb_ptr);
     1026 			mstxn_transactions_needed = output_dbcb_ptr -> dbcb.data.transactions_needed;
     1027 		     end;
     1028 	     end;
     1029 
     1030 retrieve_tuple:
     1031 	if transaction_group_size = 0
     1032 	then goto dont_start_the_transaction;
     1033 	if transaction_tuple_count < transaction_group_size
     1034 	then goto dont_start_the_transaction;
     1035 	transaction_tuple_count = 0;
     1036 	mstxn_txn_id = "0"b;
     1037 	on any_other call mstxn_any_other;
     1038 	on cleanup begin;
     1039 		call mstxn_cleanup;
     1040 		call clean_up;
     1041 	     end;
     1042 	on transaction_deadlock begin;
     1043 		mftxn_code = dm_error_$lock_deadlock;
     1044 		mstxn_retries = 100;		/* fake the include file into not retrying */
     1045 		goto mftxn_check_code;
     1046 	     end;
     1047 
 16     1 /* ====== BEGIN INCLUDE FILE	          mrds_start_transaction.incl.pl1 =========================== */
 16     2 
 16     3 
 16     4 
 16     5 /****^  HISTORY COMMENTS:
 16     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
 16     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
 16     8*     This entry is being made to cover the changes made on 85-05-06 and
 16     9*     85-04-19 by Thanh Nguyen. The dependency on dbcb.user_started_transaction
 16    10*     was removed because not all modules need the dbcb, and the
 16    11*     user_transaction_id field was added for mrds_dsl_retrieve (mrds error
 16    12*     list #136).
 16    13*                                                   END HISTORY COMMENTS */
 16    14 
 16    15 
 16    16 /*
 16    17*                    BEGIN_DESCRIPTION
 16    18*
 16    19*   A generalized routine accessed by all MRDS modules (with the temporary 
 16    20*   (perhaps) exception of restructuring modules) that must start transactions 
 16    21*   if none are present.  The intent is that it be executed as inline code.
 16    22*   The variable mstxn_transactions_needed must be set prior to entering this
 16    23*   code.  In most cases a simple assignment from dbcb_data.transactions_needed
 16    24*   will suffice.  Included are procedures called mstxn_cleanup and 
 16    25*   mstxn_any_other.  These procedures must be called by cleanup and any_other 
 16    26*   handlers in the program.  Such handlers should be established just prior to
 16    27*   the inclusion of this code and disabled just following the inclusion of
 16    28*   mrds_finish_transaction.  Directly prior to establishing the handlers
 16    29*   mstxn_txn_id must be set to "0"b.  This must be done even though this 
 16    30*   include file does the same, because this code might not have been entered 
 16    31*   yet when the handler is invoked.  Directly following this include file the 
 16    32*   contents of mstxn_code should be examined.  If zero, then either the 
 16    33*   transaction was successfully started or no transaction was required.  If the
 16    34*   mrds_finish_transaction code is referenced in general error handling 
 16    35*   situations where the possibility exists that the code in this include file 
 16    36*   has not been executed, it is necessary to initialize mstxn_txn_id to "0"b at
 16    37*   the beginning of the program.
 16    38*
 16    39*                    END_DESCRIPTION
 16    40*
 16    41*   Written 82-09-28 by Paul W. Benjamin.
 16    42*   Modified 82-12-09 by PWB to include mstxn_any_other.
 16    43*   Modified 83-01-07 by PWB to not reference the dbcb.
 16    44*   Modified 83-01-10 by PWB to add a call to continue_to_signal_ to the
 16    45*		 any_other handler in situations where the module did
 16    46*		 not start the transaction.
 16    47*   Modified 83-05-05 by PWB to abandon when abort fails.
 16    48*   Modified 83-05-18 by PWB to use mstxn_temp_code in calls to abandon and
 16    49*		 and abort.
 16    50*   Modified 83-05-19 by PWB to handle transaction_deadlock and 
 16    51*		 transaction_bj_full conditions.
 16    52*   Modified 84-02-04 by PWB to add trailing underscores to the 2 conditions
 16    53*		 and to handle transaction_lock_timeout_.
 16    54*   Modified 85-04-14 by Thanh Nguyen: Added code to set the 
 16    55*                     dbcb.user_started_transaction flag.
 16    56*   Modified 85-04-19 by Thanh Nguyen to add user_started_transaction flag.
 16    57*   Modified 85-05-06 By Thanh Nguyen to synchronize this include file in the 
 16    58*                     directory >ldd>include and >exl>mrd>i
 16    59**/
 16    60 
 16    61 dcl continue_to_signal_ entry (fixed bin(35));
 16    62 dcl dm_error_$no_current_transaction fixed bin (35) ext static;
 16    63 dcl error_table_$null_info_ptr fixed bin(35) ext static;
 16    64 dcl find_condition_info_ entry (ptr, ptr, fixed bin(35));
 16    65 dcl mstxn_code fixed bin (35);
 16    66 dcl mstxn_retries fixed;
 16    67 dcl mstxn_temp_code fixed bin (35);
 16    68 dcl mstxn_transactions_needed bit (1) aligned;
 16    69 dcl user_started_transaction bit (1) aligned;
 16    70 dcl mstxn_txn_id bit (36) aligned;
 16    71 dcl user_transaction_id bit (36) aligned;
 16    72 dcl transaction_manager_$abandon_txn entry (bit (36) aligned, fixed bin (35));
 16    73 dcl transaction_manager_$abort_txn entry (bit (36) aligned, fixed bin (35));
 16    74 dcl transaction_manager_$begin_txn entry (fixed bin, fixed bin (35), bit (36) aligned, fixed bin (35));
 16    75 dcl transaction_manager_$get_current_txn_id entry (bit (36) aligned, fixed bin (35));
 16    76 dcl transaction_manager_$handle_conditions entry ();
 16    77 dcl 1 mstxn_condition_info like condition_info;
 16    78 
 17     1 /*  START OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 17     2 
 17     3 /* HISTORY:
 17     4*
 17     5*Designed by Matthew C. Pierret, 01/26/82.
 17     6*Coded by Jeffrey D. Ives, 04/30/82.
 17     7*Modified:
 17     8*10/18/82 by Steve Herbst: Names changed.
 17     9*01/19/83 by Steve Herbst: Added (LOWEST HIGHEST)_MODE.
 17    10**/
 17    11 
 17    12 dcl (LOWEST_MODE init (1),
 17    13      HIGHEST_MODE init (8)) fixed bin int static options (constant);
 17    14 
 17    15      dcl	   TM_NORMAL_MODE	      fixed bin static options (constant) init (1);
 17    16      dcl	   TM_STATISTICAL_MODE   fixed bin static options (constant) init (2);
 17    17      dcl	   TM_READ_ONLY_MODE     fixed bin static options (constant) init (3);
 17    18      dcl	   TM_NEVER_WRITE_MODE   fixed bin static options (constant) init (4);
 17    19      dcl	   TM_TEST_NORMAL_MODE   fixed bin static options (constant) init (5);
 17    20      dcl	   TM_TEST_STATISTICAL_MODE fixed bin static options (constant) init (6);
 17    21      dcl	   TM_TEST_READ_ONLY_MODE fixed bin static options (constant) init (7);
 17    22      dcl	   TM_TEST_NEVER_WRITE_MODE fixed bin static options (constant) init (8);
 17    23 
 17    24 /*  END OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 16    79 

 16    80 
 18     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
 18     2 
 18     3 /* Structure for find_condition_info_.
 18     4*
 18     5*   Written 1-Mar-79 by M. N. Davidoff.
 18     6**/
 18     7 
 18     8 /* automatic */
 18     9 
 18    10      declare condition_info_ptr     pointer;
 18    11 
 18    12 /* based */
 18    13 
 18    14      declare 1 condition_info	      aligned based (condition_info_ptr),
 18    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
 18    16 	     2 version	      fixed binary,		/* Must be 1 */
 18    17 	     2 condition_name     char (32) varying,	/* name of condition */
 18    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
 18    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
 18    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
 18    21 	     2 flags	      unaligned,
 18    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
 18    23 	       3 pad1	      bit (35),
 18    24 	     2 pad2	      bit (36),
 18    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
 18    26 	     2 pad3	      (4) bit (36);
 18    27 
 18    28 /* internal static */
 18    29 
 18    30      declare condition_info_version_1
 18    31 			      fixed binary internal static options (constant) initial (1);
 18    32 
 18    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
 16    81 
 16    82 
 16    83 	mstxn_code = 0;
 16    84 	mstxn_txn_id = "0"b;
 16    85 	
 16    86 	if ^mstxn_transactions_needed			/* only need transactions */
 16    87 	     then goto mstxn_exit;			/* for protected page files */
 16    88 	mstxn_retries = 0;
 16    89 	call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
 16    90 	if mstxn_code ^= dm_error_$no_current_transaction	/* and if none already in progress */
 16    91 	     then do;				
 16    92 	     user_started_transaction = "1"b;
 16    93 	     user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
 16    94 	     mstxn_txn_id = "0"b;			/* you didn't start it, it's none of your business */
 16    95 	     goto mstxn_exit;	
 16    96 	end;
 16    97 
 16    98 	user_started_transaction = "0"b;
 16    99 	call transaction_manager_$begin_txn (TM_NORMAL_MODE, 0, mstxn_txn_id, mstxn_code);
 16   100 	user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
 16   101 
 16   102 mstxn_cleanup:
 16   103 proc;
 16   104 
 16   105 /*  This procedure MUST be called by a cleanup handler. */
 16   106 
 16   107           if mstxn_txn_id ^= "0"b
 16   108           then do;
 16   109 	     call transaction_manager_$abort_txn (mstxn_txn_id, mstxn_temp_code);
 16   110 	     if mstxn_temp_code ^= 0
 16   111 		then call transaction_manager_$abandon_txn (mstxn_txn_id, mstxn_temp_code);
 16   112 	end;
 16   113 	
 16   114      end mstxn_cleanup;
 16   115 
 16   116 mstxn_any_other:
 16   117 proc;
 16   118 
 16   119 /*  This procedure MUST be called by an any_other handler. */
 16   120 
 16   121           if mstxn_txn_id ^= "0"b
 16   122           then do;
 16   123 	     call find_condition_info_ (null (), addr(mstxn_condition_info), mstxn_temp_code);
 16   124 	     if mstxn_condition_info.condition_name = "transaction_deadlock_"
 16   125 		then do;
 16   126 		mftxn_code = dm_error_$lock_deadlock;
 16   127 		goto mftxn_check_code;
 16   128 	     end;
 16   129 	     else if mstxn_condition_info.condition_name = "transaction_bj_full_"
 16   130 		| mstxn_condition_info.condition_name = "transaction_lock_timeout_"
 16   131 		then do;
 16   132 		mftxn_code = dm_error_$bj_journal_full;
 16   133 		goto mftxn_check_code;
 16   134 	     end;
 16   135 	     else call transaction_manager_$handle_conditions;
 16   136 	end;
 16   137 	else call continue_to_signal_ (mstxn_code);	/* code returned will always be zero */
 16   138      end mstxn_any_other;
 16   139      
 16   140 mstxn_exit:
 16   141      
 16   142 /* ------ END INCLUDE FILE	          mrds_start_transaction.incl.pl1 --------------------------- */
     1048 
     1049 
     1050 	if mstxn_code ^= 0
     1051 	then call error (mstxn_code, "Unable to start a transaction.");
     1052 
     1053 	dbcb.user_started_transaction = user_started_transaction;
     1054 
     1055 dont_start_the_transaction:
     1056 	call cu_$generate_call (mrds_dsl_retrieve, retrieve_al_ptr);
     1057 	if error_code ^= 0
     1058 	then finished = ON;
     1059 	else do;
     1060 		tuples_retrieved = tuples_retrieved + 1;
     1061 		transaction_tuple_count = transaction_tuple_count + 1;
     1062 		call cu_$generate_call (mrds_dsl_store, store_al_ptr);
     1063 		if error_code ^= 0
     1064 		then finished = ON;
     1065 		if first_retrieval & ^finished
     1066 		then do;
     1067 			first_retrieval = OFF;
     1068 			retrieve_al_ptr -> arg_list.arg_des_ptr (2) = addr (ANOTHER_RETRIEVAL_SELECT_EXPR);
     1069 			retrieve_al_ptr -> arg_list.arg_des_ptr (retrieve_desc_index + 2) = addr (CHAR_8_DESCR);
     1070 		     end;
     1071 	     end;
     1072 	if error_code = mrds_error_$tuple_not_found
     1073 	then do;
     1074 		error_code = 0;
     1075 		call ioa_ ("Copied ^4d tuples from relation ^a.",
     1076 		     tuples_retrieved, relations_to_be_copied.rel_name (k));
     1077 	     end;
     1078 
     1079 	if transaction_group_size = 0
     1080 	then goto dont_finish_the_transaction;
     1081 	if transaction_tuple_count < transaction_group_size & ^finished
     1082 	then goto dont_finish_the_transaction;
     1083 	mftxn_code = error_code;
     1084 
 19     1 /* ====== BEGIN INCLUDE FILE           mrds_finish_transaction.incl.pl1 =========================== */
 19     2 
 19     3 
 19     4 
 19     5 /****^  HISTORY COMMENTS:
 19     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
 19     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
 19     8*     This entry is being made to cover the change made on 85-05-06 by Thanh
 19     9*     Nguyen. The code now checks a local flag. (mrds error list #136).
 19    10*                                                   END HISTORY COMMENTS */
 19    11 
 19    12 
 19    13 /*
 19    14*                    BEGIN_DESCRIPTION
 19    15*
 19    16*   A generalized routine accessed by all MRDS modules that begin and commit 
 19    17*   transactions.  The intent is that it be executed as inline code. It is 
 19    18*   assumed that mrds_start_transaction was executed previously in the 
 19    19*   procedure.  Prior to this include file the program should assign the value 
 19    20*   of its local error code to mftxn_code.  The program utilizing this
 19    21*   include file must supply a function labeled should_rollback that returns
 19    22*   bit (1).  This routine should examine the error code mftxn_code and whether
 19    23*   the transaction should be aborted or rolled back.  "0"b means abort and "1"b
 19    24*   means rollback.  This procedure may choose to simply return "0"b as it 
 19    25*   appears that MRDS will generally NOT rollback transactions.  This routine
 19    26*   does rollback and restart if the before journal is full but only attempts it
 19    27*   once.  A procedure labelled restore_significant_data must also be supplied, 
 19    28*   where any data that was saved prior to the transaction is restored.  A 
 19    29*   procedure consisting solely of a return statement can be supplied if 
 19    30*   necessary.  After execution of this include file, mftxn_code must be
 19    31*   examined.  If it was 0 before entering the code and is non-zero afterward,
 19    32*   then the commit has failed.  Otherwise it will be unchanged.
 19    33*
 19    34*                    END_DESCRIPTION
 19    35*
 19    36*   Written 82-09-30 by Paul W. Benjamin.
 19    37*   Modified 83-01-13 by PWB to add retry on deadlocks and to return a non-zero 
 19    38*                     error code only when the transaction is in an error state.
 19    39*   Modified 83-02-04 by PWB to reset transaction id to 0 upon completion.
 19    40*   Modified 83-05-05 by PWB to abort when rollback fails, abandon when abort
 19    41*		 fails, and to abort rather than rollback when bj is full.
 19    42*   Modified 83-05-18 by PWB to use mftxn_temp_code in calls to abandon, abort
 19    43*		 and rollback.
 19    44*   Modified 83-05-19 by PWB to add mftxn_check_code label.  It is transferred
 19    45*		 to by the mstxn_any_other procedure.
 19    46*   Modified 85-04-14 by Thanh Nguyen not to commit the transaction in case of
 19    47*                     the user already started his own transaction.
 19    48*   Modified 85-05-06 by Thanh Nguyen to synchronize this include file between
 19    49*                     the directory >ldd>include and >exl>mrd>i.
 19    50**/
 19    51 
 19    52 dcl dm_error_$bj_journal_full fixed bin(35) ext static;
 19    53 dcl dm_error_$lock_deadlock fixed bin(35) ext static;
 19    54 dcl mftxn_code fixed bin (35);
 19    55 dcl mftxn_temp_code fixed bin (35);
 19    56 dcl transaction_manager_$commit_txn entry (bit (36) aligned, fixed bin (35));
 19    57 dcl transaction_manager_$rollback_txn entry (bit (36) aligned, fixed bin (17), fixed bin (35));
 19    58 	
 19    59 
 19    60 	if mstxn_txn_id = "0"b | user_started_transaction = "1"b	/* No transaction or we did not started it */
 19    61 	     then do;
 19    62 	     mftxn_code = 0;
 19    63 	     goto mftxn_exit;
 19    64 	end;
 19    65 mftxn_check_code:
 19    66 	if mftxn_code = 0
 19    67 	     then do;
 19    68 	     call transaction_manager_$commit_txn (mstxn_txn_id, mftxn_code);
 19    69 	     if mftxn_code ^= 0
 19    70 		then do;
 19    71 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
 19    72 		if mftxn_temp_code ^= 0
 19    73 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
 19    74 	     end;
 19    75 	end;
 19    76 	else do;
 19    77 	     call restore_significant_data;
 19    78 	     if mftxn_code = dm_error_$lock_deadlock	/* retry just once if deadlock */
 19    79 		& mstxn_retries < 1		
 19    80 		then do;
 19    81 		     mstxn_retries = mstxn_retries + 1;
 19    82 		     call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
 19    83 		     if mftxn_temp_code ^= 0
 19    84 			then do;
 19    85 			call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
 19    86 			if mftxn_temp_code ^= 0
 19    87 			     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
 19    88 		     end;
 19    89 		     else do;
 19    90 			mstxn_code = 0;
 19    91 			goto mstxn_exit;		/* go back and try again */
 19    92 		     end;
 19    93 		end;
 19    94 	     else if should_rollback ()		/* let the program decide */
 19    95 		then do;
 19    96 		call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
 19    97 		if mftxn_temp_code ^= 0
 19    98 		     then do;
 19    99 		     call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
 19   100 		     if mftxn_temp_code ^= 0
 19   101 			then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
 19   102 		end;
 19   103 		else do;
 19   104 		     mstxn_code = 0;
 19   105 		     goto mstxn_exit;		/* go back and try again */
 19   106 		end;
 19   107 	     end;
 19   108 	     else do;
 19   109 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
 19   110 		if mftxn_temp_code ^= 0
 19   111 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
 19   112 	     end;
 19   113 	end;
 19   114 	mstxn_txn_id = "0"b;			/* should never be nonzero unless there is a txn */
 19   115 mftxn_exit:
 19   116      
 19   117 /* ------ END INCLUDE FILE	          mrds_finish_transaction.incl.pl1 --------------------------- */
     1085 
     1086 
     1087 	revert any_other;
     1088 	revert transaction_deadlock;
     1089 	on cleanup call clean_up;
     1090 dont_finish_the_transaction:
     1091 	if error_code ^= 0
     1092 	then call error (error_code, "");
     1093 	if mftxn_code ^= 0
     1094 	then call error (mftxn_code, "");
     1095 	if ^finished
     1096 	then goto retrieve_tuple;
     1097 should_rollback:
     1098      procedure returns (bit (1));
     1099 	return ("0"b);
     1100      end should_rollback;
     1101 restore_significant_data:
     1102      procedure;
     1103      end restore_significant_data;
     1104 
     1105      end copy_tuples;
     1106 
     1107 free_arg_lists: procedure ();
     1108 
     1109 /* this routine frees the existing argument lists, and data space for attributes,
     1110*   so that the same space can be reused for each relation */
     1111 
     1112 
     1113 	if store_al_ptr ^= null
     1114 	then free store_al_ptr -> arg_list in (work_area);
     1115 
     1116 	if retrieve_al_ptr ^= null
     1117 	then free retrieve_al_ptr -> arg_list in (work_area);
     1118 
     1119 	if data_space_ptr_ptr ^= null
     1120 	then do;
     1121 		do n = 1 to input_rd_ptr -> rel_desc.num_attr;
     1122 		     if data_space_ptr (n) ^= null
     1123 		     then free data_space_ptr (n) -> data_space;
     1124 		end;
     1125 		free data_space_ptr;
     1126 	     end;
     1127 
     1128 
     1129 
     1130 
     1131      end free_arg_lists;
     1132 
     1133 delete_scope:
     1134      procedure;
     1135 
     1136 /* for this current relation, delete scope on both input and output */
     1137 
     1138 	call mrds_dsl_set_scope$dl_scope (input_dbi, relations_to_be_copied.rel_name (k), READ_ATTR, specified_input_prevents, error_code);
     1139 
     1140 	if error_code ^= 0
     1141 	then do;
     1142 		call com_err_ (error_code, CALLER_NAME, "^/Deleting scope on relation ^a of input database.", relations_to_be_copied.rel_name (k));
     1143 		call clean_up;
     1144 		goto exit;
     1145 	     end;
     1146 
     1147 	call mrds_dsl_set_scope$dl_scope (output_dbi, relations_to_be_copied.rel_name (k), APPEND_TUPLE, specified_output_prevents, error_code);
     1148 
     1149 	if error_code ^= 0
     1150 	then do;
     1151 		call com_err_ (error_code, CALLER_NAME, "^/Deleting scope on relation ^a of output database.", relations_to_be_copied.rel_name (k));
     1152 		call clean_up;
     1153 		goto exit;
     1154 	     end;
     1155      end;
     1156 
     1157 get_database_uid: procedure (path, db_uid);
     1158 
     1159 /* this routine turns a path into a pointer for comparison purposes */
     1160 
     1161 	call expand_pathname_ (path, dir, entry, error_code);
     1162 	if error_code ^= 0
     1163 	then call error (error_code, path);
     1164 
     1165 	allocate status_branch set (status_ptr) in (work_area); /* get space for answer */
     1166 
     1167 	call hcs_$status_long (dir, entry, 1, status_ptr, temp_seg_ptr, error_code);
     1168 
     1169 	if error_code ^= 0
     1170 	then do;
     1171 		free status_ptr -> status_branch in (work_area);
     1172 		call error (error_code, path);
     1173 	     end;
     1174 
     1175 	db_uid = status_ptr -> status_branch.uid;
     1176 
     1177 	free status_ptr -> status_branch in (work_area);
     1178 
     1179 	declare path		 char (168);	/* absolute path input */
     1180 	declare dir		 char (168);	/* direcotry portion */
     1181 	declare entry		 char (32);	/* entry portion */
     1182 	declare db_uid		 bit (36);	/* unique id of directory given by input path */
     1183 
     1184      end get_database_uid;
     1185 
     1186 error: procedure (err_code, err_message);
     1187 
     1188 	dcl     err_code		 fixed bin (35);
     1189 	dcl     err_message		 char (*);
     1190 	dcl     saved_code		 fixed bin (35);
     1191 
     1192 	saved_code = err_code;
     1193 	call com_err_ (saved_code, CALLER_NAME, err_message);
     1194 	call clean_up;
     1195 	go to exit;
     1196 
     1197      end error;
     1198 
     1199 clean_up: procedure ();
     1200 
     1201 /* get rid of temporary storage, and close any open databases or datamodels */
     1202 
     1203 	if status_ptr ^= null
     1204 	then free status_ptr -> status_branch;
     1205 
     1206 	if rtbc_ptr ^= null
     1207 	then free relations_to_be_copied;
     1208 
     1209 	call free_arg_lists;
     1210 	dbcb.data.dont_check_txn_id = "0"b;
     1211 	
     1212 	if input_dbi ^= 0
     1213 	then do;
     1214 		call mrds_dsl_close (input_dbi, error_code);
     1215 		if error_code ^= 0
     1216 		then call com_err_ (error_code, CALLER_NAME, "^/^a ^d ^a",
     1217 			"Unable to close the input database using index", input_dbi, ".");
     1218 		input_dbi = 0;
     1219 	     end;
     1220 
     1221 	if output_dbi ^= 0
     1222 	then do;
     1223 		call mrds_dsl_close (output_dbi, error_code);
     1224 		if error_code ^= 0
     1225 		then call com_err_ (error_code, CALLER_NAME, "^/^a ^d ^a",
     1226 			"Unable to close the output database using index", output_dbi, ".");
     1227 		output_dbi = 0;
     1228 	     end;
     1229 
     1230 	if input_dm_ptr ^= null ()
     1231 	then do;
     1232 		call mrds_dm_close (input_dm_ptr, error_code);
     1233 		if error_code ^= 0
     1234 		then call com_err_ (error_code, CALLER_NAME, "^/Unable to close the input datamodel.");
     1235 		input_dm_ptr = null ();
     1236 	     end;
     1237 
     1238 	if output_dm_ptr ^= null ()
     1239 	then do;
     1240 		call mrds_dm_close (output_dm_ptr, error_code);
     1241 		if error_code ^= 0
     1242 		then call com_err_ (error_code, CALLER_NAME, "^/Unable to close the output datamodel.");
     1243 		output_dm_ptr = null ();
     1244 	     end;
     1245 
     1246 	if temp_seg_ptr ^= null ()
     1247 	then do;
     1248 		call release_temp_segment_ (CALLER_NAME, temp_seg_ptr, error_code);
     1249 		if error_code ^= 0
     1250 		then call com_err_ (error_code, CALLER_NAME);
     1251 		temp_seg_ptr = null ();
     1252 	     end;
     1253 
     1254      end clean_up;
     1255 
     1256      end copy_mrds_data;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1313.8  copy_mrds_data.pl1                >special_ldd>install>MR12.2-1073>copy_mrds_data.pl1
227          1    10/14/83  1609.0  mdbm_arg_list.incl.pl1            >ldd>include>mdbm_arg_list.incl.pl1
229          2    10/14/83  1608.6  mdbm_descriptor.incl.pl1          >ldd>include>mdbm_descriptor.incl.pl1
231          3    10/14/83  1609.1  mdbm_rm_attr_info.incl.pl1        >ldd>include>mdbm_rm_attr_info.incl.pl1
233          4    08/01/88  1310.7  mdbm_rm_db_info.incl.pl1          >special_ldd>install>MR12.2-1073>mdbm_rm_db_info.incl.pl1
235          5    10/14/83  1609.1  mdbm_rm_domain_info.incl.pl1      >ldd>include>mdbm_rm_domain_info.incl.pl1
237          6    10/14/83  1609.1  mdbm_rm_rel_array.incl.pl1        >ldd>include>mdbm_rm_rel_array.incl.pl1
239          7    10/14/83  1609.1  mdbm_rm_rel_info.incl.pl1         >ldd>include>mdbm_rm_rel_info.incl.pl1
241          8    08/01/88  1300.0  mrds_dbcb.incl.pl1                >special_ldd>install>MR12.2-1073>mrds_dbcb.incl.pl1
243          9    10/14/83  1608.8  mrds_path_info.incl.pl1           >ldd>include>mrds_path_info.incl.pl1
245         10    10/14/83  1608.6  mrds_dm_header.incl.pl1           >ldd>include>mrds_dm_header.incl.pl1
247         11    10/14/83  1608.4  mrds_model_relations.incl.pl1     >ldd>include>mrds_model_relations.incl.pl1
249         12    10/14/83  1609.0  mrds_rel_desc.incl.pl1            >ldd>include>mrds_rel_desc.incl.pl1
251         13    10/14/83  1608.7  mrds_new_scope_modes.incl.pl1     >ldd>include>mrds_new_scope_modes.incl.pl1
253         14    10/14/83  1608.6  mrds_opening_modes_.incl.pl1      >ldd>include>mrds_opening_modes_.incl.pl1
255         15    11/22/82  0955.7  status_structures.incl.pl1        >ldd>include>status_structures.incl.pl1
1048        16    02/05/86  1416.4  mrds_start_transaction.incl.pl1   >ldd>include>mrds_start_transaction.incl.pl1
16-79       17    01/07/85  0900.0  dm_tm_modes.incl.pl1              >ldd>include>dm_tm_modes.incl.pl1
16-81       18    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
1085        19    02/05/86  1416.4  mrds_finish_transaction.incl.pl1  >ldd>include>mrds_finish_transaction.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ANOTHER_RETRIEVAL_SELECT_EXPR   000014 constant        char(8)                  initial dcl 202 set ref 1068
APPEND_TUPLE                    000103 constant        fixed bin(17,0)          initial dcl 13-18 set ref 402 441 803* 1147*
CALLER_NAME                     000010 constant        char(15)                 initial packed unaligned dcl 204 set ref 346* 365*
                                                                                  381* 393* 420* 432* 459* 514* 559* 568* 598* 608*
                                                                                  691* 731* 798* 807* 823* 835* 853* 881* 900* 1142*
                                                                                  1151* 1193* 1215* 1224* 1233* 1241* 1248* 1249*
CHAR_32_DESCR                   000007 constant        bit(36)                  initial packed unaligned dcl 208 set ref 1002
CHAR_53_DESCR                   000006 constant        bit(36)                  initial packed unaligned dcl 210 set ref 945
CHAR_8_DESCR                    000052 constant        bit(36)                  initial packed unaligned dcl 206 set ref 1069
DELETE_TUPLE                           constant        fixed bin(17,0)          initial dcl 13-18 ref 405 444
FIXED_BIN_35_DESCR              000101 constant        bit(36)                  initial packed unaligned dcl 212 set ref 937 980
MODIFY_ATTR                            constant        fixed bin(17,0)          initial dcl 13-18 ref 408 447
OFF                                    constant        bit(1)                   initial packed unaligned dcl 216 ref 487 658 674 686
                                                                                  705 865 1017 1067
ON                                     constant        bit(1)                   initial packed unaligned dcl 214 ref 484 662 670 678
                                                                                  691 712 875 1016 1057 1063
PAREN_SELECT                    000003 constant        char(11)                 initial packed unaligned dcl 218 ref 941
RANGE_PAREN                     000000 constant        char(10)                 initial packed unaligned dcl 220 ref 939
READ_ATTR                       000100 constant        fixed bin(17,0)          initial dcl 13-18 set ref 399 438 794* 1138*
RETRIEVAL                       000100 constant        fixed bin(35,0)          initial dcl 14-15 set ref 555*
RETRIEVAL_MODE                  000103 constant        fixed bin(17,0)          initial dcl 222 set ref 564* 604*
TM_NORMAL_MODE                  000100 constant        fixed bin(17,0)          initial dcl 17-15 set ref 16-99*
UPDATE                          000103 constant        fixed bin(35,0)          initial dcl 14-15 set ref 594*
UPDATE_OPS                             constant        fixed bin(17,0)          initial dcl 13-18 ref 411 450 510
absolute_path             1            based           char(168)                level 2 dcl 9-22 ref 306 334
addr                                                   builtin function         dcl 145 ref 935 937 943 945 960 960 970 979 980 998
                                                                                  1000 1002 1068 1069 16-123 16-123
addrel                                                 builtin function         dcl 145 ref 960
any_other                       000000 stack reference condition                dcl 151 ref 1037 19-115
arg                                    based           char                     packed unaligned dcl 131 set ref 359 359* 361 361
                                                                                  365* 377 381* 390 391 393 393 399 402 402 405 408
                                                                                  411 416 420* 429 430 432 432 438 441 441 444 447
                                                                                  450 455 459* 467 469 471*
arg_count                              based           fixed bin(17,0)          level 2 packed packed unaligned dcl 1-6 set ref 931*
arg_des_ptr               2            based           pointer                  array level 2 dcl 1-6 set ref 935* 937* 943* 945*
                                                                                  960* 968* 970* 979* 980* 998* 1000* 1002* 1068*
                                                                                  1069*
arg_length                      000100 automatic       fixed bin(21,0)          dcl 72 set ref 356* 359 359 359 361 361 365 365 370*
                                                                                  375 377 381 381 386* 390 391 393 393 399 402 402
                                                                                  405 408 411 416 420 420 425* 429 430 432 432 438
                                                                                  441 441 444 447 450 455 459 459 464* 467 469 471
                                                                                  471
arg_list                               based           structure                level 1 unaligned dcl 1-6 set ref 927 991 993* 993
                                                                                  1113 1116
arg_ptr                         000102 automatic       pointer                  dcl 73 set ref 356* 359 359 361 361 365 370* 374 377
                                                                                  381 386* 390 391 393 393 399 402 402 405 408 411
                                                                                  416 420 425* 429 430 432 432 438 441 441 444 447
                                                                                  450 455 459 464* 467 469 471
attr_bit_length                 000104 automatic       fixed bin(35,0)          dcl 74 set ref 950* 958 958 1122 1122
attr_ptrs                              based           pointer                  array level 2 dcl 7-119 ref 950 960 960 970
attribute_name            5            based           char(32)                 array level 3 packed packed unaligned dcl 12-12 set
                                                                                  ref 871 871 881* 900*
attributes                5            based           structure                array level 2 unaligned dcl 12-12
cleanup                         000376 stack reference condition                dcl 151 ref 264 1038 1089
code                      0(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 1-6 set ref 929*
com_err_                        000010 constant        entry                    external dcl 156 ref 346 365 381 393 420 432 459 467
                                                                                  559 568 598 608 691 731 798 807 823 835 853 881
                                                                                  900 1142 1151 1193 1215 1224 1233 1241 1249
condition_info                         based           structure                level 1 dcl 18-14
condition_name            3     000110 automatic       varying char(32)         level 2 dcl 16-77 set ref 16-124 16-129 16-129
continue_to_signal_             000122 constant        entry                    external dcl 16-61 ref 16-137
create_time              14            based           fixed bin(71,0)          level 2 dcl 10-6 set ref 579* 620*
creator_id                3            based           char(32)                 level 2 packed packed unaligned dcl 10-6 set ref
                                                                                  580* 622*
cu_$arg_count                   000012 constant        entry                    external dcl 157 ref 286
cu_$arg_ptr                     000014 constant        entry                    external dcl 158 ref 293 323 356 370 386 425 464
cu_$generate_call               000016 constant        entry                    external dcl 159 ref 1055 1062
data                                   based           structure                level 2 in structure "rm_db_info" dcl 4-86
                                                                                  in procedure "cpmd"
data                                   based           structure                level 2 in structure "dbcb" dcl 8-142 in procedure
                                                                                  "cpmd"
data_space                             based           bit                      packed unaligned dcl 132 ref 958 1122
data_space_ptr                         based           pointer                  array dcl 133 set ref 947 958* 960 968 1122 1122
                                                                                  1125
data_space_ptr_ptr              000106 automatic       pointer                  dcl 75 set ref 502* 947* 958 960 968 1119 1122 1122
                                                                                  1125
date_time_                      000020 constant        entry                    external dcl 160 ref 579 620
db_uid                                 parameter       bit(36)                  packed unaligned dcl 1182 set ref 1157 1175*
dbcb                                   based           structure                level 1 dcl 8-142
dbcb_data                              based           structure                level 1 unaligned dcl 8-148
dbcb_ptr                        000412 automatic       pointer                  dcl 8-146 set ref 633* 638 645 659 660 703 707 709
                                                                                  722 900 950 960 960 970 1021 1022 1053 1210
desc_count                1            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 1-6 set ref 933*
descriptor               30            based           bit(36)                  array level 3 packed packed unaligned dcl 12-12 ref
                                                                                  876 876
dir                             000454 automatic       char(168)                packed unaligned dcl 1180 set ref 1161* 1167*
dm_error_$bj_journal_full       000142 external static fixed bin(35,0)          dcl 19-52 ref 16-132
dm_error_$lock_deadlock         000144 external static fixed bin(35,0)          dcl 19-53 ref 19-78 1043 16-126
dm_error_$no_current_transaction
                                000124 external static fixed bin(35,0)          dcl 16-62 ref 16-90
dm_header                              based           structure                level 1 unaligned dcl 10-6
dmd_version               2            based           fixed bin(17,0)          level 2 dcl 10-6 set ref 580* 584 622*
domain_ptr               26            based           pointer                  level 2 dcl 3-46 ref 950 960 960 970
dont_check_txn_id       106(25)        based           bit(1)                   level 3 packed packed unaligned dcl 8-142 set ref
                                                                                  1021* 1210*
empty                                                  builtin function         dcl 145 ref 518
entry                           000526 automatic       char(32)                 packed unaligned dcl 1181 set ref 1161* 1167*
equal                           000436 automatic       bit(1)                   packed unaligned dcl 492 set ref 484* 487* 490
err_code                               parameter       fixed bin(35,0)          dcl 1188 ref 1186 1192
err_message                            parameter       char                     packed unaligned dcl 1189 set ref 1186 1193*
error_code                      000110 automatic       fixed bin(35,0)          dcl 76 set ref 293* 294 294* 302* 308 310 310* 313*
                                                                                  323* 324 324* 330* 336 338 338* 341* 356* 357 357*
                                                                                  370* 371 371* 386* 387 387* 425* 426 426* 464* 465
                                                                                  465* 514* 515 515* 555* 556 559* 564* 565 568*
                                                                                  576* 577 577* 594* 595 598* 604* 605 608* 616* 617
                                                                                  617* 669* 685* 703 707 722* 728 731* 753 794* 796
                                                                                  798* 803* 805 807* 819* 821 823* 830* 833 835*
                                                                                  852* 853* 864 867 881* 892* 898 900* 979 1057 1063
                                                                                  1072 1074* 1083 1090 1090* 1138* 1140 1142* 1147*
                                                                                  1149 1151* 1161* 1162 1162* 1167* 1169 1172* 1214*
                                                                                  1215 1215* 1223* 1224 1224* 1232* 1233 1233* 1240*
                                                                                  1241 1241* 1248* 1249 1249*
error_table_$bad_arg            000070 external static fixed bin(35,0)          dcl 186 set ref 359* 393* 432* 467*
error_table_$badcall            000072 external static fixed bin(35,0)          dcl 187 set ref 317* 346* 638*
error_table_$badopt             000074 external static fixed bin(35,0)          dcl 188 set ref 471*
error_table_$noarg              000076 external static fixed bin(35,0)          dcl 189 set ref 287* 297* 326* 365* 381* 420* 459*
error_table_$sameseg            000100 external static fixed bin(35,0)          dcl 190 set ref 272*
expand_pathname_                000022 constant        entry                    external dcl 161 ref 1161
find_condition_info_            000126 constant        entry                    external dcl 16-64 ref 16-123
finished                        000111 automatic       bit(1)                   packed unaligned dcl 77 set ref 1017* 1057* 1063*
                                                                                  1065 1081 1095
first_retrieval                 000112 automatic       bit(1)                   packed unaligned dcl 78 set ref 1016* 1065 1067*
fixed                                                  builtin function         dcl 145 ref 469
found                           000113 automatic       bit(1)                   packed unaligned dcl 79 set ref 658* 659 662* 667
                                                                                  674* 675 678* 683 689 705* 707 712* 865* 867 875*
get_temp_segment_               000024 constant        entry                    external dcl 162 ref 514
hcs_$status_long                000026 constant        entry                    external dcl 163 ref 1167
i                               000114 automatic       fixed bin(17,0)          dcl 80 set ref 659* 660 663* 675* 676 679* 703* 709
                                                                                  713 714 714 715 715* 731
input_abs_path                  000115 automatic       char(168)                packed unaligned dcl 81 set ref 304* 306* 313 317
                                                                                  346* 486* 555* 559* 564* 568* 577* 580*
input_converted_time            000167 automatic       char(24)                 packed unaligned dcl 82 set ref 579* 580*
input_db_uid                    000175 automatic       bit(36)                  packed unaligned dcl 83 set ref 486* 487
input_dbi                       000176 automatic       fixed bin(35,0)          dcl 84 set ref 506* 555* 558* 633* 794* 935 1138*
                                                                                  1212 1214* 1215* 1218*
input_dm_ptr                    000200 automatic       pointer                  dcl 85 set ref 502* 564* 567* 576* 819* 1230 1232*
                                                                                  1235*
input_dmh_ptr                   000202 automatic       pointer                  dcl 86 set ref 502* 576* 579 580 580 584
input_path                             based           char                     packed unaligned dcl 135 set ref 297 302* 304
input_path_len                  000204 automatic       fixed bin(21,0)          dcl 87 set ref 293* 297 302 302 304
input_path_ptr                  000206 automatic       pointer                  dcl 88 set ref 293* 297 302 304
input_rd_ptr                    000210 automatic       pointer                  dcl 89 set ref 819* 849 849 867 871 876 876 892 923
                                                                                  947 1121 1125
input_rel_missing               000212 automatic       bit(1)                   packed unaligned dcl 90 set ref 670* 686* 691
input_rel_num                          based           fixed bin(17,0)          array level 2 dcl 138 set ref 663* 713* 950 960 960
                                                                                  970
ioa_                            000030 constant        entry                    external dcl 164 ref 545 580 622 1075
j                               000213 automatic       fixed bin(17,0)          dcl 91 set ref 707* 709 713 722*
k                               000214 automatic       fixed bin(17,0)          dcl 92 set ref 753* 794 798 803 807 819 823 830 835
                                                                                  853 881 900 939 950 960 960 970 1004 1075 1138
                                                                                  1142 1147 1151
key_flag                 25(18)        based           bit(1)                   array level 3 packed packed unaligned dcl 12-12 ref
                                                                                  876 876
l                               000215 automatic       fixed bin(17,0)          dcl 93 set ref 864* 871 876 876 881 900*
long                      4            based           structure                level 2 dcl 15-8
m                               000216 automatic       fixed bin(17,0)          dcl 94 set ref 866* 867* 871 876 876 892*
mftxn_code                      000142 automatic       fixed bin(35,0)          dcl 19-54 set ref 1015* 1083* 19-62* 19-65 19-68*
                                                                                  19-69 19-78 1043* 1093 1093* 16-126* 16-132*
mftxn_temp_code                 000143 automatic       fixed bin(35,0)          dcl 19-55 set ref 19-71* 19-72 19-72* 19-82* 19-83
                                                                                  19-85* 19-86 19-86* 19-96* 19-97 19-99* 19-100
                                                                                  19-100* 19-109* 19-110 19-110*
model_name                             based           char(30)                 array level 3 dcl 6-34 set ref 660 676 709 709 715
                                                                                  731* 900*
mrds_dm_close                   000032 constant        entry                    external dcl 165 ref 1232 1240
mrds_dm_get_attributes          000036 constant        entry                    external dcl 167 ref 819 830
mrds_dm_get_header              000034 constant        entry                    external dcl 166 ref 576 616
mrds_dm_open                    000040 constant        entry                    external dcl 168 ref 564 604
mrds_dsl_close                  000042 constant        entry                    external dcl 169 ref 1214 1223
mrds_dsl_get_version$get_path_info
                                000044 constant        entry                    external dcl 170 ref 302 330
mrds_dsl_open                   000046 constant        entry                    external dcl 171 ref 555 594
mrds_dsl_retrieve               000050 constant        entry                    external dcl 172 ref 1055 1055
mrds_dsl_set_scope$dl_scope     000052 constant        entry                    external dcl 173 ref 1138 1147
mrds_dsl_set_scope$set_scope    000054 constant        entry                    external dcl 175 ref 794 803
mrds_dsl_store                  000056 constant        entry                    external dcl 177 ref 1062 1062
mrds_error_$no_database         000102 external static fixed bin(35,0)          dcl 191 ref 310 338
mrds_error_$no_model_submodel   000104 external static fixed bin(35,0)          dcl 192 ref 310 338
mrds_error_$rst_wrong_command   000106 external static fixed bin(35,0)          dcl 193 set ref 584* 852
mrds_error_$tuple_not_found     000110 external static fixed bin(35,0)          dcl 194 ref 1072
mrds_error_$undef_attr          000112 external static fixed bin(35,0)          dcl 195 ref 892 898
mrds_error_$unknown_relation_name
                                000114 external static fixed bin(35,0)          dcl 196 set ref 669 685 691* 722
mrds_error_$version_not_supported
                                000116 external static fixed bin(35,0)          dcl 197 set ref 315*
mrds_path_info                         based           structure                level 1 dcl 9-22
mrds_path_info_ptr              000414 automatic       pointer                  dcl 9-36 set ref 302* 304 306 315 317 330* 332 334
                                                                                  344
mrds_path_info_structure_version
                                000100 constant        fixed bin(17,0)          initial dcl 9-38 set ref 302* 330*
mrds_version             54            based           fixed bin(17,0)          level 2 dcl 9-22 ref 315
mstxn_code                      000100 automatic       fixed bin(35,0)          dcl 16-65 set ref 16-83* 16-89* 16-90 16-99* 16-140
                                                                                  16-140* 19-90* 19-104* 16-137*
mstxn_condition_info            000110 automatic       structure                level 1 unaligned dcl 16-77 set ref 16-123 16-123
mstxn_retries                   000101 automatic       fixed bin(17,0)          dcl 16-66 set ref 16-88* 19-78 19-81* 19-81 1044*
mstxn_temp_code                 000102 automatic       fixed bin(35,0)          dcl 16-67 set ref 16-109* 16-110 16-110* 16-123*
mstxn_transactions_needed       000103 automatic       bit(1)                   dcl 16-68 set ref 1022* 1026* 16-86
mstxn_txn_id                    000105 automatic       bit(36)                  dcl 16-70 set ref 1036* 16-84* 16-89* 16-93 16-94*
                                                                                  16-99* 16-100 19-60 19-68* 19-71* 19-72* 19-82*
                                                                                  19-85* 19-86* 19-96* 19-99* 19-100* 19-109*
                                                                                  19-110* 19-114* 16-107 16-109* 16-110* 16-121
mu_data_class$varying           000060 constant        entry                    external dcl 178 ref 960
mu_data_length                  000062 constant        entry                    external dcl 179 ref 950
mu_database_index$get_resultant_model_pointer
                                000064 constant        entry                    external dcl 180 ref 633 634 1025
n                               000220 automatic       fixed bin(17,0)          dcl 96 set ref 353* 356* 363 369* 369 370* 379 385*
                                                                                  385 386* 418 424* 424 425* 457 463* 463 464* 949*
                                                                                  950 958 960 960 960 960 968 968 970 970* 1121*
                                                                                  1122 1122*
n_rels_to_be_copied             000221 automatic       fixed bin(17,0)          dcl 97 set ref 643* 645* 646 753 1206
nargs                           000217 automatic       fixed bin(17,0)          dcl 95 set ref 286* 287 353 363 379 418 457
nkey_attr                24            based           fixed bin(17,0)          level 2 dcl 7-119 ref 950 960 960 970
null                                                   builtin function         dcl 145 ref 3-65 5-51 304 332 502 567 607 16-123
                                                                                  16-123 1113 1116 1119 1122 1203 1206 1230 1235
                                                                                  1238 1243 1246 1251
num_attr                               based           fixed bin(17,0)          level 2 dcl 12-12 ref 849 849 864 867 892 923 947
                                                                                  1121 1125
num_dims                        000405 automatic       fixed bin(17,0)          initial dcl 2-20 set ref 2-20*
num_keys                  3            based           fixed bin(17,0)          level 2 dcl 12-12 ref 849 849
num_ptrs                        000404 automatic       fixed bin(17,0)          dcl 1-14 set ref 925* 927 931 933 991 993 1113 1116
num_rels                               based           fixed bin(17,0)          level 2 dcl 6-34 ref 638 638 645 659 660 675 676 703
                                                                                  707 709 709 715 722 731 900 950 960 960 970
op_num                          000222 automatic       fixed bin(17,0)          dcl 98 set ref 391* 392 393 393 430* 431 432 432
output_abs_path                 000223 automatic       char(168)                packed unaligned dcl 99 set ref 332* 334* 341 485*
                                                                                  594* 598* 604* 608* 617* 622*
output_converted_time           000275 automatic       char(24)                 packed unaligned dcl 100 set ref 620* 622*
output_db_uid                   000303 automatic       bit(36)                  packed unaligned dcl 101 set ref 485* 487
output_dbcb_ptr                 000304 automatic       pointer                  dcl 102 set ref 634* 638 675 676 709 715 731 1025*
                                                                                  1026
output_dbi                      000306 automatic       fixed bin(35,0)          dcl 103 set ref 506* 594* 597* 634* 803* 998 1025*
                                                                                  1147* 1221 1223* 1224* 1227*
output_dm_ptr                   000310 automatic       pointer                  dcl 104 set ref 502* 604* 607* 616* 830* 1238 1240*
                                                                                  1243*
output_dmh_ptr                  000312 automatic       pointer                  dcl 105 set ref 502* 616* 620 622 622
output_path                            based           char                     packed unaligned dcl 134 set ref 326 330* 332
output_path_len                 000314 automatic       fixed bin(21,0)          dcl 106 set ref 323* 326 330 330 332
output_path_ptr                 000316 automatic       pointer                  dcl 107 set ref 323* 326 330 332
output_rd_ptr                   000320 automatic       pointer                  dcl 108 set ref 830* 849 849 864 871 876 876 881 900
output_rel_num            1            based           fixed bin(17,0)          array level 2 dcl 138 set ref 679* 714*
path                                   parameter       char(168)                packed unaligned dcl 1179 set ref 1157 1161* 1162*
                                                                                  1172*
ra_ptr                  134            based           pointer                  level 3 dcl 4-86 ref 638 638 645 659 660 675 676 703
                                                                                  707 709 709 715 722 731 900 950 960 960 970
rai_ptr                         000406 automatic       pointer                  initial dcl 3-65 set ref 3-65*
rdbi_ptr                               based           pointer                  level 3 dcl 8-142 ref 638 638 645 659 660 675 676
                                                                                  703 707 709 709 715 722 731 900 950 960 960 970
rdi_ptr                         000410 automatic       pointer                  initial dcl 5-51 set ref 5-51*
rel_arg                                based           char                     packed unaligned dcl 136 set ref 660 676 680 691*
rel_arg_length                  000322 automatic       fixed bin(21,0)          dcl 109 set ref 375* 660 676 680 691 691
rel_arg_ptr                     000324 automatic       pointer                  dcl 110 set ref 374* 660 676 680 691
rel_data                               based           structure                array level 2 dcl 6-34
rel_desc                               based           structure                level 1 unaligned dcl 12-12
rel_name                  2            based           char(32)                 array level 2 packed packed unaligned dcl 138 set
                                                                                  ref 680* 715* 794* 798* 803* 807* 819* 823* 830*
                                                                                  835* 853* 881* 939 1004 1075* 1138* 1142* 1147*
                                                                                  1151*
relations_to_be_copied                 based           structure                array level 1 unaligned dcl 138 set ref 646 1206
release_temp_segment_           000066 constant        entry                    external dcl 182 ref 1248
retrieve_al_ptr                 000326 automatic       pointer                  dcl 111 set ref 502* 927* 929 931 933 935 937 943
                                                                                  945 960 968 970 979 980 993 1055* 1068 1069 1116
                                                                                  1116
retrieve_desc_index             000330 automatic       fixed bin(17,0)          dcl 112 set ref 923* 925 937 945 949 970 979 980
                                                                                  1002 1069
retrieve_select_expr            000331 automatic       char(53)                 dcl 113 set ref 939* 941* 941 943
ri_ptr                                 based           pointer                  array level 3 packed packed unaligned dcl 6-34 ref
                                                                                  950 960 960 970
rm_attr_info                           based           structure                level 1 dcl 3-46
rm_db_info                             based           structure                level 1 dcl 4-86
rm_db_info_data                        based           structure                level 1 unaligned dcl 4-92
rm_domain_info                         based           structure                level 1 dcl 5-35
rm_rel_array                           based           structure                level 1 dcl 6-34
rm_rel_info                            based           structure                level 1 dcl 7-119
rtbc_ptr                        000350 automatic       pointer                  dcl 114 set ref 502* 646* 663 679 680 713 714 715
                                                                                  794 798 803 807 819 823 830 835 853 881 939 950
                                                                                  960 960 970 1004 1075 1138 1142 1147 1151 1206
                                                                                  1206
rtrim                                                  builtin function         dcl 145 ref 941
saved_code                      000100 automatic       fixed bin(35,0)          dcl 1190 set ref 1192* 1193*
search                                                 builtin function         dcl 145 ref 399 402 402 405 408 411 438 441 441 444
                                                                                  447 450
single_relation                 000352 automatic       bit(1)                   packed unaligned dcl 115 set ref 373* 508* 638 643
                                                                                  656
specified_input_prevents        000353 automatic       fixed bin(17,0)          dcl 116 set ref 389* 399* 399 402* 402 405* 405 408*
                                                                                  408 411* 411 510* 794* 1138*
specified_output_prevents       000354 automatic       fixed bin(17,0)          dcl 118 set ref 428* 438* 438 441* 441 444* 444 447*
                                                                                  447 450* 450 510* 803* 1147*
status_branch                          based           structure                level 1 dcl 15-8 ref 1165 1171 1177 1203
status_ptr                      000416 automatic       pointer                  dcl 15-47 set ref 502* 1165* 1167* 1171 1175 1177
                                                                                  1203 1203
store_al_ptr                    000356 automatic       pointer                  dcl 120 set ref 502* 991* 993 998 1000 1002 1062*
                                                                                  1113 1113
store_select_expr               000360 automatic       char(32)                 dcl 121 set ref 1000 1004*
sub_error_                      000000 stack reference condition                dcl 151 ref 528
submodel                 53(02)        based           bit(1)                   level 3 packed packed unaligned dcl 9-22 ref 317 344
substr                                                 builtin function         dcl 145 ref 297 326 359 393 393 432 432
sys_info$max_seg_size           000120 external static fixed bin(35,0)          dcl 198 ref 518
temp_seg_ptr                    000370 automatic       pointer                  dcl 122 set ref 302* 330* 502* 514* 518 576* 616*
                                                                                  646 819* 830* 927 947 958 991 1113 1116 1165 1167*
                                                                                  1171 1177 1246 1248* 1251*
transaction_deadlock            000000 stack reference condition                dcl 151 ref 1042 1088
transaction_group_size          000372 automatic       fixed bin(17,0)          dcl 123 set ref 469* 506* 1018 1019 1030 1033 1079
                                                                                  1081
transaction_manager_$abandon_txn
                                000130 constant        entry                    external dcl 16-72 ref 19-72 19-86 19-100 19-110
                                                                                  16-110
transaction_manager_$abort_txn  000132 constant        entry                    external dcl 16-73 ref 19-71 19-85 19-99 19-109
                                                                                  16-109
transaction_manager_$begin_txn  000134 constant        entry                    external dcl 16-74 ref 16-99
transaction_manager_$commit_txn 000146 constant        entry                    external dcl 19-56 ref 19-68
transaction_manager_$get_current_txn_id
                                000136 constant        entry                    external dcl 16-75 ref 16-89
transaction_manager_$handle_conditions
                                000140 constant        entry                    external dcl 16-76 ref 16-135
transaction_manager_$rollback_txn
                                000150 constant        entry                    external dcl 19-57 ref 19-82 19-96
transaction_tuple_count         000373 automatic       fixed bin(17,0)          dcl 125 set ref 1018* 1033 1035* 1061* 1061 1081
transactions_needed     106(13)        based           bit(1)                   level 3 packed packed unaligned dcl 8-142 ref 1022
                                                                                  1026
tuples_retrieved                000374 automatic       fixed bin(35,0)          dcl 127 set ref 1015* 1060* 1060 1075*
type                     53            based           structure                level 2 dcl 9-22
uid                      11            based           bit(36)                  level 3 packed packed unaligned dcl 15-8 ref 1175
user_desc                11            based           bit(36)                  level 2 dcl 5-35 set ref 950 960 960 970
user_started_transaction        000104 automatic       bit(1)                   dcl 16-69 in procedure "copy_tuples" set ref 16-92*
                                                                                  16-98* 1053 19-60
user_started_transaction
                        106(22)        based           bit(1)                   level 3 in structure "dbcb" packed packed unaligned
                                                                                  dcl 8-142 in procedure "cpmd" set ref 1053*
user_transaction_id             000106 automatic       bit(36)                  dcl 16-71 set ref 16-93* 16-100*
verify                                                 builtin function         dcl 145 ref 391 430 467
work_area                              based           area                     dcl 68 set ref 518* 646 927 947 958 991 1113 1116
                                                                                  1165 1171 1177

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALL_OPS                                internal static fixed bin(17,0)          initial dcl 13-18
Directory                              internal static fixed bin(17,0)          initial dcl 15-56
EXCLUSIVE_RETRIEVAL                    internal static fixed bin(35,0)          initial dcl 14-15
EXCLUSIVE_UPDATE                       internal static fixed bin(35,0)          initial dcl 14-15
HIGHEST_MODE                           internal static fixed bin(17,0)          initial dcl 17-12
LOWEST_MODE                            internal static fixed bin(17,0)          initial dcl 17-12
Link                                   internal static fixed bin(17,0)          initial dcl 15-56
NO_OP                                  internal static fixed bin(17,0)          initial dcl 13-18
Segment                                internal static fixed bin(17,0)          initial dcl 15-56
TM_NEVER_WRITE_MODE                    internal static fixed bin(17,0)          initial dcl 17-18
TM_READ_ONLY_MODE                      internal static fixed bin(17,0)          initial dcl 17-17
TM_STATISTICAL_MODE                    internal static fixed bin(17,0)          initial dcl 17-16
TM_TEST_NEVER_WRITE_MODE               internal static fixed bin(17,0)          initial dcl 17-22
TM_TEST_NORMAL_MODE                    internal static fixed bin(17,0)          initial dcl 17-19
TM_TEST_READ_ONLY_MODE                 internal static fixed bin(17,0)          initial dcl 17-21
TM_TEST_STATISTICAL_MODE               internal static fixed bin(17,0)          initial dcl 17-20
al_ptr                                 automatic       pointer                  dcl 1-13
condition_info_ptr                     automatic       pointer                  dcl 18-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 18-30
desc_ptr                               automatic       pointer                  dcl 2-19
descriptor                             based           structure                level 1 unaligned dcl 2-6
dmh_ptr                                automatic       pointer                  dcl 10-12
error_table_$null_info_ptr             external static fixed bin(35,0)          dcl 16-63
model_relations                        based           structure                level 1 unaligned dcl 11-5
mr_ptr                                 automatic       pointer                  dcl 11-11
natts_init                             automatic       fixed bin(17,0)          dcl 7-157
nkey_attr_init                         automatic       fixed bin(17,0)          dcl 7-157
num_attr_alloc                         automatic       fixed bin(10,0)          dcl 12-29
num_relations_alloc                    automatic       fixed bin(10,0)          dcl 11-9
nvar_atts_init                         automatic       fixed bin(17,0)          dcl 7-157
rd_ptr                                 automatic       pointer                  dcl 12-31
rdbi_ptr                               automatic       pointer                  dcl 4-90
rel                                                    builtin function         dcl 145
rm_num_rels_init                       automatic       fixed bin(17,0)          dcl 6-44
rmra_ptr                               automatic       pointer                  dcl 6-43
rmri_ptr                               automatic       pointer                  dcl 7-156
status_area_ptr                        automatic       pointer                  dcl 15-47
status_entry_names                     based           char(32)                 array dcl 15-47
status_link                            based           structure                level 1 dcl 15-38
status_pathname                        based           char                     dcl 15-47

NAMES DECLARED BY EXPLICIT CONTEXT.
build_retrieve_argument_list    006174 constant        entry                    internal dcl 913 ref 768
build_store_argument_list       006564 constant        entry                    internal dcl 983 ref 772
check_args                      001257 constant        entry                    internal dcl 282 ref 268
clean_up                        010426 constant        entry                    internal dcl 1199 ref 264 279 348 366 382 396 421
                                                                                  435 460 561 570 600 610 696 740 799 808 826 838
                                                                                  857 887 907 1040 1089 1143 1152 1194
compare_attributes              005534 constant        entry                    internal dcl 844 ref 764
compare_relations               004255 constant        entry                    internal dcl 629 ref 537
copy_database_data              003326 constant        entry                    internal dcl 522 ref 277
copy_mrds_data                  001172 constant        entry                    external dcl 21
copy_relation_data              005041 constant        entry                    internal dcl 746 ref 543
copy_tuples                     006631 constant        entry                    internal dcl 1008 ref 777
cpmd                            001162 constant        entry                    external dcl 21
delete_scope                    010001 constant        entry                    internal dcl 1133 ref 783
dont_finish_the_transaction     007502 constant        label                    dcl 1090 ref 1079 1081
dont_start_the_transaction      007072 constant        label                    dcl 1055 ref 1030 1033
duplicate_paths                 003214 constant        entry                    internal dcl 477 ref 272
error                           010357 constant        entry                    internal dcl 1186 ref 272 287 294 297 313 315 317
                                                                                  324 326 341 357 359 371 387 426 465 471 515 577
                                                                                  584 617 638 16-140 1090 1093 1162 1172
exit                            001256 constant        label                    dcl 280 ref 349 367 383 397 422 436 461 562 571 601
                                                                                  611 697 741 800 809 827 839 858 888 908 1144 1153
                                                                                  1195
free_arg_lists                  007706 constant        entry                    internal dcl 1107 ref 781 1209
get_database_uid                010214 constant        entry                    internal dcl 1157 ref 485 486
get_relation_attributes         005315 constant        entry                    internal dcl 814 ref 760
initialize                      003236 constant        entry                    internal dcl 496 ref 262
match_relation_names            004361 constant        entry                    internal dcl 652 ref 648
mftxn_check_code                007236 constant        label                    dcl 19-65 ref 1045 16-127 16-133
mftxn_exit                      007456 constant        label                    dcl 19-115 ref 19-63
mstxn_any_other                 007577 constant        entry                    internal dcl 16-116 ref 1037
mstxn_cleanup                   007545 constant        entry                    internal dcl 16-102 ref 1039
mstxn_exit                      007041 constant        label                    dcl 16-140 ref 16-86 16-95 19-91 19-105
open_input_db                   003371 constant        entry                    internal dcl 549 ref 532
open_output_db                  003736 constant        entry                    internal dcl 589 ref 533
restore_significant_data        007703 constant        entry                    internal dcl 1101 ref 19-77
retrieve_tuple                  006676 constant        label                    dcl 1030 ref 1095
set_scope                       005102 constant        entry                    internal dcl 789 ref 758
should_rollback                 007674 constant        entry                    internal dcl 1097 ref 19-94

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     14024       14176   13065       14034
Length     15202   13065       152         770     737           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cpmd                                742 external procedure  is an external procedure.  
on unit on line 264                  64 on unit               
check_args                              internal procedure  shares stack frame of external procedure cpmd.  
duplicate_paths                         internal procedure  shares stack frame of external procedure cpmd.  
initialize                              internal procedure  shares stack frame of external procedure cpmd.  
copy_database_data                  640 internal procedure  enables or reverts conditions.  
on unit on line 528                  64 on unit               
open_input_db                           internal procedure  shares stack frame of internal procedure copy_database_data.  
open_output_db                          internal procedure  shares stack frame of internal procedure copy_database_data.  
compare_relations                       internal procedure  shares stack frame of internal procedure copy_database_data.  
match_relation_names                    internal procedure  shares stack frame of internal procedure copy_database_data.  
copy_relation_data                      internal procedure  shares stack frame of internal procedure copy_database_data.  
set_scope                               internal procedure  shares stack frame of internal procedure copy_database_data.  
get_relation_attributes                 internal procedure  shares stack frame of internal procedure copy_database_data.  
compare_attributes                      internal procedure  shares stack frame of internal procedure copy_database_data.  
build_retrieve_argument_list            internal procedure  shares stack frame of internal procedure copy_database_data.  
build_store_argument_list               internal procedure  shares stack frame of internal procedure copy_database_data.  
copy_tuples                         174 internal procedure  enables or reverts conditions.  
on unit on line 1037                 82 on unit               
on unit on line 1038                 76 on unit               
on unit on line 1042                 64 on unit               
mstxn_cleanup                           internal procedure  shares stack frame of on unit on line 1038.  
mstxn_any_other                         internal procedure  shares stack frame of on unit on line 1037.  
on unit on line 1089                 64 on unit               
should_rollback                         internal procedure  shares stack frame of internal procedure copy_tuples.  
restore_significant_data                internal procedure  shares stack frame of internal procedure copy_tuples.  
free_arg_lists                       66 internal procedure  is called by several nonquick procedures.  
delete_scope                            internal procedure  shares stack frame of internal procedure copy_database_data.  
get_database_uid                        internal procedure  shares stack frame of external procedure cpmd.  
error                                80 internal procedure  is called by several nonquick procedures.  
clean_up                            114 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
copy_tuples              000100 mstxn_code                  copy_tuples
                         000101 mstxn_retries               copy_tuples
                         000102 mstxn_temp_code             copy_tuples
                         000103 mstxn_transactions_needed   copy_tuples
                         000104 user_started_transaction    copy_tuples
                         000105 mstxn_txn_id                copy_tuples
                         000106 user_transaction_id         copy_tuples
                         000110 mstxn_condition_info        copy_tuples
                         000142 mftxn_code                  copy_tuples
                         000143 mftxn_temp_code             copy_tuples
cpmd                     000100 arg_length                  cpmd
                         000102 arg_ptr                     cpmd
                         000104 attr_bit_length             cpmd
                         000106 data_space_ptr_ptr          cpmd
                         000110 error_code                  cpmd
                         000111 finished                    cpmd
                         000112 first_retrieval             cpmd
                         000113 found                       cpmd
                         000114 i                           cpmd
                         000115 input_abs_path              cpmd
                         000167 input_converted_time        cpmd
                         000175 input_db_uid                cpmd
                         000176 input_dbi                   cpmd
                         000200 input_dm_ptr                cpmd
                         000202 input_dmh_ptr               cpmd
                         000204 input_path_len              cpmd
                         000206 input_path_ptr              cpmd
                         000210 input_rd_ptr                cpmd
                         000212 input_rel_missing           cpmd
                         000213 j                           cpmd
                         000214 k                           cpmd
                         000215 l                           cpmd
                         000216 m                           cpmd
                         000217 nargs                       cpmd
                         000220 n                           cpmd
                         000221 n_rels_to_be_copied         cpmd
                         000222 op_num                      cpmd
                         000223 output_abs_path             cpmd
                         000275 output_converted_time       cpmd
                         000303 output_db_uid               cpmd
                         000304 output_dbcb_ptr             cpmd
                         000306 output_dbi                  cpmd
                         000310 output_dm_ptr               cpmd
                         000312 output_dmh_ptr              cpmd
                         000314 output_path_len             cpmd
                         000316 output_path_ptr             cpmd
                         000320 output_rd_ptr               cpmd
                         000322 rel_arg_length              cpmd
                         000324 rel_arg_ptr                 cpmd
                         000326 retrieve_al_ptr             cpmd
                         000330 retrieve_desc_index         cpmd
                         000331 retrieve_select_expr        cpmd
                         000350 rtbc_ptr                    cpmd
                         000352 single_relation             cpmd
                         000353 specified_input_prevents    cpmd
                         000354 specified_output_prevents   cpmd
                         000356 store_al_ptr                cpmd
                         000360 store_select_expr           cpmd
                         000370 temp_seg_ptr                cpmd
                         000372 transaction_group_size      cpmd
                         000373 transaction_tuple_count     cpmd
                         000374 tuples_retrieved            cpmd
                         000404 num_ptrs                    cpmd
                         000405 num_dims                    cpmd
                         000406 rai_ptr                     cpmd
                         000410 rdi_ptr                     cpmd
                         000412 dbcb_ptr                    cpmd
                         000414 mrds_path_info_ptr          cpmd
                         000416 status_ptr                  cpmd
                         000436 equal                       duplicate_paths
                         000454 dir                         get_database_uid
                         000526 entry                       get_database_uid
error                    000100 saved_code                  error

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this
call_int_other_desc call_int_other      return_mac          tra_ext_1           enable_op           shorten_stack
ext_entry           int_entry           int_entry_desc      any_to_any_truncate_op_alloc_           op_freen_
op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      continue_to_signal_           cu_$arg_count                 cu_$arg_ptr
cu_$generate_call             date_time_                    expand_pathname_              find_condition_info_
get_temp_segment_             hcs_$status_long              ioa_                          mrds_dm_close
mrds_dm_get_attributes        mrds_dm_get_header            mrds_dm_open                  mrds_dsl_close
mrds_dsl_get_version$get_path_info                          mrds_dsl_open                 mrds_dsl_retrieve
mrds_dsl_set_scope$dl_scope   mrds_dsl_set_scope$set_scope  mrds_dsl_store                mu_data_class$varying
mu_data_length                mu_database_index$get_resultant_model_pointer               release_temp_segment_
transaction_manager_$abandon_txn                            transaction_manager_$abort_txn
transaction_manager_$begin_txn                              transaction_manager_$commit_txn
transaction_manager_$get_current_txn_id                     transaction_manager_$handle_conditions
transaction_manager_$rollback_txn

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bj_journal_full     dm_error_$lock_deadlock       dm_error_$no_current_transaction
error_table_$bad_arg          error_table_$badcall          error_table_$badopt           error_table_$noarg
error_table_$sameseg          mrds_error_$no_database       mrds_error_$no_model_submodel mrds_error_$rst_wrong_command
mrds_error_$tuple_not_found   mrds_error_$undef_attr        mrds_error_$unknown_relation_name
mrds_error_$version_not_supported                           sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 2   20 001153    3   65 001154    5   51 001156        21 001161       262 001200       264 001201       268 001223
    272 001224       277 001246       279 001252       280 001256       282 001257       286 001260       287 001267
    293 001312       294 001331       297 001355       302 001402       304 001435       306 001447       308 001453
    310 001455       313 001462       315 001504       317 001530       323 001557       324 001576       326 001622
    330 001647       332 001702       334 001714       336 001720       338 001722       341 001727       344 001751
    346 001755       348 002005       349 002011       353 002012       356 002021       357 002036       359 002055
    361 002103       363 002114       365 002117       366 002153       367 002157       369 002160       370 002161
    371 002176       373 002214       374 002216       375 002220       376 002222       377 002223       379 002227
    381 002232       382 002266       383 002272       385 002273       386 002274       387 002311       389 002327
    390 002330       391 002336       392 002350       393 002351       396 002405       397 002411       399 002412
    402 002425       405 002453       408 002467       411 002503       415 002517       416 002520       418 002524
    420 002527       421 002563       422 002567       424 002570       425 002571       426 002606       428 002624
    429 002625       430 002633       431 002645       432 002646       435 002702       436 002706       438 002707
    441 002722       444 002750       447 002764       450 003000       454 003014       455 003015       457 003021
    459 003024       460 003060       461 003064       463 003065       464 003066       465 003103       467 003121
    469 003155       470 003170       471 003171       472 003211       475 003213       477 003214       484 003216
    485 003220       486 003222       487 003224       490 003230       496 003236       502 003237       506 003252
    508 003255       510 003256       514 003261       515 003302       518 003320       520 003324       522 003325
    528 003333       532 003350       533 003351       537 003352       543 003353       545 003354       547 003370
    549 003371       555 003372       556 003416       558 003421       559 003422       561 003467       562 003474
    564 003477       565 003514       567 003517       568 003521       570 003565       571 003572       576 003575
    577 003612       579 003632       580 003651       584 003707       587 003735       589 003736       594 003737
    595 003763       597 003766       598 003767       600 004034       601 004041       604 004044       605 004061
    607 004064       608 004066       610 004132       611 004137       616 004142       617 004157       620 004177
    622 004216       627 004254       629 004255       633 004256       634 004270       638 004302       643 004335
    645 004343       646 004347       648 004357       650 004360       652 004361       656 004362       658 004365
    659 004366       660 004402       662 004425       663 004427       665 004431       667 004433       669 004435
    670 004440       671 004442       674 004443       675 004444       676 004460       678 004503       679 004505
    680 004510       682 004514       683 004516       685 004520       686 004523       689 004524       691 004526
    696 004571       697 004576       699 004601       703 004602       705 004616       707 004617       709 004636
    712 004675       713 004700       714 004706       715 004710       720 004724       722 004725       724 004734
    726 004737       728 004741       731 004743       740 005030       741 005035       744 005040       746 005041
    753 005042       758 005056       760 005057       764 005060       768 005061       772 005062       777 005063
    781 005070       783 005075       785 005076       787 005101       789 005102       794 005103       796 005140
    798 005143       799 005200       800 005205       803 005210       805 005244       807 005247       808 005304
    809 005311       812 005314       814 005315       819 005316       821 005341       823 005344       826 005415
    827 005422       830 005425       833 005447       835 005452       838 005523       839 005530       842 005533
    844 005534       849 005535       852 005546       853 005551       857 005622       858 005627       864 005632
    865 005644       866 005645       867 005647       871 005662       875 005701       876 005703       881 005724
    887 006025       888 006032       890 006035       892 006036       894 006044       898 006047       900 006053
    907 006161       908 006166       910 006171       911 006173       913 006174       923 006175       925 006201
    927 006203       929 006214       931 006216       933 006221       935 006224       937 006226       939 006233
    941 006254       943 006303       945 006307       947 006312       949 006322       950 006334       958 006402
    960 006421       968 006502       970 006510       977 006552       979 006554       980 006560       981 006563
    983 006564       991 006565       993 006576       998 006606      1000 006610      1002 006613      1004 006620
   1006 006627      1008 006630      1015 006636      1016 006641      1017 006643      1018 006644      1019 006646
   1021 006647      1022 006652      1025 006660      1026 006670      1030 006676      1033 006701      1035 006703
   1036 006704      1037 006705      1038 006723      1039 006737      1040 006740      1041 006745      1042 006746
   1043 006762      1044 006765      1045 006767   16   83 006772   16   86 006773   16   88 006775   16   89 006776
16   90 007007   16   92 007013   16   93 007015   16   94 007017   16   95 007020   16   98 007021   16   99 007022
16  100 007037   16  140 007041      1053 007063      1055 007072      1057 007107      1060 007115      1061 007121
   1062 007122      1063 007137      1065 007144      1067 007150      1068 007151      1069 007154      1072 007161
   1074 007165      1075 007166      1079 007216      1081 007221      1083 007225   19   60 007227   19   62 007234
19   63 007235   19   65 007236   19   68 007240   19   69 007251   19   71 007253   19   72 007264   19   75 007277
19   77 007300   19   78 007301   19   81 007310   19   82 007311   19   83 007324   19   85 007326   19   86 007337
19   88 007352   19   90 007353   19   91 007354   19   93 007355   19   94 007356   19   96 007363   19   97 007377
19   99 007401   19  100 007412   19  102 007425   19  104 007426   19  105 007427   19  107 007430   19  109 007431
19  110 007442   19  114 007455   19  115 007456      1088 007457      1089 007460      1090 007502      1093 007522
   1095 007541      1105 007544   16  102 007545   16  107 007546   16  109 007551   16  110 007562   16  114 007576
16  116 007577   16  121 007600   16  123 007603   16  124 007622   16  126 007630   16  127 007633   16  129 007636
16  132 007650   16  133 007653   16  135 007656   16  136 007663   16  137 007664   16  138 007673      1097 007674
   1099 007676      1101 007703      1103 007704      1107 007705      1113 007713      1116 007725      1119 007737
   1121 007744      1122 007754      1124 007771      1125 007774      1131 010000      1133 010001      1138 010002
   1140 010037      1142 010042      1143 010077      1144 010104      1147 010107      1149 010143      1151 010146
   1152 010203      1153 010210      1155 010213      1157 010214      1161 010216      1162 010242      1165 010261
   1167 010266      1169 010324      1171 010326      1172 010330      1175 010345      1177 010353      1184 010355
   1186 010356      1192 010372      1193 010375      1194 010415      1195 010422      1199 010425      1203 010433
   1206 010442      1209 010453      1210 010460      1212 010464      1214 010466      1215 010502      1218 010552
   1221 010554      1223 010556      1224 010572      1227 010642      1230 010644      1232 010650      1233 010661
   1235 010710      1238 010713      1240 010717      1241 010730      1243 010757      1246 010762      1248 010766
   1249 011007      1251 011027      1254 011032


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
