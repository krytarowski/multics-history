	COMPILATION LISTING OF SEGMENT cm_opening_info
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  0953.4 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* DESCRIPTION:
        9*
       10*         This   routine   handles   all  manipulation  of  opening  info  for
       11*     collections.
       12*
       13*     $get gets a pointer to a cm_info structure associated with  the  supplied
       14*     p_file_oid and p_collection_id.  If no cm_info exists yet, it creates one
       15*     by  extracting  information out of the collection header and stores it in
       16*     the opening info area (dm_data_$area_ptr). If cm_info exists and the
       17*     current transaction is not the same as that identified by 
       18*     cm_info.current_txn_id, the information is copied from the collection
       19*     header to the location where cm_info is stored.
       20*
       21*     $full_get is the same as $get, except it also gets the storage record
       22*     for the collection.  The reason for the two entries is because most
       23*     operations do not need the information in the storage record, and
       24*     shouldn't pay the expense and possible concurrency problems of getting
       25*     the storage record.
       26*
       27*     $get_storage_record - given a pointer to a cm_info structure, sets
       28*     cm_info.storage_record_ptr to the location of the collection's storage
       29*     record.  If cm_info.storage_record_ptr = null or cm_info.current_txn_id
       30*     ^= the current transaciton, the storage record is retrieved from the
       31*     collection header.
       32*
       33*     These entries call cm_get_element, depending on it not in turn calling
       34*     one of these entries again.  If cm_get_element is ever changed to use
       35*     opening info, these entries will have to be changed to get elements
       36*     in another way.
       37*     
       38*     $opening_table_ptr - is a function which returns the value of the static
       39*     variable static_opening_table_ptr.
       40*     
       41*     $degug_(on off) - turn debugging features (on off) for this process.
       42**/
       43 
       44 /* HISTORY:
       45*
       46*Written by Matthew Pierret, 11/01/82.
       47*Modified:
       48*11/22/82 by Lindsey Spratt:  Changed to initialize collection_header_ptr to
       49*	  null.
       50*12/10/82 by Lindsey Spratt:  Changed to refresh the cm_info if the txn has
       51*	  changed.  Also, fixed to not free the cm_info (in FINISH) if not
       52*	  allocated by this module.
       53*01/25/83 by Matthew Pierret: Added $get_storage_record entry. Changed to
       54*            convert certain error codes to dm_error_$collection_not_found
       55*            when error is encountered attempting to get the collection_header.
       56*            It is assumed that the caller supplied an incorrect collection_id.
       57*            Changed to report an internal inconsistency if the same errors
       58*            are encountered attempting to get the storage record, as this 
       59*            indicates that the collection_header.storage_record_element_id
       60*            is invalid.
       61*            Changed to use cm_info version 2.
       62*            Changed to use cm_get_element$bypass_info to prevent looping.
       63*03/24/83 by Matthew Pierret: Added $opening_table_ptr entry.
       64*04/08/83 by Matthew Pierret: Chnaged to set cm_info.storage_record_ptr to null
       65*            after refreshing. Changed to not use dm_data_$(area_ptr
       66*            current_txn_id), but to call (get_dm_free_area_ 
       67*            tm_$get_current_txn_id) instead.
       68*04/08/83 by Lindsey L. Spratt:  Fixed to initialize the storage_record_ptr to
       69*            null when refreshing the opening.
       70*04/12/83 by Lindsey L. Spratt:  Changed to only get the storage_record when
       71*            the get_storage_record flag is on and the
       72*            cm_info.storage_record_ptr is null.  Added the debug displays and
       73*	  the debug_on/off entries.
       74*02/08/84 by Matthew Pierret:  Changed to new calling sequence of 
       75*            cm_get_element$bypass_info, which now includes a position arg.
       76*10/02/84 by Matthew Pierret:  Changed to use cm_get_element instead of
       77*            cm_get_element$bypass_info (now obsolete).  Added ERROR_RETURN 
       78*            procedure. Changed CHECK_VERSION to follow variable name
       79*            prefixing convention.  Made dm_area_ptr a static variable,
       80*            initialized to null, so that get_dm_free_area_ need only be called
       81*            once per process.  Changed the get_info and get_storage_record
       82*            flags to both be set for each of the entries which use them.
       83**/
       84 
       85 /* format: style2,ind3 */
       86 
       87 cm_opening_info:
       88    proc ();
       89 
       90       return;
       91 
       92 
       93 /* START OF DECLARATIONS */
       94 /* Parameter */
       95 
       96       dcl	    p_file_oid	       bit (36) aligned parameter;
       97       dcl	    p_collection_id	       bit (36) aligned parameter;
       98       dcl	    p_cm_info_ptr	       ptr parameter;
       99       dcl	    p_code	       fixed bin (35) parameter;
      100 
      101 /* Automatic */
      102 
      103       dcl	    (get_info, get_storage_record)
      104 			       bit (1) aligned;
      105       dcl	    (alloc_new_cm_info, refresh_cm_info, init_table)
      106 			       bit (1) aligned init ("0"b);
      107       dcl	    code		       fixed bin (35);
      108       dcl	    current_transaction_id bit (36) aligned init ("0"b);
      109 
      110 /* Based */
      111 
      112       dcl	    work_area	       area (sys_info$max_seg_size) based (dm_area_ptr);
      113 
      114 /* Builtin */
      115 
      116       dcl	    (addr, max, null, size)
      117 			       builtin;
      118 
      119 /* Constant */
      120 
      121       dcl	    DONT_POSITION	       init (0) fixed bin internal static options (constant);
      122       dcl	    BITS_PER_WORD	       init (36) fixed bin internal static options (constant);
      123       dcl	    NUMBER_OF_BUCKETS      init (20) fixed bin internal static options (constant);
      124       dcl	    myname	       init ("cm_opening_info") char (32) varying internal static options (constant);
      125 
      126 /* Entry */
      127 
      128       dcl	    ioa_		       entry () options (variable);
      129       dcl	    get_dm_free_area_      entry () returns (ptr);
      130       dcl	    opening_manager_$get_opening
      131 			       entry (ptr, bit (72) aligned, ptr, fixed bin (35));
      132       dcl	    opening_manager_$put_opening
      133 			       entry (ptr, bit (72) aligned, ptr, fixed bin (35));
      134       dcl	    opening_manager_$init  entry (fixed bin, ptr, fixed bin (35));
      135       dcl	    sub_err_	       entry () options (variable);
      136       dcl	    transaction_manager_$get_current_txn_id
      137 			       entry (bit (36) aligned, fixed bin (35));
      138 
      139 /* External */
      140 
      141       dcl	    (
      142 	    dm_error_$ci_not_in_collection,
      143 	    dm_error_$collection_not_found,
      144 	    dm_error_$programming_error,
      145 	    dm_error_$no_element,
      146 	    dm_error_$no_current_transaction
      147 	    )		       fixed bin (35) ext;
      148       dcl	    error_table_$unimplemented_version
      149 			       fixed bin (35) ext;
      150       dcl	    sys_info$max_seg_size  fixed bin (35) ext;
      151 
      152 /* Static */
      153 
      154       dcl	    internal_debug	       bit (1) init ("0"b) aligned internal static;
      155       dcl	    static_opening_table_ptr
      156 			       init (null) ptr internal static;
      157       dcl	    dm_area_ptr	       init (null) ptr internal static;
      158 
      159 /* END OF DECLARATIONS */
      160 
      161 opening_table_ptr:
      162    entry () returns (ptr);
      163 
      164       return (static_opening_table_ptr);
      165 
      166 debug_on:
      167    entry ();
      168       internal_debug = "1"b;
      169       return;
      170 debug_off:
      171    entry ();
      172       internal_debug = "0"b;
      173       return;
      174 
      175 get_storage_record:
      176    entry (p_cm_info_ptr, p_code);
      177 
      178       get_info = "0"b;
      179       get_storage_record = "1"b;
      180       cm_info_ptr = p_cm_info_ptr;
      181       call CHECK_VERSION (cm_info.version, CM_INFO_VERSION_2, "cm_info");
      182       call CHECK_VERSION (cm_info.header_ptr -> collection_header.version, COLLECTION_HEADER_VERSION_2,
      183 	 "collection_header");
      184 
      185       goto JOIN;
      186 
      187 full_get:
      188    entry (p_file_oid, p_collection_id, p_cm_info_ptr, p_code);
      189 
      190       get_info = "1"b;
      191       get_storage_record = "1"b;
      192       collection_header_ptr, cm_info_ptr = null;
      193       go to JOIN;
      194 
      195 get:
      196    entry (p_file_oid, p_collection_id, p_cm_info_ptr, p_code);
      197 
      198       get_info = "1"b;
      199       get_storage_record = "0"b;
      200       collection_header_ptr, cm_info_ptr = null;
      201       go to JOIN;
      202 
      203 JOIN:
      204       p_code, code = 0;
      205       call transaction_manager_$get_current_txn_id (current_transaction_id, code);
      206       if code ^= 0
      207       then if code ^= dm_error_$no_current_transaction
      208 	 then call ERROR_RETURN (code);
      209 	 else code = 0;
      210 
      211       if dm_area_ptr = null
      212       then dm_area_ptr = get_dm_free_area_ ();
      213 
      214       if get_info
      215       then
      216 GET_HEADER:
      217          do;
      218 
      219 	  if static_opening_table_ptr = null
      220 	  then
      221 	     do;
      222 	        alloc_new_cm_info, refresh_cm_info, init_table = "1"b;
      223 	        call opening_manager_$init (NUMBER_OF_BUCKETS, static_opening_table_ptr, code);
      224 	        if code ^= 0
      225 	        then call ERROR_RETURN (code);
      226 	     end;
      227 	  else
      228 	     do;
      229 	        call opening_manager_$get_opening (static_opening_table_ptr, (p_file_oid || p_collection_id),
      230 		   cm_info_ptr, code);
      231 	        if code ^= 0
      232 	        then
      233 		 do;
      234 		    code = 0;
      235 		    refresh_cm_info, alloc_new_cm_info = "1"b;
      236 		 end;
      237 	        else
      238 		 do;
      239 		    call CHECK_VERSION (cm_info.version, CM_INFO_VERSION_2, "cm_info");
      240 		    if cm_info.current_txn_id ^= current_transaction_id
      241 		    then refresh_cm_info = "1"b;
      242 		 end;
      243 	     end;
      244 
      245 	  if refresh_cm_info
      246 	  then
      247 	     do;
      248 
      249 /*
      250*     The opening info could not be found, so create a cm_info structure
      251*     and set up an entry in the opening_info_table for it.
      252**/
      253 	        if internal_debug
      254 	        then
      255 		 do;
      256 		    call ioa_ ("Getting opening info for collection ^3bo in file ^3bo.", p_collection_id, p_file_oid);
      257 		    if init_table
      258 		    then call ioa_ ("^5xInitialized the opening table.");
      259 		    if alloc_new_cm_info
      260 		    then call ioa_ ("^5xAllocating a new opening.");
      261 		    else call ioa_ (
      262 			    "^5xRefreshing the opening because it was last valid for txn ^3bo,^/^10xand the current txn is ^3bo."
      263 			    , cm_info.current_txn_id, current_transaction_id);
      264 		 end;
      265 
      266 	        if alloc_new_cm_info
      267 	        then
      268 		 do;
      269 		    alloc cm_info in (work_area);
      270 		    cm_info.version = CM_INFO_VERSION_2;
      271 		 end;
      272 
      273 	        call cm_get_element (p_file_oid, HEADER_COLLECTION_ID, p_collection_id, DONT_POSITION,
      274 		   cm_info.header_ptr, size (collection_header) * BITS_PER_WORD, dm_area_ptr, ("1"b),
      275 		   cm_info.header_ptr, (0), code);
      276 	        if code ^= 0
      277 	        then
      278 		 do;
      279 		    if code = dm_error_$ci_not_in_collection | code = dm_error_$no_element
      280 		    then call ERROR_RETURN (dm_error_$collection_not_found);
      281 		    else call ERROR_RETURN (code);
      282 		 end;
      283 	        collection_header_ptr = cm_info.header_ptr;
      284 	        call CHECK_VERSION (collection_header.version, COLLECTION_HEADER_VERSION_2, "collection_header");
      285 
      286 
      287 	        cm_info.current_txn_id = current_transaction_id;
      288 	        cm_info.file_oid = p_file_oid;
      289 	        cm_info.collection_id = p_collection_id;
      290 	        cm_info.storage_record_ptr = null;
      291 
      292 
      293 	        if alloc_new_cm_info
      294 	        then
      295 		 do;
      296 		    call opening_manager_$put_opening (static_opening_table_ptr, (p_file_oid || p_collection_id),
      297 		         cm_info_ptr, code);
      298 		    if code ^= 0
      299 		    then call ERROR_RETURN (code);
      300 		 end;
      301 	     end;
      302          end GET_HEADER;
      303 
      304       if get_storage_record
      305       then if cm_info.storage_record_ptr = null
      306 	 then
      307 	    do;
      308 	       if internal_debug
      309 	       then call ioa_ ("^5xGetting the storage record for collection ^3bo of file ^3bo.", cm_info.collection_id,
      310 		       cm_info.file_oid);
      311 	       call cm_get_element (cm_info.file_oid, HEADER_COLLECTION_ID,
      312 		  cm_info.header_ptr -> collection_header.storage_record_element_id, DONT_POSITION,
      313 		  cm_info.storage_record_buffer_ptr,
      314 		  max (size (blocked_storage_record), size (unblocked_storage_record)) * BITS_PER_WORD, dm_area_ptr,
      315 		  ("1"b), cm_info.storage_record_ptr, (0), code);
      316 	       if code ^= 0
      317 	       then if code ^= dm_error_$ci_not_in_collection & code ^= dm_error_$no_element
      318 		  then call ERROR_RETURN (code);
      319 		  else call sub_err_ (dm_error_$programming_error, myname, ACTION_CANT_RESTART, null, 0,
      320 			  "^/^a ^3bo ^a^/^a^/control interval ^d, slot ^d. ^[That control interval is not part of the ^/header_collection.^;That slot contains no data.^]"
      321 			  , "The storage record for collection", cm_info.collection_id,
      322 			  "is not at the location recorded",
      323 			  "in the collection's header.  The header claims the storage record is at",
      324 			  addr (cm_info.header_ptr -> collection_header.storage_record_element_id)
      325 			  -> element_id.control_interval_id,
      326 			  addr (cm_info.header_ptr -> collection_header.storage_record_element_id)
      327 			  -> element_id.index);
      328 
      329 
      330 	       cm_info.current_txn_id = current_transaction_id;
      331 	       cm_info.storage_record_buffer_ptr = cm_info.storage_record_ptr;
      332 	    end;
      333 
      334       p_cm_info_ptr = cm_info_ptr;
      335 MAIN_RETURN:
      336       return;
      337 
      338 
      339 ERROR_RETURN:
      340    proc (er_p_code);
      341 
      342       dcl	    er_p_code	       fixed bin (35);
      343 
      344       p_code = er_p_code;
      345       call FINISH;
      346       go to MAIN_RETURN;
      347 
      348    end ERROR_RETURN;
      349 
      350 FINISH:
      351    proc ();					/*
      352*     Free anything that this instance of cm_opening_info allocated.
      353*     The storage record need not be freed, as it can not have been 
      354*     allocated if this routine was called.
      355**/
      356 
      357       if alloc_new_cm_info
      358       then
      359          do;
      360 	  if collection_header_ptr ^= null
      361 	  then free collection_header in (work_area);
      362 
      363 	  if cm_info_ptr ^= null & p_cm_info_ptr ^= cm_info_ptr
      364 	  then free cm_info in (work_area);
      365          end;
      366       return;
      367 
      368    end FINISH;
      369 
      370 CHECK_VERSION:
      371    proc (cv_p_received_version, cv_p_expected_version, cv_p_structure_name);
      372       dcl	    cv_p_received_version  char (8) aligned;
      373       dcl	    cv_p_expected_version  char (8) aligned;
      374       dcl	    cv_p_structure_name    char (*);
      375 
      376       if cv_p_received_version ^= cv_p_expected_version
      377       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      378 	      "^/Expected version ^a of the ^a structure.
      379 Received version ^a instead.", cv_p_expected_version, cv_p_structure_name, cv_p_received_version);
      380 
      381    end CHECK_VERSION;
      382 
  1     1 /* BEGIN INCLUDE FILE - dm_cm_info.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*        The cm_info structure is used to hold per-process opening information
  1     5*   about a collection.  It is generally allocated in the process' DM free
  1     6*   area, as returned by the function get_dm_free_area_.  The opening_manager_
  1     7*   is used to provide access the cm_info structure, keeping it in a hash
  1     8*   table keyed on file opening id and collection id combined.
  1     9*        Currently cm_info is never freed until the process terminates.  Each
  1    10*   time a new transaction is started, detected when the current transaction
  1    11*   id of a process differs from cm_info.current_transaction_id, the information
  1    12*   in cm_info is refreshed.  Storage record information is only refreshed on
  1    13*   demand, as most modules do not need the information in the storage record.
  1    14*   Instead, cm_info.storage_record_ptr is set to null (), but 
  1    15*   cm_info.storage_record_buffer_ptr remains set to the previous value of
  1    16*   cm_info.storage_record_ptr.  When a refreshed copy of the storage record is
  1    17*   requested, it is placed at the location pointed to by
  1    18*   cm_info.storage_record_buffer_ptr, saving the expense of re-allocation.
  1    19**/
  1    20 
  1    21 /* HISTORY:
  1    22*Written by Matthew Pierret, 10/27/82. 
  1    23*Modified:
  1    24*01/25/83 by Matthew Pierret: Changed to version 2.  Added 
  1    25*            storage_record_buffer_ptr. This points to the storage_record.
  1    26*            When cm_info is refreshed, storage_record_ptr is set to null,
  1    27*            but storage_record_buffer_ptr continues to point at where the
  1    28*            storage_record was. When the storge_record is again requested,
  1    29*            it is put back in the same place rather than allocating a new
  1    30*            storage_record.
  1    31*09/24/84 by Matthew Pierret:  Re-wrote DESCRIPTION section. Removed the
  1    32*            init clause from the version component.
  1    33**/
  1    34 
  1    35 /* format: style2,ind3,ll79 */
  1    36 
  1    37      dcl	   1 cm_info	      aligned based (cm_info_ptr),
  1    38 	     2 version	      char (8),
  1    39 	     2 current_txn_id     bit (36) aligned init ("0"b),
  1    40 	     2 file_oid	      bit (36) aligned init ("0"b),
  1    41 	     2 collection_id      bit (36) aligned init ("0"b),
  1    42 	     2 header_ptr	      ptr init (null),
  1    43 	     2 storage_record_ptr ptr init (null),
  1    44 	     2 storage_record_buffer_ptr
  1    45 			      ptr init (null);
  1    46 
  1    47      dcl	   cm_info_ptr	      ptr init (null);
  1    48      dcl	   CM_INFO_VERSION_2      init ("cm_info2") char (8) aligned
  1    49 			      internal static options (constant);
  1    50 
  1    51 /* END INCLUDE FILE - dm_cm_info.incl.pl1 */
      383 
      384 
  2     1 /* BEGIN INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*        Contains the identifier of the Header Collection for a file
  2     6*   managed by the collection_manager_.  This is used by callers of 
  2     7*   collection_manager who wish to maintain their own file header or who wish
  2     8*   to maintain their own collection header information beyond the caller
  2     9*   collection header provided by colleciton_manager_$(get put)_header.
  2    10**/
  2    11 
  2    12 /* HISTORY:
  2    13*Written by Matthew Pierret, 09/24/84.
  2    14*Modified:
  2    15**/
  2    16 
  2    17 /* format: style2,ind3,ll79 */
  2    18 
  2    19      dcl	   HEADER_COLLECTION_ID   init ("000000000001"b3) bit (36)
  2    20 			      aligned internal static options (constant);
  2    21 
  2    22 /* END INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
      385 
      386 
  3     1 /* BEGIN INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*       Associated with each collection is the following collection_header
  3     5*   structure stored as an element in the Header Collection of the file.
  3     6*   The identifier of this element is also the idenfifier of the collection.
  3     7*   Even the Header Collection has a collection_header stored in the Header
  3     8*   Collection itself in the element identified by the constant
  3     9*   HEADER_COLLECTION_HEADER_ELEMENT_ID declared in dm_cm_hdr_col_ids.incl.pl1.
  3    10*   The information in collection_header is expected to be stable information.
  3    11*   The structure elements are described as follows:
  3    12*   
  3    13*   version is a character string version equal to COLLECTION_HEADER_VERSION_2.
  3    14*   
  3    15*   flags.fixed_size_elements indicates, if on that all elements in the
  3    16*   collection are of a fixed length.
  3    17*   
  3    18*   flags.thread_elements indicates that elements in a collection are to be
  3    19*   threaded in a linked list.  This is currrently unupported.
  3    20*   
  3    21*   flags.thread_control_intervals indicates, if on, that control intervals in
  3    22*   a collection are to be threaded in a linked list.  This is only useful if
  3    23*   the control interval storage method is blocked.
  3    24*   
  3    25*   flags.must_be_zero1 is reserved for future use and must be "0"b.
  3    26*   
  3    27*   control_interval_storage_method is the method of storage management of
  3    28*   control intervals for this collection, either
  3    29*   BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD (not yet supported) or
  3    30*   UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD, declared in
  3    31*   dm_cism_info.incl.pl1.
  3    32*   
  3    33*   element_storage_method is the method of storage management of elements in
  3    34*   this collection, either BASIC_ELEMENT_STORAGE_METHOD or
  3    35*   ORDERED_ELEMENT_STORAGE_METHOD, declared in dm_esm_info.incl.pl1.
  3    36*   
  3    37*   maximum_element_size is the maximum size of an element in bits in this
  3    38*   collection.
  3    39*   
  3    40*   header_record_element_id is the identifier of an element containing a
  3    41*   caller-defined header for this collection.  If equal to "0"b, no
  3    42*   caller-defined header yet exists.  The put_header collection_manager_
  3    43*   operation stores such a header.
  3    44*   
  3    45*   storage_record_element_id is the identifier of the element containing the
  3    46*   storage_record for this collection.  The storage_record contains
  3    47*   information expected to be dynamic, such as the identifier of the last
  3    48*   control interval of the collection.  Its format is also dependent upon the
  3    49*   storage methods in effect for this collection.  storage_record structures
  3    50*   are declared in dm_cm_storage_record.incl.pl1.
  3    51*
  3    52**/
  3    53 
  3    54 /* HISTORY:
  3    55*Written by Matthew Pierret, 04/01/82.
  3    56*Modified:
  3    57*07/01/82 by Matthew Pierret: Changed to version A, added storage_record_area.
  3    58*10/29/82 by Matthew Pierret: Changed to version 2 ("col_hdr2"), separated
  3    59*            storage_record_area out, leaving storage_record_element_id behind.
  3    60*09/18/84 by Matthew Pierret: Added DESCRIPTION section.
  3    61**/
  3    62 
  3    63 /* format: style2,ind3,ll79 */
  3    64 
  3    65      dcl	   1 collection_header    aligned based (collection_header_ptr),
  3    66 	     2 version	      char (8),
  3    67 	     2 flags	      unaligned,
  3    68 	       3 fixed_size_elements
  3    69 			      bit (1),
  3    70 	       3 thread_elements  bit (1),
  3    71 	       3 thread_control_intervals
  3    72 			      bit (1),
  3    73 	       3 must_be_zero1    bit (15),
  3    74 	     2 control_interval_storage_method
  3    75 			      fixed bin (17) unal,
  3    76 	     2 element_storage_method
  3    77 			      fixed bin (17),
  3    78 	     2 maximum_element_size
  3    79 			      fixed bin (35),
  3    80 	     2 header_record_element_id
  3    81 			      bit (36) aligned,
  3    82 	     2 storage_record_element_id
  3    83 			      bit (36) aligned;
  3    84 
  3    85      dcl	   collection_header_ptr  ptr;
  3    86      dcl	   COLLECTION_HEADER_VERSION_2
  3    87 			      init ("col_hdr2") char (8) aligned
  3    88 			      int static options (constant);
  3    89 
  3    90 /* END INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
      387 
      388 
  4     1 /* BEGIN INCLUDE FILE dm_cm_storage_record.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*        A storage record is an extension to the collection_header structure.
  4     6*   It is expected to be more volatile than collection_header and has a 
  4     7*   different format depending on the control interval storage method in use
  4     8*   for the collection.  A storage record is stored as an element in the 
  4     9*   file's Header Collection with the element identifier 
  4    10*   collection_header.storage_record_element_id.
  4    11*   
  4    12*        The unblocked_storage_record contains the control interval numbers
  4    13*   of the first and last control intervals of a collection.  Unblocked
  4    14*   control intervals are chained together, so all control intervals can be 
  4    15*   found by starting at one end and following the chain forward or backward.
  4    16*   
  4    17*        The blocked_storage_record is not yet used, as the Blocked Control
  4    18*   Interval Storage Method is not yet implemented.
  4    19**/
  4    20 
  4    21 /* HISTORY:
  4    22*Written by Matthew Pierret, 09/24/84.
  4    23*Modified:
  4    24**/
  4    25 
  4    26 /* format: style2,ind3,ll79 */
  4    27 
  4    28      dcl	   1 unblocked_storage_record
  4    29 			      aligned
  4    30 			      based (unblocked_storage_record_ptr),
  4    31 	     2 first_control_interval
  4    32 			      fixed bin (24) uns,
  4    33 	     2 last_control_interval
  4    34 			      fixed bin (24) uns;
  4    35 
  4    36      dcl	   1 blocked_storage_record
  4    37 			      aligned based (blocked_storage_record_ptr),
  4    38 	     2 last_control_interval
  4    39 			      fixed bin (24) uns,
  4    40 	     2 number_of_blocks   fixed bin (17) unal,
  4    41 	     2 number_of_control_intervals_per_block
  4    42 			      fixed bin (17) unal,
  4    43 	     2 allocation_map_element_id
  4    44 			      bit (36) aligned;
  4    45 
  4    46      dcl	   unblocked_storage_record_ptr
  4    47 			      ptr init (null ());
  4    48      dcl	   blocked_storage_record_ptr
  4    49 			      ptr init (null ());
  4    50 
  4    51 /* END INCLUDE FILE dm_cm_storage_record.incl.pl1 */
      389 
      390 
  5     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*        Contains the declaration of an element identifier.  Element
  5     6*   identifiers consist of two parts, the id (number) of the control interval
  5     7*   in which the element resides, and the index into the slot table of
  5     8*   the element in the control interval.  The declaration of the element_id 
  5     9*   structure reflects this division of the element identifier.  The structure 
  5    10*   is based on the automatic bit string element_id_string because programs
  5    11*   generally pass bit strings (element_id_string) to each other, then 
  5    12*   interpret the bit string by overlaying the element_id structure ony if
  5    13*   it is necessary to access the parts of the id.  Basing element_id on
  5    14*   addr(element_id_string) instead of on a pointer removes the necessity
  5    15*   for always setting that pointer explicitly and guarantees that changes
  5    16*   made to the string or structure do not get inconsistent.
  5    17*
  5    18*   Changes made to element_id must also be made to datum_id, declared in 
  5    19*   dm_cm_datum.incl.pl1.
  5    20**/
  5    21 
  5    22 /* HISTORY:
  5    23*Written by Matthew Pierret, 04/01/82.
  5    24*Modified:
  5    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  5    26**/
  5    27 
  5    28 /* format: style2,ind3,ll79 */
  5    29 
  5    30      dcl	   element_id_string      bit (36) aligned;
  5    31 
  5    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  5    33 	     2 control_interval_id
  5    34 			      fixed bin (24) unal unsigned,
  5    35 	     2 index	      fixed bin (12) unal unsigned;
  5    36 
  5    37 
  5    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      391 
      392 
  6     1 /* BEGIN INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*
  6     5*   Contains entry declarations of internally available collection_manager_
  6     6*   entries.  Entries which are only available via the collection_manager_
  6     7*   transfer vector are not included here, but are declared instead in 
  6     8*   dm_collmgr_entry_dcls.incl.pl1.
  6     9**/
  6    10 
  6    11 /* HISTORY:
  6    12*Written by Mathew Pierret, 04/01/82.
  6    13*Modified:
  6    14*09/21/82 by Lindsey Spratt:  Added the cm_compact$replacement entry.
  6    15*10/29/82 by Matthew Pierret:  Added cm_find_free_slot, cm_determine_free_space,
  6    16*            cm_find_ci_to_alloc_datum, cm_recursive_put.
  6    17*            Added cm_get_element$info*, $header*.  The former is used when
  6    18*            the caller has a cm_info structure already; the latter is used to
  6    19*            get collection headers.
  6    20*            Added cm_opening_info$get. Removed cm_add_ci_(part thread).
  6    21*            Added cm_allocate_element$info.
  6    22*11/09/82 by Matthew Pierret:  Added argument to cm_allocate_ordered_element
  6    23*            calling sequence for returning free space.
  6    24*            Added cm_free_cn_datum("" $header).
  6    25*01/07/83 by Matthew Pierret:  Added:
  6    26*            cm_allocate_element$buffered("" _info);
  6    27*            cm_put_element$buffered("" _info);
  6    28*            cm_put_datum_in_place$buffered("" _continued);
  6    29*            cm_put_datum_in_pool$buffered("" _continued);
  6    30*            cm_compact$buffered.
  6    31*01/26/83 by Matthew Pierret: Replaced cm_get_header_and_slot with
  6    32*            cm_get_bci_header$slot and added cm_get_bci_header$slot_exclusive.
  6    33*            Added cm_opening_info$get_storage_record.
  6    34*            Added a bit(36)aligned argument to cm_recursive_put to hold the
  6    35*            id of the previous datum.
  6    36*02/02/83 by Matthew Pierret: Added fixed bin (17) argument to cm_find_free_slot
  6    37*            which is for the number of slots after allocation.
  6    38*02/07/83 by Matthew Pierret: Added cm_get_id$(id info info_return_slot
  6    39*            header header_return_slot).
  6    40*            Added cm_get_element_portion$(exclusive info info_exclusive).
  6    41*            Added cm_get_element$bypass_info.
  6    42*03/25/83 by Matthew Pierret: Added cm_free_element$info and
  6    43*            cm_free_opening_info.
  6    44*04/29/83 by Matthew Pierret: Added cm_put_element$unprotected_info
  6    45*08/04/83 by Matthew Pierret:  Added the entries $does_new_datum_fit and
  6    46*            $does_replacement_fit to cm_determine_free_space.  These entries
  6    47*            return flags indicating if a datum fits in the ci and the pool.
  6    48*            Added a bit(1)aligned parameter to cm_find_free_slot in which is
  6    49*            returned the new value of bci_header.free_slot_is_present.
  6    50*02/07/84 by Matthew Pierret:  Added cm_get_id$ptr.  Removed all cm_get_id
  6    51*            modules except cm_get_id$id.  Removed all cm_get_element$info*
  6    52*            entries.  Changed cm_get_element_$bypass_info to have the same
  6    53*            calling sequence as other cm_get_element entries.
  6    54*06/12/84 by Matthew Pierret:  Changed cm_put_element to cm_modify
  6    55*            and cm_allocate_element to cm_put.
  6    56*            Switched the element_length/element_ptr parameter pair to be
  6    57*            element_ptr/element_length in cm_modify and cm_put.
  6    58*07/24/84 by Matthew Pierret:  Added cm_free_ci$raw_return_prev_next.
  6    59*09/24/84 by Matthew Pierret:  Added trace_thread_modifications_(on off)
  6    60*            entries to cm_free_ci and cm_replace_buffered_ci, 
  6    61*            cm_allocate_ci$info_header, cm_opening_info$opening_table_ptr.
  6    62*            Removed cm_find_free_space. Commented out un-used entries.
  6    63*            Re-named allocate  entries to put entries, except for allocate_ci.
  6    64*            Re-named free element and free datum entries to use delete instead
  6    65*            of free, and cm_recursive_put to cm_recursive_modify.
  6    66*            Removed cm_get_element$bypass_info.
  6    67*02/27/85 by Matthew C. Pierret:  Re-added cm_compact$buffered_replacement now
  6    68*            that cm_modify$buffered uses it.
  6    69*03/07/85 by R. Michael Tague:  Added cm_postcommit_increment.
  6    70**/
  6    71 
  6    72 /* format: style2,ind3 */
  6    73 
  6    74 
  6    75      dcl	   cm_allocate_ci	      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  6    76      dcl	   cm_allocate_ci$info    entry (ptr, fixed bin (24) unsigned, fixed bin (35));
  6    77      dcl	   cm_allocate_ci$info_header
  6    78 			      entry (ptr, fixed bin (24) unsigned, ptr, fixed bin (35));
  6    79 
  6    80 
  6    81      dcl	   cm_compact	      entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
  6    82      dcl	   cm_compact$buffered    entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
  6    83      dcl	   cm_compact$replacement entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
  6    84      dcl	   cm_compact$buffered_replacement
  6    85 			      entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
  6    86 
  6    87      dcl	   cm_delete_cn_datum     entry (ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
  6    88 
  6    89      dcl	   cm_delete_cn_datum$header
  6    90 			      entry (ptr, ptr, ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
  6    91 
  6    92      dcl	   cm_delete	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  6    93 			      fixed bin (35));
  6    94      dcl	   cm_delete$info	      entry (ptr, bit (36) aligned, bit (1) aligned, fixed bin (35));
  6    95 
  6    96      dcl	   cm_determine_free_space$all
  6    97 			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35));
  6    98      dcl	   cm_determine_free_space$effective
  6    99 			      entry (ptr, fixed bin (35), bit (1) aligned, bit (1) aligned, fixed bin (35),
  6   100 			      fixed bin (35));
  6   101      dcl	   cm_determine_free_space$does_new_datum_fit
  6   102 			      entry (ptr, fixed bin (35), fixed bin (35), bit (1) aligned, bit (1) aligned,
  6   103 			      bit (1) aligned, bit (1) aligned, fixed bin (35));
  6   104 
  6   105 /**** Not yet used *********************************************************
  6   106*     dcl	   cm_determine_free_space$does_replacement_fit
  6   107*			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35), bit (1) aligned,
  6   108*			      bit (1) aligned, bit (1) aligned, bit (1) aligned, fixed bin (35)); 
  6   109*************************************************************************** */
  6   110 
  6   111      dcl	   cm_find_ci_to_alloc_datum
  6   112 			      entry (ptr, fixed bin (35), fixed bin (24) uns, bit (1) aligned, bit (1) aligned, ptr,
  6   113 			      fixed bin (24) uns, fixed bin (35));
  6   114 
  6   115      dcl	   cm_find_free_slot      entry (bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (17), fixed bin (17),
  6   116 			      bit (1) aligned, fixed bin (35));
  6   117 
  6   118      dcl	   cm_free_ci$info	      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (35));
  6   119      dcl	   cm_free_ci$raw_return_prev_next
  6   120 			      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (24) uns,
  6   121 			      fixed bin (24) uns, fixed bin (35));
  6   122      dcl	   cm_free_ci$trace_thread_modifications_on
  6   123 			      entry ();
  6   124      dcl	   cm_free_ci$trace_thread_modifications_off
  6   125 			      entry ();
  6   126 
  6   127 
  6   128      dcl	   cm_free_opening_info   entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  6   129 
  6   130      dcl	   cm_get_bci_header      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
  6   131      dcl	   cm_get_bci_header$exclusive
  6   132 			      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
  6   133      dcl	   cm_get_bci_header$slot entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  6   134 
  6   135 /**** Not yet used ********************************************************
  6   136*     dcl	   cm_get_bci_header$slot_exclusive
  6   137*			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  6   138*************************************************************************** */
  6   139 
  6   140      dcl	   cm_get_element	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  6   141 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  6   142      dcl	   cm_get_element$exclusive
  6   143 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  6   144 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  6   145 
  6   146      dcl	   cm_get_element_portion entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  6   147 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  6   148 			      fixed bin (35), fixed bin (35));
  6   149 
  6   150 /**** Not yet used ********************************************************
  6   151*     dcl	   cm_get_element_portion$exclusive
  6   152*			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  6   153*			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  6   154*			      fixed bin (35), fixed bin (35));
  6   155*************************************************************************** */
  6   156 
  6   157      dcl	   cm_get_id$id	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
  6   158 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  6   159      dcl	   cm_get_id$ptr	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
  6   160 			      bit (1) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  6   161 
  6   162      dcl	   cm_modify	      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  6   163 			      fixed bin (35), fixed bin (35));
  6   164      dcl	   cm_modify$buffered     entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  6   165 			      fixed bin (35), fixed bin (35));
  6   166 
  6   167 /******* Not yet used *****************************************************
  6   168*     dcl	   cm_modify$buffered_info
  6   169*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
  6   170*			      fixed bin (35));
  6   171*****************************************************************************/
  6   172 
  6   173      dcl	   cm_modify$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  6   174      dcl	   cm_modify$unprotected_info
  6   175 			      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  6   176 
  6   177 
  6   178 /******* Not yet used *****************************************************
  6   179*     dcl	   cm_modify_portion entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35),
  6   180*			      fixed bin (35), ptr, bit (36) aligned, fixed bin (35), fixed bin (35));
  6   181*****************************************************************************/
  6   182 
  6   183 
  6   184      dcl	   cm_opening_info$get    entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  6   185      dcl	   cm_opening_info$get_storage_record
  6   186 			      entry (ptr, fixed bin (35));
  6   187      dcl	   cm_opening_info$full_get
  6   188 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  6   189      dcl	   cm_opening_info$opening_table_ptr
  6   190 			      entry () returns (ptr);
  6   191 
  6   192      dcl	   cm_postcommit_increment
  6   193 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  6   194 
  6   195      dcl	   cm_put		      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  6   196 			      fixed bin (35), fixed bin (35));
  6   197      dcl	   cm_put$buffered	      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  6   198 			      fixed bin (35), fixed bin (35));
  6   199 
  6   200 /******* Not yet used *****************************************************
  6   201*     dcl	   cm_put$buffered_info
  6   202*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
  6   203*			      fixed bin (35));
  6   204*****************************************************************************/
  6   205 
  6   206      dcl	   cm_put$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  6   207 
  6   208      dcl	   cm_put_basic_element   entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  6   209 			      fixed bin (35));
  6   210 
  6   211      dcl	   cm_put_cn_datum	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, bit (36) aligned, fixed bin (35));
  6   212 
  6   213      dcl	   cm_put_datum_in_place  entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  6   214 			      fixed bin (35));
  6   215      dcl	   cm_put_datum_in_place$buffered
  6   216 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  6   217      dcl	   cm_put_datum_in_place$buffered_continued
  6   218 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
  6   219 			      fixed bin (35));
  6   220      dcl	   cm_put_datum_in_place$continued
  6   221 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  6   222 			      fixed bin (35), bit (36) aligned, fixed bin (35));
  6   223 
  6   224      dcl	   cm_put_datum_in_pool   entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  6   225 			      fixed bin (35));
  6   226      dcl	   cm_put_datum_in_pool$buffered
  6   227 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  6   228      dcl	   cm_put_datum_in_pool$buffered_continued
  6   229 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
  6   230 			      fixed bin (35));
  6   231      dcl	   cm_put_datum_in_pool$continued
  6   232 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  6   233 			      fixed bin (35), bit (36) aligned, fixed bin (35));
  6   234 
  6   235      dcl	   cm_put_ordered_element entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  6   236 			      fixed bin (35));
  6   237      dcl	   cm_put_ordered_element$buffered
  6   238 			      entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  6   239 			      fixed bin (35));
  6   240 
  6   241      dcl	   cm_put_overlength_tail entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35));
  6   242 
  6   243      dcl	   cm_recursive_modify    entry (ptr, bit (36) aligned, ptr, fixed bin (35), fixed bin (35), bit (36) aligned,
  6   244 			      fixed bin (35));
  6   245 
  6   246 
  6   247      dcl	   cm_replace_buffered_ci$trace_thread_modifications_on
  6   248 			      entry ();
  6   249      dcl	   cm_replace_buffered_ci$trace_thread_modifications_off
  6   250 			      entry ();
  6   251 
  6   252 /* END INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
      393 
      394 
  7     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  7     2 /* format: style3 */
  7     3 
  7     4 /* These constants are to be used for the flags argument of sub_err_ */
  7     5 /* They are just "string (condition_info_header.action_flags)" */
  7     6 
  7     7 declare	(
  7     8 	ACTION_CAN_RESTART	init (""b),
  7     9 	ACTION_CANT_RESTART init ("1"b),
  7    10 	ACTION_DEFAULT_RESTART
  7    11 			init ("01"b),
  7    12 	ACTION_QUIET_RESTART
  7    13 			init ("001"b),
  7    14 	ACTION_SUPPORT_SIGNAL
  7    15 			init ("0001"b)
  7    16 	)		bit (36) aligned internal static options (constant);
  7    17 
  7    18 /* End include file */
      395 
      396    end cm_opening_info;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0912.7  cm_opening_info.pl1               >spec>on>7192.pbf-04/04/85>cm_opening_info.pl1
383          1    01/07/85  0858.4  dm_cm_info.incl.pl1               >ldd>include>dm_cm_info.incl.pl1
385          2    01/07/85  0858.8  dm_hdr_collection_id.incl.pl1     >ldd>include>dm_hdr_collection_id.incl.pl1
387          3    01/07/85  0858.2  dm_cm_collection_header.incl.pl1  >ldd>include>dm_cm_collection_header.incl.pl1
389          4    01/07/85  0858.4  dm_cm_storage_record.incl.pl1     >ldd>include>dm_cm_storage_record.incl.pl1
391          5    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
393          6    04/04/85  0819.0  dm_cm_entry_dcls.incl.pl1         >spec>on>7192.pbf-04/04/85>dm_cm_entry_dcls.incl.pl1
395          7    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000036 constant        bit(36)                  initial dcl 7-7 set ref 319* 376*
BITS_PER_WORD                          constant        fixed bin(17,0)          initial dcl 122 ref 273 311
CM_INFO_VERSION_2               000002 constant        char(8)                  initial dcl 1-48 set ref 181* 239* 270
COLLECTION_HEADER_VERSION_2     000000 constant        char(8)                  initial dcl 3-86 set ref 182* 284*
DONT_POSITION                   000037 constant        fixed bin(17,0)          initial dcl 121 set ref 273* 311*
HEADER_COLLECTION_ID            000041 constant        bit(36)                  initial dcl 2-19 set ref 273* 311*
NUMBER_OF_BUCKETS               000015 constant        fixed bin(17,0)          initial dcl 123 set ref 223*
addr                                                   builtin function         dcl 116 ref 319 319
alloc_new_cm_info               000102 automatic       bit(1)                   initial dcl 105 set ref 105* 222* 235* 259 266 293
                                                                                  357
blocked_storage_record                 based           structure                level 1 dcl 4-36 ref 311
blocked_storage_record_ptr      000116 automatic       pointer                  initial dcl 4-48 set ref 311 4-48*
cm_get_element                  000050 constant        entry                    external dcl 6-140 ref 273 311
cm_info                                based           structure                level 1 dcl 1-37 set ref 269 363
cm_info_ptr                     000110 automatic       pointer                  initial dcl 1-47 set ref 180* 181 182 192* 200* 229*
                                                                                  239 240 261 269* 270 273 273 283 287 288 289 290
                                                                                  296* 304 308 308 311 311 311 311 319 319 319 330
                                                                                  331 331 334 1-47* 363 363 363
code                            000105 automatic       fixed bin(35,0)          dcl 107 set ref 203* 205* 206 206 206* 209* 223* 224
                                                                                  224* 229* 231 234* 273* 276 279 279 281* 296* 298
                                                                                  298* 311* 316 316 316 316*
collection_header                      based           structure                level 1 dcl 3-65 set ref 273 360
collection_header_ptr           000112 automatic       pointer                  dcl 3-85 set ref 192* 200* 273 283* 284 360 360
collection_id             4            based           bit(36)                  initial level 2 dcl 1-37 set ref 269* 289* 308* 319*
control_interval_id                    based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 5-32 set ref
                                                                                  319*
current_transaction_id          000106 automatic       bit(36)                  initial dcl 108 set ref 108* 205* 240 261* 287 330
current_txn_id            2            based           bit(36)                  initial level 2 dcl 1-37 set ref 240 261* 269* 287*
                                                                                  330*
cv_p_expected_version                  parameter       char(8)                  dcl 373 set ref 370 376 376*
cv_p_received_version                  parameter       char(8)                  dcl 372 set ref 370 376 376*
cv_p_structure_name                    parameter       char                     unaligned dcl 374 set ref 370 376*
dm_area_ptr                     000014 internal static pointer                  initial dcl 157 set ref 211 211* 269 273* 311* 360
                                                                                  363
dm_error_$ci_not_in_collection  000034 external static fixed bin(35,0)          dcl 141 ref 279 316
dm_error_$collection_not_found  000036 external static fixed bin(35,0)          dcl 141 set ref 279*
dm_error_$no_current_transaction
                                000044 external static fixed bin(35,0)          dcl 141 ref 206
dm_error_$no_element            000042 external static fixed bin(35,0)          dcl 141 ref 279 316
dm_error_$programming_error     000040 external static fixed bin(35,0)          dcl 141 set ref 319*
element_id                             based           structure                level 1 dcl 5-32
er_p_code                              parameter       fixed bin(35,0)          dcl 342 ref 339 344
error_table_$unimplemented_version
                                000046 external static fixed bin(35,0)          dcl 148 set ref 376*
file_oid                  3            based           bit(36)                  initial level 2 dcl 1-37 set ref 269* 288* 308* 311*
get_dm_free_area_               000020 constant        entry                    external dcl 129 ref 211
get_info                        000100 automatic       bit(1)                   dcl 103 set ref 178* 190* 198* 214
get_storage_record              000101 automatic       bit(1)                   dcl 103 set ref 179* 191* 199* 304
header_ptr                6            based           pointer                  initial level 2 dcl 1-37 set ref 182 269* 273* 273*
                                                                                  283 311 319 319
index                     0(24)        based           fixed bin(12,0)          level 2 packed unsigned unaligned dcl 5-32 set ref
                                                                                  319*
init_table                      000104 automatic       bit(1)                   initial dcl 105 set ref 105* 222* 257
internal_debug                  000010 internal static bit(1)                   initial dcl 154 set ref 168* 172* 253 308
ioa_                            000016 constant        entry                    external dcl 128 ref 256 257 259 261 308
max                                                    builtin function         dcl 116 ref 311
myname                          000004 constant        varying char(32)         initial dcl 124 set ref 319* 376*
null                                                   builtin function         dcl 116 ref 192 200 211 219 269 269 269 290 304 319
                                                                                  319 1-47 4-46 4-48 360 363 376 376
opening_manager_$get_opening    000022 constant        entry                    external dcl 130 ref 229
opening_manager_$init           000026 constant        entry                    external dcl 134 ref 223
opening_manager_$put_opening    000024 constant        entry                    external dcl 132 ref 296
p_cm_info_ptr                          parameter       pointer                  dcl 98 set ref 175 180 187 195 334* 363
p_code                                 parameter       fixed bin(35,0)          dcl 99 set ref 175 187 195 203* 344*
p_collection_id                        parameter       bit(36)                  dcl 97 set ref 187 195 229 256* 273* 289 296
p_file_oid                             parameter       bit(36)                  dcl 96 set ref 187 195 229 256* 273* 288 296
refresh_cm_info                 000103 automatic       bit(1)                   initial dcl 105 set ref 105* 222* 235* 240* 245
size                                                   builtin function         dcl 116 ref 273 311 311
static_opening_table_ptr        000012 internal static pointer                  initial dcl 155 set ref 164 219 223* 229* 296*
storage_record_buffer_ptr
                         12            based           pointer                  initial level 2 dcl 1-37 set ref 269* 311* 331*
storage_record_element_id
                          6            based           bit(36)                  level 2 dcl 3-65 set ref 311* 319 319
storage_record_ptr       10            based           pointer                  initial level 2 dcl 1-37 set ref 269* 290* 304 311*
                                                                                  331
sub_err_                        000030 constant        entry                    external dcl 135 ref 319 376
transaction_manager_$get_current_txn_id
                                000032 constant        entry                    external dcl 136 ref 205
unblocked_storage_record               based           structure                level 1 dcl 4-28 ref 311
unblocked_storage_record_ptr    000114 automatic       pointer                  initial dcl 4-46 set ref 311 4-46*
version                                based           char(8)                  level 2 in structure "collection_header" dcl 3-65
                                                                                  in procedure "cm_opening_info" set ref 182* 284*
version                                based           char(8)                  level 2 in structure "cm_info" dcl 1-37 in procedure
                                                                                  "cm_opening_info" set ref 181* 239* 270*
work_area                              based           area                     dcl 112 ref 269 360 363

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 7-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 7-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 7-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 7-7
cm_allocate_ci                  000000 constant        entry                    external dcl 6-75
cm_allocate_ci$info             000000 constant        entry                    external dcl 6-76
cm_allocate_ci$info_header      000000 constant        entry                    external dcl 6-77
cm_compact                      000000 constant        entry                    external dcl 6-81
cm_compact$buffered             000000 constant        entry                    external dcl 6-82
cm_compact$buffered_replacement 000000 constant        entry                    external dcl 6-84
cm_compact$replacement          000000 constant        entry                    external dcl 6-83
cm_delete                       000000 constant        entry                    external dcl 6-92
cm_delete$info                  000000 constant        entry                    external dcl 6-94
cm_delete_cn_datum              000000 constant        entry                    external dcl 6-87
cm_delete_cn_datum$header       000000 constant        entry                    external dcl 6-89
cm_determine_free_space$all     000000 constant        entry                    external dcl 6-96
cm_determine_free_space$does_new_datum_fit
                                000000 constant        entry                    external dcl 6-101
cm_determine_free_space$effective
                                000000 constant        entry                    external dcl 6-98
cm_find_ci_to_alloc_datum       000000 constant        entry                    external dcl 6-111
cm_find_free_slot               000000 constant        entry                    external dcl 6-115
cm_free_ci$info                 000000 constant        entry                    external dcl 6-118
cm_free_ci$raw_return_prev_next 000000 constant        entry                    external dcl 6-119
cm_free_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 6-124
cm_free_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 6-122
cm_free_opening_info            000000 constant        entry                    external dcl 6-128
cm_get_bci_header               000000 constant        entry                    external dcl 6-130
cm_get_bci_header$exclusive     000000 constant        entry                    external dcl 6-131
cm_get_bci_header$slot          000000 constant        entry                    external dcl 6-133
cm_get_element$exclusive        000000 constant        entry                    external dcl 6-142
cm_get_element_portion          000000 constant        entry                    external dcl 6-146
cm_get_id$id                    000000 constant        entry                    external dcl 6-157
cm_get_id$ptr                   000000 constant        entry                    external dcl 6-159
cm_modify                       000000 constant        entry                    external dcl 6-162
cm_modify$buffered              000000 constant        entry                    external dcl 6-164
cm_modify$info                  000000 constant        entry                    external dcl 6-173
cm_modify$unprotected_info      000000 constant        entry                    external dcl 6-174
cm_opening_info$full_get        000000 constant        entry                    external dcl 6-187
cm_opening_info$get             000000 constant        entry                    external dcl 6-184
cm_opening_info$get_storage_record
                                000000 constant        entry                    external dcl 6-185
cm_opening_info$opening_table_ptr
                                000000 constant        entry                    external dcl 6-189
cm_postcommit_increment         000000 constant        entry                    external dcl 6-192
cm_put                          000000 constant        entry                    external dcl 6-195
cm_put$buffered                 000000 constant        entry                    external dcl 6-197
cm_put$info                     000000 constant        entry                    external dcl 6-206
cm_put_basic_element            000000 constant        entry                    external dcl 6-208
cm_put_cn_datum                 000000 constant        entry                    external dcl 6-211
cm_put_datum_in_place           000000 constant        entry                    external dcl 6-213
cm_put_datum_in_place$buffered  000000 constant        entry                    external dcl 6-215
cm_put_datum_in_place$buffered_continued
                                000000 constant        entry                    external dcl 6-217
cm_put_datum_in_place$continued 000000 constant        entry                    external dcl 6-220
cm_put_datum_in_pool            000000 constant        entry                    external dcl 6-224
cm_put_datum_in_pool$buffered   000000 constant        entry                    external dcl 6-226
cm_put_datum_in_pool$buffered_continued
                                000000 constant        entry                    external dcl 6-228
cm_put_datum_in_pool$continued  000000 constant        entry                    external dcl 6-231
cm_put_ordered_element          000000 constant        entry                    external dcl 6-235
cm_put_ordered_element$buffered 000000 constant        entry                    external dcl 6-237
cm_put_overlength_tail          000000 constant        entry                    external dcl 6-241
cm_recursive_modify             000000 constant        entry                    external dcl 6-243
cm_replace_buffered_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 6-249
cm_replace_buffered_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 6-247
element_id_string                      automatic       bit(36)                  dcl 5-30
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 150

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   001575 constant        entry                    internal dcl 370 ref 181 182 239 284
ERROR_RETURN                    001543 constant        entry                    internal dcl 339 ref 206 224 279 281 298 316
FINISH                          001551 constant        entry                    internal dcl 350 ref 345
GET_HEADER                      000667 constant        label                    dcl 214
JOIN                            000626 constant        label                    dcl 203 ref 185 193 201
MAIN_RETURN                     001534 constant        label                    dcl 335 ref 346
cm_opening_info                 000337 constant        entry                    external dcl 87
debug_off                       000427 constant        entry                    external dcl 170
debug_on                        000404 constant        entry                    external dcl 166
full_get                        000554 constant        entry                    external dcl 187
get                             000602 constant        entry                    external dcl 195
get_storage_record              000454 constant        entry                    external dcl 175
opening_table_ptr               000361 constant        entry                    external dcl 161

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2166        2240    1704        2176
Length      2624    1704        52         347     262           6

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cm_opening_info                     314 external procedure  is an external procedure.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure cm_opening_info.  
FINISH                                  internal procedure  shares stack frame of external procedure cm_opening_info.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure cm_opening_info.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 internal_debug              cm_opening_info
000012 static_opening_table_ptr    cm_opening_info
000014 dm_area_ptr                 cm_opening_info

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cm_opening_info          000100 get_info                    cm_opening_info
                         000101 get_storage_record          cm_opening_info
                         000102 alloc_new_cm_info           cm_opening_info
                         000103 refresh_cm_info             cm_opening_info
                         000104 init_table                  cm_opening_info
                         000105 code                        cm_opening_info
                         000106 current_transaction_id      cm_opening_info
                         000110 cm_info_ptr                 cm_opening_info
                         000112 collection_header_ptr       cm_opening_info
                         000114 unblocked_storage_record_ptr
                                                            cm_opening_info
                         000116 blocked_storage_record_ptr  cm_opening_info

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              signal              ext_entry           alloc_based
free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cm_get_element                get_dm_free_area_             ioa_                          opening_manager_$get_opening
opening_manager_$init         opening_manager_$put_opening  sub_err_
transaction_manager_$get_current_txn_id

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$ci_not_in_collection                              dm_error_$collection_not_found
dm_error_$no_current_transaction                            dm_error_$no_element          dm_error_$programming_error
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    105 000324       108 000327    1   47 000330    4   46 000332    4   48 000333        87 000336        90 000347
    161 000356       164 000370       166 000403       168 000414       169 000417       170 000426       172 000437
    173 000441       175 000450       178 000471       179 000472       180 000474       181 000477       182 000520
    185 000546       187 000547       190 000571       191 000573       192 000574       193 000577       195 000600
    198 000617       199 000621       200 000622       201 000625       203 000626       205 000630       206 000641
    209 000651       211 000652       214 000665       219 000667       222 000674       223 000700       224 000712
    226 000716       229 000717       231 000737       234 000741       235 000742       236 000745       239 000746
    240 000767       245 000775       253 000777       256 001002       257 001025       259 001043       261 001062
    266 001106       269 001110       270 001125       273 001130       276 001173       279 001175       281 001211
    283 001213       284 001216       287 001243       288 001246       289 001251       290 001253       293 001255
    296 001257       298 001277       304 001303       308 001312       311 001337       316 001405       319 001417
    330 001525       331 001530       334 001532       335 001534       339 001543       344 001545       345 001547
    346 001550       350 001551       357 001552       360 001554       363 001562       366 001574       370 001575
    376 001606       381 001676


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
