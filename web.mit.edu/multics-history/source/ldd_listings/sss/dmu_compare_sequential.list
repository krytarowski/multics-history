	COMPILATION LISTING OF SEGMENT dmu_compare_sequential
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/24/88  1531.2 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 /* DESCRIPTION:
        7*
        8*         This subroutine determines if a leaf key or record string satisfies  a
        9*     sequential specification.
       10**/
       11 
       12 /* HISTORY:
       13*
       14*Written by Lindsey L. Spratt, 07/07/82.
       15*Modified:
       16*08/17/82 by Matthew Pierret:  Changed from im_compare_sequential to
       17*            dmu_compare_sequential, as this routine is now used by both
       18*            index_manager_ and record_manager_.
       19*09/27/82 by Matthew Pierret:  Corrected flaw in logic in subroutine "compare"
       20*            which decides whether a key satisfies a specification.
       21*10/07/82 by Lindsey Spratt:  Changed to use search_specification version 2,
       22*	  and to take the and_group_id_list_ptr,
       23*	  number_of_fully_structural_fields and partial_structural_field_id
       24*	  parameters.  Constraints with field ids <=
       25*	  number_of_fully_structural_fields are ignored.  If a constraint
       26*	  has a field id = partial_structural_field_id, then it
       27*	  is only used if its operator_code uses a regular expression or if
       28*	  it is a "^=" comparison.  Any other comparisons on this field will
       29*	  have been satisfied already.
       30*03/22/83 by Lindsey Spratt:  Changed to use version 2 field_table.  Internal
       31*	  procedure names were uppercased.  Did some restructuring of the
       32*	  code in preparation for the version 4 search_specification which
       33*	  suports "intra-tuple" comparisons.  Fixed an error in calculating
       34*	  the location of varying field data.
       35*05/02/83 by Lindsey L. Spratt:  Fixed SETUP_PTR_AND_LENGTH to allow for
       36*            whether the field length is in characters or bits when locating a
       37*            varying field.
       38*05/03/83 by Lindsey L. Spratt:  Fixed to use the addbitno builtin when
       39*            calculating the addr of a field value in a string.
       40*05/23/83 by Matthew Pierret:  Changed to use version 4 specifications,
       41*            which have intra-key/record comparisons. Removed the comments
       42*            around the code which Lindsey wrote in expectation of this event,
       43*            as described in the preceding journalization entries.
       44*02/28/84 by Matthew Pierret: Changed to use the simple_search_specification
       45*            structure and the simplified COMPARE_CONSTRAINT if such a 
       46*            structure is supplied. Changed to check for varying-ness of data
       47*            type by examining the field_descriptor instead of thefield_table's
       48*            varying_field_map, since we already had the field_descriptor.
       49*            Added ERROR_RETURN.  Changed to use the this_constraint structure
       50*            instead of accessing the search specification.
       51*03/01/84 by Matthew Pierret: Corrected a flaw in the logic which determines
       52*            if the result of a comparison between two values is satisfactory.
       53*            This was introduced in the last modification and failed to catch 
       54*            the case where greater-equal was wanted and greater was the result.
       55*03/08/84 by Matthew Pierret: Changed SETUP_PTR_AND_LENGTH to use a based
       56*            overlay to pick up the length fields of varying fields instead
       57*            of the less performant assignment using substr and copy.
       58*05/02/84 by Matthew Pierret:  Changed to FIELD_TABLE_VERSION_3.
       59*06/08/84 by Lee Baldwin:  Fixed to call dm_error_$unimplemented_data_type
       60*            instead of $bad_descriptor_type which didn't exist.
       61*10/13/84 by Lindsey L. Spratt:  In response to audit comments; changed to only
       62*            have arg_descriptor included in the outermost proc, the two
       63*            internal procs which use it either reference it explicitly or via
       64*            a like dcl.  Moved the proc stmt to standard location.  Deleted
       65*            unused dcls.
       66*01/12/85 by Lee A. Newcomb:  Fixed to use error_table_$unsupported_operation
       67*            instead of the non-existant error_table_$unimplemented_operation.
       68**/
       69 
       70 /* format: style2,ind3 */
       71 dmu_compare_sequential:
       72    proc (p_field_table_ptr, p_search_specification_ptr, p_and_group_id_list_ptr, p_number_of_fully_structural_fields,
       73         p_partial_structural_field_id, p_key_string, p_key_satisfies_specification, p_code);
       74 
       75 
       76 /* START OF DECLARATIONS */
       77 /* Parameter */
       78 
       79       dcl	    p_field_table_ptr      ptr parameter;
       80       dcl	    p_search_specification_ptr
       81 			       ptr parameter;
       82       dcl	    p_and_group_id_list_ptr
       83 			       ptr parameter;
       84       dcl	    p_number_of_fully_structural_fields
       85 			       fixed bin;
       86       dcl	    p_partial_structural_field_id
       87 			       fixed bin;
       88       dcl	    p_key_string	       bit (*) parameter;
       89       dcl	    p_key_satisfies_specification
       90 			       bit (1) aligned parameter;
       91       dcl	    p_code	       fixed bin (35) parameter;
       92 
       93 /* Automatic */
       94 
       95       dcl	    key_satisfies_specification
       96 			       bit (1) aligned;
       97 
       98       dcl	    (and_group_list_idx, and_group_idx, constraint_idx)
       99 			       fixed bin;
      100       dcl	    constraint_operator_code
      101 			       fixed bin (18) uns unal;
      102       dcl	    (constraint_field_id, constraint_value_field_id)
      103 			       fixed bin;
      104 
      105       dcl	    field_value_offset     fixed bin (35);
      106       dcl	    (field_value_length, second_value_length)
      107 			       fixed bin (35);
      108       dcl	    (field_value_ptr, second_value_ptr)
      109 			       ptr;
      110       dcl	    field_descriptor_ptr   ptr;
      111       dcl	    input_key_string_ptr   ptr init (null);
      112       dcl	    this_constraint_ptr    ptr init (null);
      113 
      114 /* Based */
      115 
      116       dcl	    field_descriptor       bit (36) based (field_descriptor_ptr);
      117       dcl	    1 this_constraint      unaligned like search_specification.and_group.constraint based (this_constraint_ptr);
      118       dcl	    1 simple_search_specification
      119 			       based (search_specification_ptr),
      120 	      2 head	       like specification_head,
      121 	      2 maximum_number_of_constraints
      122 			       fixed bin (17) unal,
      123 	      2 number_of_and_groups
      124 			       fixed bin (17) unal,
      125 	      2 range	       unal,
      126 	        3 type	       fixed bin (17),
      127 	        3 size	       fixed bin (17),
      128 	      2 and_group,
      129 	        3 number_of_constraints
      130 			       fixed bin (17) unal,
      131 	        3 constraint       like search_specification.and_group.constraint;
      132 
      133 /* Builtin */
      134 
      135       dcl	    (addbitno, addr, bin, null, substr, unspec)
      136 			       builtin;
      137 
      138 /* Constant */
      139 
      140       dcl	    myname	       init ("dmu_compare_sequential") char (32) varying internal static options (constant);
      141 
      142       dcl	    BITS_PER_BYTE	       init (9) fixed bin internal static options (constant);
      143       dcl	    DEFAULT_VALUE_LENGTH   init (-1) fixed bin (35) internal static options (constant);
      144 
      145 /* Entry */
      146 
      147       dcl	    sub_err_	       entry () options (variable);
      148       dcl	    dmu_compare_values     entry (ptr, ptr, ptr, fixed bin (35), bit (1) aligned, bit (1) aligned,
      149 			       fixed bin (35));
      150       dcl	    dmu_compare_values$field_to_field
      151 			       entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (1) aligned,
      152 			       bit (1) aligned, fixed bin (35));
      153       dcl	    search_file_	       entry (ptr, fixed bin (21), fixed bin (21), ptr, fixed bin (21), fixed bin (21),
      154 			       fixed bin (21), fixed bin (21), fixed bin (35));
      155 
      156 /* External */
      157 
      158       dcl	    error_table_$unsupported_operation
      159 			       fixed bin (35) ext;
      160       dcl	    dm_error_$unimplemented_data_type
      161 			       fixed bin (35) ext;
      162 
      163 /* END OF DECLARATIONS */
      164 
      165       search_specification_ptr = p_search_specification_ptr;
      166 
      167       field_table_ptr = p_field_table_ptr;
      168 
      169 /**** ********** Removed for efficiency ********************
      170*
      171*      call CHECK_VERSION (search_specification.version, SPECIFICATION_VERSION_4, "search_specification");
      172*      call CHECK_VERSION_CHAR (field_table.version, FIELD_TABLE_VERSION_3, "field_table");
      173*      if id_list_ptr ^= null
      174*      then call CHECK_VERSION (id_list.version, (ID_LIST_VERSION_1), "id_list");
      175*
      176* **** ******************************************************/
      177 
      178       input_key_string_ptr = addr (p_key_string);
      179 
      180       key_satisfies_specification = "0"b;
      181 
      182       if simple_search_specification.number_of_and_groups = 1
      183 	 & simple_search_specification.and_group.number_of_constraints = 1
      184       then call COMPARE_CONSTRAINT;
      185       else
      186 COMPARE_AND_GROUPS:
      187          do;
      188 
      189 	  id_list_ptr = p_and_group_id_list_ptr;
      190 
      191 	  if id_list_ptr ^= null
      192 	  then
      193 AND_GROUP_LIST_LOOP:
      194 	     do and_group_list_idx = 1 to id_list.number_of_ids while (^key_satisfies_specification);
      195 
      196 	        and_group_idx = id_list.id (and_group_list_idx);
      197 
      198 	        key_satisfies_specification = "1"b;
      199 	        call COMPARE_AND_GROUP;
      200 	     end AND_GROUP_LIST_LOOP;
      201 	  else
      202 AND_GROUP_LOOP:
      203 	     do and_group_idx = 1 to search_specification.number_of_and_groups while (^key_satisfies_specification);
      204 	        key_satisfies_specification = "1"b;
      205 	        call COMPARE_AND_GROUP;
      206 	     end AND_GROUP_LOOP;
      207 
      208          end COMPARE_AND_GROUPS;
      209 
      210       p_code = 0;
      211 MAIN_RETURN:
      212       p_key_satisfies_specification = key_satisfies_specification;
      213 
      214       return;
      215 
      216 
      217 ERROR_RETURN:
      218    proc (er_p_code);
      219 
      220       dcl	    er_p_code	       fixed bin (35);
      221 
      222       p_code = er_p_code;
      223       goto MAIN_RETURN;
      224 
      225    end ERROR_RETURN;
      226 
      227 COMPARE_CONSTRAINT:
      228    proc;
      229 
      230 
      231       constraint_field_id = simple_search_specification.and_group.constraint.field_id;
      232       constraint_operator_code = simple_search_specification.and_group.constraint.operator_code;
      233       constraint_value_field_id = simple_search_specification.and_group.constraint.value_field_id;
      234 
      235       field_descriptor_ptr = addr (field_table.field (constraint_field_id).descriptor);
      236 
      237       call SETUP_PTR_AND_LENGTH (constraint_field_id, field_descriptor_ptr, field_value_ptr, field_value_length);
      238 
      239       if constraint_value_field_id > 0
      240       then
      241          do;
      242 	  call SETUP_PTR_AND_LENGTH (constraint_value_field_id, field_descriptor_ptr, second_value_ptr,
      243 	       second_value_length);
      244 
      245 	  if field_table.field (constraint_value_field_id).descriptor ^= field_descriptor
      246 	  then call sub_err_ (error_table_$unsupported_operation, myname, ACTION_CANT_RESTART, null, 0,
      247 		  "^/Currently fields to be compared must have identical descriptors.");
      248 
      249 /**** FOR COMPARISON OF FIELDS WITH DIFFERENT DESCRIPTORS 
      250*
      251*		         do;
      252*			  call
      253*			     CONVERT_AND_COMPARE (unspec (constraint_operator_code),
      254*			     field_descriptor_ptr, field_value_ptr,
      255*			     field_value_length, addr (field_table.field (constraint_value_field_id).descriptor),
      256*			     second_value_ptr, second_value_length, key_satisfies_specification);
      257*
      258*		         end;
      259*
      260***** END FOR COMPARISONS OF FIELDS WITH DIFFERENT DESCRIPTORS */
      261 
      262 	  else
      263 	     do;
      264 	        call COMPARE (unspec (constraint_operator_code), second_value_ptr, second_value_length,
      265 		   field_descriptor_ptr, field_value_ptr, field_value_length, key_satisfies_specification);
      266 
      267 	     end;
      268          end;
      269       else
      270          do;
      271 
      272 	  call COMPARE (unspec (constraint_operator_code), (simple_search_specification.and_group.constraint.value_ptr),
      273 	       DEFAULT_VALUE_LENGTH, field_descriptor_ptr, field_value_ptr, field_value_length,
      274 	       key_satisfies_specification);
      275 
      276          end;
      277 
      278       return;
      279 
      280    end COMPARE_CONSTRAINT;
      281 
      282 COMPARE_AND_GROUP:
      283    proc;
      284       do constraint_idx = 1 to search_specification.and_group (and_group_idx).number_of_constraints
      285 	 while (key_satisfies_specification);
      286 
      287          this_constraint_ptr = addr (search_specification.and_group (and_group_idx).constraint (constraint_idx));
      288 
      289          constraint_field_id = this_constraint.field_id;
      290          constraint_operator_code = this_constraint.operator_code;
      291          constraint_value_field_id = this_constraint.value_field_id;
      292 
      293          if constraint_field_id > p_number_of_fully_structural_fields
      294          then if constraint_field_id ^= p_partial_structural_field_id
      295 	         | (USES_REGULAR_EXPRESSION_OPERATOR (constraint_operator_code)
      296 	         | constraint_operator_code = NOT_EQUAL_OPERATOR_CODE | constraint_value_field_id >= 0)
      297 	    then
      298 CHECK_CONSTRAINT:
      299 	       do;
      300 
      301 		field_descriptor_ptr = addr (field_table.field (constraint_field_id).descriptor);
      302 
      303 		call SETUP_PTR_AND_LENGTH (constraint_field_id, field_descriptor_ptr, field_value_ptr,
      304 		     field_value_length);
      305 
      306 		if constraint_value_field_id > 0
      307 		then
      308 		   do;
      309 		      call SETUP_PTR_AND_LENGTH (constraint_value_field_id, field_descriptor_ptr, second_value_ptr,
      310 			 second_value_length);
      311 
      312 		      if field_table.field (constraint_value_field_id).descriptor ^= field_descriptor
      313 		      then call sub_err_ (error_table_$unsupported_operation, myname, ACTION_CANT_RESTART, null, 0,
      314 			      "^/Currently fields to be compared must have identical descriptors.");
      315 
      316 /**** FOR COMPARISON OF FIELDS WITH DIFFERENT DESCRIPTORS 
      317*
      318*		         do;
      319*			  call
      320*			     CONVERT_AND_COMPARE (unspec (constraint_operator_code),
      321*			     field_descriptor_ptr, field_value_ptr,
      322*			     field_value_length, addr (field_table.field (constraint_value_field_id).descriptor),
      323*			     second_value_ptr, second_value_length, key_satisfies_specification);
      324*
      325*		         end;
      326*
      327***** END FOR COMPARISONS OF FIELDS WITH DIFFERENT DESCRIPTORS */
      328 
      329 		      else
      330 		         do;
      331 			  call COMPARE (unspec (constraint_operator_code), second_value_ptr, second_value_length,
      332 			       field_descriptor_ptr, field_value_ptr, field_value_length,
      333 			       key_satisfies_specification);
      334 
      335 		         end;
      336 		   end;
      337 		else
      338 		   do;
      339 
      340 		      call COMPARE (unspec (constraint_operator_code), (this_constraint.value_ptr),
      341 			 DEFAULT_VALUE_LENGTH, field_descriptor_ptr, field_value_ptr, field_value_length,
      342 			 key_satisfies_specification);
      343 
      344 		   end;
      345 	       end CHECK_CONSTRAINT;
      346       end;
      347    end COMPARE_AND_GROUP;
      348 
      349 SETUP_PTR_AND_LENGTH:
      350    proc (spl_p_field_id, spl_p_field_descriptor_ptr, spl_p_field_value_ptr, spl_p_field_value_length);
      351 
      352       dcl	    spl_p_field_id	       fixed bin;
      353       dcl	    spl_p_field_descriptor_ptr
      354 			       ptr;
      355       dcl	    spl_p_field_value_ptr  ptr;
      356       dcl	    spl_p_field_value_length
      357 			       fixed bin (35);
      358 
      359       dcl	    spl_temp_field_id      fixed bin;
      360       dcl	    spl_temp_field_value_length
      361 			       fixed bin (35);
      362       dcl	    spl_varying_field_idx  fixed bin;
      363       dcl	    spl_varying_field_location
      364 			       fixed bin (35);
      365       dcl	    spl_length_field_length
      366 			       fixed bin (35);
      367       dcl	    spl_length_field_ptr   ptr;
      368       dcl	    spl_length_field_string
      369 			       bit (spl_length_field_length) based (spl_length_field_ptr);
      370 
      371       dcl	    spl_descriptor_type    fixed bin (35) init (0);
      372 
      373       spl_descriptor_type = spl_p_field_descriptor_ptr -> arg_descriptor.type;
      374 
      375       if spl_descriptor_type ^= varying_bit_dtype & spl_descriptor_type ^= varying_char_dtype
      376       then
      377 PREPARE_NONVARYING_FIELD:
      378          do;
      379 	  spl_p_field_value_length = -1;
      380 	  spl_p_field_value_ptr = addbitno (input_key_string_ptr, field_table.field (spl_p_field_id).location - 1);
      381          end PREPARE_NONVARYING_FIELD;
      382       else
      383 PREPARE_VARYING_FIELD:
      384          do;
      385 	  spl_length_field_length = field_table.field (spl_p_field_id).length_in_bits;
      386 	  spl_length_field_ptr = addbitno (input_key_string_ptr, field_table.field (spl_p_field_id).location - 1);
      387 	  spl_p_field_value_length = bin (spl_length_field_string, 35, 0);
      388 
      389 	  spl_varying_field_location = field_table.location_of_first_varying_field;
      390 SET_VARYING_FIELD_VALUE_OFFSET:
      391 	  do spl_varying_field_idx = 1 to field_table.varying_field_map (spl_p_field_id).varying_field_index - 1;
      392 	     spl_temp_field_id = field_table.varying_field_map (spl_varying_field_idx).field_id;
      393 	     spl_length_field_length = field_table.field (spl_temp_field_id).length_in_bits;
      394 	     spl_length_field_ptr = addbitno (input_key_string_ptr, field_table.field (spl_temp_field_id).location - 1);
      395 	     spl_temp_field_value_length = bin (spl_length_field_string, 35, 0);
      396 
      397 	     if field_table.field (spl_temp_field_id).length_is_in_characters
      398 	     then spl_varying_field_location = spl_varying_field_location + spl_temp_field_value_length * BITS_PER_BYTE;
      399 	     else spl_varying_field_location = spl_varying_field_location + spl_temp_field_value_length;
      400 	  end SET_VARYING_FIELD_VALUE_OFFSET;
      401 
      402 	  spl_p_field_value_ptr = addbitno (input_key_string_ptr, spl_varying_field_location - 1);
      403          end PREPARE_VARYING_FIELD;
      404 
      405       return;
      406 
      407 
      408    end SETUP_PTR_AND_LENGTH;
      409 
      410 COMPARE:
      411    proc (c_p_operator_code_string, c_p_spec_value_ptr, c_p_spec_value_length, c_p_field_descriptor_ptr,
      412         c_p_field_value_ptr, c_p_field_value_length, c_p_key_satisfies_specification);
      413 
      414       dcl	    c_p_operator_code_string
      415 			       bit (*);
      416       dcl	    c_p_spec_value_ptr     ptr;
      417       dcl	    c_p_spec_value_length  fixed bin (35);
      418       dcl	    c_p_field_descriptor_ptr
      419 			       ptr;
      420       dcl	    c_p_field_value_ptr    ptr;
      421       dcl	    c_p_field_value_length fixed bin (35);
      422       dcl	    c_p_key_satisfies_specification
      423 			       bit (1) aligned;
      424 
      425       dcl	    c_code	       fixed bin (35);
      426 
      427       dcl	    (c_want_key_equal_to_spec, c_want_key_greater_than_spec, c_invert_spec, c_want_key_match_regular_expression)
      428 			       bit (1) aligned;
      429       dcl	    (c_spec_equal_to_key, c_spec_less_than_key)
      430 			       bit (1) aligned;
      431 
      432       dcl	    1 c_p_field_descriptor based (c_p_field_descriptor_ptr) like arg_descriptor;
      433 
      434       dcl	    1 c_varying_spec_value based (c_p_spec_value_ptr),
      435 	      2 length	       fixed bin (35),
      436 	      2 string	       char (0 refer (c_varying_spec_value.length));
      437 
      438       c_code = 0;
      439       c_want_key_match_regular_expression = substr (c_p_operator_code_string, REGULAR_EXPRESSION_IDX, 1);
      440       c_invert_spec = substr (c_p_operator_code_string, NOT_IDX, 1);
      441 
      442       if c_want_key_match_regular_expression
      443       then
      444          do;
      445 	  if c_p_field_value_length = -1
      446 	  then
      447 	     do;
      448 	        if c_p_field_descriptor.type ^= char_dtype
      449 	        then call ERROR_RETURN (dm_error_$unimplemented_data_type);
      450 
      451 	        c_p_field_value_length = c_p_field_descriptor.size;
      452 	     end;
      453 	  call search_file_ (addr (c_varying_spec_value.string), 1, (c_varying_spec_value.length), c_p_field_value_ptr,
      454 	       1, (c_p_field_value_length), 0, 0, c_code);
      455 	  if c_code = 0
      456 	  then c_p_key_satisfies_specification = "1"b;
      457 	  else if c_code = 1
      458 	  then c_p_key_satisfies_specification = "0"b;
      459 	  else call ERROR_RETURN (c_code);
      460 
      461          end;
      462       else
      463          do;
      464 	  c_want_key_equal_to_spec = substr (c_p_operator_code_string, EQUAL_IDX, 1);
      465 	  c_want_key_greater_than_spec = substr (c_p_operator_code_string, GREATER_IDX, 1);
      466 
      467 	  if c_p_spec_value_length = -1
      468 	  then call dmu_compare_values (c_p_field_descriptor_ptr, c_p_spec_value_ptr, c_p_field_value_ptr,
      469 		  c_p_field_value_length, c_spec_equal_to_key, c_spec_less_than_key, c_code);
      470 	  else call dmu_compare_values$field_to_field (c_p_field_descriptor_ptr, c_p_spec_value_ptr,
      471 		  c_p_spec_value_length, c_p_field_value_ptr, c_p_field_value_length, c_spec_equal_to_key,
      472 		  c_spec_less_than_key, c_code);
      473 
      474 	  if c_code ^= 0
      475 	  then call ERROR_RETURN (c_code);
      476 
      477 /* format: off */
      478 	  if (c_want_key_equal_to_spec & c_spec_equal_to_key) 
      479 						/* want equal and is equal */
      480 	  |  (c_want_key_greater_than_spec & ^c_spec_equal_to_key & c_spec_less_than_key)
      481 						/* want greater and is greater */
      482             then c_p_key_satisfies_specification = "1"b;
      483 	  else c_p_key_satisfies_specification = "0"b;
      484                                                             /* format: on */
      485          end;
      486 
      487       if c_invert_spec
      488       then c_p_key_satisfies_specification = ^c_p_key_satisfies_specification;
      489 
      490       return;
      491 
      492    end COMPARE;
      493 
      494 /* ******************** Removed for efficiency ********************************
      495*%page;
      496*CHECK_VERSION:
      497*   proc (p_received_version, p_expected_version, p_structure_name);
      498*      dcl	    p_received_version     fixed bin (35);
      499*      dcl	    p_expected_version     fixed bin (35);
      500*      dcl	    p_structure_name       char (*);
      501*      if p_received_version ^= p_expected_version
      502*      then call
      503*	    sub_err_ (error_table_$unimplemented_version, myname, "s", null, 0,
      504*	    "^/The expected version for the ^a structure was ^d. Received ^d instead.", p_expected_version,
      505*	    p_structure_name, p_received_version);
      506*
      507*   end CHECK_VERSION;
      508*%page;
      509*CHECK_VERSION_CHAR:
      510*   proc (p_received_version, p_expected_version, p_structure_name);
      511*      dcl	    p_received_version     char (*) parameter;
      512*      dcl	    p_expected_version     char (*) parameter;
      513*      dcl	    p_structure_name       char (*) parameter;
      514*
      515*      if p_received_version ^= p_expected_version
      516*      then call
      517*	    sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      518*	    "^/Expected version ^a of the ^a structure. Received version ^a.", p_expected_version, p_structure_name,
      519*	    p_received_version);
      520*
      521*   end CHECK_VERSION_CHAR;
      522*
      523********************* End of code removed for efficiency *********************/
      524 
  1     1 /* BEGIN INCLUDE FILE - dm_specification.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*          The specification structure is used to identify sets items based on
  1     6*     the value of some of the contents of the items (the
  1     7*     search_specification), or based on the ordinal position (the
  1     8*     numeric_specification) of the first or last item in the desired set of
  1     9*     items in the set of all possible items.  It is used with the relation,
  1    10*     index and record managers.  The items for these three managers are
  1    11*     tuples, keys and records, respectively.  The sets of "all possible
  1    12*     items", for determination of ordinal position for these three managers
  1    13*     are: a relation, an index, and a record collection, respectively.
  1    14*     
  1    15*          The specification_head structure, in dm_specification_head.incl.pl1,
  1    16*     must be included in any program which uses this (the
  1    17*     dm_specification.incl.pl1) include file.
  1    18**/
  1    19 
  1    20 /* HISTORY:
  1    21*
  1    22*Written by Lindsey Spratt, 05/19/82.
  1    23*Modified:
  1    24*08/17/82 by Matthew Pierret:  Added all specification type constants.
  1    25*09/24/82 by Ronald Harvey: Changed version and added and_groups.
  1    26*10/22/82 by Lindsey Spratt:  Added the range_size to the numeric_specification.
  1    27*	  Changed the version to 3.
  1    28*05/11/83 by Matthew Pierret: Moved specification_head and and type constants
  1    29*            to dm_specification_head.incl.pl1. Added constraint.value_field_id.
  1    30*            Moved range type constants into dm_range_constants.incl.pl1.
  1    31*05/20/83 by Matthew Pierret: Added constraint.value_field_id for specifying
  1    32*            intra-key/record compares.
  1    33*10/02/84 by Lindsey L. Spratt:  Moved a misplaced journalization comment.
  1    34*            Added a DESCRIPTION comment.
  1    35**/
  1    36 
  1    37 /* format: style2,ind3 */
  1    38      dcl	   1 search_specification based (search_specification_ptr),
  1    39 	     2 head	      like specification_head,
  1    40 	     2 maximum_number_of_constraints
  1    41 			      fixed bin (17) unal,
  1    42 	     2 number_of_and_groups
  1    43 			      fixed bin (17) unal,
  1    44 	     2 range	      unal,
  1    45 	       3 type	      fixed bin (17),
  1    46 	       3 size	      fixed bin (17),
  1    47 	     2 and_group	      (ss_number_of_and_groups refer (search_specification.number_of_and_groups)),
  1    48 	       3 number_of_constraints
  1    49 			      fixed bin (17) unal,
  1    50 	       3 constraint	      (ss_maximum_number_of_constraints
  1    51 			      refer (search_specification.maximum_number_of_constraints)),
  1    52 	         4 field_id	      fixed bin (17) unal,
  1    53 	         4 operator_code  fixed bin (17) unal,
  1    54 	         4 value_field_id fixed bin (17) unal,
  1    55 	         4 pad	      bit (18) unal,
  1    56 	         4 value_ptr      ptr unal;
  1    57 
  1    58      dcl	   search_specification_ptr
  1    59 			      ptr;
  1    60      dcl	   (ss_number_of_and_groups, ss_maximum_number_of_constraints)
  1    61 			      fixed bin (17);
  1    62 
  1    63      dcl	   1 numeric_specification
  1    64 			      based (numeric_specification_ptr),
  1    65 	     2 head	      like specification_head,
  1    66 	     2 range_size	      fixed bin (35) aligned,
  1    67 	     2 position_number    fixed bin (17) unal,
  1    68 	     2 pad	      bit (18) unal;
  1    69 
  1    70      dcl	   numeric_specification_ptr
  1    71 			      ptr;
  1    72 
  1    73 /* END INCLUDE FILE - dm_specification.incl.pl1 */
      525 
      526 
  2     1 /* BEGIN INCLUDE FILE dm_specification_head.incl.pl1 */
  2     2 
  2     3 /* HISTORY:
  2     4*Written by Matthew Pierret, 05/11/83. (Extracted from dm_specification.incl.pl1)
  2     5*Modified:
  2     6*05/20/83 by Matthew Pierret: Changed to use version 4.
  2     7**/
  2     8 
  2     9 /* format: style2,ind3 */
  2    10      dcl	   1 specification_head   based (specification_head_ptr),
  2    11 	     2 version	      fixed bin (35),
  2    12 	     2 type	      fixed bin (17) unal,
  2    13 	     2 pad	      bit (18) unal,
  2    14 	     2 subset_specification_ptr
  2    15 			      ptr;
  2    16 
  2    17 
  2    18      dcl	   specification_head_ptr ptr;
  2    19      dcl	   SPECIFICATION_VERSION_4
  2    20 			      init (4) fixed bin (35) internal static options (constant);
  2    21 
  2    22      dcl	   (
  2    23 	   SEARCH_SPECIFICATION_TYPE
  2    24 			      init (1),
  2    25 	   ABSOLUTE_SEARCH_SPECIFICATION_TYPE
  2    26 			      init (1),
  2    27 	   NUMERIC_SPECIFICATION_TYPE
  2    28 			      init (2),
  2    29 	   ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
  2    30 			      init (2),
  2    31 	   RELATIVE_SEARCH_SPECIFICATION_TYPE
  2    32 			      init (3),
  2    33 	   RELATIVE_NUMERIC_SPECIFICATION_TYPE
  2    34 			      init (4),
  2    35 	   ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
  2    36 			      init (5),
  2    37 	   RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
  2    38 			      init (6),
  2    39 	   ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
  2    40 			      init (7),
  2    41 	   RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
  2    42 			      init (8)
  2    43 	   )		      fixed bin (17) internal static options (constant);
  2    44 
  2    45 
  2    46 /* END INCLUDE FILE dm_specification_head.incl.pl1 */
      527 
      528 
  3     1 /* BEGIN INCLUDE FILE ... std_descriptor_types.incl.pl1 */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
  3     6*     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1208):
  3     7*     Added pascal_string_type_dtype descriptor type.  Its number is 87.
  3     8*     Objects of this type are PASCAL string types.
  3     9*  2) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  3    10*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  3    11*     Added the new C types.
  3    12*                                                   END HISTORY COMMENTS */
  3    13 
  3    14 /* This include file defines mnemonic names for the Multics
  3    15*   standard descriptor types, using both pl1 and cobol terminology.
  3    16*   PG 780613
  3    17*   JRD 790530
  3    18*   JRD 791016
  3    19*   MBW 810731
  3    20*   TGO 830614 Add hex types.
  3    21*   Modified June 83 JMAthane to add PASCAL data types
  3    22*   TGO 840120 Add float dec extended and generic, float binary generic
  3    23**/
  3    24 
  3    25      dcl	   (real_fix_bin_1_dtype  init (1),
  3    26 	   real_fix_bin_2_dtype   init (2),
  3    27 	   real_flt_bin_1_dtype   init (3),
  3    28 	   real_flt_bin_2_dtype   init (4),
  3    29 	   cplx_fix_bin_1_dtype   init (5),
  3    30 	   cplx_fix_bin_2_dtype   init (6),
  3    31 	   cplx_flt_bin_1_dtype   init (7),
  3    32 	   cplx_flt_bin_2_dtype   init (8),
  3    33 	   real_fix_dec_9bit_ls_dtype init (9),
  3    34 	   real_flt_dec_9bit_dtype init (10),
  3    35 	   cplx_fix_dec_9bit_ls_dtype init (11),
  3    36 	   cplx_flt_dec_9bit_dtype init (12),
  3    37 	   pointer_dtype	      init (13),
  3    38 	   offset_dtype	      init (14),
  3    39 	   label_dtype	      init (15),
  3    40 	   entry_dtype	      init (16),
  3    41 	   structure_dtype	      init (17),
  3    42 	   area_dtype	      init (18),
  3    43 	   bit_dtype	      init (19),
  3    44 	   varying_bit_dtype      init (20),
  3    45 	   char_dtype	      init (21),
  3    46 	   varying_char_dtype     init (22),
  3    47 	   file_dtype	      init (23),
  3    48 	   real_fix_dec_9bit_ls_overp_dtype init (29),
  3    49 	   real_fix_dec_9bit_ts_overp_dtype init (30),
  3    50 	   real_fix_bin_1_uns_dtype init (33),
  3    51 	   real_fix_bin_2_uns_dtype init (34),
  3    52 	   real_fix_dec_9bit_uns_dtype init (35),
  3    53 	   real_fix_dec_9bit_ts_dtype init (36),
  3    54 	   real_fix_dec_4bit_uns_dtype init (38),	/* digit-aligned */
  3    55 	   real_fix_dec_4bit_ts_dtype init (39),	/* byte-aligned */
  3    56 	   real_fix_dec_4bit_bytealigned_uns_dtype init (40), /* COBOL */
  3    57 	   real_fix_dec_4bit_ls_dtype init (41),	/* digit-aligned */
  3    58 	   real_flt_dec_4bit_dtype init (42),		/* digit-aligned */
  3    59 	   real_fix_dec_4bit_bytealigned_ls_dtype init (43),
  3    60 	   real_flt_dec_4bit_bytealigned_dtype init (44),
  3    61 	   cplx_fix_dec_4bit_bytealigned_ls_dtype init (45),
  3    62 	   cplx_flt_dec_4bit_bytealigned_dtype init (46),
  3    63 	   real_flt_hex_1_dtype   init (47),
  3    64 	   real_flt_hex_2_dtype   init (48),
  3    65 	   cplx_flt_hex_1_dtype   init (49),
  3    66 	   cplx_flt_hex_2_dtype   init (50),
  3    67 	   c_typeref_dtype        init (54),
  3    68 	   c_enum_dtype           init (55),
  3    69              c_enum_const_dtype     init (56),
  3    70 	   c_union_dtype          init (57),
  3    71 	   algol68_straight_dtype init (59),
  3    72 	   algol68_format_dtype   init (60),
  3    73 	   algol68_array_descriptor_dtype init (61),
  3    74 	   algol68_union_dtype    init (62),
  3    75 
  3    76 	   cobol_comp_6_dtype     init (1),
  3    77 	   cobol_comp_7_dtype     init (1),
  3    78 	   cobol_display_ls_dtype init (9),
  3    79 	   cobol_structure_dtype  init (17),
  3    80 	   cobol_char_string_dtype init (21),
  3    81 	   cobol_display_ls_overp_dtype init (29),
  3    82 	   cobol_display_ts_overp_dtype init (30),
  3    83 	   cobol_display_uns_dtype init (35),
  3    84 	   cobol_display_ts_dtype init (36),
  3    85 	   cobol_comp_8_uns_dtype init (38),		/* digit aligned */
  3    86 	   cobol_comp_5_ts_dtype  init (39),		/* byte aligned */
  3    87 	   cobol_comp_5_uns_dtype init (40),
  3    88 	   cobol_comp_8_ls_dtype  init (41),		/* digit aligned */
  3    89 	   real_flt_dec_extended_dtype init (81),	/* 9-bit exponent */
  3    90 	   cplx_flt_dec_extended_dtype init (82),	/* 9-bit exponent */
  3    91 	   real_flt_dec_generic_dtype init (83),	/* generic float decimal */
  3    92 	   cplx_flt_dec_generic_dtype init (84),
  3    93 	   real_flt_bin_generic_dtype init (85),	/* generic float binary */
  3    94 	   cplx_flt_bin_generic_dtype init (86)) fixed bin internal static options (constant);
  3    95 
  3    96      dcl	   (ft_integer_dtype      init (1),
  3    97 	   ft_real_dtype	      init (3),
  3    98 	   ft_double_dtype	      init (4),
  3    99 	   ft_complex_dtype	      init (7),
  3   100 	   ft_complex_double_dtype init (8),
  3   101 	   ft_external_dtype      init (16),
  3   102 	   ft_logical_dtype	      init (19),
  3   103 	   ft_char_dtype	      init (21),
  3   104 	   ft_hex_real_dtype      init (47),
  3   105 	   ft_hex_double_dtype    init (48),
  3   106 	   ft_hex_complex_dtype   init (49),
  3   107 	   ft_hex_complex_double_dtype init (50)
  3   108 	   )		      fixed bin internal static options (constant);
  3   109 
  3   110      dcl	   (algol68_short_int_dtype init (1),
  3   111 	   algol68_int_dtype      init (1),
  3   112 	   algol68_long_int_dtype init (2),
  3   113 	   algol68_real_dtype     init (3),
  3   114 	   algol68_long_real_dtype init (4),
  3   115 	   algol68_compl_dtype    init (7),
  3   116 	   algol68_long_compl_dtype init (8),
  3   117 	   algol68_bits_dtype     init (19),
  3   118 	   algol68_bool_dtype     init (19),
  3   119 	   algol68_char_dtype     init (21),
  3   120 	   algol68_byte_dtype     init (21),
  3   121 	   algol68_struct_struct_char_dtype init (22),
  3   122 	   algol68_struct_struct_bool_dtype init (20)
  3   123 	   )		      fixed bin internal static options (constant);
  3   124 
  3   125      dcl	   (label_constant_runtime_dtype init (24),
  3   126 	   int_entry_runtime_dtype init (25),
  3   127 	   ext_entry_runtime_dtype init (26),
  3   128 	   ext_procedure_runtime_dtype init (27),
  3   129 	   picture_runtime_dtype  init (63)
  3   130 	   )		      fixed bin internal static options (constant);
  3   131 
  3   132      dcl	   (pascal_integer_dtype  init (1),
  3   133 	   pascal_real_dtype      init (4),
  3   134 	   pascal_label_dtype     init (24),
  3   135 	   pascal_internal_procedure_dtype init (25),
  3   136 	   pascal_exportable_procedure_dtype init (26),
  3   137 	   pascal_imported_procedure_dtype init (27),
  3   138 	   pascal_typed_pointer_type_dtype init (64),
  3   139 	   pascal_char_dtype      init (65),
  3   140 	   pascal_boolean_dtype   init (66),
  3   141 	   pascal_record_file_type_dtype init (67),
  3   142 	   pascal_record_type_dtype init (68),
  3   143 	   pascal_set_dtype	      init (69),
  3   144 	   pascal_enumerated_type_dtype init (70),
  3   145 	   pascal_enumerated_type_element_dtype init (71),
  3   146 	   pascal_enumerated_type_instance_dtype init (72),
  3   147 	   pascal_user_defined_type_dtype init (73),
  3   148 	   pascal_user_defined_type_instance_dtype init (74),
  3   149 	   pascal_text_file_dtype init (75),
  3   150 	   pascal_procedure_type_dtype init (76),
  3   151 	   pascal_variable_formal_parameter_dtype init (77),
  3   152 	   pascal_value_formal_parameter_dtype init (78),
  3   153 	   pascal_entry_formal_parameter_dtype init (79),
  3   154 	   pascal_parameter_procedure_dtype init (80),
  3   155 	   pascal_string_type_dtype init (87)) fixed bin int static options (constant);
  3   156 
  3   157 
  3   158 /* END INCLUDE FILE ... std_descriptor_types.incl.pl1 */
      529 
      530 
  4     1 /* BEGIN INCLUDE FILE - dm_id_list.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION
  4     4*        The id_list structure is used to identify attributes, fields and
  4     5*   dimensions by various modules of the Data Management System.
  4     6**/
  4     7 
  4     8 /* HISTORY:
  4     9*Written by Matthew Pierret, '82.
  4    10*Modified:
  4    11*08/17/83 by Matthew Pierret: Made version constant 'internal static options
  4    12*            (constant)' and to initialize automatic variables.
  4    13**/
  4    14 
  4    15 /* format: style2,ind3 */
  4    16      dcl	   1 id_list	      aligned based (id_list_ptr),
  4    17 	     2 version	      fixed bin (35),
  4    18 	     2 number_of_ids      fixed bin (17),
  4    19 	     2 id		      (il_number_of_ids refer (id_list.number_of_ids)) fixed bin (17);
  4    20 
  4    21      dcl	   id_list_ptr	      ptr init (null);
  4    22      dcl	   il_number_of_ids	      fixed bin (17) init (-1);
  4    23      dcl	   ID_LIST_VERSION_1      fixed bin (17) init (1) internal static options (constant);
  4    24 
  4    25 /* END INCLUDE FILE - dm_id_list.incl.pl1 */
      531 
      532 
  5     1 /* ********** BEGIN INCLUDE FILE dm_field_table.incl.pl1 ********** */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*          The field_table describes the layout of a set of fields in a
  5     6*     formatted data string.  Such a string is the stored representation of a
  5     7*     record or a key.  Fields are placed side-by-side in the string in the
  5     8*     order they appear in the field_table.field array.  The string is divided
  5     9*     into the fixed portion and the varying portion.  In the fixed portion
  5    10*     appear fixed-length fields and fixed-size length-fields for
  5    11*     varying-length fields.  In the varying portion appear varying length
  5    12*     fields.  The length-field for a varying-length field contains the length
  5    13*     of the field values either in bits or in characters, depending on the
  5    14*     data type of the field.
  5    15**/
  5    16 
  5    17 /* HISTORY:
  5    18*Written by Matthew Pierret, 04/01/82.
  5    19*Modified:
  5    20*04/20/82 by Matthew Pierret: Added length_is_in_characters, meaning, if on,
  5    21*	  that if the field is varying, its length is expressed in
  5    22*	  bytes/characters.
  5    23*03/22/83 by Lindsey Spratt:  Changed lofvf to have a precision of 35 instead
  5    24*	  of 17, changed version to 2, changed version field to char(8) from
  5    25*	  fixed bin (17).
  5    26*05/01/84 by Matthew Pierret:  Changed version to 3. Removed field.name and
  5    27*            put field names in one string (field_names) at the end of the 
  5    28*            structure. Added field.location_of_name and field.length_of_name
  5    29*            for locating the field name in field_names. Aligned all "fixed bin"
  5    30*            structure elements.  Changed maximum_field_name_length to 
  5    31*            length_of_field_names.
  5    32**/
  5    33 
  5    34 /* format: style2 */
  5    35 
  5    36      dcl	   1 field_table	      aligned based (field_table_ptr),
  5    37 	     2 version	      char (8) aligned init (FIELD_TABLE_VERSION_3),
  5    38 	     2 number_of_fields   fixed bin (17),
  5    39 	     2 length_of_field_names
  5    40 			      fixed bin (17),	/* length of field_names in characters */
  5    41 	     2 location_of_first_varying_field
  5    42 			      fixed bin (35),	/* location of first bit in the varying portion of the formatted string */
  5    43 	     2 field	      (ft_number_of_fields refer (field_table.number_of_fields)),
  5    44 	       3 flags	      aligned,
  5    45 	         4 descriptor_is_varying
  5    46 			      bit (1) unal,		/* if on, the descriptor is not limited to the standard 36 bits */
  5    47 						/* and is stored in a stand-alone fashion, with field.descriptor */
  5    48 						/* containing the id of the element in which the descriptor is stored. */
  5    49 	         4 length_is_in_characters
  5    50 			      bit (1) unal,		/* if field is varying, the length field describes its length */
  5    51 						/* in characters instead of in bits */
  5    52 	         4 must_be_zero   bit (34) unal,
  5    53 	       3 descriptor	      bit (36) aligned,
  5    54 	       3 location	      fixed bin (35),	/* location of first bit of field in formatted string */
  5    55 	       3 length_in_bits   fixed bin (35),	/* length of field in bits */
  5    56 	     3 location_of_name   fixed bin (17),	/* location of first character of field name in field_names */
  5    57 	     3 length_of_name     fixed bin (17),	/* length of name in characters */
  5    58 	     2 varying_field_map  (ft_number_of_fields refer (field_table.number_of_fields)),
  5    59 	       3 field_id	      fixed bin (17),	/* field_id of Nth varying field */
  5    60 	       3 varying_field_index
  5    61 			      fixed bin (17),	/* ordinality among varying fields of field N */
  5    62 	     2 field_names	      char (ft_length_of_field_names refer (field_table.length_of_field_names));
  5    63 
  5    64 
  5    65      dcl	   field_table_ptr	      ptr;
  5    66      dcl	   ft_length_of_field_names
  5    67 			      fixed bin;
  5    68      dcl	   ft_number_of_fields    fixed bin;
  5    69      dcl	   FIELD_TABLE_VERSION_3  char (8) aligned init ("FldTbl 3") internal static options (constant);
  5    70 
  5    71 dcl field_name char (field_name_length) based (field_name_ptr);
  5    72 
  5    73 dcl field_name_length fixed bin;
  5    74 dcl field_name_ptr ptr;
  5    75 
  5    76 /* END INCLUDE FILE dm_field_table.incl.pl1 */
      533 
      534 
  6     1 /* BEGIN INCLUDE FILE - dm_operator_constants.incl.pl1 */
  6     2 
  6     3 /* Written by Lindsey Spratt, 07/07/82
  6     4*Modified:
  6     5*10/07/82 by Lindsey Spratt:  Added the GREATER, LESS, GREATER_OR_EQUAL,
  6     6*	  LESS_OR_EQUAL and REGULAR_EXPRESSION operator codes.  Also, added
  6     7*	  bit(1) arrays for determining if a given operator code "uses" a
  6     8*	  given operator.  For example, USES_LESS_OPERATOR(x) = "1"b only if
  6     9*	  x = LESS_OPERATOR_CODE or x = LESS_OR_EQUAL_OPERATOR_CODE.
  6    10**/
  6    11 
  6    12 /* format: style2,ind3 */
  6    13      dcl	   (
  6    14 	   EQUAL_OPERATOR_CODE    init (1),
  6    15 	   GREATER_OPERATOR_CODE  init (2),
  6    16 	   LESS_OPERATOR_CODE     init (7),
  6    17 	   REGULAR_EXPRESSION_OPERATOR_CODE
  6    18 			      init (8),
  6    19 	   NOT_EQUAL_OPERATOR_CODE
  6    20 			      init (5),
  6    21 	   GREATER_OR_EQUAL_OPERATOR_CODE
  6    22 			      init (3),
  6    23 	   LESS_OR_EQUAL_OPERATOR_CODE
  6    24 			      init (6),
  6    25 	   EQUAL_IDX	      init (18),
  6    26 	   GREATER_IDX	      init (17),
  6    27 	   NOT_IDX	      init (16),
  6    28 	   REGULAR_EXPRESSION_IDX init (15)
  6    29 	   )		      fixed bin internal static options (constant);
  6    30 
  6    31      dcl	   (
  6    32 	   USES_LESS_OPERATOR     init ("0"b, (5) (1)"0"b, "1"b /* <= */, "1"b /* < */, (24) (1)"0"b),
  6    33 	   USES_GREATER_OPERATOR  init ("0"b, "0"b, "1"b /* > */, "1"b /* >= */, (28) (1)"0"b),
  6    34 	   USES_EQUAL_OPERATOR    init ("0"b, "1"b /* = */, "0"b, "1"b /* >= */, "0"b, "0"b, "1"b /* <= */,
  6    35 			      (25) (1)"0"b),
  6    36 	   USES_REGULAR_EXPRESSION_OPERATOR
  6    37 			      init ("0"b, (7) (1)"0"b, "1"b /* reg exp */, (3) (1)"0"b, "1"b /* not reg exp */,
  6    38 			      (19) (1)"0"b)
  6    39 	   )		      dimension (0:31) bit (1) unaligned internal static options (constant);
  6    40 
  6    41 /* END INCLUDE FILE - dm_operator_constants.incl.pl1 */
      535 
      536 
  7     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  7     2 /* format: style3 */
  7     3 
  7     4 /* These constants are to be used for the flags argument of sub_err_ */
  7     5 /* They are just "string (condition_info_header.action_flags)" */
  7     6 
  7     7 declare	(
  7     8 	ACTION_CAN_RESTART	init (""b),
  7     9 	ACTION_CANT_RESTART init ("1"b),
  7    10 	ACTION_DEFAULT_RESTART
  7    11 			init ("01"b),
  7    12 	ACTION_QUIET_RESTART
  7    13 			init ("001"b),
  7    14 	ACTION_SUPPORT_SIGNAL
  7    15 			init ("0001"b)
  7    16 	)		bit (36) aligned internal static options (constant);
  7    17 
  7    18 /* End include file */
      537 
      538 
  8     1 /* BEGIN INCLUDE FILE ... arg_descriptor.incl.pl1
  8     2*
  8     3*   James R. Davis 1 Mar 79 */
  8     4 /* Modified June 83 JMAthane for extended arg descriptor format */
  8     5 
  8     6      dcl	   1 arg_descriptor	      based (arg_descriptor_ptr) aligned,
  8     7 	     2 flag	      bit (1) unal,
  8     8 	     2 type	      fixed bin (6) unsigned unal,
  8     9 	     2 packed	      bit (1) unal,
  8    10 	     2 number_dims	      fixed bin (4) unsigned unal,
  8    11 	     2 size	      fixed bin (24) unsigned unal;
  8    12 
  8    13      dcl	   1 fixed_arg_descriptor based (arg_descriptor_ptr) aligned,
  8    14 	     2 flag	      bit (1) unal,
  8    15 	     2 type	      fixed bin (6) unsigned unal,
  8    16 	     2 packed	      bit (1) unal,
  8    17 	     2 number_dims	      fixed bin (4) unsigned unal,
  8    18 	     2 scale	      fixed bin (11) unal,
  8    19 	     2 precision	      fixed bin (12) unsigned unal;
  8    20 
  8    21      dcl	   1 extended_arg_descriptor based (arg_descriptor_ptr) aligned,
  8    22 	     2 flag	      bit (1) unal,		/* = "1"b */
  8    23 	     2 type	      fixed bin (6) unsigned unal, /* = 58 */
  8    24 	     2 packed	      bit (1) unal,		/* significant if number_dims ^= 0 */
  8    25 	     2 number_dims	      fixed (4) unsigned unal,/* number of variable dimensions */
  8    26 	     2 size	      bit (24) unal,
  8    27 	     2 dims	      (0 refer (extended_arg_descriptor.number_dims)), /* part referenced by called generated code */
  8    28 	       3 low	      fixed bin (35),
  8    29 	       3 high	      fixed bin (35),
  8    30 	       3 multiplier	      fixed bin (35),	/* in bits if packed, in words if not */
  8    31 	     2 real_type	      fixed bin (18) unsigned unal,
  8    32 	     2 type_offset	      fixed bin (18) unsigned unal; /* offset rel to symbol tree to symbol node for type, if any */
  8    33 
  8    34      dcl	   arg_descriptor_ptr     ptr;
  8    35 
  8    36      dcl	   extended_arg_type      fixed bin init (58);
  8    37 
  8    38 /* END INCLUDE file .... arg_descriptor.incl.pl1  */
      539 
      540    end dmu_compare_sequential;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/24/88  1400.1  dmu_compare_sequential.pl1        >special_ldd>install>MR12.2-1184>dmu_compare_sequential.pl1
525          1    01/07/85  0859.8  dm_specification.incl.pl1         >ldd>include>dm_specification.incl.pl1
527          2    10/14/83  1609.1  dm_specification_head.incl.pl1    >ldd>include>dm_specification_head.incl.pl1
529          3    10/24/88  1336.9  std_descriptor_types.incl.pl1     >special_ldd>install>MR12.2-1184>std_descriptor_types.incl.pl1
531          4    10/14/83  1609.1  dm_id_list.incl.pl1               >ldd>include>dm_id_list.incl.pl1
533          5    01/07/85  0858.8  dm_field_table.incl.pl1           >ldd>include>dm_field_table.incl.pl1
535          6    10/14/83  1609.1  dm_operator_constants.incl.pl1    >ldd>include>dm_operator_constants.incl.pl1
537          7    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
539          8    11/02/83  1845.0  arg_descriptor.incl.pl1           >ldd>include>arg_descriptor.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000020 constant        bit(36)                  initial dcl 7-7 set ref 245* 312*
BITS_PER_BYTE                          constant        fixed bin(17,0)          initial dcl 142 ref 397
DEFAULT_VALUE_LENGTH                   constant        fixed bin(35,0)          initial dcl 143 set ref 272* 340*
EQUAL_IDX                              constant        fixed bin(17,0)          initial dcl 6-13 ref 464
GREATER_IDX                            constant        fixed bin(17,0)          initial dcl 6-13 ref 465
NOT_EQUAL_OPERATOR_CODE                constant        fixed bin(17,0)          initial dcl 6-13 ref 293
NOT_IDX                                constant        fixed bin(17,0)          initial dcl 6-13 ref 440
REGULAR_EXPRESSION_IDX                 constant        fixed bin(17,0)          initial dcl 6-13 ref 439
USES_REGULAR_EXPRESSION_OPERATOR
                                000000 constant        bit(1)                   initial array packed unaligned dcl 6-31 ref 293
addbitno                                               builtin function         dcl 135 ref 380 386 394 402
addr                                                   builtin function         dcl 135 ref 178 235 287 301 453 453
and_group                 6            based           structure                level 2 in structure "simple_search_specification"
                                                                                  packed packed unaligned dcl 118 in procedure
                                                                                  "dmu_compare_sequential"
and_group                 6            based           structure                array level 2 in structure "search_specification"
                                                                                  packed packed unaligned dcl 1-38 in procedure
                                                                                  "dmu_compare_sequential"
and_group_idx                   000102 automatic       fixed bin(17,0)          dcl 98 set ref 196* 201* 284 287
and_group_list_idx              000101 automatic       fixed bin(17,0)          dcl 98 set ref 191* 196*
arg_descriptor                         based           structure                level 1 dcl 8-6
bin                                                    builtin function         dcl 135 ref 387 395
c_code                          000252 automatic       fixed bin(35,0)          dcl 425 set ref 438* 453* 455 457 459* 467* 470* 474
                                                                                  474*
c_invert_spec                   000255 automatic       bit(1)                   dcl 427 set ref 440* 487
c_p_field_descriptor                   based           structure                level 1 packed packed unaligned dcl 432
c_p_field_descriptor_ptr               parameter       pointer                  dcl 418 set ref 410 448 451 467* 470*
c_p_field_value_length                 parameter       fixed bin(35,0)          dcl 421 set ref 410 445 451* 453 467* 470*
c_p_field_value_ptr                    parameter       pointer                  dcl 420 set ref 410 453* 467* 470*
c_p_key_satisfies_specification        parameter       bit(1)                   dcl 422 set ref 410 455* 457* 478* 483* 487* 487
c_p_operator_code_string               parameter       bit                      packed unaligned dcl 414 ref 410 439 440 464 465
c_p_spec_value_length                  parameter       fixed bin(35,0)          dcl 417 set ref 410 467 470*
c_p_spec_value_ptr                     parameter       pointer                  dcl 416 set ref 410 453 453 453 467* 470*
c_spec_equal_to_key             000257 automatic       bit(1)                   dcl 429 set ref 467* 470* 478 478
c_spec_less_than_key            000260 automatic       bit(1)                   dcl 429 set ref 467* 470* 478
c_varying_spec_value                   based           structure                level 1 unaligned dcl 434
c_want_key_equal_to_spec        000253 automatic       bit(1)                   dcl 427 set ref 464* 478
c_want_key_greater_than_spec    000254 automatic       bit(1)                   dcl 427 set ref 465* 478
c_want_key_match_regular_expression
                                000256 automatic       bit(1)                   dcl 427 set ref 439* 442
char_dtype                             constant        fixed bin(17,0)          initial dcl 3-25 ref 448
constraint                6(18)        based           structure                level 3 in structure "simple_search_specification"
                                                                                  packed packed unaligned dcl 118 in procedure
                                                                                  "dmu_compare_sequential"
constraint                6(18)        based           structure                array level 3 in structure "search_specification"
                                                                                  packed packed unaligned dcl 1-38 in procedure
                                                                                  "dmu_compare_sequential" set ref 287
constraint_field_id             000105 automatic       fixed bin(17,0)          dcl 102 set ref 231* 235 237* 289* 293 293 301 303*
constraint_idx                  000103 automatic       fixed bin(17,0)          dcl 98 set ref 284* 287*
constraint_operator_code        000104 automatic       fixed bin(18,0)          packed unsigned unaligned dcl 100 set ref 232* 264
                                                                                  264 272 272 290* 293 293 331 331 340 340
constraint_value_field_id       000106 automatic       fixed bin(17,0)          dcl 102 set ref 233* 239 242* 245 291* 293 306 309*
                                                                                  312
descriptor                6            based           bit(36)                  array level 3 dcl 5-36 set ref 235 245 301 312
dm_error_$unimplemented_data_type
                                000022 external static fixed bin(35,0)          dcl 160 set ref 448*
dmu_compare_values              000012 constant        entry                    external dcl 148 ref 467
dmu_compare_values$field_to_field
                                000014 constant        entry                    external dcl 150 ref 470
er_p_code                              parameter       fixed bin(35,0)          dcl 220 ref 217 222
error_table_$unsupported_operation
                                000020 external static fixed bin(35,0)          dcl 158 set ref 245* 312*
extended_arg_type               000134 automatic       fixed bin(17,0)          initial dcl 8-36 set ref 8-36*
field                     5            based           structure                array level 2 dcl 5-36
field_descriptor                       based           bit(36)                  packed unaligned dcl 116 ref 245 312
field_descriptor_ptr            000116 automatic       pointer                  dcl 110 set ref 235* 237* 242* 245 264* 272* 301*
                                                                                  303* 309* 312 331* 340*
field_id                               based           fixed bin(17,0)          array level 3 in structure "field_table" dcl 5-36
                                                                                  in procedure "dmu_compare_sequential" ref 392
field_id                               based           fixed bin(17,0)          level 2 in structure "this_constraint" packed packed
                                                                                  unaligned dcl 117 in procedure
                                                                                  "dmu_compare_sequential" ref 289
field_id                  6(18)        based           fixed bin(17,0)          level 4 in structure "simple_search_specification"
                                                                                  packed packed unaligned dcl 118 in procedure
                                                                                  "dmu_compare_sequential" ref 231
field_table                            based           structure                level 1 dcl 5-36
field_table_ptr                 000132 automatic       pointer                  dcl 5-65 set ref 167* 235 245 301 312 380 385 386
                                                                                  389 390 392 393 394 397
field_value_length              000107 automatic       fixed bin(35,0)          dcl 106 set ref 237* 264* 272* 303* 331* 340*
field_value_ptr                 000112 automatic       pointer                  dcl 108 set ref 237* 264* 272* 303* 331* 340*
flags                     5            based           structure                array level 3 dcl 5-36
id                        2            based           fixed bin(17,0)          array level 2 dcl 4-16 ref 196
id_list                                based           structure                level 1 dcl 4-16
id_list_ptr                     000126 automatic       pointer                  initial dcl 4-21 set ref 189* 191 191 196 4-21*
il_number_of_ids                000130 automatic       fixed bin(17,0)          initial dcl 4-22 set ref 4-22*
input_key_string_ptr            000120 automatic       pointer                  initial dcl 111 set ref 111* 178* 380 386 394 402
key_satisfies_specification     000100 automatic       bit(1)                   dcl 95 set ref 180* 191 198* 201 204* 211 264* 272*
                                                                                  284 331* 340*
length                                 based           fixed bin(35,0)          level 2 dcl 434 ref 453 453 453
length_in_bits           10            based           fixed bin(35,0)          array level 3 dcl 5-36 ref 385 393
length_is_in_characters
                          5(01)        based           bit(1)                   array level 4 packed packed unaligned dcl 5-36 ref
                                                                                  397
location                  7            based           fixed bin(35,0)          array level 3 dcl 5-36 ref 380 386 394
location_of_first_varying_field
                          4            based           fixed bin(35,0)          level 2 dcl 5-36 ref 389
maximum_number_of_constraints
                          4            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 1-38 ref 284 284
                                                                                  287 287
myname                          000001 constant        varying char(32)         initial dcl 140 set ref 245* 312*
null                                                   builtin function         dcl 135 ref 111 112 191 4-21 245 245 312 312
number_of_and_groups      4(18)        based           fixed bin(17,0)          level 2 in structure "search_specification" packed
                                                                                  packed unaligned dcl 1-38 in procedure
                                                                                  "dmu_compare_sequential" ref 201
number_of_and_groups      4(18)        based           fixed bin(17,0)          level 2 in structure "simple_search_specification"
                                                                                  packed packed unaligned dcl 118 in procedure
                                                                                  "dmu_compare_sequential" ref 182
number_of_constraints
                          6            based           fixed bin(17,0)          array level 3 in structure "search_specification"
                                                                                  packed packed unaligned dcl 1-38 in procedure
                                                                                  "dmu_compare_sequential" ref 284
number_of_constraints
                          6            based           fixed bin(17,0)          level 3 in structure "simple_search_specification"
                                                                                  packed packed unaligned dcl 118 in procedure
                                                                                  "dmu_compare_sequential" ref 182
number_of_fields          2            based           fixed bin(17,0)          level 2 dcl 5-36 ref 390 392
number_of_ids             1            based           fixed bin(17,0)          level 2 dcl 4-16 ref 191
operator_code             7            based           fixed bin(17,0)          level 4 in structure "simple_search_specification"
                                                                                  packed packed unaligned dcl 118 in procedure
                                                                                  "dmu_compare_sequential" ref 232
operator_code             0(18)        based           fixed bin(17,0)          level 2 in structure "this_constraint" packed packed
                                                                                  unaligned dcl 117 in procedure
                                                                                  "dmu_compare_sequential" ref 290
p_and_group_id_list_ptr                parameter       pointer                  dcl 82 ref 71 189
p_code                                 parameter       fixed bin(35,0)          dcl 91 set ref 71 210* 222*
p_field_table_ptr                      parameter       pointer                  dcl 79 ref 71 167
p_key_satisfies_specification          parameter       bit(1)                   dcl 89 set ref 71 211*
p_key_string                           parameter       bit                      packed unaligned dcl 88 set ref 71 178
p_number_of_fully_structural_fields    parameter       fixed bin(17,0)          dcl 84 ref 71 293
p_partial_structural_field_id          parameter       fixed bin(17,0)          dcl 86 ref 71 293
p_search_specification_ptr             parameter       pointer                  dcl 80 ref 71 165
search_file_                    000016 constant        entry                    external dcl 153 ref 453
search_specification                   based           structure                level 1 unaligned dcl 1-38
search_specification_ptr        000124 automatic       pointer                  dcl 1-58 set ref 165* 182 182 201 231 232 233 272
                                                                                  284 287
second_value_length             000110 automatic       fixed bin(35,0)          dcl 106 set ref 242* 264* 309* 331*
second_value_ptr                000114 automatic       pointer                  dcl 108 set ref 242* 264* 309* 331*
simple_search_specification            based           structure                level 1 unaligned dcl 118
size                      0(12)        based           fixed bin(24,0)          level 2 packed packed unsigned unaligned dcl 432 ref
                                                                                  451
specification_head                     based           structure                level 1 unaligned dcl 2-10
spl_descriptor_type             000242 automatic       fixed bin(35,0)          initial dcl 371 set ref 371* 373* 375 375
spl_length_field_length         000236 automatic       fixed bin(35,0)          dcl 365 set ref 385* 387 393* 395
spl_length_field_ptr            000240 automatic       pointer                  dcl 367 set ref 386* 387 394* 395
spl_length_field_string                based           bit                      packed unaligned dcl 368 ref 387 395
spl_p_field_descriptor_ptr             parameter       pointer                  dcl 353 ref 349 373
spl_p_field_id                         parameter       fixed bin(17,0)          dcl 352 ref 349 380 385 386 390
spl_p_field_value_length               parameter       fixed bin(35,0)          dcl 356 set ref 349 379* 387*
spl_p_field_value_ptr                  parameter       pointer                  dcl 355 set ref 349 380* 402*
spl_temp_field_id               000232 automatic       fixed bin(17,0)          dcl 359 set ref 392* 393 394 397
spl_temp_field_value_length     000233 automatic       fixed bin(35,0)          dcl 360 set ref 395* 397 399
spl_varying_field_idx           000234 automatic       fixed bin(17,0)          dcl 362 set ref 390* 392*
spl_varying_field_location      000235 automatic       fixed bin(35,0)          dcl 363 set ref 389* 397* 397 399* 399 402
string                    1            based           char                     level 2 packed packed unaligned dcl 434 set ref 453
                                                                                  453
sub_err_                        000010 constant        entry                    external dcl 147 ref 245 312
substr                                                 builtin function         dcl 135 ref 439 440 464 465
this_constraint                        based           structure                level 1 packed packed unaligned dcl 117
this_constraint_ptr             000122 automatic       pointer                  initial dcl 112 set ref 112* 287* 289 290 291 340
type                      0(01)        based           fixed bin(6,0)           level 2 in structure "arg_descriptor" packed packed
                                                                                  unsigned unaligned dcl 8-6 in procedure
                                                                                  "dmu_compare_sequential" ref 373
type                      0(01)        based           fixed bin(6,0)           level 2 in structure "c_p_field_descriptor" packed
                                                                                  packed unsigned unaligned dcl 432 in procedure
                                                                                  "COMPARE" ref 448
unspec                                                 builtin function         dcl 135 ref 264 264 272 272 331 331 340 340
value_field_id            1            based           fixed bin(17,0)          level 2 in structure "this_constraint" packed packed
                                                                                  unaligned dcl 117 in procedure
                                                                                  "dmu_compare_sequential" ref 291
value_field_id            7(18)        based           fixed bin(17,0)          level 4 in structure "simple_search_specification"
                                                                                  packed packed unaligned dcl 118 in procedure
                                                                                  "dmu_compare_sequential" ref 233
value_ptr                 2            based           pointer                  level 2 in structure "this_constraint" packed packed
                                                                                  unaligned dcl 117 in procedure
                                                                                  "dmu_compare_sequential" ref 340
value_ptr                10(18)        based           pointer                  level 4 in structure "simple_search_specification"
                                                                                  packed packed unaligned dcl 118 in procedure
                                                                                  "dmu_compare_sequential" ref 272
varying_bit_dtype                      constant        fixed bin(17,0)          initial dcl 3-25 ref 375
varying_char_dtype                     constant        fixed bin(17,0)          initial dcl 3-25 ref 375
varying_field_index                    based           fixed bin(17,0)          array level 3 dcl 5-36 ref 390
varying_field_map                      based           structure                array level 2 dcl 5-36

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSOLUTE_NUMERIC_SPECIFICATION_TYPE    internal static fixed bin(17,0)          initial dcl 2-22
ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 2-22
ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 2-22
ABSOLUTE_SEARCH_SPECIFICATION_TYPE     internal static fixed bin(17,0)          initial dcl 2-22
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 7-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 7-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 7-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 7-7
EQUAL_OPERATOR_CODE                    internal static fixed bin(17,0)          initial dcl 6-13
FIELD_TABLE_VERSION_3                  internal static char(8)                  initial dcl 5-69
GREATER_OPERATOR_CODE                  internal static fixed bin(17,0)          initial dcl 6-13
GREATER_OR_EQUAL_OPERATOR_CODE         internal static fixed bin(17,0)          initial dcl 6-13
ID_LIST_VERSION_1                      internal static fixed bin(17,0)          initial dcl 4-23
LESS_OPERATOR_CODE                     internal static fixed bin(17,0)          initial dcl 6-13
LESS_OR_EQUAL_OPERATOR_CODE            internal static fixed bin(17,0)          initial dcl 6-13
NUMERIC_SPECIFICATION_TYPE             internal static fixed bin(17,0)          initial dcl 2-22
REGULAR_EXPRESSION_OPERATOR_CODE       internal static fixed bin(17,0)          initial dcl 6-13
RELATIVE_NUMERIC_SPECIFICATION_TYPE    internal static fixed bin(17,0)          initial dcl 2-22
RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 2-22
RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 2-22
RELATIVE_SEARCH_SPECIFICATION_TYPE     internal static fixed bin(17,0)          initial dcl 2-22
SEARCH_SPECIFICATION_TYPE              internal static fixed bin(17,0)          initial dcl 2-22
SPECIFICATION_VERSION_4                internal static fixed bin(35,0)          initial dcl 2-19
USES_EQUAL_OPERATOR                    internal static bit(1)                   initial array packed unaligned dcl 6-31
USES_GREATER_OPERATOR                  internal static bit(1)                   initial array packed unaligned dcl 6-31
USES_LESS_OPERATOR                     internal static bit(1)                   initial array packed unaligned dcl 6-31
algol68_array_descriptor_dtype         internal static fixed bin(17,0)          initial dcl 3-25
algol68_bits_dtype                     internal static fixed bin(17,0)          initial dcl 3-110
algol68_bool_dtype                     internal static fixed bin(17,0)          initial dcl 3-110
algol68_byte_dtype                     internal static fixed bin(17,0)          initial dcl 3-110
algol68_char_dtype                     internal static fixed bin(17,0)          initial dcl 3-110
algol68_compl_dtype                    internal static fixed bin(17,0)          initial dcl 3-110
algol68_format_dtype                   internal static fixed bin(17,0)          initial dcl 3-25
algol68_int_dtype                      internal static fixed bin(17,0)          initial dcl 3-110
algol68_long_compl_dtype               internal static fixed bin(17,0)          initial dcl 3-110
algol68_long_int_dtype                 internal static fixed bin(17,0)          initial dcl 3-110
algol68_long_real_dtype                internal static fixed bin(17,0)          initial dcl 3-110
algol68_real_dtype                     internal static fixed bin(17,0)          initial dcl 3-110
algol68_short_int_dtype                internal static fixed bin(17,0)          initial dcl 3-110
algol68_straight_dtype                 internal static fixed bin(17,0)          initial dcl 3-25
algol68_struct_struct_bool_dtype       internal static fixed bin(17,0)          initial dcl 3-110
algol68_struct_struct_char_dtype       internal static fixed bin(17,0)          initial dcl 3-110
algol68_union_dtype                    internal static fixed bin(17,0)          initial dcl 3-25
area_dtype                             internal static fixed bin(17,0)          initial dcl 3-25
arg_descriptor_ptr                     automatic       pointer                  dcl 8-34
bit_dtype                              internal static fixed bin(17,0)          initial dcl 3-25
c_enum_const_dtype                     internal static fixed bin(17,0)          initial dcl 3-25
c_enum_dtype                           internal static fixed bin(17,0)          initial dcl 3-25
c_typeref_dtype                        internal static fixed bin(17,0)          initial dcl 3-25
c_union_dtype                          internal static fixed bin(17,0)          initial dcl 3-25
cobol_char_string_dtype                internal static fixed bin(17,0)          initial dcl 3-25
cobol_comp_5_ts_dtype                  internal static fixed bin(17,0)          initial dcl 3-25
cobol_comp_5_uns_dtype                 internal static fixed bin(17,0)          initial dcl 3-25
cobol_comp_6_dtype                     internal static fixed bin(17,0)          initial dcl 3-25
cobol_comp_7_dtype                     internal static fixed bin(17,0)          initial dcl 3-25
cobol_comp_8_ls_dtype                  internal static fixed bin(17,0)          initial dcl 3-25
cobol_comp_8_uns_dtype                 internal static fixed bin(17,0)          initial dcl 3-25
cobol_display_ls_dtype                 internal static fixed bin(17,0)          initial dcl 3-25
cobol_display_ls_overp_dtype           internal static fixed bin(17,0)          initial dcl 3-25
cobol_display_ts_dtype                 internal static fixed bin(17,0)          initial dcl 3-25
cobol_display_ts_overp_dtype           internal static fixed bin(17,0)          initial dcl 3-25
cobol_display_uns_dtype                internal static fixed bin(17,0)          initial dcl 3-25
cobol_structure_dtype                  internal static fixed bin(17,0)          initial dcl 3-25
cplx_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 3-25
cplx_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 3-25
cplx_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 3-25
cplx_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 3-25
cplx_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 3-25
cplx_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 3-25
cplx_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 3-25
cplx_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 3-25
cplx_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 3-25
cplx_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 3-25
cplx_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 3-25
cplx_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 3-25
cplx_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 3-25
entry_dtype                            internal static fixed bin(17,0)          initial dcl 3-25
ext_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 3-125
ext_procedure_runtime_dtype            internal static fixed bin(17,0)          initial dcl 3-125
extended_arg_descriptor                based           structure                level 1 dcl 8-21
field_name                             based           char                     packed unaligned dcl 5-71
field_name_length                      automatic       fixed bin(17,0)          dcl 5-73
field_name_ptr                         automatic       pointer                  dcl 5-74
field_value_offset                     automatic       fixed bin(35,0)          dcl 105
file_dtype                             internal static fixed bin(17,0)          initial dcl 3-25
fixed_arg_descriptor                   based           structure                level 1 dcl 8-13
ft_char_dtype                          internal static fixed bin(17,0)          initial dcl 3-96
ft_complex_double_dtype                internal static fixed bin(17,0)          initial dcl 3-96
ft_complex_dtype                       internal static fixed bin(17,0)          initial dcl 3-96
ft_double_dtype                        internal static fixed bin(17,0)          initial dcl 3-96
ft_external_dtype                      internal static fixed bin(17,0)          initial dcl 3-96
ft_hex_complex_double_dtype            internal static fixed bin(17,0)          initial dcl 3-96
ft_hex_complex_dtype                   internal static fixed bin(17,0)          initial dcl 3-96
ft_hex_double_dtype                    internal static fixed bin(17,0)          initial dcl 3-96
ft_hex_real_dtype                      internal static fixed bin(17,0)          initial dcl 3-96
ft_integer_dtype                       internal static fixed bin(17,0)          initial dcl 3-96
ft_length_of_field_names               automatic       fixed bin(17,0)          dcl 5-66
ft_logical_dtype                       internal static fixed bin(17,0)          initial dcl 3-96
ft_number_of_fields                    automatic       fixed bin(17,0)          dcl 5-68
ft_real_dtype                          internal static fixed bin(17,0)          initial dcl 3-96
int_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 3-125
label_constant_runtime_dtype           internal static fixed bin(17,0)          initial dcl 3-125
label_dtype                            internal static fixed bin(17,0)          initial dcl 3-25
numeric_specification                  based           structure                level 1 unaligned dcl 1-63
numeric_specification_ptr              automatic       pointer                  dcl 1-70
offset_dtype                           internal static fixed bin(17,0)          initial dcl 3-25
pascal_boolean_dtype                   internal static fixed bin(17,0)          initial dcl 3-132
pascal_char_dtype                      internal static fixed bin(17,0)          initial dcl 3-132
pascal_entry_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 3-132
pascal_enumerated_type_dtype           internal static fixed bin(17,0)          initial dcl 3-132
pascal_enumerated_type_element_dtype   internal static fixed bin(17,0)          initial dcl 3-132
pascal_enumerated_type_instance_dtype  internal static fixed bin(17,0)          initial dcl 3-132
pascal_exportable_procedure_dtype      internal static fixed bin(17,0)          initial dcl 3-132
pascal_imported_procedure_dtype        internal static fixed bin(17,0)          initial dcl 3-132
pascal_integer_dtype                   internal static fixed bin(17,0)          initial dcl 3-132
pascal_internal_procedure_dtype        internal static fixed bin(17,0)          initial dcl 3-132
pascal_label_dtype                     internal static fixed bin(17,0)          initial dcl 3-132
pascal_parameter_procedure_dtype       internal static fixed bin(17,0)          initial dcl 3-132
pascal_procedure_type_dtype            internal static fixed bin(17,0)          initial dcl 3-132
pascal_real_dtype                      internal static fixed bin(17,0)          initial dcl 3-132
pascal_record_file_type_dtype          internal static fixed bin(17,0)          initial dcl 3-132
pascal_record_type_dtype               internal static fixed bin(17,0)          initial dcl 3-132
pascal_set_dtype                       internal static fixed bin(17,0)          initial dcl 3-132
pascal_string_type_dtype               internal static fixed bin(17,0)          initial dcl 3-132
pascal_text_file_dtype                 internal static fixed bin(17,0)          initial dcl 3-132
pascal_typed_pointer_type_dtype        internal static fixed bin(17,0)          initial dcl 3-132
pascal_user_defined_type_dtype         internal static fixed bin(17,0)          initial dcl 3-132
pascal_user_defined_type_instance_dtype
                                       internal static fixed bin(17,0)          initial dcl 3-132
pascal_value_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 3-132
pascal_variable_formal_parameter_dtype internal static fixed bin(17,0)          initial dcl 3-132
picture_runtime_dtype                  internal static fixed bin(17,0)          initial dcl 3-125
pointer_dtype                          internal static fixed bin(17,0)          initial dcl 3-25
real_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 3-25
real_fix_bin_1_uns_dtype               internal static fixed bin(17,0)          initial dcl 3-25
real_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 3-25
real_fix_bin_2_uns_dtype               internal static fixed bin(17,0)          initial dcl 3-25
real_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 3-25
real_fix_dec_4bit_bytealigned_uns_dtype
                                       internal static fixed bin(17,0)          initial dcl 3-25
real_fix_dec_4bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 3-25
real_fix_dec_4bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 3-25
real_fix_dec_4bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 3-25
real_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 3-25
real_fix_dec_9bit_ls_overp_dtype       internal static fixed bin(17,0)          initial dcl 3-25
real_fix_dec_9bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 3-25
real_fix_dec_9bit_ts_overp_dtype       internal static fixed bin(17,0)          initial dcl 3-25
real_fix_dec_9bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 3-25
real_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 3-25
real_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 3-25
real_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 3-25
real_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 3-25
real_flt_dec_4bit_dtype                internal static fixed bin(17,0)          initial dcl 3-25
real_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 3-25
real_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 3-25
real_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 3-25
real_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 3-25
real_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 3-25
specification_head_ptr                 automatic       pointer                  dcl 2-18
ss_maximum_number_of_constraints       automatic       fixed bin(17,0)          dcl 1-60
ss_number_of_and_groups                automatic       fixed bin(17,0)          dcl 1-60
structure_dtype                        internal static fixed bin(17,0)          initial dcl 3-25

NAMES DECLARED BY EXPLICIT CONTEXT.
AND_GROUP_LIST_LOOP             000137 constant        label                    dcl 191
AND_GROUP_LOOP                  000163 constant        label                    dcl 201
CHECK_CONSTRAINT                000470 constant        label                    dcl 293
COMPARE                         000763 constant        entry                    internal dcl 410 ref 264 272 331 340
COMPARE_AND_GROUP               000353 constant        entry                    internal dcl 282 ref 199 205
COMPARE_AND_GROUPS              000130 constant        label                    dcl 185
COMPARE_CONSTRAINT              000222 constant        entry                    internal dcl 227 ref 182
ERROR_RETURN                    000214 constant        entry                    internal dcl 217 ref 448 459 474
MAIN_RETURN                     000207 constant        label                    dcl 211 ref 223
PREPARE_NONVARYING_FIELD        000620 constant        label                    dcl 375
PREPARE_VARYING_FIELD           000636 constant        label                    dcl 382
SETUP_PTR_AND_LENGTH            000604 constant        entry                    internal dcl 349 ref 237 242 303 309
SET_VARYING_FIELD_VALUE_OFFSET  000664 constant        label                    dcl 390
dmu_compare_sequential          000060 constant        entry                    external dcl 71

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1610        1634    1474        1620
Length      2214    1474        24         344     114           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
dmu_compare_sequential              310 external procedure  is an external procedure.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure dmu_compare_sequential.  
COMPARE_CONSTRAINT                      internal procedure  shares stack frame of external procedure dmu_compare_sequential.  
COMPARE_AND_GROUP                       internal procedure  shares stack frame of external procedure dmu_compare_sequential.  
SETUP_PTR_AND_LENGTH                    internal procedure  shares stack frame of external procedure dmu_compare_sequential.  
COMPARE                                 internal procedure  shares stack frame of external procedure dmu_compare_sequential.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
dmu_compare_sequential   000100 key_satisfies_specification dmu_compare_sequential
                         000101 and_group_list_idx          dmu_compare_sequential
                         000102 and_group_idx               dmu_compare_sequential
                         000103 constraint_idx              dmu_compare_sequential
                         000104 constraint_operator_code    dmu_compare_sequential
                         000105 constraint_field_id         dmu_compare_sequential
                         000106 constraint_value_field_id   dmu_compare_sequential
                         000107 field_value_length          dmu_compare_sequential
                         000110 second_value_length         dmu_compare_sequential
                         000112 field_value_ptr             dmu_compare_sequential
                         000114 second_value_ptr            dmu_compare_sequential
                         000116 field_descriptor_ptr        dmu_compare_sequential
                         000120 input_key_string_ptr        dmu_compare_sequential
                         000122 this_constraint_ptr         dmu_compare_sequential
                         000124 search_specification_ptr    dmu_compare_sequential
                         000126 id_list_ptr                 dmu_compare_sequential
                         000130 il_number_of_ids            dmu_compare_sequential
                         000132 field_table_ptr             dmu_compare_sequential
                         000134 extended_arg_type           dmu_compare_sequential
                         000232 spl_temp_field_id           SETUP_PTR_AND_LENGTH
                         000233 spl_temp_field_value_length SETUP_PTR_AND_LENGTH
                         000234 spl_varying_field_idx       SETUP_PTR_AND_LENGTH
                         000235 spl_varying_field_location  SETUP_PTR_AND_LENGTH
                         000236 spl_length_field_length     SETUP_PTR_AND_LENGTH
                         000240 spl_length_field_ptr        SETUP_PTR_AND_LENGTH
                         000242 spl_descriptor_type         SETUP_PTR_AND_LENGTH
                         000252 c_code                      COMPARE
                         000253 c_want_key_equal_to_spec    COMPARE
                         000254 c_want_key_greater_than_spec
                                                            COMPARE
                         000255 c_invert_spec               COMPARE
                         000256 c_want_key_match_regular_expression
                                                            COMPARE
                         000257 c_spec_equal_to_key         COMPARE
                         000260 c_spec_less_than_key        COMPARE

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          longbs_to_fx2       ext_entry_desc      set_bits_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
dmu_compare_values            dmu_compare_values$field_to_field                           search_file_
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$unimplemented_data_type                           error_table_$unsupported_operation




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     71 000051       111 000073       112 000075    4   21 000076    4   22 000077    8   36 000101       165 000103
    167 000107       178 000112       180 000114       182 000115       189 000130       191 000133       196 000152
    198 000155       199 000157       200 000160       201 000163       204 000200       205 000202       206 000203
    210 000205       211 000207       214 000213       217 000214       222 000216       223 000221       227 000222
    231 000223       232 000230       233 000233       235 000237       237 000243       239 000245       242 000247
    245 000251       264 000325       268 000333       272 000334       278 000352       282 000353       284 000354
    287 000404       289 000426       290 000434       291 000441       293 000447       301 000470       303 000474
    306 000476       309 000500       312 000502       331 000556       336 000564       340 000565       346 000601
    347 000603       349 000604       371 000606       373 000607       375 000614       379 000620       380 000622
    381 000635       385 000636       386 000644       387 000654       389 000662       390 000664       392 000703
    393 000714       394 000720       395 000730       397 000734       399 000743       400 000747       402 000751
    405 000762       410 000763       438 000774       439 000775       440 001003       442 001007       445 001011
    448 001014       451 001034       453 001045       455 001112       457 001120       459 001125       461 001127
    464 001130       465 001134       467 001140       470 001167       474 001214       478 001220       483 001241
    487 001243       490 001252


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
