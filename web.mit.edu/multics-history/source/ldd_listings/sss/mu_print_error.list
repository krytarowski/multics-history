	COMPILATION LISTING OF SEGMENT mu_print_error
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1333.9 mst Mon
	    Options: optimize map

        1 /****^  ********************************************
        2*        *                                          *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988 *
        4*        *                                          *
        5*        ******************************************** */
        6 
        7 
        8 
        9 /****^  HISTORY COMMENTS:
       10*  1) change(87-01-22,Hergert), approve(88-07-11,MCR7903),
       11*     audit(88-07-08,Dupuis), install(88-08-01,MR12.2-1073):
       12*     Written.
       13*                                                   END HISTORY COMMENTS */
       14 
       15 
       16 mu_print_error:
       17     proc (a_se_info_ptr);
       18 
       19 /*   DESCRIPTION
       20*
       21*   The purpose of this procedure is to try and print some form of intelligent
       22*   error message from the parser when syntax errors are discovered in the
       23*   parsing of a selection expression.
       24*
       25*   HISTORY:
       26*
       27*   84-11-05 Originally written by John Hergert (FMC).
       28*
       29*   86-02-25 John Hergert: modified for new parser.
       30*
       31*   INPUT CONDITIONS:
       32*
       33*   se_info_ptr points to the se_info structure which has all the info to print
       34*
       35*
       36*   OUTPUT DEFINITIONS:
       37*
       38*   This routine calls ioa_ with a formatted selection expression and
       39*   the error code generated in the parse after signalling mrds_se_error_.
       40*
       41**/
       42 
       43         se_info_ptr = a_se_info_ptr;
       44 
       45         if se_info.se_length = 0 then return;
       46 
       47         se_len = se_info.se_length;
       48         se_ptr = se_info.se_ptr;
       49         call init_sex;				/* make local copy of sex */
       50 
       51         on cleanup free sex in (work_area);
       52 
       53         if se_info.token_start > se_info.se_length
       54         then
       55 	   raw_token_position, token_position = se_info.se_length;
       56         else raw_token_position, token_position = se_info.token_start;
       57 
       58         token_ptr = addcharno(se_info.se_ptr,se_info.token_start-1);
       59 
       60         call format_sex;
       61 
       62 /* now put in the pointer to the offending token */
       63 
       64         current_NL = 1;
       65         done = "0"b;
       66         do while (^done);
       67 	  next_NL = index (substr (sex || NL, current_NL), NL);
       68 	  if token_position >= next_NL then do;
       69 	      token_position = token_position - next_NL + 1;
       70 	      current_NL = current_NL + next_NL;
       71 	  end;
       72 	  else do;
       73 	      if current_NL + next_NL < length (sex)	/* we are not in the last line */
       74 	      then sex =
       75 		     substr (sex, 1, current_NL + next_NL - 1)
       76 						/* first portion of se */
       77 		     || copy (" ", token_position - 1) || "^"
       78 		     || NL			/* the pointer */
       79 		     || substr (sex, current_NL + next_NL);
       80 						/* the second portion of the se */
       81 
       82 	      else sex = sex || NL || copy (" ", token_position - 1) || "^";
       83 	      done = "1"b;
       84 	  end;
       85         end;
       86 
       87         call convert_status_code_ (se_info.error_code, short_message,
       88 	  long_message);
       89 						/* get english error message */
       90 
       91         msei.header.version = error_info_version;
       92         msei.header.action_flags.cant_restart = "0"b;
       93         msei.header.action_flags.default_restart = "1"b;
       94         msei.header.action_flags.quiet_restart = "0"b;
       95         msei.header.action_flags.support_signal = "1"b;
       96         msei.header.action_flags.pad = "0"b;
       97         msei.header.info_string = "";			/* used by default_error_handler_ */
       98         msei.header.status_code = se_info.error_code;
       99         msei.error_type = se_info.error_type;
      100         msei.error_msg = se_info.error_msg;
      101         msei.token = token;
      102         msei.raw_select_expr.se_ptr = se_info.se_ptr;
      103         msei.raw_select_expr.se_len = se_info.se_length;
      104         msei.raw_select_expr.token_position = raw_token_position;
      105         msei.formatted_select_expr.se_ptr = addr (sex);
      106         msei.formatted_select_expr.se_len = length (sex);
      107         msei.formatted_select_expr.token_position = token_position;
      108         msei.header.length = size (msei);
      109 
      110         call signal_ ("mrds_se_error_", null, addr (msei), null);
      111 						/* see if anyone wants to handle it. */
      112 
      113 /* if no one handles the signal the default_error_handler_ will just
      114*   put the string "default_error_handler_" into info_string. */
      115 
      116         if msei.header.info_string = "default_error_handler_"
      117 						/* user didnt handle it */
      118         then
      119 	   call ioa_$ioa_switch (iox_$error_output,
      120 	       "^2/Error: MRDS ^a error.^/^a^/^[^s^;^a^/^]^a^/",
      121 	       rtrim (se_info.error_type), rtrim (long_message),
      122 	       se_info.error_msg = " ", rtrim (se_info.error_msg),
      123 	       rtrim (sex));
      124 
      125         free sex in (work_area);
      126 
      127         return;
      128 
      129 print_se:
      130     entry (a_se_ptr, a_se_len);
      131 
      132 /* entry to just print out formatted selection expression */
      133 
      134         if se_len ^= 0 then do;
      135 	  se_ptr = a_se_ptr;
      136 	  se_len = a_se_len;
      137 	  call init_sex;				/* make a local copy of sex */
      138 	  on cleanup free sex in (work_area);
      139 
      140 	  call format_sex;
      141 	  call ioa_ ("^/^a^/", rtrim (sex));
      142 	  free sex in (work_area);
      143         end;
      144 
      145         return;
      146 
      147 format_sex:
      148     proc;
      149 						/*
      150*						   procedure to format the selection expression by putting newlines in before
      151*						   keywords
      152*						*/
      153 						/* put NL's in to sex before each keyword */
      154 
      155         do j = 1 to hbound (keyword.name, 1);		/* for each keyword */
      156 	  if keyword.major_keyword (j) then do;
      157 	      i = verify (sex, WHITE_SPACE) + 1;	/* start after the first keyword */
      158 	      done = "0"b;
      159 	      do while (^done);			/* until end of sex is reached */
      160 		if i < length (sex) then do;
      161 		    x = index (substr (sex, i), rtrim (keyword.name (j)));
      162 		    if x ^= 0 then do;
      163 		        sex = substr (sex, 1, x + i - 2) || NL
      164 			  || substr (sex, x + i - 1);
      165 		        i = x + i + 4;		/* skip past the NL and the token */
      166 		    end;
      167 		    else done = "1"b;
      168 		end;
      169 		else done = "1"b;
      170 	      end;
      171 	  end;
      172         end;
      173 
      174 
      175 
      176 /* break each line into no more than 79 chars */
      177 
      178         current_NL = 1;
      179         done = "0"b;
      180 
      181         do while (^done);
      182 	  if current_NL < length (sex) then do;
      183 	      next_NL = index (substr (sex || NL, current_NL), NL);
      184 	      if next_NL > 79 then do;
      185 		i = index (reverse (substr (sex, 1, current_NL + 79)), SP);
      186 		if i < 80 then do;
      187 		    sex = substr (sex, 1, current_NL + 80 - i) || NL
      188 		        || substr (sex, current_NL + 81 - i);
      189 		    current_NL = current_NL + 82 - i;
      190 		end;
      191 		else done = "1"b;
      192 	      end;
      193 	      else if next_NL = 0
      194 		 then done = "1"b;
      195 		 else current_NL = current_NL + next_NL + 1;
      196 	  end;
      197 	  else done = "1"b;
      198         end;
      199 
      200     end format_sex;
      201 
      202 init_sex:
      203     proc;
      204 
      205 /* Since we are going to be manipulating the selection expression we need
      206*   to make a local copy. Since we have no idea how big it is going to get
      207*   we need to put it somewhere out of the way
      208**/
      209 
      210         work_area_ptr = get_system_free_area_ ();
      211         allocate sex in (work_area) set (sex_ptr);
      212 
      213         sex = arg_sex;
      214 
      215     end;
      216 
  1     1 /* BEGIN INCLUDE FILE  mrds_se_info.incl.pl1 
  1     2*
  1     3*   These contains information relating to the selection expression.
  1     4*
  1     5**/
  1     6 
  1     7 /****^  HISTORY COMMENTS:
  1     8*  1) change(85-08-05,Hergert), approve(88-06-28,MCR7903),
  1     9*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  1    10*     Created for for new parser.
  1    11*                                                   END HISTORY COMMENTS */
  1    12 
  1    13 dcl     1 se_info		 aligned based (se_info_ptr),
  1    14 	2 se_ptr		 ptr,			/* points to the beginning of the selection expression */
  1    15 	2 se_length	 fixed bin,		/* length of the selection expression */
  1    16 	2 se_cursor	 fixed bin,		/* current place in se */
  1    17 	2 flags,
  1    18 	  3 pso_seen	 bit,			/* -pso supplied in se */
  1    19 	  3 no_ot_seen	 bit,			/* -no_ot supplied in se */
  1    20           2 error_report,
  1    21 	  3 error_info_supplied bit aligned,              /* ON -> structure already filled in */
  1    22 	  3 loud             bit aligned,                	/* ON -> call mu_print_error */
  1    23             3 token_start      fixed bin,                   /* position in se where token starts */
  1    24             3 token_length     fixed bin,                   /* length of token in se */
  1    25 	  3 error_code       fixed bin(35),               /* system error code */
  1    26             3 stack_offset     fixed bin,                   /* how far down the token is in the lex stack */
  1    27             3 error_type       char(24),                    /* type of error. ie range, select where... */
  1    28 	  3 error_msg        char(256);         	/* message to explain problem */
  1    29 
  1    30 
  1    31 /* various types of errors. actually the string that is reported in the
  1    32*   error message. */
  1    33 dcl     RC_TYPE		 char (12) internal static
  1    34 			 options (constant) init ("Range Clause");
  1    35 dcl     SE_TYPE		 char (20) internal static
  1    36 			 options (constant)
  1    37 			 init ("Selection Expression");
  1    38 dcl     SC_TYPE		 char (13) internal static
  1    39 			 options (constant)
  1    40 			 init ("Select Clause");
  1    41 dcl     WC_TYPE		 char (12) internal static
  1    42 			 options (constant)
  1    43 			 init ("Where Clause");
  1    44 dcl     WCE_TYPE		 char (23) internal static
  1    45 			 options (constant)
  1    46 			 init ("Where Clause Expression");
  1    47 dcl     WCF_TYPE		 char (21) internal static
  1    48 			 options (constant)
  1    49 			 init ("Where Clause Function");
  1    50 dcl     AV_TYPE		 char (16) internal static
  1    51 			 options (constant)
  1    52 			 init ("Access Violation");
  1    53 dcl     IL_TYPE		 char (14) internal static
  1    54 			 options (constant)
  1    55 			 init ("Internal Logic");
  1    56 
  1    57 /* parser_work_area is used to hold all static data for an invocation
  1    58*   of the parser. parser_static_info holds ptrs to all of these relevant
  1    59*   data and also a ptr back to the area it is allocated in. 
  1    60*   parser_work_area.
  1    61**/
  1    62 
  1    63 dcl parser_work_area aligned area (sys_info$max_seg_size) based (parser_static_info.pwa_ptr);
  1    64 
  1    65 dcl psi_ptr ptr;
  1    66 dcl 1 parser_static_info aligned based (psi_ptr),
  1    67       2 pwa_ptr ptr,
  1    68       2 semantics, /* for mrds_dsl_semantics */
  1    69         3 static_data_ptr ptr,
  1    70       2 expr, /* for mrds_dsl_expr_ */
  1    71         3 data_stacks_ptr ptr,
  1    72       2 func, /* for mrds_dsl_func_ */
  1    73         3 sfptrs_ptr ptr,
  1    74       2 where_clause, /* for mrds_dsl_where_clause_ */
  1    75         3 ns_ptr ptr;
  1    76 
  1    77 
  1    78 /* END INCLUDE FILE  mrds_se_info.incl.pl1 */
      217 
      218 
  2     1 /* BEGIN INCLUDE FILE ..... mrds_dsl_keywords.incl.pl1 ..... 03/17/87  1851.1 est Tue kwsl (generated) */
  2     2 	/* Keywords from >user_dir_dir>MRDS>Hergert>p>mrds_dsl.grammar
  2     3*	   Generated from >udd>MRDS>Hergert>p>mrds_dsl.lalr
  2     4*	   by Hergert.MRDS.a                  
  2     5*	   at Ford ECC Multics A              
  2     6*	   on 03/17/87  1825.8 est Tue */
  2     7 
  2     8 /* this is the list of keywords and their synonyms that are known to the scanner. */
  2     9 
  2    10 /****^  HISTORY COMMENTS:
  2    11*  1) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  2    12*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  2    13*     Created for for new parser.
  2    14*                                                   END HISTORY COMMENTS */
  2    15 
  2    16 dcl 1 keyword aligned internal static options (constant),
  2    17     2 name (74) unaligned char (24) init(
  2    18 	/*   1 */	"&",                    /*   1 &                   */
  2    19 	/*   2 */	"(",                    /*   2 (                   */
  2    20 	/*   3 */	"(+)",                  /*   3 (+)                 */
  2    21 	/*   4 */	")",                    /*   4 )                   */
  2    22 	/*   5 */	"*",                    /*   5 *                   */
  2    23 	/*   6 */	"+",                    /*   6 +                   */
  2    24 	/*   7 */	",",                    /*   7 ,                   */
  2    25 	/*   8 */	"-",                    /*   8 -                   */
  2    26 	/*   9 */	"-all_of",              /*   9 -all_of             */
  2    27 	/*  10 */	"-and",                 /*   1 &                   */
  2    28 	/*  11 */	"-any_of",              /*  10 -any_of             */
  2    29 	/*  12 */	"-ascending",           /*  11 -ascending          */
  2    30 	/*  13 */	"-current",             /*  12 -current            */
  2    31 	/*  14 */	"-descending",          /*  13 -descending         */
  2    32 	/*  15 */	"-differ",              /*  14 -differ             */
  2    33 	/*  16 */	"-distinct",            /*  15 -distinct           */
  2    34 	/*  17 */	"-dup",                 /*  16 -dup                */
  2    35 	/*  18 */	"-from",                /*  33 -range              */
  2    36 	/*  19 */	"-group_by",            /*  17 -group_by           */
  2    37 	/*  20 */	"-having",              /*  18 -having             */
  2    38 	/*  21 */	"-inter",               /*  19 -inter              */
  2    39 	/*  22 */	"-is_between",          /*  20 -is_between         */
  2    40 	/*  23 */	"-is_in",               /*  21 -is_in              */
  2    41 	/*  24 */	"-is_like",             /*  22 -is_like            */
  2    42 	/*  25 */	"-is_not_between",      /*  23 -is_not_between     */
  2    43 	/*  26 */	"-is_not_in",           /*  24 -is_not_in          */
  2    44 	/*  27 */	"-is_not_like",         /*  25 -is_not_like        */
  2    45 	/*  28 */	"-is_not_null",         /*  26 -is_not_null        */
  2    46 	/*  29 */	"-is_null",             /*  27 -is_null            */
  2    47 	/*  30 */	"-no_optimize",         /*  28 -no_optimize        */
  2    48 	/*  31 */	"-no_ot",               /*  29 -no_ot              */
  2    49 	/*  32 */	"-not",                 /*  53 ^                   */
  2    50 	/*  33 */	"-or",                  /*  55 |                   */
  2    51 	/*  34 */	"-order_by",            /*  30 -order_by           */
  2    52 	/*  35 */	"-print_search_order",  /*  31 -print_search_order */
  2    53 	/*  36 */	"-pso",                 /*  32 -pso                */
  2    54 	/*  37 */	"-range",               /*  33 -range              */
  2    55 	/*  38 */	"-select",              /*  34 -select             */
  2    56 	/*  39 */	"-union",               /*  35 -union              */
  2    57 	/*  40 */	"-where",               /*  36 -where              */
  2    58 	/*  41 */	".",                    /*  37 .                   */
  2    59 	/*  42 */	".V.",                  /*  38 .V.                 */
  2    60 	/*  43 */	".X.",                  /*  39 .X.                 */
  2    61 	/*  44 */	".v.",                  /*  38 .V.                 */
  2    62 	/*  45 */	".x.",                  /*  39 .X.                 */
  2    63 	/*  46 */	"/",                    /*  40 /                   */
  2    64 	/*  47 */	"::",                   /*  41 ::                  */
  2    65 	/*  48 */	"<",                    /*  42 <                   */
  2    66 	/*  49 */	"<=",                   /*  43 <=                  */
  2    67 	/*  50 */	"<>",                   /*  54 ^=                  */
  2    68 	/*  51 */	"<bit_string>",         /*  44 <bit_string>        */
  2    69 	/*  52 */	"<integer>",            /*  45 <integer>           */
  2    70 	/*  53 */	"<string>",             /*  46 <string>            */
  2    71 	/*  54 */	"<symbol>",             /*  47 <symbol>            */
  2    72 	/*  55 */	"=",                    /*  48 =                   */
  2    73 	/*  56 */	"=<",                   /*  43 <=                  */
  2    74 	/*  57 */	"=>",                   /*  50 >=                  */
  2    75 	/*  58 */	">",                    /*  49 >                   */
  2    76 	/*  59 */	"><",                   /*  54 ^=                  */
  2    77 	/*  60 */	">=",                   /*  50 >=                  */
  2    78 	/*  61 */	"[",                    /*  51 [                   */
  2    79 	/*  62 */	"]",                    /*  52 ]                   */
  2    80 	/*  63 */	"^",                    /*  53 ^                   */
  2    81 	/*  64 */	"^<",                   /*  50 >=                  */
  2    82 	/*  65 */	"^<=",                  /*  49 >                   */
  2    83 	/*  66 */	"^<>",                  /*  48 =                   */
  2    84 	/*  67 */	"^=",                   /*  54 ^=                  */
  2    85 	/*  68 */	"^=<",                  /*  49 >                   */
  2    86 	/*  69 */	"^=>",                  /*  42 <                   */
  2    87 	/*  70 */	"^>",                   /*  43 <=                  */
  2    88 	/*  71 */	"^><",                  /*  48 =                   */
  2    89 	/*  72 */	"^>=",                  /*  42 <                   */
  2    90 	/*  73 */	"|",                    /*  55 |                   */
  2    91 	/*  74 */	"||"),                  /*  56 ||                  */
  2    92 
  2    93 /* This table contains the codes that are known to the parser. One code
  2    94*   per token. Synonomous tokens have the same code. */
  2    95     2 value (74) fixed bin init (
  2    96 	1,	2,	3,	4,	5,	6,	7,
  2    97 	8,	9,	1,	10,	11,	12,	13,
  2    98 	14,	15,	16,	33,	17,	18,	19,
  2    99 	20,	21,	22,	23,	24,	25,	26,
  2   100 	27,	28,	29,	53,	55,	30,	31,
  2   101 	32,	33,	34,	35,	36,	37,	38,
  2   102 	39,	38,	39,	40,	41,	42,	43,
  2   103 	54,	44,	45,	46,	47,	48,	43,
  2   104 	50,	49,	54,	50,	51,	52,	53,
  2   105 	50,	49,	48,	54,	49,	42,	43,
  2   106 	48,	42,	55,	56),
  2   107 
  2   108 /* This table is used for error reporting. It decides that the keyword is
  2   109*   a "major" one. These currently are -differ, -range, -group_by, -having,
  2   110*   -inter, -order_by, -from, -select, -union, -where */
  2   111     2 major_keyword (74) bit unaligned init (
  2   112 /* 1-7   */ "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,
  2   113 /* 8-14  */ "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,
  2   114 /* 15-21 */ "1"b,     "0"b,     "0"b,     "1"b,     "1"b,     "1"b,     "1"b,
  2   115 /* 22-28 */ "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,
  2   116 /* 29-35 */ "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "1"b,     "0"b,
  2   117 /* 36-42 */ "0"b,     "1"b,     "1"b,     "1"b,     "1"b,     "0"b,     "0"b,
  2   118 /* 43-49 */ "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,
  2   119 /* 50-56 */ "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,
  2   120 /* 57-63 */ "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,
  2   121 /* 64-70 */ "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,
  2   122 /* 71-74 */ "0"b,     "0"b,     "0"b,     "0"b);
  2   123          
  2   124 /*   END INCLUDE FILE ..... mrds_dsl_keywords.incl.pl1 ..... */
      219 
      220 
  3     1 /* BEGIN INCLUDE FILE  mrds_se_error_info.incl.pl1
  3     2*
  3     3*   This include file contains the info structure for the "mrds_se_error_"
  3     4*   condition. This condition is signalled by MRDS when a syntax error
  3     5*   in a selection expression is uncovered.
  3     6*
  3     7*   This include file must be used with condition_info_header.incl.pl1
  3     8*
  3     9*   17-09-85 John Hergert (FMC) Written.
  3    10*
  3    11**/
  3    12 
  3    13 /****^  HISTORY COMMENTS:
  3    14*  1) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  3    15*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  3    16*     Created for for new parser.
  3    17*                                                   END HISTORY COMMENTS */
  3    18 
  3    19 dcl     mrds_se_error_info_ptr ptr;			/* pointer to info struct */
  3    20 
  3    21 dcl     1 mrds_se_error_info	 aligned based (mrds_se_error_info_ptr),
  3    22 	2 header		 aligned like condition_info_header,
  3    23 						/* necessary for all info structs */
  3    24 	2 error_type	 char (32),		/* range, select... */
  3    25           2 error_msg          char (256),                  /* informational msg */
  3    26 	2 token		 char (mrds_data_$max_token_size), /* last known token */
  3    27 	2 raw_select_expr,
  3    28 	  3 se_ptr	 ptr,			/* ptr to the actual se */
  3    29 	  3 se_len	 fixed bin,		/* length of actual se */
  3    30 	  3 token_position	 fixed bin,		/* where the token starts in raw_select_expr */
  3    31 	2 formatted_select_expr,
  3    32 	  3 se_ptr	 ptr,			/* ptr to "pretty" se */
  3    33 	  3 se_len	 fixed bin,		/* length of "pretty" se */
  3    34 	  3 token_position	 fixed bin;         	/* where the token starts in formatted_select_expr */
  3    35 
  3    36 dcl error_info_version fixed bin init(1) internal static options (constant);
  3    37 dcl     mrds_data_$max_token_size
  3    38 			 ext fixed bin (35);
  3    39 
  3    40 /* END INCLUDE FILE  mrds_se_error_info.incl.pl1 */
      221 
      222 
  4     1 /* BEGIN INCLUDE FILE condition_info_header.incl.pl1 BIM 1981 */
  4     2 /* format: style2 */
  4     3 
  4     4      declare condition_info_header_ptr
  4     5 			      pointer;
  4     6      declare 1 condition_info_header
  4     7 			      aligned based (condition_info_header_ptr),
  4     8 	     2 length	      fixed bin,		/* length in words of this structure */
  4     9 	     2 version	      fixed bin,		/* version number of this structure */
  4    10 	     2 action_flags	      aligned,		/* tell handler how to proceed */
  4    11 	       3 cant_restart     bit (1) unaligned,	/* caller doesn't ever want to be returned to */
  4    12 	       3 default_restart  bit (1) unaligned,	/* caller can be returned to with no further action */
  4    13 	       3 quiet_restart    bit (1) unaligned,	/* return, and print no message */
  4    14 	       3 support_signal   bit (1) unaligned,	/* treat this signal as if the signalling procedure had the support bit set */
  4    15 						/* if the signalling procedure had the support bit set, do the same for its caller */
  4    16 	       3 pad	      bit (32) unaligned,
  4    17 	     2 info_string	      char (256) varying,	/* may contain printable message */
  4    18 	     2 status_code	      fixed bin (35);	/* if^=0, code interpretable by com_err_ */
  4    19 
  4    20 /* END INCLUDE FILE condition_info_header.incl.pl1 */
      223 
      224 
      225 /* ARGS */
      226 dcl     a_se_info_ptr	 ptr parameter;
      227 dcl     a_se_ptr		 ptr parameter;
      228 dcl     a_se_len		 fixed bin (17) parameter;
      229 
      230 
      231 /* LOCALS */
      232 
      233 dcl     se_info_ptr		 ptr;
      234 dcl     work_area_ptr	 ptr;
      235 dcl     sex_ptr		 ptr;
      236 
      237 dcl     1 msei		 aligned like mrds_se_error_info;
      238 						/* the working copy */
      239 
      240 dcl     short_message	 char (8) aligned;
      241 dcl     long_message	 char (100) aligned;
      242 dcl     token		 char (se_info.token_length) based (token_ptr);
      243 dcl     token_ptr              ptr;
      244 
      245 dcl     (raw_token_position, token_position, current_NL, next_NL, i, j, x)
      246 			 fixed bin;
      247 dcl     done		 bit;
      248 dcl     WHITE_SPACE		 char (6) based (addr (WHITE_SPACE_data));
      249 dcl     WHITE_SPACE_data	 (6) bit (9) unaligned internal static
      250 			 options (constant)
      251 			 init ("011"b3, "012"b3, "013"b3, "014"b3,
      252 			 "015"b3, "040"b3);		/* HT LF VT FF CR SP */
      253 dcl     NL		 char (1) based (addr(NL_data));
      254 dcl NL_data bit(9) internal static options (constant) init("012"b3);
      255 dcl     SP		 char (1) internal static options (constant)
      256 			 init (" ");
      257 
      258 dcl     se_ptr		 ptr;
      259 dcl     se_len		 fixed bin;
      260 dcl     arg_sex		 char (se_len) based (se_ptr);
      261 dcl     sex		 char (se_len + 256) var based (sex_ptr);
      262 
      263 dcl     mrds_data_$max_td_len	 fixed bin (35) ext;
      264 dcl     sys_info$max_seg_size	 fixed bin (35) ext static;
      265 dcl     iox_$error_output	 ptr ext static;
      266 
      267 dcl     cleanup		 condition;
      268 
      269 dcl     (addcharno, addr, char, copy, fixed, hbound, index, length, ltrim, null, rel, reverse, rtrim,
      270         size, substr, verify)		 builtin;
      271 
      272 dcl     work_area		 area based (work_area_ptr);
      273 
      274 dcl     convert_status_code_	 entry (fixed bin (35), char (8) aligned,
      275 			 char (100) aligned);
      276 dcl     get_system_free_area_	 entry () returns (ptr);
      277 dcl     ioa_		 entry () options (variable);
      278 dcl     ioa_$ioa_switch	 entry () options (variable);
      279 dcl     signal_		 entry (char (*), ptr, ptr, ptr);
      280 
      281     end mu_print_error;
      282 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1300.0  mu_print_error.pl1                >special_ldd>install>MR12.2-1073>mu_print_error.pl1
217          1    08/01/88  1300.0  mrds_se_info.incl.pl1             >special_ldd>install>MR12.2-1073>mrds_se_info.incl.pl1
219          2    08/01/88  1300.0  mrds_dsl_keywords.incl.pl1        >special_ldd>install>MR12.2-1073>mrds_dsl_keywords.incl.pl1
221          3    08/01/88  1300.0  mrds_se_error_info.incl.pl1       >special_ldd>install>MR12.2-1073>mrds_se_error_info.incl.pl1
223          4    03/24/82  1347.2  condition_info_header.incl.pl1    >ldd>include>condition_info_header.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
NL                                     based           char(1)                  packed unaligned dcl 253 ref 67 67 73 82 163 183 183
                                                                                  187
NL_data                         001011 constant        bit(9)                   initial packed unaligned dcl 254 set ref 67 67 73 82
                                                                                  163 183 183 187
SP                                     constant        char(1)                  initial packed unaligned dcl 255 ref 185
WHITE_SPACE                            based           char(6)                  packed unaligned dcl 248 ref 157
WHITE_SPACE_data                001012 constant        bit(9)                   initial array packed unaligned dcl 249 set ref 157
a_se_info_ptr                          parameter       pointer                  dcl 226 ref 16 43
a_se_len                               parameter       fixed bin(17,0)          dcl 228 ref 129 136
a_se_ptr                               parameter       pointer                  dcl 227 ref 129 135
action_flags              2     000106 automatic       structure                level 3 dcl 237
addcharno                                              builtin function         dcl 269 ref 58
addr                                                   builtin function         dcl 269 ref 67 67 73 82 105 110 110 157 163 183 183
                                                                                  187
arg_sex                                based           char                     packed unaligned dcl 260 ref 213
cant_restart              2     000106 automatic       bit(1)                   level 4 packed packed unaligned dcl 237 set ref 92*
cleanup                         000160 stack reference condition                dcl 267 ref 51 138
condition_info_header                  based           structure                level 1 dcl 4-6
convert_status_code_            000014 constant        entry                    external dcl 274 ref 87
copy                                                   builtin function         dcl 269 ref 73 82
current_NL                      000146 automatic       fixed bin(17,0)          dcl 245 set ref 64* 67 70* 70 73 73 73 178* 182 183
                                                                                  185 187 187 189* 189 195* 195
default_restart           2(01) 000106 automatic       bit(1)                   level 4 packed packed unaligned dcl 237 set ref 93*
done                            000153 automatic       bit(1)                   packed unaligned dcl 247 set ref 65* 66 83* 158* 159
                                                                                  167* 169* 179* 181 191* 193* 197*
error_code               12            based           fixed bin(35,0)          level 3 dcl 1-13 set ref 87* 98
error_info_version                     constant        fixed bin(17,0)          initial dcl 3-36 ref 91
error_msg               115     000106 automatic       char(256)                level 2 in structure "msei" dcl 237 in procedure
                                                                                  "mu_print_error" set ref 100*
error_msg                22            based           char(256)                level 3 in structure "se_info" dcl 1-13 in procedure
                                                                                  "mu_print_error" ref 100 116 116 116
error_report              6            based           structure                level 2 dcl 1-13
error_type               14            based           char(24)                 level 3 in structure "se_info" dcl 1-13 in procedure
                                                                                  "mu_print_error" ref 99 116 116
error_type              105     000106 automatic       char(32)                 level 2 in structure "msei" dcl 237 in procedure
                                                                                  "mu_print_error" set ref 99*
formatted_select_expr           000106 automatic       structure                level 2 dcl 237
get_system_free_area_           000016 constant        entry                    external dcl 276 ref 210
hbound                                                 builtin function         dcl 269 ref 155
header                          000106 automatic       structure                level 2 dcl 237
i                               000150 automatic       fixed bin(17,0)          dcl 245 set ref 157* 160 161 163 163 165* 165 185*
                                                                                  186 187 187 189
index                                                  builtin function         dcl 269 ref 67 161 183 185
info_string               3     000106 automatic       varying char(256)        level 3 dcl 237 set ref 97* 116
ioa_                            000020 constant        entry                    external dcl 277 ref 141
ioa_$ioa_switch                 000022 constant        entry                    external dcl 278 ref 116
iox_$error_output               000012 external static pointer                  dcl 265 set ref 116*
j                               000151 automatic       fixed bin(17,0)          dcl 245 set ref 155* 156 161*
keyword                         000000 constant        structure                level 1 dcl 2-16
length                          000106 automatic       fixed bin(17,0)          level 3 in structure "msei" dcl 237 in procedure
                                                                                  "mu_print_error" set ref 108*
length                                                 builtin function         dcl 269 in procedure "mu_print_error" ref 73 106 160
                                                                                  182
long_message                    000110 automatic       char(100)                dcl 241 set ref 87* 116 116
major_keyword          1006     000000 constant        bit(1)                   initial array level 2 packed packed unaligned
                                                                                  dcl 2-16 ref 156
mrds_data_$max_token_size       000010 external static fixed bin(35,0)          dcl 3-37 ref 101 102 103 104 105 106 107 108 237
mrds_se_error_info                     based           structure                level 1 dcl 3-21
msei                            000106 automatic       structure                level 1 dcl 237 set ref 108 110 110
name                            000000 constant        char(24)                 initial array level 2 packed packed unaligned
                                                                                  dcl 2-16 ref 155 161
next_NL                         000147 automatic       fixed bin(17,0)          dcl 245 set ref 67* 68 69 70 73 73 73 183* 184 193
                                                                                  195
null                                                   builtin function         dcl 269 ref 110 110 110 110
pad                       2(04) 000106 automatic       bit(32)                  level 4 packed packed unaligned dcl 237 set ref 96*
quiet_restart             2(02) 000106 automatic       bit(1)                   level 4 packed packed unaligned dcl 237 set ref 94*
raw_select_expr                 000106 automatic       structure                level 2 dcl 237
raw_token_position              000144 automatic       fixed bin(17,0)          dcl 245 set ref 53* 56* 104
reverse                                                builtin function         dcl 269 ref 185
rtrim                                                  builtin function         dcl 269 ref 116 116 116 116 116 116 116 116 141 141
                                                                                  161
se_info                                based           structure                level 1 dcl 1-13
se_info_ptr                     000100 automatic       pointer                  dcl 233 set ref 43* 45 47 48 53 53 53 56 58 58 87 98
                                                                                  99 100 101 102 103 116 116 116 116 116
se_len                          000156 automatic       fixed bin(17,0)          dcl 259 in procedure "mu_print_error" set ref 47* 51
                                                                                  73 82 125 134 136* 138 142 163 187 211 213 213
se_len                          000106 automatic       fixed bin(17,0)          level 3 in structure "msei" dcl 237 in procedure
                                                                                  "mu_print_error" set ref 103*
se_len                          000106 automatic       fixed bin(17,0)          level 3 in structure "msei" dcl 237 in procedure
                                                                                  "mu_print_error" set ref 106*
se_length                 2            based           fixed bin(17,0)          level 2 dcl 1-13 ref 45 47 53 53 103
se_ptr                          000106 automatic       pointer                  level 3 in structure "msei" dcl 237 in procedure
                                                                                  "mu_print_error" set ref 102*
se_ptr                          000154 automatic       pointer                  dcl 258 in procedure "mu_print_error" set ref 48*
                                                                                  135* 213
se_ptr                                 based           pointer                  level 2 in structure "se_info" dcl 1-13 in procedure
                                                                                  "mu_print_error" ref 48 58 102
se_ptr                          000106 automatic       pointer                  level 3 in structure "msei" dcl 237 in procedure
                                                                                  "mu_print_error" set ref 105*
sex                                    based           varying char             dcl 261 set ref 51 67 73 73* 73 73 82* 82 105 106
                                                                                  116 116 125 138 141 141 142 157 160 161 163* 163
                                                                                  163 182 183 185 187* 187 187 211 213*
sex_ptr                         000104 automatic       pointer                  dcl 235 set ref 51 67 73 73 73 73 82 82 105 106 116
                                                                                  116 125 138 141 141 142 157 160 161 163 163 163
                                                                                  182 183 185 187 187 187 211* 213
short_message                   000106 automatic       char(8)                  dcl 240 set ref 87*
signal_                         000024 constant        entry                    external dcl 279 ref 110
size                                                   builtin function         dcl 269 ref 108
status_code             104     000106 automatic       fixed bin(35,0)          level 3 dcl 237 set ref 98*
substr                                                 builtin function         dcl 269 ref 67 73 73 161 163 163 183 185 187 187
support_signal            2(03) 000106 automatic       bit(1)                   level 4 packed packed unaligned dcl 237 set ref 95*
token                   215     000106 automatic       char                     level 2 in structure "msei" dcl 237 in procedure
                                                                                  "mu_print_error" set ref 101*
token                                  based           char                     packed unaligned dcl 242 in procedure
                                                                                  "mu_print_error" ref 101
token_length             11            based           fixed bin(17,0)          level 3 dcl 1-13 ref 101
token_position                  000106 automatic       fixed bin(17,0)          level 3 in structure "msei" dcl 237 in procedure
                                                                                  "mu_print_error" set ref 104*
token_position                  000145 automatic       fixed bin(17,0)          dcl 245 in procedure "mu_print_error" set ref 53*
                                                                                  56* 68 69* 69 73 82 107
token_position                  000106 automatic       fixed bin(17,0)          level 3 in structure "msei" dcl 237 in procedure
                                                                                  "mu_print_error" set ref 107*
token_ptr                       000142 automatic       pointer                  dcl 243 set ref 58* 101
token_start              10            based           fixed bin(17,0)          level 3 dcl 1-13 ref 53 56 58
verify                                                 builtin function         dcl 269 ref 157
version                   1     000106 automatic       fixed bin(17,0)          level 3 dcl 237 set ref 91*
work_area                              based           area(1024)               dcl 272 ref 51 125 138 142 211
work_area_ptr                   000102 automatic       pointer                  dcl 234 set ref 51 125 138 142 210* 211
x                               000152 automatic       fixed bin(17,0)          dcl 245 set ref 161* 162 163 163 165

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
AV_TYPE                                internal static char(16)                 initial packed unaligned dcl 1-50
IL_TYPE                                internal static char(14)                 initial packed unaligned dcl 1-53
RC_TYPE                                internal static char(12)                 initial packed unaligned dcl 1-33
SC_TYPE                                internal static char(13)                 initial packed unaligned dcl 1-38
SE_TYPE                                internal static char(20)                 initial packed unaligned dcl 1-35
WCE_TYPE                               internal static char(23)                 initial packed unaligned dcl 1-44
WCF_TYPE                               internal static char(21)                 initial packed unaligned dcl 1-47
WC_TYPE                                internal static char(12)                 initial packed unaligned dcl 1-41
char                                                   builtin function         dcl 269
condition_info_header_ptr              automatic       pointer                  dcl 4-4
fixed                                                  builtin function         dcl 269
ltrim                                                  builtin function         dcl 269
mrds_data_$max_td_len                  external static fixed bin(35,0)          dcl 263
mrds_se_error_info_ptr                 automatic       pointer                  dcl 3-19
parser_static_info                     based           structure                level 1 dcl 1-66
parser_work_area                       based           area                     dcl 1-63
psi_ptr                                automatic       pointer                  dcl 1-65
rel                                                    builtin function         dcl 269
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 264

NAMES DECLARED BY EXPLICIT CONTEXT.
format_sex                      002117 constant        entry                    internal dcl 147 ref 60 140
init_sex                        002471 constant        entry                    internal dcl 202 ref 49 137
mu_print_error                  001103 constant        entry                    external dcl 16
print_se                        002000 constant        entry                    external dcl 129

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2670        2716    2533        2700
Length      3214    2533        26         262     134           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mu_print_error                      225 external procedure  is an external procedure.  
on unit on line 51                   64 on unit               
on unit on line 138                  64 on unit               
format_sex                              internal procedure  shares stack frame of external procedure mu_print_error.  
init_sex                                internal procedure  shares stack frame of external procedure mu_print_error.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mu_print_error           000100 se_info_ptr                 mu_print_error
                         000102 work_area_ptr               mu_print_error
                         000104 sex_ptr                     mu_print_error
                         000106 msei                        mu_print_error
                         000106 short_message               mu_print_error
                         000110 long_message                mu_print_error
                         000142 token_ptr                   mu_print_error
                         000144 raw_token_position          mu_print_error
                         000145 token_position              mu_print_error
                         000146 current_NL                  mu_print_error
                         000147 next_NL                     mu_print_error
                         000150 i                           mu_print_error
                         000151 j                           mu_print_error
                         000152 x                           mu_print_error
                         000153 done                        mu_print_error
                         000154 se_ptr                      mu_print_error
                         000156 se_len                      mu_print_error

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        return_mac
alloc_auto_adj      enable_op           shorten_stack       ext_entry           int_entry           set_chars_eis
index_chars_eis     verify_eis          op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
convert_status_code_          get_system_free_area_         ioa_                          ioa_$ioa_switch
signal_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
iox_$error_output             mrds_data_$max_token_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    237 001061        16 001100        43 001111        45 001115        47 001117        48 001120        49 001122
     51 001123        53 001150        56 001160        58 001162        60 001167        64 001170        65 001172
     66 001173        67 001176        68 001233        69 001242        70 001245        71 001247        73 001250
     82 001354        83 001433        85 001436        87 001437        91 001453        92 001456        93 001460
     94 001462        95 001464        96 001466        97 001470        98 001471        99 001474       100 001477
    101 001502       102 001511       103 001521       104 001524       105 001526       106 001535       107 001540
    108 001542       110 001546       116 001601       125 001763       127 001773       129 001774       134 002006
    135 002010       136 002014       137 002016       138 002017       140 002044       141 002045       142 002106
    145 002116       147 002117       155 002120       156 002125       157 002131       158 002141       159 002142
    160 002144       161 002147       162 002207       163 002210       165 002262       166 002266       167 002267
    168 002271       169 002272       170 002274       172 002275       178 002277       179 002301       181 002302
    182 002304       183 002307       184 002344       185 002347       186 002363       187 002365       189 002443
    190 002450       191 002451       192 002453       193 002454       195 002461       196 002464       197 002465
    198 002467       200 002470       202 002471       210 002472       211 002501       213 002512       215 002526


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
