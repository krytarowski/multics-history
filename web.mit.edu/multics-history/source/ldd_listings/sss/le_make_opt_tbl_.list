	COMPILATION LISTING OF SEGMENT le_make_opt_tbl_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 12/10/86  1257.5 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /****^  HISTORY COMMENTS:
        8*  1) change(86-08-12,Elhard), approve(86-08-12,MCR7505),
        9*     audit(86-12-10,DGHowe), install(86-12-10,MR12.0-1241):
       10*     Originally written to extract definition options and create the sorted
       11*     option table to be used for definition retention determination.
       12*                                                   END HISTORY COMMENTS */
       13 
       14 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       15 
       16 le_make_opt_tbl_:
       17   proc (leip,			/** le_input ptr	    (in )	*/
       18        leop);			/** le_options ptr	    (i/o) */
       19 
       20   /*** ****************************************************************/
       21   /***							*/
       22   /***	Name:	le_make_opt_tbl_				*/
       23   /***	Input:	leip, leop				*/
       24   /***	Function:	creates the option table from the le_input	*/
       25   /***		structure.  This table is scanned to resolve	*/
       26   /***		options which may be global, or deal with a	*/
       27   /***		single component or entrypoint.  Options are	*/
       28   /***		places into the option list ordered such that	*/
       29   /***		the most specific options are first.  This way,	*/
       30   /***		a linear search of the options for the first	*/
       31   /***		option which matches will provide the option	*/
       32   /***		which is most appropriate.			*/
       33   /***	Output:	leop					*/
       34   /***							*/
       35   /*** ****************************************************************/
       36 
       37   /* constants */
       38 
       39   dcl true		bit (1) static options (constant) init ("1"b);
       40   dcl false		bit (1) static options (constant) init ("0"b);
       41 
       42   /* parameters */
       43 
       44   dcl leip		ptr parameter;
       45   dcl leop		ptr parameter;
       46 
       47   /* procedures */
       48 
       49   dcl check_star_name_$entry	entry (char (*), fixed bin (35));
       50   dcl le_error_		entry options (variable);
       51 
       52   /* external */
       53 
       54   dcl le_et_$bad_ep_starname	external fixed bin (35);
       55   dcl le_et_$dup_ep_option	external fixed bin (35);
       56   dcl le_et_$dup_global_option
       57 			external fixed bin (35);
       58 
       59   /* based */
       60 
       61   dcl 01 lei		aligned based (leip),
       62        02 header		aligned like le_input.header,
       63        02 opt		dim (0 refer (lei.n_opts)) like le_option;
       64   dcl 01 leo		aligned based (leop),
       65        02 header		aligned like le_options.header,
       66        02 opt		dim (0 refer (leo.n_opts)) like le_options.opt;
       67 
       68   /* automatic */
       69 
       70   dcl cl			fixed bin automatic;
       71   dcl ec			fixed bin (35) automatic;
       72   dcl en			char (256) automatic;
       73   dcl io			fixed bin automatic;
       74   dcl optx		fixed bin automatic;
       75   dcl sn			char (32) automatic;
       76 
       77   /* builtin */
       78 
       79   dcl after		builtin;
       80   dcl before		builtin;
       81   dcl mod			builtin;
       82   dcl unspec		builtin;
       83 
       84   /* scan the option list for definition-disposition options,	*/
       85   /* evaluate their ordering and add them to the option table.	*/
       86 
       87   do io = 1 to lei.n_opts;
       88 
       89     if (lei.opt (io).type = DELETE |
       90          lei.opt (io).type = RETAIN |
       91          lei.opt (io).type = NO_LINK) &
       92          ^lei.opt (io).flags.ignore
       93       then do;
       94         lei.opt (io).flags.used = true;
       95         sn = before (lei.opt (io).path_or_ep, "$");
       96         en = after (lei.opt (io).path_or_ep, "$");
       97         cl = get_class (sn, en, ec);
       98         if ec ^= 0
       99 	then do;
      100 	  call le_error_ (LE_WARNING, le_et_$bad_ep_starname, "^a",
      101 	       lei.opt (io).path_or_ep);
      102 	  lei.opt (io).flags.ignore = true;
      103 	end;
      104 	else do;
      105 	  optx, leo.n_opts = leo.n_opts + 1;
      106 	  leo.opt (optx).type = lei.opt (io).type;
      107 	  leo.opt (optx).inhibit_error = lei.opt (io).flags.inhibit_error;
      108 	  leo.opt (optx).used = false;
      109 	  leo.opt (optx).order = io;
      110 	  leo.opt (optx).segname = sn;
      111 	  leo.opt (optx).ep_name = en;
      112 	  leo.opt (optx).class = cl;
      113 	end;
      114       end;
      115   end;
      116 
      117   /* sort the options into ascending order by ordering class */
      118 
      119   call sort_opts (leop);
      120 
      121   /* now that they are sorted, check for duplicates and print a message */
      122 
      123   do optx = 1 to leo.n_opts - 1;
      124     if leo.opt (optx).segname = leo.opt (optx + 1).segname &
      125          leo.opt (optx).ep_name = leo.opt (optx + 1).ep_name
      126       then do;
      127         if leo.opt (optx).class = 9
      128 	then call le_error_ (LE_WARNING, le_et_$dup_global_option,
      129 		"^/Global ""^[retain^;delete^;no_link^]"" option ignored.",
      130 		leo.opt (optx + 1).type - RETAIN + 1);
      131 	else call le_error_ (LE_WARNING, le_et_$dup_ep_option,
      132 		"^/Option ""^[retain^;delete^;no_link^] ^[^a$^;^s^]^[^a^;^s^]"" ignored.",
      133 		leo.opt (optx + 1).type - RETAIN + 1,
      134 		(mod (leo.opt (optx + 1).class, 3) ^= 0),
      135 		leo.opt (optx + 1).segname,
      136 		(leo.opt (optx + 1).class < 7),
      137 		leo.opt (optx + 1).ep_name);
      138       end;
      139   end;
      140 
      141   return;
      142 
      143 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      144 
      145 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      146 
      147 
      148 get_class:
      149   proc (segname,			/** segname string	    (in )	*/
      150        offsetname,			/** offsetname string   (in ) */
      151        ec)			/** error code	    (out) */
      152        returns (fixed bin);		/** ordering class	    (out) */
      153 
      154   /*** ****************************************************************/
      155   /***							*/
      156   /***	Name:	get_class					*/
      157   /***	Input:	segname, offsetname				*/
      158   /***	Function:	calculates the ordering class of an entrypoint	*/
      159   /***		specification.  Ordering class is based on how	*/
      160   /***		specific the name is.  Valid values are:	*/
      161   /***		  1 - segname$offsetname			*/
      162   /***		  2 - starname$offsetname			*/
      163   /***		  3 - **$offsetname				*/
      164   /***		  4 - segname$starname			*/
      165   /***		  5 - starname$starname			*/
      166   /***		  6 - **$starname				*/
      167   /***		  7 - segname$**				*/
      168   /***		  8 - starname$**				*/
      169   /***		  9 - **$**				*/
      170   /***		The options are sorted in ascending order by	*/
      171   /***		ordering class.  When trying to ascertain the	*/
      172   /***		disposition of any single definition, the option	*/
      173   /***		table is searched and the first matching option	*/
      174   /***		is used.					*/
      175   /***	Output:	ordering_class, error_code			*/
      176   /***							*/
      177   /*** ****************************************************************/
      178 
      179   /* parameters */
      180 
      181   dcl segname		char (*) parameter;
      182   dcl offsetname		char (*) parameter;
      183   dcl ec			fixed bin (35) parameter;
      184 
      185   /* automatic */
      186 
      187   dcl ordering_class	fixed bin automatic;
      188 
      189   /* The ordering class is derived based on the error code returned	*/
      190   /* by check_star_name_$entry.  If the string is a valid non-star	*/
      191   /* name, a 0 is returned, a starname returns a 1, and a starname	*/
      192   /* which matches anything (ie. **) returns a 2.  If the error code	*/
      193   /* is greater than 2, then the name is invalid.			*/
      194 
      195   call check_star_name_$entry (offsetname, ec);
      196   if ec > 2
      197     then return (9999);
      198   ordering_class = ec * 3;
      199   call check_star_name_$entry (segname, ec);
      200   if ec > 2
      201     then return (9999);
      202   ordering_class = ordering_class + ec + 1;
      203   ec = 0;
      204 
      205   return (ordering_class);
      206 
      207   end get_class;
      208 
      209 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      210 
      211 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      212 
      213 
      214 sort_opts:
      215   proc (leop);			/** le_options pointer  (i/o)	*/
      216 
      217   /*** ****************************************************************/
      218   /***							*/
      219   /***	Name:	sort_opts					*/
      220   /***	Input:	leop					*/
      221   /***	Function:	sorts the options into ascending order based on	*/
      222   /***		the ordering class.  This allows the disposition	*/
      223   /***		of any definition to be determined by performing	*/
      224   /***		a linear search of the option list searching for	*/
      225   /***		the first matching specification.		*/
      226   /***	Output:	leop					*/
      227   /***							*/
      228   /*** ****************************************************************/
      229 
      230   /* parameters */
      231 
      232   dcl leop		ptr parameter;
      233 
      234   /* based */
      235 
      236   dcl 01 leo		aligned based (leop),
      237        02 header		aligned like le_options.header,
      238        02 opt		dim (0 refer (leo.n_opts)) like le_options.opt;
      239 
      240   /* automatic */
      241 
      242   dcl i			fixed bin automatic;
      243 
      244   /* build the heap */
      245 
      246   do i = leo.n_opts / 2 by -1 to 1;
      247     call adjust_heap (leop, i, leo.n_opts);
      248   end;
      249 
      250   /* sort the heap by extracting the largest and placing it at the	*/
      251   /* end of the array and inserting the last item into the heap to	*/
      252   /* rebuild a heap 1 smaller.				*/
      253 
      254   do i = leo.n_opts - 1 by -1 to 1;
      255     call exchange (leop, i + 1, 1);
      256     call adjust_heap (leop, 1, i);
      257   end;
      258 
      259   end sort_opts;
      260 
      261 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      262 
      263 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      264 
      265 
      266 adjust_heap:
      267   proc (leop,			/** le_options pointer  (i/o)	*/
      268        head,			/** pseudo-head index   (in ) */
      269        size);			/** end of heap	    (in ) */
      270 
      271   /*** ****************************************************************/
      272   /***							*/
      273   /***	Name:	adjust_heap				*/
      274   /***	Input:	leop, head, size				*/
      275   /***	Function:	given a heap structure and a starting node,	*/
      276   /***		adjust the heap structure into a true heap by	*/
      277   /***		making sure that each node has a value greater	*/
      278   /***		than both of the child nodes.			*/
      279   /***	Output:	leop					*/
      280   /***							*/
      281   /*** ****************************************************************/
      282 
      283   /* parameters */
      284 
      285   dcl leop		ptr parameter;
      286   dcl head		fixed bin parameter;
      287   dcl size		fixed bin parameter;
      288 
      289   /* automatic */
      290 
      291   dcl r			fixed bin automatic;
      292   dcl l			fixed bin automatic;
      293   dcl exch		fixed bin automatic;
      294 
      295   /* get the indecies of the left and right child nodes */
      296 
      297   l = 2 * head;
      298   r = l + 1;
      299 
      300   /* if they are out of bounds, we are done */
      301 
      302   if l > size
      303     then return;
      304 
      305   if r > size
      306     then r = 0;
      307 
      308   if greater (leop, head, r)
      309     then if greater (leop, l, r)
      310 	 then exch = r;
      311 	 else exch = l;
      312   else if greater (leop, head, l)
      313     then exch = l;
      314   else return;
      315 
      316   call exchange (leop, exch, head);
      317   call adjust_heap (leop, exch, size);
      318 
      319   end adjust_heap;
      320 
      321 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      322 
      323 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      324 
      325 
      326 exchange:
      327   proc (leop,			/** le_options pointer  (i/o)	*/
      328        x1,			/** exch node index 1   (in ) */
      329        x2);			/** exch node index 2   (in ) */
      330 
      331   /*** ****************************************************************/
      332   /***							*/
      333   /***	Name:	exchange					*/
      334   /***	Input:	leop, x1, x2				*/
      335   /***	Function:	exchange the nodes indicated by the indicies x1	*/
      336   /***		and x2.					*/
      337   /***	Output:	leop					*/
      338   /***							*/
      339   /*** ****************************************************************/
      340 
      341   /* parameters */
      342 
      343   dcl leop		ptr parameter;
      344   dcl x1			fixed bin parameter;
      345   dcl x2			fixed bin parameter;
      346 
      347   /* based */
      348 
      349   dcl 01 leo		aligned based (leop),
      350        02 header		aligned like le_options.header,
      351        02 opt		dim (0 refer (leo.n_opts)) like le_options.opt;
      352 
      353   /* automatic */
      354 
      355   dcl 01 temp		aligned automatic like le_options.opt;
      356 
      357   temp = leo.opt (x2);
      358   leo.opt (x2) = leo.opt (x1);
      359   leo.opt (x1) = temp;
      360 
      361   end exchange;
      362 
      363 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      364 
      365 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      366 
      367 
      368 greater:
      369   proc (leop,			/** le_option pointer   (in )	*/
      370        orig,			/** index of original   (in ) */
      371        new)			/** index of new	    (in ) */
      372        returns (bit (1));		/** true if new > orig  (out) */
      373 
      374   /*** ****************************************************************/
      375   /***							*/
      376   /***	Name:	greater					*/
      377   /***	Input:	leop, new, orig				*/
      378   /***	Function:	determine if the option indicated by new is	*/
      379   /***		greated (according to the ordering method) than	*/
      380   /***		the option indicated by orig.			*/
      381   /***	Output:	greater_sw				*/
      382   /***							*/
      383   /*** ****************************************************************/
      384 
      385   /* parameters */
      386 
      387   dcl leop		ptr parameter;
      388   dcl new			fixed bin parameter;
      389   dcl orig		fixed bin parameter;
      390 
      391   /* based */
      392 
      393   dcl 01 leo		aligned based (leop),
      394        02 header		aligned like le_options.header,
      395        02 opt		dim (0 refer (leo.n_opts)) like le_options.opt;
      396 
      397   if new = 0
      398     then return (false);
      399 
      400   /* first criterion is ordering class */
      401 
      402   if leo.opt (new).class > leo.opt (orig).class
      403     then return (true);
      404   else if leo.opt (new).class < leo.opt (orig).class
      405     then return (false);
      406 
      407   /* with class, sort by segname */
      408 
      409   if leo.opt (new).segname > leo.opt (orig).segname
      410     then return (true);
      411   else if leo.opt (new).segname < leo.opt (orig).segname
      412     then return (false);
      413 
      414   /* within class and segname, sort by ep_name */
      415 
      416   if leo.opt (new).ep_name > leo.opt (orig).ep_name
      417     then return (true);
      418   else if leo.opt (new).ep_name < leo.opt (orig).ep_name
      419     then return (false);
      420 
      421   /* within class, segname, and ep_name, sort by order given in the	*/
      422   /* input options.						*/
      423 
      424   if leo.opt (new).order > leo.opt (orig).order
      425     then return (true);
      426     else return (false);
      427 
      428   end greater;
      429 
      430 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      431 
      432 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      433 
      434 
  1     1 /****  START OF:	le_data.incl.pl1			 *  *  *  *  *  */
  1     2 
  1     3 /****^  HISTORY COMMENTS:
  1     4*  1) change(86-08-12,Elhard), approve(86-08-12,MCR7505),
  1     5*     audit(86-12-10,DGHowe), install(86-12-10,MR12.0-1241):
  1     6*     Originally written to define the structures used internally by le_.
  1     7*                                                   END HISTORY COMMENTS */
  1     8 
  1     9   /*** ****************************************************************/
  1    10   /***							*/
  1    11   /***	Name:	le_data					*/
  1    12   /***	Function:	This include file defines the data structures	*/
  1    13   /***		used internally by the linkage_editor subroutine.	*/
  1    14   /***							*/
  1    15   /*** ****************************************************************/
  1    16   
  1    17   /* error severity constants */
  1    18   
  1    19   dcl LE_WARNING		fixed bin static options (constant) init (1);
  1    20   dcl LE_ERROR		fixed bin static options (constant) init (2);
  1    21   dcl LE_FATAL_ERROR	fixed bin static options (constant) init (3);
  1    22   dcl LE_ABORT_ERROR	fixed bin static options (constant) init (4);
  1    23   
  1    24   /* section identifier constants */
  1    25   
  1    26   dcl Text		fixed bin (3) static options (constant)
  1    27 			init (0);
  1    28   dcl Linkage		fixed bin (3) static options (constant)
  1    29 			init (1);
  1    30   dcl Symbol		fixed bin (3) static options (constant)
  1    31 			init (2);
  1    32   dcl Definition		fixed bin (3) static options (constant)
  1    33 			init (3);
  1    34   dcl Static		fixed bin (3) static options (constant)
  1    35 			init (4);
  1    36   dcl System		fixed bin (3) static options (constant)
  1    37 			init (5);
  1    38   dcl Heap		fixed bin (3) static options (constant)
  1    39 			init (6);
  1    40   
  1    41   dcl section_nm		(0:6) char (16) static options (constant)
  1    42 			init ("text", "linkage", "symbol", "definition",
  1    43 			"static", "system", "heap");
  1    44   
  1    45   /* link type constants */
  1    46   
  1    47   dcl Self_Base		fixed bin (3) static options (constant)
  1    48 			init (1);
  1    49   dcl Refname_Base		fixed bin (3) static options (constant)
  1    50 			init (3);
  1    51   dcl Refname_Offsetname	fixed bin (3) static options (constant)
  1    52 			init (4);
  1    53   dcl Self_Offsetname	fixed bin (3) static options (constant)
  1    54 			init (5);
  1    55   
  1    56   /* backpatch type constants */
  1    57   
  1    58   dcl Patch_Link		fixed bin static options (constant) init (1);
  1    59   dcl Patch_Init		fixed bin static options (constant) init (2);
  1    60   dcl Patch_Symbol_Ref	fixed bin static options (constant) init (3);
  1    61   dcl Patch_Self_Init	fixed bin static options (constant) init (4);
  1    62   
  1    63   /*** ****************************************************************/
  1    64   /***							*/
  1    65   /***	Name:	le_components				*/
  1    66   /***	Function:	the component table is used to keep information	*/
  1    67   /***		about the input components being used and their	*/
  1    68   /***		disposition in output components.		*/
  1    69   /***							*/
  1    70   /*** ****************************************************************/
  1    71   
  1    72   dcl 01 le_components	aligned based,
  1    73        02 header		aligned,
  1    74         03 flags		aligned,
  1    75          04 separate_static	bit (1) unaligned,
  1    76          04 perprocess_static	bit (1) unaligned,
  1    77          04 mbz		bit (34) unaligned,
  1    78         03 n_components	fixed bin,
  1    79        02 comp		(0 refer (le_components.n_components))
  1    80 			like le_comp;
  1    81   
  1    82   /*** ****************************************************************/
  1    83   /***							*/
  1    84   /***	Name:	le_comp					*/
  1    85   /***	Function:	this is a single component table entry.		*/
  1    86   /***							*/
  1    87   /*** ****************************************************************/
  1    88   
  1    89   dcl 01 le_comp		aligned based,
  1    90        02 segp		ptr,
  1    91        02 bc		fixed bin (24),
  1    92        02 uid		bit (36) aligned,
  1    93        02 dtcm		fixed bin (71),
  1    94        02 name		char (32) varying,
  1    95        02 path		char (194) varying,
  1    96        02 compiler		char (8),
  1    97        02 target		fixed bin,
  1    98        02 flags		aligned,
  1    99         03 library		bit (1) unaligned,
  1   100         03 include		bit (1) unaligned,
  1   101         03 delete_table	bit (1) unaligned,
  1   102         03 separate_static	bit (1) unaligned,
  1   103         03 io_table		bit (1) unaligned,
  1   104         03 unique_path	bit (1) unaligned,
  1   105         03 mbz		bit (30) unaligned,
  1   106        02 tables		aligned,
  1   107         03 lesp		ptr,
  1   108         03 ledp		ptr,
  1   109         03 lelp		ptr,
  1   110        02 orig		aligned,
  1   111         03 textp		ptr,
  1   112         03 defnp		ptr,
  1   113         03 linkp		ptr,
  1   114         03 statp		ptr,
  1   115         03 symbp		ptr,
  1   116         03 rel_textp	ptr,
  1   117         03 rel_symbp	ptr,
  1   118         03 rel_linkp	ptr,
  1   119         03 textl		fixed bin (18) unsigned unaligned,
  1   120         03 defnl		fixed bin (18) unsigned unaligned,
  1   121         03 linkl		fixed bin (18) unsigned unaligned,
  1   122         03 statl		fixed bin (18) unsigned unaligned,
  1   123         03 symbl		fixed bin (18) unsigned unaligned,
  1   124         03 symbl_no_rel	fixed bin (18) unsigned unaligned,
  1   125         03 symbl_no_table	fixed bin (18) unsigned unaligned,
  1   126         03 n_symb_blocks	fixed bin (18) unsigned unaligned,
  1   127         03 text_boundary	fixed bin (9) unsigned unaligned,
  1   128         03 static_boundary	fixed bin (9) unsigned unaligned,
  1   129         03 next_comp	fixed bin (18) unsigned unaligned,
  1   130        02 new		aligned,
  1   131         03 rel_text		fixed bin (18) unsigned unaligned,
  1   132         03 rel_symb		fixed bin (18) unsigned unaligned,
  1   133         03 rel_stat		fixed bin (18) unsigned unaligned,
  1   134         03 text_pad		fixed bin (18) unsigned unaligned,
  1   135         03 static_pad	fixed bin (18) unsigned unaligned,
  1   136         03 symbol_pad	fixed bin (18) unsigned unaligned;
  1   137   
  1   138   /*** ****************************************************************/
  1   139   /***							*/
  1   140   /***	Name:	le_segnames				*/
  1   141   /***	Function:	the segname table is used for two purposes:	*/
  1   142   /***		 - to determine the target components of links	*/
  1   143   /***		   being resolved internally.			*/
  1   144   /***		 - to determine the segname definitions to be	*/
  1   145   /***		   emited for definitions being retained.	*/
  1   146   /***							*/
  1   147   /*** ****************************************************************/
  1   148   
  1   149   dcl 01 le_segnames	aligned based,
  1   150        02 header		aligned,
  1   151         03 n_segnames	fixed bin,
  1   152        02 segname		(segname_count refer (le_segnames.n_segnames)),
  1   153         03 str		char (32) varying,
  1   154         03 relp		fixed bin (18) unsigned unaligned,
  1   155         03 pad		bit (18) unaligned;
  1   156   dcl segname_count		fixed bin automatic;
  1   157   
  1   158   /*** ****************************************************************/
  1   159   /***							*/
  1   160   /***	Name:	le_definitions				*/
  1   161   /***	Function:	the definition table contains the definitions	*/
  1   162   /***		from the input components and is used to resolve	*/
  1   163   /***		link targets, and regenerate definition entries	*/
  1   164   /***							*/
  1   165   /*** ****************************************************************/
  1   166   
  1   167   dcl 01 le_definitions	aligned based,
  1   168        02 header		aligned,
  1   169         03 n_defs		fixed bin,
  1   170         03 pad		bit (36),
  1   171        02 def		(def_count refer (le_definitions.n_defs))
  1   172 			like le_definition;
  1   173   dcl def_count		fixed bin automatic;
  1   174   
  1   175   dcl 01 le_definition	aligned based,
  1   176        02 str		char (256) varying,
  1   177        02 type		fixed bin (18) unsigned unaligned,
  1   178        02 relp		fixed bin (18) unsigned unaligned,
  1   179        02 offset		fixed bin (18) unsigned unaligned,
  1   180        02 new_offset	fixed bin (18) unsigned unaligned,
  1   181        02 flags		aligned,
  1   182         03 force_retain	bit (1) unaligned,
  1   183         03 entrypoint	bit (1) unaligned,
  1   184         03 ignore		bit (1) unaligned,
  1   185         03 referenced	bit (1) unaligned,
  1   186         03 no_link		bit (1) unaligned,
  1   187         03 retain		bit (1) unaligned,
  1   188         03 delete		bit (1) unaligned,
  1   189         03 mbz		bit (29) unaligned;
  1   190   
  1   191   /*** ****************************************************************/
  1   192   /***							*/
  1   193   /***	Name:	le_options				*/
  1   194   /***	Function:	the option table contains definition retention	*/
  1   195   /***		information.  The input retentions options are	*/
  1   196   /***		ordered such that a linear search of the option	*/
  1   197   /***		table for the first matching starname will give	*/
  1   198   /***		the correct retention state.			*/
  1   199   /***							*/
  1   200   /*** ****************************************************************/
  1   201   
  1   202   dcl 01 le_options		aligned based,
  1   203        02 header		aligned,
  1   204         03 n_opts		fixed bin,
  1   205        02 opt		(0 refer (le_options.n_opts)),
  1   206         03 type		fixed bin (8) unaligned,
  1   207         03 used		bit (1) unaligned,
  1   208         03 inhibit_error	bit (1) unaligned,
  1   209         03 class		fixed bin (6) unaligned,
  1   210         03 order		fixed bin (17) unaligned,
  1   211         03 segname		char (32) unaligned,
  1   212         03 ep_name		char (256) unaligned;
  1   213   
  1   214   /*** ****************************************************************/
  1   215   /***							*/
  1   216   /***	Name:	le_links					*/
  1   217   /***	Function:	the link table contains information on all of the	*/
  1   218   /***		links in the input components. It is used to	*/
  1   219   /***		determine link targets, which library components	*/
  1   220   /***		will be included, and what init_info will be	*/
  1   221   /***		used, and where it will be placed.		*/
  1   222   /***							*/
  1   223   /*** ****************************************************************/
  1   224   
  1   225   dcl 01 le_links		aligned based,
  1   226        02 header		aligned,
  1   227         03 offset_adjustment	fixed bin (18),
  1   228         03 n_links		fixed bin,
  1   229        02 link		(link_count refer (le_links.n_links))
  1   230 			like le_link;
  1   231   dcl link_count		fixed bin automatic;
  1   232 
  1   233   dcl 01 le_link		aligned based,
  1   234        02 flags		unaligned,
  1   235         03 used		bit (1),
  1   236         03 mbx		bit (35),
  1   237        02 type		fixed bin (6) unsigned unaligned,
  1   238        02 class		fixed bin (6) unsigned unaligned,
  1   239        02 mod		bit (6) unaligned,
  1   240        02 exp		fixed bin (17) unaligned,
  1   241        02 target		fixed bin (18) unsigned unaligned,
  1   242        02 defx		fixed bin (18) unsigned unaligned,
  1   243        02 relp		fixed bin (18) unsigned unaligned,
  1   244        02 target_comp	fixed bin (18) unsigned unaligned,
  1   245        02 target_link	fixed bin (18) unsigned unaligned,
  1   246        02 extension		fixed bin (18) unsigned unaligned,
  1   247        02 initp		ptr unaligned,
  1   248        02 segnamep		ptr unaligned,
  1   249        02 offsetp		ptr unaligned;
  1   250   
  1   251   /*** ****************************************************************/
  1   252   /***							*/
  1   253   /***	Name:	le_binaries				*/
  1   254   /***	Function:	This table contains information about the output	*/
  1   255   /***		binaries.  It is primarily used for creation and	*/
  1   256   /***		backpatching of MSF output.			*/
  1   257   /***							*/
  1   258   /*** ****************************************************************/
  1   259   
  1   260   dcl 01 le_binaries	aligned based,
  1   261        02 header		aligned,
  1   262         03 n_binaries	fixed bin,
  1   263         03 pad		bit (36),
  1   264        02 binary		(0:0 refer (le_binaries.n_binaries)),
  1   265         03 segp		ptr,
  1   266         03 bc		fixed bin (24),
  1   267         03 uid		bit (36),
  1   268         03 aclc		fixed bin,
  1   269         03 aclp		ptr,
  1   270         03 textp		ptr,
  1   271         03 defnp		ptr,
  1   272         03 linkp		ptr,
  1   273         03 symbp		ptr,
  1   274         03 statp		ptr,
  1   275         03 textl		fixed bin (18) unsigned unaligned,
  1   276         03 defnl		fixed bin (18) unsigned unaligned,
  1   277         03 linkl		fixed bin (18) unsigned unaligned,
  1   278         03 symbl		fixed bin (18) unsigned unaligned,
  1   279         03 statl		fixed bin (18) unsigned unaligned,
  1   280         03 mbz2		bit (18) unaligned;
  1   281   
  1   282   /*** ****************************************************************/
  1   283   /***							*/
  1   284   /***	Name:	le_patches				*/
  1   285   /***	Function:	This table contains the list of backpatches to be	*/
  1   286   /***		performed when the rest of the object creation is	*/
  1   287   /***		complete. Since le_backpatch_ is the only routine	*/
  1   288   /***		concerned with this,  it is maintained completely	*/
  1   289   /***		internal to le_backpatch_.			*/
  1   290   /***							*/
  1   291   /*** ****************************************************************/
  1   292   
  1   293   dcl 01 le_patches		aligned based,
  1   294        02 header		aligned,
  1   295         03 n_patches	fixed bin,
  1   296        02 patch		(0 refer (le_patches.n_patches)) like le_patch;
  1   297        
  1   298   dcl 01 le_patch		aligned based,
  1   299        02 type		fixed bin,
  1   300        02 comp		fixed bin,
  1   301        02 relp		fixed bin (18) unsigned,
  1   302        02 target		fixed bin,
  1   303        02 index		fixed bin;
  1   304   
  1   305 /****  END OF:	le_data.incl.pl1			 *  *  *  *  *  */
      435 
  2     1 /****  START OF:	le_input.incl.pl1			 *  *  *  *  *  */
  2     2 
  2     3   /****^  HISTORY COMMENTS:
  2     4*  1) change(86-08-12,Elhard), approve(86-08-12,MCR7505),
  2     5*     audit(86-12-10,DGHowe), install(86-12-10,MR12.0-1241):
  2     6*     Orignally written to define the le_ input structures.
  2     7*                                                   END HISTORY COMMENTS */
  2     8 
  2     9   /*** ****************************************************************/
  2    10   /***							*/
  2    11   /***	Name:	le_input					*/
  2    12   /***	Function:	This include file declares the input structure to	*/
  2    13   /***		to the le_ subroutine.  The structure consists of	*/
  2    14   /***		a set of standard data, and a variable length	*/
  2    15   /***		array of options.  The options have a type field	*/
  2    16   /***		which specified what the option means.  The	*/
  2    17   /***		options can have the following types:		*/
  2    18   /***							*/
  2    19   /***		PATH	  - specified a single input component	*/
  2    20   /***			    to be bound in with the object	*/
  2    21   /***		 name	  - is the name of the component	*/
  2    22   /***		 path_or_ep - is the pathname to the component	*/
  2    23   /***			    this may be an archive component	*/
  2    24   /***			    pathname.			*/
  2    25   /***		 flags      - link is used by the le command to	*/
  2    26   /***			    keep track of the pathnames that	*/
  2    27   /***			    were found via links for chase	*/
  2    28   /***			    processing.			*/
  2    29   /***		 bc	  - is the bit count of the component	*/
  2    30   /***		 optp	  - is a pointer to the component	*/
  2    31   /***							*/
  2    32   /***		LIBRARY	  - specifies a single library	*/
  2    33   /***			    component.  Library components are	*/
  2    34   /***			    only included if they are referred	*/
  2    35   /***			    to by a PATH component or a library	*/
  2    36   /***			    component that is referenced and	*/
  2    37   /***			    therefor included.		*/
  2    38   /***		 name	  - same as for PATH.		*/
  2    39   /***		 path_or_ep - same as for PATH.		*/
  2    40   /***		 flags	  - same as for PATH.		*/
  2    41   /***		 bc	  - same as for PATH.		*/
  2    42   /***		 optp	  - same as for PATH.		*/
  2    43   /***							*/
  2    44   /***		ADDNAME	  - specifies a name to be added to the	*/
  2    45   /***			    bound object.			*/
  2    46   /***		 name	  - is the name to be added to the	*/
  2    47   /***			    bound unit			*/
  2    48   /***							*/
  2    49   /***		SYNONYM	  - specifies a synonym to be added to	*/
  2    50   /***			    a particular component.  This is	*/
  2    51   /***			    reflected as a segname definition	*/
  2    52   /***			    added to the block for that	*/
  2    53   /***			    component.			*/
  2    54   /***		 name	  - specifies the name of the component	*/
  2    55   /***			    to which you are adding a name.	*/
  2    56   /***		 path_or_ep - is the name being added		*/
  2    57   /***							*/
  2    58   /***		RETAIN	  - gives a starname to be used when	*/
  2    59   /***			    determining if a definition should	*/
  2    60   /***			    be retained.  If the definition	*/
  2    61   /***			    matches the starname and no more	*/
  2    62   /***			    specific info is given, the name is	*/
  2    63   /***			    retained.			*/
  2    64   /***		 flags      - the "inhibit_error" flag indicates	*/
  2    65   /***			    that it is not an error if this	*/
  2    66   /***			    option is unused.		*/
  2    67   /***		 path_or_ep - is the starname to match		*/
  2    68   /***							*/
  2    69   /***		DELETE	  - gives a starname to be used when	*/
  2    70   /***			    determining if a definition should	*/
  2    71   /***			    be retained.  If the definition	*/
  2    72   /***			    matches the starname and no more	*/
  2    73   /***			    specific info is given, the name is	*/
  2    74   /***			    deleted.			*/
  2    75   /***		 flags      - the "inhibit_error" flag indicates	*/
  2    76   /***			    that it is not an error if this	*/
  2    77   /***			    option is unused.		*/
  2    78   /***		 path_or_ep - is the starname to match.		*/
  2    79   /***							*/
  2    80   /***		NO_LINK	  - gives a starname to be used when	*/
  2    81   /***			    determining if a definition should	*/
  2    82   /***			    be retained.  If the definition	*/
  2    83   /***			    matches the starname and no more	*/
  2    84   /***			    specific info is given, the name is	*/
  2    85   /***			    retained and references to the	*/
  2    86   /***			    definition within the bound uni	*/
  2    87   /***			    are not resolved but are generated	*/
  2    88   /***			    as external links.		*/
  2    89   /***		 flags      - the "inhibit_error" flag indicates	*/
  2    90   /***			    that it is not an error if this	*/
  2    91   /***			    option is unused.		*/
  2    92   /***		 path_or_ep - is the starname to match		*/
  2    93   /***							*/
  2    94   /***		TABLE	  - specifies that the table for a	*/
  2    95   /***			    particular component is to be	*/
  2    96   /***			    retained.			*/
  2    97   /***		 name	  - is the name of the component to	*/
  2    98   /***			    which the option applies.  If name	*/
  2    99   /***			    is "", this is a global option and	*/
  2   100   /***			    applies to all component for which	*/
  2   101   /***			    a specific option does not exist.	*/
  2   102   /***							*/
  2   103   /***		NO_TABLE	  - specifies that the table for a	*/
  2   104   /***			    particular component is to be	*/
  2   105   /***			    deleted.			*/
  2   106   /***		 name	  - is the name of the component to	*/
  2   107   /***			    which the option applies.  If name	*/
  2   108   /***			    is "", this is a global option and	*/
  2   109   /***			    applies to all component for which	*/
  2   110   /***			    a specific option does not exist.	*/
  2   111   /***							*/
  2   112   /*** ****************************************************************/
  2   113   
  2   114   dcl 01 le_input		aligned based,
  2   115        02 header		aligned,
  2   116         03 version		char (8),
  2   117         03 name		char (32),
  2   118         03 flags		aligned,
  2   119          04 perprocess_static	bit (1) unaligned,
  2   120          04 force		bit (1) unaligned,
  2   121          04 debug		bit (1) unaligned,
  2   122          04 list		bit (1) unaligned,
  2   123          04 map		bit (1) unaligned,
  2   124          04 auto_segnames	bit (1) unaligned,
  2   125          04 mbz		bit (30) unaligned,
  2   126         03 output_file	unaligned,
  2   127          04 dir		char (168),
  2   128          04 entry		char (32),
  2   129         03 component_size	fixed bin,
  2   130         03 display_severity	fixed bin,
  2   131         03 abort_severity	fixed bin,
  2   132         03 bindfile		aligned,
  2   133          04 name		char (32),
  2   134          04 dt_updated	fixed bin (71),
  2   135          04 dt_modified	fixed bin (71),
  2   136         03 pad		bit (36),
  2   137         03 n_opts		fixed bin,
  2   138        02 opt		dim (0 refer (le_input.n_opts)) like le_option;
  2   139   
  2   140   dcl 01 le_option		aligned based,
  2   141        02 name		char (32) unaligned,
  2   142        02 path_or_ep	char (194) unaligned,
  2   143        02 flags		unaligned,
  2   144         03 link		bit (1),
  2   145         03 ignore		bit (1),
  2   146         03 used		bit (1),
  2   147         03 inhibit_error	bit (1),
  2   148         03 mbz		bit (5),
  2   149        02 type		fixed bin (8) unaligned,
  2   150        02 bc		fixed bin (24),
  2   151        02 optp		ptr;
  2   152   
  2   153   dcl le_input_version_1	char (8) static options (constant)
  2   154 			init ("le_ 1.0 ");
  2   155   
  2   156   /* constants for the defined option types */
  2   157   
  2   158   dcl PATH		fixed bin static options (constant) init (1);
  2   159   dcl LIBRARY		fixed bin static options (constant) init (2);
  2   160   dcl ADDNAME		fixed bin static options (constant) init (3);
  2   161   dcl SYNONYM		fixed bin static options (constant) init (4);
  2   162   dcl RETAIN		fixed bin static options (constant) init (5);
  2   163   dcl DELETE		fixed bin static options (constant) init (6);
  2   164   dcl NO_LINK		fixed bin static options (constant) init (7);
  2   165   dcl TABLE		fixed bin static options (constant) init (8);
  2   166   dcl NO_TABLE		fixed bin static options (constant) init (9);
  2   167   
  2   168 /****  END OF:	le_input.incl.pl1			 *  *  *  *  *  */
      436 
      437 
      438   end le_make_opt_tbl_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/10/86  1252.1  le_make_opt_tbl_.pl1              >special_ldd>install>MR12.0-1241>le_make_opt_tbl_.pl1
435          1    12/10/86  1248.4  le_data.incl.pl1                  >special_ldd>install>MR12.0-1241>le_data.incl.pl1
436          2    12/10/86  1248.7  le_input.incl.pl1                 >special_ldd>install>MR12.0-1241>le_input.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DELETE                                 constant        fixed bin(17,0)          initial dcl 2-163 ref 89
LE_WARNING                      000014 constant        fixed bin(17,0)          initial dcl 1-19 set ref 100* 127* 131*
NO_LINK                                constant        fixed bin(17,0)          initial dcl 2-164 ref 89
RETAIN                                 constant        fixed bin(17,0)          initial dcl 2-162 ref 89 127 131
after                                                  builtin function         dcl 79 ref 96
before                                                 builtin function         dcl 80 ref 95
check_star_name_$entry          000010 constant        entry                    external dcl 49 ref 195 199
cl                              000100 automatic       fixed bin(17,0)          dcl 70 set ref 97* 112
class                     1(11)        based           fixed bin(6,0)           array level 3 in structure "leo" packed unaligned
                                                                                  dcl 393 in procedure "greater" ref 402 402 404 404
class                     1(11)        based           fixed bin(6,0)           array level 3 in structure "leo" packed unaligned
                                                                                  dcl 64 in procedure "le_make_opt_tbl_" set ref
                                                                                  112* 127 131 131
ec                                     parameter       fixed bin(35,0)          dcl 183 in procedure "get_class" set ref 148 195*
                                                                                  196 198 199* 200 202 203*
ec                              000101 automatic       fixed bin(35,0)          dcl 71 in procedure "le_make_opt_tbl_" set ref 97*
                                                                                  98
en                              000102 automatic       char(256)                unaligned dcl 72 set ref 96* 97* 111
ep_name                  12            based           char(256)                array level 3 in structure "leo" packed unaligned
                                                                                  dcl 393 in procedure "greater" ref 416 416 418 418
ep_name                  12            based           char(256)                array level 3 in structure "leo" packed unaligned
                                                                                  dcl 64 in procedure "le_make_opt_tbl_" set ref
                                                                                  111* 124 124 131*
exch                            000102 automatic       fixed bin(17,0)          dcl 293 set ref 308* 311* 312* 316* 317*
false                                  constant        bit(1)                   initial unaligned dcl 40 ref 108 397 404 411 418 426
flags                   206(18)        based           structure                array level 3 packed unaligned dcl 61
head                                   parameter       fixed bin(17,0)          dcl 286 set ref 266 297 308* 312* 316*
header                                 based           structure                level 2 in structure "leo" dcl 64 in procedure
                                                                                  "le_make_opt_tbl_"
header                                 based           structure                level 2 in structure "leo" dcl 236 in procedure
                                                                                  "sort_opts"
header                                 based           structure                level 2 in structure "le_input" dcl 2-114
                                                                                  in procedure "le_make_opt_tbl_"
header                                 based           structure                level 2 in structure "lei" dcl 61 in procedure
                                                                                  "le_make_opt_tbl_"
header                                 based           structure                level 2 in structure "le_options" dcl 1-202
                                                                                  in procedure "le_make_opt_tbl_"
i                               000234 automatic       fixed bin(17,0)          dcl 242 set ref 246* 247* 254* 255 256*
ignore                  206(19)        based           bit(1)                   array level 4 packed unaligned dcl 61 set ref 89
                                                                                  102*
inhibit_error           206(21)        based           bit(1)                   array level 4 in structure "lei" packed unaligned
                                                                                  dcl 61 in procedure "le_make_opt_tbl_" ref 107
inhibit_error             1(10)        based           bit(1)                   array level 3 in structure "leo" packed unaligned
                                                                                  dcl 64 in procedure "le_make_opt_tbl_" set ref
                                                                                  107*
io                              000202 automatic       fixed bin(17,0)          dcl 73 set ref 87* 89 89 89 89 94 95 96 100 102 106
                                                                                  107 109*
l                               000101 automatic       fixed bin(17,0)          dcl 292 set ref 297* 298 302 308* 311 312* 312
le_comp                                based           structure                level 1 dcl 1-89
le_definition                          based           structure                level 1 dcl 1-175
le_error_                       000012 constant        entry                    external dcl 50 ref 100 127 131
le_et_$bad_ep_starname          000014 external static fixed bin(35,0)          dcl 54 set ref 100*
le_et_$dup_ep_option            000016 external static fixed bin(35,0)          dcl 55 set ref 131*
le_et_$dup_global_option        000020 external static fixed bin(35,0)          dcl 56 set ref 127*
le_input                               based           structure                level 1 dcl 2-114
le_link                                based           structure                level 1 dcl 1-233
le_option                              based           structure                level 1 dcl 2-140
le_options                             based           structure                level 1 dcl 1-202
le_patch                               based           structure                level 1 dcl 1-298
lei                                    based           structure                level 1 dcl 61
leip                                   parameter       pointer                  dcl 44 ref 16 87 89 89 89 89 94 95 96 100 102 106
                                                                                  107
leo                                    based           structure                level 1 dcl 393 in procedure "greater"
leo                                    based           structure                level 1 dcl 64 in procedure "le_make_opt_tbl_"
leo                                    based           structure                level 1 dcl 349 in procedure "exchange"
leo                                    based           structure                level 1 dcl 236 in procedure "sort_opts"
leop                                   parameter       pointer                  dcl 45 in procedure "le_make_opt_tbl_" set ref 16
                                                                                  105 105 106 107 108 109 110 111 112 119* 123 124
                                                                                  124 124 124 127 127 131 131 131 131 131
leop                                   parameter       pointer                  dcl 232 in procedure "sort_opts" set ref 214 246
                                                                                  247* 247 254 255* 256*
leop                                   parameter       pointer                  dcl 343 in procedure "exchange" ref 326 357 358 358
                                                                                  359
leop                                   parameter       pointer                  dcl 285 in procedure "adjust_heap" set ref 266 308*
                                                                                  308* 312* 316* 317*
leop                                   parameter       pointer                  dcl 387 in procedure "greater" ref 368 402 402 404
                                                                                  404 409 409 411 411 416 416 418 418 424 424
mod                                                    builtin function         dcl 81 ref 131
n_opts                  115            based           fixed bin(17,0)          level 3 in structure "lei" dcl 61 in procedure
                                                                                  "le_make_opt_tbl_" ref 87
n_opts                                 based           fixed bin(17,0)          level 3 in structure "leo" dcl 236 in procedure
                                                                                  "sort_opts" set ref 246 247* 254
n_opts                                 based           fixed bin(17,0)          level 3 in structure "leo" dcl 64 in procedure
                                                                                  "le_make_opt_tbl_" set ref 105 105* 123
new                                    parameter       fixed bin(17,0)          dcl 388 ref 368 397 402 404 409 411 416 418 424
offsetname                             parameter       char                     unaligned dcl 182 set ref 148 195*
opt                     116            based           structure                array level 2 in structure "lei" dcl 61 in procedure
                                                                                  "le_make_opt_tbl_"
opt                       1            based           structure                array level 2 in structure "leo" dcl 64 in procedure
                                                                                  "le_make_opt_tbl_"
opt                       1            based           structure                array level 2 in structure "le_options" dcl 1-202
                                                                                  in procedure "le_make_opt_tbl_"
opt                       1            based           structure                array level 2 in structure "leo" dcl 393
                                                                                  in procedure "greater"
opt                       1            based           structure                array level 2 in structure "leo" dcl 349
                                                                                  in procedure "exchange" set ref 357 358* 358 359*
optx                            000203 automatic       fixed bin(17,0)          dcl 74 set ref 105* 106 107 108 109 110 111 112 123*
                                                                                  124 124 124 124 127 127 131 131 131 131 131*
order                     1(18)        based           fixed bin(17,0)          array level 3 in structure "leo" packed unaligned
                                                                                  dcl 393 in procedure "greater" ref 424 424
order                     1(18)        based           fixed bin(17,0)          array level 3 in structure "leo" packed unaligned
                                                                                  dcl 64 in procedure "le_make_opt_tbl_" set ref
                                                                                  109*
ordering_class                  000224 automatic       fixed bin(17,0)          dcl 187 set ref 198* 202* 202 205
orig                                   parameter       fixed bin(17,0)          dcl 389 ref 368 402 404 409 411 416 418 424
path_or_ep              126            based           char(194)                array level 3 packed unaligned dcl 61 set ref 95 96
                                                                                  100*
r                               000100 automatic       fixed bin(17,0)          dcl 291 set ref 298* 305 305* 308* 308* 308
segname                   2            based           char(32)                 array level 3 in structure "leo" packed unaligned
                                                                                  dcl 393 in procedure "greater" ref 409 409 411 411
segname                                parameter       char                     unaligned dcl 181 in procedure "get_class" set ref
                                                                                  148 199*
segname                   2            based           char(32)                 array level 3 in structure "leo" packed unaligned
                                                                                  dcl 64 in procedure "le_make_opt_tbl_" set ref
                                                                                  110* 124 124 131*
size                                   parameter       fixed bin(17,0)          dcl 287 set ref 266 302 305 317*
sn                              000204 automatic       char(32)                 unaligned dcl 75 set ref 95* 97* 110
temp                            000100 automatic       structure                level 1 dcl 355 set ref 357* 359
true                                   constant        bit(1)                   initial unaligned dcl 39 ref 94 102 402 409 416 424
type                      1            based           fixed bin(8,0)           array level 3 in structure "leo" packed unaligned
                                                                                  dcl 64 in procedure "le_make_opt_tbl_" set ref
                                                                                  106* 127 131
type                    206(27)        based           fixed bin(8,0)           array level 3 in structure "lei" packed unaligned
                                                                                  dcl 61 in procedure "le_make_opt_tbl_" ref 89 89
                                                                                  89 106
used                      1(09)        based           bit(1)                   array level 3 in structure "leo" packed unaligned
                                                                                  dcl 64 in procedure "le_make_opt_tbl_" set ref
                                                                                  108*
used                    206(20)        based           bit(1)                   array level 4 in structure "lei" packed unaligned
                                                                                  dcl 61 in procedure "le_make_opt_tbl_" set ref 94*
x1                                     parameter       fixed bin(17,0)          dcl 344 ref 326 358 359
x2                                     parameter       fixed bin(17,0)          dcl 345 ref 326 357 358

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ADDNAME                                internal static fixed bin(17,0)          initial dcl 2-160
Definition                             internal static fixed bin(3,0)           initial dcl 1-32
Heap                                   internal static fixed bin(3,0)           initial dcl 1-38
LE_ABORT_ERROR                         internal static fixed bin(17,0)          initial dcl 1-22
LE_ERROR                               internal static fixed bin(17,0)          initial dcl 1-20
LE_FATAL_ERROR                         internal static fixed bin(17,0)          initial dcl 1-21
LIBRARY                                internal static fixed bin(17,0)          initial dcl 2-159
Linkage                                internal static fixed bin(3,0)           initial dcl 1-28
NO_TABLE                               internal static fixed bin(17,0)          initial dcl 2-166
PATH                                   internal static fixed bin(17,0)          initial dcl 2-158
Patch_Init                             internal static fixed bin(17,0)          initial dcl 1-59
Patch_Link                             internal static fixed bin(17,0)          initial dcl 1-58
Patch_Self_Init                        internal static fixed bin(17,0)          initial dcl 1-61
Patch_Symbol_Ref                       internal static fixed bin(17,0)          initial dcl 1-60
Refname_Base                           internal static fixed bin(3,0)           initial dcl 1-49
Refname_Offsetname                     internal static fixed bin(3,0)           initial dcl 1-51
SYNONYM                                internal static fixed bin(17,0)          initial dcl 2-161
Self_Base                              internal static fixed bin(3,0)           initial dcl 1-47
Self_Offsetname                        internal static fixed bin(3,0)           initial dcl 1-53
Static                                 internal static fixed bin(3,0)           initial dcl 1-34
Symbol                                 internal static fixed bin(3,0)           initial dcl 1-30
System                                 internal static fixed bin(3,0)           initial dcl 1-36
TABLE                                  internal static fixed bin(17,0)          initial dcl 2-165
Text                                   internal static fixed bin(3,0)           initial dcl 1-26
def_count                              automatic       fixed bin(17,0)          dcl 1-173
le_binaries                            based           structure                level 1 dcl 1-260
le_components                          based           structure                level 1 dcl 1-72
le_definitions                         based           structure                level 1 dcl 1-167
le_input_version_1                     internal static char(8)                  initial unaligned dcl 2-153
le_links                               based           structure                level 1 dcl 1-225
le_patches                             based           structure                level 1 dcl 1-293
le_segnames                            based           structure                level 1 dcl 1-149
link_count                             automatic       fixed bin(17,0)          dcl 1-231
section_nm                             internal static char(16)                 initial array unaligned dcl 1-41
segname_count                          automatic       fixed bin(17,0)          dcl 1-156
unspec                                                 builtin function         dcl 82

NAMES DECLARED BY EXPLICIT CONTEXT.
adjust_heap                     000740 constant        entry                    internal dcl 266 ref 247 256 317
exchange                        001105 constant        entry                    internal dcl 326 ref 255 316
get_class                       000526 constant        entry                    internal dcl 148 ref 97
greater                         001140 constant        entry                    internal dcl 368 ref 308 308 312
le_make_opt_tbl_                000062 constant        entry                    external dcl 16
sort_opts                       000631 constant        entry                    internal dcl 214 ref 119

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1436        1460    1324        1446
Length      1706    1324        22         211     112           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
le_make_opt_tbl_                    258 external procedure  is an external procedure.  
get_class                               internal procedure  shares stack frame of external procedure le_make_opt_tbl_.  
sort_opts                               internal procedure  shares stack frame of external procedure le_make_opt_tbl_.  
adjust_heap                          92 internal procedure  calls itself recursively.  
exchange                            138 internal procedure  is called by several nonquick procedures.  
greater                                 internal procedure  shares stack frame of internal procedure adjust_heap.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
adjust_heap              000100 r                           adjust_heap
                         000101 l                           adjust_heap
                         000102 exch                        adjust_heap
exchange                 000100 temp                        exchange
le_make_opt_tbl_         000100 cl                          le_make_opt_tbl_
                         000101 ec                          le_make_opt_tbl_
                         000102 en                          le_make_opt_tbl_
                         000202 io                          le_make_opt_tbl_
                         000203 optx                        le_make_opt_tbl_
                         000204 sn                          le_make_opt_tbl_
                         000224 ordering_class              get_class
                         000234 i                           sort_opts

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_l_a               r_ne_as             call_ext_out_desc   call_int_this       call_int_other      return_mac
mdfx1               ext_entry           int_entry           trunc_fx2           divide_fx1

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
check_star_name_$entry        le_error_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
le_et_$bad_ep_starname        le_et_$dup_ep_option          le_et_$dup_global_option




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     16 000056        87 000067        89 000101        94 000124        95 000126        96 000146        97 000170
     98 000173       100 000175       102 000234       103 000242       105 000243       106 000251       107 000264
    108 000271       109 000273       110 000276       111 000302       112 000306       115 000313       119 000315
    123 000324       124 000337       127 000360       131 000423       139 000523       141 000525       148 000526
    195 000544       196 000563       198 000572       199 000574       200 000612       202 000621       203 000626
    205 000627       214 000631       246 000633       247 000647       248 000663       254 000666       255 000677
    256 000716       257 000733       259 000736       266 000737       297 000745       298 000751       302 000753
    305 000756       308 000762       311 001024       312 001027       314 001052       316 001053       317 001067
    319 001103       326 001104       357 001112       358 001123       359 001133       361 001137       368 001140
    397 001142       402 001151       404 001177       409 001205       411 001223       416 001231       418 001245
    424 001253       426 001271


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
