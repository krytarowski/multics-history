	COMPILATION LISTING OF SEGMENT abs_io_control
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 08/11/87  0925.9 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* format: style3,idind30,ll122,ifthenstmt */
        9 
       10 abs_io_control:
       11      procedure (P_iocb_ptr, P_order, P_info_ptr, P_status);
       12 
       13 /* Initial coding: 25 June 1979 by J. Spencer Love							*/
       14 /* Modified: 12 June 1980 by J. Spencer Love to add sleep and close entrypoints, and to handle io_call orders		*/
       15 /* Control order "no_set_bc" added for "ear -no_set_bit_count" 07/29/81 S. Herbst */
       16 /* Incorrect COMMAND and FUNCTION labels sorted out 07/28/82 S. Herbst */
       17 /* Recompiled for changed abs_data structure 04/12/83 S. Herbst */
       18 /* Added "set_trace" control order to implement ec -trace 05/03/84 S. Herbst */
       19 
       20 /* Parameters											*/
       21 
       22 declare	P_iocb_ptr		ptr parameter,
       23 	P_attach_data_ptr		ptr parameter,
       24 	P_order			char (*) parameter,
       25 	P_arg_array		(*) char (*) varying parameter,
       26 	P_info_ptr		ptr parameter,
       27 	P_first_arg		fixed bin parameter,
       28 	P_status			fixed bin (35) parameter;
       29 
       30 /* Builtin											*/
       31 
       32 declare	(addr, fixed, hbound, lbound, length, null, substr, unspec)
       33 				builtin;
       34 
       35 declare	(area, any_other, bad_area_format, bad_area_initialization)
       36 				condition;
       37 
       38 /* Automatic											*/
       39 
       40 declare	arg_array_ptr		ptr,
       41 	arg_array_size		fixed bin,
       42 	arg_idx			fixed bin,
       43 	factor			float bin,
       44 	first_arg			fixed bin,
       45 	info_ptr			ptr,
       46 	iocb_ptr			ptr,
       47 	mask			bit (36),
       48 	order			fixed bin,
       49 	sleep_time		fixed bin (71),
       50 	status			fixed bin (35);
       51 
       52 /* External											*/
       53 
       54 declare	(
       55 	error_table_$badcall,
       56 	error_table_$badopt,
       57 	error_table_$no_operation,
       58 	error_table_$noalloc,
       59 	error_table_$notalloc,
       60 	error_table_$unable_to_do_io,
       61 	error_table_$undefined_order_request
       62 	)			fixed bin (35) external,
       63 	iox_$user_input		ptr external;
       64 
       65 /* Based												*/
       66 
       67 declare	attach_descrip		char (256) varying based;
       68 
       69 declare	1 timed_input		based (info_ptr),
       70 	  2 low_sleep_time		fixed bin (35),
       71 	  2 sleep_time_range	fixed bin (35),
       72 	  2 seed			fixed bin (35);
       73 
       74 declare	1 arg_array		(arg_array_size) aligned based (arg_array_ptr),
       75 	  2 ptr			ptr,
       76 	  2 len			fixed bin (21),
       77 	  2 quotes		fixed bin (21);
       78 
       79 declare	arg_string		char (arg_array (arg_idx).len) based (arg_array (arg_idx).ptr);
       80 
       81 declare	1 set_args		aligned based (info_ptr),
       82 	  2 count			fixed bin,
       83 	  2 e			(0 refer (set_args.count)),
       84 	    3 ptr			ptr unaligned,
       85 	    3 len			fixed bin (21);
       86 
       87 /* Constants											*/
       88 
       89 declare	Orders			(11) char (32) varying static options (constant)
       90 				initial ("attach", "detach", "set_ec_data_ptr", "set_argument_ptrs",
       91 				"set_arguments", "timed_input", "io_call", "io_call_af", "no_set_bc", "set_bc",
       92 				"set_trace");
       93 
       94 declare	Active			(11) bit (1) aligned static options (constant)
       95 				initial ((3) ("1"b), (2) ("0"b), (6) ("1"b));
       96 
       97 declare	Open			(11) bit (1) aligned static options (constant) initial ((11) ("1"b));
       98 
       99 declare	Closed			(11) bit (1) aligned static options (constant) initial ((2) ("0"b), (9) ("1"b));
      100 
      101 declare	Info			(0:11) bit (1) aligned static options (constant) initial ((3) ("0"b), (9) ("1"b));
      102 
      103 declare	Null			(0:11) bit (1) aligned static options (constant)
      104 				initial ((4) ("1"b), (5) ("0"b), (2) ("1"b), "0"b);
      105 
      106 declare	Command			(0:11) bit (1) aligned static options (constant)
      107 				initial ((3) ("1"b), (2) ("0"b), (7) ("1"b));
      108 
      109 declare	Function			(0:11) bit (1) aligned static options (constant)
      110 				initial ("1"b, (6) ("0"b), (5) ("1"b));
      111 
      112 /* Entries											*/
      113 
      114 declare	continue_to_signal_		entry (fixed bin (35)),
      115 	hcs_$reset_ips_mask		entry (bit (36), bit (36)),
      116 	hcs_$set_ips_mask		entry (bit (36), bit (36)),
      117 	iox_$attach_ptr		entry (ptr, char (*), ptr, fixed bin (35)),
      118 	iox_$detach_iocb		entry (ptr, fixed bin (35)),
      119 	iox_$find_iocb		entry (char (*), ptr, fixed bin (35)),
      120 	iox_$move_attach		entry (ptr, ptr, fixed bin (35)),
      121 	random_$uniform		entry (fixed bin (35), float bin),
      122 	terminate_process_		entry (char (*), ptr),
      123 	timer_manager_$sleep	entry (fixed bin (71), bit (2));
      124 
      125 /* abs_io_control:
      126*        procedure (P_iocb_ptr, P_order, P_info_ptr, P_status);						*/
      127 
      128 	iocb_ptr = P_iocb_ptr -> iocb.actual_iocb_ptr;
      129 	abs_data_ptr = iocb_ptr -> iocb.attach_data_ptr;
      130 	ec_data_ptr = abs_data.ec_data_ptr;
      131 	info_ptr = P_info_ptr;
      132 	mask = ""b;
      133 	status = 0;
      134 
      135 	order = interpret_order (P_order);
      136 	if (info_ptr ^= null () & Info (order)) | (info_ptr = null () & Null (order)) then go to ORDER (order);
      137 
      138 ORDER (0):					/* 0 subscript is for undefined order			*/
      139 COMMAND (0):
      140 FUNCTION (0):
      141 COMMAND (7):					/* io_call order may not specify io_call or io_call_af	*/
      142 FUNCTION (7):
      143 COMMAND (8):					/* io_call_af order may not specify io_call or io_call_af	*/
      144 FUNCTION (8):
      145 FUNCTION (9):
      146 FUNCTION (10):
      147 NO_OPERATION:					/* Come here if operation cannot be performed now		*/
      148 	status = error_table_$no_operation;
      149 
      150 	go to EGRESS;
      151 
      152 CALL_BACK_LATER:
      153 	status = error_table_$undefined_order_request;
      154 
      155 	go to EGRESS;
      156 
      157 BAD_CALL:						/* Come here to reject input data structure		*/
      158 	status = error_table_$badcall;
      159 
      160 	go to EGRESS;
      161 
      162 AREA_FULL:					/* come here for area condition			*/
      163 	status = error_table_$noalloc;
      164 
      165 	go to EGRESS;
      166 
      167 BAD_AREA:						/* come here for bad_area_format or bad_area_initialization */
      168 	status = error_table_$notalloc;
      169 
      170 EGRESS:
      171 	if substr (mask, 36, 1) then call hcs_$reset_ips_mask (mask, mask);
      172 
      173 	P_status = status;
      174 
      175 	return;
      176 
      177 interpret_order:
      178      procedure (P_order) returns (fixed bin);
      179 
      180 declare	P_order			char (*),
      181 	order			fixed bin;
      182 
      183 	do order = lbound (Orders, 1) to hbound (Orders, 1);
      184 	     if Orders (order) = P_order
      185 	     then if (iocb_ptr -> iocb.open_descrip_ptr = null () & ^Closed (order))
      186 		     | (iocb_ptr -> iocb.open_descrip_ptr ^= null () & ^abs_data.active & ^Open (order))
      187 		     | (abs_data.active & ^Active (order))
      188 		then return (0);
      189 		else return (order);
      190 	end;
      191 
      192 	return (0);
      193 
      194      end interpret_order;
      195 
      196 /* ORDER = "set_ec_data_ptr"  This order is used to estabish communication between listeners and abs_io_.		*/
      197 
      198 ORDER (3):
      199 	if info_ptr ^= null
      200 	then do;
      201 		if info_ptr -> ec_data.version ^= ec_data_version_1 then go to BAD_CALL;
      202 		if info_ptr -> ec_data.version_id ^= ec_data_version_id then go to BAD_CALL;
      203 	     end;
      204 
      205 	abs_data.ec_data_ptr = info_ptr;
      206 
      207 	go to EGRESS;
      208 
      209 /* ORDER = "timed_input"  This is used to simulate interactive usage by going blocked on each get_line call		*/
      210 
      211 ORDER (6):
      212 	if timed_input.sleep_time_range < 0 then go to BAD_CALL;
      213 
      214 	abs_data.timed_input = (timed_input.low_sleep_time + timed_input.sleep_time_range > 0);
      215 
      216 	if ^abs_data.timed_input then go to EGRESS;
      217 
      218 	abs_data.low_sleep_time = timed_input.low_sleep_time;
      219 	abs_data.sleep_time_range = timed_input.sleep_time_range;
      220 	abs_data.seed = timed_input.seed;
      221 
      222 	go to EGRESS;
      223 
      224 COMMAND (6):
      225 	if io_call_info.nargs ^= 1
      226 	then do;
      227 		call io_call_info.error (0, io_call_info.caller_name, "One of ""-on"" or ""-off"" must be given.");
      228 		go to EGRESS;
      229 	     end;
      230 
      231 	if io_call_info.args (1) = "-off" then abs_data.timed_input = "0"b;
      232 	else if io_call_info.args (1) = "-on"
      233 	then abs_data.timed_input = (abs_data.low_sleep_time + abs_data.sleep_time_range > 0);
      234 	else call io_call_info.error (error_table_$badopt, io_call_info.caller_name, "^a", io_call_info.args (1));
      235 
      236 	go to EGRESS;
      237 
      238 /* This entrypoint is used to simulate interactive waits.  Waits are uniformly distributed over a range.  The range can
      239*   overlap zero so that some specified percentage of calls will result in no wait (to simulate type ahead).  The only
      240*   thing it lacks is the priority boost that is caused by a real interaction.  This feature is used for benchmarking.	*/
      241 
      242 abs_io_control$sleep:
      243      entry (P_attach_data_ptr);
      244 
      245 	abs_data_ptr = P_attach_data_ptr;
      246 
      247 	call random_$uniform (abs_data.seed, factor);
      248 	sleep_time = fixed (factor * abs_data.sleep_time_range, 71) + abs_data.low_sleep_time;
      249 	if sleep_time > 0 then call timer_manager_$sleep (sleep_time, "10"b);
      250 
      251 	return;
      252 
      253 attach:
      254      entry (P_attach_data_ptr, P_info_ptr, P_status);
      255 
      256 	abs_data_ptr = P_attach_data_ptr;
      257 	ec_data_ptr = abs_data.ec_data_ptr;
      258 	info_ptr = P_info_ptr;
      259 	mask = ""b;
      260 	status = 0;
      261 
      262 ORDER (1):
      263 	on any_other call any_other_handler ();
      264 
      265 	call hcs_$set_ips_mask (mask, mask);
      266 
      267 	if ec_data_ptr = null () then go to NO_OPERATION;
      268 
      269 	if abs_data.attach.target_ptr ^= null () then go to NO_OPERATION;
      270 
      271 	if abs_data.attach.save_ptr = null ()
      272 	then do;
      273 		call iox_$find_iocb (ec_data.id_string || "." || abs_data.io_module_name, abs_data.attach.save_ptr,
      274 		     status);
      275 		if status ^= 0 then go to EGRESS;
      276 	     end;
      277 
      278 	abs_data.attach.victim_ptr = iox_$user_input;
      279 	call iox_$move_attach (abs_data.attach.victim_ptr, abs_data.attach.save_ptr, status);
      280 	if status ^= 0 then go to EGRESS;
      281 
      282 	abs_data.attach.target_ptr = ec_data.switch_ptr;
      283 	call iox_$attach_ptr (abs_data.attach.victim_ptr, "syn_ " || abs_data.attach.target_ptr -> iocb.name, null (),
      284 	     status);
      285 	if status ^= 0
      286 	then do;
      287 		call iox_$move_attach (abs_data.attach.save_ptr, abs_data.attach.victim_ptr, (0));
      288 		abs_data.attach.target_ptr = null ();
      289 		go to EGRESS;
      290 	     end;
      291 
      292 	call hcs_$reset_ips_mask (mask, mask);
      293 
      294 	go to EGRESS;
      295 
      296 COMMAND (1):
      297 	if io_call_info.nargs > 0
      298 	then do;
      299 		call io_call_info.error (0, io_call_info.caller_name, "No arguments are permitted for ""attach"".");
      300 		go to EGRESS;
      301 	     end;
      302 
      303 	go to ORDER (1);
      304 
      305 abs_io_control$detach:
      306      entry (P_attach_data_ptr, P_info_ptr, P_status);
      307 
      308 	abs_data_ptr = P_attach_data_ptr;
      309 	info_ptr = P_info_ptr;
      310 	mask = ""b;
      311 	status = 0;
      312 
      313 ORDER (2):
      314 	on any_other call any_other_handler ();
      315 
      316 	call hcs_$set_ips_mask (mask, mask);
      317 
      318 	status = detach ();
      319 
      320 	call hcs_$reset_ips_mask (mask, mask);
      321 
      322 	go to EGRESS;
      323 
      324 
      325 
      326 COMMAND (2):					/* "io control &ec_switch detach" */
      327 	if io_call_info.nargs > 0
      328 	then do;
      329 		call io_call_info.error (0, io_call_info.caller_name, "No arguments are permitted for ""detach"".");
      330 		go to EGRESS;
      331 	     end;
      332 
      333 	on any_other call any_other_handler ();
      334 
      335 	call hcs_$set_ips_mask (mask, mask);
      336 
      337 	status = detach ();
      338 
      339 	call hcs_$reset_ips_mask (mask, mask);
      340 
      341 	if status ^= 0 then call io_call_info.error (status, io_call_info.caller_name, "Detaching.");
      342 	status = 0;
      343 
      344 	go to EGRESS;
      345 
      346 
      347 
      348 abs_io_control$close:
      349      entry (P_attach_data_ptr);
      350 
      351 	abs_data_ptr = P_attach_data_ptr;
      352 
      353 	status = detach ();
      354 
      355 	call iox_$detach_iocb (abs_data.attach.save_ptr, (0));
      356 
      357 	return;
      358 
      359 detach:
      360      procedure () returns (fixed bin (35));
      361 
      362 	if abs_data.attach.target_ptr = null () then return (error_table_$no_operation);
      363 
      364 	if abs_data.attach.victim_ptr -> iocb.attach_descrip_ptr -> attach_descrip
      365 	     ^= "syn_ " || abs_data.attach.target_ptr -> iocb.name
      366 	then return (error_table_$badcall);
      367 
      368 	call iox_$detach_iocb (abs_data.attach.victim_ptr, status);
      369 	if status ^= 0 then return (status);
      370 
      371 	call iox_$move_attach (abs_data.attach.save_ptr, abs_data.attach.victim_ptr, status);
      372 	if status ^= 0
      373 	then do;
      374 		call iox_$attach_ptr (abs_data.attach.victim_ptr, "syn_ " || abs_data.attach.target_ptr -> iocb.name,
      375 		     null (), (0));
      376 		return (status);
      377 	     end;
      378 
      379 	abs_data.attach.target_ptr, abs_data.attach.victim_ptr = null ();
      380 
      381 	return (0);
      382 
      383      end detach;
      384 
      385 /* ORDER = "set_argument_ptrs"  Set ptrs and lengths of arguments from info structure without copying for efficiency	*/
      386 
      387 ORDER (4):
      388 	call release_args ();
      389 
      390 	arg_array_size = set_args.count;
      391 	call allocate_arg_array ();
      392 
      393 	arg_array (*).len = set_args (*).len;
      394 	arg_array (*).ptr = set_args (*).ptr;
      395 	arg_array (*).quotes = -1;
      396 
      397 	abs_data.arg_count = arg_array_size;
      398 	abs_data.args_copied = "0"b;
      399 	abs_data.arg_ptr = arg_array_ptr;
      400 
      401 	go to EGRESS;
      402 
      403 /* ORDER = "set_arguments"  Used to set arguments from structure of pointers and lengths, copying them into work_area	*/
      404 
      405 ORDER (5):
      406 	call release_args ();
      407 
      408 	arg_array_size = set_args.count;
      409 	call allocate_arg_array ();
      410 
      411 	do arg_idx = 1 to arg_array_size;
      412 	     arg_array (arg_idx).len = set_args (arg_idx).len;
      413 	     arg_array (arg_idx).quotes = -1;
      414 	     allocate arg_string in (abs_data.work_area);
      415 	     arg_string = set_args (arg_idx).ptr -> arg_string;
      416 	end;
      417 
      418 	abs_data.arg_count = arg_array_size;
      419 	abs_data.args_copied = "1"b;
      420 	abs_data.arg_ptr = arg_array_ptr;
      421 
      422 	go to EGRESS;
      423 
      424 COMMAND (5):
      425 	call release_args ();
      426 
      427 	arg_array_size = io_call_info.nargs;
      428 	call allocate_arg_array ();
      429 
      430 	do arg_idx = 1 to arg_array_size;
      431 	     arg_array (arg_idx).len = length (io_call_info.args (arg_idx));
      432 	     arg_array (arg_idx).quotes = -1;
      433 	     allocate arg_string in (abs_data.work_area);
      434 	     arg_string = io_call_info.args (arg_idx);
      435 	end;
      436 
      437 	abs_data.arg_count = arg_array_size;
      438 	abs_data.args_copied = "1"b;
      439 	abs_data.arg_ptr = arg_array_ptr;
      440 
      441 	go to EGRESS;
      442 
      443 /* This entrypoint is used by abs_io_attach to set arguments which are given on in the attach description		*/
      444 
      445 set_arguments:
      446      entry (P_attach_data_ptr, P_arg_array, P_first_arg, P_status);
      447 
      448 	abs_data_ptr = P_attach_data_ptr;
      449 	first_arg = P_first_arg;
      450 	mask = ""b;
      451 	status = 0;
      452 
      453 	if first_arg <= 0 then go to EGRESS;
      454 
      455 	call release_args ();
      456 
      457 	arg_array_size = hbound (P_arg_array, 1) - first_arg + 1;
      458 	call allocate_arg_array ();
      459 
      460 	do arg_idx = 1 to arg_array_size;
      461 	     arg_array (arg_idx).len = length (P_arg_array (arg_idx + first_arg - 1));
      462 	     arg_array (arg_idx).quotes = -1;
      463 	     allocate arg_string in (abs_data.work_area);
      464 	     arg_string = P_arg_array (arg_idx + first_arg - 1);
      465 	end;
      466 
      467 	abs_data.arg_count = arg_array_size;
      468 	abs_data.args_copied = "1"b;
      469 	abs_data.arg_ptr = arg_array_ptr;
      470 
      471 	go to EGRESS;
      472 
      473 /* This internal procedure is used to allocate argument info with condition handlers				*/
      474 
      475 allocate_arg_array:
      476      procedure ();
      477 
      478 	if arg_array_size <= 0 then go to EGRESS;
      479 
      480 	on area go to AREA_FULL;
      481 	on bad_area_format go to BAD_AREA;
      482 	on bad_area_initialization go to BAD_AREA;
      483 
      484 	allocate arg_array in (abs_data.work_area);
      485 
      486 	return;
      487 
      488      end allocate_arg_array;
      489 
      490 /* This internal procedure is used by the argument setting routines to release storage that previously held arguments	*/
      491 
      492 release_args:
      493      procedure ();
      494 
      495 	arg_array_ptr = abs_data.arg_ptr;
      496 	arg_array_size = abs_data.arg_count;
      497 	abs_data.arg_ptr = null ();
      498 	abs_data.arg_count = 0;
      499 	if abs_data.args_copied
      500 	then do arg_idx = 1 to arg_array_size;
      501 		free arg_string;
      502 	     end;
      503 	if arg_array_ptr ^= null () then free arg_array;
      504 
      505 	return;
      506      end release_args;
      507 
      508 /* ORDER = "io_call"										*/
      509 
      510 ORDER (7):
      511 	io_call_infop = info_ptr;
      512 	if io_call_info.version ^= 1 then go to NO_OPERATION;
      513 
      514 	order = interpret_order ((io_call_info.order_name));
      515 	if Command (order) then go to COMMAND (order);
      516 
      517 	go to CALL_BACK_LATER;
      518 
      519 /* ORDER = "io_call_af"										*/
      520 
      521 ORDER (8):
      522 	io_call_infop = info_ptr;
      523 	if io_call_info.version ^= 1 then go to NO_OPERATION;
      524 
      525 	order = interpret_order ((io_call_info.order_name));
      526 	if Function (order) then go to FUNCTION (order);
      527 
      528 	go to CALL_BACK_LATER;
      529 
      530 /* ORDER = "no_set_bc" */
      531 
      532 ORDER (9):
      533 COMMAND (9):
      534 	abs_data.open_data.no_set_bc = "1"b;
      535 
      536 	go to EGRESS;
      537 
      538 
      539 /* ORDER = "set_bc" */
      540 
      541 ORDER (10):
      542 COMMAND (10):
      543 	abs_data.open_data.no_set_bc = "0"b;
      544 
      545 	go to EGRESS;
      546 
      547 /* ORDER = "set_trace" */
      548 
      549 ORDER (11):
      550 	call set_trace (info_ptr -> ec_trace_info.command_line, abs_data.command_line);
      551 	call set_trace (info_ptr -> ec_trace_info.comment_line, abs_data.comment_line);
      552 	call set_trace (info_ptr -> ec_trace_info.control_line, abs_data.control_line);
      553 	call set_trace (info_ptr -> ec_trace_info.input_line, abs_data.input_line);
      554 
      555 	go to EGRESS;
      556 
      557 set_trace: proc (P_info_line, P_abs_line);
      558 
      559 /* This internal procedure copies the elements of ec_trace_info into the trace portion of abs_data trace */
      560 
      561 dcl 1 P_info_line aligned like ec_trace_info.command_line;
      562 dcl 1 P_abs_line aligned like abs_data.command_line;
      563 
      564 	if ^P_info_line.explicit_sw then return;	/* nothing to set for this type of line */
      565 
      566 	P_abs_line.by_control_arg = "1"b;
      567 	P_abs_line.on = P_info_line.on;
      568 	P_abs_line.expand = P_info_line.expand;
      569 	if unspec (P_info_line.iocb) = "0"b then P_abs_line.iocb = null;
      570 	else P_abs_line.iocb = P_info_line.iocb;
      571 	P_abs_line.prefix = P_info_line.prefix;
      572 
      573 end set_trace;
      574 
      575 any_other_handler:
      576      procedure ();
      577 
      578 declare	1 ts			aligned,
      579 	  2 version		fixed bin,
      580 	  2 status_code		fixed bin (35);
      581 
      582 	if substr (mask, 36, 1)
      583 	then do;
      584 		ts.version = 0;
      585 		ts.status_code = error_table_$unable_to_do_io;
      586 		call terminate_process_ ("fatal_error", addr (ts));
      587 	     end;
      588 
      589 	call continue_to_signal_ ((0));		/* We don't want it; pass it on			*/
      590 
      591 	return;
      592 
      593      end any_other_handler;
      594 
  1     1 /*  START OF:	abs_io_data.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(87-02-20,Parisek), approve(87-07-23,MCR7716),
  1     6*     audit(87-07-30,Fawcett), install(87-08-11,MR12.1-1080):
  1     7*     Added the noabort flag for determining whether or not to abort after
  1     8*     exec_com error occurs.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* Initial coding: 25 June 79 by J. Spencer Love */
  1    13 /* login_channel option flag BIM 11/81 */
  1    14 /* Added this_action and next_action 04/20/82 S. Herbst */
  1    15 /* Added on_info, goto_statement_(pos len) 01/06/83 S. Herbst */
  1    16 /* Added output_file.turn_off_ssw 05/16/83 S. Herbst */
  1    17 /* Added attach.trim_whitespace_sw 06/02/83 S. Herbst */
  1    18 /* Added listener_pl1_label and get_line_pl1_label 11/17/83 S. Herbst */
  1    19 /* Added (command comment control input)_line.by_control_arg 03/20/84 S. Herbst */
  1    20 
  1    21 declare	abs_data_ptr		ptr;
  1    22 
  1    23 declare	1 abs_data		aligned based (abs_data_ptr),
  1    24 	  2 version		fixed bin,	/* Version = 1					*/
  1    25 	  2 io_module_name		char (32) varying,	/* either "abs_io_" or "ec_input_"			*/
  1    26 	  2 open_description	char (24) varying,	/* either "stream_input" or "stream_input_output"		*/
  1    27 	  2 unique_name		char (15) varying,	/* &! -- either blank or 15 char unique string		*/
  1    28 						/*						*/
  1    29 	  2 ec_data_ptr		ptr,		/* -> communication area for exec_com			*/
  1    30 	  2 expand_data_ptr		ptr,		/* -> structure for abs_io_expand_			*/
  1    31 						/*						*/
  1    32 	  2 instance_chain,				/* two way linked chain of abs_data blocks for debugging	*/
  1    33 	    3 prev_ptr		ptr,		/* -> next older abs_data instance			*/
  1    34 	    3 next_ptr		ptr,		/* -> next newer abs_data instance			*/
  1    35 	    3 level		fixed bin,	/* level of ec invocation in chain for debugging		*/
  1    36 	    3 pad			bit (36),		/*						*/
  1    37 						/*						*/
  1    38 	  2 arg_info,				/*						*/
  1    39 	    3 ec_path_ptr		ptr,		/* Ptr to allocated &ec_path string			*/
  1    40 	    3 ec_path_len		fixed bin (21),	/* Length of allocated &ec_path (&0) string		*/
  1    41 	    3 ec_path_quotes	fixed bin (21),	/* Number of quote chars in &ec_path, -1 if not yet counted */
  1    42 	    3 ec_name_ptr		ptr,		/* Ptr to allocated &ec_name string			*/
  1    43 	    3 ec_name_len		fixed bin (21),	/* Length of allocated &ec_name string			*/
  1    44 	    3 ec_name_quotes	fixed bin (21),	/* Number of quote chars in &ec_name, -1 if not yet counted */
  1    45 	    3 arg_ptr		ptr,		/* pointer to allocated structure containing args		*/
  1    46 	    3 arg_count		fixed bin,	/* number of arguments passed				*/
  1    47 	    3 args_copied		bit (1),		/* 1 indicates arguments were copied into work_area	*/
  1    48 	    3 default_arg_ptr	ptr,		/* pointer to allocated &default args			*/
  1    49 	    3 default_arg_count	fixed bin,	/* number of &default args				*/
  1    50 	    3 pad			bit (36),		/*						*/
  1    51 						/*						*/
  1    52 	  2 input_string,				/* data about input segment or archive component		*/
  1    53 	    3 ptr			ptr,		/* pointer to input file				*/
  1    54 	    3 len			fixed bin (21),	/* number of characters in input file			*/
  1    55 	    3 start		fixed bin (21),	/* initial value for input_pos, set beyond &version, if any */
  1    56 	    3 position		fixed bin (21),	/* current index into input file			*/
  1    57 	    3 limit		fixed bin (21),	/* farthest point yet reached...begin &label search here	*/
  1    58 						/*						*/
  1    59 	  2 open_data,				/* data saved at attach time for open time		*/
  1    60 	    3 output_dir		char (168) unal,	/* directory pathname of output file (if specified)	*/
  1    61 	    3 output_entry		char (32) unal,	/* entryname of output file (if specified)		*/
  1    62 	    3 parser_version	fixed bin,	/* indicates version of parser (get_line) for open	*/
  1    63 	    3 si			bit (1) unal,	/* 1 indicates opening for stream_input permitted		*/
  1    64 	    3 sio			bit (1) unal,	/* 1 indicates opening for stream_input_output permitted	*/
  1    65 	    3 ssf			bit (1) unal,	/* 1 indicates output file cannot be MSF		*/
  1    66 	    3 truncate		bit (1) unal,	/* 1 indicates output file truncated at open		*/
  1    67 	    3 no_set_bc		bit (1) unal,	/* 1 to set absout bitcount only at close		  */
  1    68 	    3 login_channel		bit (1) unal,       /* 1 to fish arguments from PIT */
  1    69 	    3 pad			bit (30) unal,	/* 						*/
  1    70 						/*						*/
  1    71 	  2 output_file,				/* data for abs_io_put_chars				*/
  1    72 	    3 fcb_ptr		ptr,		/* -> File Control Block for msf_manager_, null if SSF	*/
  1    73 	    3 seg_ptr		ptr,		/* -> base of current component of output file		*/
  1    74 	    3 current_len		fixed bin (21),	/* number of characters in current component		*/
  1    75 	    3 max_len		fixed bin (21),	/* max number of characters in a component		*/
  1    76 	    3 MSF_seg_idx		fixed bin,	/* index of current MSF component. Used to get new ones	*/
  1    77 	    3 switches		aligned,
  1    78 	     4 may_be_MSF		bit (1) unaligned,	/* 1 indicates absout can become an MSF		*/
  1    79 	     4 turn_off_ssw		bit (1) unaligned,	/* 1 means safety switch of absout was off originally	*/
  1    80 	     4 mbz		bit (34) unaligned,
  1    81 						/*						*/
  1    82 	  2 command_line,				/* substructure dealing with tracing command lines	*/
  1    83 	    3 by_control_arg	bit (1) unaligned,	/* 1 if trace modes specified by ec control arg		*/
  1    84 	    3 on			bit (1) unaligned,	/* 1 to print tracing information			*/
  1    85 	    3 expand		fixed bin (3) unal,	/* 1 to print unexpanded, 2 expanded, 3 all, 4 both	*/
  1    86 	    3 pad1		bit (66) unaligned,	/* pad to double word				*/
  1    87 	    3 iocb		ptr,		/* I/O switch to put trace out on			*/
  1    88 	    3 prefix		char (32) varying,	/* prefix for &trace tracing, eg. "COMMAND: "		*/
  1    89 	    3 pad2		bit (36),		/*						*/
  1    90 	  2 (comment_line,				/* for tracing comments..always unexpanded		*/
  1    91 	     control_line,				/* for tracing control lines				*/
  1    92 	     input_line)				/* for tracing input lines in &attach mode		*/
  1    93 				like abs_data.command_line,
  1    94 						/*						*/
  1    95 	  2 attach,				/*						*/
  1    96 	   3 victim_ptr		ptr,		/* -> IOCB affected by &attach (usually iox_$user_input	*/
  1    97 	   3 target_ptr		ptr,		/* -> IOCB &attached to (created by exec_com command)	*/
  1    98 	   3 save_ptr		ptr,		/* -> IOCB used to save previous victim_ptr -> IOCB	*/
  1    99 	   3 switches,
  1   100 	    4 trim_whitespace_sw	bit (1) unaligned,	/* OFF for &attach &trim off, ON by default		*/
  1   101               4 noabort                 bit (1) unaligned,	/* ON if continue after severity 1 error */
  1   102 	    4 pad			bit (34) unaligned,
  1   103 						/*						*/
  1   104 	  2 allocated_chars_ptr	ptr,		/* -> allocated buffer for freeing			*/
  1   105 	  2 chars_ptr		ptr,		/* -> characters in buffer waiting to be returned		*/
  1   106 	  2 else_clause_ptr		ptr,		/* -> characters in deferred else clause		*/
  1   107 	  2 allocated_chars_len	fixed bin (21),	/* total length of allocated buffer			*/
  1   108 	  2 chars_len		fixed bin (21),	/* characters left in buffer to be returned		*/
  1   109 	  2 else_clause_len		fixed bin (21),	/* length of deferred else clause			*/
  1   110 						/*						*/
  1   111 	  2 absentee		bit (1),		/* 1 indicates logout on &quit			*/
  1   112 	  2 quit			bit (1),		/* 1 indicates orderly exit, quit or return		*/
  1   113 						/*						*/
  1   114 	  2 active		bit (1),		/* 1 indicates get_line is busy, for recursion check	*/
  1   115 	  2 eof			bit (1),		/* 1 indicates &quit found or no more input		*/
  1   116 	  2 last_input_line_sw	bit (1),		/* previous line returned was an input line		*/
  1   117 	  2 label_search_sw		bit (1),		/* ON when searching for target of &goto		*/
  1   118 	  2 nest_level		fixed bin,	/* V1: depth of &if-&then-&else nesting			*/
  1   119 	  2 expected_nest_level	fixed bin,	/* V1: depth that must be reached to resume execution	*/
  1   120 						/*						*/
  1   121 	  2 goto_statement_pos	fixed bin (21),	/* position of last &goto stmt, for error msgs		*/
  1   122 	  2 goto_statement_len	fixed bin (21),	/* length of the &goto stmt				*/
  1   123 
  1   124 	  2 if_info aligned,			/* &if-&then-&else nesting info			*/
  1   125 	   3 if_sw		bit (1),		/* ON if inside an &if-&then-&else construct		*/
  1   126 	   3 true_sw		bit (1),		/* ON after "&if true"				*/
  1   127 	   3 got_then_sw		bit (1),		/* ON after the &then has been seen			*/
  1   128 	   3 got_else_sw		bit (1),		/* ON after the &else has been seen			*/
  1   129 	   3 clause_type		fixed bin,	/* previous &then or &else				*/
  1   130 	   3 skip_sw		bit (1),		/* ON if skipping a &then or &else clause		*/
  1   131 	   3 skip_block_level	fixed bin,	/* how many levels of &do we are inside while skipping	*/
  1   132 	   3 prev_if_ptr		ptr,		/* ptr to if_info (saved) of &if we are nested inside	*/
  1   133 	   3 this_action		fixed bin,	/* copy of expand_data.this_statement.action */
  1   134 	   3 next_action		fixed bin,	/* copy of expand_data.next_statement.action */
  1   135 
  1   136 	  2 on_info aligned,			/* info pertaining to &on units in the ec		*/
  1   137 	   3 cleanup_handler_ptr	ptr,		/* -> node for cleanup handler if any			*/
  1   138 	   3 first_handler_ptr	ptr,		/* -> top of chain of nodes for other handlers		*/
  1   139 	   3 switches		aligned,
  1   140 	    4 was_attached_sw	bit (1) unal,	/* 1 indicates parent ec was &attach'ed		*/
  1   141 	    4 in_handler_sw		bit (1) unal,	/* 1 indicates we are now executing some handler text	*/
  1   142 	    4 exit_sw		bit (1) unal,	/* 1 indicates ready to exit the handler via &exit or &goto	*/
  1   143 	    4 goto_sw		bit (1) unal,	/* 1 means this exit is accomplished by a nonlocal &goto	*/
  1   144 	    4 continue_to_signal_sw	bit (1) unal,	/* 1 means &continue_to_signal was executed		*/
  1   145 	    4 pad			bit (31) unal,
  1   146 	   3 handler_node_ptr	ptr,		/* -> parent's handler_node for this condition		*/
  1   147 	   3 parent_abs_data_ptr	ptr,		/* -> abs_data structure of parent ec				*/
  1   148 	   3 condition_info		aligned,		/* selected condition info if in_handler_sw is ON		*/
  1   149 	    4 condition_name	char (32),	/* name of condition signalled			*/
  1   150 	    4 mc_ptr		ptr,		/* machine conditions ptr for signal_			*/
  1   151 	    4 info_ptr		ptr,		/* ptr to specific condition info, for signal_		*/
  1   152 	    4 wc_ptr		ptr,		/* machine conditions for lower ring fault, for signal_	*/
  1   153 	   3 goto_label_ptr		ptr,		/* -> &goto label if goto_sw is on			*/
  1   154 	   3 goto_label_len		fixed bin (21),	/* length of the &goto label				*/
  1   155 	   3 listener_pl1_label	label variable,	/* for nonlocal goto to parent ec's listener's stack frame	*/
  1   156 	   3 get_line_pl1_label	label variable,	/* for nonlocal goto to parent ec's get_line's stack frame	*/
  1   157 						/*						*/
  1   158 	  2 saved_state_ptr		ptr,		/* -> top of parser stack				*/
  1   159 	  2 current_lex_block_ptr	ptr,		/* -> lex_block for current block position		*/
  1   160 	  2 current_proc_block_ptr	ptr,		/* -> proc block for current procedure			*/
  1   161 	  2 last_block_ptr		ptr,		/* -> last lex or proc block that has been allocated	*/
  1   162 	  2 current_loop_ptr	ptr,		/* -> loop_block for current active loop		*/
  1   163 	  2 last_loop_ptr		ptr,		/* -> last loop block that has been allocated 		*/
  1   164 						/*						*/
  1   165 	  2 labels_ptr		ptr,		/* hash table ptr for label hash table			*/
  1   166 	  2 first_xlabel_ptr	ptr,		/* first expandable label				*/
  1   167 	  2 last_xlabel_ptr		ptr,		/* last expandable label				*/
  1   168 	  2 variables_ptr		ptr,		/* hash table ptr for variable hash table		*/
  1   169 						/*						*/
  1   170 	  2 timed_input		bit (1),		/* 1 indicates input requests may be delayed		*/
  1   171 	  2 low_sleep_time		fixed bin (35),	/* low  sleep time for timed input			*/
  1   172 	  2 sleep_time_range	fixed bin (35),	/* high sleep time for timed input			*/
  1   173 	  2 seed			fixed bin (35),	/* seed for timed input random numbers			*/
  1   174 						/*						*/
  1   175 	  2 work_area		area (800);	/* extensible area for args, etc.			*/
  1   176 
  1   177 declare	abs_data_version_1		fixed bin static options (constant) initial (1),
  1   178 	Work_area_size		fixed bin static options (constant) initial (800);
  1   179 
  1   180 dcl (UNEXPANDED init (1), EXPANDED init (2), ALL init (3), BOTH init (4))
  1   181 	fixed bin int static options (constant);
  1   182 
  1   183 /*  END OF:	abs_io_data.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	*/
      595 
      596 
  2     1 /*  START OF:	ec_data.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	*/
  2     2 
  2     3 declare	ec_data_ptr		ptr;
  2     4 
  2     5 declare	1 ec_data			aligned based (ec_data_ptr),
  2     6 	  2 version_id		char (4),		/* " ec "						*/
  2     7 	  2 version		fixed bin,	/* 1						*/
  2     8 	  2 active_function		bit (1),		/* This affects &is_af and &return			*/
  2     9 	  2 return_len		fixed bin (21),	/* maximum length and pointer to varying character string	*/
  2    10 	  2 return_ptr		ptr,		/* for active function return value			*/
  2    11 	  2 execute_line		entry (ptr, fixed bin (21), fixed bin (35)),
  2    12 	  2 eval_string		entry (ptr, char (*), fixed bin, char (*) var, fixed bin (35)),
  2    13 	  2 set_ready_mode		entry (1 aligned, 2 bit (1) unal, 2 bit (35) unal),
  2    14 	  2 error			entry () options (variable),
  2    15 	  2 switch_ptr		ptr,		/* switch affected by &attach				*/
  2    16 	  2 id_string		char (19),	/* name string for &attach save switch should contain this	*/
  2    17 	  2 input_line		bit (1),		/* this makes the command_line/input_line distinction	*/
  2    18 	  2 call_ready_proc		bit (1),		/* this implements the &ready_proc keyword		*/
  2    19 	  2 who_am_i		char (72) varying;	/* for error messages. It's 72 chars for subsystem requests */
  2    20 
  2    21 declare	ec_data_version_id		char (4) aligned static options (constant) initial (" ec "),
  2    22 	ec_data_version_1		fixed bin static options (constant) initial (1);
  2    23 
  2    24 /*  END OF:	ec_data.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	*/
      597 
      598 
  3     1 /* BEGIN INCLUDE FILE: ec_trace_info.incl.pl1 */
  3     2 
  3     3 /* Information passed to exec_com "set_trace" control order, to implement ec -trace */
  3     4 /* Written 05/03/84 by Steve Herbst */
  3     5 
  3     6 dcl ec_trace_info_ptr ptr;
  3     7 
  3     8 dcl 1 ec_trace_info aligned based (ec_trace_info_ptr),
  3     9    2 command_line,
  3    10     3 explicit_sw bit (1) unaligned,			/* ON => contains meaningful info */
  3    11     3 on bit (1) unaligned,				/* turn tracing on/off for this type of line */
  3    12     3 expand fixed bin (3) unaligned,			/* 1=unexpanded, 2=expanded, 3=all, 4=both */
  3    13     3 pad1 bit (66) unaligned,			/* pad to double word */
  3    14     3 iocb ptr,					/* IOCB to write trace on */
  3    15     3 prefix char (32) varying,			/* prefix for trace of this type of line */
  3    16     3 pad2 bit (36),
  3    17    2 comment_line like ec_trace_info.command_line,
  3    18    2 control_line like ec_trace_info.command_line,
  3    19    2 input_line like ec_trace_info.command_line;
  3    20 
  3    21 /* END OF INCLUDE FILE: ec_trace_info.incl.pl1 */
      599 
      600 
  4     1 /* Begin include file ..... io_call_info.incl.pl1 */
  4     2 
  4     3 /* This include file defines the info_structure used by an I/O module to perform an "io_call" order
  4     4*   on behalf of the io_call command. */
  4     5 /* Coded April 1976 by Larry Johnson */
  4     6 /* Changed June 1977 by Larry Johnson for "io_call_af" order */
  4     7 
  4     8      dcl	   io_call_infop	      ptr;
  4     9 
  4    10      dcl	   1 io_call_info	      aligned based (io_call_infop),
  4    11 	     2 version	      fixed bin,
  4    12 	     2 caller_name	      char (32),		/* Caller name for error messages */
  4    13 	     2 order_name	      char (32),		/* Actual name of the order to be performed */
  4    14 	     2 report	      entry variable options (variable),
  4    15 						/* Entry to ioa_ like procedure to report results */
  4    16 	     2 error	      entry variable options (variable),
  4    17 						/* Entry to com_err_ like procedure to report results */
  4    18 	     2 af_returnp	      ptr,		/* Pointer to return string if "io_call_af"  order */
  4    19 	     2 af_returnl	      fixed bin,		/* Length of string */
  4    20 	     2 fill	      (5) bit (36) aligned,
  4    21 	     2 nargs	      fixed bin,		/* Number of additional command arguments provided */
  4    22 	     2 max_arglen	      fixed bin,		/* Length of longest argument (used to define array) */
  4    23 	     2 args	      (0 refer (io_call_info.nargs)) char (0 refer (io_call_info.max_arglen)) varying;
  4    24 
  4    25      dcl	   io_call_af_ret	      char (io_call_info.af_returnl) based (io_call_info.af_returnp) varying;
  4    26 						/* Return string for active function */
  4    27 
  4    28 /* End include file ..... io_call_info.incl.pl1 */
      601 
      602 
  5     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  5     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  5     3*      version number to IOX2. */
  5     4 /* format: style2 */
  5     5 
  5     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  5     7 	     2 version	      character (4) aligned,	/* IOX2 */
  5     8 	     2 name	      char (32),		/* I/O name of this block. */
  5     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  5    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  5    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  5    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  5    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  5    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  5    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  5    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  5    17 						/* open(p,mode,not_used,s) */
  5    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  5    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  5    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  5    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  5    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  5    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  5    24 						/* put_chars(p,bufptr,buflen,s) */
  5    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  5    26 						/* modes(p,newmode,oldmode,s) */
  5    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  5    28 						/* position(p,u1,u2,s) */
  5    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  5    30 						/* control(p,order,infptr,s) */
  5    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  5    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  5    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  5    34 						/* write_record(p,bufptr,buflen,s) */
  5    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  5    36 						/* rewrite_record(p,bufptr,buflen,s) */
  5    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  5    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  5    39 						/* seek_key(p,key,len,s) */
  5    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  5    41 						/* read_key(p,key,len,s) */
  5    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  5    43 						/* read_length(p,len,s) */
  5    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  5    45 						/* open_file(p,mode,desc,not_used,s) */
  5    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  5    47 						/* close_file(p,desc,s) */
  5    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  5    49 						/* detach(p,desc,s) */
  5    50 
  5    51      declare iox_$iocb_version_sentinel
  5    52 			      character (4) aligned external static;
  5    53 
  5    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
      603 
      604 
      605 
      606      end abs_io_control;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/11/87  0925.9  abs_io_control.pl1                >spec>install>MR12.1-1080>abs_io_control.pl1
595          1    08/11/87  0925.5  abs_io_data.incl.pl1              >spec>install>MR12.1-1080>abs_io_data.incl.pl1
597          2    04/13/82  1620.2  ec_data.incl.pl1                  >ldd>include>ec_data.incl.pl1
599          3    10/23/84  0848.6  ec_trace_info.incl.pl1            >ldd>include>ec_trace_info.incl.pl1
601          4    07/19/79  1547.1  io_call_info.incl.pl1             >ldd>include>io_call_info.incl.pl1
603          5    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Active                          000151 constant        bit(1)                   initial array dcl 94 ref 184
Closed                          000123 constant        bit(1)                   initial array dcl 99 ref 184
Command                         000057 constant        bit(1)                   initial array dcl 106 ref 515
Function                        000043 constant        bit(1)                   initial array dcl 109 ref 526
Info                            000107 constant        bit(1)                   initial array dcl 101 ref 136
Null                            000073 constant        bit(1)                   initial array dcl 103 ref 136
Open                            000136 constant        bit(1)                   initial array dcl 97 ref 184
Orders                          000164 constant        varying char(32)         initial array dcl 89 ref 183 183 184
P_abs_line                             parameter       structure                level 1 dcl 562 set ref 557
P_arg_array                            parameter       varying char             array dcl 22 ref 445 457 461 464
P_attach_data_ptr                      parameter       pointer                  dcl 22 ref 242 245 253 256 305 308 348 351 445 448
P_first_arg                            parameter       fixed bin(17,0)          dcl 22 ref 445 449
P_info_line                            parameter       structure                level 1 dcl 561 ref 557
P_info_ptr                             parameter       pointer                  dcl 22 ref 10 131 253 258 305 309
P_iocb_ptr                             parameter       pointer                  dcl 22 ref 10 128
P_order                                parameter       char                     unaligned dcl 180 in procedure "interpret_order" ref
                                                                                  177 184
P_order                                parameter       char                     unaligned dcl 22 in procedure "abs_io_control" set
                                                                                  ref 10 135*
P_status                               parameter       fixed bin(35,0)          dcl 22 set ref 10 173* 253 305 445
abs_data                               based           structure                level 1 dcl 1-23
abs_data_ptr                    000126 automatic       pointer                  dcl 1-21 set ref 129* 130 184 184 205 214 216 218
                                                                                  219 220 231 232 232 232 245* 247 248 248 256* 257
                                                                                  269 271 273 273 278 279 279 282 283 283 287 287
                                                                                  288 308* 351* 355 362 364 364 368 371 371 374 374
                                                                                  379 379 397 398 399 414 418 419 420 433 437 438
                                                                                  439 448* 463 467 468 469 484 495 496 497 498 499
                                                                                  532 541 549 551 552 553
active                  275            based           bit(1)                   level 2 dcl 1-23 ref 184 184
actual_iocb_ptr          12            based           pointer                  level 2 dcl 5-6 ref 128
addr                                                   builtin function         dcl 32 ref 586 586
any_other                       000100 stack reference condition                dcl 35 ref 262 313 333
area                            000000 stack reference condition                dcl 35 ref 480
arg_array                              based           structure                array level 1 dcl 74 set ref 484 503
arg_array_ptr                   000106 automatic       pointer                  dcl 40 set ref 393 394 395 399 412 413 414 414 414
                                                                                  415 415 415 420 431 432 433 433 433 434 434 439
                                                                                  461 462 463 463 463 464 464 469 484* 495* 501 501
                                                                                  501 503 503
arg_array_size                  000110 automatic       fixed bin(17,0)          dcl 40 set ref 390* 393 394 395 397 408* 411 418
                                                                                  427* 430 437 457* 460 467 478 484 496* 499 503
arg_count                52            based           fixed bin(17,0)          level 3 dcl 1-23 set ref 397* 418* 437* 467* 496
                                                                                  498*
arg_idx                         000111 automatic       fixed bin(17,0)          dcl 40 set ref 411* 412 412 413 414 414 414 415 415
                                                                                  415 415* 430* 431 431 432 433 433 433 434 434 434*
                                                                                  460* 461 461 462 463 463 463 464 464 464* 499* 501
                                                                                  501 501*
arg_info                 40            based           structure                level 2 dcl 1-23
arg_ptr                  50            based           pointer                  level 3 dcl 1-23 set ref 399* 420* 439* 469* 495
                                                                                  497*
arg_string                             based           char                     unaligned dcl 79 set ref 414 415* 415 433 434* 463
                                                                                  464* 501
args                     44            based           varying char             array level 2 dcl 4-10 set ref 231 232 234* 431 434
args_copied              53            based           bit(1)                   level 3 dcl 1-23 set ref 398* 419* 438* 468* 499
attach                  252            based           structure                level 2 dcl 1-23
attach_data_ptr          16            based           pointer                  level 2 dcl 5-6 ref 129
attach_descrip                         based           varying char(256)        dcl 67 ref 364
attach_descrip_ptr       14            based           pointer                  level 2 dcl 5-6 ref 364
bad_area_format                 000000 stack reference condition                dcl 35 ref 481
bad_area_initialization         000000 stack reference condition                dcl 35 ref 482
by_control_arg                         parameter       bit(1)                   level 2 packed unaligned dcl 562 set ref 566*
caller_name               1            based           char(32)                 level 2 dcl 4-10 set ref 227* 234* 299* 329* 341*
command_line            162            based           structure                level 2 in structure "abs_data" dcl 1-23
                                                                                  in procedure "abs_io_control" set ref 549*
command_line                           based           structure                level 2 in structure "ec_trace_info" dcl 3-8
                                                                                  in procedure "abs_io_control" set ref 549*
comment_line            200            based           structure                level 2 in structure "abs_data" dcl 1-23
                                                                                  in procedure "abs_io_control" set ref 551*
comment_line             16            based           structure                level 2 in structure "ec_trace_info" dcl 3-8
                                                                                  in procedure "abs_io_control" set ref 551*
continue_to_signal_             000030 constant        entry                    external dcl 114 ref 589
control_line            216            based           structure                level 2 in structure "abs_data" dcl 1-23
                                                                                  in procedure "abs_io_control" set ref 552*
control_line             34            based           structure                level 2 in structure "ec_trace_info" dcl 3-8
                                                                                  in procedure "abs_io_control" set ref 552*
count                                  based           fixed bin(17,0)          level 2 dcl 81 ref 390 393 394 408
e                         1            based           structure                array level 2 dcl 81
ec_data                                based           structure                level 1 dcl 2-5
ec_data_ptr              26            based           pointer                  level 2 in structure "abs_data" dcl 1-23
                                                                                  in procedure "abs_io_control" set ref 130 205* 257
ec_data_ptr                     000130 automatic       pointer                  dcl 2-3 in procedure "abs_io_control" set ref 130*
                                                                                  257* 267 273 282
ec_data_version_1                      constant        fixed bin(17,0)          initial dcl 2-21 ref 201
ec_data_version_id              000042 constant        char(4)                  initial dcl 2-21 ref 202
ec_trace_info                          based           structure                level 1 dcl 3-8
error                    26            based           entry variable           level 2 dcl 4-10 ref 227 234 299 329 341
error_table_$badcall            000010 external static fixed bin(35,0)          dcl 54 ref 157 364
error_table_$badopt             000012 external static fixed bin(35,0)          dcl 54 set ref 234*
error_table_$no_operation       000014 external static fixed bin(35,0)          dcl 54 ref 138 362
error_table_$noalloc            000016 external static fixed bin(35,0)          dcl 54 ref 162
error_table_$notalloc           000020 external static fixed bin(35,0)          dcl 54 ref 167
error_table_$unable_to_do_io    000022 external static fixed bin(35,0)          dcl 54 ref 585
error_table_$undefined_order_request
                                000024 external static fixed bin(35,0)          dcl 54 ref 152
expand                    0(02)        parameter       fixed bin(3,0)           level 2 in structure "P_abs_line" packed unaligned
                                                                                  dcl 562 in procedure "set_trace" set ref 568*
expand                    0(02)        parameter       fixed bin(3,0)           level 2 in structure "P_info_line" packed unaligned
                                                                                  dcl 561 in procedure "set_trace" ref 568
explicit_sw                            parameter       bit(1)                   level 2 packed unaligned dcl 561 ref 564
factor                          000112 automatic       float bin(27)            dcl 40 set ref 247* 248
first_arg                       000113 automatic       fixed bin(17,0)          dcl 40 set ref 449* 453 457 461 464
fixed                                                  builtin function         dcl 32 ref 248
hbound                                                 builtin function         dcl 32 ref 183 457
hcs_$reset_ips_mask             000032 constant        entry                    external dcl 114 ref 170 292 320 339
hcs_$set_ips_mask               000034 constant        entry                    external dcl 114 ref 265 316 335
id_string                30            based           char(19)                 level 2 dcl 2-5 ref 273
info_ptr                        000114 automatic       pointer                  dcl 40 set ref 131* 136 136 198 201 202 205 211 214
                                                                                  214 218 219 220 258* 309* 390 393 394 408 412 415
                                                                                  510 521 549 551 552 553
input_line               52            based           structure                level 2 in structure "ec_trace_info" dcl 3-8
                                                                                  in procedure "abs_io_control" set ref 553*
input_line              234            based           structure                level 2 in structure "abs_data" dcl 1-23
                                                                                  in procedure "abs_io_control" set ref 553*
io_call_info                           based           structure                level 1 dcl 4-10
io_call_infop                   000132 automatic       pointer                  dcl 4-8 set ref 224 227 227 231 232 234 234 234 296
                                                                                  299 299 326 329 329 341 341 427 431 434 510* 512
                                                                                  514 521* 523 525
io_module_name            1            based           varying char(32)         level 2 dcl 1-23 ref 273
iocb                      2            parameter       pointer                  level 2 in structure "P_info_line" dcl 561
                                                                                  in procedure "set_trace" ref 569 570
iocb                                   based           structure                level 1 dcl 5-6 in procedure "abs_io_control"
iocb                      2            parameter       pointer                  level 2 in structure "P_abs_line" dcl 562
                                                                                  in procedure "set_trace" set ref 569* 570*
iocb_ptr                        000116 automatic       pointer                  dcl 40 set ref 128* 129 184 184
iox_$attach_ptr                 000036 constant        entry                    external dcl 114 ref 283 374
iox_$detach_iocb                000040 constant        entry                    external dcl 114 ref 355 368
iox_$find_iocb                  000042 constant        entry                    external dcl 114 ref 273
iox_$move_attach                000044 constant        entry                    external dcl 114 ref 279 287 371
iox_$user_input                 000026 external static pointer                  dcl 54 ref 278
lbound                                                 builtin function         dcl 32 ref 183
len                       2            based           fixed bin(21,0)          array level 3 in structure "set_args" dcl 81
                                                                                  in procedure "abs_io_control" ref 393 412
len                       2            based           fixed bin(21,0)          array level 2 in structure "arg_array" dcl 74
                                                                                  in procedure "abs_io_control" set ref 393* 412*
                                                                                  414 414 415 415 431* 433 433 434 461* 463 463 464
                                                                                  501 501
length                                                 builtin function         dcl 32 ref 431 461
low_sleep_time          413            based           fixed bin(35,0)          level 2 in structure "abs_data" dcl 1-23
                                                                                  in procedure "abs_io_control" set ref 218* 232 248
low_sleep_time                         based           fixed bin(35,0)          level 2 in structure "timed_input" dcl 69
                                                                                  in procedure "abs_io_control" ref 214 218
mask                            000120 automatic       bit(36)                  unaligned dcl 40 set ref 132* 170 170* 170* 259*
                                                                                  265* 265* 292* 292* 310* 316* 316* 320* 320* 335*
                                                                                  335* 339* 339* 450* 582
max_arglen               43            based           fixed bin(17,0)          level 2 dcl 4-10 ref 231 231 232 232 234 234 234 431
                                                                                  431 434 434
name                      1            based           char(32)                 level 2 dcl 5-6 ref 283 364 374
nargs                    42            based           fixed bin(17,0)          level 2 dcl 4-10 ref 224 296 326 427
no_set_bc               151(04)        based           bit(1)                   level 3 packed unaligned dcl 1-23 set ref 532* 541*
null                                                   builtin function         dcl 32 ref 136 136 184 184 198 267 269 271 283 283
                                                                                  288 362 374 374 379 497 503 569
on                        0(01)        parameter       bit(1)                   level 2 in structure "P_info_line" packed unaligned
                                                                                  dcl 561 in procedure "set_trace" ref 567
on                        0(01)        parameter       bit(1)                   level 2 in structure "P_abs_line" packed unaligned
                                                                                  dcl 562 in procedure "set_trace" set ref 567*
open_data                66            based           structure                level 2 dcl 1-23
open_descrip_ptr         20            based           pointer                  level 2 dcl 5-6 ref 184 184
order                           000152 automatic       fixed bin(17,0)          dcl 180 in procedure "interpret_order" set ref 183*
                                                                                  184 184 184 184 189*
order                           000121 automatic       fixed bin(17,0)          dcl 40 in procedure "abs_io_control" set ref 135*
                                                                                  136 136 136 514* 515 515 525* 526 526
order_name               11            based           char(32)                 level 2 dcl 4-10 ref 514 525
prefix                    4            parameter       varying char(32)         level 2 in structure "P_abs_line" dcl 562
                                                                                  in procedure "set_trace" set ref 571*
prefix                    4            parameter       varying char(32)         level 2 in structure "P_info_line" dcl 561
                                                                                  in procedure "set_trace" ref 571
ptr                                    based           pointer                  array level 2 in structure "arg_array" dcl 74
                                                                                  in procedure "abs_io_control" set ref 394* 414*
                                                                                  415 433* 434 463* 464 501
ptr                       1            based           pointer                  array level 3 in structure "set_args" packed
                                                                                  unaligned dcl 81 in procedure "abs_io_control" ref
                                                                                  394 415
quotes                    3            based           fixed bin(21,0)          array level 2 dcl 74 set ref 395* 413* 432* 462*
random_$uniform                 000046 constant        entry                    external dcl 114 ref 247
save_ptr                256            based           pointer                  level 3 dcl 1-23 set ref 271 273* 279* 287* 355*
                                                                                  371*
seed                      2            based           fixed bin(35,0)          level 2 in structure "timed_input" dcl 69
                                                                                  in procedure "abs_io_control" ref 220
seed                    415            based           fixed bin(35,0)          level 2 in structure "abs_data" dcl 1-23
                                                                                  in procedure "abs_io_control" set ref 220* 247*
set_args                               based           structure                level 1 dcl 81
sleep_time                      000122 automatic       fixed bin(71,0)          dcl 40 set ref 248* 249 249*
sleep_time_range          1            based           fixed bin(35,0)          level 2 in structure "timed_input" dcl 69
                                                                                  in procedure "abs_io_control" ref 211 214 219
sleep_time_range        414            based           fixed bin(35,0)          level 2 in structure "abs_data" dcl 1-23
                                                                                  in procedure "abs_io_control" set ref 219* 232 248
status                          000124 automatic       fixed bin(35,0)          dcl 40 set ref 133* 138* 152* 157* 162* 167* 173
                                                                                  260* 273* 275 279* 280 283* 285 311* 318* 337* 341
                                                                                  341* 342* 353* 368* 369 369 371* 372 376 451*
status_code               1     000100 automatic       fixed bin(35,0)          level 2 dcl 578 set ref 585*
substr                                                 builtin function         dcl 32 ref 170 582
switch_ptr               26            based           pointer                  level 2 dcl 2-5 ref 282
target_ptr              254            based           pointer                  level 3 dcl 1-23 set ref 269 282* 283 288* 362 364
                                                                                  374 379*
terminate_process_              000050 constant        entry                    external dcl 114 ref 586
timed_input             412            based           bit(1)                   level 2 in structure "abs_data" dcl 1-23
                                                                                  in procedure "abs_io_control" set ref 214* 216
                                                                                  231* 232*
timed_input                            based           structure                level 1 unaligned dcl 69 in procedure
                                                                                  "abs_io_control"
timer_manager_$sleep            000052 constant        entry                    external dcl 114 ref 249
ts                              000100 automatic       structure                level 1 dcl 578 set ref 586 586
unspec                                                 builtin function         dcl 32 ref 569
version                   1            based           fixed bin(17,0)          level 2 in structure "ec_data" dcl 2-5 in procedure
                                                                                  "abs_io_control" ref 201
version                                based           fixed bin(17,0)          level 2 in structure "io_call_info" dcl 4-10
                                                                                  in procedure "abs_io_control" ref 512 523
version                         000100 automatic       fixed bin(17,0)          level 2 in structure "ts" dcl 578 in procedure
                                                                                  "any_other_handler" set ref 584*
version_id                             based           char(4)                  level 2 dcl 2-5 ref 202
victim_ptr              252            based           pointer                  level 3 dcl 1-23 set ref 278* 279* 283* 287* 364
                                                                                  368* 371* 374* 379*
work_area               416            based           area(800)                level 2 dcl 1-23 ref 414 433 463 484

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALL                                    internal static fixed bin(17,0)          initial dcl 1-180
BOTH                                   internal static fixed bin(17,0)          initial dcl 1-180
EXPANDED                               internal static fixed bin(17,0)          initial dcl 1-180
UNEXPANDED                             internal static fixed bin(17,0)          initial dcl 1-180
Work_area_size                         internal static fixed bin(17,0)          initial dcl 1-177
abs_data_version_1                     internal static fixed bin(17,0)          initial dcl 1-177
ec_trace_info_ptr                      automatic       pointer                  dcl 3-6
io_call_af_ret                         based           varying char             dcl 4-25
iox_$iocb_version_sentinel             external static char(4)                  dcl 5-51

NAMES DECLARED BY EXPLICIT CONTEXT.
AREA_FULL                       000563 constant        label                    dcl 162 ref 480
BAD_AREA                        000567 constant        label                    dcl 167 ref 481 482
BAD_CALL                        000557 constant        label                    dcl 157 ref 201 202 211
CALL_BACK_LATER                 000553 constant        label                    dcl 152 ref 517 528
COMMAND                         000013 constant        label                    array(0:10) dcl 138 ref 515
EGRESS                          000572 constant        label                    dcl 170 ref 150 155 160 165 207 216 222 228 236 275
                                                                                  280 289 294 300 322 330 344 401 422 441 453 471
                                                                                  478 536 545 555
FUNCTION                        000000 constant        label                    array(0:10) dcl 138 ref 526
NO_OPERATION                    000547 constant        label                    dcl 138 ref 267 269 512 523
ORDER                           000026 constant        label                    array(0:11) dcl 138 ref 136 303
abs_io_control                  000456 constant        entry                    external dcl 10
abs_io_control$close            001570 constant        entry                    external dcl 348
abs_io_control$detach           001350 constant        entry                    external dcl 305
abs_io_control$sleep            000763 constant        entry                    external dcl 242
allocate_arg_array              002667 constant        entry                    internal dcl 475 ref 391 409 428 458
any_other_handler               003105 constant        entry                    internal dcl 575 ref 262 313 333
attach                          001035 constant        entry                    external dcl 253
detach                          002517 constant        entry                    internal dcl 359 ref 318 337 353
interpret_order                 002425 constant        entry                    internal dcl 177 ref 135 514 525
release_args                    002771 constant        entry                    internal dcl 492 ref 387 405 424 455
set_arguments                   002131 constant        entry                    external dcl 445
set_trace                       003041 constant        entry                    internal dcl 557 ref 549 551 552 553

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3600        3654    3175        3610
Length      4220    3175        54         327     402           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
abs_io_control                      229 external procedure  is an external procedure.  
interpret_order                         internal procedure  shares stack frame of external procedure abs_io_control.  
on unit on line 262                  64 on unit               
on unit on line 313                  64 on unit               
on unit on line 333                  64 on unit               
detach                                  internal procedure  shares stack frame of external procedure abs_io_control.  
allocate_arg_array                   82 internal procedure  enables or reverts conditions.  
on unit on line 480                  64 on unit               
on unit on line 481                  64 on unit               
on unit on line 482                  64 on unit               
release_args                            internal procedure  shares stack frame of external procedure abs_io_control.  
set_trace                               internal procedure  shares stack frame of external procedure abs_io_control.  
any_other_handler                    82 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
abs_io_control           000106 arg_array_ptr               abs_io_control
                         000110 arg_array_size              abs_io_control
                         000111 arg_idx                     abs_io_control
                         000112 factor                      abs_io_control
                         000113 first_arg                   abs_io_control
                         000114 info_ptr                    abs_io_control
                         000116 iocb_ptr                    abs_io_control
                         000120 mask                        abs_io_control
                         000121 order                       abs_io_control
                         000122 sleep_time                  abs_io_control
                         000124 status                      abs_io_control
                         000126 abs_data_ptr                abs_io_control
                         000130 ec_data_ptr                 abs_io_control
                         000132 io_call_infop               abs_io_control
                         000152 order                       interpret_order
any_other_handler        000100 ts                          any_other_handler

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
fx1_to_fl2          r_g_a               alloc_char_temp     cat_realloc_chars   call_ent_var_desc   call_ext_out_desc
call_ext_out        call_int_this       call_int_other      return_mac          fl2_to_fx2          tra_ext_1
bound_ck_signal     enable_op           shorten_stack       ext_entry           ext_entry_desc      int_entry
op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
continue_to_signal_           hcs_$reset_ips_mask           hcs_$set_ips_mask             iox_$attach_ptr
iox_$detach_iocb              iox_$find_iocb                iox_$move_attach              random_$uniform
terminate_process_            timer_manager_$sleep

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badcall          error_table_$badopt           error_table_$no_operation     error_table_$noalloc
error_table_$notalloc         error_table_$unable_to_do_io  error_table_$undefined_order_request
iox_$user_input




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     10 000451       128 000476       129 000502       130 000504       131 000506       132 000511       133 000512
    135 000513       136 000530       138 000547       150 000552       152 000553       155 000556       157 000557
    160 000562       162 000563       165 000566       167 000567       170 000572       173 000605       175 000607
    198 000610       201 000614       202 000620       205 000623       207 000626       211 000627       214 000632
    216 000640       218 000641       219 000643       220 000645       222 000647       224 000650       227 000654
    228 000700       231 000701       232 000711       234 000725       236 000757       242 000760       245 000770
    247 000774       248 001005       249 001014       251 001030       253 001031       256 001047       257 001053
    258 001055       259 001060       260 001061       262 001062       265 001104       267 001114       269 001120
    271 001125       273 001131       275 001175       278 001200       279 001205       280 001217       282 001221
    283 001225       285 001261       287 001263       288 001300       289 001303       292 001304       294 001314
    296 001315       299 001320       300 001344       303 001345       305 001346       308 001362       309 001366
    310 001371       311 001372       313 001373       316 001415       318 001425       320 001427       322 001437
    326 001440       329 001443       330 001467       333 001470       335 001512       337 001522       339 001524
    341 001534       342 001564       344 001565       348 001566       351 001575       353 001601       355 001603
    357 001616       387 001617       390 001620       391 001622       393 001626       394 001654       395 001673
    397 001710       398 001713       399 001714       401 001715       405 001716       408 001717       409 001721
    411 001725       412 001735       413 001744       414 001746       415 001764       416 002000       418 002002
    419 002005       420 002007       422 002011       424 002012       427 002013       428 002016       430 002022
    431 002031       432 002047       433 002051       434 002067       435 002112       437 002114       438 002117
    439 002121       441 002123       445 002124       448 002147       449 002153       450 002155       451 002156
    453 002157       455 002160       457 002161       458 002167       460 002173       461 002203       462 002224
    463 002226       464 002244       465 002271       467 002273       468 002276       469 002300       471 002302
    510 002303       512 002305       514 002310       515 002317       517 002323       521 002324       523 002326
    525 002331       526 002340       528 002344       532 002345       536 002350       541 002351       545 002354
    549 002355       551 002366       552 002400       553 002412       555 002424       177 002425       183 002436
    184 002443       189 002507       190 002512       192 002514       359 002517       362 002521       364 002532
    368 002560       369 002571       371 002576       372 002612       374 002614       376 002653       379 002657
    381 002663       475 002666       478 002674       480 002702       481 002721       482 002740       484 002757
    486 002770       492 002771       495 002772       496 002775       497 003000       498 003002       499 003003
    501 003015       502 003026       503 003030       505 003040       557 003041       564 003043       566 003047
    567 003051       568 003055       569 003061       570 003072       571 003075       573 003103       575 003104
    582 003112       584 003116       585 003117       586 003121       589 003143       591 003153


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
