	COMPILATION LISTING OF SEGMENT mtape_util_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 12/17/86  0849.6 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 mtape_util_: procedure;
        7 
        8 /* format: style4 */
        9 
       10 /* *	This program is part of the mtape_ I/O module and as such is not
       11*   *	called directly by users, but through the iox_ I/O system.  This
       12*   *	program implements several common subroutines.
       13*   *
       14*   *	Modification History:
       15*   *
       16*   *	Created by J. A. Bush 10/05/82
       17*   *	Modified by J. A. Bush 01/09/84 to enable referencing dir search rule
       18*   *	 when searching for Per-Format modules
       19**/
       20 
       21 /*		ARGUMENT DATA		*/
       22 
       23 dcl  arg_mtdp ptr;					/* Pointer to mtape_data */
       24 dcl  arg_alloc_type fixed bin;			/* Type of structure to allocate */
       25 dcl  arg_prev_ptr ptr;				/* Pointer to previously allocated structure */
       26 dcl  arg_length fixed bin (21);			/* Length of string to allocate */
       27 dcl  arg_return_ptr ptr;				/* Pointer to allocated storage */
       28 dcl  arg_code fixed bin (35);				/* Return error code */
       29 dcl  arg_qcode fixed bin;				/* User query index */
       30 
       31 /*		AUTOMATIC DATA		*/
       32 
       33 dcl  (prev_ptr, temp_ptr, argp, qep, ep) ptr;
       34 dcl  pfmn char (32);
       35 dcl  (str_length, rs_len) fixed bin (21);
       36 dcl  (alloc_type, i, cdx) fixed bin;
       37 dcl  explain_str char (1024);
       38 dcl  rs_emess char (512);
       39 dcl  answer char (128);
       40 dcl  code fixed bin (35);
       41 dcl  invert_qsw bit (1) aligned;
       42 dcl  1 atec aligned like tec;
       43 
       44 /*		CONSTANT DATA		*/
       45 
       46 dcl  myname char (6) int static options (constant) init ("mtape_");
       47 dcl  1 EXPLAIN_NO_NEXT_VOLUME int static options (constant),
       48        2 n_lines fixed bin init (5),
       49        2 text (5) char (71) unaligned init
       50 	  ("Physical end of volume has been detected on a multi-volume file, but",
       51 	  "no volumes remain in the volume sequence list.  A ""yes"" answer will",
       52 	  "lock the file such that no further I/O operations are possible (i.e.",
       53 	  "the file may only be closed).  A ""no"" answer will cause a further",
       54 	  "query for the next volume name.");
       55 
       56 dcl  1 EXPLAIN_LABELED_VOLUME int static options (constant),
       57        2 n_lines fixed bin init (9),
       58        2 text (9) char (71) unaligned init
       59 	  ("The indicated volume requires initialization but contains a valid",
       60 	  "volume label of some other type not recognized by the Per Format",
       61 	  "module currently in control.  A ""yes"" answer will cause the volume",
       62 	  "to be initialized with the volume label sequence of the Per-Format",
       63 	  "module in control.  A ""no"" answer will cause one of the following",
       64 	  "actions.  If this is the initial file opening, then the opening will",
       65 	  "be aborted.  If this condition was detected on a subsequent volume",
       66 	  "switch of a multi-volume file, then the file will be locked such that",
       67 	  "further I/O operations are not possible.");
       68 
       69 dcl  1 EXPLAIN_UNEXPIRED_VOLUME int static options (constant),
       70        2 n_lines fixed bin init (4),
       71        2 text (4) char (71) unaligned init
       72 	  ("It has been determined that the indicated volume must be initialized",
       73 	  "but its first file contains an expiration date which is in the future.",
       74 	  "A ""yes"" answer will allow processing to continue.",
       75 	  "A ""no"" answer will abort the opening.");
       76 
       77 dcl  1 EXPLAIN_INCORRECT_VOLUME int static options (constant),
       78        2 n_lines fixed bin init (6),
       79        2 text (6) char (71) unaligned init
       80 	  ("The volume name specified by the user and the volume name recorded on",
       81 	  "the indicated volume do not agree. If opening for output, a ""yes""",
       82 	  "answer will cause the volume to be initialized with the volume name",
       83 	  "specified by the user.  If opening for input, a ""yes"" answer will",
       84 	  "cause the descrepency to be ignored and processing will continue.  A",
       85 	  """no"" answer will cause the opening to be aborted.");
       86 
       87 dcl  1 EXPLAIN_UNEXPIRED_FILE int static options (constant),
       88        2 n_lines fixed bin init (5),
       89        2 text (5) char (71) unaligned init
       90 	  ("The file that is being opened currently exists and must be replaced,",
       91 	  "modified or extended but the recorded files expiration date is in the",
       92 	  "future.  A ""yes"" answer will cause the file labels to be overwritten",
       93 	  "and processing will continue.  A ""no"" answer will abort the file",
       94 	  "opening.");
       95 
       96 dcl  1 EXPLAIN_ABORT_FILE int static options (constant),
       97        2 n_lines fixed bin init (6),
       98        2 text (6) char (71) unaligned init
       99 	  ("Unrecoverable tape errors have ocurred while attempting to write file",
      100 	  "headers, trailers or tape marks, thus invalidating the file-set",
      101 	  "structure. A ""yes"" answer causes an attempt to be made to delete",
      102 	  "the defective file section.  A ""no"" answer will cause no action",
      103 	  "to be taken.  In either case, the file is locked and no further",
      104 	  "I/O is possible.");
      105 
      106 dcl  1 EXPLAIN_NEW_VOLUME int static options (constant),
      107        2 n_lines fixed bin init (4),
      108        2 text (4) char (71) unaligned init
      109 	  ("The user is requested to supply the volume name of a new volume",
      110 	  "following a ""no"" answer from a previous ""no_next_volume"" query.",
      111 	  "An optional mount comment may also be supplied.  The expected user",
      112 	  "response must be in the form: ""volume_name -comment STR"".");
      113 dcl  NL char (1) int static options (constant) init ("
      114 ");
      115 
      116 /*		EXTERNAL STATIC DATA	*/
      117 
      118 dcl  error_table_$no_next_volume fixed bin (35) ext static;
      119 dcl  error_table_$uninitialized_volume fixed bin (35) ext static;
      120 dcl  error_table_$unexpired_volume fixed bin (35) ext static;
      121 dcl  error_table_$unexpired_file fixed bin (35) ext static;
      122 dcl  error_table_$file_aborted fixed bin (35) ext static;
      123 
      124 /*		BUILTIN FUNCTIONS		*/
      125 
      126 dcl  (addr, codeptr, hbound, index, length, ltrim, null, rtrim, substr, translate) builtin;
      127 
      128 /*		EXTERNAL ENTRIES		*/
      129 
      130 dcl  tape_ioi_$get_statistics entry (bit (36) aligned, ptr, fixed bin (35));
      131 dcl  tape_ioi_$reset_statistics entry (bit (36) aligned, fixed bin (35));
      132 dcl  mtape_util_$error entry options (variable);
      133 dcl  canon_for_volume_label_ entry (char (*), char (*), char (*) aligned, fixed bin, fixed bin (35));
      134 dcl  ioa_$rsnnl entry () options (variable);
      135 dcl  com_err_ entry () options (variable);
      136 dcl  command_query_ entry () options (variable);
      137 dcl  cu_$arg_list_ptr entry (ptr);
      138 dcl  ioa_$general_rs entry (ptr, fixed bin, fixed bin, char (*), fixed bin (21), bit (1) aligned, bit (1) aligned);
      139 dcl  hcs_$make_entry entry (ptr, char (*), char (*), entry, fixed bin (35));
      140 dcl  hcs_$make_ptr entry (ptr, char (*), char (*), ptr, fixed bin (35));
      141 
      142 /*		BASED STORAGE		*/
      143 
      144 dcl  based_str char (str_length) based;
      145 dcl  based_area area based (mtape_data.areap);
      146 
      147 dcl  1 query_explanation based (qep),			/* command query explanation template */
      148        2 n_lines fixed bin,				/* number of lines in the explanation text */
      149        2 text (12) char (71) unaligned;			/* message text array */
      150 
      151 /* alloc - entry to allocate storage for various structures
      152*   *
      153*   *	Usage:
      154*   *
      155*   *	dcl mtape_util_$alloc entry (ptr, fixed bin, ptr, fixed bin (21), ptr);
      156*   *	call mtape_util_$alloc (mtdp, alloc_type, prev_ptr, str_length, return_ptr);
      157*   *
      158*   *	where:
      159*   *	1. mtdp
      160*   *	     is a pointer to the mtape_data structure defined by
      161*   *	     mtape_data.incl.pl1. (INPUT)
      162*   *	2. alloc_type
      163*   *	     is the structure type to be allocated, defined in
      164*   *	     mtape_constants.incl.pl1. (INPUT)
      165*   *	3. prev_ptr
      166*   *	     is a pointer to the previous structure of this type, for types
      167*   *	     1 - 3. If non-null, the previous and next pointers in the
      168*   *	     respective structures will be linked. (INPUT)
      169*   *	4. str_length
      170*   *	     is the string length in characters to be allocated for type 4
      171*   *	     allocation. The parameter is ignored for other allocation types.
      172*   *	     (INPUT)
      173*   *	5. return_ptr
      174*   *	     is a pointer to the allocated storage. (OUTPUT)
      175**/
      176 
      177 alloc: entry (arg_mtdp, arg_alloc_type, arg_prev_ptr, arg_length, arg_return_ptr);
      178 	mtdp = arg_mtdp;				/* copy arguments */
      179 	alloc_type = arg_alloc_type;
      180 	prev_ptr = arg_prev_ptr;
      181 	go to alloc_storage (alloc_type);		/* go do the appropriate allocation */
      182 
      183 
      184 alloc_storage (1):					/* allocate a volume set structure */
      185 	allocate mtape_vol_set in (based_area) set (temp_ptr); /* that should do it */
      186 	vs_ptr = temp_ptr;				/* initialize the structure */
      187 	mtape_vol_set.version = mtape_vs_version_1;
      188 	mtape_vol_set.mrm_vs_ptr, mtape_vol_set.lrm_vs_ptr = null;
      189 	mtape_vol_set.first_vl_ptr, mtape_vol_set.last_vl_ptr = null;
      190 	mtape_vol_set.volume_name, mtape_vol_set.volume_id = "";
      191 	mtape_vol_set.mount_comment, mtape_vol_set.device_name = "";
      192 	mtape_vol_set.demount_comment = "";
      193 	mtape_vol_set.next_vs_ptr = null;		/* link the structures if possible */
      194 	mtape_vol_set.prev_vs_ptr = prev_ptr;
      195 	if prev_ptr ^= null then do;			/* if user supplied valid prev ptr.. */
      196 	     prev_ptr -> mtape_vol_set.next_vs_ptr = vs_ptr; /* link the previous volume set */
      197 	     mtape_vol_set.volume_index = prev_ptr -> mtape_vol_set.volume_index + 1; /* increment vol sequence */
      198 	end;
      199 	else mtape_vol_set.volume_index = 1;		/* first volume, set to 1 */
      200 	go to alloc_end;
      201 
      202 alloc_storage (2):					/* allocate a label record structure */
      203 	allocate mtape_label_record in (based_area) set (temp_ptr); /* that should do it */
      204 	lr_ptr = temp_ptr;				/* initialize the structure */
      205 	mtape_label_record.version = mtape_lr_version_1;
      206 	mtape_label_record.lab_ptr = null;
      207 	mtape_label_record.next_lab_ptr = null;		/* link the structures if possible */
      208 	mtape_label_record.prev_lab_ptr = prev_ptr;
      209 	if prev_ptr ^= null then			/* if user supplied valid prev ptr.. */
      210 	     prev_ptr -> mtape_label_record.next_lab_ptr = lr_ptr; /* link the previous label record */
      211 	go to alloc_end;
      212 
      213 alloc_storage (3):					/* allocate a file info structure */
      214 	allocate mtape_file_info in (based_area) set (temp_ptr); /* that should do it */
      215 	fi_ptr = temp_ptr;				/* initialize structure */
      216 	mtape_file_info.version = mtape_fi_version_1;
      217 	mtape_file_info.first_file_lab_ptr, mtape_file_info.last_file_lab_ptr = null;
      218 	mtape_file_info.first_file_trail_ptr, mtape_file_info.last_file_trail_ptr = null;
      219 	mtape_file_info.first_file_section_ptr = null;
      220 	mtape_file_info.begin_vs_ptr, mtape_file_info.end_vs_ptr = null;
      221 	mtape_file_info.file_id, mtape_file_info.file_set_id = "";
      222 	mtape_file_info.creation_date, mtape_file_info.expiration_date = "";
      223 	mtape_file_info.pfm_opt_str (*) = "";
      224 	mtape_file_info.char_size = 9;		/* until told otherwise */
      225 	mtape_file_info.next_fi_ptr = null;		/* link the structures if possible */
      226 	mtape_file_info.prev_fi_ptr = prev_ptr;
      227 	if prev_ptr ^= null then			/* if user supplied valid prev ptr.. */
      228 	     prev_ptr -> mtape_file_info.next_fi_ptr = fi_ptr; /* link the previous file structure */
      229 	go to alloc_end;
      230 
      231 alloc_storage (4):					/* allocate storage for a string of bytes */
      232 	str_length = arg_length;			/* copy the length */
      233 	allocate based_str in (based_area) set (temp_ptr);/* that should do it */
      234 	go to alloc_end;
      235 
      236 alloc_end:
      237 	arg_return_ptr = temp_ptr;			/* copy the pointer for the user */
      238 	return;					/* thats all folks */
      239 
      240 /* error - entry to display error messages */
      241 
      242 error: entry (arg_mtdp, arg_code);			/* externally declared as options (variable) */
      243 
      244 	if arg_mtdp -> mtape_data.display_errors then do; /* only display errors if he wants us to */
      245 	     rs_emess = "";				/* pad the message first */
      246 	     call cu_$arg_list_ptr (argp);		/* get ptr to our argument list */
      247 	     call ioa_$general_rs (argp, 3, 4, rs_emess, rs_len, "1"b, "0"b); /* format message */
      248 	     call com_err_ (arg_code, myname, rs_emess);	/* display message */
      249 	end;
      250 
      251 	return;
      252 
      253 /* get_statistics - entry to update error statistics counters in vol_set and file_info structures */
      254 
      255 get_statistics: entry (arg_mtdp, arg_code);
      256 
      257 	mtdp = arg_mtdp;				/* copy args */
      258 	vs_ptr = mtape_data.vs_current;
      259 	fi_ptr = mtape_data.fi_current;
      260 
      261 	code, arg_code = 0;
      262 	tape_ioi_error_counts_ptr = addr (atec);	/* set ptr to auto structure */
      263 	tec.version = TEC_VERSION_1;			/* set structure version */
      264 	call tape_ioi_$get_statistics (mtape_data.tioi_id, tape_ioi_error_counts_ptr, code);
      265 	if code ^= 0 then do;			/* if error, probably wrong version */
      266 	     call mtape_util_$error (mtdp, code, "Error from tape_ioi_$get_statistics");
      267 	     go to gs_return;
      268 	end;
      269 	call tape_ioi_$reset_statistics (mtape_data.tioi_id, code); /* reset tape_ioi_ error counters */
      270 	if code ^= 0 then do;
      271 	     call mtape_util_$error (mtdp, code, "Error from tape_ioi_$reset_statistics");
      272 	     go to gs_return;
      273 	end;
      274 
      275 /* Now that we have the current error stats, merge them in with vol_set and file_info structures */
      276 
      277 	mtape_vol_set.tot_error_stats.read.errors =
      278 	     mtape_vol_set.tot_error_stats.read.errors + tec.reads.errors;
      279 	mtape_vol_set.tot_error_stats.read.operations =
      280 	     mtape_vol_set.tot_error_stats.read.operations + tec.reads.total;
      281 	mtape_vol_set.tot_error_stats.write.errors =
      282 	     mtape_vol_set.tot_error_stats.write.errors + tec.writes.errors;
      283 	mtape_vol_set.tot_error_stats.write.operations =
      284 	     mtape_vol_set.tot_error_stats.write.operations + tec.writes.total;
      285 	mtape_vol_set.tot_error_stats.orders.errors =
      286 	     mtape_vol_set.tot_error_stats.orders.errors + tec.orders.errors;
      287 	mtape_vol_set.tot_error_stats.orders.operations =
      288 	     mtape_vol_set.tot_error_stats.orders.operations + tec.orders.total;
      289 
      290 	mtape_vol_set.rel_error_stats.read.errors =
      291 	     mtape_vol_set.rel_error_stats.read.errors + tec.reads.errors;
      292 	mtape_vol_set.rel_error_stats.read.operations =
      293 	     mtape_vol_set.rel_error_stats.read.operations + tec.reads.total;
      294 	mtape_vol_set.rel_error_stats.write.errors =
      295 	     mtape_vol_set.rel_error_stats.write.errors + tec.writes.errors;
      296 	mtape_vol_set.rel_error_stats.write.operations =
      297 	     mtape_vol_set.rel_error_stats.write.operations + tec.writes.total;
      298 	mtape_vol_set.rel_error_stats.orders.errors =
      299 	     mtape_vol_set.rel_error_stats.orders.errors + tec.orders.errors;
      300 	mtape_vol_set.rel_error_stats.orders.operations =
      301 	     mtape_vol_set.rel_error_stats.orders.operations + tec.orders.total;
      302 	do i = 1 to hbound (mtape_vol_set.tot_error_stats.successful_retry, 1);
      303 	     mtape_vol_set.tot_error_stats.successful_retry (i) = mtape_vol_set.tot_error_stats.successful_retry (i)
      304 		+ tec.successful_retry_strategy (i);
      305 	     mtape_vol_set.rel_error_stats.successful_retry (i) = mtape_vol_set.rel_error_stats.successful_retry (i)
      306 		+ tec.successful_retry_strategy (i);
      307 	end;
      308 	if fi_ptr ^= null then do;			/* update file error statistics? */
      309 	     mtape_file_info.read_errors = mtape_file_info.read_errors + tec.reads.errors;
      310 	     mtape_file_info.write_errors = mtape_file_info.write_errors + tec.writes.errors;
      311 	end;
      312 
      313 gs_return:
      314 	arg_code = code;
      315 	return;
      316 
      317 /* init_pfm - entry to select the appropriate Per-Format module and check it for existence and access */
      318 
      319 init_pfm: entry (arg_mtdp, arg_code);
      320 
      321 	mtdp = arg_mtdp;				/* copy args */
      322 	vs_ptr = mtape_data.vs_current;
      323 	maip = mtape_data.attach_info_ptr;
      324 	code, arg_code = 0;
      325 
      326 	if mtape_attach_info.pfm_prefix ^= "" then	/*  if a "-vt" specified by the user */
      327 	     pfmn = mtape_attach_info.pfm_prefix;	/* use user specifed prefix */
      328 	else do;					/* otherwise check RCP designation */
      329 	     if mtape_vol_set.volume_type = Volume_multics_tape | /* is tape one we recognize? */
      330 		mtape_vol_set.volume_type = Volume_gcos_tape |
      331 		mtape_vol_set.volume_type = Volume_ibm_tape |
      332 		mtape_vol_set.volume_type = Volume_ansi_tape then
      333 		pfmn = Tape_volume_types (mtape_vol_set.volume_type); /* yes, form prefix directly */
      334 	     else if mtape_vol_set.volume_type = Volume_unknown_format then /* if readable but unrecognized.. */
      335 		pfmn = "raw";			/* set prefix for the "raw" PFM */
      336 	     else pfmn = mtape_attach_info.default_pfm_prefix; /* Use default prefix */
      337 	end;
      338 	pfmn = translate (pfmn, "abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ"); /* Make it LC */
      339 	mtape_attach_info.pfm_prefix = pfmn;		/* save the PFM prefix */
      340 	if index (pfmn, "_tape_io_") = 0 then		/* if user didn't already do it.. */
      341 	     pfmn = rtrim (pfmn) || "_tape_io_";	/*  complete PFM name */
      342 
      343 /* Locate the Per-Format module, using the standard object search rules */
      344 
      345 	call hcs_$make_ptr (codeptr (mtape_util_), pfmn, "", ep, code);
      346 	if ep = null then do;			/* if we can't find it complain */
      347 	     call mtape_util_$error (mtdp, code, "Can't find the ""^a"" Per-Format module.", pfmn);
      348 	     arg_code = code;
      349 	     return;
      350 	end;
      351 	mtape_data.pfm_name = pfmn;			/* success, save the PFM name */
      352 
      353 /* Make sure all required entry points are there */
      354 
      355 	call hcs_$make_entry (codeptr (mtape_util_), pfmn, "pfm_init", mtape_data.pfm_init, code);
      356 	if code ^= 0 then do;
      357 	     call mtape_util_$error (mtdp, code,
      358 		"Could not find the ""pfm_init"" entry point for the ""^a"" Per-Format module.", pfmn);
      359 	     call SAVE_CODE;			/* set return code (if not already set ) */
      360 	end;
      361 	call hcs_$make_entry (codeptr (mtape_util_), pfmn, "file_open", mtape_data.file_open, code);
      362 	if code ^= 0 then do;
      363 	     call mtape_util_$error (mtdp, code,
      364 		"Could not find the ""file_open"" entry point for the ""^a"" Per-Format module.", pfmn);
      365 	     call SAVE_CODE;			/* set return code (if not already set ) */
      366 	end;
      367 	call hcs_$make_entry (codeptr (mtape_util_), pfmn, "file_close", mtape_data.file_close, code);
      368 	if code ^= 0 then do;
      369 	     call mtape_util_$error (mtdp, code,
      370 		"Could not find the ""file_close"" entry point for the ""^a"" Per-Format module.", pfmn);
      371 	     call SAVE_CODE;			/* set return code (if not already set ) */
      372 	end;
      373 	call hcs_$make_entry (codeptr (mtape_util_), pfmn, "read", mtape_data.read, code);
      374 	if code ^= 0 then do;
      375 	     call mtape_util_$error (mtdp, code,
      376 		"Could not find the ""read"" entry point for the ""^a"" Per-Format module.", pfmn);
      377 	     call SAVE_CODE;			/* set return code (if not already set ) */
      378 	end;
      379 	call hcs_$make_entry (codeptr (mtape_util_), pfmn, "write", mtape_data.write, code);
      380 	if code ^= 0 then do;
      381 	     call mtape_util_$error (mtdp, code,
      382 		"Could not find the ""write"" entry point for the ""^a"" Per-Format module.", pfmn);
      383 	     call SAVE_CODE;			/* set return code (if not already set ) */
      384 	end;
      385 	call hcs_$make_entry (codeptr (mtape_util_), pfmn, "order", mtape_data.order, code);
      386 	if code ^= 0 then do;
      387 	     call mtape_util_$error (mtdp, code,
      388 		"Could not find the ""order"" entry point for the ""^a"" Per-Format module.", pfmn);
      389 	     call SAVE_CODE;			/* set return code (if not already set ) */
      390 	end;
      391 	call hcs_$make_entry (codeptr (mtape_util_), pfmn, "decode_file_labels", mtape_data.decode_file_labels, code);
      392 	if code ^= 0 then do;
      393 	     call mtape_util_$error (mtdp, code,
      394 		"Could not find the ""decode_file_labels"" entry point for the ""^a"" Per-Format module.", pfmn);
      395 	     call SAVE_CODE;			/* set return code (if not already set ) */
      396 	end;
      397 	call hcs_$make_entry (codeptr (mtape_util_), pfmn, "encode_file_labels", mtape_data.encode_file_labels, code);
      398 	if code ^= 0 then do;
      399 	     call mtape_util_$error (mtdp, code,
      400 		"Could not find the ""encode_file_labels"" entry point for the ""^a"" Per-Format module.", pfmn);
      401 	     call SAVE_CODE;			/* set return code (if not already set ) */
      402 	end;
      403 
      404 	return;
      405 
      406 /* user_query - entry to generate standard user queries for various information */
      407 
      408 user_query: entry (arg_mtdp, arg_qcode, arg_code);
      409 
      410 	mtdp = arg_mtdp;				/* copy args */
      411 	vs_ptr = mtape_data.vs_current;
      412 	fi_ptr = mtape_data.fi_current;
      413 	maip = mtape_data.attach_info_ptr;
      414 	moip = mtape_data.open_info_ptr;
      415 	mpfmip = mtape_data.pfm_info_ptr;
      416 	rs_emess, answer = "";			/* pad message and answer with blanks */
      417 	invert_qsw = "0"b;				/* yes answer is positive for most */
      418 	arg_code = 0;				/* clear return code for positive response */
      419 	query_info.version = query_info_version_6;	/* set version number */
      420 	query_info.yes_or_no_sw = "1"b;		/* set yes or no switch */
      421 	query_info.prompt_after_explanation = "1"b;
      422 	go to U_QUERY (arg_qcode);			/* ask the right question */
      423 
      424 U_QUERY (1):					/* Q_NO_NEXT_VOLUME */
      425 	qep = addr (EXPLAIN_NO_NEXT_VOLUME);		/* set the explaination ptr */
      426 	code = error_table_$no_next_volume;		/* set appropriate error code */
      427 	invert_qsw = "1"b;				/* no answer is the positive in this case */
      428 	call ioa_$rsnnl ("Reached the end of volume on volume ^a.
      429 Do you wish to terminate processing of this volume-set?",
      430 	     rs_emess, rs_len, mtape_vol_set.volume_id);
      431 
      432 	go to U_QUERY_COM;
      433 
      434 U_QUERY (2):					/* Q_LABELED_VOLUME */
      435 	qep = addr (EXPLAIN_LABELED_VOLUME);		/* set the explaination ptr */
      436 	code = error_table_$uninitialized_volume;	/* set appropriate error code */
      437 	query_info.query_code = 2;			/* set query code of command_question handlers */
      438 	call ioa_$rsnnl ("Volume ^a has a valid ^a volume label.
      439 Do you want to ^[initialize it with a standard ^a volume label^;^1suse this volume for unlabeled output^]? ",
      440 	     rs_emess, rs_len, mtape_vol_set.volume_id, Tape_volume_types (mtape_vol_set.volume_type),
      441 	     mtape_attach_info.labeled, mtape_pfm_info.module_id);
      442 	go to U_QUERY_COM;
      443 
      444 U_QUERY (3):					/* Q_UNEXPIRED_VOLUME */
      445 	qep = addr (EXPLAIN_UNEXPIRED_VOLUME);		/* set the explaination ptr */
      446 	code = error_table_$unexpired_volume;		/* set appropriate error code */
      447 	call ioa_$rsnnl ("Volume ^a requires initialization, but contains an unexpired file.
      448 Do you want to initialize it?",
      449 	     rs_emess, rs_len, mtape_vol_set.volume_name);
      450 	go to U_QUERY_COM;
      451 
      452 U_QUERY (4):					/* Q_INCORRECT_VOLUME */
      453 	qep = addr (EXPLAIN_INCORRECT_VOLUME);		/* set the explaination ptr */
      454 	code = error_table_$uninitialized_volume;	/* set appropriate error code */
      455 	query_info.query_code = 3;			/* set query code of command_question handlers */
      456 	call ioa_$rsnnl ("Warning: Label for volume ^a contains identifier ^a instead.
      457 Do you want to ^[continue processing^;re-initialize it as the desired volume^]?",
      458 	     rs_emess, rs_len,
      459 	     mtape_vol_set.volume_name, mtape_vol_set.volume_id, (mtape_open_info.open_mode = Sequential_input));
      460 	go to U_QUERY_COM;
      461 
      462 U_QUERY (5):					/* Q_UNEXPIRED_FILE */
      463 	qep = addr (EXPLAIN_UNEXPIRED_FILE);		/* set the explaination ptr */
      464 	code = error_table_$unexpired_file;		/* set appropriate error code */
      465 	call ioa_$rsnnl ("Do you want to overwrite the unexpired file ""^a""?",
      466 	     rs_emess, rs_len, mtape_file_info.file_id);
      467 	go to U_QUERY_COM;
      468 
      469 U_QUERY (6):					/* Q_ABORT_FILE */
      470 	qep = addr (EXPLAIN_ABORT_FILE);		/* set the explaination ptr */
      471 	code = error_table_$file_aborted;		/* set appropriate error code */
      472 	call ioa_$rsnnl ("Error while writing labels of file ""^a"", section ^d.
      473 The defective file section invalidates the structure of the entire file set.
      474 Do you want to delete the defective section?", rs_emess, rs_len,
      475 	     mtape_file_info.file_id, mtape_file_info.section);
      476 	go to U_QUERY_COM;
      477 
      478 U_QUERY_COM:
      479 	query_info.status_code = code;		/* set error code */
      480 	call SET_EXPLANATION;			/* set up the explanation string */
      481 	call command_query_ (addr (query_info), answer, myname, rtrim (rs_emess)); /* ask question */
      482 	if (answer = "no" & ^invert_qsw) | (answer = "yes" & invert_qsw) then
      483 	     arg_code = code;			/* answer was negative, return code */
      484 	else if arg_qcode = Q_NO_NEXT_VOLUME then do;	/* must get new volume name */
      485 	     call alloc (mtdp, MTAPE_ALLOC_VS, mtape_data.vs_tail, 0, vs_ptr); /* allocate vol_set struct. */
      486 	     mtape_data.vs_tail = vs_ptr;
      487 	     answer = "";				/* initialize answer */
      488 	     query_info.yes_or_no_sw = "0"b;		/* not a yes/no answer */
      489 	     query_info.suppress_name_sw = "0"b;
      490 	     query_info.status_code, query_info.query_code = 0;
      491 	     qep = addr (EXPLAIN_NEW_VOLUME);		/* set the explaination ptr */
      492 	     call SET_EXPLANATION;			/* set up the explanation string */
      493 	     code = 1;				/* go through loop at least once */
      494 	     do while (code ^= 0);			/* do it until user gets it right */
      495 		call command_query_ (addr (query_info), answer, myname,
      496 		     "^[(""^a"" incorrect)^/^;^1s^]Enter volume name of next volume (and optional comment).^/",
      497 		     (answer ^= ""), answer);
      498 		if answer ^= "" then do;		/* if we have some answer */
      499 		     cdx = index (answer, " ") - 1;	/* index to end of volume name */
      500 		     if cdx < 0 then		/* if no comment given */
      501 			cdx = length (rtrim (answer));
      502 		     call canon_for_volume_label_ (VOLUME_TYPE (TAPE_VOL_VTYPEX), substr (answer, 1, cdx),
      503 			mtape_vol_set.volume_name, 0, code);
      504 		     if code ^= 0 then		/* if error from canonicalize */
      505 			query_info.status_code = code;
      506 		     else do;			/* now check for comment */
      507 			answer = ltrim (substr (answer, cdx + 1)); /* remove volume name */
      508 			if answer ^= "" then do;	/* we have some comment */
      509 			     if substr (answer, 1, 8) = "-comment" | substr (answer, 1, 4) = "-com" then
      510 				answer = substr (answer, index (answer, " ") + 1); /* strip off control arg */
      511 			     mtape_vol_set.mount_comment = answer; /* copy the mount comment */
      512 			end;
      513 		     end;
      514 		end;
      515 	     end;
      516 	end;
      517 	return;
      518 
      519 /* SET_EXPLANATION - internal procedure to set up the command_query_ explanation string and pointer */
      520 
      521 SET_EXPLANATION: proc;
      522 
      523 dcl  i fixed bin;
      524 
      525 	explain_str = "";
      526 	do i = 1 to query_explanation.n_lines;
      527 	     explain_str = rtrim (explain_str) || query_explanation.text (i) || NL;
      528 	end;
      529 	query_info.explanation_ptr = addr (explain_str);
      530 	query_info.explanation_len = length (rtrim (explain_str));
      531 
      532      end SET_EXPLANATION;
      533 
      534 /* SAVE_CODE - internal procedure to set the return error code if not already set */
      535 
      536 SAVE_CODE: proc;
      537 
      538 	if arg_code = 0 then			/* set return code only if not already set */
      539 	     arg_code = code;
      540 
      541      end SAVE_CODE;
      542 
  1     1 /* BEGIN INCLUDE FILE mtape_data.incl.pl1. Created by J. A. Bush 10/06/82  */
  1     2 /* format: style4 */
  1     3 
  1     4 dcl  mtdp ptr;
  1     5 
  1     6 dcl  mtape_data_version_1 char (8) int static options (constant) init ("mtdv0001");
  1     7 
  1     8 dcl  1 mtape_data aligned based (mtdp),
  1     9        2 version char (8),				/* Current structure version */
  1    10        2 areap ptr,					/* Pointer to an allocation area  */
  1    11        2 iocb_ptr ptr,				/* Pointer to our IO control block */
  1    12        2 atdp ptr,					/* Pointer to the attach description string  */
  1    13        2 opdp ptr,					/* Pointer to the open description string */
  1    14        2 cldp ptr,					/* Pointer to close description string */
  1    15        2 dtdp ptr,					/* Pointer to detach description string */
  1    16        2 cmtdp ptr,					/* If non-null, Ptr to allocated copy of mtape_data */
  1    17        2 vs_head ptr,				/* Pointer to the first volume_set structure  */
  1    18        2 vs_tail ptr,				/* Pointer to the last volume_set structure  */
  1    19        2 vs_current ptr,				/* Pointer to the current volume_set structure  */
  1    20        2 vs_mounted_tail ptr,				/* Pointer to MRM volume_set member */
  1    21        2 fi_head ptr,				/* Pointer to the first file_info structure  */
  1    22        2 fi_tail ptr,				/* Pointer to the last file_info structure  */
  1    23        2 fi_current ptr,				/* Pointer to the current file_info structure  */
  1    24        2 tape_infop ptr,				/* Pointer to rcp tape info structure */
  1    25        2 last_ur_status_ptr ptr,			/* If non-null, Ptr to last unrecoverable status */
  1    26        2 io_echan fixed bin (71),			/* Fast wait channel for I/O interrupts */
  1    27        2 mount_echan fixed bin (71),			/* Regular wait channel for mount requests */
  1    28        2 data_xfer_args,				/* Arguments for time critical (read/write) calls */
  1    29          3 arg_buf_ptr ptr,				/* Pointer to users buffer */
  1    30          3 arg_buf_len fixed bin (21),			/* Length of users buffer in bytes */
  1    31          3 arg_rec_len fixed bin (21),			/* Length of record read in bytes */
  1    32        2 error_lock fixed bin (35),			/* if ^= 0 = file locked error code */
  1    33        2 abs_ans char (3),				/* Query answer (yes or no) for abs user */
  1    34        2 user_type bit (1),				/* "1"b => interactive; "0"b => absentee */
  1    35        2 display_errors bit (1),			/* "1"b => display verbose error messages */
  1    36        2 force_end_of_volume bit (1),			/* "1"b => simulate EOV on next write */
  1    37        2 opd_len fixed bin (21),			/* Allocated length of open description */
  1    38        2 drives_in_use fixed bin,			/* Number of tape drives currently in use */
  1    39        2 data_buffers,				/* Info about data buffers */
  1    40          3 buf_ptrs (8) ptr,				/* Pointers to a subset of ioi buffers */
  1    41          3 blind_buf_ptrs (8) ptr,			/* Pointers to other subset of buffers */
  1    42          3 buf_len (8) fixed bin (21),			/* Length of buffers in 9 bit bytes */
  1    43          3 blind_buf_len (8) fixed bin (21),		/* Lengths of other subset of buffers */
  1    44          3 nbufs fixed bin,				/* Number of data buffers currently in use */
  1    45          3 buf_size fixed bin (21),			/* Allocated size of data buffers in bytes */
  1    46          3 bufs_per_subset fixed bin,			/* Number of buffers to write/read per I/O */
  1    47          3 cur_buf_idx fixed bin,			/* Index into subset of current buffer */
  1    48          3 run bit (1),				/* "1"b => wrt I/O queued thru tape_ioi_; "0"b => ^Queued */
  1    49        2 label_buffer,				/* Info about label record buffer */
  1    50          3 lab_bufp ptr,				/* Pointer to label I/O buffer */
  1    51          3 lab_buf_len fixed bin (21),			/* Length of label buffer in 9 bit bytes */
  1    52        2 tlb ptr,					/* Pointer to a temp label record structure */
  1    53        2 position,					/* Position on current volume */
  1    54          3 phy_file fixed bin,			/* physical file number */
  1    55          3 phy_block fixed bin,			/* physical block within physical file */
  1    56        2 current_file,				/* instantanious info about current file */
  1    57          3 cur_block,				/* info about current block */
  1    58 	 4 cur_buf_ptr ptr,				/* Pointer to the current data buffer */
  1    59 	 4 log_record_ptr ptr,			/* Pointer to current logical record */
  1    60 	 4 length fixed bin (21),			/* Length of current block in bytes */
  1    61 	 4 processed fixed bin (21),			/* Number of chars processed already */
  1    62 	 4 remain fixed bin (21),			/* Number of chars remaining to be processed */
  1    63 	 4 log_record fixed bin (21),			/* Log. record within the current block */
  1    64          3 char_size fixed bin,			/* Size in bits of the data chars of this file */
  1    65          3 padding_char char (1),			/* To pad blocks to mod 4 on binary writes */
  1    66          3 length_mode fixed bin,			/* 0 => W/R mod 4 blocks; 1 => W/R non-mod 4 blocks */
  1    67          3 hdw_mode fixed bin,			/* Hardware recording mode:
  1    68*						   1 = binary; 2 = nine track; 3 = BCD */
  1    69          3 conversion fixed bin,			/* File data conversion:
  1    70*						   0 = no conversion; 1 = ASCII<->EBCDIC; 2 = ASCII<->BCD */
  1    71          3 buffer_offset fixed bin,			/* Number of bytes prior to data */
  1    72          3 block_size fixed bin (21),			/* Maximum block size for this file */
  1    73          3 record_size fixed bin (21),			/* Maximum record size for this file */
  1    74          3 prev_block_no fixed bin (21),		/* Number of previous block read */
  1    75          3 ad_file_format fixed bin,			/* 1 = U; 2 = F; 3 = D or V; 4 = S or VS */
  1    76          3 file_blocked bit (1),			/* "1"b => file is blocked */
  1    77          3 native_file bit (1),			/* "1"b => current file written by mtape_ PFM */
  1    78          3 write_after_read bit (1),			/* "1"b => truncate file (and file_set) at this record */
  1    79          3 first_file bit (1),			/* "1"b => first file has been processed */
  1    80          3 tot_bytes_processed fixed bin (35),		/* total bytes in this file section */
  1    81          3 last_io fixed bin,				/* Last I/O operation (1 = read; 2 = write) */
  1    82          3 lrec_rrcx fixed bin,			/* current index of the lrec round robin counter */
  1    83          3 lrec_rrc,				/* history of last n logical records */
  1    84 	 4 block_no (0:7) fixed bin (35),		/* block (within file section) where lrec starts */
  1    85 	 4 block_len (0:7) fixed bin (35),		/* block len of current block */
  1    86 	 4 lrec_no (0:7) fixed bin (35),		/* logical record within currnt block */
  1    87 	 4 abs_byte (0:7) fixed bin (35),		/* byte (within file section) where lrec starts */
  1    88 	 4 byte_offset (0:7) fixed bin,		/* offset of 1st byte of lrec (within block) */
  1    89          3 blk_rrcx fixed bin,			/* index into blk_rrrc array of last block */
  1    90          3 blk_rrrc (0:7) fixed bin (35),		/* contains Lrec count of last n blocks */
  1    91          3 tot_lrec fixed bin (35),			/* Total logical records processed in current file */
  1    92        2 tioi_id bit (36),				/* Identifier used for calls to tape_ioi_ */
  1    93        2 attach_info_ptr ptr,				/* Pointer to attach option info */
  1    94        2 open_info_ptr ptr,				/* Pointer to open option info */
  1    95        2 close_info_ptr ptr,				/* Pointer to close option info */
  1    96        2 detach_info_ptr ptr,				/* Pointer to detach option info */
  1    97        2 pfm_info_ptr ptr,				/* Pointer to PFM info block */
  1    98        2 saved_pfm_info_ptr ptr,			/* Pointer to info for "change_module" control OP */
  1    99        2 pfm_name char (32),				/* Name of Per-Format module */
  1   100        2 pfm_required_entries like pfm_entries,		/* Required entry point declarations in PFM */
  1   101        2 pfm_work_area (32) fixed bin (35);		/* PFM work buffer */
  1   102 
  1   103 dcl  1 pfm_entries based aligned,			/* Entry declarations for PFM entries */
  1   104        2 pfm_init entry (ptr, fixed bin (35)),		/* PFM initialization entry */
  1   105        2 file_open entry (ptr, fixed bin (35)),		/* PFM file_open entry */
  1   106        2 file_close entry (ptr, fixed bin (35)),		/* PFM file_close entry */
  1   107        2 read entry (ptr, fixed bin (35)),		/* PFM read entry */
  1   108        2 write entry (ptr, fixed bin (35)),		/* PFM write entry */
  1   109        2 order entry (ptr, char (*), ptr, ptr, fixed bin (35)), /* PFM control order entry */
  1   110        2 decode_file_labels entry (ptr, ptr, fixed bin, fixed bin, fixed bin (35)),
  1   111        2 encode_file_labels entry (ptr, ptr, fixed bin, fixed bin, fixed bin, fixed bin (35));
  1   112 
  1   113 dcl  all_buf_ptrs (16) ptr based (addr (mtape_data.buf_ptrs));
  1   114 dcl  all_buf_lens (16) fixed bin (21) based (addr (mtape_data.buf_len));
  1   115 dcl  tape_blk (mtape_data.length) char (1) unaligned based (mtape_data.cur_buf_ptr); /* template for a tape block */
  1   116 
  1   117 /* END INCLUDE FILE mtape_data.incl.pl1 */
      543 
      544 
  2     1 /* BEGIN INCLUDE FILE mtape_attach_info.incl.pl1. Created by J. A. Bush 06/13/83 */
  2     2 /* format: style4 */
  2     3 
  2     4 dcl  maip ptr;
  2     5 
  2     6 dcl  mtape_attach_info_version_1 char (8) int static options (constant) init ("maiv0001");
  2     7 
  2     8 dcl  1 mtape_attach_info aligned based (maip),
  2     9        2 version char (8),				/* Current structure version */
  2    10        2 density fixed bin (35),			/* 200, 556, 800, 1600, 6250 BPI */
  2    11        2 tracks fixed bin (35),			/* Number of tracks, 7 or 9 */
  2    12        2 speed bit (36),				/* "000"b = any speed; "1xx"b = 75 IPS;
  2    13*						   "x1x"b = 125 IPS; "xx1"b = 200 IPS */
  2    14        2 ndrives fixed bin (35),			/* 0 = unspecified; 1 - 63 devices to be used */
  2    15        2 wait_time fixed bin (35),			/* time to wait in minutes for available device */
  2    16        2 pfm_prefix char (21),			/* if "-volume_type" was specified */
  2    17        2 default_pfm_prefix char (21),			/* if no "-vt" specified and blank volume */
  2    18        2 display bit (1),				/* Display attach description on user_output */
  2    19        2 labeled bit (1),				/* "1"b => labeled; "0"b => unlabeled volume set */
  2    20        2 wait bit (1),				/* "1"b => wait for available devices; "0"b => don't wait */
  2    21        2 system bit (1),				/* "1"b => User wants to be a "system" process */
  2    22        2 ring bit (1);				/* "1"b => write ring in; "0"b => no write ring */
  2    23 
  2    24 /* END INCLUDE FILE mtape_attach_info.incl.pl1 */
      545 
      546 
  3     1 /* BEGIN INCLUDE FILE mtape_open_close_info.incl.pl1. Created by J. A. Bush 06/13/83 */
  3     2 /* format: style4 */
  3     3 
  3     4 dcl  moip ptr;					/* Pointer to mtape_open_info structure */
  3     5 dcl  mcip ptr;					/* Pointer to mtape_close_info structure */
  3     6 
  3     7 dcl  mtape_open_info_version_1 char (8) int static options (constant) init ("moiv0001");
  3     8 dcl  mtape_close_info_version_1 char (8) int static options (constant) init ("mciv0001");
  3     9 
  3    10 dcl  1 mtape_open_info aligned based (moip),
  3    11        2 version char (8),				/* Current structure version */
  3    12        2 cs_ptr ptr,				/* Pointer to arg processing control structure */
  3    13        2 cal_ptr ptr,				/* Pointer to arg processing ctl arg list */
  3    14        2 so_ptr ptr,				/* Pointer to last saved iox_ options */
  3    15        2 open_mode fixed bin,				/* iox_ opening mode */
  3    16        2 comment char (80),				/* Display on user_output after open */
  3    17        2 expiration char (24),			/* File expiration date */
  3    18        2 file_format char (3),			/* File format code */
  3    19        2 recording_mode char (6),			/* Ascii, ebcdic, or binary */
  3    20        2 file_name char (32),				/* Name of file to be recorded */
  3    21        2 replace_id char (32),			/* Name of file to replace */
  3    22        2 init_to_zero,				/* Enables clearing rest of structure */
  3    23          3 block_length fixed bin (35),			/* Block size in bytes */
  3    24          3 record_length fixed bin (35),		/* Record length specified by user */
  3    25          3 default_span_rlen fixed bin (35),		/* Default record length for spanned records */
  3    26          3 default_var_rlen fixed bin (35),		/* Default record length for variable records */
  3    27          3 default_fix_rlen fixed bin (35),		/* Default record length for fixed records */
  3    28          3 seq_number fixed bin (35),			/* File sequence number */
  3    29          3 append bit (1),				/* "1"b => append file to end of file set */
  3    30          3 create bit (1),				/* "1"b => create this file */
  3    31          3 display bit (1),				/* "1"b => display the open description */
  3    32          3 extend bit (1),				/* "1"b => extend the current file */
  3    33          3 force bit (1),				/* "1"b => disregard file expiration when creating */
  3    34          3 last_file bit (1),				/* "1"b => position to last file of file set */
  3    35          3 next_file bit (1),				/* "1"b => position to next file of file set */
  3    36          3 modify bit (1),				/* "1"b => modify the current file */
  3    37          3 label_entry_present bit (1),			/* "1"b => user label entry is valid */
  3    38          3 user_label entry (ptr, char (*), fixed bin, fixed bin, fixed bin, fixed bin (35)),
  3    39          3 pfm_args like pfm_arg_values;		/* see structure below */
  3    40 
  3    41 dcl  1 mtape_close_info aligned based (mcip),
  3    42        2 version char (8),				/* Current structure version */
  3    43        2 cs_ptr ptr,				/* Pointer to arg processing control structure */
  3    44        2 cal_ptr ptr,				/* Pointer to arg processing ctl arg list */
  3    45        2 so_ptr ptr,				/* Pointer to last saved iox_ options */
  3    46        2 comment char (80),				/* Display on user_output after open */
  3    47        2 init_to_zero,				/* Enables clearing rest of structure */
  3    48          3 display bit (1),				/* Display open description for user */
  3    49          3 position fixed bin,			/* For positioning on file closing:
  3    50*						   0 = Leave at current position;
  3    51*						   1 = Position to beginning of file;
  3    52*						   2 = Position to end of file;
  3    53*						   3 = Position to beginning of file section;
  3    54*						   4 = Position to end of file section */
  3    55          3 pfm_args like pfm_arg_values;		/* see structure below */
  3    56 
  3    57 dcl  1 pfm_arg_values aligned based,			/* Common to open and close_info */
  3    58        2 pfm_opt_sw (5) bit (1),			/* PFM dependent */
  3    59        2 pfm_opt_value (5) fixed bin (35),		/* PFM dependent */
  3    60        2 pfm_opt_str (5) char (32);			/* PFM dependent */
  3    61 
  3    62 /* END INCLUDE FILE mtape_open_close_info.incl.pl1 */
      547 
      548 
  4     1 /*  BEGIN INCLUDE FILE mtape_pfm_info.incl.pl1. Created by J. A. Bush 06/16/83 */
  4     2 /* format: style4 */
  4     3 
  4     4 dcl  mpfmip ptr;
  4     5 
  4     6 dcl  mtape_pfm_info_version_1 char (8) int static options (constant) init ("mpiv0001");
  4     7 
  4     8 dcl  1 mtape_pfm_info aligned based (mpfmip),		/* PFM information block */
  4     9        2 version char (8),				/* Current structure version */
  4    10        2 module_id char (21),				/* For identification of PFM. (e.g. ANSI, IBM, GCOS) */
  4    11        2 open_modes_allowed (3) fixed bin,		/* Allowable open modes for this PFM */
  4    12        2 bof_prefix char (3),				/* For identification of BOF labels */
  4    13        2 eov_prefix char (3),				/* For identification of EOV labels */
  4    14        2 eof_prefix char (3),				/* For identification of EOF labels */
  4    15        2 no_labels_ok bit (1),			/* "1"b => PFM processes unlabeled volumes */
  4    16        2 multi_volumes_ok bit (1),			/* "1"b => PFM processes multi-volume sets */
  4    17        2 extended_error_recovery bit (1),		/* "1"b => PFM will do error recovery after mtape_ gives up */
  4    18        2 pfm_open_options like pfm_options,		/* open options common to this PFM */
  4    19        2 pfm_close_options like pfm_options;		/* close options common to this PFM */
  4    20 
  4    21 dcl  1 pfm_options aligned based,			/* common to open and close pfm options */
  4    22        2 pfm_opt_flags (5),				/* identifies use of "pfm_opt_sw (1-5)" close flags */
  4    23          3 flag_name char (32),			/* name of flag */
  4    24          3 flag_ant_name char (32),			/* antonym name */
  4    25        2 pfm_opt_value_name (5) char (32),		/* identifies use of "pfm_opt_value (1-5)" */
  4    26        2 pfm_opt_str_name (5) char (32);		/* identifies use of "pfm_opt_str (1-5)" */
  4    27 
  4    28 /*  END INCLUDE FILE mtape_pfm_info.incl.pl1 */
      549 
      550 
  5     1 /* BEGIN INCLUDE FILE mtape_vol_set.incl.pl1. Created by J. A. Bush 10/13/82 */
  5     2 /* The include file mtape_err_stats.incl.pl1 is referenced by this include file */
  5     3 /* format: style4 */
  5     4 
  5     5 dcl  vs_ptr ptr;
  5     6 
  5     7 dcl  mtape_vs_version_1 char (8) int static options (constant) init ("mtvsv001");
  5     8 
  5     9 dcl  1 mtape_vol_set aligned based (vs_ptr),
  5    10        2 version char (8),				/* Current version */
  5    11        2 prev_vs_ptr ptr,				/* Pointer to previous volume set entry */
  5    12        2 next_vs_ptr ptr,				/* Pointer to next volume set entry */
  5    13        2 mrm_vs_ptr ptr,				/* Pointer to Most Recently Mounted VS member */
  5    14        2 lrm_vs_ptr ptr,				/* Pointer to Least Recently Mounted VS member */
  5    15        2 first_vl_ptr ptr,				/* Pointer to the first volume label record structure */
  5    16        2 last_vl_ptr ptr,				/* Pointer to the last volume label record structure */
  5    17        2 volume_name char (32),			/* Name specified in the attach description */
  5    18        2 volume_id char (32),				/* Name as recorded in the volume label */
  5    19        2 mount_comment char (64),			/* Mount comment from attach description */
  5    20        2 demount_comment char (64),			/* Demount comment from detach description */
  5    21        2 device_name char (8),			/* Device volume is currently or last mounted on */
  5    22        2 rcp_id bit (36),				/* RCP activation for this volume */
  5    23        2 tioi_id bit (36),				/* tape_ioi_ activation for this volume */
  5    24        2 volume_index fixed bin,			/* Volume sequence number within volume set */
  5    25        2 volume_density fixed bin,			/* Actual volume density determined by RCP */
  5    26        2 volume_type fixed bin,			/* Use rcp_volume_formats.incl.pl1 for decode */
  5    27        2 volume_check fixed bin,			/* Refer to named constants below for values */
  5    28        2 number_of_vol_labels fixed bin,		/* # of volume label records on this volume */
  5    29        2 auth_required bit (1),			/* "1"b => Operator authentication was required */
  5    30        2 mounted bit (1),				/* "1"b => volume currently mounted */
  5    31        2 ever_mounted bit (1),			/* "1"b => volume has been mounted */
  5    32        2 volume_end bit (1),				/* "1"b => reached end of volume (EOT foil) on write */
  5    33        2 first_file_unexpired bit (1),			/* "1"b => first file of volume is unexpired */
  5    34        2 dev_att_retry bit (1),			/* "1"b => DEVICE ATTENTION recovery in progress */
  5    35        2 pwr_off_retry bit (1),			/* "1"b => POWER OFF recovery in progress */
  5    36        2 mounts fixed bin,				/* Number of times volume mounted during attachment */
  5    37        2 tot_error_stats like mtape_err_stats,		/* Summation of error statistics for all mounts */
  5    38        2 rel_error_stats like mtape_err_stats;		/* Summation of error statistics, this mount */
  5    39 
  5    40 /* Named constants applied to volume_check variable, when volume label read by PFMs pfm_init entry */
  5    41 
  5    42 dcl  (MTAPE_VOLUME init (1),				/* Volume recorded by mtape_ (desired type) */
  5    43      MULT_PRIOR_VOLUME init (2),			/* Volume recorded by prior Multics software
  5    44*						   (desired type) */
  5    45      NON_MULT_VOLUME init (3),			/* Volume recorded by other vendor (desired type) */
  5    46      BLANK_VOLUME init (4),				/* Volume is blank/unreadable */
  5    47      UNLABELED_VOLUME init (5),			/* Volume is unlabeled or has unrecognized label */
  5    48      RECOG_FORMAT_VOLUME init (6)			/* Volume has label of other recognized format */
  5    49      ) fixed bin int static options (constant);
  5    50 
  5    51 /* END INCLUDE FILE mtape_vol_set.incl.pl1 */
      551 
      552 
  6     1 /* BEGIN INCLUDE FILE mtape_label_record.incl.pl1. Created by J. A. Bush 10/13/82 */
  6     2 /* format: style4 */
  6     3 
  6     4 dcl  lr_ptr ptr;
  6     5 
  6     6 dcl  mtape_lr_version_1 char (8) int static options (constant) init ("mtlrv001");
  6     7 
  6     8 dcl  1 mtape_label_record aligned based (lr_ptr),
  6     9        2 version char (8),				/* Current version */
  6    10        2 prev_lab_ptr ptr,				/* Pointer to previous label record structure */
  6    11        2 next_lab_ptr ptr,				/* Pointer to next label record structure */
  6    12        2 lab_ptr ptr,				/* Pointer to the actual format specific label record */
  6    13        2 lab_length fixed bin,			/* Length in 9 bit bytes of the label record */
  6    14        2 mode fixed bin,				/* Hardware recording mode:
  6    15*						   1 = binary
  6    16*						   2 = nine
  6    17*						   3 = bcd */
  6    18        2 conversion fixed bin;			/* Character set conversion required:
  6    19*						   1 = no conversion
  6    20*						   2 = ASCII <==> EBCDIC (any case)
  6    21*						   3 = ASCII <==> BCD
  6    22*						   4 = ASCII ==> Upper case ASCII
  6    23*						   5 = ASCII ==> Upper case EBCDIC */
  6    24 
  6    25 /* END INCLUDE FILE mtape_label_record.incl.pl1 */
      553 
      554 
  7     1 /* BEGIN INCLUDE FILE mtape_err_stats.incl.pl1. Created by J. A. Bush 07/22/83. */
  7     2 /* format: style4 */
  7     3 
  7     4 dcl  es_ptr ptr;
  7     5 
  7     6 dcl  1 mtape_err_stats aligned based (es_ptr),		/* Error statistics block */
  7     7        2 read like err_entry,				/* For read operations */
  7     8        2 write like err_entry,			/* For write operations */
  7     9        2 orders like err_entry,			/* For non-data xfer operations */
  7    10        2 successful_retry (7) fixed bin (35);		/* retrys that succeeded after 1-7 trys */
  7    11 
  7    12 dcl  1 err_entry aligned based,
  7    13        2 errors fixed bin (35),
  7    14        2 operations fixed bin (35);
  7    15 
  7    16 /* END INCLUDE FILE mtape_err_stats.incl.pl1 */
      555 
      556 
  8     1 /* BEGIN INCLUDE FILE mtape_file_info.incl.pl1. Created by J. A. Bush 10/13/82 */
  8     2 /* format: style4 */
  8     3 
  8     4 dcl  fi_ptr ptr;
  8     5 
  8     6 dcl  mtape_fi_version_1 char (8) int static options (constant) init ("mtfiv001");
  8     7 
  8     8 dcl  1 mtape_file_info aligned based (fi_ptr),
  8     9        2 version char (8),				/* Current version */
  8    10        2 prev_fi_ptr ptr,				/* Pointer to the previous file info structure */
  8    11        2 next_fi_ptr ptr,				/* Pointer to the next file info structure */
  8    12        2 first_file_lab_ptr ptr,			/* Pointer to 1st label record struc. */
  8    13        2 last_file_lab_ptr ptr,			/* Pointer to last label record struc. */
  8    14        2 first_file_trail_ptr ptr,			/* Pointer to 1st trailer record struc. */
  8    15        2 last_file_trail_ptr ptr,			/* Pointer to last trailer record struc. */
  8    16        2 first_file_section_ptr ptr,			/* Pointer to file_info struct. of 1st file section */
  8    17        2 begin_vs_ptr ptr,				/* Pointer to 1st volume set struct. containing this file */
  8    18        2 end_vs_ptr ptr,				/* Pointer to last volume set struct. containing this file */
  8    19        2 position_within_file fixed bin,		/* 0 = In HDR; 1 = In data file; 2 = In trailer;
  8    20*						   3 = Not positioned within this file
  8    21*						   4 = At beginning of data file; 5 = At EOF */
  8    22        2 per_file_info,				/* Information pertaining to entire file */
  8    23          3 file_id char (32),				/* File identifier or name */
  8    24          3 file_set_id char (32),			/* Identifies the file set */
  8    25          3 creation_date char (6),			/* File creation date in form " yyddd" */
  8    26          3 expiration_date char (6),			/* File expiration date in form " yyddd" */
  8    27          3 file_code char (3),			/* Printable file code */
  8    28          3 file_format fixed bin,			/* Current file format:
  8    29*						   0 = unspecified; 1 = U; 2 = F; 3 = D or V;
  8    30*						   4 = S or VS; 5 = FB;
  8    31*						   6 = DB or VB; 7 = SB or VBS; */
  8    32          3 seq_number fixed bin,			/* File sequence number */
  8    33          3 generation fixed bin,			/* File generation number, if supported */
  8    34          3 gen_version fixed bin,			/* File generation version number, if supported */
  8    35          3 char_size fixed bin,			/* Size in bits of the data chars of this file */
  8    36          3 hdw_mode fixed bin,			/* Hardware mode: 1 = binary; 2 = nine; 3 = BCD */
  8    37          3 conversion fixed bin,			/* File data conversion:
  8    38*						   1 = no conversion; 2 = ASCII<->EBCDIC; 3 = ASCII<->BCD */
  8    39          3 buffer_offset fixed bin,			/* Number of bytes prior to data */
  8    40          3 length_mode fixed bin,			/* 0 => W/R mod 4 blocks; 1 => W/R non-mod 4 blocks */
  8    41          3 block_size fixed bin (21),			/* Maximum block size for this file */
  8    42          3 record_size fixed bin (21),			/* Maximum record size for this file */
  8    43          3 native_file bit (1),			/* "1"b => current file written by mtape_ PFM */
  8    44          3 user_labels_present bit (1),			/* "1"b => UHL<n>/UTL<n> are present */
  8    45          3 unlabeled_file bit (1),			/* "1"b => this is unlabeled file */
  8    46          3 pfm_opt_sw (5) bit (1),			/* PFM dependent */
  8    47          3 pfm_opt_value (5) fixed bin (35),		/* PFM dependent */
  8    48          3 pfm_opt_str (5) char (32),			/* PFM dependent */
  8    49        2 per_section_info,				/* Information pertaining only to this file section */
  8    50          3 section fixed bin,				/* File section number for multi-volume files */
  8    51          3 phy_file fixed bin,			/* Phy. file of HDR label GRP, on the current volume */
  8    52          3 first_file_on_volume bit (1),		/* "1"b => First file or file section on this volume */
  8    53          3 end_of_file_set bit (1),			/* "1"b => This is last file of file set */
  8    54          3 block_count fixed bin (35),			/* Number of blocks in this file section */
  8    55          3 read_errors fixed bin (35),			/* of errors encountered reading this file */
  8    56          3 write_errors fixed bin (35);			/* of errors encountered writing this file */
  8    57 
  8    58 /* END INCLUDE FILE mtape_file_info.incl.pl1 */
      557 
      558 
  9     1 /* BEGIN INCLUDE FILE mtape_constants.incl.pl1. Created by J. A. Bush 10/07/82 */
  9     2 /* format: style4 */
  9     3 
  9     4 /* This include file defines various named constants used throughout mtape_
  9     5*   and its associated Per-Format modules */
  9     6 
  9     7 /* Storage allocation constants, used to denote what type of storage to allocate */
  9     8 
  9     9 dcl  (MTAPE_ALLOC_VS init (1),			/* to allocate a volume_set structure */
  9    10      MTAPE_ALLOC_LR init (2),				/* to allocate a label record structure */
  9    11      MTAPE_ALLOC_FI init (3),				/* to allocate a file_info structure */
  9    12      MTAPE_ALLOC_STR init (4)				/* to allocate a character string, or undefined block */
  9    13      ) fixed bin int static options (constant);
  9    14 
  9    15 /* Volume density constants */
  9    16 
  9    17 dcl  MTAPE_VALID_DENSITIES (5) init (200, 556, 800, 1600, 6250)
  9    18 	fixed bin int static options (constant);
  9    19 
  9    20 /* Device speed constants */
  9    21 
  9    22 dcl  MTAPE_SPEED_VALUES (4) init (0, 75, 125, 200)	/* 0 is any speed device */
  9    23 	fixed bin int static options (constant);
  9    24 
  9    25 /* Hardware Mode constants */
  9    26 
  9    27 dcl  (MTAPE_HWM_BIN init (1),				/* For binary hardware mode */
  9    28      MTAPE_HWM_NINE init (2),				/* For nine hardware mode */
  9    29      MTAPE_HWM_BCD init (3)				/* For BCD hardware mode */
  9    30      ) fixed bin int static options (constant);
  9    31 
  9    32 /* Data conversion constants */
  9    33 
  9    34 dcl  (MTAPE_UNSPECIFIED init (0),			/* attribute not specified */
  9    35      MTAPE_NO_CONVERSION init (1),			/* No conversion on input or output */
  9    36      MTAPE_CV_EBCDIC init (2),			/* Convert to/from EBCDIC (from/to ASCII) */
  9    37      MTAPE_CV_BCD init (3),				/* Convert to/from BCD (from/to ASCII) */
  9    38      MTAPE_CV_UC_ASCII init (4),			/* Convert to Upper case ASCII (from any case ASCII) */
  9    39      MTAPE_CV_UC_EBCDIC init (5)			/* Convert to Upper case EBCDIC (from any case ASCII) */
  9    40      ) fixed bin int static options (constant);
  9    41 
  9    42 /* File positioning constants */
  9    43 
  9    44 dcl  (NOT_POSITIONED_IN_FILE init (0),			/* Not currently positioned within this file */
  9    45      AT_BOFH init (1),				/* Positioned at beginning of file hdr */
  9    46      AT_EOFH init (2),				/* Positioned at end of file hdr */
  9    47      AT_BOFD init (3),				/* Positioned at beginning of file data */
  9    48      AT_IFD init (4),				/* Positioned in file data, not beginning */
  9    49      AT_EOFD init (5),				/* Positioned prior to end of data file */
  9    50      AT_BOFT init (6),				/* Positioned at beginning of trailer label file */
  9    51      AT_EOFT init (7),				/* Positioned at end of trailer label file */
  9    52      AT_EOF init (8),				/* Positioned after trailer labels at EOF */
  9    53      FILES_PER_FILE_GRP init (3)			/* # of physical files per file (section) group */
  9    54      ) fixed bin int static options (constant);
  9    55 
  9    56 dcl  (BOF_LABEL init (1),				/* indicates beginning of file label */
  9    57      EOV_LABEL init (2),				/* indicates end of volume label */
  9    58      EOF_LABEL init (3)				/* indicates end of file label */
  9    59      ) fixed bin int static options (constant);
  9    60 
  9    61 /* user query constant codes */
  9    62 
  9    63 dcl  (Q_NO_NEXT_VOLUME init (1),
  9    64      Q_LABELED_VOLUME init (2),
  9    65      Q_UNEXPIRED_VOLUME init (3),
  9    66      Q_INCORRECT_VOLUME init (4),
  9    67      Q_UNEXPIRED_FILE init (5),
  9    68      Q_ABORT_FILE init (6)
  9    69      ) fixed bin int static options (constant);
  9    70 
  9    71 /* END INCLUDE FILE mtape_constants.incl.pl1 */
      559 
      560 
 10     1 /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
 10     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
 10     3 /*	version number changed to 4, 08/10/78 WOS */
 10     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
 10     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
 10     6 
 10     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
 10     8     2 version fixed bin,				/* version of this structure - must be set, see below */
 10     9     2 switches aligned,                                     /* various bit switch values */
 10    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
 10    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
 10    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
 10    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
 10    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
 10    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
 10    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
 10    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
 10    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
 10    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
 10    20 
 10    21 /*  Limit of data defined for version 2 */
 10    22 
 10    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
 10    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
 10    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
 10    26 						/* minimum of 30 seconds required for repeat */
 10    27 						/* otherwise, no repeat will occur */
 10    28 /* Limit of data defined for version 4 */
 10    29 
 10    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
 10    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
 10    32 
 10    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
 10    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
 10    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
 10    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
 10    37 
 10    38 /*	END INCLUDE FILE query_info.incl.pl1 */
      561 
      562 
 11     1 /*	Begin include file ... rcp_resource_types.incl.pl1
 11     2*   *
 11     3*   *	Created 3/79 by Michael R. Jordan for MR7.0R
 11     4*   *
 11     5*   *	This include file defines the official RCP resource types.
 11     6*   *	The array of names is indexed by the corresponding device type.
 11     7*   *      MOD by RAF for MCA
 11     8**/
 11     9 
 11    10 
 11    11 
 11    12 /****^  HISTORY COMMENTS:
 11    13*  1) change(85-09-09,Fawcett), approve(85-09-09,MCR6979),
 11    14*     audit(85-12-09,CLJones), install(86-03-21,MR12.0-1033):
 11    15*     Support of MCA.
 11    16*                                                   END HISTORY COMMENTS */
 11    17 
 11    18 dcl  DEVICE_TYPE (8) char (32)
 11    19 	internal static options (constant)
 11    20 	init ("tape_drive", "disk_drive", "console", "printer", "punch", "reader", "special", "mca");
 11    21 
 11    22 dcl  NUM_QUALIFIERS (8) fixed bin			/* Number of qualifiers for each device type. */
 11    23 	internal static init (3, 0, 0, 2, 0, 0, 0, 0);
 11    24 
 11    25 dcl  VOLUME_TYPE (8) char (32)
 11    26 	internal static options (constant)
 11    27 	init ("tape_vol", "disk_vol", "", "", "", "", "", "");
 11    28 
 11    29 dcl  TAPE_DRIVE_DTYPEX fixed bin static internal options (constant) init (1);
 11    30 dcl  DISK_DRIVE_DTYPEX fixed bin static internal options (constant) init (2);
 11    31 dcl  CONSOLE_DTYPEX fixed bin static internal options (constant) init (3);
 11    32 dcl  PRINTER_DTYPEX fixed bin static internal options (constant) init (4);
 11    33 dcl  PUNCH_DTYPEX fixed bin static internal options (constant) init (5);
 11    34 dcl  READER_DTYPEX fixed bin static internal options (constant) init (6);
 11    35 dcl  SPECIAL_DTYPEX fixed bin static internal options (constant) init (7);
 11    36 dcl  MCA_DTYPEX fixed bin static internal options (constant) init (8);
 11    37 dcl  TAPE_VOL_VTYPEX fixed bin static internal options (constant) init (1);
 11    38 dcl  DISK_VOL_VTYPEX fixed bin static internal options (constant) init (2);
 11    39 
 11    40 
 11    41 /*	End include file ... rcp_resource_types.incl.pl1 */
      563 
      564 
 12     1 /* --------------- BEGIN include file rcp_volume_formats.incl.pl1 --------------- */
 12     2 
 12     3 
 12     4 
 12     5 /****^  HISTORY COMMENTS:
 12     6*  1) change(86-12-08,GWMay), approve(86-12-08,PBF7552),
 12     7*     audit(86-12-08,Martinson), install(86-12-17,MR12.0-1250):
 12     8*     added array entry 0 to the volume format types to indicate that the tape
 12     9*     volume was not authenticated by rcp.
 12    10*                                                   END HISTORY COMMENTS */
 12    11 
 12    12 
 12    13 /* General volume types */
 12    14 
 12    15 dcl (Volume_unauthenticated initial (0),
 12    16      Volume_blank initial (1),
 12    17      Volume_unknown_format initial (6),
 12    18      Volume_unreadable initial (7),
 12    19 
 12    20 /* Tape volume types */
 12    21 
 12    22      Volume_multics_tape initial (2),
 12    23      Volume_gcos_tape initial (3),
 12    24      Volume_ibm_tape initial (4),
 12    25      Volume_ansi_tape initial (5)) fixed bin static options (constant);
 12    26 
 12    27 /* Printable descriptions of volume types */
 12    28 
 12    29 dcl  Tape_volume_types (0:7) char (16) static options (constant) initial
 12    30     ("unauthenticated",
 12    31      "blank",
 12    32      "Multics",
 12    33      "GCOS",
 12    34      "IBM",
 12    35      "ANSI",
 12    36      "unrecognizable",
 12    37      "unreadable");
 12    38 
 12    39 /* ---------------- END include file rcp_volume_formats.incl.pl1 ---------------- */
      565 
      566 
 13     1 /*  START OF:	tape_ioi_error_counts.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 13     2 /* Written 22 April 1982 by Chris Jones */
 13     3 
 13     4 /* format: style4,delnl,insnl,indattr,ifthen,declareind10,dclind10 */
 13     5 dcl	tape_ioi_error_counts_ptr
 13     6 			   ptr;
 13     7 
 13     8 dcl	1 tec		   based (tape_ioi_error_counts_ptr) aligned,
 13     9 	  2 version	   char (8),
 13    10 	  2 reads		   like tec_entry,
 13    11 	  2 successful_retry_strategy
 13    12 			   (7) fixed bin (35),
 13    13 	  2 writes	   like tec_entry,
 13    14 	  2 orders	   like tec_entry;
 13    15 
 13    16 dcl	1 tec_entry	   based aligned,
 13    17 	  2 total		   fixed bin (35),
 13    18 	  2 errors	   fixed bin (35);
 13    19 
 13    20 dcl	TEC_VERSION_1	   char (8) aligned internal static options (constant) init ("TECV001");
 13    21 
 13    22 dcl	TEC_VERSION	   char (8) aligned internal static options (constant) init ("TECV001");
 13    23 
 13    24 /*  END OF:	tape_ioi_error_counts.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      567 
      568 
 14     1 /* Begin include file ..... iox_modes.incl.pl1 */
 14     2 
 14     3 /* Written by C. D. Tavares, 03/17/75 */
 14     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
 14     5 
 14     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
 14     7     ("stream_input", "stream_output", "stream_input_output",
 14     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
 14     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
 14    10      "direct_input", "direct_output", "direct_update");
 14    11 
 14    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
 14    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
 14    14 
 14    15 dcl (Stream_input initial (1),
 14    16      Stream_output initial (2),
 14    17      Stream_input_output initial (3),
 14    18      Sequential_input initial (4),
 14    19      Sequential_output initial (5),
 14    20      Sequential_input_output initial (6),
 14    21      Sequential_update initial (7),
 14    22      Keyed_sequential_input initial (8),
 14    23      Keyed_sequential_output initial (9),
 14    24      Keyed_sequential_update initial (10),
 14    25      Direct_input initial (11),
 14    26      Direct_output initial (12),
 14    27      Direct_update initial (13)) fixed bin int static options (constant);
 14    28 
 14    29 /* End include file ..... iox_modes.incl.pl1 */
      569 
      570 
      571      end mtape_util_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/17/86  0830.0  mtape_util_.pl1                   >special_ldd>install>MR12.0-1250>mtape_util_.pl1
543          1    02/16/84  1452.3  mtape_data.incl.pl1               >ldd>include>mtape_data.incl.pl1
545          2    02/16/84  1452.3  mtape_attach_info.incl.pl1        >ldd>include>mtape_attach_info.incl.pl1
547          3    06/11/85  1429.6  mtape_open_close_info.incl.pl1    >ldd>include>mtape_open_close_info.incl.pl1
549          4    02/16/84  1452.4  mtape_pfm_info.incl.pl1           >ldd>include>mtape_pfm_info.incl.pl1
551          5    02/16/84  1452.4  mtape_vol_set.incl.pl1            >ldd>include>mtape_vol_set.incl.pl1
553          6    02/16/84  1452.3  mtape_label_record.incl.pl1       >ldd>include>mtape_label_record.incl.pl1
555          7    02/16/84  1452.3  mtape_err_stats.incl.pl1          >ldd>include>mtape_err_stats.incl.pl1
557          8    02/16/84  1452.3  mtape_file_info.incl.pl1          >ldd>include>mtape_file_info.incl.pl1
559          9    02/16/84  1452.3  mtape_constants.incl.pl1          >ldd>include>mtape_constants.incl.pl1
561         10    03/11/83  1204.3  query_info.incl.pl1               >ldd>include>query_info.incl.pl1
563         11    03/27/86  1120.0  rcp_resource_types.incl.pl1       >ldd>include>rcp_resource_types.incl.pl1
565         12    12/17/86  0758.3  rcp_volume_formats.incl.pl1       >special_ldd>install>MR12.0-1250>rcp_volume_formats.incl.pl1
567         13    12/01/82  1039.8  tape_ioi_error_counts.incl.pl1    >ldd>include>tape_ioi_error_counts.incl.pl1
569         14    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
EXPLAIN_ABORT_FILE              001011 constant        structure                level 1 unaligned dcl 96 set ref 469
EXPLAIN_INCORRECT_VOLUME        000503 constant        structure                level 1 unaligned dcl 77 set ref 452
EXPLAIN_LABELED_VOLUME          000132 constant        structure                level 1 unaligned dcl 56 set ref 434
EXPLAIN_NEW_VOLUME              001165 constant        structure                level 1 unaligned dcl 106 set ref 491
EXPLAIN_NO_NEXT_VOLUME          000000 constant        structure                level 1 unaligned dcl 47 set ref 424
EXPLAIN_UNEXPIRED_FILE          000657 constant        structure                level 1 unaligned dcl 87 set ref 462
EXPLAIN_UNEXPIRED_VOLUME        000373 constant        structure                level 1 unaligned dcl 69 set ref 444
MTAPE_ALLOC_VS                  001530 constant        fixed bin(17,0)          initial dcl 9-9 set ref 485*
NL                              006017 constant        char(1)                  initial unaligned dcl 113 ref 527
Q_NO_NEXT_VOLUME                       constant        fixed bin(17,0)          initial dcl 9-63 ref 484
Sequential_input                       constant        fixed bin(17,0)          initial dcl 14-15 ref 456
TAPE_VOL_VTYPEX                        constant        fixed bin(17,0)          initial dcl 11-37 ref 502
TEC_VERSION_1                   001310 constant        char(8)                  initial dcl 13-20 ref 263
Tape_volume_types               001312 constant        char(16)                 initial array unaligned dcl 12-29 set ref 329 438*
VOLUME_TYPE                     001352 constant        char(32)                 initial array unaligned dcl 11-25 set ref 502*
Volume_ansi_tape                       constant        fixed bin(17,0)          initial dcl 12-15 ref 329
Volume_gcos_tape                       constant        fixed bin(17,0)          initial dcl 12-15 ref 329
Volume_ibm_tape                        constant        fixed bin(17,0)          initial dcl 12-15 ref 329
Volume_multics_tape                    constant        fixed bin(17,0)          initial dcl 12-15 ref 329
Volume_unknown_format                  constant        fixed bin(17,0)          initial dcl 12-15 ref 334
addr                                                   builtin function         dcl 126 ref 262 424 434 444 452 462 469 481 481 491
                                                                                  495 495 529
alloc_type                      000124 automatic       fixed bin(17,0)          dcl 36 set ref 179* 181
answer                          000727 automatic       char(128)                unaligned dcl 39 set ref 416* 481* 482 482 487* 495*
                                                                                  495 495* 498 499 500 502 502 507* 507 508 509 509
                                                                                  509* 509 509 511
answer_iocbp              6     001026 automatic       pointer                  initial level 2 dcl 10-7 set ref 10-7*
areap                     2            based           pointer                  level 2 dcl 1-8 ref 184 202 213 233
arg_alloc_type                         parameter       fixed bin(17,0)          dcl 24 ref 177 179
arg_code                               parameter       fixed bin(35,0)          dcl 28 set ref 242 248* 255 261* 313* 319 324* 348*
                                                                                  408 418* 482* 538 538*
arg_length                             parameter       fixed bin(21,0)          dcl 26 ref 177 231
arg_mtdp                               parameter       pointer                  dcl 23 ref 177 178 242 244 255 257 319 321 408 410
arg_prev_ptr                           parameter       pointer                  dcl 25 ref 177 180
arg_qcode                              parameter       fixed bin(17,0)          dcl 29 ref 408 422 484
arg_return_ptr                         parameter       pointer                  dcl 27 set ref 177 236*
argp                            000104 automatic       pointer                  dcl 33 set ref 246* 247*
atec                            000771 automatic       structure                level 1 dcl 42 set ref 262
attach_info_ptr         274            based           pointer                  level 2 dcl 1-8 ref 323 413
based_area                             based           area(1024)               dcl 145 ref 184 202 213 233
based_str                              based           char                     unaligned dcl 144 ref 233
begin_vs_ptr             20            based           pointer                  level 2 dcl 8-8 set ref 220*
canon_for_volume_label_         000030 constant        entry                    external dcl 133 ref 502
cdx                             000126 automatic       fixed bin(17,0)          dcl 36 set ref 499* 500 500* 502 502 507
char_size                56            based           fixed bin(17,0)          level 3 dcl 8-8 set ref 224*
code                            000767 automatic       fixed bin(35,0)          dcl 40 set ref 261* 264* 265 266* 269* 270 271* 313
                                                                                  324* 345* 347* 348 355* 356 357* 361* 362 363*
                                                                                  367* 368 369* 373* 374 375* 379* 380 381* 385* 386
                                                                                  387* 391* 392 393* 397* 398 399* 426* 436* 446*
                                                                                  454* 464* 471* 478 482 493* 494 502* 504 504 538
codeptr                                                builtin function         dcl 126 ref 345 345 355 355 361 361 367 367 373 373
                                                                                  379 379 385 385 391 391 397 397
com_err_                        000034 constant        entry                    external dcl 135 ref 248
command_query_                  000036 constant        entry                    external dcl 136 ref 481 495
cp_escape_control         1(02) 001026 automatic       bit(2)                   initial level 3 packed unaligned dcl 10-7 set ref
                                                                                  10-7*
creation_date            45            based           char(6)                  level 3 dcl 8-8 set ref 222*
cu_$arg_list_ptr                000040 constant        entry                    external dcl 137 ref 246
decode_file_labels      350            based           entry variable           level 3 dcl 1-8 set ref 391*
default_pfm_prefix       15            based           char(21)                 level 2 dcl 2-8 ref 336
demount_comment          56            based           char(64)                 level 2 dcl 5-9 set ref 192*
device_name              76            based           char(8)                  level 2 dcl 5-9 set ref 191*
display_errors           55            based           bit(1)                   level 2 dcl 1-8 ref 244
encode_file_labels      354            based           entry variable           level 3 dcl 1-8 set ref 397*
end_vs_ptr               22            based           pointer                  level 2 dcl 8-8 set ref 220*
ep                              000110 automatic       pointer                  dcl 33 set ref 345* 346
err_entry                              based           structure                level 1 dcl 7-12
error_table_$file_aborted       000020 external static fixed bin(35,0)          dcl 122 ref 471
error_table_$no_next_volume     000010 external static fixed bin(35,0)          dcl 118 ref 426
error_table_$unexpired_file     000016 external static fixed bin(35,0)          dcl 121 ref 464
error_table_$unexpired_volume   000014 external static fixed bin(35,0)          dcl 120 ref 446
error_table_$uninitialized_volume
                                000012 external static fixed bin(35,0)          dcl 119 ref 436 454
errors                    3            based           fixed bin(35,0)          level 3 in structure "tec" dcl 13-8 in procedure
                                                                                  "mtape_util_" ref 277 290 309
errors                  123            based           fixed bin(35,0)          level 4 in structure "mtape_vol_set" dcl 5-9
                                                                                  in procedure "mtape_util_" set ref 285* 285
errors                   16            based           fixed bin(35,0)          level 3 in structure "tec" dcl 13-8 in procedure
                                                                                  "mtape_util_" ref 285 298
errors                   14            based           fixed bin(35,0)          level 3 in structure "tec" dcl 13-8 in procedure
                                                                                  "mtape_util_" ref 281 294 310
errors                  117            based           fixed bin(35,0)          level 4 in structure "mtape_vol_set" dcl 5-9
                                                                                  in procedure "mtape_util_" set ref 277* 277
errors                  134            based           fixed bin(35,0)          level 4 in structure "mtape_vol_set" dcl 5-9
                                                                                  in procedure "mtape_util_" set ref 290* 290
errors                  140            based           fixed bin(35,0)          level 4 in structure "mtape_vol_set" dcl 5-9
                                                                                  in procedure "mtape_util_" set ref 298* 298
errors                  121            based           fixed bin(35,0)          level 4 in structure "mtape_vol_set" dcl 5-9
                                                                                  in procedure "mtape_util_" set ref 281* 281
errors                  136            based           fixed bin(35,0)          level 4 in structure "mtape_vol_set" dcl 5-9
                                                                                  in procedure "mtape_util_" set ref 294* 294
expiration_date          47            based           char(6)                  level 3 dcl 8-8 set ref 222*
explain_str                     000127 automatic       char(1024)               unaligned dcl 37 set ref 525* 527* 527 529 530
explanation_len          14     001026 automatic       fixed bin(21,0)          initial level 2 dcl 10-7 set ref 10-7* 530*
explanation_ptr          12     001026 automatic       pointer                  initial level 2 dcl 10-7 set ref 10-7* 529*
fi_current               34            based           pointer                  level 2 dcl 1-8 ref 259 412
fi_ptr                          001024 automatic       pointer                  dcl 8-4 set ref 215* 216 217 217 218 218 219 220 220
                                                                                  221 221 222 222 223 224 225 226 227 259* 308 309
                                                                                  309 310 310 412* 465 472 472
file_close              330            based           entry variable           level 3 dcl 1-8 set ref 367*
file_id                  25            based           char(32)                 level 3 dcl 8-8 set ref 221* 465* 472*
file_open               324            based           entry variable           level 3 dcl 1-8 set ref 361*
file_set_id              35            based           char(32)                 level 3 dcl 8-8 set ref 221*
first_file_lab_ptr        6            based           pointer                  level 2 dcl 8-8 set ref 217*
first_file_section_ptr
                         16            based           pointer                  level 2 dcl 8-8 set ref 219*
first_file_trail_ptr     12            based           pointer                  level 2 dcl 8-8 set ref 218*
first_vl_ptr             12            based           pointer                  level 2 dcl 5-9 set ref 189*
hbound                                                 builtin function         dcl 126 ref 302
hcs_$make_entry                 000044 constant        entry                    external dcl 139 ref 355 361 367 373 379 385 391 397
hcs_$make_ptr                   000046 constant        entry                    external dcl 140 ref 345
i                               001060 automatic       fixed bin(17,0)          dcl 523 in procedure "SET_EXPLANATION" set ref 526*
                                                                                  527*
i                               000125 automatic       fixed bin(17,0)          dcl 36 in procedure "mtape_util_" set ref 302* 303
                                                                                  303 303 305 305 305*
index                                                  builtin function         dcl 126 ref 340 499 509
invert_qsw                      000770 automatic       bit(1)                   dcl 41 set ref 417* 427* 482 482
ioa_$general_rs                 000042 constant        entry                    external dcl 138 ref 247
ioa_$rsnnl                      000032 constant        entry                    external dcl 134 ref 428 438 447 456 465 472
lab_ptr                   6            based           pointer                  level 2 dcl 6-8 set ref 206*
labeled                  24            based           bit(1)                   level 2 dcl 2-8 set ref 438*
last_file_lab_ptr        10            based           pointer                  level 2 dcl 8-8 set ref 217*
last_file_trail_ptr      14            based           pointer                  level 2 dcl 8-8 set ref 218*
last_vl_ptr              14            based           pointer                  level 2 dcl 5-9 set ref 189*
length                                                 builtin function         dcl 126 ref 500 530
literal_sw                1(05) 001026 automatic       bit(1)                   initial level 3 packed unaligned dcl 10-7 set ref
                                                                                  10-7*
lr_ptr                          001022 automatic       pointer                  dcl 6-4 set ref 204* 205 206 207 208 209
lrm_vs_ptr               10            based           pointer                  level 2 dcl 5-9 set ref 188*
ltrim                                                  builtin function         dcl 126 ref 507
maip                            001012 automatic       pointer                  dcl 2-4 set ref 323* 326 326 336 339 413* 438
module_id                 2            based           char(21)                 level 2 dcl 4-8 set ref 438*
moip                            001014 automatic       pointer                  dcl 3-4 set ref 414* 456
mount_comment            36            based           char(64)                 level 2 dcl 5-9 set ref 191* 511*
mpfmip                          001016 automatic       pointer                  dcl 4-4 set ref 415* 438
mrm_vs_ptr                6            based           pointer                  level 2 dcl 5-9 set ref 188*
mtape_attach_info                      based           structure                level 1 dcl 2-8
mtape_data                             based           structure                level 1 dcl 1-8
mtape_err_stats                        based           structure                level 1 dcl 7-6
mtape_fi_version_1              001452 constant        char(8)                  initial unaligned dcl 8-6 ref 216
mtape_file_info                        based           structure                level 1 dcl 8-8 set ref 213
mtape_label_record                     based           structure                level 1 dcl 6-8 set ref 202
mtape_lr_version_1              001454 constant        char(8)                  initial unaligned dcl 6-6 ref 205
mtape_open_info                        based           structure                level 1 dcl 3-10
mtape_pfm_info                         based           structure                level 1 dcl 4-8
mtape_util_$error               000026 constant        entry                    external dcl 132 ref 266 271 347 357 363 369 375 381
                                                                                  387 393 399
mtape_vol_set                          based           structure                level 1 dcl 5-9 set ref 184
mtape_vs_version_1              001456 constant        char(8)                  initial unaligned dcl 5-7 ref 187
mtdp                            001010 automatic       pointer                  dcl 1-4 set ref 178* 184 202 213 233 257* 258 259
                                                                                  264 266* 269 271* 321* 322 323 347* 351 355 357*
                                                                                  361 363* 367 369* 373 375* 379 381* 385 387* 391
                                                                                  393* 397 399* 410* 411 412 413 414 415 485* 485
                                                                                  486
myname                          001460 constant        char(6)                  initial unaligned dcl 46 set ref 248* 481* 495*
n_lines                                based           fixed bin(17,0)          level 2 dcl 147 ref 526
next_fi_ptr               4            based           pointer                  level 2 dcl 8-8 set ref 225* 227*
next_lab_ptr              4            based           pointer                  level 2 dcl 6-8 set ref 207* 209*
next_vs_ptr               4            based           pointer                  level 2 dcl 5-9 set ref 193* 196*
null                                                   builtin function         dcl 126 ref 188 189 193 195 206 207 209 217 218 219
                                                                                  220 225 227 308 346 10-7 10-7 10-7
open_info_ptr           276            based           pointer                  level 2 dcl 1-8 ref 414
open_mode                10            based           fixed bin(17,0)          level 2 dcl 3-10 ref 456
operations              137            based           fixed bin(35,0)          level 4 in structure "mtape_vol_set" dcl 5-9
                                                                                  in procedure "mtape_util_" set ref 296* 296
operations              122            based           fixed bin(35,0)          level 4 in structure "mtape_vol_set" dcl 5-9
                                                                                  in procedure "mtape_util_" set ref 283* 283
operations              141            based           fixed bin(35,0)          level 4 in structure "mtape_vol_set" dcl 5-9
                                                                                  in procedure "mtape_util_" set ref 300* 300
operations              124            based           fixed bin(35,0)          level 4 in structure "mtape_vol_set" dcl 5-9
                                                                                  in procedure "mtape_util_" set ref 287* 287
operations              120            based           fixed bin(35,0)          level 4 in structure "mtape_vol_set" dcl 5-9
                                                                                  in procedure "mtape_util_" set ref 279* 279
operations              135            based           fixed bin(35,0)          level 4 in structure "mtape_vol_set" dcl 5-9
                                                                                  in procedure "mtape_util_" set ref 292* 292
order                   344            based           entry variable           level 3 dcl 1-8 set ref 385*
orders                  123            based           structure                level 3 in structure "mtape_vol_set" dcl 5-9
                                                                                  in procedure "mtape_util_"
orders                  140            based           structure                level 3 in structure "mtape_vol_set" dcl 5-9
                                                                                  in procedure "mtape_util_"
orders                   15            based           structure                level 2 in structure "tec" dcl 13-8 in procedure
                                                                                  "mtape_util_"
padding                   1(07) 001026 automatic       bit(29)                  initial level 3 packed unaligned dcl 10-7 set ref
                                                                                  10-7*
per_file_info            25            based           structure                level 2 dcl 8-8
per_section_info        152            based           structure                level 2 dcl 8-8
pfm_arg_values                         based           structure                level 1 dcl 3-57
pfm_entries                            based           structure                level 1 dcl 1-103
pfm_info_ptr            304            based           pointer                  level 2 dcl 1-8 ref 415
pfm_init                320            based           entry variable           level 3 dcl 1-8 set ref 355*
pfm_name                310            based           char(32)                 level 2 dcl 1-8 set ref 351*
pfm_opt_str             102            based           char(32)                 array level 3 dcl 8-8 set ref 223*
pfm_options                            based           structure                level 1 dcl 4-21
pfm_prefix                7            based           char(21)                 level 2 dcl 2-8 set ref 326 326 339*
pfm_required_entries    320            based           structure                level 2 dcl 1-8
pfmn                            000112 automatic       char(32)                 unaligned dcl 34 set ref 326* 329* 334* 336* 338*
                                                                                  338 339 340 340* 340 345* 347* 351 355* 357* 361*
                                                                                  363* 367* 369* 373* 375* 379* 381* 385* 387* 391*
                                                                                  393* 397* 399*
prev_fi_ptr               2            based           pointer                  level 2 dcl 8-8 set ref 226*
prev_lab_ptr              2            based           pointer                  level 2 dcl 6-8 set ref 208*
prev_ptr                        000100 automatic       pointer                  dcl 33 set ref 180* 194 195 196 197 208 209 209 226
                                                                                  227 227
prev_vs_ptr               2            based           pointer                  level 2 dcl 5-9 set ref 194*
prompt_after_explanation
                          1(06) 001026 automatic       bit(1)                   initial level 3 packed unaligned dcl 10-7 set ref
                                                                                  421* 10-7*
qep                             000106 automatic       pointer                  dcl 33 set ref 424* 434* 444* 452* 462* 469* 491*
                                                                                  526 527
query_code                3     001026 automatic       fixed bin(35,0)          initial level 2 dcl 10-7 set ref 437* 455* 490*
                                                                                  10-7*
query_explanation                      based           structure                level 1 unaligned dcl 147
query_info                      001026 automatic       structure                level 1 dcl 10-7 set ref 481 481 495 495
query_info_version_6                   constant        fixed bin(17,0)          initial dcl 10-36 ref 419
question_iocbp            4     001026 automatic       pointer                  initial level 2 dcl 10-7 set ref 10-7*
read                    334            based           entry variable           level 3 in structure "mtape_data" dcl 1-8
                                                                                  in procedure "mtape_util_" set ref 373*
read                    117            based           structure                level 3 in structure "mtape_vol_set" dcl 5-9
                                                                                  in procedure "mtape_util_"
read                    134            based           structure                level 3 in structure "mtape_vol_set" dcl 5-9
                                                                                  in procedure "mtape_util_"
read_errors             157            based           fixed bin(35,0)          level 3 dcl 8-8 set ref 309* 309
reads                     2            based           structure                level 2 dcl 13-8
rel_error_stats         134            based           structure                level 2 dcl 5-9
repeat_time              10     001026 automatic       fixed bin(71,0)          initial level 2 dcl 10-7 set ref 10-7*
rs_emess                        000527 automatic       char(512)                unaligned dcl 38 set ref 245* 247* 248* 416* 428*
                                                                                  438* 447* 456* 465* 472* 481 481
rs_len                          000123 automatic       fixed bin(21,0)          dcl 35 set ref 247* 428* 438* 447* 456* 465* 472*
rtrim                                                  builtin function         dcl 126 ref 340 481 481 500 527 530
section                 152            based           fixed bin(17,0)          level 3 dcl 8-8 set ref 472*
status_code               2     001026 automatic       fixed bin(35,0)          initial level 2 dcl 10-7 set ref 478* 490* 504*
                                                                                  10-7*
str_length                      000122 automatic       fixed bin(21,0)          dcl 35 set ref 231* 233 233
substr                                                 builtin function         dcl 126 ref 502 502 507 509 509 509
successful_retry        125            based           fixed bin(35,0)          array level 3 in structure "mtape_vol_set" dcl 5-9
                                                                                  in procedure "mtape_util_" set ref 302 303* 303
successful_retry        142            based           fixed bin(35,0)          array level 3 in structure "mtape_vol_set" dcl 5-9
                                                                                  in procedure "mtape_util_" set ref 305* 305
successful_retry_strategy
                          4            based           fixed bin(35,0)          array level 2 dcl 13-8 ref 303 305
suppress_name_sw          1(01) 001026 automatic       bit(1)                   initial level 3 packed unaligned dcl 10-7 set ref
                                                                                  489* 10-7*
suppress_spacing          1(04) 001026 automatic       bit(1)                   initial level 3 packed unaligned dcl 10-7 set ref
                                                                                  10-7*
switches                  1     001026 automatic       structure                level 2 dcl 10-7
tape_ioi_$get_statistics        000022 constant        entry                    external dcl 130 ref 264
tape_ioi_$reset_statistics      000024 constant        entry                    external dcl 131 ref 269
tape_ioi_error_counts_ptr       001044 automatic       pointer                  dcl 13-5 set ref 262* 263 264* 277 279 281 283 285
                                                                                  287 290 292 294 296 298 300 303 305 309 310
tec                                    based           structure                level 1 dcl 13-8
tec_entry                              based           structure                level 1 dcl 13-16
temp_ptr                        000102 automatic       pointer                  dcl 33 set ref 184* 186 202* 204 213* 215 233* 236
text                      1            based           char(71)                 array level 2 packed unaligned dcl 147 ref 527
tioi_id                 273            based           bit(36)                  level 2 dcl 1-8 set ref 264* 269*
tot_error_stats         117            based           structure                level 2 dcl 5-9
total                     2            based           fixed bin(35,0)          level 3 in structure "tec" dcl 13-8 in procedure
                                                                                  "mtape_util_" ref 279 292
total                    13            based           fixed bin(35,0)          level 3 in structure "tec" dcl 13-8 in procedure
                                                                                  "mtape_util_" ref 283 296
total                    15            based           fixed bin(35,0)          level 3 in structure "tec" dcl 13-8 in procedure
                                                                                  "mtape_util_" ref 287 300
translate                                              builtin function         dcl 126 ref 338
version                                based           char(8)                  level 2 in structure "mtape_vol_set" dcl 5-9
                                                                                  in procedure "mtape_util_" set ref 187*
version                                based           char(8)                  level 2 in structure "mtape_file_info" dcl 8-8
                                                                                  in procedure "mtape_util_" set ref 216*
version                                based           char(8)                  level 2 in structure "mtape_label_record" dcl 6-8
                                                                                  in procedure "mtape_util_" set ref 205*
version                                based           char(8)                  level 2 in structure "tec" dcl 13-8 in procedure
                                                                                  "mtape_util_" set ref 263*
version                         001026 automatic       fixed bin(17,0)          level 2 in structure "query_info" dcl 10-7
                                                                                  in procedure "mtape_util_" set ref 419*
volume_id                26            based           char(32)                 level 2 dcl 5-9 set ref 190* 428* 438* 456*
volume_index            102            based           fixed bin(17,0)          level 2 dcl 5-9 set ref 197* 197 199*
volume_name              16            based           char(32)                 level 2 dcl 5-9 set ref 190* 447* 456* 502*
volume_type             104            based           fixed bin(17,0)          level 2 dcl 5-9 ref 329 329 329 329 329 334 438
vs_current               24            based           pointer                  level 2 dcl 1-8 ref 258 322 411
vs_ptr                          001020 automatic       pointer                  dcl 5-5 set ref 186* 187 188 188 189 189 190 190 191
                                                                                  191 192 193 194 196 197 199 258* 277 277 279 279
                                                                                  281 281 283 283 285 285 287 287 290 290 292 292
                                                                                  294 294 296 296 298 298 300 300 302 303 303 305
                                                                                  305 322* 329 329 329 329 329 334 411* 428 438 438
                                                                                  447 456 456 485* 486 502 511
vs_tail                  22            based           pointer                  level 2 dcl 1-8 set ref 485* 486*
write                   340            based           entry variable           level 3 in structure "mtape_data" dcl 1-8
                                                                                  in procedure "mtape_util_" set ref 379*
write                   136            based           structure                level 3 in structure "mtape_vol_set" dcl 5-9
                                                                                  in procedure "mtape_util_"
write                   121            based           structure                level 3 in structure "mtape_vol_set" dcl 5-9
                                                                                  in procedure "mtape_util_"
write_errors            160            based           fixed bin(35,0)          level 3 dcl 8-8 set ref 310* 310
writes                   13            based           structure                level 2 dcl 13-8
yes_or_no_sw              1     001026 automatic       bit(1)                   initial level 3 packed unaligned dcl 10-7 set ref
                                                                                  420* 488* 10-7*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
AT_BOFD                                internal static fixed bin(17,0)          initial dcl 9-44
AT_BOFH                                internal static fixed bin(17,0)          initial dcl 9-44
AT_BOFT                                internal static fixed bin(17,0)          initial dcl 9-44
AT_EOF                                 internal static fixed bin(17,0)          initial dcl 9-44
AT_EOFD                                internal static fixed bin(17,0)          initial dcl 9-44
AT_EOFH                                internal static fixed bin(17,0)          initial dcl 9-44
AT_EOFT                                internal static fixed bin(17,0)          initial dcl 9-44
AT_IFD                                 internal static fixed bin(17,0)          initial dcl 9-44
BLANK_VOLUME                           internal static fixed bin(17,0)          initial dcl 5-42
BOF_LABEL                              internal static fixed bin(17,0)          initial dcl 9-56
CONSOLE_DTYPEX                         internal static fixed bin(17,0)          initial dcl 11-31
DEVICE_TYPE                            internal static char(32)                 initial array unaligned dcl 11-18
DISK_DRIVE_DTYPEX                      internal static fixed bin(17,0)          initial dcl 11-30
DISK_VOL_VTYPEX                        internal static fixed bin(17,0)          initial dcl 11-38
Direct_input                           internal static fixed bin(17,0)          initial dcl 14-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 14-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 14-15
EOF_LABEL                              internal static fixed bin(17,0)          initial dcl 9-56
EOV_LABEL                              internal static fixed bin(17,0)          initial dcl 9-56
FILES_PER_FILE_GRP                     internal static fixed bin(17,0)          initial dcl 9-44
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 14-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 14-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 14-15
MCA_DTYPEX                             internal static fixed bin(17,0)          initial dcl 11-36
MTAPE_ALLOC_FI                         internal static fixed bin(17,0)          initial dcl 9-9
MTAPE_ALLOC_LR                         internal static fixed bin(17,0)          initial dcl 9-9
MTAPE_ALLOC_STR                        internal static fixed bin(17,0)          initial dcl 9-9
MTAPE_CV_BCD                           internal static fixed bin(17,0)          initial dcl 9-34
MTAPE_CV_EBCDIC                        internal static fixed bin(17,0)          initial dcl 9-34
MTAPE_CV_UC_ASCII                      internal static fixed bin(17,0)          initial dcl 9-34
MTAPE_CV_UC_EBCDIC                     internal static fixed bin(17,0)          initial dcl 9-34
MTAPE_HWM_BCD                          internal static fixed bin(17,0)          initial dcl 9-27
MTAPE_HWM_BIN                          internal static fixed bin(17,0)          initial dcl 9-27
MTAPE_HWM_NINE                         internal static fixed bin(17,0)          initial dcl 9-27
MTAPE_NO_CONVERSION                    internal static fixed bin(17,0)          initial dcl 9-34
MTAPE_SPEED_VALUES                     internal static fixed bin(17,0)          initial array dcl 9-22
MTAPE_UNSPECIFIED                      internal static fixed bin(17,0)          initial dcl 9-34
MTAPE_VALID_DENSITIES                  internal static fixed bin(17,0)          initial array dcl 9-17
MTAPE_VOLUME                           internal static fixed bin(17,0)          initial dcl 5-42
MULT_PRIOR_VOLUME                      internal static fixed bin(17,0)          initial dcl 5-42
NON_MULT_VOLUME                        internal static fixed bin(17,0)          initial dcl 5-42
NOT_POSITIONED_IN_FILE                 internal static fixed bin(17,0)          initial dcl 9-44
NUM_QUALIFIERS                         internal static fixed bin(17,0)          initial array dcl 11-22
PRINTER_DTYPEX                         internal static fixed bin(17,0)          initial dcl 11-32
PUNCH_DTYPEX                           internal static fixed bin(17,0)          initial dcl 11-33
Q_ABORT_FILE                           internal static fixed bin(17,0)          initial dcl 9-63
Q_INCORRECT_VOLUME                     internal static fixed bin(17,0)          initial dcl 9-63
Q_LABELED_VOLUME                       internal static fixed bin(17,0)          initial dcl 9-63
Q_UNEXPIRED_FILE                       internal static fixed bin(17,0)          initial dcl 9-63
Q_UNEXPIRED_VOLUME                     internal static fixed bin(17,0)          initial dcl 9-63
READER_DTYPEX                          internal static fixed bin(17,0)          initial dcl 11-34
RECOG_FORMAT_VOLUME                    internal static fixed bin(17,0)          initial dcl 5-42
SPECIAL_DTYPEX                         internal static fixed bin(17,0)          initial dcl 11-35
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 14-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 14-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 14-15
Stream_input                           internal static fixed bin(17,0)          initial dcl 14-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 14-15
Stream_output                          internal static fixed bin(17,0)          initial dcl 14-15
TAPE_DRIVE_DTYPEX                      internal static fixed bin(17,0)          initial dcl 11-29
TEC_VERSION                            internal static char(8)                  initial dcl 13-22
UNLABELED_VOLUME                       internal static fixed bin(17,0)          initial dcl 5-42
Volume_blank                           internal static fixed bin(17,0)          initial dcl 12-15
Volume_unauthenticated                 internal static fixed bin(17,0)          initial dcl 12-15
Volume_unreadable                      internal static fixed bin(17,0)          initial dcl 12-15
all_buf_lens                           based           fixed bin(21,0)          array dcl 1-114
all_buf_ptrs                           based           pointer                  array dcl 1-113
es_ptr                                 automatic       pointer                  dcl 7-4
iox_modes                              internal static char(24)                 initial array dcl 14-6
mcip                                   automatic       pointer                  dcl 3-5
mtape_attach_info_version_1            internal static char(8)                  initial unaligned dcl 2-6
mtape_close_info                       based           structure                level 1 dcl 3-41
mtape_close_info_version_1             internal static char(8)                  initial unaligned dcl 3-8
mtape_data_version_1                   internal static char(8)                  initial unaligned dcl 1-6
mtape_open_info_version_1              internal static char(8)                  initial unaligned dcl 3-7
mtape_pfm_info_version_1               internal static char(8)                  initial unaligned dcl 4-6
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 10-33
query_info_version_4                   internal static fixed bin(17,0)          initial dcl 10-34
query_info_version_5                   internal static fixed bin(17,0)          initial dcl 10-35
short_iox_modes                        internal static char(4)                  initial array dcl 14-12
tape_blk                               based           char(1)                  array unaligned dcl 1-115

NAMES DECLARED BY EXPLICIT CONTEXT.
SAVE_CODE                       005603 constant        entry                    internal dcl 536 ref 359 365 371 377 383 389 395 401
SET_EXPLANATION                 005505 constant        entry                    internal dcl 521 ref 480 492
U_QUERY                         001301 constant        label                    array(6) dcl 424 set ref 422
U_QUERY_COM                     005112 constant        label                    dcl 478 ref 432 442 450 460 467 476
alloc                           002460 constant        entry                    external dcl 177 ref 485
alloc_end                       002712 constant        label                    dcl 236 ref 200 211 229 234
alloc_storage                   001275 constant        label                    array(4) dcl 184 ref 181
error                           002722 constant        entry                    external dcl 242
get_statistics                  003045 constant        entry                    external dcl 255
gs_return                       003322 constant        label                    dcl 313 ref 267 272
init_pfm                        003327 constant        entry                    external dcl 319
mtape_util_                     002444 constant        entry                    external dcl 6 ref 345 345 355 355 361 361 367 367
                                                                                  373 373 379 379 385 385 391 391 397 397
user_query                      004511 constant        entry                    external dcl 408

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6266        6336    6021        6276
Length      7066    6021        50         513     245           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mtape_util_                         728 external procedure  is an external procedure.  
SET_EXPLANATION                         internal procedure  shares stack frame of external procedure mtape_util_.  
SAVE_CODE                               internal procedure  shares stack frame of external procedure mtape_util_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mtape_util_              000100 prev_ptr                    mtape_util_
                         000102 temp_ptr                    mtape_util_
                         000104 argp                        mtape_util_
                         000106 qep                         mtape_util_
                         000110 ep                          mtape_util_
                         000112 pfmn                        mtape_util_
                         000122 str_length                  mtape_util_
                         000123 rs_len                      mtape_util_
                         000124 alloc_type                  mtape_util_
                         000125 i                           mtape_util_
                         000126 cdx                         mtape_util_
                         000127 explain_str                 mtape_util_
                         000527 rs_emess                    mtape_util_
                         000727 answer                      mtape_util_
                         000767 code                        mtape_util_
                         000770 invert_qsw                  mtape_util_
                         000771 atec                        mtape_util_
                         001010 mtdp                        mtape_util_
                         001012 maip                        mtape_util_
                         001014 moip                        mtape_util_
                         001016 mpfmip                      mtape_util_
                         001020 vs_ptr                      mtape_util_
                         001022 lr_ptr                      mtape_util_
                         001024 fi_ptr                      mtape_util_
                         001026 query_info                  mtape_util_
                         001044 tape_ioi_error_counts_ptr   mtape_util_
                         001060 i                           SET_EXPLANATION

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             alloc_char_temp     cat_realloc_chars   call_ext_in         call_ext_out_desc
call_ext_out        return_mac          shorten_stack       ext_entry           set_chars_eis       index_chars_eis
op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
canon_for_volume_label_       com_err_                      command_query_                cu_$arg_list_ptr
hcs_$make_entry               hcs_$make_ptr                 ioa_$general_rs               ioa_$rsnnl
mtape_util_$error             tape_ioi_$get_statistics      tape_ioi_$reset_statistics

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$file_aborted     error_table_$no_next_volume   error_table_$unexpired_file   error_table_$unexpired_volume
error_table_$uninitialized_volume




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
10    7 002411         6 002443       177 002452       178 002466       179 002472       180 002474       181 002477
    184 002500       186 002506       187 002507       188 002513       189 002516       190 002521       191 002527
    192 002535       193 002540       194 002542       195 002544       196 002547       197 002550       198 002553
    199 002554       200 002556       202 002557       204 002565       205 002566       206 002572       207 002574
    208 002575       209 002577       211 002603       213 002604       215 002612       216 002613       217 002617
    218 002622       219 002625       220 002627       221 002632       222 002640       223 002645       224 002663
    225 002666       226 002670       227 002672       229 002676       231 002677       233 002701       234 002711
    236 002712       238 002715       242 002716       244 002733       245 002740       246 002743       247 002752
    248 003021       251 003042       255 003043       257 003056       258 003062       259 003064       261 003066
    262 003070       263 003072       264 003075       265 003110       266 003112       267 003136       269 003137
    270 003151       271 003153       272 003177       277 003200       279 003206       281 003212       283 003216
    285 003222       287 003226       290 003232       292 003236       294 003242       296 003246       298 003252
    300 003256       302 003262       303 003267       305 003276       307 003302       308 003304       309 003310
    310 003316       313 003322       315 003324       319 003325       321 003340       322 003344       323 003346
    324 003350       326 003352       329 003362       334 003401       336 003407       338 003412       339 003423
    340 003430       345 003465       346 003520       347 003524       348 003554       349 003556       351 003557
    355 003563       356 003620       357 003622       359 003652       361 003653       362 003714       363 003716
    365 003746       367 003747       368 004007       369 004011       371 004041       373 004042       374 004100
    375 004102       377 004132       379 004133       380 004171       381 004173       383 004223       385 004224
    386 004262       387 004264       389 004314       391 004315       392 004357       393 004361       395 004411
    397 004412       398 004451       399 004453       401 004503       404 004504       408 004505       410 004522
    411 004526       412 004530       413 004532       414 004534       415 004536       416 004540       417 004546
    418 004547       419 004550       420 004552       421 004554       422 004556       424 004560       426 004562
    427 004565       428 004567       432 004617       434 004620       436 004622       437 004625       438 004627
    442 004677       444 004700       446 004702       447 004705       450 004735       452 004736       454 004740
    455 004743       456 004745       460 005011       462 005012       464 005014       465 005017       467 005047
    469 005050       471 005052       472 005055       476 005111       478 005112       480 005114       481 005115
    482 005164       484 005204       485 005210       486 005230       487 005233       488 005236       489 005240
    490 005242       491 005244       492 005246       493 005247       494 005251       495 005254       498 005322
    499 005326       500 005336       502 005351       504 005414       507 005421       508 005445       509 005451
    511 005477       515 005503       517 005504       521 005505       525 005506       526 005511       527 005521
    528 005563       529 005566       530 005570       532 005602       536 005603       538 005604       541 005610


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
