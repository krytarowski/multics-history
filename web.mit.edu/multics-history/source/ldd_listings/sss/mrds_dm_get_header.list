	COMPILATION LISTING OF SEGMENT mrds_dm_get_header
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/16/86  1345.0 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1976 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 
       19 
       20 /*
       21*                   BEGIN_DESCRIPTION
       22*   this routine has three  entries,  get_header  for  use  by  dmd_,
       23*   mrds_dm_get_header for use internally by mrds, and get_model_info
       24*   for use by mmi_
       25*
       26*   It's purpose is to return the version and creation infmoration on
       27*   the database model.
       28*
       29*   There are three entries. mrds_dm_get_header is for  internal  use
       30*   by  mrds.  get_header is for external use by dmd_. get_model_info
       31*   is for external use by mmi_. The external entries check  for  the
       32*   user being a DBA if the database is secured.
       33*                   END_DESCRIPTION
       34**/
       35 
       36 /* PARAMETERS:
       37*
       38*   ======= for the get_model_info entry
       39*
       40*   open_name - - (input) char(*), the name given to mmi_$open_model
       41*
       42*   area_ptr - - (input) ptr, points to a freeing area for  structure
       43*   allocation
       44*
       45*   structure_version - - (input) fixed bin, the desired  version  of
       46*   the structure
       47*
       48*   mrds_db_model_info_ptr - - (output) ptr, points to the  allocated
       49*   structure in mrds_db_model_info.incl.pl1
       50*
       51*   code - - (output) fixed bin(35), the error status encoding
       52*
       53*   ======= for the mrds_dm_get_header and get_header entries
       54*
       55*   data_model_ptr - - (input) ptr, the model pointer  returned  from
       56*   dmd_$open_dm
       57*
       58*   area_ptr - - (input) ptr, points to an area in which to  allocate
       59*   the header information
       60*
       61*   dmh_ptr  -  -  (output)  ptr,  points   to   the   structure   in
       62*   mrds_dm_header.incl.pl1
       63*
       64*   code - - (output) fixed bin(35), error status encoding
       65*
       66**/
       67 
       68 /* HISTORY:
       69*
       70*   Modified by Oris Friesen for new version data  bases  --  October
       71*   1978
       72*
       73*   Modified by Jim Gray - - Feb. 1980, to correctly determine  which
       74*   version  database  data_model_ptr, we were being called with. Old
       75*   versions  will  have  data_mode_ptr  =  to  an  iocb_ptr  in  the
       76*   area_linker,  since  it  is  to  the  data_model  vfile  for that
       77*   version.
       78*
       79*
       80*   81-02-12 Jim Gray  :  changed  so  that  calls  to  the  external
       81*   interface  dmd_$get_header  require  a  DBA  once the database is
       82*   secured.  mrds_dm_get_header  entry  should  only  be  called  by
       83*   internal mrds, and internal mrds should never call the get_header
       84*   entry.
       85*
       86*   81-04-22 Jim Gray : added get_model_info entry for mmi_
       87*
       88*   83-02-18 Davids: Modified get_model_info entry by adding the label
       89*   exit_get_model_info and changing the deeply nested structure to one
       90*   which just goes to the exit increase of an error. Also added code
       91*   for handling version2 structures and for differentiating between
       92*   version 1 and version 2 structures. Added the declaration for version 1
       93*   structures since the include file now has version 2.
       94*
       95*   83-02-24 Davids: changed references to mrds_db_model_info_(V DM)FILE_TYPE
       96*   to mrds_db_model_info_(v dm)file_type, and before_joural in the dmfile_attributes
       97*   substructure of mrds_db_model_info to rollback.
       98*
       99*   83-06-10 Roger Lackey : Added code to force version 3 database to be
      100*   vfile_type database instead of trying to overlay the db_model to determine
      101*   what type it is.
      102*
      103*   83-06-21 Davids: Removed check for old version database and the call
      104*   to v1 code if it was an old version db (old version dbs can no longer
      105*   be opened)
      106**/
      107 
      108 /* BEGIN CHANGE 81-02-12 **************************************** */
      109 
      110 mrds_dm_get_header: proc (data_model_ptr_a, area_ptr_a, dmh_ptr_a, code_a);
      111 
      112 /* for internal mrds use */
      113 
      114 	internal_call = "1"b;
      115 
      116 	data_model_ptr = data_model_ptr_a;
      117 	area_ptr = area_ptr_a;
      118 
      119 	call common ();
      120 
      121 	dmh_ptr_a = dmh_ptr;
      122 	code_a = code;
      123 
      124 	return;
      125 
      126 get_header: entry (data_model_ptr_b, area_ptr_b, dmh_ptr_b, code_b);
      127 
      128 /* for external use only, not by mrds, needs a DBA if db secured */
      129 
      130 	internal_call = "0"b;
      131 
      132 	data_model_ptr = data_model_ptr_b;
      133 	area_ptr = area_ptr_b;
      134 
      135 	call common ();
      136 
      137 	dmh_ptr_b = dmh_ptr;
      138 	code_b = code;
      139 
      140 	return;
      141 
      142 /* END CHANGE 81-02-12 ************************************************* */
      143 
      144 /* BEGIN CHANGE 81-04-22 ************************************** */
      145 
      146 get_model_info: entry (open_name, area_ptr_c, structure_version, mrds_db_model_info_ptr, code_c);
      147 
      148 /* routine to get db creation info for the mmi_ interface.
      149*   It uses the get_header entry to allow secured databases only
      150*   have DBA's use this entry, and to handle old version databases
      151*   in a common manner. */
      152 
      153 /* initialize */
      154 
      155 	code_c = 0;
      156 	mrds_db_model_info_ptr = null ();
      157 
      158 /* get the model pointer from the opening name */
      159 
      160 	call mu_open_name_manager$get_model_pointer (open_name, model_type, model_ptr, code_c);
      161 	if code_c ^= 0
      162 	then goto exit_get_model_info;
      163 
      164 /* get the header info for either an old or new database,
      165*   not allowing a non-dba to mess with a secured database. */
      166 
      167 	call get_header (model_ptr, addr (local_area), dmh_ptr_c, code_c);
      168 	if code_c ^= 0
      169 	then goto exit_get_model_info;
      170 
      171 	dmh_ptr = dmh_ptr_c;
      172 	area_ptr = area_ptr_c;
      173 
      174 /* check the arguments */
      175 
      176 	if area_ptr = null ()
      177 	then do;
      178 		code_c = error_table_$badcall;
      179 		goto exit_get_model_info;
      180 	     end;
      181 
      182 	unspec (my_area_info) = "0"b;
      183 	my_area_info.version = 1;
      184 	my_area_info.areap = area_ptr;
      185 	call area_info_ (addr (my_area_info), code_c);
      186 	if code_c ^= 0
      187 	then goto exit_get_model_info;
      188 
      189 	if my_area_info.no_freeing
      190 	then do;
      191 		code_c = mrds_error_$not_freeing_area;
      192 		goto exit_get_model_info;
      193 	     end;
      194 
      195 	if structure_version ^= 1 & structure_version ^= 2
      196 	then do;
      197 		code_c = error_table_$unimplemented_version;
      198 		goto exit_get_model_info;
      199 	     end;
      200 
      201 /* good arguments, fill in the users structure */
      202 
      203 	on area begin;
      204 		code_c = error_table_$area_too_small;
      205 		goto exit_get_model_info;
      206 	     end;
      207 
      208 	on cleanup begin;
      209 		if mrds_db_model_info_ptr ^= null ()
      210 		then do;
      211 			if structure_version = 1
      212 			then
      213 			     free mrds_db_model_info_ptr -> mrds_db_model_info_1 in (return_area);
      214 			else
      215 			     free mrds_db_model_info_ptr -> mrds_db_model_info in (return_area);
      216 			mrds_db_model_info_ptr = null ();
      217 		     end;
      218 	     end;
      219 
      220 	if structure_version = 1
      221 	then do;
      222 		allocate mrds_db_model_info_1 set (mrds_db_model_info_ptr) in (return_area);
      223 		unspec (mrds_db_model_info_1) = "0"b;
      224 		mrds_db_model_info_1.version = 1;
      225 		mrds_db_model_info_1.model_version = dm_header.dmd_version;
      226 		mrds_db_model_info_1.creator_id = dm_header.creator_id;
      227 		mrds_db_model_info_1.creation_time = dm_header.create_time;
      228 	     end;
      229 	else do;
      230 		if dm_header.dmd_version = 3 then vfile_database_sw = "1"b;
      231 		else vfile_database_sw = model_ptr -> db_model.vfile_type;
      232 
      233 		allocate mrds_db_model_info set (mrds_db_model_info_ptr) in (return_area);
      234 		unspec (mrds_db_model_info) = "0"b;
      235 		mrds_db_model_info.version = 2;
      236 		mrds_db_model_info.model_version = dm_header.dmd_version;
      237 		mrds_db_model_info.creator_id = dm_header.creator_id;
      238 		mrds_db_model_info.creation_time = dm_header.create_time;
      239 		if vfile_database_sw
      240 		then do;
      241 			mrds_db_model_info.db_type = mrds_db_model_info_vfile_type;
      242 			mrds_db_model_info.dmfile_attributes.protected = "0"b;
      243 			mrds_db_model_info.dmfile_attributes.rollback = "0"b;
      244 			mrds_db_model_info.dmfile_attributes.concurrency = "0"b;
      245 		     end;
      246 		else do;
      247 			mrds_db_model_info.db_type = mrds_db_model_info_dmfile_type;
      248 			mrds_db_model_info.dmfile_attributes.protected = model_ptr -> db_model.db_type_flags.transactions_needed;
      249 			mrds_db_model_info.dmfile_attributes.rollback = model_ptr -> db_model.db_type_flags.rollback_on;
      250 			mrds_db_model_info.dmfile_attributes.concurrency = model_ptr -> db_model.db_type_flags.concurrency_on;
      251 		     end;
      252 	     end;
      253 
      254 exit_get_model_info:
      255 	return;
      256 
      257 /* END CHANGE 81-04-22 ************************************************* */
      258 
      259 common: procedure ();
      260 
      261 /* initialize */
      262 
      263 	dmh_ptr = null;
      264 
      265 
      266 	call hcs_$fs_get_path_name (data_model_ptr, db_path, ldn, model_name,
      267 	     code);
      268 	if code = 0 then do;
      269 
      270 		dbm_ptr = data_model_ptr;
      271 
      272 /* check for the user being a DBA, if the database is secured */
      273 
      274 		if ^internal_call then
      275 		     call secured_db_check ();
      276 
      277 		if code = 0 then do;
      278 
      279 /* fill in the database creation information */
      280 
      281 			on cleanup begin;
      282 				if dmh_ptr ^= null () then do;
      283 					free dm_header in (return_area);
      284 					dmh_ptr = null ();
      285 				     end;
      286 			     end;
      287 
      288 			on no_read_permission begin;
      289 				code = mrds_error_$no_model_access;
      290 				dmh_ptr = null ();
      291 				goto exit;
      292 			     end;
      293 
      294 			allocate dm_header in (return_area);
      295 			unspec (dm_header) = "0"b;
      296 
      297 			dm_header.dm_header_id = " "; /* this used to be 'dmd_head' */
      298 			dm_header.dmd_version = db_model.version;
      299 
      300 			changer_ptr = pointer (dbm_ptr, db_model.changer_ptr);
      301 			do while (changer_ptr -> changer.next ^= NULL_OFFSET); /* creator is last on change list */
      302 			     changer_ptr = pointer (dbm_ptr, changer_ptr -> changer.next);
      303 			end;
      304 
      305 			dm_header.creator_id = changer_ptr -> changer.id;
      306 			dm_header.create_time = changer_ptr -> changer.time;
      307 
      308 		     end;
      309 	     end;
      310 exit:
      311 
      312 	return;
      313 
      314      end;
      315 
      316 /* BEGIN CHANGE 81-02-12 ********************************************** */
      317 
      318 secured_db_check: procedure ();
      319 
      320 /* routine to check for the database being is a secured state,
      321*   and if so, that the user is a DBA, and thus may use the external entry */
      322 
      323 	if code ^= 0 then ;
      324 	else if internal_call then ;
      325 	else do;
      326 
      327 /* get the secured state of the dataabase */
      328 
      329 		call mrds_dm_db_secured$get_secured_status (dbm_ptr, addr (local_area),
      330 		     database_state_structure_version, database_state_ptr, code);
      331 		if code ^= 0 then
      332 
      333 		     call sub_err_ (code, caller_name, continue, info_ptr, return_value, "^/^a^a^a",
      334 			"Unable to get the secured state of database """, db_path, """.");
      335 
      336 		else if ^database_state.secured then ;
      337 		else do;
      338 
      339 /* database secured, see if the user is a DBA */
      340 
      341 			call mrds_dm_authorization$get_user_class (rtrim (db_path), addr (local_area),
      342 			     mrds_authorization_structure_version, mrds_authorization_ptr, code);
      343 			if code ^= 0 then
      344 
      345 			     call sub_err_ (code, caller_name, continue, info_ptr, return_value, "^/^a^a^a",
      346 				"Unable to get user class for database """, db_path, """.");
      347 
      348 			else if mrds_authorization.administrator then ;
      349 			else do;
      350 
      351 				code = error_table_$insufficient_access;
      352 
      353 				call sub_err_ (code, caller_name, continue, info_ptr, return_value, "^/^a^a^a ^a",
      354 				     "The database """, db_path, """ has been secured,",
      355 				     "so the caller must be a DBA to use direct model access.");
      356 
      357 			     end;
      358 
      359 		     end;
      360 
      361 	     end;
      362 
      363 	if code ^= 0 then
      364 	     data_model_ptr, dbm_ptr = null ();
      365 
      366      end;
      367 
      368 /* END CHANGE 81-02-12 ************************************************ */
      369 
      370 	declare NULL_OFFSET		 bit (18) init ((18)"1"b);
      371 	declare area		 condition;	/* if area too small */
      372 	declare area_info_		 entry (ptr, fixed bin (35)); /* gets area details */
      373 	declare area_ptr		 ptr;		/* points to area in which informationb is returned */
      374 	declare area_ptr_a		 ptr;		/* temp for mrd_dm_get_header entry */
      375 	declare area_ptr_b		 ptr;		/* temp for get_header entry */
      376 	declare area_ptr_c		 ptr;		/* temp for get_model_info entry */
      377 	declare caller_name		 char (32) init ("dmd_$open_dm"); /* name of calling routine */
      378 	declare cleanup		 condition;
      379 	declare code		 fixed bin (35);	/* status return code */
      380 	declare code_a		 fixed bin (35);	/* temp for mrds_dm_get_header entry */
      381 	declare code_b		 fixed bin (35);	/* temp for get_header entry */
      382 	declare code_c		 fixed bin (35);	/* temp for get_model_info entry */
      383 	declare continue		 char (1) init ("c"); /* dont stop after print mesg */
      384 	declare data_model_ptr	 ptr;		/* points to data model to be searched -- input */
      385 	declare data_model_ptr_a	 ptr;		/* temp for mrds_dm_get_header entry */
      386 	declare data_model_ptr_b	 ptr;		/* temp for get_header_entry */
      387 	declare db_path		 char (168);
      388 	declare dmh_ptr_a		 ptr;		/* temp for mrds_dm_get_header entry */
      389 	declare dmh_ptr_b		 ptr;		/* temp for get_header entry */
      390 	declare dmh_ptr_c		 ptr;		/* temp for get_model_info entry */
      391 	declare error_table_$area_too_small fixed bin (35) ext; /* small area */
      392 	declare error_table_$badcall	 fixed bin (35) ext;/* null area ptr */
      393 	declare error_table_$insufficient_access fixed bin (35) ext; /* not DBA and db secured */
      394 	declare error_table_$unimplemented_version fixed bin (35) ext; /* bad struct version */
      395 	declare hcs_$fs_get_path_name	 entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
      396 	declare info_ptr		 ptr init (null ());/* unused */
      397 	declare internal_call	 bit (1);		/* on => called from mrds, not by dmd_ */
      398 	declare ldn		 fixed bin;
      399 	declare local_area		 area (1024);	/* space for db state, and user class info */
      400 	declare mu_open_name_manager$get_model_pointer entry (char (*), char (1), ptr, fixed bin (35)); /* gets ptr from name */
      401 	declare model_name		 char (32);
      402 	declare model_ptr		 ptr;
      403 	declare model_type		 char (1);	/* type of opening */
      404 	declare mrds_dm_authorization$get_user_class entry (char (*), ptr, fixed bin, ptr, fixed bin (35)); /* finds if DBA */
      405 	declare mrds_dm_db_secured$get_secured_status entry (ptr, ptr, fixed bin, ptr, fixed bin (35)); /* gets secured bit */
      406 	declare mrds_error_$no_model_access fixed bin (35) ext; /* no r acl to model */
      407 	declare mrds_error_$not_freeing_area fixed bin (35) ext; /* no freeing attr on area */
      408 	declare no_read_permission	 condition;	/* no r acl to model */
      409 	declare open_name		 char (*);	/* model opening name */
      410 	declare return_area		 area (sys_info$max_seg_size) based (area_ptr);
      411 	declare return_value	 fixed bin (35) init (0); /* unused */
      412 	declare structure_version	 fixed bin;	/* desired structure version */
      413 	declare sub_err_		 entry options (variable); /* reports errors */
      414 	declare sys_info$max_seg_size	 fixed bin ext;
      415 	declare vfile_database_sw	 bit (1) aligned;
      416 	declare (addr, empty, fixed, rel, null, pointer, rtrim, unspec) builtin;
      417 	declare 1 my_area_info	 like area_info;	/* local copy */
      418 	declare 1 mrds_db_model_info_1 aligned based (mrds_db_model_info_ptr),
      419 						/* version 1 of this structure (now obsolete) */
      420 		2 version		 fixed bin,	/* version number for this structure */
      421 		2 model_version	 fixed bin,	/* the version number of the database model */
      422 		2 creator_id	 char (32),	/* the person.project.tag of the database creator */
      423 		2 creation_time	 fixed bin (71),	/* the convert date to binary form of the database creation time */
      424 		2 mbz		 bit (36) unal;
      425 
  1     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  1     6*     modified to save space occupied by model
  1     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  1     8*     to add mdbm_secured bit in db_model
  1     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  1    10*     collapsed the following into an unused_offset array:
  1    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  1    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  1    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  1    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  1    15*       unused_1
  1    16*     Also changed the name of unused_2 to restructuring_history_offset
  1    17*     and changed the comment on the changer structure to indicate
  1    18*     that it will contain on database creation information.
  1    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  1    20*     used one of the unused_offsets to point to a message which indicates
  1    21*     why the db is inconsistent. The offset will be null when the db is created
  1    22*     and set the first time the message is used. this is so it will be
  1    23*     consistent with existing data bases. Also added the message structure.
  1    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  1    25*     added the undo_request element to the message structure
  1    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  1    27*     changed unused_offset (12) to last_restructruring_history_offset and
  1    28*     changed restructuring_history_offset to first_restructuring_history_offset
  1    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  1    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  1    31*     1 => vfile database and 2 => page_file database. Up to this point all
  1    32*     database types were equal to 1.
  1    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  1    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  1    35*     flags. This will allow information about transactions and dm_file
  1    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  1    37*     change is compatable with all datamodels created by the released version
  1    38*     of mrds.
  1    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  1    40*     added the rollback_on flag to the db_type_flags since it appears that you
  1    41*     can have a dmfile database that requires transactions but does not have any
  1    42*     journalizing. Also switched the order of the transactions_needed and
  1    43*     concurrency_on flags - this makes the change compatable with existing
  1    44*     dmfile databases except when displaying the model since concurrency_on and
  1    45*     rollback_on will be off in the model even though the dmfile relations had
  1    46*     them on during creation.
  1    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  1    48*      Removed ctl_file_path_ptr.
  1    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  1    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  1    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  1    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  1    53*      in the flag word for rmdb copying.
  1    54*                                                   END HISTORY COMMENTS */
  1    55 
  1    56 
  1    57 /* this include file contains the structures that go into the make up
  1    58*   of the "db_model" segment in the model for the database.
  1    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  1    60*
  1    61*   the db_model structure goes at the base of the segment, and contains items unique to
  1    62*   the whole databse. in addition, it has an area of size to fill the
  1    63*   rest of a segment, that holds the lists of files and domains in the database.
  1    64*   these lists are singly forward linked lists. all "pointers" in the database model
  1    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  1    66*   since actual pointers are process dependent on segment number.
  1    67*   the remaining structures are first a path_entry one to save pathnames in,
  1    68*   and the stack_item and constent structures, used to save a boolean
  1    69*   expression in polish form, with the stack represented by a linked list.
  1    70*   the final structure is one for identifying the status of version information */
  1    71 
  1    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  1    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  1    74 	     2 db_type_flags      unal,
  1    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  1    76 	       3 unused	      (13) bit (1) unal,
  1    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  1    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  1    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  1    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  1    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  1    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  1    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  1    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  1    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  1    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  1    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  1    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  1    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  1    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  1    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  1    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  1    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  1    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  1    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  1    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  1    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  1    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  1    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  1   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  1   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  1   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  1   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  1   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  1   105 
  1   106      dcl	   dbm_ptr	      ptr;
  1   107 
  1   108 /* the files in the database each have a file_info containing
  1   109*   their name, the file_model for each file is found by initiating the
  1   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  1   111*   the file_info list is a singly linked list in definition order */
  1   112 
  1   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  1   114 	     2 file_name	      char (30),		/* name of file */
  1   115 	     2 file_id	      bit (36),		/* id number of file */
  1   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  1   117 	     2 unused	      unal bit (18);	/* for future expansion */
  1   118 
  1   119      dcl	   fi_ptr		      ptr;
  1   120 
  1   121 /* each domain used in the database will have a domain info saved in the db_model
  1   122*   segment. it describes the domain of the given name, and it's options.
  1   123*   the domain_info's form a singly linked list in definition order */
  1   124 
  1   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  1   126 	     2 name	      char (32),		/* name of domain */
  1   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  1   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  1   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  1   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  1   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  1   132 	     2 reserved	      bit (31) unal,
  1   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  1   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  1   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  1   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  1   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  1   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  1   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  1   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  1   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  1   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  1   143 	     2 str_err_path_ptr   unal bit (18),
  1   144 	     2 str_after_path_ptr unal bit (18),
  1   145 	     2 get_before_path_ptr unal bit (18),
  1   146 	     2 get_err_path_ptr   unal bit (18),
  1   147 	     2 get_after_path_ptr unal bit (18),
  1   148 	     2 mod_before_path_ptr unal bit (18),
  1   149 	     2 mod_err_path_ptr   unal bit (18),
  1   150 	     2 mod_after_path_ptr unal bit (18),
  1   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  1   152 	     2 unused_2	      unal bit (18),
  1   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  1   154 
  1   155      dcl	   di_ptr		      ptr;
  1   156 
  1   157 /* information necessary for attributes that are not used in any relation */
  1   158 
  1   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  1   160 	     2 name char (32),			/* name of attribute */
  1   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  1   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  1   163 	     2 unused (2) bit (18) unal;
  1   164 
  1   165      dcl     ua_ptr ptr;
  1   166 
  1   167 
  1   168 /* space saving pathname$entryname structure, to be allocated
  1   169*   only when a path$entry has to be saved, else only a bit(18)
  1   170*   offset takes up space in the main model structure */
  1   171 
  1   172      declare 1 path_entry	      based (path_entry_ptr),
  1   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  1   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  1   175 	     2 reserved	      unal bit (36);	/* for future use */
  1   176 
  1   177      declare path_entry_ptr	      ptr;
  1   178 
  1   179 
  1   180 
  1   181 
  1   182 
  1   183 /* declarations for model of postfix stack holding the check option boolean expression
  1   184*   the following encoding values indicate the corresponding type of stack element
  1   185*
  1   186*   1  =
  1   187*   2  ^=
  1   188*   3  >
  1   189*   4  <
  1   190*   5  >=
  1   191*   6  <=
  1   192*
  1   193*   10  and
  1   194*   20  or
  1   195*   30  not
  1   196*
  1   197*   40  - (minus)
  1   198*
  1   199*   50  domain variable(same name as domain)
  1   200*
  1   201*   60  constant(number, bit string, or character string)
  1   202*
  1   203**/
  1   204 
  1   205 
  1   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  1   207 	     2 next	      bit (18),		/* link to next in list */
  1   208 	     2 type	      fixed binary,		/* code for this element type */
  1   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  1   210*						   if this is a constant element type */
  1   211 
  1   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  1   213 
  1   214 
  1   215 
  1   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  1   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  1   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  1   219 
  1   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  1   221 
  1   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  1   223 
  1   224 /* version structure, giving status of source for CMDB/RMDB,
  1   225*   status of model, and status of resultant */
  1   226 
  1   227 /* version number is in form MM.N.Y
  1   228*   where MM is the major version number, N is the minor version alteration,
  1   229*   and Y is the lastest modification to that alteration,
  1   230*   where M and N represent numbers 0-9, and Y is a letter */
  1   231 
  1   232      declare 1 version_status	      unal based (version_status_ptr),
  1   233 	     2 cmdb_rmdb,
  1   234 	       3 major	      fixed bin,
  1   235 	       3 minor	      fixed bin,
  1   236 	       3 modification     char (4),
  1   237 	     2 model,
  1   238 	       3 major	      fixed bin,
  1   239 	       3 minor	      fixed bin,
  1   240 	       3 modification     char (4),
  1   241 	     2 resultant,
  1   242 	       3 major	      fixed bin,
  1   243 	       3 minor	      fixed bin,
  1   244 	       3 modification     char (4);
  1   245 
  1   246      declare version_status_ptr     ptr;
  1   247 
  1   248 
  1   249 /* maintains information only about the db creation */
  1   250 
  1   251      declare 1 changer	      unal based (changer_ptr),
  1   252 	     2 id		      char (32),
  1   253 	     2 time	      fixed bin (71),
  1   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  1   255 
  1   256      declare changer_ptr	      ptr;
  1   257 
  1   258 
  1   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  1   260 	     02 len	      fixed bin,		/* length of the message */
  1   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  1   262 	     02 name	      char (32),		/* name of thing that set the message */
  1   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  1   264*                                                               that caused the database to become inconsistent */
  1   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  1   266 
  1   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  1   268 
  1   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  1   270 
  1   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  1   272 
  1   273 
      426 
      427 
  2     1 /*	BEGIN INCLUDE FILE		mrds_dm_header.incl.pl1
  2     2*
  2     3*   Created October, 1975 for release in MR 4.0
  2     4*   Modified December, 1975 to provide more info.					*/
  2     5 
  2     6 dcl 1 dm_header based (dmh_ptr),			/* data model header */
  2     7     2 dm_header_id char (8),				/* identification as data model header */
  2     8     2 dmd_version fixed bin,				/* version number of dmd_ creating this model */
  2     9     2 creator_id char (32),				/* group id of creator */
  2    10     2 create_time fixed bin (71);			/* time of creation */
  2    11 
  2    12 dcl  dmh_ptr ptr;
  2    13 
  2    14 /*	END INCLUDE FILE		mrds_dm_header.incl.pl1				*/
  2    15 
      428 
      429 
  3     1 /* BEGIN INCLUDE FILE mrds_authorization.incl.pl1 - - 81-01-20 Jim Gray */
  3     2 
  3     3 /* HISTORY:
  3     4*
  3     5*   81-01-20 Jim Gray : original created for the mmi_$get_authorization interface
  3     6*
  3     7**/
  3     8 
  3     9 /* DESCRIPTION:
  3    10*
  3    11*   this structure returns the callers user_class
  3    12*   either database administrator or normal user.
  3    13*   Note that these separate classes were used to allow
  3    14*   future expansion to the user classes, rather than
  3    15*   make them logical "not"'s of one another.
  3    16*   NOTE: a DBA is always also a normal user, thus if the caller
  3    17*   is a DBA, his normal_user bit will be on also.
  3    18*
  3    19**/
  3    20 
  3    21 
  3    22 declare 1 mrds_authorization aligned based (mrds_authorization_ptr),
  3    23         2 version fixed bin,				/* version number of this structure */
  3    24         2 administrator bit (1) unal,			/* caller is a DBA */
  3    25         2 normal_user bit (1) unal,			/* caller has no special priviledges */
  3    26         2 mbz bit (34) unal ;
  3    27 
  3    28 
  3    29 declare  mrds_authorization_ptr ptr ;			/* pointer for referring to the structure */
  3    30 
  3    31 declare  mrds_authorization_structure_version fixed bin init (1) int static options (constant) ;
  3    32 
  3    33 /* END INCLUDE FILE mrds_authorization.incl.pl1 */
      430 
      431 
  4     1 /* BEGIN INCLUDE FILE mrds_database_state.incl.pl1 - - 81-01-20 Jim Gray */
  4     2 
  4     3 /* HISTORY:
  4     4*
  4     5*   81-01-20 Jim Gray : original created for the mmi_$get_secured_status interface
  4     6*
  4     7**/
  4     8 
  4     9 /* DESCRIPTION:
  4    10*
  4    11*   This structure returns the database state (secured or unsecured)
  4    12*   for determining how commands and subroutines will behave for each case.
  4    13*   The secured bit was kept separate from the unsecured,
  4    14*   rather than it's logical "not", to allow for future extensibility
  4    15*   of database secured states.
  4    16*
  4    17**/
  4    18 
  4    19 
  4    20 declare 1 database_state aligned based (database_state_ptr),
  4    21         2 version fixed bin,				/* version number of this structure */
  4    22         2 unsecured bit (1) unal,			/* database not secured */
  4    23         2 secured bit (1) unal,			/* database has been secured */
  4    24         2 mbz bit (34) unal ;
  4    25 
  4    26 
  4    27 declare  database_state_ptr ptr ;			/* pointer for referring to the structure */
  4    28 
  4    29 declare  database_state_structure_version fixed bin init (1) int static options (constant) ;
  4    30 
  4    31 /* END INCLUDE FILE mrds_database_state.incl.pl1 */
      432 
      433 
  5     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  5     2 
  5     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  5     4 
  5     5 dcl  area_infop ptr;
  5     6 
  5     7 dcl 1 area_info aligned based (area_infop),
  5     8     2 version fixed bin,				/* version number for this structure is 1 */
  5     9     2 control aligned like area_control,		/* control bits for the area */
  5    10     2 owner char (32) unal,				/* creator of the area */
  5    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  5    12     2 size fixed bin (18),				/* size of the area in words */
  5    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  5    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  5    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  5    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  5    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  5    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  5    19 
  5    20 dcl 1 area_control aligned based,
  5    21     2 extend bit (1) unal,				/* says area is extensible */
  5    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  5    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  5    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  5    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  5    26     2 system bit (1) unal,				/* says area is managed by system */
  5    27     2 pad bit (30) unal;
  5    28 
  5    29 /* END INCLUDE FILE area_info.incl.pl1 */
      434 
      435 
  6     1 /* BEGIN INCLUDE FILE mrds_db_model_info.incl.pl1 - - Jim Gray 81-01-28 */
  6     2 
  6     3 /* HISTORY:
  6     4*
  6     5*   81-01-28 Jim Gray : originally created for the mmi_$get_model_info interface.
  6     6*
  6     7*   83-02-18 Davids: added db_type and dmfile_attributes substructure. Also
  6     8*   the constants mrds_db_model_info_VFILE_TYPE and DMFILE_TYPE. Changed version
  6     9*   value to 2 from 1.
  6    10*
  6    11*   83-02-24 Davids: renamed the before_journal element of the dmfile_attributes
  6    12*   substructure to rollback. and changed the VFILE_TYPE and DMFILE_TYPE to
  6    13*   vfile_type and dmfile_file
  6    14**/
  6    15 
  6    16 /* DESCRIPTION:
  6    17*
  6    18*   This structure passes back information common to the whole database,
  6    19*   rather than that pertaining to a particular relation or attribute.
  6    20*   It refers to the database model, rather than to some submodel for that model.
  6    21*   This structure is to be used externally, not internal to MRDS.
  6    22*
  6    23**/
  6    24 
  6    25 
  6    26 declare 1 mrds_db_model_info aligned based (mrds_db_model_info_ptr),
  6    27         2 version fixed bin,				/* version number for this structure */
  6    28         2 model_version fixed bin,			/* the version number of the database model */
  6    29         2 db_type fixed bin,                                /* type of database, vfile or dmfile */
  6    30         2 dmfile_attributes,
  6    31           3 protected bit (1) unal,                         /* "1"b implies that transactions must be used */
  6    32           3 rollback  bit (1) unal,                         /* "1"b implies that it is possible to rollback a transaction */
  6    33           3 concurrency bit (1) unal,                       /* "1"b implies concurrency locks will be used */
  6    34           3 mbz bit (33) unal, 
  6    35         2 creator_id char (32),			/* the person.project.tag of the database creator */
  6    36         2 creation_time fixed bin (71);                     /* the convert date to binary form of the database creation time */
  6    37 
  6    38 declare  mrds_db_model_info_ptr ptr ;
  6    39 
  6    40 declare  mrds_db_model_info_structure_version fixed bin int static options (constant) init (2) ;
  6    41 
  6    42 declare   mrds_db_model_info_vfile_type fixed bin int static options (constant) init (1);
  6    43 
  6    44 declare   mrds_db_model_info_dmfile_type fixed bin int static options (constant) init (2);
  6    45 
  6    46 
  6    47 /* END INCLUDE FILE mrds_db_model_info.incl.pl1 */
      436 
      437 
      438      end mrds_dm_get_header;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/16/86  1145.0  mrds_dm_get_header.pl1            >special_ldd>install>MR12.0-1187>mrds_dm_get_header.pl1
426          1    10/16/86  1139.3  mdbm_db_model.incl.pl1            >special_ldd>install>MR12.0-1187>mdbm_db_model.incl.pl1
428          2    10/14/83  1608.6  mrds_dm_header.incl.pl1           >ldd>include>mrds_dm_header.incl.pl1
430          3    10/14/83  1608.8  mrds_authorization.incl.pl1       >ldd>include>mrds_authorization.incl.pl1
432          4    10/14/83  1608.8  mrds_database_state.incl.pl1      >ldd>include>mrds_database_state.incl.pl1
434          5    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
436          6    10/14/83  1609.1  mrds_db_model_info.incl.pl1       >ldd>include>mrds_db_model_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
NULL_OFFSET                     000100 automatic       bit(18)                  initial unaligned dcl 370 set ref 301 370*
addr                                                   builtin function         dcl 416 ref 167 167 185 185 329 329 341 341
administrator             1            based           bit(1)                   level 2 packed unaligned dcl 3-22 ref 348
area                            000102 stack reference condition                dcl 371 ref 203
area_control                           based           structure                level 1 dcl 5-20
area_info                              based           structure                level 1 dcl 5-7
area_info_                      000010 constant        entry                    external dcl 372 ref 185
area_ptr                        000110 automatic       pointer                  dcl 373 set ref 117* 133* 172* 176 184 211 214 222
                                                                                  233 283 294
area_ptr_a                             parameter       pointer                  dcl 374 ref 110 117
area_ptr_b                             parameter       pointer                  dcl 375 ref 126 133
area_ptr_c                             parameter       pointer                  dcl 376 ref 146 172
areap                    16     002232 automatic       pointer                  level 2 dcl 417 set ref 184*
caller_name                     000112 automatic       char(32)                 initial unaligned dcl 377 set ref 331* 343* 353*
                                                                                  377*
changer                                based           structure                level 1 packed unaligned dcl 1-251
changer_ptr                     002260 automatic       pointer                  dcl 1-256 in procedure "mrds_dm_get_header" set ref
                                                                                  300* 301 302* 302 305 306
changer_ptr              32(18)        based           bit(18)                  level 2 in structure "db_model" packed unaligned
                                                                                  dcl 1-72 in procedure "mrds_dm_get_header" ref 300
cleanup                         000122 stack reference condition                dcl 378 ref 208 281
code                            000130 automatic       fixed bin(35,0)          dcl 379 set ref 122 138 266* 268 277 289* 323 329*
                                                                                  331 331* 341* 343 343* 351* 353* 363
code_a                                 parameter       fixed bin(35,0)          dcl 380 set ref 110 122*
code_b                                 parameter       fixed bin(35,0)          dcl 381 set ref 126 138*
code_c                                 parameter       fixed bin(35,0)          dcl 382 set ref 146 155* 160* 161 167* 168 178* 185*
                                                                                  186 191* 197* 204*
concurrency               3(02)        based           bit(1)                   level 3 packed unaligned dcl 6-26 set ref 244* 250*
concurrency_on            0(33)        based           bit(1)                   level 3 packed unaligned dcl 1-72 ref 250
continue                        000131 automatic       char(1)                  initial unaligned dcl 383 set ref 331* 343* 353*
                                                                                  383*
control                   1     002232 automatic       structure                level 2 dcl 417
create_time              14            based           fixed bin(71,0)          level 2 dcl 2-6 set ref 227 238 306*
creation_time            12            based           fixed bin(71,0)          level 2 in structure "mrds_db_model_info_1" dcl 418
                                                                                  in procedure "mrds_dm_get_header" set ref 227*
creation_time            14            based           fixed bin(71,0)          level 2 in structure "mrds_db_model_info" dcl 6-26
                                                                                  in procedure "mrds_dm_get_header" set ref 238*
creator_id                3            based           char(32)                 level 2 in structure "dm_header" packed unaligned
                                                                                  dcl 2-6 in procedure "mrds_dm_get_header" set ref
                                                                                  226 237 305*
creator_id                2            based           char(32)                 level 2 in structure "mrds_db_model_info_1" dcl 418
                                                                                  in procedure "mrds_dm_get_header" set ref 226*
creator_id                4            based           char(32)                 level 2 in structure "mrds_db_model_info" dcl 6-26
                                                                                  in procedure "mrds_dm_get_header" set ref 237*
data_model_ptr                  000132 automatic       pointer                  dcl 384 set ref 116* 132* 266* 270 363*
data_model_ptr_a                       parameter       pointer                  dcl 385 ref 110 116
data_model_ptr_b                       parameter       pointer                  dcl 386 ref 126 132
database_state                         based           structure                level 1 dcl 4-20
database_state_ptr              002266 automatic       pointer                  dcl 4-27 set ref 329* 336
database_state_structure_version
                                000021 constant        fixed bin(17,0)          initial dcl 4-29 set ref 329*
db_model                               based           structure                level 1 dcl 1-72
db_path                         000134 automatic       char(168)                unaligned dcl 387 set ref 266* 331* 341 341 343*
                                                                                  353*
db_type                   2            based           fixed bin(17,0)          level 2 dcl 6-26 set ref 241* 247*
db_type_flags             0(18)        based           structure                level 2 packed unaligned dcl 1-72
dbm_ptr                         002256 automatic       pointer                  dcl 1-106 set ref 270* 298 300 300 302 329* 363*
dm_header                              based           structure                level 1 unaligned dcl 2-6 set ref 283 294 295*
dm_header_id                           based           char(8)                  level 2 packed unaligned dcl 2-6 set ref 297*
dmd_version               2            based           fixed bin(17,0)          level 2 dcl 2-6 set ref 225 230 236 298*
dmfile_attributes         3            based           structure                level 2 dcl 6-26
dmh_ptr                         002262 automatic       pointer                  dcl 2-12 set ref 121 137 171* 225 226 227 230 236
                                                                                  237 238 263* 282 283 284* 290* 294* 295 297 298
                                                                                  305 306
dmh_ptr_a                              parameter       pointer                  dcl 388 set ref 110 121*
dmh_ptr_b                              parameter       pointer                  dcl 389 set ref 126 137*
dmh_ptr_c                       000206 automatic       pointer                  dcl 390 set ref 167* 171
empty                                                  builtin function         dcl 416 ref 399
error_table_$area_too_small     000012 external static fixed bin(35,0)          dcl 391 ref 204
error_table_$badcall            000014 external static fixed bin(35,0)          dcl 392 ref 178
error_table_$insufficient_access
                                000016 external static fixed bin(35,0)          dcl 393 ref 351
error_table_$unimplemented_version
                                000020 external static fixed bin(35,0)          dcl 394 ref 197
hcs_$fs_get_path_name           000022 constant        entry                    external dcl 395 ref 266
id                                     based           char(32)                 level 2 packed unaligned dcl 1-251 ref 305
info_ptr                        000210 automatic       pointer                  initial dcl 396 set ref 331* 343* 353* 396*
internal_call                   000212 automatic       bit(1)                   unaligned dcl 397 set ref 114* 130* 274 324
ldn                             000213 automatic       fixed bin(17,0)          dcl 398 set ref 266*
local_area                      000214 automatic       area(1024)               dcl 399 set ref 167 167 329 329 341 341 399*
model_name                      002214 automatic       char(32)                 unaligned dcl 401 set ref 266*
model_ptr                       002224 automatic       pointer                  dcl 402 set ref 160* 167* 231 248 249 250
model_type                      002226 automatic       char(1)                  unaligned dcl 403 set ref 160*
model_version             1            based           fixed bin(17,0)          level 2 in structure "mrds_db_model_info_1" dcl 418
                                                                                  in procedure "mrds_dm_get_header" set ref 225*
model_version             1            based           fixed bin(17,0)          level 2 in structure "mrds_db_model_info" dcl 6-26
                                                                                  in procedure "mrds_dm_get_header" set ref 236*
mrds_authorization                     based           structure                level 1 dcl 3-22
mrds_authorization_ptr          002264 automatic       pointer                  dcl 3-29 set ref 341* 348
mrds_authorization_structure_version
                                000021 constant        fixed bin(17,0)          initial dcl 3-31 set ref 341*
mrds_db_model_info                     based           structure                level 1 dcl 6-26 set ref 214 233 234*
mrds_db_model_info_1                   based           structure                level 1 dcl 418 set ref 211 222 223*
mrds_db_model_info_dmfile_type         constant        fixed bin(17,0)          initial dcl 6-44 ref 247
mrds_db_model_info_ptr                 parameter       pointer                  dcl 6-38 set ref 146 156* 209 211 214 216* 222* 223
                                                                                  224 225 226 227 233* 234 235 236 237 238 241 242
                                                                                  243 244 247 248 249 250
mrds_db_model_info_vfile_type          constant        fixed bin(17,0)          initial dcl 6-42 ref 241
mrds_dm_authorization$get_user_class
                                000026 constant        entry                    external dcl 404 ref 341
mrds_dm_db_secured$get_secured_status
                                000030 constant        entry                    external dcl 405 ref 329
mrds_error_$no_model_access     000032 external static fixed bin(35,0)          dcl 406 ref 289
mrds_error_$not_freeing_area    000034 external static fixed bin(35,0)          dcl 407 ref 191
mu_open_name_manager$get_model_pointer
                                000024 constant        entry                    external dcl 400 ref 160
my_area_info                    002232 automatic       structure                level 1 unaligned dcl 417 set ref 182* 185 185
next                     12            based           bit(18)                  level 2 packed unaligned dcl 1-251 ref 301 302
no_freeing                1(04) 002232 automatic       bit(1)                   level 3 packed unaligned dcl 417 set ref 189
no_read_permission              000000 stack reference condition                dcl 408 ref 288
null                                                   builtin function         dcl 416 ref 156 176 209 216 263 282 284 290 363 396
open_name                              parameter       char                     unaligned dcl 409 set ref 146 160*
pointer                                                builtin function         dcl 416 ref 300 302
protected                 3            based           bit(1)                   level 3 packed unaligned dcl 6-26 set ref 242* 248*
return_area                            based           area                     dcl 410 ref 211 214 222 233 283 294
return_value                    002227 automatic       fixed bin(35,0)          initial dcl 411 set ref 331* 343* 353* 411*
rollback                  3(01)        based           bit(1)                   level 3 packed unaligned dcl 6-26 set ref 243* 249*
rollback_on               0(32)        based           bit(1)                   level 3 packed unaligned dcl 1-72 ref 249
rtrim                                                  builtin function         dcl 416 ref 341 341
secured                   1(01)        based           bit(1)                   level 2 packed unaligned dcl 4-20 ref 336
structure_version                      parameter       fixed bin(17,0)          dcl 412 ref 146 195 195 211 220
sub_err_                        000036 constant        entry                    external dcl 413 ref 331 343 353
time                     10            based           fixed bin(71,0)          level 2 packed unaligned dcl 1-251 ref 306
transactions_needed       0(34)        based           bit(1)                   level 3 packed unaligned dcl 1-72 ref 248
unspec                                                 builtin function         dcl 416 set ref 182* 223* 234* 295*
version                         002232 automatic       fixed bin(17,0)          level 2 in structure "my_area_info" dcl 417
                                                                                  in procedure "mrds_dm_get_header" set ref 183*
version                                based           fixed bin(17,0)          level 2 in structure "mrds_db_model_info_1" dcl 418
                                                                                  in procedure "mrds_dm_get_header" set ref 224*
version                                based           fixed bin(17,0)          level 2 in structure "db_model" packed unaligned
                                                                                  dcl 1-72 in procedure "mrds_dm_get_header" ref 298
version                                based           fixed bin(17,0)          level 2 in structure "mrds_db_model_info" dcl 6-26
                                                                                  in procedure "mrds_dm_get_header" set ref 235*
vfile_database_sw               002230 automatic       bit(1)                   dcl 415 set ref 230* 231* 239
vfile_type                0(35)        based           bit(1)                   level 3 packed unaligned dcl 1-72 ref 231

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
alloc_length                           internal static fixed bin(35,0)          dcl 1-222
area_info_version_1                    internal static fixed bin(17,0)          initial dcl 5-3
area_infop                             automatic       pointer                  dcl 5-5
constant                               based           structure                level 1 unaligned dcl 1-216
constant_ptr                           automatic       pointer                  dcl 1-220
di_ptr                                 automatic       pointer                  dcl 1-155
domain_info                            based           structure                level 1 dcl 1-125
fi_ptr                                 automatic       pointer                  dcl 1-119
file_info                              based           structure                level 1 dcl 1-113
fixed                                                  builtin function         dcl 416
message_str                            based           structure                level 1 packed unaligned dcl 1-259
message_str_len                        automatic       fixed bin(17,0)          dcl 1-269
message_str_ptr                        automatic       pointer                  dcl 1-267
mrds_db_model_info_structure_version   internal static fixed bin(17,0)          initial dcl 6-40
path_entry                             based           structure                level 1 packed unaligned dcl 1-172
path_entry_ptr                         automatic       pointer                  dcl 1-177
rel                                                    builtin function         dcl 416
stack_item                             based           structure                level 1 unaligned dcl 1-206
stack_item_ptr                         automatic       pointer                  dcl 1-212
sys_info$max_seg_size                  external static fixed bin(17,0)          dcl 414
ua_ptr                                 automatic       pointer                  dcl 1-165
unreferenced_attribute                 based           structure                level 1 dcl 1-159
version_status                         based           structure                level 1 packed unaligned dcl 1-232
version_status_ptr                     automatic       pointer                  dcl 1-246

NAMES DECLARED BY EXPLICIT CONTEXT.
common                          000617 constant        entry                    internal dcl 259 ref 119 135
exit                            001024 constant        label                    dcl 310 ref 291
exit_get_model_info             000615 constant        label                    dcl 254 ref 161 168 179 186 192 198 205
get_header                      000202 constant        entry                    external dcl 126 ref 167
get_model_info                  000237 constant        entry                    external dcl 146
mrds_dm_get_header              000147 constant        entry                    external dcl 110
secured_db_check                001025 constant        entry                    internal dcl 318 ref 274

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1706        1746    1422        1716
Length      2302    1422        40         317     263           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_dm_get_header                 1230 external procedure  is an external procedure.  
on unit on line 203                  64 on unit               
on unit on line 208                  64 on unit               
common                              224 internal procedure  enables or reverts conditions.  
on unit on line 281                  64 on unit               
on unit on line 288                  64 on unit               
secured_db_check                        internal procedure  shares stack frame of internal procedure common.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_dm_get_header       000100 NULL_OFFSET                 mrds_dm_get_header
                         000110 area_ptr                    mrds_dm_get_header
                         000112 caller_name                 mrds_dm_get_header
                         000130 code                        mrds_dm_get_header
                         000131 continue                    mrds_dm_get_header
                         000132 data_model_ptr              mrds_dm_get_header
                         000134 db_path                     mrds_dm_get_header
                         000206 dmh_ptr_c                   mrds_dm_get_header
                         000210 info_ptr                    mrds_dm_get_header
                         000212 internal_call               mrds_dm_get_header
                         000213 ldn                         mrds_dm_get_header
                         000214 local_area                  mrds_dm_get_header
                         002214 model_name                  mrds_dm_get_header
                         002224 model_ptr                   mrds_dm_get_header
                         002226 model_type                  mrds_dm_get_header
                         002227 return_value                mrds_dm_get_header
                         002230 vfile_database_sw           mrds_dm_get_header
                         002232 my_area_info                mrds_dm_get_header
                         002256 dbm_ptr                     mrds_dm_get_header
                         002260 changer_ptr                 mrds_dm_get_header
                         002262 dmh_ptr                     mrds_dm_get_header
                         002264 mrds_authorization_ptr      mrds_dm_get_header
                         002266 database_state_ptr          mrds_dm_get_header

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_in         call_ext_out_desc   call_ext_out        call_int_this       return_mac
tra_ext_1           enable_op           shorten_stack       ext_entry           ext_entry_desc      int_entry
op_alloc_           op_freen_           op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
area_info_                    hcs_$fs_get_path_name         mrds_dm_authorization$get_user_class
mrds_dm_db_secured$get_secured_status                       mu_open_name_manager$get_model_pointer
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$area_too_small   error_table_$badcall          error_table_$insufficient_access
error_table_$unimplemented_version                          mrds_error_$no_model_access   mrds_error_$not_freeing_area




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    370 000123       377 000125       383 000130       396 000132       399 000134       411 000137       110 000142
    114 000155       116 000157       117 000163       119 000166       121 000172       122 000175       124 000177
    126 000200       130 000210       132 000211       133 000215       135 000220       137 000224       138 000227
    140 000231       146 000232       155 000253       156 000255       160 000257       161 000305       167 000310
    168 000326       171 000331       172 000333       176 000336       178 000342       179 000345       182 000346
    183 000351       184 000353       185 000354       186 000367       189 000372       191 000375       192 000400
    195 000401       197 000406       198 000411       203 000412       204 000426       205 000432       208 000435
    209 000451       211 000457       214 000465       216 000467       218 000473       220 000474       222 000500
    223 000506       224 000511       225 000513       226 000516       227 000521       228 000523       230 000524
    231 000533       233 000536       234 000544       235 000547       236 000551       237 000554       238 000557
    239 000561       241 000563       242 000565       243 000567       244 000571       245 000573       247 000574
    248 000576       249 000603       250 000610       254 000615       259 000616       263 000624       266 000627
    268 000657       270 000662       274 000664       277 000667       281 000672       282 000706       283 000714
    284 000716       286 000722       288 000723       289 000737       290 000743       291 000745       294 000750
    295 000757       297 000762       298 000765       300 000770       301 000776       302 001006       303 001011
    305 001012       306 001016       310 001024       318 001025       323 001026       324 001032       329 001035
    331 001056       336 001141       341 001146       343 001220       348 001304       351 001311       353 001314
    363 001410       366 001416


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
