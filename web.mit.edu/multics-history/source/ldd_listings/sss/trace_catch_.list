ASSEMBLY LISTING OF SEGMENT >udd>sm>ds>w>ml>trace_catch_.alm                                                                                                                                        
ASSEMBLED ON:	04/18/00  1154.7 mdt Tue
OPTIONS USED:	list symbols 
ASSEMBLED BY:	ALM Version 8.14 March 1989     
ASSEMBLER CREATED:	06/09/89  1102.3 mdt Fri

                                     1  " ***********************************************************
                                     2  " *                                                         *
                                     3  " * Copyright, (C) Honeywell Information Systems Inc., 1983 *
                                     4  " *                                                         *
                                     5  " ***********************************************************
                                     6  
                                     7  " Program to trace procedure calls
                                     8  "
                                     9  " Barry L. Wolman, 2 January 1970
                                    10  " Modified: 18 June 1971 by BLW for Version II pl1
                                    11  " Modified: 30 May 1972 by BLW to use per/process info procedure instead of usage_values
                                    12  " Modified: 2 March 1973 by BLW for 6180
                                    13  " Modified: 16 May 1974 by BLW for change in setting up cleanup handler
                                    14  " Modified: 2 January 1974 by Richard A. Barnes to fix up many bugs
                                    15  " Modified: 7 May 1975 by RAB for new pl1_operators_ interface
                                    16  " Modified: 6 December 1975 by RAB to fix bugs in TRACE_CATCH_CLEANUP and update_stats
                                    17  " Modified: 20 September 1977 by PCK to use a temporary segment for trace_storage.
                                    18  " Modified: Autumn 1978 by R.E. Mullen for dynamic tracelist
                                    19  " Modified: 28 July 1981 by Jeffrey D. Ives, fix returns (*), cleanup trace_catch_$in_trace.
                                    20  " Modified: 01 Apr 1982 by Jeffrey D. Ives, add trace_catch_$switch for efficiency.
                                    21  " Rewritten: 23 June 1983 by Jeffrey D. Ives, multitasking, accurate metering, and macros.
                                    22  " Modified: May 1984 by Jeffrey D. Ives, for new trace_tab, parameters, global_parameters.
                                    23  
    000000                          24  	name	trace_catch_
                                    25  
                                    26  
                                    27  " This is the first reference trap code for trace_catch_.  It snaps these
                                    28  " links so that the linker will not run and invoke trace_catch_ while
                                    29  " trace_catch_ itself is running.
                                    30  
                        000000      31  	entry	initialize
    000000                          32  initialize:
    000000  4a  4 00352 6331 20     33  	rccl	sys_info$clock_,*
    000001  4a  4 00354 3715 20     34  	epp5	cpu_time_and_paging_op_$cpu_time_and_paging_op_
    000002  4a  4 00356 3715 20     35  	epp5	trace_catch_$trace_catcher_
    000003  4a  4 00360 3715 20     36  	epp5	trace_catch_$TRACE_CATCH_CLEANUP
                                    37  
    000004  4a  4 00362 3715 20     38  	epp5	pl1_operators_$operator_table
    000005  4a  4 00364 3715 20     39  	epp5	operator_pointers_$operator_pointers_
    000006  4a  4 00366 3715 20     40  	epp5	pl1_operators_$alm_entry
    000007  4a  4 00370 3715 20     41  	epp5	pl1_operators_$trace_operator_table
    000010  4a  4 00372 3715 20     42  	epp5	trace_operator_pointers_$trace_operator_pointers_
    000011  4a  4 00374 3715 20     43  	epp5	pl1_operators_$trace_alm_entry
                                    44  
                                    45  " Remember these entrypoints because they are very special.
                                    46  
    000012  4a  4 00376 3715 20     47  	epp5	trace_transactions_$transaction_begin
    000013  9a  4 00010 5451 00     48  	sprp5	pr4|TRANSACTION_BEGIN
    000014  4a  4 00400 3715 20     49  	epp5	trace_transactions_$transaction_begin_force
    000015  9a  4 00011 5451 00     50  	sprp5	pr4|TRANSACTION_BEGIN_FORCE
    000016  4a  4 00402 3715 20     51  	epp5	signal_$signal_
    000017  9a  4 00012 5451 00     52  	sprp5	pr4|SIGNAL_
    000020  4a  4 00404 3715 20     53  	epp5	signal_$io_signal
    000021  9a  4 00013 5451 00     54  	sprp5	pr4|IO_SIGNAL
    000022  aa  7 00044 7101 20     55  	short_return
                                    56  
                                    57  " STACK FRAME DATA   STACK FRAME DATA   STACK FRAME DATA   STACK FRAME DATA
                                    58  
                                    59  " Do not put anything ahead of ptr_registers_saved unless it is mod16 in length.
                                    60  
                                    61  	temp8	registers_saved
                                    62  	temp8	ptr_registers_saved(2)	" This must be on a mod16 boundary!
                                    63  
                                    64  	tempd	arg_list.header
                                    65  	tempd	arg_list.first_arg_ptr
                                    66  	tempd	arg_list.second_arg_ptr
                                    67  	tempd	arg_list.third_arg_ptr
                                    68  
                                    69  	tempd	event(8)
                                    70  	tempd	cleanup_unit(3)
                                    71  	tempd	trace_frames_saved
                                    72  
                                    73  	tempd	global_start.real_time	" These three MUST be kept together.
                                    74  	tempd	global_start.vcpu_time
                                    75  	temp	global_start.page_faults
                                    76  
                                    77  	temp	indicators_saved
                                    78  	temp	watch_values_changed
                                    79  	temp	stack_frame_end(0)		" For checking stack_frame_size.
                                    80  
                        000160      81  	equ	stack_frame_size,112	" Trace_catch_ pushes this size frame.
                                    82  
                                    83  " MACRO DEFINITIONS   MACRO DEFINITIONS   MACRO DEFINITIONS   MACRO DEFINITIONS
                                    84  
                                    85  
                                    86  	macro	get_pr4
                              1     87  	epaq	*
                              2     88  	lprp4	pr7|stack_header.lot_ptr,*au
                              3     89  	&end
                                    90  
                                    91  
                                    92  
                                    93  
                                    94  	macro	read_the_calendar_clock	<pr4|&1 like meters aligned>
                              1     95  	rccl	sys_info$clock_,*
                              2     96  	staq	pr4|&1+meters.real_time
                              3     97  	&end
                                    98  
                                    99  
                                   100  
                                   101  
                                   102  	macro	read_vcpu_time_and_page_faults <pr4|&1 like meters aligned>
                              1    103  
                              2    104  	stcd	pr6|stack_frame.return_ptr
                              3    105  	call6	cpu_time_and_paging_op_$cpu_time_and_paging_op_
                              4    106  
                              5    107  	epbp7	pr6|0
                              6    108  	epp4	pr6|stack_frame.lp_ptr,*
                              7    109  	staq	pr4|&1+meters.vcpu_time   " Vcpu time is returned in AQ register.
                              8    110  	stx0	pr4|&1+meters.page_faults " Page faults are returned in X0 and X1.
                              9    111  	sxl1	pr4|&1+meters.page_faults
                             10    112  	&end
                                   113  
                                   114  "		  A FEW WORDS ON THE METERING METHOD
                                   115  
                                   116  " The trace facility meters real time, virtual CPU time, and page faults.
                                   117  " Trace_catch_ reads the real time clock and usage meters as soon as possible
                                   118  " when it gets control and as late as possible when it relinquishes control.
                                   119  " This minimizes the effect of the overhead tracing overhead that is metered.
                                   120  " The remaining inaccuracy is reduced by a set of compensation values.
                                   121  
                                   122  " There are four kinds of intervals during which an entrypoint can collect
                                   123  " meters:
                                   124  
                                   125  "      1. from the time it is entered until control enters another
                                   126  "      2. from the time it is entered until it returns
                                   127  "      3. from the time it is returned to until it enters another
                                   128  "      4. from the time it is returned to until it returns
                                   129  
                                   130  " When control leaves trace_catch_, the meters are always saved in
                                   131  " trace_catch_$start.  When control comes back, they are saved in
                                   132  " trace_catch_$stop.  The difference between start and stop is accumulated in
                                   133  " the trace_catch_ frame associated with the procedure that relinquished
                                   134  " control.  Eventually, when that frame is popped or unwound, the accumulated
                                   135  " meters are added to the tab for that procedure.  At that time, they are also
                                   136  " added to trace_catch_$metered which accumulates all metered quantities and
                                   137  " is always equal the sum of the meters in the tabs and trace_catch_$removed,
                                   138  " which accumulates the meters of entrypoints that are removed from the trace
                                   139  " table.
                                   140  
                                   141  " The meters described in the previous paragraph are called frame meters and
                                   142  " represent the usage of a procedure without including the usage of any traced
                                   143  " procedures it calls.  Global meters represent the usage from the time a
                                   144  " procedure is called until it returns.  However, if it calls itself, it
                                   145  " should not be double metered.  When an entrypoint is called, the values in
                                   146  " trace_catch_$metered are saved in its trace_catch_ frame in the variable
                                   147  " global_start.  When it finally returns (or is unwound) the difference
                                   148  " between the current value of tc_$metered and global_start is added to
                                   149  " tab.global, which accumulates the entrypoint's global meters.
                                   150  
                                   151  " The user may wish to see the meters or remove entrypoints from the trace
                                   152  " table while trace_catch_ frames are still on the stack.  Therefore, at the
                                   153  " beginning of each trace command, there is a call to
                                   154  " trace_catch_$stop_tracing.  This routine yanks the trace operator pointers
                                   155  " and walks the stack of trace_catch_ frames, flushing the accumulated frame
                                   156  " and global meters into the corresponding tabs.  At the end of each trace
                                   157  " command, there is a call to trace_catch_$start_tracing which again walks the
                                   158  " stack and sets the global_starts to tc_$metered.
                                   159  
                                   160  " This macro starts a metering interval.  It puts the linkage section offset of
                                   161  " the appropriate portion of the compensation table in pr4|start_comp.  It
                                   162  " then reads the meters into pr4|start.  It does not store real_time because
                                   163  " this will be done at the very last.
                                   164  " It clobbers X4 and the registers clobbered by read_vcpu_time_and_page_faults.
                                   165  
                                   166  	macro	start_metering_interval	<compensation_type>
                              1    167  	eax4	global_parameters+global_parms.comps+from_&1
                              2    168  	stx4	pr4|start_comp		" Remember which compensations to use.
                              3    169  
                              4    170  	read_vcpu_time_and_page_faults	start
                              5    171  
                              6    172  NOTHING_TO_START&U:
                              7    173  	&end
                                   174  
                                   175  
                                   176  
                                   177  
                                   178  
                                   179  
                                   180  
                                   181  " This macro calculates the usages during a metering interval and adds them to
                                   182  " the meters in whatever stack frame &1 points to and to pr4|metered.
                                   183  " Pr4|start_comp contains an offset into the linkage section for the
                                   184  " compensation values.  If pr4|start is zero, there is no interval and there
                                   185  " is nothing to do.  It assumes that pr4|stop contains the stop readings and
                                   186  " it uses pr4|delta as working storage.  It clobbers AQ and X4.
                                   187  
                                   188  	macro	metering_interval_calculations	<sp>,<compensation_type>
                              1    189  	lcaq	pr4|start+meters.real_time
                              2    190  	tze	INTERVAL_CALCULATED&U
                              3    191  
                              4    192  	ldx4	pr4|start_comp		" How were they started?
                              5    193  	adaq	pr4|stop+meters.real_time	" Calculate elapsed real time.
                              6    194  	tmi	trace_error_halt_$trace_error_halt_
                              7    195  	sbaq	pr4|to_&2.real_time,x4	" Subtract appropriate compensation.
                              8    196  	tpl	*+2			" A negative number would later
                              9    197  	lls	72			" be detected as an inconsistency.
                             10    198  	staq	pr4|delta+meters.real_time
                             11    199  
                             12    200  	ldaq	pr4|stop+meters.vcpu_time	" Calculate elapsed vcpu time.
                             13    201  	sbaq	pr4|start+meters.vcpu_time
                             14    202  	cmpaq	pr4|delta+meters.real_time	" Elapsed vcpu time should always be less
                             15    203  	tmoz	*+5			" than or equal to elapsed real time.
                             16    204  	szn	pr4|global_parameters+global_parms.calibrate " Don't apply correction
                             17    205  	tnz	*+3			" when determining compensations.
                             18    206  	ldaq	pr4|delta+meters.real_time	" If it isn't, use real time instead.
                             19    207  	tra	*+2			" Delta real is already compensated.
                             20    208  	sbaq	pr4|to_&2.vcpu_time,x4	" Subtract appropriate compensation.
                             21    209  	staq	pr4|delta+meters.vcpu_time
                             22    210  
                             23    211  	ldaq	&1|event+event.frame.real_time
                             24    212  	adaq	pr4|delta+meters.real_time	" Update frame real time.
                             25    213  	staq	&1|event+event.frame.real_time
                             26    214  
                             27    215  	ldaq	&1|event+event.frame.vcpu_time
                             28    216  	adaq	pr4|delta+meters.vcpu_time	" Update frame vcpu time.
                             29    217  	staq	&1|event+event.frame.vcpu_time
                             30    218  
                             31    219  	lda	pr4|stop+meters.page_faults
                             32    220  	sba	pr4|start+meters.page_faults
                             33    221  	tmi	trace_error_halt_$trace_error_halt_
                             34    222  	asa	&1|event+event.frame.page_faults " Update frame page faults.
                             35    223  
                             36    224  INTERVAL_CALCULATED&U:
                             37    225  	lls	72			" Insure that they are not used again.
                             38    226  	staq	pr4|start+meters.real_time
                             39    227  	staq	pr4|start+meters.vcpu_time
                             40    228  	stz	pr4|start+meters.page_faults
                             41    229  	&end
                                   230  
                                   231  " This macro starts a global metering interval if the recursion count is 1.
                                   232  " This is because we don't want to multiple-meter procedures used recursively.
                                   233  
                                   234  	macro	start_global_metering_interval	<sp>
                              1    235  
                              2    236  	lda	&1|event+event.saved.level	" Only start global meters
                              3    237  	tpnz	GLOBAL_INTERVAL_STARTED&U	" at recursion level 1.
                              4    238  	tmi	trace_error_halt_$trace_error_halt_
                              5    239  
                              6    240  	lda	pr4|metered+meters.page_faults
                              7    241  	sta	&1|global_start.page_faults
                              8    242  
                              9    243  	ldaq	pr4|metered+meters.vcpu_time
                             10    244  	staq	&1|global_start.vcpu_time
                             11    245  
                             12    246  	ldaq	pr4|metered+meters.real_time	" Store this one last because it shows
                             13    247  	staq	&1|global_start.real_time " that the others are valid.
                             14    248  
                             15    249  GLOBAL_INTERVAL_STARTED&U:
                             16    250  	&end
                                   251  
                                   252  " This macro takes the meters that have been accumulating in a trace_catch_
                                   253  " frame and adds them to the tab.  It also adds them to trace_catch_$metered,
                                   254  " which accumulates all metered time and page faults.  This may be done either
                                   255  " because the frame is being popped or because we need the latest information
                                   256  " in the tab in order to produce a metering report.
                                   257  
                                   258  	macro	update_tab_meters	<sp>
                              1    259  	ldaq	pr4|metered+meters.real_time
                              2    260  	adaq	&1|event+event.frame.real_time	" Update metered real time.
                              3    261  	staq	pr4|metered+meters.real_time
                              4    262  
                              5    263  	ldaq	pr2|tab.local+meters.real_time
                              6    264  	adaq	&1|event+event.frame.real_time	" Update tab real time.
                              7    265  	staq	pr2|tab.local+meters.real_time
                              8    266  
                              9    267  	ldaq	pr4|metered+meters.vcpu_time
                             10    268  	adaq	&1|event+event.frame.vcpu_time	" Update metered vcpu time.
                             11    269  	staq	pr4|metered+meters.vcpu_time
                             12    270  
                             13    271  	ldaq	pr2|tab.local+meters.vcpu_time
                             14    272  	adaq	&1|event+event.frame.vcpu_time	" Update tab real time.
                             15    273  	staq	pr2|tab.local+meters.vcpu_time
                             16    274  
                             17    275  	lda	&1|event+event.frame.page_faults
                             18    276  	asa	pr4|metered+meters.page_faults " Update metered page faults.
                             19    277  	asa	pr2|tab.local+meters.page_faults " Update tab page faults.
                             20    278  
                             21    279  	ldaq	&1|global_start.real_time
                             22    280  	tze	FRAME_METERS_UPDATED&U	" No global metering in this frame.
                             23    281  
                             24    282  	ldaq	pr4|metered+meters.real_time	" Update global real time.
                             25    283  	sbaq	&1|global_start.real_time
                             26    284  	tmi	trace_error_halt_$trace_error_halt_
                             27    285  	adaq	pr2|tab.global+meters.real_time
                             28    286  	staq	pr2|tab.global+meters.real_time
                             29    287  
                             30    288  	ldaq	pr4|metered+meters.vcpu_time	" Update global vcpu time.
                             31    289  	sbaq	&1|global_start.vcpu_time
                             32    290  	adaq	pr2|tab.global+meters.vcpu_time
                             33    291  	staq	pr2|tab.global+meters.vcpu_time
                             34    292  
                             35    293  	lda	pr4|metered+meters.page_faults " Update global page faults.
                             36    294  	sba	&1|global_start.page_faults
                             37    295  	tmi	trace_error_halt_$trace_error_halt_
                             38    296  	asa	pr2|tab.global+meters.page_faults
                             39    297  
                             40    298  FRAME_METERS_UPDATED&U:
                             41    299  	lls	72			" Insure that they are not used again.
                             42    300  	staq	&1|event+event.frame.real_time
                             43    301  	staq	&1|event+event.frame.vcpu_time
                             44    302  	stz	&1|event+event.frame.page_faults
                             45    303  	staq	&1|global_start.real_time
                             46    304  	staq	&1|global_start.vcpu_time
                             47    305  	stz	&1|global_start.page_faults
                             48    306  	&end
                                   307  
                                   308  " FILL EVENT FOR PRINT OR STOP MACRO
                                   309  
                                   310  	macro	fill_event_for_trace_or_signal
                              1    311  	lda	EVENT_VERSION_3
                              2    312  	sta	event+event.version
                              3    313  	lxl0	trace_frames_saved+trace_frames.count
                              4    314  	sxl0	event+event.frame_count
                              5    315  
                              6    316  	epp0	ptr_registers_saved+2*0,*	" This is where PR0 was saved.
                              7    317  	sprp0	event+event.arg_list_ptr
                              8    318  	epp0	pr6|0
                              9    319  	epp0	pr0|stack_frame.prev_sp,*	" Pointer to caller's stack frame.
                             10    320  	lda	pr0|stack_frame.flag_word
                             11    321  	ana	stack_frame.support_bit,dl
                             12    322  	tnz	*-3			" Skip support frames.
                             13    323  	sprp0	event+event.callers_sp
                             14    324  	epp0	pr0|stack_frame.return_ptr,*	" Pointer to caller's return point.
                             15    325  	sprp0	event+event.return_ptr
                             16    326  	&end	" fill_event_for_trace_or_signal
                                   327  
                                   328  
                                   329  
                                   330  " CALL STOP ROUTINE MACRO
                                   331  
                                   332  	macro	call_stop_routine <sp>,<ca/re>
                              1    333  
                              2    334  " call global_parameters.stop_routine (event, watch_values_changed);
                              3    335  " dcl  global_parameters.stop_routine entry (1 like event aligned, bit aligned);
                              4    336  
                              5    337  	ldx0	=2a&2,du
                              6    338  	stx0	&1|event+event.kind
                              7    339  
                              8    340  	ldaq	two_arg_list_header
                              9    341  	staq	arg_list.header
                             10    342  	ldaq	pr4|global_parameters+global_parms.stop_routine+2 " Environment ptr.
                             11    343  	staq	arg_list.third_arg_ptr
                             12    344  	eraq	null_ptr
                             13    345  	anaq	ptr_mask
                             14    346  	tze	*+3
                             15    347  	ldaq	two_arg_list_header_w_env
                             16    348  	staq	arg_list.header
                             17    349  	epp0	&1|event
                             18    350  	spri0	arg_list.first_arg_ptr
                             19    351  	epp0	&1|watch_values_changed
                             20    352  	spri0	arg_list.second_arg_ptr
                             21    353  
                             22    354  	call	pr4|global_parameters+global_parms.stop_routine,*(arg_list.header)
                             23    355  	&end
                                   356  
                                   357  " CALL PRINT ROUTINE MACRO
                                   358  
                                   359  	macro	call_trace_routine_or_buffer <sp>,<ca/re/un/si>
                              1    360  
                              2    361  " call global_parameters.print_routine (event);
                              3    362  " dcl  global_parameters.print_routine entry (1 like event aligned);
                              4    363  
                              5    364  	ldx0	=2a&2,du
                              6    365  	stx0	&1|event+event.kind
                              7    366  
                              8    367  	lda	pr4|global_parameters+global_parms.buffer_ptr
                              9    368  	cmpa	packed_null
                             10    369  	tze	CALL_TRACE_PRINT&U
                             11    370  	lprp1	pr4|global_parameters+global_parms.buffer_ptr
                             12    371  	ldaq	pr1|buffer.h.version
                             13    372  	cmpaq	BUFFER_VERSION_3
                             14    373  	tnz	trace_error_halt_$trace_error_halt_
                             15    374  	lda	pr1|buffer.h.count
                             16    375  	aos	pr1|buffer.h.count
                             17    376  	ana	=o017777,dl		" mod 8192
                             18    377  	als	4			" 16 words per event.
                             19    378  	epp1	pr1|buffer.e,al		" pr1 -> buffer entry
                             20    379  	mlr	(pr),(pr)
                             21    380  	desc9a	&1|event,(event_size-2)*4
                             22    381  	desc9a	pr1|0,(event_size-2)*4
                             23    382  	ldaq	pr4|stop+meters.real_time
                             24    383  	staq	pr1|event_size-2		" Put clock reading in last two words.
                             25    384  	ife	&2,si
                             26    385  	mlr	(),(pr)			" Initialize so we can punt fast.
                             27    386  	desc9a	UNUSUAL_SIGNAL_ARG_LIST,24	" "Unusual signal_ arg list"
                             28    387  	desc9a	pr1|event.saved,24		" 24 is from event.saved to the clock.
                             29    388  	epp0	&1|ptr_registers_saved+2*0,*	" PR0 -> argument list header.
                             30    389  	lxl0	pr0|0			" If arg_list.header.call_type
                             31    390  	cmpx0	4,du			" ^= Interseg_call_type
                             32    391  	tnz	SKIP_TRACE_PRINT&U	" then punt.
                             33    392  	ldx0	pr0|1			" If arg_list.header.desc_count
                             34    393  	cmpx0	2,du			" < 1
                             35    394  	tmi	SKIP_TRACE_PRINT&U	" then punt.
                             36    395  	ldx0	pr0|0			" If arg_list.header.arg_count
                             37    396  	cmpx0	2,du			" < 1
                             38    397  	tmi	SKIP_TRACE_PRINT&U	" then punt.
                             39    398  	lda	pr0|2,x0*			" A = descriptor
                             40    399  	als	1			" Bit bucket = arg_descriptor.flag
                             41    400  	lrl	25
                             42    401  	arl	5			" A = arg_descriptor.type
                             43    402  	cmpa	21,dl			" If arg_descriptor.type ^= char_dtype
                             44    403  	tnz	SKIP_TRACE_PRINT&U	" then punt.
                             45    404  	qrl	12			" Q = arg_descriptor.size
                             46    405  	epp0	pr0|2,*			" PR0 -> signal name.
                             47    406  	mlr	(pr,rl),(pr),fill(040)
                             48    407  	desc9a	pr0|0,ql
                             49    408  	desc9a	pr1|event.saved,24		" 24 is from event.saved to the clock.
                             50    409  	ifend
                             51    410  	tra	SKIP_TRACE_PRINT&U
                             52    411  
                             53    412  CALL_TRACE_PRINT&U:
                             54    413  	ldaq	one_arg_list_header		" call trace_print_$trace (event);
                             55    414  	staq	arg_list.header
                             56    415  	ldaq	pr4|global_parameters+global_parms.trace_routine+2 " Environment ptr.
                             57    416  	staq	arg_list.second_arg_ptr
                             58    417  	eraq	null_ptr
                             59    418  	anaq	ptr_mask
                             60    419  	tze	*+3
                             61    420  	ldaq	one_arg_list_header_w_env
                             62    421  	staq	arg_list.header
                             63    422  	epp0	&1|event
                             64    423  	spri0	arg_list.first_arg_ptr
                             65    424  
                             66    425  	call	pr4|global_parameters+global_parms.trace_routine,*(arg_list.header)
                             67    426  SKIP_TRACE_PRINT&U:
                             68    427  	&end
                                   428  
                                   429  " CHECK OR UPDATE WATCH TABLE MACRO
                                   430  
                                   431  " This macro either checks or updates the watch table, depending on its second
                                   432  " argument.  It clobbers PR0, PR1, AQ, and X0.
                                   433  
                                   434  	macro	check_or_update_watch_table	<sp>,<check/update>
                              1    435  	ife	&2,check
                              2    436  	stz	&1|watch_values_changed
                              3    437  	ifend
                              4    438  	ife	&2,update
                              5    439  	szn	&1|watch_values_changed
                              6    440  	tze	WATCH_TABLE_DONE&U
                              7    441  	ifend
                              8    442  
                              9    443  	epp1	pr4|wt_ptr,*		" Pr1 points to the table header.
                             10    444  	ldaq	pr1|table.version
                             11    445  	cmpaq	TT_VERSION_3
                             12    446  	tnz	trace_error_halt_$trace_error_halt_
                             13    447  
                             14    448  	lxl0	pr1|table.count
                             15    449  WATCH_TABLE_LOOP&U:
                             16    450  	eax0	-1,x0
                             17    451  	tmi	WATCH_TABLE_DONE&U
                             18    452  	eaa	0,x0
                             19    453  	ars	18
                             20    454  	cmpa	pr1|table.idx+idx.low	" if idx - idx.low < 0
                             21    455  	tmi	*+3			" then actual_idx = idx;
                             22    456  	sba	pr1|table.idx+idx.low	" else actual_idx = idx - idx.low
                             23    457  	ada	pr1|table.idx+idx.high	" + idx.high;
                             24    458  	als	1
                             25    459  	lprp0	pr1|table.e+te.key,al
                             26    460  	ldq	pr0|0
                             27    461  	cmpq	pr1|table.e+te.data,al
                             28    462  	tze	WATCH_TABLE_LOOP&U
                             29    463  	ife	&2,check
                             30    464  	eaa	TRUE
                             31    465  	sta	&1|watch_values_changed
                             32    466  	ifend
                             33    467  	ife	&2,update
                             34    468  	stq	pr1|table.e+te.data,al
                             35    469  	tra	WATCH_TABLE_LOOP&U
                             36    470  	ifend
                             37    471  WATCH_TABLE_DONE&U:
                             38    472  	&end
                                   473  
                                   474  " TRACE IF NECESSARY MACRO
                                   475  
                                   476  	macro	trace_and_stop_if_necessary	<sp>,<ca/re/un>
                              1    477  
                              2    478  	szn	pr4|global_parameters+global_parms.meter
                              3    479  	tnz	DONT_CALL_ANYTHING&U
                              4    480  
                              5    481  	lda	pr2|tab.parms_ptr
                              6    482  	cmpa	packed_null		" If this entrypoint has been removed,
                              7    483  	tze	DONT_CALL_ANYTHING&U	" then don't trace it.
                              8    484  
                              9    485  	szn	pr2|tab.on		" If this entrypoint is -off,
                             10    486  	tze	DONT_CALL_ANYTHING&U	" then don't trace it.
                             11    487  
                             12    488  	szn	pr4|global_parameters+global_parms.alm
                             13    489  	tnz	*+4
                             14    490  	lda	pr2|tab.translator_id
                             15    491  	cmpa	1,dl			" If tab.translator_id = ALM
                             16    492  	tze	DONT_CALL_ANYTHING&U	" then don't trace.
                             17    493  
                             18    494  	inhibit	off		" <-> <-> <-> <-> <-> <-> <-> <-> <->
                             19    495  	lprp3	pr2|tab.parms_ptr		" pr3 = tab.parms_ptr;
                             20    496  	ldaq	pr3|parms.version
                             21    497  	cmpaq	PARAMETERS_VERSION_3
                             22    498  	tnz	trace_error_halt_$trace_error_halt_
                             23    499  
                             24    500  	lda	pr3|parms.trace		" Check inout.
                             25    501  &^=&2,ca&[	als	1
                             26    502  &]	tpl	CHECK_WATCH_TABLE&U
                             27    503  
                             28    504  	ldaq	&1|event+event.saved.calls
                             29    505  	adl	1,dl			" Get current count.
                             30    506  	staq	arg_list.header		" Save in strange temporary.
                             31    507  
                             32    508  	szn	pr3|parms.every		" Is this parameter active?
                             33    509  	tze	CHECK_FIRST&U
                             34    510  
                             35    511  	lrs	34			" If mod (call_count, tab.every) ^= 0
                             36    512  	dvf	pr3|parms.every		" then don't trace.
                             37    513  	lls	36
                             38    514  	ldq	arg_list.header+1		" Actually counts.calls+1.
                             39    515  	qls	1
                             40    516  	dvf	pr3|parms.every		" Q = mod (saved calls, tab.every);
                             41    517  	qrs	0			" Set indicators from register Q.
                             42    518  	tnz	CHECK_WATCH_TABLE&U
                             43    519  
                             44    520  CHECK_FIRST&U:
                             45    521  	lcaq	arg_list.header		" Actually counts.calls.
                             46    522  	adl	pr3|parms.first		" If tab.first - saved calls > 0
                             47    523  	tpnz	CHECK_WATCH_TABLE&U	" then don't trace.
                             48    524  
                             49    525  	szn	pr3|parms.last
                             50    526  	tze	*+4			" -last 0 means it is diasbled.
                             51    527  	lcaq	arg_list.header		" Actually counts.calls.
                             52    528  	adl	pr3|parms.last		" If parms.last - saved calls < 0
                             53    529  	tmi	CHECK_WATCH_TABLE&U	" then don't trace.
                             54    530  
                             55    531  	lda	&1|event+event.saved.level
                             56    532  	ada	1,dl			" Get current level.
                             57    533  	cmpa	pr3|parms.low		" If level - parms.low < 0
                             58    534  	tmi	CHECK_WATCH_TABLE&U	" then don't trace.
                             59    535  
                             60    536  	szn	pr3|parms.high
                             61    537  	tze	*+3			" -high 0 means it is diasbled.
                             62    538  	cmpa	pr3|parms.high		" If level - parms.high > 0
                             63    539  	tpnz	CHECK_WATCH_TABLE&U	" then don't trace.
                             64    540  
                             65    541  	szn	pr3|parms.new_high		" If -new_high is off
                             66    542  	tze	*+3			" then skip this check.
                             67    543  	cmpa	&1|event+event.saved.max_level
                             68    544  	tmoz	CHECK_WATCH_TABLE&U	" then don't trace.
                             69    545  
                             70    546  	call_trace_routine_or_buffer &1,&2
                             71    547  	
                             72    548  CHECK_WATCH_TABLE&U:
                             73    549  	ine	&2,un
                             74    550  
                             75    551  	check_or_update_watch_table	&1,check
                             76    552  
                             77    553  	szn	&1|watch_values_changed
                             78    554  	tnz	STOP_IT&U
                             79    555  
                             80    556  	lda	pr3|parms.stop
                             81    557  &^=&2,ca&[	als	1
                             82    558  &]	tpl	DONT_CALL_ANYTHING&U
                             83    559  
                             84    560  	ldaq	&1|event+event.saved.calls
                             85    561  	adl	1,dl			" Get real counts.calls.
                             86    562  	staq	arg_list.header		" Use this as a temporary.
                             87    563  
                             88    564  	szn	pr3|parms.stop_every	" Is this parameter active?
                             89    565  	tze	CHECK_STOP_LOW&U
                             90    566  
                             91    567  	lrs	34			" If mod (call_count, tab.every) ^= 0
                             92    568  	dvf	pr3|parms.stop_every	" then don't stop.
                             93    569  	lls	36
                             94    570  	ldq	arg_list.header+1		" Actually counts.calls+1.
                             95    571  	qls	1
                             96    572  	dvf	pr3|parms.stop_every	" Q = mod (saved calls, tab.every);
                             97    573  	qrs	0			" Set indicators from register Q.
                             98    574  	tnz	DONT_CALL_ANYTHING&U
                             99    575  
                            100    576  CHECK_STOP_LOW&U:
                            101    577  	lda	&1|event+event.saved.level
                            102    578  	ada	1,dl			" Get current level.
                            103    579  	cmpa	pr3|parms.stop_low		" If level - parms.stop_low < 0
                            104    580  	tmi	DONT_CALL_ANYTHING&U	" then don't stop.
                            105    581  
                            106    582  STOP_IT&U:
                            107    583  
                            108    584  	call_stop_routine &1,&2
                            109    585  
                            110    586  	check_or_update_watch_table	&1,update
                            111    587  
                            112    588  	ifend
                            113    589  	inhibit	on		" <+> <+> <+> <+> <+> <+> <+> <+> <+>
                            114    590  DONT_CALL_ANYTHING&U:
                            115    591  	&end
                                   592  
                                   593  	macro	is_tracing_permitted	<THE_ANSWER_IS_NO_LABEL>
                              1    594  " Is tracing this entry point permitted?
                              2    595  
                              3    596  	lda	pr2|tab.translator_id	" If tab.translator_id < 0,
                              4    597  	tmi	&1		" then this program can't be traced.
                              5    598  	szn	pr4|global_parameters+global_parms.alm
                              6    599  	tnz	*+3
                              7    600  	cmpa	1,dl			" If tab.translator_id = ALM
                              8    601  	tze	&1		" then don't trace.
                              9    602  
                             10    603  	szn	pr2|tab.on		" If this entrypoint is -off,
                             11    604  	tze	&1		" then don't trace it.
                             12    605  	&end
                                   606  
                                   607  
                                   608  
                                   609  
                                   610  
                                   611  	macro	pop_tab	<sp>
                              1    612  	lda	&1|event+event.saved.level	" Revert tab.cts.level,
                              2    613  	tmi	trace_error_halt_$trace_error_halt_
                              3    614  	sta	pr2|tab.cts+counts.level
                                   615  	&end;
                                   616  
                                   617  "	  A FEW WORDS ABOUT THE STRUCTURE OF THE TRACE TABLES
                                   618  
                                   619  " The trace facility maintains four tables in the same format:
                                   620  
                                   621  "      tt:  The trace table itself, which has a maximum of 10,000 entries.
                                   622  "      stt: The table of entrypoints specified by the trace command.
                                   623  "      wt:  The table locations being watched, with a maximum of 1024 entries.
                                   624  "      swt: The table of locations specified by the watch_locations command.
                                   625  
                                   626  " Each table has an 8 word header that contains a version, the maximum number
                                   627  " of entries (max_count), and the current number of entries (count).  The
                                   628  " table entries are two words each and are sorted into ascending order based
                                   629  " on the numeric value of the first word, which is known as the key.  The
                                   630  " second word is known as the data.
                                   631  
                                   632  " In order to facilitate updating, the entries in a table are divided into two
                                   633  " halves.  One half is at the low end of the table and the other half is at
                                   634  " the high end.  When an entry is to be added to a table, entries are shifted
                                   635  " from one half to the other until the new entry can be added by appending it
                                   636  " to the high end of the low half.
                                   637  
                                   638  " The index of a table entry must be translated into the index of an element
                                   639  " in the table array.  Both the array indexes and the table indexes are zero
                                   640  " relative.  The first element of the table array is 0 and the index of the
                                   641  " last element is max_count - 1.  If an entry is in the low half, the array
                                   642  " index is the same as the entry index.
                                   643  
                                   644  " There is a double word in the table header that describes the halvs.  The
                                   645  " first word is called idx.low and the second word is called idx.high.
                                   646  " Idx.high is the array index of the first element in the high half.  If it is
                                   647  " equal to max_count, there are no entries in the high half.  Idx.low is the
                                   648  " number of entries in the low half.  An entry is in the high half if its
                                   649  " entry index is >= idx.low.  If an entry is in the high half, its array index
                                   650  " is its entry index - idx.low + idx.high.
                                   651  
                                   652  " There are three macros for manipulating these tables.
                                   653  
                                   654  "      seek_table		which finds an entry, given its key.
                                   655  "      index_table		which finds an entry, given its entry index.
                                   656  "      normalize_table	which moves entries until idx.low = entry index.
                                   657  
                                   658  " SEEK TABLE MACRO
                                   659  " This macro searches the trace or locations table for an entry or location.
                                   660  " It is called with:
                                   661  " 	PR1 -> table header,
                                   662  " 	Q containing the key being searched for.
                                   663  " If the entry is found, it returns to the FOUND label with:
                                   664  " 	PR2 -> the matching entry
                                   665  " 	X2 containing the entry index
                                   666  "	A, X1, and table.working_storage clobbered.
                                   667  " If the entry is not found, it returns to the NOT_FOUND label with:
                                   668  " 	X2 containing the entry index it would have if it were added.
                                   669  "	PR2, A, X1, and table.working_storage clobbered.
                                   670  " If the table is empty, it goes to the NOT_FOUND label with:
                                   671  " 	X2 = 0.
                                   672  "	PR2, A, X1, and table.working_storage clobbered.
                                   673  
                                   674  	macro	seek_table	" Syntax: seek_table FOUND,NOT_FOUND
                              1    675  	lda	pr1|table.idx+idx.high
                              2    676  	als	1
                              3    677  	epp2	pr1|table.e,al	" Pr2 points to high half.
                              4    678  	lda	pr1|table.max_count
                              5    679  	sba	pr1|table.idx+idx.high " If table.max_count - idx.high = 0,
                              6    680  	tze	SEEK_LOW&U	" then the high half is empty.
                              7    681  	tmi	trace_error_halt_$trace_error_halt_
                              8    682  	cmpq	pr2|te.key	" If Q - table.e (idx.high) < 0
                              9    683  	tmi	SEEK_LOW&U
                             10    684  	tpnz	BINARY_LOOP&U
                             11    685  	lxl2	pr1|table.idx+idx.low " Good luck.  We found it.
                             12    686  	tra	&1
                             13    687  
                             14    688  SEEK_LOW&U:
                             15    689  	epp2	pr1|table.e	" Pr2 points to low half.
                             16    690  	lda	pr1|table.idx+idx.low	" A = number of entries in low half.
                             17    691  	tpnz	BINARY_LOOP&U	" If A > 0, then do a binary search.
                             18    692  	tmi	trace_error_halt_$trace_error_halt_
                             19    693  	eax2	0		" else it's not in the table.
                             20    694  	tra	&2
                             21    695  
                             22    696  " The binary search uses pr2 to point to the group of remaining candidates.
                             23    697  " It uses the A register to contain the number of remaining candidates.
                             24    698  " During the search uses X2 to represent the offset to the middle of the candidates.
                             25    699  
                             26    700  BINARY_LOOP&U:		" X2 contains offset that divides portion in half,
                             27    701  	eax2	-1,al		" with the upper division being the larger one.
                             28    702  	tmi	BINARY_NOT_FOUND&U " Quit, if the portion is zero length.
                             29    703  
                             30    704  	anx2	=o777776,du	" Truncate offset in x2 to a double word boundary.
                             31    705  	ars	1		" Calculate size of the portion for the next pass.
                             32    706  
                             33    707  	cmpq	pr2|te.key,x2	" If value we are looking for is LESS than value we
                             34    708  	tmi	BINARY_LOOP&U	" are looking at, then look again in LOWER division.
                             35    709  
                             36    710  	epp2	pr2|te_size,x2	" If value we are looking for is MORE than value we
                             37    711  	tpnz	BINARY_LOOP&U	" are looking at, then look again in UPPER division.
                             38    712  
                             39    713  	epp2	pr2|-te_size	" Success!  The binary search always
                             40    714  	eax1	&1	" succeeds with PR2 -> to the next entry.
                             41    715  	tra	FIGURE_INDEX&U
                             42    716  
                             43    717  BINARY_NOT_FOUND&U:		" The binary search always fails with
                             44    718  	eax1	&2	" PR2 -> entry where it should have been.
                             45    719  
                             46    720  FIGURE_INDEX&U:
                             47    721  	eaa	pr1|table.e	" Calculate the winning index.
                             48    722  	arl	19
                             49    723  	sta	pr1|table.working_storage
                             50    724  	eaa	pr2|0
                             51    725  	arl	19
                             52    726  	sba	pr1|table.working_storage
                             53    727  	eax2	0,al
                             54    728  	cmpa	pr1|table.idx+idx.low	" If index - idx.low <= 0,
                             55    729  	tmoz	0,x1	" then it is in the low half and we are done.
                             56    730  	sba	pr1|table.idx+idx.high
                             57    731  	tmi	trace_error_halt_$trace_error_halt_
                             58    732  	ada	pr1|table.idx+idx.low
                             59    733  	eax2	0,al		" index = index - idx.high + idx.low;
                             60    734  	tra	0,x1
                             61    735  	&end
                                   736  
                                   737  " INDEX TABLE MACRO
                                   738  " This macro assumes that:
                                   739  "	PR1 -> table,
                                   740  "	X2 = table index.
                                   741  " It finishes with:
                                   742  "	PR2 -> the table entry specified by the index in X2,
                                   743  "	A clobbered.
                                   744  
                                   745  	macro	index_table
                              1    746  	eaa	0,x2
                              2    747  	ars	18
                              3    748  	tmi	trace_error_halt_$table_index_oob
                              4    749  	cmpa	pr1|table.idx+idx.low	" If table_index - idx.low > 0,
                              5    750  	tpl	INDEX_HIGH&U	" then get it from the high half.
                              6    751  	als	1
                              7    752  	epp2	pr1|table.e,al
                              8    753  	tra	INDEX_DONE&U
                              9    754  INDEX_HIGH&U:
                             10    755  	sba	pr1|table.idx+idx.low
                             11    756  	ada	pr1|table.idx+idx.high	" Q = array_index - idx.low + idx.high;
                             12    757  	cmpa	pr1|table.max_count
                             13    758  	tpl	trace_error_halt_$table_index_oob
                             14    759  	als	1
                             15    760  	epp2	pr1|table.e,al
                             16    761  INDEX_DONE&U:
                             17    762  	&end
                                   763  
                                   764  " NORMALIZE TABLE MACRO
                                   765  " This macro assumes that:
                                   766  "	PR1 -> table
                                   767  "	X2 contains an entry index.
                                   768  " It moves table entries until idx.low = X2, using the mlr or mrl instruction.
                                   769  " When it returns:
                                   770  "	idx.low = X2.
                                   771  "	PR2, PR3, AQ, and table.working_storage clobbered.
                                   772  
                                   773  	macro	normalize_table
                              1    774  	ldaq	pr1|table.idx
                              2    775  	staq	pr1|table.working_storage
                              3    776  	eaa	0,x2
                              4    777  	ars	18
                              5    778  	sba	pr1|table.idx+idx.low	"A = table_index - idx.low;
                              6    779  	tze	TABLE_NORMALIZED&U " The table is already normalized.
                              7    780  	asa	pr1|table.working_storage+idx.low  " Working_storage is an image of
                              8    781  	asa	pr1|table.working_storage+idx.high " what table.idx will be.
                              9    782  	ldq	pr1|table.max_count
                             10    783  	sbq	pr1|table.count	" If table.max_count - table.count = 0,
                             11    784  	tze	TABLE_NORMALIZED&U " then table is full, so just change idx.
                             12    785  	tmi	trace_error_halt_$trace_error_halt_
                             13    786  	ars	0		" Set the indicator registers from A.
                             14    787  	tpnz	MOVE_HIGH_TO_LOW&U " If A > 0, move data down.
                             15    788  
                             16    789  MOVE_LOW_TO_HIGH&U:		" If A < 0, move data up.
                             17    790  	ldaq	pr1|table.working_storage
                             18    791  	lls	1
                             19    792  	epp2	pr1|table.e,al	" Pr2 -> table.e (idx.low).
                             20    793  	epp3	pr1|table.e,ql	" Pr3 -> table.e (idx.high).
                             21    794  	lda	pr1|table.idx+idx.low
                             22    795  	sba	pr1|table.working_storage+idx.low
                             23    796  	als	3		" There are eight bytes per entry.
                             24    797  	mrl	(pr,rl),(pr,rl)
                             25    798  	desc9a	pr2|0,al
                             26    799  	desc9a	pr3|0,al
                             27    800  	tra	TABLE_NORMALIZED&U
                             28    801  
                             29    802  MOVE_HIGH_TO_LOW&U:
                             30    803  	ldaq	pr1|table.idx
                             31    804  	lls	1
                             32    805  	epp2	pr1|table.e,al	" Pr2 -> table.e (idx.low).
                             33    806  	epp3	pr1|table.e,ql	" Pr3 -> table.e (idx.high).
                             34    807  	lda	pr1|table.working_storage+idx.low
                             35    808  	sba	pr1|table.idx+idx.low
                             36    809  	als	3		" There are eight bytes per entry.
                             37    810  	mlr	(pr,rl),(pr,rl)
                             38    811  	desc9a	pr3|0,al
                             39    812  	desc9a	pr2|0,al
                             40    813  
                             41    814  TABLE_NORMALIZED&U:
                             42    815  	ldaq	pr1|table.working_storage
                             43    816  	staq	pr1|table.idx
                             44    817  	&end
                                   818  
                                   819  " TABLE SEEK
                                   820  " dcl trace_catch_$table_seek entry (ptr, bit (36) aligned) returns (fixed bin);
                                   821  " table_index = trace_catch_$table_seek (table_ptr, key);
                                   822  
                        000023     823  	segdef	table_seek
    000023                         824  table_seek:
                                   825  	get_pr4
    000023  0a   000023 2130 00         	epaq	*
    000024  aa  7 00026 7641 61         	lprp4	pr7|stack_header.lot_ptr,*au
    000025  aa  0 00002 3515 20    826  	epp1	pr0|2,*
    000026  aa  1 00000 3515 20    827  	epp1	pr1|0,*		" Pr1 points to the table header.
    000027  aa  1 00000 2371 00    828  	ldaq	pr1|table.version
    000030  0a   003264 1170 00    829  	cmpaq	TT_VERSION_3
    000031  4a  4 00406 6011 20    830  	tnz	trace_error_halt_$trace_error_halt_
                                   831  
    000032  aa  0 00004 2361 20    832  	ldq	pr0|4,*		" Q reg contains the key we seek.
                                   833  
                                   834  	seek_table	TABLE_SEEK_FOUND,TABLE_SEEK_NOT_FOUND
    000033  aa  1 00005 2351 00         	lda	pr1|table.idx+idx.high
    000034  aa   000001 7350 00         	als	1
    000035  aa  1 00010 3521 05         	epp2	pr1|table.e,al	" Pr2 points to high half.
    000036  aa  1 00002 2351 00         	lda	pr1|table.max_count
    000037  aa  1 00005 1751 00         	sba	pr1|table.idx+idx.high " If table.max_count - idx.high = 0,
    000040  0a   000047 6000 00         	tze	SEEK_LOW.._00000	" then the high half is empty.
    000041  4a  4 00406 6041 20         	tmi	trace_error_halt_$trace_error_halt_
    000042  aa  2 00000 1161 00         	cmpq	pr2|te.key	" If Q - table.e (idx.high) < 0
    000043  0a   000047 6040 00         	tmi	SEEK_LOW.._00000
    000044  0a   000055 6054 00         	tpnz	BINARY_LOOP.._00000
    000045  aa  1 00004 7221 00         	lxl2	pr1|table.idx+idx.low " Good luck.  We found it.
    000046  0a   000107 7100 00         	tra	TABLE_SEEK_FOUND
                                        
    000047                              SEEK_LOW.._00000:
    000047  aa  1 00010 3521 00         	epp2	pr1|table.e	" Pr2 points to low half.
    000050  aa  1 00004 2351 00         	lda	pr1|table.idx+idx.low	" A = number of entries in low half.
    000051  0a   000055 6054 00         	tpnz	BINARY_LOOP.._00000	" If A > 0, then do a binary search.
    000052  4a  4 00406 6041 20         	tmi	trace_error_halt_$trace_error_halt_
    000053  aa   000000 6220 00         	eax2	0		" else it's not in the table.
    000054  0a   000113 7100 00         	tra	TABLE_SEEK_NOT_FOUND
                                        
                                        " The binary search uses pr2 to point to the group of remaining candidates.
                                        " It uses the A register to contain the number of remaining candidates.
                                        " During the search uses X2 to represent the offset to the middle of the candidates.
                                        
    000055                              BINARY_LOOP.._00000:		" X2 contains offset that divides portion in half,
    000055  aa   777777 6220 05         	eax2	-1,al		" with the upper division being the larger one.
    000056  0a   000070 6040 00         	tmi	BINARY_NOT_FOUND.._00000 " Quit, if the portion is zero length.
                                        
    000057  aa   777776 3620 03         	anx2	=o777776,du	" Truncate offset in x2 to a double word boundary.
    000060  aa   000001 7310 00         	ars	1		" Calculate size of the portion for the next pass.
                                        
    000061  aa  2 00000 1161 12         	cmpq	pr2|te.key,x2	" If value we are looking for is LESS than value we
    000062  0a   000055 6040 00         	tmi	BINARY_LOOP.._00000	" are looking at, then look again in LOWER division.
                                        
    000063  aa  2 00002 3521 12         	epp2	pr2|te_size,x2	" If value we are looking for is MORE than value we
    000064  0a   000055 6054 00         	tpnz	BINARY_LOOP.._00000	" are looking at, then look again in UPPER division.
                                        
    000065  aa  2 77776 3521 00         	epp2	pr2|-te_size	" Success!  The binary search always
    000066  0a   000107 6210 00         	eax1	TABLE_SEEK_FOUND	" succeeds with PR2 -> to the next entry.
    000067  0a   000071 7100 00         	tra	FIGURE_INDEX.._00000
                                        
    000070                              BINARY_NOT_FOUND.._00000:		" The binary search always fails with
    000070  0a   000113 6210 00         	eax1	TABLE_SEEK_NOT_FOUND	" PR2 -> entry where it should have been.
                                        
    000071                              FIGURE_INDEX.._00000:
    000071  aa  1 00010 6351 00         	eaa	pr1|table.e	" Calculate the winning index.
    000072  aa   000023 7710 00         	arl	19
    000073  aa  1 00006 7551 00         	sta	pr1|table.working_storage
    000074  aa  2 00000 6351 00         	eaa	pr2|0
    000075  aa   000023 7710 00         	arl	19
    000076  aa  1 00006 1751 00         	sba	pr1|table.working_storage
    000077  aa   000000 6220 05         	eax2	0,al
    000100  aa  1 00004 1151 00         	cmpa	pr1|table.idx+idx.low	" If index - idx.low <= 0,
    000101  aa   000000 6044 11         	tmoz	0,x1	" then it is in the low half and we are done.
    000102  aa  1 00005 1751 00         	sba	pr1|table.idx+idx.high
    000103  4a  4 00406 6041 20         	tmi	trace_error_halt_$trace_error_halt_
    000104  aa  1 00004 0751 00         	ada	pr1|table.idx+idx.low
    000105  aa   000000 6220 05         	eax2	0,al		" index = index - idx.high + idx.low;
    000106  aa   000000 7100 11         	tra	0,x1
                                   835  
    000107                         836  TABLE_SEEK_FOUND:
    000107  aa   000000 6350 12    837  	eaa	0,x2
    000110  aa   000022 7310 00    838  	ars	18
    000111  aa  0 00006 7551 20    839  	sta	pr0|6,*
    000112  aa  7 00044 7101 20    840  	short_return		" return (table_index);
                                   841  
    000113                         842  TABLE_SEEK_NOT_FOUND:
    000113  aa   000001 3350 07    843  	lca	1,dl
    000114  aa  0 00006 7551 20    844  	sta	pr0|6,*
    000115  aa  7 00044 7101 20    845  	short_return		" return (-1)
                                   846  
                                   847  " TABLE GET
                                   848  " dcl trace_catch_$table_get entry (ptr, fixed bin) returns (1 like table_entry aligned);
                                   849  " table_entry = trace_catch_$table_get (table_ptr, table_index);
                                   850  
                                   851  	
                        000116     852  	segdef	table_get
    000116                         853  table_get:
                                   854  	get_pr4
    000116  0a   000116 2130 00         	epaq	*
    000117  aa  7 00026 7641 61         	lprp4	pr7|stack_header.lot_ptr,*au
    000120  aa  0 00002 3515 20    855  	epp1	pr0|2,*
    000121  aa  1 00000 3515 20    856  	epp1	pr1|0,*		" Pr1 points to the table header.
    000122  aa  1 00000 2371 00    857  	ldaq	pr1|table.version
    000123  0a   003264 1170 00    858  	cmpaq	TT_VERSION_3
    000124  4a  4 00406 6011 20    859  	tnz	trace_error_halt_$trace_error_halt_
                                   860  
    000125  aa  0 00004 7221 20    861  	lxl2	pr0|4,*		" X2 contains the index.
                                   862  
                                   863  	index_table
    000126  aa   000000 6350 12         	eaa	0,x2
    000127  aa   000022 7310 00         	ars	18
    000130  4a  4 00410 6041 20         	tmi	trace_error_halt_$table_index_oob
    000131  aa  1 00004 1151 00         	cmpa	pr1|table.idx+idx.low	" If table_index - idx.low > 0,
    000132  0a   000136 6050 00         	tpl	INDEX_HIGH.._00001	" then get it from the high half.
    000133  aa   000001 7350 00         	als	1
    000134  aa  1 00010 3521 05         	epp2	pr1|table.e,al
    000135  0a   000144 7100 00         	tra	INDEX_DONE.._00001
    000136                              INDEX_HIGH.._00001:
    000136  aa  1 00004 1751 00         	sba	pr1|table.idx+idx.low
    000137  aa  1 00005 0751 00         	ada	pr1|table.idx+idx.high	" Q = array_index - idx.low + idx.high;
    000140  aa  1 00002 1151 00         	cmpa	pr1|table.max_count
    000141  4a  4 00410 6051 20         	tpl	trace_error_halt_$table_index_oob
    000142  aa   000001 7350 00         	als	1
    000143  aa  1 00010 3521 05         	epp2	pr1|table.e,al
    000144                              INDEX_DONE.._00001:
                                   864  
    000144  aa  2 00000 2371 00    865  	ldaq	pr2|te
    000145  aa  0 00006 3535 20    866  	epp3	pr0|6,*
    000146  aa  3 00000 7551 00    867  	sta	pr3|te.key
    000147  aa  3 00001 7561 00    868  	stq	pr3|te.data
    000150  aa  7 00044 7101 20    869  	short_return		" return (AQ);
                                   870  
                                   871  " TABLE PUT DATA
                                   872  " dcl trace_catch_$table_put_data entry (ptr, fixed bin, bit (36) aligned);
                                   873  " call trace_catch_$table_put_data (table_ptr, table_index, data);
                                   874  
                                   875  	
                        000151     876  	segdef	table_put_data
    000151                         877  table_put_data:
                                   878  	get_pr4
    000151  0a   000151 2130 00         	epaq	*
    000152  aa  7 00026 7641 61         	lprp4	pr7|stack_header.lot_ptr,*au
    000153  aa  0 00002 3515 20    879  	epp1	pr0|2,*
    000154  aa  1 00000 3515 20    880  	epp1	pr1|0,*		" Pr1 points to the table header.
    000155  aa  1 00000 2371 00    881  	ldaq	pr1|table.version
    000156  0a   003264 1170 00    882  	cmpaq	TT_VERSION_3
    000157  4a  4 00406 6011 20    883  	tnz	trace_error_halt_$trace_error_halt_
                                   884  
    000160  aa  0 00004 7221 20    885  	lxl2	pr0|4,*		" X2 contains the index.
                                   886  
                                   887  	index_table
    000161  aa   000000 6350 12         	eaa	0,x2
    000162  aa   000022 7310 00         	ars	18
    000163  4a  4 00410 6041 20         	tmi	trace_error_halt_$table_index_oob
    000164  aa  1 00004 1151 00         	cmpa	pr1|table.idx+idx.low	" If table_index - idx.low > 0,
    000165  0a   000171 6050 00         	tpl	INDEX_HIGH.._00002	" then get it from the high half.
    000166  aa   000001 7350 00         	als	1
    000167  aa  1 00010 3521 05         	epp2	pr1|table.e,al
    000170  0a   000177 7100 00         	tra	INDEX_DONE.._00002
    000171                              INDEX_HIGH.._00002:
    000171  aa  1 00004 1751 00         	sba	pr1|table.idx+idx.low
    000172  aa  1 00005 0751 00         	ada	pr1|table.idx+idx.high	" Q = array_index - idx.low + idx.high;
    000173  aa  1 00002 1151 00         	cmpa	pr1|table.max_count
    000174  4a  4 00410 6051 20         	tpl	trace_error_halt_$table_index_oob
    000175  aa   000001 7350 00         	als	1
    000176  aa  1 00010 3521 05         	epp2	pr1|table.e,al
    000177                              INDEX_DONE.._00002:
                                   888  
    000177  aa  0 00006 2361 20    889  	ldq	pr0|6,*
    000200  aa  2 00001 7561 00    890  	stq	pr2|te.data
    000201  aa  7 00044 7101 20    891  	short_return
                                   892  
                                   893  " TABLE ADD
                                   894  " dcl trace_catch_$table_add entry (ptr, 1 like table_entry aligned) returns (fixed bin);
                                   895  " table_index = trace_catch_$table_add (table_ptr, table_entry);
                                   896  
                        000202     897  	segdef	table_add
    000202                         898  table_add:
                                   899  	get_pr4
    000202  0a   000202 2130 00         	epaq	*
    000203  aa  7 00026 7641 61         	lprp4	pr7|stack_header.lot_ptr,*au
    000204  aa  0 00002 3515 20    900  	epp1	pr0|2,*
    000205  aa  1 00000 3515 20    901  	epp1	pr1|0,*		" Pr1 points to the table header.
    000206  aa  1 00000 2371 00    902  	ldaq	pr1|table.version
    000207  0a   003264 1170 00    903  	cmpaq	TT_VERSION_3
    000210  4a  4 00406 6011 20    904  	tnz	trace_error_halt_$trace_error_halt_
                                   905  
    000211  aa  0 00004 2361 20    906  	ldq	pr0|4,*		" Q reg contains the key we seek.
                                   907  
                                   908  	seek_table	ADD_ENTRY_FOUND_IN_TABLE,TRY_LOW_HALF_APPEND
    000212  aa  1 00005 2351 00         	lda	pr1|table.idx+idx.high
    000213  aa   000001 7350 00         	als	1
    000214  aa  1 00010 3521 05         	epp2	pr1|table.e,al	" Pr2 points to high half.
    000215  aa  1 00002 2351 00         	lda	pr1|table.max_count
    000216  aa  1 00005 1751 00         	sba	pr1|table.idx+idx.high " If table.max_count - idx.high = 0,
    000217  0a   000226 6000 00         	tze	SEEK_LOW.._00003	" then the high half is empty.
    000220  4a  4 00406 6041 20         	tmi	trace_error_halt_$trace_error_halt_
    000221  aa  2 00000 1161 00         	cmpq	pr2|te.key	" If Q - table.e (idx.high) < 0
    000222  0a   000226 6040 00         	tmi	SEEK_LOW.._00003
    000223  0a   000234 6054 00         	tpnz	BINARY_LOOP.._00003
    000224  aa  1 00004 7221 00         	lxl2	pr1|table.idx+idx.low " Good luck.  We found it.
    000225  0a   000266 7100 00         	tra	ADD_ENTRY_FOUND_IN_TABLE
                                        
    000226                              SEEK_LOW.._00003:
    000226  aa  1 00010 3521 00         	epp2	pr1|table.e	" Pr2 points to low half.
    000227  aa  1 00004 2351 00         	lda	pr1|table.idx+idx.low	" A = number of entries in low half.
    000230  0a   000234 6054 00         	tpnz	BINARY_LOOP.._00003	" If A > 0, then do a binary search.
    000231  4a  4 00406 6041 20         	tmi	trace_error_halt_$trace_error_halt_
    000232  aa   000000 6220 00         	eax2	0		" else it's not in the table.
    000233  0a   000271 7100 00         	tra	TRY_LOW_HALF_APPEND
                                        
                                        " The binary search uses pr2 to point to the group of remaining candidates.
                                        " It uses the A register to contain the number of remaining candidates.
                                        " During the search uses X2 to represent the offset to the middle of the candidates.
                                        
    000234                              BINARY_LOOP.._00003:		" X2 contains offset that divides portion in half,
    000234  aa   777777 6220 05         	eax2	-1,al		" with the upper division being the larger one.
    000235  0a   000247 6040 00         	tmi	BINARY_NOT_FOUND.._00003 " Quit, if the portion is zero length.
                                        
    000236  aa   777776 3620 03         	anx2	=o777776,du	" Truncate offset in x2 to a double word boundary.
    000237  aa   000001 7310 00         	ars	1		" Calculate size of the portion for the next pass.
                                        
    000240  aa  2 00000 1161 12         	cmpq	pr2|te.key,x2	" If value we are looking for is LESS than value we
    000241  0a   000234 6040 00         	tmi	BINARY_LOOP.._00003	" are looking at, then look again in LOWER division.
                                        
    000242  aa  2 00002 3521 12         	epp2	pr2|te_size,x2	" If value we are looking for is MORE than value we
    000243  0a   000234 6054 00         	tpnz	BINARY_LOOP.._00003	" are looking at, then look again in UPPER division.
                                        
    000244  aa  2 77776 3521 00         	epp2	pr2|-te_size	" Success!  The binary search always
    000245  0a   000266 6210 00         	eax1	ADD_ENTRY_FOUND_IN_TABLE	" succeeds with PR2 -> to the next entry.
    000246  0a   000250 7100 00         	tra	FIGURE_INDEX.._00003
                                        
    000247                              BINARY_NOT_FOUND.._00003:		" The binary search always fails with
    000247  0a   000271 6210 00         	eax1	TRY_LOW_HALF_APPEND	" PR2 -> entry where it should have been.
                                        
    000250                              FIGURE_INDEX.._00003:
    000250  aa  1 00010 6351 00         	eaa	pr1|table.e	" Calculate the winning index.
    000251  aa   000023 7710 00         	arl	19
    000252  aa  1 00006 7551 00         	sta	pr1|table.working_storage
    000253  aa  2 00000 6351 00         	eaa	pr2|0
    000254  aa   000023 7710 00         	arl	19
    000255  aa  1 00006 1751 00         	sba	pr1|table.working_storage
    000256  aa   000000 6220 05         	eax2	0,al
    000257  aa  1 00004 1151 00         	cmpa	pr1|table.idx+idx.low	" If index - idx.low <= 0,
    000260  aa   000000 6044 11         	tmoz	0,x1	" then it is in the low half and we are done.
    000261  aa  1 00005 1751 00         	sba	pr1|table.idx+idx.high
    000262  4a  4 00406 6041 20         	tmi	trace_error_halt_$trace_error_halt_
    000263  aa  1 00004 0751 00         	ada	pr1|table.idx+idx.low
    000264  aa   000000 6220 05         	eax2	0,al		" index = index - idx.high + idx.low;
    000265  aa   000000 7100 11         	tra	0,x1
                                   909  
    000266                         910  ADD_ENTRY_FOUND_IN_TABLE:
    000266  aa   000001 3350 07    911  	lca	1,dl
    000267  aa  0 00006 7551 20    912  	sta	pr0|6,*
    000270  aa  7 00044 7101 20    913  	short_return		" return (-1);
                                   914  
    000271                         915  TRY_LOW_HALF_APPEND:
    000271  aa   000000 6350 12    916  	eaa	0,x2
    000272  aa   000022 7310 00    917  	ars	18
    000273  aa  1 00004 1151 00    918  	cmpa	pr1|table.idx+idx.low " If index_we_want ^= idx.low
    000274  0a   000312 6010 00    919  	tnz	NORMALIZE_FOR_ADD
    000275  aa  1 00005 1151 00    920  	cmpa	pr1|table.idx+idx.high " If idx.low - idx.high >= 0,
    000276  4a  4 00412 6051 20    921  	tpl	trace_error_halt_$table_full " then the table is already full.
    000277  aa   000001 7350 00    922  	als	1
    000300  aa  1 00010 3521 05    923  	epp2	pr1|table.e,al	" PR2 -> where new entry will go.
    000301  aa  0 00004 3535 20    924  	epp3	pr0|4,*
    000302  aa  3 00000 2351 00    925  	lda	pr3|te.key	" Arg is not necessarily double word aligned.
    000303  aa  3 00001 2361 00    926  	ldq	pr3|te.data
    000304  aa  2 00000 7571 00    927  	staq	pr2|te		" table.e (idx.low) = table_entry;
    000305  aa  1 00004 2351 00    928  	lda	pr1|table.idx+idx.low
    000306  aa  0 00006 7551 20    929  	sta	pr0|6,*		" return (idx.low);
    000307                         930  	inhibit	on		" <+> <+> <+> <+> <+> <+> <+> <+> <+>
    000307  aa  1 00004 0543 00    931  	aos	pr1|table.idx+idx.low " idx.low = idx.low + 1;
    000310  aa  1 00003 0543 00    932  	aos	pr1|table.count	" table.count = table.count + 1;
    000311                         933  	inhibit	off		" <-> <-> <-> <-> <-> <-> <-> <-> <->
    000311  aa  7 00044 7101 20    934  	short_return
                                   935  
    000312                         936  NORMALIZE_FOR_ADD:
                                   937  	normalize_table
    000312  aa  1 00004 2371 00         	ldaq	pr1|table.idx
    000313  aa  1 00006 7571 00         	staq	pr1|table.working_storage
    000314  aa   000000 6350 12         	eaa	0,x2
    000315  aa   000022 7310 00         	ars	18
    000316  aa  1 00004 1751 00         	sba	pr1|table.idx+idx.low	"A = table_index - idx.low;
    000317  0a   000355 6000 00         	tze	TABLE_NORMALIZED.._00004 " The table is already normalized.
    000320  aa  1 00006 0551 00         	asa	pr1|table.working_storage+idx.low  " Working_storage is an image of
    000321  aa  1 00007 0551 00         	asa	pr1|table.working_storage+idx.high " what table.idx will be.
    000322  aa  1 00002 2361 00         	ldq	pr1|table.max_count
    000323  aa  1 00003 1761 00         	sbq	pr1|table.count	" If table.max_count - table.count = 0,
    000324  0a   000355 6000 00         	tze	TABLE_NORMALIZED.._00004 " then table is full, so just change idx.
    000325  4a  4 00406 6041 20         	tmi	trace_error_halt_$trace_error_halt_
    000326  aa   000000 7310 00         	ars	0		" Set the indicator registers from A.
    000327  0a   000343 6054 00         	tpnz	MOVE_HIGH_TO_LOW.._00004 " If A > 0, move data down.
                                        
    000330                              MOVE_LOW_TO_HIGH.._00004:		" If A < 0, move data up.
    000330  aa  1 00006 2371 00         	ldaq	pr1|table.working_storage
    000331  aa   000001 7370 00         	lls	1
    000332  aa  1 00010 3521 05         	epp2	pr1|table.e,al	" Pr2 -> table.e (idx.low).
    000333  aa  1 00010 3535 06         	epp3	pr1|table.e,ql	" Pr3 -> table.e (idx.high).
    000334  aa  1 00004 2351 00         	lda	pr1|table.idx+idx.low
    000335  aa  1 00006 1751 00         	sba	pr1|table.working_storage+idx.low
    000336  aa   000003 7350 00         	als	3		" There are eight bytes per entry.
    000337  aa  0 00140 1015 40         	mrl	(pr,rl),(pr,rl)
    000340  aa   200000 000005          	desc9a	pr2|0,al
    000341  aa   300000 000005          	desc9a	pr3|0,al
    000342  0a   000355 7100 00         	tra	TABLE_NORMALIZED.._00004
                                        
    000343                              MOVE_HIGH_TO_LOW.._00004:
    000343  aa  1 00004 2371 00         	ldaq	pr1|table.idx
    000344  aa   000001 7370 00         	lls	1
    000345  aa  1 00010 3521 05         	epp2	pr1|table.e,al	" Pr2 -> table.e (idx.low).
    000346  aa  1 00010 3535 06         	epp3	pr1|table.e,ql	" Pr3 -> table.e (idx.high).
    000347  aa  1 00006 2351 00         	lda	pr1|table.working_storage+idx.low
    000350  aa  1 00004 1751 00         	sba	pr1|table.idx+idx.low
    000351  aa   000003 7350 00         	als	3		" There are eight bytes per entry.
    000352  aa  0 00140 1005 40         	mlr	(pr,rl),(pr,rl)
    000353  aa   300000 000005          	desc9a	pr3|0,al
    000354  aa   200000 000005          	desc9a	pr2|0,al
                                        
    000355                              TABLE_NORMALIZED.._00004:
    000355  aa  1 00006 2371 00         	ldaq	pr1|table.working_storage
    000356  aa  1 00004 7571 00         	staq	pr1|table.idx
                                   938  
    000357  0a   000271 7100 00    939  	tra	TRY_LOW_HALF_APPEND	" This will work now.
                                   940  
                                   941  " TABLE REMOVE
                                   942  " dcl trace_catch_$table_remove entry (ptr, fixed bin) returns (1 like te aligned);
                                   943  " te = trace_catch_$table_remove (table_ptr, table_index);
                                   944  
                        000360     945  	segdef	table_remove
    000360                         946  table_remove:
                                   947  	get_pr4
    000360  0a   000360 2130 00         	epaq	*
    000361  aa  7 00026 7641 61         	lprp4	pr7|stack_header.lot_ptr,*au
    000362  aa  0 00002 3515 20    948  	epp1	pr0|2,*
    000363  aa  1 00000 3515 20    949  	epp1	pr1|0,*		" Pr1 points to the table header.
    000364  aa  1 00000 2371 00    950  	ldaq	pr1|table.version
    000365  0a   003264 1170 00    951  	cmpaq	TT_VERSION_3
    000366  4a  4 00406 6011 20    952  	tnz	trace_error_halt_$trace_error_halt_
                                   953  
    000367  aa  0 00004 7221 20    954  	lxl2	pr0|4,*		" X2 contains the index.
                                   955  
                                   956  	index_table
    000370  aa   000000 6350 12         	eaa	0,x2
    000371  aa   000022 7310 00         	ars	18
    000372  4a  4 00410 6041 20         	tmi	trace_error_halt_$table_index_oob
    000373  aa  1 00004 1151 00         	cmpa	pr1|table.idx+idx.low	" If table_index - idx.low > 0,
    000374  0a   000400 6050 00         	tpl	INDEX_HIGH.._00005	" then get it from the high half.
    000375  aa   000001 7350 00         	als	1
    000376  aa  1 00010 3521 05         	epp2	pr1|table.e,al
    000377  0a   000406 7100 00         	tra	INDEX_DONE.._00005
    000400                              INDEX_HIGH.._00005:
    000400  aa  1 00004 1751 00         	sba	pr1|table.idx+idx.low
    000401  aa  1 00005 0751 00         	ada	pr1|table.idx+idx.high	" Q = array_index - idx.low + idx.high;
    000402  aa  1 00002 1151 00         	cmpa	pr1|table.max_count
    000403  4a  4 00410 6051 20         	tpl	trace_error_halt_$table_index_oob
    000404  aa   000001 7350 00         	als	1
    000405  aa  1 00010 3521 05         	epp2	pr1|table.e,al
    000406                              INDEX_DONE.._00005:
                                   957  
    000406  aa  2 00000 2371 00    958  	ldaq	pr2|te		" Store the return value.
    000407  aa  0 00006 3535 20    959  	epp3	pr0|6,*
    000410  aa  3 00000 7551 00    960  	sta	pr3|te.key	" Return arg is not necessarily
    000411  aa  3 00001 7561 00    961  	stq	pr3|te.data	" double word aligned.
                                   962  
                                   963  	normalize_table
    000412  aa  1 00004 2371 00         	ldaq	pr1|table.idx
    000413  aa  1 00006 7571 00         	staq	pr1|table.working_storage
    000414  aa   000000 6350 12         	eaa	0,x2
    000415  aa   000022 7310 00         	ars	18
    000416  aa  1 00004 1751 00         	sba	pr1|table.idx+idx.low	"A = table_index - idx.low;
    000417  0a   000455 6000 00         	tze	TABLE_NORMALIZED.._00006 " The table is already normalized.
    000420  aa  1 00006 0551 00         	asa	pr1|table.working_storage+idx.low  " Working_storage is an image of
    000421  aa  1 00007 0551 00         	asa	pr1|table.working_storage+idx.high " what table.idx will be.
    000422  aa  1 00002 2361 00         	ldq	pr1|table.max_count
    000423  aa  1 00003 1761 00         	sbq	pr1|table.count	" If table.max_count - table.count = 0,
    000424  0a   000455 6000 00         	tze	TABLE_NORMALIZED.._00006 " then table is full, so just change idx.
    000425  4a  4 00406 6041 20         	tmi	trace_error_halt_$trace_error_halt_
    000426  aa   000000 7310 00         	ars	0		" Set the indicator registers from A.
    000427  0a   000443 6054 00         	tpnz	MOVE_HIGH_TO_LOW.._00006 " If A > 0, move data down.
                                        
    000430                              MOVE_LOW_TO_HIGH.._00006:		" If A < 0, move data up.
    000430  aa  1 00006 2371 00         	ldaq	pr1|table.working_storage
    000431  aa   000001 7370 00         	lls	1
    000432  aa  1 00010 3521 05         	epp2	pr1|table.e,al	" Pr2 -> table.e (idx.low).
    000433  aa  1 00010 3535 06         	epp3	pr1|table.e,ql	" Pr3 -> table.e (idx.high).
    000434  aa  1 00004 2351 00         	lda	pr1|table.idx+idx.low
    000435  aa  1 00006 1751 00         	sba	pr1|table.working_storage+idx.low
    000436  aa   000003 7350 00         	als	3		" There are eight bytes per entry.
    000437  aa  0 00140 1015 40         	mrl	(pr,rl),(pr,rl)
    000440  aa   200000 000005          	desc9a	pr2|0,al
    000441  aa   300000 000005          	desc9a	pr3|0,al
    000442  0a   000455 7100 00         	tra	TABLE_NORMALIZED.._00006
                                        
    000443                              MOVE_HIGH_TO_LOW.._00006:
    000443  aa  1 00004 2371 00         	ldaq	pr1|table.idx
    000444  aa   000001 7370 00         	lls	1
    000445  aa  1 00010 3521 05         	epp2	pr1|table.e,al	" Pr2 -> table.e (idx.low).
    000446  aa  1 00010 3535 06         	epp3	pr1|table.e,ql	" Pr3 -> table.e (idx.high).
    000447  aa  1 00006 2351 00         	lda	pr1|table.working_storage+idx.low
    000450  aa  1 00004 1751 00         	sba	pr1|table.idx+idx.low
    000451  aa   000003 7350 00         	als	3		" There are eight bytes per entry.
    000452  aa  0 00140 1005 40         	mlr	(pr,rl),(pr,rl)
    000453  aa   300000 000005          	desc9a	pr3|0,al
    000454  aa   200000 000005          	desc9a	pr2|0,al
                                        
    000455                              TABLE_NORMALIZED.._00006:
    000455  aa  1 00006 2371 00         	ldaq	pr1|table.working_storage
    000456  aa  1 00004 7571 00         	staq	pr1|table.idx
                                   964  
    000457                         965  	inhibit	on		" <+> <+> <+> <+> <+> <+> <+> <+> <+>
    000457  aa  1 00005 0543 00    966  	aos	pr1|table.idx+idx.high " idx.high = idx.high + 1;
    000460  aa   000001 3352 07    967  	lca	1,dl
    000461  aa  1 00003 0553 00    968  	asa	pr1|table.count	" table.count = table.count - 1;
    000462                         969  	inhibit	off		" <-> <-> <-> <-> <-> <-> <-> <-> <->
    000462  aa  7 00044 7101 20    970  	short_return
                                   971  
                                   972  " The entry operators do a tsp2 to trace$catch_pl1_, so
                                   973  "
                                   974  "	PR2 -> place to resume the entry operator.
                                   975  "
                                   976  " The entry operator uses the first two words after the end of the stack for
                                   977  " temporary storage.  These two words must be restored before resuming the
                                   978  " operator.  The following pl1 declaration shows what is stored there.
                                   979  "
                                   980  "	dcl  1 saved aligned based (stack_header.stack_end_ptr),
                                   981  "	       2 entry_ptr ptr unal,	/* packed ptr to entry being traced */
                                   982  "	       2 pr1 ptr unal,	/* not needed, but must be restored */
                                   983  
                                   984  
                                   985  " Trace_catcher_ is a stub entry point for the benefit of debuggers.
                                   986  
                        000463     987  	entry	trace_catcher_
    000463                         988  trace_catcher_:
    000463  aa  7 00044 7101 20    989  	short_return
                                   990  
                                   991  
                        000464     992  	segdef	catch_pl1_
    000464                         993  catch_pl1_:
                                   994  
    000464                         995  	inhibit	on		<+> <+> <+> <+> <+> <+> <+> <+> <+> <+>
                                   996  
                                   997  	get_pr4
    000464  0a   000464 2132 00         	epaq	*
    000465  aa  7 00026 7643 61         	lprp4	pr7|stack_header.lot_ptr,*au
                                   998  
                                   999  " Read the calendar clock as soon as possible.
                                  1000  
                                  1001  	read_the_calendar_clock	stop
    000466  4a  4 00352 6333 20         	rccl	sys_info$clock_,*
    000467  9a  4 00022 7573 00         	staq	pr4|stop+meters.real_time
                                  1002  
                                  1003  " If tracing is inhibited, just resume the entry operator.
                                  1004  
    000470  aa  7 00074 2343 00   1005  	szn	pr7|stack_header.in_trace
    000471  aa  2 00000 6013 00   1006  	tnz	pr2|0
                                  1007  
                                  1008  " Getlp.  This cutrate getlp uses PR4 and PR5 as temporaries since the
                                  1009  " remainder of the entry operator will change them anyway.
                                  1010  
    000472  aa  7 00024 3717 20   1011  	epp5	pr7|stack_header.stack_end_ptr,* " PR5 -> stack frame construction site.
    000473  4a  4 00356 3703 20   1012  	epp4	trace_catch_$trace_catcher_	" Let debuggers see a real entry point.
    000474  aa  5 00026 6503 00   1013  	spri4	pr5|stack_frame.entry_ptr
                                  1014  
                                  1015  " Push.
                                  1016  
    000475  aa  5 00020 6523 00   1017  	spri6	pr5|stack_frame.prev_sp
    000476  0a   003330 3702 20   1018  	epp4	null_ptr,*
    000477  aa  5 00032 6503 00   1019  	spri4	pr5|stack_frame.arg_ptr
                                  1020  	get_pr4
    000500  0a   000500 2132 00         	epaq	*
    000501  aa  7 00026 7643 61         	lprp4	pr7|stack_header.lot_ptr,*au
    000502  aa  5 00030 6503 00   1021  	spri4	pr5|stack_frame.lp_ptr
    000503  aa  5 00000 3723 00   1022  	epp6	pr5|0
    000504  aa  6 00160 3717 00   1023  	epp5	pr6|stack_frame_size
    000505  aa  7 00024 6517 00   1024  	spri5	pr7|stack_header.stack_end_ptr
    000506  aa  6 00022 6517 00   1025  	spri5	pr6|stack_frame.next_sp
                                  1026  
                                  1027  " Save the cpu registers, and the two words where end of stack used to be, in a safe place.
                                  1028  
    000507  aa  6 00000 2373 00   1029  	ldaq	pr6|0
                                  1030  
    000510  aa  6 00060 2543 00   1031  	spri	ptr_registers_saved
    000511  aa  6 00050 7533 00   1032  	sreg	registers_saved
    000512  aa  6 00145 7543 00   1033  	sti	indicators_saved
                                  1034  
                                  1035  " Read the meters.  I wish it could have been done sooner.
                                  1036  
                                  1037  	read_vcpu_time_and_page_faults	stop
                                        
    000513  aa  6 00024 3573 00         	stcd	pr6|stack_frame.return_ptr
    000514  4a  4 00354 7133 20         	call6	cpu_time_and_paging_op_$cpu_time_and_paging_op_
                                        
    000515  aa  6 00000 3733 00         	epbp7	pr6|0
    000516  aa  6 00030 3703 20         	epp4	pr6|stack_frame.lp_ptr,*
    000517  9a  4 00024 7573 00         	staq	pr4|stop+meters.vcpu_time   " Vcpu time is returned in AQ register.
    000520  9a  4 00026 7403 00         	stx0	pr4|stop+meters.page_faults " Page faults are returned in X0 and X1.
    000521  9a  4 00026 4413 00         	sxl1	pr4|stop+meters.page_faults
                                  1038  
                                  1039  " To whom it may concern: trace_catch_ is an alm program.
                                  1040  
    000522  aa   000001 6272 00   1041  	eax7	1
    000523  aa  6 00037 7473 00   1042  	stx7	pr6|stack_frame.translator_id
                                  1043  
                                  1044  " Establish a cleanup handler to undo changes to static data.
                                  1045  
    000524  0a   003360 3502 00   1046  	epp0	=7acleanup		" Initialize the on unit data block.
    000525  aa  6 00130 2503 00   1047  	spri0	cleanup_unit+on_unit.name
    000526  0a   002274 3502 00   1048  	epp0	PRELIMINARY_CLEANUP_HANDLER	" It just resets stack_header.in_trace.
    000527  aa  6 00132 2503 00   1049  	spri0	cleanup_unit+on_unit.body
    000530  aa   000007 2362 07   1050  	ldq	7,dl
    000531  aa  6 00134 7563 00   1051  	stq	cleanup_unit+on_unit.size
    000532  aa  6 00135 4503 00   1052  	stz	cleanup_unit+on_unit.next
                                  1053  
                        000130    1054  	equ	cleanup_unit_offset,cleanup_unit
    000533  aa   000130 6352 00   1055  	eaa	cleanup_unit_offset		" Put it at the head of the list.
    000534  aa  6 00036 7553 00   1056  	sta	pr6|stack_frame.on_unit_rel_ptrs
                                  1057  
    000535  aa   000300 2352 07   1058  	lda	stack_frame.condition_bit+stack_frame.support_bit,dl
    000536  aa  6 00020 2553 00   1059  	orsa	pr6|stack_frame.flag_word	" List is valid & this is a support frame.
                                  1060  
                                  1061  " Prevent recursion in case of calls or errors.
                                  1062  
    000537  aa   400000 6352 00   1063  	eaa	TRUE
    000540  aa  7 00074 7553 00   1064  	sta	pr7|stack_header.in_trace
                                  1065  
                                  1066  " Calculate the meters and store them in the previously top trace_catch_ frame,
                                  1067  " if there is one.
                                  1068  
    000541  aa  7 00072 2373 00   1069  	ldaq	pr7|stack_header.trace_frames
    000542  aa  6 00136 7573 00   1070  	staq	trace_frames_saved
    000543  0a   000611 6002 00   1071  	tze	SEEK_TAB_FOR_CALL
    000544  aa  6 00137 7653 00   1072  	lprp5	trace_frames_saved+trace_frames.top_ptr
    000545  aa   000001 1752 07   1073  	sba	1,dl			" Make sure things are copacetic.
    000546  aa  5 00136 1153 00   1074  	cmpa	pr5|trace_frames_saved+trace_frames.count
    000547  4a  4 00406 6013 20   1075  	tnz	trace_error_halt_$trace_error_halt_
                                  1076  
                                  1077  	metering_interval_calculations	pr5,entry
    000550  9a  4 00014 3373 00         	lcaq	pr4|start+meters.real_time
    000551  0a   000605 6002 00         	tze	INTERVAL_CALCULATED.._00007
                                        
    000552  9a  4 00021 2243 00         	ldx4	pr4|start_comp		" How were they started?
    000553  9a  4 00022 0773 00         	adaq	pr4|stop+meters.real_time	" Calculate elapsed real time.
    000554  4a  4 00406 6043 20         	tmi	trace_error_halt_$trace_error_halt_
    000555  aa  4 00000 1773 14         	sbaq	pr4|to_entry.real_time,x4	" Subtract appropriate compensation.
    000556  0a   000560 6052 00         	tpl	*+2			" A negative number would later
    000557  aa   000110 7372 00         	lls	72			" be detected as an inconsistency.
    000560  9a  4 00030 7573 00         	staq	pr4|delta+meters.real_time
                                        
    000561  9a  4 00024 2373 00         	ldaq	pr4|stop+meters.vcpu_time	" Calculate elapsed vcpu time.
    000562  9a  4 00016 1773 00         	sbaq	pr4|start+meters.vcpu_time
    000563  9a  4 00030 1173 00         	cmpaq	pr4|delta+meters.real_time	" Elapsed vcpu time should always be less
    000564  0a   000571 6046 00         	tmoz	*+5			" than or equal to elapsed real time.
    000565  9a  4 00325 2343 00         	szn	pr4|global_parameters+global_parms.calibrate " Don't apply correction
    000566  0a   000571 6012 00         	tnz	*+3			" when determining compensations.
    000567  9a  4 00030 2373 00         	ldaq	pr4|delta+meters.real_time	" If it isn't, use real time instead.
    000570  0a   000572 7102 00         	tra	*+2			" Delta real is already compensated.
    000571  aa  4 00002 1773 14         	sbaq	pr4|to_entry.vcpu_time,x4	" Subtract appropriate compensation.
    000572  9a  4 00032 7573 00         	staq	pr4|delta+meters.vcpu_time
                                        
    000573  aa  5 00112 2373 00         	ldaq	pr5|event+event.frame.real_time
    000574  9a  4 00030 0773 00         	adaq	pr4|delta+meters.real_time	" Update frame real time.
    000575  aa  5 00112 7573 00         	staq	pr5|event+event.frame.real_time
                                        
    000576  aa  5 00114 2373 00         	ldaq	pr5|event+event.frame.vcpu_time
    000577  9a  4 00032 0773 00         	adaq	pr4|delta+meters.vcpu_time	" Update frame vcpu time.
    000600  aa  5 00114 7573 00         	staq	pr5|event+event.frame.vcpu_time
                                        
    000601  9a  4 00026 2353 00         	lda	pr4|stop+meters.page_faults
    000602  9a  4 00020 1753 00         	sba	pr4|start+meters.page_faults
    000603  4a  4 00406 6043 20         	tmi	trace_error_halt_$trace_error_halt_
    000604  aa  5 00116 0553 00         	asa	pr5|event+event.frame.page_faults " Update frame page faults.
                                        
    000605                              INTERVAL_CALCULATED.._00007:
    000605  aa   000110 7372 00         	lls	72			" Insure that they are not used again.
    000606  9a  4 00014 7573 00         	staq	pr4|start+meters.real_time
    000607  9a  4 00016 7573 00         	staq	pr4|start+meters.vcpu_time
    000610  9a  4 00020 4503 00         	stz	pr4|start+meters.page_faults
                                  1078  
    000611                        1079  SEEK_TAB_FOR_CALL:
                                  1080  
                                  1081  " Copy the packed pointer to the entry being traced from where the end of stack used to be.
                                  1082  
    000611  aa  6 00054 2353 00   1083  	lda	registers_saved+4	" This is where the sreg instruction puts A.
    000612  aa  6 00117 7553 00   1084  	sta	event+event.entry_ptr
                                  1085  
                                  1086  " Get the tab for this entrypoint, if it is in the trace table.
                                  1087  
    000613  9a  4 00054 3517 20   1088  	epp1	pr4|tt_ptr,*
    000614  aa  1 00000 2373 00   1089  	ldaq	pr1|table.version
    000615  0a   003264 1172 00   1090  	cmpaq	TT_VERSION_3
    000616  4a  4 00406 6013 20   1091  	tnz	trace_error_halt_$trace_error_halt_
                                  1092  
    000617  aa  6 00117 2363 00   1093  	ldq	event+event.entry_ptr		" Q reg contains the value we are looking for.
                                  1094  
                                  1095  	seek_table	EP_IS_IN_TT_AT_CALL,ADD_ENTRYPOINT
    000620  aa  1 00005 2353 00         	lda	pr1|table.idx+idx.high
    000621  aa   000001 7352 00         	als	1
    000622  aa  1 00010 3523 05         	epp2	pr1|table.e,al	" Pr2 points to high half.
    000623  aa  1 00002 2353 00         	lda	pr1|table.max_count
    000624  aa  1 00005 1753 00         	sba	pr1|table.idx+idx.high " If table.max_count - idx.high = 0,
    000625  0a   000634 6002 00         	tze	SEEK_LOW.._00010	" then the high half is empty.
    000626  4a  4 00406 6043 20         	tmi	trace_error_halt_$trace_error_halt_
    000627  aa  2 00000 1163 00         	cmpq	pr2|te.key	" If Q - table.e (idx.high) < 0
    000630  0a   000634 6042 00         	tmi	SEEK_LOW.._00010
    000631  0a   000642 6056 00         	tpnz	BINARY_LOOP.._00010
    000632  aa  1 00004 7223 00         	lxl2	pr1|table.idx+idx.low " Good luck.  We found it.
    000633  0a   000674 7102 00         	tra	EP_IS_IN_TT_AT_CALL
                                        
    000634                              SEEK_LOW.._00010:
    000634  aa  1 00010 3523 00         	epp2	pr1|table.e	" Pr2 points to low half.
    000635  aa  1 00004 2353 00         	lda	pr1|table.idx+idx.low	" A = number of entries in low half.
    000636  0a   000642 6056 00         	tpnz	BINARY_LOOP.._00010	" If A > 0, then do a binary search.
    000637  4a  4 00406 6043 20         	tmi	trace_error_halt_$trace_error_halt_
    000640  aa   000000 6222 00         	eax2	0		" else it's not in the table.
    000641  0a   000701 7102 00         	tra	ADD_ENTRYPOINT
                                        
                                        " The binary search uses pr2 to point to the group of remaining candidates.
                                        " It uses the A register to contain the number of remaining candidates.
                                        " During the search uses X2 to represent the offset to the middle of the candidates.
                                        
    000642                              BINARY_LOOP.._00010:		" X2 contains offset that divides portion in half,
    000642  aa   777777 6222 05         	eax2	-1,al		" with the upper division being the larger one.
    000643  0a   000655 6042 00         	tmi	BINARY_NOT_FOUND.._00010 " Quit, if the portion is zero length.
                                        
    000644  aa   777776 3622 03         	anx2	=o777776,du	" Truncate offset in x2 to a double word boundary.
    000645  aa   000001 7312 00         	ars	1		" Calculate size of the portion for the next pass.
                                        
    000646  aa  2 00000 1163 12         	cmpq	pr2|te.key,x2	" If value we are looking for is LESS than value we
    000647  0a   000642 6042 00         	tmi	BINARY_LOOP.._00010	" are looking at, then look again in LOWER division.
                                        
    000650  aa  2 00002 3523 12         	epp2	pr2|te_size,x2	" If value we are looking for is MORE than value we
    000651  0a   000642 6056 00         	tpnz	BINARY_LOOP.._00010	" are looking at, then look again in UPPER division.
                                        
    000652  aa  2 77776 3523 00         	epp2	pr2|-te_size	" Success!  The binary search always
    000653  0a   000674 6212 00         	eax1	EP_IS_IN_TT_AT_CALL	" succeeds with PR2 -> to the next entry.
    000654  0a   000656 7102 00         	tra	FIGURE_INDEX.._00010
                                        
    000655                              BINARY_NOT_FOUND.._00010:		" The binary search always fails with
    000655  0a   000701 6212 00         	eax1	ADD_ENTRYPOINT	" PR2 -> entry where it should have been.
                                        
    000656                              FIGURE_INDEX.._00010:
    000656  aa  1 00010 6353 00         	eaa	pr1|table.e	" Calculate the winning index.
    000657  aa   000023 7712 00         	arl	19
    000660  aa  1 00006 7553 00         	sta	pr1|table.working_storage
    000661  aa  2 00000 6353 00         	eaa	pr2|0
    000662  aa   000023 7712 00         	arl	19
    000663  aa  1 00006 1753 00         	sba	pr1|table.working_storage
    000664  aa   000000 6222 05         	eax2	0,al
    000665  aa  1 00004 1153 00         	cmpa	pr1|table.idx+idx.low	" If index - idx.low <= 0,
    000666  aa   000000 6046 11         	tmoz	0,x1	" then it is in the low half and we are done.
    000667  aa  1 00005 1753 00         	sba	pr1|table.idx+idx.high
    000670  4a  4 00406 6043 20         	tmi	trace_error_halt_$trace_error_halt_
    000671  aa  1 00004 0753 00         	ada	pr1|table.idx+idx.low
    000672  aa   000000 6222 05         	eax2	0,al		" index = index - idx.high + idx.low;
    000673  aa   000000 7102 11         	tra	0,x1
                                  1096  
    000674                        1097  EP_IS_IN_TT_AT_CALL:
    000674  aa   000000 6352 12   1098  	eaa	0,x2
    000675  aa   000022 7312 00   1099  	ars	18
    000676  aa  6 00124 7553 00   1100  	sta	event+event.entry_idx
    000677  aa  2 00001 7623 00   1101  	lprp2	pr2|te.data
    000700  0a   001103 7102 00   1102  	tra	HAVE_TAB
                                  1103  
    000701                        1104  ADD_ENTRYPOINT:
    000701  aa   000001 3352 07   1105  	lca	1,dl
    000702  aa  6 00124 7553 00   1106  	sta	event+event.entry_idx
    000703  0a   003330 3522 20   1107  	epp2	null_ptr,*		" Catch bugs early.
                                  1108  
                                  1109  
                                  1110  " If the entry point is signal_$signal_ or signal_$io_signal, then trace as signal.
                                  1111  
    000704  aa  6 00117 2363 00   1112  	ldq	event+event.entry_ptr
    000705  9a  4 00012 1163 00   1113  	cmpq	pr4|SIGNAL_
    000706  0a   000762 6002 00   1114  	tze	THIS_IS_A_SIGNAL
                                  1115  
    000707  9a  4 00013 1163 00   1116  	cmpq	pr4|IO_SIGNAL
    000710  0a   000762 6002 00   1117  	tze	THIS_IS_A_SIGNAL
                                  1118  
                                  1119  " If -auto on, then add this entry point to the trace table.
                                  1120  
    000711  9a  4 00065 2343 00   1121  	szn	pr4|global_parameters+global_parms.automatic
    000712  0a   001474 6002 00   1122  	tze	POP_TRACE_FRAME_AND_RESUME
                                  1123  
                                  1124  " If the entry point is trace_transactions_$transaction_begin, then skip it.
                                  1125  
    000713  9a  4 00010 1163 00   1126  	cmpq	pr4|TRANSACTION_BEGIN
    000714  0a   001474 6002 00   1127  	tze	POP_TRACE_FRAME_AND_RESUME
                                  1128  
    000715  9a  4 00011 1163 00   1129  	cmpq	pr4|TRANSACTION_BEGIN_FORCE
    000716  0a   001474 6002 00   1130  	tze	POP_TRACE_FRAME_AND_RESUME
                                  1131  
                                  1132  " call trace_entrypoints_$add_entrypoint (event+event.entry_ptr, pr2);
                                  1133  
    000717  0a   003306 2372 00   1134  	ldaq	two_arg_list_header
    000720  aa  6 00100 7573 00   1135  	staq	arg_list.header
    000721  aa  6 00117 3503 00   1136  	epp0	event+event.entry_ptr
    000722  aa  6 00102 2503 00   1137  	spri0	arg_list.first_arg_ptr
    000723  aa  6 00124 3503 00   1138  	epp0	event+event.entry_idx
    000724  aa  6 00104 2503 00   1139  	spri0	arg_list.second_arg_ptr
                                  1140  
    000725  aa  6 00000 2543 00   1141  	call	trace_entrypoints_$add_entrypoint(arg_list.header)
    000726  aa  6 00100 3503 00
    000727  4a  4 00350 3523 20
    000730  aa  6 00040 7533 00
    000731  aa  7 00036 6703 20
    000732  aa  6 00000 1733 00
    000733  aa  6 00040 0733 00
                                  1142  
    000734  aa  6 00124 7223 00   1143  	lxl2	event+event.entry_idx
    000735  0a   001474 6042 00   1144  	tmi	POP_TRACE_FRAME_AND_RESUME
                                  1145  
    000736  9a  4 00054 3517 20   1146  	epp1	pr4|tt_ptr,*
    000737  aa  1 00000 2373 00   1147  	ldaq	pr1|table.version
    000740  0a   003264 1172 00   1148  	cmpaq	TT_VERSION_3
    000741  4a  4 00406 6013 20   1149  	tnz	trace_error_halt_$trace_error_halt_
                                  1150  
                                  1151  	index_table
    000742  aa   000000 6352 12         	eaa	0,x2
    000743  aa   000022 7312 00         	ars	18
    000744  4a  4 00410 6043 20         	tmi	trace_error_halt_$table_index_oob
    000745  aa  1 00004 1153 00         	cmpa	pr1|table.idx+idx.low	" If table_index - idx.low > 0,
    000746  0a   000752 6052 00         	tpl	INDEX_HIGH.._00011	" then get it from the high half.
    000747  aa   000001 7352 00         	als	1
    000750  aa  1 00010 3523 05         	epp2	pr1|table.e,al
    000751  0a   000760 7102 00         	tra	INDEX_DONE.._00011
    000752                              INDEX_HIGH.._00011:
    000752  aa  1 00004 1753 00         	sba	pr1|table.idx+idx.low
    000753  aa  1 00005 0753 00         	ada	pr1|table.idx+idx.high	" Q = array_index - idx.low + idx.high;
    000754  aa  1 00002 1153 00         	cmpa	pr1|table.max_count
    000755  4a  4 00410 6053 20         	tpl	trace_error_halt_$table_index_oob
    000756  aa   000001 7352 00         	als	1
    000757  aa  1 00010 3523 05         	epp2	pr1|table.e,al
    000760                              INDEX_DONE.._00011:
                                  1152  
    000760  aa  2 00001 7623 00   1153  	lprp2	pr2|te.data
    000761  0a   001103 7102 00   1154  	tra	HAVE_TAB
                                  1155  
    000762                        1156  THIS_IS_A_SIGNAL:
                                  1157  
    000762  9a  4 00066 2343 00   1158  	szn	pr4|global_parameters+global_parms.meter
    000763  0a   001474 6012 00   1159  	tnz	POP_TRACE_FRAME_AND_RESUME
                                  1160  
    000764  9a  4 00067 2343 00   1161  	szn	pr4|global_parameters+global_parms.signals
    000765  0a   001474 6002 00   1162  	tze	POP_TRACE_FRAME_AND_RESUME		" Never trace signal_ as a procedure.
                                  1163  
                                  1164  
    000766                        1165  TRACE_THIS_SIGNAL:
                                  1166  	fill_event_for_trace_or_signal
    000766  0a   003262 2352 00         	lda	EVENT_VERSION_3
    000767  aa  6 00110 7553 00         	sta	event+event.version
    000770  aa  6 00136 7203 00         	lxl0	trace_frames_saved+trace_frames.count
    000771  aa  6 00111 4403 00         	sxl0	event+event.frame_count
                                        
    000772  aa  6 00060 3503 20         	epp0	ptr_registers_saved+2*0,*	" This is where PR0 was saved.
    000773  aa  6 00125 5403 00         	sprp0	event+event.arg_list_ptr
    000774  aa  6 00000 3503 00         	epp0	pr6|0
    000775  aa  0 00020 3503 20         	epp0	pr0|stack_frame.prev_sp,*	" Pointer to caller's stack frame.
    000776  aa  0 00020 2353 00         	lda	pr0|stack_frame.flag_word
    000777  aa   000200 3752 07         	ana	stack_frame.support_bit,dl
    001000  0a   000775 6012 00         	tnz	*-3			" Skip support frames.
    001001  aa  6 00126 5403 00         	sprp0	event+event.callers_sp
    001002  aa  0 00024 3503 20         	epp0	pr0|stack_frame.return_ptr,*	" Pointer to caller's return point.
    001003  aa  6 00127 5403 00         	sprp0	event+event.return_ptr
                                  1167  
                                  1168  	call_trace_routine_or_buffer pr6,si
                                        
                                        " call global_parameters.print_routine (event);
                                        " dcl  global_parameters.print_routine entry (1 like event aligned);
                                        
    001004  aa   163151 2202 03         	ldx0	=2asi,du
    001005  aa  6 00111 7403 00         	stx0	pr6|event+event.kind
                                        
    001006  9a  4 00326 2353 00         	lda	pr4|global_parameters+global_parms.buffer_ptr
    001007  0a   003340 1152 00         	cmpa	packed_null
    001010  0a   001060 6002 00         	tze	CALL_TRACE_PRINT.._00012
    001011  9a  4 00326 7613 00         	lprp1	pr4|global_parameters+global_parms.buffer_ptr
    001012  aa  1 00000 2373 00         	ldaq	pr1|buffer.h.version
    001013  0a   003260 1172 00         	cmpaq	BUFFER_VERSION_3
    001014  4a  4 00406 6013 20         	tnz	trace_error_halt_$trace_error_halt_
    001015  aa  1 00003 2353 00         	lda	pr1|buffer.h.count
    001016  aa  1 00003 0543 00         	aos	pr1|buffer.h.count
    001017  aa   017777 3752 07         	ana	=o017777,dl		" mod 8192
    001020  aa   000004 7352 00         	als	4			" 16 words per event.
    001021  aa  1 00004 3517 05         	epp1	pr1|buffer.e,al		" pr1 -> buffer entry
    001022  aa  0 00100 1007 00         	mlr	(pr),(pr)
    001023  aa   600110 000070          	desc9a	pr6|event,(event_size-2)*4
    001024  aa   100000 000070          	desc9a	pr1|0,(event_size-2)*4
    001025  9a  4 00022 2373 00         	ldaq	pr4|stop+meters.real_time
    001026  aa  1 00016 7573 00         	staq	pr1|event_size-2		" Put clock reading in last two words.
    001027  aa   000100 1006 00         	mlr	(),(pr)			" Initialize so we can punt fast.
    001030  0a   003274 000030          	desc9a	UNUSUAL_SIGNAL_ARG_LIST,24	" "Unusual signal_ arg list"
    001031  aa   100010 000030          	desc9a	pr1|event.saved,24		" 24 is from event.saved to the clock.
    001032  aa  6 00060 3503 20         	epp0	pr6|ptr_registers_saved+2*0,*	" PR0 -> argument list header.
    001033  aa  0 00000 7203 00         	lxl0	pr0|0			" If arg_list.header.call_type
    001034  aa   000004 1002 03         	cmpx0	4,du			" ^= Interseg_call_type
    001035  0a   001102 6012 00         	tnz	SKIP_TRACE_PRINT.._00012	" then punt.
    001036  aa  0 00001 2203 00         	ldx0	pr0|1			" If arg_list.header.desc_count
    001037  aa   000002 1002 03         	cmpx0	2,du			" < 1
    001040  0a   001102 6042 00         	tmi	SKIP_TRACE_PRINT.._00012	" then punt.
    001041  aa  0 00000 2203 00         	ldx0	pr0|0			" If arg_list.header.arg_count
    001042  aa   000002 1002 03         	cmpx0	2,du			" < 1
    001043  0a   001102 6042 00         	tmi	SKIP_TRACE_PRINT.._00012	" then punt.
    001044  aa  0 00002 2353 30         	lda	pr0|2,x0*			" A = descriptor
    001045  aa   000001 7352 00         	als	1			" Bit bucket = arg_descriptor.flag
    001046  aa   000031 7732 00         	lrl	25
    001047  aa   000005 7712 00         	arl	5			" A = arg_descriptor.type
    001050  aa   000025 1152 07         	cmpa	21,dl			" If arg_descriptor.type ^= char_dtype
    001051  0a   001102 6012 00         	tnz	SKIP_TRACE_PRINT.._00012	" then punt.
    001052  aa   000014 7722 00         	qrl	12			" Q = arg_descriptor.size
    001053  aa  0 00002 3503 20         	epp0	pr0|2,*			" PR0 -> signal name.
    001054  aa  0 40100 1007 40         	mlr	(pr,rl),(pr),fill(040)
    001055  aa   000000 000006          	desc9a	pr0|0,ql
    001056  aa   100010 000030          	desc9a	pr1|event.saved,24		" 24 is from event.saved to the clock.
    001057  0a   001102 7102 00         	tra	SKIP_TRACE_PRINT.._00012
                                        
    001060                              CALL_TRACE_PRINT.._00012:
    001060  0a   003304 2372 00         	ldaq	one_arg_list_header		" call trace_print_$trace (event);
    001061  aa  6 00100 7573 00         	staq	arg_list.header
    001062  9a  4 00316 2373 00         	ldaq	pr4|global_parameters+global_parms.trace_routine+2 " Environment ptr.
    001063  aa  6 00104 7573 00         	staq	arg_list.second_arg_ptr
    001064  0a   003330 6772 00         	eraq	null_ptr
    001065  0a   003332 3772 00         	anaq	ptr_mask
    001066  0a   001071 6002 00         	tze	*+3
    001067  0a   003316 2372 00         	ldaq	one_arg_list_header_w_env
    001070  aa  6 00100 7573 00         	staq	arg_list.header
    001071  aa  6 00110 3503 00         	epp0	pr6|event
    001072  aa  6 00102 2503 00         	spri0	arg_list.first_arg_ptr
                                        
    001073  aa  6 00000 2543 00         	call	pr4|global_parameters+global_parms.trace_routine,*(arg_list.header)
    001074  aa  6 00100 3503 00
    001075  9a  4 00314 3523 20
    001076  aa  6 00040 7533 00
    001077  aa  7 00036 6703 20
    001100  aa  6 00000 1733 00
    001101  aa  6 00040 0733 00
    001102                              SKIP_TRACE_PRINT.._00012:
                                  1169  
    001102  0a   001474 7102 00   1170  	tra	POP_TRACE_FRAME_AND_RESUME		" Never trace signal_ as a procedure.
                                  1171  
    001103                        1172  HAVE_TAB:
    001103  aa  2 00000 2373 00   1173  	ldaq	pr2|tab.version
    001104  0a   003266 1172 00   1174  	cmpaq	TAB_VERSION_3
    001105  4a  4 00406 6013 20   1175  	tnz	trace_error_halt_$trace_error_halt_
                                  1176  
                                  1177  " Save the old counts before we start modifying them.
                                  1178  
    001106  aa  2 00004 2373 00   1179  	ldaq	pr2|tab.cts
    001107  aa  6 00120 7573 00   1180  	staq	event+event.saved
    001110  aa  2 00006 2373 00   1181  	ldaq	pr2|tab.cts+2
    001111  aa  6 00122 7573 00   1182  	staq	event+event.saved+2
                                  1183  
                                  1184  " Count this entry whether we trace it or not.
                                  1185  
    001112  aa  2 00004 2373 00   1186  	ldaq	pr2|tab.cts+counts.calls
    001113  aa   000001 0332 07   1187  	adl	1,dl
    001114  aa  2 00004 7573 00   1188  	staq	pr2|tab.cts+counts.calls
                                  1189  
                                  1190  " See if this entrypoint is traceable.
                                  1191  
                                  1192  	is_tracing_permitted	POP_TRACE_FRAME_AND_RESUME
                                        " Is tracing this entry point permitted?
                                        
    001115  aa  2 00023 2353 00         	lda	pr2|tab.translator_id	" If tab.translator_id < 0,
    001116  0a   001474 6042 00         	tmi	POP_TRACE_FRAME_AND_RESUME		" then this program can't be traced.
    001117  9a  4 00064 2343 00         	szn	pr4|global_parameters+global_parms.alm
    001120  0a   001123 6012 00         	tnz	*+3
    001121  aa   000001 1152 07         	cmpa	1,dl			" If tab.translator_id = ALM
    001122  0a   001474 6002 00         	tze	POP_TRACE_FRAME_AND_RESUME		" then don't trace.
                                        
    001123  aa  2 00015 2343 00         	szn	pr2|tab.on		" If this entrypoint is -off,
    001124  0a   001474 6002 00         	tze	POP_TRACE_FRAME_AND_RESUME		" then don't trace it.
                                  1193  
                                  1194  " Calculate the recursion level and maximum recursion level.
                                  1195  
    001125  aa  2 00006 2353 00   1196  	lda	pr2|tab.cts+counts.level
    001126  aa   000001 0752 07   1197  	ada	1,dl
    001127  aa  2 00006 7553 00   1198  	sta	pr2|tab.cts+counts.level
    001130  aa  2 00007 1153 00   1199  	cmpa	pr2|tab.cts+counts.max_level
    001131  0a   001133 6046 00   1200  	tmoz	*+2			" if tab.cts.level - tab.cts.max_level > 0
    001132  aa  2 00007 7553 00   1201  	sta	pr2|tab.cts+counts.max_level	" then tab.cts.max_level = tab.cts.level;
                                  1202  
                                  1203  " Initialize some values used by the cleanup handler.
                                  1204  
    001133  aa   000110 7372 00   1205  	lls	72			" Initialize the meters.
    001134  aa  6 00112 7573 00   1206  	staq	event+event.frame.real_time
    001135  aa  6 00114 7573 00   1207  	staq	event+event.frame.vcpu_time
    001136  aa  6 00116 4503 00   1208  	stz	event+event.frame.page_faults
    001137  aa  6 00140 7573 00   1209  	staq	global_start.real_time
    001140  aa  6 00142 7573 00   1210  	staq	global_start.vcpu_time
    001141  aa  6 00144 4503 00   1211  	stz	global_start.page_faults
                                  1212  
                                  1213  " Turn on the full cleanup handler now.
                                  1214  
    001142  0a   002276 3502 00   1215  	epp0	TRACE_CATCH_CLEANUP
    001143  aa  6 00132 2503 00   1216  	spri0	cleanup_unit+on_unit.body
                                  1217  
                                  1218  " Push this frame onto the stack of trace_catch_ frames.
                                  1219  
    001144  aa  7 00072 0543 00   1220  	aos	pr7|stack_header.trace_frames+trace_frames.count
    001145  aa  7 00073 5463 00   1221  	sprp6	pr7|stack_header.trace_frames+trace_frames.top_ptr
                                  1222  
                                  1223  " If we are not just metering, call the procedure that prints the tracing message.
                                  1224  
                                  1225  	fill_event_for_trace_or_signal
    001146  0a   003262 2352 00         	lda	EVENT_VERSION_3
    001147  aa  6 00110 7553 00         	sta	event+event.version
    001150  aa  6 00136 7203 00         	lxl0	trace_frames_saved+trace_frames.count
    001151  aa  6 00111 4403 00         	sxl0	event+event.frame_count
                                        
    001152  aa  6 00060 3503 20         	epp0	ptr_registers_saved+2*0,*	" This is where PR0 was saved.
    001153  aa  6 00125 5403 00         	sprp0	event+event.arg_list_ptr
    001154  aa  6 00000 3503 00         	epp0	pr6|0
    001155  aa  0 00020 3503 20         	epp0	pr0|stack_frame.prev_sp,*	" Pointer to caller's stack frame.
    001156  aa  0 00020 2353 00         	lda	pr0|stack_frame.flag_word
    001157  aa   000200 3752 07         	ana	stack_frame.support_bit,dl
    001160  0a   001155 6012 00         	tnz	*-3			" Skip support frames.
    001161  aa  6 00126 5403 00         	sprp0	event+event.callers_sp
    001162  aa  0 00024 3503 20         	epp0	pr0|stack_frame.return_ptr,*	" Pointer to caller's return point.
    001163  aa  6 00127 5403 00         	sprp0	event+event.return_ptr
                                  1226  
                                  1227  	trace_and_stop_if_necessary	pr6,ca
                                        
    001164  9a  4 00066 2343 00         	szn	pr4|global_parameters+global_parms.meter
    001165  0a   001443 6012 00         	tnz	DONT_CALL_ANYTHING.._00013
                                        
    001166  aa  2 00003 2353 00         	lda	pr2|tab.parms_ptr
    001167  0a   003340 1152 00         	cmpa	packed_null		" If this entrypoint has been removed,
    001170  0a   001443 6002 00         	tze	DONT_CALL_ANYTHING.._00013	" then don't trace it.
                                        
    001171  aa  2 00015 2343 00         	szn	pr2|tab.on		" If this entrypoint is -off,
    001172  0a   001443 6002 00         	tze	DONT_CALL_ANYTHING.._00013	" then don't trace it.
                                        
    001173  9a  4 00064 2343 00         	szn	pr4|global_parameters+global_parms.alm
    001174  0a   001200 6012 00         	tnz	*+4
    001175  aa  2 00023 2353 00         	lda	pr2|tab.translator_id
    001176  aa   000001 1152 07         	cmpa	1,dl			" If tab.translator_id = ALM
    001177  0a   001443 6002 00         	tze	DONT_CALL_ANYTHING.._00013	" then don't trace.
                                        
    001200                              	inhibit	off		" <-> <-> <-> <-> <-> <-> <-> <-> <->
    001200  aa  2 00003 7631 00         	lprp3	pr2|tab.parms_ptr		" pr3 = tab.parms_ptr;
    001201  aa  3 00000 2371 00         	ldaq	pr3|parms.version
    001202  0a   003270 1170 00         	cmpaq	PARAMETERS_VERSION_3
    001203  4a  4 00406 6011 20         	tnz	trace_error_halt_$trace_error_halt_
                                        
    001204  aa  3 00016 2351 00         	lda	pr3|parms.trace		" Check inout.
    001205  0a   001315 6050 00         	tpl	CHECK_WATCH_TABLE.._00013
                                        
    001206  aa  6 00120 2371 00         	ldaq	pr6|event+event.saved.calls
    001207  aa   000001 0330 07         	adl	1,dl			" Get current count.
    001210  aa  6 00100 7571 00         	staq	arg_list.header		" Save in strange temporary.
                                        
    001211  aa  3 00003 2341 00         	szn	pr3|parms.every		" Is this parameter active?
    001212  0a   001223 6000 00         	tze	CHECK_FIRST.._00013
                                        
    001213  aa   000042 7330 00         	lrs	34			" If mod (call_count, tab.every) ^= 0
    001214  aa  3 00003 5071 00         	dvf	pr3|parms.every		" then don't trace.
    001215  aa   000044 7370 00         	lls	36
    001216  aa  6 00101 2361 00         	ldq	arg_list.header+1		" Actually counts.calls+1.
    001217  aa   000001 7360 00         	qls	1
    001220  aa  3 00003 5071 00         	dvf	pr3|parms.every		" Q = mod (saved calls, tab.every);
    001221  aa   000000 7320 00         	qrs	0			" Set indicators from register Q.
    001222  0a   001315 6010 00         	tnz	CHECK_WATCH_TABLE.._00013
                                        
    001223                              CHECK_FIRST.._00013:
    001223  aa  6 00100 3371 00         	lcaq	arg_list.header		" Actually counts.calls.
    001224  aa  3 00004 0331 00         	adl	pr3|parms.first		" If tab.first - saved calls > 0
    001225  0a   001315 6054 00         	tpnz	CHECK_WATCH_TABLE.._00013	" then don't trace.
                                        
    001226  aa  3 00005 2341 00         	szn	pr3|parms.last
    001227  0a   001233 6000 00         	tze	*+4			" -last 0 means it is diasbled.
    001230  aa  6 00100 3371 00         	lcaq	arg_list.header		" Actually counts.calls.
    001231  aa  3 00005 0331 00         	adl	pr3|parms.last		" If parms.last - saved calls < 0
    001232  0a   001315 6040 00         	tmi	CHECK_WATCH_TABLE.._00013	" then don't trace.
                                        
    001233  aa  6 00122 2351 00         	lda	pr6|event+event.saved.level
    001234  aa   000001 0750 07         	ada	1,dl			" Get current level.
    001235  aa  3 00006 1151 00         	cmpa	pr3|parms.low		" If level - parms.low < 0
    001236  0a   001315 6040 00         	tmi	CHECK_WATCH_TABLE.._00013	" then don't trace.
                                        
    001237  aa  3 00007 2341 00         	szn	pr3|parms.high
    001240  0a   001243 6000 00         	tze	*+3			" -high 0 means it is diasbled.
    001241  aa  3 00007 1151 00         	cmpa	pr3|parms.high		" If level - parms.high > 0
    001242  0a   001315 6054 00         	tpnz	CHECK_WATCH_TABLE.._00013	" then don't trace.
                                        
    001243  aa  3 00010 2341 00         	szn	pr3|parms.new_high		" If -new_high is off
    001244  0a   001247 6000 00         	tze	*+3			" then skip this check.
    001245  aa  6 00123 1151 00         	cmpa	pr6|event+event.saved.max_level
    001246  0a   001315 6044 00         	tmoz	CHECK_WATCH_TABLE.._00013	" then don't trace.
                                        
                                        	call_trace_routine_or_buffer pr6,ca
                                        
                                        " call global_parameters.print_routine (event);
                                        " dcl  global_parameters.print_routine entry (1 like event aligned);
                                        
    001247  aa   143141 2200 03         	ldx0	=2aca,du
    001250  aa  6 00111 7401 00         	stx0	pr6|event+event.kind
                                        
    001251  9a  4 00326 2351 00         	lda	pr4|global_parameters+global_parms.buffer_ptr
    001252  0a   003340 1150 00         	cmpa	packed_null
    001253  0a   001273 6000 00         	tze	CALL_TRACE_PRINT.._00014
    001254  9a  4 00326 7611 00         	lprp1	pr4|global_parameters+global_parms.buffer_ptr
    001255  aa  1 00000 2371 00         	ldaq	pr1|buffer.h.version
    001256  0a   003260 1170 00         	cmpaq	BUFFER_VERSION_3
    001257  4a  4 00406 6011 20         	tnz	trace_error_halt_$trace_error_halt_
    001260  aa  1 00003 2351 00         	lda	pr1|buffer.h.count
    001261  aa  1 00003 0541 00         	aos	pr1|buffer.h.count
    001262  aa   017777 3750 07         	ana	=o017777,dl		" mod 8192
    001263  aa   000004 7350 00         	als	4			" 16 words per event.
    001264  aa  1 00004 3515 05         	epp1	pr1|buffer.e,al		" pr1 -> buffer entry
    001265  aa  0 00100 1005 00         	mlr	(pr),(pr)
    001266  aa   600110 000070          	desc9a	pr6|event,(event_size-2)*4
    001267  aa   100000 000070          	desc9a	pr1|0,(event_size-2)*4
    001270  9a  4 00022 2371 00         	ldaq	pr4|stop+meters.real_time
    001271  aa  1 00016 7571 00         	staq	pr1|event_size-2		" Put clock reading in last two words.
    001272  0a   001315 7100 00         	tra	SKIP_TRACE_PRINT.._00014
                                        
    001273                              CALL_TRACE_PRINT.._00014:
    001273  0a   003304 2370 00         	ldaq	one_arg_list_header		" call trace_print_$trace (event);
    001274  aa  6 00100 7571 00         	staq	arg_list.header
    001275  9a  4 00316 2371 00         	ldaq	pr4|global_parameters+global_parms.trace_routine+2 " Environment ptr.
    001276  aa  6 00104 7571 00         	staq	arg_list.second_arg_ptr
    001277  0a   003330 6770 00         	eraq	null_ptr
    001300  0a   003332 3770 00         	anaq	ptr_mask
    001301  0a   001304 6000 00         	tze	*+3
    001302  0a   003316 2370 00         	ldaq	one_arg_list_header_w_env
    001303  aa  6 00100 7571 00         	staq	arg_list.header
    001304  aa  6 00110 3501 00         	epp0	pr6|event
    001305  aa  6 00102 2501 00         	spri0	arg_list.first_arg_ptr
                                        
    001306  aa  6 00000 2541 00         	call	pr4|global_parameters+global_parms.trace_routine,*(arg_list.header)
    001307  aa  6 00100 3501 00
    001310  9a  4 00314 3521 20
    001311  aa  6 00040 7531 00
    001312  aa  7 00036 6701 20
    001313  aa  6 00000 1731 00
    001314  aa  6 00040 0731 00
    001315                              SKIP_TRACE_PRINT.._00014:
                                        	
    001315                              CHECK_WATCH_TABLE.._00013:
                                        
                                        	check_or_update_watch_table	pr6,check
    001315  aa  6 00146 4501 00         	stz	pr6|watch_values_changed
                                        
    001316  9a  4 00056 3515 20         	epp1	pr4|wt_ptr,*		" Pr1 points to the table header.
    001317  aa  1 00000 2371 00         	ldaq	pr1|table.version
    001320  0a   003264 1170 00         	cmpaq	TT_VERSION_3
    001321  4a  4 00406 6011 20         	tnz	trace_error_halt_$trace_error_halt_
                                        
    001322  aa  1 00003 7201 00         	lxl0	pr1|table.count
    001323                              WATCH_TABLE_LOOP.._00015:
    001323  aa   777777 6200 10         	eax0	-1,x0
    001324  0a   001342 6040 00         	tmi	WATCH_TABLE_DONE.._00015
    001325  aa   000000 6350 10         	eaa	0,x0
    001326  aa   000022 7310 00         	ars	18
    001327  aa  1 00004 1151 00         	cmpa	pr1|table.idx+idx.low	" if idx - idx.low < 0
    001330  0a   001333 6040 00         	tmi	*+3			" then actual_idx = idx;
    001331  aa  1 00004 1751 00         	sba	pr1|table.idx+idx.low	" else actual_idx = idx - idx.low
    001332  aa  1 00005 0751 00         	ada	pr1|table.idx+idx.high	" + idx.high;
    001333  aa   000001 7350 00         	als	1
    001334  aa  1 00010 7601 05         	lprp0	pr1|table.e+te.key,al
    001335  aa  0 00000 2361 00         	ldq	pr0|0
    001336  aa  1 00011 1161 05         	cmpq	pr1|table.e+te.data,al
    001337  0a   001323 6000 00         	tze	WATCH_TABLE_LOOP.._00015
    001340  aa   400000 6350 00         	eaa	TRUE
    001341  aa  6 00146 7551 00         	sta	pr6|watch_values_changed
    001342                              WATCH_TABLE_DONE.._00015:
                                        
    001342  aa  6 00146 2341 00         	szn	pr6|watch_values_changed
    001343  0a   001367 6010 00         	tnz	STOP_IT.._00013
                                        
    001344  aa  3 00015 2351 00         	lda	pr3|parms.stop
    001345  0a   001443 6050 00         	tpl	DONT_CALL_ANYTHING.._00013
                                        
    001346  aa  6 00120 2371 00         	ldaq	pr6|event+event.saved.calls
    001347  aa   000001 0330 07         	adl	1,dl			" Get real counts.calls.
    001350  aa  6 00100 7571 00         	staq	arg_list.header		" Use this as a temporary.
                                        
    001351  aa  3 00013 2341 00         	szn	pr3|parms.stop_every	" Is this parameter active?
    001352  0a   001363 6000 00         	tze	CHECK_STOP_LOW.._00013
                                        
    001353  aa   000042 7330 00         	lrs	34			" If mod (call_count, tab.every) ^= 0
    001354  aa  3 00013 5071 00         	dvf	pr3|parms.stop_every	" then don't stop.
    001355  aa   000044 7370 00         	lls	36
    001356  aa  6 00101 2361 00         	ldq	arg_list.header+1		" Actually counts.calls+1.
    001357  aa   000001 7360 00         	qls	1
    001360  aa  3 00013 5071 00         	dvf	pr3|parms.stop_every	" Q = mod (saved calls, tab.every);
    001361  aa   000000 7320 00         	qrs	0			" Set indicators from register Q.
    001362  0a   001443 6010 00         	tnz	DONT_CALL_ANYTHING.._00013
                                        
    001363                              CHECK_STOP_LOW.._00013:
    001363  aa  6 00122 2351 00         	lda	pr6|event+event.saved.level
    001364  aa   000001 0750 07         	ada	1,dl			" Get current level.
    001365  aa  3 00014 1151 00         	cmpa	pr3|parms.stop_low		" If level - parms.stop_low < 0
    001366  0a   001443 6040 00         	tmi	DONT_CALL_ANYTHING.._00013	" then don't stop.
                                        
    001367                              STOP_IT.._00013:
                                        
                                        	call_stop_routine pr6,ca
                                        
                                        " call global_parameters.stop_routine (event, watch_values_changed);
                                        " dcl  global_parameters.stop_routine entry (1 like event aligned, bit aligned);
                                        
    001367  aa   143141 2200 03         	ldx0	=2aca,du
    001370  aa  6 00111 7401 00         	stx0	pr6|event+event.kind
                                        
    001371  0a   003306 2370 00         	ldaq	two_arg_list_header
    001372  aa  6 00100 7571 00         	staq	arg_list.header
    001373  9a  4 00322 2371 00         	ldaq	pr4|global_parameters+global_parms.stop_routine+2 " Environment ptr.
    001374  aa  6 00106 7571 00         	staq	arg_list.third_arg_ptr
    001375  0a   003330 6770 00         	eraq	null_ptr
    001376  0a   003332 3770 00         	anaq	ptr_mask
    001377  0a   001402 6000 00         	tze	*+3
    001400  0a   003320 2370 00         	ldaq	two_arg_list_header_w_env
    001401  aa  6 00100 7571 00         	staq	arg_list.header
    001402  aa  6 00110 3501 00         	epp0	pr6|event
    001403  aa  6 00102 2501 00         	spri0	arg_list.first_arg_ptr
    001404  aa  6 00146 3501 00         	epp0	pr6|watch_values_changed
    001405  aa  6 00104 2501 00         	spri0	arg_list.second_arg_ptr
                                        
    001406  aa  6 00000 2541 00         	call	pr4|global_parameters+global_parms.stop_routine,*(arg_list.header)
    001407  aa  6 00100 3501 00
    001410  9a  4 00320 3521 20
    001411  aa  6 00040 7531 00
    001412  aa  7 00036 6701 20
    001413  aa  6 00000 1731 00
    001414  aa  6 00040 0731 00
                                        
                                        	check_or_update_watch_table	pr6,update
    001415  aa  6 00146 2341 00         	szn	pr6|watch_values_changed
    001416  0a   001443 6000 00         	tze	WATCH_TABLE_DONE.._00016
                                        
    001417  9a  4 00056 3515 20         	epp1	pr4|wt_ptr,*		" Pr1 points to the table header.
    001420  aa  1 00000 2371 00         	ldaq	pr1|table.version
    001421  0a   003264 1170 00         	cmpaq	TT_VERSION_3
    001422  4a  4 00406 6011 20         	tnz	trace_error_halt_$trace_error_halt_
                                        
    001423  aa  1 00003 7201 00         	lxl0	pr1|table.count
    001424                              WATCH_TABLE_LOOP.._00016:
    001424  aa   777777 6200 10         	eax0	-1,x0
    001425  0a   001443 6040 00         	tmi	WATCH_TABLE_DONE.._00016
    001426  aa   000000 6350 10         	eaa	0,x0
    001427  aa   000022 7310 00         	ars	18
    001430  aa  1 00004 1151 00         	cmpa	pr1|table.idx+idx.low	" if idx - idx.low < 0
    001431  0a   001434 6040 00         	tmi	*+3			" then actual_idx = idx;
    001432  aa  1 00004 1751 00         	sba	pr1|table.idx+idx.low	" else actual_idx = idx - idx.low
    001433  aa  1 00005 0751 00         	ada	pr1|table.idx+idx.high	" + idx.high;
    001434  aa   000001 7350 00         	als	1
    001435  aa  1 00010 7601 05         	lprp0	pr1|table.e+te.key,al
    001436  aa  0 00000 2361 00         	ldq	pr0|0
    001437  aa  1 00011 1161 05         	cmpq	pr1|table.e+te.data,al
    001440  0a   001424 6000 00         	tze	WATCH_TABLE_LOOP.._00016
    001441  aa  1 00011 7561 05         	stq	pr1|table.e+te.data,al
    001442  0a   001424 7100 00         	tra	WATCH_TABLE_LOOP.._00016
    001443                              WATCH_TABLE_DONE.._00016:
                                        
    001443                              	inhibit	on		" <+> <+> <+> <+> <+> <+> <+> <+> <+>
    001443                              DONT_CALL_ANYTHING.._00013:
                                  1228  
                                  1229  " Start the global meters for this procedure if this is the first level of recursion.
                                  1230  
                                  1231  	start_global_metering_interval	pr6
                                        
    001443  aa  6 00122 2353 00         	lda	pr6|event+event.saved.level	" Only start global meters
    001444  0a   001454 6056 00         	tpnz	GLOBAL_INTERVAL_STARTED.._00017	" at recursion level 1.
    001445  4a  4 00406 6043 20         	tmi	trace_error_halt_$trace_error_halt_
                                        
    001446  9a  4 00042 2353 00         	lda	pr4|metered+meters.page_faults
    001447  aa  6 00144 7553 00         	sta	pr6|global_start.page_faults
                                        
    001450  9a  4 00040 2373 00         	ldaq	pr4|metered+meters.vcpu_time
    001451  aa  6 00142 7573 00         	staq	pr6|global_start.vcpu_time
                                        
    001452  9a  4 00036 2373 00         	ldaq	pr4|metered+meters.real_time	" Store this one last because it shows
    001453  aa  6 00140 7573 00         	staq	pr6|global_start.real_time " that the others are valid.
                                        
    001454                              GLOBAL_INTERVAL_STARTED.._00017:
                                  1232  
                                  1233  " Start the metering interval.
                                  1234  
                                  1235  	start_metering_interval	entry
    001454  8a   000330 6242 00         	eax4	global_parameters+global_parms.comps+from_entry
    001455  9a  4 00021 7443 00         	stx4	pr4|start_comp		" Remember which compensations to use.
                                        
                                        	read_vcpu_time_and_page_faults	start
                                        
    001456  aa  6 00024 3573 00         	stcd	pr6|stack_frame.return_ptr
    001457  4a  4 00354 7133 20         	call6	cpu_time_and_paging_op_$cpu_time_and_paging_op_
                                        
    001460  aa  6 00000 3733 00         	epbp7	pr6|0
    001461  aa  6 00030 3703 20         	epp4	pr6|stack_frame.lp_ptr,*
    001462  9a  4 00016 7573 00         	staq	pr4|start+meters.vcpu_time   " Vcpu time is returned in AQ register.
    001463  9a  4 00020 7403 00         	stx0	pr4|start+meters.page_faults " Page faults are returned in X0 and X1.
    001464  9a  4 00020 4413 00         	sxl1	pr4|start+meters.page_faults
                                        
    001465                              NOTHING_TO_START.._00020:
                                  1236  
                                  1237  " Establish the return point, like the call operator would.
                                  1238  
    001465  0a   001517 3522 00   1239  	epp2	PROCEDURE_RETURN_POINT
    001466  aa  6 00024 2523 00   1240  	spri2	pr6|stack_frame.return_ptr
    001467  aa  6 00025 7543 00   1241  	sti	pr6|stack_frame.return_ptr+1
                                  1242  
                                  1243  " Restore registers.  Ptr_registers_saved pr4 and pr6 contain trace_catch_'s lp and sp.
                                  1244  
    001470  aa  6 00060 1733 00   1245  	lpri	ptr_registers_saved
    001471  aa  6 00050 0733 00   1246  	lreg	registers_saved
    001472  aa  6 00145 6343 00   1247  	ldi	indicators_saved
    001473  0a   001512 7102 00   1248  	tra	RESUME_ENTRY_OPERATOR
                                  1249  
                                  1250  " Control comes here when the entry point cannot be traced.
                                  1251  
    001474                        1252  POP_TRACE_FRAME_AND_RESUME:
                                  1253  	start_metering_interval	entry
    001474  8a   000330 6242 00         	eax4	global_parameters+global_parms.comps+from_entry
    001475  9a  4 00021 7443 00         	stx4	pr4|start_comp		" Remember which compensations to use.
                                        
                                        	read_vcpu_time_and_page_faults	start
                                        
    001476  aa  6 00024 3573 00         	stcd	pr6|stack_frame.return_ptr
    001477  4a  4 00354 7133 20         	call6	cpu_time_and_paging_op_$cpu_time_and_paging_op_
                                        
    001500  aa  6 00000 3733 00         	epbp7	pr6|0
    001501  aa  6 00030 3703 20         	epp4	pr6|stack_frame.lp_ptr,*
    001502  9a  4 00016 7573 00         	staq	pr4|start+meters.vcpu_time   " Vcpu time is returned in AQ register.
    001503  9a  4 00020 7403 00         	stx0	pr4|start+meters.page_faults " Page faults are returned in X0 and X1.
    001504  9a  4 00020 4413 00         	sxl1	pr4|start+meters.page_faults
                                        
    001505                              NOTHING_TO_START.._00021:
                                  1254  
                                  1255  " Restore registers.  Ptr_registers_saved pr4 and pr6 contain trace_catch_'s lp and sp.
                                  1256  
    001505  aa  6 00060 1733 00   1257  	lpri	ptr_registers_saved
    001506  aa  6 00050 0733 00   1258  	lreg	registers_saved
    001507  aa  6 00145 6343 00   1259  	ldi	indicators_saved
                                  1260  
                                  1261  " Pop our stack frame.
                                  1262  
    001510  aa  7 00024 6523 00   1263  	spri6	pr7|stack_header.stack_end_ptr
    001511  aa  6 00020 3723 20   1264  	epp6	pr6|stack_frame.prev_sp,*
                                  1265  
    001512                        1266  RESUME_ENTRY_OPERATOR:
                                  1267  
                                  1268  " Restore two words at stack end that were saved with the registers for the entry operator.
                                  1269  
    001512  aa  7 00024 7573 20   1270  	staq	pr7|stack_header.stack_end_ptr,*
                                  1271  
                                  1272  " Permit tracing again.
                                  1273  
    001513  aa  7 00074 4503 00   1274  	stz	pr7|stack_header.in_trace
                                  1275  
                                  1276  " We have postponed reading the clock until now for accurate metering.
                                  1277  
                                  1278  	read_the_calendar_clock	start
    001514  4a  4 00352 6333 20         	rccl	sys_info$clock_,*
    001515  9a  4 00014 7573 00         	staq	pr4|start+meters.real_time
                                  1279  
                                  1280  " Resume the entry operator.
                                  1281  
    001516  aa  2 00000 7103 00   1282  	tra	pr2|0
                                  1283  
                                  1284  " Control comes to this label when the procedure being traced does a return.
                                  1285  
    001517                        1286  PROCEDURE_RETURN_POINT:
                                  1287  
                                  1288  " First priority is reading the clock for accurate metering.
                                  1289  
    001517  aa  6 00030 3703 20   1290  	epp4	pr6|stack_frame.lp_ptr,*
                                  1291  	read_the_calendar_clock	stop
    001520  4a  4 00352 6333 20         	rccl	sys_info$clock_,*
    001521  9a  4 00022 7573 00         	staq	pr4|stop+meters.real_time
                                  1292  
                                  1293  " Save the cpu registers.
                                  1294  
    001522  aa  6 00060 2543 00   1295  	spri	ptr_registers_saved
    001523  aa  6 00050 7533 00   1296  	sreg	registers_saved
                                  1297  
                                  1298  " Read the meters.
                                  1299  
                                  1300  	read_vcpu_time_and_page_faults	stop
                                        
    001524  aa  6 00024 3573 00         	stcd	pr6|stack_frame.return_ptr
    001525  4a  4 00354 7133 20         	call6	cpu_time_and_paging_op_$cpu_time_and_paging_op_
                                        
    001526  aa  6 00000 3733 00         	epbp7	pr6|0
    001527  aa  6 00030 3703 20         	epp4	pr6|stack_frame.lp_ptr,*
    001530  9a  4 00024 7573 00         	staq	pr4|stop+meters.vcpu_time   " Vcpu time is returned in AQ register.
    001531  9a  4 00026 7403 00         	stx0	pr4|stop+meters.page_faults " Page faults are returned in X0 and X1.
    001532  9a  4 00026 4413 00         	sxl1	pr4|stop+meters.page_faults
                                  1301  
                                  1302  " Prevent recursion in case of calls or errors.  The A register is never zero at this point.
                                  1303  
    001533  aa   400000 6352 00   1304  	eaa	TRUE
    001534  aa  7 00074 7553 00   1305  	sta	pr7|stack_header.in_trace
                                  1306  
                                  1307  " Make sure we are where we think we are.
                                  1308  
    001535  aa  6 00100 5463 00   1309  	sprp6	arg_list.header
    001536  aa  7 00073 2353 00   1310  	lda	pr7|stack_header.trace_frames+trace_frames.top_ptr
    001537  aa  6 00100 1153 00   1311  	cmpa	arg_list.header
    001540  4a  4 00406 6013 20   1312  	tnz	trace_error_halt_$trace_error_halt_
                                  1313  
                                  1314  " Calculate the elapsed meters and store them in this frame.
                                  1315  
                                  1316  	metering_interval_calculations	pr6,return
    001541  9a  4 00014 3373 00         	lcaq	pr4|start+meters.real_time
    001542  0a   001576 6002 00         	tze	INTERVAL_CALCULATED.._00022
                                        
    001543  9a  4 00021 2243 00         	ldx4	pr4|start_comp		" How were they started?
    001544  9a  4 00022 0773 00         	adaq	pr4|stop+meters.real_time	" Calculate elapsed real time.
    001545  4a  4 00406 6043 20         	tmi	trace_error_halt_$trace_error_halt_
    001546  aa  4 00004 1773 14         	sbaq	pr4|to_return.real_time,x4	" Subtract appropriate compensation.
    001547  0a   001551 6052 00         	tpl	*+2			" A negative number would later
    001550  aa   000110 7372 00         	lls	72			" be detected as an inconsistency.
    001551  9a  4 00030 7573 00         	staq	pr4|delta+meters.real_time
                                        
    001552  9a  4 00024 2373 00         	ldaq	pr4|stop+meters.vcpu_time	" Calculate elapsed vcpu time.
    001553  9a  4 00016 1773 00         	sbaq	pr4|start+meters.vcpu_time
    001554  9a  4 00030 1173 00         	cmpaq	pr4|delta+meters.real_time	" Elapsed vcpu time should always be less
    001555  0a   001562 6046 00         	tmoz	*+5			" than or equal to elapsed real time.
    001556  9a  4 00325 2343 00         	szn	pr4|global_parameters+global_parms.calibrate " Don't apply correction
    001557  0a   001562 6012 00         	tnz	*+3			" when determining compensations.
    001560  9a  4 00030 2373 00         	ldaq	pr4|delta+meters.real_time	" If it isn't, use real time instead.
    001561  0a   001563 7102 00         	tra	*+2			" Delta real is already compensated.
    001562  aa  4 00006 1773 14         	sbaq	pr4|to_return.vcpu_time,x4	" Subtract appropriate compensation.
    001563  9a  4 00032 7573 00         	staq	pr4|delta+meters.vcpu_time
                                        
    001564  aa  6 00112 2373 00         	ldaq	pr6|event+event.frame.real_time
    001565  9a  4 00030 0773 00         	adaq	pr4|delta+meters.real_time	" Update frame real time.
    001566  aa  6 00112 7573 00         	staq	pr6|event+event.frame.real_time
                                        
    001567  aa  6 00114 2373 00         	ldaq	pr6|event+event.frame.vcpu_time
    001570  9a  4 00032 0773 00         	adaq	pr4|delta+meters.vcpu_time	" Update frame vcpu time.
    001571  aa  6 00114 7573 00         	staq	pr6|event+event.frame.vcpu_time
                                        
    001572  9a  4 00026 2353 00         	lda	pr4|stop+meters.page_faults
    001573  9a  4 00020 1753 00         	sba	pr4|start+meters.page_faults
    001574  4a  4 00406 6043 20         	tmi	trace_error_halt_$trace_error_halt_
    001575  aa  6 00116 0553 00         	asa	pr6|event+event.frame.page_faults " Update frame page faults.
                                        
    001576                              INTERVAL_CALCULATED.._00022:
    001576  aa   000110 7372 00         	lls	72			" Insure that they are not used again.
    001577  9a  4 00014 7573 00         	staq	pr4|start+meters.real_time
    001600  9a  4 00016 7573 00         	staq	pr4|start+meters.vcpu_time
    001601  9a  4 00020 4503 00         	stz	pr4|start+meters.page_faults
                                  1317  
                                  1318  " Get the tab_ptr, if this entrypoint is still in the trace table.
                                  1319  
    001602  9a  4 00054 3517 20   1320  	epp1	pr4|tt_ptr,*
    001603  aa  1 00000 2373 00   1321  	ldaq	pr1|table.version
    001604  0a   003264 1172 00   1322  	cmpaq	TT_VERSION_3
    001605  4a  4 00406 6013 20   1323  	tnz	trace_error_halt_$trace_error_halt_
                                  1324  
    001606  aa  6 00117 2363 00   1325  	ldq	event+event.entry_ptr		" Q reg contains the value we are looking for.
                                  1326  
                                  1327  	seek_table	EP_IS_IN_TT_AT_RETURN,POP_TRACE_FRAME_AND_RETURN
    001607  aa  1 00005 2353 00         	lda	pr1|table.idx+idx.high
    001610  aa   000001 7352 00         	als	1
    001611  aa  1 00010 3523 05         	epp2	pr1|table.e,al	" Pr2 points to high half.
    001612  aa  1 00002 2353 00         	lda	pr1|table.max_count
    001613  aa  1 00005 1753 00         	sba	pr1|table.idx+idx.high " If table.max_count - idx.high = 0,
    001614  0a   001623 6002 00         	tze	SEEK_LOW.._00023	" then the high half is empty.
    001615  4a  4 00406 6043 20         	tmi	trace_error_halt_$trace_error_halt_
    001616  aa  2 00000 1163 00         	cmpq	pr2|te.key	" If Q - table.e (idx.high) < 0
    001617  0a   001623 6042 00         	tmi	SEEK_LOW.._00023
    001620  0a   001631 6056 00         	tpnz	BINARY_LOOP.._00023
    001621  aa  1 00004 7223 00         	lxl2	pr1|table.idx+idx.low " Good luck.  We found it.
    001622  0a   001663 7102 00         	tra	EP_IS_IN_TT_AT_RETURN
                                        
    001623                              SEEK_LOW.._00023:
    001623  aa  1 00010 3523 00         	epp2	pr1|table.e	" Pr2 points to low half.
    001624  aa  1 00004 2353 00         	lda	pr1|table.idx+idx.low	" A = number of entries in low half.
    001625  0a   001631 6056 00         	tpnz	BINARY_LOOP.._00023	" If A > 0, then do a binary search.
    001626  4a  4 00406 6043 20         	tmi	trace_error_halt_$trace_error_halt_
    001627  aa   000000 6222 00         	eax2	0		" else it's not in the table.
    001630  0a   002235 7102 00         	tra	POP_TRACE_FRAME_AND_RETURN
                                        
                                        " The binary search uses pr2 to point to the group of remaining candidates.
                                        " It uses the A register to contain the number of remaining candidates.
                                        " During the search uses X2 to represent the offset to the middle of the candidates.
                                        
    001631                              BINARY_LOOP.._00023:		" X2 contains offset that divides portion in half,
    001631  aa   777777 6222 05         	eax2	-1,al		" with the upper division being the larger one.
    001632  0a   001644 6042 00         	tmi	BINARY_NOT_FOUND.._00023 " Quit, if the portion is zero length.
                                        
    001633  aa   777776 3622 03         	anx2	=o777776,du	" Truncate offset in x2 to a double word boundary.
    001634  aa   000001 7312 00         	ars	1		" Calculate size of the portion for the next pass.
                                        
    001635  aa  2 00000 1163 12         	cmpq	pr2|te.key,x2	" If value we are looking for is LESS than value we
    001636  0a   001631 6042 00         	tmi	BINARY_LOOP.._00023	" are looking at, then look again in LOWER division.
                                        
    001637  aa  2 00002 3523 12         	epp2	pr2|te_size,x2	" If value we are looking for is MORE than value we
    001640  0a   001631 6056 00         	tpnz	BINARY_LOOP.._00023	" are looking at, then look again in UPPER division.
                                        
    001641  aa  2 77776 3523 00         	epp2	pr2|-te_size	" Success!  The binary search always
    001642  0a   001663 6212 00         	eax1	EP_IS_IN_TT_AT_RETURN	" succeeds with PR2 -> to the next entry.
    001643  0a   001645 7102 00         	tra	FIGURE_INDEX.._00023
                                        
    001644                              BINARY_NOT_FOUND.._00023:		" The binary search always fails with
    001644  0a   002235 6212 00         	eax1	POP_TRACE_FRAME_AND_RETURN	" PR2 -> entry where it should have been.
                                        
    001645                              FIGURE_INDEX.._00023:
    001645  aa  1 00010 6353 00         	eaa	pr1|table.e	" Calculate the winning index.
    001646  aa   000023 7712 00         	arl	19
    001647  aa  1 00006 7553 00         	sta	pr1|table.working_storage
    001650  aa  2 00000 6353 00         	eaa	pr2|0
    001651  aa   000023 7712 00         	arl	19
    001652  aa  1 00006 1753 00         	sba	pr1|table.working_storage
    001653  aa   000000 6222 05         	eax2	0,al
    001654  aa  1 00004 1153 00         	cmpa	pr1|table.idx+idx.low	" If index - idx.low <= 0,
    001655  aa   000000 6046 11         	tmoz	0,x1	" then it is in the low half and we are done.
    001656  aa  1 00005 1753 00         	sba	pr1|table.idx+idx.high
    001657  4a  4 00406 6043 20         	tmi	trace_error_halt_$trace_error_halt_
    001660  aa  1 00004 0753 00         	ada	pr1|table.idx+idx.low
    001661  aa   000000 6222 05         	eax2	0,al		" index = index - idx.high + idx.low;
    001662  aa   000000 7102 11         	tra	0,x1
                                  1328  
    001663                        1329  EP_IS_IN_TT_AT_RETURN:
    001663  aa   000000 6352 12   1330  	eaa	0,x2
    001664  aa   000022 7312 00   1331  	ars	18
    001665  aa  6 00124 7553 00   1332  	sta	event+event.entry_idx
    001666  aa  2 00001 7623 00   1333  	lprp2	pr2|te.data
    001667  aa  2 00000 2373 00   1334  	ldaq	pr2|tab.version
    001670  0a   003266 1172 00   1335  	cmpaq	TAB_VERSION_3
    001671  4a  4 00406 6013 20   1336  	tnz	trace_error_halt_$trace_error_halt_
                                  1337  
                                  1338  " If tracing is disabled, the operator pointers have been yanked.  Pretend we arn't here.
                                  1339  
    001672  9a  4 00070 2343 00   1340  	szn	pr4|global_parameters+global_parms.enabled
    001673  0a   002232 6002 00   1341  	tze	POP_TAB_AND_RETURN
                                  1342  
                                  1343  " See if this entrypoint can still be traced.  The user could have turned it off while stopped.
                                  1344  
                                  1345  	is_tracing_permitted	POP_TAB_AND_RETURN
                                        " Is tracing this entry point permitted?
                                        
    001674  aa  2 00023 2353 00         	lda	pr2|tab.translator_id	" If tab.translator_id < 0,
    001675  0a   002232 6042 00         	tmi	POP_TAB_AND_RETURN		" then this program can't be traced.
    001676  9a  4 00064 2343 00         	szn	pr4|global_parameters+global_parms.alm
    001677  0a   001702 6012 00         	tnz	*+3
    001700  aa   000001 1152 07         	cmpa	1,dl			" If tab.translator_id = ALM
    001701  0a   002232 6002 00         	tze	POP_TAB_AND_RETURN		" then don't trace.
                                        
    001702  aa  2 00015 2343 00         	szn	pr2|tab.on		" If this entrypoint is -off,
    001703  0a   002232 6002 00         	tze	POP_TAB_AND_RETURN		" then don't trace it.
                                  1346  
                                  1347  " If we are not just metering, call the procedure that prints the tracing message.
                                  1348  
                                  1349  	trace_and_stop_if_necessary	pr6,re
                                        
    001704  9a  4 00066 2343 00         	szn	pr4|global_parameters+global_parms.meter
    001705  0a   002165 6012 00         	tnz	DONT_CALL_ANYTHING.._00024
                                        
    001706  aa  2 00003 2353 00         	lda	pr2|tab.parms_ptr
    001707  0a   003340 1152 00         	cmpa	packed_null		" If this entrypoint has been removed,
    001710  0a   002165 6002 00         	tze	DONT_CALL_ANYTHING.._00024	" then don't trace it.
                                        
    001711  aa  2 00015 2343 00         	szn	pr2|tab.on		" If this entrypoint is -off,
    001712  0a   002165 6002 00         	tze	DONT_CALL_ANYTHING.._00024	" then don't trace it.
                                        
    001713  9a  4 00064 2343 00         	szn	pr4|global_parameters+global_parms.alm
    001714  0a   001720 6012 00         	tnz	*+4
    001715  aa  2 00023 2353 00         	lda	pr2|tab.translator_id
    001716  aa   000001 1152 07         	cmpa	1,dl			" If tab.translator_id = ALM
    001717  0a   002165 6002 00         	tze	DONT_CALL_ANYTHING.._00024	" then don't trace.
                                        
    001720                              	inhibit	off		" <-> <-> <-> <-> <-> <-> <-> <-> <->
    001720  aa  2 00003 7631 00         	lprp3	pr2|tab.parms_ptr		" pr3 = tab.parms_ptr;
    001721  aa  3 00000 2371 00         	ldaq	pr3|parms.version
    001722  0a   003270 1170 00         	cmpaq	PARAMETERS_VERSION_3
    001723  4a  4 00406 6011 20         	tnz	trace_error_halt_$trace_error_halt_
                                        
    001724  aa  3 00016 2351 00         	lda	pr3|parms.trace		" Check inout.
    001725  aa   000001 7350 00         	als	1
    001726  0a   002036 6050 00         	tpl	CHECK_WATCH_TABLE.._00024
                                        
    001727  aa  6 00120 2371 00         	ldaq	pr6|event+event.saved.calls
    001730  aa   000001 0330 07         	adl	1,dl			" Get current count.
    001731  aa  6 00100 7571 00         	staq	arg_list.header		" Save in strange temporary.
                                        
    001732  aa  3 00003 2341 00         	szn	pr3|parms.every		" Is this parameter active?
    001733  0a   001744 6000 00         	tze	CHECK_FIRST.._00024
                                        
    001734  aa   000042 7330 00         	lrs	34			" If mod (call_count, tab.every) ^= 0
    001735  aa  3 00003 5071 00         	dvf	pr3|parms.every		" then don't trace.
    001736  aa   000044 7370 00         	lls	36
    001737  aa  6 00101 2361 00         	ldq	arg_list.header+1		" Actually counts.calls+1.
    001740  aa   000001 7360 00         	qls	1
    001741  aa  3 00003 5071 00         	dvf	pr3|parms.every		" Q = mod (saved calls, tab.every);
    001742  aa   000000 7320 00         	qrs	0			" Set indicators from register Q.
    001743  0a   002036 6010 00         	tnz	CHECK_WATCH_TABLE.._00024
                                        
    001744                              CHECK_FIRST.._00024:
    001744  aa  6 00100 3371 00         	lcaq	arg_list.header		" Actually counts.calls.
    001745  aa  3 00004 0331 00         	adl	pr3|parms.first		" If tab.first - saved calls > 0
    001746  0a   002036 6054 00         	tpnz	CHECK_WATCH_TABLE.._00024	" then don't trace.
                                        
    001747  aa  3 00005 2341 00         	szn	pr3|parms.last
    001750  0a   001754 6000 00         	tze	*+4			" -last 0 means it is diasbled.
    001751  aa  6 00100 3371 00         	lcaq	arg_list.header		" Actually counts.calls.
    001752  aa  3 00005 0331 00         	adl	pr3|parms.last		" If parms.last - saved calls < 0
    001753  0a   002036 6040 00         	tmi	CHECK_WATCH_TABLE.._00024	" then don't trace.
                                        
    001754  aa  6 00122 2351 00         	lda	pr6|event+event.saved.level
    001755  aa   000001 0750 07         	ada	1,dl			" Get current level.
    001756  aa  3 00006 1151 00         	cmpa	pr3|parms.low		" If level - parms.low < 0
    001757  0a   002036 6040 00         	tmi	CHECK_WATCH_TABLE.._00024	" then don't trace.
                                        
    001760  aa  3 00007 2341 00         	szn	pr3|parms.high
    001761  0a   001764 6000 00         	tze	*+3			" -high 0 means it is diasbled.
    001762  aa  3 00007 1151 00         	cmpa	pr3|parms.high		" If level - parms.high > 0
    001763  0a   002036 6054 00         	tpnz	CHECK_WATCH_TABLE.._00024	" then don't trace.
                                        
    001764  aa  3 00010 2341 00         	szn	pr3|parms.new_high		" If -new_high is off
    001765  0a   001770 6000 00         	tze	*+3			" then skip this check.
    001766  aa  6 00123 1151 00         	cmpa	pr6|event+event.saved.max_level
    001767  0a   002036 6044 00         	tmoz	CHECK_WATCH_TABLE.._00024	" then don't trace.
                                        
                                        	call_trace_routine_or_buffer pr6,re
                                        
                                        " call global_parameters.print_routine (event);
                                        " dcl  global_parameters.print_routine entry (1 like event aligned);
                                        
    001770  aa   162145 2200 03         	ldx0	=2are,du
    001771  aa  6 00111 7401 00         	stx0	pr6|event+event.kind
                                        
    001772  9a  4 00326 2351 00         	lda	pr4|global_parameters+global_parms.buffer_ptr
    001773  0a   003340 1150 00         	cmpa	packed_null
    001774  0a   002014 6000 00         	tze	CALL_TRACE_PRINT.._00025
    001775  9a  4 00326 7611 00         	lprp1	pr4|global_parameters+global_parms.buffer_ptr
    001776  aa  1 00000 2371 00         	ldaq	pr1|buffer.h.version
    001777  0a   003260 1170 00         	cmpaq	BUFFER_VERSION_3
    002000  4a  4 00406 6011 20         	tnz	trace_error_halt_$trace_error_halt_
    002001  aa  1 00003 2351 00         	lda	pr1|buffer.h.count
    002002  aa  1 00003 0541 00         	aos	pr1|buffer.h.count
    002003  aa   017777 3750 07         	ana	=o017777,dl		" mod 8192
    002004  aa   000004 7350 00         	als	4			" 16 words per event.
    002005  aa  1 00004 3515 05         	epp1	pr1|buffer.e,al		" pr1 -> buffer entry
    002006  aa  0 00100 1005 00         	mlr	(pr),(pr)
    002007  aa   600110 000070          	desc9a	pr6|event,(event_size-2)*4
    002010  aa   100000 000070          	desc9a	pr1|0,(event_size-2)*4
    002011  9a  4 00022 2371 00         	ldaq	pr4|stop+meters.real_time
    002012  aa  1 00016 7571 00         	staq	pr1|event_size-2		" Put clock reading in last two words.
    002013  0a   002036 7100 00         	tra	SKIP_TRACE_PRINT.._00025
                                        
    002014                              CALL_TRACE_PRINT.._00025:
    002014  0a   003304 2370 00         	ldaq	one_arg_list_header		" call trace_print_$trace (event);
    002015  aa  6 00100 7571 00         	staq	arg_list.header
    002016  9a  4 00316 2371 00         	ldaq	pr4|global_parameters+global_parms.trace_routine+2 " Environment ptr.
    002017  aa  6 00104 7571 00         	staq	arg_list.second_arg_ptr
    002020  0a   003330 6770 00         	eraq	null_ptr
    002021  0a   003332 3770 00         	anaq	ptr_mask
    002022  0a   002025 6000 00         	tze	*+3
    002023  0a   003316 2370 00         	ldaq	one_arg_list_header_w_env
    002024  aa  6 00100 7571 00         	staq	arg_list.header
    002025  aa  6 00110 3501 00         	epp0	pr6|event
    002026  aa  6 00102 2501 00         	spri0	arg_list.first_arg_ptr
                                        
    002027  aa  6 00000 2541 00         	call	pr4|global_parameters+global_parms.trace_routine,*(arg_list.header)
    002030  aa  6 00100 3501 00
    002031  9a  4 00314 3521 20
    002032  aa  6 00040 7531 00
    002033  aa  7 00036 6701 20
    002034  aa  6 00000 1731 00
    002035  aa  6 00040 0731 00
    002036                              SKIP_TRACE_PRINT.._00025:
                                        	
    002036                              CHECK_WATCH_TABLE.._00024:
                                        
                                        	check_or_update_watch_table	pr6,check
    002036  aa  6 00146 4501 00         	stz	pr6|watch_values_changed
                                        
    002037  9a  4 00056 3515 20         	epp1	pr4|wt_ptr,*		" Pr1 points to the table header.
    002040  aa  1 00000 2371 00         	ldaq	pr1|table.version
    002041  0a   003264 1170 00         	cmpaq	TT_VERSION_3
    002042  4a  4 00406 6011 20         	tnz	trace_error_halt_$trace_error_halt_
                                        
    002043  aa  1 00003 7201 00         	lxl0	pr1|table.count
    002044                              WATCH_TABLE_LOOP.._00026:
    002044  aa   777777 6200 10         	eax0	-1,x0
    002045  0a   002063 6040 00         	tmi	WATCH_TABLE_DONE.._00026
    002046  aa   000000 6350 10         	eaa	0,x0
    002047  aa   000022 7310 00         	ars	18
    002050  aa  1 00004 1151 00         	cmpa	pr1|table.idx+idx.low	" if idx - idx.low < 0
    002051  0a   002054 6040 00         	tmi	*+3			" then actual_idx = idx;
    002052  aa  1 00004 1751 00         	sba	pr1|table.idx+idx.low	" else actual_idx = idx - idx.low
    002053  aa  1 00005 0751 00         	ada	pr1|table.idx+idx.high	" + idx.high;
    002054  aa   000001 7350 00         	als	1
    002055  aa  1 00010 7601 05         	lprp0	pr1|table.e+te.key,al
    002056  aa  0 00000 2361 00         	ldq	pr0|0
    002057  aa  1 00011 1161 05         	cmpq	pr1|table.e+te.data,al
    002060  0a   002044 6000 00         	tze	WATCH_TABLE_LOOP.._00026
    002061  aa   400000 6350 00         	eaa	TRUE
    002062  aa  6 00146 7551 00         	sta	pr6|watch_values_changed
    002063                              WATCH_TABLE_DONE.._00026:
                                        
    002063  aa  6 00146 2341 00         	szn	pr6|watch_values_changed
    002064  0a   002111 6010 00         	tnz	STOP_IT.._00024
                                        
    002065  aa  3 00015 2351 00         	lda	pr3|parms.stop
    002066  aa   000001 7350 00         	als	1
    002067  0a   002165 6050 00         	tpl	DONT_CALL_ANYTHING.._00024
                                        
    002070  aa  6 00120 2371 00         	ldaq	pr6|event+event.saved.calls
    002071  aa   000001 0330 07         	adl	1,dl			" Get real counts.calls.
    002072  aa  6 00100 7571 00         	staq	arg_list.header		" Use this as a temporary.
                                        
    002073  aa  3 00013 2341 00         	szn	pr3|parms.stop_every	" Is this parameter active?
    002074  0a   002105 6000 00         	tze	CHECK_STOP_LOW.._00024
                                        
    002075  aa   000042 7330 00         	lrs	34			" If mod (call_count, tab.every) ^= 0
    002076  aa  3 00013 5071 00         	dvf	pr3|parms.stop_every	" then don't stop.
    002077  aa   000044 7370 00         	lls	36
    002100  aa  6 00101 2361 00         	ldq	arg_list.header+1		" Actually counts.calls+1.
    002101  aa   000001 7360 00         	qls	1
    002102  aa  3 00013 5071 00         	dvf	pr3|parms.stop_every	" Q = mod (saved calls, tab.every);
    002103  aa   000000 7320 00         	qrs	0			" Set indicators from register Q.
    002104  0a   002165 6010 00         	tnz	DONT_CALL_ANYTHING.._00024
                                        
    002105                              CHECK_STOP_LOW.._00024:
    002105  aa  6 00122 2351 00         	lda	pr6|event+event.saved.level
    002106  aa   000001 0750 07         	ada	1,dl			" Get current level.
    002107  aa  3 00014 1151 00         	cmpa	pr3|parms.stop_low		" If level - parms.stop_low < 0
    002110  0a   002165 6040 00         	tmi	DONT_CALL_ANYTHING.._00024	" then don't stop.
                                        
    002111                              STOP_IT.._00024:
                                        
                                        	call_stop_routine pr6,re
                                        
                                        " call global_parameters.stop_routine (event, watch_values_changed);
                                        " dcl  global_parameters.stop_routine entry (1 like event aligned, bit aligned);
                                        
    002111  aa   162145 2200 03         	ldx0	=2are,du
    002112  aa  6 00111 7401 00         	stx0	pr6|event+event.kind
                                        
    002113  0a   003306 2370 00         	ldaq	two_arg_list_header
    002114  aa  6 00100 7571 00         	staq	arg_list.header
    002115  9a  4 00322 2371 00         	ldaq	pr4|global_parameters+global_parms.stop_routine+2 " Environment ptr.
    002116  aa  6 00106 7571 00         	staq	arg_list.third_arg_ptr
    002117  0a   003330 6770 00         	eraq	null_ptr
    002120  0a   003332 3770 00         	anaq	ptr_mask
    002121  0a   002124 6000 00         	tze	*+3
    002122  0a   003320 2370 00         	ldaq	two_arg_list_header_w_env
    002123  aa  6 00100 7571 00         	staq	arg_list.header
    002124  aa  6 00110 3501 00         	epp0	pr6|event
    002125  aa  6 00102 2501 00         	spri0	arg_list.first_arg_ptr
    002126  aa  6 00146 3501 00         	epp0	pr6|watch_values_changed
    002127  aa  6 00104 2501 00         	spri0	arg_list.second_arg_ptr
                                        
    002130  aa  6 00000 2541 00         	call	pr4|global_parameters+global_parms.stop_routine,*(arg_list.header)
    002131  aa  6 00100 3501 00
    002132  9a  4 00320 3521 20
    002133  aa  6 00040 7531 00
    002134  aa  7 00036 6701 20
    002135  aa  6 00000 1731 00
    002136  aa  6 00040 0731 00
                                        
                                        	check_or_update_watch_table	pr6,update
    002137  aa  6 00146 2341 00         	szn	pr6|watch_values_changed
    002140  0a   002165 6000 00         	tze	WATCH_TABLE_DONE.._00027
                                        
    002141  9a  4 00056 3515 20         	epp1	pr4|wt_ptr,*		" Pr1 points to the table header.
    002142  aa  1 00000 2371 00         	ldaq	pr1|table.version
    002143  0a   003264 1170 00         	cmpaq	TT_VERSION_3
    002144  4a  4 00406 6011 20         	tnz	trace_error_halt_$trace_error_halt_
                                        
    002145  aa  1 00003 7201 00         	lxl0	pr1|table.count
    002146                              WATCH_TABLE_LOOP.._00027:
    002146  aa   777777 6200 10         	eax0	-1,x0
    002147  0a   002165 6040 00         	tmi	WATCH_TABLE_DONE.._00027
    002150  aa   000000 6350 10         	eaa	0,x0
    002151  aa   000022 7310 00         	ars	18
    002152  aa  1 00004 1151 00         	cmpa	pr1|table.idx+idx.low	" if idx - idx.low < 0
    002153  0a   002156 6040 00         	tmi	*+3			" then actual_idx = idx;
    002154  aa  1 00004 1751 00         	sba	pr1|table.idx+idx.low	" else actual_idx = idx - idx.low
    002155  aa  1 00005 0751 00         	ada	pr1|table.idx+idx.high	" + idx.high;
    002156  aa   000001 7350 00         	als	1
    002157  aa  1 00010 7601 05         	lprp0	pr1|table.e+te.key,al
    002160  aa  0 00000 2361 00         	ldq	pr0|0
    002161  aa  1 00011 1161 05         	cmpq	pr1|table.e+te.data,al
    002162  0a   002146 6000 00         	tze	WATCH_TABLE_LOOP.._00027
    002163  aa  1 00011 7561 05         	stq	pr1|table.e+te.data,al
    002164  0a   002146 7100 00         	tra	WATCH_TABLE_LOOP.._00027
    002165                              WATCH_TABLE_DONE.._00027:
                                        
    002165                              	inhibit	on		" <+> <+> <+> <+> <+> <+> <+> <+> <+>
    002165                              DONT_CALL_ANYTHING.._00024:
                                  1350  
                                  1351  " Update the meters in the tab since this frame is about to be popped.
                                  1352  
                                  1353  	update_tab_meters	pr6
    002165  9a  4 00036 2373 00         	ldaq	pr4|metered+meters.real_time
    002166  aa  6 00112 0773 00         	adaq	pr6|event+event.frame.real_time	" Update metered real time.
    002167  9a  4 00036 7573 00         	staq	pr4|metered+meters.real_time
                                        
    002170  aa  2 00010 2373 00         	ldaq	pr2|tab.local+meters.real_time
    002171  aa  6 00112 0773 00         	adaq	pr6|event+event.frame.real_time	" Update tab real time.
    002172  aa  2 00010 7573 00         	staq	pr2|tab.local+meters.real_time
                                        
    002173  9a  4 00040 2373 00         	ldaq	pr4|metered+meters.vcpu_time
    002174  aa  6 00114 0773 00         	adaq	pr6|event+event.frame.vcpu_time	" Update metered vcpu time.
    002175  9a  4 00040 7573 00         	staq	pr4|metered+meters.vcpu_time
                                        
    002176  aa  2 00012 2373 00         	ldaq	pr2|tab.local+meters.vcpu_time
    002177  aa  6 00114 0773 00         	adaq	pr6|event+event.frame.vcpu_time	" Update tab real time.
    002200  aa  2 00012 7573 00         	staq	pr2|tab.local+meters.vcpu_time
                                        
    002201  aa  6 00116 2353 00         	lda	pr6|event+event.frame.page_faults
    002202  9a  4 00042 0553 00         	asa	pr4|metered+meters.page_faults " Update metered page faults.
    002203  aa  2 00014 0553 00         	asa	pr2|tab.local+meters.page_faults " Update tab page faults.
                                        
    002204  aa  6 00140 2373 00         	ldaq	pr6|global_start.real_time
    002205  0a   002223 6002 00         	tze	FRAME_METERS_UPDATED.._00030	" No global metering in this frame.
                                        
    002206  9a  4 00036 2373 00         	ldaq	pr4|metered+meters.real_time	" Update global real time.
    002207  aa  6 00140 1773 00         	sbaq	pr6|global_start.real_time
    002210  4a  4 00406 6043 20         	tmi	trace_error_halt_$trace_error_halt_
    002211  aa  2 00016 0773 00         	adaq	pr2|tab.global+meters.real_time
    002212  aa  2 00016 7573 00         	staq	pr2|tab.global+meters.real_time
                                        
    002213  9a  4 00040 2373 00         	ldaq	pr4|metered+meters.vcpu_time	" Update global vcpu time.
    002214  aa  6 00142 1773 00         	sbaq	pr6|global_start.vcpu_time
    002215  aa  2 00020 0773 00         	adaq	pr2|tab.global+meters.vcpu_time
    002216  aa  2 00020 7573 00         	staq	pr2|tab.global+meters.vcpu_time
                                        
    002217  9a  4 00042 2353 00         	lda	pr4|metered+meters.page_faults " Update global page faults.
    002220  aa  6 00144 1753 00         	sba	pr6|global_start.page_faults
    002221  4a  4 00406 6043 20         	tmi	trace_error_halt_$trace_error_halt_
    002222  aa  2 00022 0553 00         	asa	pr2|tab.global+meters.page_faults
                                        
    002223                              FRAME_METERS_UPDATED.._00030:
    002223  aa   000110 7372 00         	lls	72			" Insure that they are not used again.
    002224  aa  6 00112 7573 00         	staq	pr6|event+event.frame.real_time
    002225  aa  6 00114 7573 00         	staq	pr6|event+event.frame.vcpu_time
    002226  aa  6 00116 4503 00         	stz	pr6|event+event.frame.page_faults
    002227  aa  6 00140 7573 00         	staq	pr6|global_start.real_time
    002230  aa  6 00142 7573 00         	staq	pr6|global_start.vcpu_time
    002231  aa  6 00144 4503 00         	stz	pr6|global_start.page_faults
                                  1354  
    002232                        1355  POP_TAB_AND_RETURN:
                                  1356  	pop_tab		pr6
    002232  aa  6 00122 2353 00         	lda	pr6|event+event.saved.level	" Revert tab.cts.level,
    002233  4a  4 00406 6043 20         	tmi	trace_error_halt_$trace_error_halt_
    002234  aa  2 00006 7553 00         	sta	pr2|tab.cts+counts.level
                                  1357  
                                  1358  " Pop this trace_catch_ frame from the top of the stack of such frames.
                                  1359  
    002235                        1360  POP_TRACE_FRAME_AND_RETURN:
    002235  aa  6 00136 2373 00   1361  	ldaq	trace_frames_saved
    002236  aa  7 00072 7573 00   1362  	staq	pr7|stack_header.trace_frames
                                  1363  
                                  1364  " Start a metering interval, regardless of whether there is anything to meter.
                                  1365  
                                  1366  	start_metering_interval	return
    002237  8a   000340 6242 00         	eax4	global_parameters+global_parms.comps+from_return
    002240  9a  4 00021 7443 00         	stx4	pr4|start_comp		" Remember which compensations to use.
                                        
                                        	read_vcpu_time_and_page_faults	start
                                        
    002241  aa  6 00024 3573 00         	stcd	pr6|stack_frame.return_ptr
    002242  4a  4 00354 7133 20         	call6	cpu_time_and_paging_op_$cpu_time_and_paging_op_
                                        
    002243  aa  6 00000 3733 00         	epbp7	pr6|0
    002244  aa  6 00030 3703 20         	epp4	pr6|stack_frame.lp_ptr,*
    002245  9a  4 00016 7573 00         	staq	pr4|start+meters.vcpu_time   " Vcpu time is returned in AQ register.
    002246  9a  4 00020 7403 00         	stx0	pr4|start+meters.page_faults " Page faults are returned in X0 and X1.
    002247  9a  4 00020 4413 00         	sxl1	pr4|start+meters.page_faults
                                        
    002250                              NOTHING_TO_START.._00031:
                                  1367  
                                  1368  " If the end of the frame is not where it should be, because it has been
                                  1369  " extended to hold the value of a returns (*) function, merge it with the
                                  1370  " previous frame.
                                  1371  
    002250  aa  6 00160 6203 00   1372  	eax0	pr6|stack_frame_size
    002251  aa  6 00023 1003 00   1373  	cmpx0	pr6|stack_frame.next_sp+1
    002252  0a   002260 6012 00   1374  	tnz	MERGE_FRAMES
                                  1375  
                                  1376  
                                  1377  " Restore registers.  Ptr_registers_saved pr4 and pr6 contain trace_catch_'s lp and sp.
                                  1378  
    002253  aa  6 00060 1733 00   1379  	lpri	ptr_registers_saved
    002254  aa  6 00050 0733 00   1380  	lreg	registers_saved
                                  1381  
                                  1382  " Pop our stack frame.
                                  1383  
    002255  aa  7 00024 6523 00   1384  	spri6	pr7|stack_header.stack_end_ptr
    002256  aa  6 00020 3723 20   1385  	epp6	pr6|stack_frame.prev_sp,*
    002257  0a   002265 7102 00   1386  	tra	RETURN
                                  1387  
    002260                        1388  MERGE_FRAMES:
                                  1389  
                                  1390  " Restore registers.  Ptr_registers_saved pr4 and pr6 contain trace_catch_'s lp and sp.
                                  1391  
    002260  aa  6 00060 1733 00   1392  	lpri	ptr_registers_saved
    002261  aa  6 00050 0733 00   1393  	lreg	registers_saved
                                  1394  
    002262  aa  7 00024 2373 00   1395  	ldaq	pr7|stack_header.stack_end_ptr " Remember where this frame ends.
    002263  aa  6 00020 3723 20   1396  	epp6	pr6|stack_frame.prev_sp,*	" Drop back to frame we are returning to.
    002264  aa  6 00022 7573 00   1397  	staq	pr6|stack_frame.next_sp	" Extend it to protect data in next frame.
                                  1398  
    002265                        1399  RETURN:
    002265  aa  6 00000 3733 00   1400  	epbp7	pr6|0
    002266  aa  6 00030 3503 20   1401  	epp0	pr6|stack_frame.operator_ptr,*
    002267  aa  6 00025 6343 00   1402  	ldi	pr6|stack_frame.return_ptr+1
                                  1403  
                                  1404  " Permit tracing again.
                                  1405  
    002270  aa  7 00074 4503 00   1406  	stz	pr7|stack_header.in_trace
                                  1407  
                                  1408  " The read the clock as the last step for maximum accuracy.
                                  1409  
                                  1410  	read_the_calendar_clock	start
    002271  4a  4 00352 6333 20         	rccl	sys_info$clock_,*
    002272  9a  4 00014 7573 00         	staq	pr4|start+meters.real_time
                                  1411  
    002273  aa  6 00024 6103 00   1412  	rtcd	pr6|stack_frame.return_ptr
                                  1413  
    002274                        1414  	inhibit	off		<-> <-> <-> <-> <-> <-> <-> <-> <-> <->
                                  1415  
                                  1416  " This preliminary cleanup handler just permits tracing again.
                                  1417  
    002274                        1418  PRELIMINARY_CLEANUP_HANDLER:
                                  1419  
    002274  aa  7 00074 4501 00   1420  	stz	pr7|stack_header.in_trace
                                  1421  
    002275  aa  7 00044 7101 20   1422  	short_return
                                  1423  
                                  1424  
                                  1425  
                                  1426  
                                  1427  
                                  1428  " This code is invoked during stack unwinding.  It calculates the meters for
                                  1429  " the last interval, adds them to the tab and trace_catch_$metered, pops the
                                  1430  " tab recursion level, pops the frame off the stack of trace_catch_ frames,
                                  1431  " and resets stack_header.in_trace to permit tracing again.
                                  1432  
                        002276    1433  	entry	TRACE_CATCH_CLEANUP
                                  1434  
    002276                        1435  TRACE_CATCH_CLEANUP:
                                  1436  
    002276                        1437  	inhibit	on		<+> <+> <+> <+> <+> <+> <+> <+> <+> <+>
                                  1438  
                                  1439  	get_pr4
    002276  0a   002276 2132 00         	epaq	*
    002277  aa  7 00026 7643 61         	lprp4	pr7|stack_header.lot_ptr,*au
                                  1440  
                                  1441  " Read the calendar clock as soon as possible.
                                  1442  
                                  1443  	read_the_calendar_clock	stop
    002300  4a  4 00352 6333 20         	rccl	sys_info$clock_,*
    002301  9a  4 00022 7573 00         	staq	pr4|stop+meters.real_time
                                  1444  
                                  1445  " Do what getlp does.
                                  1446  
    002302  aa  7 00024 3717 20   1447  	epp5	pr7|stack_header.stack_end_ptr,* " PR5 -> stack frame construction site.
    002303  4a  4 00360 3537 20   1448  	epp3	trace_catch_$TRACE_CATCH_CLEANUP " Let debuggers see a real entry point.
    002304  aa  5 00026 2537 00   1449  	spri3	pr5|stack_frame.entry_ptr
                                  1450  
                                  1451  " Push.
                                  1452  
    002305  aa  5 00020 6523 00   1453  	spri6	pr5|stack_frame.prev_sp
    002306  aa  5 00032 2503 00   1454  	spri0	pr5|stack_frame.arg_ptr
    002307  aa  5 00030 6503 00   1455  	spri4	pr5|stack_frame.lp_ptr
    002310  aa  5 00000 3723 00   1456  	epp6	pr5|0
    002311  aa  6 00160 3717 00   1457  	epp5	pr6|stack_frame_size
    002312  aa  7 00024 6517 00   1458  	spri5	pr7|stack_header.stack_end_ptr
    002313  aa  6 00022 6517 00   1459  	spri5	pr6|stack_frame.next_sp
                                  1460  
                                  1461  " Read the meters.
                                  1462  
                                  1463  	read_vcpu_time_and_page_faults	stop
                                        
    002314  aa  6 00024 3573 00         	stcd	pr6|stack_frame.return_ptr
    002315  4a  4 00354 7133 20         	call6	cpu_time_and_paging_op_$cpu_time_and_paging_op_
                                        
    002316  aa  6 00000 3733 00         	epbp7	pr6|0
    002317  aa  6 00030 3703 20         	epp4	pr6|stack_frame.lp_ptr,*
    002320  9a  4 00024 7573 00         	staq	pr4|stop+meters.vcpu_time   " Vcpu time is returned in AQ register.
    002321  9a  4 00026 7403 00         	stx0	pr4|stop+meters.page_faults " Page faults are returned in X0 and X1.
    002322  9a  4 00026 4413 00         	sxl1	pr4|stop+meters.page_faults
                                  1464  
                                  1465  " Prevent tracing of calls or errors during cleanup.
                                  1466  
    002323  aa   400000 6352 00   1467  	eaa	TRUE
    002324  aa  7 00074 7553 00   1468  	sta	pr7|stack_header.in_trace
                                  1469  
                                  1470  " Put environment pointer from argument into pr5.
                                  1471  
    002325  aa  6 00032 3503 20   1472  	epp0	pr6|stack_frame.arg_ptr,*
    002326  aa  0 00000 2353 00   1473  	lda	pr0|0
    002327  aa   777777 6362 00   1474  	eaq	-1
    002330  aa   000010 2112 07   1475  	cmk	8,dl		" If there in no environment pointer,
    002331  4a  4 00406 6013 20   1476  	tnz	trace_error_halt_$trace_error_halt_ " we can't go further.
    002332  aa  0 00002 3717 21   1477  	epp5	pr0|2,au*
                                  1478  
                                  1479  " Calculate the elapsed meters and store them in the frame being unwound.
                                  1480  
                                  1481  	metering_interval_calculations	pr5,entry
    002333  9a  4 00014 3373 00         	lcaq	pr4|start+meters.real_time
    002334  0a   002370 6002 00         	tze	INTERVAL_CALCULATED.._00032
                                        
    002335  9a  4 00021 2243 00         	ldx4	pr4|start_comp		" How were they started?
    002336  9a  4 00022 0773 00         	adaq	pr4|stop+meters.real_time	" Calculate elapsed real time.
    002337  4a  4 00406 6043 20         	tmi	trace_error_halt_$trace_error_halt_
    002340  aa  4 00000 1773 14         	sbaq	pr4|to_entry.real_time,x4	" Subtract appropriate compensation.
    002341  0a   002343 6052 00         	tpl	*+2			" A negative number would later
    002342  aa   000110 7372 00         	lls	72			" be detected as an inconsistency.
    002343  9a  4 00030 7573 00         	staq	pr4|delta+meters.real_time
                                        
    002344  9a  4 00024 2373 00         	ldaq	pr4|stop+meters.vcpu_time	" Calculate elapsed vcpu time.
    002345  9a  4 00016 1773 00         	sbaq	pr4|start+meters.vcpu_time
    002346  9a  4 00030 1173 00         	cmpaq	pr4|delta+meters.real_time	" Elapsed vcpu time should always be less
    002347  0a   002354 6046 00         	tmoz	*+5			" than or equal to elapsed real time.
    002350  9a  4 00325 2343 00         	szn	pr4|global_parameters+global_parms.calibrate " Don't apply correction
    002351  0a   002354 6012 00         	tnz	*+3			" when determining compensations.
    002352  9a  4 00030 2373 00         	ldaq	pr4|delta+meters.real_time	" If it isn't, use real time instead.
    002353  0a   002355 7102 00         	tra	*+2			" Delta real is already compensated.
    002354  aa  4 00002 1773 14         	sbaq	pr4|to_entry.vcpu_time,x4	" Subtract appropriate compensation.
    002355  9a  4 00032 7573 00         	staq	pr4|delta+meters.vcpu_time
                                        
    002356  aa  5 00112 2373 00         	ldaq	pr5|event+event.frame.real_time
    002357  9a  4 00030 0773 00         	adaq	pr4|delta+meters.real_time	" Update frame real time.
    002360  aa  5 00112 7573 00         	staq	pr5|event+event.frame.real_time
                                        
    002361  aa  5 00114 2373 00         	ldaq	pr5|event+event.frame.vcpu_time
    002362  9a  4 00032 0773 00         	adaq	pr4|delta+meters.vcpu_time	" Update frame vcpu time.
    002363  aa  5 00114 7573 00         	staq	pr5|event+event.frame.vcpu_time
                                        
    002364  9a  4 00026 2353 00         	lda	pr4|stop+meters.page_faults
    002365  9a  4 00020 1753 00         	sba	pr4|start+meters.page_faults
    002366  4a  4 00406 6043 20         	tmi	trace_error_halt_$trace_error_halt_
    002367  aa  5 00116 0553 00         	asa	pr5|event+event.frame.page_faults " Update frame page faults.
                                        
    002370                              INTERVAL_CALCULATED.._00032:
    002370  aa   000110 7372 00         	lls	72			" Insure that they are not used again.
    002371  9a  4 00014 7573 00         	staq	pr4|start+meters.real_time
    002372  9a  4 00016 7573 00         	staq	pr4|start+meters.vcpu_time
    002373  9a  4 00020 4503 00         	stz	pr4|start+meters.page_faults
                                  1482  
                                  1483  " Get the tab_ptr, if this entrypoint is still in the trace table.
                                  1484  
    002374  9a  4 00054 3517 20   1485  	epp1	pr4|tt_ptr,*
    002375  aa  1 00000 2373 00   1486  	ldaq	pr1|table.version
    002376  0a   003264 1172 00   1487  	cmpaq	TT_VERSION_3
    002377  4a  4 00406 6013 20   1488  	tnz	trace_error_halt_$trace_error_halt_
                                  1489  
    002400  aa  5 00117 2363 00   1490  	ldq	pr5|event+event.entry_ptr	" Q reg contains the value we are looking for.
                                  1491  
                                  1492  	seek_table	EP_IS_IN_TT_AT_UNWIND,POP_TRACE_FRAME_AT_UNWIND
    002401  aa  1 00005 2353 00         	lda	pr1|table.idx+idx.high
    002402  aa   000001 7352 00         	als	1
    002403  aa  1 00010 3523 05         	epp2	pr1|table.e,al	" Pr2 points to high half.
    002404  aa  1 00002 2353 00         	lda	pr1|table.max_count
    002405  aa  1 00005 1753 00         	sba	pr1|table.idx+idx.high " If table.max_count - idx.high = 0,
    002406  0a   002415 6002 00         	tze	SEEK_LOW.._00033	" then the high half is empty.
    002407  4a  4 00406 6043 20         	tmi	trace_error_halt_$trace_error_halt_
    002410  aa  2 00000 1163 00         	cmpq	pr2|te.key	" If Q - table.e (idx.high) < 0
    002411  0a   002415 6042 00         	tmi	SEEK_LOW.._00033
    002412  0a   002423 6056 00         	tpnz	BINARY_LOOP.._00033
    002413  aa  1 00004 7223 00         	lxl2	pr1|table.idx+idx.low " Good luck.  We found it.
    002414  0a   002455 7102 00         	tra	EP_IS_IN_TT_AT_UNWIND
                                        
    002415                              SEEK_LOW.._00033:
    002415  aa  1 00010 3523 00         	epp2	pr1|table.e	" Pr2 points to low half.
    002416  aa  1 00004 2353 00         	lda	pr1|table.idx+idx.low	" A = number of entries in low half.
    002417  0a   002423 6056 00         	tpnz	BINARY_LOOP.._00033	" If A > 0, then do a binary search.
    002420  4a  4 00406 6043 20         	tmi	trace_error_halt_$trace_error_halt_
    002421  aa   000000 6222 00         	eax2	0		" else it's not in the table.
    002422  0a   002700 7102 00         	tra	POP_TRACE_FRAME_AT_UNWIND
                                        
                                        " The binary search uses pr2 to point to the group of remaining candidates.
                                        " It uses the A register to contain the number of remaining candidates.
                                        " During the search uses X2 to represent the offset to the middle of the candidates.
                                        
    002423                              BINARY_LOOP.._00033:		" X2 contains offset that divides portion in half,
    002423  aa   777777 6222 05         	eax2	-1,al		" with the upper division being the larger one.
    002424  0a   002436 6042 00         	tmi	BINARY_NOT_FOUND.._00033 " Quit, if the portion is zero length.
                                        
    002425  aa   777776 3622 03         	anx2	=o777776,du	" Truncate offset in x2 to a double word boundary.
    002426  aa   000001 7312 00         	ars	1		" Calculate size of the portion for the next pass.
                                        
    002427  aa  2 00000 1163 12         	cmpq	pr2|te.key,x2	" If value we are looking for is LESS than value we
    002430  0a   002423 6042 00         	tmi	BINARY_LOOP.._00033	" are looking at, then look again in LOWER division.
                                        
    002431  aa  2 00002 3523 12         	epp2	pr2|te_size,x2	" If value we are looking for is MORE than value we
    002432  0a   002423 6056 00         	tpnz	BINARY_LOOP.._00033	" are looking at, then look again in UPPER division.
                                        
    002433  aa  2 77776 3523 00         	epp2	pr2|-te_size	" Success!  The binary search always
    002434  0a   002455 6212 00         	eax1	EP_IS_IN_TT_AT_UNWIND	" succeeds with PR2 -> to the next entry.
    002435  0a   002437 7102 00         	tra	FIGURE_INDEX.._00033
                                        
    002436                              BINARY_NOT_FOUND.._00033:		" The binary search always fails with
    002436  0a   002700 6212 00         	eax1	POP_TRACE_FRAME_AT_UNWIND	" PR2 -> entry where it should have been.
                                        
    002437                              FIGURE_INDEX.._00033:
    002437  aa  1 00010 6353 00         	eaa	pr1|table.e	" Calculate the winning index.
    002440  aa   000023 7712 00         	arl	19
    002441  aa  1 00006 7553 00         	sta	pr1|table.working_storage
    002442  aa  2 00000 6353 00         	eaa	pr2|0
    002443  aa   000023 7712 00         	arl	19
    002444  aa  1 00006 1753 00         	sba	pr1|table.working_storage
    002445  aa   000000 6222 05         	eax2	0,al
    002446  aa  1 00004 1153 00         	cmpa	pr1|table.idx+idx.low	" If index - idx.low <= 0,
    002447  aa   000000 6046 11         	tmoz	0,x1	" then it is in the low half and we are done.
    002450  aa  1 00005 1753 00         	sba	pr1|table.idx+idx.high
    002451  4a  4 00406 6043 20         	tmi	trace_error_halt_$trace_error_halt_
    002452  aa  1 00004 0753 00         	ada	pr1|table.idx+idx.low
    002453  aa   000000 6222 05         	eax2	0,al		" index = index - idx.high + idx.low;
    002454  aa   000000 7102 11         	tra	0,x1
                                  1493  
    002455                        1494  EP_IS_IN_TT_AT_UNWIND:
    002455  aa   000000 6352 12   1495  	eaa	0,x2
    002456  aa   000022 7312 00   1496  	ars	18
    002457  aa  5 00124 7553 00   1497  	sta	pr5|event+event.entry_idx
    002460  aa  2 00001 7623 00   1498  	lprp2	pr2|te.data
    002461  aa  2 00000 2373 00   1499  	ldaq	pr2|tab.version
    002462  0a   003266 1172 00   1500  	cmpaq	TAB_VERSION_3
    002463  4a  4 00406 6013 20   1501  	tnz	trace_error_halt_$trace_error_halt_
                                  1502  
                                  1503  " If tracing is disabled, the operator pointers have been yanked.  Pretend we arn't here.
                                  1504  
    002464  9a  4 00070 2343 00   1505  	szn	pr4|global_parameters+global_parms.enabled
    002465  0a   002675 6002 00   1506  	tze	POP_TAB_AT_UNWIND
                                  1507  
                                  1508  " See if this entrypoint can still be traced.  The user could have turned it off while stopped.
                                  1509  
                                  1510  	is_tracing_permitted	POP_TAB_AT_UNWIND
                                        " Is tracing this entry point permitted?
                                        
    002466  aa  2 00023 2353 00         	lda	pr2|tab.translator_id	" If tab.translator_id < 0,
    002467  0a   002675 6042 00         	tmi	POP_TAB_AT_UNWIND		" then this program can't be traced.
    002470  9a  4 00064 2343 00         	szn	pr4|global_parameters+global_parms.alm
    002471  0a   002474 6012 00         	tnz	*+3
    002472  aa   000001 1152 07         	cmpa	1,dl			" If tab.translator_id = ALM
    002473  0a   002675 6002 00         	tze	POP_TAB_AT_UNWIND		" then don't trace.
                                        
    002474  aa  2 00015 2343 00         	szn	pr2|tab.on		" If this entrypoint is -off,
    002475  0a   002675 6002 00         	tze	POP_TAB_AT_UNWIND		" then don't trace it.
                                  1511  
                                  1512  " Call the procedure that prints the tracing message, if appropriate.
                                  1513  
                                  1514  	trace_and_stop_if_necessary	pr5,un
                                        
    002476  9a  4 00066 2343 00         	szn	pr4|global_parameters+global_parms.meter
    002477  0a   002630 6012 00         	tnz	DONT_CALL_ANYTHING.._00034
                                        
    002500  aa  2 00003 2353 00         	lda	pr2|tab.parms_ptr
    002501  0a   003340 1152 00         	cmpa	packed_null		" If this entrypoint has been removed,
    002502  0a   002630 6002 00         	tze	DONT_CALL_ANYTHING.._00034	" then don't trace it.
                                        
    002503  aa  2 00015 2343 00         	szn	pr2|tab.on		" If this entrypoint is -off,
    002504  0a   002630 6002 00         	tze	DONT_CALL_ANYTHING.._00034	" then don't trace it.
                                        
    002505  9a  4 00064 2343 00         	szn	pr4|global_parameters+global_parms.alm
    002506  0a   002512 6012 00         	tnz	*+4
    002507  aa  2 00023 2353 00         	lda	pr2|tab.translator_id
    002510  aa   000001 1152 07         	cmpa	1,dl			" If tab.translator_id = ALM
    002511  0a   002630 6002 00         	tze	DONT_CALL_ANYTHING.._00034	" then don't trace.
                                        
    002512                              	inhibit	off		" <-> <-> <-> <-> <-> <-> <-> <-> <->
    002512  aa  2 00003 7631 00         	lprp3	pr2|tab.parms_ptr		" pr3 = tab.parms_ptr;
    002513  aa  3 00000 2371 00         	ldaq	pr3|parms.version
    002514  0a   003270 1170 00         	cmpaq	PARAMETERS_VERSION_3
    002515  4a  4 00406 6011 20         	tnz	trace_error_halt_$trace_error_halt_
                                        
    002516  aa  3 00016 2351 00         	lda	pr3|parms.trace		" Check inout.
    002517  aa   000001 7350 00         	als	1
    002520  0a   002630 6050 00         	tpl	CHECK_WATCH_TABLE.._00034
                                        
    002521  aa  5 00120 2371 00         	ldaq	pr5|event+event.saved.calls
    002522  aa   000001 0330 07         	adl	1,dl			" Get current count.
    002523  aa  6 00100 7571 00         	staq	arg_list.header		" Save in strange temporary.
                                        
    002524  aa  3 00003 2341 00         	szn	pr3|parms.every		" Is this parameter active?
    002525  0a   002536 6000 00         	tze	CHECK_FIRST.._00034
                                        
    002526  aa   000042 7330 00         	lrs	34			" If mod (call_count, tab.every) ^= 0
    002527  aa  3 00003 5071 00         	dvf	pr3|parms.every		" then don't trace.
    002530  aa   000044 7370 00         	lls	36
    002531  aa  6 00101 2361 00         	ldq	arg_list.header+1		" Actually counts.calls+1.
    002532  aa   000001 7360 00         	qls	1
    002533  aa  3 00003 5071 00         	dvf	pr3|parms.every		" Q = mod (saved calls, tab.every);
    002534  aa   000000 7320 00         	qrs	0			" Set indicators from register Q.
    002535  0a   002630 6010 00         	tnz	CHECK_WATCH_TABLE.._00034
                                        
    002536                              CHECK_FIRST.._00034:
    002536  aa  6 00100 3371 00         	lcaq	arg_list.header		" Actually counts.calls.
    002537  aa  3 00004 0331 00         	adl	pr3|parms.first		" If tab.first - saved calls > 0
    002540  0a   002630 6054 00         	tpnz	CHECK_WATCH_TABLE.._00034	" then don't trace.
                                        
    002541  aa  3 00005 2341 00         	szn	pr3|parms.last
    002542  0a   002546 6000 00         	tze	*+4			" -last 0 means it is diasbled.
    002543  aa  6 00100 3371 00         	lcaq	arg_list.header		" Actually counts.calls.
    002544  aa  3 00005 0331 00         	adl	pr3|parms.last		" If parms.last - saved calls < 0
    002545  0a   002630 6040 00         	tmi	CHECK_WATCH_TABLE.._00034	" then don't trace.
                                        
    002546  aa  5 00122 2351 00         	lda	pr5|event+event.saved.level
    002547  aa   000001 0750 07         	ada	1,dl			" Get current level.
    002550  aa  3 00006 1151 00         	cmpa	pr3|parms.low		" If level - parms.low < 0
    002551  0a   002630 6040 00         	tmi	CHECK_WATCH_TABLE.._00034	" then don't trace.
                                        
    002552  aa  3 00007 2341 00         	szn	pr3|parms.high
    002553  0a   002556 6000 00         	tze	*+3			" -high 0 means it is diasbled.
    002554  aa  3 00007 1151 00         	cmpa	pr3|parms.high		" If level - parms.high > 0
    002555  0a   002630 6054 00         	tpnz	CHECK_WATCH_TABLE.._00034	" then don't trace.
                                        
    002556  aa  3 00010 2341 00         	szn	pr3|parms.new_high		" If -new_high is off
    002557  0a   002562 6000 00         	tze	*+3			" then skip this check.
    002560  aa  5 00123 1151 00         	cmpa	pr5|event+event.saved.max_level
    002561  0a   002630 6044 00         	tmoz	CHECK_WATCH_TABLE.._00034	" then don't trace.
                                        
                                        	call_trace_routine_or_buffer pr5,un
                                        
                                        " call global_parameters.print_routine (event);
                                        " dcl  global_parameters.print_routine entry (1 like event aligned);
                                        
    002562  aa   165156 2200 03         	ldx0	=2aun,du
    002563  aa  5 00111 7401 00         	stx0	pr5|event+event.kind
                                        
    002564  9a  4 00326 2351 00         	lda	pr4|global_parameters+global_parms.buffer_ptr
    002565  0a   003340 1150 00         	cmpa	packed_null
    002566  0a   002606 6000 00         	tze	CALL_TRACE_PRINT.._00035
    002567  9a  4 00326 7611 00         	lprp1	pr4|global_parameters+global_parms.buffer_ptr
    002570  aa  1 00000 2371 00         	ldaq	pr1|buffer.h.version
    002571  0a   003260 1170 00         	cmpaq	BUFFER_VERSION_3
    002572  4a  4 00406 6011 20         	tnz	trace_error_halt_$trace_error_halt_
    002573  aa  1 00003 2351 00         	lda	pr1|buffer.h.count
    002574  aa  1 00003 0541 00         	aos	pr1|buffer.h.count
    002575  aa   017777 3750 07         	ana	=o017777,dl		" mod 8192
    002576  aa   000004 7350 00         	als	4			" 16 words per event.
    002577  aa  1 00004 3515 05         	epp1	pr1|buffer.e,al		" pr1 -> buffer entry
    002600  aa  0 00100 1005 00         	mlr	(pr),(pr)
    002601  aa   500110 000070          	desc9a	pr5|event,(event_size-2)*4
    002602  aa   100000 000070          	desc9a	pr1|0,(event_size-2)*4
    002603  9a  4 00022 2371 00         	ldaq	pr4|stop+meters.real_time
    002604  aa  1 00016 7571 00         	staq	pr1|event_size-2		" Put clock reading in last two words.
    002605  0a   002630 7100 00         	tra	SKIP_TRACE_PRINT.._00035
                                        
    002606                              CALL_TRACE_PRINT.._00035:
    002606  0a   003304 2370 00         	ldaq	one_arg_list_header		" call trace_print_$trace (event);
    002607  aa  6 00100 7571 00         	staq	arg_list.header
    002610  9a  4 00316 2371 00         	ldaq	pr4|global_parameters+global_parms.trace_routine+2 " Environment ptr.
    002611  aa  6 00104 7571 00         	staq	arg_list.second_arg_ptr
    002612  0a   003330 6770 00         	eraq	null_ptr
    002613  0a   003332 3770 00         	anaq	ptr_mask
    002614  0a   002617 6000 00         	tze	*+3
    002615  0a   003316 2370 00         	ldaq	one_arg_list_header_w_env
    002616  aa  6 00100 7571 00         	staq	arg_list.header
    002617  aa  5 00110 3501 00         	epp0	pr5|event
    002620  aa  6 00102 2501 00         	spri0	arg_list.first_arg_ptr
                                        
    002621  aa  6 00000 2541 00         	call	pr4|global_parameters+global_parms.trace_routine,*(arg_list.header)
    002622  aa  6 00100 3501 00
    002623  9a  4 00314 3521 20
    002624  aa  6 00040 7531 00
    002625  aa  7 00036 6701 20
    002626  aa  6 00000 1731 00
    002627  aa  6 00040 0731 00
    002630                              SKIP_TRACE_PRINT.._00035:
                                        	
    002630                              CHECK_WATCH_TABLE.._00034:
    002630                              	inhibit	on		" <+> <+> <+> <+> <+> <+> <+> <+> <+>
    002630                              DONT_CALL_ANYTHING.._00034:
                                  1515  
                                  1516  " Move the meters to the tab.
                                  1517  
                                  1518  	update_tab_meters	pr5
    002630  9a  4 00036 2373 00         	ldaq	pr4|metered+meters.real_time
    002631  aa  5 00112 0773 00         	adaq	pr5|event+event.frame.real_time	" Update metered real time.
    002632  9a  4 00036 7573 00         	staq	pr4|metered+meters.real_time
                                        
    002633  aa  2 00010 2373 00         	ldaq	pr2|tab.local+meters.real_time
    002634  aa  5 00112 0773 00         	adaq	pr5|event+event.frame.real_time	" Update tab real time.
    002635  aa  2 00010 7573 00         	staq	pr2|tab.local+meters.real_time
                                        
    002636  9a  4 00040 2373 00         	ldaq	pr4|metered+meters.vcpu_time
    002637  aa  5 00114 0773 00         	adaq	pr5|event+event.frame.vcpu_time	" Update metered vcpu time.
    002640  9a  4 00040 7573 00         	staq	pr4|metered+meters.vcpu_time
                                        
    002641  aa  2 00012 2373 00         	ldaq	pr2|tab.local+meters.vcpu_time
    002642  aa  5 00114 0773 00         	adaq	pr5|event+event.frame.vcpu_time	" Update tab real time.
    002643  aa  2 00012 7573 00         	staq	pr2|tab.local+meters.vcpu_time
                                        
    002644  aa  5 00116 2353 00         	lda	pr5|event+event.frame.page_faults
    002645  9a  4 00042 0553 00         	asa	pr4|metered+meters.page_faults " Update metered page faults.
    002646  aa  2 00014 0553 00         	asa	pr2|tab.local+meters.page_faults " Update tab page faults.
                                        
    002647  aa  5 00140 2373 00         	ldaq	pr5|global_start.real_time
    002650  0a   002666 6002 00         	tze	FRAME_METERS_UPDATED.._00036	" No global metering in this frame.
                                        
    002651  9a  4 00036 2373 00         	ldaq	pr4|metered+meters.real_time	" Update global real time.
    002652  aa  5 00140 1773 00         	sbaq	pr5|global_start.real_time
    002653  4a  4 00406 6043 20         	tmi	trace_error_halt_$trace_error_halt_
    002654  aa  2 00016 0773 00         	adaq	pr2|tab.global+meters.real_time
    002655  aa  2 00016 7573 00         	staq	pr2|tab.global+meters.real_time
                                        
    002656  9a  4 00040 2373 00         	ldaq	pr4|metered+meters.vcpu_time	" Update global vcpu time.
    002657  aa  5 00142 1773 00         	sbaq	pr5|global_start.vcpu_time
    002660  aa  2 00020 0773 00         	adaq	pr2|tab.global+meters.vcpu_time
    002661  aa  2 00020 7573 00         	staq	pr2|tab.global+meters.vcpu_time
                                        
    002662  9a  4 00042 2353 00         	lda	pr4|metered+meters.page_faults " Update global page faults.
    002663  aa  5 00144 1753 00         	sba	pr5|global_start.page_faults
    002664  4a  4 00406 6043 20         	tmi	trace_error_halt_$trace_error_halt_
    002665  aa  2 00022 0553 00         	asa	pr2|tab.global+meters.page_faults
                                        
    002666                              FRAME_METERS_UPDATED.._00036:
    002666  aa   000110 7372 00         	lls	72			" Insure that they are not used again.
    002667  aa  5 00112 7573 00         	staq	pr5|event+event.frame.real_time
    002670  aa  5 00114 7573 00         	staq	pr5|event+event.frame.vcpu_time
    002671  aa  5 00116 4503 00         	stz	pr5|event+event.frame.page_faults
    002672  aa  5 00140 7573 00         	staq	pr5|global_start.real_time
    002673  aa  5 00142 7573 00         	staq	pr5|global_start.vcpu_time
    002674  aa  5 00144 4503 00         	stz	pr5|global_start.page_faults
                                  1519  
    002675                        1520  POP_TAB_AT_UNWIND:			" Restore the recursion level in the tab.
                                  1521  	pop_tab		pr5
    002675  aa  5 00122 2353 00         	lda	pr5|event+event.saved.level	" Revert tab.cts.level,
    002676  4a  4 00406 6043 20         	tmi	trace_error_halt_$trace_error_halt_
    002677  aa  2 00006 7553 00         	sta	pr2|tab.cts+counts.level
                                  1522  
    002700                        1523  POP_TRACE_FRAME_AT_UNWIND:
    002700  0a   003330 3522 20   1524  	epp2	null_ptr,*		" For safety.
                                  1525  
                                  1526  " Pop this frame off the stack of trace_catch_ frames.
                                  1527  
    002701  aa  5 00136 2373 00   1528  	ldaq	pr5|trace_frames_saved
    002702  aa  7 00072 7573 00   1529  	staq	pr7|stack_header.trace_frames
                                  1530  
                                  1531  " Permit tracing again.  We don't expect any errors from the few operations below.
                                  1532  
    002703  aa  7 00074 4503 00   1533  	stz	pr7|stack_header.in_trace
                                  1534  
                                  1535  " Start a metering interval, regardless of whether there is anything to meter.
                                  1536  
                                  1537  	start_metering_interval	return
    002704  8a   000340 6242 00         	eax4	global_parameters+global_parms.comps+from_return
    002705  9a  4 00021 7443 00         	stx4	pr4|start_comp		" Remember which compensations to use.
                                        
                                        	read_vcpu_time_and_page_faults	start
                                        
    002706  aa  6 00024 3573 00         	stcd	pr6|stack_frame.return_ptr
    002707  4a  4 00354 7133 20         	call6	cpu_time_and_paging_op_$cpu_time_and_paging_op_
                                        
    002710  aa  6 00000 3733 00         	epbp7	pr6|0
    002711  aa  6 00030 3703 20         	epp4	pr6|stack_frame.lp_ptr,*
    002712  9a  4 00016 7573 00         	staq	pr4|start+meters.vcpu_time   " Vcpu time is returned in AQ register.
    002713  9a  4 00020 7403 00         	stx0	pr4|start+meters.page_faults " Page faults are returned in X0 and X1.
    002714  9a  4 00020 4413 00         	sxl1	pr4|start+meters.page_faults
                                        
    002715                              NOTHING_TO_START.._00037:
                                  1538  
                                  1539  " Pop our stack frame.
                                  1540  
    002715  aa  7 00024 6523 00   1541  	spri6	pr7|stack_header.stack_end_ptr
    002716  aa  6 00020 3723 20   1542  	epp6	pr6|stack_frame.prev_sp,*
                                  1543  
                                  1544  " Return.
                                  1545  
    002717  aa  6 00000 3733 00   1546  	epbp7	pr6|0
    002720  aa  6 00030 3503 20   1547  	epp0	pr6|stack_frame.operator_ptr,*
    002721  aa  6 00025 6343 00   1548  	ldi	pr6|stack_frame.return_ptr+1
                                  1549  
                                  1550  " The read the clock as the last step for maximum accuracy.
                                  1551  
                                  1552  	read_the_calendar_clock	start
    002722  4a  4 00352 6333 20         	rccl	sys_info$clock_,*
    002723  9a  4 00014 7573 00         	staq	pr4|start+meters.real_time
                                  1553  
    002724  aa  6 00024 6103 00   1554  	rtcd	pr6|stack_frame.return_ptr
                                  1555  
    002725                        1556  	inhibit	off		<-> <-> <-> <-> <-> <-> <-> <-> <-> <->
                                  1557  
                                  1558  " This entrypoint disables the trace facility by yanking the trace operator
                                  1559  " pointers from the stack header.  It then flushes the frame and global meters
                                  1560  " from all the trace_catch_ frames on the stack.  It is
                                  1561  " only called if trace is enabled at the beginning of the transaction.
                                  1562  
                                  1563  " dcl  trace_catch_$stop_tracing entry ();
                                  1564  " call trace_catch_$stop_tracing ();
                                  1565  
                        002725    1566  	segdef	stop_tracing
    002725                        1567  stop_tracing:
                                  1568  	get_pr4
    002725  0a   002725 2130 00         	epaq	*
    002726  aa  7 00026 7641 61         	lprp4	pr7|stack_header.lot_ptr,*au
                                  1569  
                                  1570  " See if trace is disabled or effectively disabled.
                                  1571  
    002727  9a  4 00070 2341 00   1572  	szn	pr4|global_parameters+global_parms.enabled
    002730  0a   002743 6000 00   1573  	tze	STOP_SHORT_RETURN
    002731  9a  4 00065 2341 00   1574  	szn	pr4|global_parameters+global_parms.automatic
    002732  0a   002744 6010 00   1575  	tnz	YANK_OP_PTRS
    002733  9a  4 00067 2341 00   1576  	szn	pr4|global_parameters+global_parms.signals
    002734  0a   002744 6010 00   1577  	tnz	YANK_OP_PTRS
    002735  9a  4 00054 3515 20   1578  	epp1	pr4|tt_ptr,*
    002736  aa  1 00000 2371 00   1579  	ldaq	pr1|table.version
    002737  0a   003264 1170 00   1580  	cmpaq	TT_VERSION_3
    002740  4a  4 00406 6011 20   1581  	tnz	trace_error_halt_$trace_error_halt_
    002741  aa  1 00003 2341 00   1582  	szn	pr1|table.count
    002742  0a   002744 6010 00   1583  	tnz	YANK_OP_PTRS
    002743                        1584  STOP_SHORT_RETURN:
    002743  aa  7 00044 7101 20   1585  	short_return
                                  1586  
                                  1587  " Yank the pl1, ALM, and other language operator pointers from the stack header.
                                  1588  
    002744                        1589  YANK_OP_PTRS:
    002744  4a  4 00362 3715 20   1590  	epp5	pl1_operators_$operator_table
    002745  aa  7 00034 6515 00   1591  	spri5	pr7|stack_header.pl1_operators_ptr
    002746  4a  4 00364 3715 20   1592  	epp5	operator_pointers_$operator_pointers_
    002747  aa  7 00050 6515 00   1593  	spri5	pr7|stack_header.trans_op_tv_ptr
    002750  4a  4 00366 3715 20   1594  	epp5	pl1_operators_$alm_entry
    002751  aa  7 00046 6515 00   1595  	spri5	pr7|stack_header.entry_op_ptr
                                  1596  
    002752  4a  4 00414 7131 20   1597  	call6	trace_catch_$STOP_TRACING
                                  1598  
                                  1599  " Its nice to be able to act like a regular ALM program.
                                  1600  
                        002753    1601  	entry	STOP_TRACING
    002753                        1602  STOP_TRACING:
    002753  aa   000160 6270 00   1603  	push
    002754  aa  7 00040 2721 20
                                  1604  
                                  1605  " Go down the stack of trace_catch_ frames and update the global meters.
                                  1606  
    002755  aa  7 00072 2351 00   1607  	lda	pr7|stack_header.trace_frames+trace_frames.count
    002756  aa  7 00073 7651 00   1608  	lprp5	pr7|stack_header.trace_frames+trace_frames.top_ptr
                                  1609  
    002757                        1610  FLUSH_METERS_FROM_THIS_FRAME:
    002757  0a   003120 6000 00   1611  	tze	ALL_FRAMES_FLUSHED
    002760  aa   000001 1750 07   1612  	sba	1,dl
    002761  aa  5 00136 1151 00   1613  	cmpa	pr5|trace_frames_saved+trace_frames.count
    002762  4a  4 00406 6011 20   1614  	tnz	trace_error_halt_$trace_error_halt_
                                  1615  
                                  1616  " Get the tab_ptr, if this entrypoint is still in the trace table.
                                  1617  
    002763  9a  4 00054 3515 20   1618  	epp1	pr4|tt_ptr,*
    002764  aa  1 00000 2371 00   1619  	ldaq	pr1|table.version
    002765  0a   003264 1170 00   1620  	cmpaq	TT_VERSION_3
    002766  4a  4 00406 6011 20   1621  	tnz	trace_error_halt_$trace_error_halt_
                                  1622  
    002767  aa  5 00117 2361 00   1623  	ldq	pr5|event+event.entry_ptr	" Q reg contains the value we are looking for.
                                  1624  
                                  1625  	seek_table	EP_IS_IN_TT_AT_STOP,FLUSH_NEXT_FRAME
    002770  aa  1 00005 2351 00         	lda	pr1|table.idx+idx.high
    002771  aa   000001 7350 00         	als	1
    002772  aa  1 00010 3521 05         	epp2	pr1|table.e,al	" Pr2 points to high half.
    002773  aa  1 00002 2351 00         	lda	pr1|table.max_count
    002774  aa  1 00005 1751 00         	sba	pr1|table.idx+idx.high " If table.max_count - idx.high = 0,
    002775  0a   003004 6000 00         	tze	SEEK_LOW.._00040	" then the high half is empty.
    002776  4a  4 00406 6041 20         	tmi	trace_error_halt_$trace_error_halt_
    002777  aa  2 00000 1161 00         	cmpq	pr2|te.key	" If Q - table.e (idx.high) < 0
    003000  0a   003004 6040 00         	tmi	SEEK_LOW.._00040
    003001  0a   003012 6054 00         	tpnz	BINARY_LOOP.._00040
    003002  aa  1 00004 7221 00         	lxl2	pr1|table.idx+idx.low " Good luck.  We found it.
    003003  0a   003044 7100 00         	tra	EP_IS_IN_TT_AT_STOP
                                        
    003004                              SEEK_LOW.._00040:
    003004  aa  1 00010 3521 00         	epp2	pr1|table.e	" Pr2 points to low half.
    003005  aa  1 00004 2351 00         	lda	pr1|table.idx+idx.low	" A = number of entries in low half.
    003006  0a   003012 6054 00         	tpnz	BINARY_LOOP.._00040	" If A > 0, then do a binary search.
    003007  4a  4 00406 6041 20         	tmi	trace_error_halt_$trace_error_halt_
    003010  aa   000000 6220 00         	eax2	0		" else it's not in the table.
    003011  0a   003115 7100 00         	tra	FLUSH_NEXT_FRAME
                                        
                                        " The binary search uses pr2 to point to the group of remaining candidates.
                                        " It uses the A register to contain the number of remaining candidates.
                                        " During the search uses X2 to represent the offset to the middle of the candidates.
                                        
    003012                              BINARY_LOOP.._00040:		" X2 contains offset that divides portion in half,
    003012  aa   777777 6220 05         	eax2	-1,al		" with the upper division being the larger one.
    003013  0a   003025 6040 00         	tmi	BINARY_NOT_FOUND.._00040 " Quit, if the portion is zero length.
                                        
    003014  aa   777776 3620 03         	anx2	=o777776,du	" Truncate offset in x2 to a double word boundary.
    003015  aa   000001 7310 00         	ars	1		" Calculate size of the portion for the next pass.
                                        
    003016  aa  2 00000 1161 12         	cmpq	pr2|te.key,x2	" If value we are looking for is LESS than value we
    003017  0a   003012 6040 00         	tmi	BINARY_LOOP.._00040	" are looking at, then look again in LOWER division.
                                        
    003020  aa  2 00002 3521 12         	epp2	pr2|te_size,x2	" If value we are looking for is MORE than value we
    003021  0a   003012 6054 00         	tpnz	BINARY_LOOP.._00040	" are looking at, then look again in UPPER division.
                                        
    003022  aa  2 77776 3521 00         	epp2	pr2|-te_size	" Success!  The binary search always
    003023  0a   003044 6210 00         	eax1	EP_IS_IN_TT_AT_STOP	" succeeds with PR2 -> to the next entry.
    003024  0a   003026 7100 00         	tra	FIGURE_INDEX.._00040
                                        
    003025                              BINARY_NOT_FOUND.._00040:		" The binary search always fails with
    003025  0a   003115 6210 00         	eax1	FLUSH_NEXT_FRAME	" PR2 -> entry where it should have been.
                                        
    003026                              FIGURE_INDEX.._00040:
    003026  aa  1 00010 6351 00         	eaa	pr1|table.e	" Calculate the winning index.
    003027  aa   000023 7710 00         	arl	19
    003030  aa  1 00006 7551 00         	sta	pr1|table.working_storage
    003031  aa  2 00000 6351 00         	eaa	pr2|0
    003032  aa   000023 7710 00         	arl	19
    003033  aa  1 00006 1751 00         	sba	pr1|table.working_storage
    003034  aa   000000 6220 05         	eax2	0,al
    003035  aa  1 00004 1151 00         	cmpa	pr1|table.idx+idx.low	" If index - idx.low <= 0,
    003036  aa   000000 6044 11         	tmoz	0,x1	" then it is in the low half and we are done.
    003037  aa  1 00005 1751 00         	sba	pr1|table.idx+idx.high
    003040  4a  4 00406 6041 20         	tmi	trace_error_halt_$trace_error_halt_
    003041  aa  1 00004 0751 00         	ada	pr1|table.idx+idx.low
    003042  aa   000000 6220 05         	eax2	0,al		" index = index - idx.high + idx.low;
    003043  aa   000000 7100 11         	tra	0,x1
                                  1626  
    003044                        1627  EP_IS_IN_TT_AT_STOP:
    003044  aa  2 00001 7621 00   1628  	lprp2	pr2|te.data
    003045  aa  2 00000 2371 00   1629  	ldaq	pr2|tab.version
    003046  0a   003266 1170 00   1630  	cmpaq	TAB_VERSION_3
    003047  4a  4 00406 6011 20   1631  	tnz	trace_error_halt_$trace_error_halt_
                                  1632  
                                  1633  " Add the meters to the tab and to trace_catch_$metered.
                                  1634  
                                  1635  	update_tab_meters	pr5
    003050  9a  4 00036 2371 00         	ldaq	pr4|metered+meters.real_time
    003051  aa  5 00112 0771 00         	adaq	pr5|event+event.frame.real_time	" Update metered real time.
    003052  9a  4 00036 7571 00         	staq	pr4|metered+meters.real_time
                                        
    003053  aa  2 00010 2371 00         	ldaq	pr2|tab.local+meters.real_time
    003054  aa  5 00112 0771 00         	adaq	pr5|event+event.frame.real_time	" Update tab real time.
    003055  aa  2 00010 7571 00         	staq	pr2|tab.local+meters.real_time
                                        
    003056  9a  4 00040 2371 00         	ldaq	pr4|metered+meters.vcpu_time
    003057  aa  5 00114 0771 00         	adaq	pr5|event+event.frame.vcpu_time	" Update metered vcpu time.
    003060  9a  4 00040 7571 00         	staq	pr4|metered+meters.vcpu_time
                                        
    003061  aa  2 00012 2371 00         	ldaq	pr2|tab.local+meters.vcpu_time
    003062  aa  5 00114 0771 00         	adaq	pr5|event+event.frame.vcpu_time	" Update tab real time.
    003063  aa  2 00012 7571 00         	staq	pr2|tab.local+meters.vcpu_time
                                        
    003064  aa  5 00116 2351 00         	lda	pr5|event+event.frame.page_faults
    003065  9a  4 00042 0551 00         	asa	pr4|metered+meters.page_faults " Update metered page faults.
    003066  aa  2 00014 0551 00         	asa	pr2|tab.local+meters.page_faults " Update tab page faults.
                                        
    003067  aa  5 00140 2371 00         	ldaq	pr5|global_start.real_time
    003070  0a   003106 6000 00         	tze	FRAME_METERS_UPDATED.._00041	" No global metering in this frame.
                                        
    003071  9a  4 00036 2371 00         	ldaq	pr4|metered+meters.real_time	" Update global real time.
    003072  aa  5 00140 1771 00         	sbaq	pr5|global_start.real_time
    003073  4a  4 00406 6041 20         	tmi	trace_error_halt_$trace_error_halt_
    003074  aa  2 00016 0771 00         	adaq	pr2|tab.global+meters.real_time
    003075  aa  2 00016 7571 00         	staq	pr2|tab.global+meters.real_time
                                        
    003076  9a  4 00040 2371 00         	ldaq	pr4|metered+meters.vcpu_time	" Update global vcpu time.
    003077  aa  5 00142 1771 00         	sbaq	pr5|global_start.vcpu_time
    003100  aa  2 00020 0771 00         	adaq	pr2|tab.global+meters.vcpu_time
    003101  aa  2 00020 7571 00         	staq	pr2|tab.global+meters.vcpu_time
                                        
    003102  9a  4 00042 2351 00         	lda	pr4|metered+meters.page_faults " Update global page faults.
    003103  aa  5 00144 1751 00         	sba	pr5|global_start.page_faults
    003104  4a  4 00406 6041 20         	tmi	trace_error_halt_$trace_error_halt_
    003105  aa  2 00022 0551 00         	asa	pr2|tab.global+meters.page_faults
                                        
    003106                              FRAME_METERS_UPDATED.._00041:
    003106  aa   000110 7370 00         	lls	72			" Insure that they are not used again.
    003107  aa  5 00112 7571 00         	staq	pr5|event+event.frame.real_time
    003110  aa  5 00114 7571 00         	staq	pr5|event+event.frame.vcpu_time
    003111  aa  5 00116 4501 00         	stz	pr5|event+event.frame.page_faults
    003112  aa  5 00140 7571 00         	staq	pr5|global_start.real_time
    003113  aa  5 00142 7571 00         	staq	pr5|global_start.vcpu_time
    003114  aa  5 00144 4501 00         	stz	pr5|global_start.page_faults
                                  1636  
    003115                        1637  FLUSH_NEXT_FRAME:
    003115  aa  5 00136 2351 00   1638  	lda	pr5|trace_frames_saved+trace_frames.count
    003116  aa  5 00137 7651 00   1639  	lprp5	pr5|trace_frames_saved+trace_frames.top_ptr
    003117  0a   002757 7100 00   1640  	tra	FLUSH_METERS_FROM_THIS_FRAME
                                  1641  
    003120                        1642  ALL_FRAMES_FLUSHED:
    003120  aa  7 00042 7101 20   1643  	return
                                  1644  
                                  1645  " This entrypoint is called at the end of a trace command transaction to plant
                                  1646  " the operator pointers and restart global metering.  It is only called if
                                  1647  " trace is enabled at the end of the transaction.  It plants the operators and
                                  1648  " reads the meters into trace_catch_$start.
                                  1649  
                                  1650  " dcl  trace_catch_$start_tracing entry ();
                                  1651  " call trace_catch_$start_tracing ();
                                  1652  
                        003121    1653  	entry	start_tracing
    003121                        1654  start_tracing:
    003121  aa   000160 6270 00   1655  	push
    003122  aa  7 00040 2721 20
                                  1656  
                                  1657  " See if trace is disabled or effectively disabled.
                                  1658  
    003123  9a  4 00070 2341 00   1659  	szn	pr4|global_parameters+global_parms.enabled
    003124  0a   003256 6000 00   1660  	tze	START_RETURN
    003125  9a  4 00065 2341 00   1661  	szn	pr4|global_parameters+global_parms.automatic
    003126  0a   003137 6010 00   1662  	tnz	RESTART_METERS
    003127  9a  4 00067 2341 00   1663  	szn	pr4|global_parameters+global_parms.signals
    003130  0a   003137 6010 00   1664  	tnz	RESTART_METERS
    003131  9a  4 00054 3515 20   1665  	epp1	pr4|tt_ptr,*
    003132  aa  1 00000 2371 00   1666  	ldaq	pr1|table.version
    003133  0a   003264 1170 00   1667  	cmpaq	TT_VERSION_3
    003134  4a  4 00406 6011 20   1668  	tnz	trace_error_halt_$trace_error_halt_
    003135  aa  1 00003 2341 00   1669  	szn	pr1|table.count
    003136  0a   003256 6000 00   1670  	tze	START_RETURN
                                  1671  
                                  1672  " Go down the stack of trace_catch_ frames and restart the global meters.
                                  1673  
    003137                        1674  RESTART_METERS:
    003137  aa  7 00072 2351 00   1675  	lda	pr7|stack_header.trace_frames+trace_frames.count
    003140  aa  7 00073 7651 00   1676  	lprp5	pr7|stack_header.trace_frames+trace_frames.top_ptr
                                  1677  
    003141                        1678  START_METERS_IN_THIS_FRAME:
    003141  0a   003246 6000 00   1679  	tze	ALL_FRAMES_STARTED
    003142  aa   000001 1750 07   1680  	sba	1,dl
    003143  aa  5 00136 1151 00   1681  	cmpa	pr5|trace_frames_saved+trace_frames.count
    003144  4a  4 00406 6011 20   1682  	tnz	trace_error_halt_$trace_error_halt_
                                  1683  
                                  1684  " Get the tab_ptr, if this entrypoint is still in the trace table.
                                  1685  
    003145  9a  4 00054 3515 20   1686  	epp1	pr4|tt_ptr,*
    003146  aa  1 00000 2371 00   1687  	ldaq	pr1|table.version
    003147  0a   003264 1170 00   1688  	cmpaq	TT_VERSION_3
    003150  4a  4 00406 6011 20   1689  	tnz	trace_error_halt_$trace_error_halt_
                                  1690  
    003151  aa  5 00117 2361 00   1691  	ldq	pr5|event+event.entry_ptr	" Q reg contains the value we are looking for.
                                  1692  
                                  1693  	seek_table	EP_IS_IN_TT_AT_START,START_NEXT_FRAME
    003152  aa  1 00005 2351 00         	lda	pr1|table.idx+idx.high
    003153  aa   000001 7350 00         	als	1
    003154  aa  1 00010 3521 05         	epp2	pr1|table.e,al	" Pr2 points to high half.
    003155  aa  1 00002 2351 00         	lda	pr1|table.max_count
    003156  aa  1 00005 1751 00         	sba	pr1|table.idx+idx.high " If table.max_count - idx.high = 0,
    003157  0a   003166 6000 00         	tze	SEEK_LOW.._00042	" then the high half is empty.
    003160  4a  4 00406 6041 20         	tmi	trace_error_halt_$trace_error_halt_
    003161  aa  2 00000 1161 00         	cmpq	pr2|te.key	" If Q - table.e (idx.high) < 0
    003162  0a   003166 6040 00         	tmi	SEEK_LOW.._00042
    003163  0a   003174 6054 00         	tpnz	BINARY_LOOP.._00042
    003164  aa  1 00004 7221 00         	lxl2	pr1|table.idx+idx.low " Good luck.  We found it.
    003165  0a   003226 7100 00         	tra	EP_IS_IN_TT_AT_START
                                        
    003166                              SEEK_LOW.._00042:
    003166  aa  1 00010 3521 00         	epp2	pr1|table.e	" Pr2 points to low half.
    003167  aa  1 00004 2351 00         	lda	pr1|table.idx+idx.low	" A = number of entries in low half.
    003170  0a   003174 6054 00         	tpnz	BINARY_LOOP.._00042	" If A > 0, then do a binary search.
    003171  4a  4 00406 6041 20         	tmi	trace_error_halt_$trace_error_halt_
    003172  aa   000000 6220 00         	eax2	0		" else it's not in the table.
    003173  0a   003243 7100 00         	tra	START_NEXT_FRAME
                                        
                                        " The binary search uses pr2 to point to the group of remaining candidates.
                                        " It uses the A register to contain the number of remaining candidates.
                                        " During the search uses X2 to represent the offset to the middle of the candidates.
                                        
    003174                              BINARY_LOOP.._00042:		" X2 contains offset that divides portion in half,
    003174  aa   777777 6220 05         	eax2	-1,al		" with the upper division being the larger one.
    003175  0a   003207 6040 00         	tmi	BINARY_NOT_FOUND.._00042 " Quit, if the portion is zero length.
                                        
    003176  aa   777776 3620 03         	anx2	=o777776,du	" Truncate offset in x2 to a double word boundary.
    003177  aa   000001 7310 00         	ars	1		" Calculate size of the portion for the next pass.
                                        
    003200  aa  2 00000 1161 12         	cmpq	pr2|te.key,x2	" If value we are looking for is LESS than value we
    003201  0a   003174 6040 00         	tmi	BINARY_LOOP.._00042	" are looking at, then look again in LOWER division.
                                        
    003202  aa  2 00002 3521 12         	epp2	pr2|te_size,x2	" If value we are looking for is MORE than value we
    003203  0a   003174 6054 00         	tpnz	BINARY_LOOP.._00042	" are looking at, then look again in UPPER division.
                                        
    003204  aa  2 77776 3521 00         	epp2	pr2|-te_size	" Success!  The binary search always
    003205  0a   003226 6210 00         	eax1	EP_IS_IN_TT_AT_START	" succeeds with PR2 -> to the next entry.
    003206  0a   003210 7100 00         	tra	FIGURE_INDEX.._00042
                                        
    003207                              BINARY_NOT_FOUND.._00042:		" The binary search always fails with
    003207  0a   003243 6210 00         	eax1	START_NEXT_FRAME	" PR2 -> entry where it should have been.
                                        
    003210                              FIGURE_INDEX.._00042:
    003210  aa  1 00010 6351 00         	eaa	pr1|table.e	" Calculate the winning index.
    003211  aa   000023 7710 00         	arl	19
    003212  aa  1 00006 7551 00         	sta	pr1|table.working_storage
    003213  aa  2 00000 6351 00         	eaa	pr2|0
    003214  aa   000023 7710 00         	arl	19
    003215  aa  1 00006 1751 00         	sba	pr1|table.working_storage
    003216  aa   000000 6220 05         	eax2	0,al
    003217  aa  1 00004 1151 00         	cmpa	pr1|table.idx+idx.low	" If index - idx.low <= 0,
    003220  aa   000000 6044 11         	tmoz	0,x1	" then it is in the low half and we are done.
    003221  aa  1 00005 1751 00         	sba	pr1|table.idx+idx.high
    003222  4a  4 00406 6041 20         	tmi	trace_error_halt_$trace_error_halt_
    003223  aa  1 00004 0751 00         	ada	pr1|table.idx+idx.low
    003224  aa   000000 6220 05         	eax2	0,al		" index = index - idx.high + idx.low;
    003225  aa   000000 7100 11         	tra	0,x1
                                  1694  
    003226                        1695  EP_IS_IN_TT_AT_START:
    003226  aa  2 00001 7621 00   1696  	lprp2	pr2|te.data
    003227  aa  2 00000 2371 00   1697  	ldaq	pr2|tab.version
    003230  0a   003266 1170 00   1698  	cmpaq	TAB_VERSION_3
    003231  4a  4 00406 6011 20   1699  	tnz	trace_error_halt_$trace_error_halt_
                                  1700  
                                  1701  " Reset the global meters for this procedure if this is the first level of recursion.
                                  1702  
                                  1703  	start_global_metering_interval	pr5
                                        
    003232  aa  5 00122 2351 00         	lda	pr5|event+event.saved.level	" Only start global meters
    003233  0a   003243 6054 00         	tpnz	GLOBAL_INTERVAL_STARTED.._00043	" at recursion level 1.
    003234  4a  4 00406 6041 20         	tmi	trace_error_halt_$trace_error_halt_
                                        
    003235  9a  4 00042 2351 00         	lda	pr4|metered+meters.page_faults
    003236  aa  5 00144 7551 00         	sta	pr5|global_start.page_faults
                                        
    003237  9a  4 00040 2371 00         	ldaq	pr4|metered+meters.vcpu_time
    003240  aa  5 00142 7571 00         	staq	pr5|global_start.vcpu_time
                                        
    003241  9a  4 00036 2371 00         	ldaq	pr4|metered+meters.real_time	" Store this one last because it shows
    003242  aa  5 00140 7571 00         	staq	pr5|global_start.real_time " that the others are valid.
                                        
    003243                              GLOBAL_INTERVAL_STARTED.._00043:
                                  1704  
    003243                        1705  START_NEXT_FRAME:
    003243  aa  5 00136 2351 00   1706  	lda	pr5|trace_frames_saved+trace_frames.count
    003244  aa  5 00137 7651 00   1707  	lprp5	pr5|trace_frames_saved+trace_frames.top_ptr
    003245  0a   003141 7100 00   1708  	tra	START_METERS_IN_THIS_FRAME
                                  1709  
                                  1710  " Plant the pl1 and other language operator pointers in the stack header.
                                  1711  
    003246                        1712  ALL_FRAMES_STARTED:
    003246  4a  4 00370 3715 20   1713  	epp5	pl1_operators_$trace_operator_table
    003247  aa  7 00034 6515 00   1714  	spri5	pr7|stack_header.pl1_operators_ptr
    003250  4a  4 00372 3715 20   1715  	epp5	trace_operator_pointers_$trace_operator_pointers_
    003251  aa  7 00050 6515 00   1716  	spri5	pr7|stack_header.trans_op_tv_ptr
                                  1717  
                                  1718  " Plant the ALM operator only if alm is on.
                                  1719  
    003252  9a  4 00064 2341 00   1720  	szn	pr4|global_parameters+global_parms.alm
    003253  0a   003256 6000 00   1721  	tze	*+3
    003254  4a  4 00374 3715 20   1722  	epp5	pl1_operators_$trace_alm_entry
    003255  aa  7 00046 6515 00   1723  	spri5	pr7|stack_header.entry_op_ptr
                                  1724  
    003256                        1725  START_RETURN:
    003256  aa  7 00042 7101 20   1726  	return
                                  1727  
                                  1728  " CONSTANTS   CONSTANTS   CONSTANTS   CONSTANTS   CONSTANTS   CONSTANTS   CONSTANTS
                                  1729  
                                  1730  
    003257  aa   000000 0110 03   1731  			even
    003260  aa  124 162 141 143   1732  BUFFER_VERSION_3:		aci	/TraceBF3/,8
    003261  aa  145 102 106 063
                                  1733  
                                  1734  			even
    003262  aa  124 105 126 063   1735  EVENT_VERSION_3:		aci	/TEV3/,4
                                  1736  
    003263  aa   000000 0110 03   1737  			even
    003264  aa  124 162 141 143   1738  TT_VERSION_3:		aci	/TraceTT3/,8
    003265  aa  145 124 124 063
                                  1739  
                                  1740  			even
    003266  aa  124 162 141 143   1741  TAB_VERSION_3:		aci	/TraceTB3/,8
    003267  aa  145 124 102 063
                                  1742  
                                  1743  			even
    003270  aa  124 162 141 143   1744  PARAMETERS_VERSION_3:	aci	/TraceTP3/,8
    003271  aa  145 124 120 063
                                  1745  
                                  1746  			even
    003272  aa  124 162 141 143   1747  GLOBAL_PARAMETERS_VERSION_3:	aci	/TraceGP3/,8
    003273  aa  145 107 120 063
                                  1748  
                                  1749  			even
    003274  aa  125 156 165 163   1750  UNUSUAL_SIGNAL_ARG_LIST:	aci	/Unusual signal_ arg list/,24
    003275  aa  165 141 154 040
    003276  aa  163 151 147 156
    003277  aa  141 154 137 040
    003300  aa  141 162 147 040
    003301  aa  154 151 163 164
                                  1751  
                                  1752  			even
    003302  aa   000000 000004    1753  zero_arg_list_header:	oct	000000000004,000000000000
    003303  aa   000000 000000 
    003304  aa   000002 000004    1754  one_arg_list_header:	oct	000002000004,000000000000
    003305  aa   000000 000000 
    003306  aa   000004 000004    1755  two_arg_list_header:	oct	000004000004,000000000000
    003307  aa   000000 000000 
    003310  aa   000006 000004    1756  three_arg_list_header:	oct	000006000004,000000000000
    003311  aa   000000 000000 
    003312  aa   000010 000004    1757  four_arg_list_header:	oct	000010000004,000000000000
    003313  aa   000000 000000 
    003314  aa   000012 000004    1758  five_arg_list_header:	oct	000012000004,000000000000
    003315  aa   000000 000000 
                                  1759  
    003316  aa   000002 000010    1760  one_arg_list_header_w_env:	oct	000002000010,000000000000
    003317  aa   000000 000000 
    003320  aa   000004 000010    1761  two_arg_list_header_w_env:	oct	000004000010,000000000000
    003321  aa   000000 000000 
    003322  aa   000006 000010    1762  three_arg_list_header_w_env:	oct	000006000010,000000000000
    003323  aa   000000 000000 
    003324  aa   000010 000010    1763  four_arg_list_header_w_env:	oct	000010000010,000000000000
    003325  aa   000000 000000 
    003326  aa   000012 000010    1764  five_arg_list_header_w_env:	oct	000012000010,000000000000
    003327  aa   000000 000000 
                                  1765  
    003330  aa   077777 000043    1766  null_ptr:			oct	077777000043,000001000000
    003331  aa   000001 000000 
    003332  aa   077777 000077    1767  ptr_mask:			oct	077777000077,777777077077
    003333  aa   777777 077077 
                                  1768  
    003334  aa   000000 000000    1769  double_precision_one:	dec	0,1
    003335  aa   000000 000001 
                                  1770  
    003336  aa   000000 000000    1771  vcpu_time_fuzz:		dec	0,16
    003337  aa   000000 000020 
                                  1772  
    003340  aa   007777 000001    1773  packed_null:		oct	007777000001
                                  1774  
                                  1775  " INTERNAL STATIC   INTERNAL STATIC   INTERNAL STATIC   INTERNAL STATIC   INTERNAL STATIC
                                  1776  
                                  1777  		use	static_section
                                  1778  		join	/link/static_section
                                  1779  
    000010  aa   007777 000001    1780  TRANSACTION_BEGIN:		oct	007777000001
    000011  aa   007777 000001    1781  TRANSACTION_BEGIN_FORCE:	oct	007777000001
    000012  aa   007777 000001    1782  SIGNAL_:			oct	007777000001
    000013  aa   007777 000001    1783  IO_SIGNAL:		oct	007777000001
                                  1784  
                                  1785  		even
    000014  aa   000000 000000    1786  start:		dec	0,0,0,0,0
    000015  aa   000000 000000 
    000016  aa   000000 000000 
    000017  aa   000000 000000 
    000020  aa   000000 000000 
    000021  aa   000000 000000    1787  start_comp:	dec	0		" UPPER HALF WORD
                                  1788  		even
    000022  aa   000000 000000    1789  stop:		dec	0,0,0,0,0
    000023  aa   000000 000000 
    000024  aa   000000 000000 
    000025  aa   000000 000000 
    000026  aa   000000 000000 
    000027  aa   000000 0110 03   1790  		even
    000030  aa   000000 000000    1791  delta:		dec	0,0,0,0,0
    000031  aa   000000 000000 
    000032  aa   000000 000000 
    000033  aa   000000 000000 
    000034  aa   000000 000000 
                                  1792  
    000035  aa   000000 0110 03   1793  		even
                        000036    1794  		segdef	metered
    000036  aa   000000 000000    1795  metered:		dec	0,1,0,1,1
    000037  aa   000000 000001 
    000040  aa   000000 000000 
    000041  aa   000000 000001 
    000042  aa   000000 000001 
                                  1796  
    000043  aa   000000 0110 03   1797  		even
                        000044    1798  		segdef	removed
    000044  aa   000000 000000    1799  removed:		dec	0,1,0,1,1
    000045  aa   000000 000001 
    000046  aa   000000 000000 
    000047  aa   000000 000001 
    000050  aa   000000 000001 
                                  1800  
    000051  aa   000000 0110 03   1801  		even
                        000052    1802  		segdef	trace_storage_ptr
    000052  aa   077777 000043    1803  trace_storage_ptr:	its	-1,1
    000053  aa   000001 000000 
                                  1804  
                                  1805  		even
                        000054    1806  		segdef	tt_ptr
    000054  aa   077777 000043    1807  tt_ptr:		its	-1,1
    000055  aa   000001 000000 
                                  1808  
                                  1809  		even
                        000056    1810  		segdef	wt_ptr
    000056  aa   077777 000043    1811  wt_ptr:		its	-1,1
    000057  aa   000001 000000 
                                  1812  
                        000060    1813  		segdef	parameters_ptr
    000060  aa   007777 000001    1814  parameters_ptr:	oct	007777000001
                                  1815  
    000061  aa   000000 0110 03   1816  		even
                        000062    1817  		segdef	global_parameters
    000062                        1818  		bss	global_parameters,182
                                  1819  
                                  1820  " SYMBOLS  SYMBOLS  SYMBOLS  SYMBOLS  SYMBOLS  SYMBOLS  SYMBOLS  SYMBOLS
                                  1821  
                        400000    1822  	bool	TRUE,400000
                                  1823  
                                  1824  "
                                  1825  "	Structure table
                                  1826  "
                        000000    1827  	equ	table.version,0		" DOUBLE
                        000002    1828  	equ	table.max_count,2
                        000003    1829  	equ	table.count,3
                                  1830  
                        000004    1831  	equ	table.idx,4		" LEVEL 2
                        000000    1832  	equ	      idx.low,0
                        000001    1833  	equ	      idx.high,1
                                  1834  
                        000006    1835  	equ	table.working_storage,6	" DOUBLE
                        000010    1836  	equ	table.e,8			" DOUBLE
                                  1837  
                                  1838  "
                                  1839  "	Structure te
                                  1840  "
                        000002    1841  	equ	te_size,2
                                  1842  
                        000000    1843  	equ	te,0			" DOUBLE
                        000000    1844  	equ	te.key,0
                        000001    1845  	equ	te.data,1
                                  1846  
                                  1847  "
                                  1848  "	Structure tab
                                  1849  "
                        000000    1850  	equ	tab.version,0		" DOUBLE
                        000002    1851  	equ	tab.reference_count,2
                        000003    1852  	equ	tab.parms_ptr,3
                                  1853  
                        000004    1854  	equ	tab.cts,4			" like counts
                                  1855  
                        000010    1856  	equ	tab.local,8		" like meters
                                  1857  
                        000015    1858  	equ	tab.on,13
                                  1859  
                        000016    1860  	equ	tab.global,14		" like meters
                                  1861  
                        000023    1862  	equ	tab.translator_id,19
                        000024    1863  	equ	tab.function,20
                                  1864  
                                  1865  "
                                  1866  "	Structure event is a 16 word block that describes a trace event.
                                  1867  "
                        000020    1868  	equ	event_size,16
                                  1869  
                        000000    1870  	equ	event.version,0
                        000001    1871  	equ	event.kind,1		" UPPER
                        000001    1872  	equ	event.frame_count,1		" LOWER
                                  1873  
                        000002    1874  	equ	event.frame,2		" LEVEL 2
                        000002    1875  	equ	event.frame.real_time,2		" DOUBLE
                        000004    1876  	equ	event.frame.vcpu_time,4		" DOUBLE
                        000006    1877  	equ	event.frame.page_faults,6
                                  1878  
                        000007    1879  	equ	event.entry_ptr,7
                        000010    1880  	equ	event.saved,8		" LEVEL 2
                        000010    1881  	equ	event.saved.calls,8		" DOUBLE
                        000012    1882  	equ	event.saved.level,10
                        000013    1883  	equ	event.saved.max_level,11
                                  1884  
                        000014    1885  	equ	event.entry_idx,12
                        000015    1886  	equ	event.arg_list_ptr,13
                        000016    1887  	equ	event.callers_sp,14
                        000017    1888  	equ	event.return_ptr,15
                                  1889  
                                  1890  "
                                  1891  "	Structure counts is passed to the trace and stop routines.
                                  1892  "
                        000000    1893  	equ	counts.calls,0		" DOUBLE
                        000002    1894  	equ	counts.level,2
                        000003    1895  	equ	counts.max_level,3
                                  1896  
                                  1897  "
                                  1898  "	Structure buffer of trace events.
                                  1899  "
                        000000    1900  	equ	buffer.h,0		" LEVEL 2
                        000000    1901  	equ	buffer.h.version,0		" DOUBLE
                        000002    1902  	equ	buffer.h.not_used,2
                        000003    1903  	equ	buffer.h.count,3
                        000004    1904  	equ	buffer.e,4		" (0 : 8191) like event
                                  1905  
                                  1906  "
                                  1907  "	Structure meters
                                  1908  "
                        000000    1909  	equ	meters.real_time,0		" DOUBLE
                        000002    1910  	equ	meters.vcpu_time,2		" DOUBLE
                        000004    1911  	equ	meters.page_faults,4
                                  1912  
                                  1913  "
                                  1914  "	Structure parms
                                  1915  "
                        000000    1916  	equ	parms.version,0		" DOUBLE
                        000002    1917  	equ	parms.reference_count,2
                        000003    1918  	equ	parms.every,3
                        000004    1919  	equ	parms.first,4
                        000005    1920  	equ	parms.last,5
                        000006    1921  	equ	parms.low,6
                        000007    1922  	equ	parms.high,7
                                  1923  
                        000010    1924  	equ	parms.new_high,8
                        000011    1925  	equ	parms.arguments,9
                        000012    1926  	equ	parms.not_used1,10
                        000013    1927  	equ	parms.stop_every,11
                        000014    1928  	equ	parms.stop_low,12
                        000015    1929  	equ	parms.stop,13
                        000016    1930  	equ	parms.trace,14
                        000017    1931  	equ	parms.call_ptr,15
                                  1932  
                                  1933  "
                                  1934  "	Structure global_parms (182 words)
                                  1935  "
                        000000    1936  	equ	global_parms.version,0	" DOUBLE
                        000002    1937  	equ	global_parms.alm,2
                        000003    1938  	equ	global_parms.automatic,3
                        000004    1939  	equ	global_parms.meter,4
                        000005    1940  	equ	global_parms.signals,5
                        000006    1941  	equ	global_parms.enabled,6
                        000007    1942  	equ	global_parms.long,7
                                  1943  
                        000010    1944  	equ	global_parms.osw,8		" LEVEL 2
                        000010    1945  	equ	global_parms.osw.iocb_ptr,8
                        000012    1946  	equ	global_parms.osw.stream_name,10
                        000023    1947  	equ	global_parms.osw.file_path,19
                                  1948  
                        000124    1949  	equ	global_parms.spp,84		" LEVEL 2
                        000124    1950  	equ	global_parms.spp.entry_value,84
                        000130    1951  	equ	global_parms.spp.entry_name,88
                                  1952  
                        000232    1953  	equ	global_parms.trace_routine,154
                        000236    1954  	equ	global_parms.stop_routine,158
                                  1955  
                        000242    1956  	equ	global_parms.loud,162
                        000243    1957  	equ	global_parms.calibrate,163
                        000244    1958  	equ	global_parms.buffer_ptr,164
                        000245    1959  	equ	global_parms.not_used,165
                                  1960  
                        000246    1961  	equ	global_parms.comps,166	" LEVEL 2
                                  1962  
                        000000    1963  	equ	from_entry,0
                        000010    1964  	equ	from_return,8
                                  1965  
                        000000    1966  	equ	to_entry.real_time,0
                        000002    1967  	equ	to_entry.vcpu_time,2
                        000004    1968  	equ	to_return.real_time,4
                        000006    1969  	equ	to_return.vcpu_time,6
                                  1970  
                                  1971  	include	stack_header
                                   1-1  "	BEGIN INCLUDE FILE ... stack_header.incl.alm  3/72  Bill Silver
                                   1-2  "
                                   1-3  "	modified 7/76 by M. Weaver for *system links and more system use of areas
                                   1-4  "	modified 3/77 by M. Weaver  to add rnt_ptr
                                   1-5  "	modified 7/77 by S. Webber to add run_unit_depth and assign_linkage_ptr
                                   1-6  "	modified 6/83 by J. Ives to add trace_frames and in_trace.
                                   1-7  
                                   1-8  " HISTORY COMMENTS:
                                   1-9  "  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
                                  1-10  "     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
                                  1-11  "     added the heap_header_ptr definition
                                  1-12  "  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
                                  1-13  "     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
                                  1-14  "     Modified to support control point management.  These changes were
                                  1-15  "     actually made in February 1985 by G. Palter.
                                  1-16  "  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
                                  1-17  "     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
                                  1-18  "     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
                                  1-19  "     bit pad after cur_lot_size for the cpm_enabled. This was done to save
                                  1-20  "     some space int the stack header and change the cpd_ptr unal to
                                  1-21  "     cpm_data_ptr (ITS pair).
                                  1-22  "                                                      END HISTORY COMMENTS
                                  1-23  
                        000004    1-24  	equ	stack_header.cpm_data_ptr,4		ptr to control point for this stack
                        000006    1-25  	equ	stack_header.combined_stat_ptr,6	ptr to separate static area
                                  1-26  
                        000010    1-27  	equ	stack_header.clr_ptr,8		ptr to area containing linkage sections
                        000012    1-28  	equ	stack_header.max_lot_size,10		number of words allowed in lot (DU)
                        000012    1-29  	equ	stack_header.main_proc_invoked,10	nonzero if main proc was invoked in run unit (DL)
                        000012    1-30  	equ	stack_header.run_unit_depth,10	number of active run units stacked (DL)
                        000013    1-31  	equ	stack_header.cur_lot_size,11		DU number of words (entries) in lot
                        000013    1-32            equ	stack_header.cpm_enabled,11		DL  non-zero if control point management is enabled
                        000014    1-33  	equ	stack_header.system_free_ptr,12	ptr to system storage area
                        000016    1-34  	equ	stack_header.user_free_ptr,14		ptr to user storage area
                                  1-35  
                        000020    1-36  	equ	stack_header.parent_ptr,16		ptr to parent stack or null
                        000022    1-37  	equ	stack_header.stack_begin_ptr,18	ptr to first stack frame
                        000024    1-38  	equ	stack_header.stack_end_ptr,20		ptr to next useable stack frame
                        000026    1-39  	equ	stack_header.lot_ptr,22		ptr to the lot for the current ring
                                  1-40  
                        000030    1-41  	equ	stack_header.signal_ptr,24		ptr to signal proc for current ring
                        000032    1-42  	equ	stack_header.bar_mode_sp,26		value of sp before entering bar mode
                        000034    1-43  	equ	stack_header.pl1_operators_ptr,28	ptr: pl1_operators_$operator_table
                        000036    1-44  	equ	stack_header.call_op_ptr,30		ptr to standard call operator
                                  1-45  
                        000040    1-46  	equ	stack_header.push_op_ptr,32		ptr to standard push operator
                        000042    1-47  	equ	stack_header.return_op_ptr,34		ptr to standard return operator
                        000044    1-48  	equ	stack_header.ret_no_pop_op_ptr,36	ptr: stand. return/ no pop operator
                        000046    1-49  	equ	stack_header.entry_op_ptr,38		ptr to standard entry operator
                                  1-50  
                        000050    1-51  	equ	stack_header.trans_op_tv_ptr,40	ptr to table of translator operator ptrs
                        000052    1-52  	equ	stack_header.isot_ptr,42		pointer to ISOT
                        000054    1-53  	equ	stack_header.sct_ptr,44		pointer to System Condition Table
                        000056    1-54  	equ	stack_header.unwinder_ptr,46		pointer to unwinder for current ring
                                  1-55  
                        000060    1-56  	equ	stack_header.sys_link_info_ptr,48	ptr to *system link name table
                        000062    1-57  	equ	stack_header.rnt_ptr,50		ptr to reference name table
                        000064    1-58  	equ	stack_header.ect_ptr,52		ptr to event channel table
                        000066    1-59  	equ	stack_header.assign_linkage_ptr,54	ptr to area for hcs_$assign_linkage calls
                        000070    1-60  	equ	stack_header.heap_header_ptr,56	ptr to heap header.
                        000072    1-61  	equ	stack_header.trace_frames,58		stack of trace_catch_ frames
                        000073    1-62  	equ	stach_header.trace_top_ptr,59		trace pointer
                        000074    1-63  	equ	stack_header.in_trace,60		trace antirecurse bit
                        000100    1-64  	equ	stack_header_end,64			length of stack header
                                  1-65  
                                  1-66  
                                  1-67  
                                  1-68  
                        000000    1-69  	equ	trace_frames.count,0		number of trace frames on stack
                        000001    1-70  	equ	trace_frames.top_ptr,1		packed pointer to top one
                                  1-71  
                                  1-72  "	The  following constant is an offset within the  pl1  operators table.
                                  1-73  "	It  references a  transfer vector table.
                                  1-74  
                        000551    1-75  	bool	tv_offset,551
                                  1-76  
                                  1-77  
                                  1-78  "	The  following constants are offsets within this transfer vector table.
                                  1-79  
                        001170    1-80  	equ	call_offset,tv_offset+271
                        001171    1-81  	equ	push_offset,tv_offset+272
                        001172    1-82  	equ	return_offset,tv_offset+273
                        001173    1-83  	equ	return_no_pop_offset,tv_offset+274
                        001174    1-84  	equ	entry_offset,tv_offset+275
                                  1-85  
                                  1-86  
                                  1-87  " 	END INCLUDE FILE stack_header.incl.alm
                                  1972  
                                  1973  	include	stack_frame
                                   2-1  "
                                   2-2  "	BEGIN INCLUDE FILE ... stack_frame.incl.alm   6/72 RBS
                                   2-3  "
                                   2-4  " Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr
                                   2-5  " Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager_bit & main_proc_bit
                                   2-6  " Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr
                                   2-7  "
                        000020     2-8  	equ	stack_frame.prev_sp,16
                        000020     2-9  	equ	stack_frame.condition_word,16
                        000022    2-10  	equ	stack_frame.next_sp,18
                        000022    2-11  	equ	stack_frame.signaller_word,18
                        000024    2-12  	equ	stack_frame.return_ptr,20
                        000026    2-13  	equ	stack_frame.entry_ptr,22
                        000030    2-14  	equ	stack_frame.operator_ptr,24
                        000030    2-15  	equ	stack_frame.lp_ptr,24
                        000032    2-16  	equ	stack_frame.arg_ptr,26
                        000034    2-17  	equ	stack_frame.static_ptr,28
                        000035    2-18  	equ	stack_frame.support_ptr,29	" only used by fortran I/O
                        000036    2-19  	equ	stack_frame.on_unit_rel_ptrs,30
                        000037    2-20  	equ	stack_frame.operator_ret_ptr,31
                        000037    2-21  	equ	stack_frame.translator_id,31
                        000040    2-22  	equ	stack_frame.regs,32
                        000060    2-23  	equ	stack_frame.min_length,48
                        000020    2-24  	equ	stack_frame.flag_word,16
                        020000    2-25  	bool	stack_frame.main_proc_bit,020000	(DL)
                        010000    2-26  	bool	stack_frame.run_unit_manager,010000	(DL)
                        004000    2-27  	bool	stack_frame.signal_bit,004000		(DL)
                        002000    2-28  	bool	stack_frame.crawl_out_bit,002000	(DL)
                        001000    2-29  	bool	stack_frame.signaller_bit,001000	(DL)
                        000400    2-30  	bool	stack_frame.link_trap_bit,000400	(DL)
                        000200    2-31  	bool	stack_frame.support_bit,000200	(DL)
                        000100    2-32  	bool	stack_frame.condition_bit,000100	(DL)
                                  2-33  
                                  2-34  "
                                  2-35  "	END INCLUDE FILE  ... stack_frame.incl.alm
                                  2-36  "
                                  1974  
                                  1975  	include	on_unit
                                   3-1  "
                                   3-2  "	BEGIN INCLUDE FILE --- on_unit.incl.alm	5/75 RAB
                                   3-3  "
                        000000     3-4  	equ	on_unit.name,0
                        000002     3-5  	equ	on_unit.body,2
                        000004     3-6  	equ	on_unit.size,4
                        000005     3-7  	equ	on_unit.next,5	upper	offset relative to stack FRAME
                        000005     3-8  	equ	on_unit.flags,5	lower
                        000006     3-9  	equ	on_unit.file,6
                        000010    3-10  	equ	on_unit.file_copy,8
                                  3-11  "
                                  3-12  "	END INCLUDE FILE --- on_unit.incl.alm
                                  3-13  "
                                  1976  
                                  1977  	end
ENTRY SEQUENCES
     
    003341  5a   000177 0000 00
    003342  aa  7 00046 2721 20
    003343  0a   000000 7100 00
    003344  5a   000130 0000 00
    003345  aa  7 00046 2721 20
    003346  0a   000463 7100 00
    003347  5a   000112 0000 00
    003350  aa  7 00046 2721 20
    003351  0a   002276 7100 00
    003352  5a   000074 0000 00
    003353  aa  7 00046 2721 20
    003354  0a   002753 7100 00
    003355  5a   000065 0000 00
    003356  aa  7 00046 2721 20
    003357  0a   003121 7100 00
LITERALS
     
    003360  aa   143154 145141 
    003361  aa   156165 160000 
NAME DEFINITIONS FOR ENTRY POINTS AND SEGDEFS

    003362  5a   000003 000000 
    003363  5a   000214 600000 
    003364  aa   000000 000000 
    003365  55   000012 000002 
    003366  5a   000002 400003 
    003367  55   000006 000012 
    003370  aa  014 164 162 141
    003371  aa  143 145 137 143
    003372  aa  141 164 143 150
    003373  aa  137 000 000 000
    003374  55   000022 000003 
    003375  2a   000062 400001 
    003376  55   000015 000003 
    003377  aa  021 147 154 157         global_parameters
    003400  aa  142 141 154 137
    003401  aa  160 141 162 141
    003402  aa  155 145 164 145
    003403  aa  162 163 000 000
    003404  55   000031 000012 
    003405  2a   000060 400001 
    003406  55   000025 000003 
    003407  aa  016 160 141 162         parameters_ptr
    003410  aa  141 155 145 164
    003411  aa  145 162 163 137
    003412  aa  160 164 162 000
    003413  55   000036 000022 
    003414  2a   000056 400001 
    003415  55   000034 000003 
    003416  aa  006 167 164 137         wt_ptr
    003417  aa  160 164 162 000
    003420  55   000043 000031 
    003421  2a   000054 400001 
    003422  55   000041 000003 
    003423  aa  006 164 164 137         tt_ptr
    003424  aa  160 164 162 000
    003425  55   000053 000036 
    003426  2a   000052 400001 
    003427  55   000046 000003 
    003430  aa  021 164 162 141         trace_storage_ptr
    003431  aa  143 145 137 163
    003432  aa  164 157 162 141
    003433  aa  147 145 137 160
    003434  aa  164 162 000 000
    003435  55   000060 000043 
    003436  2a   000044 400001 
    003437  55   000056 000003 
    003440  aa  007 162 145 155         removed
    003441  aa  157 166 145 144
    003442  55   000065 000053 
    003443  2a   000036 400001 
    003444  55   000063 000003 
    003445  aa  007 155 145 164         metered
    003446  aa  145 162 145 144
    003447  55   000074 000060 
    003450  0a   003356 500000 
    003451  55   000070 000003 
    003452  aa  015 163 164 141         start_tracing
    003453  aa  162 164 137 164
    003454  aa  162 141 143 151
    003455  aa  156 147 000 000
    003456  55   000103 000065 
    003457  0a   003353 500000 
    003460  55   000077 000003 
    003461  aa  014 123 124 117         STOP_TRACING
    003462  aa  120 137 124 122
    003463  aa  101 103 111 116
    003464  aa  107 000 000 000
    003465  55   000112 000074 
    003466  0a   002725 400000 
    003467  55   000106 000003 
    003470  aa  014 163 164 157         stop_tracing
    003471  aa  160 137 164 162
    003472  aa  141 143 151 156
    003473  aa  147 000 000 000
    003474  55   000122 000103 
    003475  0a   003350 500000 
    003476  55   000115 000003 
    003477  aa  023 124 122 101         TRACE_CATCH_CLEANUP
    003500  aa  103 105 137 103
    003501  aa  101 124 103 110
    003502  aa  137 103 114 105
    003503  aa  101 116 125 120
    003504  55   000130 000112 
    003505  0a   000464 400000 
    003506  55   000125 000003 
    003507  aa  012 143 141 164         catch_pl1_
    003510  aa  143 150 137 160
    003511  aa  154 061 137 000
    003512  55   000137 000122 
    003513  0a   003345 500000 
    003514  55   000133 000003 
    003515  aa  016 164 162 141         trace_catcher_
    003516  aa  143 145 137 143
    003517  aa  141 164 143 150
    003520  aa  145 162 137 000
    003521  55   000146 000130 
    003522  0a   000360 400000 
    003523  55   000142 000003 
    003524  aa  014 164 141 142         table_remove
    003525  aa  154 145 137 162
    003526  aa  145 155 157 166
    003527  aa  145 000 000 000
    003530  55   000154 000137 
    003531  0a   000202 400000 
    003532  55   000151 000003 
    003533  aa  011 164 141 142         table_add
    003534  aa  154 145 137 141
    003535  aa  144 144 000 000
    003536  55   000163 000146 
    003537  0a   000151 400000 
    003540  55   000157 000003 
    003541  aa  016 164 141 142         table_put_data
    003542  aa  154 145 137 160
    003543  aa  165 164 137 144
    003544  aa  141 164 141 000
    003545  55   000171 000154 
    003546  0a   000116 400000 
    003547  55   000166 000003 
    003550  aa  011 164 141 142         table_get
    003551  aa  154 145 137 147
    003552  aa  145 164 000 000
    003553  55   000177 000163 
    003554  0a   000023 400000 
    003555  55   000174 000003 
    003556  aa  012 164 141 142         table_seek
    003557  aa  154 145 137 163
    003560  aa  145 145 153 000
    003561  55   000205 000171 
    003562  0a   003342 500000 
    003563  55   000202 000003 
    003564  aa  012 151 156 151         initialize
    003565  aa  164 151 141 154
    003566  aa  151 172 145 000
    003567  55   000002 000177 
    003570  6a   000000 400002 
    003571  55   000210 000003 
    003572  aa  014 163 171 155         symbol_table
    003573  aa  142 157 154 137
    003574  aa  164 141 142 154
    003575  aa  145 000 000 000

DEFINITIONS HASH TABLE

    003576  aa   000000 000033 
    003577  5a   000122 000000 
    003600  5a   000043 000000 
    003601  5a   000065 000000 
    003602  5a   000146 000000 
    003603  5a   000130 000000 
    003604  5a   000163 000000 
    003605  aa   000000 000000 
    003606  5a   000022 000000 
    003607  5a   000012 000000 
    003610  5a   000036 000000 
    003611  5a   000053 000000 
    003612  5a   000031 000000 
    003613  5a   000060 000000 
    003614  5a   000074 000000 
    003615  5a   000177 000000 
    003616  5a   000205 000000 
    003617  aa   000000 000000 
    003620  5a   000103 000000 
    003621  aa   000000 000000 
    003622  aa   000000 000000 
    003623  aa   000000 000000 
    003624  5a   000112 000000 
    003625  5a   000154 000000 
    003626  aa   000000 000000 
    003627  5a   000137 000000 
    003630  aa   000000 000000 
    003631  5a   000171 000000 

EXTERNAL NAMES

    003632  aa  012 164 141 142         table_full
    003633  aa  154 145 137 146
    003634  aa  165 154 154 000
    003635  aa  017 164 141 142         table_index_oob
    003636  aa  154 145 137 151
    003637  aa  156 144 145 170
    003640  aa  137 157 157 142
    003641  aa  021 164 162 141         trace_error_halt_
    003642  aa  143 145 137 145
    003643  aa  162 162 157 162
    003644  aa  137 150 141 154
    003645  aa  164 137 000 000
    003646  aa  011 151 157 137         io_signal
    003647  aa  163 151 147 156
    003650  aa  141 154 000 000
    003651  aa  007 163 151 147         signal_
    003652  aa  156 141 154 137
    003653  aa  027 164 162 141         transaction_begin_force
    003654  aa  156 163 141 143
    003655  aa  164 151 157 156
    003656  aa  137 142 145 147
    003657  aa  151 156 137 146
    003660  aa  157 162 143 145
    003661  aa  021 164 162 141         transaction_begin
    003662  aa  156 163 141 143
    003663  aa  164 151 157 156
    003664  aa  137 142 145 147
    003665  aa  151 156 000 000
    003666  aa  023 164 162 141         trace_transactions_
    003667  aa  143 145 137 164
    003670  aa  162 141 156 163
    003671  aa  141 143 164 151
    003672  aa  157 156 163 137
    003673  aa  017 164 162 141         trace_alm_entry
    003674  aa  143 145 137 141
    003675  aa  154 155 137 145
    003676  aa  156 164 162 171
    003677  aa  030 164 162 141         trace_operator_pointers_
    003700  aa  143 145 137 157
    003701  aa  160 145 162 141
    003702  aa  164 157 162 137
    003703  aa  160 157 151 156
    003704  aa  164 145 162 163
    003705  aa  137 000 000 000
    003706  aa  024 164 162 141         trace_operator_table
    003707  aa  143 145 137 157
    003710  aa  160 145 162 141
    003711  aa  164 157 162 137
    003712  aa  164 141 142 154
    003713  aa  145 000 000 000
    003714  aa  011 141 154 155         alm_entry
    003715  aa  137 145 156 164
    003716  aa  162 171 000 000
    003717  aa  022 157 160 145         operator_pointers_
    003720  aa  162 141 164 157
    003721  aa  162 137 160 157
    003722  aa  151 156 164 145
    003723  aa  162 163 137 000
    003724  aa  016 157 160 145         operator_table
    003725  aa  162 141 164 157
    003726  aa  162 137 164 141
    003727  aa  142 154 145 000
    003730  aa  016 160 154 061         pl1_operators_
    003731  aa  137 157 160 145
    003732  aa  162 141 164 157
    003733  aa  162 163 137 000
    003734  aa  014 164 162 141         trace_catch_
    003735  aa  143 145 137 143
    003736  aa  141 164 143 150
    003737  aa  137 000 000 000
    003740  aa  027 143 160 165         cpu_time_and_paging_op_
    003741  aa  137 164 151 155
    003742  aa  145 137 141 156
    003743  aa  144 137 160 141
    003744  aa  147 151 156 147
    003745  aa  137 157 160 137
    003746  aa  006 143 154 157         clock_
    003747  aa  143 153 137 000
    003750  aa  010 163 171 163         sys_info
    003751  aa  137 151 156 146
    003752  aa  157 000 000 000
    003753  aa  016 141 144 144         add_entrypoint
    003754  aa  137 145 156 164
    003755  aa  162 171 160 157
    003756  aa  151 156 164 000
    003757  aa  022 164 162 141         trace_entrypoints_
    003760  aa  143 145 137 145
    003761  aa  156 164 162 171
    003762  aa  160 157 151 156
    003763  aa  164 163 137 000

NO TRAP POINTER WORDS

TYPE PAIR BLOCKS

    003764  aa   000004 000000 
    003765  55   000352 000077 
    003766  aa   000004 000000 
    003767  55   000257 000250 
    003770  aa   000004 000000 
    003771  55   000257 000253 
    003772  aa   000004 000000 
    003773  55   000257 000257 
    003774  aa   000004 000000 
    003775  55   000267 000264 
    003776  aa   000004 000000 
    003777  55   000267 000267 
    004000  aa   000004 000000 
    004001  55   000304 000271 
    004002  aa   000004 000000 
    004003  55   000304 000277 
    004004  aa   000004 000000 
    004005  55   000346 000311 
    004006  aa   000004 000000 
    004007  55   000315 000315 
    004010  aa   000004 000000 
    004011  55   000346 000324 
    004012  aa   000004 000000 
    004013  55   000346 000332 
    004014  aa   000004 000000 
    004015  55   000335 000335 
    004016  aa   000004 000000 
    004017  55   000346 000342 
    004020  aa   000004 000000 
    004021  55   000352 000115 
    004022  aa   000004 000000 
    004023  55   000352 000133 
    004024  aa   000004 000000 
    004025  55   000356 000356 
    004026  aa   000004 000000 
    004027  55   000366 000364 
    004030  aa   000004 000000 
    004031  55   000375 000371 
    004032  aa   000001 000000 
    004033  aa   000000 000000 

INTERNAL EXPRESSION WORDS

    004034  5a   000402 000000 
    004035  5a   000404 000000 
    004036  5a   000406 000000 
    004037  5a   000410 000000 
    004040  5a   000412 000000 
    004041  5a   000414 000000 
    004042  5a   000416 000000 
    004043  5a   000420 000000 
    004044  5a   000422 000000 
    004045  5a   000424 000000 
    004046  5a   000426 000000 
    004047  5a   000430 000000 
    004050  5a   000432 000000 
    004051  5a   000434 000000 
    004052  5a   000436 000000 
    004053  5a   000440 000000 
    004054  5a   000442 000000 
    004055  5a   000444 000000 
    004056  5a   000446 000000 
    004057  aa   000000 000000 
LINKAGE INFORMATION
      
    000000  aa   000000 000000 
    000001  0a   003362 000000 
    000002  aa   000000 000000 
    000003  aa   000000 000000 
    000004  aa   000000 000000 
    000005  aa   000000 000000 
    000006  22   000350 000416 
    000007  a2   000000 000340 
    000350  9a   777430 0000 46         trace_entrypoints_|add_entrypoint
    000351  5a   000474 0000 00
    000352  9a   777426 0000 46         sys_info|clock_
    000353  5a   000473 0000 20
    000354  9a   777424 0000 46         cpu_time_and_paging_op_|cpu_time_and_paging_op_
    000355  5a   000472 0000 00
    000356  9a   777422 0000 46         trace_catch_|trace_catcher_
    000357  5a   000471 0000 00
    000360  9a   777420 0000 46         trace_catch_|TRACE_CATCH_CLEANUP
    000361  5a   000470 0000 00
    000362  9a   777416 0000 46         pl1_operators_|operator_table
    000363  5a   000467 0000 00
    000364  9a   777414 0000 46         operator_pointers_|operator_pointers_
    000365  5a   000466 0000 00
    000366  9a   777412 0000 46         pl1_operators_|alm_entry
    000367  5a   000465 0000 00
    000370  9a   777410 0000 46         pl1_operators_|trace_operator_table
    000371  5a   000464 0000 00
    000372  9a   777406 0000 46         trace_operator_pointers_|trace_operator_pointers_
    000373  5a   000463 0000 00
    000374  9a   777404 0000 46         pl1_operators_|trace_alm_entry
    000375  5a   000462 0000 00
    000376  9a   777402 0000 46         trace_transactions_|transaction_begin
    000377  5a   000461 0000 00
    000400  9a   777400 0000 46         trace_transactions_|transaction_begin_force
    000401  5a   000460 0000 00
    000402  9a   777376 0000 46         signal_|signal_
    000403  5a   000457 0000 00
    000404  9a   777374 0000 46         signal_|io_signal
    000405  5a   000456 0000 00
    000406  9a   777372 0000 46         trace_error_halt_|trace_error_halt_
    000407  5a   000455 0000 00
    000410  9a   777370 0000 46         trace_error_halt_|table_index_oob
    000411  5a   000454 0000 00
    000412  9a   777366 0000 46         trace_error_halt_|table_full
    000413  5a   000453 0000 00
    000414  9a   777364 0000 46         trace_catch_|STOP_TRACING
    000415  5a   000452 0000 00
SYMBOL INFORMATION
     
SYMBOL TABLE HEADER
     
    000000  aa   000000 000001 
    000001  aa   163171 155142 
    000002  aa   164162 145145 
    000003  aa   000000 000010 
    000004  aa   000000 117244 
    000005  aa   361023 525721 
    000006  aa   000000 131036 
    000007  aa   722237 440012 
    000010  aa   141154 155040 
    000011  aa   040040 040040 
    000012  aa   000024 000040 
    000013  aa   000034 000040 
    000014  aa   000044 000100 
    000015  aa   000002 000002 
    000016  aa   000064 000000 
    000017  aa   000000 000531 
    000020  aa   000000 000145 
    000021  aa   000450 000422 
    000022  aa   000521 000145 
    000023  aa   000064 000000 
    000024  aa   101114 115040 
    000025  aa   126145 162163 
    000026  aa   151157 156040 
    000027  aa   070056 061064 
    000030  aa   040115 141162 
    000031  aa   143150 040061 
    000032  aa   071070 071040 
    000033  aa   040040 040040 
    000034  aa   123143 150162 
    000035  aa   157164 150056 
    000036  aa   123171 163115 
    000037  aa   141151 156164 
    000040  aa   056155 040040 
    000041  aa   040040 040040 
    000042  aa   040040 040040 
    000043  aa   040040 040040 
    000044  aa   154151 163164 
    000045  aa   040163 171155 
    000046  aa   142157 154163 
    000047  aa   040040 040040 
    000050  aa   040040 040040 
    000051  aa   040040 040040 
    000052  aa   040040 040040 
    000053  aa   040040 040040 
    000054  aa   040040 040040 
    000055  aa   040040 040040 
    000056  aa   040040 040040 
    000057  aa   040040 040040 
    000060  aa   040040 040040 
    000061  aa   040040 040040 
    000062  aa   040040 040040 
    000063  aa   040040 040040 
    000064  aa   000000 000001 
    000065  aa   000000 000004 
    000066  aa   000106 000040 
    000067  aa   310157 127605 
    000070  aa   000000 131036 
    000071  aa   722237 400000 
    000072  aa   000116 000037 
    000073  aa   305736 051531 
    000074  aa   000000 115000 
    000075  aa   507463 000000 
    000076  aa   000126 000036 
    000077  aa   305736 051524 
    000100  aa   000000 105272 
    000101  aa   317215 400000 
    000102  aa   000136 000032 
    000103  aa   305736 050655 
    000104  aa   000000 102727 
    000105  aa   712743 600000 
    000106  aa   076165 144144          >udd>sm>ds>w>ml>trace_catch_.alm
    000107  aa   076163 155076 
    000110  aa   144163 076167 
    000111  aa   076155 154076 
    000112  aa   164162 141143 
    000113  aa   145137 143141 
    000114  aa   164143 150137 
    000115  aa   056141 154155 
    000116  aa   076154 144144          >ldd>incl>stack_header.incl.alm
    000117  aa   076151 156143 
    000120  aa   154076 163164 
    000121  aa   141143 153137 
    000122  aa   150145 141144 
    000123  aa   145162 056151 
    000124  aa   156143 154056 
    000125  aa   141154 155040 
    000126  aa   076154 144144          >ldd>incl>stack_frame.incl.alm
    000127  aa   076151 156143 
    000130  aa   154076 163164 
    000131  aa   141143 153137 
    000132  aa   146162 141155 
    000133  aa   145056 151156 
    000134  aa   143154 056141 
    000135  aa   154155 040040 
    000136  aa   076154 144144          >ldd>incl>on_unit.incl.alm
    000137  aa   076151 156143 
    000140  aa   154076 157156 
    000141  aa   137165 156151 
    000142  aa   164056 151156 
    000143  aa   143154 056141 
    000144  aa   154155 040040 
               MULTICS ASSEMBLY CROSS REFERENCE LISTING

   Value        Symbol                   Source file   Line number

         701    ADD_ENTRYPOINT           trace_catch_:      1095, 1104.
                add_entrypoint           trace_catch_:      1141.
         266    ADD_ENTRY_FOUND_IN_TABLE       trace_catch_:       908,  910.
        3120    ALL_FRAMES_FLUSHED       trace_catch_:      1611, 1642.
        3246    ALL_FRAMES_STARTED       trace_catch_:      1679, 1712.
                alm_entry                trace_catch_:        40, 1594.
         102    arg_list.first_arg_ptr   trace_catch_:        65, 1137, 1168, 1227, 1349, 1514.
         100    arg_list.header          trace_catch_:        64, 1135, 1141, 1168, 1227, 1309, 1311, 1349, 1514.
         104    arg_list.second_arg_ptr  trace_catch_:        66, 1139, 1168, 1227, 1349, 1514.
         106    arg_list.third_arg_ptr   trace_catch_:        67, 1227, 1349.
          55    BINARY_LOOP.._00000      trace_catch_:       834.
         234    BINARY_LOOP.._00003      trace_catch_:       908.
         642    BINARY_LOOP.._00010      trace_catch_:      1095.
        1631    BINARY_LOOP.._00023      trace_catch_:      1327.
        2423    BINARY_LOOP.._00033      trace_catch_:      1492.
        3012    BINARY_LOOP.._00040      trace_catch_:      1625.
        3174    BINARY_LOOP.._00042      trace_catch_:      1693.
          70    BINARY_NOT_FOUND.._00000       trace_catch_:       834.
         247    BINARY_NOT_FOUND.._00003       trace_catch_:       908.
         655    BINARY_NOT_FOUND.._00010       trace_catch_:      1095.
        1644    BINARY_NOT_FOUND.._00023       trace_catch_:      1327.
        2436    BINARY_NOT_FOUND.._00033       trace_catch_:      1492.
        3025    BINARY_NOT_FOUND.._00040       trace_catch_:      1625.
        3207    BINARY_NOT_FOUND.._00042       trace_catch_:      1693.
           4    buffer.e                 trace_catch_:      1168, 1227, 1349, 1514, 1904.
           0    buffer.h                 trace_catch_:      1900.
           3    buffer.h.count           trace_catch_:      1168, 1227, 1349, 1514, 1903.
           2    buffer.h.not_used        trace_catch_:      1902.
           0    buffer.h.version         trace_catch_:      1168, 1227, 1349, 1514, 1901.
        3260    BUFFER_VERSION_3         trace_catch_:      1168, 1227, 1349, 1514, 1732.
        1170    call_offset              stack_header:        80.
        1060    CALL_TRACE_PRINT.._00012       trace_catch_:      1168.
        1273    CALL_TRACE_PRINT.._00014       trace_catch_:      1227.
        2014    CALL_TRACE_PRINT.._00025       trace_catch_:      1349.
        2606    CALL_TRACE_PRINT.._00035       trace_catch_:      1514.
         464    catch_pl1_               trace_catch_:       992,  993.
        1223    CHECK_FIRST.._00013      trace_catch_:      1227.
        1744    CHECK_FIRST.._00024      trace_catch_:      1349.
        2536    CHECK_FIRST.._00034      trace_catch_:      1514.
        1363    CHECK_STOP_LOW.._00013   trace_catch_:      1227.
        2105    CHECK_STOP_LOW.._00024   trace_catch_:      1349.
        1315    CHECK_WATCH_TABLE.._00013      trace_catch_:      1227.
        2036    CHECK_WATCH_TABLE.._00024      trace_catch_:      1349.
        2630    CHECK_WATCH_TABLE.._00034      trace_catch_:      1514.
         130    cleanup_unit             trace_catch_:        70, 1047, 1049, 1051, 1052, 1054, 1216.
         130    cleanup_unit_offset      trace_catch_:      1054, 1055.
                clock_                   trace_catch_:        33, 1001, 1278, 1291, 1410, 1443, 1552.
           0    counts.calls             trace_catch_:      1186, 1188, 1893.
           2    counts.level             trace_catch_:      1196, 1198, 1356, 1521, 1894.
           3    counts.max_level         trace_catch_:      1199, 1201, 1895.
                cpu_time_and_paging_op_  trace_catch_:        34, 1037, 1235, 1253, 1300, 1366, 1463, 1537.
          30    delta                    trace_catch_:      1077, 1316, 1481, 1791.
        1443    DONT_CALL_ANYTHING.._00013     trace_catch_:      1227.
        2165    DONT_CALL_ANYTHING.._00024     trace_catch_:      1349.
        2630    DONT_CALL_ANYTHING.._00034     trace_catch_:      1514.
        3334    double_precision_one     trace_catch_:      1769.
        1174    entry_offset             stack_header:        84.
         674    EP_IS_IN_TT_AT_CALL      trace_catch_:      1095, 1097.
        1663    EP_IS_IN_TT_AT_RETURN    trace_catch_:      1327, 1329.
        3226    EP_IS_IN_TT_AT_START     trace_catch_:      1693, 1695.
        3044    EP_IS_IN_TT_AT_STOP      trace_catch_:      1625, 1627.
        2455    EP_IS_IN_TT_AT_UNWIND    trace_catch_:      1492, 1494.
         110    event                    trace_catch_:        69, 1077, 1084, 1093, 1100, 1106, 1112, 1136, 1138, 1143, 1166,
                                                            1168, 1180, 1182, 1206, 1207, 1208, 1225, 1227, 1231, 1316, 1325,
                                                            1332, 1349, 1353, 1356, 1481, 1490, 1497, 1514, 1518, 1521, 1623,
                                                            1635, 1691, 1703.
          15    event.arg_list_ptr       trace_catch_:      1166, 1225, 1886.
          16    event.callers_sp         trace_catch_:      1166, 1225, 1887.
          14    event.entry_idx          trace_catch_:      1100, 1106, 1138, 1143, 1332, 1497, 1885.
           7    event.entry_ptr          trace_catch_:      1084, 1093, 1112, 1136, 1325, 1490, 1623, 1691, 1879.
           2    event.frame              trace_catch_:      1874.
           6    event.frame.page_faults  trace_catch_:      1077, 1208, 1316, 1353, 1481, 1518, 1635, 1877.
           2    event.frame.real_time    trace_catch_:      1077, 1206, 1316, 1353, 1481, 1518, 1635, 1875.
           4    event.frame.vcpu_time    trace_catch_:      1077, 1207, 1316, 1353, 1481, 1518, 1635, 1876.
           1    event.frame_count        trace_catch_:      1166, 1225, 1872.
           1    event.kind               trace_catch_:      1168, 1227, 1349, 1514, 1871.
          17    event.return_ptr         trace_catch_:      1166, 1225, 1888.
          10    event.saved              trace_catch_:      1168, 1180, 1182, 1880.
          10    event.saved.calls        trace_catch_:      1227, 1349, 1514, 1881.
          12    event.saved.level        trace_catch_:      1227, 1231, 1349, 1356, 1514, 1521, 1703, 1882.
          13    event.saved.max_level    trace_catch_:      1227, 1349, 1514, 1883.
           0    event.version            trace_catch_:      1166, 1225, 1870.
          20    event_size               trace_catch_:      1168, 1227, 1349, 1514, 1868.
        3262    EVENT_VERSION_3          trace_catch_:      1166, 1225, 1735.
          71    FIGURE_INDEX.._00000     trace_catch_:       834.
         250    FIGURE_INDEX.._00003     trace_catch_:       908.
         656    FIGURE_INDEX.._00010     trace_catch_:      1095.
        1645    FIGURE_INDEX.._00023     trace_catch_:      1327.
        2437    FIGURE_INDEX.._00033     trace_catch_:      1492.
        3026    FIGURE_INDEX.._00040     trace_catch_:      1625.
        3210    FIGURE_INDEX.._00042     trace_catch_:      1693.
        3314    five_arg_list_header     trace_catch_:      1758.
        3326    five_arg_list_header_w_env     trace_catch_:      1764.
        2757    FLUSH_METERS_FROM_THIS_FRAME   trace_catch_:      1610, 1640.
        3115    FLUSH_NEXT_FRAME         trace_catch_:      1625, 1637.
        3312    four_arg_list_header     trace_catch_:      1757.
        3324    four_arg_list_header_w_env     trace_catch_:      1763.
        2223    FRAME_METERS_UPDATED.._00030   trace_catch_:      1353.
        2666    FRAME_METERS_UPDATED.._00036   trace_catch_:      1518.
        3106    FRAME_METERS_UPDATED.._00041   trace_catch_:      1635.
           0    from_entry               trace_catch_:      1235, 1253, 1963.
          10    from_return              trace_catch_:      1366, 1537, 1964.
        1454    GLOBAL_INTERVAL_STARTED.._00017      trace_catch_:      1231.
        3243    GLOBAL_INTERVAL_STARTED.._00043      trace_catch_:      1703.
          62    global_parameters        trace_catch_:      1077, 1121, 1158, 1161, 1168, 1192, 1227, 1235, 1253, 1316, 1340,
                                                            1345, 1349, 1366, 1481, 1505, 1510, 1514, 1537, 1572, 1574, 1576,
                                                            1659, 1661, 1663, 1720, 1817, 1818.
        3272    GLOBAL_PARAMETERS_VERSION_3    trace_catch_:      1747.
           2    global_parms.alm         trace_catch_:      1192, 1227, 1345, 1349, 1510, 1514, 1720, 1937.
           3    global_parms.automatic   trace_catch_:      1121, 1574, 1661, 1938.
         244    global_parms.buffer_ptr  trace_catch_:      1168, 1227, 1349, 1514, 1958.
         243    global_parms.calibrate   trace_catch_:      1077, 1316, 1481, 1957.
         246    global_parms.comps       trace_catch_:      1235, 1253, 1366, 1537, 1961.
           6    global_parms.enabled     trace_catch_:      1340, 1505, 1572, 1659, 1941.
           7    global_parms.long        trace_catch_:      1942.
         242    global_parms.loud        trace_catch_:      1956.
           4    global_parms.meter       trace_catch_:      1158, 1227, 1349, 1514, 1939.
         245    global_parms.not_used    trace_catch_:      1959.
          10    global_parms.osw         trace_catch_:      1944.
          23    global_parms.osw.file_path     trace_catch_:      1947.
          10    global_parms.osw.iocb_ptr      trace_catch_:      1945.
          12    global_parms.osw.stream_name   trace_catch_:      1946.
           5    global_parms.signals     trace_catch_:      1161, 1576, 1663, 1940.
         124    global_parms.spp         trace_catch_:      1949.
         130    global_parms.spp.entry_name    trace_catch_:      1951.
         124    global_parms.spp.entry_value   trace_catch_:      1950.
         236    global_parms.stop_routine      trace_catch_:      1227, 1349, 1954.
         232    global_parms.trace_routine     trace_catch_:      1168, 1227, 1349, 1514, 1953.
           0    global_parms.version     trace_catch_:      1936.
         144    global_start.page_faults       trace_catch_:        75, 1211, 1231, 1353, 1518, 1635, 1703.
         140    global_start.real_time   trace_catch_:        73, 1209, 1231, 1353, 1518, 1635, 1703.
         142    global_start.vcpu_time   trace_catch_:        74, 1210, 1231, 1353, 1518, 1635, 1703.
        1103    HAVE_TAB                 trace_catch_:      1102, 1154, 1172.
           1    idx.high                 trace_catch_:       834,  863,  887,  908,  920,  937,  956,  963,  966, 1095, 1151,
                                                            1227, 1327, 1349, 1492, 1625, 1693, 1833.
           0    idx.low                  trace_catch_:       834,  863,  887,  908,  918,  928,  931,  937,  956,  963, 1095,
                                                            1151, 1227, 1327, 1349, 1492, 1625, 1693, 1832.
         144    INDEX_DONE.._00001       trace_catch_:       863.
         177    INDEX_DONE.._00002       trace_catch_:       887.
         406    INDEX_DONE.._00005       trace_catch_:       956.
         760    INDEX_DONE.._00011       trace_catch_:      1151.
         136    INDEX_HIGH.._00001       trace_catch_:       863.
         171    INDEX_HIGH.._00002       trace_catch_:       887.
         400    INDEX_HIGH.._00005       trace_catch_:       956.
         752    INDEX_HIGH.._00011       trace_catch_:      1151.
         145    indicators_saved         trace_catch_:        77, 1033, 1247, 1259.
           0    initialize               trace_catch_:        31,   32.
         605    INTERVAL_CALCULATED.._00007    trace_catch_:      1077.
        1576    INTERVAL_CALCULATED.._00022    trace_catch_:      1316.
        2370    INTERVAL_CALCULATED.._00032    trace_catch_:      1481.
          13    IO_SIGNAL                trace_catch_:        54, 1116, 1783.
                io_signal                trace_catch_:        53.
        2260    MERGE_FRAMES             trace_catch_:      1374, 1388.
          36    metered                  trace_catch_:      1231, 1353, 1518, 1635, 1703, 1794, 1795.
           4    meters.page_faults       trace_catch_:      1037, 1077, 1231, 1235, 1253, 1300, 1316, 1353, 1366, 1463, 1481,
                                                            1518, 1537, 1635, 1703, 1911.
           0    meters.real_time         trace_catch_:      1001, 1077, 1168, 1227, 1231, 1278, 1291, 1316, 1349, 1353, 1410,
                                                            1443, 1481, 1514, 1518, 1552, 1635, 1703, 1909.
           2    meters.vcpu_time         trace_catch_:      1037, 1077, 1231, 1235, 1253, 1300, 1316, 1353, 1366, 1463, 1481,
                                                            1518, 1537, 1635, 1703, 1910.
         343    MOVE_HIGH_TO_LOW.._00004       trace_catch_:       937.
         443    MOVE_HIGH_TO_LOW.._00006       trace_catch_:       963.
         330    MOVE_LOW_TO_HIGH.._00004       trace_catch_:       937.
         430    MOVE_LOW_TO_HIGH.._00006       trace_catch_:       963.
         312    NORMALIZE_FOR_ADD        trace_catch_:       919,  936.
        1465    NOTHING_TO_START.._00020       trace_catch_:      1235.
        1505    NOTHING_TO_START.._00021       trace_catch_:      1253.
        2250    NOTHING_TO_START.._00031       trace_catch_:      1366.
        2715    NOTHING_TO_START.._00037       trace_catch_:      1537.
        3330    null_ptr                 trace_catch_:      1018, 1107, 1168, 1227, 1349, 1514, 1524, 1766.
        3304    one_arg_list_header      trace_catch_:      1168, 1227, 1349, 1514, 1754.
        3316    one_arg_list_header_w_env      trace_catch_:      1168, 1227, 1349, 1514, 1760.
           2    on_unit.body             trace_catch_:      1049, 1216,
                                         on_unit:        5.
           6    on_unit.file             on_unit:        9.
          10    on_unit.file_copy        on_unit:       10.
           5    on_unit.flags            on_unit:        8.
           0    on_unit.name             trace_catch_:      1047,
                                         on_unit:        4.
           5    on_unit.next             trace_catch_:      1052,
                                         on_unit:        7.
           4    on_unit.size             trace_catch_:      1051,
                                         on_unit:        6.
                operator_pointers_       trace_catch_:        39, 1592.
                operator_table           trace_catch_:        38, 1590.
        3340    packed_null              trace_catch_:      1168, 1227, 1349, 1514, 1773.
          60    parameters_ptr           trace_catch_:      1813, 1814.
        3270    PARAMETERS_VERSION_3     trace_catch_:      1227, 1349, 1514, 1744.
          11    parms.arguments          trace_catch_:      1925.
          17    parms.call_ptr           trace_catch_:      1931.
           3    parms.every              trace_catch_:      1227, 1349, 1514, 1918.
           4    parms.first              trace_catch_:      1227, 1349, 1514, 1919.
           7    parms.high               trace_catch_:      1227, 1349, 1514, 1922.
           5    parms.last               trace_catch_:      1227, 1349, 1514, 1920.
           6    parms.low                trace_catch_:      1227, 1349, 1514, 1921.
          10    parms.new_high           trace_catch_:      1227, 1349, 1514, 1924.
          12    parms.not_used1          trace_catch_:      1926.
           2    parms.reference_count    trace_catch_:      1917.
          15    parms.stop               trace_catch_:      1227, 1349, 1929.
          13    parms.stop_every         trace_catch_:      1227, 1349, 1927.
          14    parms.stop_low           trace_catch_:      1227, 1349, 1928.
          16    parms.trace              trace_catch_:      1227, 1349, 1514, 1930.
           0    parms.version            trace_catch_:      1227, 1349, 1514, 1916.
                pl1_operators_           trace_catch_:        38,   40,   41,   43, 1590, 1594, 1713, 1722.
        2232    POP_TAB_AND_RETURN       trace_catch_:      1341, 1345, 1355.
        2675    POP_TAB_AT_UNWIND        trace_catch_:      1506, 1510, 1520.
        1474    POP_TRACE_FRAME_AND_RESUME     trace_catch_:      1122, 1127, 1130, 1144, 1159, 1162, 1170, 1192, 1252.
        2235    POP_TRACE_FRAME_AND_RETURN     trace_catch_:      1327, 1360.
        2700    POP_TRACE_FRAME_AT_UNWIND      trace_catch_:      1492, 1523.
        2274    PRELIMINARY_CLEANUP_HANDLER    trace_catch_:      1048, 1418.
        1517    PROCEDURE_RETURN_POINT   trace_catch_:      1239, 1286.
        3332    ptr_mask                 trace_catch_:      1168, 1227, 1349, 1514, 1767.
          60    ptr_registers_saved      trace_catch_:        62, 1031, 1166, 1168, 1225, 1245, 1257, 1295, 1379, 1392.
        1171    push_offset              stack_header:        81.
          50    registers_saved          trace_catch_:        61, 1032, 1083, 1246, 1258, 1296, 1380, 1393.
          44    removed                  trace_catch_:      1798, 1799.
        3137    RESTART_METERS           trace_catch_:      1662, 1664, 1674.
        1512    RESUME_ENTRY_OPERATOR    trace_catch_:      1248, 1266.
        2265    RETURN                   trace_catch_:      1386, 1399.
        1173    return_no_pop_offset     stack_header:        83.
        1172    return_offset            stack_header:        82.
          47    SEEK_LOW.._00000         trace_catch_:       834.
         226    SEEK_LOW.._00003         trace_catch_:       908.
         634    SEEK_LOW.._00010         trace_catch_:      1095.
        1623    SEEK_LOW.._00023         trace_catch_:      1327.
        2415    SEEK_LOW.._00033         trace_catch_:      1492.
        3004    SEEK_LOW.._00040         trace_catch_:      1625.
        3166    SEEK_LOW.._00042         trace_catch_:      1693.
         611    SEEK_TAB_FOR_CALL        trace_catch_:      1071, 1079.
          12    SIGNAL_                  trace_catch_:        52, 1113, 1782.
                signal_                  trace_catch_:        51,   53.
        1102    SKIP_TRACE_PRINT.._00012       trace_catch_:      1168.
        1315    SKIP_TRACE_PRINT.._00014       trace_catch_:      1227.
        2036    SKIP_TRACE_PRINT.._00025       trace_catch_:      1349.
        2630    SKIP_TRACE_PRINT.._00035       trace_catch_:      1514.
          73    stach_header.trace_top_ptr     stack_header:        62.
          32    stack_frame.arg_ptr      trace_catch_:      1019, 1454, 1472,
                                         stack_frame:   16.
         100    stack_frame.condition_bit      trace_catch_:      1058,
                                               stack_frame:   32.
          20    stack_frame.condition_word     stack_frame:    9.
        2000    stack_frame.crawl_out_bit      stack_frame:   28.
          26    stack_frame.entry_ptr    trace_catch_:      1013, 1449,
                                         stack_frame:   13.
          20    stack_frame.flag_word    trace_catch_:      1059, 1166, 1225,
                                         stack_frame:   24.
         400    stack_frame.link_trap_bit      stack_frame:   30.
          30    stack_frame.lp_ptr       trace_catch_:      1021, 1037, 1235, 1253, 1290, 1300, 1366, 1455, 1463, 1537,
                                         stack_frame:   15.
       20000    stack_frame.main_proc_bit      stack_frame:   25.
          60    stack_frame.min_length   stack_frame:   23.
          22    stack_frame.next_sp      trace_catch_:      1025, 1373, 1397, 1459,
                                         stack_frame:   10.
          36    stack_frame.on_unit_rel_ptrs   trace_catch_:      1056,
                                               stack_frame:   19.
          30    stack_frame.operator_ptr       trace_catch_:      1401, 1547,
                                               stack_frame:   14.
          37    stack_frame.operator_ret_ptr   stack_frame:   20.
          20    stack_frame.prev_sp      trace_catch_:      1017, 1166, 1225, 1264, 1385, 1396, 1453, 1542,
                                         stack_frame:    8.
          40    stack_frame.regs         stack_frame:   22.
          24    stack_frame.return_ptr   trace_catch_:      1037, 1166, 1225, 1235, 1240, 1241, 1253, 1300, 1366, 1402, 1412,
                                                            1463, 1537, 1548, 1554,
                                         stack_frame:   12.
       10000    stack_frame.run_unit_manager   stack_frame:   26.
        1000    stack_frame.signaller_bit      stack_frame:   29.
          22    stack_frame.signaller_word     stack_frame:   11.
        4000    stack_frame.signal_bit   stack_frame:   27.
          34    stack_frame.static_ptr   stack_frame:   17.
         200    stack_frame.support_bit  trace_catch_:      1058, 1166, 1225,
                                         stack_frame:   31.
          35    stack_frame.support_ptr  stack_frame:   18.
          37    stack_frame.translator_id      trace_catch_:      1042,
                                               stack_frame:   21.
         147    stack_frame_end          trace_catch_:        79.
         160    stack_frame_size         trace_catch_:        81, 1023, 1372, 1457.
          66    stack_header.assign_linkage_ptr      stack_header:        59.
          32    stack_header.bar_mode_sp       stack_header:        42.
          36    stack_header.call_op_ptr       stack_header:        44.
          10    stack_header.clr_ptr     stack_header:        27.
           6    stack_header.combined_stat_ptr       stack_header:        25.
           4    stack_header.cpm_data_ptr      stack_header:        24.
          13    stack_header.cpm_enabled       stack_header:        32.
          13    stack_header.cur_lot_size      stack_header:        31.
          64    stack_header.ect_ptr     stack_header:        58.
          46    stack_header.entry_op_ptr      trace_catch_:      1595, 1723,
                                               stack_header:        49.
          70    stack_header.heap_header_ptr   stack_header:        60.
          74    stack_header.in_trace    trace_catch_:      1005, 1064, 1274, 1305, 1406, 1420, 1468, 1533,
                                         stack_header:        63.
          52    stack_header.isot_ptr    stack_header:        52.
          26    stack_header.lot_ptr     trace_catch_:       825,  854,  878,  899,  947,  997, 1020, 1439, 1568,
                                         stack_header:        39.
          12    stack_header.main_proc_invoked       stack_header:        29.
          12    stack_header.max_lot_size      stack_header:        28.
          20    stack_header.parent_ptr  stack_header:        36.
          34    stack_header.pl1_operators_ptr       trace_catch_:      1591, 1714,
                                                     stack_header:        43.
          40    stack_header.push_op_ptr       stack_header:        46.
          42    stack_header.return_op_ptr     stack_header:        47.
          44    stack_header.ret_no_pop_op_ptr       stack_header:        48.
          62    stack_header.rnt_ptr     stack_header:        57.
          12    stack_header.run_unit_depth    stack_header:        30.
          54    stack_header.sct_ptr     stack_header:        53.
          30    stack_header.signal_ptr  stack_header:        41.
          22    stack_header.stack_begin_ptr   stack_header:        37.
          24    stack_header.stack_end_ptr     trace_catch_:      1011, 1024, 1263, 1270, 1384, 1395, 1447, 1458, 1541,
                                               stack_header:        38.
          14    stack_header.system_free_ptr   stack_header:        33.
          60    stack_header.sys_link_info_ptr       stack_header:        56.
          72    stack_header.trace_frames      trace_catch_:      1069, 1220, 1221, 1310, 1362, 1529, 1607, 1608, 1675, 1676,
                                               stack_header:        61.
          50    stack_header.trans_op_tv_ptr   trace_catch_:      1593, 1716,
                                               stack_header:        51.
          56    stack_header.unwinder_ptr      stack_header:        54.
          16    stack_header.user_free_ptr     stack_header:        34.
         100    stack_header_end         stack_header:        64.
          14    start                    trace_catch_:      1077, 1235, 1253, 1278, 1316, 1366, 1410, 1481, 1537, 1552, 1786.
          21    start_comp               trace_catch_:      1077, 1235, 1253, 1316, 1366, 1481, 1537, 1787.
        3141    START_METERS_IN_THIS_FRAME     trace_catch_:      1678, 1708.
        3243    START_NEXT_FRAME         trace_catch_:      1693, 1705.
        3256    START_RETURN             trace_catch_:      1660, 1670, 1725.
        3121    start_tracing            trace_catch_:      1653, 1654.
          10    static_section           trace_catch_:      1777, 1778.
          22    stop                     trace_catch_:      1001, 1037, 1077, 1168, 1227, 1291, 1300, 1316, 1349, 1443, 1463,
                                                            1481, 1514, 1789.
        1367    STOP_IT.._00013          trace_catch_:      1227.
        2111    STOP_IT.._00024          trace_catch_:      1349.
        2743    STOP_SHORT_RETURN        trace_catch_:      1573, 1584.
        2753    STOP_TRACING             trace_catch_:      1597, 1601, 1602.
        2725    stop_tracing             trace_catch_:      1566, 1567.
                sys_info                 trace_catch_:        33, 1001, 1278, 1291, 1410, 1443, 1552.
           4    tab.cts                  trace_catch_:      1179, 1181, 1186, 1188, 1196, 1198, 1199, 1201, 1356, 1521, 1854.
          24    tab.function             trace_catch_:      1863.
          16    tab.global               trace_catch_:      1353, 1518, 1635, 1860.
          10    tab.local                trace_catch_:      1353, 1518, 1635, 1856.
          15    tab.on                   trace_catch_:      1192, 1227, 1345, 1349, 1510, 1514, 1858.
           3    tab.parms_ptr            trace_catch_:      1227, 1349, 1514, 1852.
           2    tab.reference_count      trace_catch_:      1851.
          23    tab.translator_id        trace_catch_:      1192, 1227, 1345, 1349, 1510, 1514, 1862.
           0    tab.version              trace_catch_:      1173, 1334, 1499, 1629, 1697, 1850.
           3    table.count              trace_catch_:       932,  937,  963,  968, 1227, 1349, 1582, 1669, 1829.
          10    table.e                  trace_catch_:       834,  863,  887,  908,  923,  937,  956,  963, 1095, 1151, 1227,
                                                            1327, 1349, 1492, 1625, 1693, 1836.
           4    table.idx                trace_catch_:       834,  863,  887,  908,  918,  920,  928,  931,  937,  956,  963,
                                                             966, 1095, 1151, 1227, 1327, 1349, 1492, 1625, 1693, 1831.
           2    table.max_count          trace_catch_:       834,  863,  887,  908,  937,  956,  963, 1095, 1151, 1327, 1492,
                                                            1625, 1693, 1828.
           0    table.version            trace_catch_:       828,  857,  881,  902,  950, 1089, 1147, 1227, 1321, 1349, 1486,
                                                            1579, 1619, 1666, 1687, 1827.
           6    table.working_storage    trace_catch_:       834,  908,  937,  963, 1095, 1327, 1492, 1625, 1693, 1835.
         202    table_add                trace_catch_:       897,  898.
                table_full               trace_catch_:       921.
         116    table_get                trace_catch_:       852,  853.
                table_index_oob          trace_catch_:       863,  887,  956, 1151.
         355    TABLE_NORMALIZED.._00004       trace_catch_:       937.
         455    TABLE_NORMALIZED.._00006       trace_catch_:       963.
         151    table_put_data           trace_catch_:       876,  877.
         360    table_remove             trace_catch_:       945,  946.
          23    table_seek               trace_catch_:       823,  824.
         107    TABLE_SEEK_FOUND         trace_catch_:       834,  836.
         113    TABLE_SEEK_NOT_FOUND     trace_catch_:       834,  842.
        3266    TAB_VERSION_3            trace_catch_:      1174, 1335, 1500, 1630, 1698, 1741.
           0    te                       trace_catch_:       865,  927,  958, 1843.
           1    te.data                  trace_catch_:       868,  890,  926,  961, 1101, 1153, 1227, 1333, 1349, 1498, 1628,
                                                            1696, 1845.
           0    te.key                   trace_catch_:       834,  867,  908,  925,  960, 1095, 1227, 1327, 1349, 1492, 1625,
                                                            1693, 1844.
           2    te_size                  trace_catch_:       834,  908, 1095, 1327, 1492, 1625, 1693, 1841.
         762    THIS_IS_A_SIGNAL         trace_catch_:      1114, 1117, 1156.
        3310    three_arg_list_header    trace_catch_:      1756.
        3322    three_arg_list_header_w_env    trace_catch_:      1762.
           0    to_entry.real_time       trace_catch_:      1077, 1481, 1966.
           2    to_entry.vcpu_time       trace_catch_:      1077, 1481, 1967.
           4    to_return.real_time      trace_catch_:      1316, 1968.
           6    to_return.vcpu_time      trace_catch_:      1316, 1969.
                trace_alm_entry          trace_catch_:        43, 1722.
         463    trace_catcher_           trace_catch_:        35,  987,  988, 1012.
                trace_catch_             trace_catch_:        35,   36, 1012, 1448, 1597.
        2276    TRACE_CATCH_CLEANUP      trace_catch_:        36, 1215, 1433, 1435, 1448.
                trace_entrypoints_       trace_catch_:      1141.
                trace_error_halt_        trace_catch_:       830,  834,  859,  863,  883,  887,  904,  908,  921,  937,  952,
                                                             956,  963, 1075, 1077, 1091, 1095, 1149, 1151, 1168, 1175, 1227,
                                                            1231, 1312, 1316, 1323, 1327, 1336, 1349, 1353, 1356, 1476, 1481,
                                                            1488, 1492, 1501, 1514, 1518, 1521, 1581, 1614, 1621, 1625, 1631,
                                                            1635, 1668, 1682, 1689, 1693, 1699, 1703.
           0    trace_frames.count       trace_catch_:      1074, 1166, 1220, 1225, 1607, 1613, 1638, 1675, 1681, 1706,
                                         stack_header:        69.
           1    trace_frames.top_ptr     trace_catch_:      1072, 1221, 1310, 1608, 1639, 1676, 1707,
                                         stack_header:        70.
         136    trace_frames_saved       trace_catch_:        71, 1070, 1072, 1074, 1166, 1225, 1361, 1528, 1613, 1638, 1639,
                                                            1681, 1706, 1707.
                trace_operator_pointers_       trace_catch_:        42, 1715.
                trace_operator_table     trace_catch_:        41, 1713.
          52    trace_storage_ptr        trace_catch_:      1802, 1803.
         766    TRACE_THIS_SIGNAL        trace_catch_:      1165.
                trace_transactions_      trace_catch_:        47,   49.
          10    TRANSACTION_BEGIN        trace_catch_:        48, 1126, 1780.
                transaction_begin        trace_catch_:        47.
          11    TRANSACTION_BEGIN_FORCE  trace_catch_:        50, 1129, 1781.
                transaction_begin_force  trace_catch_:        49.
      400000    TRUE                     trace_catch_:      1063, 1227, 1304, 1349, 1467, 1822.
         271    TRY_LOW_HALF_APPEND      trace_catch_:       908,  915,  939.
          54    tt_ptr                   trace_catch_:      1088, 1146, 1320, 1485, 1578, 1618, 1665, 1686, 1806, 1807.
        3264    TT_VERSION_3             trace_catch_:       829,  858,  882,  903,  951, 1090, 1148, 1227, 1322, 1349, 1487,
                                                            1580, 1620, 1667, 1688, 1738.
         551    tv_offset                stack_header:        75,   80,   81,   82,   83,   84.
        3306    two_arg_list_header      trace_catch_:      1134, 1227, 1349, 1755.
        3320    two_arg_list_header_w_env      trace_catch_:      1227, 1349, 1761.
        3274    UNUSUAL_SIGNAL_ARG_LIST  trace_catch_:      1168, 1750.
        3336    vcpu_time_fuzz           trace_catch_:      1771.
        1342    WATCH_TABLE_DONE.._00015       trace_catch_:      1227.
        1443    WATCH_TABLE_DONE.._00016       trace_catch_:      1227.
        2063    WATCH_TABLE_DONE.._00026       trace_catch_:      1349.
        2165    WATCH_TABLE_DONE.._00027       trace_catch_:      1349.
        1323    WATCH_TABLE_LOOP.._00015       trace_catch_:      1227.
        1424    WATCH_TABLE_LOOP.._00016       trace_catch_:      1227.
        2044    WATCH_TABLE_LOOP.._00026       trace_catch_:      1349.
        2146    WATCH_TABLE_LOOP.._00027       trace_catch_:      1349.
         146    watch_values_changed     trace_catch_:        78, 1227, 1349.
          56    wt_ptr                   trace_catch_:      1227, 1349, 1810, 1811.
        2744    YANK_OP_PTRS             trace_catch_:      1575, 1577, 1583, 1589.
        3302    zero_arg_list_header     trace_catch_:      1753.


NO FATAL ERRORS


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
