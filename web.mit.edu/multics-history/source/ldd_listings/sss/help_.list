	COMPILATION LISTING OF SEGMENT help_
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 09/13/88  1320.9 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(86-03-05,LJAdams), approve(86-03-05,MCR7327),
       16*     audit(86-04-17,Lippard), install(86-04-24,MR12.0-1048):
       17*     Changed routines to use line parsing.
       18*  2) change(86-05-08,LJAdams), approve(86-05-14,MCR7416),
       19*     audit(86-06-06,Gilcrease), install(86-06-12,MR12.0-1074):
       20*     Changed sort so that the ep identifier is included.  This is so that
       21*     separate infos are maintained for each entry_point is given on the
       22*     command line.
       23*  3) change(86-09-04,LJAdams), approve(86-09-04,MCR7506),
       24*     audit(86-10-29,GDixon), install(86-10-30,MR12.0-1203):
       25*     Moved error messages for no match on srh/section and entry point not
       26*     found here to avoid printing duplicate error messages per info seg
       27*     found in search path.
       28*  4) change(87-01-20,LJAdams), approve(87-09-03,MCR7766),
       29*     audit(88-08-14,GDixon), install(88-09-13,MR12.2-1109):
       30*     Changed to version Vhelp_args_3.
       31*  5) change(88-02-17,LJAdams), approve(88-03-07,MCR7857),
       32*     audit(88-08-14,GDixon), install(88-09-13,MR12.2-1109):
       33*     Changed to check the help_args.help_data_ptr to determine if it is a
       34*     list_request operation.  This is because when checking the validity of
       35*     names the lr operation must allow the (. .. ?) symbols.
       36*  6) change(88-03-14,LJAdams), approve(88-06-01,MCR7873),
       37*     audit(88-08-14,GDixon), install(88-09-13,MR12.2-1109):
       38*     Changed VPDinfo_seg_1 to VPDinfo_seg_2.  Changed sort to eliminate
       39*     duplicates from sorting 360 bits to sorting 396 bits. (phx21111)
       40*                                                   END HISTORY COMMENTS */
       41 
       42 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       43 /*									*/
       44 /* Name:  help_								*/
       45 /*									*/
       46 /* This subroutine implements the help command.  It performs the following functions.	*/
       47 /*									*/
       48 /* 1) Finds info segments.							*/
       49 /* 2) Selects particular infos within multi-info segments.				*/
       50 /* 3) Sorts the list of infos to be processed.					*/
       51 /* 4) Processes each info, implementing all help control arguments and query responses.	*/
       52 /*									*/
       53 /* The subroutine may also be used to implement a help-style information facility in	*/
       54 /* other subsystems.  Information segments (with an info suffix or another suffix) are	*/
       55 /* selected and printed, based upon information given primarily in a help_args structure,	*/
       56 /* which is declared in help_args_.incl.pl1.					*/
       57 /*									*/
       58 /* Usage									*/
       59 /*									*/
       60 /* The help_ subroutine must be invoked by a sequence of calls.			*/
       61 /*									*/
       62 /* 1) call help_$init to get temp segment containing help_args structure and stores the 	*/
       63 /*    current info_segments search rules in the structure.				*/
       64 /* 2) call help_ one or more times to select and print info segments                      */
       65 /* 3) call help_$term to release the temp segment.				*/
       66 /*									*/
       67 /* Entry:  help_$check_info_segs						*/
       68 /*									*/
       69 /* This subroutine generates the list of info segments to be processed by the 		*/
       70 /* check_info_segs command.  It finds info segments modified since a given date, sorts	*/
       71 /* the list and returns it for check_info_segs to process.				*/
       72 /*									*/
       73 /* Usage									*/
       74 /*									*/
       75 /* 1) call help_$init to get temp segment containing help_args and the output list.	*/
       76 /* 2) call help_$check_info_segs to build and sort the list of segments to be processed.	*/
       77 /* 3) call help_$term to release the temp segment.				*/
       78 /*									*/
       79 
       80 /* Status									*/
       81 /*									*/
       82 /* 0) Created:   November, 1969   by T. H. VanVleck				*/
       83 /* 1) Modified:  February, 1975   by T. H. VanVleck - complete rewrite		*/
       84 /* 2) Modified:  September,1976   by Steve Herbst - accept -pathname ctl_arg		*/
       85 /* 3) Modified:  June, 1977	    by Paul Green - diagnose zero-length info segs	*/
       86 /* 4) Modified:  October, 1978    by Gary Dixon - complete rewrite; split into help	*/
       87 /*				command and separate help_ subroutine.		*/
       88 /*				Add support for check_info_segs.		*/
       89 /* 5) Modified:  April, 1985      by L. Adams - rewrote parsing routines to use line logic*/
       90 /*									*/
       91 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       92 
       93 /* format: style2,ind2,ll131,dclind4,idind15,comcol41,linecom,ifthen */
       94 help_:	
       95   procedure (procedure_name, Phelp_args, suffix, progress, Acode);
       96 
       97     dcl				/*	Parameters			*/
       98         procedure_name char (*),	/* Caller of help_ and help_$init.		*/
       99 				/*   1) Owns temp segment help_args are stored in.*/
      100 				/*   2) Name used in error messages.		*/
      101 /*      Phelp_args	   ptr, */          /* ptr to argument struc at base of temp seg.	*/
      102 				/* This is really declared in include seg.	*/
      103         suffix	   char (*),	/* Suffix on segs to be processed. Normally "info"*/
      104 				/* but may be some other suffix or "" to omit	*/
      105 				/* suffix processing.			*/
      106         progress	   fixed bin,	/* =1: bad help_args version			*/
      107 				/* =2: no pathnames given.			*/
      108 				/* =3: evaluating pathnames.			*/
      109 				/* =4: finding help segs.			*/
      110 				/* =5: -section/-search & printing help segs.	*/
      111         Acode	   fixed bin (35),	/* Return code.				*/
      112         APPDinfo_seg   ptr;		/* Ptr to output structures returned by		*/
      113 				/* help_$check_info_segs			*/
      114 
      115     dcl Lseg	   fixed bin (21),	/* Length of info.				*/
      116         Ninfos_printed fixed bin,	/* Number of infos for which something has printed*/
      117         Nlast_info_cross_ref
      118 		   fixed bin,	/* Last info with Scross_ref on.		*/
      119         Nlast_info_no_brief_data
      120 		   fixed bin,	/* Last info not containing Syntax section,	*/
      121 				/* which get_brief_data encountered.		*/
      122         PI_LABEL	   label variable,
      123         PDeps	   ptr,
      124         PDinfo	   ptr,
      125         Pinit_assoc_mem
      126 		   ptr,
      127         Pnext_free_space
      128 		   ptr,		/* ptr to next free word location in temp	*/
      129 				/*   seg containing help_args.		*/
      130         Pquery_answers ptr,		/* ptr to formatted list of help responses.	*/
      131         Pseg	   ptr,
      132         Ptemp	   ptr,
      133         Sprint_inhibit bit (1) aligned, /* on if printing stopped by program_interrupt.	*/
      134         Sstandalone_invocation
      135 		   bit (1),
      136         cleanup	   condition,
      137         code	   fixed bin (35),
      138         fcn	   fixed bin,	/* Function to be performed by this invocation.	*/
      139         (
      140         HELP	   init (0),	/*   help_				*/
      141         CIS	   init (1)
      142         )				/*   check_info_segs			*/
      143 		   fixed bin int static options (constant),
      144         (i, j)	   fixed bin,
      145         offset	   fixed bin (35),
      146         program_interrupt
      147 		   condition;
      148 
      149     dcl 1 Dinfo	   aligned based (PDinfo),
      150 	2 N	   fixed bin,
      151 	2 seg	   (0 refer (Dinfo.N)) like Dinfo_seg;
      152 				/* Information about each log. info to be printed.*/
      153 
      154     dcl 1 init_assoc_mem
      155 		   aligned based (Pinit_assoc_mem),
      156 				/* Associative memory in which initiated segments	*/
      157 	2 N	   fixed bin,	/* are stored.				*/
      158 	2 seg	   (50),		/* Allow up to 50 initiated segments at once.	*/
      159 	  3 dir	   char (168) unal,
      160 	  3 ent	   char (32) unal,
      161 	  3 uid	   bit (36),
      162 	  3 pad	   fixed bin,
      163 	  3 P	   ptr;
      164 
      165     dcl 1 LIST	   aligned based,	/* structure used to format list of things to be	*/
      166 	2 header,			/* output in columns.			*/
      167 	  3 N	   fixed bin,	/*   number of list elements.			*/
      168 	  3 Nreal	   fixed bin,	/*   number of filled list elements.		*/
      169 	  3 Npghs	   fixed bin,	/*   number of filled paragraphs of formatted out.*/
      170 	  3 Nrows	   fixed bin,	/*   number of rows in formatted output.	*/
      171 	  3 Ncols	   fixed bin,	/*   number of columns in formatted output.	*/
      172 	  3 ML	   (6) fixed bin,	/*   length of longest element in each column.	*/
      173 	  3 title	   char (80) varying,
      174 				/*   title of output list.			*/
      175 	  3 Iunit	   fixed bin,	/*   unit no of pgh containing list elements.	*/
      176 	2 group	   (0 refer (LIST.N)),
      177 	  3 arg	   char (88) varying,
      178 				/*   the argument.				*/
      179 	  3 Snot_found
      180 		   fixed bin;	/*   = 1 if no match found for the argument.	*/
      181 
      182     dcl 1 query_answers
      183 		   aligned based (Pquery_answers),
      184 	2 header	   like LIST.header,
      185 	2 group	   (0 refer (query_answers.N)) like LIST.group;
      186 
      187     dcl responses	   (25) char (50) var int static options (constant) init (" yes, y",
      188 				/* List of allowed responses to questions asked	*/
      189 				/*   by help_.				*/
      190 		   " rest {-scn} {-all_entrypoints} {-entrypoints}", 
      191                        "    r {-scn} {-aep} {-ep}",
      192                        " no, n",
      193                        " quit, q",
      194                        " top, t",
      195                        " header, he",
      196 		   " title {-top}",
      197                        " section {STRs} {-case_sensitive} {-top},", 
      198                        "    scn  {STRs} {-cs} {-top}",
      199 		   " search  {STRs} {-case_sensitive} {-top},", 
      200                        "    srh  {STRs} {-cs} {-top}",
      201 		   " skip {-scn} {-seen} {-rest} {-ep},",
      202                        "    s {-scn} {-seen} {-rest} {-ep}",
      203                        " brief, bf",
      204 		   " control_arg STRs, ca STRs",
      205                        " entry_point {EP_NAME},",
      206                        "    ep {EP_NAME}",
      207                        " list_entry_points",
      208 		   "    lep",
      209                        " list_requests,",
      210                        "    lr",
      211                        " ?",
      212                        " .",
      213                        " ..");
      214 
      215     dcl bit36	   bit (36) aligned based,
      216         bit360	   bit (360) aligned based;
      217   
      218     dcl (addr, addrel, binary, char, currentsize, dim, dimension, divide, empty, hbound, index, lbound, length, ltrim, mod,
      219         null, ptr, rel, reverse, rtrim, search, string, substr, unspec, verify)
      220 		   builtin;
      221 
      222 
      223     dcl com_err_	   entry options (variable),
      224         convert_date_to_binary_
      225 		   entry (char (*), fixed bin (71), fixed bin (35)),
      226         get_temp_segment_
      227 		   entry (char (*), ptr, fixed bin (35)),
      228         hcs_$get_uid_seg
      229 		   entry (ptr, bit (36) aligned, fixed bin (35)),
      230         hcs_$initiate  entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35)),
      231         hcs_$terminate_noname
      232 		   entry (ptr, fixed bin (35)),
      233         hcs_$truncate_seg
      234 		   entry (ptr, fixed bin, fixed bin (35)),
      235         help_rql_	   entry (char(*), char(*), ptr, fixed bin, fixed bin, fixed bin(24),
      236 				     fixed bin, fixed bin, ptr, ptr, ptr, ptr, label, bit(1) aligned,
      237 				     fixed bin(35)),
      238         match_star_name_
      239 		   entry (char (*), char (*), fixed bin (35)),
      240         pathname_$component
      241 		   entry (char (*), char (*), char (*)) returns (char (194)),
      242         release_temp_segment_
      243 		   entry (char (*), ptr, fixed bin (35)),
      244         search_paths_$get
      245 		   entry (char (*), bit (36), char (*), ptr, ptr, fixed bin, ptr, fixed bin (35)),
      246         (
      247         sort_items_$bit,
      248         sort_items_$char
      249         )		   entry (ptr, fixed bin),
      250         ssu_$destroy_invocation
      251 		   entry (ptr),
      252         ssu_$print_message
      253 		   entry () options (variable),
      254         ssu_$standalone_invocation
      255 		   entry (ptr, char (*), char (*), ptr, entry, fixed bin (35));
      256 
      257     dcl (
      258         FALSE	   init ("0"b),
      259         TRUE	   init ("1"b)
      260         )		   bit (1) int static options (constant),
      261         HT_SP	   char (2) init ("	 ") int static options (constant),
      262 				/* Horizontal-tab followed by space.		*/
      263         NL	   char (1) int static options (constant) init ("
      264 "),
      265         (
      266         error_table_$badsyntax,
      267         error_table_$inconsistent,
      268         error_table_$incorrect_access,
      269         error_table_$moderr,
      270         error_table_$no_s_permission,
      271         error_table_$noarg,
      272         error_table_$noentry,
      273         error_table_$no_info,
      274         error_table_$nomatch,
      275         error_table_$unimplemented_version,
      276         error_table_$zero_length_seg
      277         )		   fixed bin (35) ext static;
      278 
      279 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      280 
      281     fcn = HELP;			/* Perform a help function.			*/
      282     go to COMMON;
      283 
      284 
      285 check_info_segs:
      286   entry (procedure_name, Phelp_args, suffix, progress, Acode, APPDinfo_seg);
      287 
      288     fcn = CIS;			/* Perform a check_info_segs function.		*/
      289 
      290 COMMON:
      291 
      292     progress = 1;
      293 
      294     if help_args.version = 1 | help_args.version = 2 then
      295       do;				/* Version 1 and version 2 are upwards-compatible with 3.	*/
      296         help_args.version = Vhelp_args_3;
      297         help_args.sci_ptr = null;
      298         help_args.Sctl.inhibit_errors = FALSE;
      299       end;
      300     if help_args.version ^= Vhelp_args_3 then
      301       do;				/* Validate structure version.		*/
      302         Acode = error_table_$unimplemented_version;
      303         return;
      304       end;
      305 
      306     progress = 2;
      307     if help_args.Npaths ^> 0 then
      308       do;				/* Make sure info file names were given.	*/
      309         Acode = error_table_$noarg;
      310         return;
      311       end;
      312     Acode = 0;
      313     progress = 3;
      314     do i = 1 to help_args.Npaths;	/* validate input paths.			*/
      315       call evaluate_path (help_args.path (i), suffix);
      316       if Acode = 0 then
      317         Acode = help_args.path.code (i);
      318     end;
      319     if Acode ^= 0 then
      320       return;
      321 
      322     progress = 4;
      323     call get_temp_segment_ (procedure_name, Pquery_answers, Acode);
      324     if Acode ^= 0 then
      325       return;			/* Get space for format list of help responses.	*/
      326 				/* Problem with size of query answers overlaping	*/
      327 				/* next list so put it in a separate temp seg	*/
      328     query_answers.N = 2 * hbound (responses, 1);
      329 				/* Copy allowed responses into the list.	*/
      330     query_answers.Nreal = query_answers.N;
      331     query_answers.Nrows = 0;		/* This indicates that list isn't formatted yet.	*/
      332     query_answers.title = "List of Responses";
      333     do i = lbound (responses, 1) to hbound (responses, 1);
      334       query_answers.group (i).arg = responses (i);
      335     end;
      336     do i = i to query_answers.N;	/* Struc must be two * size of response array	*/
      337       query_answers.group (i).arg = ""; /*   to allow for extension during formatting.	*/
      338     end;				/*   Set added elements to null strings.	*/
      339 
      340     Pinit_assoc_mem, Pnext_free_space = set_space_used (Phelp_args, currentsize (help_args));
      341 				/* Get space in temp seg for associative memory	*/
      342 				/* used to reduce calls to hcs_$initiate.	*/
      343     Sstandalone_invocation = FALSE;
      344     init_assoc_mem.N = 0;
      345     on cleanup call janitor ();	/* Establish cleanup on unit.			*/
      346 
      347     PDinfo, Pnext_free_space = set_space_used (Pnext_free_space, currentsize (init_assoc_mem));
      348     Dinfo.N = 0;			/* Obtain space for list of info segs to be read.	*/
      349     do i = 1 to help_args.Npaths;	/* Convert input paths to list of info segs.	*/
      350       if help_args.path (i).S.less_greater then
      351         call get_info_seg_list (procedure_name, suffix, fcn, help_args.path (i).dir (*), help_args.path (i), PDinfo);
      352       else call get_info_seg_list (procedure_name, suffix, fcn, help_args.search_dirs (*), help_args.path (i), PDinfo);
      353     end;
      354     if Dinfo.N <= 0 then
      355       do;				/* Stop if no matching segs found.		*/
      356         Acode = error_table_$nomatch;	/*   get_info_seg_list has already complained.	*/
      357         call janitor ();
      358         return;
      359       end;
      360 
      361     progress = 5;			/* Infos selected by starname.  Any other errors	*/
      362 				/* reported via Acode describe info selection by	*/
      363 				/* -search and -seciton criteria.		*/
      364     PPDinfo_seg, Pnext_free_space = set_space_used (Pnext_free_space, currentsize (Dinfo));
      365     PDinfo_seg.version = VPDinfo_seg_2;
      366     PDinfo_seg.N = Dinfo.N;
      367     do i = 1 to Dinfo.N;		/* Sort listed infos thrice:			*/
      368       PDinfo_seg.P (i) = addr (Dinfo.seg (i).uid);
      369       Dinfo.seg (i).X = i;		/*   1st:  sort on  Dinfo.seg.uid/.I/.E combo     */
      370     end;				/* 	 to eliminate duplicate infos.	*/
      371 				/*   2nd:  sort on Dinfo.seg.ent to identify	*/
      372 				/* 	 versions of info seg in different dirs.*/
      373     if Dinfo.N > 1 then
      374       do;				/*   3rd:  sort on Dinfo.seg.Scross_ref/dir/.ent	*/
      375         call sort_items_$bit (addr (PDinfo_seg.N), 396);
      376 				/*	 combination to alphabetize output.	*/
      377         offset = binary (rel (addr (Dinfo.seg (1).ent))) - binary (rel (addr (Dinfo.seg (1).uid)));
      378 				/* Compute negative offset to adjust ptrs to	*/
      379 				/* Dinfo.seg.uid to point back to Dinfo.seg.ent.	*/
      380 
      381         do i = 1 to Dinfo.N while (PDinfo_seg.P (i) -> bit360 = "0"b);
      382 	PDinfo_seg.P (i) = addrel (PDinfo_seg.P (i), offset);
      383         end;			/* Allow duplicate .uid/.I combos for infos	*/
      384 				/* in which errors were encountered.  These errors*/
      385 				/* must be reported.  get_info_seg_list has set	*/
      386 				/* .uid/.I combo to "0"b in these cases.	*/
      387         j = i - 1;
      388         if i > Dinfo.N then		/* if all info segs are in error, skip the	*/
      389 	go to SKIP_ELIMINATION;	/* elimination of duplicates.			*/
      390         go to CHECK (fcn);
      391 
      392 
      393 CHECK (0):
      394         do i = i to Dinfo.N - 1;	/* Eliminate duplicate .uid/.I combos.		*/
      395 	if PDinfo_seg.P (i) -> bit360 ^= PDinfo_seg.P (i + 1) -> bit360 then
      396 	  do;
      397 	    j = j + 1;		/*   (Only retain unique .uid/.I combos.)	*/
      398 	    PDinfo_seg.P (j) = addrel (PDinfo_seg.P (i), offset);
      399 	  end;
      400 	else PDinfo_seg.P (i + 1) = PDinfo_seg.P (i);
      401 				/*   (Retain info found earliest in search rules).*/
      402         end;
      403         go to END_CHECK;
      404 
      405 CHECK (1):
      406         do i = i to Dinfo.N - 1;	/* Eliminate duplicate .uid combos.		*/
      407 	if PDinfo_seg.P (i) -> bit36 ^= PDinfo_seg.P (i + 1) -> bit36 then
      408 	  do;
      409 	    j = j + 1;		/*   (Only retain unique .uid combos.)		*/
      410 	    PDinfo_seg.P (j) = addrel (PDinfo_seg.P (i), offset);
      411 	  end;
      412 	else PDinfo_seg.P (i + 1) = PDinfo_seg.P (i);
      413 				/*   (Retain info found earliest in search rules).*/
      414         end;
      415 
      416 END_CHECK:
      417         j = j + 1;			/*   (Always retain the last entry in the list.)	*/
      418         PDinfo_seg.P (j) = addrel (PDinfo_seg.P (i), offset);
      419         PDinfo_seg.N = j;
      420       end;
      421     else PDinfo_seg.P (1) = addr (Dinfo.seg (1).ent);
      422 
      423 SKIP_ELIMINATION:
      424     if PDinfo_seg.N > 1 then
      425       do;				/* Sort alphabetically by ent to identify info 	*/
      426         call sort_items_$char (addr (PDinfo_seg.N), 32);
      427 				/* segments appearing in more than one search dir.*/
      428         offset = binary (rel (addr (Dinfo.seg (1).Scross_ref))) - binary (rel (addr (Dinfo.seg (1).ent)));
      429 				/* Compute negative offset to adjust ptrs from	*/
      430 				/* Dinfo.seg.ent to point to Dinfo.seg.Scross_ref.*/
      431         PDinfo_seg.P (1) = addrel (PDinfo_seg.P (1), offset);
      432         do i = 1 to Dinfo.N - 1;	/* Check for entry of same name in different dirs.*/
      433 	PDinfo_seg.P (i + 1) = addrel (PDinfo_seg.P (i + 1), offset);
      434 	if PDinfo_seg.P (i) -> Dinfo_seg.ent = PDinfo_seg.P (i + 1) -> Dinfo_seg.ent
      435 	     & PDinfo_seg.P (i) -> Dinfo_seg.uid ^= PDinfo_seg.P (i + 1) -> Dinfo_seg.uid
      436 	     & PDinfo_seg.P (i) -> Dinfo_seg.uid ^= "0"b & "0"b ^= PDinfo_seg.P (i + 1) -> Dinfo_seg.uid then
      437 	  do;
      438 	    if binary (rel (PDinfo_seg.P (i)), 18) < binary (rel (PDinfo_seg.P (i + 1)), 18) then
      439 	      do;
      440 	        Ptemp = PDinfo_seg.P (i);
      441 				/* Mark all but entry found earliest in search	*/
      442 	        PDinfo_seg.P (i) = PDinfo_seg.P (i + 1);
      443 	        PDinfo_seg.P (i + 1) = Ptemp;
      444 				/* rules with a cross reference flag.		*/
      445 	      end;
      446 	    PDinfo_seg.P (i) -> Dinfo_seg.Scross_ref = TRUE;
      447 	  end;
      448         end;
      449       end;
      450     else PDinfo_seg.P (1) = addr (Dinfo.seg (1).Scross_ref);
      451 
      452     if PDinfo_seg.N > 1 then		/* Sort alphabetically by Scross_ref/dir/ent combo*/
      453       call sort_items_$char (addr (PDinfo_seg.N), 204);
      454 				/* 4 + 168 + 32                                   */
      455     if fcn = CIS then
      456       do;
      457         call term_assoc_mem ();
      458         APPDinfo_seg = PPDinfo_seg;
      459         return;
      460       end;
      461 
      462     PDeps, Pnext_free_space = set_space_used (Pnext_free_space, currentsize (PDinfo_seg));
      463 				/* Get space for entry point info descriptors.	*/
      464     Nlast_info_no_brief_data = -1;	/* No info processed yet.			*/
      465     Nlast_info_cross_ref = -1;
      466 
      467     PI_LABEL = PROCESS;		/* Establish pi handler.			*/
      468     on program_interrupt
      469       begin;
      470         Sprint_inhibit = TRUE;
      471         go to PI_LABEL;
      472       end;
      473 
      474 PROCESS:
      475     Ninfos_printed = 0;
      476     code = 0;
      477 
      478     do i = 1 to PDinfo_seg.N while (code = 0);
      479 				/* Process each listed info in alphabetical order.*/
      480       PI_LABEL = NEXT_INFO;
      481       PDinfo_seg_ = PDinfo_seg.P (i);
      482       if Dinfo_seg_.code ^= 0 then
      483         do;			/* Print any error encountered while finding seg.	*/
      484 INIT_ERROR:
      485 	call error (help_args.sci_ptr, Dinfo_seg_.code, "For ^[link^;segment^;directory^]: ^a^[>^]^a^[
      486 Looking for an info matching ^a^].", binary (Dinfo_seg_.segment_type, 2) + 1, Dinfo_seg_.dir, Dinfo_seg_.dir ^= ">",
      487 	     Dinfo_seg_.ent, (Dinfo_seg_.info_name ^= ""), Dinfo_seg_.info_name);
      488 	go to NEXT_INFO;
      489         end;
      490       call initiate (Dinfo_seg_.dir, Dinfo_seg_.ent, Dinfo_seg_.uid, Pseg, code);
      491       if Pseg = null then
      492         go to INIT_ERROR;		/* Initiate the info segment.			*/
      493       Lseg = Dinfo_seg_.L;		/* Address all/only log info we are printing.	*/
      494       if Lseg = 0 then
      495         do;
      496 	code = error_table_$zero_length_seg;
      497 	go to INIT_ERROR;
      498         end;
      499 
      500       call help_rql_ (procedure_name, suffix, Phelp_args, i, Ninfos_printed, PDinfo_seg.N, Nlast_info_no_brief_data,
      501 	 Nlast_info_cross_ref, PDinfo_seg_, Pseg, PDeps, Pquery_answers, PI_LABEL, Sprint_inhibit, code);
      502       if ^help_args.Sctl.inhibit_errors & code = error_table_$noentry then
      503         call error (help_args.sci_ptr, code, "^/Looking for entry point ^a in^/^5x^a", Dinfo_seg_.ep,
      504 	   pathname_$component (Dinfo_seg_.dir, Dinfo_seg_.ent, ""));
      505 
      506 NEXT_INFO:
      507     end;
      508 EXIT_LOOP:
      509     if Ninfos_printed = 0 then	/* -section and -search didn't find any match.	*/
      510       Acode = error_table_$nomatch;
      511 QUIT:
      512     call janitor ();
      513     return;
      514 
      515 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      516 
      517 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      518 
      519 
      520 abort_help_subr:
      521   procedure;
      522 
      523     go to QUIT;
      524 
      525   end abort_help_subr;
      526 
      527 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      528 
      529 
      530 error:
      531   procedure options (variable);
      532 
      533     dcl code	   fixed bin(35);
      534     dcl cu_$arg_list_ptr
      535 		   entry returns (ptr),
      536         cu_$generate_call
      537 		   entry (entry, ptr);
      538     dcl EMPTY_ARG_LIST fixed bin(71) int static options(constant) init(0);
      539 
      540     if help_args.Sctl.inhibit_errors then
      541         return;
      542 
      543     if help_args.sci_ptr = null then
      544         do;
      545         Sstandalone_invocation = TRUE;
      546         call ssu_$standalone_invocation (help_args.sci_ptr, procedure_name, ltrim (char (Vhelp_args_3)),
      547 	   addr(EMPTY_ARG_LIST), abort_help_subr, code);
      548         if code ^= 0 then
      549 	call com_err_ (code, procedure_name, "Calling ssu_$standalone_invocation.");
      550         end;
      551 
      552     if help_args.sci_ptr ^= null then
      553         call cu_$generate_call (ssu_$print_message, cu_$arg_list_ptr ());
      554 
      555   end error;
      556 
      557 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      558 
      559 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      560 
      561 
      562 evaluate_path:
      563   procedure (info_path, suffix);
      564 
      565     dcl 1 info_path	   aligned like help_args.path,
      566         suffix	   char (*);
      567 
      568     dcl i		   fixed bin;
      569 
      570     dcl check_star_name_$entry
      571 		   entry (char (*), fixed bin (35)),
      572         expand_pathname_$add_suffix
      573 		   entry (char (*), char (*), char (*), char (*), fixed bin (35));
      574 
      575     info_path.dir (1) = "";		/* Initialize to unset so caller can depend on	*/
      576     info_path.ent = "";		/* these values.				*/
      577     info_path.ep = "";
      578     info_path.S.less_greater = (search (info_path.value, "<>") > 0);
      579 				/* see if user gave more than just an entryname.	*/
      580     i = index (reverse (info_path.value), "$");
      581 				/* see if user gave a subr entry point name.	*/
      582     if info_path.S.less_greater then	/*   Must allow $ in entry names forming dir	*/
      583 				/*   part of pathname.			*/
      584       if search (reverse (info_path.value), "<>") < i then
      585         i = 0;
      586     if i > 0 then			/* save entry point name given by user in his	*/
      587       info_path.ep = substr (info_path.value, length (info_path.value) - i + 2);
      588     else info_path.ep = "";		/*   pathname argument.			*/
      589     call expand_pathname_$add_suffix (substr (info_path.value, 1, length (info_path.value) - i), suffix, info_path.dir (1),
      590          info_path.ent, info_path.code);
      591     if info_path.code ^= 0 then	/* separate pathname into dir/ent parts, add info	*/
      592       return;			/*   suffix.				*/
      593     if info_path.S.pn_ctl_arg then	/* if -pn given, assume relative pathname follows	*/
      594       info_path.S.less_greater = TRUE;	/*   (Note we've already expanded path on this	*/
      595 				/*    assumption.)				*/
      596     if info_path.info_name = "" then
      597       do;
      598         info_path.S.separate_info_name = FALSE;
      599 				/* info_name usually = entryname w/o suffix.	*/
      600         if suffix = "" then
      601 	info_path.info_name = info_path.ent;
      602         else info_path.info_name =
      603 	        substr (info_path.ent, 1, 32 - length (suffix) - index (reverse (info_path.ent), reverse (suffix) || "."));
      604       end;
      605     else info_path.S.separate_info_name = TRUE;
      606     call check_star_name_$entry (info_path.ent, info_path.code);
      607     if info_path.code = 0 then
      608       do;				/* if no starname given, -ep ctl arg allowed.	*/
      609         info_path.S.starname_ent = FALSE;
      610         if help_args.Sctl.ep & info_path.ep = "" then
      611 				/* Default ep name = entryname w/o suffix.	*/
      612 	if suffix = "" then
      613 	  info_path.ep = info_path.ent;
      614 	else info_path.ep =
      615 	  substr (info_path.ent, 1, 32 - length (suffix) - index (reverse (info_path.ent), reverse (suffix) || "."));
      616       end;
      617     else if info_path.code = 1 |	/* forbid -ep if starname was given.		*/
      618          info_path.code = 2 then
      619       do;
      620         info_path.code = 0;
      621         info_path.S.starname_ent = TRUE;
      622         if help_args.Sctl.ep | (info_path.ep ^= "") then
      623 	info_path.code = error_table_$inconsistent;
      624       end;
      625 
      626     if info_path.code ^= 0 then
      627       return;
      628     if info_path.S.separate_info_name then
      629       do;				/* Check star-ness of user-supplied info_name.	*/
      630         if info_path.S.info_name_not_starname then
      631 	info_path.S.starname_info_name = FALSE;
      632         else
      633 	do;
      634 	  call check_star_name_$entry (info_path.info_name, info_path.code);
      635 	  if info_path.code = 1 | info_path.code = 2 then
      636 	    do;
      637 	      info_path.code = 0;
      638 	      info_path.S.starname_info_name = TRUE;
      639 	    end;
      640 	  else info_path.S.starname_info_name = FALSE;
      641 	end;
      642       end;
      643     else info_path.S.starname_info_name = info_path.S.starname_ent;
      644 
      645   end evaluate_path;
      646 
      647 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      648 
      649 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      650 
      651 
      652 get_info_seg_list:
      653   procedure (procedure_name, suffix, fcn, dirs, info_path, PDinfo_) options (non_quick);
      654 				/* non_quick so that the large area won't stay around	*/
      655 				/*   all the while help active and take up stack frame	*/
      656 				/*   space.					*/
      657 
      658     dcl procedure_name char (*),
      659         suffix	   char (*),
      660         fcn	   fixed bin,
      661         dirs	   (*) char (168) unaligned,
      662         1 info_path	   aligned like help_args.path,
      663         PDinfo_	   ptr;
      664 
      665     dcl I		   fixed bin,
      666         Lline	   fixed bin,
      667         Lseg	   fixed bin (21),
      668         Nstart	   fixed bin,
      669         Pseg	   ptr,
      670         Ptemp	   ptr,
      671         area	   area (25000) init (empty ()),
      672         code	   fixed bin (35),
      673         (i, j, k)	   fixed bin,
      674         l		   fixed bin (21),
      675         line	   char (Lline) based (Pseg),
      676         linfo_name	   char (32),	/* info name without the suffix.		*/
      677         sinfo_name	   char (32),	/* info name with the suffix.			*/
      678         saved_date	   fixed bin (71);
      679 
      680     dcl 1 Dinfo_	   aligned based (PDinfo_),
      681 	2 N	   fixed bin,
      682 	2 seg	   (0 refer (Dinfo_.N)) like Dinfo_seg;
      683 
      684     dcl seg	   char (Lseg) based (Pseg),
      685 				/* The info segment.  Pseg must be declared in	*/
      686 				/* the external procedure so its on unit	*/
      687 				/* (janitor) can terminate the segment.		*/
      688         seg_char	   (Lseg) char (1) based (Pseg);
      689 
      690     dcl hcs_$star_dir_list_
      691 		   entry (char (*), char (*), fixed bin (3), ptr, fixed bin, fixed bin, ptr, ptr, fixed bin (35)),
      692         hcs_$status_long
      693 		   entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
      694 
      695     Nstart = Dinfo_.N;		/* Remember count of info segs found before we	*/
      696 				/*   start.  Then we'll know if we find any.	*/
      697     do i = lbound (dirs, 1) to hbound (dirs, 1);
      698 				/* Apply info path to each dir to be searched.	*/
      699       star_select_sw = star_ALL_ENTRIES;
      700       call hcs_$star_dir_list_ (dirs (i), info_path.ent, star_select_sw, addr (area), star_branch_count, star_link_count,
      701 	 star_list_branch_ptr, star_list_names_ptr, code);
      702       if code = 0 then
      703         do;
      704 	do j = 1 to star_branch_count + star_link_count;
      705 				/* process entries found in this directory.	*/
      706 	  k, Dinfo_.N = Dinfo_.N + 1;
      707 	  Dinfo_.seg (k).Scross_ref = FALSE;
      708 	  Dinfo_.seg (k).dir = dirs (i);
      709 	  Dinfo_.seg (k).ent = star_list_names (star_dir_list_branch (j).nindex);
      710 	  Dinfo_.seg (k).info_name = "";
      711 	  Dinfo_.seg (k).ep = info_path.ep;
      712 	  Dinfo_.seg (k).E = info_path.ep;
      713 	  Dinfo_.seg (k).segment_type = star_dir_list_branch (j).type;
      714 
      715 /* Process each entry according to its type.	*/
      716 	  if star_dir_list_branch (j).type = star_SEGMENT then
      717 	    do;
      718 	      Dinfo_.seg (k).L = divide (star_dir_list_branch (j).bit_count, 9, 24, 0);
      719 	      Dinfo_.seg (k).date = numeric_date (star_dir_list_branch (j).dtem);
      720 	      Dinfo_.seg (k).mode = substr (star_dir_list_branch (j).mode, 2, 3);
      721 				/* extract "rew" mode bits from "trewa".			*/
      722 	      Dinfo_.seg (k).code = 0;
      723 	      if Dinfo_.seg (k).L = 0 then
      724 	        Dinfo_.seg (k).code = error_table_$zero_length_seg;
      725 	      else if star_dir_list_branch (j).bit_count - 9 * Dinfo_.seg (k).L > 0 then
      726 	        Dinfo_.seg (k).code = error_table_$badsyntax;
      727 	    end;
      728 	  else if star_dir_list_branch (j).type = star_LINK then
      729 	    do;			/* Links must be chased, and target examined.	*/
      730 	      call hcs_$status_long (Dinfo_.seg (k).dir, Dinfo_.seg (k).ent, 1, addr (branch), null (), code);
      731 	      if (code = 0) | (code = error_table_$no_s_permission) then
      732 	        do;
      733 		if branch.type = Segment then
      734 		  do;
      735 		    Dinfo_.seg (k).L = divide (binary (branch.bit_count, 24), 9, 24, 0);
      736 		    Dinfo_.seg (k).date = numeric_date (branch.dtem);
      737 		    Dinfo_.seg (k).mode = substr (branch.mode, 2, 3);
      738 		    Dinfo_.seg (k).code = 0;
      739 		    if Dinfo_.seg (k).L = 0 then
      740 		      Dinfo_.seg (k).code = error_table_$zero_length_seg;
      741 		    else if binary (branch.bit_count, 24) - 9 * Dinfo_.seg (k).L > 0 then
      742 		      Dinfo_.seg (k).code = error_table_$badsyntax;
      743 		  end;
      744 		else if branch.type = Link then
      745 		  do;
      746 		    Dinfo_.seg (k).L = 0;
      747 		    Dinfo_.seg (k).date = 0;
      748 		    Dinfo_.seg (k).mode = "0"b;
      749 		    Dinfo_.seg (k).code = error_table_$noentry;
      750 		  end;
      751 		else
      752 		  do;		/* Skip matching directories.			*/
      753 		    Dinfo_.N = Dinfo_.N - 1;
      754 		    go to SKIP_ENTRY;
      755 				/*   Forget everything we've done for this entry.	*/
      756 		  end;
      757 	        end;
      758 	      else
      759 	        do;		/* Don't have access to the link target.	*/
      760 		Dinfo_.seg (k).L = 0;
      761 		Dinfo_.seg (k).date = 0;
      762 		Dinfo_.seg (k).mode = "0"b;
      763 		Dinfo_.seg (k).code = code;
      764 	        end;
      765 	    end;
      766 	  else
      767 	    do;			/* Skip matching directories.			*/
      768 	      Dinfo_.N = Dinfo_.N - 1;
      769 	      go to SKIP_ENTRY;
      770 	    end;
      771 	  if Dinfo_.seg (k).code = 0 then
      772 	    if (Dinfo_.seg (k).mode & "100"b) then
      773 	      if help_args.min_date_time ^< Dinfo_.seg (k).date then
      774 	        Dinfo_.N = Dinfo_.N - 1;
      775 	      else ;
      776 	    else Dinfo_.seg (k).code = error_table_$moderr;
      777 				/* report error if user can't access info seg.	*/
      778 SKIP_ENTRY:
      779 	end;
      780 
      781 	free star_list_names in (area),
      782 				/* free found entry structures.		*/
      783 	     star_dir_list_branch in (area);
      784         end;
      785 
      786       else if (code = error_table_$incorrect_access | code = error_table_$no_info) & ^info_path.S.starname_ent then
      787         do;			/* If user does not have "s" permission to dir,	*/
      788 				/* look for a specific help seg.		*/
      789 	call hcs_$status_long (dirs (i), info_path.ent, 1, addr (branch), null (), code);
      790 	if (code = error_table_$no_s_permission) | (code = 0) then
      791 	  do;
      792 	    if branch.type ^= Directory then
      793 	      do;
      794 	        k, Dinfo_.N = Dinfo_.N + 1;
      795 	        Dinfo_.seg (k).Scross_ref = FALSE;
      796 	        Dinfo_.seg (k).dir = dirs (i);
      797 	        Dinfo_.seg (k).ent = info_path.ent;
      798 	        Dinfo_.seg (k).info_name = "";
      799 	        Dinfo_.seg (k).ep = info_path.ep;
      800 	        Dinfo_.seg (k).E = info_path.ep;
      801 	        Dinfo_.seg (k).segment_type = branch.type;
      802 	        if branch.type = Segment then
      803 		do;
      804 		  Dinfo_.seg (k).L = divide (binary (branch.bit_count, 24), 9, 24, 0);
      805 		  Dinfo_.seg (k).date = numeric_date (branch.dtem);
      806 		  Dinfo_.seg (k).mode = substr (branch.mode, 2, 3);
      807 		  if Dinfo_.seg (k).mode & "100"b then
      808 		    Dinfo_.seg (k).code = 0;
      809 		  else Dinfo_.seg (k).code = error_table_$moderr;
      810 		  if Dinfo_.seg (k).L = 0 then
      811 		    Dinfo_.seg (k).code = error_table_$zero_length_seg;
      812 		  else if binary (branch.bit_count, 24) - 9 * Dinfo_.seg (k).L > 0 then
      813 		    Dinfo_.seg (k).code = error_table_$badsyntax;
      814 		  else if code = 0 then
      815 		    if help_args.min_date_time ^< Dinfo_.seg (k).date then
      816 		      Dinfo_.N = Dinfo_.N - 1;
      817 		end;
      818 	        else
      819 		do;		/* Give error for link target being a link.	*/
      820 		  Dinfo_.seg (k).L = 0;
      821 		  Dinfo_.seg (k).date = 0;
      822 		  Dinfo_.seg (k).mode = "0"b;
      823 		  Dinfo_.seg (k).code = error_table_$noentry;
      824 		end;
      825 	      end;
      826 	  end;
      827 	else if code = error_table_$noentry then
      828 	  ;
      829 	else go to DIR_ERROR;
      830         end;
      831       else if code = error_table_$nomatch then
      832         ;
      833       else
      834         do;			/* Fatal error looking in this dir.		*/
      835 DIR_ERROR:
      836 	call error (help_args.sci_ptr, code, "^/Looking for info segments in ^a.", dirs (i));
      837 	if dim (dirs, 1) = 1 then
      838 	  return;			/* Avoid getting nomatch error in addition to 	*/
      839         end;			/* this one when only 1 dir to look into.	*/
      840     end;
      841 
      842     if fcn = CIS then
      843       do;
      844         do i = Nstart + 1 to Dinfo_.N;
      845 	if Dinfo_.seg (i).code ^= 0 then
      846 	  do;
      847 	    Dinfo_.seg (i).uid = "0"b;
      848 	    Dinfo_.seg (i).I = 0;
      849 	    Dinfo_.seg (i).E = "";
      850 	  end;
      851         end;
      852         return;
      853       end;
      854     else if Dinfo_.N = Nstart then
      855       do;
      856         if info_path.S.starname_ent then
      857 	code = error_table_$nomatch;
      858         else code = error_table_$noentry;
      859         call error (help_args.sci_ptr, code, "^[-pn ^]^a", info_path.S.pn_ctl_arg, info_path.value);
      860       end;
      861     else
      862       do i = Nstart + 1 to Dinfo_.N;	/* Look for :Info: info dividers.		*/
      863         if Dinfo_.seg (i).code = 0 then
      864 	do;
      865 	  Dinfo_.seg (i).uid = "0"b;	/* We don't know seg's uid yet.		*/
      866 	  call initiate (Dinfo_.seg (i).dir, Dinfo_.seg (i).ent, Dinfo_.seg (i).uid, Pseg, code);
      867 	  if Pseg ^= null then
      868 	    do;
      869 	      Lseg = Dinfo_.seg (i).L;
      870 	      Dinfo_.seg (i).I = 1;	/* Fill in substring index of 1st		*/
      871 				/* char of physical info seg.			*/
      872 	      I = verify (seg, "	 
      873 ");
      874 	      if I > 1 then
      875 	        do;		/* Strip HT SP NL from start of info seg.	*/
      876 		Pseg = addr (seg_char (I));
      877 		Lseg = Lseg - (I - 1);
      878 	        end;
      879 	      if Lseg > 8 then	/* See if info seg begins with :Info:		*/
      880 				/*   (8 = length(":Info:C:"), C is any char.	*/
      881 	        if substr (seg, 1, 6) = ":Info:" | substr (seg, 1, 10) = ":Internal:" then
      882 		do;		/* Internal is for help vis			*/
      883 		  if substr (seg, 1, 6) = ":Info:" then
      884 		    do;
      885 		      Pseg = addr (seg_char (7));
      886 		      Lseg = Lseg - 6;
      887 		    end;
      888 		  else
      889 		    do;
      890 		      Pseg = addr (seg_char (11));
      891 		      Lseg = Lseg - 10;
      892 		    end;
      893 		  k = i;
      894 		  Dinfo_.seg (k).info_name = info_path.info_name;
      895 				/* save info_name used to find infos for use in	*/
      896 				/* error messages  (without suffix).		*/
      897 		  saved_date = Dinfo_.seg (k).date;
      898 				/* save date assoc with phys info seg in case	*/
      899 				/* some log. infos don't have date in their header*/
      900 		end;
      901 	        else Lseg, k = 0;
      902 	      else Lseg, k = 0;
      903 
      904 	      do while (Lseg > 0);	/* It does contain :Info:.  Look for info(s)	*/
      905 	        Lline = index (seg, NL);
      906 				/* which match user-supplied entryname.		*/
      907 	        if Lline = 0 then
      908 		Lline = Lseg;
      909 	        linfo_name = find_info_name (line, I);
      910 	        do while (I > 0);
      911 		if info_path.S.starname_info_name then
      912 		  do;
      913 		    call match_star_name_ (linfo_name, info_path.info_name, code);
      914 		    if code ^= 0 then
      915 		      go to NO_MATCH;
      916 		  end;
      917 		else if linfo_name ^= info_path.info_name then
      918 		  go to NO_MATCH;
      919 
      920 		if ^info_path.S.separate_info_name then
      921 		  do;		/* POTENTIAL BUG:  Use of assoc. memory for 	*/
      922 				/* initiated segs may subvert test to see if 	*/
      923 				/* info_name really a name on phys. info seg.	*/
      924 				/* Subsequent attempt to reinitiate may succeed 	*/
      925 				/* by uid found in assoc mem, rather than by name	*/
      926 				/* being found on phys. info seg.		*/
      927 		    if suffix ^= "" then
      928 		      sinfo_name = rtrim (linfo_name) || "." || suffix;
      929 		    else sinfo_name = linfo_name;
      930 
      931 /* Test now to see if log info_name is on seg.	*/
      932 		    if info_path.S.starname_ent then
      933 		      do;
      934 		        call hcs_$initiate (Dinfo_.seg (k).dir, sinfo_name, "", 0, 0, Ptemp, code);
      935 		        if Ptemp = null then
      936 			go to NO_MATCH;
      937 		      end;
      938 		    Dinfo_.seg (k).ent = sinfo_name;
      939 		  end;		/* This info matches.  Include it in output list.	*/
      940 		j = Lline - index (reverse (line), ":") + 2;
      941 		Dinfo_.seg (k).I = rel_char (addr (seg_char (j))) + 1;
      942 				/* get index of first char of this info.	*/
      943 				/* 1 is added to the char offset returned by 	*/
      944 				/* rel_char to get a char index.		*/
      945 		l = index (seg, "
      946 
      947 
      948 :Info:");				/* get info length by finding next info.	*/
      949 		if l = 0 then	/* need for help vis			*/
      950 		  l = index (seg, "
      951 
      952 
      953 :Internal:");			/* get info length by finding next info.	*/
      954 		if l > 0 then
      955 		  Dinfo_.seg (k).L = l - (j - 1);
      956 		else Dinfo_.seg (k).L = Lseg - (j - 1);
      957 		Pseg = addr (seg_char (j));
      958 		Lseg = Lseg - (j - 1);
      959 		Lline = Lline - (j - 1);
      960 		j = verify (seg, "	 
      961 ");
      962 		if j > 1 then
      963 		  do;		/* Remove leading HT SP NL from log info.	*/
      964 		    Pseg = addr (seg_char (j));
      965 		    Lseg = Lseg - (j - 1);
      966 		    Lline = index (seg, NL);
      967 		    if Lline = 0 then
      968 		      Lline = Lseg;
      969 		  end;
      970 		if Lseg >= Lline + 1 then
      971 				/* Store date assoc with log info.		*/
      972 		  if seg_char (Lline + 1) = NL then
      973 		    do;		/* Date comes from 1st field of heading line of	*/
      974 				/* log info, which must be followed by blank line.*/
      975 		      Lline = Lline - 1;
      976 		      j = search (line, "	 ");
      977 		      if j = 0 then
      978 		        j = Lline;
      979 		      else
      980 		        do;
      981 			call convert_date_to_binary_ (substr (line, 1, j), Dinfo_.seg (k).date, code);
      982 			if code ^= 0 then
      983 			  Dinfo_.seg (k).date = saved_date;
      984 		        end;
      985 		    end;
      986 		  else Dinfo_.seg (k).date = saved_date;
      987 		else Dinfo_.seg (k).date = saved_date;
      988 		I = 0;		/* Stop processing this :Info: line (this info).	*/
      989 		if ^(info_path.S.starname_info_name | info_path.S.separate_info_name) then
      990 		  Lseg = 0;	/* If not a starname or separate info_name, 	*/
      991 				/* we've found one & only matching log. info	*/
      992 		if help_args.min_date_time ^< Dinfo_.seg (k).date then
      993 		  go to MATCH;	/* Info modified before min date; skip it	*/
      994 		Dinfo_.seg (k).info_name = linfo_name;
      995 				/* Save info_name for use in headings.		*/
      996 		k, Dinfo_.N = Dinfo_.N + 1;
      997 		Dinfo_.seg (k) = Dinfo_.seg (i);
      998 		go to MATCH;
      999 
     1000 NO_MATCH:
     1001 		Pseg = addr (seg_char (I + 1));
     1002 		Lseg = Lseg - I;	/* Look for another name on this info, since	*/
     1003 		Lline = Lline - I;	/* previous names on it don't match user wants.	*/
     1004 		linfo_name = find_info_name (line, I);
     1005 MATCH:
     1006 	        end;
     1007 
     1008 	        I = index (seg, "
     1009 
     1010 
     1011 :Info:");
     1012 	        if I > 0 then
     1013 		do;
     1014 		  Pseg = addr (seg_char (I + 9));
     1015 		  Lseg = Lseg - (I + 8);
     1016 		end;
     1017 	        else
     1018 		do;		/* need for help vis			*/
     1019 		  I = index (seg, "
     1020 
     1021 
     1022 :Internal:");
     1023 		  if I > 0 then
     1024 		    do;
     1025 		      Pseg = addr (seg_char (I + 13));
     1026 		      Lseg = Lseg - (I + 10);
     1027 		    end;
     1028 		  else Lseg = 0;
     1029 		end;
     1030 	      end;
     1031 	      if k = 0 then
     1032 	        ;			/* No :Info: in phys info seg.		*/
     1033 	      else if k = i then	/* No matching info in phys info seg.		*/
     1034 	        if info_path.S.starname_info_name then
     1035 		Dinfo_.seg (i).code = error_table_$nomatch;
     1036 	        else Dinfo_.seg (i).code = error_table_$noentry;
     1037 	      else Dinfo_.N = Dinfo_.N - 1;
     1038 				/* Matching info found.  We always get one more	*/
     1039 				/* Dinfo_.seg than we can use.		*/
     1040 	    end;
     1041 	  else Dinfo_.seg (i).code = code;
     1042 				/* Failed to initiate physical info seg.	*/
     1043 	end;
     1044         if Dinfo_.seg (i).code ^= 0 then
     1045 	do;
     1046 	  Dinfo_.seg (i).uid = "0"b;	/* If error occurred during processing, mark	*/
     1047 	  Dinfo_.seg (i).I = 0;	/* info to cause error message to be printed.	*/
     1048 	  Dinfo_.seg (i).E = "";
     1049 	end;
     1050       end;
     1051 
     1052 find_info_name:
     1053   proc (Aline, Iline) returns (char (32));
     1054 
     1055     dcl Aline	   char (*),	/* unprocessed part of :Info: line (incl NL).	*/
     1056         Iline	   fixed bin,	/* amount processed while finding this info name. */
     1057         info_name	   char (32) varying;
     1058 				/* the info_name which was found.		*/
     1059 
     1060     dcl (Icolon, Inon_space, Iquote, Iquote_quote)
     1061 		   fixed bin,
     1062         Lline	   fixed bin,
     1063         Pline	   ptr;
     1064 
     1065     dcl (
     1066         QUOTE	   char (1) init (""""),
     1067         QUOTE_QUOTE	   char (2) init ("""""")
     1068         )		   int static options (constant);
     1069 
     1070     dcl line	   char (Lline) based (Pline),
     1071         line_char	   (Lline) char (1) based (Pline);
     1072 
     1073     Pline = addr (Aline);
     1074     Lline = length (Aline);
     1075     Inon_space = verify (line, HT_SP);	/* Remove leading white space from info name.	*/
     1076     if Inon_space > 1 then
     1077       do;
     1078         Pline = addr (line_char (Inon_space));
     1079         Lline = Lline - (Inon_space - 1);
     1080       end;
     1081     else if Inon_space = 0 then
     1082       do;				/* Remainder of line is empty.		*/
     1083 ERROR:
     1084         Iline = length (Aline);
     1085         return ("");
     1086       end;
     1087 
     1088     if line_char (1) = QUOTE then
     1089       do;				/* Look for quoted info name.			*/
     1090         Pline = addr (line_char (length (QUOTE) + 1));
     1091 				/*   Skip the opening quote.			*/
     1092         Lline = Lline - length (QUOTE);
     1093         Iquote = index (line, QUOTE);	/*   Search for trailing quote.		*/
     1094         if Iquote = 0 | Iquote + 2 > Lline then
     1095 				/*   Trailing quote is missing.		*/
     1096 	go to ERROR;
     1097         Iquote_quote = index (line, QUOTE_QUOTE);
     1098 				/*   Check for doubled quotes.		*/
     1099         if Iquote ^= Iquote_quote then	/*   There are none.			*/
     1100 	info_name = substr (line, 1, Iquote - 1);
     1101         else
     1102 	do;			/*   Doubled quotes must be undoubled in info name*/
     1103 	  info_name = "";
     1104 	  do while (Iquote = Iquote_quote);
     1105 	    info_name = info_name || substr (line, 1, Iquote);
     1106 	    Pline = addr (line_char (Iquote + length (QUOTE_QUOTE)));
     1107 	    Lline = Lline - (Iquote + length (QUOTE_QUOTE) - 1);
     1108 	    Iquote = index (line, QUOTE);
     1109 	    if Iquote = 0 | Iquote + 2 > Lline then
     1110 	      go to ERROR;
     1111 	    Iquote_quote = index (line, QUOTE_QUOTE);
     1112 	  end;
     1113 	  info_name = info_name || substr (line, 1, Iquote - 1);
     1114 	end;
     1115         Pline = addr (line_char (Iquote + length (QUOTE)));
     1116         Lline = Lline - (Iquote + length (QUOTE) - 1);
     1117         Inon_space = verify (line, HT_SP);
     1118 				/* Remove trailing white space.		*/
     1119         if Inon_space > 1 then
     1120 	do;
     1121 	  Pline = addr (line_char (Inon_space));
     1122 	  Lline = Lline - (Inon_space - 1);
     1123 	end;
     1124         else if Inon_space = 0 then
     1125 	go to ERROR;		/* No trailing colon.  Skip last name.		*/
     1126         if line_char (1) = ":" then	/* info name found in correct format.		*/
     1127 	Iline = length (Aline) - (Lline - 1);
     1128         else go to ERROR;		/* No trailing colon.  That's bad;		*/
     1129       end;
     1130     else
     1131       do;				/* Info name is not quoted.			*/
     1132         Icolon = index (line, ":");
     1133         if Icolon = 0 then
     1134 	go to ERROR;		/*   No trailing colon.			*/
     1135         info_name = rtrim (substr (line, 1, Icolon - 1));
     1136         Iline = length (Aline) - (Lline - Icolon);
     1137       end;
     1138     return (info_name);
     1139 
     1140   end find_info_name;
     1141 
  1     1 /* BEGIN INCLUDE FILE . . . star_structures.incl.pl1 */
  1     2 
  1     3 /* This include file contains structures for the hcs_$star_,
  1     4*   hcs_$star_list_ and hcs_$star_dir_list_ entry points.
  1     5*
  1     6*   Written 23 October 1978 by Monte Davidoff.
  1     7*   Modified January 1979 by Michael R. Jordan to use unsigned and different pointers for different structures.
  1     8*   Modified June 1981 by C. Hornig to count link pathnames more efficiently.
  1     9**/
  1    10 
  1    11 /* automatic */
  1    12 
  1    13 declare  star_branch_count fixed binary;		/* hcs_$star_list_, hcs_$star_dir_list_: matching branch count */
  1    14 declare  star_entry_count fixed binary;			/* hcs_$star_: number of matching entries */
  1    15 declare  star_entry_ptr pointer;			/* hcs_$star_: pointer to array of entry information */
  1    16 declare  star_list_branch_ptr pointer;			/* hcs_$star_list_, hcs_$star_dir_list_: ptr to array of info */
  1    17 declare  star_link_count fixed binary;			/* hcs_$star_list_, hcs_$star_dir_list_: matching link count */
  1    18 declare  star_linkx fixed binary;			/* hcs_$star_list_, hcs_$star_dir_list_: index into star_links */
  1    19 declare  star_names_ptr pointer;			/* hcs_$star_: pointer to array of entry names */
  1    20 declare  star_list_names_ptr pointer;			/* hcs_$star_list_, hcs_$star_dir_list_: ptr to entry names */
  1    21 declare  star_select_sw fixed binary (3);		/* hcs_$star_list_, hcs_$star_dir_list_: what info to return */
  1    22 
  1    23 /* based */
  1    24 
  1    25 /* hcs_$star_ entry structure */
  1    26 
  1    27 declare 1 star_entries (star_entry_count) aligned based (star_entry_ptr),
  1    28         2 type fixed binary (2) unsigned unaligned,
  1    29 						/* storage system type */
  1    30         2 nnames fixed binary (16) unsigned unaligned,
  1    31 						/* number of names of entry that match star_name */
  1    32         2 nindex fixed binary (18) unsigned unaligned;
  1    33 						/* index of first name in star_names */
  1    34 
  1    35 /* hcs_$star_ name structure */
  1    36 
  1    37 declare  star_names (sum (star_entries (*).nnames)) char (32) based (star_names_ptr);
  1    38 
  1    39 /* hcs_$star_list_ branch structure */
  1    40 
  1    41 declare 1 star_list_branch (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
  1    42         2 type fixed binary (2) unsigned unaligned,
  1    43 						/* storage system type */
  1    44         2 nnames fixed binary (16) unsigned unaligned,
  1    45 						/* number of names of entry that match star_name */
  1    46         2 nindex fixed binary (18) unsigned unaligned,
  1    47 						/* index of first name in star_list_names */
  1    48         2 dtcm bit (36) unaligned,			/* date-time contents of branch were last modified */
  1    49         2 dtu bit (36) unaligned,			/* date-time branch was last used */
  1    50         2 mode bit (5) unaligned,			/* user's access mode to the branch */
  1    51         2 raw_mode bit (5) unaligned,			/* user's ACL access mode */
  1    52         2 master_dir bit (1) unaligned,			/* is branch a master directory */
  1    53         2 pad bit (7) unaligned,
  1    54         2 records fixed binary (18) unsigned unaligned;
  1    55 						/* records used by branch */
  1    56 
  1    57 /* hcs_$star_dir_list_ branch structure */
  1    58 
  1    59 declare 1 star_dir_list_branch (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
  1    60         2 type fixed binary (2) unsigned unaligned,
  1    61 						/* storage system type */
  1    62         2 nnames fixed binary (16) unsigned unaligned,
  1    63 						/* number of names of entry that match star_name */
  1    64         2 nindex fixed binary (18) unsigned unaligned,
  1    65 						/* index of first name in star_list_names */
  1    66         2 dtem bit (36) unaligned,			/* date-time directory entry of branch was last modified */
  1    67         2 pad bit (36) unaligned,
  1    68         2 mode bit (5) unaligned,			/* user's access mode to the branch */
  1    69         2 raw_mode bit (5) unaligned,			/* user's ACL access mode */
  1    70         2 master_dir bit (1) unaligned,			/* is branch a master directory */
  1    71         2 bit_count fixed binary (24) unaligned;
  1    72 						/* bit count of the branch */
  1    73 
  1    74 /* hcs_$star_list_ and hcs_$star_dir_list_ link structure */
  1    75 
  1    76 declare 1 star_links (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
  1    77         2 type fixed binary (2) unsigned unaligned,
  1    78 						/* storage system type */
  1    79         2 nnames fixed binary (16) unsigned unaligned,
  1    80 						/* number of names of entry that match star_name */
  1    81         2 nindex fixed binary (18) unsigned unaligned,
  1    82 						/* index of first name in star_list_names */
  1    83         2 dtem bit (36) unaligned,			/* date-time link was last modified */
  1    84         2 dtd bit (36) unaligned,			/* date-time the link was last dumped */
  1    85         2 pathname_len fixed binary (18) unsigned unaligned,
  1    86 						/* length of the pathname of the link */
  1    87         2 pathname_index fixed binary (18) unsigned unaligned;
  1    88 						/* index of start of pathname in star_list_names */
  1    89 
  1    90 /* hcs_$star_list_ and hcs_$star_dir_list_ name array */
  1    91 
  1    92 declare  star_list_names char (32) based (star_list_names_ptr)
  1    93 	dimension (star_links (star_branch_count + star_link_count).nindex
  1    94 	 + star_links (star_branch_count + star_link_count).nnames
  1    95 	 + divide (star_links (star_branch_count + star_link_count).pathname_len + 31, 32, 17, 0)
  1    96 	   * binary (
  1    97 	     (star_links (star_branch_count + star_link_count).type = star_LINK)
  1    98 	     & (star_select_sw >= star_LINKS_ONLY_WITH_LINK_PATHS), 1));
  1    99 
  1   100 /* hcs_$star_list_ and hcs_$star_dir_list_ link pathname */
  1   101 
  1   102 declare  star_link_pathname char (star_links (star_linkx).pathname_len)
  1   103          based (addr (star_list_names (star_links (star_linkx).pathname_index)));
  1   104 
  1   105 /* internal static */
  1   106 
  1   107 /* star_select_sw values */
  1   108 
  1   109 declare  star_LINKS_ONLY fixed binary (2) internal static options (constant) initial (1);
  1   110 declare  star_BRANCHES_ONLY fixed binary (2) internal static options (constant) initial (2);
  1   111 declare  star_ALL_ENTRIES fixed binary (2) internal static options (constant) initial (3);
  1   112 declare  star_LINKS_ONLY_WITH_LINK_PATHS
  1   113          fixed binary (3) internal static options (constant) initial (5);
  1   114 declare  star_ALL_ENTRIES_WITH_LINK_PATHS
  1   115          fixed binary (3) internal static options (constant) initial (7);
  1   116 
  1   117 /* storage system types */
  1   118 
  1   119 declare  star_LINK fixed binary (2) unsigned internal static options (constant) initial (0);
  1   120 declare  star_SEGMENT fixed binary (2) unsigned internal static options (constant) initial (1);
  1   121 declare  star_DIRECTORY fixed binary (2) unsigned internal static options (constant) initial (2);
  1   122 
  1   123 /* END INCLUDE FILE . . . star_structures.incl.pl1 */
     1142 
     1143 
  2     1 /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
  2     2 
  2     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
  2     4 
  2     5 /* This include file contains branch and link structures returned by
  2     6*   hcs_$status_ and hcs_$status_long. */
  2     7 
  2     8 dcl 1 status_branch aligned based (status_ptr),
  2     9     2 short aligned,
  2    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
  2    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
  2    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
  2    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
  2    14       3 dtu bit (36) unaligned,			/* date/time last used */
  2    15       3 mode bit (5) unaligned,			/* caller's effective access */
  2    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
  2    17       3 pad1 bit (8) unaligned,
  2    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
  2    19 
  2    20 /* Limit of information returned by hcs_$status_ */
  2    21 
  2    22     2 long aligned,
  2    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
  2    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
  2    25       3 lvid bit (36) unaligned,			/* logical volume ID */
  2    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
  2    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
  2    28       3 pad2 bit (8) unaligned,
  2    29       3 copy_switch bit (1) unaligned,			/* copy switch */
  2    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
  2    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
  2    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
  2    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
  2    34       3 pad3 bit (5) unaligned,
  2    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
  2    36       3 uid bit (36) unaligned;			/* unique ID */
  2    37 
  2    38 dcl 1 status_link aligned based (status_ptr),
  2    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
  2    40     2 nnames fixed bin (16) unaligned unsigned,
  2    41     2 names_relp bit (18) unaligned,
  2    42     2 dtem bit (36) unaligned,
  2    43     2 dtd bit (36) unaligned,
  2    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
  2    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
  2    46 
  2    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
  2    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
  2    49 						/* array of names returned */
  2    50      status_pathname character (status_link.pathname_length) aligned
  2    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
  2    52 						/* link target path */
  2    53      status_area_ptr pointer,
  2    54      status_ptr pointer;
  2    55 
  2    56 dcl (Link initial (0),
  2    57      Segment initial (1),
  2    58      Directory initial (2)) fixed bin internal static options (constant);
  2    59 						/* values for type fields declared above */
  2    60 
  2    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
     1144 
     1145 
     1146     dcl 1 branch	   aligned like status_branch;
     1147 
     1148   end get_info_seg_list;
     1149 
     1150 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1151 
     1152 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1153 
     1154 
     1155 initiate:
     1156   procedure (dir, ent, uid, Pseg, code);/* Provide an associative memory for info segs	*/
     1157 				/* to reduce amt. of double initiating each seg.	*/
     1158 
     1159     dcl dir	   char (168) unal,
     1160         ent	   char (32) unal,
     1161         uid	   bit (36) aligned,
     1162         Pseg	   ptr,
     1163         code	   fixed bin (35);
     1164 
     1165     dcl i		   fixed bin;
     1166     dcl Iempty	   fixed bin;
     1167 
     1168     Iempty = 0;			/* No empty slots in assoc. mem so far.		*/
     1169     code = 0;
     1170     Pseg = null;
     1171     do i = 1 to init_assoc_mem.N while (Pseg = null);
     1172 				/* Look for seg to be initiated in assoc. mem.	*/
     1173       if init_assoc_mem.seg (i).uid ^= "0"b then
     1174         do;			/*   Zero uid?  No, we must check the cell.	*/
     1175 	if uid ^= "0"b then		/*   Can't check if we don't know segs uid.	*/
     1176 	  if uid = init_assoc_mem.seg (i).uid then
     1177 	    Pseg = init_assoc_mem.seg (i).P;
     1178 				/*   Found seg in assoc mem. Got off cheap!	*/
     1179 	  else ;
     1180 	else if dir = init_assoc_mem.seg (i).dir & ent = init_assoc_mem.seg (i).ent then
     1181 	  do;			/*   Check segs dir/ent with assoc mem.		*/
     1182 	    uid = init_assoc_mem.seg (i).uid;
     1183 	    Pseg = init_assoc_mem.seg (i).P;
     1184 	  end;
     1185         end;
     1186       else if Iempty = 0 then		/* Remember first empty cell in  case seg not	*/
     1187         Iempty = i;			/* found in assoc. mem.			*/
     1188     end;
     1189     if Pseg ^= null then
     1190       return;			/* See found in assoc. All done!		*/
     1191 
     1192     call hcs_$initiate (dir, ent, "", 0, 0, Pseg, code);
     1193     if Pseg = null then
     1194       return;			/* Have to initiate the segment.		*/
     1195     call hcs_$get_uid_seg (Pseg, uid, code);
     1196 				/* Complain if error.  Otherwise, get seg's uid.	*/
     1197     do i = 1 to init_assoc_mem.N while (init_assoc_mem.seg (i).uid ^= uid);
     1198     end;				/* make sure uid doesn't appear in assoc memory	*/
     1199     if i <= init_assoc_mem.N then
     1200       return;			/* under another name.  If so, don't add again.	*/
     1201     if Iempty = 0 then		/* If no empty cells, must make one.		*/
     1202       if init_assoc_mem.N < dimension (init_assoc_mem.seg, 1) then
     1203         do;
     1204 	init_assoc_mem.N = init_assoc_mem.N + 1;
     1205 	Iempty = init_assoc_mem.N;	/* Add new cell to the table, if room.		*/
     1206         end;
     1207       else
     1208         do;			/* Must terminate cell member to make room for new*/
     1209 	Iempty = init_assoc_mem.N;	/* seg in assoc. mem.			*/
     1210 	call hcs_$terminate_noname (init_assoc_mem.seg (Iempty).P, code);
     1211         end;
     1212     init_assoc_mem.seg (Iempty).dir = dir;
     1213     init_assoc_mem.seg (Iempty).ent = ent;
     1214     init_assoc_mem.seg (Iempty).uid = uid;
     1215     init_assoc_mem.seg (Iempty).P = Pseg;
     1216 
     1217   end initiate;
     1218 
     1219 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1220 
     1221 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1222 
     1223 
     1224 janitor:
     1225   procedure;			/* terminate known info segs;  truncate temp seg.	*/
     1226 
     1227     call term_assoc_mem ();
     1228     call hcs_$truncate_seg (Phelp_args, currentsize (help_args), 0);
     1229 
     1230     if Sstandalone_invocation then
     1231       if help_args.sci_ptr ^= null then
     1232         do;
     1233 	call ssu_$destroy_invocation (help_args.sci_ptr);
     1234 	help_args.sci_ptr = null;
     1235         end;
     1236 
     1237     if Pquery_answers ^= null then
     1238       call release_temp_segment_ (procedure_name, Pquery_answers, code);
     1239 
     1240   end janitor;
     1241 
     1242 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1243 
     1244 
     1245 numeric_date:
     1246   procedure (bit_date) returns (fixed bin (71));
     1247 				/* This procedure converts a file system date	*/
     1248 				/* to a numeric clock value.  A file system date	*/
     1249 				/* is the high-order 36 bits of a 52 bit clock	*/
     1250 				/* value.					*/
     1251 
     1252     dcl bit_date	   bit (36) unal,
     1253         num_date	   fixed bin (71);
     1254 
     1255 
     1256     num_date = 0;
     1257     substr (unspec (num_date), 21, 36) = bit_date;
     1258     return (num_date);
     1259 
     1260   end numeric_date;
     1261 
     1262 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1263 
     1264 
     1265 rel_char:
     1266   proc (P) returns (fixed bin (21));	/* This procedure converts a pointer value into	*/
     1267 				/* a character offset from base of segment	*/
     1268 				/* pointed to.  We need a PL/I bif to do this.	*/
     1269     dcl P		   ptr;
     1270 
     1271     dcl I		   fixed bin (21),
     1272         P1	   ptr,
     1273         i		   fixed bin;
     1274 
     1275     dcl char_offset	   (0:3) char (1) based (P1);
     1276 
     1277     P1 = ptr (P, rel (P));
     1278     I = 4 * binary (rel (P));
     1279     do i = 0 to 3 while (addr (char_offset (i)) ^= P);
     1280     end;
     1281     I = I + i;
     1282     return (I);
     1283 
     1284   end rel_char;
     1285 
     1286 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1287 
     1288 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1289 
     1290 
     1291 set_space_used:
     1292   procedure (Pcurrent_space, size_current_space) returns (ptr);
     1293 				/* This procedure returns pointer to next free	*/
     1294 				/* word of storage in help_args temp segment.	*/
     1295     dcl Pcurrent_space ptr,		/* ptr to last space allocated in the seg.	*/
     1296         size_current_space
     1297 		   fixed bin (21),	/* amount of space used in structure last alloc.	*/
     1298         Pnext_space	   ptr;		/* ptr to next free space.			*/
     1299 
     1300     Pnext_space = addrel (Pcurrent_space, size_current_space + mod (size_current_space, 2));
     1301     return (Pnext_space);
     1302 
     1303   end set_space_used;
     1304 
     1305 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1306 
     1307 
     1308 term_assoc_mem:
     1309   procedure;			/* terminate known info segs.			*/
     1310 
     1311     do init_assoc_mem.N = init_assoc_mem.N to 1 by -1;
     1312       if init_assoc_mem.seg (init_assoc_mem.N).uid ^= "0"b then
     1313         call hcs_$terminate_noname (init_assoc_mem.seg (init_assoc_mem.N).P, 0);
     1314     end;
     1315   end term_assoc_mem;
     1316 
     1317 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1318 
     1319 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1320 
     1321 
     1322 init:
     1323   entry (procedure_name, search_list_name, search_list_ref_dir, Vrequired, Phelp_args, Acode);
     1324 
     1325     dcl search_list_name
     1326 		   char (*),	/* Name of search list used in finding infos.	*/
     1327 				/*   (input)				*/
     1328         search_list_ref_dir
     1329 		   char (*),	/* Referencing dir used in  search rules.	*/
     1330 				/*   (input)				*/
     1331         Vrequired	   fixed bin;	/* Required version of help_args structure.	*/
     1332 				/*   (input)				*/
     1333 
     1334     dcl Parea	   ptr,
     1335         area	   area (25000) based (Parea);
     1336 
     1337     if Vrequired ^= Vhelp_args_3 & Vrequired ^= 2 & Vrequired ^= 1 then
     1338       do;
     1339         Acode = error_table_$unimplemented_version;
     1340         return;
     1341       end;
     1342     call get_temp_segment_ (procedure_name, Phelp_args, Acode);
     1343     if Acode ^= 0 then		/* Obtain a temporary segment.		*/
     1344       Phelp_args = null;
     1345     else
     1346       do;
     1347         help_args.version = Vrequired;	/* Initialize the help argument structure.	*/
     1348         help_args.help_data_ptr = null;
     1349         help_args.sci_ptr = null;
     1350         string (help_args.Sctl) = "0"b;
     1351         help_args.min_Lpgh = 4;
     1352         help_args.max_Lpgh = 15;
     1353         help_args.Lspace_between_infos = 2;
     1354         help_args.min_date_time = -1;
     1355         help_args.Npaths = 0;
     1356         help_args.Ncas = 0;
     1357         help_args.Nsrhs = 0;
     1358         if search_list_name ^= "" then
     1359 	do;
     1360 	  help_args.Nsearch_dirs = 1000;
     1361 				/* Allow room for up to 1000 search dirs.	*/
     1362 	  Parea = set_space_used (Phelp_args, currentsize (help_args));
     1363 	  area = empty ();
     1364 	  call search_paths_$get (search_list_name, sl_control_default, search_list_ref_dir, null, Parea, sl_info_version_1,
     1365 	       sl_info_p, Acode);
     1366 	  if Acode = 0 then
     1367 	    do;
     1368 	      help_args.Nsearch_dirs = sl_info.num_paths;
     1369 	      if help_args.Nsearch_dirs > 0 then
     1370 	        help_args.search_dirs (*) = sl_info.paths (*).pathname;
     1371 	    end;
     1372 	  else help_args.Nsearch_dirs = 0;
     1373 	end;
     1374         else help_args.Nsearch_dirs = 0;
     1375         call hcs_$truncate_seg (Phelp_args, currentsize (help_args), 0);
     1376       end;
     1377     return;
     1378 
     1379 
  3     1 /* BEGIN INCLUDE FILE . . . sl_info.incl.pl1 */
  3     2 
  3     3      
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(87-11-16,Lippard), approve(87-12-21,MCR7822),
  3     7*     audit(88-02-09,Blair), install(88-02-16,MR12.2-1023):
  3     8*     Modified to add INITIATED_SEGS type.
  3     9*  2) change(87-11-19,Lippard), approve(87-12-21,MCR7822),
  3    10*     audit(88-02-09,Blair), install(88-02-16,MR12.2-1023):
  3    11*     Added uid to sl_info structure.
  3    12*                                                   END HISTORY COMMENTS */
  3    13 
  3    14 
  3    15 declare 1 sl_info	      aligned based (sl_info_p),
  3    16 	     2 version	      fixed binary,		/* Must be 1 */
  3    17 	     2 num_paths	      fixed binary,		/* Number of search paths */
  3    18 	     2 change_index_p     pointer,		/* Pointer to search list's update count */
  3    19 	     2 change_index	      fixed binary (71),	/* This search list's update count */
  3    20 	     2 pad1	      (6) bit (36),		/* Must be zero */
  3    21 	     2 paths	      (sl_info_num_paths refer (sl_info.num_paths)),
  3    22 	       3 type	      fixed binary,		/* Type of search path */
  3    23 	       3 code	      fixed binary (35),	/* Standard status code of search path */
  3    24 	       3 uid	      bit (36),		/* Unique ID */
  3    25 	       3 pathname	      char (168) unaligned;	/* Search pathname */
  3    26 
  3    27      declare sl_info_num_paths      fixed binary;
  3    28      declare sl_info_p	      pointer;
  3    29      declare sl_info_version_1      fixed binary internal static options (constant) initial (1);
  3    30 
  3    31 /* Keyword Types */
  3    32 
  3    33      declare ABSOLUTE_PATH	      fixed binary internal static options (constant) initial (0);
  3    34      declare UNEXPANDED_PATH	      fixed binary internal static options (constant) initial (1);
  3    35      declare REFERENCING_DIR	      fixed binary internal static options (constant) initial (3);
  3    36      declare WORKING_DIR	      fixed binary internal static options (constant) initial (4);
  3    37      declare PROCESS_DIR	      fixed binary internal static options (constant) initial (5);
  3    38      declare HOME_DIR	      fixed binary internal static options (constant) initial (6);
  3    39      declare INITIATED_SEGS	      fixed binary internal static options (constant) initial (7);
  3    40 
  3    41 /* END INCLUDE FILE . . . sl_info.incl.pl1 */
     1380 
     1381 
  4     1 /* BEGIN INCLUDE FILE . . . sl_control_s.incl.pl1 */
  4     2 
  4     3      declare 1 sl_control_s	      unaligned based (addr (sl_control)),
  4     4 	     2 af_pathname	      bit (1),		/* "1"b => expand active functions */
  4     5 	     2 pad1	      bit (1),		/* Must be zero */
  4     6 	     2 key_ref_dir	      bit (1),		/* "1"b => expand -referencing_dir keyword */
  4     7 	     2 key_work_dir	      bit (1),		/* "1"b => expand -working_dir keyword */
  4     8 	     2 key_proc_dir	      bit (1),		/* "1"b => expand -process_dir keyword */
  4     9 	     2 key_home_dir	      bit (1),		/* "1"b => expand -home_dir keyword */
  4    10 	     2 pad2	      bit (30);		/* Must be zero */
  4    11 
  4    12      declare sl_control	      bit (36);
  4    13      declare sl_control_default     bit (36) internal static options (constant) initial ("101111"b);
  4    14 
  4    15 /* END INCLUDE FILE . . . sl_control_s.incl.pl1 */
     1382 
     1383 
     1384 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1385 
     1386 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1387 
     1388 
     1389 term:
     1390   entry (procedure_name, Phelp_args, Acode);
     1391 
     1392     if Phelp_args ^= null then
     1393       do;
     1394         if unspec(help_args.help_data_ptr) = ""b then;	/* check for case where interruption	  */
     1395 						/*  occurred before help_$init could	  */
     1396 						/*  complete its initialization of	  */
     1397 						/*  the help_args structure.  Otherwise,  */
     1398 						/*  the reference to help_data_ptr could  */
     1399 						/*  cause a seg_fault referencing dseg	  */
     1400 						/*  (segment 0|0).			  */
     1401         else if help_args.help_data_ptr ^= null then
     1402            call help_$term (procedure_name, help_args.help_data_ptr, Acode);
     1403         call release_temp_segment_ (procedure_name, Phelp_args, Acode);
     1404       end;
     1405     
     1406     return;
     1407 
     1408 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
     1409 
  5     1 /* BEGIN INCLUDE FILE ... arg_list.incl.pl1
  5     2*
  5     3*   James R. Davis 10 May 79 */
  5     4 
  5     5 
  5     6      
  5     7 /****^  HISTORY COMMENTS:
  5     8*  1) change(86-05-15,DGHowe), approve(86-05-15,MCR7375),
  5     9*     audit(86-07-15,Schroth):
  5    10*     added command_name_arglist declaration to allow the storage of the
  5    11*     command name given to the command processor
  5    12*                                                   END HISTORY COMMENTS */
  5    13 
  5    14      dcl	   1 arg_list	      aligned based,
  5    15 	     2 header,
  5    16 	       3 arg_count	      fixed bin (17) unsigned unal,
  5    17 	       3 pad1	      bit (1) unal,
  5    18 	       3 call_type	      fixed bin (18) unsigned unal,
  5    19 	       3 desc_count	      fixed bin (17) unsigned unal,
  5    20 	       3 pad2	      bit (19) unal,
  5    21 	     2 arg_ptrs	      (arg_list_arg_count refer (arg_list.arg_count)) ptr,
  5    22 	     2 desc_ptrs	      (arg_list_arg_count refer (arg_list.arg_count)) ptr;
  5    23 
  5    24 
  5    25      dcl	   1 command_name_arglist	      aligned based,
  5    26 	     2 header,
  5    27 	       3 arg_count	      fixed bin (17) unsigned unal,
  5    28 	       3 pad1	      bit (1) unal,
  5    29 	       3 call_type	      fixed bin (18) unsigned unal,
  5    30 	       3 desc_count	      fixed bin (17) unsigned unal,
  5    31 	       3 mbz              bit(1) unal,
  5    32                  3 has_command_name bit(1) unal,
  5    33 	       3 pad2	      bit (17) unal,
  5    34 	     2 arg_ptrs	      (arg_list_arg_count refer (command_name_arglist.arg_count)) ptr,
  5    35 	     2 desc_ptrs	      (arg_list_arg_count refer (command_name_arglist.arg_count)) ptr,
  5    36 	     2 name,
  5    37                  3 command_name_ptr         pointer,
  5    38                  3 command_name_length      fixed bin (21);
  5    39 	
  5    40 
  5    41 
  5    42      dcl	   1 arg_list_with_envptr aligned based,	/* used with non-quick int and entry-var calls */
  5    43 	     2 header,
  5    44 	       3 arg_count	      fixed bin (17) unsigned unal,
  5    45 	       3 pad1	      bit (1) unal,
  5    46 	       3 call_type	      fixed bin (18) unsigned unal,
  5    47 	       3 desc_count	      fixed bin (17) unsigned unal,
  5    48 	       3 pad2	      bit (19) unal,
  5    49 	     2 arg_ptrs	      (arg_list_arg_count refer (arg_list_with_envptr.arg_count)) ptr,
  5    50 	     2 envptr	      ptr,
  5    51 	     2 desc_ptrs	      (arg_list_arg_count refer (arg_list_with_envptr.arg_count)) ptr;
  5    52 
  5    53 
  5    54      dcl	   (
  5    55 	   Quick_call_type	      init (0),
  5    56 	   Interseg_call_type     init (4),
  5    57 	   Envptr_supplied_call_type
  5    58 			      init (8)
  5    59 	   )		      fixed bin (18) unsigned unal int static options (constant);
  5    60 
  5    61 /* The user must declare arg_list_arg_count - if an adjustable automatic structure
  5    62*   is being "liked" then arg_list_arg_count may be a parameter, in order to allocate
  5    63*   an argument list of the proper size in the user's stack
  5    64*
  5    65**/
  5    66 /* END INCLUDE FILE ... arg_list.incl.pl1 */
     1410 
     1411 
  6     1 /*  BEGIN:   help_args_.incl.pl1			  *  *  *  *  *  */
  6     2 
  6     3 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6     4 /*									*/
  6     5 /* Name:   help_args_.incl.pl1						*/
  6     6 /*									*/
  6     7 /* This include file declares the structure used by the help command and other subsystems	*/
  6     8 /* to pass info segment selection and printing control information to the help_		*/
  6     9 /* subroutine.  This based structure is NEVER allocated.  Instead, the caller of help_	*/
  6    10 /* must call help_$init to get a pointer to a temporary segment which is used for	*/
  6    11 /* storage for the structure.  The structure contains 5 arrays with refer extents,	*/
  6    12 /* allowing complete freedom in the numbers of selection values given.  Typically, the	*/
  6    13 /* caller fills in the arrays at the top of the structure first, growing the arrays	*/
  6    14 /* as each new element is added.  After each array is filled, the caller begins filling	*/
  6    15 /* in the next array.  Note that, on return from help_$init, all of the arrays have 0	*/
  6    16 /* extents, except that the search_dirs array contains the list of directories to be	*/
  6    17 /* searched in to find info segments, as defined by the search facility.  The caller	*/
  6    18 /* may of course change or replace these search directories.			*/
  6    19 /*									*/
  6    20 /* A legend describing the variable naming convention follows.			*/
  6    21 /*									*/
  6    22 /*   STARTING LETTER	STANDS FOR					*/
  6    23 /*	P		pointer to					*/
  6    24 /*	L		length of						*/
  6    25 /*	D		descriptor of					*/
  6    26 /*	S		switch						*/
  6    27 /*	V		version						*/
  6    28 /*									*/
  6    29 /* Status									*/
  6    30 /*									*/
  6    31 /* 0) Created:   October, 1978    by Gary Dixon					*/
  6    32 /* 1) Modified:  June 4, 1983	    by Gary Dixon - add Sctl.inhibit_errors flag.		*/
  6    33 /* 2) Modified:  April, 1985      by L.Adams - use Vhelp_args_2.			*/
  6    34 /*									*/
  6    35 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    36 
  6    37 /****^  HISTORY COMMENTS:
  6    38*  1) change(86-03-07,LJAdams), approve(86-03-07,MCR7327),
  6    39*     audit(86-03-10,Lippard), install(86-04-24,MR12.0-1048):
  6    40*     Declares structure used by the help command and other subsystems to pass
  6    41*     info segment selection and printing control information the help_
  6    42*     subroutine.
  6    43*  2) change(87-01-26,LJAdams), approve(87-09-03,MCR7766),
  6    44*     audit(88-05-03,GDixon), install(88-09-13,MR12.2-1109):
  6    45*     Added lep to Sctl.
  6    46*     Added Sctl.cs to indicate if search or section requests are to be case
  6    47*     sensitive or not.
  6    48*     Changed version to Vhelp_args_3.
  6    49*  3) change(88-02-12,LJAdams), approve(88-03-07,MCR7857),
  6    50*     audit(88-05-03,GDixon), install(88-09-13,MR12.2-1109):
  6    51*     Added help_data_ptr to point to a second help_args structure that will be
  6    52*     used for list_requests.
  6    53*                                                   END HISTORY COMMENTS */
  6    54 
  6    55      dcl	1 help_args aligned based (Phelp_args),		/* help's input arguments.			*/
  6    56 	  2 version		fixed bin,	/* = 3, currently. Use Vhelp_args_3.		*/
  6    57 						/*	(set by help_$init, checked by caller)	*/
  6    58 	  2 Sctl,					/* control argument switches.			*/
  6    59 						/*	(SET BY CALLER OF help_)		*/
  6    60 	   (3 he_only,				/*   print only a heading, nothing else.	*/
  6    61 	    3 he_pn,				/*   when heading printed, include info pathname.	*/
  6    62 	    3 he_info_name,				/*   when heading printed, include info_name.	*/
  6    63 	    3 he_counts,				/*   when heading printed, include line counts.	*/
  6    64 						/*   If none of the 3 switches above are set,	*/
  6    65 						/*   then only info header is incl. in heading.	*/
  6    66 	    3 title,				/*   -title				*/
  6    67 	    3 scn,				/*   -section				*/
  6    68 	    3 srh,				/*   -search				*/
  6    69 	    3 bf,					/*   -brief				*/
  6    70 	    3 ca,					/*   -control_arg				*/
  6    71 	    3 ep,					/*   -entry_point				*/
  6    72 	    3 all,				/*   -all					*/
  6    73               3 lep,				/*   -lep 				*/
  6    74               3 cs,                                         /*   -case_sensitive                              */
  6    75 	    3 inhibit_errors)			/*   inhibits error diagnostics when desired	*/
  6    76 						/*     information is not found.  Useful for	*/
  6    77 						/*     subsystems like ted that want to diagnose	*/
  6    78 						/*     their own errors.			*/
  6    79 				bit(1) unal,
  6    80 	    3 mbz1		bit(22) unal,
  6    81 	  2 Nsearch_dirs		fixed bin,	/* number of info_segment (or other) search dirs.	*/
  6    82 						/*	(set by help_$init, CALLER CAN CHANGE)	*/
  6    83 	  2 Npaths		fixed bin,	/* number of info segment names.		*/
  6    84 						/*	(SET BY CALLER OF help_)		*/
  6    85 	  2 Ncas			fixed bin,	/* number of control arg names given with -ca	*/
  6    86 						/*	(SET BY CALLER OF help_)		*/
  6    87 	  2 Nscns			fixed bin,	/* number of section substrings.		*/
  6    88 						/*	(SET BY CALLER OF help_)		*/
  6    89 	  2 Nsrhs			fixed bin,	/* number of search strings.			*/
  6    90 						/*	(SET BY CALLER OF help_)		*/
  6    91 	  2 min_Lpgh		fixed bin,	/* minimum length of a paragraph.		*/
  6    92 						/*	(set by help_$init, CALLER CAN CHANGE)	*/
  6    93 	  2 max_Lpgh		fixed bin,	/* maximum lines in group of aggregated paragraphs*/
  6    94 						/* or in paragraphs constructed by help_.	*/
  6    95 						/*	(set by help_$init, CALLER CAN CHANGE)	*/
  6    96 	  2 Lspace_between_infos	fixed bin,	/* spaces inserted between infos when several	*/
  6    97 						/* printed by one invocation.			*/
  6    98 						/*	(set by help_$init, CALLER CAN CHANGE)	*/
  6    99 	  2 min_date_time		fixed bin(71),	/* do not process infos modified before this date.*/
  6   100 						/*	(SET BY CALLER OF help_)		*/
  6   101 	  2 sci_ptr		ptr,		/* sci_ptr when help_ is invoked by a subsystem.	*/
  6   102 						/*   This must be set to null when not invoked 	*/
  6   103 						/*   from a subsystem.			*/
  6   104             2 help_data_ptr             ptr,                /* ptr to second help_args (used for list rqts)   */
  6   105 	  2 pad2 (6) 		fixed bin,	/* reserved for future expansion.		*/
  6   106 
  6   107 	/*		End of fixed-length part of the structure.				*/
  6   108 
  6   109 	  2 search_dirs (0 refer (help_args.Nsearch_dirs))
  6   110 				char (168) unal,	/* directories help_ will look in to find info	*/
  6   111 						/*   segments when relative paths (without < or >)*/
  6   112 						/*   are given.  When help_$init is called, the	*/
  6   113 						/*   current search rules (from a search list of	*/
  6   114 						/*   caller's choice) will be given here.  Caller	*/
  6   115 						/*   may modify this list if desired before	*/
  6   116 						/*   calling help_.				*/
  6   117 	  2 path (0 refer (help_args.Npaths)),		/* names of sought info segments.		*/
  6   118 	    3 value		char(425) varying,	/*   These are the args themselves, without	*/
  6   119 	    					/*   processing by expand_pathname_, etc.	*/
  6   120 						/*   Their length is length(path) + length("$")	*/
  6   121 						/*   + length(entry_point_name).		*/
  6   122 						/*   Note that entry_point_names can be 256 chars.*/
  6   123 						/*	(SET BY CALLER OF help_)		*/
  6   124 	    3 info_name		char(32) unal,	/*   name of logical info to be printed.	*/
  6   125 						/*	(SET BY CALLER OF help_)		*/
  6   126 						/*   "" = help_ should set this to entry part	*/
  6   127 						/*        of path.value, minus the suffix.	*/
  6   128 						/*   other = logical info name not a name on the	*/
  6   129 						/* 	   physical info segment.		*/
  6   130 	    3 dir (1)		char(168) unal,	/*   dir part of a pathname (set by help_).	*/
  6   131 	    3 ent			char(32) unal,	/*   ent part of name (set by help_).		*/
  6   132 	    3 ep			char(32) varying,	/*   entry point part of name. (set by help_)	*/
  6   133 	    3 code		fixed bin(35),	/*   error code while processing this path.	*/
  6   134 						/*     (set by help_)			*/
  6   135 	    3 S,					/*   switches indicating path type.		*/
  6   136 	     (4 pn_ctl_arg,				/*     -pn ctl given before this path. 		*/
  6   137 						/*     	(SET BY CALLER OF help_)		*/
  6   138 	      4 info_name_not_starname,		/*     caller-supplied path.info_name is not a	*/
  6   139 						/*       star name, even if it has * or ? chars.	*/
  6   140 						/*     	(SET BY CALLER OF help_)		*/
  6   141 	      4 less_greater,			/*     A < or > appears in path.value.		*/
  6   142 						/*     	(set by help_)			*/
  6   143 	      4 starname_ent,			/*     on if ent is a starname.		*/
  6   144 						/*	(set by help_)			*/
  6   145 	      4 starname_info_name,			/*     on if info_name is a starname.		*/
  6   146 						/*	(set by help_)			*/
  6   147 	      4 separate_info_name) 	bit(1) unal,	/*     on if info_name given by caller.		*/
  6   148 						/*	(set by help_)			*/
  6   149 	      4 pad3	 	bit(30) unal,
  6   150 	  2 ca (0 refer (help_args.Ncas))		/* the ctl_arg names, without leading - just as	*/
  6   151 				char(32) varying,	/*   req'd by the -ca ctl_arg of help.		*/
  6   152 						/*	(SET BY CALLER OF help_)		*/
  6   153 	  2 scn (0 refer (help_args.Nscns))		/* substrings sought in section titles.		*/
  6   154 				char(80) varying,	/*	(SET BY CALLER OF help_)		*/
  6   155 	  2 srh (0 refer (help_args.Nsrhs))		/* search strings.				*/
  6   156 				char(80) varying,	/*	(SET BY CALLER OF help_)		*/
  6   157 	Phelp_args		ptr,
  6   158 	Vhelp_args_3		fixed bin int static options(constant) init(3);
  6   159 
  6   160      dcl	help_			entry (char(*), ptr, char(*), fixed bin, fixed bin(35)),
  6   161 	help_$init		entry (char(*), char(*), char(*), fixed bin, ptr, fixed bin(35)),
  6   162 	help_$term		entry (char(*), ptr, fixed bin(35));
  6   163 
  6   164 /*  END OF:  help_args_.incl.pl1			  *  *  *  *  *  */
     1412 
     1413 
  7     1 /*	BEGIN OF:	help_cis_args_.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  7     2 
  7     3 	
  7     4 
  7     5 /****^  HISTORY COMMENTS:
  7     6*  1) change(86-03-07,LJAdams), approve(86-03-07,MCR7327),
  7     7*     audit(86-03-10,Lippard), install(86-04-24,MR12.0-1048):
  7     8*     Changed segment type from bit(2) to fixed bin(2) uns.
  7     9*  2) change(86-05-12,LJAdams), approve(86-05-14,MCR7416),
  7    10*     audit(86-05-19,Gilcrease), install(86-06-12,MR12.0-1074):
  7    11*     Added E as an unique identifier for entry_point name to be used during
  7    12*     sorting.
  7    13*  3) change(87-02-18,LJAdams), approve(87-09-03,MCR7766),
  7    14*     audit(88-05-03,GDixon), install(88-09-13,MR12.2-1109):
  7    15*     Added X as a sort identifier to be used when sorting via sort_items_$char
  7    16*     as the original order of the records is not maintained when sorting equal
  7    17*     items.
  7    18*  4) change(88-03-14,LJAdams), approve(88-06-01,MCR7873),
  7    19*     audit(88-05-03,GDixon), install(88-09-13,MR12.2-1109):
  7    20*     Changed order of fields being sorted and added a pad field to maintain
  7    21*     alignment.
  7    22*                                                   END HISTORY COMMENTS */
  7    23 
  7    24 
  7    25 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    26 	/*									*/
  7    27 	/* Name:	help_cis_args_.incl.pl1						*/
  7    28 	/*									*/
  7    29 	/* This include file declares the structures returned by help_$check_info_segs for use	*/
  7    30 	/* in the check_info_segs command.  The structures contain information about the	*/
  7    31 	/* segments which check_info_segs will process.  The structures are allocated in the temp	*/
  7    32 	/* segment obtained in the call to help_$init.  They SHOULD NOT BE FREED.  Instead, the	*/
  7    33 	/* help_$term entry should be called to release the entire temporary segment.		*/
  7    34 	/*									*/
  7    35 	/* Status									*/
  7    36 	/*									*/
  7    37 	/* 0) Created:   October, 1978	by Gary Dixon				*/
  7    38 	/*									*/
  7    39 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    40 
  7    41      dcl	1 Dinfo_seg		aligned based,	/* Information  about one info segment.		*/
  7    42 						/* NOTE: code depends upon Scross_ref, dir and ent*/
  7    43 						/*   1st, 2nd & 3rd elements of item substruc.	*/
  7    44 	    3 Scross_ref		bit(36) aligned,	/*   bit 1 on if same info appears in diff. dirs.	*/
  7    45 	    3 dir			char(168) unal,	/*   dir part of its pathname.		*/
  7    46 	    3 ent			char(32) unal,	/*   ent part of its pathname.		*/
  7    47 	    3 info_name		char(32) unal,	/*   info_name used to find info, if different	*/
  7    48 						/*     from ent (without suffix).		*/
  7    49 	    3 ep			char(32) var,	/*   entry point name requested in command line.	*/
  7    50 	    3 uid			bit(36),		/*   unique ID of containing segment.		*/
  7    51 	    3 I			fixed bin(35),
  7    52                                                   	/*   index of 1st character of the info.	*/
  7    53 	    3 E                       char(32),		/*   ep name to be used for sorting		*/
  7    54               3 X                       fixed bin(35),
  7    55                                                             /*   index of original record order		*/
  7    56               3 pad2                    fixed bin(35),
  7    57 	    3 L			fixed bin,	/*   length, in chars.			*/
  7    58 	    3 date		fixed bin(71),	/*   date_time_entry_modified of info segment.	*/
  7    59 	   (3 segment_type		fixed bin(2) uns,	/*   00 - link, 01 - segment			*/
  7    60 	    3 mode		bit(3),		/*   access mode.				*/
  7    61 	    3 pad1		bit(31)) unal,
  7    62 	    3 code		fixed bin(35),	/*   error code encounter in processing seg.	*/
  7    63 	1 PDinfo_seg		aligned based(PPDinfo_seg),
  7    64 	  2 version		fixed bin,	/* Version of this return structure (= 2).	*/
  7    65 	  2 N			fixed bin(24),	/* Count of info segments data returned for.	*/
  7    66 	  2 P (0 refer (PDinfo_seg.N))		/* Pointers to Dinfo_seg structure for each info.	*/
  7    67 				ptr unal,
  7    68 	PPDinfo_seg		ptr,
  7    69 	VPDinfo_seg_2		fixed bin int static options(constant) init(2);
  7    70 
  7    71      dcl	help_$check_info_segs	entry (char(*), ptr, char(*), fixed bin, fixed bin(35), ptr);
  7    72 
  7    73 /*	END OF:	help_cis_args_.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1414 
     1415 
     1416     dcl 1 Dinfo_seg_   aligned like Dinfo_seg based (PDinfo_seg_),
     1417         PDinfo_seg_	   ptr;
     1418 
     1419   end help_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    09/13/88  1306.3  help_.pl1                         >spec>install>MR12.2-1109>help_.pl1
1142         1    06/10/82  1045.5  star_structures.incl.pl1          >ldd>include>star_structures.incl.pl1
1144         2    11/22/82  0955.7  status_structures.incl.pl1        >ldd>include>status_structures.incl.pl1
1380         3    02/18/88  2023.8  sl_info.incl.pl1                  >ldd>include>sl_info.incl.pl1
1382         4    01/09/79  1617.9  sl_control_s.incl.pl1             >ldd>include>sl_control_s.incl.pl1
1410         5    08/05/86  0856.8  arg_list.incl.pl1                 >ldd>include>arg_list.incl.pl1
1412         6    09/13/88  1257.6  help_args_.incl.pl1               >spec>install>MR12.2-1109>help_args_.incl.pl1
1414         7    09/13/88  1257.6  help_cis_args_.incl.pl1           >spec>install>MR12.2-1109>help_cis_args_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
APPDinfo_seg                           parameter       pointer                  dcl 97 set ref 285 458*
Acode                                  parameter       fixed bin(35,0)          dcl 97 set ref 94 285 302* 309* 312* 316 316* 319
                                                                                  323* 324 356* 508* 1322 1339* 1342* 1343 1364*
                                                                                  1366 1389 1401* 1403*
Aline                                  parameter       char                     packed unaligned dcl 1055 set ref 1052 1073 1074
                                                                                  1083 1126 1136
CIS                                    constant        fixed bin(17,0)          initial dcl 115 ref 288 455 842
Dinfo                                  based           structure                level 1 dcl 149 set ref 364 364
Dinfo_                                 based           structure                level 1 dcl 680
Dinfo_seg                              based           structure                level 1 dcl 7-41
Dinfo_seg_                             based           structure                level 1 dcl 1416
Directory                              constant        fixed bin(17,0)          initial dcl 2-56 ref 792
E                       110            based           char(32)                 array level 3 dcl 680 set ref 712* 800* 849* 1048*
EMPTY_ARG_LIST                  000002 constant        fixed bin(71,0)          initial dcl 538 set ref 546 546
FALSE                                  constant        bit(1)                   initial packed unaligned dcl 257 ref 298 343 598 609
                                                                                  630 640 707 795
HELP                                   constant        fixed bin(17,0)          initial dcl 115 ref 281
HT_SP                                  constant        char(2)                  initial packed unaligned dcl 257 ref 1075 1117
I                               000100 automatic       fixed bin(17,0)          dcl 665 in procedure "get_info_seg_list" set ref
                                                                                  872* 874 876 877 909* 910 988* 1000 1002 1003
                                                                                  1004* 1008* 1012 1014 1015 1019* 1023 1025 1026
I                       107            based           fixed bin(35,0)          array level 3 in structure "Dinfo_" dcl 680
                                                                                  in procedure "get_info_seg_list" set ref 848* 870*
                                                                                  941* 1047*
I                               061104 automatic       fixed bin(21,0)          dcl 1271 in procedure "rel_char" set ref 1278* 1281*
                                                                                  1281 1282
Icolon                          061057 automatic       fixed bin(17,0)          dcl 1060 set ref 1132* 1133 1135 1136
Iempty                          000101 automatic       fixed bin(17,0)          dcl 1166 set ref 1168* 1186 1186* 1201 1205* 1209*
                                                                                  1210 1212 1213 1214 1215
Iline                                  parameter       fixed bin(17,0)          dcl 1055 set ref 1052 1083* 1126* 1136*
Inon_space                      061060 automatic       fixed bin(17,0)          dcl 1060 set ref 1075* 1076 1078 1079 1081 1117*
                                                                                  1119 1121 1122 1124
Iquote                          061061 automatic       fixed bin(17,0)          dcl 1060 set ref 1093* 1094 1094 1099 1099 1104 1105
                                                                                  1106 1107 1108* 1109 1109 1113 1115 1116
Iquote_quote                    061062 automatic       fixed bin(17,0)          dcl 1060 set ref 1097* 1099 1104 1111*
L                       122            based           fixed bin(17,0)          array level 3 in structure "Dinfo_" dcl 680
                                                                                  in procedure "get_info_seg_list" set ref 718* 723
                                                                                  725 735* 739 741 746* 760* 804* 810 812 820* 869
                                                                                  954* 956*
L                       120            based           fixed bin(17,0)          level 2 in structure "Dinfo_seg_" dcl 1416
                                                                                  in procedure "help_" ref 493
LIST                                   based           structure                level 1 dcl 165
Link                                   constant        fixed bin(17,0)          initial dcl 2-56 ref 744
Lline                           061063 automatic       fixed bin(17,0)          dcl 1060 in procedure "find_info_name" set ref 1074*
                                                                                  1075 1079* 1079 1092* 1092 1093 1094 1097 1099
                                                                                  1105 1107* 1107 1108 1109 1111 1113 1116* 1116
                                                                                  1117 1122* 1122 1126 1132 1135 1136
Lline                           000101 automatic       fixed bin(17,0)          dcl 665 in procedure "get_info_seg_list" set ref
                                                                                  905* 907 907* 909 909 940 940 959* 959 966* 967
                                                                                  967* 970 970 975* 975 976 977 981 981 1003* 1003
                                                                                  1004 1004
Lseg                            000100 automatic       fixed bin(21,0)          dcl 115 in procedure "help_" set ref 493* 494
Lseg                            000102 automatic       fixed bin(21,0)          dcl 665 in procedure "get_info_seg_list" set ref
                                                                                  869* 872 877* 877 879 879 879 883 886* 886 891*
                                                                                  891 901* 902* 904 905 907 945 949 956 958* 958 960
                                                                                  965* 965 966 967 970 989* 1002* 1002 1008 1015*
                                                                                  1015 1019 1026* 1026 1028*
Lspace_between_infos     11            based           fixed bin(17,0)          level 2 dcl 6-55 set ref 1353*
N                                      based           fixed bin(17,0)          level 2 in structure "init_assoc_mem" dcl 154
                                                                                  in procedure "help_" set ref 344* 1171 1197 1199
                                                                                  1201 1204* 1204 1205 1209 1311* 1311* 1312 1312*
N                                      based           fixed bin(17,0)          level 2 in structure "Dinfo" dcl 149 in procedure
                                                                                  "help_" set ref 348* 354 364 364 366 367 373 381
                                                                                  388 393 405 432
N                                      based           fixed bin(17,0)          level 3 in structure "query_answers" dcl 182
                                                                                  in procedure "help_" set ref 328* 330 336
N                         1            based           fixed bin(24,0)          level 2 in structure "PDinfo_seg" dcl 7-41
                                                                                  in procedure "help_" set ref 366* 375 375 419* 423
                                                                                  426 426 452 452 452 462 462 478 500*
N                                      based           fixed bin(17,0)          level 2 in structure "Dinfo_" dcl 680 in procedure
                                                                                  "get_info_seg_list" set ref 695 706 706* 753* 753
                                                                                  768* 768 771* 771 794 794* 814* 814 844 854 861
                                                                                  996 996* 1037* 1037
NL                              011435 constant        char(1)                  initial packed unaligned dcl 257 ref 905 966 970
Ncas                      4            based           fixed bin(17,0)          level 2 dcl 6-55 set ref 340 340 1228 1228 1356*
                                                                                  1362 1362 1375 1375
Ninfos_printed                  000101 automatic       fixed bin(17,0)          dcl 115 set ref 474* 500* 508
Nlast_info_cross_ref            000102 automatic       fixed bin(17,0)          dcl 115 set ref 465* 500*
Nlast_info_no_brief_data        000103 automatic       fixed bin(17,0)          dcl 115 set ref 464* 500*
Npaths                    3            based           fixed bin(17,0)          level 2 dcl 6-55 set ref 307 314 340 340 349 1228
                                                                                  1228 1355* 1362 1362 1375 1375
Nreal                     1            based           fixed bin(17,0)          level 3 dcl 182 set ref 330*
Nrows                     3            based           fixed bin(17,0)          level 3 dcl 182 set ref 331*
Nscns                     5            based           fixed bin(17,0)          level 2 dcl 6-55 ref 340 340 1228 1228 1362 1362
                                                                                  1375 1375
Nsearch_dirs              2            based           fixed bin(17,0)          level 2 dcl 6-55 set ref 315 316 340 340 350 350 350
                                                                                  352 352 1228 1228 1360* 1362 1362 1368* 1369 1369
                                                                                  1372* 1374* 1375 1375
Nsrhs                     6            based           fixed bin(17,0)          level 2 dcl 6-55 set ref 340 340 1228 1228 1357*
                                                                                  1362 1362 1375 1375
Nstart                          000103 automatic       fixed bin(17,0)          dcl 665 set ref 695* 844 854 861
P                         2            based           pointer                  array level 2 in structure "PDinfo_seg" packed
                                                                                  packed unaligned dcl 7-41 in procedure "help_" set
                                                                                  ref 368* 381 382* 382 395 395 398* 398 400* 400
                                                                                  407 407 410* 410 412* 412 418* 418 421* 431* 431
                                                                                  433* 433 434 434 434 434 434 434 438 438 440 442*
                                                                                  442 443* 446 450* 481
P                                      parameter       pointer                  dcl 1269 in procedure "rel_char" ref 1265 1277 1277
                                                                                  1278 1279
P                        66            based           pointer                  array level 3 in structure "init_assoc_mem" dcl 154
                                                                                  in procedure "help_" set ref 1175 1183 1210* 1215*
                                                                                  1312*
P1                              061106 automatic       pointer                  dcl 1271 set ref 1277* 1279
PDeps                           000110 automatic       pointer                  dcl 115 set ref 462* 500*
PDinfo                          000112 automatic       pointer                  dcl 115 set ref 347* 348 350* 352* 354 364 364 366
                                                                                  367 368 369 373 377 377 381 388 393 405 421 428
                                                                                  428 432 450
PDinfo_                                parameter       pointer                  dcl 658 ref 652 695 706 706 707 708 709 710 711 712
                                                                                  713 718 719 720 722 723 723 725 725 730 730 735
                                                                                  736 737 738 739 739 741 741 746 747 748 749 753
                                                                                  753 760 761 762 763 768 768 771 771 771 771 771
                                                                                  776 794 794 795 796 797 798 799 800 801 804 805
                                                                                  806 807 807 809 810 810 812 812 814 814 814 820
                                                                                  821 822 823 844 845 847 848 849 854 861 863 865
                                                                                  866 866 866 869 870 894 897 934 938 941 954 956
                                                                                  981 982 986 987 992 994 996 996 997 997 1033 1036
                                                                                  1037 1037 1041 1044 1046 1047 1048
PDinfo_seg                             based           structure                level 1 dcl 7-41 set ref 462 462
PDinfo_seg_                     000160 automatic       pointer                  dcl 1416 set ref 481* 482 484 484 484 484 484 484
                                                                                  484 490 490 490 493 500* 502 502 502 502 502
PI_LABEL                        000104 automatic       label variable           dcl 115 set ref 467* 471 480* 500*
PPDinfo_seg                     000156 automatic       pointer                  dcl 7-41 set ref 364* 365 366 368 375 375 381 382
                                                                                  382 395 395 398 398 400 400 407 407 410 410 412
                                                                                  412 418 418 419 421 423 426 426 431 431 433 433
                                                                                  434 434 434 434 434 434 438 438 440 442 442 443
                                                                                  446 450 452 452 452 458 462 462 478 481 500
Parea                           000152 automatic       pointer                  dcl 1334 set ref 1362* 1363 1364*
Pcurrent_space                         parameter       pointer                  dcl 1295 ref 1291 1300
Phelp_args                             parameter       pointer                  dcl 6-55 set ref 94 285 294 294 296 297 298 300 307
                                                                                  314 315 316 340* 340 340 349 350 350 350 352 352
                                                                                  484 500* 502 502 540 543 546 552 610 622 771 814
                                                                                  835 859 992 1228* 1228 1228 1230 1233 1234 1322
                                                                                  1342* 1343* 1347 1348 1349 1350 1351 1352 1353
                                                                                  1354 1355 1356 1357 1360 1362* 1362 1362 1368 1369
                                                                                  1369 1372 1374 1375* 1375 1375 1389 1392 1394 1401
                                                                                  1401 1403*
Pinit_assoc_mem                 000114 automatic       pointer                  dcl 115 set ref 340* 344 347 347 1171 1173 1175 1175
                                                                                  1180 1180 1182 1183 1197 1197 1199 1201 1201 1204
                                                                                  1204 1205 1209 1210 1212 1213 1214 1215 1311 1311
                                                                                  1312 1312 1312 1312
Pline                           061064 automatic       pointer                  dcl 1060 set ref 1073* 1075 1078* 1078 1088 1090*
                                                                                  1090 1093 1097 1099 1105 1106* 1106 1108 1111 1113
                                                                                  1115* 1115 1117 1121* 1121 1126 1132 1135
Pnext_free_space                000116 automatic       pointer                  dcl 115 set ref 340* 347* 347* 364* 364* 462* 462*
Pnext_space                     000216 automatic       pointer                  dcl 1295 set ref 1300* 1301
Pquery_answers                  000120 automatic       pointer                  dcl 115 set ref 323* 328 330 330 331 332 334 336 337
                                                                                  500* 1237 1237*
Pseg                            000104 automatic       pointer                  dcl 665 in procedure "get_info_seg_list" set ref
                                                                                  866* 867 872 876* 876 879 879 883 885* 885 890*
                                                                                  890 905 909 940 941 941 945 949 957* 957 960 964*
                                                                                  964 966 970 976 981 981 1000* 1000 1004 1008 1014*
                                                                                  1014 1019 1025* 1025
Pseg                            000122 automatic       pointer                  dcl 115 in procedure "help_" set ref 490* 491 500*
Pseg                                   parameter       pointer                  dcl 1159 in procedure "initiate" set ref 1155 1170*
                                                                                  1171 1175* 1183* 1189 1192* 1193 1195* 1215
Ptemp                           000124 automatic       pointer                  dcl 115 in procedure "help_" set ref 440* 443
Ptemp                           000106 automatic       pointer                  dcl 665 in procedure "get_info_seg_list" set ref
                                                                                  934* 935
QUOTE                           011433 constant        char(1)                  initial packed unaligned dcl 1065 ref 1088 1090 1092
                                                                                  1093 1108 1115 1116
QUOTE_QUOTE                            constant        char(2)                  initial packed unaligned dcl 1065 ref 1097 1106 1107
                                                                                  1111
S                       260            parameter       structure                level 2 in structure "info_path" dcl 658
                                                                                  in procedure "get_info_seg_list"
S                                      based           structure                array level 3 in structure "help_args" dcl 6-55
                                                                                  in procedure "help_"
S                       260            parameter       structure                level 2 in structure "info_path" dcl 565
                                                                                  in procedure "evaluate_path"
Scross_ref                2            based           bit(36)                  array level 3 in structure "Dinfo_" dcl 680
                                                                                  in procedure "get_info_seg_list" set ref 707* 795*
Scross_ref                             based           bit(36)                  level 2 in structure "Dinfo_seg" dcl 7-41
                                                                                  in procedure "help_" set ref 446*
Scross_ref                2            based           bit(36)                  array level 3 in structure "Dinfo" dcl 149
                                                                                  in procedure "help_" set ref 428 450
Sctl                      1            based           structure                level 2 dcl 6-55 set ref 1350*
Segment                                constant        fixed bin(17,0)          initial dcl 2-56 ref 733 802
Sprint_inhibit                  000126 automatic       bit(1)                   dcl 115 set ref 470* 500*
Sstandalone_invocation          000127 automatic       bit(1)                   packed unaligned dcl 115 set ref 343* 545* 1230
TRUE                                   constant        bit(1)                   initial packed unaligned dcl 257 ref 446 470 545 593
                                                                                  605 621 638
VPDinfo_seg_2                          constant        fixed bin(17,0)          initial dcl 7-41 ref 365
Vhelp_args_3                    011434 constant        fixed bin(17,0)          initial dcl 6-55 ref 296 300 546 546 1337
Vrequired                              parameter       fixed bin(17,0)          dcl 1325 ref 1322 1337 1337 1337 1347
X                       120            based           fixed bin(35,0)          array level 3 dcl 149 set ref 369*
addr                                                   builtin function         dcl 218 ref 368 375 375 377 377 421 426 426 428 428
                                                                                  450 452 452 546 546 700 700 730 730 789 789 876
                                                                                  885 890 941 941 957 964 1000 1014 1025 1073 1078
                                                                                  1090 1106 1115 1121 1279
addrel                                                 builtin function         dcl 218 ref 382 398 410 418 431 433 1300
area                            000110 automatic       area(25000)              initial dcl 665 in procedure "get_info_seg_list" set
                                                                                  ref 665* 700 700 781 781
area                                   based           area(25000)              dcl 1334 in procedure "help_" set ref 1363*
arg                      41            based           varying char(88)         array level 3 dcl 182 set ref 334* 337*
binary                                                 builtin function         dcl 218 ref 377 377 428 428 438 438 484 735 741 781
                                                                                  804 812 1278
bit36                                  based           bit(36)                  dcl 215 ref 407 407
bit360                                 based           bit(360)                 dcl 215 ref 381 395 395
bit_count                 3(11)        based           fixed bin(24,0)          array level 2 packed packed unaligned dcl 1-59 ref
                                                                                  718 725
bit_date                               parameter       bit(36)                  packed unaligned dcl 1252 ref 1245 1257
branch                          061021 automatic       structure                level 1 dcl 1146 set ref 730 730 789 789
char                                                   builtin function         dcl 218 ref 546 546
char_offset                            based           char(1)                  array packed unaligned dcl 1275 set ref 1279
check_star_name_$entry          000106 constant        entry                    external dcl 570 ref 606 634
cleanup                         000130 stack reference condition                dcl 115 ref 345
code                            060760 automatic       fixed bin(35,0)          dcl 665 in procedure "get_info_seg_list" set ref
                                                                                  700* 702 730* 731 731 763 786 786 789* 790 790 814
                                                                                  827 831 835* 856* 858* 859* 866* 913* 914 934*
                                                                                  981* 982 1041
code                                   parameter       fixed bin(35,0)          dcl 1159 in procedure "initiate" set ref 1155 1169*
                                                                                  1192* 1195* 1210*
code                                   based           fixed bin(35,0)          array level 3 in structure "help_args" dcl 6-55
                                                                                  in procedure "help_" set ref 316
code                    125            based           fixed bin(35,0)          level 2 in structure "Dinfo_seg_" dcl 1416
                                                                                  in procedure "help_" set ref 482 484*
code                    127            based           fixed bin(35,0)          array level 3 in structure "Dinfo_" dcl 680
                                                                                  in procedure "get_info_seg_list" set ref 722* 723*
                                                                                  725* 738* 739* 741* 749* 763* 771 776* 807* 809*
                                                                                  810* 812* 823* 845 863 1033* 1036* 1041* 1044
code                            000136 automatic       fixed bin(35,0)          dcl 115 in procedure "help_" set ref 476* 478 490*
                                                                                  496* 500* 502 502* 1237*
code                            000100 automatic       fixed bin(35,0)          dcl 533 in procedure "error" set ref 546* 548 548*
code                    257            parameter       fixed bin(35,0)          level 2 in structure "info_path" dcl 565
                                                                                  in procedure "evaluate_path" set ref 589* 591 606*
                                                                                  607 617 617 620* 622* 626 634* 635 635 637*
com_err_                        000010 constant        entry                    external dcl 223 ref 548
convert_date_to_binary_         000012 constant        entry                    external dcl 223 ref 981
cu_$arg_list_ptr                000102 constant        entry                    external dcl 534 ref 552 552
cu_$generate_call               000104 constant        entry                    external dcl 534 ref 552
currentsize                                            builtin function         dcl 218 ref 340 340 347 347 364 364 462 462 1228
                                                                                  1228 1362 1362 1375 1375
date                    124            based           fixed bin(71,0)          array level 3 dcl 680 set ref 719* 736* 747* 761*
                                                                                  771 805* 814 821* 897 981* 982* 986* 987* 992
dim                                                    builtin function         dcl 218 ref 837
dimension                                              builtin function         dcl 218 ref 1201
dir                       2            based           char(168)                array level 3 in structure "init_assoc_mem" packed
                                                                                  packed unaligned dcl 154 in procedure "help_" set
                                                                                  ref 1180 1212*
dir                       3            based           char(168)                array level 3 in structure "Dinfo_" packed packed
                                                                                  unaligned dcl 680 in procedure "get_info_seg_list"
                                                                                  set ref 708* 730* 796* 866* 934*
dir                                    parameter       char(168)                packed unaligned dcl 1159 in procedure "initiate"
                                                                                  set ref 1155 1180 1192* 1212
dir                       1            based           char(168)                level 2 in structure "Dinfo_seg_" packed packed
                                                                                  unaligned dcl 1416 in procedure "help_" set ref
                                                                                  484* 484 490* 502* 502*
dir                     164            parameter       char(168)                array level 2 in structure "info_path" packed packed
                                                                                  unaligned dcl 565 in procedure "evaluate_path" set
                                                                                  ref 575* 589*
dir                                    based           char(168)                array level 3 in structure "help_args" packed packed
                                                                                  unaligned dcl 6-55 in procedure "help_" set ref
                                                                                  350*
dirs                                   parameter       char(168)                array packed unaligned dcl 658 set ref 652 697 697
                                                                                  700* 708 789* 796 835* 837
divide                                                 builtin function         dcl 218 ref 718 735 781 804
dtem                      1            based           bit(36)                  array level 2 packed packed unaligned dcl 1-59 set
                                                                                  ref 719*
empty                                                  builtin function         dcl 218 ref 665 1363
ent                      55            based           char(32)                 array level 3 in structure "Dinfo" packed packed
                                                                                  unaligned dcl 149 in procedure "help_" set ref 377
                                                                                  421 428
ent                                    parameter       char(32)                 packed unaligned dcl 1159 in procedure "initiate"
                                                                                  set ref 1155 1180 1192* 1213
ent                     236            parameter       char(32)                 level 2 in structure "info_path" packed packed
                                                                                  unaligned dcl 565 in procedure "evaluate_path" set
                                                                                  ref 576* 589* 600 602 602 606* 610 614 614
ent                     236            parameter       char(32)                 level 2 in structure "info_path" packed packed
                                                                                  unaligned dcl 658 in procedure "get_info_seg_list"
                                                                                  set ref 700* 789* 797
ent                      55            based           char(32)                 array level 3 in structure "Dinfo_" packed packed
                                                                                  unaligned dcl 680 in procedure "get_info_seg_list"
                                                                                  set ref 709* 730* 797* 866* 938*
ent                      54            based           char(32)                 array level 3 in structure "init_assoc_mem" packed
                                                                                  packed unaligned dcl 154 in procedure "help_" set
                                                                                  ref 1180 1213*
ent                      53            based           char(32)                 level 2 in structure "Dinfo_seg" packed packed
                                                                                  unaligned dcl 7-41 in procedure "help_" ref 434
                                                                                  434
ent                      53            based           char(32)                 level 2 in structure "Dinfo_seg_" packed packed
                                                                                  unaligned dcl 1416 in procedure "help_" set ref
                                                                                  484* 490* 502* 502*
ep                        1(09)        based           bit(1)                   level 3 in structure "help_args" packed packed
                                                                                  unaligned dcl 6-55 in procedure "help_" set ref
                                                                                  610 622
ep                       73            based           varying char(32)         level 2 in structure "Dinfo_seg_" dcl 1416
                                                                                  in procedure "help_" set ref 502*
ep                      246            parameter       varying char(32)         level 2 in structure "info_path" dcl 658
                                                                                  in procedure "get_info_seg_list" ref 711 712 799
                                                                                  800
ep                      246            parameter       varying char(32)         level 2 in structure "info_path" dcl 565
                                                                                  in procedure "evaluate_path" set ref 577* 586*
                                                                                  588* 610 610* 614* 622
ep                       75            based           varying char(32)         array level 3 in structure "Dinfo_" dcl 680
                                                                                  in procedure "get_info_seg_list" set ref 711* 799*
error_table_$badsyntax          000052 external static fixed bin(35,0)          dcl 257 ref 725 741 812
error_table_$inconsistent       000054 external static fixed bin(35,0)          dcl 257 ref 622
error_table_$incorrect_access   000056 external static fixed bin(35,0)          dcl 257 ref 786
error_table_$moderr             000060 external static fixed bin(35,0)          dcl 257 ref 776 809
error_table_$no_info            000070 external static fixed bin(35,0)          dcl 257 ref 786
error_table_$no_s_permission    000062 external static fixed bin(35,0)          dcl 257 ref 731 790
error_table_$noarg              000064 external static fixed bin(35,0)          dcl 257 ref 309
error_table_$noentry            000066 external static fixed bin(35,0)          dcl 257 ref 502 749 823 827 858 1036
error_table_$nomatch            000072 external static fixed bin(35,0)          dcl 257 ref 356 508 831 856 1033
error_table_$unimplemented_version
                                000074 external static fixed bin(35,0)          dcl 257 ref 302 1339
error_table_$zero_length_seg    000076 external static fixed bin(35,0)          dcl 257 ref 496 723 739 810
expand_pathname_$add_suffix     000110 constant        entry                    external dcl 570 ref 589
fcn                             000137 automatic       fixed bin(17,0)          dcl 115 in procedure "help_" set ref 281* 288* 350*
                                                                                  352* 390 455
fcn                                    parameter       fixed bin(17,0)          dcl 658 in procedure "get_info_seg_list" ref 652 842
get_temp_segment_               000014 constant        entry                    external dcl 223 ref 323 1342
group                    41            based           structure                array level 2 in structure "LIST" dcl 165
                                                                                  in procedure "help_"
group                    41            based           structure                array level 2 in structure "query_answers" dcl 182
                                                                                  in procedure "help_"
hbound                                                 builtin function         dcl 218 ref 328 333 697
hcs_$get_uid_seg                000016 constant        entry                    external dcl 223 ref 1195
hcs_$initiate                   000020 constant        entry                    external dcl 223 ref 934 1192
hcs_$star_dir_list_             000112 constant        entry                    external dcl 690 ref 700
hcs_$status_long                000114 constant        entry                    external dcl 690 ref 730 789
hcs_$terminate_noname           000022 constant        entry                    external dcl 223 ref 1210 1312
hcs_$truncate_seg               000024 constant        entry                    external dcl 223 ref 1228 1375
header                                 based           structure                level 2 in structure "LIST" dcl 165 in procedure
                                                                                  "help_"
header                                 based           structure                level 2 in structure "query_answers" dcl 182
                                                                                  in procedure "help_"
help_$term                      000100 constant        entry                    external dcl 6-160 ref 1401
help_args                              based           structure                level 1 dcl 6-55 set ref 340 340 1228 1228 1362 1362
                                                                                  1375 1375
help_data_ptr            16            based           pointer                  level 2 dcl 6-55 set ref 1348* 1394 1401 1401*
help_rql_                       000026 constant        entry                    external dcl 223 ref 500
i                               060761 automatic       fixed bin(17,0)          dcl 665 in procedure "get_info_seg_list" set ref
                                                                                  697* 700 708 789 796 835* 844* 845 847 848 849*
                                                                                  861* 863 865 866 866 866 869 870 893 997 1033 1033
                                                                                  1036 1041 1044 1046 1047 1048*
i                               061110 automatic       fixed bin(17,0)          dcl 1271 in procedure "rel_char" set ref 1279* 1279*
                                                                                  1281
i                               000140 automatic       fixed bin(17,0)          dcl 115 in procedure "help_" set ref 314* 315 316*
                                                                                  333* 334 334* 336* 336* 337* 349* 350 350 350 352*
                                                                                  367* 368 368 369 369* 381* 381* 382 382* 387 388
                                                                                  393* 393* 395 395 398 400 400* 405* 405* 407 407
                                                                                  410 412 412* 418 432* 433 433 434 434 434 434 434
                                                                                  434 438 438 440 442 442 443 446* 478* 481 500*
i                               000206 automatic       fixed bin(17,0)          dcl 568 in procedure "evaluate_path" set ref 580*
                                                                                  582 582* 586 586 589 589
i                               000100 automatic       fixed bin(17,0)          dcl 1165 in procedure "initiate" set ref 1171* 1173
                                                                                  1175 1175 1180 1180 1182 1183 1186* 1197* 1197*
                                                                                  1199
index                                                  builtin function         dcl 218 ref 580 602 614 905 940 945 949 966 1008
                                                                                  1019 1093 1097 1108 1111 1132
info_name                63            based           char(32)                 level 2 in structure "Dinfo_seg_" packed packed
                                                                                  unaligned dcl 1416 in procedure "help_" set ref
                                                                                  484 484*
info_name               154            parameter       char(32)                 level 2 in structure "info_path" packed packed
                                                                                  unaligned dcl 658 in procedure "get_info_seg_list"
                                                                                  set ref 894 913* 917
info_name                65            based           char(32)                 array level 3 in structure "Dinfo_" packed packed
                                                                                  unaligned dcl 680 in procedure "get_info_seg_list"
                                                                                  set ref 710* 798* 894* 994*
info_name                       061046 automatic       varying char(32)         dcl 1055 in procedure "find_info_name" set ref 1099*
                                                                                  1103* 1105* 1105 1113* 1113 1135* 1138
info_name               154            parameter       char(32)                 level 2 in structure "info_path" packed packed
                                                                                  unaligned dcl 565 in procedure "evaluate_path" set
                                                                                  ref 596 600* 602* 634*
info_name_not_starname
                        260(01)        parameter       bit(1)                   level 3 packed packed unaligned dcl 565 ref 630
info_path                              parameter       structure                level 1 dcl 565 in procedure "evaluate_path" set ref
                                                                                  562
info_path                              parameter       structure                level 1 dcl 658 in procedure "get_info_seg_list" set
                                                                                  ref 652
inhibit_errors            1(13)        based           bit(1)                   level 3 packed packed unaligned dcl 6-55 set ref
                                                                                  298* 502 540
init_assoc_mem                         based           structure                level 1 dcl 154 set ref 347 347
j                               060762 automatic       fixed bin(17,0)          dcl 665 in procedure "get_info_seg_list" set ref
                                                                                  704* 709 713 716 718 719 720 725 728* 940* 941 941
                                                                                  954 956 957 958 959 960* 962 964 965 976* 977 977*
                                                                                  981 981
j                               000141 automatic       fixed bin(17,0)          dcl 115 in procedure "help_" set ref 387* 397* 397
                                                                                  398 409* 409 410 416* 416 418 419
k                               060763 automatic       fixed bin(17,0)          dcl 665 set ref 706* 707 708 709 710 711 712 713 718
                                                                                  719 720 722 723 723 725 725 730 730 735 736 737
                                                                                  738 739 739 741 741 746 747 748 749 760 761 762
                                                                                  763 771 771 771 776 794* 795 796 797 798 799 800
                                                                                  801 804 805 806 807 807 809 810 810 812 812 814
                                                                                  820 821 822 823 893* 894 897 901* 902* 934 938 941
                                                                                  954 956 981 982 986 987 992 994 996* 997 1031 1033
l                               060764 automatic       fixed bin(21,0)          dcl 665 set ref 945* 949 949* 954 954
lbound                                                 builtin function         dcl 218 ref 333 697
length                                                 builtin function         dcl 218 ref 586 589 589 602 614 1074 1083 1090 1092
                                                                                  1106 1107 1115 1116 1126 1136
less_greater            260(02)        parameter       bit(1)                   level 3 in structure "info_path" packed packed
                                                                                  unaligned dcl 565 in procedure "evaluate_path" set
                                                                                  ref 578* 582 593*
less_greater                           based           bit(1)                   array level 4 in structure "help_args" packed packed
                                                                                  unaligned dcl 6-55 in procedure "help_" set ref
                                                                                  350
line                                   based           char                     packed unaligned dcl 1070 in procedure
                                                                                  "find_info_name" ref 1075 1093 1097 1099 1105 1108
                                                                                  1111 1113 1117 1132 1135
line                                   based           char                     packed unaligned dcl 665 in procedure
                                                                                  "get_info_seg_list" set ref 909* 940 976 981 981
                                                                                  1004*
line_char                              based           char(1)                  array packed unaligned dcl 1070 set ref 1078 1088
                                                                                  1090 1106 1115 1121 1126
linfo_name                      060765 automatic       char(32)                 packed unaligned dcl 665 set ref 909* 913* 917 927
                                                                                  929 994 1004*
ltrim                                                  builtin function         dcl 218 ref 546 546
match_star_name_                000030 constant        entry                    external dcl 223 ref 913
max_Lpgh                 10            based           fixed bin(17,0)          level 2 dcl 6-55 set ref 1352*
min_Lpgh                  7            based           fixed bin(17,0)          level 2 dcl 6-55 set ref 1351*
min_date_time            12            based           fixed bin(71,0)          level 2 dcl 6-55 set ref 771 814 992 1354*
mod                                                    builtin function         dcl 218 ref 1300
mode                    126(02)        based           bit(3)                   array level 3 in structure "Dinfo_" packed packed
                                                                                  unaligned dcl 680 in procedure "get_info_seg_list"
                                                                                  set ref 720* 737* 748* 762* 771 806* 807 822*
mode                      3            based           bit(5)                   array level 2 in structure "star_dir_list_branch"
                                                                                  packed packed unaligned dcl 1-59 in procedure
                                                                                  "get_info_seg_list" ref 720
nindex                    0(18)        based           fixed bin(18,0)          array level 2 in structure "star_links" packed
                                                                                  packed unsigned unaligned dcl 1-76 in procedure
                                                                                  "get_info_seg_list" ref 781
nindex                    0(18)        based           fixed bin(18,0)          array level 2 in structure "star_dir_list_branch"
                                                                                  packed packed unsigned unaligned dcl 1-59
                                                                                  in procedure "get_info_seg_list" ref 709
nnames                    0(02)        based           fixed bin(16,0)          array level 2 packed packed unsigned unaligned
                                                                                  dcl 1-76 ref 781
null                                                   builtin function         dcl 218 ref 297 491 543 552 730 730 789 789 867 935
                                                                                  1170 1171 1189 1193 1230 1234 1237 1343 1348 1349
                                                                                  1364 1364 1392 1401
num_date                        061074 automatic       fixed bin(71,0)          dcl 1252 set ref 1256* 1257 1258
num_paths                 1            based           fixed bin(17,0)          level 2 dcl 3-15 ref 1368 1369 1369 1369 1369
offset                          000142 automatic       fixed bin(35,0)          dcl 115 set ref 377* 382 398 410 418 428* 431 433
path                                   based           structure                array level 2 dcl 6-55 set ref 315* 350* 352*
pathname                 17            based           char(168)                array level 3 packed packed unaligned dcl 3-15 ref
                                                                                  1369
pathname_$component             000032 constant        entry                    external dcl 223 ref 502 502
pathname_len              3            based           fixed bin(18,0)          array level 2 packed packed unsigned unaligned
                                                                                  dcl 1-76 ref 781
paths                    14            based           structure                array level 2 dcl 3-15
pn_ctl_arg              260            parameter       bit(1)                   level 3 in structure "info_path" packed packed
                                                                                  unaligned dcl 565 in procedure "evaluate_path" ref
                                                                                  593
pn_ctl_arg              260            parameter       bit(1)                   level 3 in structure "info_path" packed packed
                                                                                  unaligned dcl 658 in procedure "get_info_seg_list"
                                                                                  set ref 859*
procedure_name                         parameter       char                     packed unaligned dcl 658 in procedure
                                                                                  "get_info_seg_list" ref 652
procedure_name                         parameter       char                     packed unaligned dcl 97 in procedure "help_" set ref
                                                                                  94 285 323* 350* 352* 500* 546* 548* 1237* 1322
                                                                                  1342* 1389 1401* 1403*
program_interrupt               000144 stack reference condition                dcl 115 ref 468
progress                               parameter       fixed bin(17,0)          dcl 97 set ref 94 285 290* 306* 313* 322* 361*
ptr                                                    builtin function         dcl 218 ref 1277
query_answers                          based           structure                level 1 dcl 182
rel                                                    builtin function         dcl 218 ref 377 377 428 428 438 438 1277 1278
release_temp_segment_           000034 constant        entry                    external dcl 223 ref 1237 1403
responses                       000005 constant        varying char(50)         initial array dcl 187 ref 328 333 333 334
reverse                                                builtin function         dcl 218 ref 580 582 602 602 614 614 940
rtrim                                                  builtin function         dcl 218 ref 927 1135
saved_date                      061006 automatic       fixed bin(71,0)          dcl 665 set ref 897* 982 986 987
sci_ptr                  14            based           pointer                  level 2 dcl 6-55 set ref 297* 484* 502* 543 546* 552
                                                                                  835* 859* 1230 1233* 1234* 1349*
search                                                 builtin function         dcl 218 ref 578 582 976
search_dirs              26            based           char(168)                array level 2 packed packed unaligned dcl 6-55 set
                                                                                  ref 352* 1369*
search_list_name                       parameter       char                     packed unaligned dcl 1325 set ref 1322 1358 1364*
search_list_ref_dir                    parameter       char                     packed unaligned dcl 1325 set ref 1322 1364*
search_paths_$get               000036 constant        entry                    external dcl 223 ref 1364
seg                       2            based           structure                array level 2 in structure "init_assoc_mem" dcl 154
                                                                                  in procedure "help_" set ref 1201
seg                       2            based           structure                array level 2 in structure "Dinfo_" dcl 680
                                                                                  in procedure "get_info_seg_list" set ref 997* 997
seg                       2            based           structure                array level 2 in structure "Dinfo" dcl 149
                                                                                  in procedure "help_"
seg                                    based           char                     packed unaligned dcl 684 in procedure
                                                                                  "get_info_seg_list" ref 872 879 879 883 905 945
                                                                                  949 960 966 1008 1019
seg_char                               based           char(1)                  array packed unaligned dcl 684 set ref 876 885 890
                                                                                  941 941 957 964 970 1000 1014 1025
segment_type            126            based           fixed bin(2,0)           array level 3 in structure "Dinfo_" packed packed
                                                                                  unsigned unaligned dcl 680 in procedure
                                                                                  "get_info_seg_list" set ref 713* 801*
segment_type            124            based           fixed bin(2,0)           level 2 in structure "Dinfo_seg_" packed packed
                                                                                  unsigned unaligned dcl 1416 in procedure "help_"
                                                                                  ref 484
separate_info_name      260(05)        parameter       bit(1)                   level 3 in structure "info_path" packed packed
                                                                                  unaligned dcl 565 in procedure "evaluate_path" set
                                                                                  ref 598* 605* 628
separate_info_name      260(05)        parameter       bit(1)                   level 3 in structure "info_path" packed packed
                                                                                  unaligned dcl 658 in procedure "get_info_seg_list"
                                                                                  ref 920 989
sinfo_name                      060775 automatic       char(32)                 packed unaligned dcl 665 set ref 927* 929* 934* 938
size_current_space                     parameter       fixed bin(21,0)          dcl 1295 ref 1291 1300 1300
sl_control_default              000004 constant        bit(36)                  initial packed unaligned dcl 4-13 set ref 1364*
sl_info                                based           structure                level 1 dcl 3-15
sl_info_p                       000154 automatic       pointer                  dcl 3-28 set ref 1364* 1368 1369
sl_info_version_1               000604 constant        fixed bin(17,0)          initial dcl 3-29 set ref 1364*
sort_items_$bit                 000040 constant        entry                    external dcl 223 ref 375
sort_items_$char                000042 constant        entry                    external dcl 223 ref 426 452
ssu_$destroy_invocation         000044 constant        entry                    external dcl 223 ref 1233
ssu_$print_message              000046 constant        entry                    external dcl 223 ref 552 552
ssu_$standalone_invocation      000050 constant        entry                    external dcl 223 ref 546
star_ALL_ENTRIES                       constant        fixed bin(2,0)           initial dcl 1-111 ref 699
star_LINK                              constant        fixed bin(2,0)           initial unsigned dcl 1-119 ref 728 781
star_LINKS_ONLY_WITH_LINK_PATHS        constant        fixed bin(3,0)           initial dcl 1-112 ref 781
star_SEGMENT                           constant        fixed bin(2,0)           initial unsigned dcl 1-120 ref 716
star_branch_count               061010 automatic       fixed bin(17,0)          dcl 1-13 set ref 700* 704 781 781 781 781 781
star_dir_list_branch                   based           structure                array level 1 dcl 1-59 set ref 781
star_link_count                 061014 automatic       fixed bin(17,0)          dcl 1-17 set ref 700* 704 781 781 781 781 781
star_links                             based           structure                array level 1 dcl 1-76
star_list_branch_ptr            061012 automatic       pointer                  dcl 1-16 set ref 700* 709 713 716 718 719 720 725
                                                                                  728 781 781 781 781 781
star_list_names                        based           char(32)                 array packed unaligned dcl 1-92 ref 709 781
star_list_names_ptr             061016 automatic       pointer                  dcl 1-20 set ref 700* 709 781
star_select_sw                  061020 automatic       fixed bin(3,0)           dcl 1-21 set ref 699* 700* 781
starname_ent            260(03)        parameter       bit(1)                   level 3 in structure "info_path" packed packed
                                                                                  unaligned dcl 658 in procedure "get_info_seg_list"
                                                                                  ref 786 856 932
starname_ent            260(03)        parameter       bit(1)                   level 3 in structure "info_path" packed packed
                                                                                  unaligned dcl 565 in procedure "evaluate_path" set
                                                                                  ref 609* 621* 643
starname_info_name      260(04)        parameter       bit(1)                   level 3 in structure "info_path" packed packed
                                                                                  unaligned dcl 658 in procedure "get_info_seg_list"
                                                                                  ref 911 989 1033
starname_info_name      260(04)        parameter       bit(1)                   level 3 in structure "info_path" packed packed
                                                                                  unaligned dcl 565 in procedure "evaluate_path" set
                                                                                  ref 630* 638* 640* 643*
status_branch                          based           structure                level 1 dcl 2-8
string                                                 builtin function         dcl 218 set ref 1350*
substr                                                 builtin function         dcl 218 set ref 586 589 589 602 614 720 737 806 879
                                                                                  879 883 981 981 1099 1105 1113 1135 1257*
suffix                                 parameter       char                     packed unaligned dcl 565 in procedure
                                                                                  "evaluate_path" set ref 562 589* 600 602 602 610
                                                                                  614 614
suffix                                 parameter       char                     packed unaligned dcl 658 in procedure
                                                                                  "get_info_seg_list" ref 652 927 927
suffix                                 parameter       char                     packed unaligned dcl 97 in procedure "help_" set ref
                                                                                  94 285 315* 350* 352* 500*
title                    13            based           varying char(80)         level 3 dcl 182 set ref 332*
type                                   based           fixed bin(2,0)           array level 2 in structure "star_links" packed
                                                                                  packed unsigned unaligned dcl 1-76 in procedure
                                                                                  "get_info_seg_list" ref 781
type                                   based           fixed bin(2,0)           array level 2 in structure "star_dir_list_branch"
                                                                                  packed packed unsigned unaligned dcl 1-59
                                                                                  in procedure "get_info_seg_list" ref 713 716 728
uid                     104            based           bit(36)                  level 2 in structure "Dinfo_seg_" dcl 1416
                                                                                  in procedure "help_" set ref 490*
uid                     104            based           bit(36)                  level 2 in structure "Dinfo_seg" dcl 7-41
                                                                                  in procedure "help_" ref 434 434 434 434
uid                     106            based           bit(36)                  array level 3 in structure "Dinfo" dcl 149
                                                                                  in procedure "help_" set ref 368 377
uid                      64            based           bit(36)                  array level 3 in structure "init_assoc_mem" dcl 154
                                                                                  in procedure "help_" set ref 1173 1175 1182 1197
                                                                                  1214* 1312
uid                                    parameter       bit(36)                  dcl 1159 in procedure "initiate" set ref 1155 1175
                                                                                  1175 1182* 1195* 1197 1214
uid                     106            based           bit(36)                  array level 3 in structure "Dinfo_" dcl 680
                                                                                  in procedure "get_info_seg_list" set ref 847* 865*
                                                                                  866* 1046*
unspec                                                 builtin function         dcl 218 ref 1257 1394
value                                  parameter       varying char(425)        level 2 in structure "info_path" dcl 658
                                                                                  in procedure "get_info_seg_list" set ref 859*
value                                  parameter       varying char(425)        level 2 in structure "info_path" dcl 565
                                                                                  in procedure "evaluate_path" ref 578 580 582 586
                                                                                  586 589 589 589 589
verify                                                 builtin function         dcl 218 ref 872 960 1075 1117
version                                based           fixed bin(17,0)          level 2 in structure "PDinfo_seg" dcl 7-41
                                                                                  in procedure "help_" set ref 365*
version                                based           fixed bin(17,0)          level 2 in structure "help_args" dcl 6-55
                                                                                  in procedure "help_" set ref 294 294 296* 300
                                                                                  1347*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSOLUTE_PATH                          internal static fixed bin(17,0)          initial dcl 3-33
Envptr_supplied_call_type              internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 5-54
HOME_DIR                               internal static fixed bin(17,0)          initial dcl 3-38
INITIATED_SEGS                         internal static fixed bin(17,0)          initial dcl 3-39
Interseg_call_type                     internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 5-54
PROCESS_DIR                            internal static fixed bin(17,0)          initial dcl 3-37
Quick_call_type                        internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 5-54
REFERENCING_DIR                        internal static fixed bin(17,0)          initial dcl 3-35
UNEXPANDED_PATH                        internal static fixed bin(17,0)          initial dcl 3-34
WORKING_DIR                            internal static fixed bin(17,0)          initial dcl 3-36
arg_list                               based           structure                level 1 dcl 5-14
arg_list_with_envptr                   based           structure                level 1 dcl 5-42
command_name_arglist                   based           structure                level 1 dcl 5-25
help_                           000000 constant        entry                    external dcl 6-160
help_$check_info_segs           000000 constant        entry                    external dcl 7-71
help_$init                      000000 constant        entry                    external dcl 6-160
sl_control                             automatic       bit(36)                  packed unaligned dcl 4-12
sl_control_s                           based           structure                level 1 packed packed unaligned dcl 4-3
sl_info_num_paths                      automatic       fixed bin(17,0)          dcl 3-27
star_ALL_ENTRIES_WITH_LINK_PATHS       internal static fixed bin(3,0)           initial dcl 1-114
star_BRANCHES_ONLY                     internal static fixed bin(2,0)           initial dcl 1-110
star_DIRECTORY                         internal static fixed bin(2,0)           initial unsigned dcl 1-121
star_LINKS_ONLY                        internal static fixed bin(2,0)           initial dcl 1-109
star_entries                           based           structure                array level 1 dcl 1-27
star_entry_count                       automatic       fixed bin(17,0)          dcl 1-14
star_entry_ptr                         automatic       pointer                  dcl 1-15
star_link_pathname                     based           char                     packed unaligned dcl 1-102
star_linkx                             automatic       fixed bin(17,0)          dcl 1-18
star_list_branch                       based           structure                array level 1 dcl 1-41
star_names                             based           char(32)                 array packed unaligned dcl 1-37
star_names_ptr                         automatic       pointer                  dcl 1-19
status_area_ptr                        automatic       pointer                  dcl 2-47
status_entry_names                     based           char(32)                 array dcl 2-47
status_link                            based           structure                level 1 dcl 2-38
status_pathname                        based           char                     dcl 2-47
status_ptr                             automatic       pointer                  dcl 2-47

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK                           000000 constant        label                    array(0:1) dcl 393 ref 390
COMMON                          001047 constant        label                    dcl 290 ref 282
DIR_ERROR                       005603 constant        label                    dcl 835 ref 827
END_CHECK                       002172 constant        label                    dcl 416 ref 403
ERROR                           007265 constant        label                    dcl 1083 ref 1094 1109 1124 1126 1133
EXIT_LOOP                       003010 constant        label                    dcl 508
INIT_ERROR                      002470 constant        label                    dcl 484 ref 491 497
MATCH                           007054 constant        label                    dcl 1005 ref 992 998
NEXT_INFO                       003006 constant        label                    dcl 506 ref 480 488
NO_MATCH                        007020 constant        label                    dcl 1000 ref 914 917 935
PROCESS                         002442 constant        label                    dcl 474 ref 467
QUIT                            003015 constant        label                    dcl 511 ref 523
SKIP_ELIMINATION                002214 constant        label                    dcl 423 ref 388
SKIP_ENTRY                      005243 constant        label                    dcl 778 ref 754 769
abort_help_subr                 003553 constant        entry                    internal dcl 520 ref 546 546
check_info_segs                 001020 constant        entry                    external dcl 285
error                           003564 constant        entry                    internal dcl 530 ref 484 502 835 859
evaluate_path                   003767 constant        entry                    internal dcl 562 ref 315
find_info_name                  007220 constant        entry                    internal dcl 1052 ref 909 1004
get_info_seg_list               004452 constant        entry                    internal dcl 652 ref 350 352
help_                           000762 constant        entry                    external dcl 94
init                            003030 constant        entry                    external dcl 1322
initiate                        007605 constant        entry                    internal dcl 1155 ref 490 866
janitor                         010073 constant        entry                    internal dcl 1224 ref 345 357 511
numeric_date                    010225 constant        entry                    internal dcl 1245 ref 719 736 805
rel_char                        010242 constant        entry                    internal dcl 1265 ref 941
set_space_used                  010307 constant        entry                    internal dcl 1291 ref 340 347 364 462 1362
term                            003444 constant        entry                    external dcl 1389
term_assoc_mem                  010325 constant        entry                    internal dcl 1308 ref 457 1227

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     12166       12304   11442       12176
Length     12736   11442       116         416     524           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
help_                               374 external procedure  is an external procedure.  
on unit on line 345                  64 on unit               
on unit on line 468                  64 on unit               
abort_help_subr                      64 internal procedure  is assigned to an entry variable.  
error                               120 internal procedure  is declared options(variable).  
evaluate_path                           internal procedure  shares stack frame of external procedure help_.  
get_info_seg_list                 25236 internal procedure  is declared options(non_quick).  
find_info_name                          internal procedure  shares stack frame of internal procedure get_info_seg_list.  
initiate                            102 internal procedure  is called by several nonquick procedures.  
janitor                              92 internal procedure  is called by several nonquick procedures.  
numeric_date                            internal procedure  shares stack frame of internal procedure get_info_seg_list.  
rel_char                                internal procedure  shares stack frame of internal procedure get_info_seg_list.  
set_space_used                          internal procedure  shares stack frame of external procedure help_.  
term_assoc_mem                       74 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
error                    000100 code                        error
get_info_seg_list        000100 I                           get_info_seg_list
                         000101 Lline                       get_info_seg_list
                         000102 Lseg                        get_info_seg_list
                         000103 Nstart                      get_info_seg_list
                         000104 Pseg                        get_info_seg_list
                         000106 Ptemp                       get_info_seg_list
                         000110 area                        get_info_seg_list
                         060760 code                        get_info_seg_list
                         060761 i                           get_info_seg_list
                         060762 j                           get_info_seg_list
                         060763 k                           get_info_seg_list
                         060764 l                           get_info_seg_list
                         060765 linfo_name                  get_info_seg_list
                         060775 sinfo_name                  get_info_seg_list
                         061006 saved_date                  get_info_seg_list
                         061010 star_branch_count           get_info_seg_list
                         061012 star_list_branch_ptr        get_info_seg_list
                         061014 star_link_count             get_info_seg_list
                         061016 star_list_names_ptr         get_info_seg_list
                         061020 star_select_sw              get_info_seg_list
                         061021 branch                      get_info_seg_list
                         061046 info_name                   find_info_name
                         061057 Icolon                      find_info_name
                         061060 Inon_space                  find_info_name
                         061061 Iquote                      find_info_name
                         061062 Iquote_quote                find_info_name
                         061063 Lline                       find_info_name
                         061064 Pline                       find_info_name
                         061074 num_date                    numeric_date
                         061104 I                           rel_char
                         061106 P1                          rel_char
                         061110 i                           rel_char
help_                    000100 Lseg                        help_
                         000101 Ninfos_printed              help_
                         000102 Nlast_info_cross_ref        help_
                         000103 Nlast_info_no_brief_data    help_
                         000104 PI_LABEL                    help_
                         000110 PDeps                       help_
                         000112 PDinfo                      help_
                         000114 Pinit_assoc_mem             help_
                         000116 Pnext_free_space            help_
                         000120 Pquery_answers              help_
                         000122 Pseg                        help_
                         000124 Ptemp                       help_
                         000126 Sprint_inhibit              help_
                         000127 Sstandalone_invocation      help_
                         000136 code                        help_
                         000137 fcn                         help_
                         000140 i                           help_
                         000141 j                           help_
                         000142 offset                      help_
                         000152 Parea                       help_
                         000154 sl_info_p                   help_
                         000156 PPDinfo_seg                 help_
                         000160 PDinfo_seg_                 help_
                         000206 i                           evaluate_path
                         000216 Pnext_space                 set_space_used
initiate                 000100 i                           initiate
                         000101 Iempty                      initiate

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              r_ne_as             r_ge_a              alloc_char_temp     alloc_temp
cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this       call_int_other_desc
call_int_other      return_mac          move_label_var      make_label_var      tra_ext_1           tra_ext_2
bound_ck_signal     mpfx2               mdfx1               enable_op           shorten_stack       ext_entry_desc
int_entry           int_entry_desc      reverse_cs          set_chars_eis       index_chars_eis     op_freen_
op_empty_           ix_rev_chars

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
check_star_name_$entry        com_err_                      convert_date_to_binary_       cu_$arg_list_ptr
cu_$generate_call             expand_pathname_$add_suffix   get_temp_segment_             hcs_$get_uid_seg
hcs_$initiate                 hcs_$star_dir_list_           hcs_$status_long              hcs_$terminate_noname
hcs_$truncate_seg             help_$term                    help_rql_                     match_star_name_
pathname_$component           release_temp_segment_         search_paths_$get             sort_items_$bit
sort_items_$char              ssu_$destroy_invocation       ssu_$print_message            ssu_$standalone_invocation

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badsyntax        error_table_$inconsistent     error_table_$incorrect_access error_table_$moderr
error_table_$no_info          error_table_$no_s_permission  error_table_$noarg            error_table_$noentry
error_table_$nomatch          error_table_$unimplemented_version                          error_table_$zero_length_seg




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     94 000755       281 001007       282 001011       285 001012       288 001045       290 001047       294 001052
    296 001060       297 001062       298 001065       300 001071       302 001075       303 001100       306 001101
    307 001103       309 001106       310 001111       312 001112       313 001113       314 001115       315 001125
    316 001212       318 001227       319 001231       322 001233       323 001236       324 001260       328 001262
    330 001264       331 001266       332 001267       333 001274       334 001301       335 001316       336 001320
    337 001327       338 001332       340 001334       343 001377       344 001400       345 001401       347 001423
    348 001432       349 001433       350 001445       352 001610       353 001724       354 001726       356 001730
    357 001733       358 001737       361 001740       364 001743       365 001754       366 001756       367 001761
    368 001767       369 001775       370 002001       373 002003       375 002006       377 002024       381 002037
    382 002057       383 002064       387 002066       388 002070       390 002073       393 002075       395 002105
    397 002116       398 002117       399 002124       400 002125       402 002131       403 002133       405 002134
    407 002145       409 002155       410 002156       411 002163       412 002164       414 002170       416 002172
    418 002173       419 002204       420 002206       421 002207       423 002214       426 002220       428 002235
    431 002250       432 002256       433 002273       434 002303       438 002320       440 002327       442 002331
    443 002333       446 002334       448 002337       449 002341       450 002342       452 002346       455 002367
    457 002372       458 002376       459 002401       462 002402       464 002413       465 002415       467 002416
    468 002421       470 002435       471 002440       474 002442       476 002443       478 002444       480 002457
    481 002462       482 002466       484 002470       488 002562       490 002563       491 002601       493 002605
    494 002610       496 002611       497 002614       500 002615       502 002712       506 003006       508 003010
    511 003015       513 003021      1322 003022      1337 003062      1339 003072      1340 003075      1342 003076
   1343 003120      1347 003125      1348 003131      1349 003134      1350 003137      1351 003142      1352 003144
   1353 003146      1354 003150      1355 003152      1356 003153      1357 003154      1358 003155      1360 003163
   1362 003165      1363 003223      1364 003226      1366 003275      1368 003277      1369 003304      1371 003366
   1372 003370      1373 003373      1374 003374      1375 003375      1377 003437      1389 003440      1392 003464
   1394 003470      1401 003477      1403 003526      1406 003551       520 003552       523 003560       530 003563
    540 003571       543 003577       545 003603       546 003605       548 003701       552 003733       555 003766
    562 003767       575 004000       576 004005       577 004010       578 004011       580 004030       582 004042
    586 004062       589 004104       591 004147       593 004155       596 004162       598 004166       600 004170
    602 004202       604 004233       605 004235       606 004237       607 004254       609 004260       610 004262
    614 004310       616 004346       617 004350       620 004354       621 004355       622 004357       626 004374
    628 004377       630 004402       634 004410       635 004425       637 004434       638 004435       639 004437
    640 004440       642 004442       643 004443       645 004450       652 004451       665 004473       695 004476
    697 004502       699 004516       700 004520       702 004610       704 004613       706 004624       707 004632
    708 004635       709 004654       710 004672       711 004676       712 004707       713 004714       716 004722
    718 004730       719 004735       720 004746       722 004762       723 004764       725 004773       727 005006
    728 005007       730 005011       731 005060       733 005066       735 005073       736 005103       737 005114
    738 005125       739 005127       741 005135       743 005146       744 005147       746 005151       747 005156
    748 005160       749 005162       750 005165       753 005166       754 005172       757 005173       760 005174
    761 005201       762 005203       763 005205       765 005207       768 005210       769 005212       771 005213
    775 005237       776 005240       778 005243       781 005246       784 005314       786 005315       789 005327
    790 005375       792 005404       794 005410       795 005417       796 005422       797 005430       798 005436
    799 005442       800 005451       801 005456       802 005463       804 005470       805 005474       806 005505
    807 005516       809 005526       810 005532       812 005540       814 005552       817 005564       820 005565
    821 005566       822 005570       823 005572       826 005574       827 005575       830 005577       831 005600
    835 005603       837 005644       840 005656       842 005661       844 005665       845 005700       847 005707
    848 005711       849 005712       851 005716       852 005720       854 005721       856 005725       858 005735
    859 005740       860 006003       861 006004       863 006014       865 006023       866 006025       867 006045
    869 006051       870 006062       872 006064       874 006100       876 006102       877 006106       879 006112
    883 006132       885 006134       886 006140       887 006142       890 006143       891 006147       893 006151
    894 006153       897 006161       900 006163       901 006164       902 006167       904 006171       905 006174
    907 006206       909 006211       910 006235       911 006240       913 006245       914 006270       916 006273
    917 006274       920 006302       927 006307       929 006361       932 006367       934 006373       935 006445
    938 006451       940 006464       941 006503       945 006532       949 006541       954 006552       956 006562
    957 006570       958 006576       959 006603       960 006605       962 006620       964 006622       965 006626
    966 006632       967 006644       970 006647       975 006660       976 006662       977 006675       981 006701
    982 006735       985 006747       986 006750       987 006753       988 006755       989 006756       992 006764
    994 006775       996 007002       997 007006       998 007017      1000 007020      1002 007024      1003 007026
   1004 007030      1005 007054      1008 007055      1012 007064      1014 007065      1015 007071      1016 007076
   1019 007077      1023 007106      1025 007107      1026 007113      1027 007120      1028 007121      1030 007122
   1031 007123      1033 007127      1036 007147      1037 007160      1040 007164      1041 007165      1044 007176
   1046 007206      1047 007210      1048 007211      1050 007215      1148 007217      1052 007220      1073 007232
   1074 007235      1075 007236      1076 007250      1078 007252      1079 007256      1080 007262      1081 007263
   1083 007265      1085 007271      1088 007276      1090 007302      1092 007305      1093 007307      1094 007321
   1097 007325      1099 007336      1103 007353      1104 007354      1105 007360      1106 007374      1107 007401
   1108 007406      1109 007420      1111 007424      1112 007435      1113 007436      1115 007454      1116 007461
   1117 007465      1119 007500      1121 007502      1122 007506      1123 007512      1124 007513      1126 007515
   1129 007530      1132 007531      1133 007543      1135 007544      1136 007567      1138 007575      1155 007604
   1168 007612      1169 007613      1170 007615      1171 007617      1173 007634      1175 007643      1179 007651
   1180 007652      1182 007667      1183 007672      1185 007674      1186 007675      1188 007701      1189 007703
   1192 007710      1193 007753      1195 007760      1197 007773      1198 010012      1199 010014      1201 010020
   1204 010025      1205 010026      1206 010030      1209 010031      1210 010032      1212 010045      1213 010057
   1214 010064      1215 010066      1217 010071      1224 010072      1227 010100      1228 010105      1230 010150
   1233 010161      1234 010170      1237 010175      1240 010224      1245 010225      1256 010230      1257 010232
   1258 010237      1265 010242      1277 010245      1278 010252      1279 010260      1280 010277      1281 010301
   1282 010303      1291 010307      1300 010311      1301 010322      1308 010324      1311 010332      1312 010343
   1314 010363      1315 010366


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
