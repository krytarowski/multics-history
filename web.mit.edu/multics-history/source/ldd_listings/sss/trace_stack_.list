	COMPILATION LISTING OF SEGMENT trace_stack_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/05/86  1041.3 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* format: style4,delnl,insnl,tree,ifthenstmt,indnoniterend */
       12 trace_stack_:
       13      procedure (stackp, mode, depth, stream);
       14 
       15 /* TRACE_STACK_ - Subroutine to produce debugging output on console.
       16*   1. explanation of fault
       17*   2. source line which caused fault (if determinable, otherwise faulting instruction)
       18*   3. machine registers at time of fault
       19*   4. listing of stack frames, in reverse order from faulting frame.
       20*   4.a. segment name and entry point name
       21*   4.b. source line or instruction
       22*   4.c. arguments to stack frame
       23*   4.d. enabled on-units
       24*   4.e. octal dump of frame
       25*
       26*   The original idea for this program came from a remark of Bob Daley's.
       27*   This program owes a great deal to Steve Webber, Melanie Weaver, and Barry Wolman.
       28*   THVV 7/70 */
       29 /**** Modified 1985-01-15, BIM: pass signal_io_, max number of errors permitted. */
       30 /**** Modified 1985-03-06, BIM: added subroutine that does history regs. */
       31 
       32 dcl  stackp ptr,					/* ptr to highest frame to trace from */
       33      mode fixed bin,				/* output mode */
       34      depth fixed bin,				/* number of frames to trace */
       35      stream char (32) aligned;			/* output stream */
       36 
       37 dcl  ilc uns fixed bin (18),				/* offset from top of segment where instruction is */
       38      (max_depth, cur_depth) fixed bin (17),
       39      target_sp ptr,
       40      argl fixed bin,
       41      gptr ptr,					/* pointer for octal dump */
       42      ec fixed bin (35),
       43      line_no char (16),
       44      strp ptr;					/* pointer to stuff for interpret_ptr_ */
       45 dcl  fault_count fixed bin;
       46 dcl  abort_label label variable;
       47 dcl  ssptr pointer;
       48 dcl  a_hr_switch fixed bin;
       49 dcl  hr_switch fixed bin;
       50 dcl  iocb ptr;
       51 
       52 dcl  (
       53      NO_HREGS init (0),
       54      HREGS init (1),
       55      HREGS_LONG init (2)
       56      ) fixed bin int static options (constant);
       57 
       58 dcl  MAX_FAULT_COUNT fixed bin init (4000) int static options (constant);
       59 
       60 dcl  (addr, addrel, binary, fixed, hbound, lbound, null, ptr, rel, stackframeptr) builtin;
       61 
       62 dcl  (any_other, cleanup) condition;
       63 
       64 dcl  dumary (8) fixed bin based (gptr);
       65 
       66 dcl  1 condinfo aligned like condition_info;
       67 
       68 dcl  print_source_line_ entry (ptr, char (32) aligned),
       69      find_source_line_ entry (ptr, char (*), char (*), char (*), fixed bin (21), fixed bin (21), fixed bin (35)),
       70      is_condition_frame_ entry (ptr) returns (bit (1) aligned),
       71      find_condition_info_ entry (ptr, ptr, fixed bin (35)),
       72      dump_machine_cond_ entry (ptr, ptr, char (32) aligned, fixed bin),
       73      interpret_ptr_$frame_owner entry (ptr, ptr, ptr),
       74      list_frame_args_ entry (ptr, char (32) aligned),
       75      list_onunits_ entry (ptr, char (32) aligned),
       76      ioa_$ioa_stream entry options (variable);
       77 dcl  condition_interpreter_ entry (ptr, ptr, fixed bin (21), fixed bin, ptr, char (*), ptr, ptr);
       78 dcl  continue_to_signal_ entry (fixed bin (35));
       79 dcl  get_system_free_area_ entry () returns (ptr);
       80 dcl  hran_$hranl entry (pointer, pointer, bit (1));
       81 dcl  iox_$find_iocb entry (char (*), ptr, fixed bin (35));
       82 
       83 
       84 	hr_switch = NO_HREGS;
       85 	go to COMMON;
       86 
       87 hregs:
       88      entry (stackp, mode, depth, stream, a_hr_switch);
       89 
       90 	hr_switch = a_hr_switch;
       91 COMMON:
       92 	iocb = null ();
       93 	call iox_$find_iocb ((stream), iocb, (0));
       94 	condinfo.version = 1;
       95 	sp, target_sp = stackp;			/* copy argument - initial stack level */
       96 	if sp = null () then sp, target_sp = stackframeptr ();
       97 	max_depth = depth;
       98 	if max_depth < 0 then max_depth = 100000;
       99 	strp = addr (strbuf);
      100 
      101 	abort_label = abort_trace;
      102 	on any_other call fault_handler;
      103 	fault_count = 0;
      104 
      105 /* This section is the actual back-trace loop on the stack.
      106*   For each frame, we call "interpret_ptr_$frame_owner" to find the owner of the frame,
      107*   and then "print_source_line_" to attempt to print the source line, or the faulting instruction.
      108*   Then we call "list_frame_args_" to list the arguments to the frame. */
      109 
      110 	do cur_depth = 0 to max_depth while (sp ^= null ());
      111 	     condinfo.mc_ptr, condinfo.user_loc_ptr = null ();
      112 	     condinfo.condition_name = "";
      113 	     struc.segment, struc.entryn = "?";
      114 	     struc.offset, struc.comment, struc.opname = "";
      115 	     line_no = "";
      116 
      117 	     abort_label = no_mc;
      118 	     if is_condition_frame_ (sp) then do;
      119 		call find_condition_info_ (sp, addr (condinfo), ec);
      120 		call dump_machine_cond_ (addr (condinfo), sp, stream, mode);
      121 		if condinfo.mc_ptr ^= null & hr_switch >= HREGS then do;
      122 		     ssptr = addwordno (condinfo.mc_ptr, -8);
      123 						/* see signaller_stack.incl.pl1 */
      124 		     if hr_switch = HREGS
      125 		     then call hran_$hranl (addr (ssptr -> signaller_stack.history_registers), iocb, "0"b);
      126 		     if hr_switch = HREGS_LONG
      127 		     then call hran_$hranl (addr (ssptr -> signaller_stack.history_registers), iocb, "1"b);
      128 		     end;
      129 		end;
      130 no_mc:
      131 	     if cur_depth < max_depth then do;
      132 		abort_label = no_ilc;
      133 		if condinfo.mc_ptr = null () then do;
      134 		     ilc = binary (rel (stack_frame.return_ptr), 18);
      135 		     if ilc > 0 then ilc = ilc - 1;	/* Get call-out location. */
      136 		     condinfo.user_loc_ptr = ptr (stack_frame.return_ptr, ilc);
      137 						/* STCD info is not a pointer */
      138 		     end;
      139 
      140 no_ilc:
      141 		abort_label = no_owner;
      142 		call interpret_ptr_$frame_owner (condinfo.user_loc_ptr, sp, strp);
      143 		call find_source_line_ (strp, line_no, (""), (""), (0), (0), ec);
      144 no_owner:
      145 		abort_label = no_brief;
      146 		call ioa_$ioa_stream (stream, "^p^13t^a^a|^a ^a ^a ^a", target_sp, struc.segment, struc.entryn,
      147 		     struc.offset, struc.comment, line_no, struc.opname);
      148 
      149 no_brief:
      150 		if mode > 0 then do;
      151 		     abort_label = no_source;
      152 		     if struc.text_ptr ^= null ()	/* skip source if looks bad. */
      153 		     then call print_source_line_ (strp, stream);
      154 no_source:
      155 		     abort_label = no_args;
      156 		     call list_frame_args_ (sp, stream);/* what are the arguments */
      157 no_args:
      158 		     abort_label = no_units;
      159 		     call list_onunits_ (sp, stream);	/* what handlers */
      160 
      161 /* This next section of code dumps the stack frame in octal.
      162*   Useful only under an "fo", I think. */
      163 
      164 no_units:
      165 		     if mode > 1 then do;
      166 			abort_label = no_long;
      167 			gptr = sp;		/* yes. */
      168 			argl = 0;
      169 			do while (rel (gptr) < rel (stack_frame.next_sp));
      170 						/* loop through 8 words at a time */
      171 			     call ioa_$ioa_stream (stream, "^6o ^5o ^w ^w ^w ^w ^w ^w ^w ^w",
      172 				fixed (rel (gptr), 18), argl, dumary);
      173 			     argl = argl + 8;
      174 			     gptr = addrel (gptr, 8);
      175 			end;
      176 			end;
      177 no_long:
      178 		     abort_label = next_frame;
      179 		     call ioa_$ioa_stream (stream, "");
      180 		     end;
      181 		end;
      182 next_frame:
      183 	     abort_label = abort_trace;
      184 	     sp, target_sp = sp -> stack_frame.prev_sp;
      185 	end;
      186 	return;
      187 
      188 
      189 abort_trace:
      190 	revert any_other;				/* If we gave up, we gave up */
      191 	call ioa_$ioa_stream (stream, "Trace aborted.");
      192 	return;
      193 
      194 fault_handler:
      195      procedure;
      196 
      197 dcl  m_ptr ptr;
      198 dcl  m_len fixed bin (21);
      199 dcl  msg char (m_len) based (m_ptr);
      200 
      201 dcl  i fixed bin;
      202 dcl  code fixed bin (35);
      203 dcl  1 ci aligned like condition_info;
      204 
      205 dcl  continue_conditions (14) char (32) static options (constant)
      206 	init ("endpage", "stringsize", "underflow", "command_error", "finish", "command_question", "trm_", "sus_",
      207 	"cput", "alrm", "wkp_", "mme2", "quit", "signal_io_");
      208 
      209 	m_ptr = null ();
      210 	on cleanup
      211 	     begin;
      212 	     if m_ptr ^= null () then do;
      213 		free msg;
      214 		m_ptr = null ();
      215 		end;
      216 	end;
      217 	on any_other goto abort_trace;
      218 	fault_count = fault_count + 1;
      219 	if fault_count > MAX_FAULT_COUNT then goto abort_trace;
      220 
      221 	call find_condition_info_ (null (), addr (ci), code);
      222 	if code ^= 0 then do;
      223 continue:
      224 	     call continue_to_signal_ ((0));
      225 	     return;
      226 	     end;
      227 
      228 	if ci.condition_name = "cleanup" then return;
      229 	do i = lbound (continue_conditions, 1) to hbound (continue_conditions, 1);
      230 	     if ci.condition_name = continue_conditions (i) then goto continue;
      231 	end;
      232 
      233 	call ioa_$ioa_stream (stream, "^a condition during trace...", ci.condition_name);
      234 	call condition_interpreter_ (get_system_free_area_ (), m_ptr, m_len, 1, ci.mc_ptr, (ci.condition_name),
      235 	     ci.wc_ptr, ci.info_ptr);
      236 	call ioa_$ioa_stream (stream, "^a", msg);
      237 	free msg;
      238 	goto abort_label;
      239 
      240      end fault_handler;
      241 
  1     1 /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
  1     2 
  1     3 /* format: off */
  1     4 
  1     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
  1     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
  1     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
  1     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
  1     9 
  1    10 
  1    11 /****^  HISTORY COMMENTS:
  1    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
  1    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
  1    14*     Modified to add constants for the translator_id field in the stack_frame
  1    15*     structure.
  1    16*                                                   END HISTORY COMMENTS */
  1    17 
  1    18 
  1    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
  1    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
  1    21 						/* with indicators (nonzero for Fortran hexfp caller) */
  1    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
  1    23 
  1    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
  1    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
  1    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
  1    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
  1    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
  1    29 
  1    30 
  1    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
  1    32 
  1    33 dcl  stack_frame_min_length fixed bin static init(48);
  1    34 
  1    35 
  1    36 dcl 1 stack_frame based(sp) aligned,
  1    37     2 pointer_registers(0 : 7) ptr,
  1    38     2 prev_sp pointer,
  1    39     2 next_sp pointer,
  1    40     2 return_ptr pointer,
  1    41     2 entry_ptr pointer,
  1    42     2 operator_and_lp_ptr ptr,			/* serves as both */
  1    43     2 arg_ptr pointer,
  1    44     2 static_ptr ptr unaligned,
  1    45     2 support_ptr ptr unal, /* only used by fortran I/O */
  1    46     2 on_unit_relp1 bit(18) unaligned,
  1    47     2 on_unit_relp2 bit(18) unaligned,
  1    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
  1    49*						   0 => PL/I version II
  1    50*						   1 => ALM
  1    51*						   2 => PL/I version I   
  1    52*						   3 => signal caller frame
  1    53*						   4 => signaller frame */
  1    54     2 operator_return_offset bit(18) unaligned,
  1    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
  1    56     2 a bit(36),					/* accumulator */
  1    57     2 q bit(36),					/* q-register */
  1    58     2 e bit(36),					/* exponent */
  1    59     2 timer bit(27) unaligned,				/* timer */
  1    60     2 pad bit(6) unaligned,
  1    61     2 ring_alarm_reg bit(3) unaligned;
  1    62 
  1    63 
  1    64 dcl 1 stack_frame_flags based(sp) aligned,
  1    65     2 pad(0 : 7) bit(72),				/* skip over prs */
  1    66     2 xx0 bit(22) unal,
  1    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
  1    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
  1    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
  1    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
  1    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
  1    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
  1    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
  1    74     2 condition bit(1) unal,				/* on if condition established in this frame */
  1    75     2 xx0a bit(6) unal,
  1    76     2 xx1 fixed bin,
  1    77     2 xx2 fixed bin,
  1    78     2 xx3 bit(25) unal,
  1    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
  1    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
  1    81     2 xx3a bit(9) unaligned,
  1    82     2 xx4(9) bit(72) aligned,
  1    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
  1    84*						*  operator puts a pointer to the base of
  1    85*						*  the calling procedure here. (text base ptr)  */
  1    86     2 xx5 bit(72) aligned,
  1    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
  1    88 
  1    89 /* format: on */
  1    90 
  1    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
      242 
  2     1 /* BEGIN INCLUDE FILE ... interpret_ptr_struc.incl.pl1 */
  2     2 
  2     3 dcl 1 struc based (strp) aligned,			/* This useful structure is in trace_stack pgms */
  2     4     2 comment char (64),				/* name of boundseg, or thing pointed to, or .. */
  2     5     2 segment char (32),				/* name of segment, or segment number with # */
  2     6     2 entryn char (33),				/* entry name, preceded by $, or blank */
  2     7     2 offset char (6),				/* offset in segment, or blank */
  2     8     2 opname char (32),				/* may be pl1 operator name */
  2     9     2 ring char (1) unal,				/* ring number of ptr */
  2    10     2 std_flag bit (1) unal,				/* TRUE if std object. */
  2    11     2 xpad bit (26) unal,
  2    12     2 bitoff char (4),				/* bit offset */
  2    13     2 modifier char (8),				/* ptr modifier, or special code like "noaccess" */
  2    14     2 symbolp ptr,					/* ptr to symbol section */
  2    15     2 instruction_counter fixed bin,			/* binary instruction counter */
  2    16     2 sourcemap fixed bin,				/* source map offset in symbol section */
  2    17     2 compiler char (8),				/* name of compiler */
  2    18     2 text_ptr ptr,					/* ptr to segment text */
  2    19     2 stack_ptr ptr;				/* ptr to stack frame */
  2    20 
  2    21 dcl 1 strbuf aligned like struc;			/* If referenced, will make storage for struc */
  2    22 
  2    23 /* END INCLUDE FILE ... interpret_ptr_struc.incl.pl1 */
      243 
  3     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  3     2 
  3     3 /* Structure for find_condition_info_.
  3     4*
  3     5*   Written 1-Mar-79 by M. N. Davidoff.
  3     6**/
  3     7 
  3     8 /* automatic */
  3     9 
  3    10      declare condition_info_ptr     pointer;
  3    11 
  3    12 /* based */
  3    13 
  3    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  3    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  3    16 	     2 version	      fixed binary,		/* Must be 1 */
  3    17 	     2 condition_name     char (32) varying,	/* name of condition */
  3    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  3    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  3    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  3    21 	     2 flags	      unaligned,
  3    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  3    23 	       3 pad1	      bit (35),
  3    24 	     2 pad2	      bit (36),
  3    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  3    26 	     2 pad3	      (4) bit (36);
  3    27 
  3    28 /* internal static */
  3    29 
  3    30      declare condition_info_version_1
  3    31 			      fixed binary internal static options (constant) initial (1);
  3    32 
  3    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
      244 
  4     1 /*	BEGIN INCLUDE FILE ... signaller_stack.incl.pl1 ... Created Feb 79 by D.Spector */
  4     2 
  4     3 /*	This file matches signaller_stack.incl.alm and is currently used only by verify_lock */
  4     4 
  4     5 declare	1 signaller_stack based unaligned,
  4     6 	  2 pad (8) bit (36),		/* Make machine conditions 0 mod 16 */
  4     7 	  2 mach_cond (48) bit (36),		/* Machine conditions */
  4     8 	  2 mc_ptr ptr aligned,		/* Pointer to machine conditions */
  4     9 	  2 null_ptr ptr aligned,		/* Null pointer */
  4    10 	  2 string_descriptor bit (36),	/* Condition name descriptor */
  4    11 	  2 ptr_descriptor bit (36),		/* M.C. ptr descriptor */
  4    12 	  2 arglist (18) bit (36),		/* Arg list for call to signal */
  4    13 	  2 signal_string char (32),		/* Condition name */
  4    14 	  2 on_unit (16) bit (36),		/* Must be at 128 in stack frame */
  4    15 	  2 history_registers (128) bit (36);
  4    16 
  4    17 /* on_unit must start at 128 because trap_caller_caller_ sets up a stack frame
  4    18*   assuming this to be so.  Similarly mach_cond must start at 48. */
  4    19 
  4    20 /*	END INCLUDE FILE ... signaller_stack.incl.pl1 ... */
      245 
      246 
      247      end trace_stack_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/86  1041.7  trace_stack_.pl1                  >special_ldd>install>MR12.0-1206>trace_stack_.pl1
242          1    11/03/86  1114.7  stack_frame.incl.pl1              >special_ldd>install>MR12.0-1206>stack_frame.incl.pl1
243          2    06/11/74  0602.3  interpret_ptr_struc.incl.pl1      >ldd>include>interpret_ptr_struc.incl.pl1
244          3    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
245          4    03/08/79  1715.0  signaller_stack.incl.pl1          >ldd>include>signaller_stack.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
HREGS                                  constant        fixed bin(17,0)          initial dcl 52 ref 121 124
HREGS_LONG                             constant        fixed bin(17,0)          initial dcl 52 ref 126
MAX_FAULT_COUNT                        constant        fixed bin(17,0)          initial dcl 58 ref 219
NO_HREGS                               constant        fixed bin(17,0)          initial dcl 52 ref 84
a_hr_switch                            parameter       fixed bin(17,0)          dcl 48 ref 87 90
abort_label                     000124 automatic       label variable           dcl 46 set ref 101* 117* 132* 140* 144* 151* 154*
                                                                                  157* 166* 177* 182* 238
addr                                                   builtin function         dcl 60 ref 99 119 119 120 120 124 124 126 126 221
                                                                                  221
addrel                                                 builtin function         dcl 60 ref 174
any_other                       000136 stack reference condition                dcl 62 ref 102 189 217
argl                            000106 automatic       fixed bin(17,0)          dcl 37 set ref 168* 171* 173* 173
binary                                                 builtin function         dcl 60 ref 134
ci                              000106 automatic       structure                level 1 dcl 203 set ref 221 221
cleanup                         000000 stack reference condition                dcl 62 ref 210
code                            000104 automatic       fixed bin(35,0)          dcl 202 set ref 221* 222
comment                                based           char(64)                 level 2 dcl 2-3 set ref 114* 146*
condinfo                        000144 automatic       structure                level 1 dcl 66 set ref 119 119 120 120
condition_info                         based           structure                level 1 dcl 3-14
condition_interpreter_          000032 constant        entry                    external dcl 77 ref 234
condition_name            3     000144 automatic       varying char(32)         level 2 in structure "condinfo" dcl 66 in procedure
                                                                                  "trace_stack_" set ref 112*
condition_name            3     000106 automatic       varying char(32)         level 2 in structure "ci" dcl 203 in procedure
                                                                                  "fault_handler" set ref 228 230 233* 234
continue_conditions             000000 constant        char(32)                 initial array unaligned dcl 205 ref 229 229 230
continue_to_signal_             000034 constant        entry                    external dcl 78 ref 223
cur_depth                       000102 automatic       fixed bin(17,0)          dcl 37 set ref 110* 130*
depth                                  parameter       fixed bin(17,0)          dcl 32 ref 12 87 97
dumary                                 based           fixed bin(17,0)          array dcl 64 set ref 171*
dump_machine_cond_              000020 constant        entry                    external dcl 68 ref 120
ec                              000112 automatic       fixed bin(35,0)          dcl 37 set ref 119* 143*
entryn                   30            based           char(33)                 level 2 dcl 2-3 set ref 113* 146*
fault_count                     000122 automatic       fixed bin(17,0)          dcl 45 set ref 103* 218* 218 219
find_condition_info_            000016 constant        entry                    external dcl 68 ref 119 221
find_source_line_               000012 constant        entry                    external dcl 68 ref 143
fixed                                                  builtin function         dcl 60 ref 171 171
get_system_free_area_           000036 constant        entry                    external dcl 79 ref 234 234
gptr                            000110 automatic       pointer                  dcl 37 set ref 167* 169 171 171 171 174* 174
hbound                                                 builtin function         dcl 60 ref 229
history_registers       150            based           bit(36)                  array level 2 packed unaligned dcl 4-5 set ref 124
                                                                                  124 126 126
hr_switch                       000132 automatic       fixed bin(17,0)          dcl 49 set ref 84* 90* 121 124 126
hran_$hranl                     000040 constant        entry                    external dcl 80 ref 124 126
i                               000103 automatic       fixed bin(17,0)          dcl 201 set ref 229* 230*
ilc                             000100 automatic       fixed bin(18,0)          unsigned dcl 37 set ref 134* 135 135* 135 136
info_ptr                 14     000106 automatic       pointer                  level 2 dcl 203 set ref 234*
interpret_ptr_$frame_owner      000022 constant        entry                    external dcl 68 ref 142
ioa_$ioa_stream                 000030 constant        entry                    external dcl 68 ref 146 171 179 191 233 236
iocb                            000134 automatic       pointer                  dcl 50 set ref 91* 93* 124* 126*
iox_$find_iocb                  000042 constant        entry                    external dcl 81 ref 93
is_condition_frame_             000014 constant        entry                    external dcl 68 ref 118
lbound                                                 builtin function         dcl 60 ref 229
line_no                         000113 automatic       char(16)                 unaligned dcl 37 set ref 115* 143* 146*
list_frame_args_                000024 constant        entry                    external dcl 68 ref 156
list_onunits_                   000026 constant        entry                    external dcl 68 ref 159
m_len                           000102 automatic       fixed bin(21,0)          dcl 198 set ref 213 213 234* 236 236 237 237
m_ptr                           000100 automatic       pointer                  dcl 197 set ref 209* 212 213 214* 234* 236 237
max_depth                       000101 automatic       fixed bin(17,0)          dcl 37 set ref 97* 98 98* 110 130
mc_ptr                          000106 automatic       pointer                  level 2 in structure "ci" dcl 203 in procedure
                                                                                  "fault_handler" set ref 234*
mc_ptr                          000144 automatic       pointer                  level 2 in structure "condinfo" dcl 66 in procedure
                                                                                  "trace_stack_" set ref 111* 121 122 133
mode                                   parameter       fixed bin(17,0)          dcl 32 set ref 12 87 120* 149 164
msg                                    based           char                     unaligned dcl 199 set ref 213 236* 237
next_sp                  22            based           pointer                  level 2 dcl 1-36 ref 169
null                                                   builtin function         dcl 60 ref 91 96 110 111 121 133 152 209 212 214 221
                                                                                  221
offset                   41            based           char(6)                  level 2 dcl 2-3 set ref 114* 146*
opname                   43            based           char(32)                 level 2 dcl 2-3 set ref 114* 146*
prev_sp                  20            based           pointer                  level 2 dcl 1-36 ref 184
print_source_line_              000010 constant        entry                    external dcl 68 ref 152
ptr                                                    builtin function         dcl 60 ref 136
rel                                                    builtin function         dcl 60 ref 134 169 169 171 171
return_ptr               24            based           pointer                  level 2 dcl 1-36 ref 134 136
segment                  20            based           char(32)                 level 2 dcl 2-3 set ref 113* 146*
signaller_stack                        based           structure                level 1 unaligned dcl 4-5
sp                              000176 automatic       pointer                  dcl 1-31 set ref 95* 96 96* 110 118* 119* 120* 134
                                                                                  136 142* 156* 159* 167 169 184 184*
ssptr                           000130 automatic       pointer                  dcl 47 set ref 122* 124 124 126 126
stack_frame                            based           structure                level 1 dcl 1-36
stackframeptr                                          builtin function         dcl 60 ref 96
stackp                                 parameter       pointer                  dcl 32 ref 12 87 95
strbuf                          000200 automatic       structure                level 1 dcl 2-21 set ref 99
stream                                 parameter       char(32)                 dcl 32 set ref 12 87 93 120* 146* 152* 156* 159*
                                                                                  171* 179* 191* 233* 236*
strp                            000120 automatic       pointer                  dcl 37 set ref 99* 113 113 114 114 114 142* 143* 146
                                                                                  146 146 146 146 152 152*
struc                                  based           structure                level 1 dcl 2-3
target_sp                       000104 automatic       pointer                  dcl 37 set ref 95* 96* 146* 184*
text_ptr                 66            based           pointer                  level 2 dcl 2-3 ref 152
user_loc_ptr             24     000144 automatic       pointer                  level 2 dcl 66 set ref 111* 136* 142*
version                   2     000144 automatic       fixed bin(17,0)          level 2 dcl 66 set ref 94*
wc_ptr                   16     000106 automatic       pointer                  level 2 dcl 203 set ref 234*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
RETURN_PTR_MASK                        internal static bit(72)                  initial unaligned dcl 1-19
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial unaligned dcl 1-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial unaligned dcl 1-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial unaligned dcl 1-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial unaligned dcl 1-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial unaligned dcl 1-27
condition_info_ptr                     automatic       pointer                  dcl 3-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 3-30
stack_frame_flags                      based           structure                level 1 dcl 1-64
stack_frame_min_length                 internal static fixed bin(17,0)          initial dcl 1-33

NAMES DECLARED BY EXPLICIT CONTEXT.
COMMON                          000304 constant        label                    dcl 91 ref 85
abort_trace                     001171 constant        label                    dcl 189 ref 101 182 217 219
continue                        001331 constant        label                    dcl 223 ref 230
fault_handler                   001220 constant        entry                    internal dcl 194 ref 102
hregs                           000274 constant        entry                    external dcl 87
next_frame                      001157 constant        label                    dcl 182 ref 177
no_args                         001032 constant        label                    dcl 157 ref 154
no_brief                        000771 constant        label                    dcl 149 ref 144
no_ilc                          000633 constant        label                    dcl 140 ref 132
no_long                         001136 constant        label                    dcl 177 ref 166
no_mc                           000605 constant        label                    dcl 130 ref 117
no_owner                        000712 constant        label                    dcl 144 ref 140
no_source                       001015 constant        label                    dcl 154 ref 151
no_units                        001047 constant        label                    dcl 164 ref 157
trace_stack_                    000257 constant        entry                    external dcl 12

NAME DECLARED BY CONTEXT OR IMPLICATION.
addwordno                                              builtin function         ref 122

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2006        2052    1540        2016
Length      2356    1540        44         270     246           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
trace_stack_                        286 external procedure  is an external procedure.  
on unit on line 102                  64 on unit               
fault_handler                       170 internal procedure  enables or reverts conditions.  
on unit on line 210                  64 on unit               
on unit on line 217                  64 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
fault_handler            000100 m_ptr                       fault_handler
                         000102 m_len                       fault_handler
                         000103 i                           fault_handler
                         000104 code                        fault_handler
                         000106 ci                          fault_handler
trace_stack_             000100 ilc                         trace_stack_
                         000101 max_depth                   trace_stack_
                         000102 cur_depth                   trace_stack_
                         000104 target_sp                   trace_stack_
                         000106 argl                        trace_stack_
                         000110 gptr                        trace_stack_
                         000112 ec                          trace_stack_
                         000113 line_no                     trace_stack_
                         000120 strp                        trace_stack_
                         000122 fault_count                 trace_stack_
                         000124 abort_label                 trace_stack_
                         000130 ssptr                       trace_stack_
                         000132 hr_switch                   trace_stack_
                         000134 iocb                        trace_stack_
                         000144 condinfo                    trace_stack_
                         000176 sp                          trace_stack_
                         000200 strbuf                      trace_stack_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_other      return_mac          tra_ext_1
tra_ext_2           enable_op           shorten_stack       ext_entry           int_entry           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
condition_interpreter_        continue_to_signal_           dump_machine_cond_            find_condition_info_
find_source_line_             get_system_free_area_         hran_$hranl                   interpret_ptr_$frame_owner
ioa_$ioa_stream               iox_$find_iocb                is_condition_frame_           list_frame_args_
list_onunits_                 print_source_line_

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 000252        84 000264        85 000266        87 000267        90 000301        91 000304        93 000306
     94 000335        95 000337        96 000344        97 000355        98 000357        99 000362       101 000364
    102 000367       103 000411       110 000412       111 000425       112 000430       113 000431       114 000440
    115 000451       117 000454       118 000457       119 000473       120 000510       121 000530       122 000537
    124 000542       126 000562       130 000605       132 000610       133 000613       134 000617       135 000623
    136 000627       140 000633       142 000636       143 000651       144 000712       146 000715       149 000771
    151 000774       152 000777       154 001015       156 001020       157 001032       159 001035       164 001047
    166 001053       167 001056       168 001060       169 001061       171 001071       173 001130       174 001132
    175 001135       177 001136       179 001141       182 001157       184 001162       185 001166       186 001170
    189 001171       191 001172       192 001216       194 001217       209 001225       210 001227       212 001243
    213 001250       214 001255       216 001260       217 001261       218 001300       219 001302       221 001310
    222 001327       223 001331       225 001341       228 001342       229 001347       230 001355       231 001364
    233 001366       234 001414       236 001476       237 001527       238 001534


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
