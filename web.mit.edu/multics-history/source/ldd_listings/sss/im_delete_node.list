	COMPILATION LISTING OF SEGMENT im_delete_node
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  0955.7 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION:
        8*
        9*         This module is used to free a node from an index.
       10**/
       11 
       12 /* HISTORY:
       13*
       14*Written by Lindsey L. Spratt, 08/06/82.
       15*Modified:
       16*12/10/82 by Lindsey Spratt:  Updated to use version 2 of the index_cursor.
       17*12/13/82 by Lindsey Spratt:  Fixed wrong calling sequence of
       18*	  $free_control_interval, the zero_on_free argument was missing.
       19*02/28/83 by Lindsey Spratt:  Updated to use version 3 of the index_cursor.
       20*04/26/83 by Lindsey L. Spratt:  Fixed to update the "sibling" node CI pointers
       21*            in the preceding and following nodes of the node being deleted.
       22*04/27/83 by Lindsey L. Spratt:  Fixed to pass the correct buffer size to
       23*            $get_element.
       24*06/07/84 by Matthew Pierret:  Re-named cm_$get_element to cm_$get,
       25*            cm_$put_element to cm_$modify.  Switched the order of the
       26*            ci header length and ptr in the call to cm_$modify.
       27**/
       28 /* format: style2,ind3 */
       29 
       30 im_delete_node:
       31    proc (p_index_cursor_ptr, p_control_interval_id, p_code);
       32 
       33 /* START OF DECLARATIONS */
       34 /* Parameter */
       35 
       36       dcl	    p_index_cursor_ptr     ptr parameter;
       37       dcl	    p_control_interval_id  fixed bin (24) unsigned parameter;
       38       dcl	    p_code	       fixed bin (35) parameter;
       39 
       40 /* Automatic */
       41 
       42       dcl	    (ci_following_deleted_node, ci_preceding_deleted_node)
       43 			       fixed bin (24) unsigned unaligned;
       44       dcl	    local_ci_header_buffer bit (max (LEAF_CI_HEADER_LENGTH_IN_BITS, BRANCH_CI_HEADER_LENGTH_IN_BITS)) aligned;
       45 
       46 /* Based */
       47 /* Builtin */
       48 
       49       dcl	    null		       builtin;
       50 
       51 /* Constant */
       52 
       53       dcl	    DEFAULT_AREA_PTR       init (null) ptr internal static options (constant);
       54       dcl	    DEFAULT_ELEMENT_LENGTH init (-1) fixed bin (35) internal static options (constant);
       55 
       56       dcl	    myname	       init ("im_delete_node") char (14) internal static options (constant);
       57       dcl	    ZERO_ON_FREE	       init ("1"b) bit aligned internal static options (constant);
       58 
       59 /* Entry */
       60 
       61       dcl	    sub_err_	       entry () options (variable);
       62 
       63 /* External */
       64 
       65       dcl	    (
       66 	    error_table_$unimplemented_version,
       67 	    dm_error_$wrong_cursor_type
       68 	    )		       fixed bin (35) ext;
       69 
       70 /* END OF DECLARATIONS */
       71 
       72       index_cursor_ptr = p_index_cursor_ptr;
       73       if index_cursor.type ^= INDEX_CURSOR_TYPE
       74       then call
       75 	    sub_err_ (dm_error_$wrong_cursor_type, myname, "s", null, 0,
       76 	    "^/Expected an ""index"" type cursor (type ^d).  
       77 Received a cursor of type ^d instead.", INDEX_CURSOR_TYPE, index_cursor.type);
       78       call CHECK_VERSION ((index_cursor.version), (INDEX_CURSOR_VERSION_3), "index_cursor");
       79 
       80 
       81       common_ci_header_ptr = addr (local_ci_header_buffer);
       82       call GET_CI_HEADER ((p_control_interval_id), common_ci_header_ptr, p_code);
       83       if p_code ^= 0
       84       then return;
       85 
       86       ci_preceding_deleted_node = common_ci_header.previous_id;
       87       ci_following_deleted_node = common_ci_header.next_id;
       88 
       89       if ci_preceding_deleted_node > 0
       90       then
       91          do;
       92 	  call GET_CI_HEADER (ci_preceding_deleted_node, common_ci_header_ptr, p_code);
       93 	  if p_code ^= 0
       94 	  then return;
       95 	  common_ci_header.next_id = ci_following_deleted_node;
       96 	  call PUT_CI_HEADER (ci_preceding_deleted_node, common_ci_header_ptr, p_code);
       97 	  if p_code ^= 0
       98 	  then return;
       99          end;
      100 
      101       if ci_following_deleted_node > 0
      102       then
      103          do;
      104 	  call GET_CI_HEADER (ci_following_deleted_node, common_ci_header_ptr, p_code);
      105 	  if p_code ^= 0
      106 	  then return;
      107 	  common_ci_header.previous_id = ci_preceding_deleted_node;
      108 	  call PUT_CI_HEADER (ci_following_deleted_node, common_ci_header_ptr, p_code);
      109 	  if p_code ^= 0
      110 	  then return;
      111          end;
      112 
      113       call
      114          collection_manager_$free_control_interval (index_cursor.file_opening_id, index_cursor.collection_id,
      115          p_control_interval_id, ZERO_ON_FREE, p_code);
      116 
      117       return;
      118 
      119 GET_CI_HEADER:
      120    proc (p_control_interval_id, p_ci_header_ptr, p_code);
      121       dcl	    p_control_interval_id  fixed bin (24) unsigned unal;
      122       dcl	    p_ci_header_ptr	       ptr;
      123       dcl	    p_code	       fixed bin (35);
      124 
      125 
      126       element_id.control_interval_id = p_control_interval_id;
      127       element_id.index = DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT;
      128       p_code = 0;
      129 
      130       call
      131          collection_manager_$get (index_cursor.file_opening_id, index_cursor.collection_id, element_id_string, 0,
      132          p_ci_header_ptr, max (LEAF_CI_HEADER_LENGTH_IN_BITS, BRANCH_CI_HEADER_LENGTH_IN_BITS), DEFAULT_AREA_PTR, "0"b,
      133          p_ci_header_ptr, (0), p_code);
      134       if p_code ^= 0
      135       then return;
      136    end GET_CI_HEADER;
      137 
      138 PUT_CI_HEADER:
      139    proc (p_control_interval_id, p_ci_header_ptr, p_code);
      140       dcl	    p_control_interval_id  fixed bin (24) unsigned unal;
      141       dcl	    p_ci_header_ptr	       ptr;
      142       dcl	    p_code	       fixed bin (35);
      143 
      144 
      145       element_id.control_interval_id = p_control_interval_id;
      146       element_id.index = DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT;
      147       p_code = 0;
      148 
      149       call
      150          collection_manager_$modify (index_cursor.file_opening_id, index_cursor.collection_id, p_ci_header_ptr,
      151          DEFAULT_ELEMENT_LENGTH, element_id_string, (0), p_code);
      152       if p_code ^= 0
      153       then return;
      154    end PUT_CI_HEADER;
      155 
      156 CHECK_VERSION:
      157    proc (p_received_version, p_expected_version, p_structure_name);
      158       dcl	    p_received_version     fixed bin (35);
      159       dcl	    p_expected_version     fixed bin (35);
      160       dcl	    p_structure_name       char (*);
      161 
      162       if p_expected_version ^= p_received_version
      163       then call
      164 	    sub_err_ (error_table_$unimplemented_version, myname,
      165 	    "^/Expected version ^d of the ^a structure. Received version ^d instead.", p_expected_version,
      166 	    p_structure_name, p_received_version);
      167 
      168    end CHECK_VERSION;
      169 
  1     1 /* BEGIN INCLUDE FILE - dm_im_cursor.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*          This structure specifies a DM file, an index collection in that DM
  1     6*file, and a position (key) in that index collection.
  1     7*
  1     8**/
  1     9 
  1    10 /* HISTORY:
  1    11*
  1    12*Written by Lindsey Spratt, 03/29/82
  1    13*Modified:
  1    14*08/09/82 by Matthew Pierret: Changed collection_id from "fixed bin (17)" to
  1    15*            "bit (35) aligned".
  1    16*08/26/82 by Lindsey Spratt:  Changed to version 2.  Added the is_valid and
  1    17*	  is_at_end_of_index flags.  Changed the key_check_value to fixed
  1    18*	  bin (35).  Added the IM_HASH_BIAS, which is used to increment the
  1    19*	  value developed by hash_index_, and IM_HASH_NUMBER_OF_BUCKETS,
  1    20*	  which is a unique number used by hash_index_ to develop the
  1    21*	  key_check_value.
  1    22*02/23/83 by Lindsey Spratt: Changed to keep the current key value in the
  1    23*	  cursor.  Also, implemented the ability to have the cursor
  1    24*	  positioned before or after the index.  
  1    25*10/23/84 by Lindsey L. Spratt:  Added a description section.
  1    26**/
  1    27 
  1    28 /* format: style2,ind3 */
  1    29      dcl	   1 index_cursor	      based (index_cursor_ptr),
  1    30 	     2 type	      fixed bin (17) unaligned,
  1    31 	     2 version	      fixed bin (17) unaligned,
  1    32 	     2 file_opening_id    bit (36) aligned,
  1    33 	     2 collection_id      bit (36) aligned,
  1    34 	     2 key_id_string      bit (36) aligned,	/* Is the location of the current key, */
  1    35 						/* if flags.current_key_exists is on. Is the location */
  1    36 						/* of the end of the index if flags.is_at_end_of_index */
  1    37 						/* is on, which is only available via an operation */
  1    38 						/* requiring the "previous" key.  Is the location of */
  1    39 						/* the "next" key, otherwise. */
  1    40 	     2 area_ptr	      ptr,		/* Area in which the cursor and key_string area allocated. */
  1    41 						/* Must be a freeing area. */
  1    42 	     2 current_key_string_ptr
  1    43 			      ptr,		/* Points to the value of the current key. */
  1    44 	     2 current_key_string_length
  1    45 			      fixed bin (24) unal,	/* Is the length of the current key in bits. */
  1    46 	     2 pad	      bit (12) unal,
  1    47 	     2 flags	      aligned,
  1    48 	       3 is_at_beginning_of_index
  1    49 			      bit (1) unaligned,	/* Only the "next" key is defined. */
  1    50 	       3 is_at_end_of_index
  1    51 			      bit (1) unaligned,	/* Only the "previous" key is defined. */
  1    52 	       3 current_key_exists
  1    53 			      bit (1) unaligned,	/* If on, indicates that the "current" key is identified */
  1    54 						/* by the key_id_string.  If off, the "current" position */
  1    55 						/* is undefined, and the key_id_string identifies the */
  1    56 						/* previous or next key, depending on whether */
  1    57 						/* flags.is_at_end_of_index is off or on, respectively. */
  1    58 	       3 is_valid	      bit (1) unaligned,	/* If off, the index_manager_ was interrupted while */
  1    59 						/* setting the cursor position and the cursor is not */
  1    60 						/* to be trusted for relative position operations. */
  1    61 	       3 pad	      bit (32) unal;
  1    62 
  1    63 
  1    64      dcl	   index_cursor_ptr	      ptr;
  1    65 
  1    66      dcl	   INDEX_CURSOR_VERSION_3 fixed bin (17) init (3) internal static options (constant);
  1    67      dcl	   INDEX_CURSOR_TYPE      init (2) fixed bin (17) internal static options (constant);
  1    68 
  1    69 /* END INCLUDE FILE - dm_im_cursor.incl.pl1 */
      170 
      171 
  2     1 /* BEGIN INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*     This include file contains declarations of all collection_manager_ 
  2     5*     entrypoints.
  2     6**/
  2     7 
  2     8 /* HISTORY:
  2     9*Written by Matthew Pierret 
  2    10*Modified:
  2    11*04/14/82 by Lindsey Spratt: Changed the control_interval_id parameter of the
  2    12*	  allocate_control_interval operation to be unaligned, as well as
  2    13*	  unsigned.
  2    14*06/17/82 by Matthew Pierret: Added the put_element_portion opertion and
  2    15*            removed the beginning_location parameter from the put_element
  2    16*            operation. Added the create_page_file_operation.
  2    17*08/09/82 by Matthew Pierret: Changed "fixed bin (17)"s to "bit (36) aligned"s
  2    18*            wherever collection_id was required.
  2    19*            Also changed the control_interval_id parameter of the 
  2    20*            allocate_control_interval operation back to be aligned. So there.
  2    21*10/20/82 by Matthew Pierret: Changed $create_page_file to $create_file,
  2    22*            added the argument file_create_info_ptr to $create_file.
  2    23*12/13/82 by Lindsey Spratt:  Corrected $free_control_interval to
  2    24*	  include the zero_on_free bit.
  2    25*12/17/82 by Matthew Pierret: Added cm_$get_id.
  2    26*01/07/83 by Matthew Pierret: Added cm_$put_element_buffered, 
  2    27*            cm_$allocate_element_buffered, cm_$free_element_buffered.
  2    28*04/27/83 by Matthew Pierret: Added cm_$put_unprotected_element,
  2    29*            cm_$put_unprotected_header.
  2    30*11/07/83 by Matthew Pierret: Added $get_element_portion_buffered,
  2    31*             $simple_get_buffered_element.
  2    32*02/08/84 by Matthew Pierret:  Changed $get_id to have only one bit(1)aligned
  2    33*            parameter for specifying absolute/relative nature of search.
  2    34*03/16/84 by Matthew Pierret:  Added cm_$get_control_interval_ptr,
  2    35*            $get_element_ptr, $get_element_portion_ptr, $simple_get_element_ptr
  2    36*04/03/84 by Matthew Pierret:  Added cm_$compact_control_interval.
  2    37*06/06/84 by Matthew Pierret:  Re-named free_element* to delete and
  2    38*            delete_from_ci_buffer.
  2    39*            Re-named *_buffered_ci to =_ci_buffer.
  2    40*            get entries.
  2    41*            modify entries.
  2    42*            Changed calling sequence of modify entries to have a ptr/length
  2    43*            instead of length/ptr parameter pair.
  2    44*03/11/85 by R. Michael Tague:  Added $postcommit_increments.
  2    45**/
  2    46 
  2    47 /* This include file contains declarations of collection_manager_ entrypoints */
  2    48 
  2    49 /* format: style2,ind3 */
  2    50      dcl	   collection_manager_$allocate_control_interval
  2    51 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  2    52      dcl	   collection_manager_$compact_control_interval
  2    53 			      entry (bit (36) aligned, fixed bin (24) uns, fixed bin (35));
  2    54      dcl	   collection_manager_$create_collection
  2    55 			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  2    56      dcl	   collection_manager_$create_file
  2    57 			      entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
  2    58      dcl	   collection_manager_$destroy_collection
  2    59 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  2    60      dcl	   collection_manager_$free_control_interval
  2    61 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, bit (1) aligned,
  2    62 			      fixed bin (35));
  2    63 
  2    64      dcl	   collection_manager_$delete
  2    65 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  2    66 			      fixed bin (35));
  2    67      dcl	   collection_manager_$delete_from_ci_buffer
  2    68 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  2    69 			      fixed bin (35));
  2    70 
  2    71      dcl	   collection_manager_$get
  2    72 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  2    73 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  2    74      dcl	   collection_manager_$get_control_interval_ptr
  2    75 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, ptr,
  2    76 			      fixed bin (35));
  2    77      dcl	   collection_manager_$get_from_ci_buffer
  2    78 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  2    79 			      ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  2    80      dcl	   collection_manager_$get_by_ci_ptr
  2    81 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  2    82 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), ptr, fixed bin (35));
  2    83      dcl	   collection_manager_$get_header
  2    84 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (17), ptr, bit (1) aligned,
  2    85 			      ptr, fixed bin (35), fixed bin (35));
  2    86      dcl	   collection_manager_$get_id
  2    87 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17),
  2    88 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  2    89      dcl	   collection_manager_$get_portion
  2    90 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  2    91 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  2    92 			      fixed bin (35), fixed bin (35));
  2    93      dcl	   collection_manager_$get_portion_from_ci_buffer
  2    94 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  2    95 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  2    96 			      fixed bin (35));
  2    97      dcl	   collection_manager_$get_portion_by_ci_ptr
  2    98 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  2    99 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  2   100 			      fixed bin (35));
  2   101      dcl	   collection_manager_$modify
  2   102 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  2   103 			      fixed bin (35), fixed bin (35));
  2   104      dcl	   collection_manager_$modify_unprotected
  2   105 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  2   106 			      fixed bin (35), fixed bin (35));
  2   107      dcl	   collection_manager_$modify_in_ci_buffer
  2   108 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  2   109 			      fixed bin (35), fixed bin (35));
  2   110      dcl	   collection_manager_$modify_portion
  2   111 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35), ptr,
  2   112 			      fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  2   113      dcl	   collection_manager_$postcommit_increments
  2   114 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  2   115      dcl	   collection_manager_$put
  2   116 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  2   117 			      fixed bin (35), fixed bin (35));
  2   118      dcl	   collection_manager_$put_in_ci_buffer
  2   119 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  2   120 			      fixed bin (35), fixed bin (35));
  2   121      dcl	   collection_manager_$put_header
  2   122 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  2   123      dcl	   collection_manager_$put_unprotected_header
  2   124 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  2   125 
  2   126      dcl	   collection_manager_$replace_ci_buffer
  2   127 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  2   128 			      fixed bin (35));
  2   129      dcl	   collection_manager_$setup_ci_buffer
  2   130 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  2   131 			      fixed bin (35));
  2   132      dcl	   collection_manager_$simple_get_by_ci_ptr
  2   133 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  2   134 			      fixed bin (35));
  2   135      dcl	   collection_manager_$simple_get_from_ci_buffer
  2   136 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  2   137 			      fixed bin (35));
  2   138 
  2   139 /* END INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
      172 
      173 
  3     1 /* BEGIN INCLUDE FILE - dm_im_ci_header.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*
  3     5*          Each node (control interval) in the index has a header which
  3     6*     describes the contents of that node.  Although there are two different
  3     7*     kinds of headers, leaf and branch, they have a great deal in common, the
  3     8*     common_ci_header.  The common_ci_header states which slots are used by
  3     9*     the keys (leaf or branch) in the key_range substructure.  There is an
  3    10*     "upward pointer" to the node's parent branch key (parent_id_string).
  3    11*     There are pointers to the previous and next nodes (previous_id and
  3    12*     next_id) on the same level to facilitate rotation of keys, and sequential
  3    13*     searching.  There is also a count of how much space is in use by the keys.
  3    14*
  3    15**/
  3    16 
  3    17 /* HISTORY:
  3    18*
  3    19*Written by Lindsey Spratt, 03/29/82.
  3    20*Modified:
  3    21*10/25/84 by Lindsey L. Spratt:  Added a description and fixed the history
  3    22*            section format.
  3    23**/
  3    24 
  3    25 /* format: style2,ind3 */
  3    26      dcl	   1 common_ci_header     based (common_ci_header_ptr),
  3    27 	     2 flags	      unaligned,
  3    28 	       3 is_leaf	      bit (1) unaligned,	/* ON for leaf_ci, OFF for branch_ci. */
  3    29 	       3 pad	      bit (17) unaligned,	/* Must be zero. */
  3    30 	     2 key_tail_space_used_since_last_prefix_compaction
  3    31 			      fixed bin (18) unsigned unal,
  3    32 	     2 key_range	      unaligned,
  3    33 	       3 first	      fixed bin (18) unsigned,
  3    34 	       3 last	      fixed bin (18) unsigned,
  3    35 	     2 parent_id_string   bit (36) aligned,
  3    36 	     2 previous_id	      fixed bin (24) unsigned unaligned,
  3    37 	     2 next_id	      fixed bin (24) unsigned unaligned,
  3    38 	     2 pad	      bit (24) unaligned;
  3    39 
  3    40 
  3    41      dcl	   common_ci_header_ptr   ptr;
  3    42 
  3    43      dcl	   1 leaf_ci_header	      based (leaf_ci_header_ptr),
  3    44 	     2 common	      like common_ci_header;
  3    45 
  3    46      dcl	   leaf_ci_header_ptr     ptr;
  3    47 
  3    48      dcl	   1 branch_ci_header     based (branch_ci_header_ptr),
  3    49 	     2 common	      like common_ci_header,
  3    50 	     2 low_branch_id      fixed bin (24) unsigned unaligned,
  3    51 	     2 pad	      bit (12) unaligned;
  3    52 
  3    53      dcl	   branch_ci_header_ptr   ptr;
  3    54 
  3    55 
  3    56      dcl	   (
  3    57 	   DEFAULT_INITIAL_KEY_SLOT
  3    58 			      init (2),
  3    59 	   DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT
  3    60 			      init (1),
  3    61 	   LEAF_CI_HEADER_LENGTH_IN_BITS
  3    62 			      init (180),
  3    63 	   BRANCH_CI_HEADER_LENGTH_IN_BITS
  3    64 			      init (216)
  3    65 	   )		      internal static options (constant) fixed bin;
  3    66 
  3    67 /* END INCLUDE FILE - dm_im_ci_header.incl.pl1 */
      174 
      175 
  4     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*        Contains the declaration of an element identifier.  Element
  4     6*   identifiers consist of two parts, the id (number) of the control interval
  4     7*   in which the element resides, and the index into the slot table of
  4     8*   the element in the control interval.  The declaration of the element_id 
  4     9*   structure reflects this division of the element identifier.  The structure 
  4    10*   is based on the automatic bit string element_id_string because programs
  4    11*   generally pass bit strings (element_id_string) to each other, then 
  4    12*   interpret the bit string by overlaying the element_id structure ony if
  4    13*   it is necessary to access the parts of the id.  Basing element_id on
  4    14*   addr(element_id_string) instead of on a pointer removes the necessity
  4    15*   for always setting that pointer explicitly and guarantees that changes
  4    16*   made to the string or structure do not get inconsistent.
  4    17*
  4    18*   Changes made to element_id must also be made to datum_id, declared in 
  4    19*   dm_cm_datum.incl.pl1.
  4    20**/
  4    21 
  4    22 /* HISTORY:
  4    23*Written by Matthew Pierret, 04/01/82.
  4    24*Modified:
  4    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  4    26**/
  4    27 
  4    28 /* format: style2,ind3,ll79 */
  4    29 
  4    30      dcl	   element_id_string      bit (36) aligned;
  4    31 
  4    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  4    33 	     2 control_interval_id
  4    34 			      fixed bin (24) unal unsigned,
  4    35 	     2 index	      fixed bin (12) unal unsigned;
  4    36 
  4    37 
  4    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      176 
      177    end im_delete_node;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0913.2  im_delete_node.pl1                >spec>on>7192.pbf-04/04/85>im_delete_node.pl1
170          1    01/07/85  0858.9  dm_im_cursor.incl.pl1             >ldd>include>dm_im_cursor.incl.pl1
172          2    04/04/85  0819.0  dm_collmgr_entry_dcls.incl.pl1    >spec>on>7192.pbf-04/04/85>dm_collmgr_entry_dcls.incl.pl1
174          3    01/07/85  0858.8  dm_im_ci_header.incl.pl1          >ldd>include>dm_im_ci_header.incl.pl1
176          4    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BRANCH_CI_HEADER_LENGTH_IN_BITS        constant        fixed bin(17,0)          initial dcl 3-56 ref 44 130 130
DEFAULT_AREA_PTR                000006 constant        pointer                  initial dcl 53 set ref 130*
DEFAULT_ELEMENT_LENGTH          000005 constant        fixed bin(35,0)          initial dcl 54 set ref 149*
DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT
                                       constant        fixed bin(17,0)          initial dcl 3-56 ref 127 146
INDEX_CURSOR_TYPE               000023 constant        fixed bin(17,0)          initial dcl 1-67 set ref 73 73*
INDEX_CURSOR_VERSION_3                 constant        fixed bin(17,0)          initial dcl 1-66 ref 78
LEAF_CI_HEADER_LENGTH_IN_BITS          constant        fixed bin(17,0)          initial dcl 3-56 ref 44 130 130
ZERO_ON_FREE                    000000 constant        bit(1)                   initial dcl 57 set ref 113*
ci_following_deleted_node       000100 automatic       fixed bin(24,0)          unsigned unaligned dcl 42 set ref 87* 95 101 104*
                                                                                  108*
ci_preceding_deleted_node       000101 automatic       fixed bin(24,0)          unsigned unaligned dcl 42 set ref 86* 89 92* 96* 107
collection_id             2            based           bit(36)                  level 2 dcl 1-29 set ref 113* 130* 149*
collection_manager_$free_control_interval
                                000016 constant        entry                    external dcl 2-60 ref 113
collection_manager_$get         000020 constant        entry                    external dcl 2-71 ref 130
collection_manager_$modify      000022 constant        entry                    external dcl 2-101 ref 149
common_ci_header                       based           structure                level 1 unaligned dcl 3-26
common_ci_header_ptr            000104 automatic       pointer                  dcl 3-41 set ref 81* 82* 86 87 92* 95 96* 104* 107
                                                                                  108*
control_interval_id                    based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 4-32 set ref
                                                                                  126* 145*
dm_error_$wrong_cursor_type     000014 external static fixed bin(35,0)          dcl 65 set ref 73*
element_id                             based           structure                level 1 dcl 4-32
element_id_string               000106 automatic       bit(36)                  dcl 4-30 set ref 126 127 130* 145 146 149*
error_table_$unimplemented_version
                                000012 external static fixed bin(35,0)          dcl 65 set ref 162*
file_opening_id           1            based           bit(36)                  level 2 dcl 1-29 set ref 113* 130* 149*
index                     0(24)        based           fixed bin(12,0)          level 2 packed unsigned unaligned dcl 4-32 set ref
                                                                                  127* 146*
index_cursor                           based           structure                level 1 unaligned dcl 1-29
index_cursor_ptr                000102 automatic       pointer                  dcl 1-64 set ref 72* 73 73 78 113 113 130 130 149
                                                                                  149
local_ci_header_buffer          000102 automatic       bit                      dcl 44 set ref 81
myname                          000001 constant        char(14)                 initial unaligned dcl 56 set ref 73* 162*
next_id                   3(24)        based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 3-26 set ref
                                                                                  87 95*
null                                                   builtin function         dcl 49 ref 73 73
p_ci_header_ptr                        parameter       pointer                  dcl 122 in procedure "GET_CI_HEADER" set ref 119
                                                                                  130* 130*
p_ci_header_ptr                        parameter       pointer                  dcl 141 in procedure "PUT_CI_HEADER" set ref 138
                                                                                  149*
p_code                                 parameter       fixed bin(35,0)          dcl 38 in procedure "im_delete_node" set ref 30 82*
                                                                                  83 92* 93 96* 97 104* 105 108* 109 113*
p_code                                 parameter       fixed bin(35,0)          dcl 142 in procedure "PUT_CI_HEADER" set ref 138
                                                                                  147* 149* 152
p_code                                 parameter       fixed bin(35,0)          dcl 123 in procedure "GET_CI_HEADER" set ref 119
                                                                                  128* 130* 134
p_control_interval_id                  parameter       fixed bin(24,0)          unsigned unaligned dcl 140 in procedure
                                                                                  "PUT_CI_HEADER" ref 138 145
p_control_interval_id                  parameter       fixed bin(24,0)          unsigned dcl 37 in procedure "im_delete_node" set
                                                                                  ref 30 82 113*
p_control_interval_id                  parameter       fixed bin(24,0)          unsigned unaligned dcl 121 in procedure
                                                                                  "GET_CI_HEADER" ref 119 126
p_expected_version                     parameter       fixed bin(35,0)          dcl 159 set ref 156 162 162*
p_index_cursor_ptr                     parameter       pointer                  dcl 36 ref 30 72
p_received_version                     parameter       fixed bin(35,0)          dcl 158 set ref 156 162 162*
p_structure_name                       parameter       char                     unaligned dcl 160 set ref 156 162*
previous_id               3            based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 3-26 set ref
                                                                                  86 107*
sub_err_                        000010 constant        entry                    external dcl 61 ref 73 162
type                                   based           fixed bin(17,0)          level 2 packed unaligned dcl 1-29 set ref 73 73*
version                   0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 1-29 ref 78

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DEFAULT_INITIAL_KEY_SLOT               internal static fixed bin(17,0)          initial dcl 3-56
branch_ci_header                       based           structure                level 1 unaligned dcl 3-48
branch_ci_header_ptr                   automatic       pointer                  dcl 3-53
collection_manager_$allocate_control_interval
                                000000 constant        entry                    external dcl 2-50
collection_manager_$compact_control_interval
                                000000 constant        entry                    external dcl 2-52
collection_manager_$create_collection
                                000000 constant        entry                    external dcl 2-54
collection_manager_$create_file 000000 constant        entry                    external dcl 2-56
collection_manager_$delete      000000 constant        entry                    external dcl 2-64
collection_manager_$delete_from_ci_buffer
                                000000 constant        entry                    external dcl 2-67
collection_manager_$destroy_collection
                                000000 constant        entry                    external dcl 2-58
collection_manager_$get_by_ci_ptr
                                000000 constant        entry                    external dcl 2-80
collection_manager_$get_control_interval_ptr
                                000000 constant        entry                    external dcl 2-74
collection_manager_$get_from_ci_buffer
                                000000 constant        entry                    external dcl 2-77
collection_manager_$get_header  000000 constant        entry                    external dcl 2-83
collection_manager_$get_id      000000 constant        entry                    external dcl 2-86
collection_manager_$get_portion 000000 constant        entry                    external dcl 2-89
collection_manager_$get_portion_by_ci_ptr
                                000000 constant        entry                    external dcl 2-97
collection_manager_$get_portion_from_ci_buffer
                                000000 constant        entry                    external dcl 2-93
collection_manager_$modify_in_ci_buffer
                                000000 constant        entry                    external dcl 2-107
collection_manager_$modify_portion
                                000000 constant        entry                    external dcl 2-110
collection_manager_$modify_unprotected
                                000000 constant        entry                    external dcl 2-104
collection_manager_$postcommit_increments
                                000000 constant        entry                    external dcl 2-113
collection_manager_$put         000000 constant        entry                    external dcl 2-115
collection_manager_$put_header  000000 constant        entry                    external dcl 2-121
collection_manager_$put_in_ci_buffer
                                000000 constant        entry                    external dcl 2-118
collection_manager_$put_unprotected_header
                                000000 constant        entry                    external dcl 2-123
collection_manager_$replace_ci_buffer
                                000000 constant        entry                    external dcl 2-126
collection_manager_$setup_ci_buffer
                                000000 constant        entry                    external dcl 2-129
collection_manager_$simple_get_by_ci_ptr
                                000000 constant        entry                    external dcl 2-132
collection_manager_$simple_get_from_ci_buffer
                                000000 constant        entry                    external dcl 2-135
leaf_ci_header                         based           structure                level 1 unaligned dcl 3-43
leaf_ci_header_ptr                     automatic       pointer                  dcl 3-46

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   000535 constant        entry                    internal dcl 156 ref 78
GET_CI_HEADER                   000405 constant        entry                    internal dcl 119 ref 82 92 104
PUT_CI_HEADER                   000471 constant        entry                    internal dcl 138 ref 96 108
im_delete_node                  000106 constant        entry                    external dcl 30

NAMES DECLARED BY CONTEXT OR IMPLICATION.
addr                                                   builtin function         ref 81 126 127 145 146
max                                                    builtin function         ref 44 130 130

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       742         766     630         752
Length      1240     630        24         236     112           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
im_delete_node                      246 external procedure  is an external procedure.  
GET_CI_HEADER                           internal procedure  shares stack frame of external procedure im_delete_node.  
PUT_CI_HEADER                           internal procedure  shares stack frame of external procedure im_delete_node.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure im_delete_node.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
im_delete_node           000100 ci_following_deleted_node   im_delete_node
                         000101 ci_preceding_deleted_node   im_delete_node
                         000102 local_ci_header_buffer      im_delete_node
                         000102 index_cursor_ptr            im_delete_node
                         000104 common_ci_header_ptr        im_delete_node
                         000106 element_id_string           im_delete_node

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              alloc_auto_adj      ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
collection_manager_$free_control_interval                   collection_manager_$get       collection_manager_$modify
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$wrong_cursor_type   error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     30 000102        44 000113        72 000125        73 000131        78 000211        81 000226        82 000230
     83 000246        86 000251        87 000255        89 000262        92 000265        93 000277        95 000302
     96 000307        97 000321       101 000324       104 000327       105 000341       107 000344       108 000347
    109 000361       113 000364       117 000404       119 000405       126 000407       127 000413       128 000415
    130 000416       134 000464       136 000470       138 000471       145 000473       146 000477       147 000501
    149 000502       152 000530       154 000534       156 000535       162 000546       168 000611


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
