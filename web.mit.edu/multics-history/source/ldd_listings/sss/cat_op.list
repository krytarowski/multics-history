	COMPILATION LISTING OF SEGMENT cat_op
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Adv Computing Technology Centre 
	Compiled on: 05/30/90  1600.8 mdt Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(89-09-27,RWaters), approve(89-09-27,MCR8068), audit(89-09-27,Vu),
       17*     install(89-10-02,MR12.3-1080):
       18*     Fixed to remove duplicate declaration attributes.
       19*  2) change(90-05-03,Huen), approve(90-05-03,MCR8169), audit(90-05-18,Gray),
       20*     install(90-05-30,MR12.4-1012):
       21*     pl1_1885: Fix pl1 optimizer to handle the concatenation of a common string
       22*     expression correctly.
       23*                                                   END HISTORY COMMENTS */
       24 
       25 
       26 /* program to compile concatenation operator
       27*
       28*   Initial Version: 28 December, 1968 by BLW
       29*	Modified:  9 September 1971 by BLW for Version II
       30*	Modified: 27 July 1972 by BLW
       31*	Modified:	8 June 1973 by RAB for EIS
       32*	Modified: 14 Sept 1979 by PCK to fix bug 1855
       33**/
       34 
       35 cat_op:	proc(node_pts,refs,code);
       36 
       37 dcl	node_pts ptr,		/* points at operator node */
       38 	refs(3) ptr,		/* reference nodes for operands */
       39 	code fixed bin;		/* local context */
       40 
       41 dcl	node_pt ptr defined (node_pts),
       42 	ref(3) ptr defined (refs);
       43 
       44 dcl	(p1,p2,p3,p,q2,q3) ptr,
       45 	(dt,type,n,s2,size1,size2,size3) fixed bin,
       46 	macro fixed bin(15),
       47 	tag bit(4) aligned,
       48 	base bit(3) aligned,
       49 	(lunits,word_offset) fixed bin(15),
       50 	string_temp entry(ptr,ptr,ptr) returns(ptr),
       51 	adjust_ref_count entry(ptr,fixed bin),
       52 	compile_exp entry(ptr),
       53 	(compile_exp$save,compile_exp$save_exp) entry(ptr) returns(ptr),
       54 	m_a entry(ptr,bit(2) aligned),
       55 	base_man$load_any_var entry(fixed bin,ptr,bit(3) aligned),
       56 	load_size$xr_or_aq entry(ptr,bit(4) aligned),
       57 	state_man$erase_reg entry(bit(19) aligned),
       58 	expmac$eis entry(fixed bin(15),ptr),
       59 	aq_man$clear_q entry,
       60 	c_a entry(fixed bin,fixed bin) returns(ptr),
       61 	expmac$one entry(fixed bin(15),ptr,fixed bin),
       62 	expmac entry(fixed bin(15),ptr);
       63 
       64 dcl	(addr,divide,fixed,mod,null) builtin;
       65 
       66 dcl	1 p1_address aligned based(addr(p1 -> reference.address)),
       67 	2 base bit(3) unal,
       68 	2 offset fixed bin(14) unal,
       69 	2 op bit(9) unal,
       70 	2 no_address bit(1) unal,
       71 	2 inhibit bit(1) unal,
       72 	2 ext_base bit(1) unal,
       73 	2 tag bit(6) unal;
       74 
       75 
       76 dcl (	cat_move_chars	init(218),
       77 	lda		init(1),
       78 	ldq		init(7),
       79 	sta		init(4),
       80 	ora		init(46),
       81 	arl		init(245),
       82 	lrl		init(62)) fixed bin(15) int static;
       83 
  1     1 /* BEGIN INCLUDE FILE ... boundary.incl.pl1 */
  1     2 
  1     3 /* Modified: 26 Apr 1979 by PCK to implement 4-bit decimal */
  1     4 
  1     5 dcl (	bit_		init(1),
  1     6 	digit_		init(2),
  1     7 	character_	init(3),
  1     8 	half_		init(4),
  1     9 	word_		init(5),
  1    10 	mod2_		init(6),
  1    11 	mod4_		init(7)) fixed bin(3) int static options(constant);
  1    12 
  1    13 /* END INCLUDE FILE ... boundary.incl.pl1 */
       84 
  2     1 /* BEGIN INCLUDE FILE ... cgsystem.incl.pl1 */
  2     2 
  2     3 /* Modified: 25 Apr 1979 by PCK to implement 4-bit decimal */
  2     4 
  2     5 dcl (	bits_per_char		init(9),
  2     6 	bits_per_half		init(18),
  2     7 	bits_per_word		init(36),
  2     8 	bits_per_two_words		init(72),
  2     9 	bits_per_four_words		init(144),
  2    10 	bits_per_words(2)		init(36,72),
  2    11 	packed_digits_per_char	init(2),
  2    12 	chars_per_word		init(4),
  2    13 	packed_digits_per_word	init(8),
  2    14 
  2    15 	break_even_bits		init(216),
  2    16 	break_even_words		init(6),
  2    17 
  2    18 	label_size		init(4),
  2    19 
  2    20 	convert_size(13:14)		init(9,1),
  2    21 	max_offset(13:14)		init(27,35),
  2    22 	max_short_size(13:14)	init(8,72),
  2    23 
  2    24 	units_per_word(0:5)		init(1,36,8,4,2,1),
  2    25 
  2    26 	max_dec_scale		init(32),
  2    27 	min_dec_scale		init(-31),
  2    28 	max_p_xreg		init(18),
  2    29 	max_p_fix_bin_1		init(35),
  2    30 	max_p_flt_bin_1		init(27),
  2    31 	max_p_fix_dec		init(59),
  2    32 	max_length_p		init(24),
  2    33 	default_fix_bin_p		init(17)) fixed bin(8) int static options(constant);
  2    34 
  2    35 dcl      (convert_offset(0:5)		init(36,1,4.5,9,18,36),
  2    36 	bits_per_packed_digit	init(4.5)) fixed bin(8,1) int static options(constant);
  2    37 
  2    38 dcl	max_index_register_value	init(262143) fixed bin(31) int static options(constant);
  2    39 
  2    40 /* END INCLUDE FILE ... cgsystem.incl.pl1 */
  2    41 
       85 
  3     1 /* BEGIN INCLUDE FILE ... cg_reference.incl.pl1 */
  3     2 
  3     3 dcl	1 reference		based aligned,
  3     4 	2 node_type		bit(9) unaligned,
  3     5 	2 array_ref		bit(1) unaligned,
  3     6 	2 varying_ref		bit(1) unaligned,
  3     7 	2 shared			bit(1) unaligned,
  3     8 	2 put_data_sw		bit(1) unaligned,
  3     9 	2 processed		bit(1) unaligned,
  3    10 	2 units			fixed(3) unaligned,
  3    11 	2 ref_count		fixed(17) unaligned,
  3    12 	2 c_offset		fixed(24),
  3    13 	2 c_length		fixed(24),
  3    14 	2 symbol			ptr unaligned,
  3    15 	2 qualifier		ptr unaligned,
  3    16 	2 offset			ptr unaligned,
  3    17 	2 length			ptr unaligned,
  3    18 						/* these fields are used by the 645 code generator */
  3    19 	2 c_f_offset		fixed bin(6),
  3    20 	2 address			structure unaligned,
  3    21 	  3 base			bit(3),
  3    22 	  3 offset		bit(15),
  3    23 	  3 op			bit(9),
  3    24 	  3 no_address		bit(1),
  3    25 	  3 inhibit		bit(1),
  3    26 	  3 ext_base		bit(1),
  3    27 	  3 tag			bit(6),
  3    28 	2 info			structure unaligned,
  3    29 	  3 address_in		structure,
  3    30 	    4 b			dimension(0:7) bit(1),
  3    31 	    4 storage		bit(1),
  3    32 	  3 value_in		structure,
  3    33 	    4 a			bit(1),
  3    34 	    4 q			bit(1),
  3    35 	    4 aq			bit(1),
  3    36 	    4 string_aq		bit(1),
  3    37 	    4 complex_aq		bit(1),
  3    38 	    4 decimal_aq		bit(1),
  3    39 	    4 b			dimension(0:7) bit(1),
  3    40 	    4 storage		bit(1),
  3    41 	    4 indicators		bit(1),
  3    42 	    4 x			dimension(0:7) bit(1),
  3    43 	  3 other			structure,
  3    44 	    4 big_offset		bit(1),
  3    45 	    4 big_length		bit(1),
  3    46 	    4 modword_in_offset	bit(1),
  3    47 	2 data_type		fixed(5) unaligned,
  3    48 	2 bits			structure unaligned,
  3    49 	  3 padded_ref		bit(1),
  3    50 	  3 aligned_ref		bit(1),
  3    51 	  3 long_ref		bit(1),
  3    52 	  3 forward_ref		bit(1),
  3    53 	  3 ic_ref		bit(1),
  3    54 	  3 temp_ref		bit(1),
  3    55 	  3 defined_ref		bit(1),
  3    56 	  3 evaluated		bit(1),
  3    57 	  3 allocate		bit(1),
  3    58 	  3 allocated		bit(1),
  3    59 	  3 aliasable		bit(1),
  3    60 	  3 even			bit(1),
  3    61 	  3 perm_address		bit(1),
  3    62 	  3 aggregate		bit(1),
  3    63 	  3 hit_zero		bit(1),
  3    64 	  3 dont_save		bit(1),
  3    65 	  3 fo_in_qual		bit(1),
  3    66 	  3 hard_to_load		bit(1),
  3    67 	2 relocation		bit(12) unaligned,
  3    68 	2 more_bits		structure unaligned,
  3    69 	  3 substr		bit(1),
  3    70 	  3 padded_for_store_ref	bit(1),
  3    71 	  3 aligned_for_store_ref	bit(1),
  3    72 	  3 mbz			bit(15),
  3    73 	2 store_ins		bit(18) unaligned;
  3    74 
  3    75 /* END INCLUDE FILE ... cg_reference.incl.pl1 */
       86 
  4     1 /* BEGIN INCLUDE FILE ... operator.incl.pl1 */
  4     2 
  4     3 /*	Modified: 2 Apr 1980 by PCK to add max_number_of_operands */
  4     4 
  4     5 /* format: style3 */
  4     6 dcl	1 operator	based aligned,
  4     7 	  2 node_type	bit (9) unaligned,
  4     8 	  2 op_code	bit (9) unaligned,
  4     9 	  2 shared	bit (1) unaligned,
  4    10 	  2 processed	bit (1) unaligned,
  4    11 	  2 optimized	bit (1) unaligned,
  4    12 	  2 number	fixed (14) unaligned,
  4    13 	  2 operand	dimension (n refer (operator.number)) ptr unaligned;
  4    14 
  4    15 dcl	max_number_of_operands
  4    16 			fixed bin (15) int static options (constant) initial (32767);
  4    17 
  4    18 /* END INCLUDE FILE ... operator.incl.pl1 */
       87 
  5     1 dcl (	real_fix_bin_1		init(1),
  5     2 	real_fix_bin_2		init(2),
  5     3 	real_flt_bin_1		init(3),
  5     4 	real_flt_bin_2		init(4),
  5     5 	complex_fix_bin_1		init(5),
  5     6 	complex_fix_bin_2		init(6),
  5     7 	complex_flt_bin_1		init(7),
  5     8 	complex_flt_bin_2		init(8),
  5     9 	real_fix_dec		init(9),
  5    10 	real_flt_dec		init(10),
  5    11 	complex_fix_dec		init(11),
  5    12 	complex_flt_dec		init(12),
  5    13 	char_string		init(13),
  5    14 	bit_string		init(14),
  5    15 	label_constant		init(15),
  5    16 	local_label_variable	init(16),
  5    17 	label_variable		init(17),
  5    18 	entry_variable		init(18),
  5    19 	ext_entry_in		init(19),
  5    20 	ext_entry_out		init(20),
  5    21 	int_entry			init(21),
  5    22 	int_entry_other		init(22),
  5    23 	unpacked_ptr		init(23),
  5    24 	packed_ptr		init(24)) fixed bin(15) int static options(constant);
       88 
  6     1 /* BEGIN INCLUDE FILE ... machine_state.incl.pl1 */
  6     2 
  6     3 dcl	cg_static_$m_s_p ptr ext static,
  6     4 	m_s_p ptr init(cg_static_$m_s_p);
  6     5 
  6     6 dcl	1 machine_state	aligned based(m_s_p),
  6     7 	2 node_type	bit(9),
  6     8 	2 indicators	fixed bin,
  6     9 	2 next		ptr unal,
  6    10 	2 a_reg,
  6    11 	  3 variable(10)	ptr unal,
  6    12 	  3 number	fixed bin(17),
  6    13 	  3 size		fixed bin(8),
  6    14 	  3 length	fixed bin(8),
  6    15 	  3 offset	fixed bin(8),
  6    16 	  3 constant	fixed bin(24),
  6    17 	  3 changed	fixed bin(18),
  6    18 	  3 instruction	bit(36),
  6    19 	  3 locked	bit(1) aligned,
  6    20 	  3 number_h_o	fixed bin,
  6    21 	  3 has_offset(3)	ptr unal,
  6    22 	2 q_reg,
  6    23 	  3 variable(10)	ptr unal,
  6    24 	  3 number	fixed bin(17),
  6    25 	  3 size		fixed bin(8),
  6    26 	  3 length	fixed bin(8),
  6    27 	  3 offset	fixed bin(8),
  6    28 	  3 constant	fixed bin(24),
  6    29 	  3 changed	fixed bin(18),
  6    30 	  3 instruction	bit(36),
  6    31 	  3 locked	bit(1) aligned,
  6    32 	  3 number_h_o	fixed bin,
  6    33 	  3 has_offset(3)	ptr unal,
  6    34 	2 string_reg,
  6    35 	  3 variable	ptr unal,
  6    36 	  3 size		fixed bin(8),
  6    37 	  3 offset	fixed bin(8),
  6    38 	2 complex_reg,
  6    39 	  3 variable	ptr unal,
  6    40 	  3 size		fixed bin(8),
  6    41 	  3 scale		fixed bin(8),
  6    42 	2 decimal_reg,
  6    43 	  3 variable	ptr unal,
  6    44 	  3 size		fixed bin(8),
  6    45 	  3 scale		fixed bin(8),
  6    46 	2 index_regs(0:7),
  6    47 	  3 variable	ptr unal,
  6    48 	  3 constant	fixed bin,
  6    49 	  3 type		fixed bin(8),
  6    50 	  3 used		fixed bin(18),
  6    51 	  3 changed	fixed bin(18),
  6    52 	  3 instruction	bit(36),
  6    53 	  3 filler	fixed bin,
  6    54 	2 base_regs(0:7),
  6    55 	  3 variable	ptr unal,
  6    56 	  3 constant	fixed bin,
  6    57 	  3 type		fixed bin(8),
  6    58 	  3 pad (12)	fixed bin,	/* future...room to make 5 element array for variable, constant, type */
  6    59 	  3 number	fixed bin (17),	/* future...number of valid elements in array */
  6    60 	  3 used		fixed bin(18),
  6    61 	  3 changed	fixed bin(18),
  6    62 	  3 instruction	bit(36),
  6    63 	  3 locked	fixed bin(2),
  6    64 	2 indicators_ref(2:3) ptr unal;
  6    65 
  6    66 /* Permissible values for machine_state.indicators. */
  6    67 
  6    68 dcl (	ind_known_refs	init (-2),		/* set by comparison of known, nonzero, references */
  6    69 	ind_invalid	init (-1),
  6    70 	ind_string_aq	init (0),			/* logical value in storage */
  6    71 	ind_logical	init (1),			/* logical value in A or AQ */
  6    72 	ind_arithmetic	init (2),			/* arith value in Q, AQ, or EAQ */
  6    73 	ind_x (0:7)	init (6, 7, 8, 9, 10, 11, 12, 13),
  6    74 	ind_decimal_reg	init (14)
  6    75 	) fixed bin internal static options (constant);
  6    76 
  6    77 /* END INCLUDE FILE ... machine_state.incl.pl1 */
       89 
       90 
       91 begin:	p = node_pt;
       92 
       93 	p1 = ref(1);
       94 	p2 = ref(2);
       95 	p3 = ref(3);
       96 
       97 	q2 = p -> operand(2);
       98 	q3 = p -> operand(3);
       99 
      100 	type = p1 -> reference.data_type;
      101 	n = convert_size(type);
      102 	size1 = p1 -> reference.c_length * n;
      103 	size2 = p2 -> reference.c_length * n;
      104 	size3 = p3 -> reference.c_length * n;
      105 	s2 = fixed(size2 > bits_per_word,1);
      106 	dt = type - char_string;
      107 
      108 	goto switch(code);
      109 
      110 	/* have atm || exp */
      111 
      112 switch(2):
      113 ae:	if p1 -> reference.long_ref then p3 = compile_exp$save_exp(q3);
      114 
      115 	/* have atm || atm */
      116 
      117 switch(3):
      118 aa:	if p1 -> reference.long_ref
      119 	then do;
      120 
      121 	     /* resultant string is long */
      122 
      123 /* Want to protect possible length expr of p2 */
      124 
      125 aa_l1:	     if ^ p2 -> reference.shared
      126 		then p2 -> reference.ref_count = p2 -> reference.ref_count + 1;
      127 
      128 /* Call string_temp to allocate a temporary and move in p2 */
      129 
      130 	     p1 = string_temp(p,p2,p3);
      131 
      132 /* THE FOLLOWING SECTION SETS UP A MOVE TO EFFECT THE CONCATENATION */
      133 
      134 aa_l3:
      135 
      136 /* If p2's length was able to be inserted directly into a descriptor, try to optimize
      137*  by changing the constant offset of the target */
      138 
      139 	     if p2 -> reference.length = null
      140 	     then if p2 -> reference.c_length < 4096
      141 		then if ^ p2 -> reference.varying_ref
      142 		     then do;
      143 			call m_a(p1,"11"b);
      144 
      145 			if dt = 0
      146 			then lunits = character_;
      147 			else lunits = bit_;
      148 
      149 			word_offset = divide(p2 -> reference.c_length,units_per_word(lunits),15,0)
      150 				  + p1_address.offset;
      151 			if word_offset < 16383
      152 			then do;
      153 			     p1 -> reference.c_f_offset = mod(p2 -> reference.c_length,units_per_word(lunits))
      154 						  + p1 -> reference.c_f_offset;
      155 			     if p1 -> reference.c_f_offset >= units_per_word(lunits)
      156 			     then do;
      157 				p1 -> reference.c_f_offset = p1 -> reference.c_f_offset - units_per_word(lunits);
      158 				word_offset = word_offset + 1;
      159 				end;
      160 			     p1_address.offset = word_offset;
      161 			     go to set_perm;
      162 			     end;
      163 			end;
      164 
      165 /* This sequence is used when p2's length was in a register .  We use p2's length as the 
      166*   offset in p1 in which to move p3 for the concatenation */
      167 
      168 	     call load_size$xr_or_aq(p2,tag);
      169 
      170 	     call m_a(p1,"11"b);
      171 
      172 	     if p1 -> address.tag
      173 	     then do;
      174 		p1 -> reference.ref_count = p1 -> reference.ref_count + 1;
      175 		p1 -> reference.perm_address = "1"b;
      176 		call base_man$load_any_var(2,p1,base);
      177 		end;
      178 
      179 	     p1 -> address.tag = "00"b || tag;
      180 
      181 /* Issue the move macro for the concatenation */
      182 
      183 set_perm:	     p1 -> reference.perm_address = "1"b;
      184 
      185 	     call expmac$eis(cat_move_chars+dt,p3);
      186 
      187 	     if dt > 0
      188 		then machine_state.indicators = -1;
      189 
      190 	     p1 -> reference.perm_address = "0"b;
      191 
      192 	     if ^ p2 -> reference.shared
      193 		then call adjust_ref_count(p2,-1);
      194 
      195 	     return;
      196 	     end;
      197 
      198 	/* resultant string is short */
      199 
      200 	if p2 -> reference.c_length = 0
      201 	then do;
      202 	     call compile_exp(q3);
      203 	     return;
      204 	     end;
      205 
      206 aa_2:	if size2 = bits_per_word & mod(code,2) ^= 0
      207 	then do;
      208 	     call expmac((lda),p2);
      209 aa_2a:	     call expmac((ldq),p3);
      210 	     end;
      211 	else do;
      212 aa_3:	     call compile_exp(q3);
      213 
      214 
      215 	     call state_man$erase_reg("1"b);	/* shift won't flush the register first */
      216 
      217 	     if size1 > bits_per_word
      218 	     then do;
      219 		macro = lrl;
      220 
      221 		/* clear q if necessary, so we
      222*		   won't have garbage left over */
      223 
      224 		if size3 <= bits_per_word
      225 		then if size2 ^= bits_per_word
      226 		     then if a_reg.length < bits_per_two_words
      227 			then call aq_man$clear_q;
      228 		end;
      229 
      230 	     else macro = arl;
      231 
      232 	     call expmac(macro,c_a(size2,1));
      233 
      234 	     call expmac$one((ora),p2,s2);
      235 	     end;
      236 
      237 	a_reg.size = size1;
      238 	return;
      239 
      240 	/* have exp || exp */
      241 
      242 switch(0):
      243 ee:	if ^ p1 -> reference.long_ref
      244 	then do;
      245 ee1:	     p2 = compile_exp$save(q2);
      246 	     goto aa_3;
      247 	     end;
      248 
      249 	p3 = compile_exp$save_exp(q3);
      250 
      251 	/* have exp || atm */
      252 
      253 switch(1):
      254 ea:	if ^ p1 -> reference.long_ref
      255 	then do;
      256 	     if size2 ^= bits_per_word then goto ee1;
      257 	     if p2 -> reference.ref_count < 1 then call compile_exp(q2);
      258 	     else p2 = compile_exp$save(q2);	/* needed later */
      259 	     goto aa_2a;
      260 	     end;
      261 
      262 ea1:	if p2 -> reference.long_ref | p2 -> reference.varying_ref
      263 	     then call compile_exp(q2);
      264 	     else p2 = compile_exp$save_exp(q2);
      265 
      266 	goto aa_l1;
      267 
      268 	end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/30/90  1600.8  cat_op.pl1                        >spec>install>1012>cat_op.pl1
84           1    10/25/79  1745.8  boundary.incl.pl1                 >ldd>include>boundary.incl.pl1
85           2    10/25/79  1745.8  cgsystem.incl.pl1                 >ldd>include>cgsystem.incl.pl1
86           3    07/21/80  1646.3  cg_reference.incl.pl1             >ldd>include>cg_reference.incl.pl1
87           4    07/21/80  1646.3  operator.incl.pl1                 >ldd>include>operator.incl.pl1
88           5    05/03/76  1420.4  data_types.incl.pl1               >ldd>include>data_types.incl.pl1
89           6    11/13/79  1115.8  machine_state.incl.pl1            >ldd>include>machine_state.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_reg                     3            based           structure                level 2 dcl 6-6
addr                                                   builtin function         dcl 64 ref 149 160
address                  10            based           structure                level 2 packed packed unaligned dcl 3-3 set ref 149
                                                                                  160
adjust_ref_count                000012 constant        entry                    external dcl 44 ref 192
aq_man$clear_q                  000034 constant        entry                    external dcl 44 ref 224
arl                                    constant        fixed bin(15,0)          initial dcl 76 ref 230
base                            000125 automatic       bit(3)                   dcl 44 set ref 176*
base_man$load_any_var           000024 constant        entry                    external dcl 44 ref 176
bit_                                   constant        fixed bin(3,0)           initial dcl 1-5 ref 147
bits                     12(06)        based           structure                level 2 packed packed unaligned dcl 3-3
bits_per_two_words                     constant        fixed bin(8,0)           initial dcl 2-5 ref 224
bits_per_word                          constant        fixed bin(8,0)           initial dcl 2-5 ref 105 206 217 224 224 256
c_a                             000036 constant        entry                    external dcl 44 ref 232 232
c_f_offset                7            based           fixed bin(6,0)           level 2 dcl 3-3 set ref 153* 153 155 157* 157
c_length                  2            based           fixed bin(24,0)          level 2 dcl 3-3 ref 102 103 104 134 149 153 200
cat_move_chars                         constant        fixed bin(15,0)          initial dcl 76 ref 185
cg_static_$m_s_p                000044 external static pointer                  dcl 6-3 ref 6-3
char_string                            constant        fixed bin(15,0)          initial dcl 5-1 ref 106
character_                             constant        fixed bin(3,0)           initial dcl 1-5 ref 145
code                                   parameter       fixed bin(17,0)          dcl 37 ref 35 108 206
compile_exp                     000014 constant        entry                    external dcl 44 ref 202 212 257 262
compile_exp$save                000016 constant        entry                    external dcl 44 ref 245 258
compile_exp$save_exp            000020 constant        entry                    external dcl 44 ref 112 249 264
convert_size                    000012 constant        fixed bin(8,0)           initial array dcl 2-5 ref 101
data_type                12            based           fixed bin(5,0)           level 2 packed packed unaligned dcl 3-3 ref 100
divide                                                 builtin function         dcl 64 ref 149
dt                              000114 automatic       fixed bin(17,0)          dcl 44 set ref 106* 145 185 187
expmac                          000042 constant        entry                    external dcl 44 ref 208 209 232
expmac$eis                      000032 constant        entry                    external dcl 44 ref 185
expmac$one                      000040 constant        entry                    external dcl 44 ref 234
fixed                                                  builtin function         dcl 64 ref 105
indicators                1            based           fixed bin(17,0)          level 2 dcl 6-6 set ref 187*
lda                                    constant        fixed bin(15,0)          initial dcl 76 ref 208
ldq                                    constant        fixed bin(15,0)          initial dcl 76 ref 209
length                    6            based           pointer                  level 2 in structure "reference" packed packed
                                                                                  unaligned dcl 3-3 in procedure "cat_op" ref 134
length                   17            based           fixed bin(8,0)           level 3 in structure "machine_state" dcl 6-6
                                                                                  in procedure "cat_op" ref 224
load_size$xr_or_aq              000026 constant        entry                    external dcl 44 ref 168
long_ref                 12(08)        based           bit(1)                   level 3 packed packed unaligned dcl 3-3 ref 112 117
                                                                                  242 253 262
lrl                                    constant        fixed bin(15,0)          initial dcl 76 ref 219
lunits                          000126 automatic       fixed bin(15,0)          dcl 44 set ref 145* 147* 149 153 155 157
m_a                             000022 constant        entry                    external dcl 44 ref 143 170
m_s_p                           000130 automatic       pointer                  initial dcl 6-3 set ref 187 224 237 6-3*
machine_state                          based           structure                level 1 dcl 6-6
macro                           000123 automatic       fixed bin(15,0)          dcl 44 set ref 219* 230* 232*
mod                                                    builtin function         dcl 64 ref 153 206
n                               000116 automatic       fixed bin(17,0)          dcl 44 set ref 101* 102 103 104
node_pt                                defined         pointer                  dcl 41 ref 91
node_pts                               parameter       pointer                  dcl 37 ref 35 91 91
null                                                   builtin function         dcl 64 ref 134
offset                    0(03)        based           fixed bin(14,0)          level 2 packed packed unaligned dcl 66 set ref 149
                                                                                  160*
operand                   1            based           pointer                  array level 2 packed packed unaligned dcl 4-6 ref 97
                                                                                  98
operator                               based           structure                level 1 dcl 4-6
ora                                    constant        fixed bin(15,0)          initial dcl 76 ref 234
p                               000106 automatic       pointer                  dcl 44 set ref 91* 97 98 130*
p1                              000100 automatic       pointer                  dcl 44 set ref 93* 100 102 112 117 130* 143* 149 153
                                                                                  153 155 157 157 160 170* 172 174 174 175 176* 179
                                                                                  183 190 242 253
p1_address                             based           structure                level 1 dcl 66
p2                              000102 automatic       pointer                  dcl 44 set ref 94* 103 125 125 125 130* 134 134 134
                                                                                  149 153 168* 192 192* 200 208* 234* 245* 257 258*
                                                                                  262 262 264*
p3                              000104 automatic       pointer                  dcl 44 set ref 95* 104 112* 130* 185* 209* 249*
perm_address             12(18)        based           bit(1)                   level 3 packed packed unaligned dcl 3-3 set ref 175*
                                                                                  183* 190*
q2                              000110 automatic       pointer                  dcl 44 set ref 97* 245* 257* 258* 262* 264*
q3                              000112 automatic       pointer                  dcl 44 set ref 98* 112* 202* 212* 249*
ref                                    defined         pointer                  array dcl 41 ref 93 94 95
ref_count                 0(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 3-3 set ref 125*
                                                                                  125 174* 174 257
reference                              based           structure                level 1 dcl 3-3
refs                                   parameter       pointer                  array dcl 37 ref 35 93 93 94 94 95 95
s2                              000117 automatic       fixed bin(17,0)          dcl 44 set ref 105* 234*
shared                    0(11)        based           bit(1)                   level 2 packed packed unaligned dcl 3-3 ref 125 192
size                     16            based           fixed bin(8,0)           level 3 dcl 6-6 set ref 237*
size1                           000120 automatic       fixed bin(17,0)          dcl 44 set ref 102* 217 237
size2                           000121 automatic       fixed bin(17,0)          dcl 44 set ref 103* 105 206 224 232* 232* 256
size3                           000122 automatic       fixed bin(17,0)          dcl 44 set ref 104* 224
state_man$erase_reg             000030 constant        entry                    external dcl 44 ref 215
string_temp                     000010 constant        entry                    external dcl 44 ref 130
tag                      10(30)        based           bit(6)                   level 3 in structure "reference" packed packed
                                                                                  unaligned dcl 3-3 in procedure "cat_op" set ref
                                                                                  172 179*
tag                             000124 automatic       bit(4)                   dcl 44 in procedure "cat_op" set ref 168* 179
type                            000115 automatic       fixed bin(17,0)          dcl 44 set ref 100* 101 106
units_per_word                  000004 constant        fixed bin(8,0)           initial array dcl 2-5 ref 149 153 155 157
varying_ref               0(10)        based           bit(1)                   level 2 packed packed unaligned dcl 3-3 ref 134 262
word_offset                     000127 automatic       fixed bin(15,0)          dcl 44 set ref 149* 151 158* 158 160

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
bit_string                             internal static fixed bin(15,0)          initial dcl 5-1
bits_per_char                          internal static fixed bin(8,0)           initial dcl 2-5
bits_per_four_words                    internal static fixed bin(8,0)           initial dcl 2-5
bits_per_half                          internal static fixed bin(8,0)           initial dcl 2-5
bits_per_packed_digit                  internal static fixed bin(8,1)           initial dcl 2-35
bits_per_words                         internal static fixed bin(8,0)           initial array dcl 2-5
break_even_bits                        internal static fixed bin(8,0)           initial dcl 2-5
break_even_words                       internal static fixed bin(8,0)           initial dcl 2-5
chars_per_word                         internal static fixed bin(8,0)           initial dcl 2-5
complex_fix_bin_1                      internal static fixed bin(15,0)          initial dcl 5-1
complex_fix_bin_2                      internal static fixed bin(15,0)          initial dcl 5-1
complex_fix_dec                        internal static fixed bin(15,0)          initial dcl 5-1
complex_flt_bin_1                      internal static fixed bin(15,0)          initial dcl 5-1
complex_flt_bin_2                      internal static fixed bin(15,0)          initial dcl 5-1
complex_flt_dec                        internal static fixed bin(15,0)          initial dcl 5-1
convert_offset                         internal static fixed bin(8,1)           initial array dcl 2-35
default_fix_bin_p                      internal static fixed bin(8,0)           initial dcl 2-5
digit_                                 internal static fixed bin(3,0)           initial dcl 1-5
entry_variable                         internal static fixed bin(15,0)          initial dcl 5-1
ext_entry_in                           internal static fixed bin(15,0)          initial dcl 5-1
ext_entry_out                          internal static fixed bin(15,0)          initial dcl 5-1
half_                                  internal static fixed bin(3,0)           initial dcl 1-5
ind_arithmetic                         internal static fixed bin(17,0)          initial dcl 6-68
ind_decimal_reg                        internal static fixed bin(17,0)          initial dcl 6-68
ind_invalid                            internal static fixed bin(17,0)          initial dcl 6-68
ind_known_refs                         internal static fixed bin(17,0)          initial dcl 6-68
ind_logical                            internal static fixed bin(17,0)          initial dcl 6-68
ind_string_aq                          internal static fixed bin(17,0)          initial dcl 6-68
ind_x                                  internal static fixed bin(17,0)          initial array dcl 6-68
int_entry                              internal static fixed bin(15,0)          initial dcl 5-1
int_entry_other                        internal static fixed bin(15,0)          initial dcl 5-1
label_constant                         internal static fixed bin(15,0)          initial dcl 5-1
label_size                             internal static fixed bin(8,0)           initial dcl 2-5
label_variable                         internal static fixed bin(15,0)          initial dcl 5-1
local_label_variable                   internal static fixed bin(15,0)          initial dcl 5-1
max_dec_scale                          internal static fixed bin(8,0)           initial dcl 2-5
max_index_register_value               internal static fixed bin(31,0)          initial dcl 2-38
max_length_p                           internal static fixed bin(8,0)           initial dcl 2-5
max_number_of_operands                 internal static fixed bin(15,0)          initial dcl 4-15
max_offset                             internal static fixed bin(8,0)           initial array dcl 2-5
max_p_fix_bin_1                        internal static fixed bin(8,0)           initial dcl 2-5
max_p_fix_dec                          internal static fixed bin(8,0)           initial dcl 2-5
max_p_flt_bin_1                        internal static fixed bin(8,0)           initial dcl 2-5
max_p_xreg                             internal static fixed bin(8,0)           initial dcl 2-5
max_short_size                         internal static fixed bin(8,0)           initial array dcl 2-5
min_dec_scale                          internal static fixed bin(8,0)           initial dcl 2-5
mod2_                                  internal static fixed bin(3,0)           initial dcl 1-5
mod4_                                  internal static fixed bin(3,0)           initial dcl 1-5
packed_digits_per_char                 internal static fixed bin(8,0)           initial dcl 2-5
packed_digits_per_word                 internal static fixed bin(8,0)           initial dcl 2-5
packed_ptr                             internal static fixed bin(15,0)          initial dcl 5-1
real_fix_bin_1                         internal static fixed bin(15,0)          initial dcl 5-1
real_fix_bin_2                         internal static fixed bin(15,0)          initial dcl 5-1
real_fix_dec                           internal static fixed bin(15,0)          initial dcl 5-1
real_flt_bin_1                         internal static fixed bin(15,0)          initial dcl 5-1
real_flt_bin_2                         internal static fixed bin(15,0)          initial dcl 5-1
real_flt_dec                           internal static fixed bin(15,0)          initial dcl 5-1
sta                                    internal static fixed bin(15,0)          initial dcl 76
unpacked_ptr                           internal static fixed bin(15,0)          initial dcl 5-1
word_                                  internal static fixed bin(3,0)           initial dcl 1-5

NAMES DECLARED BY EXPLICIT CONTEXT.
aa                              000127 constant        label                    dcl 117
aa_2                            000414 constant        label                    dcl 206
aa_2a                           000437 constant        label                    dcl 209 ref 259
aa_3                            000453 constant        label                    dcl 212 ref 246
aa_l1                           000133 constant        label                    dcl 125 ref 266
aa_l3                           000161 constant        label                    dcl 134
ae                              000114 constant        label                    dcl 112
begin                           000040 constant        label                    dcl 91
cat_op                          000030 constant        entry                    external dcl 35
ea                              000616 constant        label                    dcl 253
ea1                             000654 constant        label                    dcl 262
ee                              000571 constant        label                    dcl 242
ee1                             000574 constant        label                    dcl 245 ref 256
set_perm                        000334 constant        label                    dcl 183 ref 161
switch                          000000 constant        label                    array(0:3) dcl 112 ref 108

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1072        1140     710        1102
Length      1446     710        46         272     162           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cat_op                              110 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cat_op                   000100 p1                          cat_op
                         000102 p2                          cat_op
                         000104 p3                          cat_op
                         000106 p                           cat_op
                         000110 q2                          cat_op
                         000112 q3                          cat_op
                         000114 dt                          cat_op
                         000115 type                        cat_op
                         000116 n                           cat_op
                         000117 s2                          cat_op
                         000120 size1                       cat_op
                         000121 size2                       cat_op
                         000122 size3                       cat_op
                         000123 macro                       cat_op
                         000124 tag                         cat_op
                         000125 base                        cat_op
                         000126 lunits                      cat_op
                         000127 word_offset                 cat_op
                         000130 m_s_p                       cat_op

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               call_ext_out        return_mac          mdfx1               ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
adjust_ref_count              aq_man$clear_q                base_man$load_any_var         c_a
compile_exp                   compile_exp$save              compile_exp$save_exp          expmac
expmac$eis                    expmac$one                    load_size$xr_or_aq            m_a
state_man$erase_reg           string_temp

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
cg_static_$m_s_p




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     35 000024    6    3 000035        91 000040        93 000044        94 000047        95 000052        97 000054
     98 000057       100 000062       101 000066       102 000070       103 000072       104 000076       105 000102
    106 000107       108 000112       112 000114       117 000127       125 000133       130 000144       134 000161
    143 000173       145 000206       147 000213       149 000215       151 000230       153 000232       155 000236
    157 000241       158 000243       160 000244       161 000251       168 000252       170 000263       172 000276
    174 000302       175 000307       176 000311       179 000326       183 000334       185 000336       187 000352
    190 000357       192 000362       195 000400       200 000401       202 000404       203 000413       206 000414
    208 000424       209 000437       210 000452       212 000453       215 000462       217 000473       219 000476
    224 000500       228 000517       230 000520       232 000522       234 000550       237 000565       238 000570
    242 000571       245 000574       246 000605       249 000606       253 000616       256 000622       257 000625
    258 000642       259 000653       262 000654       264 000673       266 000704


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
