	COMPILATION LISTING OF SEGMENT le_create_binary_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 12/10/86  1255.9 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /****^  HISTORY COMMENTS:
        8*  1) change(86-08-12,Elhard), approve(86-08-12,MCR7505),
        9*     audit(86-12-10,DGHowe), install(86-12-10,MR12.0-1241):
       10*     Originally written to create the output binary, and to resolve conflicts
       11*     between single segment or MSF output.
       12*                                                   END HISTORY COMMENTS */
       13 
       14 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       15 
       16 le_create_binary_:
       17   proc (lecp,			/** components pointer  (in )	*/
       18        dname,			/** input dirname	    (in )	*/
       19        ename,			/** input entryname	    (in ) */
       20        comp_count,			/** component count	    (in ) */
       21        force,			/** force switch	    (in ) */
       22        act_dname,			/** actual dirname	    (out) */
       23        act_ename);			/** actual entryname    (out) */
       24 
       25   /*** ****************************************************************/
       26   /***							*/
       27   /***	Name:	le_create_binary_				*/
       28   /***	Input:	lecp, dname, ename, comp_count		*/
       29   /***	Function:	If the leb.n_binaries is greater than 1, (ie. the	*/
       30   /***		output binary is an MSF), we create a single	*/
       31   /***		component MSF, and adjust the pathnames so	*/
       32   /***		that the segments are created in the MSF dir.	*/
       33   /***	Output:	act_dname, act_ename			*/
       34   /***							*/
       35   /*** ****************************************************************/
       36 
       37   /* constants */
       38 
       39   dcl true		bit (1) static options (constant) init ("1"b);
       40   dcl false		bit (1) static options (constant) init ("0"b);
       41 
       42   /* parameters */
       43 
       44   dcl lecp		ptr parameter;
       45   dcl dname		char (*) parameter;
       46   dcl ename		char (*) parameter;
       47   dcl comp_count		fixed bin parameter;
       48   dcl force		bit (1) parameter;
       49   dcl act_dname		char (*) parameter;
       50   dcl act_ename		char (*) parameter;
       51 
       52   /* procedures */
       53 
       54   dcl get_group_id_$tag_star	entry () returns (char (32));
       55   dcl hcs_$add_acl_entries	entry (char (*), char (*), ptr, fixed bin,
       56 			fixed bin (35));
       57   dcl hcs_$status_long	entry (char (*), char (*), fixed bin (1), ptr,
       58 			ptr, fixed bin (35));
       59   dcl le_error_		entry options (variable);
       60   dcl le_util_$check_uid	entry (ptr, ptr, bit (36) aligned)
       61 			returns (bit (1));
       62   dcl make_msf_		entry (char (*), char (*), (3) fixed bin (6),
       63 			fixed bin (35));
       64   dcl nd_handler_		entry (char (*), char (*), char (*),
       65 			fixed bin (35));
       66   dcl nd_handler_$force	entry (char (*), char (*), char (*),
       67 			fixed bin (35));
       68   dcl object_info_$brief	entry (ptr, fixed bin (24), ptr,
       69 			fixed bin (35));
       70   dcl object_lib_$initiate	entry (char (*), char (*), char (*), bit (1),
       71 			ptr,
       72 			fixed bin (24), bit (1), fixed bin (35));
       73   dcl pathname_		entry (char (*), char (*)) returns (char (168));
       74   dcl unmake_msf_		entry (char (*), char (*), bit (1),
       75 			(3) fixed bin (6), fixed bin (35));
       76 
       77   /* external */
       78 
       79   dcl error_table_$noentry	external fixed bin (35);
       80   dcl le_data_$caller	external char (32) varying;
       81   dcl le_et_$input_output_overlap
       82 			external fixed bin (35);
       83 
       84   /* automatic */
       85 
       86   dcl abort		bit (1) automatic;
       87   dcl bc			fixed bin (24) automatic;
       88   dcl 01 br_info		aligned like status_branch automatic;
       89   dcl deleted		bit (1) automatic;
       90   dcl ec			fixed bin (35) automatic;
       91   dcl msf_sw		bit (1) automatic;
       92   dcl 01 my_acl		aligned like segment_acl_entry automatic;
       93   dcl 01 oi		aligned like object_info automatic;
       94   dcl rbs			(3) fixed bin (6) automatic;
       95   dcl segp		ptr automatic;
       96 
       97   /* conditions */
       98 
       99   dcl le_abort_		condition;
      100 
      101   /* builtin */
      102 
      103   dcl addr		builtin;
      104   dcl null		builtin;
      105 
      106   abort = false;
      107   act_dname = dname;
      108   act_ename = ename;
      109 
      110   /* see if the item exists at all.  If not, just return */
      111 
      112   call hcs_$status_long (dname, ename, 1, addr (br_info), null, ec);
      113   if ec = error_table_$noentry
      114     then do;
      115 
      116       /* the target does not exist, we create it if the output target	*/
      117       /* an msf and adjust the pathnames accordingly.		*/
      118 
      119       if comp_count > 1
      120         then do;
      121 	call make_msf_ (dname, ename, rbs, ec);
      122 	if ec ^= 0
      123 	  then call le_error_ (LE_ABORT_ERROR, ec,
      124 		  "Unable to create MSF output file ^a.",
      125 		  pathname_ (dname, ename));
      126 	act_dname = pathname_ (dname, ename);
      127 	act_ename = ename;
      128         end;
      129 
      130       return;
      131     end;
      132 
      133   if le_util_$check_uid (lecp, null, (br_info.uid))
      134     then call le_error_ (LE_ABORT_ERROR, le_et_$input_output_overlap,
      135 	    "^/The output file is the same as one of the input files.");
      136 
      137   /* try to initiate it as an object and validate that it is one.	*/
      138   /* We generally want to query any time the target exists but is not	*/
      139   /* an object file.  Object_lib_$initiate will only return		*/
      140   /* a zero code when called with the validate switch set if the	*/
      141   /* target is a legitimate object file.			*/
      142 
      143   deleted = false;
      144 
      145   call object_lib_$initiate (dname, ename, "", "1"b, segp, bc, msf_sw, ec);
      146   if ec ^= 0
      147     then do;
      148       msf_sw = false;
      149       if ^force
      150         then call nd_handler_ ((le_data_$caller), dname, ename, ec);
      151         else call nd_handler_$force ((le_data_$caller), dname, ename, ec);
      152       if ec ^= 0
      153         then signal le_abort_;
      154       deleted = true;
      155     end;
      156     else do;
      157       oi.version_number = object_info_version_2;
      158       call object_info_$brief (segp, bc, addr (oi), ec);
      159       if ^oi.format.bound
      160         then do;
      161 	if force
      162 	  then call nd_handler_$force ((le_data_$caller), dname, ename, ec);
      163 	  else call nd_handler_ ((le_data_$caller), dname, ename, ec);
      164 	if ec ^= 0
      165 	  then signal le_abort_;
      166 	msf_sw = false;
      167 	deleted = true;
      168         end;
      169     end;
      170 
      171   if msf_sw
      172     then do;
      173 
      174       /* convert it to a SSF */
      175 
      176       call unmake_msf_ (dname, ename, ""b, rbs, ec);
      177       if ec ^= 0
      178         then call le_error_ (LE_ABORT_ERROR, ec,
      179 	        "^/Unable to truncate MSF to a single segment. ^a",
      180 	        pathname_ (dname, ename));
      181 
      182     end;
      183 
      184   if comp_count > 1
      185     then do;
      186 
      187       if ^deleted
      188         then do;
      189 
      190 	/* give myself enough access to turn this thing into an MSF */
      191 
      192 	my_acl.access_name = get_group_id_$tag_star ();
      193 	my_acl.mode = REW_ACCESS;
      194 	my_acl.extended_mode = ""b;
      195 	my_acl.status_code = 0;
      196 
      197 	call hcs_$add_acl_entries (dname, ename, addr (my_acl), 1, ec);
      198         end;
      199 
      200       /* create/convert MSF */
      201 
      202       call make_msf_ (dname, ename, rbs, ec);
      203 
      204       if ec ^= 0
      205         then call le_error_ (LE_ABORT_ERROR, ec,
      206 	        "^/Unable to convert ^a to MSF format",
      207 	        pathname_ (dname, ename));
      208 
      209       act_dname = pathname_ (dname, ename);
      210     end;
      211 
      212   return;
      213 
      214 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      215 
      216 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      217 
      218 
  1     1 /* Begin include file -- acl_structures.incl.pl1 BIM 3/82 */
  1     2 /* format: style3,indcomtxt,idind30 */
  1     3 
  1     4 declare   acl_ptr                       pointer;
  1     5 declare   acl_count                     fixed bin;
  1     6 
  1     7 declare 1 general_acl                   aligned based (acl_ptr), /* for fs_util_ */
  1     8           2 version                     char (8) aligned,
  1     9           2 count                       fixed bin,
  1    10           2 entries                     (acl_count refer (general_acl.count)) aligned like general_acl_entry;
  1    11 
  1    12 declare 1 general_acl_entry             based,
  1    13           2 access_name                 character (32) unaligned,
  1    14           2 mode                        bit (36) aligned,
  1    15           2 status_code                 fixed bin (35);
  1    16 
  1    17 
  1    18 declare 1 general_extended_acl          aligned based (acl_ptr), /* for fs_util_ */
  1    19           2 version                     char (8) aligned,
  1    20           2 count                       fixed bin,
  1    21           2 entries                     (acl_count refer (general_extended_acl.count)) aligned like general_extended_acl_entry;
  1    22 
  1    23 declare 1 general_extended_acl_entry    aligned based,
  1    24           2 access_name                 character (32) unaligned,
  1    25           2 mode                        bit (36) aligned,
  1    26           2 extended_mode               bit (36) aligned,
  1    27           2 status_code                 fixed bin (35);
  1    28 
  1    29 
  1    30 declare 1 general_delete_acl            aligned based (acl_ptr), /* for file_system_ */
  1    31           2 version                     char (8) aligned,
  1    32           2 count                       fixed bin,
  1    33           2 entries                     (acl_count refer (general_delete_acl.count)) aligned like delete_acl_entry;
  1    34 
  1    35 declare 1 general_delete_acl_entry      aligned based,
  1    36           2 access_name                 character (32) unaligned,
  1    37           2 status_code                 fixed bin (35);
  1    38 
  1    39 
  1    40 declare 1 segment_acl                   aligned based (acl_ptr),
  1    41           2 version                     fixed bin,
  1    42           2 count                       fixed bin,
  1    43           2 entries                     (acl_count refer (segment_acl.count)) aligned like segment_acl_entry;
  1    44 
  1    45 declare 1 segment_acl_entry             like general_extended_acl_entry aligned based;
  1    46 declare 1 segment_acl_array             (acl_count) aligned like segment_acl_entry based (acl_ptr);
  1    47 
  1    48 
  1    49 declare 1 directory_acl                 aligned based (acl_ptr),
  1    50           2 version                     fixed bin,
  1    51           2 count                       fixed bin,
  1    52           2 entries                     (acl_count refer (directory_acl.count)) aligned like directory_acl_entry;
  1    53 
  1    54 declare 1 directory_acl_entry           like general_acl_entry aligned based;
  1    55 declare 1 directory_acl_array           (acl_count) aligned like directory_acl_entry based (acl_ptr);
  1    56 
  1    57 
  1    58 declare 1 delete_acl                    based (acl_ptr) aligned,
  1    59           2 version                     fixed bin,
  1    60           2 count                       fixed bin,
  1    61           2 entries                     (acl_count refer (delete_acl.count)) aligned like delete_acl_entry;
  1    62 
  1    63 declare 1 delete_acl_entry              like general_delete_acl_entry aligned based;
  1    64 declare 1 delete_acl_array              (acl_count) aligned like delete_acl_entry based (acl_ptr);
  1    65 
  1    66 
  1    67 declare  (SEG_ACL_VERSION_1             init ("sga1"),
  1    68           DIR_ACL_VERSION_1             init ("dra1"),
  1    69           DELETE_ACL_VERSION_1          init ("dla1"))
  1    70                                         char (4) int static options (constant);
  1    71 
  1    72 declare  (GENERAL_ACL_VERSION_1         init ("gacl001"),
  1    73           GENERAL_EXTENDED_ACL_VERSION_1 init ("gxacl001"),
  1    74           GENERAL_DELETE_ACL_VERSION_1  init ("gdacl001"))
  1    75                                         char (8) internal static options (constant);
  1    76 
  1    77 declare   ACL_VERSION_1                 fixed bin init (1) int static options (constant);
  1    78 
  1    79 /* End include file acl_structures.incl.pl1 */
      219 
  2     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  2     2*
  2     3*   Values for the "access mode" argument so often used in hardcore
  2     4*   James R. Davis 26 Jan 81  MCR 4844
  2     5*   Added constants for SM access 4/28/82 Jay Pattin
  2     6*   Added text strings 03/19/85 Chris Jones
  2     7**/
  2     8 
  2     9 
  2    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  2    11 dcl	(
  2    12 	N_ACCESS		   init ("000"b),
  2    13 	R_ACCESS		   init ("100"b),
  2    14 	E_ACCESS		   init ("010"b),
  2    15 	W_ACCESS		   init ("001"b),
  2    16 	RE_ACCESS		   init ("110"b),
  2    17 	REW_ACCESS	   init ("111"b),
  2    18 	RW_ACCESS		   init ("101"b),
  2    19 	S_ACCESS		   init ("100"b),
  2    20 	M_ACCESS		   init ("010"b),
  2    21 	A_ACCESS		   init ("001"b),
  2    22 	SA_ACCESS		   init ("101"b),
  2    23 	SM_ACCESS		   init ("110"b),
  2    24 	SMA_ACCESS	   init ("111"b)
  2    25 	)		   bit (3) internal static options (constant);
  2    26 
  2    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  2    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  2    29 
  2    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  2    31 			   static options (constant);
  2    32 
  2    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  2    34 			   static options (constant);
  2    35 
  2    36 dcl	(
  2    37 	N_ACCESS_BIN	   init (00000b),
  2    38 	R_ACCESS_BIN	   init (01000b),
  2    39 	E_ACCESS_BIN	   init (00100b),
  2    40 	W_ACCESS_BIN	   init (00010b),
  2    41 	RW_ACCESS_BIN	   init (01010b),
  2    42 	RE_ACCESS_BIN	   init (01100b),
  2    43 	REW_ACCESS_BIN	   init (01110b),
  2    44 	S_ACCESS_BIN	   init (01000b),
  2    45 	M_ACCESS_BIN	   init (00010b),
  2    46 	A_ACCESS_BIN	   init (00001b),
  2    47 	SA_ACCESS_BIN	   init (01001b),
  2    48 	SM_ACCESS_BIN	   init (01010b),
  2    49 	SMA_ACCESS_BIN	   init (01011b)
  2    50 	)		   fixed bin (5) internal static options (constant);
  2    51 
  2    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      220 
  3     1 /****  START OF:	le_data.incl.pl1			 *  *  *  *  *  */
  3     2 
  3     3 /****^  HISTORY COMMENTS:
  3     4*  1) change(86-08-12,Elhard), approve(86-08-12,MCR7505),
  3     5*     audit(86-12-10,DGHowe), install(86-12-10,MR12.0-1241):
  3     6*     Originally written to define the structures used internally by le_.
  3     7*                                                   END HISTORY COMMENTS */
  3     8 
  3     9   /*** ****************************************************************/
  3    10   /***							*/
  3    11   /***	Name:	le_data					*/
  3    12   /***	Function:	This include file defines the data structures	*/
  3    13   /***		used internally by the linkage_editor subroutine.	*/
  3    14   /***							*/
  3    15   /*** ****************************************************************/
  3    16   
  3    17   /* error severity constants */
  3    18   
  3    19   dcl LE_WARNING		fixed bin static options (constant) init (1);
  3    20   dcl LE_ERROR		fixed bin static options (constant) init (2);
  3    21   dcl LE_FATAL_ERROR	fixed bin static options (constant) init (3);
  3    22   dcl LE_ABORT_ERROR	fixed bin static options (constant) init (4);
  3    23   
  3    24   /* section identifier constants */
  3    25   
  3    26   dcl Text		fixed bin (3) static options (constant)
  3    27 			init (0);
  3    28   dcl Linkage		fixed bin (3) static options (constant)
  3    29 			init (1);
  3    30   dcl Symbol		fixed bin (3) static options (constant)
  3    31 			init (2);
  3    32   dcl Definition		fixed bin (3) static options (constant)
  3    33 			init (3);
  3    34   dcl Static		fixed bin (3) static options (constant)
  3    35 			init (4);
  3    36   dcl System		fixed bin (3) static options (constant)
  3    37 			init (5);
  3    38   dcl Heap		fixed bin (3) static options (constant)
  3    39 			init (6);
  3    40   
  3    41   dcl section_nm		(0:6) char (16) static options (constant)
  3    42 			init ("text", "linkage", "symbol", "definition",
  3    43 			"static", "system", "heap");
  3    44   
  3    45   /* link type constants */
  3    46   
  3    47   dcl Self_Base		fixed bin (3) static options (constant)
  3    48 			init (1);
  3    49   dcl Refname_Base		fixed bin (3) static options (constant)
  3    50 			init (3);
  3    51   dcl Refname_Offsetname	fixed bin (3) static options (constant)
  3    52 			init (4);
  3    53   dcl Self_Offsetname	fixed bin (3) static options (constant)
  3    54 			init (5);
  3    55   
  3    56   /* backpatch type constants */
  3    57   
  3    58   dcl Patch_Link		fixed bin static options (constant) init (1);
  3    59   dcl Patch_Init		fixed bin static options (constant) init (2);
  3    60   dcl Patch_Symbol_Ref	fixed bin static options (constant) init (3);
  3    61   dcl Patch_Self_Init	fixed bin static options (constant) init (4);
  3    62   
  3    63   /*** ****************************************************************/
  3    64   /***							*/
  3    65   /***	Name:	le_components				*/
  3    66   /***	Function:	the component table is used to keep information	*/
  3    67   /***		about the input components being used and their	*/
  3    68   /***		disposition in output components.		*/
  3    69   /***							*/
  3    70   /*** ****************************************************************/
  3    71   
  3    72   dcl 01 le_components	aligned based,
  3    73        02 header		aligned,
  3    74         03 flags		aligned,
  3    75          04 separate_static	bit (1) unaligned,
  3    76          04 perprocess_static	bit (1) unaligned,
  3    77          04 mbz		bit (34) unaligned,
  3    78         03 n_components	fixed bin,
  3    79        02 comp		(0 refer (le_components.n_components))
  3    80 			like le_comp;
  3    81   
  3    82   /*** ****************************************************************/
  3    83   /***							*/
  3    84   /***	Name:	le_comp					*/
  3    85   /***	Function:	this is a single component table entry.		*/
  3    86   /***							*/
  3    87   /*** ****************************************************************/
  3    88   
  3    89   dcl 01 le_comp		aligned based,
  3    90        02 segp		ptr,
  3    91        02 bc		fixed bin (24),
  3    92        02 uid		bit (36) aligned,
  3    93        02 dtcm		fixed bin (71),
  3    94        02 name		char (32) varying,
  3    95        02 path		char (194) varying,
  3    96        02 compiler		char (8),
  3    97        02 target		fixed bin,
  3    98        02 flags		aligned,
  3    99         03 library		bit (1) unaligned,
  3   100         03 include		bit (1) unaligned,
  3   101         03 delete_table	bit (1) unaligned,
  3   102         03 separate_static	bit (1) unaligned,
  3   103         03 io_table		bit (1) unaligned,
  3   104         03 unique_path	bit (1) unaligned,
  3   105         03 mbz		bit (30) unaligned,
  3   106        02 tables		aligned,
  3   107         03 lesp		ptr,
  3   108         03 ledp		ptr,
  3   109         03 lelp		ptr,
  3   110        02 orig		aligned,
  3   111         03 textp		ptr,
  3   112         03 defnp		ptr,
  3   113         03 linkp		ptr,
  3   114         03 statp		ptr,
  3   115         03 symbp		ptr,
  3   116         03 rel_textp	ptr,
  3   117         03 rel_symbp	ptr,
  3   118         03 rel_linkp	ptr,
  3   119         03 textl		fixed bin (18) unsigned unaligned,
  3   120         03 defnl		fixed bin (18) unsigned unaligned,
  3   121         03 linkl		fixed bin (18) unsigned unaligned,
  3   122         03 statl		fixed bin (18) unsigned unaligned,
  3   123         03 symbl		fixed bin (18) unsigned unaligned,
  3   124         03 symbl_no_rel	fixed bin (18) unsigned unaligned,
  3   125         03 symbl_no_table	fixed bin (18) unsigned unaligned,
  3   126         03 n_symb_blocks	fixed bin (18) unsigned unaligned,
  3   127         03 text_boundary	fixed bin (9) unsigned unaligned,
  3   128         03 static_boundary	fixed bin (9) unsigned unaligned,
  3   129         03 next_comp	fixed bin (18) unsigned unaligned,
  3   130        02 new		aligned,
  3   131         03 rel_text		fixed bin (18) unsigned unaligned,
  3   132         03 rel_symb		fixed bin (18) unsigned unaligned,
  3   133         03 rel_stat		fixed bin (18) unsigned unaligned,
  3   134         03 text_pad		fixed bin (18) unsigned unaligned,
  3   135         03 static_pad	fixed bin (18) unsigned unaligned,
  3   136         03 symbol_pad	fixed bin (18) unsigned unaligned;
  3   137   
  3   138   /*** ****************************************************************/
  3   139   /***							*/
  3   140   /***	Name:	le_segnames				*/
  3   141   /***	Function:	the segname table is used for two purposes:	*/
  3   142   /***		 - to determine the target components of links	*/
  3   143   /***		   being resolved internally.			*/
  3   144   /***		 - to determine the segname definitions to be	*/
  3   145   /***		   emited for definitions being retained.	*/
  3   146   /***							*/
  3   147   /*** ****************************************************************/
  3   148   
  3   149   dcl 01 le_segnames	aligned based,
  3   150        02 header		aligned,
  3   151         03 n_segnames	fixed bin,
  3   152        02 segname		(segname_count refer (le_segnames.n_segnames)),
  3   153         03 str		char (32) varying,
  3   154         03 relp		fixed bin (18) unsigned unaligned,
  3   155         03 pad		bit (18) unaligned;
  3   156   dcl segname_count		fixed bin automatic;
  3   157   
  3   158   /*** ****************************************************************/
  3   159   /***							*/
  3   160   /***	Name:	le_definitions				*/
  3   161   /***	Function:	the definition table contains the definitions	*/
  3   162   /***		from the input components and is used to resolve	*/
  3   163   /***		link targets, and regenerate definition entries	*/
  3   164   /***							*/
  3   165   /*** ****************************************************************/
  3   166   
  3   167   dcl 01 le_definitions	aligned based,
  3   168        02 header		aligned,
  3   169         03 n_defs		fixed bin,
  3   170         03 pad		bit (36),
  3   171        02 def		(def_count refer (le_definitions.n_defs))
  3   172 			like le_definition;
  3   173   dcl def_count		fixed bin automatic;
  3   174   
  3   175   dcl 01 le_definition	aligned based,
  3   176        02 str		char (256) varying,
  3   177        02 type		fixed bin (18) unsigned unaligned,
  3   178        02 relp		fixed bin (18) unsigned unaligned,
  3   179        02 offset		fixed bin (18) unsigned unaligned,
  3   180        02 new_offset	fixed bin (18) unsigned unaligned,
  3   181        02 flags		aligned,
  3   182         03 force_retain	bit (1) unaligned,
  3   183         03 entrypoint	bit (1) unaligned,
  3   184         03 ignore		bit (1) unaligned,
  3   185         03 referenced	bit (1) unaligned,
  3   186         03 no_link		bit (1) unaligned,
  3   187         03 retain		bit (1) unaligned,
  3   188         03 delete		bit (1) unaligned,
  3   189         03 mbz		bit (29) unaligned;
  3   190   
  3   191   /*** ****************************************************************/
  3   192   /***							*/
  3   193   /***	Name:	le_options				*/
  3   194   /***	Function:	the option table contains definition retention	*/
  3   195   /***		information.  The input retentions options are	*/
  3   196   /***		ordered such that a linear search of the option	*/
  3   197   /***		table for the first matching starname will give	*/
  3   198   /***		the correct retention state.			*/
  3   199   /***							*/
  3   200   /*** ****************************************************************/
  3   201   
  3   202   dcl 01 le_options		aligned based,
  3   203        02 header		aligned,
  3   204         03 n_opts		fixed bin,
  3   205        02 opt		(0 refer (le_options.n_opts)),
  3   206         03 type		fixed bin (8) unaligned,
  3   207         03 used		bit (1) unaligned,
  3   208         03 inhibit_error	bit (1) unaligned,
  3   209         03 class		fixed bin (6) unaligned,
  3   210         03 order		fixed bin (17) unaligned,
  3   211         03 segname		char (32) unaligned,
  3   212         03 ep_name		char (256) unaligned;
  3   213   
  3   214   /*** ****************************************************************/
  3   215   /***							*/
  3   216   /***	Name:	le_links					*/
  3   217   /***	Function:	the link table contains information on all of the	*/
  3   218   /***		links in the input components. It is used to	*/
  3   219   /***		determine link targets, which library components	*/
  3   220   /***		will be included, and what init_info will be	*/
  3   221   /***		used, and where it will be placed.		*/
  3   222   /***							*/
  3   223   /*** ****************************************************************/
  3   224   
  3   225   dcl 01 le_links		aligned based,
  3   226        02 header		aligned,
  3   227         03 offset_adjustment	fixed bin (18),
  3   228         03 n_links		fixed bin,
  3   229        02 link		(link_count refer (le_links.n_links))
  3   230 			like le_link;
  3   231   dcl link_count		fixed bin automatic;
  3   232 
  3   233   dcl 01 le_link		aligned based,
  3   234        02 flags		unaligned,
  3   235         03 used		bit (1),
  3   236         03 mbx		bit (35),
  3   237        02 type		fixed bin (6) unsigned unaligned,
  3   238        02 class		fixed bin (6) unsigned unaligned,
  3   239        02 mod		bit (6) unaligned,
  3   240        02 exp		fixed bin (17) unaligned,
  3   241        02 target		fixed bin (18) unsigned unaligned,
  3   242        02 defx		fixed bin (18) unsigned unaligned,
  3   243        02 relp		fixed bin (18) unsigned unaligned,
  3   244        02 target_comp	fixed bin (18) unsigned unaligned,
  3   245        02 target_link	fixed bin (18) unsigned unaligned,
  3   246        02 extension		fixed bin (18) unsigned unaligned,
  3   247        02 initp		ptr unaligned,
  3   248        02 segnamep		ptr unaligned,
  3   249        02 offsetp		ptr unaligned;
  3   250   
  3   251   /*** ****************************************************************/
  3   252   /***							*/
  3   253   /***	Name:	le_binaries				*/
  3   254   /***	Function:	This table contains information about the output	*/
  3   255   /***		binaries.  It is primarily used for creation and	*/
  3   256   /***		backpatching of MSF output.			*/
  3   257   /***							*/
  3   258   /*** ****************************************************************/
  3   259   
  3   260   dcl 01 le_binaries	aligned based,
  3   261        02 header		aligned,
  3   262         03 n_binaries	fixed bin,
  3   263         03 pad		bit (36),
  3   264        02 binary		(0:0 refer (le_binaries.n_binaries)),
  3   265         03 segp		ptr,
  3   266         03 bc		fixed bin (24),
  3   267         03 uid		bit (36),
  3   268         03 aclc		fixed bin,
  3   269         03 aclp		ptr,
  3   270         03 textp		ptr,
  3   271         03 defnp		ptr,
  3   272         03 linkp		ptr,
  3   273         03 symbp		ptr,
  3   274         03 statp		ptr,
  3   275         03 textl		fixed bin (18) unsigned unaligned,
  3   276         03 defnl		fixed bin (18) unsigned unaligned,
  3   277         03 linkl		fixed bin (18) unsigned unaligned,
  3   278         03 symbl		fixed bin (18) unsigned unaligned,
  3   279         03 statl		fixed bin (18) unsigned unaligned,
  3   280         03 mbz2		bit (18) unaligned;
  3   281   
  3   282   /*** ****************************************************************/
  3   283   /***							*/
  3   284   /***	Name:	le_patches				*/
  3   285   /***	Function:	This table contains the list of backpatches to be	*/
  3   286   /***		performed when the rest of the object creation is	*/
  3   287   /***		complete. Since le_backpatch_ is the only routine	*/
  3   288   /***		concerned with this,  it is maintained completely	*/
  3   289   /***		internal to le_backpatch_.			*/
  3   290   /***							*/
  3   291   /*** ****************************************************************/
  3   292   
  3   293   dcl 01 le_patches		aligned based,
  3   294        02 header		aligned,
  3   295         03 n_patches	fixed bin,
  3   296        02 patch		(0 refer (le_patches.n_patches)) like le_patch;
  3   297        
  3   298   dcl 01 le_patch		aligned based,
  3   299        02 type		fixed bin,
  3   300        02 comp		fixed bin,
  3   301        02 relp		fixed bin (18) unsigned,
  3   302        02 target		fixed bin,
  3   303        02 index		fixed bin;
  3   304   
  3   305 /****  END OF:	le_data.incl.pl1			 *  *  *  *  *  */
      221 
  4     1 /* BEGIN INCLUDE FILE ... object_info.incl.pl1
  4     2*coded February 8, 1972 by Michael J. Spier	*/
  4     3 /* modified May 26, 1972 by M. Weaver */
  4     4 /* modified 15 April, 1975 by M. Weaver */
  4     5 
  4     6 declare	1 object_info aligned based,		/* structure containing object info based, returned by object_info_ */
  4     7 	2 version_number fixed bin,		/* version number of current structure format (=2) */
  4     8 	2 textp pointer,			/* pointer to beginning of text section */
  4     9 	2 defp pointer,			/* pointer to beginning of definition section */
  4    10 	2 linkp pointer,			/* pointer to beginning of linkage section */
  4    11 	2 statp pointer,			/* pointer to beginning of static section */
  4    12 	2 symbp pointer,			/* pointer to beginning of symbol section */
  4    13 	2 bmapp pointer,			/* pointer to beginning of break map (may be null) */
  4    14 	2 tlng fixed bin,			/* length in words of text section */
  4    15 	2 dlng fixed bin,			/* length in words of definition section */
  4    16 	2 llng fixed bin,			/* length in words of linkage section */
  4    17 	2 ilng fixed bin,			/* length in words of static section */
  4    18 	2 slng fixed bin,			/* length in words of symbol section */
  4    19 	2 blng fixed bin,			/* length in words of break map */
  4    20 	2 format,				/* word containing bit flags about object type */
  4    21 	  3 old_format bit(1) unaligned,	/* on if segment isn't in new format, i.e. has old style object map */
  4    22 	  3 bound bit(1) unaligned,		/* on if segment is bound */
  4    23 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
  4    24 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
  4    25 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
  4    26 	  3 gate bit(1) unaligned,		/* on if segment is a gate */
  4    27 	  3 separate_static bit(1) unaligned,	/* on if static not in linkage */
  4    28 	  3 links_in_text bit(1) unaligned,	/* on if there are threaded links in text */
  4    29 	  3 perprocess_static bit (1) unaligned, /* on if static is not to be per run unit */
  4    30 	  3 pad bit(27) unaligned,
  4    31 	2 entry_bound fixed bin,		/* entry bound if segment is a gate */
  4    32 	2 textlinkp pointer,		/* ptr to first link in text */
  4    33 
  4    34 	/* LIMIT OF BRIEF STRUCTURE */
  4    35 
  4    36 	2 compiler char(8) aligned,		/* name of processor which generated segment */
  4    37 	2 compile_time fixed bin(71),		/* clock reading of date/time object was generated */
  4    38 	2 userid char(32) aligned,		/* standard Multics id of creator of object segment */
  4    39 	2 cvers aligned,			/* generator version name in printable char string form */
  4    40 	  3 offset bit(18) unaligned,		/* offset of name in words relative to base of symbol section */
  4    41 	  3 length bit(18) unaligned,		/* length of name in characters */
  4    42 	2 comment aligned,			/* printable comment concerning generator or generation of segment */
  4    43 	  3 offset bit(18) unaligned,		/* offset of comment in words relative to base of symbol section */
  4    44 	  3 length bit(18) unaligned,		/* length of comment in characters */
  4    45 	2 source_map fixed bin,		/* offset, relative to base of symbol section, of source map structure */
  4    46 
  4    47 	/* LIMIT OF DISPLAY STRUCTURE */
  4    48 
  4    49 	2 rel_text pointer,			/* pointer to text section relocation info */
  4    50 	2 rel_def pointer,			/* pointer to definition section relocation info */
  4    51 	2 rel_link pointer,			/* pointer to linkage section relocation info */
  4    52 	2 rel_static pointer,		/* pointer to static section relocation info */
  4    53 	2 rel_symbol pointer,		/* pointer to symbol section relocation info */
  4    54 	2 text_boundary fixed bin,		/* specifies mod  of text section base boundary */
  4    55 	2 static_boundary fixed bin,		/* specifies mod of internal static base boundary */
  4    56 					/* currently not used by system */
  4    57 	2 default_truncate fixed bin,		/* offset rel to symbp for binder to automatically trunc. symb sect. */
  4    58 	2 optional_truncate fixed bin;	/* offset rel to symbp for binder to optionally trunc. symb sect. */
  4    59 
  4    60 declare	object_info_version_2 fixed bin int static init(2);
  4    61 
  4    62 /* END INCLUDE FILE ... object_info.incl.pl1 */
      222 
  5     1 /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
  5     2 
  5     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
  5     4 
  5     5 /* This include file contains branch and link structures returned by
  5     6*   hcs_$status_ and hcs_$status_long. */
  5     7 
  5     8 dcl 1 status_branch aligned based (status_ptr),
  5     9     2 short aligned,
  5    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
  5    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
  5    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
  5    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
  5    14       3 dtu bit (36) unaligned,			/* date/time last used */
  5    15       3 mode bit (5) unaligned,			/* caller's effective access */
  5    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
  5    17       3 pad1 bit (8) unaligned,
  5    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
  5    19 
  5    20 /* Limit of information returned by hcs_$status_ */
  5    21 
  5    22     2 long aligned,
  5    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
  5    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
  5    25       3 lvid bit (36) unaligned,			/* logical volume ID */
  5    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
  5    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
  5    28       3 pad2 bit (8) unaligned,
  5    29       3 copy_switch bit (1) unaligned,			/* copy switch */
  5    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
  5    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
  5    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
  5    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
  5    34       3 pad3 bit (5) unaligned,
  5    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
  5    36       3 uid bit (36) unaligned;			/* unique ID */
  5    37 
  5    38 dcl 1 status_link aligned based (status_ptr),
  5    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
  5    40     2 nnames fixed bin (16) unaligned unsigned,
  5    41     2 names_relp bit (18) unaligned,
  5    42     2 dtem bit (36) unaligned,
  5    43     2 dtd bit (36) unaligned,
  5    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
  5    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
  5    46 
  5    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
  5    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
  5    49 						/* array of names returned */
  5    50      status_pathname character (status_link.pathname_length) aligned
  5    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
  5    52 						/* link target path */
  5    53      status_area_ptr pointer,
  5    54      status_ptr pointer;
  5    55 
  5    56 dcl (Link initial (0),
  5    57      Segment initial (1),
  5    58      Directory initial (2)) fixed bin internal static options (constant);
  5    59 						/* values for type fields declared above */
  5    60 
  5    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
      223 
      224 
      225   end le_create_binary_;
      226 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/10/86  1251.8  le_create_binary_.pl1             >special_ldd>install>MR12.0-1241>le_create_binary_.pl1
219          1    10/14/83  1606.6  acl_structures.incl.pl1           >ldd>include>acl_structures.incl.pl1
220          2    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
221          3    12/10/86  1248.4  le_data.incl.pl1                  >special_ldd>install>MR12.0-1241>le_data.incl.pl1
222          4    08/05/77  1022.5  object_info.incl.pl1              >ldd>include>object_info.incl.pl1
223          5    11/22/82  0955.7  status_structures.incl.pl1        >ldd>include>status_structures.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
LE_ABORT_ERROR                  000014 constant        fixed bin(17,0)          initial dcl 3-22 set ref 122* 133* 177* 204*
REW_ACCESS                             constant        bit(3)                   initial unaligned dcl 2-11 ref 193
abort                           000100 automatic       bit(1)                   unaligned dcl 86 set ref 106*
access_name                     000117 automatic       char(32)                 level 2 packed unaligned dcl 92 set ref 192*
act_dname                              parameter       char                     unaligned dcl 49 set ref 16 107* 126* 209*
act_ename                              parameter       char                     unaligned dcl 50 set ref 16 108* 127*
addr                                                   builtin function         dcl 103 ref 112 112 158 158 197 197
bc                              000101 automatic       fixed bin(24,0)          dcl 87 set ref 145* 158*
bound                    24(01) 000132 automatic       bit(1)                   level 3 packed unaligned dcl 93 set ref 159
br_info                         000102 automatic       structure                level 1 dcl 88 set ref 112 112
comp_count                             parameter       fixed bin(17,0)          dcl 47 ref 16 119 184
delete_acl_entry                       based           structure                level 1 dcl 1-63
deleted                         000114 automatic       bit(1)                   unaligned dcl 89 set ref 143* 154* 167* 187
directory_acl_entry                    based           structure                level 1 dcl 1-54
dname                                  parameter       char                     unaligned dcl 45 set ref 16 107 112* 121* 122* 122*
                                                                                  126* 145* 149* 151* 161* 163* 176* 177* 177* 197*
                                                                                  202* 204* 204* 209*
ec                              000115 automatic       fixed bin(35,0)          dcl 90 set ref 112* 113 121* 122 122* 145* 146 149*
                                                                                  151* 152 158* 161* 163* 164 176* 177 177* 197*
                                                                                  202* 204 204*
ename                                  parameter       char                     unaligned dcl 46 set ref 16 108 112* 121* 122* 122*
                                                                                  126* 127 145* 149* 151* 161* 163* 176* 177* 177*
                                                                                  197* 202* 204* 204* 209*
error_table_$noentry            000040 external static fixed bin(35,0)          dcl 79 ref 113
extended_mode            11     000117 automatic       bit(36)                  level 2 dcl 92 set ref 194*
false                                  constant        bit(1)                   initial unaligned dcl 40 ref 106 143 148 166
force                                  parameter       bit(1)                   unaligned dcl 48 ref 16 149 161
format                   24     000132 automatic       structure                level 2 dcl 93
general_acl_entry                      based           structure                level 1 unaligned dcl 1-12
general_delete_acl_entry               based           structure                level 1 dcl 1-35
general_extended_acl_entry             based           structure                level 1 dcl 1-23
get_group_id_$tag_star          000010 constant        entry                    external dcl 54 ref 192
hcs_$add_acl_entries            000012 constant        entry                    external dcl 55 ref 197
hcs_$status_long                000014 constant        entry                    external dcl 57 ref 112
le_abort_                       000226 stack reference condition                dcl 99 ref 152 164
le_comp                                based           structure                level 1 dcl 3-89
le_data_$caller                 000042 external static varying char(32)         dcl 80 ref 149 151 161 163
le_definition                          based           structure                level 1 dcl 3-175
le_error_                       000016 constant        entry                    external dcl 59 ref 122 133 177 204
le_et_$input_output_overlap     000044 external static fixed bin(35,0)          dcl 81 set ref 133*
le_link                                based           structure                level 1 dcl 3-233
le_patch                               based           structure                level 1 dcl 3-298
le_util_$check_uid              000020 constant        entry                    external dcl 60 ref 133
lecp                                   parameter       pointer                  dcl 44 set ref 16 133*
long                      4     000102 automatic       structure                level 2 dcl 88
make_msf_                       000022 constant        entry                    external dcl 62 ref 121 202
mode                     10     000117 automatic       bit(36)                  level 2 dcl 92 set ref 193*
msf_sw                          000116 automatic       bit(1)                   unaligned dcl 91 set ref 145* 148* 166* 171
my_acl                          000117 automatic       structure                level 1 dcl 92 set ref 197 197
nd_handler_                     000024 constant        entry                    external dcl 64 ref 149 163
nd_handler_$force               000026 constant        entry                    external dcl 66 ref 151 161
null                                                   builtin function         dcl 104 ref 112 112 133 133
object_info                            based           structure                level 1 dcl 4-6
object_info_$brief              000030 constant        entry                    external dcl 68 ref 158
object_info_version_2                  constant        fixed bin(17,0)          initial dcl 4-60 ref 157
object_lib_$initiate            000032 constant        entry                    external dcl 70 ref 145
oi                              000132 automatic       structure                level 1 dcl 93 set ref 158 158
pathname_                       000034 constant        entry                    external dcl 73 ref 122 122 126 177 177 204 204 209
rbs                             000220 automatic       fixed bin(6,0)           array dcl 94 set ref 121* 176* 202*
segment_acl_entry                      based           structure                level 1 dcl 1-45
segp                            000224 automatic       pointer                  dcl 95 set ref 145* 158*
status_branch                          based           structure                level 1 dcl 5-8
status_code              12     000117 automatic       fixed bin(35,0)          level 2 dcl 92 set ref 195*
true                                   constant        bit(1)                   initial unaligned dcl 39 ref 154 167
uid                      11     000102 automatic       bit(36)                  level 3 packed unaligned dcl 88 set ref 133
unmake_msf_                     000036 constant        entry                    external dcl 74 ref 176
version_number                  000132 automatic       fixed bin(17,0)          level 2 dcl 93 set ref 157*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACL_VERSION_1                          internal static fixed bin(17,0)          initial dcl 1-77
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 2-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
DELETE_ACL_VERSION_1                   internal static char(4)                  initial unaligned dcl 1-67
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 2-33
DIR_ACL_VERSION_1                      internal static char(4)                  initial unaligned dcl 1-67
Definition                             internal static fixed bin(3,0)           initial dcl 3-32
Directory                              internal static fixed bin(17,0)          initial dcl 5-56
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 2-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
GENERAL_ACL_VERSION_1                  internal static char(8)                  initial unaligned dcl 1-72
GENERAL_DELETE_ACL_VERSION_1           internal static char(8)                  initial unaligned dcl 1-72
GENERAL_EXTENDED_ACL_VERSION_1         internal static char(8)                  initial unaligned dcl 1-72
Heap                                   internal static fixed bin(3,0)           initial dcl 3-38
LE_ERROR                               internal static fixed bin(17,0)          initial dcl 3-20
LE_FATAL_ERROR                         internal static fixed bin(17,0)          initial dcl 3-21
LE_WARNING                             internal static fixed bin(17,0)          initial dcl 3-19
Link                                   internal static fixed bin(17,0)          initial dcl 5-56
Linkage                                internal static fixed bin(3,0)           initial dcl 3-28
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 2-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 2-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
Patch_Init                             internal static fixed bin(17,0)          initial dcl 3-59
Patch_Link                             internal static fixed bin(17,0)          initial dcl 3-58
Patch_Self_Init                        internal static fixed bin(17,0)          initial dcl 3-61
Patch_Symbol_Ref                       internal static fixed bin(17,0)          initial dcl 3-60
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 2-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 2-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
RW_ACCESS                              internal static bit(3)                   initial unaligned dcl 2-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
R_ACCESS                               internal static bit(3)                   initial unaligned dcl 2-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
Refname_Base                           internal static fixed bin(3,0)           initial dcl 3-49
Refname_Offsetname                     internal static fixed bin(3,0)           initial dcl 3-51
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 2-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 2-30
SEG_ACL_VERSION_1                      internal static char(4)                  initial unaligned dcl 1-67
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 2-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 2-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 2-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 2-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
Segment                                internal static fixed bin(17,0)          initial dcl 5-56
Self_Base                              internal static fixed bin(3,0)           initial dcl 3-47
Self_Offsetname                        internal static fixed bin(3,0)           initial dcl 3-53
Static                                 internal static fixed bin(3,0)           initial dcl 3-34
Symbol                                 internal static fixed bin(3,0)           initial dcl 3-30
System                                 internal static fixed bin(3,0)           initial dcl 3-36
Text                                   internal static fixed bin(3,0)           initial dcl 3-26
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 2-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
acl_count                              automatic       fixed bin(17,0)          dcl 1-5
acl_ptr                                automatic       pointer                  dcl 1-4
def_count                              automatic       fixed bin(17,0)          dcl 3-173
delete_acl                             based           structure                level 1 dcl 1-58
delete_acl_array                       based           structure                array level 1 dcl 1-64
directory_acl                          based           structure                level 1 dcl 1-49
directory_acl_array                    based           structure                array level 1 dcl 1-55
general_acl                            based           structure                level 1 dcl 1-7
general_delete_acl                     based           structure                level 1 dcl 1-30
general_extended_acl                   based           structure                level 1 dcl 1-18
le_binaries                            based           structure                level 1 dcl 3-260
le_components                          based           structure                level 1 dcl 3-72
le_definitions                         based           structure                level 1 dcl 3-167
le_links                               based           structure                level 1 dcl 3-225
le_options                             based           structure                level 1 dcl 3-202
le_patches                             based           structure                level 1 dcl 3-293
le_segnames                            based           structure                level 1 dcl 3-149
link_count                             automatic       fixed bin(17,0)          dcl 3-231
section_nm                             internal static char(16)                 initial array unaligned dcl 3-41
segment_acl                            based           structure                level 1 dcl 1-40
segment_acl_array                      based           structure                array level 1 dcl 1-46
segname_count                          automatic       fixed bin(17,0)          dcl 3-156
status_area_ptr                        automatic       pointer                  dcl 5-47
status_entry_names                     based           char(32)                 array dcl 5-47
status_link                            based           structure                level 1 dcl 5-38
status_pathname                        based           char                     dcl 5-47
status_ptr                             automatic       pointer                  dcl 5-47

NAME DECLARED BY EXPLICIT CONTEXT.
le_create_binary_               000113 constant        entry                    external dcl 16

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1560        1626    1347        1570
Length      2146    1347        46         304     211           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
le_create_binary_                   266 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
le_create_binary_        000100 abort                       le_create_binary_
                         000101 bc                          le_create_binary_
                         000102 br_info                     le_create_binary_
                         000114 deleted                     le_create_binary_
                         000115 ec                          le_create_binary_
                         000116 msf_sw                      le_create_binary_
                         000117 my_acl                      le_create_binary_
                         000132 oi                          le_create_binary_
                         000220 rbs                         le_create_binary_
                         000224 segp                        le_create_binary_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          signal_op           shorten_stack
ext_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_group_id_$tag_star        hcs_$add_acl_entries          hcs_$status_long              le_error_
le_util_$check_uid            make_msf_                     nd_handler_                   nd_handler_$force
object_info_$brief            object_lib_$initiate          pathname_                     unmake_msf_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$noentry          le_data_$caller               le_et_$input_output_overlap




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     16 000105       106 000145       107 000146       108 000156       112 000165       113 000227       119 000233
    121 000237       122 000264       126 000341       127 000372       130 000401       133 000402       143 000452
    145 000453       146 000524       148 000526       149 000530       151 000576       152 000636       154 000644
    155 000646       157 000647       158 000651       159 000670       161 000673       163 000741       164 001001
    166 001007       167 001011       171 001013       176 001016       177 001053       184 001130       187 001134
    192 001136       193 001145       194 001147       195 001150       197 001151       202 001210       204 001237
    209 001314       212 001345


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
