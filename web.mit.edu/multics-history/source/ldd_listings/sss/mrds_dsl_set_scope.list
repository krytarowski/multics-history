	COMPILATION LISTING OF SEGMENT mrds_dsl_set_scope
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1325.2 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 
       19 /****^  HISTORY COMMENTS:
       20*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
       21*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
       22*     This entry is being made to cover the change made on 85-07-01 by Thanh
       23*     Nguyen. (see mrds #137)
       24*                                                   END HISTORY COMMENTS */
       25 
       26 /* HISTORY:
       27*   Originally written by Jim Gray - - September 1979
       28*   5-jun-80 Davids: Modified to correctly calculate the number of arguments   when called with the dl_scope_all entry.
       29*   Modified by Jim Gray - - June 1980, to detect dl_scope on unshared openings.
       30*
       31*   80-12-10 Jim Gray : removed conversion or r-s-m-d modes to r-u type scope modes
       32*   so that complete r-s-m-d modes could be implemented.
       33*   Also changed displayed names of modes as follows:
       34*   retrieve now = read_attr, store/update now = append_tuple
       35*   delete now = delete_tuple, modify now = modify_attr
       36*   This was done to agree with security acl modes.
       37*   Also added use of mrds_new_scope_modes and mrds_opening_modes_ include files.
       38*
       39*   80-12-11 Jim Gray : Changed error reproting on detection of invalid combination
       40*   of modes into a sum when the set_scope_all entry was used.
       41*
       42*   81-01-29 Jim Gray : removed references to mdbm_data_$current_version,
       43*   using a constant instead, to allow for future db version expansion.
       44*   Previously, since no relation name was available, a null ptr was referenced.
       45*
       46*   81-06-01 Jim Gray : removed all code tranlating from a file
       47*   to relation interface, as part of changing to use new resultant model
       48*   structures.
       49*
       50*   83-06-20 Davids: Removed check for old version database and the call
       51*   to v1 code if it was an old version db (old version dbs can no longer
       52*   be opened)
       53*
       54*   85-07-01 Thanh Nguyen: Added code to set the dbcb.scopes_changed on when
       55*   ever scopes had been successfully modified.  The mrds_dsl_gen_srch_prog 
       56*   and mrds_dsl_optimize will reset at the time they build a new search_vars
       57*   structure for a new select_expression.  So we can detect that the scopes
       58*   had been changed in -another.
       59**/
       60 
       61 mrds_dsl_set_scope: procedure (); return;		/* not valid entry */
       62 
       63 /* DESCRIPTION:
       64*   this routine was written to allow upward compatible calls to
       65*   dsl_$set_scope, dsl_$set_scope_all, dsl_$dl_scope, and dsl_$dl_scope_all.
       66*   if this routine is called by a user with an old version database,
       67*   the calls are simply passed on(via generate_call) to the old version programs.
       68*   if called by the new version database user, the _all entries,
       69*   simply call the corresponding fscope_all entries to take the
       70*   correct scope action on all files, and thus all relations.
       71*   if the non "_all" entries are called, then a new argument list is built
       72*   that contains the file names of files containing the given relations,
       73*   the permit/prevent operations are set according, and the appropriate
       74*   fscope entry point is called. note: relation modify/delete are converted to file update scope.  */
       75 
       76 /* PARAMETERS:
       77*   database_index - - (input) fixed bin(35) aligned, the opening index returned
       78*   from the call to dsl_$open for the users database.
       79*
       80*   relation_name - - (input) char nonvarying, only for the non "_all" entries,
       81*   the name of the relation on which to set/delete scope.
       82*   any number of relation_name/permits/prevents triples may be present(up to number of relation).
       83*   when this argument is missing(in "_all" entries) all relations are affected.
       84*
       85*   permits - - (input) fixed bin (17), the operations to be permitted on the relations,
       86*   it is a sum of the codes desired, where the allowed codes are:
       87*   1(retrieve), 2(store/update), 4(delete), 8(modify)
       88*
       89*   prevents - - (input) fixed bin (17), the operations which others(processes)
       90*   are to prevented from doing. a sum of the desired codes, as above.
       91*
       92*   wait_time - - (input) fixed bin (35), optional time to wait in seconds, on set_scope entries,
       93*   if the request can not be honored immediately.
       94*
       95*   error_code - - (output) fixed bin(35), the error status encoding, 0 unless an error occured
       96*
       97*   sub_error_ - - (output) condition, signaled upon occurence of an error to provide more info  */
       98 
       99 /* NOTE ON USE OF DSL_$DL_SCOPE WITH NEW VERSION DATABASES:
      100*
      101*   The use of dsl_$dl_scope with blocked files,
      102*   when not all relations in the file are specified in the argument list,
      103*   will not be allowed for the following reasons:
      104*
      105*   1) this routine is primarily a transition tool to get old version
      106*   application programs to run without change on new version databases
      107*   by converting set/dl_scope calls into set/dl_fscope (file scope) calls.
      108*   Since relations get default unblocked files when processed
      109*   by create_mrds_db, and there is only one relation per file,
      110*   no problems are encountered in the use of this tool.
      111*   However, the following example illustrates a problem with "partial dl_scope",
      112*   on blocked files.
      113*
      114*   EXAMPLE: file_1 has two relations rel_1 and rel_2 with current scope settings of:
      115*   rel_1 has retrieve and update scopes, rel_2 has only retrieve scope.
      116*   a call to this module to delete both retrieve and update
      117*   scope on rel_1 would be transformed into a call to dl_fscope on file_1.
      118*   this would result in null scopes for both rel_1 and rel_2!!
      119*   attempts to access or delete scope on rel_2 would result in an error.
      120*
      121*   this is a problem with the algorithm used in this module, i.e. deleting
      122*   the maximum, not minimum scope on a file.
      123*
      124*   2) to correct the problem noted in 1 above would require changes to the
      125*   rm_rel_array to maintain per process scopes in affect per relation,
      126*   thus requiring recompilation of many modules, when ideally the
      127*   transition tool should be limited to the logic in this module.
      128*
      129*   3) most important, if users are going to change to the new blocked file
      130*   structure for their databases, then they should be making use of the
      131*   set/dl_fscope entries, and not this transition tool, which may eventually
      132*   not be supported.
      133*
      134*
      135*   Therefore the following RESTRICTIONS ON THE USE OF DL_SCOPE are enforced:
      136*
      137*   1) no restrictions on the user of dl_scope_all.
      138*
      139*   2) no restrictions on unblocked files.
      140*
      141*   3) when blocked files are in use, dl_scope may be successfully be used
      142*   only when all relations in the file have their complete scopes given
      143*   in the call, i.e. "partial deletes are not allowed"
      144*
      145*   in terms of the given example this means, that to remove update permission
      146*   from rel_1, the call would contain the arguments:
      147*
      148*   rel_1 update null rel_2 update null
      149*
      150*   for relation/permit/prevent triples, even though rel_2 has no update permission
      151*   in the sense of the old scope mechanism.
      152*
      153**/
      154 
      155 set_scope: entry ();
      156 
      157 /* entry called to set scope on a single relation, or list of relations */
      158 
      159 	SET_SCOPE_ENTRY = ON;
      160 	SCOPE_ALL_ENTRY = OFF;
      161 	min_args = 5;				/* args = db_index, rel_name, permits, prevents, error_code
      162*						   any number of rel_name/permits/prevents triples allowed
      163*						   wait time argument is optional */
      164 
      165 	goto common_scope_routine;			/* use goto to save external argument list for cu_ call */
      166 
      167 
      168 
      169 
      170 set_scope_all: entry ();
      171 
      172 /* entry called to set scope on all relations, without naming them */
      173 
      174 	SET_SCOPE_ENTRY = ON;
      175 	SCOPE_ALL_ENTRY = ON;
      176 	min_args = 4;				/* args = db_index, permits, prevents, error_code
      177*						   wait time argument is optional */
      178 
      179 	goto common_scope_routine;
      180 
      181 
      182 
      183 
      184 
      185 
      186 dl_scope: entry ();
      187 
      188 /* entry called to delete scope on a single relation, or list of relations */
      189 
      190 	SET_SCOPE_ENTRY = OFF;
      191 	SCOPE_ALL_ENTRY = OFF;
      192 	min_args = 5;				/* args = db_index, rel_name, permits, prevents, error_code
      193*						   any number of rel_name/permits/prevents triples allowed
      194*						   wait time argument not allowed */
      195 
      196 	goto common_scope_routine;
      197 
      198 
      199 
      200 
      201 dl_scope_all: entry ();
      202 
      203 /* entry called to delete scope on all relations without naming them */
      204 
      205 	SET_SCOPE_ENTRY = OFF;
      206 	SCOPE_ALL_ENTRY = ON;
      207 	min_args = 2;				/* args = db_index, error_code */
      208 
      209 	goto common_scope_routine;
      210 
      211 common_scope_routine: ;
      212 
      213 /* logic common to all entry points for setting/deleting scope,
      214*   on all relations, or one at a time, as specified by arguments */
      215 
      216 	error_code = 0;				/* initialize */
      217 
      218 /* get the external procedures argument list, before going to an internal routine */
      219 
      220 	call cu_$arg_list_ptr (al_ptr);		/* get argument list */
      221 
      222 /* determine user's database version number */
      223 
      224 	call get_version_of_caller ();
      225 
      226 /* now make the appropriate call -- to set_scope for old versions, to set_fscope for new_versions */
      227 
      228 	call pass_call_to_correct_version ();
      229 
      230 /* now set the users error code, if neccessary */
      231 
      232 	if error_code = 0 then
      233 	     if dbcb_ptr ^= null then
      234 		dbcb.scopes_changed = "1"b;
      235 	     else;
      236 	else if desc_index = 0 & ^(SCOPE_ALL_ENTRY & ^SET_SCOPE_ENTRY) then ; /* can't get descriptor, or dl_scope_all */
      237 	else do;
      238 		desc_ptr = arg_list.arg_des_ptr (desc_index + nargs);
      239 		if ^(SCOPE_ALL_ENTRY & ^SET_SCOPE_ENTRY) & /* ignore for dl_scope_all */
      240 		     desc_ptr -> descriptor_ovrly ^= fixed_bin_35_descr then ; /* don't assign unknown data type */
      241 		else if arg_list.arg_des_ptr (nargs) -> error_code_ovrly ^= 0 then ; /* set by called version */
      242 		else arg_list.arg_des_ptr (nargs) -> error_code_ovrly = error_code;
      243 	     end;
      244 
      245 	return;
      246 
      247 get_version_of_caller: procedure ();
      248 
      249 /* first get the callers argument list, and check for minimum arguments,
      250*   before finding version of database from resultant model via the database index */
      251 
      252 	if SCOPE_ALL_ENTRY & ^SET_SCOPE_ENTRY then /* dl_scope_all called */
      253 	     nargs = arg_list.arg_count / 2;		/* not an options (variable) entry */
      254 	else nargs = arg_list.desc_count / 2;		/* = number of args if called options(variable) */
      255 	desc_index = 0;				/* in case of early error */
      256 
      257 	if nargs < min_args then do;
      258 		error_code = error_table_$wrong_no_of_args;
      259 		call sub_err_ (error_code, caller_name, continue, info_ptr, return_value, "^/^a ^d ^a ^d ^a",
      260 		     "The number of arguments =", nargs,
      261 		     "was less than the minimum of", min_args,
      262 		     "or the entry was not declared ""options (variable)"".");
      263 	     end;
      264 	else do;
      265 
      266 /* get the offset of descriptors in the argument list */
      267 
      268 		if SCOPE_ALL_ENTRY & ^SET_SCOPE_ENTRY then ; /* no descriptors for dl_scope_all */
      269 		else if arg_list.code = SPECIAL then
      270 		     desc_index = nargs + 1;
      271 		else desc_index = nargs;
      272 		num_ptrs = desc_index + nargs;
      273 
      274 /* check for a valid error code argument, and then initialize it */
      275 
      276 		desc_ptr = arg_list.arg_des_ptr (desc_index + nargs);
      277 		if ^(SCOPE_ALL_ENTRY & ^SET_SCOPE_ENTRY) & /* can't check descriptor on dl_scope_all */
      278 		     desc_ptr -> descriptor_ovrly ^= fixed_bin_35_descr then do;
      279 			error_code = error_table_$bad_arg;
      280 			call sub_err_ (error_code, caller_name, continue, info_ptr, return_value, "^/^a ^a",
      281 			     "The error code(last) argument",
      282 			     "was not declared ""fixed binary (35) aligned"".");
      283 		     end;
      284 		else do;
      285 
      286 			arg_list.arg_des_ptr (nargs) -> error_code_ovrly = 0; /* initialize users error code */
      287 
      288 /* check for old or new version database call to set_scope
      289*   by getting the version out of the resultant model built
      290*   at open time, via the given database index */
      291 
      292 			num_dims = 0;
      293 
      294 			if SCOPE_ALL_ENTRY & ^SET_SCOPE_ENTRY then /* can't check descriptor on dl_scope_all */
      295 			     desc_ptr = addr (fixed_bin_35_descr); /* => don't convert, use arg directly */
      296 			else desc_ptr = arg_list.arg_des_ptr (desc_index + 1);
      297 
      298 			call mu_convert_parameter$convert_input_parameter (arg_list.arg_des_ptr (1), desc_ptr, db_index_ptr,
      299 			     addr (fixed_bin_35_descr), addr (local_area), error_code);
      300 			if error_code ^= 0 then do;
      301 				call sub_err_ (error_code, caller_name, continue, info_ptr, return_value, "^/^a",
      302 				     "The database index argument could not be converted to ""fixed binary (35) aligned"".");
      303 			     end;
      304 			else do;
      305 
      306 /* check for valid database index, in order to get resultant model pointer */
      307 
      308 				call mu_database_index$get_resultant_model_pointer (db_index, dbcb_ptr);
      309 
      310 				if dbcb_ptr = null () then do;
      311 					error_code = mrds_error_$invalid_db_index;
      312 					call sub_err_ (error_code, caller_name, continue, info_ptr, return_value, "^/^a ^d ^a",
      313 					     "The database index =", db_index,
      314 					     "does not refer to a database that is currently open by this process.");
      315 				     end;
      316 
      317 			     end;
      318 
      319 		     end;
      320 
      321 	     end;
      322 
      323      end;
      324 
      325 pass_call_to_correct_version: procedure ();
      326 
      327 /* call old set_scope, for old version database calls,
      328*   and the new set_fscope for new version database calls,
      329*   after converting relation names into files names,
      330*   with duplicates removed, and max permissions granted,
      331*   and max prevents allowed that will not conflict. */
      332 
      333 	if error_code ^= 0 then ;
      334 	else do;
      335 
      336 		new_al_ptr = al_ptr;
      337 
      338 		exclusive_opening = (fixed (dbcb.open_mode) = EXCLUSIVE_RETRIEVAL |
      339 		     fixed (dbcb.open_mode) = EXCLUSIVE_UPDATE);
      340 		if exclusive_opening then error_code = mrds_error_$unshared_opening;
      341 
      342 		if SCOPE_ALL_ENTRY then do;
      343 
      344 
      345 			if SET_SCOPE_ENTRY then
      346 			     entry_name = mrds_dsl_set_fscope$set_fscope_all;
      347 			else entry_name = mrds_dsl_dl_fscope$dl_fscope_all;
      348 		     end;
      349 		else do;
      350 
      351 			if SET_SCOPE_ENTRY then
      352 			     entry_name = mrds_dsl_set_fscope$set_fscope;
      353 			else entry_name = mrds_dsl_dl_fscope$dl_fscope;
      354 		     end;
      355 
      356 		if error_code ^= 0 then ;
      357 		else call cu_$generate_call (entry_name, new_al_ptr);
      358 	     end;
      359      end;
      360 
      361 	declare sub_err_		 entry options (variable); /* reports errors */
      362 	declare caller_name		 char (20) init ("mrds_dsl_set_scope"); /* name of calling routine */
      363 	declare continue		 char (1) init ("c"); /* don't stop after printing error msg */
      364 	declare info_ptr		 ptr init (null ());/* unused */
      365 	declare return_value	 fixed bin (35) init (0); /* unused */
      366 	declare cu_$arg_list_ptr	 entry (ptr);	/* gets pointer to argument list */
      367 	declare cu_$generate_call	 entry (entry, ptr);/* makes call to given entry with given arg list */
      368 	declare SCOPE_ALL_ENTRY	 bit (1);		/* on => all entry called */
      369 	declare entry_name		 entry options (variable) variable;
      370 	declare mu_database_index$get_resultant_model_pointer entry (fixed bin (35), ptr); /* gets ptr for opening index */
      371 	declare error_code		 fixed bin (35);	/* error status encoding */
      372 	declare mrds_error_$invalid_db_index fixed bin (35) ext; /* bad database indeex */
      373 	declare error_table_$bad_arg	 fixed bin (35) ext;/* bad subroutine argument */
      374 	declare error_table_$wrong_no_of_args fixed bin (35) ext; /* bad argument count */
      375 	declare db_index		 fixed bin (35) based (db_index_ptr); /* database index */
      376 	declare db_index_ptr	 ptr;		/* points to database index */
      377 	declare nargs		 fixed bin;	/* number of input arguments */
      378 	declare descriptor_ovrly	 bit (36) unal based; /* overlay for descriptor */
      379 	declare fixed_bin_35_descr	 bit (36) init ("100000100000000000000000000000100011"b); /* descriptor for fixed bin(35) */
      380 	declare desc_index		 fixed bin;	/* offset to start of descriptors in array */
      381 	declare SPECIAL		 fixed bin init (8);/* special version code for arg list */
      382 	declare ON		 bit (1) init ("1"b); /* true value */
      383 	declare OFF		 bit (1) init ("0"b); /* false value */
      384 	declare new_al_ptr		 ptr;		/* points to converted argument list */
      385 	declare sys_info$max_seg_size	 fixed bin (35) ext;/* largest segment size */
      386 	declare (addr, rel, fixed, null, empty) builtin;
      387 	declare min_args		 fixed bin;	/* either 4 or 5, for "all" or not entries */
      388 	declare CHAR_NONVAR		 fixed bin init (21); /* nonvarying character string data type */
      389 	declare fixed_bin_17_descr	 bit (36) init ("100000100000000000000000000000010001"b); /* descriptor for fixed bin (17) */
      390 	declare char_nonvar_descr	 bit (36) init ("101010100000000000000000000000011110"b); /* char(30) nonvarying descriptor */
      391 	declare NON_SPECIAL		 fixed bin init (4);/* no extra pointer in arg list */
      392 	declare local_area		 area (100);	/* space for converting parameters */
      393 	declare SET_SCOPE_ENTRY	 bit (1);		/* on => called to set, not delete, scope */
      394 	declare error_code_ovrly	 fixed bin (35) based; /* overlay for assigning error code */
      395 	declare mu_convert_parameter$convert_input_parameter entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)); /* gets in needed type */
      396 
      397 	declare (mrds_dsl_dl_fscope$dl_fscope,
      398 	        mrds_dsl_dl_fscope$dl_fscope_all,
      399 	        mrds_dsl_set_fscope$set_fscope,
      400 	        mrds_dsl_set_fscope$set_fscope_all) entry options (variable); /* actual procedures that will be called */
      401 	declare mrds_error_$unshared_opening fixed bin (35) ext; /* opened er or eu => dont allow delete scope */
      402 	declare exclusive_opening	 bit (1);		/* on => er or eu open mode */
      403 
  1     1 /* BEGIN mdbm_descriptor.incl.pl1 -- jaw 5/31/78 */
  1     2 /* modified by Jim Gray - - Nov. 1979, to change type from fixed bin(5) to
  1     3*   unsigned fixed bin(6), so new packed decimal data types could be handled.
  1     4*   also the duplicate mrds_descriptor.incl.pl1 was eliminated. */
  1     5 
  1     6 dcl 1 descriptor based (desc_ptr),			/* map of Multics descriptor */
  1     7     2 version bit (1) unal,				/* DBM handles vers. 1 only */
  1     8     2 type unsigned fixed bin (6) unal,			/* data type */
  1     9     2 packed bit (1) unal,				/* on if data item is packed */
  1    10     2 number_dims bit (4) unal,			/* dimensions */
  1    11     2 size,					/* size for string data */
  1    12       3 scale bit (12) unal,				/* scale for num. data */
  1    13       3 precision bit (12) unal,			/* prec. for num. data */
  1    14     2 array_info (num_dims),
  1    15       3 lower_bound fixed bin (35),			/* lower bound of dimension */
  1    16       3 upper_bound fixed bin (35),			/* upper bound of dimension */
  1    17       3 multiplier fixed bin (35);			/*  element separation */
  1    18 
  1    19 dcl  desc_ptr ptr;
  1    20 dcl  num_dims fixed bin init (0) ;			/* more useful form of number_dims */
  1    21 
  1    22 /* END mdbm_descriptor.incl.pl1 */
  1    23 
  1    24 
      404 
  2     1 /* START OF:	mrds_new_scope_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2     4 /* 									*/
  2     5 /* Name:  mrds_new_scope_modes.incl.pl1						*/
  2     6 /* 									*/
  2     7 /*      This include file defines named constants which can be used to specify the MRDS	*/
  2     8 /* operations to be permitted and prevented in a call to dsl_$set_scope.		*/
  2     9 /* 									*/
  2    10 /* Status									*/
  2    11 /* 									*/
  2    12 /* 0)   Created on January 25, 1980 by Jim Gray          				*/
  2    13 /* 1)   80-12-10 Jim Gray : r-u scope modes changed to r-s-m-d type scope modes,          */
  2    14 /*    also, names were changed to agree with security acl modes in MRDS.	          */
  2    15 /*									*/
  2    16 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    17 
  2    18 dcl (NO_OP init (0),
  2    19      READ_ATTR init (1),
  2    20      APPEND_TUPLE init (2),
  2    21      DELETE_TUPLE init (4),
  2    22      MODIFY_ATTR init (8),
  2    23      UPDATE_OPS init (14),
  2    24      ALL_OPS init (15)) fixed bin int static options (constant);
  2    25 
  2    26 /* END OF:	mrds_new_scope_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      405 
  3     1 /* START OF:	mrds_opening_modes_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3     4 	/*									*/
  3     5 	/* Name:  mrds_opening_modes_.incl.pl1						*/
  3     6 	/*									*/
  3     7 	/* Defines named constants which can be used in calls to dsl_$open when opening a MRDS	*/
  3     8 	/* data base.								*/
  3     9 	/*									*/
  3    10 	/* Status									*/
  3    11 	/* 0)  Created by:   Gary C. Dixon; January 22, 1979				*/
  3    12 	/*									*/
  3    13 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    14 
  3    15      dcl (RETRIEVAL			init(1),
  3    16 	UPDATE			init(2),
  3    17 	EXCLUSIVE_RETRIEVAL		init(3),
  3    18 	EXCLUSIVE_UPDATE		init(4)) fixed bin(35) int static options(constant);
  3    19 	
  3    20 /* END OF:	mrds_opening_modes_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3    21 
      406 
  4     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  4     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  4     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  4     9*     Nguyen. The scopes_changed flag was added to make checking for this
  4    10*     more efficient (mrds error list #137).
  4    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  4    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  4    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  4    14*     care if multiple txns use the same selection_expression. (mrds #156)
  4    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  4    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  4    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  4    18*                                                   END HISTORY COMMENTS */
  4    19 
  4    20 
  4    21 /* WARNING
  4    22*          If the dbcb structure is changed then the mrds_data_
  4    23*          item saved_res_version MUST be incremented to invalidate all
  4    24*          existing saved resultants
  4    25**/
  4    26 
  4    27 /* HISTORY :
  4    28*
  4    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  4    30*   tid_list management
  4    31*
  4    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  4    33*   phony resultant in mu_database_index, without having the area dcl
  4    34*   included.
  4    35*
  4    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  4    37*   mrds_dsl_store
  4    38*
  4    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  4    40*   switches
  4    41*
  4    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  4    43*   expression,  so  that relation statistics can be updated relative
  4    44*   to number of selection expressions seem. Also  removed  init  for
  4    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  4    46*   mrds_dsl_init_res.
  4    47*
  4    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  4    49*
  4    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  4    51*   for the conversion to the relation manager.
  4    52*
  4    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  4    54*   substructures so that the entries and costs can change
  4    55*   depending on the type of database that is opened.
  4    56*
  4    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  4    58*   since modify uses a different vector type (general) than does store.
  4    59*
  4    60*   82-09-20 Davids: changed names of (store modify)_vector to
  4    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  4    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  4    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  4    64*   during the first call.
  4    65*
  4    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  4    67*   since it deals with the pointers to the cursors and not the cursors
  4    68*   themelves and added the element cursor_storage_area_ptr which points
  4    69*   to the area where the cursors are kept.
  4    70*
  4    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  4    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  4    73*   anything.
  4    74*
  4    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  4    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  4    77*   by mrds_dsl_define_temp_rel.
  4    78*
  4    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  4    80*   is needed by mu_store.
  4    81*
  4    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  4    83*   bin to float bin since the values are not integers.
  4    84*
  4    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  4    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  4    87*   added to the end of the structure to allow modules that don't use
  4    88*   the element to continue to reference the dbcb structure without recompiling.
  4    89*
  4    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  4    91*   are needed so that temp rels can be created with the same file attributes
  4    92*   as the permanent relations.
  4    93*
  4    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  4    95*   added the resultant_in_pdir bit.
  4    96*
  4    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  4    98*   added the res_already_made element.
  4    99*
  4   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  4   101*
  4   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  4   103*   one of the unused pointers.
  4   104*
  4   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  4   106*
  4   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  4   108*   leaving unused_ptrs(1).
  4   109*
  4   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  4   111*   unused_ptrs (1).
  4   112*
  4   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  4   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  4   115*   spare ptrs, entries and reserved storages for future enhancement, since
  4   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  4   117*
  4   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  4   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  4   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  4   121**/
  4   122 
  4   123 
  4   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  4   125*   that constitutes the non-secure portion of the resultant model that is
  4   126*   created during the opening of a database. it contains variables that
  4   127*   are used during the runtime access of the database, and an area
  4   128*   for evaluation of requests. it points to four other
  4   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  4   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  4   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  4   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  4   133*   used in the elimination of duplicate tuples during a retrieve.
  4   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  4   135*   that is used when the database is using the file scope mechanism
  4   136*   for concurrency control over file readying. the segment overlayed via
  4   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  4   138*   across database openings. the pointer to this dbcb structure is kept in a table
  4   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  4   140*   opening instances of resultant models. (see mu_database_index routine) */
  4   141 
  4   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  4   143 	     2 data	      like dbcb_data,
  4   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  4   145 
  4   146      dcl	   dbcb_ptr	      ptr;
  4   147 
  4   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  4   149*						   like references can avoid getting the area declaration */
  4   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  4   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  4   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  4   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  4   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  4   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  4   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  4   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  4   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  4   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  4   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  4   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  4   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  4   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  4   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  4   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  4   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  4   167*						   for eliminating duplicate tuples. */
  4   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  4   169*						   for eliminating duplicate tuples. */
  4   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  4   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  4   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  4   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  4   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  4   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  4   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  4   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  4   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  4   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  4   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  4   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  4   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  4   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  4   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  4   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  4   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  4   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  4   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  4   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  4   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  4   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  4   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  4   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  4   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  4   195 	     2 val_del	      bit (1) unal,		/* for delete */
  4   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  4   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  4   198*                                                                     not imply that the database is of type page_file */
  4   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  4   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  4   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  4   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  4   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  4   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  4   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  4   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  4   207*						   inside a sequence of -another selection expression. */
  4   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  4   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  4   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  4   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  4   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  4   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  4   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  4   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  4   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  4   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  4   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  4   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  4   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  4   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  4   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  4   223 	     2 relmgr_entries,			/* relation manager entries */
  4   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  4   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  4   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  4   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  4   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  4   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  4   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  4   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  4   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  4   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  4   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  4   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  4   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  4   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  4   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  4   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  4   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  4   241 	       3 reserved_entries (5) entry (),
  4   242 	     2 access_costs,			/* access costs for permute */
  4   243 	       3 total_primary_key_cost float bin,
  4   244 	       3 access_cost      float bin,
  4   245 	       3 access_overhead  float bin,
  4   246 	       3 us_access_cost   float bin,
  4   247 	       3 os_access_cost   float bin,
  4   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  4   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  4   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  4   251 
  4   252 /* END mrds_dbcb.incl.pl1 */
  4   253 
  4   254 
      407 
  5     1 /* BEGIN mdbm_arg_list.incl.pl1 -- jaw 5/31/78 */
  5     2 /* the duplicate mrds_arg_list.incl.pl1 was eliminated by Jim Gray, Nov. 1979 */
  5     3 
  5     4 /* layout of argument list for IDS and DBM entries with options (variable) */
  5     5 
  5     6 dcl 1 arg_list based (al_ptr),
  5     7     2 arg_count fixed bin (17) unal,			/* 2 * no. of args. */
  5     8     2 code fixed bin (17) unal,			/* 4 => normal, 8 => special */
  5     9     2 desc_count fixed bin (17) unal,			/* 2 * no. of descriptors */
  5    10     2 pad fixed bin (17) unal,			/* must be 0 */
  5    11     2 arg_des_ptr (num_ptrs) ptr;			/* argument/descriptor pointer */
  5    12 
  5    13 dcl  al_ptr ptr;
  5    14 dcl  num_ptrs fixed bin;
  5    15 
  5    16 /* END mdbm_arg_list.incl.pl1  */
  5    17 
      408 
      409 
      410 
      411      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1315.0  mrds_dsl_set_scope.pl1            >special_ldd>install>MR12.2-1073>mrds_dsl_set_scope.pl1
404          1    10/14/83  1608.6  mdbm_descriptor.incl.pl1          >ldd>include>mdbm_descriptor.incl.pl1
405          2    10/14/83  1608.7  mrds_new_scope_modes.incl.pl1     >ldd>include>mrds_new_scope_modes.incl.pl1
406          3    10/14/83  1608.6  mrds_opening_modes_.incl.pl1      >ldd>include>mrds_opening_modes_.incl.pl1
407          4    08/01/88  1300.0  mrds_dbcb.incl.pl1                >special_ldd>install>MR12.2-1073>mrds_dbcb.incl.pl1
408          5    10/14/83  1609.0  mdbm_arg_list.incl.pl1            >ldd>include>mdbm_arg_list.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CHAR_NONVAR                     000133 automatic       fixed bin(17,0)          initial dcl 388 set ref 388*
EXCLUSIVE_RETRIEVAL                    constant        fixed bin(35,0)          initial dcl 3-15 ref 338
EXCLUSIVE_UPDATE                       constant        fixed bin(35,0)          initial dcl 3-15 ref 338
NON_SPECIAL                     000136 automatic       fixed bin(17,0)          initial dcl 391 set ref 391*
OFF                             000127 automatic       bit(1)                   initial packed unaligned dcl 383 set ref 160 190 191
                                                                                  205 383*
ON                              000126 automatic       bit(1)                   initial packed unaligned dcl 382 set ref 159 174 175
                                                                                  206 382*
SCOPE_ALL_ENTRY                 000111 automatic       bit(1)                   packed unaligned dcl 368 set ref 160* 175* 191* 206*
                                                                                  236 239 252 268 277 294 342
SET_SCOPE_ENTRY                 000304 automatic       bit(1)                   packed unaligned dcl 393 set ref 159* 174* 190* 205*
                                                                                  236 239 252 268 277 294 345 351
SPECIAL                         000125 automatic       fixed bin(17,0)          initial dcl 381 set ref 269 381*
addr                                                   builtin function         dcl 386 ref 294 298 298 298 298
al_ptr                          000314 automatic       pointer                  dcl 5-13 set ref 220* 238 241 242 252 254 269 276
                                                                                  286 296 298 336
arg_count                              based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-6 ref 252
arg_des_ptr               2            based           pointer                  array level 2 dcl 5-6 set ref 238 241 242 276 286
                                                                                  296 298*
arg_list                               based           structure                level 1 unaligned dcl 5-6
caller_name                     000100 automatic       char(20)                 initial packed unaligned dcl 362 set ref 259* 280*
                                                                                  301* 312* 362*
char_nonvar_descr               000135 automatic       bit(36)                  initial packed unaligned dcl 390 set ref 390*
code                      0(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-6 ref 269
continue                        000105 automatic       char(1)                  initial packed unaligned dcl 363 set ref 259* 280*
                                                                                  301* 312* 363*
cu_$arg_list_ptr                000012 constant        entry                    external dcl 366 ref 220
cu_$generate_call               000014 constant        entry                    external dcl 367 ref 357
data                                   based           structure                level 2 dcl 4-142
db_index                               based           fixed bin(35,0)          dcl 375 set ref 308* 312*
db_index_ptr                    000120 automatic       pointer                  dcl 376 set ref 298* 308 312
dbcb                                   based           structure                level 1 dcl 4-142
dbcb_data                              based           structure                level 1 unaligned dcl 4-148
dbcb_ptr                        000312 automatic       pointer                  dcl 4-146 set ref 232 232 308* 310 338 338
desc_count                1            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-6 ref 254
desc_index                      000124 automatic       fixed bin(17,0)          dcl 380 set ref 236 238 255* 269* 271* 272 276 296
desc_ptr                        000306 automatic       pointer                  dcl 1-19 set ref 238* 239 276* 277 294* 296* 298*
descriptor_ovrly                       based           bit(36)                  packed unaligned dcl 378 ref 239 277
empty                                                  builtin function         dcl 386 ref 392
entry_name                      000112 automatic       entry variable           dcl 369 set ref 345* 347* 351* 353* 357*
error_code                      000116 automatic       fixed bin(35,0)          dcl 371 set ref 216* 232 242 258* 259* 279* 280*
                                                                                  298* 300 301* 311* 312* 333 340* 356
error_code_ovrly                       based           fixed bin(35,0)          dcl 394 set ref 241 242* 286*
error_table_$bad_arg            000022 external static fixed bin(35,0)          dcl 373 ref 279
error_table_$wrong_no_of_args   000024 external static fixed bin(35,0)          dcl 374 ref 258
exclusive_opening               000305 automatic       bit(1)                   packed unaligned dcl 402 set ref 338* 340
fixed                                                  builtin function         dcl 386 ref 338 338
fixed_bin_17_descr              000134 automatic       bit(36)                  initial packed unaligned dcl 389 set ref 389*
fixed_bin_35_descr              000123 automatic       bit(36)                  initial packed unaligned dcl 379 set ref 239 277 294
                                                                                  298 298 379*
info_ptr                        000106 automatic       pointer                  initial dcl 364 set ref 259* 280* 301* 312* 364*
local_area                      000140 automatic       area(100)                dcl 392 set ref 298 298 392*
min_args                        000132 automatic       fixed bin(17,0)          dcl 387 set ref 161* 176* 192* 207* 257 259*
mrds_dsl_dl_fscope$dl_fscope    000030 constant        entry                    external dcl 397 ref 353
mrds_dsl_dl_fscope$dl_fscope_all
                                000032 constant        entry                    external dcl 397 ref 347
mrds_dsl_set_fscope$set_fscope  000034 constant        entry                    external dcl 397 ref 351
mrds_dsl_set_fscope$set_fscope_all
                                000036 constant        entry                    external dcl 397 ref 345
mrds_error_$invalid_db_index    000020 external static fixed bin(35,0)          dcl 372 ref 311
mrds_error_$unshared_opening    000040 external static fixed bin(35,0)          dcl 401 ref 340
mu_convert_parameter$convert_input_parameter
                                000026 constant        entry                    external dcl 395 ref 298
mu_database_index$get_resultant_model_pointer
                                000016 constant        entry                    external dcl 370 ref 308
nargs                           000122 automatic       fixed bin(17,0)          dcl 377 set ref 238 241 242 252* 254* 257 259* 269
                                                                                  271 272 276 286
new_al_ptr                      000130 automatic       pointer                  dcl 384 set ref 336* 357*
null                                                   builtin function         dcl 386 ref 232 310 364
num_dims                        000310 automatic       fixed bin(17,0)          initial dcl 1-20 set ref 1-20* 292*
num_ptrs                        000316 automatic       fixed bin(17,0)          dcl 5-14 set ref 272*
open_mode               106(14)        based           bit(3)                   level 3 packed packed unaligned dcl 4-142 ref 338
                                                                                  338
return_value                    000110 automatic       fixed bin(35,0)          initial dcl 365 set ref 259* 280* 301* 312* 365*
scopes_changed          106(24)        based           bit(1)                   level 3 packed packed unaligned dcl 4-142 set ref
                                                                                  232*
sub_err_                        000010 constant        entry                    external dcl 361 ref 259 280 301 312

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALL_OPS                                internal static fixed bin(17,0)          initial dcl 2-18
APPEND_TUPLE                           internal static fixed bin(17,0)          initial dcl 2-18
DELETE_TUPLE                           internal static fixed bin(17,0)          initial dcl 2-18
MODIFY_ATTR                            internal static fixed bin(17,0)          initial dcl 2-18
NO_OP                                  internal static fixed bin(17,0)          initial dcl 2-18
READ_ATTR                              internal static fixed bin(17,0)          initial dcl 2-18
RETRIEVAL                              internal static fixed bin(35,0)          initial dcl 3-15
UPDATE                                 internal static fixed bin(35,0)          initial dcl 3-15
UPDATE_OPS                             internal static fixed bin(17,0)          initial dcl 2-18
descriptor                             based           structure                level 1 unaligned dcl 1-6
rel                                                    builtin function         dcl 386
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 385

NAMES DECLARED BY EXPLICIT CONTEXT.
common_scope_routine            000330 constant        label                    dcl 211 ref 165 179 196 209
dl_scope                        000276 constant        entry                    external dcl 186
dl_scope_all                    000313 constant        entry                    external dcl 201
get_version_of_caller           000415 constant        entry                    internal dcl 247 ref 224
mrds_dsl_set_scope              000233 constant        entry                    external dcl 61
pass_call_to_correct_version    001103 constant        entry                    internal dcl 325 ref 228
set_scope                       000243 constant        entry                    external dcl 155
set_scope_all                   000261 constant        entry                    external dcl 170

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1464        1526    1211        1474
Length      2042    1211        42         300     253           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_dsl_set_scope                  356 external procedure  is an external procedure.  
get_version_of_caller                   internal procedure  shares stack frame of external procedure mrds_dsl_set_scope.  
pass_call_to_correct_version            internal procedure  shares stack frame of external procedure mrds_dsl_set_scope.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_dsl_set_scope       000100 caller_name                 mrds_dsl_set_scope
                         000105 continue                    mrds_dsl_set_scope
                         000106 info_ptr                    mrds_dsl_set_scope
                         000110 return_value                mrds_dsl_set_scope
                         000111 SCOPE_ALL_ENTRY             mrds_dsl_set_scope
                         000112 entry_name                  mrds_dsl_set_scope
                         000116 error_code                  mrds_dsl_set_scope
                         000120 db_index_ptr                mrds_dsl_set_scope
                         000122 nargs                       mrds_dsl_set_scope
                         000123 fixed_bin_35_descr          mrds_dsl_set_scope
                         000124 desc_index                  mrds_dsl_set_scope
                         000125 SPECIAL                     mrds_dsl_set_scope
                         000126 ON                          mrds_dsl_set_scope
                         000127 OFF                         mrds_dsl_set_scope
                         000130 new_al_ptr                  mrds_dsl_set_scope
                         000132 min_args                    mrds_dsl_set_scope
                         000133 CHAR_NONVAR                 mrds_dsl_set_scope
                         000134 fixed_bin_17_descr          mrds_dsl_set_scope
                         000135 char_nonvar_descr           mrds_dsl_set_scope
                         000136 NON_SPECIAL                 mrds_dsl_set_scope
                         000140 local_area                  mrds_dsl_set_scope
                         000304 SET_SCOPE_ENTRY             mrds_dsl_set_scope
                         000305 exclusive_opening           mrds_dsl_set_scope
                         000306 desc_ptr                    mrds_dsl_set_scope
                         000310 num_dims                    mrds_dsl_set_scope
                         000312 dbcb_ptr                    mrds_dsl_set_scope
                         000314 al_ptr                      mrds_dsl_set_scope
                         000316 num_ptrs                    mrds_dsl_set_scope

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out_desc   call_ext_out        return_mac          ext_entry           trunc_fx2
divide_fx1          op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$arg_list_ptr              cu_$generate_call             mrds_dsl_dl_fscope$dl_fscope
mrds_dsl_dl_fscope$dl_fscope_all                            mrds_dsl_set_fscope$set_fscope
mrds_dsl_set_fscope$set_fscope_all                          mu_convert_parameter$convert_input_parameter
mu_database_index$get_resultant_model_pointer               sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$wrong_no_of_args mrds_error_$invalid_db_index  mrds_error_$unshared_opening




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    362 000175       363 000200       364 000202       365 000204       379 000205       381 000207       382 000211
    383 000213       388 000214       389 000216       390 000220       391 000222       392 000224    1   20 000227
     61 000232        61 000241       155 000242       159 000251       160 000253       161 000255       165 000257
    170 000260       174 000267       175 000271       176 000272       179 000274       186 000275       190 000304
    191 000306       192 000307       196 000311       201 000312       205 000321       206 000323       207 000325
    209 000327       211 000330       216 000331       220 000332       224 000341       228 000342       232 000343
    235 000354       236 000355       238 000366       239 000374       241 000403       242 000412       245 000414
    247 000415       252 000416       254 000434       255 000445       257 000446       258 000450       259 000453
    263 000550       268 000551       269 000554       271 000565       272 000567       276 000572       277 000600
    279 000606       280 000611       283 000664       286 000665       292 000671       294 000672       296 000677
    298 000704       300 000732       301 000734       303 001001       308 001002       310 001013       311 001017
    312 001022       323 001102       325 001103       333 001104       336 001107       338 001111       340 001131
    342 001135       345 001137       347 001147       348 001154       351 001155       353 001165       356 001172
    357 001175       359 001205


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
