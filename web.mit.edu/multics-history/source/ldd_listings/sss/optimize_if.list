	COMPILATION LISTING OF SEGMENT optimize_if
	Compiled by: Multics PL/I Compiler, Release 28d, of September 14, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 10/03/83  1653.3 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* procedure to optimize an if statement
       12*
       13*   Initial Version:	1 November 1975 by RAB
       14*	Modified:	1 July 1976 by RAB for label array improvements
       15*	Modified:	23 Jan 1977 by RAB to make recursive for combine_tests
       16*	Modified:	9 Mar 1977 by RAB to remove some dead code
       17*	Modified:	12 March 1977 by RAB to change handling of mod_word
       18*	Modified:	9 April 1977 by RAB to remove mod_word	*/
       19 
       20 /* if statements are optimized by changing boolean operations into jumps.
       21*   Among the transformations performed are:
       22*
       23*   jump_true(target,or_bits(a,b)) -> jump_true(target,a), jump_true(target,b)
       24*
       25*   jump_true(target,and_bits(a,b)) -> jump_false(next,a), jump_true(target,b)
       26*
       27*   jump_true(target,not_bits(a)) -> jump_false(target,a)
       28*
       29*   jump_false(target,and_bits(a,b)) -> jump_false(target,a), jump_false(target,b)
       30*
       31*   jump_false(target,or_bits(a,b)) -> jump_true(next,a), jump_false(target,b)
       32*
       33*   jump_false(target,not_bits(a)) -> jump_true(target,a)
       34*
       35*   These transformations are not performed if the boolean operators have already
       36*   been evaluated or if their values are needed later on */
       37 
       38 optimize_if:	proc(pt);
       39 
       40 dcl	pt ptr;	/* points at statement being optimized */
       41 
       42 dcl	(jop,lp,next,nextlab,p3,st,target,tree,next_tree) ptr;
       43 dcl	(jump_code,op_code) bit(9) aligned;
       44 
       45 dcl	(cg_stat$cur_block,pl1_stat_$cur_statement) ptr ext static;
       46 dcl	cg_stat$cur_level fixed bin ext static;
       47 
       48 dcl (	rel_op		init("00100"b),
       49 	jump_op		init("00101"b)
       50 			) bit(5) aligned int static;
       51 
       52 dcl	(fixed,null,string,substr) builtin;
       53 
       54 dcl	create_list entry(fixed bin) returns(ptr);
       55 dcl	create_label entry(ptr,ptr,bit(3) aligned) returns(ptr);
       56 dcl	create_operator entry(bit(9) aligned,fixed bin(15)) returns(ptr);
       57 dcl	create_statement entry(bit(9) aligned,ptr,ptr,bit(12) aligned) returns(ptr);
       58 dcl	share_expression entry(ptr) returns(ptr);
       59 dcl	jump_op$eval_primaries entry(ptr);
       60 dcl	prepare_operand entry(ptr,fixed bin,bit(1) aligned) returns(ptr);
       61 dcl	compile_exp entry(ptr);
       62 
  1     1 /* BEGIN INCLUDE FILE ... nodes.incl.pl1 */
  1     2 
  1     3 /* Modified: 26 Dec 1979 by PCK to implement by name assignment */
  1     4 
  1     5 dcl (	block_node		initial("000000001"b),
  1     6 	statement_node		initial("000000010"b),
  1     7 	operator_node		initial("000000011"b),
  1     8 	reference_node		initial("000000100"b),
  1     9 	token_node		initial("000000101"b),
  1    10 	symbol_node		initial("000000110"b),
  1    11 	context_node		initial("000000111"b),
  1    12 	array_node		initial("000001000"b),
  1    13 	bound_node		initial("000001001"b),
  1    14 	format_value_node		initial("000001010"b),
  1    15 	list_node			initial("000001011"b),
  1    16 	default_node		initial("000001100"b),
  1    17 	machine_state_node		initial("000001101"b),
  1    18 	source_node		initial("000001110"b),
  1    19 	label_node		initial("000001111"b),
  1    20 	cross_reference_node	initial("000010000"b),
  1    21 	sf_par_node		initial("000010001"b),
  1    22 	temporary_node		initial("000010010"b),
  1    23 	label_array_element_node	initial("000010011"b),
  1    24 	by_name_agg_node		initial("000010100"b))
  1    25 				bit(9) internal static aligned options(constant);
  1    26 
  1    27 dcl	1 node			based aligned,
  1    28 	2 type			unal bit(9),
  1    29 	2 source_id		unal structure,
  1    30 	  3 file_number		bit(8),
  1    31 	  3 line_number		bit(14),
  1    32 	  3 statement_number	bit(5);
  1    33 
  1    34 /* END INCLUDE FILE ... nodes.incl.pl1 */
       63 
  2     1 /* BEGIN INCLUDE FILE ... block.incl.pl1 */
  2     2 /* Modified 22 Ocober 1980 by M. N. Davidoff to increase max block.number to 511 */
  2     3 /* format: style3,idind30 */
  2     4 
  2     5 declare	1 block			aligned based,
  2     6 	  2 node_type		bit (9) unaligned,
  2     7 	  2 source_id		structure unaligned,
  2     8 	    3 file_number		bit (8),
  2     9 	    3 line_number		bit (14),
  2    10 	    3 statement_number	bit (5),
  2    11 	  2 father		ptr unaligned,
  2    12 	  2 brother		ptr unaligned,
  2    13 	  2 son			ptr unaligned,
  2    14 	  2 declaration		ptr unaligned,
  2    15 	  2 end_declaration		ptr unaligned,
  2    16 	  2 default		ptr unaligned,
  2    17 	  2 end_default		ptr unaligned,
  2    18 	  2 context		ptr unaligned,
  2    19 	  2 prologue		ptr unaligned,
  2    20 	  2 end_prologue		ptr unaligned,
  2    21 	  2 main			ptr unaligned,
  2    22 	  2 end_main		ptr unaligned,
  2    23 	  2 return_values		ptr unaligned,
  2    24 	  2 return_count		ptr unaligned,
  2    25 	  2 plio_ps		ptr unaligned,
  2    26 	  2 plio_fa		ptr unaligned,
  2    27 	  2 plio_ffsb		ptr unaligned,
  2    28 	  2 plio_ssl		ptr unaligned,
  2    29 	  2 plio_fab2		ptr unaligned,
  2    30 	  2 block_type		bit (9) unaligned,
  2    31 	  2 prefix		bit (12) unaligned,
  2    32 	  2 like_attribute		bit (1) unaligned,
  2    33 	  2 no_stack		bit (1) unaligned,
  2    34 	  2 get_data		bit (1) unaligned,
  2    35 	  2 flush_at_call		bit (1) unaligned,
  2    36 	  2 processed		bit (1) unaligned,
  2    37 	  2 text_displayed		bit (1) unaligned,
  2    38 	  2 number		fixed bin (9) unsigned unaligned,
  2    39 	  2 free_temps		dimension (3) ptr,	/* these fields are used by the code generator */
  2    40 	  2 temp_list		ptr,
  2    41 	  2 entry_list		ptr,
  2    42 	  2 o_and_s		ptr,
  2    43 	  2 why_nonquick		aligned,
  2    44 	    3 auto_adjustable_storage bit (1) unaligned,
  2    45 	    3 returns_star_extents	bit (1) unaligned,
  2    46 	    3 stack_extended_by_args	bit (1) unaligned,
  2    47 	    3 invoked_by_format	bit (1) unaligned,
  2    48 	    3 format_statement	bit (1) unaligned,
  2    49 	    3 io_statements		bit (1) unaligned,
  2    50 	    3 assigned_to_entry_var	bit (1) unaligned,
  2    51 	    3 condition_statements	bit (1) unaligned,
  2    52 	    3 no_owner		bit (1) unaligned,
  2    53 	    3 recursive_call	bit (1) unaligned,
  2    54 	    3 options_non_quick	bit (1) unaligned,
  2    55 	    3 options_variable	bit (1) unaligned,
  2    56 	    3 never_referenced	bit (1) unaligned,
  2    57 	    3 pad_nonquick		bit (5) unaligned,
  2    58 	  2 prologue_flag		bit (1) unaligned,
  2    59 	  2 options_main		bit (1) unaligned,
  2    60 	  2 pad			bit (16) unaligned,
  2    61 	  2 number_of_entries	fixed bin (17),
  2    62 	  2 level			fixed bin (17),
  2    63 	  2 last_auto_loc		fixed bin (17),
  2    64 	  2 symbol_block		fixed bin (17),
  2    65 	  2 entry_info		fixed bin (18),
  2    66 	  2 enter			structure unaligned,
  2    67 	    3 start		fixed bin (17),
  2    68 	    3 end			fixed bin (17),
  2    69 	  2 leave			structure unaligned,
  2    70 	    3 start		fixed bin (17),
  2    71 	    3 end			fixed bin (17),
  2    72 	  2 owner			ptr;
  2    73 
  2    74 declare	max_block_number		fixed bin internal static options (constant) initial (511);
  2    75 
  2    76 /* END INCLUDE FILE ... block.incl.pl1 */
       64 
  3     1 /* ***********************************************************
  3     2*   *                                                         *
  3     3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
  3     4*   *                                                         *
  3     5*   *********************************************************** */
  3     6 /* BEGIN INCLUDE FILE ... statement.incl.pl1 */
  3     7 /* Internal interface of the PL/I compiler */
  3     8 
  3     9 dcl	1 statement		based aligned,
  3    10 	2 node_type		bit(9) unaligned,
  3    11 	2 source_id		structure unaligned,
  3    12 	  3 file_number		bit(8),
  3    13 	  3 line_number		bit(14),
  3    14 	  3 statement_number	bit(5),
  3    15 	2 next			ptr unaligned,
  3    16 	2 back			ptr unaligned,
  3    17 	2 root			ptr unaligned,
  3    18 	2 labels			ptr unaligned,
  3    19 	2 reference_list		ptr unaligned,
  3    20 	2 state_list		ptr unaligned,
  3    21 	2 reference_count		fixed(17) unaligned,
  3    22 	2 ref_count_copy		fixed(17) unaligned,
  3    23 	2 object			structure unaligned,
  3    24 	  3 start			fixed(17),
  3    25 	  3 finish		fixed(17),
  3    26 	2 source			structure unaligned,
  3    27 	  3 segment		fixed(11),
  3    28 	  3 start			fixed(23),
  3    29 	  3 length		fixed(11),
  3    30 	2 prefix			bit(12) unaligned,
  3    31 	2 optimized		bit(1) unaligned,
  3    32 	2 free_temps		bit(1) unaligned,
  3    33 	2 LHS_in_RHS		bit(1) unaligned,
  3    34 	2 statement_type		bit(9) unaligned,
  3    35 	2 bits			structure unaligned,
  3    36 	  3 processed		bit(1) unaligned,
  3    37 	  3 put_in_profile		bit(1) unaligned,
  3    38 	  3 generated		bit(1) unaligned,
  3    39 	  3 snap			bit(1) unaligned,
  3    40 	  3 system		bit(1) unaligned,
  3    41 	  3 irreducible		bit(1) unaligned,
  3    42 	  3 checked		bit(1) unaligned,
  3    43 	  3 save_temps		bit(1) unaligned,
  3    44 	  3 suppress_warnings	bit(1) unaligned,
  3    45 	  3 force_nonquick		bit(1) unaligned,
  3    46 	  3 expanded_by_name	bit(1) unaligned,
  3    47 	  3 begins_loop		bit(1) unaligned,
  3    48 	  3 pad			bit(24) unaligned;
  3    49 
  3    50 /* END INCLUDE FILE ... statement.incl.pl1 */
       65 
  4     1 	/* statement types */
  4     2 
  4     3 dcl (	unknown_statement		initial("000000000"b),
  4     4 	allocate_statement		initial("000000001"b),
  4     5 	assignment_statement	initial("000000010"b),
  4     6 	begin_statement		initial("000000011"b),
  4     7 	call_statement		initial("000000100"b),
  4     8 	close_statement		initial("000000101"b),
  4     9 	declare_statement		initial("000000110"b),
  4    10 	lock_statement		initial("000000111"b),
  4    11 	delete_statement		initial("000001000"b),
  4    12 	display_statement		initial("000001001"b),
  4    13 	do_statement		initial("000001010"b),
  4    14 	else_clause		initial("000001011"b),
  4    15 	end_statement		initial("000001100"b),
  4    16 	entry_statement		initial("000001101"b),
  4    17 	exit_statement		initial("000001110"b),
  4    18 	format_statement		initial("000001111"b),
  4    19 	free_statement		initial("000010000"b),
  4    20 	get_statement		initial("000010001"b),
  4    21 	goto_statement		initial("000010010"b),
  4    22 	if_statement		initial("000010011"b),
  4    23 	locate_statement		initial("000010100"b),
  4    24 	null_statement		initial("000010101"b),
  4    25 	on_statement		initial("000010110"b),
  4    26 	open_statement		initial("000010111"b),
  4    27 	procedure_statement 	initial("000011000"b),
  4    28 	put_statement		initial("000011001"b),
  4    29 	read_statement		initial("000011010"b),
  4    30 	return_statement		initial("000011011"b),
  4    31 	revert_statement		initial("000011100"b),
  4    32 	rewrite_statement		initial("000011101"b),
  4    33 	signal_statement		initial("000011110"b),
  4    34 	stop_statement		initial("000011111"b),
  4    35 	system_on_unit		initial("000100000"b),
  4    36 	unlock_statement		initial("000100001"b),
  4    37 	wait_statement		initial("000100010"b),
  4    38 	write_statement		initial("000100011"b),
  4    39 	default_statement		initial("000100100"b),
  4    40 	continue_statement		initial("000100101"b)) bit(9) internal static aligned options(constant);
       66 
  5     1 dcl	1 label			based aligned,
  5     2 	2 node_type		bit(9) unaligned,
  5     3 	2 source_id		structure unaligned,
  5     4 	  3 file_number		bit(8),
  5     5 	  3 line_number		bit(14),
  5     6 	  3 statement_number	bit(5),
  5     7 	2 location		fixed(17) unaligned,
  5     8 	2 allocated		bit(1) unaligned,
  5     9 	2 dcl_type		bit(3) unaligned,
  5    10 	2 reserved		bit(29) unaligned,
  5    11 	2 array			bit(1) unaligned,
  5    12 	2 used_as_format		bit(1) unaligned,
  5    13 	2 used_in_goto		bit(1) unaligned,
  5    14 	2 symbol_table		bit(18) unaligned,
  5    15 	2 low_bound		fixed(17) unaligned,
  5    16 	2 high_bound		fixed(17) unaligned,
  5    17 	2 block_node		ptr unaligned,
  5    18 	2 token			ptr unaligned,
  5    19 	2 next			ptr unaligned,
  5    20 	2 multi_use		ptr unaligned,
  5    21 	2 cross_reference		ptr unaligned,
  5    22 	2 statement		ptr unaligned;
       67 
  6     1 /* BEGIN INCLUDE FILE ... declare_type.incl.pl1 */
  6     2 
  6     3 /* Modified: 25 Apr 1979 by PCK to implement 4-bit decimal */
  6     4 
  6     5 dcl  (	by_declare	initial("001"b),
  6     6 	by_explicit_context initial("010"b),
  6     7 	by_context	initial("011"b),
  6     8 	by_implication	initial("100"b),
  6     9 	by_compiler	initial("101"b)) int static bit(3) aligned options(constant);
  6    10 
  6    11 /* END INCLUDE FILE ... declare_type.incl.pl1 */
       68 
  7     1 /* BEGIN INCLUDE FILE ... list.incl.pl1 */
  7     2 
  7     3 /* Modified 26 June 81 by EBush to add max_list_elements */
  7     4 
  7     5 
  7     6 dcl	1 list		based aligned,
  7     7 	2 node_type	bit(9) unaligned,
  7     8 	2 reserved	bit(12) unaligned,
  7     9 	2 number		fixed(14) unaligned,
  7    10 	2 element		dimension(n refer(list.number)) ptr unaligned;
  7    11 
  7    12 dcl       max_list_elements   fixed bin(17) internal static options (constant)
  7    13 	                    init(16383);
  7    14 
  7    15 /* END INCLUDE FILE ... list.incl.pl1 */
       69 
  8     1 /* BEGIN INCLUDE FILE ... reference.incl.pl1 */
  8     2 
  8     3 dcl	1 reference		based aligned,
  8     4 	2 node_type		bit(9) unaligned,
  8     5 	2 array_ref		bit(1) unaligned,
  8     6 	2 varying_ref		bit(1) unaligned,
  8     7 	2 shared			bit(1) unaligned,
  8     8 	2 put_data_sw		bit(1) unaligned,
  8     9 	2 processed		bit(1) unaligned,
  8    10 	2 units			fixed(3) unaligned,
  8    11 	2 ref_count		fixed(17) unaligned,
  8    12 	2 c_offset		fixed(24),
  8    13 	2 c_length		fixed(24),
  8    14 	2 symbol			ptr unaligned,
  8    15 	2 qualifier		ptr unaligned,
  8    16 	2 offset			ptr unaligned,
  8    17 	2 length			ptr unaligned,
  8    18 	2 subscript_list		ptr unaligned,
  8    19 						/* these fields are used by the 645 code generator */
  8    20 	2 address			structure unaligned,
  8    21 	  3 base			bit(3),
  8    22 	  3 offset		bit(15),
  8    23 	  3 op			bit(9),
  8    24 	  3 no_address		bit(1),
  8    25 	  3 inhibit		bit(1),
  8    26 	  3 ext_base		bit(1),
  8    27 	  3 tag			bit(6),
  8    28 	2 info			structure unaligned,
  8    29 	  3 address_in		structure,
  8    30 	    4 b			dimension(0:7) bit(1),
  8    31 	    4 storage		bit(1),
  8    32 	  3 value_in		structure,
  8    33 	    4 a			bit(1),
  8    34 	    4 q			bit(1),
  8    35 	    4 aq			bit(1),
  8    36 	    4 string_aq		bit(1),
  8    37 	    4 complex_aq		bit(1),
  8    38 	    4 decimal_aq		bit(1),
  8    39 	    4 b			dimension(0:7) bit(1),
  8    40 	    4 storage		bit(1),
  8    41 	    4 indicators		bit(1),
  8    42 	    4 x			dimension(0:7) bit(1),
  8    43 	  3 other			structure,
  8    44 	    4 big_offset		bit(1),
  8    45 	    4 big_length		bit(1),
  8    46 	    4 modword_in_offset	bit(1),
  8    47 	2 data_type		fixed(5) unaligned,
  8    48 	2 bits			structure unaligned,
  8    49 	  3 padded_ref		bit(1),
  8    50 	  3 aligned_ref		bit(1),
  8    51 	  3 long_ref		bit(1),
  8    52 	  3 forward_ref		bit(1),
  8    53 	  3 ic_ref		bit(1),
  8    54 	  3 temp_ref		bit(1),
  8    55 	  3 defined_ref		bit(1),
  8    56 	  3 evaluated		bit(1),
  8    57 	  3 allocate		bit(1),
  8    58 	  3 allocated		bit(1),
  8    59 	  3 aliasable		bit(1),
  8    60 	  3 even			bit(1),
  8    61 	  3 perm_address		bit(1),
  8    62 	  3 aggregate		bit(1),
  8    63 	  3 hit_zero		bit(1),
  8    64 	  3 dont_save		bit(1),
  8    65 	  3 fo_in_qual		bit(1),
  8    66 	  3 hard_to_load		bit(1),
  8    67 	2 relocation		bit(12) unaligned,
  8    68 	2 more_bits		structure unaligned,
  8    69 	  3 substr		bit(1),
  8    70 	  3 padded_for_store_ref	bit(1),
  8    71 	  3 aligned_for_store_ref	bit(1),
  8    72 	  3 mbz			bit(15),
  8    73 	2 store_ins		bit(18) unaligned;
  8    74 
  8    75 /* END INCLUDE FILE ... reference.incl.pl1 */
       70 
  9     1 /* BEGIN INCLUDE FILE ... operator.incl.pl1 */
  9     2 
  9     3 /*	Modified: 2 Apr 1980 by PCK to add max_number_of_operands */
  9     4 
  9     5 /* format: style3 */
  9     6 dcl	1 operator	based aligned,
  9     7 	  2 node_type	bit (9) unaligned,
  9     8 	  2 op_code	bit (9) unaligned,
  9     9 	  2 shared	bit (1) unaligned,
  9    10 	  2 processed	bit (1) unaligned,
  9    11 	  2 optimized	bit (1) unaligned,
  9    12 	  2 number	fixed (14) unaligned,
  9    13 	  2 operand	dimension (n refer (operator.number)) ptr unaligned;
  9    14 
  9    15 dcl	max_number_of_operands
  9    16 			fixed bin (15) int static options (constant) initial (32767);
  9    17 
  9    18 /* END INCLUDE FILE ... operator.incl.pl1 */
       71 
 10     1 /* BEGIN INCLUDE FILE ... op_codes.incl.pl1 */
 10     2 
 10     3 /* Modified: 25 Apr 1979 by PCK 4-bit decimal */
 10     4 /* Modified: 6 Jun 1979 by PG to add rank and byte */
 10     5 /* Modified: 26 Dec 1979 by PCK to add assign_by_name */
 10     6 /* Modified: 26 July 82 BIM wordno, segno */
 10     7 
 10     8 dcl (	add		initial("000010001"b),	/* opnd(1) <- opnd(2)+opnd(3)		*/
 10     9 	sub		initial("000010010"b),	/* opnd(1) <- opnd(2)-opnd(3)		*/
 10    10 	mult		initial("000010011"b),	/* opnd(1) <- opnd(2)*opnd(3)		*/
 10    11 	div		initial("000010100"b),	/* opnd(1) <- opnd(2)/opnd(3)		*/
 10    12 	negate		initial("000010101"b),	/* opnd(1) <- -opnd(2)  		*/
 10    13 	exp		initial("000010110"b),	/* opnd(1) <- opnd(2) ** opnd(3)	*/
 10    14 
 10    15 	and_bits		initial("000100001"b),	/* opnd(1) <- opnd(2) & opnd(3)	*/
 10    16 	or_bits		initial("000100010"b),	/* opnd(1) <- opnd(2)|opnd(3)		*/
 10    17 	xor_bits		initial("000100011"b),	/* opnd(1) <- opnd(2) xor opnd(3)	*/
 10    18 	not_bits		initial("000100100"b),	/* opnd(1) <- ^opnd(2)		*/
 10    19 	cat_string	initial("000100101"b),	/* opnd(1) <- opnd(2)||opnd(3)	*/
 10    20 	bool_fun		initial("000100110"b),	/* opnd(1) <- bool(opnd(2),opnd(3),opnd(4)) */
 10    21 
 10    22 	assign		initial("000110001"b),	/* opnd(1) <- opnd(2)		*/
 10    23 	assign_size_ck	initial("000110010"b),	/* opnd(1) <- opnd(2)		*/
 10    24 	assign_zero	initial("000110011"b),	/* opnd(1) <- 0			*/
 10    25 	copy_words	initial("000110100"b),	/* move opnd(2) to opnd(1) by opnd(3) words */
 10    26 	copy_string	initial("000110101"b),	/* move opnd(2) to opnd(1) by opnd(3) units */
 10    27 	make_desc		initial("000110110"b),	/* opnd(1) <- descriptor(opnd(2),opnd(3)) */
 10    28 	assign_round	initial("000110111"b),	/* opnd(1) <- opnd(2) rounded		*/
 10    29 	pack		initial("000111000"b),	/* opnd(1) <- encode to picture opnd(2) */
 10    30 	unpack		initial("000111001"b),	/* opnd(1) <- decode from picture opnd(2) */
 10    31 
 10    32 	less_than		initial("001000100"b),	/* opnd(1) <- opnd(2) < opnd(3)	*/
 10    33 	greater_than	initial("001000101"b),	/* opnd(1) <- opnd(2) > opnd(3)	*/
 10    34 	equal		initial("001000110"b),	/* opnd(1) <- opnd(2) = opnd(3)	*/
 10    35 	not_equal		initial("001000111"b),	/* opnd(1) <- opnd(2) ^= opnd(3)	*/
 10    36 	less_or_equal	initial("001001000"b),	/* opnd(1) <- opnd(2) <= opnd(3)	*/
 10    37 	greater_or_equal	initial("001001001"b),	/* opnd(1) <- opnd(2) >= opnd(3)	*/
 10    38 
 10    39 	jump		initial("001010001"b),	/* go to opnd(1) unconditionally	*/
 10    40 	jump_true		initial("001010010"b),	/* go to opnd(1) if opnd(2) is not 0	*/
 10    41 	jump_false	initial("001010011"b),	/* go to opnd(1) if opnd(2) is all 0	*/
 10    42 	jump_if_lt	initial("001010100"b),	/* go to opnd(1) if opnd(2) < opnd(3)	*/
 10    43 	jump_if_gt	initial("001010101"b),	/* go to opnd(1) if opnd(2) > opnd(3)	*/
 10    44 	jump_if_eq	initial("001010110"b),	/* go to opnd(1) if opnd(2) = opnd(3)	*/
 10    45 	jump_if_ne	initial("001010111"b),	/* go to opnd(1) if opnd(2) ^= opnd(3)	*/
 10    46 	jump_if_le	initial("001011000"b),	/* go to opnd(1) if opnd(2) <= opnd(3)	*/
 10    47 	jump_if_ge	initial("001011001"b),	/* go to opnd(1) if opnd(2) >= opnd(3)	*/
 10    48 
 10    49 	std_arg_list	initial("001100001"b),	/* opnd(1) <- arglist(opnd(2) desclist(opnd(3)))	*/
 10    50 	return_words	initial("001100010"b),	/* return aggregate opnd(1), opnd(2) is length in words */
 10    51 	std_call		initial("001100011"b),	/* opnd(1) <- call opnd(2) with opnd(3)		*/
 10    52 	return_bits	initial("001100100"b),	/* return aggregate opnd(1), opnd(2) is length in bits */
 10    53 	std_entry		initial("001100101"b),	/* entry(opnd(1)... opnd(n))			*/
 10    54 	return_string	initial("001100110"b),	/* return string opnd(1) */
 10    55 	ex_prologue	initial("001100111"b),	/* execute the prologue -no operands-		*/
 10    56 	allot_auto	initial("001101000"b),	/* opnd(1) <- addrel(stack,opnd(2))		*/
 10    57 	param_ptr		initial("001101001"b),	/* opnd(1) <- ptr to opnd(2) in  block opnd(3)	*/
 10    58 	param_desc_ptr	initial("001101010"b),	/* opnd(1) <- ptr to opnd(2) in block opnd(3)	*/
 10    59 	std_return	initial("001101011"b),	/* return -no arguments-			*/
 10    60 	allot_ctl		initial("001101100"b),	/* allocate opnd(1) , length in words is opnd(2) 	*/
 10    61 	free_ctl		initial("001101101"b),	/* free opnd(1)				*/
 10    62 	stop		initial("001101110"b),	/* stop - terminate run unit			*/
 10    63 
 10    64 	mod_bit		initial("001110000"b),	/* opnd(1) <- mod(opnd(3),36),
 10    65*						   opnd(2) <- opnd(3) / 36		*/
 10    66 	mod_byte		initial("001110001"b),	/* opnd(1) <- mod(opnd(3),4),
 10    67*						   opnd(2) <- opnd(3) / 4		*/
 10    68 	mod_half		initial("001110010"b),	/* opnd(1) <- mod(opnd(3),2),
 10    69*						   opnd(2) <- opnd(3) / 2		*/
 10    70 	mod_word		initial("001110011"b),	/* TO BE DEFINED BY BLW			*/
 10    71 
 10    72 	bit_to_char	initial("010000000"b),	/* opnd(1) <- (opnd(2)+8)/9		*/
 10    73 	bit_to_word	initial("010000001"b),	/* opnd(1) <- (opnd(2)+35)/36		*/
 10    74 	char_to_word	initial("010000010"b),	/* opnd(1) <- (opnd(2)+3)/4		*/
 10    75 	half_to_word	initial("010000011"b),	/* opnd(1) <- (opnd(2)+1)/2		*/
 10    76 	word_to_mod2	initial("010000100"b),	/* opnd(1) <- (opnd(2)+1)/2*2		*/
 10    77 	word_to_mod4	initial("010000101"b),	/* opnd(1) <- (opnd(2)+3)/4*4		*/
 10    78 	word_to_mod8	initial("010000110"b),	/* opnd(1) <- (opnd(2)+7)/8*8		*/
 10    79 	rel_fun		initial("010000111"b),	/* opnd(1) <- rel(opnd(2))		*/
 10    80 	baseno_fun	initial("010001000"b),	/* opnd(1) <- baseno(opnd(2))		*/
 10    81 	desc_size		initial("010001001"b),	/* opnd(1) <- substr(opnd(2),13,24)	*/
 10    82 	bit_pointer	initial("010001010"b),	/* opnd(1) <- bit offset of opnd(2)	*/
 10    83 	index_before_fun	initial("010001011"b),	/* opnd(1) <- length of before(opnd(2),opnd(3)) */
 10    84 	index_after_fun	initial("010001100"b),	/* opnd(1) <- offset of after(opnd(2),opnd(3)) in opnd(2) */
 10    85 	verify_ltrim_fun	initial("010001101"b),	/* opnd(1) <- offset of ltrim(opnd(2),opnd(3)) in opnd(2) */
 10    86 	verify_rtrim_fun	initial("010001110"b),	/* opnd(1) <- length(opnd(2))-length(rtrim(opnd(2),opnd(3))) */
 10    87 	digit_to_bit	initial("010001111"b),	/* opnd(1) <- 9*opnd(2)/2		*/
 10    88 
 10    89 	ceil_fun		initial("010010000"b),	/* opnd(1) <- ceil(opnd(2))		*/
 10    90 	floor_fun		initial("010010001"b),	/* opnd(1) <- floor(opnd(2))		*/
 10    91 	round_fun		initial("010010010"b),	/* opnd(1) <- round(opnd(2))		*/
 10    92 	sign_fun		initial("010010011"b),	/* opnd(1) <- sign(opnd(2))		*/
 10    93 	abs_fun		initial("010010100"b),	/* opnd(1) <- abs(opnd(2))		*/
 10    94 	trunc_fun		initial("010010101"b),	/* opnd(1) <- trunc(opnd(2))		*/
 10    95 	byte_fun		initial("010010110"b),	/* opnd(1) <- byte(opnd(2))		*/
 10    96 	rank_fun		initial("010010111"b),	/* opnd(1) <- rank(opnd(2))		*/
 10    97 	index_rev_fun	initial("010011000"b),	/* opnd(1) <- index(reverse(opnd(2)),reverse(opnd(3))) */
 10    98 	search_rev_fun	initial("010011001"b),	/* opnd(1) <- search(reverse(opnd(2)),opnd(3)) */
 10    99 	verify_rev_fun	initial("010011010"b),	/* opnd(1) <- verify(reverse(opnd(2)),opnd(3)) */
 10   100 	wordno_fun	initial("010011011"b),        /* opnd(1) <- wordno (opnd(2)) */
 10   101 	segno_fun		initial("010011100"b),        /* opnd(1) <- segno (opnd(2)) */
 10   102 	bitno_fun           initial("010011101"b),        /* opnd(1) <- bitno (opnd(2)) */
 10   103 	charno_fun	initial("010011110"b),        /* opnd(1) <- charno (opnd(2)) */
 10   104 
 10   105 	index_fun		initial("010100000"b),	/* opnd(1) <- index(opnd(2),opnd(3))	*/
 10   106 	off_fun		initial("010100001"b),	/* opnd(1) <- offset(opnd(2),opnd(3))	*/
 10   107 	complex_fun	initial("010100010"b),	/* opnd(1) <- complex(opnd(2),opnd(3))	*/
 10   108 	conjg_fun		initial("010100011"b),	/* opnd(1) <- conjg(opnd(2),opnd(3))	*/
 10   109 	mod_fun		initial("010100100"b),	/* opnd(1) <- mod(opnd(2),opnd(3))	*/
 10   110 	repeat_fun	initial("010100101"b),	/* opnd(1) <- repeat(opnd(2),opnd(3))	*/
 10   111 	verify_fun	initial("010100110"b),	/* opnd(1) <- verify(opnd(2),opnd(3))	*/
 10   112 	translate_fun	initial("010100111"b),	/* opnd(1) <- translate(opnd(2),opnd(3))*/
 10   113 	real_fun   	initial("010101001"b),	/* opnd(1) <- real(opnd(2))		*/
 10   114 	imag_fun   	initial("010101010"b),	/* opnd(1) <- imag(opnd(2))		*/
 10   115 	length_fun	initial("010101011"b),	/* opnd(1) <- length(opnd(2))	*/
 10   116 	pl1_mod_fun	initial("010101100"b),	/* opnd(1) <- mod(opnd(2)) */
 10   117 	search_fun	initial("010101101"b),	/* opnd(1) <- search(opnd(2),opnd(3)) */
 10   118 	allocation_fun	initial("010101110"b),	/* opnd(1) <- allocation(opnd(2)) */
 10   119 	reverse_fun	initial("010101111"b),	/* opnd(1) <- reverse(opnd(2)) */
 10   120 
 10   121 	addr_fun		initial("010110000"b),	/* opnd(1) <- addr(opnd(2))		*/
 10   122 	addr_fun_bits	initial("010110001"b),	/* opnd(1) <- addr(opnd(2))		*/
 10   123 	ptr_fun		initial("010110010"b),	/* opnd(1) <- ptr(opnd(2),opnd(3))	*/
 10   124 	baseptr_fun	initial("010110011"b),	/* opnd(1) <- baseptr(opnd(2))	*/
 10   125 	addrel_fun	initial("010110100"b),	/* opnd(1) <- addrel(opnd(2),opnd(3))	*/
 10   126 	codeptr_fun	initial("010110101"b),	/* opnd(1) <- codeptr(opnd(2))	*/
 10   127 	environmentptr_fun	initial("010110110"b),	/* opnd(1) <- environmentptr(opnd(2))	*/
 10   128 	stackbaseptr_fun	initial("010110111"b),	/* opnd(1) is ptr to base of current stack	*/
 10   129 	stackframeptr_fun	initial("010111000"b),	/* opnd(1) is ptr to current block's stack frame	*/
 10   130 	setcharno_fun	initial("010111001"b),	/* opnd(1) <- opnd(2) with charno opnd(3) */
 10   131 	addcharno_fun	initial("010111010"b),	/* opnd(1) <- opnd(2) with charno = charno + opnd(3) */
 10   132 	setbitno_fun	initial("010111011"b),	/* setcharno for bitsno */
 10   133 	addbitno_fun	initial("010111100"b),	/* addcharno for bitno */
 10   134 
 10   135 	min_fun		initial("011000000"b),	/* opnd(1) <- min(opnd(1),opnd(2),...)	*/
 10   136 	max_fun		initial("011000001"b),	/* opnd(1) <- max(opnd(1),opnd(2),...)	*/
 10   137 
 10   138 	stack_ptr		initial("011010001"b),	/* opnd(1) <- stack frame ptr		*/
 10   139 	empty_area	initial("011010010"b),	/* empty opnd(1), length in words is opnd(2) */
 10   140 	enable_on		initial("011010100"b),	/* opnd(1) is the cond name
 10   141*						   opnd(2) is the file name
 10   142*						   opnd(3) is the block	*/
 10   143 	revert_on		initial("011010101"b),	/* opnd(1) is the cond name,
 10   144*						   opnd(2) is the file name	*/
 10   145 	signal_on		initial("011010110"b),	/* opnd(1) is the cond name
 10   146*						   opnd(2) is the file name */
 10   147 
 10   148 	lock_fun		initial("011010111"b),	/* opnd(1) <- stac(opnd(2),opnd(3))	*/
 10   149 	stacq_fun		initial("011011000"b),	/* opnd(1) is result, opnd(2) is ptr to lock word,
 10   150*						   opnd(3) is old value, (4) is new value. */
 10   151 	clock_fun		initial("011011001"b),	/* opnd(1) is the clock time		*/
 10   152 	vclock_fun	initial("011011010"b),	/* opnd(1) is the virtual clock time	*/
 10   153 
 10   154 	bound_ck		initial("011100000"b),	/* opnd(1) <- opnd(2) if opnd(3) <= opnd(2) <= opnd(4) */
 10   155 	range_ck		initial("011100001"b),	/* opnd(1) <- opnd(2) if opnd(3) <= opnd(2) <= opnd(4) */
 10   156 	loop		initial("011100010"b),	/* do opnd(1) for opnd(2) from opnd(3) to opnd(4) by 1,
 10   157*						   opnd(5) is the list */
 10   158 	join		initial("011100011"b),	/* do opnd(1), opnd(2) ... opnd(n)	*/
 10   159 	allot_based	initial("011100100"b),	/* allocate opnd(2) words in opnd(3), set opnd(1) */
 10   160 	free_based	initial("011100101"b),	/* free opnd(1) in opnd(3), length is opnd(2) words */
 10   161 
 10   162 	r_parn		initial("011110001"b),	/* format op code			*/
 10   163 	l_parn		initial("011110010"b),
 10   164 	r_format		initial("011110011"b),
 10   165 	c_format		initial("011110100"b),
 10   166 	f_format		initial("011110101"b),
 10   167 	e_format		initial("011110110"b),
 10   168 	b_format		initial("011110111"b),
 10   169 	a_format		initial("011111000"b),
 10   170 	x_format		initial("011111001"b),
 10   171 	skip_format	initial("011111010"b),
 10   172 	column_format	initial("011111011"b),
 10   173 	page_format	initial("011111100"b),
 10   174 	line_format	initial("011111101"b),
 10   175 	picture_format	initial("011111110"b),
 10   176 	bn_format		initial("011111111"b),	/* bit format, length(opnd(2)), radix factor(opnd(3)) */
 10   177 
 10   178 	get_list_trans	initial("100000000"b),	/* getlist(opnd(2) with desc(opnd(1)))	*/
 10   179 	get_edit_trans	initial("100000001"b),	/* getedit(opnd(2) with desc(opnd(1)))	*/
 10   180 	get_data_trans	initial("100000010"b),	/* getdata(opnd(1) to opnd(n))	*/
 10   181 	put_list_trans	initial("100000011"b),	/* putlist(opnd(2) with desc(opnd(1)))	*/
 10   182 	put_edit_trans	initial("100000100"b),	/* putedit(opnd(2) with desc(opnd(1)))	*/
 10   183 	put_data_trans	initial("100000101"b),	/* putdata(opnd(2)) with subscript-list opnd(1) */
 10   184 	terminate_trans	initial("100000110"b),	/* terminate stream transmission	*/
 10   185 	stream_prep	initial("100000111"b),	/* initiate stream transmission	*/
 10   186 	record_io		initial("100001000"b),	/* perform record io operation	*/
 10   187 	fortran_read	initial("100001001"b),	/* A complete read statement		*/
 10   188 	fortran_write	initial("100001010"b),	/* A complete write statement		*/
 10   189 	ftn_file_manip	initial("100001011"b),	/* endfile,backspace,rewind,etc.	*/
 10   190 	ftn_trans_loop	initial("100001100"b),	/* An implied do in i/o list		*/
 10   191 	put_control	initial("100001101"b),	/* put control opnd(1) opnd(2) times	*/
 10   192 	put_field		initial("100001110"b),	/* putlist(opnd(2)) of length(opnd(1))	*/
 10   193 	put_field_chk	initial("100001111"b),	/* putlist(op(2)) of len(op(1)) check char index(op(3)) */
 10   194 
 10   195 /* These operators are produced by the parse but are not used as input to the code generator.	*/
 10   196 /* They are processed by the semantic translator.						*/
 10   197 
 10   198 	return_value	initial("100010010"b),	/* return(opnd(1))			*/
 10   199 	allot_var		initial("100010011"b),	/* allot opnd(1) in opnd(2)		*/
 10   200 	free_var		initial("100010100"b),	/* free opnd(1) out of opnd(2)	*/
 10   201 	get_file		initial("100010101"b),	/* opnd(1) is filename,opnd(2) is copy	*/
 10   202 						/* opnd(3) is skip, opnd(4) is list	*/
 10   203 	get_string	initial("100010110"b),	/* opnd(1) is string,opnd(2) is list	*/
 10   204 	put_file		initial("100010111"b),	/* opnd(1) is filename,opnd(2) is page	*/
 10   205 						/* opnd(3) is skip,opnd(4) is line	*/
 10   206 	put_string	initial("100011000"b),	/* opnd(1) is string,opnd(2) is list	*/
 10   207 	open_file		initial("100011001"b),
 10   208 	close_file	initial("100011010"b),
 10   209 	read_file		initial("100011011"b),
 10   210 	write_file	initial("100011100"b),
 10   211 	locate_file	initial("100011101"b),
 10   212 	do_fun		initial("100011110"b),	/* opnd(1) is join of a list		*/
 10   213 						/* opnd(2) is control variable ref	*/
 10   214 						/* opnd(3) is specification operator	*/
 10   215 	do_spec		initial("100011111"b),	/* opnd(1) to opnd(2) by opnd(3) 	*/
 10   216 						/* repeat opnd(4) while opnd(5)	*/
 10   217 						/* opnd(6) is next specification	*/
 10   218 
 10   219 	rewrite_file	initial("100100000"b),
 10   220 	delete_file	initial("100100001"b),
 10   221 	unlock_file	initial("100100010"b),
 10   222 	lock_file		initial("100100011"b),
 10   223 	refer		initial("100100101"b),	/* opnd(1) refer(opnd(2))		*/
 10   224 	prefix_plus	initial("100100110"b),	/* opnd(1) <- +opnd(2)		*/
 10   225 	nop		initial("100100111"b),	/* no-op */
 10   226 	assign_by_name	initial("100101000"b),	/* opnd(1) <- opnd(2),by name		*/
 10   227 
 10   228 /* These operators are produced by the semantic translator in processing the math
 10   229*   builtin functions and are used as input to the code generator			*/
 10   230 
 10   231 	sqrt_fun		initial("100110000"b),	/* opnd(1) <- sqrt(opnd(2))	*/
 10   232 	sin_fun		initial("100110001"b),	/* opnd(1) <- sin(opnd(2))	*/
 10   233 	sind_fun		initial("100110010"b),	/* opnd(1) <- sind(opnd(2))	*/
 10   234 	cos_fun		initial("100110011"b),	/* opnd(1) <- cos(opnd(2))	*/
 10   235 	cosd_fun		initial("100110100"b),	/* opnd(1) <- cosd(opnd(2))	*/
 10   236 	tan_fun		initial("100110101"b),	/* opnd(1) <- tan(opnd(2))	*/
 10   237 	tand_fun		initial("100110110"b),	/* opnd(1) <- tand(opnd(2))	*/
 10   238 	asin_fun		initial("100110111"b),	/* opnd(1) <- asin(opnd(2))	*/
 10   239 	asind_fun		initial("100111000"b),	/* opnd(1) <- asind(opnd(2))	*/
 10   240 	acos_fun		initial("100111001"b),	/* opnd(1) <- acos(opnd(2))	*/
 10   241 	acosd_fun		initial("100111010"b),	/* opnd(1) <- acosd(opnd(2))	*/
 10   242 	atan_fun		initial("100111011"b),	/* opnd(1) <- atan(opnd(2)[,opnd(3)])	*/
 10   243 	atand_fun		initial("100111100"b),	/* opnd(1) <- atand(opnd(2)[,opnd(3)])	*/
 10   244 	log2_fun		initial("100111101"b),	/* opnd(1) <- log2(opnd(2))	*/
 10   245 	log_fun		initial("100111110"b),	/* opnd(1) <- log(opnd(2))	*/
 10   246 	log10_fun		initial("100111111"b),	/* opnd(1) <- log10(opnd(2))	*/
 10   247 
 10   248 	exp_fun		initial("101000000"b))	/* opnd(1) <- exp(opnd(2))	*/
 10   249 
 10   250 			bit(9) aligned internal static options(constant);
 10   251 
 10   252 /* END INCLUDE FILE ... op_codes.incl.pl1 */
       72 
 11     1 dcl	jump_complement(2:9) bit(9) aligned static options(constant)
 11     2 	init("001010011"b,	/* jump_true  -> jump_false	*/
 11     3 	     "001010010"b,	/* jump_false -> jump_true	*/
 11     4 	     "001011001"b,	/* jump_if_lt -> jump_if_ge	*/
 11     5 	     "001011000"b,	/* jump_if_gt -> jump_if_le	*/
 11     6 	     "001010111"b,	/* jump_if_eq -> jump_if_ne	*/
 11     7 	     "001010110"b,	/* jump_if_ne -> jump_if_eq	*/
 11     8 	     "001010101"b,	/* jump_if_le -> jump_if_gt	*/
 11     9 	     "001010100"b);	/* jump_if_ge -> jump_if_lt	*/
       73 
 12     1 /* BEGIN INCLUDE FILE ... machine_state.incl.pl1 */
 12     2 
 12     3 dcl	cg_static_$m_s_p ptr ext static,
 12     4 	m_s_p ptr init(cg_static_$m_s_p);
 12     5 
 12     6 dcl	1 machine_state	aligned based(m_s_p),
 12     7 	2 node_type	bit(9),
 12     8 	2 indicators	fixed bin,
 12     9 	2 next		ptr unal,
 12    10 	2 a_reg,
 12    11 	  3 variable(10)	ptr unal,
 12    12 	  3 number	fixed bin(17),
 12    13 	  3 size		fixed bin(8),
 12    14 	  3 length	fixed bin(8),
 12    15 	  3 offset	fixed bin(8),
 12    16 	  3 constant	fixed bin(24),
 12    17 	  3 changed	fixed bin(18),
 12    18 	  3 instruction	bit(36),
 12    19 	  3 locked	bit(1) aligned,
 12    20 	  3 number_h_o	fixed bin,
 12    21 	  3 has_offset(3)	ptr unal,
 12    22 	2 q_reg,
 12    23 	  3 variable(10)	ptr unal,
 12    24 	  3 number	fixed bin(17),
 12    25 	  3 size		fixed bin(8),
 12    26 	  3 length	fixed bin(8),
 12    27 	  3 offset	fixed bin(8),
 12    28 	  3 constant	fixed bin(24),
 12    29 	  3 changed	fixed bin(18),
 12    30 	  3 instruction	bit(36),
 12    31 	  3 locked	bit(1) aligned,
 12    32 	  3 number_h_o	fixed bin,
 12    33 	  3 has_offset(3)	ptr unal,
 12    34 	2 string_reg,
 12    35 	  3 variable	ptr unal,
 12    36 	  3 size		fixed bin(8),
 12    37 	  3 offset	fixed bin(8),
 12    38 	2 complex_reg,
 12    39 	  3 variable	ptr unal,
 12    40 	  3 size		fixed bin(8),
 12    41 	  3 scale		fixed bin(8),
 12    42 	2 decimal_reg,
 12    43 	  3 variable	ptr unal,
 12    44 	  3 size		fixed bin(8),
 12    45 	  3 scale		fixed bin(8),
 12    46 	2 index_regs(0:7),
 12    47 	  3 variable	ptr unal,
 12    48 	  3 constant	fixed bin,
 12    49 	  3 type		fixed bin(8),
 12    50 	  3 used		fixed bin(18),
 12    51 	  3 changed	fixed bin(18),
 12    52 	  3 instruction	bit(36),
 12    53 	  3 filler	fixed bin,
 12    54 	2 base_regs(0:7),
 12    55 	  3 variable	ptr unal,
 12    56 	  3 constant	fixed bin,
 12    57 	  3 type		fixed bin(8),
 12    58 	  3 pad (12)	fixed bin,	/* future...room to make 5 element array for variable, constant, type */
 12    59 	  3 number	fixed bin (17),	/* future...number of valid elements in array */
 12    60 	  3 used		fixed bin(18),
 12    61 	  3 changed	fixed bin(18),
 12    62 	  3 instruction	bit(36),
 12    63 	  3 locked	fixed bin(2),
 12    64 	2 indicators_ref(2:3) ptr unal;
 12    65 
 12    66 /* Permissible values for machine_state.indicators. */
 12    67 
 12    68 dcl (	ind_known_refs	init (-2),		/* set by comparison of known, nonzero, references */
 12    69 	ind_invalid	init (-1),
 12    70 	ind_string_aq	init (0),			/* logical value in storage */
 12    71 	ind_logical	init (1),			/* logical value in A or AQ */
 12    72 	ind_arithmetic	init (2),			/* arith value in Q, AQ, or EAQ */
 12    73 	ind_x (0:7)	init (6, 7, 8, 9, 10, 11, 12, 13),
 12    74 	ind_decimal_reg	init (14)
 12    75 	) fixed bin internal static options (constant);
 12    76 
 12    77 /* END INCLUDE FILE ... machine_state.incl.pl1 */
       74 
       75 
       76 	st = pt;
       77 	jop = st -> statement.root;
       78 
       79 	if ^ st -> statement.checked
       80 	then do;
       81 	     target = jop -> operand(1);
       82 
       83 	     if target -> node.type = label_node
       84 	     then if ^ target -> label.allocated
       85 		then if cg_stat$cur_level = target -> label.block_node -> block.level
       86 		     then call jump_op$eval_primaries(target);
       87 		     else;
       88 		else;
       89 	     else do;
       90 
       91 		/* operator_semantics has ensured that the target of a
       92*		   conditional jump will not be an operator nor a reference
       93*	  	   with expressions hanging off it, so that calling
       94*		   check_expr for the target is unnecessary */
       95 
       96 		if target -> node.type = reference_node
       97 		then if target -> reference.symbol ^= null
       98 		     then if target -> reference.symbol -> node.type = label_node
       99 			then if target -> reference.symbol -> label.block_node = cg_stat$cur_block
      100 			     then call jump_op$eval_primaries(target);
      101 		end;
      102 
      103 	     call check_expr((jop -> operand(2)));
      104 	     st -> statement.checked = "1"b;
      105 	     end;
      106 
      107 
      108 	do while("1"b);
      109 	     tree = jop -> operand(2);
      110 
      111 	     if tree -> node.type ^= operator_node then return;
      112 	     if tree -> operand(1) -> reference.evaluated then return;
      113 	     if tree -> operand(1) -> reference.c_length ^= 1 then return;
      114 
      115 	     jump_code = jop -> operator.op_code;
      116 	     op_code = tree -> operator.op_code;
      117 
      118 	     if op_code = not_bits
      119 	     then do;
      120 
      121 		/* not - complement the type of jump */
      122 
      123 		jop -> operator.op_code = jump_complement(fixed(substr(jump_code,6,4),4));
      124 		jop -> operand(2) = tree -> operand(2);
      125 		end;
      126 
      127 	     else if substr(op_code,1,5) = rel_op
      128 	     then do;
      129 
      130 		/* rel_op - change into a jump_rel and return */
      131 
      132 		if jump_code = jump_true
      133 		     then substr(tree -> operator.op_code,1,5) = jump_op;
      134 		     else tree -> operator.op_code = jump_complement(fixed(substr(op_code,6,4),4));
      135 
      136 		tree -> operand(1) = jop -> operand(1);
      137 		st -> statement.root = tree;
      138 		return;
      139 		end;
      140 
      141 	     else if op_code = and_bits | op_code = or_bits
      142 	     then do;
      143 
      144 		/* or_bits | and_bits - split into 2 statements */
      145 
      146 		if machine_state.indicators = 1
      147 		then do;
      148 
      149 		     /* if result of second computation is in a with
      150*		        indicators set, do that one first */
      151 
      152 		     p3 = tree -> operand(3);
      153 		     if p3 -> node.type = operator_node
      154 			then p3 = p3 -> operand(1);
      155 
      156 		     if p3 -> reference.value_in.a & p3 -> reference.allocate
      157 		     then do;
      158 			p3 = tree -> operand(3);
      159 			tree -> operand(3) = tree -> operand(2);
      160 			tree -> operand(2) = p3;
      161 			end;
      162 		     end;
      163 
      164 		if op_code = and_bits & jump_code = jump_false
      165 		 | op_code = or_bits & jump_code = jump_true
      166 		then do;
      167 
      168 		     /* simply duplicate the statement */
      169 
      170 		     call make(/* jump_code,target,tree -> operand(3) */);
      171 
      172 		     jop -> operand(2) = tree -> operand(2);
      173 
      174 		     target = jop -> operand(1);
      175 		     if target -> node.type = label_node
      176 			then target -> label.statement -> statement.reference_count =
      177 			     target -> label.statement -> statement.reference_count + 1;
      178 			else target = share_target_expression(target);
      179 		     end;
      180 
      181 	          else do;
      182 
      183 		     /* make a second statement; reverse the form of
      184*		        the first statement and redirect to the next
      185*		        statement */
      186 
      187 		     next = st -> statement.next;
      188 
      189 		     call make(/* jump_code,target,tree -> operand(3) */);
      190 
      191 		     jop -> operand(2) = tree -> operand(2);
      192 
      193 		     if jump_code = jump_true
      194 			then jop -> operator.op_code = jump_false;
      195 			else jop -> operator.op_code = jump_true;
      196 
      197 		     nextlab = create_label(cg_stat$cur_block,null,(by_compiler));
      198 		     lp = create_list(2);
      199 
      200 		     /* connect nextlab to next stmt */
      201 
      202 		     jop -> operand(1) = nextlab;
      203 		     nextlab -> label.statement = next;
      204 
      205 		     lp -> element(2) = nextlab;
      206 		     lp -> element(1) = next -> statement.labels;
      207 		     next -> statement.labels = lp;
      208 
      209 		     string(nextlab -> label.source_id) = string(next -> statement.source_id);
      210 
      211 		     /* reference_count updated once for new reference and once for new label */
      212 
      213 		     next -> statement.reference_count = next -> statement.reference_count + 2;
      214 
      215 		     /* optimizer didn't know about this label, so make sure all temps
      216*		        are saved before anyone jumps here */
      217 
      218 		     next -> statement.save_temps = "1"b;
      219 		     end;
      220 
      221 		next_tree = st -> statement.next -> statement.root;
      222 
      223 		if next_tree -> operand(2) -> node.type = operator_node
      224 		then if ^ next_tree -> operand(2) -> operand(1) -> reference.evaluated
      225 		then if next_tree -> operand(2) -> operand(1) -> reference.c_length = 1
      226 		then call optimize_if((st -> statement.next));
      227 
      228 		end;
      229 
      230 	     else return;
      231 
      232 	     end;
      233 
      234 /*  */
      235 make:	     proc(/* op_code,target,expr */);
      236 
      237 	     /* make a new if statement */
      238 
      239 dcl	     (new,op) ptr;
      240 
      241 	     pl1_stat_$cur_statement = st;	/* otherwise create_statement fails */
      242 
      243 	     new = create_statement((if_statement),st,null,(st -> statement.prefix));
      244 	     op = create_operator((jump_code),2);
      245 
      246 	     new -> statement.generated,
      247 	     new -> statement.checked = "1"b;
      248 	     new -> statement.root = op;
      249 
      250 	     op -> operand(1) = jop -> operand(1);
      251 	     op -> operand(2) = tree -> operand(3);
      252 
      253 	     end;
      254 /**/
      255 share_target_expression: proc(p) returns(ptr);
      256 
      257 	     /* updates all relevant reference counts when a jump target is
      258*	        NOT a label (it might be a subscripted label reference)
      259*	        Note, however, that operator_semantics has ensured that the
      260*	        target of a conditional jump will not be an operator nor a
      261*	        reference with expressions hanging off it. */
      262 
      263 dcl	     (p,q,vector) ptr;
      264 dcl	     i fixed bin;
      265 
      266 	     if p -> reference.symbol ^= null
      267 	     then if p -> reference.symbol -> node.type = label_node
      268 	     then do;
      269 		vector = p -> reference.symbol -> label.statement;
      270 
      271 		q = vector -> element(p -> reference.c_offset + 1);
      272 		q -> statement.reference_count = q -> statement.reference_count + 1;
      273 		end;
      274 
      275 	     if ^ p -> reference.shared
      276 		then p -> reference.ref_count = p -> reference.ref_count + 1;
      277 
      278 	     return(p);
      279 
      280 	     end;
      281 /*  */
      282 check_expr:	proc(pt);
      283 
      284 	     /* forces evaluation of any expression that could be used in
      285*	        more than one place */
      286 
      287 dcl	     (pt,p,q) ptr;
      288 dcl	     (i,n) fixed bin;
      289 dcl	     atomic bit(1) aligned;
      290 
      291 	     p = pt;
      292 	     if p = null then return;
      293 	     if p -> node.type = temporary_node then return;
      294 
      295 	     if p -> node.type = list_node
      296 	     then do;
      297 
      298 		/* should appear only in arg lists */
      299 
      300 		do i = 1 to p -> list.number - 1;
      301 		     call check_expr((p -> list.element(i)));
      302 		     end;
      303 		return;
      304 		end;
      305 
      306 	     q = p;
      307 
      308 	     if p -> node.type = operator_node
      309 	     then do;
      310 		if p -> operator.op_code = param_ptr | p -> operator.op_code = param_desc_ptr
      311 		     then return;
      312 
      313 		if p -> operator.op_code = std_call
      314 		     then n = 2;
      315 		     else n = 1;
      316 
      317 		p = p -> operand(1);
      318 
      319 		if p -> reference.ref_count <= n
      320 		then do;
      321 		     do i = q -> operator.number to 2 by -1;
      322 			call check_expr((q -> operand(i)));
      323 			end;
      324 		     return;
      325 		     end;
      326 		end;
      327 
      328 	     else do;
      329 		if p -> reference.ref_count <= 1
      330 		then do;
      331 		     if p -> reference.length ^= null
      332 			then call check_expr((p -> reference.length));
      333 		     if p -> reference.qualifier ^= null
      334 			then call check_expr((p -> reference.qualifier));
      335 		     if p -> reference.offset ^= null
      336 			then call check_expr((p -> reference.offset));
      337 		     return;
      338 		     end;
      339 		end;
      340 
      341 	     p = prepare_operand(q,1,atomic);
      342 
      343 	     if ^ atomic
      344 	     then do;
      345 		p -> reference.ref_count = p -> reference.ref_count + 1;
      346 		call compile_exp(q);
      347 		end;
      348 
      349 	     return;
      350 	     end;
      351 
      352 	end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/03/83  1009.1  optimize_if.pl1                   >spec>on>pl128d>optimize_if.pl1
63           1    07/21/80  1546.3  nodes.incl.pl1                    >ldd>include>nodes.incl.pl1
64           2    08/13/81  2043.5  block.incl.pl1                    >ldd>include>block.incl.pl1
65           3    04/07/83  1635.0  statement.incl.pl1                >ldd>include>statement.incl.pl1
66           4    05/03/76  1320.4  statement_types.incl.pl1          >ldd>include>statement_types.incl.pl1
67           5    05/06/74  1742.1  label.incl.pl1                    >ldd>include>label.incl.pl1
68           6    10/25/79  1645.8  declare_type.incl.pl1             >ldd>include>declare_type.incl.pl1
69           7    08/13/81  2211.5  list.incl.pl1                     >ldd>include>list.incl.pl1
70           8    07/21/80  1546.3  reference.incl.pl1                >ldd>include>reference.incl.pl1
71           9    07/21/80  1546.3  operator.incl.pl1                 >ldd>include>operator.incl.pl1
72          10    04/07/83  1635.0  op_codes.incl.pl1                 >ldd>include>op_codes.incl.pl1
73          11    05/03/76  1320.4  jump_complement.incl.pl1          >ldd>include>jump_complement.incl.pl1
74          12    11/13/79  1015.8  machine_state.incl.pl1            >ldd>include>machine_state.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a                        11(09)        based           bit(1)                   level 4 packed unaligned dcl 8-3 ref 156
allocate                 12(14)        based           bit(1)                   level 3 packed unaligned dcl 8-3 ref 156
allocated                 1(18)        based           bit(1)                   level 2 packed unaligned dcl 5-1 ref 83
and_bits                               constant        bit(9)                   initial dcl 10-8 ref 141 164
atomic                          000106 automatic       bit(1)                   dcl 289 set ref 341* 343
bits                     13            based           structure                level 2 in structure "statement" packed unaligned
                                                                                  dcl 3-9 in procedure "optimize_if"
bits                     12(06)        based           structure                level 2 in structure "reference" packed unaligned
                                                                                  dcl 8-3 in procedure "optimize_if"
block                                  based           structure                level 1 dcl 2-5
block_node                4            based           pointer                  level 2 packed unaligned dcl 5-1 ref 83 96
by_compiler                            constant        bit(3)                   initial dcl 6-5 ref 197
c_length                  2            based           fixed bin(24,0)          level 2 dcl 8-3 ref 113 223
c_offset                  1            based           fixed bin(24,0)          level 2 dcl 8-3 ref 271
cg_stat$cur_block               000010 external static pointer                  dcl 45 set ref 96 197*
cg_stat$cur_level               000014 external static fixed bin(17,0)          dcl 46 ref 83
cg_static_$m_s_p                000034 external static pointer                  dcl 12-3 ref 12-3
checked                  13(06)        based           bit(1)                   level 3 packed unaligned dcl 3-9 set ref 79 104*
                                                                                  246*
compile_exp                     000032 constant        entry                    external dcl 61 ref 346
create_label                    000020 constant        entry                    external dcl 55 ref 197
create_list                     000016 constant        entry                    external dcl 54 ref 198
create_operator                 000022 constant        entry                    external dcl 56 ref 244
create_statement                000024 constant        entry                    external dcl 57 ref 243
element                   1            based           pointer                  array level 2 packed unaligned dcl 7-6 set ref 205*
                                                                                  206* 271 301
evaluated                12(13)        based           bit(1)                   level 3 packed unaligned dcl 8-3 ref 112 223
fixed                                                  builtin function         dcl 52 ref 123 134
generated                13(02)        based           bit(1)                   level 3 packed unaligned dcl 3-9 set ref 246*
i                               000104 automatic       fixed bin(17,0)          dcl 288 set ref 300* 301* 321* 322*
if_statement                           constant        bit(9)                   initial dcl 4-3 ref 243
indicators                1            based           fixed bin(17,0)          level 2 dcl 12-6 ref 146
info                     11            based           structure                level 2 packed unaligned dcl 8-3
jop                             000100 automatic       pointer                  dcl 42 set ref 77* 81 103 109 115 123 124 136 172
                                                                                  174 191 193 195 202 250
jump_code                       000122 automatic       bit(9)                   dcl 43 set ref 115* 123 132 164 164 193 244
jump_complement                 000000 constant        bit(9)                   initial array dcl 11-1 ref 123 134
jump_false                             constant        bit(9)                   initial dcl 10-8 ref 164 193
jump_op                                constant        bit(5)                   initial dcl 48 ref 132
jump_op$eval_primaries          000026 constant        entry                    external dcl 59 ref 83 96
jump_true                              constant        bit(9)                   initial dcl 10-8 ref 132 164 193 195
label                                  based           structure                level 1 dcl 5-1
label_node                             constant        bit(9)                   initial dcl 1-5 ref 83 96 175 266
labels                    4            based           pointer                  level 2 packed unaligned dcl 3-9 set ref 206 207*
length                    6            based           pointer                  level 2 packed unaligned dcl 8-3 ref 331 331
level                    45            based           fixed bin(17,0)          level 2 dcl 2-5 ref 83
list                                   based           structure                level 1 dcl 7-6
list_node                              constant        bit(9)                   initial dcl 1-5 ref 295
lp                              000102 automatic       pointer                  dcl 42 set ref 198* 205 206 207
m_s_p                           000124 automatic       pointer                  initial dcl 12-3 set ref 146 12-3*
machine_state                          based           structure                level 1 dcl 12-6
n                               000105 automatic       fixed bin(17,0)          dcl 288 set ref 313* 315* 319
new                             000134 automatic       pointer                  dcl 239 set ref 243* 246 246 248
next                      1            based           pointer                  level 2 in structure "statement" packed unaligned
                                                                                  dcl 3-9 in procedure "optimize_if" ref 187 221 223
next                            000104 automatic       pointer                  dcl 42 in procedure "optimize_if" set ref 187* 203
                                                                                  206 207 209 213 213 218
next_tree                       000120 automatic       pointer                  dcl 42 set ref 221* 223 223 223
nextlab                         000106 automatic       pointer                  dcl 42 set ref 197* 202 203 205 209
node                                   based           structure                level 1 dcl 1-27
not_bits                               constant        bit(9)                   initial dcl 10-8 ref 118
null                                                   builtin function         dcl 52 ref 96 197 197 243 243 266 292 331 333 335
number                    0(21)        based           fixed bin(14,0)          level 2 in structure "operator" packed unaligned
                                                                                  dcl 9-6 in procedure "optimize_if" ref 321
number                    0(21)        based           fixed bin(14,0)          level 2 in structure "list" packed unaligned dcl 7-6
                                                                                  in procedure "optimize_if" ref 300
offset                    5            based           pointer                  level 2 packed unaligned dcl 8-3 ref 335 335
op                              000136 automatic       pointer                  dcl 239 set ref 244* 248 250 251
op_code                         000123 automatic       bit(9)                   dcl 43 in procedure "optimize_if" set ref 116* 118
                                                                                  127 134 141 141 164 164
op_code                   0(09)        based           bit(9)                   level 2 in structure "operator" packed unaligned
                                                                                  dcl 9-6 in procedure "optimize_if" set ref 115 116
                                                                                  123* 132* 134* 193* 195* 310 310 313
operand                   1            based           pointer                  array level 2 packed unaligned dcl 9-6 set ref 81
                                                                                  103 109 112 113 124* 124 136* 136 152 153 158 159*
                                                                                  159 160* 172* 172 174 191* 191 202* 223 223 223
                                                                                  223 223 250* 250 251* 251 317 322
operator                               based           structure                level 1 dcl 9-6
operator_node                          constant        bit(9)                   initial dcl 1-5 ref 111 153 223 308
or_bits                                constant        bit(9)                   initial dcl 10-8 ref 141 164
p                               000100 automatic       pointer                  dcl 287 in procedure "check_expr" set ref 291* 292
                                                                                  293 295 300 301 306 308 310 310 313 317* 317 319
                                                                                  329 331 331 333 333 335 335 341* 345 345
p                                      parameter       pointer                  dcl 263 in procedure "share_target_expression" ref
                                                                                  255 266 266 269 271 275 275 275 278
p3                              000110 automatic       pointer                  dcl 42 set ref 152* 153 153* 153 156 156 158* 160
param_desc_ptr                         constant        bit(9)                   initial dcl 10-8 ref 310
param_ptr                              constant        bit(9)                   initial dcl 10-8 ref 310
pl1_stat_$cur_statement         000012 external static pointer                  dcl 45 set ref 241*
prefix                   12(12)        based           bit(12)                  level 2 packed unaligned dcl 3-9 ref 243
prepare_operand                 000030 constant        entry                    external dcl 60 ref 341
pt                                     parameter       pointer                  dcl 40 in procedure "optimize_if" ref 38 76
pt                                     parameter       pointer                  dcl 287 in procedure "check_expr" ref 282 291
q                               000146 automatic       pointer                  dcl 263 in procedure "share_target_expression" set
                                                                                  ref 271* 272 272
q                               000102 automatic       pointer                  dcl 287 in procedure "check_expr" set ref 306* 321
                                                                                  322 341* 346*
qualifier                 4            based           pointer                  level 2 packed unaligned dcl 8-3 ref 333 333
ref_count                 0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 8-3 set ref 275* 275
                                                                                  319 329 345* 345
reference                              based           structure                level 1 dcl 8-3
reference_count           7            based           fixed bin(17,0)          level 2 packed unaligned dcl 3-9 set ref 175* 175
                                                                                  213* 213 272* 272
reference_node                         constant        bit(9)                   initial dcl 1-5 ref 96
rel_op                                 constant        bit(5)                   initial dcl 48 ref 127
root                      3            based           pointer                  level 2 packed unaligned dcl 3-9 set ref 77 137* 221
                                                                                  248*
save_temps               13(07)        based           bit(1)                   level 3 packed unaligned dcl 3-9 set ref 218*
shared                    0(11)        based           bit(1)                   level 2 packed unaligned dcl 8-3 ref 275
source_id                 0(09)        based           structure                level 2 in structure "statement" packed unaligned
                                                                                  dcl 3-9 in procedure "optimize_if" ref 209
source_id                 0(09)        based           structure                level 2 in structure "label" packed unaligned
                                                                                  dcl 5-1 in procedure "optimize_if" set ref 209*
st                              000112 automatic       pointer                  dcl 42 set ref 76* 77 79 104 137 187 221 223 241
                                                                                  243* 243
statement                              based           structure                level 1 dcl 3-9 in procedure "optimize_if"
statement                11            based           pointer                  level 2 in structure "label" packed unaligned
                                                                                  dcl 5-1 in procedure "optimize_if" set ref 175 175
                                                                                  203* 269
std_call                               constant        bit(9)                   initial dcl 10-8 ref 313
string                                                 builtin function         dcl 52 set ref 209* 209
substr                                                 builtin function         dcl 52 set ref 123 127 132* 134
symbol                    3            based           pointer                  level 2 packed unaligned dcl 8-3 ref 96 96 96 266
                                                                                  266 269
target                          000114 automatic       pointer                  dcl 42 set ref 81* 83 83 83 83* 96 96 96 96 96* 174*
                                                                                  175 175 175 178* 178*
temporary_node                         constant        bit(9)                   initial dcl 1-5 ref 293
tree                            000116 automatic       pointer                  dcl 42 set ref 109* 111 112 113 116 124 132 134 136
                                                                                  137 152 158 159 159 160 172 191 251
type                                   based           bit(9)                   level 2 packed unaligned dcl 1-27 ref 83 96 96 111
                                                                                  153 175 223 266 293 295 308
value_in                 11(09)        based           structure                level 3 packed unaligned dcl 8-3
vector                          000150 automatic       pointer                  dcl 263 set ref 269* 271

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
a_format                               internal static bit(9)                   initial dcl 10-8
abs_fun                                internal static bit(9)                   initial dcl 10-8
acos_fun                               internal static bit(9)                   initial dcl 10-8
acosd_fun                              internal static bit(9)                   initial dcl 10-8
add                                    internal static bit(9)                   initial dcl 10-8
addbitno_fun                           internal static bit(9)                   initial dcl 10-8
addcharno_fun                          internal static bit(9)                   initial dcl 10-8
addr_fun                               internal static bit(9)                   initial dcl 10-8
addr_fun_bits                          internal static bit(9)                   initial dcl 10-8
addrel_fun                             internal static bit(9)                   initial dcl 10-8
allocate_statement                     internal static bit(9)                   initial dcl 4-3
allocation_fun                         internal static bit(9)                   initial dcl 10-8
allot_auto                             internal static bit(9)                   initial dcl 10-8
allot_based                            internal static bit(9)                   initial dcl 10-8
allot_ctl                              internal static bit(9)                   initial dcl 10-8
allot_var                              internal static bit(9)                   initial dcl 10-8
array_node                             internal static bit(9)                   initial dcl 1-5
asin_fun                               internal static bit(9)                   initial dcl 10-8
asind_fun                              internal static bit(9)                   initial dcl 10-8
assign                                 internal static bit(9)                   initial dcl 10-8
assign_by_name                         internal static bit(9)                   initial dcl 10-8
assign_round                           internal static bit(9)                   initial dcl 10-8
assign_size_ck                         internal static bit(9)                   initial dcl 10-8
assign_zero                            internal static bit(9)                   initial dcl 10-8
assignment_statement                   internal static bit(9)                   initial dcl 4-3
atan_fun                               internal static bit(9)                   initial dcl 10-8
atand_fun                              internal static bit(9)                   initial dcl 10-8
b_format                               internal static bit(9)                   initial dcl 10-8
baseno_fun                             internal static bit(9)                   initial dcl 10-8
baseptr_fun                            internal static bit(9)                   initial dcl 10-8
begin_statement                        internal static bit(9)                   initial dcl 4-3
bit_pointer                            internal static bit(9)                   initial dcl 10-8
bit_to_char                            internal static bit(9)                   initial dcl 10-8
bit_to_word                            internal static bit(9)                   initial dcl 10-8
bitno_fun                              internal static bit(9)                   initial dcl 10-8
block_node                             internal static bit(9)                   initial dcl 1-5
bn_format                              internal static bit(9)                   initial dcl 10-8
bool_fun                               internal static bit(9)                   initial dcl 10-8
bound_ck                               internal static bit(9)                   initial dcl 10-8
bound_node                             internal static bit(9)                   initial dcl 1-5
by_context                             internal static bit(3)                   initial dcl 6-5
by_declare                             internal static bit(3)                   initial dcl 6-5
by_explicit_context                    internal static bit(3)                   initial dcl 6-5
by_implication                         internal static bit(3)                   initial dcl 6-5
by_name_agg_node                       internal static bit(9)                   initial dcl 1-5
byte_fun                               internal static bit(9)                   initial dcl 10-8
c_format                               internal static bit(9)                   initial dcl 10-8
call_statement                         internal static bit(9)                   initial dcl 4-3
cat_string                             internal static bit(9)                   initial dcl 10-8
ceil_fun                               internal static bit(9)                   initial dcl 10-8
char_to_word                           internal static bit(9)                   initial dcl 10-8
charno_fun                             internal static bit(9)                   initial dcl 10-8
clock_fun                              internal static bit(9)                   initial dcl 10-8
close_file                             internal static bit(9)                   initial dcl 10-8
close_statement                        internal static bit(9)                   initial dcl 4-3
codeptr_fun                            internal static bit(9)                   initial dcl 10-8
column_format                          internal static bit(9)                   initial dcl 10-8
complex_fun                            internal static bit(9)                   initial dcl 10-8
conjg_fun                              internal static bit(9)                   initial dcl 10-8
context_node                           internal static bit(9)                   initial dcl 1-5
continue_statement                     internal static bit(9)                   initial dcl 4-3
copy_string                            internal static bit(9)                   initial dcl 10-8
copy_words                             internal static bit(9)                   initial dcl 10-8
cos_fun                                internal static bit(9)                   initial dcl 10-8
cosd_fun                               internal static bit(9)                   initial dcl 10-8
cross_reference_node                   internal static bit(9)                   initial dcl 1-5
declare_statement                      internal static bit(9)                   initial dcl 4-3
default_node                           internal static bit(9)                   initial dcl 1-5
default_statement                      internal static bit(9)                   initial dcl 4-3
delete_file                            internal static bit(9)                   initial dcl 10-8
delete_statement                       internal static bit(9)                   initial dcl 4-3
desc_size                              internal static bit(9)                   initial dcl 10-8
digit_to_bit                           internal static bit(9)                   initial dcl 10-8
display_statement                      internal static bit(9)                   initial dcl 4-3
div                                    internal static bit(9)                   initial dcl 10-8
do_fun                                 internal static bit(9)                   initial dcl 10-8
do_spec                                internal static bit(9)                   initial dcl 10-8
do_statement                           internal static bit(9)                   initial dcl 4-3
e_format                               internal static bit(9)                   initial dcl 10-8
else_clause                            internal static bit(9)                   initial dcl 4-3
empty_area                             internal static bit(9)                   initial dcl 10-8
enable_on                              internal static bit(9)                   initial dcl 10-8
end_statement                          internal static bit(9)                   initial dcl 4-3
entry_statement                        internal static bit(9)                   initial dcl 4-3
environmentptr_fun                     internal static bit(9)                   initial dcl 10-8
equal                                  internal static bit(9)                   initial dcl 10-8
ex_prologue                            internal static bit(9)                   initial dcl 10-8
exit_statement                         internal static bit(9)                   initial dcl 4-3
exp                                    internal static bit(9)                   initial dcl 10-8
exp_fun                                internal static bit(9)                   initial dcl 10-8
f_format                               internal static bit(9)                   initial dcl 10-8
floor_fun                              internal static bit(9)                   initial dcl 10-8
format_statement                       internal static bit(9)                   initial dcl 4-3
format_value_node                      internal static bit(9)                   initial dcl 1-5
fortran_read                           internal static bit(9)                   initial dcl 10-8
fortran_write                          internal static bit(9)                   initial dcl 10-8
free_based                             internal static bit(9)                   initial dcl 10-8
free_ctl                               internal static bit(9)                   initial dcl 10-8
free_statement                         internal static bit(9)                   initial dcl 4-3
free_var                               internal static bit(9)                   initial dcl 10-8
ftn_file_manip                         internal static bit(9)                   initial dcl 10-8
ftn_trans_loop                         internal static bit(9)                   initial dcl 10-8
get_data_trans                         internal static bit(9)                   initial dcl 10-8
get_edit_trans                         internal static bit(9)                   initial dcl 10-8
get_file                               internal static bit(9)                   initial dcl 10-8
get_list_trans                         internal static bit(9)                   initial dcl 10-8
get_statement                          internal static bit(9)                   initial dcl 4-3
get_string                             internal static bit(9)                   initial dcl 10-8
goto_statement                         internal static bit(9)                   initial dcl 4-3
greater_or_equal                       internal static bit(9)                   initial dcl 10-8
greater_than                           internal static bit(9)                   initial dcl 10-8
half_to_word                           internal static bit(9)                   initial dcl 10-8
i                                      automatic       fixed bin(17,0)          dcl 264
imag_fun                               internal static bit(9)                   initial dcl 10-8
ind_arithmetic                         internal static fixed bin(17,0)          initial dcl 12-68
ind_decimal_reg                        internal static fixed bin(17,0)          initial dcl 12-68
ind_invalid                            internal static fixed bin(17,0)          initial dcl 12-68
ind_known_refs                         internal static fixed bin(17,0)          initial dcl 12-68
ind_logical                            internal static fixed bin(17,0)          initial dcl 12-68
ind_string_aq                          internal static fixed bin(17,0)          initial dcl 12-68
ind_x                                  internal static fixed bin(17,0)          initial array dcl 12-68
index_after_fun                        internal static bit(9)                   initial dcl 10-8
index_before_fun                       internal static bit(9)                   initial dcl 10-8
index_fun                              internal static bit(9)                   initial dcl 10-8
index_rev_fun                          internal static bit(9)                   initial dcl 10-8
join                                   internal static bit(9)                   initial dcl 10-8
jump                                   internal static bit(9)                   initial dcl 10-8
jump_if_eq                             internal static bit(9)                   initial dcl 10-8
jump_if_ge                             internal static bit(9)                   initial dcl 10-8
jump_if_gt                             internal static bit(9)                   initial dcl 10-8
jump_if_le                             internal static bit(9)                   initial dcl 10-8
jump_if_lt                             internal static bit(9)                   initial dcl 10-8
jump_if_ne                             internal static bit(9)                   initial dcl 10-8
l_parn                                 internal static bit(9)                   initial dcl 10-8
label_array_element_node               internal static bit(9)                   initial dcl 1-5
length_fun                             internal static bit(9)                   initial dcl 10-8
less_or_equal                          internal static bit(9)                   initial dcl 10-8
less_than                              internal static bit(9)                   initial dcl 10-8
line_format                            internal static bit(9)                   initial dcl 10-8
locate_file                            internal static bit(9)                   initial dcl 10-8
locate_statement                       internal static bit(9)                   initial dcl 4-3
lock_file                              internal static bit(9)                   initial dcl 10-8
lock_fun                               internal static bit(9)                   initial dcl 10-8
lock_statement                         internal static bit(9)                   initial dcl 4-3
log10_fun                              internal static bit(9)                   initial dcl 10-8
log2_fun                               internal static bit(9)                   initial dcl 10-8
log_fun                                internal static bit(9)                   initial dcl 10-8
loop                                   internal static bit(9)                   initial dcl 10-8
machine_state_node                     internal static bit(9)                   initial dcl 1-5
make_desc                              internal static bit(9)                   initial dcl 10-8
max_block_number                       internal static fixed bin(17,0)          initial dcl 2-74
max_fun                                internal static bit(9)                   initial dcl 10-8
max_list_elements                      internal static fixed bin(17,0)          initial dcl 7-12
max_number_of_operands                 internal static fixed bin(15,0)          initial dcl 9-15
min_fun                                internal static bit(9)                   initial dcl 10-8
mod_bit                                internal static bit(9)                   initial dcl 10-8
mod_byte                               internal static bit(9)                   initial dcl 10-8
mod_fun                                internal static bit(9)                   initial dcl 10-8
mod_half                               internal static bit(9)                   initial dcl 10-8
mod_word                               internal static bit(9)                   initial dcl 10-8
mult                                   internal static bit(9)                   initial dcl 10-8
negate                                 internal static bit(9)                   initial dcl 10-8
nop                                    internal static bit(9)                   initial dcl 10-8
not_equal                              internal static bit(9)                   initial dcl 10-8
null_statement                         internal static bit(9)                   initial dcl 4-3
off_fun                                internal static bit(9)                   initial dcl 10-8
on_statement                           internal static bit(9)                   initial dcl 4-3
open_file                              internal static bit(9)                   initial dcl 10-8
open_statement                         internal static bit(9)                   initial dcl 4-3
pack                                   internal static bit(9)                   initial dcl 10-8
page_format                            internal static bit(9)                   initial dcl 10-8
picture_format                         internal static bit(9)                   initial dcl 10-8
pl1_mod_fun                            internal static bit(9)                   initial dcl 10-8
prefix_plus                            internal static bit(9)                   initial dcl 10-8
procedure_statement                    internal static bit(9)                   initial dcl 4-3
ptr_fun                                internal static bit(9)                   initial dcl 10-8
put_control                            internal static bit(9)                   initial dcl 10-8
put_data_trans                         internal static bit(9)                   initial dcl 10-8
put_edit_trans                         internal static bit(9)                   initial dcl 10-8
put_field                              internal static bit(9)                   initial dcl 10-8
put_field_chk                          internal static bit(9)                   initial dcl 10-8
put_file                               internal static bit(9)                   initial dcl 10-8
put_list_trans                         internal static bit(9)                   initial dcl 10-8
put_statement                          internal static bit(9)                   initial dcl 4-3
put_string                             internal static bit(9)                   initial dcl 10-8
r_format                               internal static bit(9)                   initial dcl 10-8
r_parn                                 internal static bit(9)                   initial dcl 10-8
range_ck                               internal static bit(9)                   initial dcl 10-8
rank_fun                               internal static bit(9)                   initial dcl 10-8
read_file                              internal static bit(9)                   initial dcl 10-8
read_statement                         internal static bit(9)                   initial dcl 4-3
real_fun                               internal static bit(9)                   initial dcl 10-8
record_io                              internal static bit(9)                   initial dcl 10-8
refer                                  internal static bit(9)                   initial dcl 10-8
rel_fun                                internal static bit(9)                   initial dcl 10-8
repeat_fun                             internal static bit(9)                   initial dcl 10-8
return_bits                            internal static bit(9)                   initial dcl 10-8
return_statement                       internal static bit(9)                   initial dcl 4-3
return_string                          internal static bit(9)                   initial dcl 10-8
return_value                           internal static bit(9)                   initial dcl 10-8
return_words                           internal static bit(9)                   initial dcl 10-8
reverse_fun                            internal static bit(9)                   initial dcl 10-8
revert_on                              internal static bit(9)                   initial dcl 10-8
revert_statement                       internal static bit(9)                   initial dcl 4-3
rewrite_file                           internal static bit(9)                   initial dcl 10-8
rewrite_statement                      internal static bit(9)                   initial dcl 4-3
round_fun                              internal static bit(9)                   initial dcl 10-8
search_fun                             internal static bit(9)                   initial dcl 10-8
search_rev_fun                         internal static bit(9)                   initial dcl 10-8
segno_fun                              internal static bit(9)                   initial dcl 10-8
setbitno_fun                           internal static bit(9)                   initial dcl 10-8
setcharno_fun                          internal static bit(9)                   initial dcl 10-8
sf_par_node                            internal static bit(9)                   initial dcl 1-5
share_expression                000000 constant        entry                    external dcl 58
sign_fun                               internal static bit(9)                   initial dcl 10-8
signal_on                              internal static bit(9)                   initial dcl 10-8
signal_statement                       internal static bit(9)                   initial dcl 4-3
sin_fun                                internal static bit(9)                   initial dcl 10-8
sind_fun                               internal static bit(9)                   initial dcl 10-8
skip_format                            internal static bit(9)                   initial dcl 10-8
source_node                            internal static bit(9)                   initial dcl 1-5
sqrt_fun                               internal static bit(9)                   initial dcl 10-8
stack_ptr                              internal static bit(9)                   initial dcl 10-8
stackbaseptr_fun                       internal static bit(9)                   initial dcl 10-8
stackframeptr_fun                      internal static bit(9)                   initial dcl 10-8
stacq_fun                              internal static bit(9)                   initial dcl 10-8
statement_node                         internal static bit(9)                   initial dcl 1-5
std_arg_list                           internal static bit(9)                   initial dcl 10-8
std_entry                              internal static bit(9)                   initial dcl 10-8
std_return                             internal static bit(9)                   initial dcl 10-8
stop                                   internal static bit(9)                   initial dcl 10-8
stop_statement                         internal static bit(9)                   initial dcl 4-3
stream_prep                            internal static bit(9)                   initial dcl 10-8
sub                                    internal static bit(9)                   initial dcl 10-8
symbol_node                            internal static bit(9)                   initial dcl 1-5
system_on_unit                         internal static bit(9)                   initial dcl 4-3
tan_fun                                internal static bit(9)                   initial dcl 10-8
tand_fun                               internal static bit(9)                   initial dcl 10-8
terminate_trans                        internal static bit(9)                   initial dcl 10-8
token_node                             internal static bit(9)                   initial dcl 1-5
translate_fun                          internal static bit(9)                   initial dcl 10-8
trunc_fun                              internal static bit(9)                   initial dcl 10-8
unknown_statement                      internal static bit(9)                   initial dcl 4-3
unlock_file                            internal static bit(9)                   initial dcl 10-8
unlock_statement                       internal static bit(9)                   initial dcl 4-3
unpack                                 internal static bit(9)                   initial dcl 10-8
vclock_fun                             internal static bit(9)                   initial dcl 10-8
verify_fun                             internal static bit(9)                   initial dcl 10-8
verify_ltrim_fun                       internal static bit(9)                   initial dcl 10-8
verify_rev_fun                         internal static bit(9)                   initial dcl 10-8
verify_rtrim_fun                       internal static bit(9)                   initial dcl 10-8
wait_statement                         internal static bit(9)                   initial dcl 4-3
word_to_mod2                           internal static bit(9)                   initial dcl 10-8
word_to_mod4                           internal static bit(9)                   initial dcl 10-8
word_to_mod8                           internal static bit(9)                   initial dcl 10-8
wordno_fun                             internal static bit(9)                   initial dcl 10-8
write_file                             internal static bit(9)                   initial dcl 10-8
write_statement                        internal static bit(9)                   initial dcl 4-3
x_format                               internal static bit(9)                   initial dcl 10-8
xor_bits                               internal static bit(9)                   initial dcl 10-8

NAMES DECLARED BY EXPLICIT CONTEXT.
check_expr                      000611 constant        entry                    internal dcl 282 ref 103 301 322 331 333 335
make                            000457 constant        entry                    internal dcl 235 ref 170 189
optimize_if                     000017 constant        entry                    external dcl 38 ref 223
share_target_expression         000547 constant        entry                    internal dcl 255 ref 178

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1242        1300    1065        1252
Length      1710    1065        36         373     154           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
optimize_if                         148 external procedure  is an external procedure.  
make                                    internal procedure  shares stack frame of external procedure optimize_if.  
share_target_expression                 internal procedure  shares stack frame of external procedure optimize_if.  
check_expr                           92 internal procedure  calls itself recursively.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
check_expr               000100 p                           check_expr
                         000102 q                           check_expr
                         000104 i                           check_expr
                         000105 n                           check_expr
                         000106 atomic                      check_expr
optimize_if              000100 jop                         optimize_if
                         000102 lp                          optimize_if
                         000104 next                        optimize_if
                         000106 nextlab                     optimize_if
                         000110 p3                          optimize_if
                         000112 st                          optimize_if
                         000114 target                      optimize_if
                         000116 tree                        optimize_if
                         000120 next_tree                   optimize_if
                         000122 jump_code                   optimize_if
                         000123 op_code                     optimize_if
                         000124 m_s_p                       optimize_if
                         000134 new                         make
                         000136 op                          make
                         000146 q                           share_target_expression
                         000150 vector                      share_target_expression

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              unpk_to_pk          call_ext_in         call_ext_out        call_int_this       call_int_other
return              ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
compile_exp                   create_label                  create_list                   create_operator
create_statement              jump_op$eval_primaries        prepare_operand

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
cg_stat$cur_block             cg_stat$cur_level             cg_static_$m_s_p              pl1_stat_$cur_statement




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     38 000014   12    3 000024        76 000027        77 000033        79 000035        81 000040        83 000042
     88 000064        96 000065       103 000111       104 000122       108 000125       109 000126       111 000131
    112 000135       113 000141       115 000144       116 000150       118 000154       123 000156       124 000165
    125 000170       127 000171       132 000175       134 000205       136 000213       137 000216       138 000220
    141 000221       146 000234       152 000240       153 000242       156 000250       158 000257       159 000261
    160 000263       164 000264       170 000276       172 000277       174 000303       175 000305       178 000320
    179 000322       187 000323       189 000326       191 000327       193 000333       195 000341       197 000343
    198 000364       202 000377       203 000402       205 000404       206 000406       207 000410       209 000411
    213 000413       218 000420       221 000422       223 000426       228 000453       230 000454       232 000455
    352 000456       235 000457       241 000460       243 000463       244 000512       246 000531       248 000536
    250 000540       251 000543       253 000546       255 000547       266 000551       269 000564       271 000566
    272 000571       275 000576       278 000606       282 000610       291 000616       292 000622       293 000626
    295 000632       300 000635       301 000647       302 000660       303 000662       306 000663       308 000664
    310 000666       313 000675       315 000702       317 000704       319 000706       321 000713       322 000723
    323 000734       324 000737       326 000740       329 000741       331 000746       333 000762       335 000777
    337 001014       341 001015       343 001034       345 001037       346 001045       349 001054


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
