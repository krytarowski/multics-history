	COMPILATION LISTING OF SEGMENT probe_seg_info_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1134.74_Tue_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /****^  HISTORY COMMENTS:
       13*  1) change(87-05-27,JRGray), approve(87-06-24,MCR7711), audit(87-06-24,Huen),
       14*     install(87-07-15,MR12.1-1040):
       15*     Modified to allow breakpoint in more than one component of a bound module
       16*     at a time (probe 111).
       17*  2) change(88-09-07,WAAnderson), approve(88-09-30,MCR7952),
       18*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       19*     Added format control comment to make the source more readable.
       20*  3) change(88-10-21,WAAnderson), approve(88-10-21,MCR7952),
       21*     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
       22*     Modified code to implement a C feature. If the user specifes 'seg' instead
       23*     of 'seg$main', probe will now assume the user wants 'seg$main' if no
       24*     statement map is found for 'seg'.  This is not particularily elegant
       25*     because it will try using the 'seg$main' convention for any object,
       26*     regardless of the compiler used to generate the object.  If the
       27*     'probe_info.entry_method' field is set to 1, we free the previous
       28*     'seg_info', because it may not reflect the current situation. This
       29*     way we get new accurate information, particularily regarding the
       30*     status of the statement map. Other modules affected to implement
       31*     this feature are 'probe_command_' and 'probe_find_procedure_'. The
       32*     include 'probe_info.incl.pl1' was modified to include the new file
       33*     'retry_using_main'.
       34*                                                   END HISTORY COMMENTS */
       35 
       36 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       37 
       38 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       39 
       40 probe_seg_info_:
       41   proc (P_probe_info_ptr, P_segment_ptr, P_code) returns (ptr);
       42 
       43   /* This procedure is used to retrieve information about a segment or component from its
       44*   symbol table.  Once extracted, the information is stored in the scratch data
       45*   segment for future reference.
       46*
       47*   Initial Version:  12 August 1974 by Jeffrey M. Broughton
       48*   Modified:  20 June 1975 by JMB for version 2 object_info structure
       49*   Modified:  26 August 1975 by JMB to change calling sequence
       50*   Converted to probe 4.0 05/19/79 WOS
       51*   Major reorganization for new source ptr and seg_info JRD 25 June 79
       52*   Fix ignore_casep to not always return "1" b for sake of FORTRAN JRD Valentines Day 1980
       53*   09/21/80 WOS -- fixed bugs in forgetting components, and names (#187, #190)
       54*   Modified 17 April 1981 by M. N. Davidoff to fix unitialized variable bug.
       55*   Fixed to check for damaged source map 01/06/83 S. Herbst
       56*   Made to ignore case for Pascal, as for COBOL 08/11/83 S. Herbst
       57*
       58*   ENTRIES -
       59*   probe_seg_info_		- to get info set up
       60*   probe_seg_info_$name	- to return the name,  given ptr to seg
       61*   probe_seg_info_$flush	- to discard info
       62**/
       63 
       64   dcl (
       65       P_probe_info_ptr	pointer,
       66       P_segment_ptr		pointer,
       67       P_code		fixed bin (35)
       68       )			parameter;
       69 
       70   dcl info		pointer;	/* to procedure source information */
       71 
       72   dcl segment_ptr		ptr;	/* copy of P_segment_ptr */
       73   dcl segment_number	fixed bin;/* its segment number */
       74   dcl segment_offset	fixed bin (35);
       75 				/* its word offset */
       76   dcl offset		bit (18); /* offset into scratch seg for our info */
       77   dcl bsinfo		ptr;	/* to info for bound seg as a whole */
       78   dcl hdr			ptr;	/* to symbol table header */
       79   dcl code		fixed bin (35);
       80   dcl directory_name	char (168);
       81   dcl entry_name		char (32);
       82   dcl time_created		fixed bin (71);
       83 
       84   dcl 1 oi		aligned like object_info;
       85 
       86   dcl (
       87       probe_et_$non_standard,
       88       probe_et_$no_table,
       89       probe_et_$old_format,
       90       probe_et_$no_map
       91       )			fixed bin (35) external static;
       92 
       93   dcl hcs_$fs_get_path_name	entry (pointer, character (*), fixed bin,
       94 			character (*), fixed bin (35));
       95   dcl hcs_$status_mins	entry (pointer, fixed bin (2), fixed bin (24),
       96 			fixed bin (35));
       97   dcl component_info_$offset	entry (pointer, fixed bin (18), pointer,
       98 			fixed bin (35));
       99   dcl object_info_$display	entry (pointer, fixed bin (24), pointer,
      100 			fixed bin (35));
      101 
      102   dcl probe_error_$warning	entry options (variable);
      103   dcl probe_lang_type_	entry (char (*)) returns (fixed bin);
      104 
      105   dcl (addr, addrel, baseno, binary, divide, fixed, index, null, pointer, rel,
      106       size, stackbaseptr, unspec)
      107 			builtin;
      108 				/**/
      109 
      110   probe_info_ptr = P_probe_info_ptr;
      111   segment_ptr = P_segment_ptr;
      112 
      113   call get_info_pointer ();		/* look up the info for segment_ptr */
      114 
      115   if info = null ()
      116     then
      117          info = probe_static_info.null_seg_info_ptr;
      118 
      119   P_code = code;			/* return the error, if any */
      120   return (info);
      121 
      122   /**/
      123 
      124 probe_seg_info_$name:
      125   entry (P_probe_info_ptr, P_segment_ptr, P_code) returns (char (32));
      126 
      127   /* *	This entry returns the "canonical" name of the procedure, nothing else */
      128 
      129   probe_info_ptr = P_probe_info_ptr;
      130   segment_ptr = P_segment_ptr;
      131 
      132   call get_info_pointer ();		/* look up the info for segment_ptr */
      133   P_code = code;			/* reflect error, if any */
      134 
      135   if info = null ()
      136     then /* couldn't find out */
      137          return ("?Unknown?");
      138   else if (info -> seg_info.segname ^= "")
      139     then
      140          return (info -> seg_info.segname);
      141   else if (info -> seg_info.entry_name ^= "")
      142     then
      143          return (info -> seg_info.entry_name);
      144   else return ("?Unknown?");		/* all cases covered here */
      145 
      146   /**/
      147 
      148 probe_seg_info_$flush:
      149   entry (P_probe_info_ptr, P_segment_ptr);
      150 
      151   /* *	This entry attempts to flush any known saved pointers which refer to
      152*   *	the segment specified. This means it flushes the major seg_info block, and
      153*   *	also any component seg_info's if it was a bound segment. It also flushes
      154*   *	various other random things, which are known about only in free_seg_info. */
      155 
      156 
      157   if P_segment_ptr = null () then do;	/* can't flush null pointer -- just return */
      158       return;
      159     end;
      160 
      161   probe_info_ptr = P_probe_info_ptr;
      162   segment_ptr = pointer (P_segment_ptr, 0);
      163 				/* we're dealing with whole segment here */
      164   segment_number = binary (baseno (segment_ptr), 15);
      165 
      166   if (seg_info_offset (segment_number) = ""b)
      167     then /* flush the seg_info */
      168          info = null ();
      169     else info =
      170 	    pointer (probe_info.scratch_area_ptr,
      171 	    seg_info_offset (segment_number));
      172 
      173   call free_seg_info ();		/* flush it */
      174   return;				/* end of code for $flush entrypoint */
      175 
      176   /**/
      177 
      178 get_info_pointer:
      179   proc ();
      180 
      181   /* *	This procedure sets the pointer "info" to point to a seg_info block for the
      182*   *	specified pointer. It's major responsibility is to verify that the segment
      183*   *	has not changed out from under us. It also sets some global variables. */
      184 
      185 
      186   code = 0;
      187 
      188   if segment_ptr = null () then do;
      189       info = probe_static_info.null_seg_info_ptr;
      190 				/* "null" seg_info */
      191       return;			/* all done */
      192     end;
      193 
      194   segment_offset = binary (rel (segment_ptr), 18);
      195   segment_number = binary (baseno (segment_ptr), 15);
      196 
      197   entry_name = "?Unknown?";
      198   info = null ();
      199   offset = seg_info_offset (segment_number);
      200 
      201   if offset ^= (18)"0"b then do;	/* we have met before */
      202       info = pointer (probe_info.scratch_area_ptr, offset);
      203 				/* find out whether anything has happened */
      204       hdr = info -> seg_info.symbol_header_ptr;
      205       if (probe_info.entry_method = 1 | seg_changedp(info, hdr)) then
      206 
      207 	call free_seg_info ();	/* get rid of old entry (entries) */
      208        probe_info.entry_method = 0;
      209 	call get_seg_info ();	/* get new info */
      210     end;				/* make a new block for a bound component this time */
      211 
      212     else do;			/* otherwise, we must construct info anew */
      213       info = null ();		/* indicate that there is nothing presently available */
      214       call get_seg_info ();		/* and call to get info */
      215     end;
      216 
      217   if info ^= null ()
      218     then /* get stuff like current LP, etc. */
      219          call get_current_runtime_info ();
      220   return;				/* all done, one way or another */
      221   end get_info_pointer;		/* internal procedure */
      222 
      223   /**/
      224 
      225 get_seg_info:
      226   proc ();
      227 
      228   /* *	This procedure sets info to point the correct seg_info block, creating one if necessary */
      229 
      230   dcl bitcount		fixed bin (24);
      231 
      232   if info ^= null () then do;		/* have valid entry? */
      233       if info -> seg_info.bits.bound_segment then do;
      234 				/* it's for a bound segment -- find the component info */
      235 				/* modified to ensure time_created is set through this code path */
      236 	time_created = info -> seg_info.identifier;
      237 				/* time object bound */
      238 	bsinfo = info;		/* save ptr to info blck for the seg */
      239 
      240 	info = search_bound_info ();	/* look through bound segment for segment_offset */
      241 	if info ^= null ()
      242 	  then /* if we already know this seg, we're all done */
      243 	       return;
      244 
      245 	call create_component_seg_info ();
      246 				/* otherwise, create new info block for component and */
      247         end;			/* fall through to fill it in */
      248 
      249         else 
      250 	   return;		/* unbound seg, so saved info guaranteed still good */
      251     end;				/* familiar, valid entry */
      252 
      253     else do;			/* the entry is new this time (might have changed, but old */
      254       
      255       call hcs_$fs_get_path_name (segment_ptr, directory_name, (0),
      256 	 entry_name, code);		/* one is all gone) */
      257       if code ^= 0
      258         then /* any of these failures are catastrophic */
      259 	   goto MAJOR_LOSSAGE;
      260 
      261       call hcs_$status_mins (segment_ptr, (0), bitcount, code);
      262       if code ^= 0
      263         then
      264 	   goto MAJOR_LOSSAGE;
      265 
      266       oi.version_number = object_info_version_2;
      267       call object_info_$display (pointer (segment_ptr, 0), bitcount, addr (oi),
      268 	 code);
      269       if code ^= 0
      270         then
      271 	   goto MAJOR_LOSSAGE;
      272 
      273       hdr = oi.symbp;		/* set this here, for segment is new */
      274       time_created = hdr -> std_symbol_header.object_created;
      275 
      276       if oi.bound then do;
      277 	call create_bound_seg_info ();/* creates and initializes a seg_info block, setting bsinfo */
      278 	call create_component_seg_info ();
      279 				/* This will set info to point to the block the the component */
      280         end;			/* new seg, which is bound */
      281 
      282         else do;			/* new seg, not bound */
      283 	if oi.old_format then do;	/* intolerable for unbound seg */
      284 	    code = probe_et_$old_format;
      285 	    goto MAJOR_LOSSAGE;
      286 	  end;
      287 
      288 	call create_unbound_seg_info ();
      289 				/* creates and initializes a block for this */
      290         end;			/* making new seg_info for unbound */
      291     end;				/*  meeting a new seg */
      292 
      293   if info = null ()
      294     then goto MAJOR_LOSSAGE;		/* somethins has clearly gone amiss */
      295 
      296   /* *	When we reach here, segment may or may not be new; however, we are
      297*   *	guaranteed that the component is new if a bound seg is being processed.
      298*   *	In any event we have created the seg_info block we must find out things
      299*   *	about it - anything that one finds out that requires knowing if
      300*   *	the seg is bound or not is known already, this still leaves looking for
      301*   *	maps, symbol tables, language type etc... */
      302 
      303   call fill_in_info ();		/* fill in, with info common for both bound segs & components */
      304   return;
      305 
      306 
      307 MAJOR_LOSSAGE:			/* the other way out of this subroutine */
      308   info = null ();			/* code is already set */
      309   return;
      310   end get_seg_info;			/* internal procedure */
      311 
      312   /**/
      313 
      314 fill_in_info:
      315   proc ();
      316 
      317   /* *	This procedure fills in binding independent information about the segment */
      318 
      319   dcl ltype		fixed bin;
      320   dcl hdr_ptr		pointer;
      321   dcl based_string_lth	fixed bin (21);
      322   dcl based_string		char (based_string_lth) based;
      323   dcl pl1			pointer;
      324   dcl map_length		fixed bin (21);
      325 
      326   info -> seg_info.linkage_ptr = get_linkage_ptr ();
      327   info -> seg_info.break_info = null ();
      328 
      329   info -> seg_info.map_size = 0;
      330   info -> seg_info.error_code = 0;
      331   info -> seg_info.bound_sym_header = hdr;
      332   info -> seg_info.bound_create_time = time_created;
      333 
      334 
      335   /* The two above are used by breaks.  If the seg is unbound they are the time the seg was compiled and a ptr
      336*   to its symbol section header.  If bound, they are the time it was bound in,
      337*   as distinct from the compile time, and a ptr to the header for the bound seg
      338**/
      339   info -> seg_info.pad (*) = 0;
      340 
      341   hdr_ptr = info -> seg_info.symbol_header_ptr;
      342 				/* symbol header for component */
      343 
      344   ltype = probe_lang_type_ ((hdr_ptr -> std_symbol_header.generator));
      345   info -> seg_info.language_type = ltype;
      346 
      347   if ltype = COBOL_lang_type | ltype = PASCAL_lang_type
      348     then
      349          info -> seg_info.ignore_case = "1"b;
      350 				/* always, for COBOL and Pascal */
      351   else if ltype = FORTRAN_lang_type
      352     then
      353          info -> seg_info.ignore_case = ignore_casep (hdr_ptr);
      354 
      355   info -> seg_info.original_source_ptr =
      356        addrel (hdr_ptr, hdr_ptr -> std_symbol_header.source_map);
      357 
      358   pl1 = addrel (hdr_ptr, hdr_ptr -> std_symbol_header.area_pointer);
      359   if pl1 -> pl1_symbol_block.identifier ^= "pl1info" then do;
      360       code = probe_et_$no_table;
      361       info -> seg_info.error_code = code;
      362 				/* record it */
      363       info -> seg_info.segname = "";	/* and give null values to the rest */
      364       info -> seg_info.statement_map_ptr = null ();
      365 				/* no map, of course */
      366       info -> seg_info.map_size = 0;
      367       return;			/* ignore the rest of this */
      368     end;
      369 
      370   based_string_lth = fixed (pl1 -> pl1_symbol_block.segname.size, 21);
      371   info -> seg_info.segname = /* name of "main" entry */
      372        addrel (hdr_ptr, pl1 -> segname.offset) -> based_string;
      373 
      374   if pl1 -> pl1_symbol_block.map.first ^= "0"b then do;
      375       info -> seg_info.statement_map_ptr =
      376 	 addrel (hdr_ptr, pl1 -> pl1_symbol_block.map.first);
      377       map_length =
      378 	 fixed (pl1 -> pl1_symbol_block.last, 18)
      379 	 - fixed (pl1 -> pl1_symbol_block.first, 18);
      380       info -> seg_info.map_size =
      381 	 divide (map_length, size (statement_map), 17, 0) - 1;
      382     end;
      383 
      384     else do;			/* otherwise, record the problem */
      385       code = probe_et_$no_map;
      386       info -> seg_info.error_code = code;
      387       info -> seg_info.statement_map_ptr = null ();
      388 				/* provide values to indicate that this is missing */
      389       info -> seg_info.map_size = 0;
      390       return;
      391     end;
      392   return;
      393   end fill_in_info;			/* internal procedure */
      394 
      395   /**/
      396 
      397 create_bound_seg_info:
      398   proc ();
      399 
      400   /* *	This procedure creates and initializes a seg_info block for an entire bound
      401*   *	segment, and sets bsinfo to point to it. hdr_ptr is pointing at
      402*   *	std_symbol_header for whole bound seg. Numerous global variables
      403*   *	are imported from above. */
      404 
      405   dcl bindmap_ptr		pointer;
      406 
      407 
      408   bindmap_ptr = addrel (hdr, hdr -> std_symbol_header.area_pointer);
      409 
      410   seg_info_nfiles = 1;		/* should be 0, but PL/I won't allow dimension (0) */
      411 
      412   allocate seg_info in (scratch_area) set (bsinfo);
      413 
      414   bsinfo -> seg_info.nfiles = seg_info_nfiles;
      415   bsinfo -> seg_info.file_pointers (*) = null ();
      416 
      417   bsinfo -> seg_info.language_type = OTHER_lang_type;
      418   bsinfo -> seg_info.bits = "0"b;
      419   bsinfo -> seg_info.bits.bound_segment = "1"b;
      420 				/* indicates primary entry for bound seg */
      421 
      422   bsinfo -> seg_info.directory_name = directory_name;
      423   bsinfo -> seg_info.entry_name = entry_name;
      424   bsinfo -> seg_info.segname = "<<Bound Segment>>";
      425   bsinfo -> seg_info.identifier = time_created;
      426 
      427   bsinfo -> seg_info.symbol_header_ptr = hdr;
      428   bsinfo -> seg_info.original_source_ptr = bindmap_ptr;
      429   bsinfo -> seg_info.statement_map_ptr = null ();
      430   bsinfo -> seg_info.break_info = null ();
      431   bsinfo -> seg_info.chain = null ();
      432   bsinfo -> seg_info.linkage_ptr = get_linkage_ptr ();
      433 				/* filters out various kinds of badness */
      434 
      435   bsinfo -> seg_info.text_bounds.start = 0;
      436   bsinfo -> seg_info.text_bounds.end = 0;
      437   bsinfo -> seg_info.symbol_bounds.start = 0;
      438   bsinfo -> seg_info.symbol_bounds.end = 0;
      439 
      440   bsinfo -> seg_info.map_size = 0;
      441   bsinfo -> seg_info.error_code = 0;
      442   bsinfo -> seg_info.pad (*) = 0;
      443 
      444   seg_info_offset (segment_number) = rel (bsinfo);
      445 				/* remember where the bound seg info is */
      446   return;
      447   end create_bound_seg_info;		/* internal procedure */
      448 
      449   /**/
      450 
      451 create_unbound_seg_info:
      452   proc ();
      453 
      454   /* *	This procedure creates and initializes a seg_info block for an unbound
      455*   *	segment, and sets info to point to it. Numerous global variables
      456*   *	are imported from above. */
      457 
      458   dcl source_map_ptr	pointer;
      459   dcl ub_info		pointer;
      460 
      461 
      462   if hdr -> std_symbol_header.source_map = "000000"b3 then do;
      463 				/* haven't got a source map at all */
      464       source_map_ptr = null ();
      465       seg_info_nfiles = 1;		/* should be 0, but dimension (0) is invalid PL/I */
      466     end;
      467 
      468     else do;			/* otherwise, get information about the source map */
      469       source_map_ptr = addrel (hdr, hdr -> std_symbol_header.source_map);
      470       seg_info_nfiles = source_map_ptr -> source_map.number;
      471     end;
      472 
      473 
      474   allocate seg_info in (scratch_area) set (ub_info);
      475 
      476   ub_info -> seg_info.nfiles = seg_info_nfiles;
      477   ub_info -> seg_info.file_pointers (*) = null ();
      478 
      479   ub_info -> seg_info.bits = ""b;
      480 
      481   ub_info -> seg_info.directory_name = directory_name;
      482   ub_info -> seg_info.entry_name = entry_name;
      483   ub_info -> seg_info.identifier = time_created;
      484 
      485   ub_info -> seg_info.symbol_header_ptr = hdr;
      486   ub_info -> seg_info.original_source_ptr = source_map_ptr;
      487 
      488   ub_info -> seg_info.text_bounds.start = 0;
      489   ub_info -> seg_info.text_bounds.end = 0;
      490   ub_info -> seg_info.symbol_bounds.start = 0;
      491   ub_info -> seg_info.symbol_bounds.end = 0;
      492   ub_info -> seg_info.chain = null;
      493 
      494   info = ub_info;			/* all done */
      495   seg_info_offset (segment_number) = rel (ub_info);
      496 				/* record the location */
      497   return;
      498 
      499   end create_unbound_seg_info;	/* internal procedure */
      500 
      501   /**/
      502 
      503 create_component_seg_info:
      504   proc ();
      505 
      506   /* *	This procedure creates and initializes a seg_info block for a component
      507*   *	of the current bound segment. */
      508 
      509   dcl ct_info		ptr;
      510   dcl hdr_ptr		pointer;
      511   dcl source_map_ptr	pointer;
      512 
      513   /* assume bsinfo is set - we need to alloc a new block, which is one of the components of the bound seg */
      514 
      515 
      516   call component_info_$offset (pointer (segment_ptr, 0), (segment_offset),
      517        addr (ci), code);
      518   if code ^= 0 then do;		/* screwed up, it appears */
      519       info = null ();
      520       return;
      521     end;
      522 
      523   if ^ci.standard then do;
      524       code = probe_et_$non_standard;	/* FATAL */
      525       info = null ();
      526       return;
      527     end;
      528 
      529   hdr_ptr = ci.symb_start;
      530 
      531   if hdr_ptr -> std_symbol_header.source_map = "000000"b3 then do;
      532 				/* haven't got a source map at all */
      533 NO_SOURCE_MAP:
      534       source_map_ptr = null ();
      535       seg_info_nfiles = 1;		/* should be 0, but dimension (0) is invalid PL/I */
      536     end;
      537 
      538     else do;			/* otherwise, get information about the source map */
      539       source_map_ptr =
      540 	 addrel (hdr_ptr, hdr_ptr -> std_symbol_header.source_map);
      541       if source_map_ptr -> source_map.version < 1
      542 	 | source_map_ptr -> source_map.version > 30
      543         then
      544 	   go to NO_SOURCE_MAP;	/* source map is damaged */
      545       seg_info_nfiles = source_map_ptr -> source_map.number;
      546       if seg_info_nfiles < 1 | seg_info_nfiles > 256
      547         then go to NO_SOURCE_MAP;	/* count damaged */
      548     end;
      549 
      550   allocate seg_info in (scratch_area) set (ct_info);
      551 
      552   /* set up stuff that is different for a component seg_info than for an unbound one */
      553 
      554   ct_info -> seg_info.nfiles = seg_info_nfiles;
      555   ct_info -> seg_info.file_pointers (*) = null ();
      556 
      557   ct_info -> seg_info.bits = ""b;
      558   ct_info -> seg_info.bits.component = "1"b;
      559 				/* indicates component entry for bound seg */
      560 
      561   ct_info -> seg_info.directory_name = bsinfo -> seg_info.directory_name;
      562   ct_info -> seg_info.entry_name = bsinfo -> seg_info.entry_name;
      563 				/* copy entry name */
      564   ct_info -> seg_info.identifier = ci.compile_time;
      565 
      566   ct_info -> seg_info.symbol_header_ptr = hdr_ptr;
      567   ct_info -> seg_info.original_source_ptr = source_map_ptr;
      568 
      569   ct_info -> seg_info.text_bounds.start = fixed (rel (ci.text_start), 18);
      570   ct_info -> seg_info.text_bounds.end =
      571        fixed (rel (ci.text_start), 18) + ci.text_lng - 1;
      572   ct_info -> seg_info.symbol_bounds.start = fixed (rel (ci.symb_start), 18);
      573   ct_info -> seg_info.symbol_bounds.end =
      574        fixed (rel (ci.symb_start), 18) + ci.symb_lng - 1;
      575 
      576   ct_info -> seg_info.chain = bsinfo -> seg_info.chain;
      577 				/* add to head of list */
      578   bsinfo -> seg_info.chain = ct_info;
      579 
      580   info = ct_info;			/* leave it set for our caller */
      581 
      582   return;				/* and return */
      583   end create_component_seg_info;	/* internal procedure */
      584 
      585   /**/
      586 
      587 free_seg_info:
      588   proc ();
      589 
      590   dcl pi_ptr		pointer;
      591   dcl next_info		ptr;
      592 
      593   if info ^= null () then do;
      594       info =
      595 	 pointer (probe_info.scratch_area_ptr,
      596 	 seg_info_offset (segment_number));
      597       seg_info_offset (segment_number) = ""b;
      598 				/* and clear it out immediately */
      599 
      600       if ^info -> seg_info.bound_segment
      601         then /* easy to free nonbound seg_info, just free it */
      602 	   free info -> seg_info in (scratch_area);
      603 
      604         else do;			/* loop through all the bound seg infos, freeing them all */
      605 	do info = info repeat next_info while (info ^= null ());
      606 	  next_info = info -> seg_info.chain;
      607 				/* save before destorying */
      608 	  if baseno (info) = baseno (probe_info.scratch_area_ptr)
      609 	    then /* hedge for bad chains */
      610 	         free info -> seg_info in (scratch_area);
      611 	end;
      612         end;			/* of bound seg case */
      613 
      614       info = null ();		/* and make sure nobody tries to use it again */
      615     end;
      616 
      617   pi_ptr = probe_info_ptr;		/* loop through the probe_info chain, invalidating any */
      618   do while (pi_ptr ^= null ());	/* source_infos associated with the */
      619     call flush_source_info /* segment number in question */
      620          (pi_ptr -> probe_info.ptr_to_initial_source);
      621     call flush_source_info
      622          (pi_ptr -> probe_info.ptr_to_current_source);
      623     pi_ptr = pi_ptr -> probe_info.previous;
      624   end;
      625 
      626   probe_static_info.good_stack = "0"b;	/* flush the saved stach trace as well, for good measure */
      627 				/* this isn't strictly necessary, since we could just flush */
      628 				/* individual entries, but this is easiest. */
      629   return;
      630   end free_seg_info;		/* internal procedure */
      631 
      632   /**/
      633 
      634 flush_source_info:
      635   proc (P_source_info_ptr);
      636 
      637   /* *	This procedure checks a supplied source_info for any pointers containing the segment number
      638*   *	being flushed, and if it finds any, re-initializes the source_info. */
      639 
      640   dcl P_source_info_ptr	pointer parameter;
      641   dcl 1 flush_source	aligned like source_info
      642 			based (P_source_info_ptr);
      643 
      644 
      645   if P_source_info_ptr = null ()
      646     then
      647          return;			/* nothing to do */
      648 
      649   if binary (baseno (flush_source.instruction_ptr), 18)
      650        = segment_number /* if we are flushing the same segment  */
      651        | binary (baseno (flush_source.entry_ptr), 18)
      652        = segment_number /* number as is known in this source_info */
      653        | binary (baseno (flush_source.block_ptr), 18) = segment_number
      654     then do;			/* then we must then flush it. */
      655 
      656       flush_source.instruction_ptr = null ();
      657       flush_source.entry_ptr = null ();
      658       flush_source.block_ptr = null ();
      659       flush_source.stack_ptr = null ();
      660       flush_source.stmnt_map_entry_index = -1;
      661       flush_source.seg_info_ptr = probe_static_info.null_seg_info_ptr;
      662     end;
      663   return;
      664   end flush_source_info;		/* internal procedure */
      665 
      666   /**/
      667 
      668 
      669 get_current_runtime_info:
      670   proc ();
      671 
      672   /* *	It is the responsibility of this procedure to get the current values for various pieces
      673*   *	of runtime information which may change at times other than recompilations. */
      674 
      675 
      676   if info -> seg_info.linkage_ptr = null ()
      677     then
      678          info -> seg_info.linkage_ptr = get_linkage_ptr ();
      679 
      680   return;				/* for the moment, only the linkage pointer is in this class */
      681   end get_current_runtime_info;	/* internal procedure */
      682 
      683   /**/
      684 
      685 get_linkage_ptr:
      686   proc () returns (pointer);
      687 
      688   /* *	This procedure returns the linkage pointer for the segment identified by
      689*   *	segment_ptr; it filters out LOT faults and the like */
      690 
      691 
      692   lotp = stackbaseptr () -> stack_header.lot_ptr;
      693 
      694   if unspec (lotp -> lot.lp (segment_number)) = lot_fault then do;
      695       if probe_modes.debug
      696         then call probe_error_$warning
      697 	        (probe_info_ptr, 0,
      698 	        "LOT Fault linkage pointer for segno ^o.", segment_number);
      699       return (null ());
      700     end;
      701   return (lotp -> lot.lp (segment_number));
      702 
      703   end get_linkage_ptr;		/* internal procedure */
      704 
      705   /**/
      706 
      707 ignore_casep:
      708   proc (P_hp) returns (bit (1) aligned);
      709 
      710   dcl P_hp		ptr parameter;
      711 
      712   dcl compiler_comment	char (
      713 			binary (P_hp -> std_symbol_header.comment.size,
      714 			21)) based (commentp);
      715   dcl commentp		ptr;
      716 
      717 
      718   commentp = addrel (P_hp, P_hp -> std_symbol_header.comment.offset);
      719 
      720   return (index (compiler_comment, "card") > 0 |
      721        index (compiler_comment, "fold") > 0);
      722 
      723   end ignore_casep;
      724 
      725 seg_changedp:
      726   proc (infop, hdr) returns (bit (1) aligned);
      727 
      728   dcl infop		ptr parameter;
      729   dcl hdr			ptr parameter;
      730 
      731 
      732   if hdr = null ()			/* others have set this, to let us know */
      733     then return ("1"b);
      734   if infop -> seg_info.identifier ^= hdr -> std_symbol_header.object_created
      735     then return ("1"b);
      736   return ("0"b);
      737 
      738   end seg_changedp;
      739 
      740 
      741 search_bound_info:
      742   proc () returns (ptr);
      743 
      744   dcl seginfop		ptr;	/* to seg_info blocks in chain of bsi */
      745 
      746 
      747   do seginfop = bsinfo -> seg_info.chain
      748        repeat (seginfop -> seg_info.chain) while (seginfop ^= null ());
      749     if inside (seginfop, segment_offset)
      750       then
      751 	 return (seginfop);
      752   end;				/* loop */
      753   return (null);			/* not found */
      754 
      755 
      756 inside:
      757   proc (sip, so) returns (bit (1) aligned);
      758   dcl sip			ptr;	/* to seg_info for a component */
      759   dcl so			fixed bin (35) parameter;
      760 				/* offset in the seg */
      761 
      762   return (
      763        (so >= sip -> seg_info.text_bounds.start
      764        & so <= sip -> seg_info.text_bounds.end) |
      765        (so >= sip -> seg_info.symbol_bounds.start
      766        & so <= sip -> seg_info.symbol_bounds.end)
      767        );
      768 
      769   end inside;
      770   end search_bound_info;
      771 
      772 
  1     1 /*	BEGIN INCLUDE FILE probe_info.incl.pl1		*/
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(88-10-24,WAAnderson), approve(88-10-24,MCR7952),
  1     7*     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
  1     8*     Added field 'retry_using_main' to add new C feature.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* Created: 04/22/79 W. Olin Sibert, from subsystem_info	
  1    13*   Modified: 22 Sept 79 JRd to remove: 	default (ptr & (auto|based)) init (null ());
  1    14*   Added flags.setting_break 08/22/83 Steve Herbst
  1    15*   Added flags.executing_quit_request 01/15/85 Steve Herbst
  1    16**/
  1    17 
  1    18 dcl 1 probe_info aligned based (probe_info_ptr),		/* standard data for a probe invocation */
  1    19     2 probe_info_version fixed bin,			/* version of this structure */
  1    20 
  1    21     2 static_info_ptr pointer unaligned,		/* pointer to static information structure */
  1    22     2 modes_ptr pointer unaligned,			/* pointer to probe_modes structure */
  1    23 
  1    24     2 ptr_to_current_source ptr,			/* current_source is based on this */
  1    25     2 ptr_to_initial_source ptr,			/* initial_source is based on this */
  1    26     2 machine_cond_ptr pointer,			/* pointer to machine conditions, if we faulted to get here */
  1    27 
  1    28     2 token_info aligned,				/* information about token chain currently being processed */
  1    29       3 first_token pointer unaligned,			/* first token in chain */
  1    30       3 ct pointer unaligned, 			/* pointer to current token; updated in MANY places */
  1    31       3 end_token bit (18) aligned,			/* token type at which to stop scanning token chain */
  1    32       3 buffer_ptr pointer unaligned,			/* pointer to input buffer */
  1    33       3 buffer_lth fixed bin (21),			/* and length */
  1    34 
  1    35     2 random_info aligned,
  1    36       3 current_stack_frame pointer unaligned,		/* stack frame pointer for frame in which probe was invoked */
  1    37       3 input_type fixed bin, 			/* current input type */
  1    38       3 language_type fixed bin,			/* current language being processed */
  1    39       3 return_method fixed bin,			/* how we should return after exiting probe */
  1    40       3 entry_method fixed bin,			/* how we got here in the first place */
  1    41       3 pad1 (19) bit (36) aligned,
  1    42 
  1    43     2 break_info,					/* break info -- only interesting if we got here via a break */
  1    44       3 break_slot_ptr pointer,			/* pointer to break slot -- non-null IFF at a break */
  1    45       3 last_break_slot_ptr pointer unaligned,		/* pointer to previous break slot, not presently used */
  1    46       3 break_reset bit (1) aligned,			/* this break has been reset by somebody further on */
  1    47       3 real_break_return_loc pointer,			/* where to REALLY return to, modulo previous bit */
  1    48 
  1    49     2 probe_area_info,				/* information about various probe areas */
  1    50       3 break_segment_ptr pointer unaligned,		/* pointer to Personid.probe */
  1    51       3 break_area_ptr pointer unaligned,		/* pointer to area in break segment */
  1    52       3 scratch_area_ptr pointer unaligned,		/* pointer to probe scratch seg in process dir */
  1    53       3 probe_area_ptr pointer unaligned,		/* This area lasts as long as an invocation of probe. */
  1    54       3 work_area_ptr pointer unaligned,		/* This area lasts as long as the current request line */
  1    55       3 expression_area_ptr pointer unaligned,		/* This area lasts as long as the current command */
  1    56 
  1    57     2 flags aligned,				/* this, in particular, should be saved and restored correctly */
  1    58      (3 execute,					/* "1"b => execute requests, "0"b => just check syntax */
  1    59       3 in_listener,				/* ON => in probe listener loop */
  1    60       3 executing_request,				/* ON => executing a request */
  1    61       3 in_interpret_line,				/* executing in probe_listen_$interpret_line */
  1    62       3 setting_break,				/* executing "after" or "before": check syntax of "if" */
  1    63       3 executing_quit_request,			/* to prevent error looping during "quit" request */
  1    64       3 pad (30)) bit (1) unaligned,
  1    65 
  1    66     2 io_switches,					/* switches probe will do normal I/O on */
  1    67       3 input_switch pointer,
  1    68       3 output_switch pointer,
  1    69 
  1    70     2 error_info,					/* information about the last error saved for later printing */
  1    71       3 error_code fixed bin (35),
  1    72       3 error_message char (300) varying,
  1    73 
  1    74     2 listener_info,				/* internal use by probe listener */
  1    75       3 request_name character (32) varying,		/* primary name of the request being processed */
  1    76       3 abort_probe_label label variable,
  1    77       3 abort_line_label label variable,
  1    78       3 depth fixed binary,				/* count of active invocations of probe */
  1    79       3 previous pointer unaligned,			/* -> previous invocation's info */
  1    80       3 next pointer unaligned,
  1    81 
  1    82     2 end_of_probe_info pointer aligned,
  1    83     2 retry_using_main fixed bin aligned;
  1    84    
  1    85 
  1    86 dcl  probe_info_ptr pointer;
  1    87 
  1    88 dcl  probe_info_version fixed bin static options (constant) initial (1);
  1    89 
  1    90 dcl  probe_info_version_1 fixed bin static options (constant) initial (1);
  1    91 
  1    92 dcl  scratch_area area based (probe_info.scratch_area_ptr);
  1    93 dcl  probe_area area based (probe_info.probe_area_ptr);
  1    94 dcl  work_area area based (probe_info.work_area_ptr);
  1    95 dcl  expression_area area based (probe_info.expression_area_ptr);
  1    96 
  1    97 /*	END INCLUDE FILE probe_info.incl.pl1		*/
      773 
      774 
  2     1 /*	BEGIN INCLUDE FILE probe_static_info.incl.pl1	*/
  2     2 
  2     3 /* *	This include file describes per-process information about probe, such
  2     4*   *	as various options available and the info directories and modes.
  2     5*   *
  2     6*   *	Created: 06/06/79 W. Olin Sibert */
  2     7 
  2     8 dcl 1 probe_static_info aligned based (probe_info.static_info_ptr), /* per-process data about probe */
  2     9     2 probe_info_version fixed bin,			/* same as probe_info.probe_info_version */
  2    10 
  2    11     2 version aligned,
  2    12       3 major_version fixed bin,
  2    13       3 minor_version fixed bin,
  2    14       3 version_string char (32) unaligned,		/* like "4.3f, patch 1" */
  2    15 
  2    16     2 name char (32) unaligned,			/* "probe" */
  2    17     2 prompt character (40) varying,			/* prompt for reading requests */
  2    18     2 switches,
  2    19       3 brief_sw bit (1) unaligned,			/* briefer break messages, no header (default OFF) */
  2    20       3 no_handle_faults_sw bit (1) unaligned,		/* don't handle bad ptr faults (default OFF) */
  2    21       3 recursive_breaks_sw bit (1) unaligned,		/* don't ignore recursive breaks in probe */
  2    22       3 prompt_on_sw bit (1) unaligned,			/* prompt for request lines */
  2    23       3 switch_pad bit (32) unaligned,
  2    24 
  2    25     2 scratch_segment_ptr pointer,			/* pointer to probe_scratch_ -- always valid */
  2    26     2 break_segment_ptr pointer,			/* pointer to Person.breaks -- valid only if needed */
  2    27 
  2    28     2 seg_info_offset_ptr pointer,			/* pointer to seg_info_offset array */
  2    29 
  2    30     2 probe_segno bit (18),				/* segment number of probe itself */
  2    31    2 last_break_segno bit (18),			/* segment number of last interrupted program */
  2    32 
  2    33     2 stack_info aligned,				/* information about the stack trace in probe_scratch_ */
  2    34       3 level_chain pointer unaligned,			/* first level frame entry pointer */
  2    35       3 max_level fixed bin,				/* number of stack levels */
  2    36       3 flags aligned,
  2    37        (4 good_stack,
  2    38         4 traced_with_all,				/* whether the stack trace includes support frames */
  2    39         4 pad1 (34)) bit (1) unaligned,
  2    40 
  2    41     2 modes_ptr pointer unaligned,			/* pointer to modes -- same as probe_info.modes_ptr */
  2    42 
  2    43     2 request_table_info aligned,			/* info for request definitions */
  2    44       3 array_ptr pointer,				/* pointer to array of request table pointers */
  2    45       3 array_size fixed bin, 			/* number of elements in use */
  2    46       3 array_max_size fixed bin,			/* max number of elements in array */
  2    47       3 using_internal_array bit (1) aligned,		/* whether or not we are using the array in probe_static_info */
  2    48 
  2    49     2 io_switches,					/* switches probe does its I/O on */
  2    50       3 input_switch pointer,
  2    51       3 output_switch pointer,
  2    52       3 (private_input_sw, private_output_sw) bit (1) aligned,
  2    53 						/* created by ids, ods and should be destroyed */
  2    54 
  2    55     2 info_directory_info aligned,			/* info about info directories */
  2    56       3 array_ptr pointer,
  2    57       3 array_size fixed bin,
  2    58       3 array_max_size fixed bin,
  2    59       3 using_internal_array bit (1) aligned,
  2    60 
  2    61     2 exclude_name_info aligned,			/* info for exclude array used in printing values */
  2    62       3 array_ptr pointer,
  2    63       3 array_size fixed bin,
  2    64       3 array_max_size fixed bin,
  2    65       3 using_internal_array bit (1) aligned,
  2    66 
  2    67     2 null_seg_info_ptr pointer unaligned,		/* pointer to the "null" seg_info block */
  2    68 
  2    69     2 initial_arrays,				/* initial versions of various arrays */
  2    70       3 request_table_ptr_array (10) pointer aligned,
  2    71       3 info_directory_name_array (3) char (168) unaligned,
  2    72       3 exclude_name_array (6) char (32) unaligned,
  2    73 
  2    74     2 metering_info,					/* last values for "mode meter" */
  2    75       3 last_clock fixed bin (71),
  2    76       3 last_vclock fixed bin (71),
  2    77       3 last_page_faults fixed bin,
  2    78 
  2    79     2 end_of_probe_static_info fixed bin;
  2    80 
  2    81 
  2    82 dcl 1 probe_seg_info_array aligned based (probe_static_info.seg_info_offset_ptr),
  2    83     2 count fixed bin,				/* number of entries in seg_info_offset array */
  2    84     2 seg_info_offset (0 : seg_info_offset_count refer (probe_seg_info_array.count)) bit (18) aligned;
  2    85 
  2    86 dcl  seg_info_offset_count fixed bin;			/* one less than the number of info_offsets */
  2    87 
  2    88 dcl  probe_request_tables (probe_static_info.request_table_info.array_max_size) /* array of request table pointers */
  2    89      pointer aligned based (probe_static_info.request_table_info.array_ptr);
  2    90 
  2    91 dcl  probe_info_directories (probe_static_info.info_directory_info.array_max_size) /* array of info directories */
  2    92      char (168) unaligned based (probe_static_info.info_directory_info.array_ptr);
  2    93 
  2    94 dcl  probe_exclude_names (probe_static_info.exclude_name_info.array_max_size) /* array of exclude names */
  2    95      char (168) unaligned based (probe_static_info.exclude_name_info.array_ptr);
  2    96 
  2    97 /*	END INCLUDE FILE probe_static_info.incl.pl1	*/
      775 
      776 
  3     1 /*	BEGIN INCLUDE FILE ... probe_modes.incl.pl1
  3     2*
  3     3*   this structure is part of the per-user data base, which alledgedly is
  3     4*   kept in person_id.probe  no probe code other than probe_modes_mgr_
  3     5*   should set these modes, or refer to them BY NAME in communication
  3     6*   with the user  I do not even promise a one-to-one correspondance
  3     7*   between the modes the user can set and the names here
  3     8*
  3     9*   James R. Davis 12 July 79 */
  3    10 /* Added meter 09/23/82 S. Herbst */
  3    11 /* Added truncate_strings 05/21/84 S. Herbst */
  3    12 
  3    13 
  3    14 dcl 1 probe_modes aligned based (probe_info.modes_ptr),
  3    15     2 len_modes,
  3    16       3 error_messages fixed bin,			/* for use by probe_error_ */
  3    17       3 qualification fixed bin,			/* for use by probe_print_value_ */
  3    18       3 value_print fixed bin,			/* for probe_print_value_ */
  3    19       3 pad (5) fixed bin,				/* for use by probe_mxyzptlk */
  3    20     2 value_separator char (32) varying,
  3    21     2 bits,
  3    22       3 use_exclude_names bit (1) unal,
  3    23       3 debug_modes_set bit (1) unaligned,		/* whether any of the *MAGIC* modes are set */
  3    24       3 ignore_faults bit (1) unaligned,
  3    25       3 octal_bitstrings bit (1) unal,			/* for Olin Sibert */
  3    26       3 catch_errors bit (1) unaligned, 		/* calls to probe_error_ will call cu_$cl */
  3    27       3 catch_error_once bit (1) unaligned,		/* next call to probe_error_ will call cu_$cl */
  3    28       3 debug_breaks bit (1) unaligned, 		/* causes various things to happen at breakpoints */
  3    29       3 use_prompt bit (1) unaligned,			/* whether to use the prompt */
  3    30       3 debug bit (1) unaligned,			/* controls printing of random debugging information */
  3    31       3 meter bit (1) unaligned,			/* controls printing of time, vcpu, pf's at halt */
  3    32       3 truncate_strings bit (1) unaligned,		/* controls value req printing only 1st 200 chars/bits */
  3    33       3 pad bit (25) unaligned;
  3    34 
  3    35 dcl (BRIEF_mode_type init (1),
  3    36      SHORT_mode_type init (2),
  3    37      LONG_mode_type init (3)) fixed bin internal static options (constant);
  3    38 
  3    39 /* END INCLUDE FILE ... probe_modes.incl.pl1 */
  3    40 
      777 
      778 
  4     1 /* BEGIN INCLUDE FILE ... probe_seg_info.incl.pl1
  4     2*
  4     3*   25 June 79 JRDavis
  4     4*
  4     5*   Modified  7 April 1983, TO - Add fields for character offset/line
  4     6*	correction per file.
  4     7**/
  4     8 
  4     9 dcl 1 seg_info based aligned,				/* place to remember information about object seg */
  4    10     2 language_type fixed bin,			/* language of source program */
  4    11     2 bits aligned,
  4    12       3 ignore_case bit (1) unal,
  4    13       3 bound_segment bit (1) unaligned,
  4    14       3 component bit (1) unaligned,
  4    15       3 pad bit (33) unal,
  4    16     2 names,					/* where to find it */
  4    17       3 directory_name character (168) unal,		/* what directory */
  4    18       3 entry_name character (32) unal,			/* what segment */
  4    19       3 segname character (32) unal,			/* procedure segname definition */
  4    20     2 identifier fixed bin (71),			/* time of object creation */
  4    21     2 pointers,					/* location of various parts of segment */
  4    22       3 symbol_header_ptr ptr unal,			/* to symbol section */
  4    23       3 original_source_ptr ptr unal,			/* to segment source map */
  4    24       3 statement_map_ptr ptr unal,			/* to segment statement map */
  4    25       3 break_info ptr unal,				/* for unbound segments, and start of chain for
  4    26*						   bound ones, -> break_map !obsolete, I think! */
  4    27       3 chain ptr unal,				/* to entry for next component if bound */
  4    28       3 linkage_ptr ptr unal,				/* to linkage section */
  4    29     2 bounds aligned,				/* structure of bounds information */
  4    30       3 text_bounds,
  4    31         4 start fixed bin (35),
  4    32         4 end fixed bin (35),
  4    33       3 symbol_bounds,
  4    34         4 start fixed bin (35),
  4    35         4 end fixed bin (35),
  4    36     2 map_size fixed bin,				/* size of statement map */
  4    37     2 error_code fixed bin (35),			/* errors encoutered while getting info, are recorded here */
  4    38     2 bound_create_time fixed bin (71),			/* time seg containing was bound or compiled. */
  4    39     2 bound_sym_header ptr unal,			/* to sym. section header for bound seg */
  4    40     2 pad (1) fixed bin (35),
  4    41 
  4    42     2 nfiles fixed bin,
  4    43     2 per_file (seg_info_nfiles refer (seg_info.nfiles)),
  4    44       3 file_pointers ptr unal,
  4    45       3 break_line (0:3) fixed bin (18) unsigned unaligned;
  4    46 
  4    47 dcl  seg_info_nfiles fixed bin;			/* for allocation purposes */
  4    48 
  4    49 
  4    50 /* END INCLUDE FILE ... probe_seg_info.incl.pl1 */
      779 
      780 
  5     1 /* BEGIN INCLUDE FILE ... probe_source_info.incl.pl1
  5     2*
  5     3*  James R. Davis 2 July 79 */
  5     4 
  5     5 dcl 1 source_info based aligned,
  5     6       2 stmnt_map_entry_index fixed bin,		/* index in stmnt map for this stmnt */
  5     7       2 instruction_ptr ptr,				/* to last instruction executed  */
  5     8       2 block_ptr ptr,				/* to runtime_block node */
  5     9       2 stack_ptr ptr,				/* to a stack frame */
  5    10       2 entry_ptr ptr,				/* to entry seq. for this proc */
  5    11       2 seg_info_ptr ptr;				/* to seg_info */
  5    12 
  5    13 dcl 1 current_source aligned like source_info based (probe_info.ptr_to_current_source);
  5    14 dcl 1 initial_source aligned like source_info based (probe_info.ptr_to_initial_source);
  5    15 
  5    16 /* END INCLUDE FILE ... probe_source_info.incl.pl1 */
      781 
      782 
  6     1 /* BEGIN INCLUDE FILE  ... probe_lang_types.incl.pl1
  6     2*
  6     3*   JRD 26 June 79
  6     4*   MBW 31 July 1981 to add algol68 */
  6     5 
  6     6 
  6     7 /****^  HISTORY COMMENTS:
  6     8*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  6     9*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  6    10*     Added C Language type.
  6    11*                                                   END HISTORY COMMENTS */
  6    12 
  6    13 
  6    14 /*   Modified June 83 JMAthane to add PASCAL language type */
  6    15 /*   Modified April 88 Hinatsu to add C language type */
  6    16 
  6    17      dcl	   (UNKNOWN_lang_type     init (1),
  6    18 	   OTHER_lang_type	      init (2),
  6    19 	   PL1_lang_type	      init (3),
  6    20 	   FORTRAN_lang_type      init (4),
  6    21 	   COBOL_lang_type	      init (5),
  6    22 	   ALM_lang_type	      init (6),
  6    23 	   ALGOL68_lang_type      init (7),
  6    24 	   PASCAL_lang_type	      init (8),
  6    25 	   C_lang_type	      init (9)) fixed bin internal static options (constant);
  6    26 
  6    27      dcl	   official_language_names (9) char (32) internal static options (constant) init
  6    28 			      ("Unknown", "other", "PL/I", "FORTRAN", "COBOL", "ALM", "Algol 68", "Pascal", "C");
  6    29 
  6    30      dcl	   palatable_language_names (9) char (32) internal static options (constant) init
  6    31 			      ("Unknown", "Other", "pl1", "fortran", "cobol", "alm", "algol68", "pascal", "c");
  6    32 
  6    33 /* END INCLUDE FILE ... probe_lang_types.incl.pl1 */
      783 
      784 
  7     1 /* BEGIN INCLUDE FILE ... source_map.incl.pl1 */
  7     2 
  7     3 dcl	1 source_map	aligned based,
  7     4 	2 version		fixed bin,
  7     5 	2 number		fixed bin,
  7     6 	2 map(n refer(source_map.number))	 aligned,
  7     7 	  3 pathname	unaligned,
  7     8 	    4 offset	bit(18),
  7     9 	    4 size	bit(18),
  7    10 	  3 uid		bit(36),
  7    11 	  3 dtm		fixed bin(71);
  7    12 
  7    13 /* END INCLUDE FILE  ... source_map.incl.pl1 */
      785 
      786 
  8     1 dcl	1 std_symbol_header	based aligned,
  8     2 	2 dcl_version	fixed bin,
  8     3 	2 identifier	char(8),
  8     4 	2 gen_number	fixed bin,
  8     5 	2 gen_created	fixed bin(71),
  8     6 	2 object_created	fixed bin(71),
  8     7 	2 generator	char(8),
  8     8 	2 gen_version	unaligned,
  8     9 	  3 offset	bit(18),
  8    10 	  3 size		bit(18),
  8    11 	2 userid		unaligned,
  8    12 	  3 offset	bit(18),
  8    13 	  3 size		bit(18),
  8    14 	2 comment		unaligned,
  8    15 	  3 offset	bit(18),
  8    16 	  3 size		bit(18),
  8    17 	2 text_boundary	bit(18) unaligned,
  8    18 	2 stat_boundary	bit(18) unaligned,
  8    19 	2 source_map	bit(18) unaligned,
  8    20 	2 area_pointer	bit(18) unaligned,
  8    21 	2 backpointer	bit(18) unaligned,
  8    22 	2 block_size	bit(18) unaligned,
  8    23 	2 next_block	bit(18) unaligned,
  8    24 	2 rel_text	bit(18) unaligned,
  8    25 	2 rel_def		bit(18) unaligned,
  8    26 	2 rel_link	bit(18) unaligned,
  8    27 	2 rel_symbol	bit(18) unaligned,
  8    28 	2 mini_truncate	bit(18) unaligned,
  8    29 	2 maxi_truncate	bit(18) unaligned;
      787 
      788 
  9     1 dcl	1 pl1_symbol_block	aligned based,
  9     2 	2 version		fixed bin,
  9     3 	2 identifier	char(8),		/* must be "pl1info" */
  9     4 	2 flags,
  9     5 	  3 profile	bit(1) unal,
  9     6 	  3 table		bit(1) unal,
  9     7 	  3 map		bit(1) unal,
  9     8 	  3 flow		bit(1) unal,
  9     9 	  3 io		bit(1) unal,
  9    10 	  3 table_removed	bit(1) unal,
  9    11 	  3 long_profile	bit(1) unal,
  9    12 	  3 pad		bit(29) unal,
  9    13 	2 greatest_severity	fixed bin,
  9    14 	2 root		unal bit(18),
  9    15 	2 profile		unal bit(18),
  9    16 	2 map		unal,
  9    17 	  3 first		bit(18),
  9    18 	  3 last		bit(18),
  9    19 	2 segname		unaligned,
  9    20 	  3 offset	bit(18),
  9    21 	  3 size		bit(18);
      789 
      790 
 10     1 dcl	1 statement_map	aligned based,
 10     2 	2 location	bit(18) unaligned,
 10     3 	2 source_id	unaligned,
 10     4 	  3 file		bit(8),
 10     5 	  3 line		bit(14),
 10     6 	  3 statement	bit(5),
 10     7 	2 source_info	unaligned,
 10     8 	  3 start		bit(18),
 10     9 	  3 length	bit(9);
      791 
      792 
 11     1 /*	BEGIN INCLUDE FILE ... runtime_symbol.incl.pl1 ... Modified 07/79 */
 11     2 
 11     3 dcl	1 runtime_symbol	aligned based,
 11     4 	2 flag		unal bit(1),	/* always "1"b for Version II */
 11     5 	2 use_digit	unal bit(1),	/* if "1"b and units are half words units are really digits */
 11     6 	2 array_units	unal bit(2),
 11     7 	2 units		unal bit(2),	/* addressing units */
 11     8 	2 type		unal bit(6),	/* data type */
 11     9 	2 level		unal bit(6),	/* structure level */
 11    10 	2 ndims		unal bit(6),	/* number of dimensions */
 11    11 	2 bits		unal,
 11    12 	  3 aligned	bit(1),
 11    13 	  3 packed	bit(1),
 11    14 	  3 simple	bit(1),
 11    15 	2 skip		unal bit(1),
 11    16 	2 scale		unal bit(8),	/* arithmetic scale factor */
 11    17 	2 name		unal bit(18),	/* rel ptr to acc name */
 11    18 	2 brother		unal bit(18),	/* rel ptr to brother entry */
 11    19 	2 father		unal bit(18),	/* rel ptr to father entry */
 11    20 	2 son		unal bit(18),	/* rel ptr to son entry */
 11    21 	2 address		unal,
 11    22 	  3 location	bit(18),		/* location in storage class */
 11    23 	  3 class		bit(4),		/* storage class */
 11    24 	  3 next		bit(14),		/* rel ptr to next of same class */
 11    25 	2 size		fixed bin(35),	/* encoded string|arith size */
 11    26 	2 offset		fixed bin(35),	/* encoded offset from address */
 11    27 	2 virtual_org	fixed bin(35),
 11    28 	2 bounds(1),
 11    29 	  3 lower		fixed bin(35),	/* encoded lower bound */
 11    30 	  3 upper		fixed bin(35),	/* encoded upper bound */
 11    31 	  3 multiplier	fixed bin(35);	/* encoded multiplier */
 11    32 
 11    33 dcl	1 runtime_bound	based,
 11    34 	2 lower		fixed bin(35),
 11    35 	2 upper		fixed bin(35),
 11    36 	2 multiplier	fixed bin(35);
 11    37 
 11    38 dcl	1 runtime_block	aligned based,
 11    39 	2 flag		unal bit(1),	/* always "1"b for Version II */
 11    40 	2 quick		unal bit(1),	/* "1"b if quick block */
 11    41 	2 fortran		unal bit(1),	/* "1"b if fortran program */
 11    42 	2 standard	unal bit(1),	/* "1"b if program has std obj segment */
 11    43 	2 owner_flag	unal bit(1),	/* "1"b if block has valid owner field */
 11    44 	2 skip		unal bit(1),
 11    45 	2 type		unal bit(6),	/* = 0 for a block node */
 11    46 	2 number		unal bit(6),	/* begin block number */
 11    47 	2 start		unal bit(18),	/* rel ptr to start of symbols */
 11    48 	2 name		unal bit(18),	/* rel ptr to name of proc */
 11    49 	2 brother		unal bit(18),	/* rel ptr to brother block */
 11    50 	2 father		unal bit(18),	/* rel ptr to father block */
 11    51 	2 son		unal bit(18),	/* rel ptr to son block */
 11    52 	2 map		unal,
 11    53 	  3 first		bit(18),		/* rel ptr to first word of map */
 11    54 	  3 last		bit(18),		/* rel ptr to last word of map */
 11    55 	2 entry_info	unal bit(18),	/* info about entry of quick block */
 11    56 	2 header		unal bit(18),	/* rel ptr to symbol header */
 11    57 	2 chain(4)	unal bit(18),	/* chain(i) is rel ptr to first symbol
 11    58*					   on start list with length >= 2**i */
 11    59 	2 token(0:5)	unal bit(18),	/* token(i) is rel ptr to first token
 11    60*					   on list with length >= 2 ** i */
 11    61 	2 owner		unal bit(18);	/* rel ptr to owner block */
 11    62 
 11    63 dcl	1 runtime_token	aligned based,
 11    64 	2 next		unal bit(18),	/* rel ptr to next token */
 11    65 	2 dcl		unal bit(18),	/* rel ptr to first dcl of this token */
 11    66 	2 name,				/* ACC */
 11    67 	  3 size		unal unsigned fixed bin (9), /* number of chars in token */
 11    68 	  3 string	unal char(n refer(runtime_token.size));
 11    69 
 11    70 dcl	1 encoded_value	aligned based,
 11    71 	2 flag		bit (2) unal,
 11    72 	2 code		bit (4) unal,
 11    73 	2 n1		bit (6) unal,
 11    74 	2 n2		bit (6) unal,
 11    75 	2 n3		bit (18) unal;
 11    76 
 11    77 /*	END INCLUDE FILE ... runtime_symbol.incl.pl1 */
      793 
      794 
 12     1 /* BEGIN INCLUDE FILE ... object_info.incl.pl1
 12     2*coded February 8, 1972 by Michael J. Spier	*/
 12     3 /* modified May 26, 1972 by M. Weaver */
 12     4 /* modified 15 April, 1975 by M. Weaver */
 12     5 
 12     6 declare	1 object_info aligned based,		/* structure containing object info based, returned by object_info_ */
 12     7 	2 version_number fixed bin,		/* version number of current structure format (=2) */
 12     8 	2 textp pointer,			/* pointer to beginning of text section */
 12     9 	2 defp pointer,			/* pointer to beginning of definition section */
 12    10 	2 linkp pointer,			/* pointer to beginning of linkage section */
 12    11 	2 statp pointer,			/* pointer to beginning of static section */
 12    12 	2 symbp pointer,			/* pointer to beginning of symbol section */
 12    13 	2 bmapp pointer,			/* pointer to beginning of break map (may be null) */
 12    14 	2 tlng fixed bin,			/* length in words of text section */
 12    15 	2 dlng fixed bin,			/* length in words of definition section */
 12    16 	2 llng fixed bin,			/* length in words of linkage section */
 12    17 	2 ilng fixed bin,			/* length in words of static section */
 12    18 	2 slng fixed bin,			/* length in words of symbol section */
 12    19 	2 blng fixed bin,			/* length in words of break map */
 12    20 	2 format,				/* word containing bit flags about object type */
 12    21 	  3 old_format bit(1) unaligned,	/* on if segment isn't in new format, i.e. has old style object map */
 12    22 	  3 bound bit(1) unaligned,		/* on if segment is bound */
 12    23 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
 12    24 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
 12    25 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
 12    26 	  3 gate bit(1) unaligned,		/* on if segment is a gate */
 12    27 	  3 separate_static bit(1) unaligned,	/* on if static not in linkage */
 12    28 	  3 links_in_text bit(1) unaligned,	/* on if there are threaded links in text */
 12    29 	  3 perprocess_static bit (1) unaligned, /* on if static is not to be per run unit */
 12    30 	  3 pad bit(27) unaligned,
 12    31 	2 entry_bound fixed bin,		/* entry bound if segment is a gate */
 12    32 	2 textlinkp pointer,		/* ptr to first link in text */
 12    33 
 12    34 	/* LIMIT OF BRIEF STRUCTURE */
 12    35 
 12    36 	2 compiler char(8) aligned,		/* name of processor which generated segment */
 12    37 	2 compile_time fixed bin(71),		/* clock reading of date/time object was generated */
 12    38 	2 userid char(32) aligned,		/* standard Multics id of creator of object segment */
 12    39 	2 cvers aligned,			/* generator version name in printable char string form */
 12    40 	  3 offset bit(18) unaligned,		/* offset of name in words relative to base of symbol section */
 12    41 	  3 length bit(18) unaligned,		/* length of name in characters */
 12    42 	2 comment aligned,			/* printable comment concerning generator or generation of segment */
 12    43 	  3 offset bit(18) unaligned,		/* offset of comment in words relative to base of symbol section */
 12    44 	  3 length bit(18) unaligned,		/* length of comment in characters */
 12    45 	2 source_map fixed bin,		/* offset, relative to base of symbol section, of source map structure */
 12    46 
 12    47 	/* LIMIT OF DISPLAY STRUCTURE */
 12    48 
 12    49 	2 rel_text pointer,			/* pointer to text section relocation info */
 12    50 	2 rel_def pointer,			/* pointer to definition section relocation info */
 12    51 	2 rel_link pointer,			/* pointer to linkage section relocation info */
 12    52 	2 rel_static pointer,		/* pointer to static section relocation info */
 12    53 	2 rel_symbol pointer,		/* pointer to symbol section relocation info */
 12    54 	2 text_boundary fixed bin,		/* specifies mod  of text section base boundary */
 12    55 	2 static_boundary fixed bin,		/* specifies mod of internal static base boundary */
 12    56 					/* currently not used by system */
 12    57 	2 default_truncate fixed bin,		/* offset rel to symbp for binder to automatically trunc. symb sect. */
 12    58 	2 optional_truncate fixed bin;	/* offset rel to symbp for binder to optionally trunc. symb sect. */
 12    59 
 12    60 declare	object_info_version_2 fixed bin int static init(2);
 12    61 
 12    62 /* END INCLUDE FILE ... object_info.incl.pl1 */
      795 
      796 
 13     1 	/* BEGIN INCLUDE SEGMENT ...  component_info.incl.pl1   M. Weaver  4/26/72  */
 13     2 
 13     3 declare	1 ci aligned,
 13     4 	2 dcl_version fixed bin,		/* version number of this structure */
 13     5 	2 name char(32) aligned,		/* objectname of component segment */
 13     6 	2 text_start pointer,		/* ptr to component's section of text */
 13     7 	2 stat_start pointer,		/* pointer to component's section of internal static */
 13     8 	2 symb_start pointer,		/* pointer to component's first symbol block */
 13     9 	2 defblock_ptr pointer,		/* ptr to component's definition block */
 13    10 	2 text_lng fixed bin,		/* length of text section */
 13    11 	2 stat_lng fixed bin,		/* length of internal static */
 13    12 	2 symb_lng fixed bin,		/* length of symbol section */
 13    13 	2 n_blocks fixed bin,		/* number of symbol blocks in component's symbol section */
 13    14 	2 standard bit(1) aligned,		/* indicates whether component is in standard (new) format */
 13    15 	2 compiler char(8) aligned,		/* name of component's compiler */
 13    16 	2 compile_time fixed bin(71),		/* time component was compiled */
 13    17 	2 userid char(32) aligned,		/* id of creator of component */
 13    18 	2 cvers aligned,			/* version of component's compiler in printable form */
 13    19 	  3 offset bit(18) unaligned,		/* offset in words relative to symb_start */
 13    20 	  3 length bit(18) unaligned,		/* length of name in characters */
 13    21 	2 comment aligned,			/* component's comment */
 13    22 	  3 offset bit(18) unaligned,		/* offset in words relative to symb_start */
 13    23 	  3 length bit(18) unaligned,		/* length of comment in characters */
 13    24 	2 source_map fixed bin;		/* offset, rel to beg of symbol block, of component's source map */
 13    25 
 13    26 	/* END INCLUDE SEGMENT ... component_info.incl.pl1 */
      797 
      798 
 14     1 /* BEGIN INCLUDE FILE --  lot.incl.pl1   S.Webber 9/74, Modified by R. Bratt 04/76, modified by M. Weaver 7/76 */
 14     2 /* modified by M. Weaver 3/77 */
 14     3 
 14     4 dcl  lotp ptr;
 14     5 
 14     6 dcl 1 lot based (lotp) aligned,
 14     7     2 lp (0:9999) ptr unaligned;			/* array of packed pointers to linkage sections */
 14     8 
 14     9 dcl lot_fault bit (36) aligned static options (constant) init ("111000000000000000000000000000000000"b);
 14    10 						/* lot fault has fault code = 0 and offset = 0 */
 14    11 
 14    12 dcl  isotp ptr;
 14    13 dcl 1 isot based (isotp) aligned,
 14    14     2 isp (0:9999) ptr unaligned;
 14    15 
 14    16 dcl 1 isot1 (0 :9999) aligned based,
 14    17     2 flags unaligned,
 14    18       3 fault bit (2) unaligned,
 14    19       3 system bit (1) unaligned,
 14    20       3 mbz bit (6) unaligned,
 14    21     2 fault_code fixed bin (8) unaligned,
 14    22     2 static_offset bit (18) unaligned;
 14    23 
 14    24 
 14    25 /* END INCLUDE FILE  lot.incl.pl1 */
      799 
      800 
 15     1 /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
 15     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
 15     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
 15     4 /*	Modified April 1983 by C. Hornig for tasking */
 15     5 
 15     6 /****^  HISTORY COMMENTS:
 15     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
 15     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
 15     9*     added the heap_header_ptr definition.
 15    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
 15    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
 15    12*     Modified to support control point management.  These changes were actually
 15    13*     made in February 1985 by G. Palter.
 15    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
 15    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
 15    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
 15    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
 15    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
 15    19*     (ITS pair).
 15    20*                                                   END HISTORY COMMENTS */
 15    21 
 15    22 /* format: style2 */
 15    23 
 15    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
 15    25 
 15    26      dcl	   1 stack_header	      based (sb) aligned,
 15    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
 15    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
 15    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
 15    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
 15    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
 15    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
 15    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
 15    34 	     2 pad4	      bit (2) unal,
 15    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
 15    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
 15    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
 15    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
 15    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
 15    40 	     2 null_ptr	      ptr,		/*  (16)  */
 15    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
 15    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
 15    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
 15    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
 15    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
 15    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
 15    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
 15    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
 15    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
 15    50 	     2 return_no_pop_op_ptr
 15    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
 15    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
 15    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
 15    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
 15    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
 15    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
 15    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
 15    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
 15    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
 15    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
 15    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
 15    62 	     2 trace,
 15    63 	       3 frames,
 15    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
 15    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
 15    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
 15    67 	     2 pad2	      bit (36),		/*  (61) */
 15    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
 15    69 
 15    70 /*	The following offset refers to a table within the  pl1  operator table.  */
 15    71 
 15    72      dcl	   tv_offset	      fixed bin init (361) internal static;
 15    73 						/* (551) octal */
 15    74 
 15    75 
 15    76 /*	The following constants are offsets within this transfer vector table.  */
 15    77 
 15    78      dcl	   (
 15    79 	   call_offset	      fixed bin init (271),
 15    80 	   push_offset	      fixed bin init (272),
 15    81 	   return_offset	      fixed bin init (273),
 15    82 	   return_no_pop_offset   fixed bin init (274),
 15    83 	   entry_offset	      fixed bin init (275)
 15    84 	   )		      internal static;
 15    85 
 15    86 
 15    87 
 15    88 
 15    89 
 15    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
 15    91*	move the whole stack header should use this overlay.
 15    92**/
 15    93 
 15    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
 15    95 
 15    96 
 15    97 
 15    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
      801 
      802 
      803   end probe_seg_info_;		/* external procedure */
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1134.7  probe_seg_info_.pl1               >udd>sm>ds>w>ml>probe_seg_info_.pl1
773          1    10/27/88  1439.2  probe_info.incl.pl1               >ldd>incl>probe_info.incl.pl1
775          2    11/12/82  1724.3  probe_static_info.incl.pl1        >ldd>incl>probe_static_info.incl.pl1
777          3    12/04/84  2112.2  probe_modes.incl.pl1              >ldd>incl>probe_modes.incl.pl1
779          4    11/02/83  1945.0  probe_seg_info.incl.pl1           >ldd>incl>probe_seg_info.incl.pl1
781          5    11/26/79  1420.6  probe_source_info.incl.pl1        >ldd>incl>probe_source_info.incl.pl1
783          6    10/26/88  1355.5  probe_lang_types.incl.pl1         >ldd>incl>probe_lang_types.incl.pl1
785          7    11/26/79  1420.6  source_map.incl.pl1               >ldd>incl>source_map.incl.pl1
787          8    05/06/74  1851.6  std_symbol_header.incl.pl1        >ldd>incl>std_symbol_header.incl.pl1
789          9    03/10/77  1445.4  pl1_symbol_block.incl.pl1         >ldd>incl>pl1_symbol_block.incl.pl1
791         10    05/06/74  1851.6  statement_map.incl.pl1            >ldd>incl>statement_map.incl.pl1
793         11    11/26/79  1420.6  runtime_symbol.incl.pl1           >ldd>incl>runtime_symbol.incl.pl1
795         12    08/05/77  1122.5  object_info.incl.pl1              >ldd>incl>object_info.incl.pl1
797         13    05/06/74  1841.0  component_info.incl.pl1           >ldd>incl>component_info.incl.pl1
799         14    08/05/77  1122.4  lot.incl.pl1                      >ldd>incl>lot.incl.pl1
801         15    11/07/86  1650.3  stack_header.incl.pl1             >ldd>incl>stack_header.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
COBOL_lang_type                        constant        fixed bin(17,0)          initial dcl 6-17 ref 347
FORTRAN_lang_type                      constant        fixed bin(17,0)          initial dcl 6-17 ref 351
OTHER_lang_type                        constant        fixed bin(17,0)          initial dcl 6-17 ref 417
PASCAL_lang_type                       constant        fixed bin(17,0)          initial dcl 6-17 ref 347
P_code                                 parameter       fixed bin(35,0)          dcl 64 set ref 40 119* 124 133*
P_hp                                   parameter       pointer                  dcl 710 ref 707 718 718 720 720
P_probe_info_ptr                       parameter       pointer                  dcl 64 ref 40 110 124 129 148 161
P_segment_ptr                          parameter       pointer                  dcl 64 ref 40 111 124 130 148 157 162
P_source_info_ptr                      parameter       pointer                  dcl 640 ref 634 645 649 649 649 656 657 658 659 660
                                                                                  661
addr                                                   builtin function         dcl 105 ref 267 267 516 516
addrel                                                 builtin function         dcl 105 ref 355 358 371 375 408 469 539 718
area_pointer             16(18)        based           bit(18)                  level 2 packed packed unaligned dcl 8-1 ref 358 408
based_string                           based           char                     packed unaligned dcl 322 ref 371
based_string_lth                000400 automatic       fixed bin(21,0)          dcl 321 set ref 370* 371
baseno                                                 builtin function         dcl 105 ref 164 195 608 608 649 649 649
binary                                                 builtin function         dcl 105 ref 164 194 195 649 649 649 720 720
bindmap_ptr                     000414 automatic       pointer                  dcl 405 set ref 408* 428
bitcount                        000364 automatic       fixed bin(24,0)          dcl 230 set ref 261* 267*
bits                     21            based           structure                level 2 in structure "probe_modes" dcl 3-14
                                                                                  in procedure "probe_seg_info_"
bits                      1            based           structure                level 2 in structure "seg_info" dcl 4-9 in procedure
                                                                                  "probe_seg_info_" set ref 418* 479* 557*
block_ptr                 4            based           pointer                  level 2 dcl 641 set ref 649 658*
bound                    24(01) 000202 automatic       bit(1)                   level 3 packed packed unaligned dcl 84 set ref 276
bound_create_time       112            based           fixed bin(71,0)          level 2 dcl 4-9 set ref 332*
bound_segment             1(01)        based           bit(1)                   level 3 packed packed unaligned dcl 4-9 set ref 233
                                                                                  419* 600
bound_sym_header        114            based           pointer                  level 2 packed packed unaligned dcl 4-9 set ref 331*
bounds                  104            based           structure                level 2 dcl 4-9
break_info              101            based           pointer                  level 3 packed packed unaligned dcl 4-9 set ref 327*
                                                                                  430*
bsinfo                          000110 automatic       pointer                  dcl 77 set ref 238* 412* 414 415 417 418 419 422 423
                                                                                  424 425 427 428 429 430 431 432 435 436 437 438
                                                                                  440 441 442 444 561 562 576 578 747
chain                   102            based           pointer                  level 3 packed packed unaligned dcl 4-9 set ref 431*
                                                                                  492* 576* 576 578* 606 747 752
ci                              000274 automatic       structure                level 1 dcl 13-3 set ref 516 516
code                            000114 automatic       fixed bin(35,0)          dcl 79 set ref 119 133 186* 255* 257 261* 262 267*
                                                                                  269 284* 360* 361 385* 386 516* 518 524*
comment                  14            based           structure                level 2 packed packed unaligned dcl 8-1
commentp                        000514 automatic       pointer                  dcl 715 set ref 718* 720 720
compile_time             32     000274 automatic       fixed bin(71,0)          level 2 dcl 13-3 set ref 564
compiler_comment                       based           char                     packed unaligned dcl 712 ref 720 720
component                 1(02)        based           bit(1)                   level 3 packed packed unaligned dcl 4-9 set ref 558*
component_info_$offset          000024 constant        entry                    external dcl 97 ref 516
ct_info                         000442 automatic       pointer                  dcl 509 set ref 550* 554 555 557 558 561 562 564 566
                                                                                  567 569 570 572 573 576 578 580
debug                    21(08)        based           bit(1)                   level 3 packed packed unaligned dcl 3-14 ref 695
directory_name                  000115 automatic       char(168)                packed unaligned dcl 80 in procedure
                                                                                  "probe_seg_info_" set ref 255* 422 481
directory_name            2            based           char(168)                level 3 in structure "seg_info" packed packed
                                                                                  unaligned dcl 4-9 in procedure "probe_seg_info_"
                                                                                  set ref 422* 481* 561* 561
divide                                                 builtin function         dcl 105 ref 380
end                     107            based           fixed bin(35,0)          level 4 in structure "seg_info" dcl 4-9 in procedure
                                                                                  "probe_seg_info_" set ref 438* 491* 573* 762
end                     105            based           fixed bin(35,0)          level 4 in structure "seg_info" dcl 4-9 in procedure
                                                                                  "probe_seg_info_" set ref 436* 489* 570* 762
entry_method             23            based           fixed bin(17,0)          level 3 dcl 1-18 set ref 205 208*
entry_name                      000167 automatic       char(32)                 packed unaligned dcl 81 in procedure
                                                                                  "probe_seg_info_" set ref 197* 255* 423 482
entry_name               54            based           char(32)                 level 3 in structure "seg_info" packed packed
                                                                                  unaligned dcl 4-9 in procedure "probe_seg_info_"
                                                                                  set ref 141 141 423* 482* 562* 562
entry_ptr                10            based           pointer                  level 2 dcl 641 set ref 649 657*
error_code              111            based           fixed bin(35,0)          level 2 dcl 4-9 set ref 330* 361* 386* 441*
file_pointers           117            based           pointer                  array level 3 packed packed unaligned dcl 4-9 set
                                                                                  ref 415* 477* 555*
first                     6            based           bit(18)                  level 3 packed packed unaligned dcl 9-1 ref 374 375
                                                                                  377
fixed                                                  builtin function         dcl 105 ref 370 377 377 569 570 572 573
flags                    52            based           structure                level 3 dcl 2-8
flush_source                           based           structure                level 1 dcl 641
format                   24     000202 automatic       structure                level 2 dcl 84
generator                10            based           char(8)                  level 2 dcl 8-1 ref 344
good_stack               52            based           bit(1)                   level 4 packed packed unaligned dcl 2-8 set ref 626*
hcs_$fs_get_path_name           000020 constant        entry                    external dcl 93 ref 255
hcs_$status_mins                000022 constant        entry                    external dcl 95 ref 261
hdr                             000112 automatic       pointer                  dcl 78 in procedure "probe_seg_info_" set ref 204*
                                                                                  205* 273* 274 331 408 408 427 462 469 469 485
hdr                                    parameter       pointer                  dcl 729 in procedure "seg_changedp" ref 725 732 734
hdr_ptr                         000376 automatic       pointer                  dcl 320 in procedure "fill_in_info" set ref 341* 344
                                                                                  351* 355 355 358 358 371 375
hdr_ptr                         000444 automatic       pointer                  dcl 510 in procedure "create_component_seg_info" set
                                                                                  ref 529* 531 539 539 566
identifier               74            based           fixed bin(71,0)          level 2 in structure "seg_info" dcl 4-9 in procedure
                                                                                  "probe_seg_info_" set ref 236 425* 483* 564* 734
identifier                1            based           char(8)                  level 2 in structure "pl1_symbol_block" dcl 9-1
                                                                                  in procedure "probe_seg_info_" ref 359
ignore_case               1            based           bit(1)                   level 3 packed packed unaligned dcl 4-9 set ref 347*
                                                                                  351*
index                                                  builtin function         dcl 105 ref 720 720
info                            000100 automatic       pointer                  dcl 70 set ref 115 115* 120 135 138 138 141 141 166*
                                                                                  169* 189* 198* 202* 204 205* 213* 217 232 233 236
                                                                                  238 240* 241 293 307* 326 327 329 330 331 332 339
                                                                                  341 345 347 351 355 361 363 364 366 371 375 380
                                                                                  386 387 389 494* 519* 525* 580* 593 594* 600 600
                                                                                  605* 605 605* 606 608 608* 614* 676 676
infop                                  parameter       pointer                  dcl 728 ref 725 734
instruction_ptr           2            based           pointer                  level 2 dcl 641 set ref 649 656*
language_type                          based           fixed bin(17,0)          level 2 dcl 4-9 set ref 345* 417*
last                      6(18)        based           bit(18)                  level 3 packed packed unaligned dcl 9-1 ref 377
linkage_ptr             103            based           pointer                  level 3 packed packed unaligned dcl 4-9 set ref 326*
                                                                                  432* 676 676*
listener_info           210            based           structure                level 2 dcl 1-18
lot                                    based           structure                level 1 dcl 14-6
lot_fault                              constant        bit(36)                  initial dcl 14-9 ref 694
lot_ptr                  26            based           pointer                  level 2 dcl 15-26 ref 692
lotp                            000344 automatic       pointer                  dcl 14-4 set ref 692* 694 701
lp                                     based           pointer                  array level 2 packed packed unaligned dcl 14-6 ref
                                                                                  694 701
ltype                           000374 automatic       fixed bin(17,0)          dcl 319 set ref 344* 345 347 347 351
map                       6            based           structure                level 2 packed packed unaligned dcl 9-1
map_length                      000404 automatic       fixed bin(21,0)          dcl 324 set ref 377* 380
map_size                110            based           fixed bin(17,0)          level 2 dcl 4-9 set ref 329* 366* 380* 389* 440*
modes_ptr                 2            based           pointer                  level 2 packed packed unaligned dcl 1-18 ref 695
names                     2            based           structure                level 2 dcl 4-9
next_info                       000462 automatic       pointer                  dcl 591 set ref 606* 611
nfiles                  116            based           fixed bin(17,0)          level 2 dcl 4-9 set ref 412* 414* 415 474* 476* 477
                                                                                  550* 554* 555 600 608
null                                                   builtin function         dcl 105 ref 115 135 157 166 188 198 213 217 232 241
                                                                                  293 307 327 364 387 415 429 430 431 464 477 492
                                                                                  519 525 533 555 593 605 614 618 645 656 657 658
                                                                                  659 676 699 732 747 753
null_seg_info_ptr       103            based           pointer                  level 2 packed packed unaligned dcl 2-8 ref 115 189
                                                                                  661
number                    1            based           fixed bin(17,0)          level 2 dcl 7-3 ref 470 545
object_created            6            based           fixed bin(71,0)          level 2 dcl 8-1 ref 274 734
object_info                            based           structure                level 1 dcl 12-6
object_info_$display            000026 constant        entry                    external dcl 99 ref 267
object_info_version_2                  constant        fixed bin(17,0)          initial dcl 12-60 ref 266
offset                   14            based           bit(18)                  level 3 in structure "std_symbol_header" packed
                                                                                  packed unaligned dcl 8-1 in procedure
                                                                                  "probe_seg_info_" ref 718
offset                          000106 automatic       bit(18)                  packed unaligned dcl 76 in procedure
                                                                                  "probe_seg_info_" set ref 199* 201 202
offset                    7            based           bit(18)                  level 3 in structure "pl1_symbol_block" packed
                                                                                  packed unaligned dcl 9-1 in procedure
                                                                                  "probe_seg_info_" ref 371
oi                              000202 automatic       structure                level 1 dcl 84 set ref 267 267
old_format               24     000202 automatic       bit(1)                   level 3 packed packed unaligned dcl 84 set ref 283
original_source_ptr      77            based           pointer                  level 3 packed packed unaligned dcl 4-9 set ref 355*
                                                                                  428* 486* 567*
pad                     115            based           fixed bin(35,0)          array level 2 dcl 4-9 set ref 339* 442*
per_file                117            based           structure                array level 2 dcl 4-9
pi_ptr                          000460 automatic       pointer                  dcl 590 set ref 617* 618 619 621 623* 623
pl1                             000402 automatic       pointer                  dcl 323 set ref 358* 359 370 371 374 375 377 377
pl1_symbol_block                       based           structure                level 1 dcl 9-1
pointer                                                builtin function         dcl 105 ref 162 169 202 267 267 516 516 594
pointers                 76            based           structure                level 2 dcl 4-9
previous                233            based           pointer                  level 3 packed packed unaligned dcl 1-18 ref 623
probe_area_info          56            based           structure                level 2 dcl 1-18
probe_error_$warning            000030 constant        entry                    external dcl 102 ref 695
probe_et_$no_map                000016 external static fixed bin(35,0)          dcl 86 ref 385
probe_et_$no_table              000012 external static fixed bin(35,0)          dcl 86 ref 360
probe_et_$non_standard          000010 external static fixed bin(35,0)          dcl 86 ref 524
probe_et_$old_format            000014 external static fixed bin(35,0)          dcl 86 ref 284
probe_info                             based           structure                level 1 dcl 1-18
probe_info_ptr                  000270 automatic       pointer                  dcl 1-86 set ref 110* 115 129* 161* 166 169 169 189
                                                                                  199 202 205 208 412 444 474 495 550 594 594 597
                                                                                  600 608 608 617 626 661 695 695*
probe_lang_type_                000032 constant        entry                    external dcl 103 ref 344
probe_modes                            based           structure                level 1 dcl 3-14
probe_seg_info_array                   based           structure                level 1 dcl 2-82
probe_static_info                      based           structure                level 1 dcl 2-8
ptr_to_current_source
                          4            based           pointer                  level 2 dcl 1-18 set ref 621*
ptr_to_initial_source
                          6            based           pointer                  level 2 dcl 1-18 set ref 619*
random_info              17            based           structure                level 2 dcl 1-18
rel                                                    builtin function         dcl 105 ref 194 444 495 569 570 572 573
scratch_area                           based           area(1024)               dcl 1-92 ref 412 474 550 600 608
scratch_area_ptr         60            based           pointer                  level 3 packed packed unaligned dcl 1-18 ref 169 202
                                                                                  412 474 550 594 600 608 608
seg_info                               based           structure                level 1 dcl 4-9 set ref 412 474 550 600 608
seg_info_nfiles                 000272 automatic       fixed bin(17,0)          dcl 4-47 set ref 410* 412 412 414 465* 470* 474 474
                                                                                  476 535* 545* 546 546 550 550 554
seg_info_offset           1            based           bit(18)                  array level 2 dcl 2-82 set ref 166 169 199 444* 495*
                                                                                  594 597*
seg_info_offset_ptr      44            based           pointer                  level 2 dcl 2-8 ref 166 169 199 444 495 594 597
seg_info_ptr             12            based           pointer                  level 2 dcl 641 set ref 661*
seginfop                        000532 automatic       pointer                  dcl 744 set ref 747* 747* 749* 749* 752
segment_number                  000104 automatic       fixed bin(17,0)          dcl 73 set ref 164* 166 169 195* 199 444 495 594 597
                                                                                  649 649 649 694 695* 701
segment_offset                  000105 automatic       fixed bin(35,0)          dcl 74 set ref 194* 516 749*
segment_ptr                     000102 automatic       pointer                  dcl 72 set ref 111* 130* 162* 164 188 194 195 255*
                                                                                  261* 267 267 516 516
segname                   7            based           structure                level 2 in structure "pl1_symbol_block" packed
                                                                                  packed unaligned dcl 9-1 in procedure
                                                                                  "probe_seg_info_"
segname                  64            based           char(32)                 level 3 in structure "seg_info" packed packed
                                                                                  unaligned dcl 4-9 in procedure "probe_seg_info_"
                                                                                  set ref 138 138 363* 371* 424*
sip                                    parameter       pointer                  dcl 758 ref 756 762 762 762 762
size                      7(18)        based           bit(18)                  level 3 in structure "pl1_symbol_block" packed
                                                                                  packed unaligned dcl 9-1 in procedure
                                                                                  "probe_seg_info_" ref 370
size                                                   builtin function         dcl 105 in procedure "probe_seg_info_" ref 380
size                     14(18)        based           bit(18)                  level 3 in structure "std_symbol_header" packed
                                                                                  packed unaligned dcl 8-1 in procedure
                                                                                  "probe_seg_info_" ref 720 720
so                                     parameter       fixed bin(35,0)          dcl 759 ref 756 762 762 762 762
source_info                            based           structure                level 1 dcl 5-5
source_map               16            based           bit(18)                  level 2 in structure "std_symbol_header" packed
                                                                                  packed unaligned dcl 8-1 in procedure
                                                                                  "probe_seg_info_" ref 355 462 469 531 539
source_map                             based           structure                level 1 dcl 7-3 in procedure "probe_seg_info_"
source_map_ptr                  000426 automatic       pointer                  dcl 458 in procedure "create_unbound_seg_info" set
                                                                                  ref 464* 469* 470 486
source_map_ptr                  000446 automatic       pointer                  dcl 511 in procedure "create_component_seg_info" set
                                                                                  ref 533* 539* 541 541 545 567
stack_header                           based           structure                level 1 dcl 15-26
stack_info               50            based           structure                level 2 dcl 2-8
stack_ptr                 6            based           pointer                  level 2 dcl 641 set ref 659*
stackbaseptr                                           builtin function         dcl 105 ref 692
standard                 26     000274 automatic       bit(1)                   level 2 dcl 13-3 set ref 523
start                   104            based           fixed bin(35,0)          level 4 in structure "seg_info" dcl 4-9 in procedure
                                                                                  "probe_seg_info_" set ref 435* 488* 569* 762
start                   106            based           fixed bin(35,0)          level 4 in structure "seg_info" dcl 4-9 in procedure
                                                                                  "probe_seg_info_" set ref 437* 490* 572* 762
statement_map                          based           structure                level 1 dcl 10-1 ref 380
statement_map_ptr       100            based           pointer                  level 3 packed packed unaligned dcl 4-9 set ref 364*
                                                                                  375* 387* 429*
static_info_ptr           1            based           pointer                  level 2 packed packed unaligned dcl 1-18 ref 115 166
                                                                                  169 189 199 444 495 594 597 626 661
std_symbol_header                      based           structure                level 1 dcl 8-1
stmnt_map_entry_index                  based           fixed bin(17,0)          level 2 dcl 641 set ref 660*
symb_lng                 24     000274 automatic       fixed bin(17,0)          level 2 dcl 13-3 set ref 573
symb_start               16     000274 automatic       pointer                  level 2 dcl 13-3 set ref 529 572 573
symbol_bounds           106            based           structure                level 3 dcl 4-9
symbol_header_ptr        76            based           pointer                  level 3 packed packed unaligned dcl 4-9 set ref 204
                                                                                  341 427* 485* 566*
symbp                    12     000202 automatic       pointer                  level 2 dcl 84 set ref 273
text_bounds             104            based           structure                level 3 dcl 4-9
text_lng                 22     000274 automatic       fixed bin(17,0)          level 2 dcl 13-3 set ref 570
text_start               12     000274 automatic       pointer                  level 2 dcl 13-3 set ref 569 570
time_created                    000200 automatic       fixed bin(71,0)          dcl 82 set ref 236* 274* 332 425 483
ub_info                         000430 automatic       pointer                  dcl 459 set ref 474* 476 477 479 481 482 483 485 486
                                                                                  488 489 490 491 492 494 495
unspec                                                 builtin function         dcl 105 ref 694
version                                based           fixed bin(17,0)          level 2 dcl 7-3 ref 541 541
version_number                  000202 automatic       fixed bin(17,0)          level 2 dcl 84 set ref 266*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALGOL68_lang_type                      internal static fixed bin(17,0)          initial dcl 6-17
ALM_lang_type                          internal static fixed bin(17,0)          initial dcl 6-17
BRIEF_mode_type                        internal static fixed bin(17,0)          initial dcl 3-35
C_lang_type                            internal static fixed bin(17,0)          initial dcl 6-17
LONG_mode_type                         internal static fixed bin(17,0)          initial dcl 3-35
PL1_lang_type                          internal static fixed bin(17,0)          initial dcl 6-17
SHORT_mode_type                        internal static fixed bin(17,0)          initial dcl 3-35
UNKNOWN_lang_type                      internal static fixed bin(17,0)          initial dcl 6-17
call_offset                            internal static fixed bin(17,0)          initial dcl 15-78
current_source                         based           structure                level 1 dcl 5-13
encoded_value                          based           structure                level 1 dcl 11-70
entry_offset                           internal static fixed bin(17,0)          initial dcl 15-78
expression_area                        based           area(1024)               dcl 1-95
initial_source                         based           structure                level 1 dcl 5-14
isot                                   based           structure                level 1 dcl 14-13
isot1                                  based           structure                array level 1 dcl 14-16
isotp                                  automatic       pointer                  dcl 14-12
official_language_names                internal static char(32)                 initial array packed unaligned dcl 6-27
palatable_language_names               internal static char(32)                 initial array packed unaligned dcl 6-30
probe_area                             based           area(1024)               dcl 1-93
probe_exclude_names                    based           char(168)                array packed unaligned dcl 2-94
probe_info_directories                 based           char(168)                array packed unaligned dcl 2-91
probe_info_version                     internal static fixed bin(17,0)          initial dcl 1-88
probe_info_version_1                   internal static fixed bin(17,0)          initial dcl 1-90
probe_request_tables                   based           pointer                  array dcl 2-88
push_offset                            internal static fixed bin(17,0)          initial dcl 15-78
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 15-78
return_offset                          internal static fixed bin(17,0)          initial dcl 15-78
runtime_block                          based           structure                level 1 dcl 11-38
runtime_bound                          based           structure                level 1 unaligned dcl 11-33
runtime_symbol                         based           structure                level 1 dcl 11-3
runtime_token                          based           structure                level 1 dcl 11-63
sb                                     automatic       pointer                  dcl 15-24
seg_info_offset_count                  automatic       fixed bin(17,0)          dcl 2-86
stack_header_overlay                   based           fixed bin(17,0)          array dcl 15-94
tv_offset                              internal static fixed bin(17,0)          initial dcl 15-72
work_area                              based           area(1024)               dcl 1-94

NAMES DECLARED BY EXPLICIT CONTEXT.
MAJOR_LOSSAGE                   000627 constant        label                    dcl 307 ref 257 262 269 285 293
NO_SOURCE_MAP                   001350 constant        label                    dcl 533 ref 541 546
create_bound_seg_info           001033 constant        entry                    internal dcl 397 ref 277
create_component_seg_info       001300 constant        entry                    internal dcl 503 ref 245 278
create_unbound_seg_info         001166 constant        entry                    internal dcl 451 ref 288
fill_in_info                    000632 constant        entry                    internal dcl 314 ref 303
flush_source_info               001623 constant        entry                    internal dcl 634 ref 619 621
free_seg_info                   001472 constant        entry                    internal dcl 587 ref 173 205
get_current_runtime_info        001677 constant        entry                    internal dcl 669 ref 217
get_info_pointer                000351 constant        entry                    internal dcl 178 ref 113 132
get_linkage_ptr                 001712 constant        entry                    internal dcl 685 ref 326 432 676
get_seg_info                    000446 constant        entry                    internal dcl 225 ref 209 214
ignore_casep                    001770 constant        entry                    internal dcl 707 ref 351
inside                          002105 constant        entry                    internal dcl 756 ref 749
probe_seg_info_                 000055 constant        entry                    external dcl 40
probe_seg_info_$flush           000264 constant        entry                    external dcl 148
probe_seg_info_$name            000130 constant        entry                    external dcl 124
search_bound_info               002053 constant        entry                    internal dcl 741 ref 240
seg_changedp                    002026 constant        entry                    internal dcl 725 ref 205

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2406        2442    2206        2416
Length      3124    2206        34         445     177           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
probe_seg_info_                     473 external procedure  is an external procedure.  
get_info_pointer                        internal procedure  shares stack frame of external procedure probe_seg_info_.  
get_seg_info                            internal procedure  shares stack frame of external procedure probe_seg_info_.  
fill_in_info                            internal procedure  shares stack frame of external procedure probe_seg_info_.  
create_bound_seg_info                   internal procedure  shares stack frame of external procedure probe_seg_info_.  
create_unbound_seg_info                 internal procedure  shares stack frame of external procedure probe_seg_info_.  
create_component_seg_info               internal procedure  shares stack frame of external procedure probe_seg_info_.  
free_seg_info                           internal procedure  shares stack frame of external procedure probe_seg_info_.  
flush_source_info                       internal procedure  shares stack frame of external procedure probe_seg_info_.  
get_current_runtime_info                internal procedure  shares stack frame of external procedure probe_seg_info_.  
get_linkage_ptr                         internal procedure  shares stack frame of external procedure probe_seg_info_.  
ignore_casep                            internal procedure  shares stack frame of external procedure probe_seg_info_.  
seg_changedp                            internal procedure  shares stack frame of external procedure probe_seg_info_.  
search_bound_info                       internal procedure  shares stack frame of external procedure probe_seg_info_.  
inside                                  internal procedure  shares stack frame of external procedure probe_seg_info_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
probe_seg_info_          000100 info                        probe_seg_info_
                         000102 segment_ptr                 probe_seg_info_
                         000104 segment_number              probe_seg_info_
                         000105 segment_offset              probe_seg_info_
                         000106 offset                      probe_seg_info_
                         000110 bsinfo                      probe_seg_info_
                         000112 hdr                         probe_seg_info_
                         000114 code                        probe_seg_info_
                         000115 directory_name              probe_seg_info_
                         000167 entry_name                  probe_seg_info_
                         000200 time_created                probe_seg_info_
                         000202 oi                          probe_seg_info_
                         000270 probe_info_ptr              probe_seg_info_
                         000272 seg_info_nfiles             probe_seg_info_
                         000274 ci                          probe_seg_info_
                         000344 lotp                        probe_seg_info_
                         000364 bitcount                    get_seg_info
                         000374 ltype                       fill_in_info
                         000376 hdr_ptr                     fill_in_info
                         000400 based_string_lth            fill_in_info
                         000402 pl1                         fill_in_info
                         000404 map_length                  fill_in_info
                         000414 bindmap_ptr                 create_bound_seg_info
                         000426 source_map_ptr              create_unbound_seg_info
                         000430 ub_info                     create_unbound_seg_info
                         000442 ct_info                     create_component_seg_info
                         000444 hdr_ptr                     create_component_seg_info
                         000446 source_map_ptr              create_component_seg_info
                         000460 pi_ptr                      free_seg_info
                         000462 next_info                   free_seg_info
                         000514 commentp                    ignore_casep
                         000532 seginfop                    search_bound_info

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              r_le_a              r_ge_a              call_ext_out_desc   call_ext_out
return_mac          signal_op           ext_entry           set_chars_eis       index_chars_eis     op_alloc_
op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
component_info_$offset        hcs_$fs_get_path_name         hcs_$status_mins              object_info_$display
probe_error_$warning          probe_lang_type_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
probe_et_$no_map              probe_et_$no_table            probe_et_$non_standard        probe_et_$old_format




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     40 000050       110 000064       111 000070       113 000073       115 000074       119 000104       120 000107
    124 000123       129 000137       130 000143       132 000146       133 000147       135 000152       138 000173
    141 000216       144 000241       148 000257       157 000272       158 000277       161 000307       162 000313
    164 000316       166 000322       169 000332       173 000337       174 000340       803 000350       178 000351
    186 000352       188 000353       189 000357       191 000363       194 000364       195 000367       197 000373
    198 000376       199 000400       201 000406       202 000407       204 000414       205 000416       208 000433
    209 000435       210 000436       214 000437       217 000440       220 000445       225 000446       232 000447
    233 000453       236 000457       238 000461       240 000462       241 000464       245 000471       247 000472
    249 000473       251 000474       255 000475       257 000527       261 000531       262 000547       266 000551
    267 000553       269 000574       273 000576       274 000600       276 000603       277 000606       278 000607
    280 000610       283 000611       284 000614       285 000617       288 000620       293 000621       303 000625
    304 000626       307 000627       309 000631       314 000632       326 000633       327 000640       329 000642
    330 000643       331 000644       332 000646       339 000650       341 000661       344 000663       345 000703
    347 000705       351 000715       355 000727       358 000736       359 000743       360 000752       361 000755
    363 000756       364 000761       366 000763       367 000764       370 000765       371 000770       374 001000
    375 001004       377 001007       380 001015       382 001020       385 001022       386 001025       387 001026
    389 001030       390 001031       392 001032       397 001033       408 001034       410 001042       412 001044
    415 001057       417 001074       418 001076       419 001106       422 001110       423 001113       424 001116
    425 001121       427 001123       428 001125       429 001127       430 001131       431 001132       432 001133
    435 001140       436 001141       437 001142       438 001143       440 001144       441 001145       442 001146
    444 001157       446 001165       451 001166       462 001167       464 001174       465 001176       466 001200
    469 001201       470 001204       474 001206       477 001221       479 001236       481 001246       482 001251
    483 001254       485 001256       486 001260       488 001262       489 001263       490 001264       491 001265
    492 001266       494 001270       495 001271       497 001277       503 001300       516 001301       518 001324
    519 001326       520 001330       523 001331       524 001333       525 001336       526 001340       529 001341
    531 001343       533 001350       535 001352       536 001354       539 001355       541 001360       545 001365
    546 001367       550 001373       555 001406       557 001422       558 001432       561 001434       562 001440
    564 001443       566 001445       567 001447       569 001451       570 001454       572 001457       573 001462
    576 001465       578 001467       580 001470       582 001471       587 001472       593 001473       594 001477
    597 001511       600 001515       605 001531       606 001536       608 001541       611 001560       614 001563
    617 001565       618 001567       619 001574       621 001603       623 001612       624 001615       626 001616
    629 001622       634 001623       645 001625       649 001632       656 001653       657 001655       658 001660
    659 001663       660 001666       661 001671       663 001676       669 001677       676 001700       680 001711
    685 001712       692 001714       694 001717       695 001723       699 001761       701 001765       707 001770
    718 001772       720 002001       725 002026       732 002030       734 002037       736 002051       741 002053
    747 002055       749 002064       752 002075       753 002101       756 002105       762 002107


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
