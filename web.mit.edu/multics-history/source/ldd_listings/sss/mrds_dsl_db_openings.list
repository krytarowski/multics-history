	COMPILATION LISTING OF SEGMENT mrds_dsl_db_openings
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1331.9 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 mrds_dsl_db_openings: list_dbs: procedure (a_area_ptr, database_list_ptr);
       19 
       20 /* DESCRIPTION:
       21*
       22*   This routine has two entries, list_dbs  which  is  obsolete,  and
       23*   list_openings  which extends the returned info to include opening
       24*   mode and type of opening (model or submodel). this  routine  will
       25*   return  an  array  of  database  indexes, and pathnames for those
       26*   databases that are currently open by this process.  if  none  are
       27*   open, a null pointer is returned. an area must be provided by the
       28*   user that is a minimum 50 words for  each  open  database,  or  a
       29*   maximum 4800 words, not counting the area header overhead of 24+2
       30*   words for 1 database
       31*
       32**/
       33 
       34 /* PARAMETERS:
       35*
       36*   ===== list_dbs entry
       37*
       38*   area_ptr - - (input) pointer to an area in which to allocate  the
       39*   database_list  structure  of open database pathnames and indexes.
       40*   it should be declared 4800 words long to handle the general case.
       41*
       42*   database_list_ptr -  -  (output)  pointer  to  the  database_list
       43*   structure  which  is an array of pathnames, database indexes, and
       44*   opening modes for the databases open in this process. the pointer
       45*   is    null   if   none   are   open.   use   the   include   file
       46*   mrds_database_list.incl.pl1 for the returned structure.
       47*
       48*
       49*   ===== get_openings entry
       50*
       51*   area_ptr - - (input) pointer to a user supplied area large enough
       52*   to hold the expected number of open database information details.
       53*
       54*   structure_version - - (input) fixed bin, the desired  version  of
       55*   the open information structure.
       56*
       57*   mrds_database_openings_ptr - - (output) pointer,  points  to  the
       58*   structure       defined       in       the      include      file
       59*   mrds_database_openings.incl.pl1 which has been allocated  in  the
       60*   users area.
       61*
       62*   error_code - - (output) fixed bin(35), error status  encoding,  0
       63*   unless an error occured. No error is returned if no databases are
       64*   currently open, the structure is  still  allocated,  but  with  a
       65*   number  open of 0. If the error code is not 0, then the structure
       66*   is not allocated, and the pointer will be null.
       67*
       68**/
       69 
       70 /* HISTORY:
       71*
       72*   79-07-01 Jim Gray: Initially written.
       73*
       74*   80-12-08 Rickie E. Brinegar: The opening mode was  added  to  the
       75*   mrds_dbs_modes_list.incl.pl1 include file and the new entry point
       76*   list_dbs_with_modes was added.
       77*
       78*   80-12-12 Jim Gray : Added separate entry parameters for the  area
       79*   pointer,  because occasionaly the wrong parameter list was looked
       80*   at for getting this pointer, and the result was a bunch  of  null
       81*   characters  for a database path. Also increased size of area from
       82*   3200 to 4800 to handle additional mode info for the possible  max
       83*   of  64 open dbs, each with 168 char paths. Also found that the do
       84*   loop in the second entry was using number_of_openings, which  was
       85*   never    initialized    in   that   entry,   instead   of   using
       86*   number_of_db_open.
       87*
       88*   81-01-30   Jim   Gray   :   changed   name   of   routine    from
       89*   mrds_dsl_list_dbs  to  mrds_dsl_db_openings,  and  name  of entry
       90*   list_dbs_with_modes to list_openings to be compatibile  with  new
       91*   include file mrds_database_openings replacing mrds_dbs_modes_list
       92*   as part of effort to  make  the  user  interface  extensible  and
       93*   maintainable.  The  interface  was  also  changed  to  agree with
       94*   project standards.
       95*
       96*   81-04-24 Jim Gray : changed  area  size  to  be  proportional  to
       97*   mrds_data_$max_dbs
       98**/
       99 
      100 	number_of_openings = mu_database_index$get_number_open_dbs ();
      101 
      102 	if number_of_openings = 0 then
      103 	     database_list_ptr = null ();
      104 	else do;
      105 
      106 		area_ptr = a_area_ptr;		/* get local version for this entry */
      107 		allocate database_list set (database_list_ptr) in (based_area);
      108 
      109 		database_list.number_open = number_of_openings;
      110 
      111 		number_found = 0;
      112 		do db_index = 1 by 1 to mrds_data_$max_dbs while (number_found < number_of_openings);
      113 
      114 		     call mu_database_index$get_resultant_model_pointer (db_index, dbcb_ptr);
      115 
      116 		     if dbcb_ptr = null () then ;	/* not valid index */
      117 		     else do;
      118 
      119 			     rdbi_ptr = dbcb_ptr -> dbcb.rdbi_ptr;
      120 			     if rdbi_ptr = null () then
      121 				pathname = "PATH NOT AVAIABLE";
      122 			     else pathname = rdbi_ptr -> rm_db_info.sm_path;
      123 
      124 			     number_found = number_found + 1;
      125 
      126 			     database_list (number_found).index = db_index;
      127 			     database_list (number_found).path = pathname;
      128 			end;
      129 
      130 		end;
      131 
      132 	     end;
      133 
      134 	return;
      135 
      136 list_openings: entry (b_area_ptr, structure_version, mrds_database_openings_ptr, error_code);
      137 
      138 /* initialize */
      139 
      140 	error_code = 0;
      141 	mrds_database_openings_ptr = null ();
      142 
      143 	mrds_database_openings_num_open_init = mu_database_index$get_number_open_dbs ();
      144 
      145 /* check the users arguments */
      146 
      147 	if structure_version ^= mrds_database_openings_structure_version then
      148 	     error_code = error_table_$unimplemented_version;
      149 	else if b_area_ptr = null () then
      150 	     error_code = error_table_$badcall;
      151 	else do;
      152 
      153 		area_ptr = b_area_ptr;		/* get local version for this entry */
      154 		unspec (my_area_info) = "0"b;
      155 		my_area_info.version = 1;
      156 		my_area_info.areap = area_ptr;
      157 
      158 		call area_info_ (addr (my_area_info), error_code);
      159 		if error_code ^= 0 then ;
      160 		else if my_area_info.no_freeing then
      161 		     error_code = mrds_error_$not_freeing_area;
      162 		else do;
      163 
      164 /* fill in the users structure */
      165 
      166 			on area begin;
      167 				error_code = error_table_$area_too_small;
      168 				goto skip_allocate;
      169 			     end;
      170 
      171 			on cleanup begin;
      172 				if mrds_database_openings_ptr ^= null () then do;
      173 					free mrds_database_openings in (based_area);
      174 					mrds_database_openings_ptr = null ();
      175 				     end;
      176 			     end;
      177 
      178 			allocate mrds_database_openings set (mrds_database_openings_ptr) in (based_area);
      179 
      180 			revert area;
      181 
      182 			unspec (mrds_database_openings) = "0"b;
      183 			mrds_database_openings.version = mrds_database_openings_structure_version;
      184 			mrds_database_openings.number_open = mrds_database_openings_num_open_init;
      185 
      186 			number_found = 0;
      187 			do db_index = 1 by 1 to mrds_data_$max_dbs
      188 			     while (number_found < mrds_database_openings_num_open_init);
      189 
      190 			     call mu_database_index$get_resultant_model_pointer (db_index, dbcb_ptr);
      191 
      192 			     if dbcb_ptr = null () then ; /* not valid index */
      193 			     else do;
      194 
      195 				     rdbi_ptr = dbcb_ptr -> dbcb.rdbi_ptr;
      196 				     if rdbi_ptr = null () then
      197 					pathname = "PATH NOT AVAIABLE";
      198 				     else pathname = rdbi_ptr -> rm_db_info.sm_path;
      199 
      200 				     number_found = number_found + 1;
      201 
      202 				     mrds_database_openings (number_found).index = db_index;
      203 				     mrds_database_openings (number_found).path = pathname;
      204 				     if dbcb.dsm_sw then
      205 					mrds_database_openings (number_found).submodel = "1"b;
      206 				     else mrds_database_openings (number_found).model = "1"b;
      207 
      208 /* set the mode argument */
      209 
      210 				     mode_code = fixed (dbcb.open_mode);
      211 				     if mode_code = 0 then
      212 					mrds_database_openings (number_found).mode = "Mode not available";
      213 				     else if mode_code = 1 then
      214 					mrds_database_openings (number_found).mode = "retrieval";
      215 				     else if mode_code = 2 then
      216 					mrds_database_openings (number_found).mode = "update";
      217 				     else if mode_code = 3 then
      218 					mrds_database_openings (number_found).mode = "exclusive_retrieval";
      219 				     else if mode_code = 4 then
      220 					mrds_database_openings (number_found).mode = "exclusive_update";
      221 				     else mrds_database_openings (number_found).mode = "Unknown opening mode";
      222 
      223 
      224 				end;
      225 
      226 			end;
      227 
      228 		     end;
      229 
      230 	     end;
      231 
      232 skip_allocate:
      233 
      234 	return;
      235 
      236 	declare a_area_ptr		 ptr;		/* for main entry */
      237 	declare area		 condition;	/* signaled if space too small */
      238 	declare area_info_		 entry (ptr, fixed bin (35)); /* gets area details */
      239 	declare area_ptr		 ptr;		/* pointer to users area */
      240 	declare b_area_ptr		 ptr;		/* for get_path_info entry */
      241 	declare based_area		 area (60 * mrds_data_$max_dbs) based (area_ptr); /* overlay for users area */
      242 	declare cleanup		 condition;
      243 	declare db_index		 fixed bin (35);	/* database index loop control */
      244 	declare error_code		 fixed bin (35);	/* error status encoding */
      245 	declare error_table_$area_too_small fixed bin (35) ext; /* not enough space for structure */
      246 	declare error_table_$badcall	 fixed bin (35) ext;/* null area ptr */
      247 	declare error_table_$unimplemented_version fixed bin (35) ext; /* unknown structure version */
      248 	declare mu_database_index$get_number_open_dbs entry returns (fixed bin); /* gets count of db's open by this process */
      249 	declare mu_database_index$get_resultant_model_pointer entry (fixed bin (35), ptr); /* get dbcb ptr from table */
      250 	declare mode_code		 fixed bin;	/* code for the opening mode */
      251 	declare mrds_data_$max_dbs	 fixed bin (35) ext;/* max number of allowed openings */
      252 	declare mrds_error_$not_freeing_area fixed bin (35) ext; /* area not freeable */
      253 	declare number_found	 fixed bin;	/* current count of found database openings */
      254 	declare pathname		 char (168);	/* pathname of database model/submodel opening */
      255 	declare structure_version	 fixed bin;	/* desired structure version */
      256 	declare sys_info$max_seg_size	 fixed bin (35) ext;/* largest segment size */
      257 	declare (addr, fixed, null, rel, unspec) builtin;
      258 	declare 1 my_area_info	 like area_info;	/* local copy */
      259 
  1     1 /* BEGIN INCLUDE FILE mrds_database_list.incl.pl1 - - Jim Gray July 1979 */
  1     2 
  1     3 /* used by mrds_dsl_list_dbs to return an array of database opening information,
  1     4*   the databases opened for the calling process have their opening index
  1     5*   and opening model or submodel pathname returned in the array */
  1     6 
  1     7 declare  database_list_ptr ptr ;			/* points to array of indexes/pathnames */
  1     8 
  1     9 declare 1 database_list aligned based (database_list_ptr),	/* array of paths/indexes */
  1    10         2 number_open fixed bin,			/* total open by this process */
  1    11         2 db (number_of_openings refer (database_list.number_open)), /* array of open db info */
  1    12 	3 index fixed bin (35),			/* database opening index */
  1    13  	3 path char (168);                                /* model or submodel opening pathname */
  1    14 
  1    15 declare  number_of_openings fixed bin ;			/* total number open by this process */
  1    16 
  1    17 /* END INCLUDE FILE mrds_database_list.incl.pl1 */
  1    18 
      260 
      261 
  2     1 /* BEGIN INCLUDE FILE mrds_database_openings.incl.pl1 - - Jim Gray July 1979 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*   used by dsl_$list_openings to return an array of database opening information,
  2     6*   the mrds_databases opened for the calling process have their opening index
  2     7*   and opening model or submodel pathname returned in the array
  2     8*
  2     9**/
  2    10 
  2    11 /* HISTORY:
  2    12*   80-12-08 Rickie E. Brinegar: added the opening mode to the structure. Taken
  2    13*   from mrds_database_list.incl.pl1
  2    14*
  2    15*   81-01-27 Jim Gray : changed name to mrds_database_openings in process of adding
  2    16*   structure version information, plus pad bits after extending info
  2    17*   to include whether opening was via a model or submodel.
  2    18**/
  2    19 
  2    20 declare 1 mrds_database_openings aligned based (mrds_database_openings_ptr), /* array of paths/indexes */
  2    21         2 version fixed bin,				/* the version number of this structure */
  2    22         2 number_open fixed bin,			/* total open by this process */
  2    23         2 mbz1 bit (36) unal,
  2    24         2 db (mrds_database_openings_num_open_init
  2    25          refer (mrds_database_openings.number_open)),	/* array of open db info */
  2    26 	3 index fixed bin (35),			/* database opening index */
  2    27 	3 path char (168),				/* model or submodel opening pathname */
  2    28 	3 mode char (20),				/* opening mode of the database */
  2    29 	3 model bit (1) unal,			/* on => opened via the model */
  2    30 	3 submodel bit (1) unal,			/* on => opened via a submodel */
  2    31 	3 mbz2 bit (34) unal ;
  2    32 
  2    33 declare  mrds_database_openings_ptr ptr ;		/* points to array of indexes/pathnames */
  2    34 
  2    35 declare  mrds_database_openings_num_open_init fixed bin ;	/* total number open by this process */
  2    36 
  2    37 declare  mrds_database_openings_structure_version fixed bin int static options (constant) init (1) ; /* current version */
  2    38 
  2    39 /* END INCLUDE FILE mrds_database_openings.incl.pl1 */
  2    40 
      262 
      263 
  3     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  3     2 
  3     3 
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  3     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  3     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  3     9*     Nguyen. The scopes_changed flag was added to make checking for this
  3    10*     more efficient (mrds error list #137).
  3    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  3    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  3    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  3    14*     care if multiple txns use the same selection_expression. (mrds #156)
  3    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  3    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  3    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  3    18*                                                   END HISTORY COMMENTS */
  3    19 
  3    20 
  3    21 /* WARNING
  3    22*          If the dbcb structure is changed then the mrds_data_
  3    23*          item saved_res_version MUST be incremented to invalidate all
  3    24*          existing saved resultants
  3    25**/
  3    26 
  3    27 /* HISTORY :
  3    28*
  3    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  3    30*   tid_list management
  3    31*
  3    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  3    33*   phony resultant in mu_database_index, without having the area dcl
  3    34*   included.
  3    35*
  3    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  3    37*   mrds_dsl_store
  3    38*
  3    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  3    40*   switches
  3    41*
  3    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  3    43*   expression,  so  that relation statistics can be updated relative
  3    44*   to number of selection expressions seem. Also  removed  init  for
  3    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  3    46*   mrds_dsl_init_res.
  3    47*
  3    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  3    49*
  3    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  3    51*   for the conversion to the relation manager.
  3    52*
  3    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  3    54*   substructures so that the entries and costs can change
  3    55*   depending on the type of database that is opened.
  3    56*
  3    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  3    58*   since modify uses a different vector type (general) than does store.
  3    59*
  3    60*   82-09-20 Davids: changed names of (store modify)_vector to
  3    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  3    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  3    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  3    64*   during the first call.
  3    65*
  3    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  3    67*   since it deals with the pointers to the cursors and not the cursors
  3    68*   themelves and added the element cursor_storage_area_ptr which points
  3    69*   to the area where the cursors are kept.
  3    70*
  3    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  3    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  3    73*   anything.
  3    74*
  3    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  3    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  3    77*   by mrds_dsl_define_temp_rel.
  3    78*
  3    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  3    80*   is needed by mu_store.
  3    81*
  3    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  3    83*   bin to float bin since the values are not integers.
  3    84*
  3    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  3    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  3    87*   added to the end of the structure to allow modules that don't use
  3    88*   the element to continue to reference the dbcb structure without recompiling.
  3    89*
  3    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  3    91*   are needed so that temp rels can be created with the same file attributes
  3    92*   as the permanent relations.
  3    93*
  3    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  3    95*   added the resultant_in_pdir bit.
  3    96*
  3    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  3    98*   added the res_already_made element.
  3    99*
  3   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  3   101*
  3   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  3   103*   one of the unused pointers.
  3   104*
  3   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  3   106*
  3   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  3   108*   leaving unused_ptrs(1).
  3   109*
  3   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  3   111*   unused_ptrs (1).
  3   112*
  3   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  3   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  3   115*   spare ptrs, entries and reserved storages for future enhancement, since
  3   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  3   117*
  3   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  3   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  3   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  3   121**/
  3   122 
  3   123 
  3   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  3   125*   that constitutes the non-secure portion of the resultant model that is
  3   126*   created during the opening of a database. it contains variables that
  3   127*   are used during the runtime access of the database, and an area
  3   128*   for evaluation of requests. it points to four other
  3   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  3   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  3   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  3   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  3   133*   used in the elimination of duplicate tuples during a retrieve.
  3   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  3   135*   that is used when the database is using the file scope mechanism
  3   136*   for concurrency control over file readying. the segment overlayed via
  3   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  3   138*   across database openings. the pointer to this dbcb structure is kept in a table
  3   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  3   140*   opening instances of resultant models. (see mu_database_index routine) */
  3   141 
  3   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  3   143 	     2 data	      like dbcb_data,
  3   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  3   145 
  3   146      dcl	   dbcb_ptr	      ptr;
  3   147 
  3   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  3   149*						   like references can avoid getting the area declaration */
  3   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  3   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  3   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  3   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  3   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  3   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  3   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  3   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  3   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  3   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  3   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  3   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  3   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  3   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  3   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  3   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  3   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  3   167*						   for eliminating duplicate tuples. */
  3   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  3   169*						   for eliminating duplicate tuples. */
  3   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  3   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  3   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  3   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  3   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  3   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  3   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  3   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  3   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  3   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  3   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  3   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  3   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  3   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  3   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  3   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  3   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  3   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  3   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  3   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  3   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  3   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  3   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  3   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  3   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  3   195 	     2 val_del	      bit (1) unal,		/* for delete */
  3   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  3   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  3   198*                                                                     not imply that the database is of type page_file */
  3   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  3   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  3   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  3   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  3   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  3   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  3   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  3   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  3   207*						   inside a sequence of -another selection expression. */
  3   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  3   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  3   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  3   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  3   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  3   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  3   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  3   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  3   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  3   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  3   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  3   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  3   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  3   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  3   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  3   223 	     2 relmgr_entries,			/* relation manager entries */
  3   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  3   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  3   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  3   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  3   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  3   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  3   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  3   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  3   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  3   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  3   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  3   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  3   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  3   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  3   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  3   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  3   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  3   241 	       3 reserved_entries (5) entry (),
  3   242 	     2 access_costs,			/* access costs for permute */
  3   243 	       3 total_primary_key_cost float bin,
  3   244 	       3 access_cost      float bin,
  3   245 	       3 access_overhead  float bin,
  3   246 	       3 us_access_cost   float bin,
  3   247 	       3 os_access_cost   float bin,
  3   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  3   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  3   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  3   251 
  3   252 /* END mrds_dbcb.incl.pl1 */
  3   253 
  3   254 
      264 
      265 
  4     1 /* BEGIN mdbm_rm_db_info.incl.pl1 -- jaw, 11/7/78 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(86-08-13,Hergert),, approve(88-06-28,MCR7903),
  4     7*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  4     8*     Removed change of 84-11-02. i.e. replaced even_word_pad.
  4     9*                                                   END HISTORY COMMENTS */
  4    10 
  4    11 
  4    12 /* WARNING
  4    13*          If the rm_db_info structure is changed then the mrds_data_
  4    14*          item saved_res_version MUST be incremented to invalidate all
  4    15*          existing saved resultants
  4    16**/
  4    17 
  4    18 /*  DESCRIPTION:  This  structure   is   based   on   a   segment
  4    19*   {unique_name}.mrds.rdbi that represents the secure portion of the
  4    20*   resultant model that is created partially at database open  time,
  4    21*   (the rm_file_array, and rm_rel_array) and partially at ready_file
  4    22*   time,    (the    rm_file_info,     rm_rel_info,     rm_attr_info,
  4    23*   rm_domain_info, rm_plink_info and rm_clink_info). it's purpose is
  4    24*   to  provide  an  efficient  means  of  accessing  database  model
  4    25*   information, as seen from the possibly submodel view of the user,
  4    26*   and his current state of "files readied". it is the  secure  part
  4    27*   because  it  contains  the  model  information  which needs to be
  4    28*   protected  from  general  knowledge,  and   this   segment   will
  4    29*   eventually  be  capable  of  being in a lower ring. the structure
  4    30*   itself points to four arrays that are  allocated  in  it's  area,
  4    31*   that  in  turn point to the other structures mentions above, also
  4    32*   allocated in  the  rm_db_info.static_area.  the  arrays  are  the
  4    33*   rm_file_array,  and  rm_rel_array. their are a pair for temporary
  4    34*   relations,  initially  empty,  and  a  pair  for   normal   model
  4    35*   files/relations.  the  normal  rm_file_array  is initialized to a
  4    36*   list of all known file names, the rm_rel_array only gets relation
  4    37*   names   as   files  are  readied.  the  rm_file_array  points  to
  4    38*   rm_file_infos for each file (see mdbm_rm_file_info.incl.pl1)  and
  4    39*   the   rm_rel_array   points  to  rm_rel_info  for  each  relation
  4    40*   "readied". (see mdbm_rm_rel_info.incl.pl1). (the  arrays  are  in
  4    41*   mdbm_rm_file_array.incl.pl1  and mdbm_rm_rel_array.incl.pl1). the
  4    42*   file infos point to contained rel infos, the rel infos  point  to
  4    43*   contained  attr  infos,  and  those in turn to domain infos. (see
  4    44*   mdbm_rm_attr_info.incl.pl1   and    mdbm_rm_domain_info.incl.pl1)
  4    45*   foreign     keys    are    represented    by    the    structures
  4    46*   mdbm_rm_plink_info.incl.pl1, and mdbm_rm_clink_info.incl.pl1. the
  4    47*   pathnames  of the model and submodel, if any, are also maintained
  4    48*   in rm_db_info. the pointer to this rm_db_info segment is obtained
  4    49*   from  the  dbcb  segment tructure(see mrds_dbcb.incl.pl1) see the
  4    50*   individual include files for  further  organization  information,
  4    51*   and particular data structures.
  4    52*
  4    53*   HISTORY:
  4    54*
  4    55*   80-02-01 Jim Gray : Modified to put area on even  word  boundary,
  4    56*   so that define_area_ could be used to make it an extensible area
  4    57*
  4    58*   81-1-9 Jim  Gray  :  added  like  reference  to  make  the  phony
  4    59*   resultant in mu_database_index easier to keep, since no reference
  4    60*   to the area is needed.
  4    61*
  4    62*   81-1-12 Jim Gray : added version of submodel used in  opening  to
  4    63*   resultant.
  4    64*
  4    65*   81-05-13 Rickie E. Brinegar: added the administrator bit  to  the
  4    66*   structure.
  4    67*
  4    68*   81-05-28 Jim Gray : removed pointers to file_arrays,  since  they
  4    69*   are  now  combined  into  the rel_array. Removed the control file
  4    70*   info which was unused. Added pointer  to  head  of  domain  list,
  4    71*   which is to be used to insure only one copy of each domain info.
  4    72*
  4    73*   83-05-19 Davids: Added the  saved_res_version element.
  4    74*
  4    75*   84-11-02 Thanh Nguyen:   Replaced  the  even_word_pad   by   the 
  4    76*   ref_name_proc_ptr  to point  to list  of reference  name of  the
  4    77*   check, encode, or decode proc.
  4    78*
  4    79*   CAUTION: The structure entries from db_version to sm_path  should
  4    80*   not  be moved or have their declarations changed because they are
  4    81*   used in the handling of old version database openings.
  4    82*
  4    83*
  4    84**/
  4    85 
  4    86      dcl	   1 rm_db_info	      aligned based (rdbi_ptr), /* data base info, located at base of res. dm. seg. */
  4    87 	     2 data	      like rm_db_info_data,
  4    88 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (rm_db_info.static_area))));
  4    89 
  4    90      dcl	   rdbi_ptr	      ptr;
  4    91 
  4    92      declare 1 rm_db_info_data      based,		/* separate declaration of info, so others can use
  4    93*						   like reference to it without getting the area as well */
  4    94 	     2 db_version	      fixed bin,		/* version no. of db */
  4    95 	     2 sm_version	      fixed bin unal,	/* version of submodel used unal, 0 if model opening */
  4    96 	     2 val_level	      fixed bin unal,	/* validation level for this db. */
  4    97 	     2 db_path	      char (168),		/* abs. path of db. */
  4    98 	     2 sm_path	      char (168),		/* path of submodel or model */
  4    99 	     2 mdbm_secured	      bit (1) unal,		/* ON => database is secured */
  4   100 	     2 administrator      bit (1) unal,		/* ON => user is an administrator */
  4   101 	     2 pad	      bit (34) unal,	/* for future use */
  4   102 	     2 saved_res_version  char (8),		/* version of the saved resultant in the 
  4   103*                                                               dbcb and rdbi segments in the db dir */
  4   104 	     2 domain_list_ptr    ptr,		/* pointer to head of list of domain_info's */
  4   105 	     2 ra_ptr	      ptr,		/* pointer to rel. array */
  4   106 	     2 tra_ptr	      ptr,		/* to rel array for temp rels */
  4   107 	     2 even_word_pad      fixed bin (71) aligned; /* padding to put area on even word boundary */
  4   108 
  4   109 /* END mdbm_rm_db_info.incl.pl1 */
  4   110 
  4   111 
      266 
      267 
  5     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  5     2 
  5     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  5     4 
  5     5 dcl  area_infop ptr;
  5     6 
  5     7 dcl 1 area_info aligned based (area_infop),
  5     8     2 version fixed bin,				/* version number for this structure is 1 */
  5     9     2 control aligned like area_control,		/* control bits for the area */
  5    10     2 owner char (32) unal,				/* creator of the area */
  5    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  5    12     2 size fixed bin (18),				/* size of the area in words */
  5    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  5    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  5    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  5    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  5    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  5    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  5    19 
  5    20 dcl 1 area_control aligned based,
  5    21     2 extend bit (1) unal,				/* says area is extensible */
  5    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  5    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  5    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  5    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  5    26     2 system bit (1) unal,				/* says area is managed by system */
  5    27     2 pad bit (30) unal;
  5    28 
  5    29 /* END INCLUDE FILE area_info.incl.pl1 */
      268 
      269 
      270      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1313.9  mrds_dsl_db_openings.pl1          >special_ldd>install>MR12.2-1073>mrds_dsl_db_openings.pl1
260          1    10/14/83  1608.7  mrds_database_list.incl.pl1       >ldd>include>mrds_database_list.incl.pl1
262          2    10/14/83  1608.7  mrds_database_openings.incl.pl1   >ldd>include>mrds_database_openings.incl.pl1
264          3    08/01/88  1300.0  mrds_dbcb.incl.pl1                >special_ldd>install>MR12.2-1073>mrds_dbcb.incl.pl1
266          4    08/01/88  1310.7  mdbm_rm_db_info.incl.pl1          >special_ldd>install>MR12.2-1073>mdbm_rm_db_info.incl.pl1
268          5    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_area_ptr                             parameter       pointer                  dcl 236 ref 18 18 106
addr                                                   builtin function         dcl 257 ref 158 158
area                            000100 stack reference condition                dcl 237 ref 166 180
area_control                           based           structure                level 1 dcl 5-20
area_info                              based           structure                level 1 dcl 5-7
area_info_                      000010 constant        entry                    external dcl 238 ref 158
area_ptr                        000106 automatic       pointer                  dcl 239 set ref 106* 107 153* 156 173 178
areap                    16     000174 automatic       pointer                  level 2 dcl 258 set ref 156*
b_area_ptr                             parameter       pointer                  dcl 240 ref 136 149 153
based_area                             based           area                     dcl 241 ref 107 173 178
cleanup                         000110 stack reference condition                dcl 242 ref 171
control                   1     000174 automatic       structure                level 2 dcl 258
data                                   based           structure                level 2 in structure "dbcb" dcl 3-142 in procedure
                                                                                  "list_dbs"
data                                   based           structure                level 2 in structure "rm_db_info" dcl 4-86
                                                                                  in procedure "list_dbs"
database_list                          based           structure                level 1 dcl 1-9 set ref 107
database_list_ptr                      parameter       pointer                  dcl 1-7 set ref 18 18 102* 107* 109 126 127
db                        3            based           structure                array level 2 in structure "mrds_database_openings"
                                                                                  dcl 2-20 in procedure "list_dbs"
db                        1            based           structure                array level 2 in structure "database_list" dcl 1-9
                                                                                  in procedure "list_dbs"
db_index                        000116 automatic       fixed bin(35,0)          dcl 243 set ref 112* 114* 126* 187* 190* 202*
dbcb                                   based           structure                level 1 dcl 3-142
dbcb_data                              based           structure                level 1 unaligned dcl 3-148
dbcb_ptr                        000222 automatic       pointer                  dcl 3-146 set ref 114* 116 119 190* 192 195 204 210
dsm_sw                  106(08)        based           bit(1)                   level 3 packed packed unaligned dcl 3-142 ref 204
error_code                             parameter       fixed bin(35,0)          dcl 244 set ref 136 140* 147* 149* 158* 159 160*
                                                                                  167*
error_table_$area_too_small     000012 external static fixed bin(35,0)          dcl 245 ref 167
error_table_$badcall            000014 external static fixed bin(35,0)          dcl 246 ref 149
error_table_$unimplemented_version
                                000016 external static fixed bin(35,0)          dcl 247 ref 147
fixed                                                  builtin function         dcl 257 ref 210
index                     1            based           fixed bin(35,0)          array level 3 in structure "database_list" dcl 1-9
                                                                                  in procedure "list_dbs" set ref 126*
index                     3            based           fixed bin(35,0)          array level 3 in structure "mrds_database_openings"
                                                                                  dcl 2-20 in procedure "list_dbs" set ref 202*
mode                     56            based           char(20)                 array level 3 dcl 2-20 set ref 211* 213* 215* 217*
                                                                                  219* 221*
mode_code                       000117 automatic       fixed bin(17,0)          dcl 250 set ref 210* 211 213 215 217 219
model                    63            based           bit(1)                   array level 3 packed packed unaligned dcl 2-20 set
                                                                                  ref 206*
mrds_data_$max_dbs              000024 external static fixed bin(35,0)          dcl 251 ref 112 187
mrds_database_openings                 based           structure                level 1 dcl 2-20 set ref 173 178 182*
mrds_database_openings_num_open_init
                                000221 automatic       fixed bin(17,0)          dcl 2-35 set ref 143* 178 178 184 187
mrds_database_openings_ptr             parameter       pointer                  dcl 2-33 set ref 136 141* 172 173 174* 178* 182 183
                                                                                  184 202 203 204 206 211 213 215 217 219 221
mrds_database_openings_structure_version
                                       constant        fixed bin(17,0)          initial dcl 2-37 ref 147 183
mrds_error_$not_freeing_area    000026 external static fixed bin(35,0)          dcl 252 ref 160
mu_database_index$get_number_open_dbs
                                000020 constant        entry                    external dcl 248 ref 100 143
mu_database_index$get_resultant_model_pointer
                                000022 constant        entry                    external dcl 249 ref 114 190
my_area_info                    000174 automatic       structure                level 1 unaligned dcl 258 set ref 154* 158 158
no_freeing                1(04) 000174 automatic       bit(1)                   level 3 packed packed unaligned dcl 258 set ref 160
null                                                   builtin function         dcl 257 ref 102 116 120 141 149 172 174 192 196
number_found                    000120 automatic       fixed bin(17,0)          dcl 253 set ref 111* 112 124* 124 126 127 186* 187
                                                                                  200* 200 202 203 204 206 211 213 215 217 219 221
number_of_openings              000220 automatic       fixed bin(17,0)          dcl 1-15 set ref 100* 102 107 107 109 112
number_open               1            based           fixed bin(17,0)          level 2 in structure "mrds_database_openings"
                                                                                  dcl 2-20 in procedure "list_dbs" set ref 173 178*
                                                                                  182 184*
number_open                            based           fixed bin(17,0)          level 2 in structure "database_list" dcl 1-9
                                                                                  in procedure "list_dbs" set ref 107* 109*
open_mode               106(14)        based           bit(3)                   level 3 packed packed unaligned dcl 3-142 ref 210
path                      2            based           char(168)                array level 3 in structure "database_list" dcl 1-9
                                                                                  in procedure "list_dbs" set ref 127*
path                      4            based           char(168)                array level 3 in structure "mrds_database_openings"
                                                                                  dcl 2-20 in procedure "list_dbs" set ref 203*
pathname                        000121 automatic       char(168)                packed unaligned dcl 254 set ref 120* 122* 127 196*
                                                                                  198* 203
rdbi_ptr                               based           pointer                  level 3 in structure "dbcb" dcl 3-142 in procedure
                                                                                  "list_dbs" ref 119 195
rdbi_ptr                        000224 automatic       pointer                  dcl 4-90 in procedure "list_dbs" set ref 119* 120
                                                                                  122 195* 196 198
rm_db_info                             based           structure                level 1 dcl 4-86
rm_db_info_data                        based           structure                level 1 unaligned dcl 4-92
sm_path                  54            based           char(168)                level 3 dcl 4-86 ref 122 198
structure_version                      parameter       fixed bin(17,0)          dcl 255 ref 136 147
submodel                 63(01)        based           bit(1)                   array level 3 packed packed unaligned dcl 2-20 set
                                                                                  ref 204*
unspec                                                 builtin function         dcl 257 set ref 154* 182*
version                                based           fixed bin(17,0)          level 2 in structure "mrds_database_openings"
                                                                                  dcl 2-20 in procedure "list_dbs" set ref 183*
version                         000174 automatic       fixed bin(17,0)          level 2 in structure "my_area_info" dcl 258
                                                                                  in procedure "list_dbs" set ref 155*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
area_info_version_1                    internal static fixed bin(17,0)          initial dcl 5-3
area_infop                             automatic       pointer                  dcl 5-5
rel                                                    builtin function         dcl 257
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 256

NAMES DECLARED BY EXPLICIT CONTEXT.
list_dbs                        000051 constant        entry                    external dcl 18
list_openings                   000220 constant        entry                    external dcl 136
mrds_dsl_db_openings            000061 constant        entry                    external dcl 18
skip_allocate                   000607 constant        label                    dcl 232 ref 168

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1000        1030     610        1010
Length      1342     610        30         276     170           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
list_dbs                            166 external procedure  is an external procedure.  
on unit on line 166                  64 on unit               
on unit on line 171                  64 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
list_dbs                 000106 area_ptr                    list_dbs
                         000116 db_index                    list_dbs
                         000117 mode_code                   list_dbs
                         000120 number_found                list_dbs
                         000121 pathname                    list_dbs
                         000174 my_area_info                list_dbs
                         000220 number_of_openings          list_dbs
                         000221 mrds_database_openings_num_open_init
                                                            list_dbs
                         000222 dbcb_ptr                    list_dbs
                         000224 rdbi_ptr                    list_dbs

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return_mac          tra_ext_1           enable_op           ext_entry           int_entry
op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
area_info_                    mu_database_index$get_number_open_dbs
mu_database_index$get_resultant_model_pointer

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$area_too_small   error_table_$badcall          error_table_$unimplemented_version
mrds_data_$max_dbs            mrds_error_$not_freeing_area




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     18 000045       100 000066       102 000074       106 000102       107 000106       111 000120       112 000121
    114 000134       116 000145       119 000152       120 000155       122 000165       124 000170       126 000171
    127 000201       130 000205       134 000212       136 000213       140 000225       141 000227       143 000231
    147 000240       149 000250       153 000260       154 000263       155 000266       156 000270       158 000271
    159 000304       160 000310       166 000317       167 000333       168 000337       171 000342       172 000356
    173 000364       174 000373       176 000377       178 000400       180 000412       182 000413       183 000423
    184 000425       186 000427       187 000430       190 000444       192 000455       195 000462       196 000465
    198 000475       200 000500       202 000501       203 000511       204 000515       206 000525       210 000527
    211 000533       213 000542       215 000551       217 000560       219 000567       221 000576       226 000602
    232 000607


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
