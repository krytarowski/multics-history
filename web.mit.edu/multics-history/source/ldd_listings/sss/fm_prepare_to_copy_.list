	COMPILATION LISTING OF SEGMENT fm_prepare_to_copy_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 03/05/85  0905.7 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION: 
        8*
        9*          This procedure locks the specified file in preparation for
       10*     copying the file and returns information to the caller needed
       11*     to copy the file.  This information includes a file_create_info
       12*     structure for creating the new copy of the file and the length
       13*     of the file.  The file_create_info information is found in
       14*     the file's file_attributes.
       15*
       16*          Error handling for this procedure is of note.  There is one
       17*     return statement in this procedure, preceded by the MAIN_RETURN label.
       18*     If no error is encountered, this return statement is reached from
       19*     the previous statement.  In all error cases, control is transferred
       20*     from the ERROR_RETURN procedure to the MAIN_RETURN label to reach
       21*     the return statement.  ERROR_RETURN is called by this procedure
       22*     when an error is encountered which does not need to be logged in
       23*     the dm_system_log.  Generally these are errors which are completely 
       24*     described by the error code.  ERROR_RETURN is also called by the
       25*     fm_sub_error_ on unit.  If the fm_sub_error_ on unit is invoked,
       26*     the error has already been logged, so should not be logged again.
       27*     Errors which have additional information are logged by calling
       28*     LOG_ERROR_RETURN.  LOG_ERROR_RETURN and possibly fm_get_last_ci_num
       29*     signal fm_sub_error_ after logging the error, causing the call to
       30*     ERROR_RETURN via the on unit.
       31**/
       32 
       33 /* HISTORY:
       34*Written by Matthew Pierret, 08/01/84.
       35*     (Extracted from fm_open_.pl1, written by Jeff Ives.)
       36*Modified:
       37*11/13/84 by Matthew Pierret:  Answered audit comments: Added check for 
       38*            saved_validation_level>0 before resetting level.  Added call to
       39*            FINISH in non-error case.  Made to make use of automatic
       40*            file_create_info_ptr variable instead of always using the 
       41*            parameter.  Changed ERROR_RETURN to LOG_ERROR_RETURN,
       42*            RETURN to ERROR_RETURN.  Added description of error handling.
       43*12/06/84 by Matthew Pierret:  Changed to use dm_error_$no_current_transaction 
       44*            instead of dm_error_$fm_no_current_txn. Added must_be_zero
       45*            component in my_ci_parts.
       46*12/17/84 by Matthew Pierret:  Changed to use new file_access_info state 
       47*            variables.
       48**/
       49 
       50 /* format: style2,ind3 */
       51 
       52 fm_prepare_to_copy_:
       53    procedure (p_file_oid, p_file_create_info_ptr, p_last_ci_num, p_code);
       54 
       55 /* START OF DECLARATIONS */
       56 
       57 /* Parameter */
       58 
       59       dcl	    p_file_oid	       bit (36) aligned parameter;
       60       dcl	    p_file_create_info_ptr ptr parameter;
       61       dcl	    p_last_ci_num	       fixed bin (27) parameter;
       62       dcl	    p_code	       fixed bin (35) parameter;
       63 
       64 /* Automatic */
       65 
       66       dcl	    code		       fixed bin (35) init (0);
       67       dcl	    dir_path	       char (168);
       68       dcl	    entry_name	       char (32);
       69       dcl	    full_path_name	       char (168);
       70       dcl	    saved_validation_level fixed bin init (0);
       71       dcl	    seg_0_ptr	       ptr init (null ());
       72       dcl	    1 my_create_info       aligned like file_create_info;
       73       dcl	    1 my_ci_part	       aligned,
       74 	      2 number_of_parts    fixed bin init (1),
       75 	      2 must_be_zero       fixed bin init (0),
       76 	      2 part	       (1) like ci_parts.part;
       77       dcl	    1 my_file_access_info  aligned like file_access_info;
       78       dcl	    1 my_file_attributes   aligned like file_attributes;
       79       dcl	    1 my_file_oid	       aligned like file_oid;
       80 
       81 /* Based */
       82 
       83 /* Builtin */
       84 
       85       dcl	    (addr, baseptr, char, fixed, lbound, null, rtrim, substr, unspec)
       86 			       builtin;
       87 
       88 /* Condition */
       89 
       90       dcl	    cleanup	       condition;
       91       dcl	    fm_sub_error_	       condition;
       92 
       93 /* Constant */
       94 
       95       dcl	    MYNAME	       init ("fm_prepare_to_copy_") char (32) varying internal static options (constant);
       96       dcl	    LOCK_WAIT_TIME	       init (1e9) fixed bin (71) internal static options (constant);
       97 
       98 /* Entry */
       99 
      100       dcl	    cu_$level_get	       entry (fixed bin);
      101       dcl	    cu_$level_set	       entry (fixed bin);
      102       dcl	    expand_pathname_       entry (char (*), char (*), char (*), fixed bin (35));
      103       dcl	    fm_error_util_$get_code
      104 			       entry () returns (fixed bin (35));
      105       dcl	    fm_error_util_$signal  entry options (variable);
      106       dcl	    fm_get_$internal_get   entry (bit (36) aligned, fixed bin (27), ptr, fixed bin (35));
      107       dcl	    fm_get_last_ci_num     entry (char (168), fixed bin, fixed bin (27));
      108       dcl	    get_ring_	       entry () returns (fixed bin (3));
      109       dcl	    hcs_$fs_get_path_name  entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
      110       dcl	    lock_manager_$lock     entry (bit (36) aligned, fixed bin (27), fixed bin, fixed bin (71), fixed bin,
      111 			       fixed bin (35));
      112 
      113 /* External */
      114 
      115       dcl	    dm_data_$current_txn_id
      116 			       bit (36) aligned ext;
      117 
      118       dcl	    dm_error_$bad_file_atrs_length
      119 			       fixed bin (35) ext;
      120       dcl	    dm_error_$bad_file_atrs_uid
      121 			       fixed bin (35) ext;
      122       dcl	    dm_error_$bad_file_atrs_ver
      123 			       fixed bin (35) ext;
      124       dcl	    dm_error_$bad_file_cr_info_ver
      125 			       fixed bin (35) ext;
      126       dcl	    dm_error_$bad_file_oid fixed bin (35) ext;
      127       dcl	    dm_error_$file_doesnt_exist
      128 			       fixed bin (35) ext;
      129       dcl	    dm_error_$no_current_transaction
      130 			       fixed bin (35) ext;
      131 
      132 /* END OF DECLARATIONS */
      133 
      134       on fm_sub_error_ call ERROR_RETURN (fm_error_util_$get_code ());
      135 
      136       unspec (my_file_oid) = p_file_oid;
      137       file_create_info_ptr = p_file_create_info_ptr;
      138       if file_create_info.version ^= FILE_CREATE_INFO_VERSION_2
      139       then call LOG_ERROR_RETURN (dm_error_$bad_file_cr_info_ver, "  Supplied version was ^a.  It should have been ^a.",
      140 	      (file_create_info.version), (FILE_CREATE_INFO_VERSION_2));
      141 
      142 /* Get file access info. */
      143 
      144       if my_file_oid.file_access_table_idx < lbound (file_access_table.e, 1)
      145 	 | my_file_oid.file_access_table_idx > file_access_table.h.last_entry
      146       then call ERROR_RETURN (dm_error_$bad_file_oid);
      147 
      148       my_file_access_info = file_access_table.e (my_file_oid.file_access_table_idx);
      149 
      150       if my_file_access_info.state.entry_state = FILE_ACCESS_INFO_NOT_IN_USE
      151       then call ERROR_RETURN (dm_error_$bad_file_oid);
      152 
      153       if my_file_access_info.state.file_state ^= FILE_EXISTS
      154       then call ERROR_RETURN (dm_error_$file_doesnt_exist);
      155 
      156       if my_file_access_info.opens = 0
      157       then call ERROR_RETURN (dm_error_$bad_file_oid);
      158 
      159       if my_file_oid.uid_tail ^= substr (my_file_access_info.uid, 19, 18)
      160       then call ERROR_RETURN (dm_error_$bad_file_oid);
      161 
      162       if my_file_access_info.seg_0_num = ""b
      163       then call ERROR_RETURN (dm_error_$file_doesnt_exist);
      164 
      165       call cu_$level_get (saved_validation_level);
      166       on cleanup call FINISH;
      167       call cu_$level_set (get_ring_ ());
      168 
      169 /* Get the path name of the file given the segment number of the first component */
      170 
      171       seg_0_ptr = baseptr (my_file_access_info.seg_0_num);
      172 
      173       call hcs_$fs_get_path_name (seg_0_ptr, full_path_name, (0), entry_name, code);
      174       if code ^= 0
      175       then call LOG_ERROR_RETURN (code, "^/Unable to get pathname of segment ^a.^s",
      176 	      char (fixed (my_file_access_info.seg_0_num)), "");
      177 
      178       call expand_pathname_ (full_path_name, dir_path, entry_name, code);
      179       if code ^= 0
      180       then call ERROR_RETURN (code);
      181 
      182 
      183       if my_file_access_info.integrity_switches.transaction
      184       then
      185          do;
      186 	  if dm_data_$current_txn_id = ""b
      187 	  then call ERROR_RETURN (dm_error_$no_current_transaction);
      188          end;
      189 
      190       if my_file_access_info.integrity_switches.lock
      191       then
      192          do;
      193 	  call lock_manager_$lock (my_file_access_info.uid, LOCK_ENTIRE_FILE, LOCK_MODE_X, LOCK_WAIT_TIME, (0), code);
      194 	  if code ^= 0
      195 	  then call LOG_ERROR_RETURN (code, "  Unable to lock file ^a, with uid ^a, exclusively.", full_path_name,
      196 		  char (my_file_access_info.uid));
      197          end;
      198 
      199 /* Get the attributes stored in the file. */
      200 
      201       unspec (my_file_attributes) = ""b;
      202       file_attributes_ptr = addr (my_file_attributes);
      203       my_ci_part.part (1).offset_in_bytes = CI_0_ADDRESSABLE_LENGTH;
      204       my_ci_part.part (1).length_in_bytes = CI_ADDRESSABLE_LENGTH - CI_0_ADDRESSABLE_LENGTH;
      205       my_ci_part.part (1).local_ptr = file_attributes_ptr;
      206 
      207       call fm_get_$internal_get (unspec (my_file_oid), 0, addr (my_ci_part), code);
      208       if code ^= 0
      209       then call ERROR_RETURN (code);
      210 
      211       if file_attributes.length_of_attributes ^= CI_ADDRESSABLE_LENGTH - CI_0_ADDRESSABLE_LENGTH - 2
      212       then call LOG_ERROR_RETURN (dm_error_$bad_file_atrs_length,
      213 	      "  The file_attributes length " || rtrim (full_path_name) || " is ^a.  It should be ^a.",
      214 	      char (file_attributes.length_of_attributes), char (CI_ADDRESSABLE_LENGTH - CI_0_ADDRESSABLE_LENGTH - 2));
      215 
      216       if file_attributes.version ^= FILE_ATTRIBUTES_VERSION_2
      217       then call LOG_ERROR_RETURN (dm_error_$bad_file_atrs_ver,
      218 	      "  The version of the file attributes is ^a.  It should be ^a.", (file_attributes.version),
      219 	      (FILE_ATTRIBUTES_VERSION_2));
      220 
      221       if file_attributes.unique_id ^= my_file_access_info.uid
      222       then call LOG_ERROR_RETURN (dm_error_$bad_file_atrs_uid,
      223 	      "  The unique identifier in the file attributes of " || rtrim (full_path_name)
      224 	      || " is ^a.  The UID in CI 0 is ^a.", char (file_attributes.unique_id), char (my_file_access_info.uid));
      225 
      226 /* Copy the file attributes into my_create_info. */
      227 
      228       unspec (my_create_info) = ""b;
      229       my_create_info.version = FILE_CREATE_INFO_VERSION_2;
      230       my_create_info.ci_size_in_bytes = file_attributes.ci_size_in_bytes;
      231       my_create_info.blocking_factor = file_attributes.blocking_factor;
      232       my_create_info.protected = file_attributes.flags.protected;
      233       my_create_info.no_concurrency = file_attributes.flags.no_concurrency;
      234       my_create_info.no_rollback = file_attributes.flags.no_rollback;
      235       my_create_info.ring_brackets (FCI_WRITE_BRACKET_IDX) = file_attributes.ring_brackets.write;
      236       my_create_info.ring_brackets (FCI_READ_BRACKET_IDX) = file_attributes.ring_brackets.read;
      237 
      238 /* Notice that there is no check to see if the caller's validation level     */
      239 /* is within the file_attributes.ring_bracket.read bracket.  This is because */
      240 /* the caller must have been within the read bracket to open the file.  In   */
      241 /* the future, if changable ring brackets are implemented, a check should be */
      242 /* added here in case the ring brackets were lowered since the time of open. */
      243 
      244 /* Copy the file_create_info from automatic storage to the caller's buffer. */
      245 
      246       file_create_info = my_create_info;
      247 
      248 /* Determine the number of the last control interval. */
      249 
      250       call fm_get_last_ci_num (full_path_name, (my_file_access_info.blocking_factor), p_last_ci_num);
      251 
      252       p_code = 0;
      253       call FINISH ();
      254 
      255 MAIN_RETURN:
      256       return;
      257 
      258 ERROR_RETURN:
      259    proc (er_p_code);
      260 
      261       dcl	    er_p_code	       fixed bin (35);
      262 
      263       p_code = er_p_code;
      264       call FINISH ();
      265       go to MAIN_RETURN;
      266 
      267    end ERROR_RETURN;
      268 
      269 
      270 LOG_ERROR_RETURN:
      271    proc (ler_p_code, ler_p_error_message, ler_p_error_message_argument_1, ler_p_error_message_argument_2);
      272 
      273       dcl	    ler_p_code	       fixed bin (35) parameter;
      274       dcl	    (ler_p_error_message, ler_p_error_message_argument_1, ler_p_error_message_argument_2)
      275 			       char (*) parameter;
      276 
      277       call fm_error_util_$signal (ler_p_code, MYNAME, (FM_ACTION_CANT_RESTART | FM_ACTION_LOG), LOG_SV,
      278 	 ler_p_error_message, ler_p_error_message_argument_1, ler_p_error_message_argument_2);
      279 
      280    end LOG_ERROR_RETURN;
      281 
      282 
      283 FINISH:
      284    proc ();
      285 
      286       if saved_validation_level > 0
      287       then call cu_$level_set (saved_validation_level);
      288 
      289    end FINISH;
      290 
  1     1 /* BEGIN INCLUDE FILE: dm_file_create_info.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*     This include file contains the declaration of the file_create_info
  1     5*     structure.  This structure is used to specify to file_manager_
  1     6*     attributes a file is to have.
  1     7**/
  1     8 
  1     9 /* HISTORY:
  1    10*Written by Jeffery D. Ives, 09/16/82.
  1    11*  (Original concept by Lindsey L. Spratt.)
  1    12*Modified:
  1    13*06/15/84 by Matthew Pierret:  Added ring_brackets. Changed to a char (8)
  1    14*            version.
  1    15*11/07/84 by Matthew Pierret:  Extended mbz_3 to by one word to cover the
  1    16*            gap caused by the double-word alignment of mbz_2.
  1    17**/
  1    18 
  1    19 /* format: style2,ind3 */
  1    20 
  1    21      dcl	   1 file_create_info     aligned based (file_create_info_ptr),
  1    22 	     2 version	      char (8) aligned,
  1    23 	     2 ci_size_in_bytes   fixed bin (35) init (4096),
  1    24 						/* control interval physical size, must be 4096	*/
  1    25 	     2 blocking_factor    fixed bin init (255),	/* # of cis in each msf seg, must be 64 or 255	*/
  1    26 	     2 flags	      unal,
  1    27 	       3 protected	      bit (1) unal init ("1"b),
  1    28 						/* protected against inconsistency		*/
  1    29 	       3 no_concurrency   bit (1) unal init ("0"b),
  1    30 						/* don't protect against concurrent access	*/
  1    31 	       3 no_rollback      bit (1) unal init ("0"b),
  1    32 						/* don't protect against system failure		*/
  1    33 	       3 mbz_1	      bit (15) unal init ("0"b),
  1    34 						/* must be zero for future compatability	*/
  1    35 	     2 ring_brackets      (2) fixed bin (3) unal init (0, 0),
  1    36 						/* write bracket is first element, read bracket is second */
  1    37 	     2 mbz_3	      bit (46) unal init ("0"b),
  1    38 						/* must be zero for future compatability */
  1    39 	     2 mbz_2	      (30) fixed bin (71);	/* must be zero for future compatability	*/
  1    40 
  1    41      dcl	   file_create_info_ptr   ptr;
  1    42 
  1    43      dcl	   FILE_CREATE_INFO_VERSION_2
  1    44 			      char (8) aligned static options (constant) init ("FileCr 2");
  1    45      dcl	   (
  1    46 	   FCI_WRITE_BRACKET_IDX  init (1),
  1    47 	   FCI_READ_BRACKET_IDX   init (2)
  1    48 	   )		      internal static options (constant);
  1    49 
  1    50 /* ************ END OF INCLUDE FILE: dm_file_create_info.incl.pl1 ********** */
      291 
      292 
  2     1 /*  BEGIN INCLUDE FILE: dm_fm_file_oid.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*        This include file contains the file_oid (file opening identifier)
  2     5*   structure.  File opening ids are passed across the file_manager_
  2     6*   interface as bit(36)aligned strings.  The file_oid structure defines
  2     7*   the contents of the string.  Two components make up a file opening id:
  2     8*   the index of the file opening in the file_access_table structure, which
  2     9*   contains per-process information on each file which is open, and the
  2    10*   last 18 bits of the file's unique id, used for verification of the entry
  2    11*   in the file_access_table.
  2    12**/
  2    13 
  2    14 /*
  2    15*HISTORY:
  2    16*Written by Matthew Pierret, 07/16/84.
  2    17*Modified:
  2    18*11/02/84 by Matthew Pierret:  Made file_oid based.
  2    19**/
  2    20 
  2    21 /* format: style2,ind3 */
  2    22 
  2    23      dcl	   1 file_oid	      aligned based,
  2    24 	     2 file_access_table_idx
  2    25 			      fixed bin (17) unal,	/* index into file_access_table */
  2    26 	     2 uid_tail	      bit (18) unal;	/* Last 18 bits of file unique id */
  2    27 
  2    28 
  2    29 /* END INCLUDE FILE:  dm_fm_file_oid.incl.pl1 */
      293 
      294 
  3     1 /* BEGIN INCLUDE FILE:	dm_fm_file_access_info.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*        The file_access_info structure contains per-process information
  3     5*   about a DM file.  Each file_access_info structure is one entry in
  3     6*   the file_access_table.e array.  The entry can be in one of three states:
  3     7*   not-in-use (file_access_info.entry_state is 0), in-use (entry_state is
  3     8*   -1) or still in-use, but to be discarded at the end of the transaction
  3     9*   (any number > 0).  An entry needs to be discarded when the file is 
  3    10*   completely closed by the user.  This last state is useful because it is 
  3    11*   better not to discard the entry when it is completely closed until the
  3    12*   end of the current transaction, so that if the transaction is aborted, the 
  3    13*   file need not be re-opened to apply the before images.  A list of entries
  3    14*   to be discarded is maintained using the entry_state variable.
  3    15*        The file can be in one of three states: exists (file_state = 1), 
  3    16*   does not exist (file_state = 0), and logically_deleted (file_state = 3).
  3    17**/
  3    18 
  3    19 /* HISTORY:
  3    20*Written by Jeffrey D. Ives, 10/11/82.
  3    21*  (Original design by Andre Bensoussan, 01/28/82.)
  3    22*Modified:
  3    23*10/05/83 Jeffrey D. Ives: Added fields for lock advice and expanded seg_nums.
  3    24*07/12/84 by Matt @p @      mos_memory_check: EDAC error on mem b store a._0    æ           T    (é  T˘·,7ò @p @      mos_memory_check: EDAC error on mem b store b._0    ^           T    (è  T˘·,;Æ @x @      mos_memory_check: EDAC error on mem b store b1.0    ≈^      Ä    h    (ê  T˘‚¿‹} ¡`  @      RCP: Check Mount of AV0131 for writing on tapa_01 for Volume_Dumper.Daemon.z Ä    H    (ë  T˘‚≈-2  H  @      RCP: Note (tapa_01) - AV0131,den=6250,sys ta Ä    d    (í  T˘‚á≤€ ¡@  @      RCP: Check Mount of COM229 for writing on tapa_00 for Backup.SysDaemon.z     Ä    H    (ì  T˘‚ã∂V  H  @      RCP: Note (tapa_00) - COM229,den=6250,sys ta      T    (î  T˘„§0q @p @      mos_memory_check: EDAC error on mem b store a._0    æ           T    (ï  T˘„§5Ç @p @      mos_memory_check: EDAC error on mem b store b._0    ^           T    (ñ  T˘„§8U @x @      mos_memory_check: EDAC error on mem b store b1.0    ≈^      Ä    h    (ó  T˘‰T ¡`  @      RCP: Check Mount of AV0131 for writing on tapa_01 for Volume_Dumper.Daemon.z Ä    H    (ò  T˘‰Yx≈  H  @      RCP: Note (tapa_01) - AV0131,den=6250,sys ta Ä    d    (ô  T˘‰‚8 ¡@  @      RCP: Check Mount of COM229 for writing on tapa_00 for Backup.SysDaemon.z     Ä    H    (ö  T˘‰â  H  @      RCP: Note (tapa_00) - COM229,den=6250,sys ta ¿    P    (õ  T˘‰ámy @  @      ioi_masked$interrupt: I/O error.‡ 0 B22     (  tapa ¿    P    (ú  T˘‰áëi @  @      ioi_masked$interrupt: I/O error.¿ 1¿B22     (  tapa ¿    P    (ù  T˘‰àˇ @  @      ioi_masked$interrupt: I/O error.‡ 4 B22     (B  tapa ¿    P    (û  T˘‰è6∞ @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Q  tapa Ä    h    (ü  T˘‰í\Ï @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapaÄÄ  c¿çò¯ Ä   Ä    h    (†  T˘‰ôaó @  @      ioi_masked$interrupt: I/O error.‡ & B22     Z   tapabÄÄ  c¿çò¯ Ä   ¿    P    (°  T˘ÂD√/ @  @      ioi_masked$interrupt: I/O error.‡0 B22     (  tapa ¿    P    (¢  T˘ÂDÎî @  @      ioi_masked$interrupt: I/O error.¿1¿B22     (  tapa ¿    P    (£  T˘ÂE¢‡ @  @      ioi_masked$interrupt: I/O error.¿4¿B22     (B  tapa Ä    h    (§  T˘ÂÜ« @  @      ioi_masked$interrupt: I/O error.‡ B22     Z   tapaRÄÄ  c¿çò¯ Ä   ¿    P    (•  T˘ÂFı @  @      ioi_masked$interrupt: I/O error.ÈA@B22     Q  tapa      T    (¶  T˘Ê: @p @      mos_memory_check: EDAC error on mem b store a.      g~           T    (ß  T˘Ê" @p @      mos_memory_check: EDAC error on mem b store b.      ^           T    (®  T˘Ê; @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^           T    (©  T˘ËïÙ3 @p @      mos_memory_check: EDAC error on mem b store a..     g~           T    (™  T˘Ëï˘H @p @      mos_memory_check: EDAC error on mem b store b..     ^           T    (´  T˘Ëï¸h @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^      Ä    h    (¨  T˘Ë∆Å @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapaÄÄ  c¿çò Ä        T    (Æ  T˘Í‘≠ @p @      mos_memory_check: EDAC error on mem b store a.      æ           T    (Ø  T˘ÍŸ @p @      mos_memory_check: EDAC error on mem b store b.      ^           T    (∞  T˘Í›ä @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^      Ä    h    (±  T˘ÏFõÏ @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapa*ÄÄ  c¿çò Ä        T    (≤  T˘ÏÜµ£ @p @      mos_memory_check: EDAC error on mem b store a.      g~           T    (≥  T˘ÏÜπu @p @      mos_memory_check: EDAC error on mem b store b.      ^           T    (¥  T˘ÏÜΩê @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^      Ä    h    (µ  T˘Ì’„ @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapa*ÄÄ  c¿çò Ä   Ä    h    (∂  T˘Ìf°ì @  @      ioi_masked$interrupt: I/O error.‡  B22     Z   tapaVÄÄÄ0 c¿çò êÄ   ¿    P    (∑  T˘ÌhΩØ @  @      ioi_masked$interrupt: I/O error.¿ ◊B22        tapa ¿    P    (∏  T˘Ìi  @  @      ioi_masked$i bin,
  4    35 	       3 mbz_1	      (6) fixed bin (71),
  4    36 	     2 e		      (1024) like file_access_info;
  4    37 
  4    38 
  4    39      dcl	   FILE_ACCESS_TABLE_VERSION_1
  4    40 			      init ("FileAT 1") char (8) aligned static options (constant);
  4    41 
  4    42 /*  END INCLUDE FILE:    dm_fm_file_access_tbl.incl.pl1  */
      297 
      298 
  5     1 /* BEGIN INCULE FILE dm_fm_file_attributes.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*     
  5     5*     This include file contains the declaration of the file_attributes
  5     6*     structure.  An instance of this structure is stored in control interval 
  5     7*     zero of each DM file.  It describes the attributes of the file.
  5     8*
  5     9*     The structure is 896 bytes, or 224 words, long.
  5    10**/
  5    11 
  5    12 /* HISTORY:
  5    13*Written by Matthew Pierret, 06/15/84.
  5    14*   (Structure designed by Jeff Ives.) 
  5    15*Modified:
  5    16*11/06/84 by Matthew Pierret:  Changed mbz_rb1 from bit (28) to bit (30).
  5    17*            Removed the un-used version overlay and related constants.
  5    18**/
  5    19 
  5    20 /* format: style2,ind3 */
  5    21 
  5    22      dcl	   1 file_attributes      aligned based (file_attributes_ptr),
  5    23 	     2 version	      char (8) aligned,
  5    24 	     2 unique_id	      bit (36),
  5    25 	     2 ci_size_in_bytes   fixed bin (35),	/* control interval physical size, must be 4096	*/
  5    26 	     2 blocking_factor    fixed bin,		/* # of cis in each msf seg, must be 64 or 255	*/
  5    27 	     2 flags	      aligned,
  5    28 	       3 protected	      bit unal,		/* protected against inconsistency		*/
  5    29 	       3 no_concurrency   bit unal,		/* don't protect against concurrent access	*/
  5    30 	       3 no_rollback      bit unal,		/* don't protect against system failure		*/
  5    31 	       3 mbz_f1	      bit (33) unal,
  5    32 	     2 date_time_created  fixed bin (71),
  5    33 	     2 ring_brackets      aligned,
  5    34 	       3 write	      fixed bin (3) uns unal,
  5    35 	       3 read	      fixed bin (3) uns unal,
  5    36 	       3 mbz_rb1	      bit (30) bit unal,
  5    37 	     2 mbz_1	      fixed bin (35),	/* 10 words so far */
  5    38 	     2 mbz_2	      (9) fixed bin (71),	/* 28 words so far */
  5    39 	     2 time_last_dumped   fixed bin (71),	/* Not yet used */
  5    40 	     2 dump_file_path     char (168),		/* Not yet used */
  5    41 	     2 mbz_3	      (4) fixed bin (71),	/* 80 words so far */
  5    42 	     2 after_journal_path char (168),		/* Not yet used */
  5    43 	     2 mbz_4	      (50) fixed bin (71),	/* 222 words so far */
  5    44 	     2 mbz_5	      bit (54) unal,	/* 223.5 words so far */
  5    45 	     2 length_of_attributes
  5    46 			      fixed bin (17) unal;	/* 224 words total */
  5    47 
  5    48 
  5    49      dcl	   file_attributes_ptr    ptr init (null ());
  5    50 
  5    51      dcl	   FILE_ATTRIBUTES_VERSION_2
  5    52 			      init ("FilAtt02") char (8) aligned internal static options (constant);
  5    53 
  5    54 
  5    55 /* END INCLUDE FILE dm_fm_file_attributes.incl.pl1 */
      299 
      300 
  6     1 /* ******* BEGIN INCLUDE FILE dm_fm_sub_error_flags.incl.pl1 ******** */
  6     2 
  6     3 /* format: style2,ind3 */
  6     4 
  6     5 /* HISTORY:
  6     6*Written by Matthew Pierret, 07/02/83.
  6     7*Modified:
  6     8**/
  6     9 
  6    10      dcl	   1 fm_error_flags	      aligned based,
  6    11 	     2 action	      unal,
  6    12 	       3 cant_restart     bit (1) unal,
  6    13 	       3 default_restart  bit (1) unal,
  6    14 	       3 quiet_restart    bit (1) unal,
  6    15 	       3 support_signal   bit (1) unal,
  6    16 	       3 mbz_1	      bit (14) unal,
  6    17 	     2 log                unal,
  6    18 	       3 system	      bit (1) unal,
  6    19 	       3 mbz_2	      bit (1) unal,
  6    20 	     2 mbz_3	      bit (16) unal;
  6    21 
  6    22      dcl	   (
  6    23 	   FM_ACTION_CANT_RESTART init ("1000"b || (32)"0"b),
  6    24 	   FM_ACTION_CAN_RESTART  init ("0000"b || (32)"0"b),
  6    25 	   FM_ACTION_DEFAULT_RESTART
  6    26 			      init ("0100"b || (32)"0"b),
  6    27 	   FM_ACTION_QUIET_RESTART
  6    28 			      init ("0010"b || (32)"0"b),
  6    29 	   FM_ACTION_LOG	      init ((18)"0"b || "10"b || (16)"0"b)
  6    30 	   )		      bit (36) aligned internal static options (constant);
  6    31 
  6    32 /* ********* END INCLUDE FILE dm_fm_sub_error_flags.incl.pl1 ******** */
      301 
      302 
  7     1 /*  START OF:	dm_lock_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*
  7     5*     Hierarchical lock modes for Data Management control interval locking.  In
  7     6*addition to conventional read and write locks, intention locks are provided
  7     7*for finer locking granularity.
  7     8**/
  7     9 
  7    10 /* HISTORY:
  7    11*Written by Jeffrey D. Ives, 04/30/82.
  7    12*Modified:
  7    13*12/05/84 by Stanford S. Cox: Added Description.
  7    14**/
  7    15 /* format: style3,idind25 */
  7    16 
  7    17      dcl	   LOCK_MODE_S	      fixed bin static options (constant) init (2);
  7    18      dcl	   LOCK_MODE_X	      fixed bin static options (constant) init (3);
  7    19      dcl	   LOCK_MODE_IS	      fixed bin static options (constant) init (4);
  7    20      dcl	   LOCK_MODE_IX	      fixed bin static options (constant) init (5);
  7    21      dcl	   LOCK_MODE_SIX	      fixed bin static options (constant) init (6);
  7    22 
  7    23      dcl	   LOCK_ENTIRE_FILE	      fixed bin (27) static options (constant) init (-1);
  7    24 
  7    25      dcl	   LOCK_MODE_NAMES (2:6)  char (3) int static options (constant)
  7    26 			      init ("  S", "  X", " IS", " IX", "SIX");
  7    27 
  7    28 /*
  7    29*     S       Share                           Let others read it but not modify it.
  7    30*     X	   Exclusive		     Let nobody else read or modify it.
  7    31*     IS	   Intention Share		     I am only using S locks, because I am only reading CIs.
  7    32*     IX	   Intention Exclusive	     I am using S and X locks, because I am reading and modifying CIs.
  7    33*     SIX	   Share with Intention Exclusive  I am reading control intervals, but only locking the ones I modify.
  7    34**/
  7    35 
  7    36 /*  END OF:	dm_lock_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      303 
      304 
  8     1 /* BEGIN INCLUDE FILE dm_ci_lengths.incl.pl1 */
  8     2 
  8     3 /* DESCRIPTION:
  8     4*       This include file contains constants which are the length in bytes
  8     5*   of the addressable portion of a control interval.  The addressable portion
  8     6*   is that part of the control interval which callers of file_manager_
  8     7*   may access, specifically, everything between the end of the control
  8     8*   interval header (ci_header) and the control interval trailer (ci_trailer).
  8     9*   Control interval 0 is slightly different, as it also contains an 
  8    10*   unaddressable portion in which it maintains the file attributes.  For
  8    11*   control interval 0 the addressable portion is everything between the end
  8    12*   of the control interval header and the beginning of the file attributes.
  8    13**/
  8    14 
  8    15 /* HISTORY:
  8    16*Written by Matthew Pierret, 11/02/84.
  8    17*Modified:
  8    18**/
  8    19 
  8    20 /* format: style2,ind3 */
  8    21 
  8    22      dcl	   CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
  8    23 			      fixed bin (17) init (4072) int static options (constant);
  8    24 
  8    25      dcl	   CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
  8    26 			      fixed bin (17) init (3176) int static options (constant);
  8    27 
  8    28 
  8    29      dcl	   CI_ADDRESSABLE_LENGTH  fixed bin (17) init (4072) int static options (constant);
  8    30 
  8    31      dcl	   CI_0_ADDRESSABLE_LENGTH
  8    32 			      fixed bin (17) init (3176) int static options (constant);
  8    33 
  8    34 /* END INCLUDE FILE dm_ci_lengths.incl.pl1 */
      305 
      306 
  9     1 /*  BEGIN INCLUDE FILE:  dm_ci_parts.incl.pl1  */
  9     2 
  9     3 /* DESCRIPTION:
  9     4*
  9     5*        This include file contains the ci_parts structure.  This structure
  9     6*   is used across the file_manager_ interface to specify the parts of a
  9     7*   control interval to get or put.  If the number_of parts is equal to 0,
  9     8*   modules which take ci_parts interpret this case to mean to do everything
  9     9*   except the actual requested operation, i.e., lock the control interval
  9    10*   but don't get anything.  offset_in_bytes is the 0-originned offset in
  9    11*   bytes from the beginning of the addressable portion of the control interval.
  9    12*   An offset_in_bytes which is in the addressable portion is in error.
  9    13*   Likewise, if offset_in_bytes + length_in_bytes is outside of the addressable
  9    14*   portion, it is in error.
  9    15**/
  9    16 
  9    17 /* HISTORY:
  9    18*Written by Matthew Pierret, 01/28/82.
  9    19*  (01/28/82 Andre Bensoussan, Design.)
  9    20*Modified:
  9    21*11/07/84 by Matthew Pierret:  To add must_be_zero, initial attributes on
  9    22*            automatic storge.
  9    23**/
  9    24 
  9    25 /* format: style2,ind3 */
  9    26 
  9    27      dcl	   1 ci_parts	      aligned based (ci_parts_ptr),
  9    28 	     2 number_of_parts    fixed bin (17),
  9    29 	     2 must_be_zero	      fixed bin,
  9    30 	     2 part	      (cip_number_of_parts refer (ci_parts.number_of_parts)),
  9    31 	       3 offset_in_bytes  fixed bin (17),
  9    32 	       3 length_in_bytes  fixed bin (17),
  9    33 	       3 local_ptr	      ptr;
  9    34 
  9    35      dcl	   ci_parts_ptr	      ptr init (null ());
  9    36      dcl	   cip_number_of_parts    fixed bin (17) init (0);
  9    37 
  9    38 
  9    39 /*  BEGIN INCLUDE FILE:   dm_ci_parts.incl.pl1   */
      307 
      308 
 10     1 /* BEGIN INCLUDE FILE dm_log_sv_codes.incl.pl1 */
 10     2 
 10     3 /* format: ^indcom */
 10     4 
 10     5 /* DESCRIPTION:
 10     6*   These are the severity codes used by the dms daemon when calling its logger.
 10     7*   The severity is ranked thusly:
 10     8*
 10     9*   severity log write situation
 10    10*   -------- --- ----- ---------
 10    11*          0 no  yes   standard output, query, etc.
 10    12*          1 yes yes   fatal error, terminate dms daemon.
 10    13*          2 yes yes   nonfatal error.
 10    14*          3 yes yes   informative message.
 10    15*          4 yes no    log information only.
 10    16**/
 10    17 
 10    18 /* HISTORY:
 10    19*
 10    20*Written by M. Pandolf, 10/06/82.
 10    21*Modified:
 10    22*12/10/84 by R. Michael Tague: Rename and reformat description/history.
 10    23*01/13/85 by Lee A. Newcomb:  Renamed to dm_log_sv_codes from
 10    24*            dm_daemon_sv_codes as the severity codes for the DM log are not
 10    25*            restrained to the DM Daemon's use.
 10    26*01/24/85 by Lee A. Newcomb:  Fixed to say dm_log_sv_codes.incl.pl1 in the
 10    27*            BEGIN and END INCLUDE comments, instead of dm_daemon_sv_codes.==.
 10    28**/
 10    29 
 10    30 /* format: style5 */
 10    31 
 10    32      dcl	   (PRINT_SV, QUERY_SV)    fixed bin internal static
 10    33 			       options (constant) init (0);
 10    34      dcl	   (CRASH_SV, FATAL_SV)    fixed bin internal static
 10    35 			       options (constant) init (1);
 10    36      dcl	   ERROR_SV	       fixed bin internal static
 10    37 			       options (constant) init (2);
 10    38      dcl	   INFORM_SV	       fixed bin internal static
 10    39 			       options (constant) init (3);
 10    40      dcl	   LOG_SV		       fixed bin internal static
 10    41 			       options (constant) init (4);
 10    42 
 10    43 /* END INCLUDE FILE dm_log_sv_codes.incl.pl1 */
      309 
      310 
      311    end fm_prepare_to_copy_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAMnterrupt: I/O error.‡ - B22        tapa ¿    P    (π  T˘Ìiq∂ @  @      ioi_masked$interrupt: I/O error.¿ ¿B22        tapa ¿    P    (∫  T˘ÌjVŸ @  @      ioi_masked$interrupt: I/O error.¿ -B22        tapa ¿    L    (ª  T˘Ìj]~  h  @      RCP: Detached tapa_00 from Backup.SysDaemon.z        Ä    D    (º  T˘ÌmÕÚ  @  @      RCP: Errors (tapa_00, volume COM229) = 9     ¿    L    (Ω  T˘Ìpaµ  x  @      RCP: Unassigned tapa_00 from Backup.SysDaemon.z      Ä    H    (æ  T˘Ìu˜&  X  @      RCP: Assigned tapa_00 to Backup.SysDaemon.zo Ä    H    (ø  T˘ÌvCÇ  `  @      RCP: Attached tapa_00 for Backup.SysDaemon.z Ä    H    (¿  T˘Ìy A  H  @      RCP: Note (tapa_00) - COM230,den=6250,sysn.z @    `    (¡  T˘Ì| ¡  @      RCP: Mount Reel COM230 with ring on tapa_00 for Backup.SysDaemon.z        T    (¬  T˘Ó˛òP @p @      mos_memory_check: EDAC error on mem b store a.r     æ           T    (√  T˘Ó˛ùr @p @      mos_memory_check: EDAC error on mem b store b.r     ^           T    (ƒ  T˘Ó˛†¿ @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^      Ä    d    (≈  T˘ÔºK ¡@  @      RCP: Check Mount of COM230 for writing on tapa_00 for Backup.SysDaemon.z     Ä    H    (∆  T˘Ô_s  H  @      RCP: Note (tapa_00) - COM230,den=6250,sys ta Ä    d    («  T˘¶Á, ¡@  @      RCP: Check Mount of COM230 for writing on tapa_00 for Backup.SysDaemon.z     Ä    H    (»  T˘™â·  H  @      RCP: Note (tapa_00) - COM230,den=6250,sys ta ¿    P    (…  T˘¥X @  @      ioi_masked$interrupt: I/O error.‡ 0 B22     (  tapa ¿    P    (   T˘¥( @  @      ioi_masked$interrupt: I/O error.¿ 1¿B22     (  tapa ¿    P    (À  T˘µœh @  @      ioi_masked$interrupt: I/O error.¿ 4¿B22     (B  tapa ¿    P    (Ã  T˘¬m“ @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Q  tapa Ä    h    (Õ  T˘≈Rè @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapaBÄÄ  c¿çò Ä   Ä    h    (Œ  T˘…ÀÇ @  @      ioi_masked$interrupt: I/O error.¿ &¿B22     Z   tapaBÄÄ  c¿çò Ä   Ä    h    (œ  T˘Ã{ÿ @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapaRÄÄ  c¿çò Ä   Ä    h    (–  T˘‰¸6 @  @      ioi_masked$interrupt: I/O error.¿ &¿B22     Z   tapaRÄÄ  c¿çò Ä   Ä    h    (—  T˘ËÌ√ @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapaBÄÄ  c¿çò Ä   Ä    h    (“  T˘ˆéÌ @  @      ioi_masked$interrupt: I/O error.¿ &¿B22     Z   tapaRÄÄ  c¿çò Ä        T    (”  T˘Òw} @p @      mos_memory_check: EDAC error on mem b store a.      g~           T    (‘  T˘ÒwÇ∏ @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^      Ä    h    (’  T˘Ò®Iª @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapaBÄÄ  c¿çò Ä   Ä    h    (Ÿ  T˘Ú«÷} @  @      ioi_masked$interrupt: I/O error.¿  B22     Z   tapaRÄÄ  c¿çò Ä   Ä    h    (⁄  T˘ÚÅ1 @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapa Ä  c¿çò Ä   Ä    h    (€  T˘Ûá⁄® @  @      ioi_masked$interrupt: I/O error.¿  B22     Z   tapaRÄÄ  c¿çò Ä        T    (‹  T˘ÛÔZ€ @p @      mos_memory_check: EDAC error on mem b store a.      g~           T    (›  T˘ÛÔ_6 @p @      mos_memory_check: EDAC error on mem b store b.      ^           T    (ﬁ  T˘ÛÔb= @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^      Ä    h    (ﬂ  T˘Ù√á¬ @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapaBÄÄ  c¿çò Ä   Ä    h    (‡  T˘Ù«0Õ @  @      ioi_masked$interrupt: I/O error.Œ  B22     Z   tapaRÄÄ  c¿çò Ä        T    (·  T˘ıh>‹ @p @      mos_memory_check: EDAC error on mem b store a.      g~           T    (‚  T˘ıhCl @p @      mos_memory_check: EDAC error on mem b store b.      ^      Ä    h    („  T˘ˆGCS @  @      ioi_masked$interrupt: I/O error.Œ  B22     Z   tapaÄÄÄ0 c¿çò êÄ        T    (‰  T˘˜‡Ç @p @      mos_memory_check: EDAC error on mem b store a.      æ           T    (Â  T˘˜‡ ﬂ @p @  m_prepare_to_copy_" set ref 72*
                                                                                  231*
char                                                   builtin function         dcl 85 ref 174 174 194 194 211 211 211 211 221 221
                                                                                  221 221
ci_parts                               based           structure                level 1 dcl 9-27
ci_parts_ptr                    000754 automatic       pointer                  initial dcl 9-35 set ref 9-35*
ci_size_in_bytes          3            based           fixed bin(35,0)          level 2 in structure "file_attributes" dcl 5-22
                                                                                  in procedure "fm_prepare_to_copy_" ref 230
ci_size_in_bytes          2     000240 automatic       fixed bin(35,0)          initial level 2 in structure "my_create_info" dcl 72
                                                                                  in procedure "fm_prepare_to_copy_" set ref 72*
                                                                                  230*
cip_number_of_parts             000756 automatic       fixed bin(17,0)          initial dcl 9-36 set ref 9-36*
cleanup                         000732 stack reference condition                dcl 90 ref 166
code                            000100 automatic       fixed bin(35,0)          initial dcl 66 set ref 66* 173* 174 174* 178* 179
                                                                                  179* 193* 194 194* 207* 208 208*
cu_$level_get                   000010 constant        entry                    external dcl 100 ref 165
cu_$level_set                   000012 constant        entry                    external dcl 101 ref 167 286
dir_path                        000101 automatic       char(168)                unaligned dcl 67 set ref 178*
dm_data_$current_txn_id         000034 external static bit(36)                  dcl 115 ref 186
dm_error_$bad_file_atrs_length  000036 external static fixed bin(35,0)          dcl 118 set ref 211*
dm_error_$bad_file_atrs_uid     000040 external static fixed bin(35,0)          dcl 120 set ref 221*
dm_error_$bad_file_atrs_ver     000042 external static fixed bin(35,0)          dcl 122 set ref 216*
dm_error_$bad_file_cr_info_ver  000044 external static fixed bin(35,0)          dcl 124 set ref 138*
dm_error_$bad_file_oid          000046 external static fixed bin(35,0)          dcl 126 set ref 144* 150* 156* 159*
dm_error_$file_doesnt_exist     000050 external static fixed bin(35,0)          dcl 127 set ref 153* 162*
dm_error_$no_current_transaction
                                000052 external static fixed bin(35,0)          dcl 129 set ref 186*
e                        20            based           structure                array level 2 dcl 4-29 ref 144 148
entry_name                      000153 automatic       char(32)                 unaligned dcl 68 set ref 173* 178*
entry_state                     000350 automatic       fixed bin(17,0)          level 3 packed unaligned dcl 77 set ref 150
er_p_code                              parameter       fixed bin(35,0)          dcl 261 ref 258 263
expand_pathname_                000014 constant        entry                    external dcl 102 ref 178
file_access_info                       based           structure                level 1 dcl 3-33
file_access_info_ptr            000750 automatic       pointer                  initial dcl 3-61 set ref 3-61*
file_access_table                      based           structure                level 1 dcl 4-29
file_access_table_idx           000730 automatic       fixed bin(17,0)          level 2 packed unaligned dcl 79 set ref 144 144 148
file_attributes                        based           structure                level 1 dcl 5-22
file_attributes_ptr             000752 automatic       pointer                  initial dcl 5-49 set ref 202* 205 211 211 211 216
                                                                                  216 221 221 221 230 231 232 233 234 235 236 5-49*
file_create_info                       based           structure                level 1 dcl 1-21 set ref 246*
file_create_info_ptr            000746 automatic       pointer                  dcl 1-41 set ref 137* 138 138 246
file_oid                               based           structure                level 1 dcl 2-23
file_state                0(18) 000350 automatic       fixed bin(17,0)          level 3 packed unaligned dcl 77 set ref 153
fixed                                                  builtin function         dcl 85 ref 174 174
flags                     4     000240 automatic       structure                level 2 in structure "my_create_info" packed
                                                                                  unaligned dcl 72 in procedure
                                                                                  "fm_prepare_to_copy_"
flags                     5            based           structure                level 2 in structure "file_attributes" dcl 5-22
                                                                                  in procedure "fm_prepare_to_copy_"
fm_data_$file_access_table_ptr  000054 external static pointer                  dcl 4-26 ref 144 144 148
fm_error_util_$get_code         000016 constant        entry                    external dcl 103 ref 134 134
fm_error_util_$signal           000020 constant        entry                    external dcl 105 ref 277
fm_get_$internal_get            000022 constant        entry                    external dcl 106 ref 207
fm_get_last_ci_num              000024 constant        entry                    external dcl 107 ref 250
fm_sub_error_                   000740 stack reference condition                dcl 91 ref 134
full_path_name                  000163 automatic       char(168)                unaligned dcl 69 set ref 173* 178* 194* 211 221 250*
get_ring_                       000026 constant        entry                    external dcl 108 ref 167 167
h                                      based           structure                level 2 dcl 4-29
hcs_$fs_get_path_name           000030 constant        entry                    external dcl 109 ref 173
integrity_switches        2(27) 000350 automatic       structure                level 2 packed unaligned dcl 77
last_entry                2            based           fixed bin(17,0)          level 3 dcl 4-29 ref 144
lbound                                                 builtin function         dcl 85 ref 144
length_in_bytes           3     000342 automatic       fixed bin(17,0)          array level 3 dcl 73 set ref 204*
length_of_attributes    337(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 5-22 ref 211 211 211
ler_p_code                             parameter       fixed bin(35,0)          dcl 273 set ref 270 277*
ler_p_error_message                    parameter       char                     unaligned dcl 274 set ref 270 277*
ler_p_error_message_argument_1         parameter       char                     unaligned dcl 274 set ref 270 277*
ler_p_error_message_argument_2         parameter       char                     unaligned dcl 274 set ref 270 277*
local_ptr                 4     000342 automatic       pointer                  array level 3 dcl 73 set ref 205*
lock                      2(29) 000350 automatic       bit(1)                   level 3 packed unaligned dcl 77 set ref 190
lock_manager_$lock              000032 constant        entry                    external dcl 110 ref 193
mbz_1                     4(03) 000240 automatic       bit(15)                  initial level 3 packed unaligned dcl 72 set ref 72*
mbz_3                     4(26) 000240 automatic       bit(46)                  initial level 2 packed unaligned dcl 72 set ref 72*
must_be_zero              1     000342 automatic       fixed bin(17,0)          initial level 2 dcl 73 set ref 73*
my_ci_part                      000342 automatic       structure                level 1 dcl 73 set ref 207 207
my_create_info                  000240 automatic       structure                level 1 dcl 72 set ref 228* 246
my_file_access_info             000350 automatic       structure                level 1 dcl 77 set ref 148*
my_file_attributes              000370 automatic       structure                level 1 dcl 78 set ref 201* 202
my_file_oid                     000730 automatic       structure                level 1 dcl 79 set ref 136* 207 207
no_concurrency            5(01)        based           bit(1)                   level 3 in structure "file_attributes" packed
                                                                                  unaligned dcl 5-22 in procedure
                                                                                  "fm_prepare_to_copy_" ref 233
no_concurrency            4(01) 000240 automatic       bit(1)                   initial level 3 in structure "my_create_info" packed
                                                                                  unaligned dcl 72 in procedure
                                                                                  "fm_prepare_to_copy_" set ref 72* 233*
no_rollback               5(02)        based           bit(1)                   level 3 in structure "file_attributes" packed
                                                                                  unaligned dcl 5-22 in procedure
                                                                                  "fm_prepare_to_copy_" ref 234
no_rollback               4(02) 000240 automatic       bit(1)                   initial level 3 in structure "my_create_info" packed
                                                                                  unaligned dcl 72 in procedure
                                                                                  "fm_prepare_to_copy_" set ref 72* 234*
null                                                   builtin function         dcl 85 ref 71 3-61 5-49 9-35
number_of_parts                 000342 automatic       fixed bin(17,0)          initial level 2 dcl 73 set ref 73*
offset_in_bytes           2     000342 automatic       fixed bin(17,0)          array level 3 dcl 73 set ref 203*
opens                     6     000350 automatic       fixed bin(17,0)          level 2 packed unaligned dcl 77 set ref 156
p_code                                 parameter       fixed bin(35,0)          dcl 62 set ref 52 252* 263*
p_file_create_info_ptr                 parameter       pointer                  dcl 60 ref 52 137
p_file_oid                             parameter       bit(36)                  dcl 59 ref 52 136
p_last_ci_num                          parameter       fixed bin(27,0)          dcl 61 set ref 52 250*
part                      2     000342 automatic       structure                array level 2 in structure "my_ci_part" dcl 73
                                                                                  in procedure "fm_prepare_to_copy_"
part                      2            based           structure                array level 2 in structure "ci_parts" dcl 9-27
                                                                                  in procedure "fm_prepare_to_copy_"
protected                 4     000240 automatic       bit(1)                   initial level 3 in structure "my_create_info" packed
                                                                                  unaligned dcl 72 in procedure
                                                                                  "fm_prepare_to_copy_" set ref 72* 232*
protected                 5            based           bit(1)                   level 3 in structure "file_attributes" packed
                                                                                  unaligned dcl 5-22 in procedure
                                                                                  "fm_prepare_to_copy_" ref 232
read                     10(03)        based           fixed bin(3,0)           level 3 packed unsigned unaligned dcl 5-22 ref 236
ring_brackets                mos_memory_check: EDAC error on mem b store b.      ^           T    (Ê  T˘˜‡$˚ @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^      Ä    h    (Á  T˘¯*œ® @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapaÄÄ  c¿çò Ä   Ä    h    (Í  T˘¯6Ò @  @      ioi_masked$interrupt: I/O error.¿ &¿B22     Z   tapaÄÄ  c¿çò Ä   Ä    h    (Ï  T˘¯Ar_ @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapaÄÄ  c¿çò Ä   ¿    P    (Ó  T˘¯F˚n @  @      ioi_masked$interrupt: I/O error.¿ ¿B22        tapa ¿    P    (Ô  T˘¯G/Û @  @      ioi_masked$interrupt: I/O error.¿ -¿B22        tapa ¿    P    (  T˘¯GíÄ @  @      ioi_masked$interrupt: I/O error.¿ ¡B22        tapa ¿    P    (Ò  T˘¯Gí‘ @  @      ioi_masked$interrupt: I/O error.¿ -B22        tapa ¿    L    (Ú  T˘¯Gò   h  @      RCP: Detached tapa_00 from Backup.SysDaemon.z        Ä    H    (Û  T˘¯J`∑  H  @      RCP: Errors (tapa_00, volume COM230) = 23on. ¿    L    (Ù  T˘¯M¬  x  @      RCP: Unassigned tapa_00 from Backup.SysDaemon.z           T    (ı  T˘˙Y  @p @      mos_memory_check: EDAC error on mem b store a.z     æ           T    (ˆ  T˘˙Y @p @      mos_memory_check: EDAC error on mem b store b.z     ^           T    (˜  T˘˙YO @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^           T    (¯  T˘¸—ÂÌ @p @      mos_memory_check: EDAC error on mem b store a..     æ           T    (˘  T˘¸—Í£ @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^      Ä    H    (˙  T˘˝ $ù  X  @      RCP: Assigned tapa_00 to Backup.SysDaemon.z  Ä    H    (˚  T˘˝H6  `  @      RCP: Attached tapa_00 for Backup.SysDaemon.z Ä    H    (¸  T˘˝Ê  H  @      RCP: Note (tapa_00) - COM231,den=6250,sysn.z @    `    (˝  T˘˝ıª ¡  @      RCP: Mount Reel COM231 with ring on tapa_00 for Backup.SysDaemon.z    ¿    0    (˛  T˘˝Ìﬁ  ¿†  @      RCP: Reready tapa_00 ¿    P    (ˇ  T˘˛ˇ“ @  @      ioi_masked$interrupt: I/O error.¿  ¿B22       tapa ¿    P    )   T˘˛Qu] @  @      ioi_masked$interrupt: I/O error.¿ 0¿B22     (  tapa ¿    P    )  T˘˛Qò· @  @      ioi_masked$interrupt: I/O error.¿ 1¿B22     (  tapa ¿    P    )  T˘˛Rd @  @      ioi_masked$interrupt: I/O error.¿ 4¿B22     (B  tapa ¿    P    )  T˘˛Hﬁ @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Q  tapa      T    )  T˘˛I¬Å @p @      mos_memory_check: EDAC error on mem b store a.      æ           T    )  T˘˛I«Ñ @p @      mos_memory_check: EDAC error on mem b store b.      ^           T    )  T˘˛I œ @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^      Ä    h    )  T˘ˇà¥ @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapabÄÄ  c¿çò Ä        T    )
  T˙ ¬® @p @      mos_memory_check: EDAC error on mem b store a.      æ           T    )  T˙ ¬¨J @p @      mos_memory_check: EDAC error on mem b store b.      ^           T    )  T˙ ¬∞« @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^      Ä    h    )  T˙à@õ @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapaäÄÄ  c¿çò Ä        T    )  T˙:ç≠ @p @      mos_memory_check: EDAC error on mem b store a.      æ      Ä    h    )  T˙»]◊ @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapa*ÄÄ  c¿çò Ä   Ä    h    )  T˙»_9 @  @      ioi_masked$interrupt: I/O error.«  B22     Z   tapafÄÄ 0 c¿çò Ä   ¿    P    )  T˙b´U @  @      ioi_masked$interrupt: I/O error.¿ ¿B22        tapa ¿    P    )  T˙bÊ0 @  @      ioi_masked$interrupt: I/O error.¿ -¿B22        tapa ¿    P    )  T˙cœ˝ @  @      ioi_masked$interrupt: I/O error.¿ ∆B22        tapa ¿    P    )  T˙cÂ} @  @      ioi_masked$interrupt: I/O error.¿ -B22        tapa ¿    L    )  T˙cÎ  h  @      RCP: Detached tapa_00 from Backup.SysDaemon.z        Ä    D    )  T˙f±a  @  @      RCP: Errors (tapa_00, volume COM231) = 9     ¿    L    )  T˙i6¬  x  @  QUIET_RESTART                internal static bit(36)                  initial dcl 6-22
INFORM_SV                              internal static fixed bin(17,0)          initial dcl 10-38
LOCK_MODE_IS                           internal static fixed bin(17,0)          initial dcl 7-19
LOCK_MODE_IX                           internal static fixed bin(17,0)          initial dcl 7-20
LOCK_MODE_NAMES                        internal static char(3)                  initial array unaligned dcl 7-25
LOCK_MODE_S                            internal static fixed bin(17,0)          initial dcl 7-17
LOCK_MODE_SIX                          internal static fixed bin(17,0)          initial dcl 7-21
PRINT_SV                               internal static fixed bin(17,0)          initial dcl 10-32
QUERY_SV                               internal static fixed bin(17,0)          initial dcl 10-32
fm_error_flags                         based           structure                level 1 dcl 6-10

NAMES DECLARED BY EXPLICIT CONTEXT.
ERROR_RETURN                    001453 constant        entry                    internal dcl 258 ref 134 144 150 153 156 159 162 179
                                                                                  186 208
FINISH                          001571 constant        entry                    internal dcl 283 ref 166 253 264
LOG_ERROR_RETURN                001476 constant        entry                    internal dcl 270 ref 138 174 194 211 216 221
MAIN_RETURN                     001451 constant        label                    dcl 255 ref 265
fm_prepare_to_copy_             000216 constant        entry                    external dcl 52

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2154        2232    1623        2164
Length      2670    1623        56         421     330           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
fm_prepare_to_copy_                 719 external procedure  is an external procedure.  
on unit on line 134                  76 on unit               
on unit on line 166                  64 on unit               
ERROR_RETURN                         64 internal procedure  is called by several nonquick procedures.  
LOG_ERROR_RETURN                     98 internal procedure  is called during a stack extension.  
FINISH                               68 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
fm_prepare_to_copy_      000100 code                        fm_prepare_to_copy_
                         000101 dir_path                    fm_prepare_to_copy_
                         000153 entry_name                  fm_prepare_to_copy_
                         000163 full_path_name              fm_prepare_to_copy_
                         000235 saved_validation_level      fm_prepare_to_copy_
                         000236 seg_0_ptr                   fm_prepare_to_copy_
                         000240 my_create_info              fm_prepare_to_copy_
                         000342 my_ci_part                  fm_prepare_to_copy_
                         000350 my_file_access_info         fm_prepare_to_copy_
                         000370 my_file_attributes          fm_prepare_to_copy_
                         000730 my_file_oid                 fm_prepare_to_copy_
                         000746 file_create_info_ptr        fm_prepare_to_copy_
                         000750 file_access_info_ptr        fm_prepare_to_copy_
                         000752 file_attributes_ptr         fm_prepare_to_copy_
                         000754 ci_parts_ptr                fm_prepare_to_copy_
                         000756 cip_number_of_parts         fm_prepare_to_copy_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this
call_int_other      return              tra_ext             enable              shorten_stack       ext_entry
int_entry           int_entry_desc      any_to_any_tr

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$level_get                 cu_$level_set                 expand_pathname_              fm_error_util_$get_code
fm_error_util_$signal         fm_get_$internal_get          fm_get_last_ci_num            get_ring_
hcs_$fs_get_path_name         lock_manager_$lock

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_data_$current_txn_id       dm_error_$bad_file_atrs_length                              dm_error_$bad_file_atrs_uid
dm_error_$bad_file_atrs_ver   dm_error_$bad_file_cr_info_ver                              dm_error_$bad_file_oid
dm_error_$file_doesnt_exist   dm_error_$no_current_transaction
fm_data_$file_access_table_ptr




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     52 000211        66 000223        70 000224        71 000225        72 000227        73 000263    3   61 000266
 5   49 000270    9   35 000271    9   36 000272       134 000273       136 000325       137 000330       138 000333
    144 000371       148 000412       150 000423       153 000434       156 000450       159 000462       162 000500
    165 000512       166 000521       167 000543       171 000563       173 000570       174 000622       178 000665
    179 000711       183 000721       186 000724       190 000735       193 000740       194 000762       201 001023
    202 001026       203 001030       204 001032       205 001034       207 001035       208 001057       211 001067
    216 001200       221 001240       228 001350       229 001354       230 001356       231 001361       232 001363
    233 001367       234 001373       235 001377       236 001407       246 001420       250 001424       252 001443
    253 001445       255 001451       258 001452       263 001460       264 001465       265 001472       270 001475
    277 001523       280 001567       283 001570       286 001576       289 001607


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
