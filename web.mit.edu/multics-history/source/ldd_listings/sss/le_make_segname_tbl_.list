	COMPILATION LISTING OF SEGMENT le_make_segname_tbl_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 12/10/86  1257.1 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /****^  HISTORY COMMENTS:
        8*  1) change(86-08-12,Elhard), approve(86-08-12,MCR7505),
        9*     audit(86-12-10,DGHowe), install(86-12-10,MR12.0-1241):
       10*     Originally written to create the segname table containing names to be
       11*     used to resolve external references.
       12*                                                   END HISTORY COMMENTS */
       13 
       14 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       15 
       16 le_make_segname_tbl_:
       17   proc (leip,			/** le_input pointer    (in )	*/
       18        lecp,			/** le_components ptr   (i/o) */
       19        leshp,			/** segname hashtbl ptr (i/o) */
       20        leap);			/** le_area pointer	    (in ) */
       21 
       22   /*** ****************************************************************/
       23   /***							*/
       24   /***	Name:	le_make_segname_tbl_			*/
       25   /***	Input:	leip, lecp, leshp, leap			*/
       26   /***	Function:	creates the segname and definition tables from	*/
       27   /***		the input and component tables.		*/
       28   /***	Output:	lecp, leshp				*/
       29   /***							*/
       30   /*** ****************************************************************/
       31 
       32   /* constants */
       33 
       34   dcl true		bit (1) static options (constant) init ("1"b);
       35   dcl false		bit (1) static options (constant) init ("0"b);
       36   dcl None		fixed bin static options (constant) init (0);
       37 
       38   /* parameters */
       39 
       40   dcl leip		ptr parameter;
       41   dcl lecp		ptr parameter;
       42   dcl leshp		ptr parameter;
       43   dcl leap		ptr parameter;
       44 
       45   /* procedures */
       46 
       47   dcl get_temp_segments_	entry (char (*), (*) ptr, fixed bin (35));
       48   dcl hash_$make		entry (ptr, fixed bin, fixed bin (35));
       49   dcl hash_$in		entry (ptr, char (*), bit (36) aligned,
       50 			fixed bin (35));
       51   dcl hash_$opt_size	entry (fixed bin) returns (fixed bin);
       52   dcl hash_$search		entry (ptr, char (*), bit (36) aligned,
       53 			fixed bin (35));
       54   dcl le_error_		entry options (variable);
       55   dcl rehash_		entry (ptr, fixed bin, fixed bin (35));
       56   dcl release_temp_segments_	entry (char (*), (*) ptr, fixed bin (35));
       57 
       58   /* external */
       59 
       60   dcl error_table_$full_hashtbl
       61 			external fixed bin (35);
       62   dcl error_table_$namedup	external fixed bin (35);
       63   dcl le_data_$caller	external char (32) varying;
       64   dcl le_et_$dup_segname	external fixed bin (35);
       65   dcl le_et_$entrypoints_inaccessible
       66 			external fixed bin (35);
       67   dcl le_et_$implementation_error
       68 			external fixed bin (35);
       69 
       70   /* based */
       71 
       72   dcl 01 acc		aligned based (accp),
       73        02 count		fixed bin (9) unsigned unaligned,
       74        02 string		char (0 refer (acc.count)) unaligned;
       75   dcl 01 def		aligned like definition based (defp);
       76   dcl 01 dh		aligned like definition_header based (dhp);
       77   dcl le_area		area based (leap);
       78   dcl 01 lec		aligned based (lecp),
       79        02 header		aligned like le_components.header,
       80        02 comp		dim (0 refer (lec.n_components)) like le_comp;
       81   dcl 01 led		aligned based (ledp),
       82        02 header		aligned like le_definitions.header,
       83        02 def		dim (def_count refer (led.n_defs))
       84 			like le_definition;
       85   dcl 01 lei		aligned based (leip),
       86        02 header		aligned like le_input.header,
       87        02 opt		dim (0 refer (lei.n_opts)) like le_option;
       88   dcl 01 les		aligned based (lesp),
       89        02 header		aligned like le_segnames.header,
       90        02 segname		dim (segname_count refer (les.n_segnames))
       91 			like le_segnames.segname;
       92   dcl word		fixed bin (35) based;
       93 
       94   /* automatic */
       95 
       96   dcl accp		ptr automatic;
       97   dcl c			fixed bin automatic;
       98   dcl def_list		fixed bin automatic;
       99   dcl defp		ptr automatic;
      100   dcl defx		fixed bin automatic;
      101   dcl dhp			ptr automatic;
      102   dcl ec			fixed bin (35) automatic;
      103   dcl has_segname		bit (1) automatic;
      104   dcl i			fixed bin automatic;
      105   dcl ledp		ptr automatic;
      106   dcl lesp		ptr automatic;
      107   dcl offset		fixed bin (18) unsigned automatic;
      108   dcl real_defs		fixed bin automatic;
      109   dcl success		bit (1) automatic;
      110   dcl ts			(2) ptr automatic;
      111 
      112   /* conditions */
      113 
      114   dcl cleanup		condition;
      115 
      116   /* builtin */
      117 
      118   dcl addr		builtin;
      119   dcl addrel		builtin;
      120   dcl null		builtin;
      121   dcl string		builtin;
      122   dcl unspec		builtin;
      123 
      124   /* since we don't know how many segnames we will have, star with	*/
      125   /* an assumption of 1000					*/
      126 
      127   call hash_$make (leshp, hash_$opt_size (1000), ec);
      128 
      129   ts (1) = null;
      130 
      131   on cleanup
      132     begin;
      133     if ts (1) ^= null
      134       then call release_temp_segments_ ((le_data_$caller), ts, 0);
      135   end;
      136 
      137   /* segname and definition tables are originally created in temp	*/
      138   /* segs so that they can be grown dynamically, and then allocated	*/
      139   /* in the le_ area.					*/
      140 
      141   call get_temp_segments_ ((le_data_$caller), ts, ec);
      142   lesp = ts (1);
      143   ledp = ts (2);
      144 
      145   do c = 1 to lec.n_components;
      146 
      147     has_segname = false;
      148     real_defs = 0;
      149     les.n_segnames = None;
      150     led.n_defs = None;
      151 
      152     /* add the component name as a segname and make it the block	*/
      153     /* head if we are not using automatic segname generation	*/
      154 
      155     if ^lei.flags.auto_segnames
      156       then do;
      157         call add_segname (lecp, leshp, lesp, c, (lec.comp (c).name), success);
      158         has_segname = has_segname | success;
      159       end;
      160 
      161     /* copy the definitions into the definition table */
      162 
      163     dhp = lec.comp (c).orig.defnp;
      164     offset = dh.def_list_relp;
      165     defp = addrel (dhp, offset);
      166     def_list = None;
      167 
      168     do while (defp -> word ^= 0);
      169 
      170       /* copy all non-segname definitions */
      171 
      172       if def.class ^= 3
      173         then do;
      174 
      175 	accp = addrel (dhp, def.name_relp);
      176 
      177 	/* make a segname for this definition if it is not a	*/
      178 	/* symbol_table definition and we are generating automatic	*/
      179 	/* segnames from the entrypoint names.			*/
      180 
      181 	if (acc.string ^= "symbol_table") &
      182 	     lei.flags.auto_segnames & ^def.flags.ignore
      183 	  then do;
      184 
      185 	    /* add the definition as a segname */
      186 
      187 	    call add_segname (lecp, leshp, lesp, c, acc.string, success);
      188 	    has_segname = has_segname | success;
      189 
      190 	  end;
      191 
      192 	/* add the definition to the table */
      193 
      194 	if acc.string ^= "symbol_table"
      195 	  then real_defs = real_defs + 1;
      196 	  
      197 	defx, led.n_defs = led.n_defs + 1;
      198 	led.def (defx).str = acc.string;
      199 	led.def (defx).offset = offset;
      200 	led.def (defx).type = def.class;
      201 	led.def (defx).relp = def.thing_relp;
      202 	led.def (defx).new_offset = None;
      203 	string (led.def (defx).flags) = ""b;
      204 	led.def (defx).flags.force_retain = def.flags.retain;
      205 	led.def (defx).flags.entrypoint = def.flags.entry;
      206 	led.def (defx).flags.ignore = def.flags.ignore;
      207 	def_list = defx;
      208         end;
      209 
      210       /* skip to the next definition */
      211 
      212       offset = def.forward_relp;
      213       defp = addrel (dhp, offset);
      214     end;
      215 
      216     /* scan the input options for synonyms for this component */
      217 
      218     do i = 1 to lei.n_opts;
      219       if lei.opt (i).type = SYNONYM & ^lei.opt (i).flags.used &
      220 	 ^lei.opt (i).flags.ignore
      221         then do;
      222 
      223 	if lei.opt (i).name = lec.comp (c).name
      224 	  then do;
      225 
      226 	    /* mark the options as used */
      227 
      228 	    lei.opt (i).flags.used = true;
      229 
      230 	    /* add the segname to the table */
      231 
      232 	    call add_segname (lecp, leshp, lesp, c,
      233 	         lei.opt (i).path_or_ep, success);
      234 	    has_segname = has_segname | success;
      235 	  end;
      236         end;
      237     end;
      238 
      239     /* if we could not put any segnames on this block, then we can't	*/
      240     /* ever find any of the entrypoints, so delete them and complain.	*/
      241 
      242     if ^has_segname
      243       then do;
      244 
      245         /* print a message only if we are losing entrypoints in a	*/
      246         /* required component (that had entrypoints to begin with)	*/
      247 
      248         if ^lec.comp (c).flags.library & real_defs > 0
      249 	then call le_error_ (LE_ERROR, le_et_$entrypoints_inaccessible,
      250 		"^/^a", lec.comp (c).name);
      251         
      252         segname_count = 0;
      253         def_count = 0;
      254         
      255         allocate le_segnames in (le_area) set (lesp);
      256         allocate le_definitions in (le_area) set (ledp);
      257         
      258         lec.comp (c).tables.lesp = lesp;
      259         lec.comp (c).tables.ledp = ledp;
      260         
      261         lesp = ts (1);
      262         ledp = ts (2);
      263         
      264       end;
      265       else do;
      266 
      267         /* allocate copies of the tables, set the component pointers	*/
      268         /* and copy the tables.				*/
      269 
      270         segname_count = les.n_segnames;
      271         def_count = led.n_defs;
      272 
      273         allocate le_segnames in (le_area) set (lesp);
      274         allocate le_definitions in (le_area) set (ledp);
      275 
      276         unspec (les) = unspec (ts (1) -> les);
      277         unspec (led) = unspec (ts (2) -> led);
      278 
      279         lec.comp (c).tables.lesp = lesp;
      280         lec.comp (c).tables.ledp = ledp;
      281 
      282         lesp = ts (1);
      283         ledp = ts (2);
      284       end;
      285 
      286   end;
      287 
      288   call release_temp_segments_ ((le_data_$caller), ts, 0);
      289 
      290   return;
      291 
      292 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      293 
      294 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      295 
      296 
      297 add_segname:
      298   proc (lecp,			/** components pointer  (in )	*/
      299        leshp,			/** seg hash tbl ptr    (i/o)	*/
      300        lesp,			/** segnames pointer    (i/o) */
      301        comp,			/** component index	    (in ) */
      302        name,			/** name to add	    (in ) */
      303        success);			/** success flag	    (out) */
      304 
      305   /*** ****************************************************************/
      306   /***							*/
      307   /***	Name:	add_segname				*/
      308   /***	Input:	leshp, lesp, name				*/
      309   /***	Function:	adds a segname definition to the segname table	*/
      310   /***		and hashes it into the hash table.		*/
      311   /***	Output:	leshp, lesp, success			*/
      312   /***							*/
      313   /*** ****************************************************************(/
      314*  
      315*  /* parameters */
      316 
      317   dcl lecp		ptr parameter;
      318   dcl leshp		ptr parameter;
      319   dcl lesp		ptr parameter;
      320   dcl comp		fixed bin parameter;
      321   dcl name		char (*) parameter;
      322   dcl success		bit (1) parameter;
      323 
      324   /* based */
      325 
      326   dcl 01 lec		aligned based (lecp),
      327        02 header		aligned like le_components.header,
      328        02 comp		dim (0 refer (lec.n_components)) like le_comp;
      329   dcl 01 les		aligned based (lesp),
      330        02 header		aligned like le_segnames.header,
      331        02 segname		dim (0 refer (les.n_segnames))
      332 			like le_segnames.segname;
      333   dcl 01 seg_addr		aligned based (addr (seg_bits)),
      334        02 comp		fixed bin (17) unaligned,
      335        02 index		fixed bin (17) unaligned;
      336 
      337   /* automatic */
      338 
      339   dcl dup_bits		bit (36) aligned automatic;
      340   dcl ec			fixed bin (35) automatic;
      341   dcl index		fixed bin automatic;
      342   dcl newsz		fixed bin automatic;
      343   dcl seg_bits		bit (36) aligned automatic;
      344 
      345   success = false;
      346 
      347   /* build the hash table key value */
      348 
      349   seg_addr.comp = comp;
      350   seg_addr.index = les.n_segnames + 1;
      351 
      352   /* first try to hash the name into the table */
      353 
      354   call hash_$in (leshp, name, seg_bits, ec);
      355 
      356   /* hash_ thinks the table is too full, but it may just be unable to	*/
      357   /* add an entry during rehash due to a bad packing. So we will make */
      358   /* one rehash attempt with an even bigger table to try to open it	*/
      359   /* up.  If that fails, then we give up.			*/
      360 
      361   if ec = error_table_$full_hashtbl
      362     then do;
      363 
      364       /* calculate the new table size */
      365 
      366       newsz = hash_$opt_size (les.n_segnames + 1);
      367       newsz = hash_$opt_size (les.n_segnames + 1);
      368 
      369       /* try rehashing the table again */
      370 
      371       call rehash_ (leshp, newsz, ec);
      372 
      373       /* if it didn't work, then we abort the run */
      374 
      375       if ec ^= 0
      376         then call le_error_ (LE_ABORT_ERROR, ec, "^/While adding segname ^a.",
      377 	        name);
      378 
      379       /* otherwise retry the hash of the segname */
      380 
      381       call hash_$in (leshp, name, seg_bits, ec);
      382     end;
      383 
      384   /* if we have a duplicate name, then we check to see if it is a	*/
      385   /* path or library component.  Library duplicates we can ignore	*/
      386   /* but if we have to ignore a required segname, we print a message.	*/
      387 
      388   if ec = error_table_$namedup
      389     then do;
      390 
      391       /* check the duplicate to see if it is already on this component */
      392 
      393       call hash_$search (leshp, name, dup_bits, ec);
      394       if ec ^= 0
      395         then call le_error_ (LE_ABORT_ERROR, le_et_$implementation_error,
      396 	        "Segname hash table damage found while adding segname ^a",
      397 	        name);
      398 
      399       /* flag that we have not added the segname */
      400 
      401       success = false;
      402 
      403       /* print an error message if the segname is already on a	*/
      404       /* different component, and that component is required.	*/
      405 
      406       if addr (dup_bits) -> seg_addr.comp ^= comp
      407         then if ^lec.comp (comp).library
      408 	     then call le_error_ (LE_ERROR, le_et_$dup_segname,
      409 		     "^/Deleting segname ""^a"" in component ^a", name,
      410 		     lec.comp (comp).name);
      411     end;
      412 
      413   /* if something else is wrong, we have a major problem so we punt */
      414 
      415   else if ec ^= 0
      416     then call le_error_ (LE_ABORT_ERROR, ec, "^/While adding segname ^a",
      417 	    name);
      418   else do;
      419 
      420     /* if the hash was ok, grow the segname table, and create an	*/
      421     /* empty entry with the appropriate name and return the index	*/
      422 
      423     index, les.n_segnames = les.n_segnames + 1;
      424 
      425     les.segname (index).str = name;
      426     les.segname (index).relp = None;
      427     success = true;
      428   end;
      429 
      430   end add_segname;
      431 
      432 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      433 
      434 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      435 
      436 
  1     1 /****  START OF:	le_input.incl.pl1			 *  *  *  *  *  */
  1     2 
  1     3   /****^  HISTORY COMMENTS:
  1     4*  1) change(86-08-12,Elhard), approve(86-08-12,MCR7505),
  1     5*     audit(86-12-10,DGHowe), install(86-12-10,MR12.0-1241):
  1     6*     Orignally written to define the le_ input structures.
  1     7*                                                   END HISTORY COMMENTS */
  1     8 
  1     9   /*** ****************************************************************/
  1    10   /***							*/
  1    11   /***	Name:	le_input					*/
  1    12   /***	Function:	This include file declares the input structure to	*/
  1    13   /***		to the le_ subroutine.  The structure consists of	*/
  1    14   /***		a set of standard data, and a variable length	*/
  1    15   /***		array of options.  The options have a type field	*/
  1    16   /***		which specified what the option means.  The	*/
  1    17   /***		options can have the following types:		*/
  1    18   /***							*/
  1    19   /***		PATH	  - specified a single input component	*/
  1    20   /***			    to be bound in with the object	*/
  1    21   /***		 name	  - is the name of the component	*/
  1    22   /***		 path_or_ep - is the pathname to the component	*/
  1    23   /***			    this may be an archive component	*/
  1    24   /***			    pathname.			*/
  1    25   /***		 flags      - link is used by the le command to	*/
  1    26   /***			    keep track of the pathnames that	*/
  1    27   /***			    were found via links for chase	*/
  1    28   /***			    processing.			*/
  1    29   /***		 bc	  - is the bit count of the component	*/
  1    30   /***		 optp	  - is a pointer to the component	*/
  1    31   /***							*/
  1    32   /***		LIBRARY	  - specifies a single library	*/
  1    33   /***			    component.  Library components are	*/
  1    34   /***			    only included if they are referred	*/
  1    35   /***			    to by a PATH component or a library	*/
  1    36   /***			    component that is referenced and	*/
  1    37   /***			    therefor included.		*/
  1    38   /***		 name	  - same as for PATH.		*/
  1    39   /***		 path_or_ep - same as for PATH.		*/
  1    40   /***		 flags	  - same as for PATH.		*/
  1    41   /***		 bc	  - same as for PATH.		*/
  1    42   /***		 optp	  - same as for PATH.		*/
  1    43   /***							*/
  1    44   /***		ADDNAME	  - specifies a name to be added to the	*/
  1    45   /***			    bound object.			*/
  1    46   /***		 name	  - is the name to be added to the	*/
  1    47   /***			    bound unit			*/
  1    48   /***							*/
  1    49   /***		SYNONYM	  - specifies a synonym to be added to	*/
  1    50   /***			    a particular component.  This is	*/
  1    51   /***			    reflected as a segname definition	*/
  1    52   /***			    added to the block for that	*/
  1    53   /***			    component.			*/
  1    54   /***		 name	  - specifies the name of the component	*/
  1    55   /***			    to which you are adding a name.	*/
  1    56   /***		 path_or_ep - is the name being added		*/
  1    57   /***							*/
  1    58   /***		RETAIN	  - gives a starname to be used when	*/
  1    59   /***			    determining if a definition should	*/
  1    60   /***			    be retained.  If the definition	*/
  1    61   /***			    matches the starname and no more	*/
  1    62   /***			    specific info is given, the name is	*/
  1    63   /***			    retained.			*/
  1    64   /***		 flags      - the "inhibit_error" flag indicates	*/
  1    65   /***			    that it is not an error if this	*/
  1    66   /***			    option is unused.		*/
  1    67   /***		 path_or_ep - is the starname to match		*/
  1    68   /***							*/
  1    69   /***		DELETE	  - gives a starname to be used when	*/
  1    70   /***			    determining if a definition should	*/
  1    71   /***			    be retained.  If the definition	*/
  1    72   /***			    matches the starname and no more	*/
  1    73   /***			    specific info is given, the name is	*/
  1    74   /***			    deleted.			*/
  1    75   /***		 flags      - the "inhibit_error" flag indicates	*/
  1    76   /***			    that it is not an error if this	*/
  1    77   /***			    option is unused.		*/
  1    78   /***		 path_or_ep - is the starname to match.		*/
  1    79   /***							*/
  1    80   /***		NO_LINK	  - gives a starname to be used when	*/
  1    81   /***			    determining if a definition should	*/
  1    82   /***			    be retained.  If the definition	*/
  1    83   /***			    matches the starname and no more	*/
  1    84   /***			    specific info is given, the name is	*/
  1    85   /***			    retained and references to the	*/
  1    86   /***			    definition within the bound uni	*/
  1    87   /***			    are not resolved but are generated	*/
  1    88   /***			    as external links.		*/
  1    89   /***		 flags      - the "inhibit_error" flag indicates	*/
  1    90   /***			    that it is not an error if this	*/
  1    91   /***			    option is unused.		*/
  1    92   /***		 path_or_ep - is the starname to match		*/
  1    93   /***							*/
  1    94   /***		TABLE	  - specifies that the table for a	*/
  1    95   /***			    particular component is to be	*/
  1    96   /***			    retained.			*/
  1    97   /***		 name	  - is the name of the component to	*/
  1    98   /***			    which the option applies.  If name	*/
  1    99   /***			    is "", this is a global option and	*/
  1   100   /***			    applies to all component for which	*/
  1   101   /***			    a specific option does not exist.	*/
  1   102   /***							*/
  1   103   /***		NO_TABLE	  - specifies that the table for a	*/
  1   104   /***			    particular component is to be	*/
  1   105   /***			    deleted.			*/
  1   106   /***		 name	  - is the name of the component to	*/
  1   107   /***			    which the option applies.  If name	*/
  1   108   /***			    is "", this is a global option and	*/
  1   109   /***			    applies to all component for which	*/
  1   110   /***			    a specific option does not exist.	*/
  1   111   /***							*/
  1   112   /*** ****************************************************************/
  1   113   
  1   114   dcl 01 le_input		aligned based,
  1   115        02 header		aligned,
  1   116         03 version		char (8),
  1   117         03 name		char (32),
  1   118         03 flags		aligned,
  1   119          04 perprocess_static	bit (1) unaligned,
  1   120          04 force		bit (1) unaligned,
  1   121          04 debug		bit (1) unaligned,
  1   122          04 list		bit (1) unaligned,
  1   123          04 map		bit (1) unaligned,
  1   124          04 auto_segnames	bit (1) unaligned,
  1   125          04 mbz		bit (30) unaligned,
  1   126         03 output_file	unaligned,
  1   127          04 dir		char (168),
  1   128          04 entry		char (32),
  1   129         03 component_size	fixed bin,
  1   130         03 display_severity	fixed bin,
  1   131         03 abort_severity	fixed bin,
  1   132         03 bindfile		aligned,
  1   133          04 name		char (32),
  1   134          04 dt_updated	fixed bin (71),
  1   135          04 dt_modified	fixed bin (71),
  1   136         03 pad		bit (36),
  1   137         03 n_opts		fixed bin,
  1   138        02 opt		dim (0 refer (le_input.n_opts)) like le_option;
  1   139   
  1   140   dcl 01 le_option		aligned based,
  1   141        02 name		char (32) unaligned,
  1   142        02 path_or_ep	char (194) unaligned,
  1   143        02 flags		unaligned,
  1   144         03 link		bit (1),
  1   145         03 ignore		bit (1),
  1   146         03 used		bit (1),
  1   147         03 inhibit_error	bit (1),
  1   148         03 mbz		bit (5),
  1   149        02 type		fixed bin (8) unaligned,
  1   150        02 bc		fixed bin (24),
  1   151        02 optp		ptr;
  1   152   
  1   153   dcl le_input_version_1	char (8) static options (constant)
  1   154 			init ("le_ 1.0 ");
  1   155   
  1   156   /* constants for the defined option types */
  1   157   
  1   158   dcl PATH		fixed bin static options (constant) init (1);
  1   159   dcl LIBRARY		fixed bin static options (constant) init (2);
  1   160   dcl ADDNAME		fixed bin static options (constant) init (3);
  1   161   dcl SYNONYM		fixed bin static options (constant) init (4);
  1   162   dcl RETAIN		fixed bin static options (constant) init (5);
  1   163   dcl DELETE		fixed bin static options (constant) init (6);
  1   164   dcl NO_LINK		fixed bin static options (constant) init (7);
  1   165   dcl TABLE		fixed bin static options (constant) init (8);
  1   166   dcl NO_TABLE		fixed bin static options (constant) init (9);
  1   167   
  1   168 /****  END OF:	le_input.incl.pl1			 *  *  *  *  *  */
      437 
  2     1 /****  START OF:	le_data.incl.pl1			 *  *  *  *  *  */
  2     2 
  2     3 /****^  HISTORY COMMENTS:
  2     4*  1) change(86-08-12,Elhard), approve(86-08-12,MCR7505),
  2     5*     audit(86-12-10,DGHowe), install(86-12-10,MR12.0-1241):
  2     6*     Originally written to define the structures used internally by le_.
  2     7*                                                   END HISTORY COMMENTS */
  2     8 
  2     9   /*** ****************************************************************/
  2    10   /***							*/
  2    11   /***	Name:	le_data					*/
  2    12   /***	Function:	This include file defines the data structures	*/
  2    13   /***		used internally by the linkage_editor subroutine.	*/
  2    14   /***							*/
  2    15   /*** ****************************************************************/
  2    16   
  2    17   /* error severity constants */
  2    18   
  2    19   dcl LE_WARNING		fixed bin static options (constant) init (1);
  2    20   dcl LE_ERROR		fixed bin static options (constant) init (2);
  2    21   dcl LE_FATAL_ERROR	fixed bin static options (constant) init (3);
  2    22   dcl LE_ABORT_ERROR	fixed bin static options (constant) init (4);
  2    23   
  2    24   /* section identifier constants */
  2    25   
  2    26   dcl Text		fixed bin (3) static options (constant)
  2    27 			init (0);
  2    28   dcl Linkage		fixed bin (3) static options (constant)
  2    29 			init (1);
  2    30   dcl Symbol		fixed bin (3) static options (constant)
  2    31 			init (2);
  2    32   dcl Definition		fixed bin (3) static options (constant)
  2    33 			init (3);
  2    34   dcl Static		fixed bin (3) static options (constant)
  2    35 			init (4);
  2    36   dcl System		fixed bin (3) static options (constant)
  2    37 			init (5);
  2    38   dcl Heap		fixed bin (3) static options (constant)
  2    39 			init (6);
  2    40   
  2    41   dcl section_nm		(0:6) char (16) static options (constant)
  2    42 			init ("text", "linkage", "symbol", "definition",
  2    43 			"static", "system", "heap");
  2    44   
  2    45   /* link type constants */
  2    46   
  2    47   dcl Self_Base		fixed bin (3) static options (constant)
  2    48 			init (1);
  2    49   dcl Refname_Base		fixed bin (3) static options (constant)
  2    50 			init (3);
  2    51   dcl Refname_Offsetname	fixed bin (3) static options (constant)
  2    52 			init (4);
  2    53   dcl Self_Offsetname	fixed bin (3) static options (constant)
  2    54 			init (5);
  2    55   
  2    56   /* backpatch type constants */
  2    57   
  2    58   dcl Patch_Link		fixed bin static options (constant) init (1);
  2    59   dcl Patch_Init		fixed bin static options (constant) init (2);
  2    60   dcl Patch_Symbol_Ref	fixed bin static options (constant) init (3);
  2    61   dcl Patch_Self_Init	fixed bin static options (constant) init (4);
  2    62   
  2    63   /*** ****************************************************************/
  2    64   /***							*/
  2    65   /***	Name:	le_components				*/
  2    66   /***	Function:	the component table is used to keep information	*/
  2    67   /***		about the input components being used and their	*/
  2    68   /***		disposition in output components.		*/
  2    69   /***							*/
  2    70   /*** ****************************************************************/
  2    71   
  2    72   dcl 01 le_components	aligned based,
  2    73        02 header		aligned,
  2    74         03 flags		aligned,
  2    75          04 separate_static	bit (1) unaligned,
  2    76          04 perprocess_static	bit (1) unaligned,
  2    77          04 mbz		bit (34) unaligned,
  2    78         03 n_components	fixed bin,
  2    79        02 comp		(0 refer (le_components.n_components))
  2    80 			like le_comp;
  2    81   
  2    82   /*** ****************************************************************/
  2    83   /***							*/
  2    84   /***	Name:	le_comp					*/
  2    85   /***	Function:	this is a single component table entry.		*/
  2    86   /***							*/
  2    87   /*** ****************************************************************/
  2    88   
  2    89   dcl 01 le_comp		aligned based,
  2    90        02 segp		ptr,
  2    91        02 bc		fixed bin (24),
  2    92        02 uid		bit (36) aligned,
  2    93        02 dtcm		fixed bin (71),
  2    94        02 name		char (32) varying,
  2    95        02 path		char (194) varying,
  2    96        02 compiler		char (8),
  2    97        02 target		fixed bin,
  2    98        02 flags		aligned,
  2    99         03 library		bit (1) unaligned,
  2   100         03 include		bit (1) unaligned,
  2   101         03 delete_table	bit (1) unaligned,
  2   102         03 separate_static	bit (1) unaligned,
  2   103         03 io_table		bit (1) unaligned,
  2   104         03 unique_path	bit (1) unaligned,
  2   105         03 mbz		bit (30) unaligned,
  2   106        02 tables		aligned,
  2   107         03 lesp		ptr,
  2   108         03 ledp		ptr,
  2   109         03 lelp		ptr,
  2   110        02 orig		aligned,
  2   111         03 textp		ptr,
  2   112         03 defnp		ptr,
  2   113         03 linkp		ptr,
  2   114         03 statp		ptr,
  2   115         03 symbp		ptr,
  2   116         03 rel_textp	ptr,
  2   117         03 rel_symbp	ptr,
  2   118         03 rel_linkp	ptr,
  2   119         03 textl		fixed bin (18) unsigned unaligned,
  2   120         03 defnl		fixed bin (18) unsigned unaligned,
  2   121         03 linkl		fixed bin (18) unsigned unaligned,
  2   122         03 statl		fixed bin (18) unsigned unaligned,
  2   123         03 symbl		fixed bin (18) unsigned unaligned,
  2   124         03 symbl_no_rel	fixed bin (18) unsigned unaligned,
  2   125         03 symbl_no_table	fixed bin (18) unsigned unaligned,
  2   126         03 n_symb_blocks	fixed bin (18) unsigned unaligned,
  2   127         03 text_boundary	fixed bin (9) unsigned unaligned,
  2   128         03 static_boundary	fixed bin (9) unsigned unaligned,
  2   129         03 next_comp	fixed bin (18) unsigned unaligned,
  2   130        02 new		aligned,
  2   131         03 rel_text		fixed bin (18) unsigned unaligned,
  2   132         03 rel_symb		fixed bin (18) unsigned unaligned,
  2   133         03 rel_stat		fixed bin (18) unsigned unaligned,
  2   134         03 text_pad		fixed bin (18) unsigned unaligned,
  2   135         03 static_pad	fixed bin (18) unsigned unaligned,
  2   136         03 symbol_pad	fixed bin (18) unsigned unaligned;
  2   137   
  2   138   /*** ****************************************************************/
  2   139   /***							*/
  2   140   /***	Name:	le_segnames				*/
  2   141   /***	Function:	the segname table is used for two purposes:	*/
  2   142   /***		 - to determine the target components of links	*/
  2   143   /***		   being resolved internally.			*/
  2   144   /***		 - to determine the segname definitions to be	*/
  2   145   /***		   emited for definitions being retained.	*/
  2   146   /***							*/
  2   147   /*** ****************************************************************/
  2   148   
  2   149   dcl 01 le_segnames	aligned based,
  2   150        02 header		aligned,
  2   151         03 n_segnames	fixed bin,
  2   152        02 segname		(segname_count refer (le_segnames.n_segnames)),
  2   153         03 str		char (32) varying,
  2   154         03 relp		fixed bin (18) unsigned unaligned,
  2   155         03 pad		bit (18) unaligned;
  2   156   dcl segname_count		fixed bin automatic;
  2   157   
  2   158   /*** ****************************************************************/
  2   159   /***							*/
  2   160   /***	Name:	le_definitions				*/
  2   161   /***	Function:	the definition table contains the definitions	*/
  2   162   /***		from the input components and is used to resolve	*/
  2   163   /***		link targets, and regenerate definition entries	*/
  2   164   /***							*/
  2   165   /*** ****************************************************************/
  2   166   
  2   167   dcl 01 le_definitions	aligned based,
  2   168        02 header		aligned,
  2   169         03 n_defs		fixed bin,
  2   170         03 pad		bit (36),
  2   171        02 def		(def_count refer (le_definitions.n_defs))
  2   172 			like le_definition;
  2   173   dcl def_count		fixed bin automatic;
  2   174   
  2   175   dcl 01 le_definition	aligned based,
  2   176        02 str		char (256) varying,
  2   177        02 type		fixed bin (18) unsigned unaligned,
  2   178        02 relp		fixed bin (18) unsigned unaligned,
  2   179        02 offset		fixed bin (18) unsigned unaligned,
  2   180        02 new_offset	fixed bin (18) unsigned unaligned,
  2   181        02 flags		aligned,
  2   182         03 force_retain	bit (1) unaligned,
  2   183         03 entrypoint	bit (1) unaligned,
  2   184         03 ignore		bit (1) unaligned,
  2   185         03 referenced	bit (1) unaligned,
  2   186         03 no_link		bit (1) unaligned,
  2   187         03 retain		bit (1) unaligned,
  2   188         03 delete		bit (1) unaligned,
  2   189         03 mbz		bit (29) unaligned;
  2   190   
  2   191   /*** ****************************************************************/
  2   192   /***							*/
  2   193   /***	Name:	le_options				*/
  2   194   /***	Function:	the option table contains definition retention	*/
  2   195   /***		information.  The input retentions options are	*/
  2   196   /***		ordered such that a linear search of the option	*/
  2   197   /***		table for the first matching starname will give	*/
  2   198   /***		the correct retention state.			*/
  2   199   /***							*/
  2   200   /*** ****************************************************************/
  2   201   
  2   202   dcl 01 le_options		aligned based,
  2   203        02 header		aligned,
  2   204         03 n_opts		fixed bin,
  2   205        02 opt		(0 refer (le_options.n_opts)),
  2   206         03 type		fixed bin (8) unaligned,
  2   207         03 used		bit (1) unaligned,
  2   208         03 inhibit_error	bit (1) unaligned,
  2   209         03 class		fixed bin (6) unaligned,
  2   210         03 order		fixed bin (17) unaligned,
  2   211         03 segname		char (32) unaligned,
  2   212         03 ep_name		char (256) unaligned;
  2   213   
  2   214   /*** ****************************************************************/
  2   215   /***							*/
  2   216   /***	Name:	le_links					*/
  2   217   /***	Function:	the link table contains information on all of the	*/
  2   218   /***		links in the input components. It is used to	*/
  2   219   /***		determine link targets, which library components	*/
  2   220   /***		will be included, and what init_info will be	*/
  2   221   /***		used, and where it will be placed.		*/
  2   222   /***							*/
  2   223   /*** ****************************************************************/
  2   224   
  2   225   dcl 01 le_links		aligned based,
  2   226        02 header		aligned,
  2   227         03 offset_adjustment	fixed bin (18),
  2   228         03 n_links		fixed bin,
  2   229        02 link		(link_count refer (le_links.n_links))
  2   230 			like le_link;
  2   231   dcl link_count		fixed bin automatic;
  2   232 
  2   233   dcl 01 le_link		aligned based,
  2   234        02 flags		unaligned,
  2   235         03 used		bit (1),
  2   236         03 mbx		bit (35),
  2   237        02 type		fixed bin (6) unsigned unaligned,
  2   238        02 class		fixed bin (6) unsigned unaligned,
  2   239        02 mod		bit (6) unaligned,
  2   240        02 exp		fixed bin (17) unaligned,
  2   241        02 target		fixed bin (18) unsigned unaligned,
  2   242        02 defx		fixed bin (18) unsigned unaligned,
  2   243        02 relp		fixed bin (18) unsigned unaligned,
  2   244        02 target_comp	fixed bin (18) unsigned unaligned,
  2   245        02 target_link	fixed bin (18) unsigned unaligned,
  2   246        02 extension		fixed bin (18) unsigned unaligned,
  2   247        02 initp		ptr unaligned,
  2   248        02 segnamep		ptr unaligned,
  2   249        02 offsetp		ptr unaligned;
  2   250   
  2   251   /*** ****************************************************************/
  2   252   /***							*/
  2   253   /***	Name:	le_binaries				*/
  2   254   /***	Function:	This table contains information about the output	*/
  2   255   /***		binaries.  It is primarily used for creation and	*/
  2   256   /***		backpatching of MSF output.			*/
  2   257   /***							*/
  2   258   /*** ****************************************************************/
  2   259   
  2   260   dcl 01 le_binaries	aligned based,
  2   261        02 header		aligned,
  2   262         03 n_binaries	fixed bin,
  2   263         03 pad		bit (36),
  2   264        02 binary		(0:0 refer (le_binaries.n_binaries)),
  2   265         03 segp		ptr,
  2   266         03 bc		fixed bin (24),
  2   267         03 uid		bit (36),
  2   268         03 aclc		fixed bin,
  2   269         03 aclp		ptr,
  2   270         03 textp		ptr,
  2   271         03 defnp		ptr,
  2   272         03 linkp		ptr,
  2   273         03 symbp		ptr,
  2   274         03 statp		ptr,
  2   275         03 textl		fixed bin (18) unsigned unaligned,
  2   276         03 defnl		fixed bin (18) unsigned unaligned,
  2   277         03 linkl		fixed bin (18) unsigned unaligned,
  2   278         03 symbl		fixed bin (18) unsigned unaligned,
  2   279         03 statl		fixed bin (18) unsigned unaligned,
  2   280         03 mbz2		bit (18) unaligned;
  2   281   
  2   282   /*** ****************************************************************/
  2   283   /***							*/
  2   284   /***	Name:	le_patches				*/
  2   285   /***	Function:	This table contains the list of backpatches to be	*/
  2   286   /***		performed when the rest of the object creation is	*/
  2   287   /***		complete. Since le_backpatch_ is the only routine	*/
  2   288   /***		concerned with this,  it is maintained completely	*/
  2   289   /***		internal to le_backpatch_.			*/
  2   290   /***							*/
  2   291   /*** ****************************************************************/
  2   292   
  2   293   dcl 01 le_patches		aligned based,
  2   294        02 header		aligned,
  2   295         03 n_patches	fixed bin,
  2   296        02 patch		(0 refer (le_patches.n_patches)) like le_patch;
  2   297        
  2   298   dcl 01 le_patch		aligned based,
  2   299        02 type		fixed bin,
  2   300        02 comp		fixed bin,
  2   301        02 relp		fixed bin (18) unsigned,
  2   302        02 target		fixed bin,
  2   303        02 index		fixed bin;
  2   304   
  2   305 /****  END OF:	le_data.incl.pl1			 *  *  *  *  *  */
      438 
  3     1 /* BEGIN INCLUDE FILE object_link_dcls.incl.pl1 BIM 1981 from linkdcl */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  3     6*     audit(86-11-18,Schroth), install(86-11-20,MR12.0-1222):
  3     7*     Modified to add partial_link structure for an object MSF partially snapped
  3     8*     link.
  3     9*  2) change(86-11-13,DGHowe), approve(86-11-13,MCR7391), audit(86-11-13,Zwick),
  3    10*     install(86-11-20,MR12.0-1222):
  3    11*     Added a declaration of FAULT_TAG_1, FAULT_TAG_2 and FAULT_TAG_3.
  3    12*                                                   END HISTORY COMMENTS */
  3    13 
  3    14 
  3    15 /* format: style3 */
  3    16 /* everything you ever wanted in a linkage section */
  3    17 
  3    18 /*
  3    19* Last Modified (Date and Reason):
  3    20*  15 Nov 1971 by C Garman 
  3    21*   6/75 by M.Weaver to add virgin_linkage_header declaration
  3    22*   6/75 by S.Webber to comment existing structures better
  3    23*   9/77 by M. Weaver to add run_depth to link
  3    24*   7/81 by B. Margulies for firstref structure, unsigned fixed bins.
  3    25*   3/83 by M. Weaver to add flags overlaying def_ptr
  3    26**/
  3    27 
  3    28 declare	1 object_link	based aligned,		/* link pair in linkage section */
  3    29 	  2 header_relp	fixed bin (17) unal,	/* rel pointer to beginning of linkage, always negative */
  3    30 	  2 ringno	fixed bin (3) unsigned unal,	/* MBZ */
  3    31 	  2 mbz		bit (6) unal,
  3    32 	  2 run_depth	fixed bin (2) unal,		/* run unit depth, filled when link is snapped */
  3    33 	  2 tag		bit (6) unal,		/* fault tag. 46(8) if not snapped, 43(8) if snapped */
  3    34 	  2 expression_relp fixed bin (18) unsigned unal, /* pointer (rel to defs) of expression word */
  3    35 	  2 mbz2		bit (12) unal,
  3    36 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  3    37 
  3    38 declare	1 partial_link	based aligned,		/* partially snapped link */
  3    39 	  2 type		fixed bin (3) unsigned unal,	/* target section of link */
  3    40 	  2 component	fixed bin (15) unsigned unal,	/* target component index */
  3    41 	  2 mbz1		bit (12) unal,
  3    42 	  2 tag		bit (6) unal,		/* fault tag 3 47(8), ITS 43(8) if snapped */
  3    43 	  
  3    44 	  2 offset	fixed bin (18) unsigned unal,	/* word offset of link */
  3    45 	  2 mbz2		bit (3) unal,
  3    46 	  2 bit_offset	fixed bin (6) unsigned unal,	/* bit offset (in practice, always 0) */
  3    47 	  2 mbz3		bit (3) unal,
  3    48 	  2 modifier	bit (6) unal;		/* modifier to be left in snapped link */
  3    49 
  3    50 declare	1 linkage_header	based aligned,		/* linkage block header */
  3    51 	  2 def_ptr	ptr,			/* pointer to definition section */
  3    52 	  2 symbol_ptr	ptr unal,			/* pointer to symbol section in object segment */
  3    53 	  2 original_linkage_ptr
  3    54 			ptr unal,			/* pointer to linkage section in object segment */
  3    55 	  2 unused	bit (72),
  3    56 	  2 stats,
  3    57 	    3 begin_links	fixed bin (18) unsigned unal, /* offset (rel to this section) of first link */
  3    58 	    3 block_length	fixed bin (18) unsigned unal, /* number of words in this linkage section */
  3    59 	    3 segment_number
  3    60 			fixed bin (18) unsigned unal, /* text segment number associated with this section */
  3    61 	    3 static_length fixed bin (18) unsigned unal; /* number of words of static for this segment */
  3    62 
  3    63 declare	1 linkage_header_flags
  3    64 			aligned based,		/* overlay of def_ptr for flags */
  3    65 	  2 pad1		bit (28) unaligned,		/* flags are in first word */
  3    66 	  2 static_vlas	bit (1) unaligned,		/* static section "owns" some LA/VLA segments */
  3    67 	  2 perprocess_static
  3    68 			bit (1) unaligned,		/* 1 copy of static section is shared among all tasks/run units */
  3    69 	  2 pad2		bit (6) unaligned;
  3    70 
  3    71 declare	1 virgin_linkage_header
  3    72 			aligned based,		/* template for linkage header in object segment */
  3    73 	  2 pad		bit (30) unaligned,		/* is filled in by linker */
  3    74 	  2 defs_in_link	bit (6) unaligned,		/* =o20 if defs in linkage (nonstandard) */
  3    75 	  2 def_offset	fixed bin (18) unsigned unaligned,
  3    76 						/* offset of definition section */
  3    77 	  2 first_ref_relp	fixed bin (18) unsigned unaligned,
  3    78 						/* offset of trap-at-first-reference offset array */
  3    79 	  2 filled_in_later bit (144),
  3    80 	  2 link_begin	fixed bin (18) unsigned unaligned,
  3    81 						/* offset of first link */
  3    82 	  2 linkage_section_lng
  3    83 			fixed bin (18) unsigned unaligned,
  3    84 						/* length of linkage section */
  3    85 	  2 segno_pad	fixed bin (18) unsigned unaligned,
  3    86 						/* will be segment number of copied linkage */
  3    87 	  2 static_length	fixed bin (18) unsigned unaligned;
  3    88 						/* length of static section */
  3    89 
  3    90 declare	1 fr_traps	based aligned,		/* First Reference Trap Procedures */
  3    91 	  2 decl_vers	fixed bin,		/* version of this struc, value=1, ABS reloc */
  3    92 	  2 n_traps	fixed bin,		/* number of traps on this segment, ABS */
  3    93 	  2 trap_array	(n_fr_traps refer (fr_traps.n_traps)) aligned,
  3    94 	    3 call_relp	fixed bin (18) unsigned unaligned,
  3    95 						/* LINK18, offset of link defining procedure to call */
  3    96 	    3 info_relp	fixed bin (18) unsigned unaligned;
  3    97 						/* LINK18, offser of link defining argument list for trap proc */
  3    98 
  3    99 declare	FR_TRAPS_VERSION_1	init (1) fixed bin internal static options (constant);
  3   100 declare   FAULT_TAG_1	bit(6) unaligned init ("40"b3) static options (constant);
  3   101 declare   FAULT_TAG_2	bit(6) unaligned init ("46"b3) static options (constant);
  3   102 declare   FAULT_TAG_3	bit(6) unaligned init ("47"b3) static options (constant);
  3   103 
  3   104 /* END INCLUDE FILE object_link_dcls.incl.pl1 */
      439 
  4     1 /* Begin include file definition_dcls.incl.pl1 BIM 1981 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  4     6*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
  4     7*     Modified to add indirect bit to definition flags, add msf_map_relp to the
  4     8*     definition header, declare the msf_map, and add structures and constants
  4     9*     for deferred initialization.
  4    10*  2) change(86-06-24,DGHowe), approve(86-06-24,MCR7420),
  4    11*     audit(86-08-05,Schroth), install(86-11-20,MR12.0-1222):
  4    12*     added the structures for pointer initialization. pointer_init_template.
  4    13*     changed list_template_entry
  4    14*                                                   END HISTORY COMMENTS */
  4    15 
  4    16 
  4    17 /* Modified:  */
  4    18 /*   13 Dec 1982 by Lee A. Newcomb to put definition_header.hash_table_relp */
  4    19 /*	after unused half-word instead of before it. */
  4    20 /*   1 March 1983 by M. Weaver to add list template init type */
  4    21 
  4    22 /* format: style3,idind25 */
  4    23 /* everything for the definition section */
  4    24 
  4    25 declare	(
  4    26 	CLASS_TEXT	     init (0),		/* text section definition */
  4    27 	CLASS_LINKAGE	     init (1),		/* linkage section definition */
  4    28 	CLASS_SYMBOL	     init (2),		/* symbol section definition */
  4    29 	CLASS_SEGNAME	     init (3),		/* segment name definition */
  4    30 	CLASS_STATIC	     init (4),		/* static section definition */
  4    31 	CLASS_SYSTEM	     init (5),		/* valid only in self links, not def class */
  4    32 	CLASS_HEAP	     init (6)		/* valid only in self links, not def class */
  4    33 	)		     fixed bin (3) unsigned internal static options (constant);
  4    34 
  4    35 declare	CLASS_NAMES	     (0:6) character (12) internal static options (constant)
  4    36 			     init ("text", "linkage", "symbol", "segname", "static", "system", "heap");
  4    37 
  4    38 declare	SYMBOLIC_SECTION_NAMES   (0:6) character (8)
  4    39 			     init ("*text", "*link", "*symbol", *, "*static", "*system", "*heap") internal static
  4    40 			     options (constant);
  4    41 
  4    42 declare	1 definition_flags	     unaligned based,
  4    43 	  2 new		     bit (1),		/* should be "1"b */
  4    44 	  2 ignore	     bit (1),		/* cannot snap link to this */
  4    45 	  2 entry		     bit (1),		/* can tra here */
  4    46 	  2 retain	     bit (1),		/* binder respects this */
  4    47 	  2 argcount	     bit (1),		/* OBSOLETE */
  4    48 	  2 descriptors	     bit (1),		/* OBSOLETE */
  4    49 	  2 indirect	     bit (1),		/* target is a pointer to actual target */
  4    50 	  2 unused	     bit (8);		/* Must be zero */
  4    51 
  4    52 
  4    53 
  4    54 
  4    55 /* Header of the definition section */
  4    56 
  4    57 declare	def_header_ptr	     pointer;
  4    58 declare	1 definition_header	     aligned based (def_header_ptr),
  4    59 	  2 def_list_relp	     fixed bin (18) unsigned unaligned,
  4    60 						/* first definition, reloc def18 */
  4    61 	  2 msf_map_relp	     fixed bin (18) unsigned unaligned,
  4    62 						/* msf_map if any, or 0 if none.  reloc def18 unless none */
  4    63 	  2 hash_table_relp	     fixed bin (18) unsigned unaligned,
  4    64 						/* def hash table, if any, or 0 if none. reloc def18 unless none */
  4    65 	  2 flags		     unaligned like definition_flags;
  4    66 						/* both new and ignore must be "1"b here */
  4    67 
  4    68 /* A non class=3 definition. See segname_definition below for class=3 */
  4    69 
  4    70 
  4    71 declare	def_ptr		     pointer;
  4    72 declare	1 definition	     aligned based (def_ptr),
  4    73 	  2 forward_relp	     unal fixed bin (18) unsigned,
  4    74 						/* offset of next def */
  4    75 	  2 backward_relp	     unal fixed bin (18) unsigned,
  4    76 						/* offset of previous def */
  4    77 	  2 thing_relp	     unal fixed bin (18) unsigned,
  4    78 						/* offset in section specified by class of thing this defines */
  4    79 	  2 flags		     unaligned like definition_flags,
  4    80 	  2 class		     unal fixed bin (3) unsigned,
  4    81 						/* Type of definition */
  4    82 	  2 name_relp	     unal fixed bin (18) unsigned,
  4    83 						/* offset of ACC for symbol */
  4    84 	  2 segname_relp	     unal fixed bin (18) unsigned;
  4    85 						/* offset of segname def to which this belongs */
  4    86 
  4    87 /* Class=3, segname definition */
  4    88 
  4    89 declare	segname_ptr	     pointer;
  4    90 declare	1 segname_definition     aligned based (segname_ptr),
  4    91 	  2 forward_relp	     unal fixed bin (18) unsigned,
  4    92 						/* offset of next def */
  4    93 	  2 backward_relp	     unal fixed bin (18) unsigned,
  4    94 						/* offset of previous def */
  4    95 	  2 next_segname_relp    unal fixed bin (18) unsigned,
  4    96 						/* offset of next segname def */
  4    97 	  2 flags		     unaligned like definition_flags,
  4    98 	  2 class		     unal fixed bin (3) unsigned,
  4    99 						/* 3 for segname */
  4   100 	  2 name_relp	     unal fixed bin (18) unsigned,
  4   101 						/* offset of ACC for symbol */
  4   102 	  2 first_relp	     unal fixed bin (18) unsigned;
  4   103 						/* see following : */
  4   104 
  4   105 /* Definition blocks are chained off of segname definitions.
  4   106*   segname_definition.first_relp is one of three things:
  4   107*    (1) the def section offset of the first ordinary (class^=3) definition
  4   108*      belonging to this segname block. In the case where there are more than
  4   109*      one segname's on a block, all their first_relp will point
  4   110*      to the same place.
  4   111*
  4   112*    (2) if there are no ordinary definitions associated with this segname,
  4   113*      then it is the def section offset of the next segname. 
  4   114*
  4   115*    (3) if there are no ordinary definitions in the block, and it
  4   116*      is the last block, then it points to a word containing 0.
  4   117*
  4   118* Thus the end of a list of synonym segnames can be detected by forward_relp
  4   119*   pointing to a class=3 definition whose first_relp is not the same as
  4   120*   the current definitions first_relp.
  4   121**/
  4   122 
  4   123 /* All the definitions are linked through the forward and
  4   124*   backward thread variables. The end of the chain can is indicated
  4   125*   by forward pointing to a zero word. */
  4   126 
  4   127 
  4   128 declare	exp_ptr		     pointer;
  4   129 declare	1 exp_word	     based (exp_ptr) aligned, /* expression word in link definition */
  4   130 	  2 type_relp	     fixed bin (18) unsigned unal,
  4   131 						/* pointer (rel to defs) of type pair structure */
  4   132 	  2 expression	     fixed bin (17) unal;	/* constant expression to be added in when snapping link */
  4   133 
  4   134 declare	(
  4   135 	LINK_SELF_BASE	     init (1),		/* *section|0+expression,modifier */
  4   136 						/* which section determined by segname_relp */
  4   137 	LINK_OBSOLETE_2	     init (2),		/* not used */
  4   138 	LINK_REFNAME_BASE	     init (3),		/* refname|0+expression,modifier */
  4   139 	LINK_REFNAME_OFFSETNAME  init (4),		/* refname|offsetname+expression,modifier */
  4   140 	LINK_SELF_OFFSETNAME     init (5),		/* *section|offsetname+expression,modifier */
  4   141 	LINK_CREATE_IF_NOT_FOUND init (6),		/* OBSOLETE: like LINK_REFNAME_OFFSETNAME except that it will create instead of taking linkage_error */
  4   142 	SECTION_TEXT	     init (0),		/* *text */
  4   143 	SECTION_LINK	     init (1),		/* *link */
  4   144 	SECTION_SYMBOL	     init (2),		/* *symbol */
  4   145 	SECTION_UNUSED	     init (3),		/* reserved */
  4   146 	SECTION_STATIC	     init (4),		/* *static */
  4   147 	SECTION_SYSTEM	     init (5),		/* *system */
  4   148 	SECTION_HEAP	     init (6)		/* *heap */
  4   149 	)		     fixed bin (18) unsigned unaligned internal static options (constant);
  4   150 
  4   151 /* use CLASS_NAMES for section names */
  4   152 
  4   153 declare	LINK_TYPE_NAMES	     (1:6)
  4   154 			     init ("absolute in section", "unused", "absolute off of refname",
  4   155 			     "symbolic off of refname", "symbolic in section", "symbolic off of refname; create")
  4   156 			     character (32) varying internal static options (constant);
  4   157 
  4   158 
  4   159 declare	type_ptr		     pointer;
  4   160 declare	1 type_pair	     based (type_ptr) aligned,/* type pair in link definition */
  4   161 	  2 type		     fixed bin (18) unsigned unal,
  4   162 						/* see above */
  4   163 	  2 trap_relp	     fixed bin (18) unsigned unal,
  4   164 						/* pointer (rel to defs) to the trap word */
  4   165 						/* unless LINK_SELF_OFFSETNAME off of *system or create link */
  4   166 	  2 segname_relp	     fixed bin (18) unsigned unal,
  4   167 						/* pointer (rel to defs) to ACC reference name for segment referenced, 
  4   168* /*or section code for SELF links */
  4   169 	  2 offsetname_relp	     fixed bin (18) unsigned unal;
  4   170 						/* for OFFSETNAME links, ACC string of name of location. */
  4   171 						/* for others, must be ZERO */
  4   172 
  4   173 
  4   174 /* Link Trap Pair */
  4   175 
  4   176 declare	link_trap_ptr	     pointer;
  4   177 declare	1 link_trap_pair	     aligned based (link_trap_ptr),
  4   178 	  2 call_relp	     fixed bin (18) unsigned unaligned,
  4   179 						/* LINK18, link to thing to call */
  4   180 	  2 info_relp	     fixed bin (18) unsigned unaligned;
  4   181 						/* LINK18, link to argument list */
  4   182 
  4   183 
  4   184 /* initialization info for *system or *heap link */
  4   185 
  4   186 
  4   187 /* NOTE --------------------------------------------------
  4   188*   the following structures defining initialization information are also
  4   189*   defined in fortran_storage.incl.pl1  system_link_init_info.incl.pl1
  4   190*   and should be kept equivalent
  4   191*   -------------------------------------------------------
  4   192**/
  4   193 
  4   194 declare	(
  4   195 	INIT_NO_INIT	     init (0),
  4   196 	INIT_COPY_INFO	     init (3),
  4   197 	INIT_DEFINE_AREA	     init (4),
  4   198 	INIT_LIST_TEMPLATE	     init (5),
  4   199 	INIT_DEFERRED	     init (6)
  4   200 	)		     fixed bin internal static options (constant);
  4   201 
  4   202 /* for type = 0 or 4 */
  4   203 
  4   204 declare	link_init_ptr	     pointer;
  4   205 declare	1 link_init	     aligned based (link_init_ptr),
  4   206 	  2 n_words	     fixed bin (35),	/* number to invent */
  4   207 	  2 type		     fixed bin;		/* see types above */
  4   208 
  4   209 /* for type=3, there is data to copy */
  4   210 
  4   211 declare	1 link_init_copy_info    aligned based (link_init_ptr),
  4   212 	  2 header	     aligned like link_init,
  4   213 	  2 initial_data	     (link_init_n_words refer (link_init_copy_info.header.n_words)) bit (36) aligned;
  4   214 
  4   215 declare	link_init_n_words	     fixed bin;
  4   216 
  4   217 /* for type = 5, there is a list template to copy */
  4   218 
  4   219 declare	1 link_init_list_template
  4   220 			     aligned based (link_init_ptr),
  4   221 	  2 header	     aligned like link_init,
  4   222 	  2 pad		     bit (18) unaligned,
  4   223 	  2 n_words_in_list	     fixed bin (18) unsigned unaligned,
  4   224 	  2 template	     (link_init_n_words_in_list refer (link_init_list_template.n_words_in_list));
  4   225 
  4   226 declare	link_init_n_words_in_list
  4   227 			     fixed bin;
  4   228 
  4   229 /* A list template consists of a series of entries with the following
  4   230*   description, concatenated together.  n_bits and datum are bit items,
  4   231*   to permit a wide range of inputs.
  4   232*
  4   233*   1.  A 'repeat' of '0' signifies skipping of 'n_bits' bits.
  4   234*   2.  A 'n_bits' of '0' signifies the last item of the list.
  4   235*
  4   236*   COMMON, VLA's, and LA's are presumed to start at the base pointer
  4   237*   of their particular storage section. */
  4   238 
  4   239 declare	1 list_template_entry    aligned based,
  4   240 	  2 n_bits	     fixed bin (35) aligned,	/* size of datum */
  4   241 	  2 mbz		     bit (3) unaligned,	/* future expansion */
  4   242 	  2 init_type	     fixed bin (3) unsigned unaligned, /* 0 normal init, 1 ptr init, 2 packed ptr init */
  4   243 	  2 repeat	     fixed bin (30) unsigned unaligned,
  4   244 						/* number of times to repeat datum */
  4   245 	  2 datum		     bit (link_init_n_bits_in_datum refer (list_template_entry.n_bits));
  4   246 
  4   247 
  4   248 /* the pointer_init_template represents the initialization information
  4   249*   for ITS and packed pointers.  Both pointer types require the entire
  4   250*   72 bit structure.
  4   251**/
  4   252 
  4   253 dcl       1 pointer_init_template  based,
  4   254 	  2 ptr_type	     fixed bin (18) unsigned unaligned,  /* 0 text section, 1 linkage section, 2 static section */
  4   255 	  2 section_offset	     fixed bin (18) unsigned unaligned,  /* offset to item in specified section */
  4   256 	  2 word_offset	     fixed bin (18) unsigned unaligned,  /* offset from section item to target in words */
  4   257 	  2 mbz		     bit (12) unaligned,
  4   258 	  2 bit_offset	     fixed bin (6) unsigned unaligned;   /* offset from section item|word offset to target in bits */
  4   259 
  4   260 
  4   261 declare	link_init_n_bits_in_datum
  4   262 			     fixed bin (35);
  4   263 
  4   264 /* for type = 6, the init_info resides in another MSF component */
  4   265 /* target_relp is a linkage section offset to a partial link to */
  4   266 /* the base of the linkage section of the component containing  */
  4   267 /* the actual init_info. link_relp is the offset of the actual  */
  4   268 /* link within that linkage section.			    */
  4   269 
  4   270 declare	1 link_init_deferred     aligned based (link_init_ptr),
  4   271 	  2 header	     aligned like link_init,
  4   272 	  2 target_relp	     fixed bin (18) unsigned unaligned,
  4   273 	  2 link_relp	     fixed bin (18) unsigned unaligned;
  4   274 
  4   275 /* Definition section hash table */
  4   276 
  4   277 declare	def_ht_ptr	     pointer;
  4   278 declare	1 definition_ht	     aligned based (def_ht_ptr),
  4   279 	  2 n_entries	     fixed bin,
  4   280 	  2 table		     (def_ht_n_entries refer (definition_ht.n_entries)) aligned,
  4   281 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  4   282 	    3 unused	     bit (18) unaligned;
  4   283 
  4   284 declare	def_ht_n_entries	     fixed bin;
  4   285 
  4   286 
  4   287 /* Component name ht */
  4   288 declare	comp_ht_ptr	     pointer;
  4   289 declare	1 component_ht	     aligned based (comp_ht_ptr),
  4   290 	  2 n_entries	     fixed bin,
  4   291 	  2 table		     (comp_ht_n_entries refer (component_ht.n_entries)) aligned,
  4   292 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  4   293 						/* hashed segname */
  4   294 	    3 block_hdr_relp     fixed bin (18) unsigned unaligned;
  4   295 						/* first segname def of block containing def_relp */
  4   296 
  4   297 declare	comp_ht_n_entries	     fixed bin;
  4   298 
  4   299 /* Duplicate name table */
  4   300 
  4   301 declare	dup_table_ptr	     pointer;
  4   302 declare	1 duplicate_table	     aligned based (dup_table_ptr),
  4   303 	  2 mbz		     bit (18) unaligned,	/* to tell it from a definition */
  4   304 	  2 n_names	     fixed bin (18) unsigned unaligned,
  4   305 						/* n in table */
  4   306 	  2 table		     (dup_table_n_names refer (duplicate_table.n_names)) aligned,
  4   307 	    3 def_relp	     fixed bin (18) unsigned unaligned,
  4   308 	    3 block_hdr_relp     fixed bin (18) unsigned unaligned;
  4   309 
  4   310 declare	dup_table_n_names	     fixed bin;
  4   311 
  4   312 /* The msf_map is found in the definition section of an	*/
  4   313 /* object MSF component.  It is used by the linker to	*/
  4   314 /* determine whether a segment is a component of an object	*/
  4   315 /* MSF or a standard single-segment object.		*/
  4   316   
  4   317   dcl msf_map_ptr		ptr;
  4   318   dcl 01 msf_map		aligned based (msf_map_ptr),
  4   319        02 version		char (8),
  4   320        02 component_count	fixed bin (15) unsigned,
  4   321        02 my_component	fixed bin (15) unsigned;
  4   322   
  4   323   dcl msf_map_version_1	char (8) static options (constant)
  4   324 			     init ("msfmp1.0");
  4   325   
  4   326 declare	acc_string_ptr	     pointer;
  4   327 declare	1 acc_string	     aligned based (acc_string_ptr),
  4   328 	  2 count		     fixed bin (9) unsigned unaligned,
  4   329 	  2 string	     character (max (3, acc_string_length) refer (acc_string.count)) unaligned,
  4   330 	  2 mbz		     bit (0) aligned;	/* this causes the statement */
  4   331 						/* unspec (acc_string) = ""b to zero out */
  4   332 						/* the last word, if the string is not of length 0mod4 */
  4   333 
  4   334 declare	acc_string_length	     fixed bin (21);
  4   335 
  4   336 
  4   337 /* end include file definitions_dcls.incl.pl1 */
      440 
      441 
      442   end le_make_segname_tbl_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/10/86  1252.0  le_make_segname_tbl_.pl1          >special_ldd>install>MR12.0-1241>le_make_segname_tbl_.pl1
437          1    12/10/86  1248.7  le_input.incl.pl1                 >special_ldd>install>MR12.0-1241>le_input.incl.pl1
438          2    12/10/86  1248.4  le_data.incl.pl1                  >special_ldd>install>MR12.0-1241>le_data.incl.pl1
439          3    11/24/86  1226.9  object_link_dcls.incl.pl1         >ldd>include>object_link_dcls.incl.pl1
440          4    11/24/86  1226.9  definition_dcls.incl.pl1          >ldd>include>definition_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
LE_ABORT_ERROR                  000017 constant        fixed bin(17,0)          initial dcl 2-22 set ref 375* 394* 415*
LE_ERROR                        000020 constant        fixed bin(17,0)          initial dcl 2-20 set ref 248* 406*
None                                   constant        fixed bin(17,0)          initial dcl 36 ref 149 150 166 202 426
SYNONYM                                constant        fixed bin(17,0)          initial dcl 1-161 ref 219
acc                                    based           structure                level 1 dcl 72
accp                            000100 automatic       pointer                  dcl 96 set ref 175* 181 187 194 198
addr                                                   builtin function         dcl 118 ref 349 350 406
addrel                                                 builtin function         dcl 119 ref 165 175 213
auto_segnames            12(05)        based           bit(1)                   level 4 packed unaligned dcl 85 ref 155 181
c                               000102 automatic       fixed bin(17,0)          dcl 97 set ref 145* 157* 157 163 187* 223 232* 248
                                                                                  248 258 259 279 280*
class                     1(33)        based           fixed bin(3,0)           level 2 packed unsigned unaligned dcl 75 ref 172 200
cleanup                         000132 stack reference condition                dcl 114 ref 131
comp                                   based           fixed bin(17,0)          level 2 in structure "seg_addr" packed unaligned
                                                                                  dcl 333 in procedure "add_segname" set ref 349*
                                                                                  406
comp                                   parameter       fixed bin(17,0)          dcl 320 in procedure "add_segname" ref 297 349 406
                                                                                  406 406
comp                      2            based           structure                array level 2 in structure "lec" dcl 78 in procedure
                                                                                  "le_make_segname_tbl_"
comp                      2            based           structure                array level 2 in structure "lec" dcl 326
                                                                                  in procedure "add_segname"
count                                  based           fixed bin(9,0)           level 2 packed unsigned unaligned dcl 72 ref 181 187
                                                                                  187 194 198
def                                    based           structure                level 1 dcl 75 in procedure "le_make_segname_tbl_"
def                       2            based           structure                array level 2 in structure "led" dcl 81 in procedure
                                                                                  "le_make_segname_tbl_"
def_count                       000141 automatic       fixed bin(17,0)          dcl 2-173 set ref 253* 256 256 271* 274 274
def_list                        000103 automatic       fixed bin(17,0)          dcl 98 set ref 166* 207*
def_list_relp                          based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 76 ref 164
definition                             based           structure                level 1 dcl 4-72
definition_flags                       based           structure                level 1 packed unaligned dcl 4-42
definition_header                      based           structure                level 1 dcl 4-58
defnp                   120            based           pointer                  array level 4 dcl 78 ref 163
defp                            000104 automatic       pointer                  dcl 99 set ref 165* 168 172 175 181 200 201 204 205
                                                                                  206 212 213*
defx                            000106 automatic       fixed bin(17,0)          dcl 100 set ref 197* 198 199 200 201 202 203 204 205
                                                                                  206 207
dh                                     based           structure                level 1 dcl 76
dhp                             000110 automatic       pointer                  dcl 101 set ref 163* 164 165 175 213
dup_bits                        000100 automatic       bit(36)                  dcl 339 set ref 393* 406
ec                              000101 automatic       fixed bin(35,0)          dcl 340 in procedure "add_segname" set ref 354* 361
                                                                                  371* 375 375* 381* 388 393* 394 415 415*
ec                              000112 automatic       fixed bin(35,0)          dcl 102 in procedure "le_make_segname_tbl_" set ref
                                                                                  127* 141*
entry                     1(20)        based           bit(1)                   level 3 packed unaligned dcl 75 ref 205
entrypoint              105(01)        based           bit(1)                   array level 4 packed unaligned dcl 81 set ref 205*
error_table_$full_hashtbl       000030 external static fixed bin(35,0)          dcl 60 ref 361
error_table_$namedup            000032 external static fixed bin(35,0)          dcl 62 ref 388
false                                  constant        bit(1)                   initial unaligned dcl 35 ref 147 345 401
flags                     1(18)        based           structure                level 2 in structure "def" packed unaligned dcl 75
                                                                                  in procedure "le_make_segname_tbl_"
flags                   105            based           structure                array level 3 in structure "led" dcl 81 in procedure
                                                                                  "le_make_segname_tbl_" set ref 203*
flags                    12            based           structure                level 3 in structure "lei" dcl 85 in procedure
                                                                                  "le_make_segname_tbl_"
flags                   206(18)        based           structure                array level 3 in structure "lei" packed unaligned
                                                                                  dcl 85 in procedure "le_make_segname_tbl_"
flags                   106            based           structure                array level 3 in structure "lec" dcl 326
                                                                                  in procedure "add_segname"
flags                   106            based           structure                array level 3 in structure "lec" dcl 78 in procedure
                                                                                  "le_make_segname_tbl_"
force_retain            105            based           bit(1)                   array level 4 packed unaligned dcl 81 set ref 204*
forward_relp                           based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 75 ref 212
get_temp_segments_              000010 constant        entry                    external dcl 47 ref 141
has_segname                     000113 automatic       bit(1)                   unaligned dcl 103 set ref 147* 158* 158 188* 188
                                                                                  234* 234 242
hash_$in                        000014 constant        entry                    external dcl 49 ref 354 381
hash_$make                      000012 constant        entry                    external dcl 48 ref 127
hash_$opt_size                  000016 constant        entry                    external dcl 51 ref 127 127 366 367
hash_$search                    000020 constant        entry                    external dcl 52 ref 393
header                                 based           structure                level 2 in structure "lei" dcl 85 in procedure
                                                                                  "le_make_segname_tbl_"
header                                 based           structure                level 2 in structure "lec" dcl 78 in procedure
                                                                                  "le_make_segname_tbl_"
header                                 based           structure                level 2 in structure "le_input" dcl 1-114
                                                                                  in procedure "le_make_segname_tbl_"
header                                 based           structure                level 2 in structure "le_segnames" dcl 2-149
                                                                                  in procedure "le_make_segname_tbl_"
header                                 based           structure                level 2 in structure "le_definitions" dcl 2-167
                                                                                  in procedure "le_make_segname_tbl_"
header                                 based           structure                level 2 in structure "led" dcl 81 in procedure
                                                                                  "le_make_segname_tbl_"
header                                 based           structure                level 2 in structure "les" dcl 88 in procedure
                                                                                  "le_make_segname_tbl_"
header                                 based           structure                level 2 in structure "le_components" dcl 2-72
                                                                                  in procedure "le_make_segname_tbl_"
header                                 based           structure                level 2 in structure "les" dcl 329 in procedure
                                                                                  "add_segname"
i                               000114 automatic       fixed bin(17,0)          dcl 104 set ref 218* 219 219 219 223 228 232*
ignore                  105(02)        based           bit(1)                   array level 4 in structure "led" packed unaligned
                                                                                  dcl 81 in procedure "le_make_segname_tbl_" set ref
                                                                                  206*
ignore                  206(19)        based           bit(1)                   array level 4 in structure "lei" packed unaligned
                                                                                  dcl 85 in procedure "le_make_segname_tbl_" ref 219
ignore                    1(19)        based           bit(1)                   level 3 in structure "def" packed unaligned dcl 75
                                                                                  in procedure "le_make_segname_tbl_" ref 181 206
index                           000102 automatic       fixed bin(17,0)          dcl 341 in procedure "add_segname" set ref 423* 425
                                                                                  426
index                     0(18)        based           fixed bin(17,0)          level 2 in structure "seg_addr" packed unaligned
                                                                                  dcl 333 in procedure "add_segname" set ref 350*
le_area                                based           area(1024)               dcl 77 ref 255 256 273 274
le_comp                                based           structure                level 1 dcl 2-89
le_components                          based           structure                level 1 dcl 2-72
le_data_$caller                 000034 external static varying char(32)         dcl 63 ref 133 141 288
le_definition                          based           structure                level 1 dcl 2-175
le_definitions                         based           structure                level 1 dcl 2-167 set ref 256 274
le_error_                       000022 constant        entry                    external dcl 54 ref 248 375 394 406 415
le_et_$dup_segname              000036 external static fixed bin(35,0)          dcl 64 set ref 406*
le_et_$entrypoints_inaccessible 000040 external static fixed bin(35,0)          dcl 65 set ref 248*
le_et_$implementation_error     000042 external static fixed bin(35,0)          dcl 67 set ref 394*
le_input                               based           structure                level 1 dcl 1-114
le_link                                based           structure                level 1 dcl 2-233
le_option                              based           structure                level 1 dcl 1-140
le_patch                               based           structure                level 1 dcl 2-298
le_segnames                            based           structure                level 1 dcl 2-149 set ref 255 273
leap                                   parameter       pointer                  dcl 43 ref 16 255 256 273 274
lec                                    based           structure                level 1 dcl 326 in procedure "add_segname"
lec                                    based           structure                level 1 dcl 78 in procedure "le_make_segname_tbl_"
lecp                                   parameter       pointer                  dcl 317 in procedure "add_segname" ref 297 406 406
lecp                                   parameter       pointer                  dcl 41 in procedure "le_make_segname_tbl_" set ref
                                                                                  16 145 157* 157 163 187* 223 232* 248 248 258 259
                                                                                  279 280
led                                    based           structure                level 1 dcl 81 set ref 277* 277
ledp                    112            based           pointer                  array level 4 in structure "lec" dcl 78 in procedure
                                                                                  "le_make_segname_tbl_" set ref 259* 280*
ledp                            000116 automatic       pointer                  dcl 105 in procedure "le_make_segname_tbl_" set ref
                                                                                  143* 150 197 197 198 199 200 201 202 203 204 205
                                                                                  206 256* 259 262* 271 274* 277 280 283*
lei                                    based           structure                level 1 dcl 85
leip                                   parameter       pointer                  dcl 40 ref 16 155 181 218 219 219 219 223 228 232
les                                    based           structure                level 1 dcl 88 in procedure "le_make_segname_tbl_"
                                                                                  set ref 276* 276
les                                    based           structure                level 1 dcl 329 in procedure "add_segname"
leshp                                  parameter       pointer                  dcl 318 in procedure "add_segname" set ref 297 354*
                                                                                  371* 381* 393*
leshp                                  parameter       pointer                  dcl 42 in procedure "le_make_segname_tbl_" set ref
                                                                                  16 127* 157* 187* 232*
lesp                    110            based           pointer                  array level 4 in structure "lec" dcl 78 in procedure
                                                                                  "le_make_segname_tbl_" set ref 258* 279*
lesp                            000120 automatic       pointer                  dcl 106 in procedure "le_make_segname_tbl_" set ref
                                                                                  142* 149 157* 187* 232* 255* 258 261* 270 273* 276
                                                                                  279 282*
lesp                                   parameter       pointer                  dcl 319 in procedure "add_segname" ref 297 350 366
                                                                                  367 423 423 425 426
library                 106            based           bit(1)                   array level 4 in structure "lec" packed unaligned
                                                                                  dcl 326 in procedure "add_segname" ref 406
library                 106            based           bit(1)                   array level 4 in structure "lec" packed unaligned
                                                                                  dcl 78 in procedure "le_make_segname_tbl_" ref 248
link_init                              based           structure                level 1 dcl 4-205
n_components              1            based           fixed bin(17,0)          level 3 dcl 78 ref 145
n_defs                                 based           fixed bin(17,0)          level 3 in structure "led" dcl 81 in procedure
                                                                                  "le_make_segname_tbl_" set ref 150* 197 197* 271
                                                                                  277 277
n_defs                                 based           fixed bin(17,0)          level 3 in structure "le_definitions" dcl 2-167
                                                                                  in procedure "le_make_segname_tbl_" set ref 256*
                                                                                  274*
n_opts                  115            based           fixed bin(17,0)          level 3 dcl 85 ref 218
n_segnames                             based           fixed bin(17,0)          level 3 in structure "le_segnames" dcl 2-149
                                                                                  in procedure "le_make_segname_tbl_" set ref 255*
                                                                                  273*
n_segnames                             based           fixed bin(17,0)          level 3 in structure "les" dcl 88 in procedure
                                                                                  "le_make_segname_tbl_" set ref 149* 270 276 276
n_segnames                             based           fixed bin(17,0)          level 3 in structure "les" dcl 329 in procedure
                                                                                  "add_segname" set ref 350 366 367 423 423*
name                     10            based           varying char(32)         array level 3 in structure "lec" dcl 78 in procedure
                                                                                  "le_make_segname_tbl_" set ref 157 223 248*
name                                   parameter       char                     unaligned dcl 321 in procedure "add_segname" set ref
                                                                                  297 354* 375* 381* 393* 394* 406* 415* 425
name                    116            based           char(32)                 array level 3 in structure "lei" packed unaligned
                                                                                  dcl 85 in procedure "le_make_segname_tbl_" ref 223
name                     10            based           varying char(32)         array level 3 in structure "lec" dcl 326
                                                                                  in procedure "add_segname" set ref 406*
name_relp                 2            based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 75 ref 175
new_offset              104(18)        based           fixed bin(18,0)          array level 3 packed unsigned unaligned dcl 81 set
                                                                                  ref 202*
newsz                           000103 automatic       fixed bin(17,0)          dcl 342 set ref 366* 367* 371*
null                                                   builtin function         dcl 120 ref 129 133
offset                  104            based           fixed bin(18,0)          array level 3 in structure "led" packed unsigned
                                                                                  unaligned dcl 81 in procedure
                                                                                  "le_make_segname_tbl_" set ref 199*
offset                          000122 automatic       fixed bin(18,0)          unsigned dcl 107 in procedure "le_make_segname_tbl_"
                                                                                  set ref 164* 165 199 212* 213
opt                     116            based           structure                array level 2 dcl 85
orig                    116            based           structure                array level 3 dcl 78
path_or_ep              126            based           char(194)                array level 3 packed unaligned dcl 85 set ref 232*
real_defs                       000123 automatic       fixed bin(17,0)          dcl 108 set ref 148* 194* 194 248
rehash_                         000024 constant        entry                    external dcl 55 ref 371
release_temp_segments_          000026 constant        entry                    external dcl 56 ref 133 288
relp                    103(18)        based           fixed bin(18,0)          array level 3 in structure "led" packed unsigned
                                                                                  unaligned dcl 81 in procedure
                                                                                  "le_make_segname_tbl_" set ref 201*
relp                     12            based           fixed bin(18,0)          array level 3 in structure "les" packed unsigned
                                                                                  unaligned dcl 329 in procedure "add_segname" set
                                                                                  ref 426*
retain                    1(21)        based           bit(1)                   level 3 packed unaligned dcl 75 ref 204
seg_addr                               based           structure                level 1 dcl 333
seg_bits                        000104 automatic       bit(36)                  dcl 343 set ref 349 350 354* 381*
segname                   1            based           structure                array level 2 in structure "les" dcl 329
                                                                                  in procedure "add_segname"
segname                   1            based           structure                array level 2 in structure "le_segnames" dcl 2-149
                                                                                  in procedure "le_make_segname_tbl_"
segname_count                   000140 automatic       fixed bin(17,0)          dcl 2-156 set ref 252* 255 255 270* 273 273
str                       1            based           varying char(32)         array level 3 in structure "les" dcl 329
                                                                                  in procedure "add_segname" set ref 425*
str                       2            based           varying char(256)        array level 3 in structure "led" dcl 81 in procedure
                                                                                  "le_make_segname_tbl_" set ref 198*
string                    0(09)        based           char                     level 2 in structure "acc" packed unaligned dcl 72
                                                                                  in procedure "le_make_segname_tbl_" set ref 181
                                                                                  187* 194 198
string                                                 builtin function         dcl 121 in procedure "le_make_segname_tbl_" set ref
                                                                                  203*
success                         000124 automatic       bit(1)                   unaligned dcl 109 in procedure
                                                                                  "le_make_segname_tbl_" set ref 157* 158 187* 188
                                                                                  232* 234
success                                parameter       bit(1)                   unaligned dcl 322 in procedure "add_segname" set ref
                                                                                  297 345* 401* 427*
tables                  110            based           structure                array level 3 dcl 78
thing_relp                1            based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 75 ref 201
true                                   constant        bit(1)                   initial unaligned dcl 34 ref 228 427
ts                              000126 automatic       pointer                  array dcl 110 set ref 129* 133 133* 141* 142 143 261
                                                                                  262 276 277 282 283 288*
type                    206(27)        based           fixed bin(8,0)           array level 3 in structure "lei" packed unaligned
                                                                                  dcl 85 in procedure "le_make_segname_tbl_" ref 219
type                    103            based           fixed bin(18,0)          array level 3 in structure "led" packed unsigned
                                                                                  unaligned dcl 81 in procedure
                                                                                  "le_make_segname_tbl_" set ref 200*
unspec                                                 builtin function         dcl 122 set ref 276* 276 277* 277
used                    206(20)        based           bit(1)                   array level 4 packed unaligned dcl 85 set ref 219
                                                                                  228*
word                                   based           fixed bin(35,0)          dcl 92 ref 168

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ADDNAME                                internal static fixed bin(17,0)          initial dcl 1-160
CLASS_HEAP                             internal static fixed bin(3,0)           initial unsigned dcl 4-25
CLASS_LINKAGE                          internal static fixed bin(3,0)           initial unsigned dcl 4-25
CLASS_NAMES                            internal static char(12)                 initial array unaligned dcl 4-35
CLASS_SEGNAME                          internal static fixed bin(3,0)           initial unsigned dcl 4-25
CLASS_STATIC                           internal static fixed bin(3,0)           initial unsigned dcl 4-25
CLASS_SYMBOL                           internal static fixed bin(3,0)           initial unsigned dcl 4-25
CLASS_SYSTEM                           internal static fixed bin(3,0)           initial unsigned dcl 4-25
CLASS_TEXT                             internal static fixed bin(3,0)           initial unsigned dcl 4-25
DELETE                                 internal static fixed bin(17,0)          initial dcl 1-163
Definition                             internal static fixed bin(3,0)           initial dcl 2-32
FAULT_TAG_1                            internal static bit(6)                   initial unaligned dcl 3-100
FAULT_TAG_2                            internal static bit(6)                   initial unaligned dcl 3-101
FAULT_TAG_3                            internal static bit(6)                   initial unaligned dcl 3-102
FR_TRAPS_VERSION_1                     internal static fixed bin(17,0)          initial dcl 3-99
Heap                                   internal static fixed bin(3,0)           initial dcl 2-38
INIT_COPY_INFO                         internal static fixed bin(17,0)          initial dcl 4-194
INIT_DEFERRED                          internal static fixed bin(17,0)          initial dcl 4-194
INIT_DEFINE_AREA                       internal static fixed bin(17,0)          initial dcl 4-194
INIT_LIST_TEMPLATE                     internal static fixed bin(17,0)          initial dcl 4-194
INIT_NO_INIT                           internal static fixed bin(17,0)          initial dcl 4-194
LE_FATAL_ERROR                         internal static fixed bin(17,0)          initial dcl 2-21
LE_WARNING                             internal static fixed bin(17,0)          initial dcl 2-19
LIBRARY                                internal static fixed bin(17,0)          initial dcl 1-159
LINK_CREATE_IF_NOT_FOUND               internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
LINK_OBSOLETE_2                        internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
LINK_REFNAME_BASE                      internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
LINK_REFNAME_OFFSETNAME                internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
LINK_SELF_BASE                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
LINK_SELF_OFFSETNAME                   internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
LINK_TYPE_NAMES                        internal static varying char(32)         initial array dcl 4-153
Linkage                                internal static fixed bin(3,0)           initial dcl 2-28
NO_LINK                                internal static fixed bin(17,0)          initial dcl 1-164
NO_TABLE                               internal static fixed bin(17,0)          initial dcl 1-166
PATH                                   internal static fixed bin(17,0)          initial dcl 1-158
Patch_Init                             internal static fixed bin(17,0)          initial dcl 2-59
Patch_Link                             internal static fixed bin(17,0)          initial dcl 2-58
Patch_Self_Init                        internal static fixed bin(17,0)          initial dcl 2-61
Patch_Symbol_Ref                       internal static fixed bin(17,0)          initial dcl 2-60
RETAIN                                 internal static fixed bin(17,0)          initial dcl 1-162
Refname_Base                           internal static fixed bin(3,0)           initial dcl 2-49
Refname_Offsetname                     internal static fixed bin(3,0)           initial dcl 2-51
SECTION_HEAP                           internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
SECTION_LINK                           internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
SECTION_STATIC                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
SECTION_SYMBOL                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
SECTION_SYSTEM                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
SECTION_TEXT                           internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
SECTION_UNUSED                         internal static fixed bin(18,0)          initial unsigned unaligned dcl 4-134
SYMBOLIC_SECTION_NAMES                 internal static char(8)                  initial array unaligned dcl 4-38
Self_Base                              internal static fixed bin(3,0)           initial dcl 2-47
Self_Offsetname                        internal static fixed bin(3,0)           initial dcl 2-53
Static                                 internal static fixed bin(3,0)           initial dcl 2-34
Symbol                                 internal static fixed bin(3,0)           initial dcl 2-30
System                                 internal static fixed bin(3,0)           initial dcl 2-36
TABLE                                  internal static fixed bin(17,0)          initial dcl 1-165
Text                                   internal static fixed bin(3,0)           initial dcl 2-26
acc_string                             based           structure                level 1 dcl 4-327
acc_string_length                      automatic       fixed bin(21,0)          dcl 4-334
acc_string_ptr                         automatic       pointer                  dcl 4-326
comp_ht_n_entries                      automatic       fixed bin(17,0)          dcl 4-297
comp_ht_ptr                            automatic       pointer                  dcl 4-288
component_ht                           based           structure                level 1 dcl 4-289
def_header_ptr                         automatic       pointer                  dcl 4-57
def_ht_n_entries                       automatic       fixed bin(17,0)          dcl 4-284
def_ht_ptr                             automatic       pointer                  dcl 4-277
def_ptr                                automatic       pointer                  dcl 4-71
definition_ht                          based           structure                level 1 dcl 4-278
dup_table_n_names                      automatic       fixed bin(17,0)          dcl 4-310
dup_table_ptr                          automatic       pointer                  dcl 4-301
duplicate_table                        based           structure                level 1 dcl 4-302
exp_ptr                                automatic       pointer                  dcl 4-128
exp_word                               based           structure                level 1 dcl 4-129
fr_traps                               based           structure                level 1 dcl 3-90
le_binaries                            based           structure                level 1 dcl 2-260
le_input_version_1                     internal static char(8)                  initial unaligned dcl 1-153
le_links                               based           structure                level 1 dcl 2-225
le_options                             based           structure                level 1 dcl 2-202
le_patches                             based           structure                level 1 dcl 2-293
link_count                             automatic       fixed bin(17,0)          dcl 2-231
link_init_copy_info                    based           structure                level 1 dcl 4-211
link_init_deferred                     based           structure                level 1 dcl 4-270
link_init_list_template                based           structure                level 1 dcl 4-219
link_init_n_bits_in_datum              automatic       fixed bin(35,0)          dcl 4-261
link_init_n_words                      automatic       fixed bin(17,0)          dcl 4-215
link_init_n_words_in_list              automatic       fixed bin(17,0)          dcl 4-226
link_init_ptr                          automatic       pointer                  dcl 4-204
link_trap_pair                         based           structure                level 1 dcl 4-177
link_trap_ptr                          automatic       pointer                  dcl 4-176
linkage_header                         based           structure                level 1 dcl 3-50
linkage_header_flags                   based           structure                level 1 dcl 3-63
list_template_entry                    based           structure                level 1 dcl 4-239
msf_map                                based           structure                level 1 dcl 4-318
msf_map_ptr                            automatic       pointer                  dcl 4-317
msf_map_version_1                      internal static char(8)                  initial unaligned dcl 4-323
object_link                            based           structure                level 1 dcl 3-28
partial_link                           based           structure                level 1 dcl 3-38
pointer_init_template                  based           structure                level 1 packed unaligned dcl 4-253
section_nm                             internal static char(16)                 initial array unaligned dcl 2-41
segname_definition                     based           structure                level 1 dcl 4-90
segname_ptr                            automatic       pointer                  dcl 4-89
type_pair                              based           structure                level 1 dcl 4-160
type_ptr                               automatic       pointer                  dcl 4-159
virgin_linkage_header                  based           structure                level 1 dcl 3-71

NAMES DECLARED BY EXPLICIT CONTEXT.
add_segname                     001173 constant        entry                    internal dcl 297 ref 157 187 232
le_make_segname_tbl_            000110 constant        entry                    external dcl 16

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2054        2120    1643        2064
Length      2426    1643        44         272     210           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
le_make_segname_tbl_                161 external procedure  is an external procedure.  
on unit on line 131                  82 on unit               
add_segname                         130 internal procedure  is called during a stack extension.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
add_segname              000100 dup_bits                    add_segname
                         000101 ec                          add_segname
                         000102 index                       add_segname
                         000103 newsz                       add_segname
                         000104 seg_bits                    add_segname
le_make_segname_tbl_     000100 accp                        le_make_segname_tbl_
                         000102 c                           le_make_segname_tbl_
                         000103 def_list                    le_make_segname_tbl_
                         000104 defp                        le_make_segname_tbl_
                         000106 defx                        le_make_segname_tbl_
                         000110 dhp                         le_make_segname_tbl_
                         000112 ec                          le_make_segname_tbl_
                         000113 has_segname                 le_make_segname_tbl_
                         000114 i                           le_make_segname_tbl_
                         000116 ledp                        le_make_segname_tbl_
                         000120 lesp                        le_make_segname_tbl_
                         000122 offset                      le_make_segname_tbl_
                         000123 real_defs                   le_make_segname_tbl_
                         000124 success                     le_make_segname_tbl_
                         000126 ts                          le_make_segname_tbl_
                         000140 segname_count               le_make_segname_tbl_
                         000141 def_count                   le_make_segname_tbl_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this_desc  return_mac          enable_op
shorten_stack       ext_entry           int_entry           int_entry_desc      op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_temp_segments_            hash_$in                      hash_$make                    hash_$opt_size
hash_$search                  le_error_                     rehash_                       release_temp_segments_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$full_hashtbl     error_table_$namedup          le_data_$caller               le_et_$dup_segname
le_et_$entrypoints_inaccessible                             le_et_$implementation_error




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     16 000103       127 000115       129 000143       131 000145       133 000161       135 000220       141 000222
    142 000254       143 000257       145 000261       147 000273       148 000274       149 000275       150 000277
    155 000300       157 000306       158 000356       163 000362       164 000371       165 000374       166 000377
    168 000401       172 000404       175 000411       181 000416       187 000435       188 000474       194 000477
    197 000510       198 000514       199 000530       200 000534       201 000542       202 000546       203 000551
    204 000552       205 000557       206 000564       207 000571       212 000573       213 000576       214 000601
    218 000602       219 000615       223 000633       228 000646       232 000650       234 000705       237 000710
    242 000712       248 000714       252 000761       253 000762       255 000763       256 000776       258 001011
    259 001020       261 001023       262 001025       264 001027       270 001030       271 001032       273 001034
    274 001047       276 001062       277 001101       279 001117       280 001125       282 001131       283 001132
    286 001133       288 001135       290 001170       297 001172       345 001206       349 001213       350 001216
    354 001222       361 001246       366 001252       367 001267       371 001305       375 001321       381 001355
    388 001404       393 001410       394 001436       401 001472       406 001477       411 001552       415 001553
    423 001607       425 001615       426 001632       427 001635       430 001642


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
