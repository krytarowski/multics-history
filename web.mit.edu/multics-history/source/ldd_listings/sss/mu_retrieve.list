	COMPILATION LISTING OF SEGMENT mu_retrieve
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1324.4 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 
       19 /****^  HISTORY COMMENTS:
       20*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
       21*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
       22*     This entry is being made to cover the change made on 85-06-14 by Thanh
       23*     Nguyen. (see mrds #137)
       24*  2) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
       25*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
       26*     This entry is being made to cover the change made on 85-10-13 by John
       27*     Hergert. (see mrds #138, phx19901)
       28*                                                   END HISTORY COMMENTS */
       29 
       30 
       31 mu_retrieve: proc (dbcb_ptr, area_ptr, rti_ptr, search_spec_ptr_parm,
       32 	cvla_ptr_parm, tid_ptr, tuple_var_name, whole_stv_ptr,
       33 	simple_typed_vector_ptr_parm, id_list_ptr_parm, code);
       34 
       35 /* NOTES:
       36*
       37*   This  procedure  retrieves  the  next  tuple  within the current range which
       38*   satisfies the specified constraints.
       39*
       40**/
       41 
       42 /* HISTORY:
       43*
       44*   78-11-01 J. A. Weeldreyer: Initially written.
       45*
       46*   79-03-28 Al Kepner: Modified to return the located  tuple_id  for
       47*   the restricted range case.
       48*
       49*   79-05-17 Al Kepner: Modified to add entries db_on & db_off.
       50*
       51*   79-06-21 Al Kepner: Partially rewritten to provide for comparison
       52*   between two values from the same tuple.
       53*
       54*   79-08-21 NSDavids: Comparison of  the  operands  (which  was  not
       55*   always  done  correctly  if  they were of different scales and/or
       56*   precisions) was replaced by a call to mu_compare_values.
       57*
       58*   79-12-01 Rickie E.  Brinegar:  Modified  to  use  mrds_debug_tool
       59*   switches instead of the entry points db_on & db_off.
       60*
       61*   80-02-01 Jim Gray: Modified to add area_ptr parameter.
       62*
       63*   80-02-15 Davids: Modified added data_ptr to the parameter list as
       64*   output.  this  is  a  pointer  to  tuple.data  which is needed by
       65*   mrds_dsl_search for determining the value of varying attributes.
       66*
       67*   80-03-25 R. Lackey: Modified to remove calls to mdbm_util_
       68*
       69*   80-05-08  Davids:  modified  assignments  of  tuple_num_atts  and
       70*   tuple_nvar_atts  to  take  values from rm_rel_info.model_num_attr
       71*   and  model_nvar_atts   rather   than   rm_rel_info.num_attr   and
       72*   nvar_atts.  This  was  to  fix  a problem with submodels were the
       73*   submodel view did not contain a varying string attribute and  the
       74*   model did.
       75*
       76*   80-10-30 M. Pierret: Modified to align 'match' for efficiency  of
       77*   call to mu_compare_values.
       78*
       79*   81-02-20 Rickie E. Brinegar: Changed calls to  mdb_display_value_
       80*   to be calls to mdb_display_data_value$ptr. The latter allows more
       81*   that 256 characters to be displayed.
       82*
       83*   81-03-27 Jim Gray : changed dbi parameter to  dbcb_ptr,  and  for
       84*   the  mu_sec_get_tuple  routines called, changed the dbi parameter
       85*   to both dbcb_ptr and rmri_ptr. This is part of getting rid of the
       86*   mus_ptr_man module.
       87*
       88*   81-05-21   Jim   Gray   :   changed   placement   of   call    to
       89*   mu_comapre_values,  so that if an error occured, the debug output
       90*   about what the values were, gets  displayed.  This  was  done  to
       91*   improve  the  information  in  the error message about conversion
       92*   problems from mu_compare_values. Also added display of data  type
       93*   for the value displayed, for the non-zero error code case.
       94*
       95*   81-05-28 Jim Gray : commented out code dealing wiith foreign  key
       96*   thread chasing.
       97*
       98*   81-06-01 Jim Gray : changed to use new resultant structure.
       99*
      100*
      101*   81-06-17 Jim Gray : added iocb index param to mu_sec_get_tuple$id
      102*   so that key retrieves do not need to use dedicated update iocb.
      103*
      104*   81-10-19 Davids: deleted many declared but unreferenced variables
      105*   and also a couple of include files that were never used. modified
      106*   the internal routine get_comparison_value to call add_bit_offset_
      107*   rather  than  overlaying  a  bit  array  and  taking  the addr of
      108*   bit_array (offset), this because there is a pl1 bug which  causes
      109*   an  incorrect  addr to be returned when the code is compiled with
      110*   the prefix subscriptrange (see tr11784)
      111*
      112*   82-09-03 Mike Kubicar : Converted the module to use the simple vector
      113*   structure instead of the tuple structure.
      114*
      115*   82-10-26 Davids: changed the call to mu_sec_get_tuple$id to pass the
      116*   rtrv_info.record_collection_cursor_ptr instead of the cursor_ptr.
      117*
      118*   82-10-28 Davids: Modified the calls to mu_sec_get_tuple$next and $id
      119*   to use the dbcb.select_area_ptr instead of the area_ptr which is an
      120*   input parameter. The select_area does not get reinitialized until the
      121*   selection expression changes, the area pointed to be the input param
      122*   gets reinitialized at every call of retrieve (or delete or modify)
      123*
      124*   83-04-25 Mike Kubicar : There is no longer any distinction between
      125*   getting tuple sequentially and getting them via a key list.  Removed
      126*   mu_sec_get_tuple$* calls and replaced it with a single internal
      127*   procedure to get the next tuple via a search specification.
      128*
      129*   83-04-28 Davids: Removed dcls for mu_sec_get_tuple$next and id.
      130*   added a dcl for the builtin empty.
      131*
      132*   83-05-24 R. Harvey: Changed to use the appropriate simple_typed_vector_ptr
      133*   and id_list_ptr that are now passed in as arguments.
      134*
      135*   83-05-31 Mike Kubicar : Updated to use new relation manager calling
      136*   sequence and search specification.
      137*
      138*   83-08-03 Mike Kubicar : This program will no longer free the element
      139*   id list after returning from relation manager.  It uses the static
      140*   list set up by search program generation.
      141*
      142*   84-08-07 Thanh Nguyen : Added code to check and call the user's decoded 
      143*   procedure of an attribute (if it is required), in case of the exp_ptr 
      144*   is null.
      145*
      146*   85-01-15 Thanh Nguyen : Added code to check error code after calling 
      147*   get_comparison_value and handle the case of uncessful allocation by reset
      148*   the work area.  Modified get_comparison_value procedure to call
      149*   mrds_space_allocate function instead of the standard PL/I allocate.  Added
      150*   two include files (mrds_space_allocate and mrds_area_initialize).
      151*
      152*   85-01-25 Thanh Nguyen & John Hergert : Added code to check and continue
      153*   to get the next tuple when the get_next_tuple subroutine received the
      154*   mrds_error_$inconsistent_data_length.  This error is caused by the deleted
      155*   tuple in the share mode while getting the tuple by its tuple-id.
      156*
      157*   85-04-14 Thanh Nguyen: Added code to detect the case of the scope that is 
      158*   changed  from non-shared to shared mode.
      159*
      160*   85-06-14 Thanh Nguyen: Added code to check for the scope that is changed
      161*   from non-shared to shared mode only if the dbcb.scopes_changed is on (This
      162*   flag is set by mrds_dsl_set_scope and reset by mrds_dsl_gen_srch_prog and
      163*   mrds_dsl_optimize
      164*
      165*   85-10-13 John Hergert: Backed out some changes made in fix of
      166*   84-08-02. This was done to fix TR's phx11536 and phx19901
      167**/
      168 
      169 /* PARAMETERS:
      170*   dbi -- (INPUT) data base index
      171*
      172*   rti_ptr -- (INPUT) pointer to rtrv_info
      173*
      174*   search_spec_ptr_parm -- (INPUT) pointer to the search spec to use for
      175*   the retrieval.  Note that the search spec may be changed from an
      176*   absolute to relative spec during this call.
      177*
      178*   cvla_ptr_parm -- (INPUT) pointer to list of comparison values
      179*
      180*   tid_ptr -- (INPUT) pointer to place that tuple_id of retrieved tuple
      181*   will be stored.
      182*
      183*   tuple_var_name -- (INPUT) name of the tuple variable for which retrieval
      184*   is done (used for debugging only)
      185*
      186*   whole_stv_ptr -- (INPUT) pointer to simple_typed_vector of whole view of
      187*   relation.
      188*
      189*   simple_typed_vector_ptr -- (INPUT) pointer to newly retrieved tuple
      190*
      191*   id_list_ptr_parm -- (INPUT) pointer to id_list structure which corresponds to
      192*   simple_typed_vector_ptr -> simple_typed_vector.
      193*
      194*   code -- (OUTPUT) error code */
      195 
      196 /* MRDS_DEBUG_TOOL SWITCHES:
      197*
      198*   bit 1 = display values compared.
      199*   bit 2 = display tuple data.
      200*   bits 3 through 9 = not used.
      201**/
      202 
      203 	display_values_compared = substr (db_mu_retrieve, 1, 1);
      204 	display_tuple_data = substr (db_mu_retrieve, 2, 1);
      205 	cvla_ptr = cvla_ptr_parm;
      206 	id_list_ptr = id_list_ptr_parm;
      207 	simple_typed_vector_ptr = simple_typed_vector_ptr_parm;
      208 
      209 	rmri_ptr = rtrv_info.ri_ptr;
      210 	k = 0;
      211 	ta_ptr = rtrv_info.ta_ptr;
      212 	ta_nids = rtrv_info.ntids;
      213 
      214 	found = "0"b;
      215 	do while (^found);				/* loop until find approp. tuple */
      216 
      217 	     call get_next_tuple (dbcb_ptr, rti_ptr,
      218 		search_spec_ptr_parm, simple_typed_vector_ptr, tuple_id);
      219 	     found = "1"b;
      220 
      221 
      222 /* Now that we've got one, see if it matches the rest of the constraints */
      223 
      224 	     i, j = 0;
      225 	     if cvla_ptr ^= null then do;		/* if comparisons to be made */
      226 
      227 		     work_area_ptr = dbcb.work_area_ptr;
      228 		     match = "0"b;
      229 		     do i = 1 to cvl_array.nlists while (^match); /* loop through and groups */
      230 			cvl_ptr = cvl_array.list_ptr (i);
      231 			match = "1"b;
      232 			do j = 1 to comp_val_list.nvals while (match); /* loop through and group items */
      233 
      234 			     desc_ptr1 = addr (comp_val_list.val.desc1 (j));
      235 			     desc_ptr2 = addr (comp_val_list.val.desc2 (j));
      236 			     need_to_free_user_value = "0"b;
      237 GET_COMPARISON_VALUE:
      238 			     call get_comparison_value (
      239 				comp_val_list.val.exp_ptr (j),
      240 				null(),
      241 				comp_val_list.val.erslt_ptr (j),
      242 				comp_val_list.val.attr_ind (j),
      243 				desc_ptr1,
      244 				di_ptr,
      245 				icode);
      246 			     if icode = error_table_$noalloc
      247 			     then do;
      248 				     call mrds_area_initialize (work_area_ptr);
      249 				     go to GET_COMPARISON_VALUE;
      250 				end;
      251 			     if comp_val_list.val.match_ptr (j) = null () /* compare to value from current tuple. */
      252 			     then do;
      253 				     call get_comparison_value (
      254 					comp_val_list.val.exp_ptr2 (j),
      255 					comp_val_list.val.c_ai_ptr2 (j),
      256 					comp_val_list.val.erslt_ptr2 (j),
      257 					comp_val_list.val.attr_ind2 (j),
      258 					desc_ptr2,
      259 					di_ptr2,
      260 					icode);
      261 				     if icode = error_table_$noalloc then do;
      262 					     call mrds_area_initialize (work_area_ptr);
      263 					     go to GET_COMPARISON_VALUE;
      264 					end;
      265 				end;
      266 			     else do;		/* compare to value not from current tuple */
      267 				     di_ptr2 = comp_val_list.val.match_ptr (j);
      268 				end;		/* compare to value not from current tuple */
      269 
      270 			     call mu_compare_values (di_ptr, desc_ptr1, di_ptr2, desc_ptr2,
      271 				comp_val_list.val.op (j), match, code);
      272 
      273 			     if display_values_compared | code ^= 0 then do;
      274 				     if display_values_compared then
      275 					call ioa_ ("di_ptr = ^p; di_ptr2 = ^p", di_ptr, di_ptr2);
      276 				     if display_values_compared then
      277 					call ioa_ ("Compared: ");
      278 				     else call ioa_ ("Compared the data type:  ^a", mu_display_descriptor (desc_ptr1));
      279 				     call mdb_display_data_value$ptr (di_ptr, desc_ptr1);
      280 				     call ioa_ ("Using the comparison operator ""^a"" to:", rtrim (CVL_ops (comp_val_list.val.op (j))));
      281 				     if ^display_values_compared then
      282 					call ioa_ ("The data type:  ^a", mu_display_descriptor (desc_ptr2));
      283 				     call mdb_display_data_value$ptr (di_ptr2, desc_ptr2);
      284 				end;		/* if debug_switch */
      285 
      286 			     if code ^= 0
      287 			     then call error (code);
      288 			     if need_to_free_user_value then
      289 				free value_for_user;
      290 			end;			/* comparing attr. in and group */
      291 		     end;				/* comparing and group with or group */
      292 		     found = match;
      293 		end;				/* if had comparisons */
      294 	     if display_tuple_data then do;
      295 		     call mdb_display_tuple_$data (simple_typed_vector_ptr, rmri_ptr, iox_$user_output, icode);
      296 		     if icode ^= 0 then call error (icode);
      297 		     if found
      298 		     then call ioa_ ("Tuple Accepted for ""^a""", tuple_var_name);
      299 		     else call ioa_ ("Tuple Rejected for ""^a""", tuple_var_name);
      300 		end;				/* if debug switch */
      301 	end;					/* search for tuple */
      302 
      303 	code = 0;
      304 
      305 exit:
      306 	return;
      307 
      308 get_next_tuple:
      309      proc (dbcbptr, retrieve_info_ptr, search_spec_ptr,
      310 	simple_typed_vector_ptr, tuple_id);
      311 
      312 /**********
      313**
      314**   This routine will get the next tuple from a relation.  It needs to call
      315**   get_tuple_id followed by get_tuple_by_id since mrds needs both the
      316**   tuple id and the tuple in many cases.  It tries to use relation manager
      317**   as efficiently as is reasonable.  To do so, it gets as many tuple ids as
      318**   it can by one call to relation manager get_tuple_id.  It will then return
      319**   the first tuple in the list of ids by getting the tuple by id.  On
      320**   successive calls, it will use the other tuple ids in the list.  When
      321**   it has run out of tuple ids, it will get more by calling $get_tuple_id
      322**   again.  The routine effectively buffers tuple ids.  The routine uses
      323**   the following parameters:
      324**
      325**   dbcbptr  (input)  - Pointer to the dbcb
      326**   retrieve_info_ptr (input) - Pointer to the retrieve info to be used
      327**       on this retrieval.  Note that the rtrv_info structure may be
      328**       modified by this procedure.
      329**   search_spec_ptr (input) - The relation_search_specification to be used
      330**       in the search.  Note that the search spec pointed at may be modified by
      331**       this procedure.
      332**   simple_typed_vector_ptr (output) - The tuple which was retrieved.  Note
      333**       that locations pointed at by the simple typed vector structure will
      334**       be filled in with data from the database.  The simple typed vector
      335**       structure itself is not changed.  If no data is to be returned
      336**       by the procedure (i.e. only the tuple id is desired) as indicated
      337**       by a zero array extent on the id list, the contents of the structure
      338**       pointed to by this pointer is undefined.  Indeed, the pointer is not
      339**       used.
      340**   tuple (output) - The tuple id of the tuple returned.
      341**
      342**
      343**   If relation manager returns an error code, the error routine is called.
      344**   Also, if a call is to be made to $get_tuple_id and less tuple ids than
      345**   expected were returned in a prior call, then mrds_error_$no_tuple_found
      346**   is passed to the error routine.
      347**
      348***********/
      349 
      350 
      351 /*  Parameters */
      352 
      353 	dcl     dbcbptr		 ptr;
      354 	dcl     retrieve_info_ptr	 ptr;
      355 	dcl     search_spec_ptr	 ptr;
      356 	dcl     simple_typed_vector_ptr ptr;
      357 	dcl     tuple_id		 bit (36) aligned;
      358 	dcl     continue_for_next_tuple bit (1) aligned;
      359 
      360 /*  Local data */
      361 
      362 	dcl     icode		 fixed bin (35);	/* Returned error code */
      363 
      364 
      365 /* Procedure */
      366 
      367 	continue_for_next_tuple = "1"b;
      368 	do while (continue_for_next_tuple);
      369 	     continue_for_next_tuple = "0"b;
      370 	     if dbcb.scopes_changed then do; 
      371 	        if retrieve_info_ptr -> rtrv_info.ri_ptr -> rm_rel_info.file_type ^= 3 then 
      372 		 /* this relation is not a temporary relation */
      373 		 if dbcb.non_shared_to_shared = "0"b then do;
      374 		     current_scope_ptr = retrieve_info_ptr -> rtrv_info.ri_ptr -> rm_rel_info.scope_flags_ptr;
      375 		     if (current_scope_flags.permits.read_attr |
      376 		         current_scope_flags.permits.delete_tuple |
      377 		         current_scope_flags.permits.modify_attr) then
      378 		        if ^current_scope_flags.prevents.modify_attr |
      379 			(^current_scope_flags.prevents.append_tuple &
      380 			 ^current_scope_flags.prevents.delete_tuple) then
      381 			if retrieve_info_ptr -> rtrv_info.maxtids ^=
      382 			  mrds_data_$max_safe_tids_returned_per_call then
      383 			/* Somebody just changes the scope to shared mode within the
      384*			same select expression (should be -another) */
      385 			  dbcb.non_shared_to_shared = "1"b;
      386 		end;
      387 	     end;
      388 
      389 	     if retrieve_info_ptr -> rtrv_info.ctid >=
      390 		retrieve_info_ptr -> rtrv_info.ntids then do; /* None left from prior call or first time in routine */
      391 		     if retrieve_info_ptr -> rtrv_info.first_seq_io then do; /* Furst get from this tuple variable */
      392 			     retrieve_info_ptr -> rtrv_info.first_seq_io = "0"b;
      393 			     search_spec_ptr -> relation_search_specification.head.type =
      394 				ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE;
      395 			end;
      396 		     else do;			/* Get another set of tids */
      397 			     if retrieve_info_ptr -> rtrv_info.ntids <
      398 				retrieve_info_ptr -> rtrv_info.maxtids /* Got less than we expected last time */
      399 			     then call error (mrds_error_$tuple_not_found);
      400 			     search_spec_ptr -> relation_search_specification.head.type =
      401 				RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE;
      402 			     retrieve_info_ptr -> rtrv_info.ta_ptr -> element_id_list.number_of_elements = 0;
      403 			end;
      404 		     call dbcbptr -> dbcb.relmgr_entries.get_tuple_id (
      405 			retrieve_info_ptr -> rtrv_info.relation_cursor_ptr,
      406 			search_spec_ptr, dbcbptr -> dbcb.select_area_ptr,
      407 			retrieve_info_ptr -> rtrv_info.ta_ptr,
      408 			icode);
      409 		     if icode ^= 0
      410 		     then call error (icode);
      411 		     retrieve_info_ptr -> rtrv_info.ctid = 0;
      412 		     retrieve_info_ptr -> rtrv_info.ntids =
      413 			retrieve_info_ptr -> rtrv_info.ta_ptr -> element_id_list.number_of_elements;
      414 		end;
      415 
      416 
      417 /* Now get the next tuple in the element id list */
      418 
      419 	     retrieve_info_ptr -> rtrv_info.ctid =
      420 		retrieve_info_ptr -> rtrv_info.ctid + 1;
      421 	     tuple_id = retrieve_info_ptr -> rtrv_info.ta_ptr ->
      422 		element_id_list.id (retrieve_info_ptr -> rtrv_info.ctid);
      423 	     if id_list_ptr -> id_list.number_of_ids > 0	/* Retrieving one or more attributes of the tuple */
      424 	     then do;
      425 		     call dbcbptr -> dbcb.relmgr_entries.get_tuple_by_id (
      426 			retrieve_info_ptr -> rtrv_info.relation_cursor_ptr,
      427 			tuple_id, id_list_ptr, dbcbptr -> dbcb.select_area_ptr,
      428 			simple_typed_vector_ptr, icode);
      429 		     if icode = mrds_error_$inconsistent_data_length then do;
      430 			     icode = 0;
      431 			     continue_for_next_tuple = "1"b;
      432 			end;
      433 		     else if icode ^= 0
      434 		     then call error (icode);
      435 		end;
      436 	end;					/* end while */
      437 
      438      end get_next_tuple;
      439 
      440 get_comparison_value: proc (exp_ptr, ai_ptr, erslt_ptr, attr_index, desc_ptr, di_ptr, icode);
      441 
      442 /* This routine produces a pointer to one of the values to be used in the
      443*   comparison.  An attribute will be check and call the decoded procedure
      444*   if there is a decode proc for that attribute.  An expression may be
      445*   evaluated if necessary. */
      446 
      447 	dcl     exp_ptr		 ptr;		/* INPUT : ptr to expression to be evaluated or null */
      448 	dcl     ai_ptr		 ptr;		/* INPUT : ptr to rm_attr_info, it may be null. */
      449 	dcl     erslt_ptr		 ptr;		/* INPUT : ptr to result of expression. */
      450 	dcl     attr_index		 fixed bin (17);	/* INPUT : attribute of interest */
      451 	dcl     desc_ptr		 ptr;		/* INPUT : ptr to descriptor */
      452 	dcl     di_ptr		 ptr;		/* IN/OUT: ptr to comparison value. */
      453 	dcl     icode		 fixed bin (35);	/* IN/OUT: standard error code. */
      454 
      455 	icode = 0;
      456 	if exp_ptr = null ()			/* Just an attribute, no expression */
      457 	then do;
      458 		di_ptr = whole_stv_ptr -> simple_typed_vector.dimension (attr_index).value_ptr;
      459 		if ai_ptr ^= null then /* need to decode attribute */
      460 		     if ai_ptr -> rm_attr_info.domain_ptr -> rm_domain_info.decd_proc
      461 		     then do;
      462 			     t_domain_ptr = ai_ptr -> rm_attr_info.domain_ptr;
      463 			     user_bit_length = t_domain_ptr -> rm_domain_info.user_bit_len;
      464 			     user_val_ptr = mrds_space_allocate (work_area_ptr, (user_bit_length + 35) / 36);
      465 			     if user_val_ptr = null () then do;
      466 				     icode = error_table_$noalloc;
      467 				     return;
      468 				end;
      469 			     k = k + 1;
      470 			     value_for_user = "0"b;	/* clear out space */
      471 						/* evaluate and call decoded procedure */
      472 			     call mu_get_data$get_data_item (ai_ptr, work_area_ptr, di_ptr,
      473 				user_val_ptr, desc_ptr, icode);
      474 			     if icode = error_table_$noalloc then
      475 				return;
      476 			     di_ptr = user_val_ptr;	/* set output ptr */
      477 			end;
      478 	     end;
      479 	else do;					/* if expression */
      480 		di_ptr = erslt_ptr;
      481 		call mrds_dsl_eval_expr (area_ptr, exp_ptr, rmri_ptr, whole_stv_ptr, icode);
      482 	     end;					/* if expression */
      483 	if icode ^= 0 then call error (icode);
      484      end get_comparison_value;
      485 
  1     1 /* BEGINNING OF:  mrds_space_allocate.incl.pl1   * * * * * * * * * * * * * * */
  1     2 
  1     3 /* HISTORY:
  1     4*
  1     5*   Created by:  Thanh Nguyen      01/15/85
  1     6*
  1     7* */
  1     8 
  1     9 
  1    10 mrds_space_allocate:   proc (mrds_area_ptr, requested_word_size) returns (ptr);
  1    11 
  1    12 /* This function "allocates" the requested space in the temporary segment, if
  1    13*   the segment is "mrds area".  The space of allocation will not be free.  If 
  1    14*   the area is full, this function returns a null pointer.  And the user has to
  1    15*   call mrds_area_initialize to reset the temporary segment back to the 
  1    16*   beginning.  So, we never have the overflow on the area and the CPU 
  1    17*   processing time for this allocation is low.  If the segment is not a
  1    18*   "mrds area", this function does a standard PL/I allocate.
  1    19* */
  1    20 
  1    21           dcl     mrds_area_ptr           ptr;       /* ptr to the temporary segment. (INPUT) */
  1    22           dcl     requested_word_size     fixed bin (35); /* number of words to be allocated. (INPUT) */
  1    23 
  1    24           dcl     actual_allocated_size   fixed bin (35); /* number of words to be allocated, rounded up to a 0 + mod 2 quantity. */
  1    25 	dcl     MRDS_AREA               char (8) init ("MRDSAREA");
  1    26           dcl     (mod, null, ptr)        builtin;
  1    27 
  1    28           dcl     1 mrds_area             based (mrds_area_ptr),
  1    29 		2 area_id             char (8),
  1    30 		2 offset_to_free_word fixed bin (35), /* offset to the next free word in temp seg.  */
  1    31 		2 length_free_space   fixed bin (35); /* length of remaining free space in temp seg.*/
  1    32 
  1    33 	dcl     p_work_area             area (sys_info$max_seg_size) based (mrds_area_ptr);
  1    34 	dcl     alloc_value_ptr         ptr;
  1    35 	dcl     alloc_value             (actual_allocated_size) bit (36) based (alloc_value_ptr);
  1    36 
  1    37 
  1    38 	/* round up to even word boundary. */
  1    39 	actual_allocated_size = requested_word_size + mod (requested_word_size, 2);
  1    40 	if mrds_area_ptr = null then return (null);
  1    41 	else if mrds_area.area_id ^= MRDS_AREA then do;
  1    42 	     /* must be a standard PL/I area. */
  1    43 	     allocate alloc_value set (alloc_value_ptr) in (p_work_area);
  1    44 	     return (alloc_value_ptr);
  1    45 	end;
  1    46 	else if actual_allocated_size <= length_free_space then do;
  1    47 	     /* get pointer to next free word of area.  */
  1    48 	     alloc_value_ptr = ptr (mrds_area_ptr, mrds_area.offset_to_free_word);
  1    49 	     /* increase offset of remaining free space */
  1    50 	     mrds_area.offset_to_free_word = mrds_area.offset_to_free_word + actual_allocated_size;
  1    51 	     /* decrease length of remaining free space */
  1    52 	     mrds_area.length_free_space = mrds_area.length_free_space - actual_allocated_size;
  1    53 	     return (alloc_value_ptr);
  1    54 	end;
  1    55 	else return (null);
  1    56 
  1    57 
  1    58 end mrds_space_allocate;
  1    59 
  1    60 /* END OF:     mrds_space_allocate.incl.pl1  * * * * * * * * * * * * * * * * */
      486 
      487 
  2     1 /* BEGINNING OF:  mrds_area_initialize.incl.pl1    * * * * * * * * * * * * * */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*   Created by:  Thanh Nguyen      01/15/85
  2     6*
  2     7* */
  2     8 
  2     9 
  2    10 mrds_area_initialize:  proc (mrds_area_ptr);
  2    11 
  2    12 /* This procedure resets the given temporary segment and initializes the offset
  2    13*   and length of the free space to beginning of the segment.  Function 
  2    14*   mrds_space_allocate in mrds_space_allocate.incl.pl1 must be used to allocate
  2    15*   any storage into this temporary segment.
  2    16* */
  2    17 
  2    18           dcl     mrds_area_ptr           ptr;       /* ptr to the temporary segment. */
  2    19 	dcl     MRDS_AREA               char (8) init ("MRDSAREA");
  2    20 
  2    21           dcl     1 mrds_area             based (mrds_area_ptr),
  2    22 	          2 area_id             char (8),
  2    23 		2 offset_to_free_word fixed bin (35), /* offset to the next free word in temp seg.  */
  2    24 		2 length_free_space   fixed bin (35); /* length of remaining free space in temp seg.*/
  2    25 
  2    26           dcl     sys_info$max_seg_size   fixed bin(35) ext static;
  2    27 
  2    28 
  2    29 	if mrds_area_ptr ^= null then do;
  2    30 	     /* Set our identification, so we can recognize it later */
  2    31 	     mrds_area.area_id = MRDS_AREA;
  2    32 	     /* Start from word four right after our heading structure. */
  2    33 	     mrds_area.offset_to_free_word = 4;
  2    34 	     mrds_area.length_free_space = sys_info$max_seg_size - 4;
  2    35 	end;
  2    36 	return;
  2    37 
  2    38 end mrds_area_initialize;
  2    39 
  2    40 /* END OF:        mrds_area_initialize.incl.pl1    * * * * * * * * * * * * * */
      488 
      489 
      490 error: proc (cd);
      491 
      492 /* Error procedure */
      493 
      494 	dcl     cd		 fixed bin (35);
      495 
      496 	if (cd = dm_error_$no_tuple) | (cd = dm_error_$no_tuple_id)
      497 	then code = mrds_error_$no_tuple;
      498 	else code = cd;
      499 	go to exit;
      500 
      501      end error;
      502 
      503 	dcl     cvla_ptr_parm	 ptr;
      504 	dcl     id_list_ptr_parm	 ptr parameter;
      505 	dcl     simple_typed_vector_ptr_parm ptr parameter;
      506 	dcl     search_spec_ptr_parm	 ptr;
      507 	dcl     tuple_var_name	 char (*);	/* tuple variable name for debugging */
      508 	dcl     user_bit_length	 fixed bin;
      509 	dcl     value_for_user	 bit (user_bit_length) based (user_val_ptr);
      510 	dcl     work_area_ptr	 ptr;
      511 
      512 	dcl     (i, k,				/* internal indexes */
      513 	        j)		 fixed bin;
      514 
      515 	dcl     (code,				/* Output:  status code */
      516 	        icode)		 fixed bin (35);	/* offset of item in tuple.data */
      517 
      518 	dcl     (area_ptr,
      519 	        desc_ptr1,				/* ptr to desc for first value to be compared. */
      520 	        desc_ptr2,				/* ptr to desc for second value to be compared. */
      521 	        di_ptr,				/* to data item */
      522 	        di_ptr2,				/* ptr to second comparison value */
      523 	        t_domain_ptr,			/* temp ptr use to point to rm_domain_info. */
      524 	        tid_ptr,
      525 	        user_val_ptr,			/* ptr to converted value for decoding */
      526 	        whole_stv_ptr)	 ptr;		/* Input:  to place to store tuple id */
      527 
      528 
      529 	dcl     (display_tuple_data,			/* flags */
      530 	        display_values_compared,
      531 	        found)		 bit (1) unaligned;
      532 
      533 	dcl     match		 bit (1) aligned;	/* aligned for efficiency in call to mu_compare_values */
      534 	dcl     need_to_free_user_value bit (1) aligned;
      535 
      536 	dcl     (addr,
      537 	        fixed,
      538 	        null,
      539 	        rel,
      540 	        rtrim,
      541 	        substr,
      542 	        unspec)		 builtin;
      543 
      544 	dcl     tuple_id		 bit (36) aligned based (tid_ptr);
      545 
      546 	dcl     CVL_ops		 (1:6) char (2) int static options (constant) init (
      547 				 "=",
      548 				 "^=",
      549 				 "<",
      550 				 "<=",
      551 				 ">",
      552 				 ">=");
      553 	dcl     1 current_scope_flags	aligned based (current_scope_ptr) like scope_flags;
      554           dcl     current_scope_ptr      ptr;
      555 	dcl     dm_error_$no_tuple	 fixed bin (35) ext static;
      556 	dcl     dm_error_$no_tuple_id	 fixed bin (35) ext static;
      557 	dcl     mrds_data_$max_safe_tids_returned_per_call fixed bin (35) ext static;
      558 	dcl     mrds_error_$no_tuple	 ext fixed bin (35);
      559 	dcl     mrds_error_$tuple_not_found fixed bin (35) ext static;
      560 	dcl     mrds_error_$inconsistent_data_length fixed bin (35) ext static;
      561 	dcl     mrds_dsl_eval_expr	 entry (ptr, ptr, ptr, ptr, fixed bin (35));
      562 	dcl     ioa_		 entry options (variable);
      563 
      564 	dcl     iox_$user_output	 ext ptr;
      565 
      566 	dcl     sys_info$max_seg_size	 fixed bin (35) ext static;
      567 
      568 	dcl     error_table_$noalloc	 fixed bin (35) ext static;
      569 
      570 	dcl     mdb_display_data_value$ptr entry (ptr, ptr);
      571 
      572 	dcl     mdb_display_tuple_$data entry (ptr, ptr, ptr, fixed bin (35));
      573 	dcl     mu_compare_values	 entry (ptr, ptr, ptr, ptr, fixed bin, bit (1) aligned, fixed bin (35));
      574 	dcl     mu_display_descriptor	 entry (ptr) returns (char (120) varying); /* gets char form of descriptor */
      575 	dcl     mu_get_data$get_data_item entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35));
      576 
  3     1 /* BEGIN INCLUDE FILE  - dm_element_id_list.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*          The element_id_list structure contains an array of element 
  3     5*     identifiers.  These identifiers are used as tuple, record or 
  3     6*     element identifiers.  This structure is used across the relation_manager_,
  3     7*     record_manager_ and index_manager_ interfaces.  At some time the 
  3     8*     version should be changed to be char(8)aligned, when such a conversion
  3     9*     can be coordinated with the other structures used at these interfaces.
  3    10**/
  3    11 
  3    12 /* HISTORY:
  3    13*Written by Matthew Pierret, 06/06/82.
  3    14*Modified:
  3    15*12/16/82 by Roger Lackey:  Changed number_of_elements to fixed bin (35).
  3    16*            Did not change version.
  3    17*02/11/85 by Matthew Pierret:  Added DESCRIPTION, Written by.
  3    18**/
  3    19 
  3    20 /* format: style2,ind3 */
  3    21      dcl	   1 element_id_list      aligned based (element_id_list_ptr),
  3    22 	     2 version	      fixed bin (35),
  3    23 	     2 number_of_elements fixed bin (35),
  3    24 	     2 id		      (eil_number_of_elements refer (element_id_list.number_of_elements)) bit (36) aligned;
  3    25 
  3    26      dcl	   element_id_list_ptr    ptr;
  3    27      dcl	   eil_number_of_elements fixed bin (35);
  3    28      dcl	   ELEMENT_ID_LIST_VERSION_1
  3    29 			      init (1) fixed bin (35);
  3    30 
  3    31 
  3    32 /* END INCLUDE FILE  - dm_element_id_list.incl.pl1 */
      577 
      578 
  4     1 /* BEGIN INCLUDE FILE - dm_id_list.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION
  4     4*        The id_list structure is used to identify attributes, fields and
  4     5*   dimensions by various modules of the Data Management System.
  4     6**/
  4     7 
  4     8 /* HISTORY:
  4     9*Written by Matthew Pierret, '82.
  4    10*Modified:
  4    11*08/17/83 by Matthew Pierret: Made version constant 'internal static options
  4    12*            (constant)' and to initialize automatic variables.
  4    13**/
  4    14 
  4    15 /* format: style2,ind3 */
  4    16      dcl	   1 id_list	      aligned based (id_list_ptr),
  4    17 	     2 version	      fixed bin (35),
  4    18 	     2 number_of_ids      fixed bin (17),
  4    19 	     2 id		      (il_number_of_ids refer (id_list.number_of_ids)) fixed bin (17);
  4    20 
  4    21      dcl	   id_list_ptr	      ptr init (null);
  4    22      dcl	   il_number_of_ids	      fixed bin (17) init (-1);
  4    23      dcl	   ID_LIST_VERSION_1      fixed bin (17) init (1) internal static options (constant);
  4    24 
  4    25 /* END INCLUDE FILE - dm_id_list.incl.pl1 */
      579 
      580 
  5     1 /* BEGIN INCLUDE FILE dm_relation_spec.incl.pl1 */
  5     2 
  5     3 /* HISTORY:
  5     4*Written by Matthew Pierret, 05/10/83.
  5     5*Modified:
  5     6**/
  5     7 
  5     8 /* format: style2,ind3 */
  5     9      dcl	   1 relation_search_specification
  5    10 			      aligned based (relation_search_specification_ptr),
  5    11 	     2 head	      like specification_head,
  5    12 	     2 maximum_number_of_constraints
  5    13 			      fixed bin (17) unal,
  5    14 	     2 number_of_and_groups
  5    15 			      fixed bin (17) unal,
  5    16 	     2 flags	      unal,
  5    17 	       3 return_unique_tuples
  5    18 			      bit (1) unal,
  5    19 	       3 mbz	      bit (35) unal,
  5    20 	     2 range,
  5    21 	       3 type	      fixed bin (17),
  5    22 	       3 size	      fixed bin (17),
  5    23 	     2 and_group	      (rss_number_of_and_groups refer (relation_search_specification.number_of_and_groups)),
  5    24 	       3 search_collection_id
  5    25 			      bit (36) aligned,
  5    26 	       3 flags	      unal,
  5    27 	         4 collection_id_supplied
  5    28 			      bit (1) unal,
  5    29 	         4 mbz	      bit (17) unal,
  5    30 	       3 number_of_constraints
  5    31 			      fixed bin (17) unal,
  5    32 	       3 constraint	      (rss_maximum_number_of_constraints
  5    33 			      refer (relation_search_specification.maximum_number_of_constraints)),
  5    34 	         4 field_id	      fixed bin (17) unal,
  5    35 	         4 operator_code  fixed bin (17) unal,
  5    36 	         4 value_field_id fixed bin (17) unal,
  5    37 	         4 mbz	      bit (18) unal,
  5    38 	         4 value_ptr      ptr;
  5    39 
  5    40 
  5    41      dcl	   1 relation_numeric_specification
  5    42 			      aligned based (relation_numeric_specification_ptr),
  5    43 	     2 head	      like specification_head,
  5    44 	     2 collection_id      bit (36) aligned,
  5    45 	     2 range_size	      fixed bin (35),
  5    46 	     2 position_number    fixed bin (17) unal,
  5    47 	     2 pad	      bit (18) unal;
  5    48 
  5    49 
  5    50      dcl	   (relation_search_specification_ptr, relation_numeric_specification_ptr)
  5    51 			      ptr init (null);
  5    52      dcl	   (rss_number_of_and_groups, rss_maximum_number_of_constraints)
  5    53 			      fixed bin (17) init (0);
  5    54 
  5    55 
  5    56 
  5    57 /* END INCLUDE FILE dm_relation_spec.incl.pl1 */
      581 
      582 
  6     1 /* BEGIN INCLUDE FILE dm_specification_head.incl.pl1 */
  6     2 
  6     3 /* HISTORY:
  6     4*Written by Matthew Pierret, 05/11/83. (Extracted from dm_specification.incl.pl1)
  6     5*Modified:
  6     6*05/20/83 by Matthew Pierret: Changed to use version 4.
  6     7**/
  6     8 
  6     9 /* format: style2,ind3 */
  6    10      dcl	   1 specification_head   based (specification_head_ptr),
  6    11 	     2 version	      fixed bin (35),
  6    12 	     2 type	      fixed bin (17) unal,
  6    13 	     2 pad	      bit (18) unal,
  6    14 	     2 subset_specification_ptr
  6    15 			      ptr;
  6    16 
  6    17 
  6    18      dcl	   specification_head_ptr ptr;
  6    19      dcl	   SPECIFICATION_VERSION_4
  6    20 			      init (4) fixed bin (35) internal static options (constant);
  6    21 
  6    22      dcl	   (
  6    23 	   SEARCH_SPECIFICATION_TYPE
  6    24 			      init (1),
  6    25 	   ABSOLUTE_SEARCH_SPECIFICATION_TYPE
  6    26 			      init (1),
  6    27 	   NUMERIC_SPECIFICATION_TYPE
  6    28 			      init (2),
  6    29 	   ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
  6    30 			      init (2),
  6    31 	   RELATIVE_SEARCH_SPECIFICATION_TYPE
  6    32 			      init (3),
  6    33 	   RELATIVE_NUMERIC_SPECIFICATION_TYPE
  6    34 			      init (4),
  6    35 	   ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
  6    36 			      init (5),
  6    37 	   RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
  6    38 			      init (6),
  6    39 	   ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
  6    40 			      init (7),
  6    41 	   RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
  6    42 			      init (8)
  6    43 	   )		      fixed bin (17) internal static options (constant);
  6    44 
  6    45 
  6    46 /* END INCLUDE FILE dm_specification_head.incl.pl1 */
      583 
      584 
  7     1 /* BEGIN mdbm_scope_info.incl.pl1 -- odf 8/8/78 */
  7     2 
  7     3 /* WARNING
  7     4*          If the scope_info or scope_flags structure is changed then the
  7     5*          mrds_data_ item saved_res_version MUST be incremented to invalidate
  7     6*          all existing saved resultants
  7     7**/
  7     8 
  7     9 /* Modified by Jim Gray - - 80-11-17, to add back store/delete/modify permissions */
  7    10 
  7    11 /* 80-12-10 Jim Gray : change name of store to append_tuple, delete to delete_tuple,
  7    12*   modify to modify_attr, retrieve to read_attr, remvoe update, put level 4
  7    13*   qualifiers for permit/prevent modes and to put pads in standard format */
  7    14 
  7    15 /* 80-12-11 Jim Gray : added submodel version of file/rel name for convenience */
  7    16 
  7    17 /* 80-12-22 Jim Gray : added like referenced structure so linus_scope_data.incl
  7    18*   could make use of it for compatibility. */
  7    19 
  7    20 /* 81-1-11 Jim Gray : added touched bit to scope_flags, so that
  7    21*   the fact that null scope has been set can be displayed */
  7    22 
  7    23 /* 85-04-14 Thanh Nguyen: Made scope_flags to be aligned so we could access the
  7    24*   prevent flags from any pointer which directly pointed to scope_flags itself
  7    25*   (i.e rm_rel_info.scope_flags_ptr). */
  7    26 
  7    27 /* this structure is to be allocated in the mrds_dbcb.incl.pl1 static area,
  7    28*   and is used to maintain the scope mechanism for file access.
  7    29*   It contains the scope permit/prevent operations that this user
  7    30*   has set in his view for this opening instance. */
  7    31 
  7    32 dcl 1 scope_info aligned based (scope_ptr),		/* array of scope tuples for this user */
  7    33     2 mbz1 bit (144),				/* Reserved for future use */
  7    34     2 nfiles fixed bin,				/* Number of scope tuples in user's scope */
  7    35     2 active_scopes fixed bin,			/* number of scopes currently active for a given user */
  7    36     2 scope (max_file_init refer (scope_info.nfiles)),	/* defines user's scope of access to files */
  7    37       3 name char (30) aligned,			/* filename */
  7    38       3 sm_name char (32),				/* name of file(rel) in submodel */
  7    39       3 flags like scope_flags ;
  7    40 
  7    41 
  7    42 declare 1 scope_flags aligned based,			/* common layout of scope flag bits */
  7    43         2 permits,					/* modes to permit this user */
  7    44 	3 read_attr bit (1) unal,			/* read_attr access to this file in scope */
  7    45 	3 append_tuple bit (1) unal,			/* append_tuple concnrrency permission */
  7    46 	3 delete_tuple bit (1) unal,			/* delete_tuple concurrency permission on rel */
  7    47 	3 modify_attr bit (1) unal,			/* modify_attr concurrency permission */
  7    48 	3 mbz2 bit (10) unal,			/* for expansion of permit ops */
  7    49         2 prevents,					/* modes to be denyed to other users */
  7    50 	3 read_attr bit (1) unal,			/* on if user has prevent on read_attr for this file */
  7    51 	3 append_tuple bit (1) unal,			/* prevent of append_tuple concurrency */
  7    52 	3 delete_tuple bit (1) unal,			/* prevent of delete_tuple concurrency */
  7    53 	3 modify_attr bit (1) unal,			/* prevent of modify_attr concurrency */
  7    54 	3 mbz3 bit (10) unal,			/* for future prevent concurrency modes */
  7    55         2 touched bit (1) unal,			/* on => scope set for this relation */
  7    56         2 mbz4 bit (7) unal ;				/* for future flags */
  7    57 
  7    58 dcl  max_file_init fixed bin;				/* nbr. of files in data base */
  7    59 dcl  scope_ptr ptr init (null ());			/* points to scope_info array */
  7    60 dcl  scope_rdy bit (6) unal init ("000011"b) int static options (constant); /* scope file ready modes (5 or 6) */
  7    61 dcl  scope_rdy_array (6) bit (1) unal based;		/* array format of scope_rdy string */
  7    62 
  7    63 /* END mdbm_scope_info.incl.pl1 */
      585 
      586 
  8     1 /* BEGIN mdbm_comp_val_list.incl.pl1 -- jaw, 2/23/79 */
  8     2 
  8     3 
  8     4 /****^  HISTORY COMMENTS:
  8     5*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  8     6*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  8     7*     This entry is being made to cover the change made on 85-10-13 by John
  8     8*     Hergert. (see mrds #138, phx19901)
  8     9*                                                   END HISTORY COMMENTS */
  8    10 
  8    11 /* HISTORY:
  8    12*   Modified by Al Kepner, June 22, 1979 to provide for comparing two
  8    13*   values from the same tuple.
  8    14*
  8    15*   82-10-12 Davids: changed rel_id from bit (12) to bit (36) aligned.
  8    16*
  8    17*   82-10-26 Woodka: deleted fields attr_pos_ind and attr_pos_ind2, 
  8    18*   no longer needed.
  8    19*
  8    20*   84-08-07 Thanh Nguyen: Added c_ai_ptr and c_ai_ptr2 (ptr for 
  8    21*   rm_attr_info).  These ptrs will be needed for checking of decoded proc
  8    22*   if we only have an attribute and exp_ptr is null.
  8    23*
  8    24*   85-10-13 John Hergert: removed c_ai_ptr for fixes for TRs phx19901
  8    25*   and phx11536. c_ai_ptr2 is now used as a flag to tell mu_retrieve
  8    26*   that the first comaparand is an expression and the second one should 
  8    27*   be decoded.
  8    28* */
  8    29 
  8    30 dcl 1 comp_val_list aligned based (cvl_ptr),		/* compar. list for hash search */
  8    31     2 nvals fixed bin,
  8    32     2 rel_id bit (36) aligned,			/* id of relation being searched */
  8    33     2 val (cvl_nvals_init refer (comp_val_list.nvals)),
  8    34       3 match_ptr ptr,				/* pointer to second comparison value
  8    35*						   when it is not in the current tuple
  8    36*						   or null (if both values are from the current tuple.) */
  8    37       3 exp_ptr ptr,				/* to expr to be evaluated, or null */
  8    38       3 exp_ptr2 ptr,				/* to expr to be evaluated, or null */
  8    39       3 c_ai_ptr2 ptr,                                      /* to rm_attr_info, and only be used when exp_ptr2 is not null. */
  8    40       3 erslt_ptr ptr,				/* to result of first expression */
  8    41       3 erslt_ptr2 ptr,				/* to result of second expression */
  8    42       3 op fixed bin,				/* 1 => =
  8    43*						   2 => ^=
  8    44*						   3 => <
  8    45*						   4 => <=
  8    46*						   5 => >
  8    47*						   6 => >= */
  8    48       3 desc1 bit (36),				/* descriptor for first comparison value */
  8    49       3 desc2 bit (36),				/* descriptor for second comparison value */
  8    50       3 attr_ind fixed bin,				/* attr. index for first value */
  8    51       3 attr_ind2 fixed bin,				/* attr. index for 2nd value in same tuple or 0 */
  8    52       3 pad bit (36);				/* fill to double word boundary. */
  8    53 
  8    54 dcl  cvl_ptr ptr int automatic init (null ());
  8    55 dcl  cvl_nvals_init fixed bin;
  8    56 
  8    57 dcl ((CVL_EQ init (1)),
  8    58     (CVL_NE init (2)),
  8    59     (CVL_LT init (3)),
  8    60     (CVL_LE init (4)),
  8    61     (CVL_GT init (5)),
  8    62     (CVL_GE init (6))) fixed bin int static options (constant);
  8    63 
  8    64 dcl 1 cvl_array aligned based (cvla_ptr),		/* array of lists */
  8    65     2 nlists fixed bin,
  8    66     2 list_ptr (cvla_nlists_init refer (cvl_array.nlists)) ptr;
  8    67 
  8    68 dcl  cvla_nlists_init fixed bin;
  8    69 dcl  cvla_ptr ptr int automatic init (null ());
  8    70 
  8    71 /* END mdbm_comp_val_list.incl.pl1 */
  8    72 
      587 
      588 
  9     1 /* BEGIN mdbm_rm_rel_info.incl.pl1 -- jaw, 11/16/78 */
  9     2 
  9     3 /* WARNING
  9     4*          If the rm_rel_info structure is changed then the mrds_data_
  9     5*          item saved_res_version MUST be incremented to invalidate all
  9     6*          existing saved resultants
  9     7**/
  9     8 
  9     9 /* HISTORY:
  9    10*
  9    11*   Modified by Jim Gray - - May 1980, to  include  model  number  of
  9    12*   attributes,   and   varying  attributes,  so  that  partial  view
  9    13*   submodels will have the  info  needed  to  properly  set  up  the
  9    14*   varying length array headers in the tuple structure.
  9    15*
  9    16*   Modified  by  Jim  Gray  -  -  80-11-06,  to  rename   r_perm   =
  9    17*   status_perm,     s_perm    =    append_tuple_perm,    d_perm    =
  9    18*   delete_tuple_perm, and make m_perm = unused_perm.
  9    19*
  9    20*   81-01-23 Jim Gray : added bit to indicate whether the last  model
  9    21*   view attribute was varying character or bit, since a partial view
  9    22*   submodel will not have this information in the resultant, and  it
  9    23*   is  needed for determining the new tuple length in mus_mod_ubtup,
  9    24*   since with exact length storage  of  varying  length  attributes,
  9    25*   each  tuple  can  be  a  different  length,  which is can only be
  9    26*   determined by examining the tuple itself.
  9    27*
  9    28*   81-01-29 Jim Gray : added curent  tuple  count,  to  provide  for
  9    29*   interface  to  allow  temp  rel  population  to  be known, and to
  9    30*   provide a more efficient means of finding an approx. current perm
  9    31*   relation population.
  9    32*
  9    33*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  9    34*   blocked  files, foreign keys, and ids procedures. Also set number
  9    35*   of files per rel to a constant of 1.
  9    36*
  9    37*   81-05-28 Jim Gray : combined data  from  rm_file_info  into  this
  9    38*   structure so that only one structure per relation is needed.
  9    39*
  9    40*   81-07-02 Jim Gray : added total_key and dup_key vfile  statistics
  9    41*   counts.   Also  added  number  of  operations  count  since  last
  9    42*   statistics update, and a time  since  the  statistics  were  last
  9    43*   updated.
  9    44*
  9    45*   81-07-06 Jim Gray :  added  a  per  selection  expression  update
  9    46*   identifier so that small relations could be updated on a per S.E.
  9    47*   basis
  9    48*
  9    49*   82-04-21 R. Lackey : Added number_selected (ri_niocbs_init refer (rm_rel_info.niocbs)) fixed bin (35)
  9    50*   to end of structure   TR 12205 (Suggestion).
  9    51*   
  9    52*   82-08-19 D. Woodka :  Removed  rm_rel_info.max_data_len  field for
  9    53*   the DMS conversion. 
  9    54*
  9    55*   82-08-30 Davids: added the opening_id element and removed the iocb
  9    56*   array and the niocb element for DMS conversion. Also removed the
  9    57*   number_selected array (and ri_niocbs_init) since subsets are not
  9    58*   going to be used.
  9    59*
  9    60*   82-09-20 Mike Kubicar : changed rm_rel_info.rel_id to bit (36) aligned
  9    61*   so that it can be used with relation manager.  Also added
  9    62*   rm_rel_info.primary_key_index_id for relation manager.
  9    63*
  9    64*   82-09-22 Mike Kubicar : Removed the, now useless, fields var_attr_ptrs,
  9    65*   nvar_atts, model_nvar_atts.
  9    66*
  9    67*   82-09-24 Davids: Removed current_key_count and current_dup_key_count
  9    68*   since the duplicate key count for each secondary index is now being
  9    69*   kept in the attr_info structure and key_count was only needed to
  9    70*   help in calculating the average selectivity of each index which
  9    71*   can now be gotten directly from each index's dup key count. Also
  9    72*   removed the file_id element since it is no longer needed for
  9    73*   anything.
  9    74*
  9    75*   82-09-27 Mike Kubicar : removed file_id_len for the same reason file_id
  9    76*   was removed.
  9    77*
  9    78*   82-11-05 Mike Kubicar : added a pointer to an id_list structure to be
  9    79*   used when retrieving tuples from this relation.
  9    80*
  9    81*   83-04-06 Davids: Added the scope_flags_ptr which points to the scope_flags structure
  9    82*   for the relation. Note that this structure is part of the resultant NOT
  9    83*   part of the db.control structure. The scopes are duplicated in the resultant
  9    84*   to reduce contention for the db.control structure. Note also that the pointer
  9    85*   will always point to a scope_flags structure even if no scopes have been
  9    86*   set on the relation, the structure is allocated when the db is opened.
  9    87**/
  9    88 
  9    89 
  9    90 /* DESCRIPTION:
  9    91*
  9    92*   This structure is allocated in the area part of the structure  in
  9    93*   mdbm_rm_db_info.incl.pl1  as  part of the resultant model created
  9    94*   at open  time  for  a  database.  There  will  be  one  of  these
  9    95*   rm_rel_info   structures  for  each  relation  appearing  in  the
  9    96*   database view (there may be less than the total in  the  database
  9    97*   for  a  submodel  openings).  There  will  also  be  one for each
  9    98*   temporary relation currently defined for that opening.
  9    99*
  9   100*   The structure in mdbm_rm_rel_array.incl.pl1 contains pointers  to
  9   101*   all  rm_rel_info  structures  allocated. It is used for searching
  9   102*   for the appropriate  structure.  This  array  is  pointed  to  by
  9   103*   rm_db_info. There are two arrays, one for perm rels, one for temp
  9   104*   rels.
  9   105*
  9   106*   The      rm_rel_info      structure      points      to       the
  9   107*   mdbm_rm_attr_info.incl.pl1  structures,  one  for  each attribute
  9   108*   appearing in this view of the relation. Each  of  these  in  turn
  9   109*   point  to a mdbm_rm_domain_info.incl.pl1 structure for the domain
  9   110*   info for each attr.
  9   111*
  9   112*   Most of the other information here deals with  specifics  of  the
  9   113*   relation's  logical  definition,  such as key and secondary index
  9   114*   attribute inidicators, security permissions, and  tuple  physical
  9   115*   construction details.
  9   116*
  9   117**/
  9   118 
  9   119      dcl	   1 rm_rel_info	      aligned based (rmri_ptr), /* relation information */
  9   120 	     2 name	      char (32),		/* from submodel */
  9   121 	     2 model_name	      char (30),		/* from model */
  9   122 	     2 rel_id	      bit (36) aligned,	/* unique id. */
  9   123 	     2 retrieve	      bit (1) unal,		/* operations allowed by this view */
  9   124 	     2 modify	      bit (1) unal,
  9   125 	     2 delete	      bit (1) unal,
  9   126 	     2 store	      bit (1) unal,
  9   127 	     2 total_key	      bit (1) unal,		/* on if view includes full primary key */
  9   128 	     2 indexed	      bit (1) unal,		/* on if exists sec. index */
  9   129 	     2 mdbm_secured	      bit (1) unal,		/* on if mdbm must check security */
  9   130 	     2 status_perm	      bit (1) unal,		/* if user has status. perm. */
  9   131 	     2 append_tuple_perm  bit (1) unal,		/* if user has store perm. */
  9   132 	     2 delete_tuple_perm  bit (1) unal,		/* if user has del. perm. */
  9   133 	     2 unused_perm	      bit (1) unal,		/* for future use. */
  9   134 	     2 last_model_attr_char_var bit (1) unal,	/* on => last model varying attr is char */
  9   135 	     2 reserved	      bit (24) unal,	/* for future use */
  9   136 	     2 num_attr	      fixed bin,		/* total no. of attr. in rel. */
  9   137 	     2 model_num_attr     fixed bin,		/* total attrs in model relation */
  9   138 	     2 nkey_attr	      fixed bin,		/* no. of key attr. */
  9   139 	     2 model_nkey_attr    fixed bin,		/* total number of keys in model */
  9   140 	     2 primary_key_index_id bit (36) aligned,     /* Index id of relation's primary key */
  9   141 	     2 nsec_inds	      fixed bin,		/* no. sec. indexes */
  9   142 	     2 max_key_len	      fixed bin (35),	/* max length (chars) of primary key */
  9   143 	     2 current_tuple_population fixed bin (35),	/* last known total  tuple count for this relation */
  9   144 	     2 last_statistics_update_count fixed bin,	/* number of operations's, since this rels stats were updated */
  9   145 	     2 last_statistics_update_time fixed bin (71),/* last time this rels stats were updated */
  9   146 	     2 last_statistics_update_s_e_ref_num fixed bin (35), /* last select expr ID that updated this rels stats */
  9   147 	     2 ready_mode	      fixed bin,		/* 1 => r, 2 => mr, 3 => u, 4 => l, 5 => sr, 6 => su */
  9   148 	     2 file_type	      fixed bin,		/* 1 => unblocked, 2 => blocked, 3 => temporary */
  9   149 	     2 tuple_id_len	      fixed bin,		/* no. bits in local tuple id */
  9   150 	     2 opening_id	      bit (36) aligned,	/* relation manager opening is */
  9   151 	     2 key_attr_ptrs      (nkey_attr_init refer (rm_rel_info.nkey_attr)) ptr, /* ptrs to key attr. */
  9   152 	     2 attr_ptrs	      (natts_init refer (rm_rel_info.num_attr)) ptr, /* ptrs to all attr. */
  9   153 	     2 id_list_ptr        ptr,		/* Id list for retrieves from the relation */
  9   154                2 scope_flags_ptr    ptr;                    /* pointer to the scope_flags structure for the rel */
  9   155 
  9   156      dcl	   rmri_ptr	      ptr;
  9   157      dcl	   (nkey_attr_init,
  9   158 	   natts_init,
  9   159 	   nvar_atts_init)	      fixed bin;
  9   160 
  9   161 /* END mdbm_rm_rel_info.incl.pl1 */
  9   162 
  9   163 
      589 
      590 
 10     1 /*  BEGIN  mdbm_rm_attr_info.incl.pl1  --  jaw,  11/16/78  */
 10     2 
 10     3 /* WARNING
 10     4*          If the rm_attr_info structure is changed then the mrds_data_
 10     5*          item saved_res_version MUST be incremented to invalidate all
 10     6*          existing saved resultants
 10     7**/
 10     8 
 10     9 /*
 10    10*
 10    11*   Modified  by  Jim  Gray - - 80-11-05, to add mdbm_secured bit, so
 10    12*   that rm_rel_info does not have to be checked
 10    13*
 10    14*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
 10    15*   foreign keys.
 10    16*
 10    17*   82-08-19  D. Woodka : removed rm_attr_info.bit_offset for the DMS
 10    18*   conversion.
 10    19*
 10    20*   82-09-15 Davids: added the number_of_dups field.
 10    21*
 10    22*   82-09-20 Mike Kubicar : changed the index_id field to be bit (36)
 10    23*   aligned.  This is to conform with the new definition in the database
 10    24*   model.  Also removed the now useless field varying.
 10    25*
 10    26*   82-11-05 Davids: added the field model_defn_order and clarified the
 10    27*   comment for the field defn_order.
 10    28*
 10    29*   83-05-23 Mike Kubicar : changed number_of_dups to fixed bin (35) since
 10    30*   that's what relation manager returns.
 10    31*
 10    32**/
 10    33 
 10    34 
 10    35 /*
 10    36*   this   structure   is   allocated   in   the   static   area   of
 10    37*   mdbm_rm_db_info.incl.pl1  once for each attribute per relation in
 10    38*   a     readied     file.      it     in     turn     points     to
 10    39*   mdbm_rm_domain_info.incl.pl1  for  the  attributes  domain.   the
 10    40*   rm_attr_info  is  pointed  to  by mdbm_rm_rel_info.incl.pl1.  all
 10    41*   structures  are  in  the  rm_db_info  area.   the  attribute data
 10    42*   position  within  a  tuple as stored in the data file are kept in
 10    43*   this resultant model of the attribute.
 10    44* */
 10    45 
 10    46 dcl 1 rm_attr_info aligned based (rai_ptr),		/* resultant attr. info */
 10    47     2 name char (32),				/* from submodel */
 10    48     2 model_name char (32),				/* from model */
 10    49     2 key_attr bit (1) unal,				/* if key attribute */
 10    50     2 index_attr bit (1) unal,			/* if secondary index */
 10    51     2 read_perm bit (1) unal,				/* user has retr. permission */
 10    52     2 modify_perm bit (1) unal,			/* user has modify permission */
 10    53     2 mdbm_secured bit (1) unal,			/* on => database secured */
 10    54     2 reserved bit (30) unal,				/* for future use */
 10    55     2 index_id bit (36) aligned,			/* index id if index_attr */
 10    56     2 defn_order fixed bin,				/* relative order in which attr is defined in the view */
 10    57     2 key_order fixed bin,				/* relative order defined in prim. key */
 10    58     2 bit_length fixed bin (35),			/* length if fixed, max. len. if var. */
 10    59     2 domain_ptr ptr,				/* to domain info */
 10    60     2 number_of_dups fixed bin (35),                        /* if the attribute is indexed this will
 10    61*                                                               be the number of duplicate values, exact
 10    62*                                                               for a page_file database, an estimate for a vfile type */
 10    63     2 model_defn_order fixed bin;                           /* relative order in which attr is defined in the model */
 10    64 
 10    65 dcl  rai_ptr ptr int automatic init (null ());
 10    66 
 10    67 /* END mdbm_rm_attr_info.incl.pl1 */
 10    68 
 10    69 
      591 
      592 
 11     1 /* BEGIN mdbm_rm_domain_info.incl.pl1 -- jaw, 9/26/78 */
 11     2 
 11     3 /* WARNING
 11     4*          If the rm_domain_info structure is changed then the mrds_data_
 11     5*          item saved_res_version MUST be incremented to invalidate all
 11     6*          existing saved resultants
 11     7**/
 11     8 
 11     9 /* DESCRIPTION:
 11    10*
 11    11*   This  structure  is  allocated  in  the  mdbm_rm_db_info.incl.pl1
 11    12*   static  area,  once per attribute used in a relation in a readied
 11    13*   file. it is pointed to by the mdbm_rm_attr_info.incl.pl1, and may
 11    14*   point  to  mdbm_rm_ck_and_group.incl.pl1  if  a  "-check"  option
 11    15*   boolean expression was declared for this domain. it contains  the
 11    16*   descriptor  for  this domain data type, and other resultant model
 11    17*   information.
 11    18*
 11    19*
 11    20*   HISTORY:
 11    21*
 11    22*   81-05-06  Rickie  E.  Brinegar:  Modified  ck_proc,  encode_proc,
 11    23*   decode_proc to be entry variables instead of entry pointers. This
 11    24*   allows these programs to be written in languages other than pl1.
 11    25*
 11    26*   81-05-28 Jim Gray : removed unused procedure points,  and  unused
 11    27*   check  stack  structure  elements.  Also made the descriptors bit
 11    28*   (36) in this structure, rather than pointers to  the  descriptors
 11    29*   elsewhere.  Also  removed un-needed redundant assign_ parameters,
 11    30*   that are actually available in the descriptors.
 11    31*
 11    32*
 11    33**/
 11    34 
 11    35 dcl 1 rm_domain_info aligned based (rdi_ptr),		/* domain information */
 11    36     2 name char (32),				/* domain name */
 11    37     2 db_desc bit (36),				/*  to desc. for db. */
 11    38     2 user_desc bit (36),				/* desc for user visible data */
 11    39     2 user_bit_len fixed bin,				/* storage length of users data */
 11    40     2 ck_proc_entry entry variable,			/* to check proc. entry */
 11    41     2 encd_proc_entry entry variable,			/* to encode proc entry */
 11    42     2 decd_proc_entry entry variable,			/* to decode proc entry */
 11    43     2 ck_proc bit (1) unal,				/* Is there a check proc */
 11    44     2 encd_proc bit (1) unal,				/* Is there an encode proc */
 11    45     2 decd_proc bit (1) unal,				/* Is there a decode proc */
 11    46     2 pad bit (33) unal,
 11    47     2 next_domain_ptr ptr ;				/* to next domain, in list of all domains */
 11    48 						/* to check stack and groups */
 11    49 
 11    50 
 11    51 dcl  rdi_ptr ptr int automatic init (null ());
 11    52 
 11    53 /* END mdbm_rm_domain_info.incl.pl1 */
 11    54 
 11    55 
      593 
      594 
 12     1 /* BEGIN mdbm_rtrv_info.incl.pl1 -- jaw, 3/15/79 */
 12     2 
 12     3 /*
 12     4*   HISTORY
 12     5*
 12     6*   82-09-21 Davids: removed reference to the iocb_ind element which was the
 12     7*   index in the rm_rel_info.iocb_ptr array of the iocb to be used and added
 12     8*   the cursor_ptr element.
 12     9*   
 12    10*   82-10-1  Woodka: changed tid_array to be bit (36) aligned instead of 
 12    11*   bit (36) unaligned. 
 12    12*
 12    13*   82-10-22 Woodka : added first_seq_io bit and changed reserved to bit 32.
 12    14*
 12    15*   82-10-26 Davids: added the record_collection_cursor_ptr element. This is
 12    16*   needed because the relation manager get_tuple_by_id entry requires a 
 12    17*   record collection cursor.
 12    18*
 12    19*   83-05-03 Mike Kubicar : deleted the unused fields: thd_type, seq_io,
 12    20*   seed_id, link_io, free_array and thd_ptr.  Added the maxtids field.
 12    21*
 12    22*   83-05-31 Mike Kubicar : got rid of cursor_ptr and
 12    23*   record_collection_cursor_ptr.  Inserted the field relation_cursor_ptr.
 12    24*
 12    25**/
 12    26 
 12    27 dcl 1 rtrv_info aligned based (rti_ptr),		/* info needed to retrieve a tuple */
 12    28     2 ri_ptr ptr,					/* to rel_info */
 12    29     2 relation_cursor_ptr ptr,                              /* pointer to cursor to use */
 12    30     2 ntids fixed bin,				/* no of tuple ids in list */
 12    31     2 ctid fixed bin,				/* current position in list */
 12    32     2 maxtids fixed bin,				/* Maximum number of tids to search for */
 12    33     2 first_seq_io bit (1) unal,			/* on if first sequential i/o is to be done */
 12    34     2 reserved bit (35) unal,
 12    35     2 ta_ptr ptr;					/* to array of tuple ids */
 12    36 
 12    37 dcl  rti_ptr ptr;
 12    38 
 12    39 dcl  tid_array (ta_nids) bit (36) aligned  based (ta_ptr);	/* array of tuple ids */
 12    40 
 12    41 dcl  ta_nids fixed bin;
 12    42 dcl  ta_ptr ptr;
 12    43 
 12    44 /* END mdbm_rtrv_info.incl.pl1 */
 12    45 
      595 
      596 
 13     1 /* BEGIN INCLUDE FILE mrds_debug_names.incl.pl1     Jim Gray 8/7/79 */
 13     2 
 13     3 /* this include file associates module names with debug switches
 13     4*   that are stored in the data segment mrds_debug_
 13     5*   each module has it's own bit(9) debug switch, to define for various
 13     6*   debug actions, with new module names to be added to the end
 13     7*   of this list using the next in order array index in mrds_debug_
 13     8*   the convention for naming is db_{module's full name}
 13     9*   for the defined declaration over mrds_debug_$switch.
 13    10*   module.name array is then changed to reflect the new
 13    11*   number of modules, with the full module name added to the bottom
 13    12*   of the initialize list for the name array.
 13    13*   the module name array is used by the command level interface that sets/resets
 13    14*   the current status of the debug switches for each module.
 13    15*   the modules themselves use the db_{module name} declared variable for
 13    16*   that module to interagate the bits for proper debug action to take.
 13    17*   the definition of the meaning of the 9-bits is up to each individual module's
 13    18*   designer. */
 13    19 
 13    20 
 13    21 /*
 13    22*   HISTORY
 13    23*
 13    24*   80-11-12 Davids: added db_mus_mod_ubtup
 13    25*
 13    26*   80-11-13 Davids: added db_mu_sec_get_tuple and db_mu_sec_get_tid
 13    27*
 13    28*   80-12-15 Jim Gray :  added  mrds_dsl_set_fscope  to  display  non
 13    29*   error  info  about  being queued, and request being granted after
 13    30*   being queued.
 13    31*
 13    32*   81-01-15 Jim Gray : added  mu_concurrency_control  bit  to  allow
 13    33*   running  MR8  and  MR9 mrds against the same database at the same
 13    34*   time.
 13    35*
 13    36*   81-02-02  Jim  Gray  :  added  bit  for  mrds_rst_dmdm  to  allow
 13    37*   displaying internal tuple format bit offset, rather than the user
 13    38*   view.
 13    39*
 13    40*   81-02-06 Jim Gray : added bit for  new  mu_open_name_manager,  to
 13    41*   dump  an  element  from  the  list, when display_open_names entry
 13    42*   called with switch set.
 13    43*
 13    44*   81-05-20 Jim Gray : added bit for  mrds_dsl_where_clause  display
 13    45*   of sub_err_ messages, when cross domain compare occurs.
 13    46*
 13    47*   81-06-17 Jim Gray : added bit for mu_open_iocb_manager to display
 13    48*   iocb slot and rel name.
 13    49*
 13    50*   81-07-08 Jim Gray : added comment for bit 4 in mrds_dsl_permute
 13    51*
 13    52*   81-07-17 Jim Gray : added comment for bit 5 in mrds_dsl_permute
 13    53*
 13    54*   81-07-18 Jim Gray : added bit 1 for  mrds_dsl_gen_srch_prog  that
 13    55*   allows  key  searches, other than than specified by permute to be
 13    56*   done as comparisons instead.
 13    57*
 13    58*   81-07-22  Jim   Gray   :   added   comment   about   bit   2   in
 13    59*   mrds_dsl_gen_srch_prog
 13    60**/
 13    61 
 13    62 declare (
 13    63          db_mrds_dsl_eval_expr bit (9) unal defined (mrds_debug_$switch (1)),
 13    64          db_mrds_dsl_get_token bit (9) unal defined (mrds_debug_$switch (2)),
 13    65          db_mrds_dsl_permute bit (9) unal defined (mrds_debug_$switch (3)),
 13    66          db_mrds_dsl_optimize bit (9) unal defined (mrds_debug_$switch (4)),
 13    67          db_mrds_dsl_search bit (9) unal defined (mrds_debug_$switch (5)),
 13    68          db_mrds_dsl_translate bit (9) unal defined (mrds_debug_$switch (6)),
 13    69          db_mu_retrieve bit (9) unal defined (mrds_debug_$switch (7)),
 13    70          db_mrds_dsl_open bit (9) unal defined (mrds_debug_$switch (8)),
 13    71          db_mrds_dsl_close bit (9) unal defined (mrds_debug_$switch (9)),
 13    72          db_mrds_dsl_init_res bit (9) unal defined (mrds_debug_$switch (10)),
 13    73          db_mu_sec_init_res bit (9) unal defined (mrds_debug_$switch (11)),
 13    74          db_mus_mod_ubtup bit (9) unal defined (mrds_debug_$switch (12)),
 13    75          db_mu_sec_get_tuple bit (9) unal defined (mrds_debug_$switch (13)),
 13    76          db_mu_sec_get_tid bit (9) unal defined (mrds_debug_$switch (14)),
 13    77          db_mrds_dsl_set_fscope bit (9) unal defined (mrds_debug_$switch (15)),
 13    78          db_mu_concurrency_control bit (9) unal defined (mrds_debug_$switch (16)),
 13    79          db_mrds_rst_dmdm bit (9) unal defined (mrds_debug_$switch (17)),
 13    80          db_mu_open_name_manager bit (9) unal defined (mrds_debug_$switch (18)),
 13    81          db_mrds_dsl_where_clause bit (9) unal defined (mrds_debug_$switch (19)),
 13    82          db_mu_open_iocb_manager bit (9) unal defined (mrds_debug_$switch (20)),
 13    83          db_mrds_dsl_gen_srch_prog bit (9) unal defined (mrds_debug_$switch (21))
 13    84          ) ;
 13    85 
 13    86 /* list of known module names, with index into name array
 13    87*   the same as that into mrds_debug_$switch,
 13    88*   number is the current count of defined module names,
 13    89*   name is the modules full name. */
 13    90 
 13    91 declare 1 module options (constant) internal static,
 13    92         2 number fixed bin init (21),
 13    93         2 name char (32) dimension (21) init (
 13    94          "mrds_dsl_eval_expr",			/* 1 => display value of each expression */
 13    95          "mrds_dsl_get_token",			/* 1 => display the current token */
 13    96          "mrds_dsl_permute",				/* each 1 => lost cost path found,
 13    97*						   2 => reverse partial path
 13    98*						   3 => use range order for path
 13    99*						   4 => display access method costs
 13   100*						   5 => display details of final low cost path */
 13   101          "mrds_dsl_optimize",				/* 1 => pred tree,
 13   102*						   2 => paths to consider, 3 => calc_cost on */
 13   103          "mrds_dsl_search",				/* 1 => display each tuple located */
 13   104          "mrds_dsl_translate",			/* 1 => display the search program */
 13   105          "mu_retrieve",				/* 1 => display values compared, 2 => display tuple data */
 13   106          "mrds_dsl_open",				/* 1 => allow cleanup sub_error_ */
 13   107          "mrds_dsl_close",				/* 1 => allow cleanup sub_error_ */
 13   108          "mrds_dsl_init_res",				/* 1 => allow cleanup sub_error_ */
 13   109          "mu_sec_init_res",				/* 1 => allow cleanup sub_error_ */
 13   110          "mus_mod_ubtup",				/* 1 => consistency checking between the old
 13   111*						   and new tuple during modifies will be done */
 13   112          "mu_sec_get_tuple",				/* 1 => attribute values
 13   113*						   will be zeroed in the tuple structure
 13   114*						   is don't have read permission. */
 13   115          "mu_sec_get_tid",				/* 1 => read permission to the key
 13   116*						   is checked (if db is secured) */
 13   117          "mrds_dsl_set_fscope",			/* 1 => display being queued,
 13   118*						   and request granted from queue messages */
 13   119          "mu_concurrency_control",			/* 1 => allow both dbc and db.control segs under db
 13   120*						   so can test both MR8 and MR9 mrds
 13   121*						   against the same database at the same time */
 13   122          "mrds_rst_dmdm",				/* 1 => allow internal form of bit offset value
 13   123*						   for attributes to be displayed, rather than user view */
 13   124          "mu_open_name_manager",			/* 1 => dump mrds_open_name tree node structure,
 13   125*						   when display_open_names entry called */
 13   126          "mrds_dsl_where_clause",			/* 1 => display details of cross domain compares */
 13   127          "mu_open_iocb_manager",			/* 1 => display relation and slot getting iocb for */
 13   128          "mrds_dsl_gen_srch_prog"			/* 1 => do additional conditions as sequential, not key searches
 13   129*						   when the original access was a key,
 13   130*						   and the additional conditions can be done as key also
 13   131*						   2 => force key searches, regardless of strategy
 13   132*						   used to decide between compare or key search */
 13   133          ) ;
 13   134 
 13   135 declare  mrds_debug_$switch (1:400) bit (9) unal ext ;	/* data segment debug array */
 13   136 
 13   137 /* END INCLUDE FILE mrds_debug_names.incl.pl1 */
 13   138 
      597 
      598 
 14     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
 14     2 
 14     3 
 14     4 
 14     5 /****^  HISTORY COMMENTS:
 14     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
 14     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
 14     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
 14     9*     Nguyen. The scopes_changed flag was added to make checking for this
 14    10*     more efficient (mrds error list #137).
 14    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
 14    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
 14    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
 14    14*     care if multiple txns use the same selection_expression. (mrds #156)
 14    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
 14    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
 14    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
 14    18*                                                   END HISTORY COMMENTS */
 14    19 
 14    20 
 14    21 /* WARNING
 14    22*          If the dbcb structure is changed then the mrds_data_
 14    23*          item saved_res_version MUST be incremented to invalidate all
 14    24*          existing saved resultants
 14    25**/
 14    26 
 14    27 /* HISTORY :
 14    28*
 14    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
 14    30*   tid_list management
 14    31*
 14    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
 14    33*   phony resultant in mu_database_index, without having the area dcl
 14    34*   included.
 14    35*
 14    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
 14    37*   mrds_dsl_store
 14    38*
 14    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
 14    40*   switches
 14    41*
 14    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
 14    43*   expression,  so  that relation statistics can be updated relative
 14    44*   to number of selection expressions seem. Also  removed  init  for
 14    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
 14    46*   mrds_dsl_init_res.
 14    47*
 14    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
 14    49*
 14    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
 14    51*   for the conversion to the relation manager.
 14    52*
 14    53*   82-08-23 Davids: added the relmgr_entries and access_costs
 14    54*   substructures so that the entries and costs can change
 14    55*   depending on the type of database that is opened.
 14    56*
 14    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
 14    58*   since modify uses a different vector type (general) than does store.
 14    59*
 14    60*   82-09-20 Davids: changed names of (store modify)_vector to
 14    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
 14    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
 14    63*   which should be inited to null and will be set by mu_cursor_manager_$get
 14    64*   during the first call.
 14    65*
 14    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
 14    67*   since it deals with the pointers to the cursors and not the cursors
 14    68*   themelves and added the element cursor_storage_area_ptr which points
 14    69*   to the area where the cursors are kept.
 14    70*
 14    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
 14    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
 14    73*   anything.
 14    74*
 14    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
 14    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
 14    77*   by mrds_dsl_define_temp_rel.
 14    78*
 14    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
 14    80*   is needed by mu_store.
 14    81*
 14    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
 14    83*   bin to float bin since the values are not integers.
 14    84*
 14    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
 14    86*   sure that the dbc_ptr still points to the correct segment. Element was 
 14    87*   added to the end of the structure to allow modules that don't use
 14    88*   the element to continue to reference the dbcb structure without recompiling.
 14    89*
 14    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
 14    91*   are needed so that temp rels can be created with the same file attributes
 14    92*   as the permanent relations.
 14    93*
 14    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
 14    95*   added the resultant_in_pdir bit.
 14    96*
 14    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
 14    98*   added the res_already_made element.
 14    99*
 14   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
 14   101*
 14   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
 14   103*   one of the unused pointers.
 14   104*
 14   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
 14   106*
 14   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
 14   108*   leaving unused_ptrs(1).
 14   109*
 14   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
 14   111*   unused_ptrs (1).
 14   112*
 14   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
 14   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
 14   115*   spare ptrs, entries and reserved storages for future enhancement, since
 14   116*   we changed the saved_res_version from rslt0001 to rslt0002.
 14   117*
 14   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
 14   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
 14   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
 14   121**/
 14   122 
 14   123 
 14   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
 14   125*   that constitutes the non-secure portion of the resultant model that is
 14   126*   created during the opening of a database. it contains variables that
 14   127*   are used during the runtime access of the database, and an area
 14   128*   for evaluation of requests. it points to four other
 14   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
 14   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
 14   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
 14   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
 14   133*   used in the elimination of duplicate tuples during a retrieve.
 14   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
 14   135*   that is used when the database is using the file scope mechanism
 14   136*   for concurrency control over file readying. the segment overlayed via
 14   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
 14   138*   across database openings. the pointer to this dbcb structure is kept in a table
 14   139*   which associates database indexes(returned from a call to dsl_$open), with particular
 14   140*   opening instances of resultant models. (see mu_database_index routine) */
 14   141 
 14   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
 14   143 	     2 data	      like dbcb_data,
 14   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
 14   145 
 14   146      dcl	   dbcb_ptr	      ptr;
 14   147 
 14   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
 14   149*						   like references can avoid getting the area declaration */
 14   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
 14   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
 14   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
 14   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
 14   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
 14   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
 14   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
 14   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
 14   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
 14   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
 14   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
 14   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
 14   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
 14   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
 14   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
 14   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
 14   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
 14   167*						   for eliminating duplicate tuples. */
 14   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
 14   169*						   for eliminating duplicate tuples. */
 14   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
 14   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
 14   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
 14   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
 14   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
 14   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
 14   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
 14   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
 14   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
 14   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
 14   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
 14   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
 14   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
 14   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
 14   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
 14   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
 14   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
 14   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
 14   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
 14   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
 14   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
 14   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
 14   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
 14   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
 14   194 	     2 val_mod	      bit (1) unal,		/* for modify */
 14   195 	     2 val_del	      bit (1) unal,		/* for delete */
 14   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
 14   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
 14   198*                                                                     not imply that the database is of type page_file */
 14   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
 14   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
 14   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
 14   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
 14   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
 14   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
 14   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
 14   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
 14   207*						   inside a sequence of -another selection expression. */
 14   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
 14   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
 14   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
 14   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
 14   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
 14   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
 14   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
 14   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
 14   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
 14   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
 14   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
 14   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
 14   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
 14   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
 14   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
 14   223 	     2 relmgr_entries,			/* relation manager entries */
 14   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
 14   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
 14   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
 14   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
 14   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
 14   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
 14   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
 14   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
 14   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
 14   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
 14   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
 14   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
 14   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
 14   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
 14   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
 14   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
 14   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
 14   241 	       3 reserved_entries (5) entry (),
 14   242 	     2 access_costs,			/* access costs for permute */
 14   243 	       3 total_primary_key_cost float bin,
 14   244 	       3 access_cost      float bin,
 14   245 	       3 access_overhead  float bin,
 14   246 	       3 us_access_cost   float bin,
 14   247 	       3 os_access_cost   float bin,
 14   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
 14   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
 14   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
 14   251 
 14   252 /* END mrds_dbcb.incl.pl1 */
 14   253 
 14   254 
      599 
      600 
 15     1 /* ***********************************************************
 15     2*   *                                                         *
 15     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
 15     4*   *                                                         *
 15     5*   *********************************************************** */
 15     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
 15     7 
 15     8 /* Written by Lindsey Spratt, 04/02/82.
 15     9*Modified:
 15    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
 15    11*	  unaligned.  Changed the type number of the simple_typed_vector to
 15    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
 15    13*	  type.
 15    14**/
 15    15 
 15    16 /* format: style2,ind3 */
 15    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
 15    18 	     2 type	      fixed bin (17) unal,
 15    19 	     2 number_of_dimensions
 15    20 			      fixed bin (17) unal,
 15    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
 15    22 	       3 value_ptr	      ptr unaligned;
 15    23 
 15    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
 15    25 	     2 type	      fixed bin (17) unal,
 15    26 	     2 number_of_dimensions
 15    27 			      fixed bin (17) unal,
 15    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
 15    29 	       3 identifier	      fixed bin (17) unal,
 15    30 	       3 pad	      bit (18) unal,
 15    31 	       3 value_ptr	      ptr unal;
 15    32 
 15    33      dcl	   simple_typed_vector_ptr
 15    34 			      ptr;
 15    35      dcl	   stv_number_of_dimensions
 15    36 			      fixed bin (17);
 15    37 
 15    38      dcl	   general_typed_vector_ptr
 15    39 			      ptr;
 15    40      dcl	   gtv_number_of_dimensions
 15    41 			      fixed bin (17);
 15    42 
 15    43      dcl	   (
 15    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
 15    45 			      init (1),		/* value_ptr was aligned. */
 15    46 	   GENERAL_TYPED_VECTOR_TYPE
 15    47 			      init (2),
 15    48 	   SIMPLE_TYPED_VECTOR_TYPE
 15    49 			      init (3)
 15    50 	   )		      fixed bin (17) internal static options (constant);
 15    51 
 15    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
      601 
      602 
      603      end mu_retrieve;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1315.0  mu_retrieve.pl1                   >special_ldd>install>MR12.2-1073>mu_retrieve.pl1
486          1    02/20/85  1610.1  mrds_space_allocate.incl.pl1      >ldd>include>mrds_space_allocate.incl.pl1
488          2    02/20/85  1610.1  mrds_area_initialize.incl.pl1     >ldd>include>mrds_area_initialize.incl.pl1
577          3    03/06/85  1031.5  dm_element_id_list.incl.pl1       >ldd>include>dm_element_id_list.incl.pl1
579          4    10/14/83  1609.1  dm_id_list.incl.pl1               >ldd>include>dm_id_list.incl.pl1
581          5    10/14/83  1609.1  dm_relation_spec.incl.pl1         >ldd>include>dm_relation_spec.incl.pl1
583          6    10/14/83  1609.1  dm_specification_head.incl.pl1    >ldd>include>dm_specification_head.incl.pl1
585          7    04/18/85  1628.1  mdbm_scope_info.incl.pl1          >ldd>include>mdbm_scope_info.incl.pl1
587          8    02/05/86  1416.4  mdbm_comp_val_list.incl.pl1       >ldd>include>mdbm_comp_val_list.incl.pl1
589          9    10/14/83  1609.1  mdbm_rm_rel_info.incl.pl1         >ldd>include>mdbm_rm_rel_info.incl.pl1
591         10    10/14/83  1609.1  mdbm_rm_attr_info.incl.pl1        >ldd>include>mdbm_rm_attr_info.incl.pl1
593         11    10/14/83  1609.1  mdbm_rm_domain_info.incl.pl1      >ldd>include>mdbm_rm_domain_info.incl.pl1
595         12    10/14/83  1609.1  mdbm_rtrv_info.incl.pl1           >ldd>include>mdbm_rtrv_info.incl.pl1
597         13    10/14/83  1609.0  mrds_debug_names.incl.pl1         >ldd>include>mrds_debug_names.incl.pl1
599         14    08/01/88  1300.0  mrds_dbcb.incl.pl1                >special_ldd>install>MR12.2-1073>mrds_dbcb.incl.pl1
601         15    10/14/83  1609.1  vu_typed_vector.incl.pl1          >ldd>include>vu_typed_vector.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       constant        fixed bin(17,0)          initial dcl 6-22 ref 393
CVL_ops                         000000 constant        char(2)                  initial array packed unaligned dcl 546 ref 280 280
ELEMENT_ID_LIST_VERSION_1       000134 automatic       fixed bin(35,0)          initial dcl 3-28 set ref 3-28*
MRDS_AREA                       000234 automatic       char(8)                  initial packed unaligned dcl 2-19 in procedure
                                                                                  "mrds_area_initialize" set ref 2-19* 2-31
MRDS_AREA                       000222 automatic       char(8)                  initial packed unaligned dcl 1-25 in procedure
                                                                                  "mrds_space_allocate" set ref 1-25* 1-41
RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       constant        fixed bin(17,0)          initial dcl 6-22 ref 400
actual_allocated_size           000220 automatic       fixed bin(35,0)          dcl 1-24 set ref 1-39* 1-43 1-46 1-50 1-52
addr                                                   builtin function         dcl 536 ref 234 235
ai_ptr                                 parameter       pointer                  dcl 448 set ref 440 459 459 462 472*
alloc_value                            based           bit(36)                  array packed unaligned dcl 1-35 ref 1-43
alloc_value_ptr                 000224 automatic       pointer                  dcl 1-34 set ref 1-43* 1-44 1-48* 1-53
append_tuple              1(01)        based           bit(1)                   level 3 packed packed unaligned dcl 553 ref 375
area_id                                based           char(8)                  level 2 in structure "mrds_area" packed packed
                                                                                  unaligned dcl 2-21 in procedure
                                                                                  "mrds_area_initialize" set ref 2-31*
area_id                                based           char(8)                  level 2 in structure "mrds_area" packed packed
                                                                                  unaligned dcl 1-28 in procedure
                                                                                  "mrds_space_allocate" ref 1-41
area_ptr                               parameter       pointer                  dcl 518 set ref 31 481*
attr_ind                 21            based           fixed bin(17,0)          array level 3 dcl 8-30 set ref 237*
attr_ind2                22            based           fixed bin(17,0)          array level 3 dcl 8-30 set ref 253*
attr_index                             parameter       fixed bin(17,0)          dcl 450 ref 440 458
c_ai_ptr2                10            based           pointer                  array level 3 dcl 8-30 set ref 253*
cd                                     parameter       fixed bin(35,0)          dcl 494 ref 490 496 496 498
code                                   parameter       fixed bin(35,0)          dcl 515 set ref 31 270* 273 286 286* 303* 496* 498*
comp_val_list                          based           structure                level 1 dcl 8-30
continue_for_next_tuple         000202 automatic       bit(1)                   dcl 358 set ref 367* 368 369* 431*
ctid                      5            based           fixed bin(17,0)          level 2 dcl 12-27 set ref 389 411* 419* 419 421
current_scope_flags                    based           structure                level 1 dcl 553
current_scope_ptr               000132 automatic       pointer                  dcl 554 set ref 374* 375 375 375 375 375 375
cvl_array                              based           structure                level 1 dcl 8-64
cvl_ptr                         000152 automatic       pointer                  initial dcl 8-54 set ref 230* 232 234 235 237 237
                                                                                  237 251 253 253 253 253 267 270 280 280 8-54*
cvla_ptr                        000154 automatic       pointer                  initial dcl 8-69 set ref 205* 225 229 230 8-69*
cvla_ptr_parm                          parameter       pointer                  dcl 503 ref 31 205
data                                   based           structure                level 2 dcl 14-142
db_mu_retrieve                         defined         bit(9)                   packed unaligned dcl 13-62 ref 203 204
dbcb                                   based           structure                level 1 dcl 14-142
dbcb_data                              based           structure                level 1 unaligned dcl 14-148
dbcb_ptr                               parameter       pointer                  dcl 14-146 set ref 31 217* 227 370 371 375
dbcbptr                                parameter       pointer                  dcl 353 ref 308 404 404 425 425
decd_proc                30(02)        based           bit(1)                   level 2 packed packed unaligned dcl 11-35 ref 459
delete_tuple              0(02)        based           bit(1)                   level 3 in structure "current_scope_flags" packed
                                                                                  packed unaligned dcl 553 in procedure
                                                                                  "mu_retrieve" ref 375
delete_tuple              1(02)        based           bit(1)                   level 3 in structure "current_scope_flags" packed
                                                                                  packed unaligned dcl 553 in procedure
                                                                                  "mu_retrieve" ref 375
desc1                    17            based           bit(36)                  array level 3 dcl 8-30 set ref 234
desc2                    20            based           bit(36)                  array level 3 dcl 8-30 set ref 235
desc_ptr                               parameter       pointer                  dcl 451 set ref 440 472*
desc_ptr1                       000110 automatic       pointer                  dcl 518 set ref 234* 237* 270* 278* 279*
desc_ptr2                       000112 automatic       pointer                  dcl 518 set ref 235* 253* 270* 281* 283*
di_ptr                                 parameter       pointer                  dcl 452 in procedure "get_comparison_value" set ref
                                                                                  440 458* 472* 476* 480*
di_ptr                          000114 automatic       pointer                  dcl 518 in procedure "mu_retrieve" set ref 237* 270*
                                                                                  274* 279*
di_ptr2                         000116 automatic       pointer                  dcl 518 set ref 253* 267* 270* 274* 283*
dimension                 1            based           structure                array level 2 packed packed unaligned dcl 15-17
display_tuple_data              000124 automatic       bit(1)                   packed unaligned dcl 529 set ref 204* 294
display_values_compared         000125 automatic       bit(1)                   packed unaligned dcl 529 set ref 203* 273 274 276
                                                                                  281
dm_error_$no_tuple              000010 external static fixed bin(35,0)          dcl 555 ref 496
dm_error_$no_tuple_id           000012 external static fixed bin(35,0)          dcl 556 ref 496
domain_ptr               26            based           pointer                  level 2 dcl 10-46 ref 459 462
element_id_list                        based           structure                level 1 dcl 3-21
error_table_$noalloc            000032 external static fixed bin(35,0)          dcl 568 ref 246 261 466 474
erslt_ptr                              parameter       pointer                  dcl 449 in procedure "get_comparison_value" ref 440
                                                                                  480
erslt_ptr                12            based           pointer                  array level 3 in structure "comp_val_list" dcl 8-30
                                                                                  in procedure "mu_retrieve" set ref 237*
erslt_ptr2               14            based           pointer                  array level 3 dcl 8-30 set ref 253*
exp_ptr                                parameter       pointer                  dcl 447 in procedure "get_comparison_value" set ref
                                                                                  440 456 481*
exp_ptr                   4            based           pointer                  array level 3 in structure "comp_val_list" dcl 8-30
                                                                                  in procedure "mu_retrieve" set ref 237*
exp_ptr2                  6            based           pointer                  array level 3 dcl 8-30 set ref 253*
file_type                40            based           fixed bin(17,0)          level 2 dcl 9-119 ref 371
first_seq_io              7            based           bit(1)                   level 2 packed packed unaligned dcl 12-27 set ref
                                                                                  391 392*
found                           000126 automatic       bit(1)                   packed unaligned dcl 529 set ref 214* 215 219* 292*
                                                                                  297
get_tuple_by_id         202            based           entry variable           level 4 dcl 14-142 ref 425
get_tuple_id            212            based           entry variable           level 4 dcl 14-142 ref 404
head                                   based           structure                level 2 dcl 5-9
i                               000104 automatic       fixed bin(17,0)          dcl 512 set ref 224* 229* 230*
icode                           000203 automatic       fixed bin(35,0)          dcl 362 in procedure "get_next_tuple" set ref 404*
                                                                                  409 409* 425* 429 430* 433 433*
icode                                  parameter       fixed bin(35,0)          dcl 453 in procedure "get_comparison_value" set ref
                                                                                  440 455* 466* 472* 474 481* 483 483*
icode                           000107 automatic       fixed bin(35,0)          dcl 515 in procedure "mu_retrieve" set ref 237* 246
                                                                                  253* 261 295* 296 296*
id                        2            based           bit(36)                  array level 2 dcl 3-21 ref 421
id_list                                based           structure                level 1 dcl 4-16
id_list_ptr                     000136 automatic       pointer                  initial dcl 4-21 set ref 206* 4-21* 423 425*
id_list_ptr_parm                       parameter       pointer                  dcl 504 ref 31 206
il_number_of_ids                000140 automatic       fixed bin(17,0)          initial dcl 4-22 set ref 4-22*
ioa_                            000026 constant        entry                    external dcl 562 ref 274 276 278 280 281 297 299
iox_$user_output                000030 external static pointer                  dcl 564 set ref 295*
j                               000106 automatic       fixed bin(17,0)          dcl 512 set ref 224* 232* 234 235 237 237 237 251
                                                                                  253 253 253 253 267 270 280 280*
k                               000105 automatic       fixed bin(17,0)          dcl 512 set ref 210* 469* 469
length_free_space         3            based           fixed bin(35,0)          level 2 in structure "mrds_area" dcl 1-28
                                                                                  in procedure "mrds_space_allocate" set ref 1-46
                                                                                  1-52* 1-52
length_free_space         3            based           fixed bin(35,0)          level 2 in structure "mrds_area" dcl 2-21
                                                                                  in procedure "mrds_area_initialize" set ref 2-34*
list_ptr                  2            based           pointer                  array level 2 dcl 8-64 ref 230
match                           000127 automatic       bit(1)                   dcl 533 set ref 228* 229 231* 232 270* 292
match_ptr                 2            based           pointer                  array level 3 dcl 8-30 ref 251 267
maxtids                   6            based           fixed bin(17,0)          level 2 dcl 12-27 ref 375 397
mdb_display_data_value$ptr      000034 constant        entry                    external dcl 570 ref 279 283
mdb_display_tuple_$data         000036 constant        entry                    external dcl 572 ref 295
mod                                                    builtin function         dcl 1-26 ref 1-39
modify_attr               0(03)        based           bit(1)                   level 3 in structure "current_scope_flags" packed
                                                                                  packed unaligned dcl 553 in procedure
                                                                                  "mu_retrieve" ref 375
modify_attr               1(03)        based           bit(1)                   level 3 in structure "current_scope_flags" packed
                                                                                  packed unaligned dcl 553 in procedure
                                                                                  "mu_retrieve" ref 375
mrds_area                              based           structure                level 1 unaligned dcl 2-21 in procedure
                                                                                  "mrds_area_initialize"
mrds_area                              based           structure                level 1 unaligned dcl 1-28 in procedure
                                                                                  "mrds_space_allocate"
mrds_area_ptr                          parameter       pointer                  dcl 1-21 in procedure "mrds_space_allocate" ref 1-10
                                                                                  1-40 1-41 1-43 1-46 1-48 1-48 1-50 1-50 1-52 1-52
mrds_area_ptr                          parameter       pointer                  dcl 2-18 in procedure "mrds_area_initialize" ref
                                                                                  2-10 2-29 2-31 2-33 2-34
mrds_data_$max_safe_tids_returned_per_call
                                000014 external static fixed bin(35,0)          dcl 557 ref 375
mrds_debug_$switch              000046 external static bit(9)                   array packed unaligned dcl 13-135 ref 203 203 204
                                                                                  204
mrds_dsl_eval_expr              000024 constant        entry                    external dcl 561 ref 481
mrds_error_$inconsistent_data_length
                                000022 external static fixed bin(35,0)          dcl 560 ref 429
mrds_error_$no_tuple            000016 external static fixed bin(35,0)          dcl 558 ref 496
mrds_error_$tuple_not_found     000020 external static fixed bin(35,0)          dcl 559 set ref 397*
mu_compare_values               000040 constant        entry                    external dcl 573 ref 270
mu_display_descriptor           000042 constant        entry                    external dcl 574 ref 278 281
mu_get_data$get_data_item       000044 constant        entry                    external dcl 575 ref 472
need_to_free_user_value         000130 automatic       bit(1)                   dcl 534 set ref 236* 288
nkey_attr                24            based           fixed bin(17,0)          level 2 dcl 9-119 ref 374
nlists                                 based           fixed bin(17,0)          level 2 dcl 8-64 ref 229
non_shared_to_shared    106(23)        based           bit(1)                   level 3 packed packed unaligned dcl 14-142 set ref
                                                                                  371 375*
ntids                     4            based           fixed bin(17,0)          level 2 dcl 12-27 set ref 212 389 397 412*
null                                                   builtin function         dcl 536 in procedure "mu_retrieve" ref 225 237 237
                                                                                  251 4-21 5-50 5-50 7-59 8-54 8-69 10-65 11-51 456
                                                                                  459 465 2-29
null                                                   builtin function         dcl 1-26 in procedure "mrds_space_allocate" ref 1-40
                                                                                  1-40 1-55
num_attr                 22            based           fixed bin(17,0)          level 2 dcl 9-119 ref 374
number_of_elements        1            based           fixed bin(35,0)          level 2 dcl 3-21 set ref 402* 412
number_of_ids             1            based           fixed bin(17,0)          level 2 dcl 4-16 ref 423
nvals                                  based           fixed bin(17,0)          level 2 dcl 8-30 ref 232
offset_to_free_word       2            based           fixed bin(35,0)          level 2 in structure "mrds_area" dcl 1-28
                                                                                  in procedure "mrds_space_allocate" set ref 1-48
                                                                                  1-50* 1-50
offset_to_free_word       2            based           fixed bin(35,0)          level 2 in structure "mrds_area" dcl 2-21
                                                                                  in procedure "mrds_area_initialize" set ref 2-33*
op                       16            based           fixed bin(17,0)          array level 3 dcl 8-30 set ref 270* 280 280
p_work_area                            based           area                     dcl 1-33 ref 1-43
permits                                based           structure                level 2 dcl 553
prevents                  1            based           structure                level 2 dcl 553
ptr                                                    builtin function         dcl 1-26 ref 1-48
rai_ptr                         000160 automatic       pointer                  initial dcl 10-65 set ref 10-65*
rdi_ptr                         000162 automatic       pointer                  initial dcl 11-51 set ref 11-51*
read_attr                              based           bit(1)                   level 3 packed packed unaligned dcl 553 ref 375
relation_cursor_ptr       2            based           pointer                  level 2 dcl 12-27 set ref 404* 425*
relation_numeric_specification_ptr
                                000144 automatic       pointer                  initial dcl 5-50 set ref 5-50*
relation_search_specification          based           structure                level 1 dcl 5-9
relation_search_specification_ptr
                                000142 automatic       pointer                  initial dcl 5-50 set ref 5-50*
relmgr_entries          146            based           structure                level 3 dcl 14-142
requested_word_size                    parameter       fixed bin(35,0)          dcl 1-22 ref 1-10 1-39 1-39
retrieve_info_ptr                      parameter       pointer                  dcl 354 ref 308 371 374 375 389 389 391 392 397 397
                                                                                  402 404 404 411 412 412 419 419 421 421 425
ri_ptr                                 based           pointer                  level 2 dcl 12-27 ref 209 371 374
rm_attr_info                           based           structure                level 1 dcl 10-46
rm_domain_info                         based           structure                level 1 dcl 11-35
rm_rel_info                            based           structure                level 1 dcl 9-119
rmri_ptr                        000156 automatic       pointer                  dcl 9-156 set ref 209* 295* 481*
rss_maximum_number_of_constraints
                                000147 automatic       fixed bin(17,0)          initial dcl 5-52 set ref 5-52*
rss_number_of_and_groups        000146 automatic       fixed bin(17,0)          initial dcl 5-52 set ref 5-52*
rti_ptr                                parameter       pointer                  dcl 12-37 set ref 31 209 211 212 217*
rtrim                                                  builtin function         dcl 536 ref 280 280
rtrv_info                              based           structure                level 1 dcl 12-27
scope_flags                            based           structure                level 1 dcl 7-42
scope_flags_ptr                        based           pointer                  level 2 dcl 9-119 ref 374
scope_ptr                       000150 automatic       pointer                  initial dcl 7-59 set ref 7-59*
scopes_changed          106(24)        based           bit(1)                   level 3 packed packed unaligned dcl 14-142 ref 370
search_spec_ptr                        parameter       pointer                  dcl 355 set ref 308 393 400 404*
search_spec_ptr_parm                   parameter       pointer                  dcl 506 set ref 31 217*
select_area_ptr          36            based           pointer                  level 3 dcl 14-142 set ref 404* 425*
simple_typed_vector                    based           structure                level 1 packed packed unaligned dcl 15-17
simple_typed_vector_ptr                parameter       pointer                  dcl 356 in procedure "get_next_tuple" set ref 308
                                                                                  425*
simple_typed_vector_ptr         000170 automatic       pointer                  dcl 15-33 in procedure "mu_retrieve" set ref 207*
                                                                                  217* 295*
simple_typed_vector_ptr_parm           parameter       pointer                  dcl 505 ref 31 207
specification_head                     based           structure                level 1 unaligned dcl 6-10
substr                                                 builtin function         dcl 536 ref 203 204
sys_info$max_seg_size           000050 external static fixed bin(35,0)          dcl 2-26 ref 2-34
t_domain_ptr                    000120 automatic       pointer                  dcl 518 set ref 462* 463
ta_nids                         000164 automatic       fixed bin(17,0)          dcl 12-41 set ref 212*
ta_ptr                   10            based           pointer                  level 2 in structure "rtrv_info" dcl 12-27
                                                                                  in procedure "mu_retrieve" set ref 211 402 404*
                                                                                  412 421
ta_ptr                          000166 automatic       pointer                  dcl 12-42 in procedure "mu_retrieve" set ref 211*
tid_ptr                                parameter       pointer                  dcl 518 ref 31 217
tuple_id                               based           bit(36)                  dcl 544 in procedure "mu_retrieve" set ref 217*
tuple_id                               parameter       bit(36)                  dcl 357 in procedure "get_next_tuple" set ref 308
                                                                                  421* 425*
tuple_var_name                         parameter       char                     packed unaligned dcl 507 set ref 31 297* 299*
type                      1            based           fixed bin(17,0)          level 3 packed packed unaligned dcl 5-9 set ref 393*
                                                                                  400*
user_bit_len             12            based           fixed bin(17,0)          level 2 dcl 11-35 ref 463
user_bit_length                 000100 automatic       fixed bin(17,0)          dcl 508 set ref 288 288 463* 464 470
user_val_ptr                    000122 automatic       pointer                  dcl 518 set ref 288 464* 465 470 472* 476
val                       2            based           structure                array level 2 dcl 8-30
value_for_user                         based           bit                      packed unaligned dcl 509 set ref 288 470*
value_ptr                 1            based           pointer                  array level 3 packed packed unaligned dcl 15-17 ref
                                                                                  458
whole_stv_ptr                          parameter       pointer                  dcl 518 set ref 31 458 481*
work_area_ptr                   000102 automatic       pointer                  dcl 510 in procedure "mu_retrieve" set ref 227* 248*
                                                                                  262* 464* 472*
work_area_ptr            70            based           pointer                  level 3 in structure "dbcb" dcl 14-142 in procedure
                                                                                  "mu_retrieve" ref 227

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSOLUTE_NUMERIC_SPECIFICATION_TYPE    internal static fixed bin(17,0)          initial dcl 6-22
ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 6-22
ABSOLUTE_SEARCH_SPECIFICATION_TYPE     internal static fixed bin(17,0)          initial dcl 6-22
CVL_EQ                                 internal static fixed bin(17,0)          initial dcl 8-57
CVL_GE                                 internal static fixed bin(17,0)          initial dcl 8-57
CVL_GT                                 internal static fixed bin(17,0)          initial dcl 8-57
CVL_LE                                 internal static fixed bin(17,0)          initial dcl 8-57
CVL_LT                                 internal static fixed bin(17,0)          initial dcl 8-57
CVL_NE                                 internal static fixed bin(17,0)          initial dcl 8-57
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 15-43
ID_LIST_VERSION_1                      internal static fixed bin(17,0)          initial dcl 4-23
NUMERIC_SPECIFICATION_TYPE             internal static fixed bin(17,0)          initial dcl 6-22
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 15-43
RELATIVE_NUMERIC_SPECIFICATION_TYPE    internal static fixed bin(17,0)          initial dcl 6-22
RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 6-22
RELATIVE_SEARCH_SPECIFICATION_TYPE     internal static fixed bin(17,0)          initial dcl 6-22
SEARCH_SPECIFICATION_TYPE              internal static fixed bin(17,0)          initial dcl 6-22
SIMPLE_TYPED_VECTOR_TYPE               internal static fixed bin(17,0)          initial dcl 15-43
SPECIFICATION_VERSION_4                internal static fixed bin(35,0)          initial dcl 6-19
cvl_nvals_init                         automatic       fixed bin(17,0)          dcl 8-55
cvla_nlists_init                       automatic       fixed bin(17,0)          dcl 8-68
db_mrds_dsl_close                      defined         bit(9)                   packed unaligned dcl 13-62
db_mrds_dsl_eval_expr                  defined         bit(9)                   packed unaligned dcl 13-62
db_mrds_dsl_gen_srch_prog              defined         bit(9)                   packed unaligned dcl 13-62
db_mrds_dsl_get_token                  defined         bit(9)                   packed unaligned dcl 13-62
db_mrds_dsl_init_res                   defined         bit(9)                   packed unaligned dcl 13-62
db_mrds_dsl_open                       defined         bit(9)                   packed unaligned dcl 13-62
db_mrds_dsl_optimize                   defined         bit(9)                   packed unaligned dcl 13-62
db_mrds_dsl_permute                    defined         bit(9)                   packed unaligned dcl 13-62
db_mrds_dsl_search                     defined         bit(9)                   packed unaligned dcl 13-62
db_mrds_dsl_set_fscope                 defined         bit(9)                   packed unaligned dcl 13-62
db_mrds_dsl_translate                  defined         bit(9)                   packed unaligned dcl 13-62
db_mrds_dsl_where_clause               defined         bit(9)                   packed unaligned dcl 13-62
db_mrds_rst_dmdm                       defined         bit(9)                   packed unaligned dcl 13-62
db_mu_concurrency_control              defined         bit(9)                   packed unaligned dcl 13-62
db_mu_open_iocb_manager                defined         bit(9)                   packed unaligned dcl 13-62
db_mu_open_name_manager                defined         bit(9)                   packed unaligned dcl 13-62
db_mu_sec_get_tid                      defined         bit(9)                   packed unaligned dcl 13-62
db_mu_sec_get_tuple                    defined         bit(9)                   packed unaligned dcl 13-62
db_mu_sec_init_res                     defined         bit(9)                   packed unaligned dcl 13-62
db_mus_mod_ubtup                       defined         bit(9)                   packed unaligned dcl 13-62
eil_number_of_elements                 automatic       fixed bin(35,0)          dcl 3-27
element_id_list_ptr                    automatic       pointer                  dcl 3-26
fixed                                                  builtin function         dcl 536
general_typed_vector                   based           structure                level 1 packed packed unaligned dcl 15-24
general_typed_vector_ptr               automatic       pointer                  dcl 15-38
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 15-40
max_file_init                          automatic       fixed bin(17,0)          dcl 7-58
module                                 internal static structure                level 1 unaligned dcl 13-91
natts_init                             automatic       fixed bin(17,0)          dcl 9-157
nkey_attr_init                         automatic       fixed bin(17,0)          dcl 9-157
nvar_atts_init                         automatic       fixed bin(17,0)          dcl 9-157
rel                                                    builtin function         dcl 536
relation_numeric_specification         based           structure                level 1 dcl 5-41
scope_info                             based           structure                level 1 dcl 7-32
scope_rdy                              internal static bit(6)                   initial packed unaligned dcl 7-60
scope_rdy_array                        based           bit(1)                   array packed unaligned dcl 7-61
specification_head_ptr                 automatic       pointer                  dcl 6-18
stv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 15-35
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 566
tid_array                              based           bit(36)                  array dcl 12-39
unspec                                                 builtin function         dcl 536

NAMES DECLARED BY EXPLICIT CONTEXT.
GET_COMPARISON_VALUE            000304 constant        label                    dcl 237 ref 249 263
error                           001552 constant        entry                    internal dcl 490 ref 286 296 397 409 433 483
exit                            001020 constant        label                    dcl 305 ref 499
get_comparison_value            001254 constant        entry                    internal dcl 440 ref 237 253
get_next_tuple                  001021 constant        entry                    internal dcl 308 ref 217
mrds_area_initialize            001523 constant        entry                    internal dcl 2-10 ref 248 262
mrds_space_allocate             001432 constant        entry                    internal dcl 1-10 ref 464
mu_retrieve                     000110 constant        entry                    external dcl 31

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2072        2144    1622        2102
Length      2702    1622        52         521     247           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mu_retrieve                         286 external procedure  is an external procedure.  
get_next_tuple                          internal procedure  shares stack frame of external procedure mu_retrieve.  
get_comparison_value                    internal procedure  shares stack frame of external procedure mu_retrieve.  
mrds_space_allocate                     internal procedure  shares stack frame of external procedure mu_retrieve.  
mrds_area_initialize                    internal procedure  shares stack frame of external procedure mu_retrieve.  
error                                   internal procedure  shares stack frame of external procedure mu_retrieve.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mu_retrieve              000100 user_bit_length             mu_retrieve
                         000102 work_area_ptr               mu_retrieve
                         000104 i                           mu_retrieve
                         000105 k                           mu_retrieve
                         000106 j                           mu_retrieve
                         000107 icode                       mu_retrieve
                         000110 desc_ptr1                   mu_retrieve
                         000112 desc_ptr2                   mu_retrieve
                         000114 di_ptr                      mu_retrieve
                         000116 di_ptr2                     mu_retrieve
                         000120 t_domain_ptr                mu_retrieve
                         000122 user_val_ptr                mu_retrieve
                         000124 display_tuple_data          mu_retrieve
                         000125 display_values_compared     mu_retrieve
                         000126 found                       mu_retrieve
                         000127 match                       mu_retrieve
                         000130 need_to_free_user_value     mu_retrieve
                         000132 current_scope_ptr           mu_retrieve
                         000134 ELEMENT_ID_LIST_VERSION_1   mu_retrieve
                         000136 id_list_ptr                 mu_retrieve
                         000140 il_number_of_ids            mu_retrieve
                         000142 relation_search_specification_ptr
                                                            mu_retrieve
                         000144 relation_numeric_specification_ptr
                                                            mu_retrieve
                         000146 rss_number_of_and_groups    mu_retrieve
                         000147 rss_maximum_number_of_constraints
                                                            mu_retrieve
                         000150 scope_ptr                   mu_retrieve
                         000152 cvl_ptr                     mu_retrieve
                         000154 cvla_ptr                    mu_retrieve
                         000156 rmri_ptr                    mu_retrieve
                         000160 rai_ptr                     mu_retrieve
                         000162 rdi_ptr                     mu_retrieve
                         000164 ta_nids                     mu_retrieve
                         000166 ta_ptr                      mu_retrieve
                         000170 simple_typed_vector_ptr     mu_retrieve
                         000202 continue_for_next_tuple     get_next_tuple
                         000203 icode                       get_next_tuple
                         000220 actual_allocated_size       mrds_space_allocate
                         000222 MRDS_AREA                   mrds_space_allocate
                         000224 alloc_value_ptr             mrds_space_allocate
                         000234 MRDS_AREA                   mrds_area_initialize

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ent_var        call_ext_out_desc   call_ext_out        return_mac          mdfx1
shorten_stack       ext_entry_desc      trunc_fx2           divide_fx1          op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_                          mdb_display_data_value$ptr    mdb_display_tuple_$data       mrds_dsl_eval_expr
mu_compare_values             mu_display_descriptor         mu_get_data$get_data_item

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$no_tuple            dm_error_$no_tuple_id         error_table_$noalloc          iox_$user_output
mrds_data_$max_safe_tids_returned_per_call                  mrds_debug_$switch
mrds_error_$inconsistent_data_length                        mrds_error_$no_tuple          mrds_error_$tuple_not_found
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     31 000100    3   28 000123    4   21 000125    4   22 000127    5   50 000131    5   52 000134    7   59 000136
 8   54 000137    8   69 000140   10   65 000141   11   51 000142       203 000143       204 000150       205 000154
    206 000160       207 000163       209 000166       210 000172       211 000173       212 000176       214 000200
    215 000201       217 000204       219 000224       224 000226       225 000230       227 000234       228 000241
    229 000242       230 000254       231 000260       232 000262       234 000274       235 000300       236 000303
    237 000304       246 000333       248 000337       249 000341       251 000342       253 000352       261 000375
    262 000401       263 000403       265 000404       267 000405       270 000410       273 000440       274 000445
    276 000472       278 000512       279 000543       280 000554       281 000621       283 000655       286 000666
    288 000677       290 000706       291 000710       292 000712       294 000715       295 000717       296 000734
    297 000740       299 000770       301 001015       303 001016       305 001020       308 001021       367 001023
    368 001025       369 001030       370 001031       371 001037       374 001051       375 001062       389 001102
    391 001110       392 001113       393 001115       395 001121       397 001122       400 001134       402 001141
    404 001145       409 001167       411 001173       412 001177       419 001202       421 001205       423 001211
    425 001214       429 001236       430 001242       431 001243       432 001245       433 001246       436 001252
    438 001253       440 001254       455 001256       456 001257       458 001263       459 001274       462 001306
    463 001307       464 001311       465 001322       466 001326       467 001332       469 001333       470 001334
    472 001341       474 001363       476 001371       478 001373       480 001374       481 001377       483 001420
    484 001431    1   10 001432    1   25 001434    1   39 001436    1   40 001446    1   41 001455    1   43 001463
 1   44 001472    1   46 001475    1   48 001500    1   50 001504    1   52 001510    1   53 001516    1   55 001520
 2   10 001523    2   19 001525    2   29 001527    2   31 001533    2   33 001540    2   34 001542    2   36 001551
    490 001552       496 001554       498 001566       499 001570


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
