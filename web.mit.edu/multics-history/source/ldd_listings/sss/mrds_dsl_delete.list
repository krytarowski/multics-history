	COMPILATION LISTING OF SEGMENT mrds_dsl_delete
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 10/16/89  1243.6 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
       15*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
       16*     This entry is being made to cover the change made on 85-04-19 by Thanh
       17*     Nguyen. (see mrds #136)
       18*  2) change(87-01-22,Hergert), approve(88-05-19,MCR7903),
       19*     audit(88-05-19,Dupuis), install(88-08-01,MR12.2-1073):
       20*     For new parser, changed references of sel_ptr to select_list_ptr.
       21*  3) change(89-09-25,AWTaylor), approve(89-09-25,MCR8116),
       22*     audit(89-10-12,Hussein), install(89-10-13,MR12.3-1093):	
       23*     phx21249 - Created variable last_tuple_id to prevent redundent processing
       24*     in while loop.
       25*                                                   END HISTORY COMMENTS */
       26 
       27 
       28 mrds_dsl_delete: delete: proc;
       29 
       30 /* (database_index, selection_expression, values, code) */
       31 
       32 /* NOTES:
       33*
       34*   The purpose of this procedure is to implement the dsl_$delete function.
       35*   This procedure calls translate with the selection expression then calls search and mu_delete.
       36*
       37*   HISTORY:
       38*   Written by R. D. Lackey January, 1976
       39*
       40*   Modified for MR7.0 by JA Weeldreyer -- October, 1978.
       41*
       42*   Modified by Al Kepner, March 26, 1979, to add caller parameter to
       43*   mrds_dsl_translate.
       44*
       45*   Modified by Al Kepner, Aug  6,  1979,  to  pick  up  the  correct
       46*   var_index for the tuple being deleted.
       47*
       48*   Modified by Jim Gray - - Nov. 1979,  to  correct  calculation  of
       49*   num_args  that  will be passed to mrds_dsl_translate from nargs -
       50*   2, to nargs - 3.
       51*
       52*   Modified by Jim Gray - - Feb. 1980,  to  put  allocations  in  an
       53*   extensible, non-freeing area managed by this routine.
       54*
       55*   Modified by Jim Gray - - June 1980,  to  add  first_time_flag  to
       56*   mu_delete interface, so allocated space could be reused.
       57*
       58*   81-01-29     Jim     Gray     :     removed     references     to
       59*   mdbm_data_$current_version,  using  a  constant instead, to allow
       60*   for future db version expansion.
       61*
       62*   81-03-24 Jim Gray : added capability for user to delcare
       63*
       64*   81-03-27 Jim  Gray  :  changed  dbi  parameter  to  mu_delete  to
       65*   dbcb_ptr  as  part  of removing use of mus_ptr_man. the selection
       66*   expression either char varying or nonvarying.
       67*
       68*   81-07-07 Jim Gray : removed  reset  of  dbcb.last_store_rel_name,
       69*   since  deletes  will  have no affect on store -another info. Also
       70*   added change of statistics  update  count  by  number  of  tuples
       71*   deleted.
       72*
       73*   81-10-13 Davids: moved the code that sets the value  of  num_ptrs
       74*   to  preceed  any  reference  that  would  need  that  value, this
       75*   prevents possible subscriptrange errors if the  random  value  of
       76*   num_ptrs is small.
       77*
       78*   82-10-07 Mike Kubicar : converted to use the relation manager.  This
       79*   involved deleting the call to mu_delete (the module has been deleted)
       80*   and calling relmgr_$delete_tuples_by_id with an array of no more than
       81*   100 tuples.  Any other functions of mu_delete needed have been moved to
       82*   this routine (a few security checks).
       83*
       84*   82-12-10 Davids: Modified the declaration of num_deleted to fixed bin (35)
       85*   from fixed bin. This was needed because the declaration of the relation
       86*   manager entries in the dbcb was changed from options variable to reality. 
       87*
       88*   83-01-21 Mike Kubicar: Added transaction processing include files.
       89*
       90*   83-02-16 Davids: Modified to not loop through collecting 100 tuple ids
       91*   for tuples to be deleted when the selection expression was a -current
       92*   just to get 1 tuple id.
       93*
       94*   83-05-04 Davids: Modified so that mu_define_area is called with a name
       95*   of MRDS || dbi_pic. This will allow closes to be faster since all
       96*   temp_segments with the name MRDS || dbi_pic can be deleted/freed in 1 call.
       97*   the variable dbi_pic was created as an easy way to convert from fixed bin
       98*   to character.
       99*
      100*   83-05-31 Mike Kubicar : Update relation manager calling sequences.
      101*
      102*   83-06-20 Davids: Removed check for old version database and the call
      103*   to v1 code if it was an old version db (old version dbs can no longer
      104*   be opened)
      105*
      106*   85-01-15 Thanh Nguyen:  Added code to create a special work area using 
      107*   mu_define_area$define_spec_temp_dir_area.  For now, this work area is used
      108*   by mu_retrieve and mu_get_data to "allocate" value_for_db and value_for_user
      109*   thru function mrds_space_allocate and reinitialize the area thru subroutine
      110*   mrds_area_initialize.
      111**/
      112 
      113 /* INPUT CONDITIONS:
      114*   database_index 		is the index of the database the used wishes to delete.
      115*
      116*   selection_expression 	is the expression supplied by the user to select the tuplies to be modified.
      117*
      118*   values			are any values used by the selection expression.
      119**/
      120 
      121 /* OUTPUT CONDITIONS:
      122*   If no errors are encountered the deletion was performed.
      123*
      124*   code = 0;				If no errors are detected.
      125*
      126*   code = mrds_error_$invalid_db_index;  	If no dbcb_ptr was found for the database index.
      127*
      128*   code = mrds_error_$tuple_not_found;	If no tuples satisying the se. expr. were found.
      129*
      130*   code = something else;  			If some other error was detected;
      131*
      132*
      133*   If less then 3 arguments were passed to this procedure the
      134*   condition arg_error will be signaled.
      135**/
      136 
      137 	dbcb_ptr, area_ptr = null ();
      138 	mstxn_txn_id = "0"b;
      139 	call cu_$arg_list_ptr (al_ptr);		/* Get pointer to this proc arg list */
      140 	if al_ptr = null then signal arg_error;		/* This returns you to command level */
      141 
      142 	nargs = arg_list.arg_count / 2;		/* Get the number of arguments to this proc */
      143 	if nargs < 3 then signal arg_error;		/* This returns to command level */
      144 
      145 
      146 	call cu_$arg_ptr (nargs, cd_ptr, arg_len, icode); /* Get  pointer to callers return code */
      147 	if icode ^= 0 then signal arg_error;		/* This returns to command level */
      148 
      149 	call cu_$arg_ptr (1, dbi_ptr, arg_len, icode);	/* Get pointer to database index */
      150 	if icode ^= 0 then call error (icode);
      151 
      152 	call cu_$arg_ptr (2, se_ptr, se_len, icode);	/* Get pointer to selection expression */
      153 	if icode ^= 0 then call error (icode);
      154 
      155 	if arg_list.code = 4
      156 	then do;
      157 		num_ptrs = arg_list.arg_count;
      158 		desc_ptr = arg_list.arg_des_ptr (nargs + 2);
      159 	     end;
      160 	else do;
      161 		num_ptrs = arg_list.arg_count + 1;
      162 		desc_ptr = arg_list.arg_des_ptr (nargs + 3);
      163 	     end;
      164 	if descriptor.type = 22 then do;
      165 		se_len_ptr = addrel (se_ptr, -1);	/* get current length of varying string */
      166 		se_len = se_len_ptr -> se_len_ovrly;
      167 	     end;
      168 
      169 	appl_ptr = addr (arg_list.arg_des_ptr (3));	/* Get pointer to the beginning  */
      170 						/*   of the arg_ptr_list for translate */
      171 						/* Now get pointer to beginning of descriptor */
      172 						/*   pointer list for translate */
      173 	if arg_list.code = 4 then adpl_ptr = addr (arg_list.arg_des_ptr (nargs + 3));
      174 	else adpl_ptr = addr (arg_list.arg_des_ptr (nargs + 4));
      175 
      176 	num_args = nargs - 3;			/* Number of args passed to translate */
      177 
      178 	call mu_database_index$get_resultant_model_pointer (database_index, dbcb_ptr); /* Get the dbcb pointer */
      179 	if dbcb_ptr = null then call error (mrds_error_$invalid_db_index);
      180 
      181 	mstxn_transactions_needed = dbcb.transactions_needed;
      182 	save_adpl_ptr = adpl_ptr;
      183 	save_appl_ptr = appl_ptr;
      184 	save_num_args = num_args;
      185 	on cleanup call mstxn_cleanup;
      186 	on any_other call mstxn_any_other;
      187 
  1     1 /* ====== BEGIN INCLUDE FILE	          mrds_start_transaction.incl.pl1 =========================== */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the changes made on 85-05-06 and
  1     9*     85-04-19 by Thanh Nguyen. The dependency on dbcb.user_started_transaction
  1    10*     was removed because not all modules need the dbcb, and the
  1    11*     user_transaction_id field was added for mrds_dsl_retrieve (mrds error
  1    12*     list #136).
  1    13*                                                   END HISTORY COMMENTS */
  1    14 
  1    15 
  1    16 /*
  1    17*                    BEGIN_DESCRIPTION
  1    18*
  1    19*   A generalized routine accessed by all MRDS modules (with the temporary 
  1    20*   (perhaps) exception of restructuring modules) that must start transactions 
  1    21*   if none are present.  The intent is that it be executed as inline code.
  1    22*   The variable mstxn_transactions_needed must be set prior to entering this
  1    23*   code.  In most cases a simple assignment from dbcb_data.transactions_needed
  1    24*   will suffice.  Included are procedures called mstxn_cleanup and 
  1    25*   mstxn_any_other.  These procedures must be called by cleanup and any_other 
  1    26*   handlers in the program.  Such handlers should be established just prior to
  1    27*   the inclusion of this code and disabled just following the inclusion of
  1    28*   mrds_finish_transaction.  Directly prior to establishing the handlers
  1    29*   mstxn_txn_id must be set to "0"b.  This must be done even though this 
  1    30*   include file does the same, because this code might not have been entered 
  1    31*   yet when the handler is invoked.  Directly following this include file the 
  1    32*   contents of mstxn_code should be examined.  If zero, then either the 
  1    33*   transaction was successfully started or no transaction was required.  If the
  1    34*   mrds_finish_transaction code is referenced in general error handling 
  1    35*   situations where the possibility exists that the code in this include file 
  1    36*   has not been executed, it is necessary to initialize mstxn_txn_id to "0"b at
  1    37*   the beginning of the program.
  1    38*
  1    39*                    END_DESCRIPTION
  1    40*
  1    41*   Written 82-09-28 by Paul W. Benjamin.
  1    42*   Modified 82-12-09 by PWB to include mstxn_any_other.
  1    43*   Modified 83-01-07 by PWB to not reference the dbcb.
  1    44*   Modified 83-01-10 by PWB to add a call to continue_to_signal_ to the
  1    45*		 any_other handler in situations where the module did
  1    46*		 not start the transaction.
  1    47*   Modified 83-05-05 by PWB to abandon when abort fails.
  1    48*   Modified 83-05-18 by PWB to use mstxn_temp_code in calls to abandon and
  1    49*		 and abort.
  1    50*   Modified 83-05-19 by PWB to handle transaction_deadlock and 
  1    51*		 transaction_bj_full conditions.
  1    52*   Modified 84-02-04 by PWB to add trailing underscores to the 2 conditions
  1    53*		 and to handle transaction_lock_timeout_.
  1    54*   Modified 85-04-14 by Thanh Nguyen: Added code to set the 
  1    55*                     dbcb.user_started_transaction flag.
  1    56*   Modified 85-04-19 by Thanh Nguyen to add user_started_transaction flag.
  1    57*   Modified 85-05-06 By Thanh Nguyen to synchronize this include file in the 
  1    58*                     directory >ldd>include and >exl>mrd>i
  1    59**/
  1    60 
  1    61 dcl continue_to_signal_ entry (fixed bin(35));
  1    62 dcl dm_error_$no_current_transaction fixed bin (35) ext static;
  1    63 dcl error_table_$null_info_ptr fixed bin(35) ext static;
  1    64 dcl find_condition_info_ entry (ptr, ptr, fixed bin(35));
  1    65 dcl mstxn_code fixed bin (35);
  1    66 dcl mstxn_retries fixed;
  1    67 dcl mstxn_temp_code fixed bin (35);
  1    68 dcl mstxn_transactions_needed bit (1) aligned;
  1    69 dcl user_started_transaction bit (1) aligned;
  1    70 dcl mstxn_txn_id bit (36) aligned;
  1    71 dcl user_transaction_id bit (36) aligned;
  1    72 dcl transaction_manager_$abandon_txn entry (bit (36) aligned, fixed bin (35));
  1    73 dcl transaction_manager_$abort_txn entry (bit (36) aligned, fixed bin (35));
  1    74 dcl transaction_manager_$begin_txn entry (fixed bin, fixed bin (35), bit (36) aligned, fixed bin (35));
  1    75 dcl transaction_manager_$get_current_txn_id entry (bit (36) aligned, fixed bin (35));
  1    76 dcl transaction_manager_$handle_conditions entry ();
  1    77 dcl 1 mstxn_condition_info like condition_info;
  1    78 
  2     1 /*  START OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*Designed by Matthew C. Pierret, 01/26/82.
  2     6*Coded by Jeffrey D. Ives, 04/30/82.
  2     7*Modified:
  2     8*10/18/82 by Steve Herbst: Names changed.
  2     9*01/19/83 by Steve Herbst: Added (LOWEST HIGHEST)_MODE.
  2    10**/
  2    11 
  2    12 dcl (LOWEST_MODE init (1),
  2    13      HIGHEST_MODE init (8)) fixed bin int static options (constant);
  2    14 
  2    15      dcl	   TM_NORMAL_MODE	      fixed bin static options (constant) init (1);
  2    16      dcl	   TM_STATISTICAL_MODE   fixed bin static options (constant) init (2);
  2    17      dcl	   TM_READ_ONLY_MODE     fixed bin static options (constant) init (3);
  2    18      dcl	   TM_NEVER_WRITE_MODE   fixed bin static options (constant) init (4);
  2    19      dcl	   TM_TEST_NORMAL_MODE   fixed bin static options (constant) init (5);
  2    20      dcl	   TM_TEST_STATISTICAL_MODE fixed bin static options (constant) init (6);
  2    21      dcl	   TM_TEST_READ_ONLY_MODE fixed bin static options (constant) init (7);
  2    22      dcl	   TM_TEST_NEVER_WRITE_MODE fixed bin static options (constant) init (8);
  2    23 
  2    24 /*  END OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    79 

  1    80 
  3     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  3     2 
  3     3 /* Structure for find_condition_info_.
  3     4*
  3     5*   Written 1-Mar-79 by M. N. Davidoff.
  3     6**/
  3     7 
  3     8 /* automatic */
  3     9 
  3    10      declare condition_info_ptr     pointer;
  3    11 
  3    12 /* based */
  3    13 
  3    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  3    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  3    16 	     2 version	      fixed binary,		/* Must be 1 */
  3    17 	     2 condition_name     char (32) varying,	/* name of condition */
  3    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  3    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  3    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  3    21 	     2 flags	      unaligned,
  3    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  3    23 	       3 pad1	      bit (35),
  3    24 	     2 pad2	      bit (36),
  3    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  3    26 	     2 pad3	      (4) bit (36);
  3    27 
  3    28 /* internal static */
  3    29 
  3    30      declare condition_info_version_1
  3    31 			      fixed binary internal static options (constant) initial (1);
  3    32 
  3    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
  1    81 
  1    82 
  1    83 	mstxn_code = 0;
  1    84 	mstxn_txn_id = "0"b;
  1    85 	
  1    86 	if ^mstxn_transactions_needed			/* only need transactions */
  1    87 	     then goto mstxn_exit;			/* for protected page files */
  1    88 	mstxn_retries = 0;
  1    89 	call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
  1    90 	if mstxn_code ^= dm_error_$no_current_transaction	/* and if none already in progress */
  1    91 	     then do;				
  1    92 	     user_started_transaction = "1"b;
  1    93 	     user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1    94 	     mstxn_txn_id = "0"b;			/* you didn't start it, it's none of your business */
  1    95 	     goto mstxn_exit;	
  1    96 	end;
  1    97 
  1    98 	user_started_transaction = "0"b;
  1    99 	call transaction_manager_$begin_txn (TM_NORMAL_MODE, 0, mstxn_txn_id, mstxn_code);
  1   100 	user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1   101 
  1   102 mstxn_cleanup:
  1   103 proc;
  1   104 
  1   105 /*  This procedure MUST be called by a cleanup handler. */
  1   106 
  1   107           if mstxn_txn_id ^= "0"b
  1   108           then do;
  1   109 	     call transaction_manager_$abort_txn (mstxn_txn_id, mstxn_temp_code);
  1   110 	     if mstxn_temp_code ^= 0
  1   111 		then call transaction_manager_$abandon_txn (mstxn_txn_id, mstxn_temp_code);
  1   112 	end;
  1   113 	
  1   114      end mstxn_cleanup;
  1   115 
  1   116 mstxn_any_other:
  1   117 proc;
  1   118 
  1   119 /*  This procedure MUST be called by an any_other handler. */
  1   120 
  1   121           if mstxn_txn_id ^= "0"b
  1   122           then do;
  1   123 	     call find_condition_info_ (null (), addr(mstxn_condition_info), mstxn_temp_code);
  1   124 	     if mstxn_condition_info.condition_name = "transaction_deadlock_"
  1   125 		then do;
  1   126 		mftxn_code = dm_error_$lock_deadlock;
  1   127 		goto mftxn_check_code;
  1   128 	     end;
  1   129 	     else if mstxn_condition_info.condition_name = "transaction_bj_full_"
  1   130 		| mstxn_condition_info.condition_name = "transaction_lock_timeout_"
  1   131 		then do;
  1   132 		mftxn_code = dm_error_$bj_journal_full;
  1   133 		goto mftxn_check_code;
  1   134 	     end;
  1   135 	     else call transaction_manager_$handle_conditions;
  1   136 	end;
  1   137 	else call continue_to_signal_ (mstxn_code);	/* code returned will always be zero */
  1   138      end mstxn_any_other;
  1   139      
  1   140 mstxn_exit:
  1   141      
  1   142 /* ------ END INCLUDE FILE	          mrds_start_transaction.incl.pl1 --------------------------- */
      188 
      189 	if mstxn_code ^= 0
      190 	then call error (mstxn_code);
      191 
      192 	dbcb.user_started_transaction = user_started_transaction;
      193 	dbi_pic = dbcb.dbi;
      194 	call mu_define_area$define_temp_dir_area (dbcb.delete_area_ptr, database_index, (sys_info$max_seg_size), "MRDS" || dbi_pic,
      195 	     "0"b /* not extensible */, "1"b /* no freeing */, "0"b, "0"b /* no zeroing */, icode);
      196 	if icode ^= 0 then call error (icode);
      197 	area_ptr = dbcb.delete_area_ptr;
      198 						/* Create a work area for mu_retrieve to allocate the value_for_user. */
      199 	call mu_define_area$define_spec_temp_dir_area (dbcb.work_area_ptr, database_index, "MRDS" || dbi_pic, icode);
      200 	if icode ^= 0 then call error (icode);
      201 
      202 	call mrds_dsl_translate (dbcb_ptr, area_ptr, mrds_data_$caller_delete,
      203 	     se_ptr, se_len, appl_ptr, adpl_ptr, num_args, icode);
      204 	if icode ^= 0 then call error (icode);
      205 	if ^dbcb.val_del then call error (mrds_error_$inval_del_expr);
      206 
      207 	ti_ptr = dbcb.ti_ptr;
      208 	range_ptr = dbcb.range_ptr;
      209 	if dbcb.current_flag then select_list_ptr = dbcb.current_ptr;
      210 	else select_list_ptr = dbcb.select_ptr;
      211 
      212 	call mrds_dsl_search (dbcb_ptr, area_ptr, icode); /* look for first tuple */
      213 	if icode ^= 0 then call error (icode);
      214 
      215 	vi = select_list.item (1).var_index;		/* var_index for tuples to be deleted. */
      216 	ntuples_deleted = 0;
      217 	first_time_flag = "1"b;
      218 	rmri_ptr = range.tup_var.ri_ptr (vi);
      219 
      220 /* Do some checking to make sure we have the correct permissions */
      221 
      222 	if rm_rel_info.ready_mode ^= SCOPE_UPDATE
      223 	then call error (mrds_error_$inc_ready_mode);
      224 	if ^rm_rel_info.delete
      225 	then call error (mrds_error_$view_prevent);
      226 	if rm_rel_info.mdbm_secured & ^rm_rel_info.delete_tuple_perm
      227 	then call error (mrds_error_$inc_rel_acc);
      228 
      229 
      230 /* So do the delete */
      231 
      232 	call mu_cursor_manager_$get (database_index, rmri_ptr, 0,
      233 	     rm_rel_info.rel_id, dbcb.relmgr_entries.create_cursor,
      234 	     dbcb.relmgr_entries.open, dbcb.cursor_ptrs_storage_ptr,
      235 	     dbcb.cursor_storage_area_ptr, cursor_ptr, icode);
      236 	if icode ^= 0
      237 	then call error (icode);
      238 	eil_number_of_elements = MAX_TUPLES_PER_CALL;
      239 	allocate element_id_list in (work_area) set (element_id_list_ptr);
      240 	element_id_list.version = ELEMENT_ID_LIST_VERSION_1;
      241 	element_id_list.number_of_elements = 0;
      242 
      243 /* phx21249, AWTaylor. Init last_tuple_id */
      244 
      245 	last_tuple_id = "0"b;
      246 
      247 	do while (icode = 0);
      248 	     if dbcb.current_flag
      249 	     then do;
      250 		     element_id_list.number_of_elements = 1;
      251 		     element_id_list.id (element_id_list.number_of_elements)
      252 			= tuple_info.tuple.tuple_id (vi);
      253 		     icode = mrds_error_$tuple_not_found;
      254 		end;
      255 	     else do;
      256 		     do while ((icode = 0)
      257 			& (element_id_list.number_of_elements
      258 			< MAX_TUPLES_PER_CALL));
      259 
      260 /* phx21249, AWTaylor. Added a check to skip over redundant tuples */
      261 
      262 			if ((element_id_list.number_of_elements = 0) |
      263 			     (tuple_info.tuple_id(vi) ^= last_tuple_id)) then do;
      264 			     element_id_list.number_of_elements
      265 			     = element_id_list.number_of_elements + 1;
      266 			     element_id_list.id (element_id_list.number_of_elements)
      267 			     = tuple_info.tuple.tuple_id (vi);
      268 			end;
      269 			last_tuple_id = tuple_info.tuple.tuple_id(vi);
      270 			call mrds_dsl_search (dbcb_ptr, area_ptr, icode);
      271 		     end;
      272 		end;
      273 	     if (icode ^= 0) & (icode ^= mrds_error_$tuple_not_found)
      274 	     then call error (icode);
      275 	     num_deleted = 0;
      276 	     if element_id_list.number_of_elements > 0 then do;
      277 		     save_icode = icode;		/* Remember code from search */
      278 		     call dbcb.relmgr_entries.delete_tuples_by_id (
      279 			cursor_ptr, element_id_list_ptr, num_deleted, icode);
      280 		     if icode ^= 0
      281 		     then call error (icode);
      282 		     icode = save_icode;
      283 		end;
      284 	     ntuples_deleted = ntuples_deleted + num_deleted;
      285 	     element_id_list.number_of_elements = 0;
      286 	end;
      287 
      288 	if rm_rel_info.last_statistics_update_count ^= 0 & /* 0 => not stats got yet */
      289 	     rm_rel_info.last_statistics_update_count <= mrds_data_$statistics_update_count_interval then do;
      290 		rm_rel_info.last_statistics_update_count =
      291 		     rm_rel_info.last_statistics_update_count + ntuples_deleted;
      292 	     end;
      293 
      294 
      295 	if icode ^= mrds_error_$tuple_not_found then call error (icode);
      296 
      297 	code = 0;
      298 
      299 exit:
      300 
      301 	if code = mrds_error_$tuple_not_found
      302 	then mftxn_code = 0;
      303 	else mftxn_code = code;
  4     1 /* ====== BEGIN INCLUDE FILE           mrds_finish_transaction.incl.pl1 =========================== */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  4     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  4     8*     This entry is being made to cover the change made on 85-05-06 by Thanh
  4     9*     Nguyen. The code now checks a local flag. (mrds error list #136).
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /*
  4    14*                    BEGIN_DESCRIPTION
  4    15*
  4    16*   A generalized routine accessed by all MRDS modules that begin and commit 
  4    17*   transactions.  The intent is that it be executed as inline code. It is 
  4    18*   assumed that mrds_start_transaction was executed previously in the 
  4    19*   procedure.  Prior to this include file the program should assign the value 
  4    20*   of its local error code to mftxn_code.  The program utilizing this
  4    21*   include file must supply a function labeled should_rollback that returns
  4    22*   bit (1).  This routine should examine the error code mftxn_code and whether
  4    23*   the transaction should be aborted or rolled back.  "0"b means abort and "1"b
  4    24*   means rollback.  This procedure may choose to simply return "0"b as it 
  4    25*   appears that MRDS will generally NOT rollback transactions.  This routine
  4    26*   does rollback and restart if the before journal is full but only attempts it
  4    27*   once.  A procedure labelled restore_significant_data must also be supplied, 
  4    28*   where any data that was saved prior to the transaction is restored.  A 
  4    29*   procedure consisting solely of a return statement can be supplied if 
  4    30*   necessary.  After execution of this include file, mftxn_code must be
  4    31*   examined.  If it was 0 before entering the code and is non-zero afterward,
  4    32*   then the commit has failed.  Otherwise it will be unchanged.
  4    33*
  4    34*                    END_DESCRIPTION
  4    35*
  4    36*   Written 82-09-30 by Paul W. Benjamin.
  4    37*   Modified 83-01-13 by PWB to add retry on deadlocks and to return a non-zero 
  4    38*                     error code only when the transaction is in an error state.
  4    39*   Modified 83-02-04 by PWB to reset transaction id to 0 upon completion.
  4    40*   Modified 83-05-05 by PWB to abort when rollback fails, abandon when abort
  4    41*		 fails, and to abort rather than rollback when bj is full.
  4    42*   Modified 83-05-18 by PWB to use mftxn_temp_code in calls to abandon, abort
  4    43*		 and rollback.
  4    44*   Modified 83-05-19 by PWB to add mftxn_check_code label.  It is transferred
  4    45*		 to by the mstxn_any_other procedure.
  4    46*   Modified 85-04-14 by Thanh Nguyen not to commit the transaction in case of
  4    47*                     the user already started his own transaction.
  4    48*   Modified 85-05-06 by Thanh Nguyen to synchronize this include file between
  4    49*                     the directory >ldd>include and >exl>mrd>i.
  4    50**/
  4    51 
  4    52 dcl dm_error_$bj_journal_full fixed bin(35) ext static;
  4    53 dcl dm_error_$lock_deadlock fixed bin(35) ext static;
  4    54 dcl mftxn_code fixed bin (35);
  4    55 dcl mftxn_temp_code fixed bin (35);
  4    56 dcl transaction_manager_$commit_txn entry (bit (36) aligned, fixed bin (35));
  4    57 dcl transaction_manager_$rollback_txn entry (bit (36) aligned, fixed bin (17), fixed bin (35));
  4    58 	
  4    59 
  4    60 	if mstxn_txn_id = "0"b | user_started_transaction = "1"b	/* No transaction or we did not started it */
  4    61 	     then do;
  4    62 	     mftxn_code = 0;
  4    63 	     goto mftxn_exit;
  4    64 	end;
  4    65 mftxn_check_code:
  4    66 	if mftxn_code = 0
  4    67 	     then do;
  4    68 	     call transaction_manager_$commit_txn (mstxn_txn_id, mftxn_code);
  4    69 	     if mftxn_code ^= 0
  4    70 		then do;
  4    71 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    72 		if mftxn_temp_code ^= 0
  4    73 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    74 	     end;
  4    75 	end;
  4    76 	else do;
  4    77 	     call restore_significant_data;
  4    78 	     if mftxn_code = dm_error_$lock_deadlock	/* retry just once if deadlock */
  4    79 		& mstxn_retries < 1		
  4    80 		then do;
  4    81 		     mstxn_retries = mstxn_retries + 1;
  4    82 		     call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    83 		     if mftxn_temp_code ^= 0
  4    84 			then do;
  4    85 			call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    86 			if mftxn_temp_code ^= 0
  4    87 			     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    88 		     end;
  4    89 		     else do;
  4    90 			mstxn_code = 0;
  4    91 			goto mstxn_exit;		/* go back and try again */
  4    92 		     end;
  4    93 		end;
  4    94 	     else if should_rollback ()		/* let the program decide */
  4    95 		then do;
  4    96 		call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    97 		if mftxn_temp_code ^= 0
  4    98 		     then do;
  4    99 		     call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   100 		     if mftxn_temp_code ^= 0
  4   101 			then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   102 		end;
  4   103 		else do;
  4   104 		     mstxn_code = 0;
  4   105 		     goto mstxn_exit;		/* go back and try again */
  4   106 		end;
  4   107 	     end;
  4   108 	     else do;
  4   109 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   110 		if mftxn_temp_code ^= 0
  4   111 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   112 	     end;
  4   113 	end;
  4   114 	mstxn_txn_id = "0"b;			/* should never be nonzero unless there is a txn */
  4   115 mftxn_exit:
  4   116      
  4   117 /* ------ END INCLUDE FILE	          mrds_finish_transaction.incl.pl1 --------------------------- */
      304 
      305 	if mftxn_code ^= 0
      306 	then code = mftxn_code;
      307 
      308 	if dbcb_ptr = null () then ;
      309 	else if dbcb.delete_area_ptr ^= null () then
      310 	     call mu_release_area (dbcb.delete_area_ptr);
      311 
      312 	return;					/* Return to the caller with a code */
      313 
      314 error: proc (cd);					/* Internal error  procedure */
      315 
      316 	dcl     cd		 fixed bin (35);
      317 
      318 	code = cd;				/* Return the error code to caller */
      319 	go to exit;
      320 
      321      end error;
      322 
      323 
      324 /**********
      325**
      326**  These routines are used by the transaction processing include files.
      327**  Restore_significant_data restores any data needed by delete to restart,
      328**  in case a rollback should occur.  Should_rollback decides if a rollback
      329**  is appropriate.  Right now, it never is.
      330**
      331***********/
      332 
      333 restore_significant_data:
      334      proc;
      335 	adpl_ptr = save_adpl_ptr;
      336 	appl_ptr = save_appl_ptr;
      337 	num_args = save_num_args;
      338 	code = 0;
      339      end restore_significant_data;
      340 
      341 should_rollback:
      342      proc returns (bit (1));
      343 	return ("0"b);
      344 						/* MRDS does not currently rollback transactions */
      345      end should_rollback;
      346 
  5     1 /* BEGIN INCLUDE FILE  - dm_element_id_list.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*          The element_id_list structure contains an array of element 
  5     5*     identifiers.  These identifiers are used as tuple, record or 
  5     6*     element identifiers.  This structure is used across the relation_manager_,
  5     7*     record_manager_ and index_manager_ interfaces.  At some time the 
  5     8*     version should be changed to be char(8)aligned, when such a conversion
  5     9*     can be coordinated with the other structures used at these interfaces.
  5    10**/
  5    11 
  5    12 /* HISTORY:
  5    13*Written by Matthew Pierret, 06/06/82.
  5    14*Modified:
  5    15*12/16/82 by Roger Lackey:  Changed number_of_elements to fixed bin (35).
  5    16*            Did not change version.
  5    17*02/11/85 by Matthew Pierret:  Added DESCRIPTION, Written by.
  5    18**/
  5    19 
  5    20 /* format: style2,ind3 */
  5    21      dcl	   1 element_id_list      aligned based (element_id_list_ptr),
  5    22 	     2 version	      fixed bin (35),
  5    23 	     2 number_of_elements fixed bin (35),
  5    24 	     2 id		      (eil_number_of_elements refer (element_id_list.number_of_elements)) bit (36) aligned;
  5    25 
  5    26      dcl	   element_id_list_ptr    ptr;
  5    27      dcl	   eil_number_of_elements fixed bin (35);
  5    28      dcl	   ELEMENT_ID_LIST_VERSION_1
  5    29 			      init (1) fixed bin (35);
  5    30 
  5    31 
  5    32 /* END INCLUDE FILE  - dm_element_id_list.incl.pl1 */
      347 
      348 
  6     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  6     2 
  6     3 
  6     4 
  6     5 /****^  HISTORY COMMENTS:
  6     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  6     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  6     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  6     9*     Nguyen. The scopes_changed flag was added to make checking for this
  6    10*     more efficient (mrds error list #137).
  6    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  6    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  6    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  6    14*     care if multiple txns use the same selection_expression. (mrds #156)
  6    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  6    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  6    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  6    18*                                                   END HISTORY COMMENTS */
  6    19 
  6    20 
  6    21 /* WARNING
  6    22*          If the dbcb structure is changed then the mrds_data_
  6    23*          item saved_res_version MUST be incremented to invalidate all
  6    24*          existing saved resultants
  6    25**/
  6    26 
  6    27 /* HISTORY :
  6    28*
  6    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  6    30*   tid_list management
  6    31*
  6    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  6    33*   phony resultant in mu_database_index, without having the area dcl
  6    34*   included.
  6    35*
  6    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  6    37*   mrds_dsl_store
  6    38*
  6    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  6    40*   switches
  6    41*
  6    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  6    43*   expression,  so  that relation statistics can be updated relative
  6    44*   to number of selection expressions seem. Also  removed  init  for
  6    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  6    46*   mrds_dsl_init_res.
  6    47*
  6    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  6    49*
  6    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  6    51*   for the conversion to the relation manager.
  6    52*
  6    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  6    54*   substructures so that the entries and costs can change
  6    55*   depending on the type of database that is opened.
  6    56*
  6    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  6    58*   since modify uses a different vector type (general) than does store.
  6    59*
  6    60*   82-09-20 Davids: changed names of (store modify)_vector to
  6    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  6    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  6    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  6    64*   during the first call.
  6    65*
  6    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  6    67*   since it deals with the pointers to the cursors and not the cursors
  6    68*   themelves and added the element cursor_storage_area_ptr which points
  6    69*   to the area where the cursors are kept.
  6    70*
  6    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  6    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  6    73*   anything.
  6    74*
  6    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  6    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  6    77*   by mrds_dsl_define_temp_rel.
  6    78*
  6    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  6    80*   is needed by mu_store.
  6    81*
  6    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  6    83*   bin to float bin since the values are not integers.
  6    84*
  6    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  6    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  6    87*   added to the end of the structure to allow modules that don't use
  6    88*   the element to continue to reference the dbcb structure without recompiling.
  6    89*
  6    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  6    91*   are needed so that temp rels can be created with the same file attributes
  6    92*   as the permanent relations.
  6    93*
  6    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  6    95*   added the resultant_in_pdir bit.
  6    96*
  6    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  6    98*   added the res_already_made element.
  6    99*
  6   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  6   101*
  6   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  6   103*   one of the unused pointers.
  6   104*
  6   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  6   106*
  6   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  6   108*   leaving unused_ptrs(1).
  6   109*
  6   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  6   111*   unused_ptrs (1).
  6   112*
  6   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  6   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  6   115*   spare ptrs, entries and reserved storages for future enhancement, since
  6   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  6   117*
  6   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  6   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  6   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  6   121**/
  6   122 
  6   123 
  6   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  6   125*   that constitutes the non-secure portion of the resultant model that is
  6   126*   created during the opening of a database. it contains variables that
  6   127*   are used during the runtime access of the database, and an area
  6   128*   for evaluation of requests. it points to four other
  6   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  6   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  6   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  6   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  6   133*   used in the elimination of duplicate tuples during a retrieve.
  6   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  6   135*   that is used when the database is using the file scope mechanism
  6   136*   for concurrency control over file readying. the segment overlayed via
  6   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  6   138*   across database openings. the pointer to this dbcb structure is kept in a table
  6   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  6   140*   opening instances of resultant models. (see mu_database_index routine) */
  6   141 
  6   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  6   143 	     2 data	      like dbcb_data,
  6   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  6   145 
  6   146      dcl	   dbcb_ptr	      ptr;
  6   147 
  6   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  6   149*						   like references can avoid getting the area declaration */
  6   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  6   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  6   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  6   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  6   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  6   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  6   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  6   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  6   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  6   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  6   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  6   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  6   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  6   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  6   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  6   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  6   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  6   167*						   for eliminating duplicate tuples. */
  6   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  6   169*						   for eliminating duplicate tuples. */
  6   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  6   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  6   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  6   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  6   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  6   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  6   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  6   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  6   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  6   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  6   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  6   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  6   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  6   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  6   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  6   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  6   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  6   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  6   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  6   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  6   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  6   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  6   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  6   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  6   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  6   195 	     2 val_del	      bit (1) unal,		/* for delete */
  6   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  6   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  6   198*                                                                     not imply that the database is of type page_file */
  6   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  6   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  6   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  6   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  6   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  6   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  6   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  6   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  6   207*						   inside a sequence of -another selection expression. */
  6   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  6   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  6   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  6   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  6   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  6   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  6   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  6   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  6   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  6   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  6   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  6   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  6   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  6   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  6   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  6   223 	     2 relmgr_entries,			/* relation manager entries */
  6   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  6   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  6   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  6   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  6   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  6   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  6   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  6   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  6   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  6   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  6   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  6   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  6   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  6   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  6   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  6   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  6   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  6   241 	       3 reserved_entries (5) entry (),
  6   242 	     2 access_costs,			/* access costs for permute */
  6   243 	       3 total_primary_key_cost float bin,
  6   244 	       3 access_cost      float bin,
  6   245 	       3 access_overhead  float bin,
  6   246 	       3 us_access_cost   float bin,
  6   247 	       3 os_access_cost   float bin,
  6   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  6   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  6   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  6   251 
  6   252 /* END mrds_dbcb.incl.pl1 */
  6   253 
  6   254 
      349 
      350 
  7     1 /* BEGIN mdbm_rm_rel_info.incl.pl1 -- jaw, 11/16/78 */
  7     2 
  7     3 /* WARNING
  7     4*          If the rm_rel_info structure is changed then the mrds_data_
  7     5*          item saved_res_version MUST be incremented to invalidate all
  7     6*          existing saved resultants
  7     7**/
  7     8 
  7     9 /* HISTORY:
  7    10*
  7    11*   Modified by Jim Gray - - May 1980, to  include  model  number  of
  7    12*   attributes,   and   varying  attributes,  so  that  partial  view
  7    13*   submodels will have the  info  needed  to  properly  set  up  the
  7    14*   varying length array headers in the tuple structure.
  7    15*
  7    16*   Modified  by  Jim  Gray  -  -  80-11-06,  to  rename   r_perm   =
  7    17*   status_perm,     s_perm    =    append_tuple_perm,    d_perm    =
  7    18*   delete_tuple_perm, and make m_perm = unused_perm.
  7    19*
  7    20*   81-01-23 Jim Gray : added bit to indicate whether the last  model
  7    21*   view attribute was varying character or bit, since a partial view
  7    22*   submodel will not have this information in the resultant, and  it
  7    23*   is  needed for determining the new tuple length in mus_mod_ubtup,
  7    24*   since with exact length storage  of  varying  length  attributes,
  7    25*   each  tuple  can  be  a  different  length,  which is can only be
  7    26*   determined by examining the tuple itself.
  7    27*
  7    28*   81-01-29 Jim Gray : added curent  tuple  count,  to  provide  for
  7    29*   interface  to  allow  temp  rel  population  to  be known, and to
  7    30*   provide a more efficient means of finding an approx. current perm
  7    31*   relation population.
  7    32*
  7    33*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  7    34*   blocked  files, foreign keys, and ids procedures. Also set number
  7    35*   of files per rel to a constant of 1.
  7    36*
  7    37*   81-05-28 Jim Gray : combined data  from  rm_file_info  into  this
  7    38*   structure so that only one structure per relation is needed.
  7    39*
  7    40*   81-07-02 Jim Gray : added total_key and dup_key vfile  statistics
  7    41*   counts.   Also  added  number  of  operations  count  since  last
  7    42*   statistics update, and a time  since  the  statistics  were  last
  7    43*   updated.
  7    44*
  7    45*   81-07-06 Jim Gray :  added  a  per  selection  expression  update
  7    46*   identifier so that small relations could be updated on a per S.E.
  7    47*   basis
  7    48*
  7    49*   82-04-21 R. Lackey : Added number_selected (ri_niocbs_init refer (rm_rel_info.niocbs)) fixed bin (35)
  7    50*   to end of structure   TR 12205 (Suggestion).
  7    51*   
  7    52*   82-08-19 D. Woodka :  Removed  rm_rel_info.max_data_len  field for
  7    53*   the DMS conversion. 
  7    54*
  7    55*   82-08-30 Davids: added the opening_id element and removed the iocb
  7    56*   array and the niocb element for DMS conversion. Also removed the
  7    57*   number_selected array (and ri_niocbs_init) since subsets are not
  7    58*   going to be used.
  7    59*
  7    60*   82-09-20 Mike Kubicar : changed rm_rel_info.rel_id to bit (36) aligned
  7    61*   so that it can be used with relation manager.  Also added
  7    62*   rm_rel_info.primary_key_index_id for relation manager.
  7    63*
  7    64*   82-09-22 Mike Kubicar : Removed the, now useless, fields var_attr_ptrs,
  7    65*   nvar_atts, model_nvar_atts.
  7    66*
  7    67*   82-09-24 Davids: Removed current_key_count and current_dup_key_count
  7    68*   since the duplicate key count for each secondary index is now being
  7    69*   kept in the attr_info structure and key_count was only needed to
  7    70*   help in calculating the average selectivity of each index which
  7    71*   can now be gotten directly from each index's dup key count. Also
  7    72*   removed the file_id element since it is no longer needed for
  7    73*   anything.
  7    74*
  7    75*   82-09-27 Mike Kubicar : removed file_id_len for the same reason file_id
  7    76*   was removed.
  7    77*
  7    78*   82-11-05 Mike Kubicar : added a pointer to an id_list structure to be
  7    79*   used when retrieving tuples from this relation.
  7    80*
  7    81*   83-04-06 Davids: Added the scope_flags_ptr which points to the scope_flags structure
  7    82*   for the relation. Note that this structure is part of the resultant NOT
  7    83*   part of the db.control structure. The scopes are duplicated in the resultant
  7    84*   to reduce contention for the db.control structure. Note also that the pointer
  7    85*   will always point to a scope_flags structure even if no scopes have been
  7    86*   set on the relation, the structure is allocated when the db is opened.
  7    87**/
  7    88 
  7    89 
  7    90 /* DESCRIPTION:
  7    91*
  7    92*   This structure is allocated in the area part of the structure  in
  7    93*   mdbm_rm_db_info.incl.pl1  as  part of the resultant model created
  7    94*   at open  time  for  a  database.  There  will  be  one  of  these
  7    95*   rm_rel_info   structures  for  each  relation  appearing  in  the
  7    96*   database view (there may be less than the total in  the  database
  7    97*   for  a  submodel  openings).  There  will  also  be  one for each
  7    98*   temporary relation currently defined for that opening.
  7    99*
  7   100*   The structure in mdbm_rm_rel_array.incl.pl1 contains pointers  to
  7   101*   all  rm_rel_info  structures  allocated. It is used for searching
  7   102*   for the appropriate  structure.  This  array  is  pointed  to  by
  7   103*   rm_db_info. There are two arrays, one for perm rels, one for temp
  7   104*   rels.
  7   105*
  7   106*   The      rm_rel_info      structure      points      to       the
  7   107*   mdbm_rm_attr_info.incl.pl1  structures,  one  for  each attribute
  7   108*   appearing in this view of the relation. Each  of  these  in  turn
  7   109*   point  to a mdbm_rm_domain_info.incl.pl1 structure for the domain
  7   110*   info for each attr.
  7   111*
  7   112*   Most of the other information here deals with  specifics  of  the
  7   113*   relation's  logical  definition,  such as key and secondary index
  7   114*   attribute inidicators, security permissions, and  tuple  physical
  7   115*   construction details.
  7   116*
  7   117**/
  7   118 
  7   119      dcl	   1 rm_rel_info	      aligned based (rmri_ptr), /* relation information */
  7   120 	     2 name	      char (32),		/* from submodel */
  7   121 	     2 model_name	      char (30),		/* from model */
  7   122 	     2 rel_id	      bit (36) aligned,	/* unique id. */
  7   123 	     2 retrieve	      bit (1) unal,		/* operations allowed by this view */
  7   124 	     2 modify	      bit (1) unal,
  7   125 	     2 delete	      bit (1) unal,
  7   126 	     2 store	      bit (1) unal,
  7   127 	     2 total_key	      bit (1) unal,		/* on if view includes full primary key */
  7   128 	     2 indexed	      bit (1) unal,		/* on if exists sec. index */
  7   129 	     2 mdbm_secured	      bit (1) unal,		/* on if mdbm must check security */
  7   130 	     2 status_perm	      bit (1) unal,		/* if user has status. perm. */
  7   131 	     2 append_tuple_perm  bit (1) unal,		/* if user has store perm. */
  7   132 	     2 delete_tuple_perm  bit (1) unal,		/* if user has del. perm. */
  7   133 	     2 unused_perm	      bit (1) unal,		/* for future use. */
  7   134 	     2 last_model_attr_char_var bit (1) unal,	/* on => last model varying attr is char */
  7   135 	     2 reserved	      bit (24) unal,	/* for future use */
  7   136 	     2 num_attr	      fixed bin,		/* total no. of attr. in rel. */
  7   137 	     2 model_num_attr     fixed bin,		/* total attrs in model relation */
  7   138 	     2 nkey_attr	      fixed bin,		/* no. of key attr. */
  7   139 	     2 model_nkey_attr    fixed bin,		/* total number of keys in model */
  7   140 	     2 primary_key_index_id bit (36) aligned,     /* Index id of relation's primary key */
  7   141 	     2 nsec_inds	      fixed bin,		/* no. sec. indexes */
  7   142 	     2 max_key_len	      fixed bin (35),	/* max length (chars) of primary key */
  7   143 	     2 current_tuple_population fixed bin (35),	/* last known total  tuple count for this relation */
  7   144 	     2 last_statistics_update_count fixed bin,	/* number of operations's, since this rels stats were updated */
  7   145 	     2 last_statistics_update_time fixed bin (71),/* last time this rels stats were updated */
  7   146 	     2 last_statistics_update_s_e_ref_num fixed bin (35), /* last select expr ID that updated this rels stats */
  7   147 	     2 ready_mode	      fixed bin,		/* 1 => r, 2 => mr, 3 => u, 4 => l, 5 => sr, 6 => su */
  7   148 	     2 file_type	      fixed bin,		/* 1 => unblocked, 2 => blocked, 3 => temporary */
  7   149 	     2 tuple_id_len	      fixed bin,		/* no. bits in local tuple id */
  7   150 	     2 opening_id	      bit (36) aligned,	/* relation manager opening is */
  7   151 	     2 key_attr_ptrs      (nkey_attr_init refer (rm_rel_info.nkey_attr)) ptr, /* ptrs to key attr. */
  7   152 	     2 attr_ptrs	      (natts_init refer (rm_rel_info.num_attr)) ptr, /* ptrs to all attr. */
  7   153 	     2 id_list_ptr        ptr,		/* Id list for retrieves from the relation */
  7   154                2 scope_flags_ptr    ptr;                    /* pointer to the scope_flags structure for the rel */
  7   155 
  7   156      dcl	   rmri_ptr	      ptr;
  7   157      dcl	   (nkey_attr_init,
  7   158 	   natts_init,
  7   159 	   nvar_atts_init)	      fixed bin;
  7   160 
  7   161 /* END mdbm_rm_rel_info.incl.pl1 */
  7   162 
  7   163 
      351 
      352 
  8     1 /* BEGIN mrds_range.incl.pl1 -- jaw, 10/20/78 */
  8     2 
  8     3 /* Modified 83-04-22 by R. Harvey to add needed_bits */
  8     4 
  8     5 dcl 1 range aligned based (range_ptr),
  8     6     2 num_vars fixed bin,				/* number of tuple variables */
  8     7     2 tup_var (mrds_data_$max_tup_var refer (range.num_vars)), /* info for each tuple variable */
  8     8       3 name char (mrds_data_$max_id_len),		/* name of tuple variable */
  8     9       3 temp_rel bit (1) unal,			/* on if temporary relation */
  8    10       3 used bit (1) unal,				/* 1 => this tuple variable is referenced by
  8    11*						   a -select clause. */
  8    12       3 whole_tuple_selected bit (1) unal,		/* the whole tuple variable is referenced in the select clause */
  8    13       3 copy_for_current bit (1) unal,			/* -current requests attributes not previously retrieved */
  8    14       3 copied_for_current bit (1) unal,		/* tuple copied during previous -current */
  8    15       3 reserved bit (31) unal,			/* reserved for future use */
  8    16       3 rel_index fixed bin,				/* index to assoc. relation */
  8    17       3 stv_ptr ptr,				/* simple typed vector */
  8    18       3 idl_ptr ptr,				/* id_list ptr */
  8    19       3 needed_bits aligned,
  8    20         4 attr (mrds_data_$max_attributes) bit (1) unal,
  8    21       3 ri_ptr ptr;					/* pointer to rel info for assoc. relation */
  8    22 
  8    23 dcl  range_ptr ptr;
  8    24 
  8    25 /* END mrds_range.incl.pl1 */
  8    26 
      353 
      354 
  9     1 /* BEGIN mrds_tuple_info.incl.pl1 -- jaw 11/2/78 */
  9     2 
  9     3 /* HISTORY:
  9     4*
  9     5*   Modified in March 1977 by O Friesen to hold allocated ptr and length
  9     6*   82-10-29 Mike Kubicar : Made tuple_id aligned
  9     7*
  9     8**/
  9     9  
  9    10 dcl 1 tuple_info aligned based (ti_ptr),
  9    11     2 num_tuples fixed bin,				/* no. of tuples for which info given */
  9    12     2 tuple (ti_ntuples_init refer (tuple_info.num_tuples)),
  9    13       3 tuple_ptr ptr,				/* pointer to found tuple */
  9    14       3 tuple_id bit (36) aligned,			/* tuple id for  found tuple */
  9    15       3 var_index fixed bin;				/* index to tuple variable  */
  9    16 
  9    17 dcl  ti_ptr ptr;
  9    18 dcl  ti_ntuples_init fixed bin;
  9    19 
  9    20 /* END mrds_tuple_info.incl.pl1 */
  9    21 
      355 
      356 
 10     1 /* BEGIN mdbm_arg_list.incl.pl1 -- jaw 5/31/78 */
 10     2 /* the duplicate mrds_arg_list.incl.pl1 was eliminated by Jim Gray, Nov. 1979 */
 10     3 
 10     4 /* layout of argument list for IDS and DBM entries with options (variable) */
 10     5 
 10     6 dcl 1 arg_list based (al_ptr),
 10     7     2 arg_count fixed bin (17) unal,			/* 2 * no. of args. */
 10     8     2 code fixed bin (17) unal,			/* 4 => normal, 8 => special */
 10     9     2 desc_count fixed bin (17) unal,			/* 2 * no. of descriptors */
 10    10     2 pad fixed bin (17) unal,			/* must be 0 */
 10    11     2 arg_des_ptr (num_ptrs) ptr;			/* argument/descriptor pointer */
 10    12 
 10    13 dcl  al_ptr ptr;
 10    14 dcl  num_ptrs fixed bin;
 10    15 
 10    16 /* END mdbm_arg_list.incl.pl1  */
 10    17 
      357 
      358 
 11     1 /* BEGIN mrds_select_list.incl.pl1 -- jaw 10/20/78 */
 11     2 
 11     3 /* HISTORY:
 11     4*
 11     5*   81-06-01 Jim Gray : removed user len and type elements,
 11     6*   since mu_convert rather than assign_ is now used.
 11     7*
 11     8*   84-11-22 John Hergert: added fr_ptr
 11     9*
 11    10*/****^  HISTORY COMMENTS:
 11    11*  1) change(86-07-17,Dupuis), approve(86-08-05,MCR7491), audit(86-08-08,Blair),
 11    12*     install(86-08-15,MR12.0-1127):
 11    13*     85-11-22 Hergert: Added variable var_exists so that it may be kept
 11    14*     around per select expression (in sets) and when compiling. (mrds #158)
 11    15*  2) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
 11    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
 11    17*     For new parser, (and general readability) renamed sel_ptr to
 11    18*     select_list_ptr.
 11    19*                                                   END HISTORY COMMENTS */
 11    20 
 11    21 
 11    22 dcl 1 select_list based (select_list_ptr),			/* tabular representation of -select clause */
 11    23     2 num_vars fixed bin,				/* number of free variables */
 11    24     2 mla_ptr ptr,					/* pointer to array of move list pointers */
 11    25     2 fr_ptr ptr,                                           /* pointer to free_raltions struct in mrds_dsl_select_clause */
 11    26     2 num_items fixed bin,				/* number of attributes specified in select list */
 11    27     2 var_exists (36) bit(1),
 11    28     2 item (mrds_data_$max_select_items refer (select_list.num_items)),
 11    29       3 must_convert bit (1) unal,			/* on if conversion required */
 11    30       3 key bit (1) unal,				/* on if to be key attr. in temp. rel. */
 11    31       3 index bit (1) unal,				/* on if index attribute in temp rel */
 11    32       3 reserved bit (33) unal,			/* reserved for future use */
 11    33       3 var_index fixed bin,				/*  index of assoc. tuple variable */
 11    34       3 ai_ptr ptr,					/* ptr to attr_info */
 11    35       3 user_desc_ptr ptr,				/* to descriptor for user value */
 11    36       3 user_ptr ptr ;				/* pointer to user's area */
 11    37 
 11    38 dcl  select_list_ptr ptr int automatic init (null ());
 11    39 
 11    40 dcl 1 move_list_array (select_list.num_vars) based (select_list.mla_ptr),
 11    41     2 var_index fixed bin,
 11    42     2 ml_ptr ptr;
 11    43 
 11    44 /* END mrds_select_list.incl.pl1 */
 11    45 
      359 
      360 
 12     1 /* BEGIN mdbm_descriptor.incl.pl1 -- jaw 5/31/78 */
 12     2 /* modified by Jim Gray - - Nov. 1979, to change type from fixed bin(5) to
 12     3*   unsigned fixed bin(6), so new packed decimal data types could be handled.
 12     4*   also the duplicate mrds_descriptor.incl.pl1 was eliminated. */
 12     5 
 12     6 dcl 1 descriptor based (desc_ptr),			/* map of Multics descriptor */
 12     7     2 version bit (1) unal,				/* DBM handles vers. 1 only */
 12     8     2 type unsigned fixed bin (6) unal,			/* data type */
 12     9     2 packed bit (1) unal,				/* on if data item is packed */
 12    10     2 number_dims bit (4) unal,			/* dimensions */
 12    11     2 size,					/* size for string data */
 12    12       3 scale bit (12) unal,				/* scale for num. data */
 12    13       3 precision bit (12) unal,			/* prec. for num. data */
 12    14     2 array_info (num_dims),
 12    15       3 lower_bound fixed bin (35),			/* lower bound of dimension */
 12    16       3 upper_bound fixed bin (35),			/* upper bound of dimension */
 12    17       3 multiplier fixed bin (35);			/*  element separation */
 12    18 
 12    19 dcl  desc_ptr ptr;
 12    20 dcl  num_dims fixed bin init (0) ;			/* more useful form of number_dims */
 12    21 
 12    22 /* END mdbm_descriptor.incl.pl1 */
 12    23 
 12    24 
      361 
      362 
      363 
      364 /* Multics subroutines */
      365 
      366 	dcl     cu_$arg_list_ptr	 entry (ptr);
      367 	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin, fixed bin (35));
      368 
      369 	dcl     sys_info$max_seg_size	 ext fixed bin;
      370 
      371 
      372 /*  DBM Routines */
      373 
      374 	dcl     mrds_dsl_search	 entry (ptr, ptr, fixed bin (35));
      375 	dcl     mrds_dsl_translate	 entry (ptr, ptr, fixed bin, ptr, fixed bin, ptr, ptr, fixed bin, fixed bin (35));
      376 	dcl     mu_cursor_manager_$get entry (fixed bin (35), ptr, fixed bin (35),
      377 				 bit (36) aligned, entry, entry, ptr, ptr, ptr, fixed bin (35));
      378 	dcl     mu_database_index$get_resultant_model_pointer entry (fixed bin (35), ptr);
      379 	dcl     mrds_data_$caller_delete fixed bin (17) ext;
      380 	dcl     mrds_data_$max_id_len	 ext fixed bin (35);
      381 
      382 	dcl     (mrds_error_$tuple_not_found,
      383 	        mrds_error_$inval_del_expr,
      384 	        mrds_error_$invalid_db_index) ext fixed bin (35);
      385 
      386 /* Based variable */
      387 
      388 	dcl     work_area		 area based (area_ptr);
      389 	dcl     code		 fixed bin (35) based (cd_ptr);
      390 	dcl     database_index	 fixed bin (35) based (dbi_ptr);
      391 
      392 /* Pointers */
      393 
      394 	dcl     (se_ptr,				/* Points to the selection expression */
      395 	        appl_ptr,				/* Points to the list of arg pointers for translate */
      396 	        adpl_ptr,				/* Points to the list of arg descriptors for translate */
      397 	        cd_ptr,				/* Points to callers return code */
      398 	        cursor_ptr,				/* Cursor for relation to operate on */
      399 	        dbi_ptr)		 ptr;		/* Points to the database index */
      400 
      401 
      402 /* Others */
      403 
      404 	dcl     any_other		 condition;
      405 	dcl     cleanup		 condition;
      406 	dcl     (nargs,				/* Number of arguments passed to this proc */
      407 	        arg_len,
      408 	        se_len,				/* Selection expression length */
      409 	        vi,				/* index of tuple_variable for tuple being deleted. */
      410 	        num_args)		 fixed bin;	/* Number of args passed to translate */
      411 
      412 	dcl     num_deleted		 fixed bin (35);	/* Number of tuples deleted by relation manager */
      413 
      414 
      415 	dcl     icode		 fixed bin (35);	/* Internal error code */
      416 	dcl     save_icode		 fixed bin (35);	/* Temp save of icode */
      417 	dcl     ntuples_deleted	 fixed bin (35);	/* deleted tuple counter */
      418 
      419 	dcl     arg_error		 condition;	/* Condition signaled if less then 3 arguments
      420*						   were passed to this proc */
      421 
      422 	dcl     area_ptr		 ptr;
      423 	dcl     mrds_data_$max_attributes fixed bin (35) ext static;
      424 	dcl     mrds_data_$statistics_update_count_interval fixed bin (35) ext; /* number of updates/references before next stats update */
      425 	dcl     mrds_error_$inc_ready_mode fixed bin (35) ext static; /* Update mode not correct */
      426 	dcl     mrds_error_$inc_rel_acc fixed bin (35) ext static; /* Not allowed by submodel */
      427 	dcl     mrds_error_$view_prevent fixed bin (35) ext static; /* Not allowed by submodel */
      428 	dcl     first_time_flag	 bit (1) aligned;	/* on => first call to mu_delete */
      429 	dcl     mu_release_area	 entry (ptr);
      430 	dcl     mu_define_area$define_temp_dir_area entry (ptr, fixed bin (35), fixed bin (18), char (11), bit (1) aligned,
      431 				 bit (1) aligned, bit (1) aligned, bit (1) aligned, fixed bin (35));
      432 	dcl     mu_define_area$define_spec_temp_dir_area entry (ptr, fixed bin (35), char (11), fixed bin (35));
      433 dcl  last_tuple_id bit (36) aligned; /* Last tuple id used to check for redundancy */
      434 	dcl     save_adpl_ptr	 ptr;		/* Saved copy of adpl_ptr in case of rollback */
      435 	dcl     save_appl_ptr	 ptr;		/* Saved copy of appl_ptr in case of rollback */
      436 	dcl     save_num_args	 fixed bin;	/* Saved copy of num_args in case of rollback */
      437 	dcl     se_len_ptr		 ptr;		/* temp for getting varying se len */
      438 	dcl     se_len_ovrly	 fixed bin (35) based;
      439 	dcl     (null,
      440 	        addr,
      441 	        addrel,
      442 	        fixed,
      443 	        rel)		 builtin;
      444 	dcl     MAX_TUPLES_PER_CALL	 fixed bin int static
      445 				 options (constant) init (100);
      446 						/* Number of tuples to delete (max) per call to relation manager */
      447 	dcl     SCOPE_UPDATE	 fixed bin int static init (6)
      448 				 options (constant);
      449 						/* Update permission needed */
      450 	dcl     dbi_pic		 picture "999";
      451 
      452      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/16/89  1242.5  mrds_dsl_delete.pl1               >spec>install>1093>mrds_dsl_delete.pl1
188          1    02/05/86  1416.4  mrds_start_transaction.incl.pl1   >ldd>include>mrds_start_transaction.incl.pl1
1-79         2    01/07/85  0900.0  dm_tm_modes.incl.pl1              >ldd>include>dm_tm_modes.incl.pl1
1-81         3    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
304          4    02/05/86  1416.4  mrds_finish_transaction.incl.pl1  >ldd>include>mrds_finish_transaction.incl.pl1
347          5    03/06/85  1031.5  dm_element_id_list.incl.pl1       >ldd>include>dm_element_id_list.incl.pl1
349          6    08/04/88  2043.3  mrds_dbcb.incl.pl1                >ldd>include>mrds_dbcb.incl.pl1
351          7    10/14/83  1609.1  mdbm_rm_rel_info.incl.pl1         >ldd>include>mdbm_rm_rel_info.incl.pl1
353          8    10/14/83  1609.1  mrds_range.incl.pl1               >ldd>include>mrds_range.incl.pl1
355          9    10/14/83  1609.0  mrds_tuple_info.incl.pl1          >ldd>include>mrds_tuple_info.incl.pl1
357         10    10/14/83  1609.0  mdbm_arg_list.incl.pl1            >ldd>include>mdbm_arg_list.incl.pl1
359         11    08/04/88  2043.3  mrds_select_list.incl.pl1         >ldd>include>mrds_select_list.incl.pl1
361         12    10/14/83  1608.6  mdbm_descriptor.incl.pl1          >ldd>include>mdbm_descriptor.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ELEMENT_ID_LIST_VERSION_1       000147 automatic       fixed bin(35,0)          initial dcl 5-28 set ref 240 5-28*
MAX_TUPLES_PER_CALL                    constant        fixed bin(17,0)          initial dcl 444 ref 238 256
SCOPE_UPDATE                           constant        fixed bin(17,0)          initial dcl 447 ref 222
TM_NORMAL_MODE                  000003 constant        fixed bin(17,0)          initial dcl 2-15 set ref 1-99*
addr                                                   builtin function         dcl 439 ref 169 173 174 1-123 1-123
addrel                                                 builtin function         dcl 439 ref 165
adpl_ptr                        000176 automatic       pointer                  dcl 394 set ref 173* 174* 182 202* 335*
al_ptr                          000160 automatic       pointer                  dcl 10-13 set ref 139* 140 142 155 157 158 161 162
                                                                                  169 173 173 174
any_other                       000206 stack reference condition                dcl 404 ref 186
appl_ptr                        000174 automatic       pointer                  dcl 394 set ref 169* 183 202* 336*
area_ptr                        000242 automatic       pointer                  dcl 422 set ref 137* 197* 202* 212* 239 270*
arg_count                              based           fixed bin(17,0)          level 2 packed packed unaligned dcl 10-6 ref 142 157
                                                                                  161
arg_des_ptr               2            based           pointer                  array level 2 dcl 10-6 set ref 158 162 169 173 174
arg_error                       000234 stack reference condition                dcl 419 ref 140 143 147
arg_len                         000223 automatic       fixed bin(17,0)          dcl 406 set ref 146* 149*
arg_list                               based           structure                level 1 unaligned dcl 10-6
cd                                     parameter       fixed bin(35,0)          dcl 316 ref 314 318
cd_ptr                          000200 automatic       pointer                  dcl 394 set ref 146* 297 299 303 4-115 318 338
cleanup                         000214 stack reference condition                dcl 405 ref 185
code                      0(18)        based           fixed bin(17,0)          level 2 in structure "arg_list" packed packed
                                                                                  unaligned dcl 10-6 in procedure "delete" ref 155
                                                                                  173
code                                   based           fixed bin(35,0)          dcl 389 in procedure "delete" set ref 297* 299 303
                                                                                  4-115* 318* 338*
condition_info                         based           structure                level 1 dcl 3-14
condition_name            3     000110 automatic       varying char(32)         level 2 dcl 1-77 set ref 1-124 1-129 1-129
continue_to_signal_             000010 constant        entry                    external dcl 1-61 ref 1-137
create_cursor           156            based           entry variable           level 4 dcl 6-142 set ref 232*
cu_$arg_list_ptr                000040 constant        entry                    external dcl 366 ref 139
cu_$arg_ptr                     000042 constant        entry                    external dcl 367 ref 146 149 152
current_flag            106(01)        based           bit(1)                   level 3 packed packed unaligned dcl 6-142 ref 209
                                                                                  248
current_ptr              16            based           pointer                  level 3 dcl 6-142 ref 209
cursor_ptr                      000202 automatic       pointer                  dcl 394 set ref 232* 278*
cursor_ptrs_storage_ptr
                        130            based           pointer                  level 3 dcl 6-142 set ref 232*
cursor_storage_area_ptr
                        132            based           pointer                  level 3 dcl 6-142 set ref 232*
data                                   based           structure                level 2 dcl 6-142
database_index                         based           fixed bin(35,0)          dcl 390 set ref 178* 194* 199* 232*
dbcb                                   based           structure                level 1 dcl 6-142
dbcb_data                              based           structure                level 1 unaligned dcl 6-148
dbcb_ptr                        000150 automatic       pointer                  dcl 6-146 set ref 137* 178* 179 181 192 193 194 197
                                                                                  199 202* 205 207 208 209 209 210 212* 232 232 232
                                                                                  232 248 270* 278 308 309 309
dbi                     114            based           fixed bin(35,0)          level 3 dcl 6-142 ref 193
dbi_pic                         000256 automatic       picture(3)               packed unaligned dcl 450 set ref 193* 194 199
dbi_ptr                         000204 automatic       pointer                  dcl 394 set ref 149* 178 194 199 232
delete                   21(02)        based           bit(1)                   level 2 packed packed unaligned dcl 7-119 ref 224
delete_area_ptr          52            based           pointer                  level 3 dcl 6-142 set ref 194* 197 309 309*
delete_tuple_perm        21(09)        based           bit(1)                   level 2 packed packed unaligned dcl 7-119 ref 226
delete_tuples_by_id     172            based           entry variable           level 4 dcl 6-142 ref 278
desc_ptr                        000166 automatic       pointer                  dcl 12-19 set ref 158* 162* 164
descriptor                             based           structure                level 1 unaligned dcl 12-6
dm_error_$bj_journal_full       000030 external static fixed bin(35,0)          dcl 4-52 ref 1-132
dm_error_$lock_deadlock         000032 external static fixed bin(35,0)          dcl 4-53 ref 4-78 1-126
dm_error_$no_current_transaction
                                000012 external static fixed bin(35,0)          dcl 1-62 ref 1-90
eil_number_of_elements          000146 automatic       fixed bin(35,0)          dcl 5-27 set ref 238* 239 239
element_id_list                        based           structure                level 1 dcl 5-21 set ref 239
element_id_list_ptr             000144 automatic       pointer                  dcl 5-26 set ref 239* 240 241 250 251 251 256 262
                                                                                  264 264 266 266 276 278* 285
find_condition_info_            000014 constant        entry                    external dcl 1-64 ref 1-123
first_time_flag                 000244 automatic       bit(1)                   dcl 428 set ref 217*
icode                           000230 automatic       fixed bin(35,0)          dcl 415 set ref 146* 147 149* 150 150* 152* 153 153*
                                                                                  194* 196 196* 199* 200 200* 202* 204 204* 212* 213
                                                                                  213* 232* 236 236* 247 253* 256 270* 273 273 273*
                                                                                  277 278* 280 280* 282* 295 295*
id                        2            based           bit(36)                  array level 2 dcl 5-21 set ref 251* 266*
item                     10            based           structure                array level 2 unaligned dcl 11-22
last_statistics_update_count
                         32            based           fixed bin(17,0)          level 2 dcl 7-119 set ref 288 288 290* 290
last_tuple_id                   000245 automatic       bit(36)                  dcl 433 set ref 245* 262 269*
mdbm_secured             21(06)        based           bit(1)                   level 2 packed packed unaligned dcl 7-119 ref 226
mftxn_code                      000142 automatic       fixed bin(35,0)          dcl 4-54 set ref 299* 303* 4-62* 4-65 4-68* 4-69
                                                                                  4-78 4-115 4-115 1-126* 1-132*
mftxn_temp_code                 000143 automatic       fixed bin(35,0)          dcl 4-55 set ref 4-71* 4-72 4-72* 4-82* 4-83 4-85*
                                                                                  4-86 4-86* 4-96* 4-97 4-99* 4-100 4-100* 4-109*
                                                                                  4-110 4-110*
mrds_data_$caller_delete        000056 external static fixed bin(17,0)          dcl 379 set ref 202*
mrds_data_$max_attributes       000070 external static fixed bin(35,0)          dcl 423 ref 218 218 218
mrds_data_$max_id_len           000060 external static fixed bin(35,0)          dcl 380 ref 218 218 218
mrds_data_$statistics_update_count_interval
                                000072 external static fixed bin(35,0)          dcl 424 ref 288
mrds_dsl_search                 000046 constant        entry                    external dcl 374 ref 212 270
mrds_dsl_translate              000050 constant        entry                    external dcl 375 ref 202
mrds_error_$inc_ready_mode      000074 external static fixed bin(35,0)          dcl 425 set ref 222*
mrds_error_$inc_rel_acc         000076 external static fixed bin(35,0)          dcl 426 set ref 226*
mrds_error_$inval_del_expr      000064 external static fixed bin(35,0)          dcl 382 set ref 205*
mrds_error_$invalid_db_index    000066 external static fixed bin(35,0)          dcl 382 set ref 179*
mrds_error_$tuple_not_found     000062 external static fixed bin(35,0)          dcl 382 ref 253 273 295 299
mrds_error_$view_prevent        000100 external static fixed bin(35,0)          dcl 427 set ref 224*
mstxn_code                      000100 automatic       fixed bin(35,0)          dcl 1-65 set ref 1-83* 1-89* 1-90 1-99* 1-140 1-140*
                                                                                  4-90* 4-104* 1-137*
mstxn_condition_info            000110 automatic       structure                level 1 unaligned dcl 1-77 set ref 1-123 1-123
mstxn_retries                   000101 automatic       fixed bin(17,0)          dcl 1-66 set ref 1-88* 4-78 4-81* 4-81
mstxn_temp_code                 000102 automatic       fixed bin(35,0)          dcl 1-67 set ref 1-109* 1-110 1-110* 1-123*
mstxn_transactions_needed       000103 automatic       bit(1)                   dcl 1-68 set ref 181* 1-86
mstxn_txn_id                    000105 automatic       bit(36)                  dcl 1-70 set ref 138* 1-84* 1-89* 1-93 1-94* 1-99*
                                                                                  1-100 4-60 4-68* 4-71* 4-72* 4-82* 4-85* 4-86*
                                                                                  4-96* 4-99* 4-100* 4-109* 4-110* 4-114* 1-107
                                                                                  1-109* 1-110* 1-121
mu_cursor_manager_$get          000052 constant        entry                    external dcl 376 ref 232
mu_database_index$get_resultant_model_pointer
                                000054 constant        entry                    external dcl 378 ref 178
mu_define_area$define_spec_temp_dir_area
                                000106 constant        entry                    external dcl 432 ref 199
mu_define_area$define_temp_dir_area
                                000104 constant        entry                    external dcl 430 ref 194
mu_release_area                 000102 constant        entry                    external dcl 429 ref 309
nargs                           000222 automatic       fixed bin(17,0)          dcl 406 set ref 142* 143 146* 158 162 173 174 176
ntuples_deleted                 000232 automatic       fixed bin(35,0)          dcl 417 set ref 216* 284* 284 290
null                                                   builtin function         dcl 439 ref 137 140 179 308 309 11-38 1-123 1-123
num_args                        000226 automatic       fixed bin(17,0)          dcl 406 set ref 176* 184 202* 337*
num_deleted                     000227 automatic       fixed bin(35,0)          dcl 412 set ref 275* 278* 284
num_dims                        000170 automatic       fixed bin(17,0)          initial dcl 12-20 set ref 12-20*
num_ptrs                        000162 automatic       fixed bin(17,0)          dcl 10-14 set ref 157* 161*
number_of_elements        1            based           fixed bin(35,0)          level 2 dcl 5-21 set ref 239* 241* 250* 251 256 262
                                                                                  264* 264 266 276 285*
open                    146            based           entry variable           level 4 dcl 6-142 set ref 232*
range                                  based           structure                level 1 dcl 8-5
range_ptr                       000154 automatic       pointer                  dcl 8-23 in procedure "delete" set ref 208* 218
range_ptr                 2            based           pointer                  level 3 in structure "dbcb" dcl 6-142 in procedure
                                                                                  "delete" ref 208
ready_mode               37            based           fixed bin(17,0)          level 2 dcl 7-119 ref 222
rel_id                   20            based           bit(36)                  level 2 dcl 7-119 set ref 232*
relmgr_entries          146            based           structure                level 3 dcl 6-142
ri_ptr                                 based           pointer                  array level 3 dcl 8-5 ref 218
rm_rel_info                            based           structure                level 1 dcl 7-119
rmri_ptr                        000152 automatic       pointer                  dcl 7-156 set ref 218* 222 224 226 226 232* 232 288
                                                                                  288 290 290
save_adpl_ptr                   000246 automatic       pointer                  dcl 434 set ref 182* 335
save_appl_ptr                   000250 automatic       pointer                  dcl 435 set ref 183* 336
save_icode                      000231 automatic       fixed bin(35,0)          dcl 416 set ref 277* 282
save_num_args                   000252 automatic       fixed bin(17,0)          dcl 436 set ref 184* 337
se_len                          000224 automatic       fixed bin(17,0)          dcl 406 set ref 152* 166* 202*
se_len_ovrly                           based           fixed bin(35,0)          dcl 438 ref 166
se_len_ptr                      000254 automatic       pointer                  dcl 437 set ref 165* 166
se_ptr                          000172 automatic       pointer                  dcl 394 set ref 152* 165 202*
select_list                            based           structure                level 1 unaligned dcl 11-22
select_list_ptr                 000164 automatic       pointer                  initial dcl 11-38 set ref 209* 210* 215 11-38*
select_ptr                4            based           pointer                  level 3 dcl 6-142 ref 210
sys_info$max_seg_size           000044 external static fixed bin(17,0)          dcl 369 ref 194
ti_ptr                   12            based           pointer                  level 3 in structure "dbcb" dcl 6-142 in procedure
                                                                                  "delete" ref 207
ti_ptr                          000156 automatic       pointer                  dcl 9-17 in procedure "delete" set ref 207* 251 262
                                                                                  266 269
transaction_manager_$abandon_txn
                                000016 constant        entry                    external dcl 1-72 ref 4-72 4-86 4-100 4-110 1-110
transaction_manager_$abort_txn  000020 constant        entry                    external dcl 1-73 ref 4-71 4-85 4-99 4-109 1-109
transaction_manager_$begin_txn  000022 constant        entry                    external dcl 1-74 ref 1-99
transaction_manager_$commit_txn 000034 constant        entry                    external dcl 4-56 ref 4-68
transaction_manager_$get_current_txn_id
                                000024 constant        entry                    external dcl 1-75 ref 1-89
transaction_manager_$handle_conditions
                                000026 constant        entry                    external dcl 1-76 ref 1-135
transaction_manager_$rollback_txn
                                000036 constant        entry                    external dcl 4-57 ref 4-82 4-96
transactions_needed     106(13)        based           bit(1)                   level 3 packed packed unaligned dcl 6-142 ref 181
tup_var                   2            based           structure                array level 2 dcl 8-5
tuple                     2            based           structure                array level 2 dcl 9-10
tuple_id                  4            based           bit(36)                  array level 3 dcl 9-10 ref 251 262 266 269
tuple_info                             based           structure                level 1 dcl 9-10
type                      0(01)        based           fixed bin(6,0)           level 2 packed packed unsigned unaligned dcl 12-6
                                                                                  ref 164
user_started_transaction        000104 automatic       bit(1)                   dcl 1-69 in procedure "delete" set ref 1-92* 1-98*
                                                                                  192 4-60
user_started_transaction
                        106(22)        based           bit(1)                   level 3 in structure "dbcb" packed packed unaligned
                                                                                  dcl 6-142 in procedure "delete" set ref 192*
user_transaction_id             000106 automatic       bit(36)                  dcl 1-71 set ref 1-93* 1-100*
val_del                 106(11)        based           bit(1)                   level 3 packed packed unaligned dcl 6-142 ref 205
var_index                11            based           fixed bin(17,0)          array level 3 dcl 11-22 ref 215
version                                based           fixed bin(35,0)          level 2 dcl 5-21 set ref 240*
vi                              000225 automatic       fixed bin(17,0)          dcl 406 set ref 215* 218 251 262 266 269
work_area                              based           area(1024)               dcl 388 ref 239
work_area_ptr            70            based           pointer                  level 3 dcl 6-142 set ref 199*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
HIGHEST_MODE                           internal static fixed bin(17,0)          initial dcl 2-12
LOWEST_MODE                            internal static fixed bin(17,0)          initial dcl 2-12
TM_NEVER_WRITE_MODE                    internal static fixed bin(17,0)          initial dcl 2-18
TM_READ_ONLY_MODE                      internal static fixed bin(17,0)          initial dcl 2-17
TM_STATISTICAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-16
TM_TEST_NEVER_WRITE_MODE               internal static fixed bin(17,0)          initial dcl 2-22
TM_TEST_NORMAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-19
TM_TEST_READ_ONLY_MODE                 internal static fixed bin(17,0)          initial dcl 2-21
TM_TEST_STATISTICAL_MODE               internal static fixed bin(17,0)          initial dcl 2-20
condition_info_ptr                     automatic       pointer                  dcl 3-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 3-30
error_table_$null_info_ptr             external static fixed bin(35,0)          dcl 1-63
fixed                                                  builtin function         dcl 439
move_list_array                        based           structure                array level 1 unaligned dcl 11-40
natts_init                             automatic       fixed bin(17,0)          dcl 7-157
nkey_attr_init                         automatic       fixed bin(17,0)          dcl 7-157
nvar_atts_init                         automatic       fixed bin(17,0)          dcl 7-157
rel                                                    builtin function         dcl 439
ti_ntuples_init                        automatic       fixed bin(17,0)          dcl 9-18

NAMES DECLARED BY EXPLICIT CONTEXT.
delete                          000051 constant        entry                    external dcl 28
error                           001663 constant        entry                    internal dcl 314 ref 150 153 179 1-140 196 200 204
                                                                                  205 213 222 224 226 236 273 280 295
exit                            001251 constant        label                    dcl 299 ref 319
mftxn_check_code                001267 constant        label                    dcl 4-65 ref 1-127 1-133
mftxn_exit                      001507 constant        label                    dcl 4-115 ref 4-63
mrds_dsl_delete                 000061 constant        entry                    external dcl 28
mstxn_any_other                 001566 constant        entry                    internal dcl 1-116 ref 186
mstxn_cleanup                   001534 constant        entry                    internal dcl 1-102 ref 185
mstxn_exit                      000447 constant        label                    dcl 1-140 ref 1-86 1-95 4-91 4-105
restore_significant_data        001670 constant        entry                    internal dcl 333 ref 4-77
should_rollback                 001701 constant        entry                    internal dcl 341 ref 4-94

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2412        2522    1727        2422
Length      3230    1727       110         472     462           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
delete                              258 external procedure  is an external procedure.  
on unit on line 185                  76 on unit               
on unit on line 186                  82 on unit               
mstxn_cleanup                           internal procedure  shares stack frame of on unit on line 185.  
mstxn_any_other                         internal procedure  shares stack frame of on unit on line 186.  
error                                   internal procedure  shares stack frame of external procedure delete.  
restore_significant_data                internal procedure  shares stack frame of external procedure delete.  
should_rollback                         internal procedure  shares stack frame of external procedure delete.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
delete                   000100 mstxn_code                  delete
                         000101 mstxn_retries               delete
                         000102 mstxn_temp_code             delete
                         000103 mstxn_transactions_needed   delete
                         000104 user_started_transaction    delete
                         000105 mstxn_txn_id                delete
                         000106 user_transaction_id         delete
                         000110 mstxn_condition_info        delete
                         000142 mftxn_code                  delete
                         000143 mftxn_temp_code             delete
                         000144 element_id_list_ptr         delete
                         000146 eil_number_of_elements      delete
                         000147 ELEMENT_ID_LIST_VERSION_1   delete
                         000150 dbcb_ptr                    delete
                         000152 rmri_ptr                    delete
                         000154 range_ptr                   delete
                         000156 ti_ptr                      delete
                         000160 al_ptr                      delete
                         000162 num_ptrs                    delete
                         000164 select_list_ptr             delete
                         000166 desc_ptr                    delete
                         000170 num_dims                    delete
                         000172 se_ptr                      delete
                         000174 appl_ptr                    delete
                         000176 adpl_ptr                    delete
                         000200 cd_ptr                      delete
                         000202 cursor_ptr                  delete
                         000204 dbi_ptr                     delete
                         000222 nargs                       delete
                         000223 arg_len                     delete
                         000224 se_len                      delete
                         000225 vi                          delete
                         000226 num_args                    delete
                         000227 num_deleted                 delete
                         000230 icode                       delete
                         000231 save_icode                  delete
                         000232 ntuples_deleted             delete
                         000242 area_ptr                    delete
                         000244 first_time_flag             delete
                         000245 last_tuple_id               delete
                         000246 save_adpl_ptr               delete
                         000250 save_appl_ptr               delete
                         000252 save_num_args               delete
                         000254 se_len_ptr                  delete
                         000256 dbi_pic                     delete

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ent_var        call_ext_out        return_mac          tra_ext_1           signal_op           enable_op
ext_entry           int_entry           trunc_fx2           divide_fx1          op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
continue_to_signal_           cu_$arg_list_ptr              cu_$arg_ptr                   find_condition_info_
mrds_dsl_search               mrds_dsl_translate            mu_cursor_manager_$get
mu_database_index$get_resultant_model_pointer               mu_define_area$define_spec_temp_dir_area
mu_define_area$define_temp_dir_area                         mu_release_area
transaction_manager_$abandon_txn                            transaction_manager_$abort_txn
transaction_manager_$begin_txn                              transaction_manager_$commit_txn
transaction_manager_$get_current_txn_id                     transaction_manager_$handle_conditions
transaction_manager_$rollback_txn

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bj_journal_full     dm_error_$lock_deadlock       dm_error_$no_current_transaction
mrds_data_$caller_delete      mrds_data_$max_attributes     mrds_data_$max_id_len
mrds_data_$statistics_update_count_interval                 mrds_error_$inc_ready_mode    mrds_error_$inc_rel_acc
mrds_error_$inval_del_expr    mrds_error_$invalid_db_index  mrds_error_$tuple_not_found   mrds_error_$view_prevent
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 5   28 000041   11   38 000043   12   20 000045        28 000050       137 000067       138 000072       139 000073
    140 000102       142 000111       143 000121       146 000126       147 000143       149 000150       150 000167
    152 000173       153 000212       155 000216       157 000224       158 000227       159 000234       161 000235
    162 000241       164 000246       165 000253       166 000256       169 000260       173 000263       174 000274
    176 000301       178 000304       179 000315       181 000330       182 000335       183 000337       184 000341
    185 000343       186 000361    1   83 000377    1   84 000400    1   86 000401    1   88 000403    1   89 000404
 1   90 000415    1   92 000421    1   93 000423    1   94 000425    1   95 000426    1   98 000427    1   99 000430
 1  100 000445    1  140 000447       192 000453       193 000461       194 000471       196 000537       197 000543
    199 000546       200 000572       202 000576       204 000625       205 000631       207 000644       208 000647
    209 000652       210 000661       212 000663       213 000676       215 000702       216 000705       217 000706
    218 000710       222 000751       224 000762       226 000775       232 001013       236 001047       238 001053
    239 001055       240 001066       241 001070       245 001071       247 001072       248 001074       250 001100
    251 001103       253 001110       254 001113       256 001114       262 001122       264 001133       266 001137
    269 001143       270 001145       271 001160       273 001161       275 001170       276 001171       277 001174
    278 001176       280 001213       282 001217       284 001221       285 001225       286 001227       288 001230
    290 001236       295 001242       297 001250       299 001251       303 001257    4   60 001260    4   62 001265
 4   63 001266    4   65 001267    4   68 001271    4   69 001302    4   71 001304    4   72 001315    4   75 001330
 4   77 001331    4   78 001332    4   81 001341    4   82 001342    4   83 001355    4   85 001357    4   86 001370
 4   88 001403    4   90 001404    4   91 001405    4   93 001406    4   94 001407    4   96 001414    4   97 001430
 4   99 001432    4  100 001443    4  102 001456    4  104 001457    4  105 001460    4  107 001461    4  109 001462
 4  110 001473    4  114 001506    4  115 001507       308 001512       309 001517       312 001533    1  102 001534
 1  107 001535    1  109 001540    1  110 001551    1  114 001565    1  116 001566    1  121 001567    1  123 001572
 1  124 001611    1  126 001617    1  127 001622    1  129 001625    1  132 001637    1  133 001642    1  135 001645
 1  136 001652    1  137 001653    1  138 001662       314 001663       318 001665       319 001667       333 001670
    335 001671       336 001673       337 001675       338 001677       339 001700       341 001701       343 001703


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
