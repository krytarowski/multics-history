	COMPILATION LISTING OF SEGMENT bj_storage_get
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  1001.2 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION:
        8*
        9**/
       10 
       11 
       12 /* HISTORY:
       13*Written by Andre Bensoussan,  07/14/1982 (Bastille Day).
       14*Modified:
       15*10/15/82 by M. Pandolf to use file_manager_ to manipulate data management
       16*	  system files.
       17*02/23/83 by A. Bensoussan to lock/unlock using bj_pste_lock$lock/unlock.
       18*06/11/84 by Lee Baldwin:  Renamed dm_error_$bj_buffer_bad_uid to
       19*            bj_bad_buffer_uid, removed dcls for dm_error_$bj_bad_buffer_address
       20*            
       21*            and $bj_journal_full because they're not being used.
       22*10/12/84 by M. Sharpe:  to use "call ERROR_RETURN (code)" convention; to
       23*	  change a goto-simulated loop to a "do while"; to clean up
       24*	  format and dcls; to rewrite GET_CI internal procedure to
       25*	  return a pointer to the requested ci obtained from
       26*	  file_manager_$get_ci_ptr. 
       27*12/06/84 by M. Sharpe:  to add format statement; to set/reset validation level
       28*	  around the call to file_manager_.
       29*01/11/85 by M. Sharpe:  to rest validation level in the ERROR_RETURN
       30*	  subroutine.
       31**/
       32 
       33 /* format: style4,^indcomtxt,idind40,^inddcls,indattr */
       34 
       35 bj_storage_get: proc (p_bj_oid, p_rec_id, p_rec_ptr, p_rec_bytes);
       36 
       37 
       38 /* Parameters */
       39 
       40 dcl  p_bj_oid			     bit (36) aligned;
       41 dcl  p_rec_id			     bit (36) aligned; /* id of requested record */
       42 dcl  p_rec_ptr			     ptr;		/* ptr to logical record */
       43 dcl  p_rec_bytes			     fixed bin;	/* number of bytes of logical record - Output */
       44 
       45 
       46 
       47 /* Automatic */
       48 
       49 dcl  ci_no			     fixed bin (24) uns;
       50 dcl  code				     fixed bin (35);
       51 dcl  curr_bytes			     fixed bin;
       52 dcl  curr_offset			     fixed bin;
       53 dcl  more_to_be_gotten		     bit (1);
       54 dcl  prev_bytes			     fixed bin;
       55 dcl  rel_distance			     fixed bin (35);
       56 dcl  sl_no			     fixed bin (12) uns;
       57 dcl  saved_level			     fixed bin init (-1);
       58 dcl  current_ring			     fixed bin (3);
       59 
       60 dcl  1 rec_id			     aligned,
       61        2 ci_no			     fixed bin (24) uns unaligned,
       62        2 sl_no			     fixed bin (12) uns unaligned;
       63 
       64 /* Based */
       65 
       66 dcl  RECORD_STRING			     char (curr_bytes) based;
       67 
       68 /* Builtin */
       69 
       70 dcl  (addcharno, addrel, null,
       71      ptr, size, unspec)		     builtin;
       72 
       73 /* Condition */
       74 
       75 dcl  cleanup			     condition;
       76 
       77 
       78 /* Constants */
       79 
       80 dcl  ME				     char (14) int static
       81 				     options (constant) init ("bj_storage_get");
       82 
       83 
       84 /* Entries */
       85 
       86 dcl  bj_pste_lock$lock		     entry (ptr, bit (36) aligned);
       87 dcl  bj_pste_lock$unlock		     entry (ptr);
       88 dcl  bj_oid_util$get_ptr		     entry (bit (36) aligned) returns (ptr);
       89 dcl  bj_report_err			     entry (fixed bin (35), char (*));
       90 dcl  bj_storage_util$distance
       91 				     entry (ptr, fixed bin (24) uns) returns (fixed bin (24) uns);
       92 dcl  bj_storage_util$next_used_ci
       93 				     entry (ptr, fixed bin (24) uns) returns (fixed bin (24) uns);
       94 dcl  cu_$level_get			     entry (fixed bin);
       95 dcl  cu_$level_set			     entry (fixed bin);
       96 dcl  file_manager_$get_ci_ptr
       97 				     entry (bit (36) aligned, fixed bin (27), ptr, fixed bin (35));
       98 dcl  get_ring_			     entry () returns (fixed bin (3));
       99 
      100 
      101 /* External Static */
      102 
      103 dcl  dm_error_$bj_bad_buffer_uid	     fixed bin (35) ext;
      104 dcl  dm_error_$bj_bad_rec_id		     fixed bin (35) ext;
      105 dcl  dm_error_$bj_bad_continuation_flag	     fixed bin (35) ext;
      106 dcl  dm_error_$bj_logic_err		     fixed bin (35) ext;
      107 
      108 
      109 /* Code */
      110 
      111 	bj_ppte_ptr = bj_oid_util$get_ptr (p_bj_oid);
      112 	bj_pste_ptr = bj_ppte.bj_pste_ptr;
      113 	bj_ci_ptr = ptr (bj_pste_ptr, bj_pste.buffer_offset);
      114 
      115 
      116 
      117 	call bj_pste_lock$lock (bj_pste_ptr, bj_ppte.bj_uid);
      118 
      119 
      120 
      121 	if bj_ci.header1.id.uid ^= bj_pste.bj_uid	/* Consistency check */
      122 	then call ERROR_RETURN (dm_error_$bj_bad_buffer_uid);
      123 
      124 
      125 /*
      126*	The bj_storage_get primitive should not be concerned with buffering
      127*	the next CI since it is not going to write in the journal. If the
      128*	last_ci_put is the last_ci_buffered, this should not prevent the get
      129*	primitive to function correctly.
      130*
      131*	The bj_storage_get primitive should not be concerned with putting
      132*	the buffered CI in the file either, even if the buffer is full, as
      133*	long as the get primitive gets the record from the buffer if it
      134*	happens to be in the buffer, which it does.
      135*     */
      136 
      137 
      138 
      139 	prev_bytes = 0;
      140 	curr_bytes = 0;
      141 
      142 	unspec (rec_id) = p_rec_id;
      143 	ci_no = rec_id.ci_no;
      144 	sl_no = rec_id.sl_no;
      145 
      146 
      147 	current_ring = get_ring_ ();
      148 	call cu_$level_get (saved_level);
      149 
      150 	on cleanup call cu_$level_set (saved_level);
      151 
      152 	more_to_be_gotten = "1"b;
      153 	do while (more_to_be_gotten);
      154 	     rel_distance = bj_storage_util$distance (bj_pste_ptr, bj_pste.last_ci_put)
      155 		- bj_storage_util$distance (bj_pste_ptr, ci_no);
      156 
      157 	     if rel_distance >= 0			/* Normal case */
      158 	     then do;
      159 		call cu_$level_set ((current_ring));
      160 		bj_ci_ptr = GET_CI (ci_no);
      161 		call cu_$level_set (saved_level);
      162 	     end;
      163 
      164 	     else if rel_distance = -1		/* Very special case: record is in buffer */
      165 	     then if ci_no = bj_pste.last_ci_buffered
      166 		then bj_ci_ptr = ptr (bj_pste_ptr, bj_pste.buffer_offset);
      167 		else call ERROR_RETURN (dm_error_$bj_logic_err);
      168 
      169 	     else call ERROR_RETURN (dm_error_$bj_bad_rec_id);
      170 
      171 	     if prev_bytes = 0			/* Check existence of record with this rec_id */
      172 	     then if sl_no > bj_ci.header2.n_slots
      173 		     | sl_no < 1
      174 		     | (sl_no = 1 & bj_ci.header2.first_is_contn)
      175 		then call ERROR_RETURN (dm_error_$bj_bad_continuation_flag);
      176 		else ;				/* OK */
      177 
      178 	     else if sl_no > bj_ci.header2.n_slots
      179 		| sl_no ^= 1
      180 		| bj_ci.header2.first_is_contn = "0"b
      181 	     then call ERROR_RETURN (dm_error_$bj_bad_continuation_flag);
      182 	     else ;				/* OK */
      183 
      184 	     curr_bytes = bj_ci.slot (sl_no).length;
      185 	     curr_offset = bj_ci.slot (sl_no).offset;
      186 
      187 	     addcharno (p_rec_ptr, prev_bytes) -> RECORD_STRING =
      188 		addcharno (bj_ci_ptr, size (ci_header) * 4 + curr_offset) -> RECORD_STRING;
      189 
      190 	     prev_bytes = prev_bytes + curr_bytes;
      191 
      192 	     if (sl_no = bj_ci.header2.n_slots) & (bj_ci.header2.last_is_contd) /* Is record continued? */
      193 	     then do;
      194 		ci_no = bj_storage_util$next_used_ci (bj_pste_ptr, ci_no);
      195 		sl_no = 1;
      196 	     end;
      197 
      198 	     else more_to_be_gotten = "0"b;
      199 
      200 	end;					/* do while */
      201 
      202 	p_rec_bytes = prev_bytes;
      203 
      204 	call bj_pste_lock$unlock (bj_pste_ptr);
      205 
      206 MAIN_RETURN:
      207 	return;
      208 
      209 
      210 ERROR_RETURN:
      211      proc (error_code);
      212 
      213 dcl  error_code			     fixed bin (35);
      214 
      215 	call bj_report_err (error_code, ME);		/* ....Who is going to unlock?...*/
      216 	if saved_level > -1 then call cu_$level_set (saved_level);
      217 
      218 	goto MAIN_RETURN;
      219      end ERROR_RETURN;
      220 
      221 
      222 GET_CI: proc (get_ci_idx) returns (ptr);
      223 
      224 
      225 dcl  get_ci_idx			     fixed bin (24) uns;
      226 dcl  get_ci_ptr			     ptr;
      227 
      228 
      229 	call file_manager_$get_ci_ptr ((bj_ppte.pf_oid), (get_ci_idx), get_ci_ptr, code);
      230 	if code ^= 0 then call ERROR_RETURN (code);
      231 
      232 	get_ci_ptr = addrel (get_ci_ptr, -(size (ci_header)));
      233 
      234 	return (get_ci_ptr);
      235      end GET_CI;
      236 
      237  	/* BEGIN dm_bj_static.incl.pl1 */
  1     2 /*
  1     3*Modified: 
  1     4*10/04/82 by Lee A. Newcomb:  To change from internal static to external
  1     5*	  static.
  1     6**/
  1     7 
  1     8 dcl dm_system_data_$bj_max_n_journals		fixed bin ext static;
  1     9 dcl dm_system_data_$bj_max_n_processes		fixed bin ext static;
  1    10 dcl dm_system_data_$max_n_transactions     fixed bin ext static;
  1    11 
  1    12 	/* END dm_bj_static.incl.pl1 */
  1    13 
      237 
      238  /*  BEGIN INCLUDE FILE:	dm_bj_ppt.incl.pl1	*/
  2     2 /*
  2     3*Layout of the per-process before journal table and entries.
  2     4*
  2     5*Written by Andre Bensoussan June/July 1982
  2     6*Modified:
  2     7*09/29/82 by Lee A. Newcomb:  To make two default oid cells, pad ppte's
  2     8*	  to account for all used space, and use dm_system_data_ for
  2     9*	  determining dimension of bj_ppt.e.
  2    10**/
  2    11 /* format: style4,indattr,idind33,^indcomtxt */
  2    12 
  2    13 dcl  BJ_PPT_VERSION_1	        fixed bin int static options (constant) init (1);
  2    14 dcl  BJ_PPTE_VERSION_1	        fixed bin int static options (constant) init (1);
  2    15 
  2    16 dcl  bj_ppt_ptr		        ptr;
  2    17 
  2    18 dcl  1 bj_ppt		        based (bj_ppt_ptr) aligned,
  2    19        2 version		        fixed bin,
  2    20        2 max_n_entries	        fixed bin,		/* should be = dm_system_data_$bj_max_n_journals */
  2    21        2 n_entries_used	        fixed bin,		/* # of BJs open in this process */
  2    22        2 highest_ix_used	        fixed bin,		/* max. # of BJs ever opened in this process */
  2    23        2 default_bj,				/* for selecting a txn def. BJ by write_before_mark protocol */
  2    24          3 user_set_oid	        bit (36),		/* explicit user setting via $set_default_bj */
  2    25          3 last_opened_oid	        bit (36),		/* implicit if no user setting, set by open and close */
  2    26 						/* if both zero, use system default BJ */
  2    27        2 process_id		        bit (36),		/* so we don't have to keep calling for it. */
  2    28        2 process_ix		        fixed bin,		/* index into bj_check_in_table */
  2    29        2 mod_list_area	        (100) fixed bin (35), /* for keeping track of ppt mods, not curr. used */
  2    30 
  2    31        2 e		        dim (dm_system_data_$bj_max_n_journals refer (bj_ppt.max_n_entries))
  2    32 			        like bj_ppte;	/* an entry for each BJ open in this process */
  2    33 						/* always make sure bj_ppt.e is on a even word boundary */
  2    34 
  2    35 /* now specify the format of each per-process BJ table entry */
  2    36 
  2    37 dcl  bj_ppte_ptr		        ptr;
  2    38 
  2    39 dcl  1 bj_ppte		        based (bj_ppte_ptr) aligned,
  2    40        2 version		        fixed bin,		/* better be the same for all entries in a bj_ppt */
  2    41        2 bj_uid		        bit (36),		/* UID of the BJ page file */
  2    42        2 pf_oid		        bit (36),		/* OID of the BJ page file */
  2    43        2 n_opening		        fixed bin,		/* how many openings this process has done for this BJ */
  2    44        2 bj_pste_ptr	        ptr,		/* "link" to per-system BJ table entry */
  2    45        2 open_time		        fixed bin (71);	/* used to fill in bj_ppt.default_bj.last_opened_oid */
  2    46 						/* if the last opened BJ is closed */
  2    47 
  2    48 /* END INCLUDE FILE:	bj_ppt.incl.pl1	*/
      238 
      239  /*  BEGIN INCLUDE FILE:	dm_bj_pst.incl.pl1	*/
  3     2 /*
  3     3*Layout of the before journal per-system table header and BJ table entries.
  3     4*
  3     5*Written by Andre Bensoussan 06-15-1982
  3     6*Modified:
  3     7*09/29/82 by Lee A. Newcomb:  To use dm_system_data_ for determining
  3     8*	  dimension of bj_pst.e and force bj_pst.mod_list_area and
  3     9*	  bj_pst.e to even word boundaries.
  3    10*04/27/82 by M. Pandolf:  To add meter space by cutting away from mod_list_area.
  3    11**/
  3    12 /* format: style4,indattr,idind33,^indcomtxt */
  3    13 
  3    14 dcl  BJ_PST_VERSION_1	        fixed bin internal static options (constant) init (1);
  3    15 
  3    16 dcl  bj_pst_ptr		        ptr;
  3    17 
  3    18 dcl  1 bj_pst		        based (bj_pst_ptr) aligned,
  3    19        2 version		        fixed bin,
  3    20        2 pad1		        bit (36),
  3    21        2 lock,
  3    22          3 pid		        bit (36),		/* process_id holding lock */
  3    23          3 event		        bit (36),
  3    24        2 time_of_bootload	        fixed bin (71),	/* for ease of access */
  3    25        2 max_n_entries	        fixed bin,		/* as determined from dm_system_data_$bj_max_n_journals */
  3    26        2 n_entries_used	        fixed bin,		/* current # of BJs open on the system */
  3    27        2 highest_ix_used	        fixed bin,		/* max. # of BJs that has ever been open of the system */
  3    28        2 pn_table_offset	        fixed bin (18) uns,	/* relative offset of bj_pn_table in bj_pst seg. */
  3    29        2 check_in_table_offset        fixed bin (18) uns,	/* ditto for bj_check_in_table */
  3    30        2 buffer_table_offset	        fixed bin (18) uns,	/* ditto for where our BJ buffers are located */
  3    31        2 max_n_buffers	        fixed bin,		/* must be <= to max_n_entries */
  3    32        2 pad2		        bit (36),		/* force next on even word boundary */
  3    33        2 meters,					/* dim (50) fixed bin (71), */
  3    34          3 n_calls_begin_txn          fixed bin (71),	/* meter (1) */
  3    35          3 n_calls_before_image       fixed bin (71),	/* meter (2) */
  3    36          3 n_calls_abort              fixed bin (71),	/* meter (3) */
  3    37          3 n_calls_commit             fixed bin (71),	/* meter (4) */
  3    38          3 n_calls_rb_mark            fixed bin (71),	/* meter (5) */
  3    39          3 n_calls_fm_pc_mark         fixed bin (71),	/* meter (6) */
  3    40          3 n_calls_fm_rbh             fixed bin (71),	/* meter (7) */
  3    41          3 n_calls_rollback           fixed bin (71),	/* meter (8) */
  3    42          3 meter dim (9:50)           fixed bin (71),	/* meter (9) - meter (50) */
  3    43        2 mod_list_area	        (100) fixed bin (35), /* for keeping track of pst mods */
  3    44 
  3    45        2 e		        dim (dm_system_data_$bj_max_n_journals refer (bj_pst.max_n_entries))
  3    46 			        like bj_pste;	/* per system BJ table entries */
  3    47 
  3    48 
  3    49 /* END INCLUDE FILE:	dm_bj_pst.incl.pl1	*/
      239 
      240  /* BEGIN INCLUDE FILE:	dm_bj_pste.incl.pl1	*/
  4     2 
  4     3 /* DESCRIPTION
  4     4*
  4     5*	Layout of the per-system before journal table
  4     6*     entries.  This structure is used to contain information
  4     7*     about a before journal active in a running DMS.  It is
  4     8*     currently also used as the header of a before journal
  4     9*     (see dm_bj_header.incl.pl1).  Version changes to this
  4    10*     structure require either automatic conversion to be set
  4    11*     up, or users to be told to re-create their journals.
  4    12*
  4    13*	Currently, a bj_pste must be 64 words long;  any
  4    14*     future changes must at least make sure a bj_pste is an
  4    15*     even # of words for the alignment of some of its
  4    16*     elements.
  4    17**/
  4    18 
  4    19 /*  HISTORY:
  4    20*
  4    21*Written by Andre Bensoussan, 06/15/82.
  4    22*Modified:
  4    23*08/16/82 by Andre Bensoussan: to add stamp_for_last_ci_put.
  4    24*09/29/82 by Lee A. Newcomb: to fix BJ_PSTE_VERSION_1 and fix some
  4    25*	  alignments.
  4    26*11/01/82 by Andre Bensoussan: to add "stamp_for_last_ci_on_disk",
  4    27*	  "n_bi_still_unsafe", and "n_bi_being_saved".
  4    28*02/08/83 by M. Pandolf: to add append_state structure.
  4    29*03/19/83 by L. A. Newcomb: to fix up some alignments and spelling problems.
  4    30*04/27/83 by M. Pandolf: to add meter structure at end.
  4    31*02/11/85 by Lee A. Newcomb:  Fixed version constant name to agree with its
  4    32*            value of 2; fixed references to page files or PF's; fixed format
  4    33*            of description and history sections.
  4    34*03/07/85 by Lee A. Newcomb:  Changed a pad word to be txn_storage_limit and
  4    35*            expanded on the description for future generations (no
  4    36*            version was made).
  4    37*03/27/85 by Lee A. Newcomb:  Changed one of the unused meters to
  4    38*            n_txn_storage_limit_hits (again without a version change).
  4    39**/
  4    40 /* format: style2,ll79,ind3,^indprocbody,ifthendo,ifthen,^indnoniterdo,^inddcls,dclind5,idind35,linecom */
  4    41 
  4    42 dcl  BJ_PSTE_VERSION_2		fixed bin internal static
  4    43 				options (constant) init (2);
  4    44 
  4    45 dcl  bj_pste_ptr			ptr;
  4    46 
  4    47 /* MUST HAVE EVEN NUMBER OR WORDS */
  4    48 dcl  1 bj_pste			based (bj_pste_ptr) aligned,
  4    49        2 version			fixed bin,
  4    50        2 bj_ix			fixed bin,	/* Index of this entry in bj_pst table */
  4    51        2 lock			aligned,
  4    52          3 pid			bit (36),		/* process ID of lock owner */
  4    53          3 event			bit (36),
  4    54        2 bj_uid			bit (36),		/* UID of BJ file */
  4    55        2 ci_size			fixed bin,	/* In number of bytes */
  4    56        2 max_size			fixed bin,	/* In number of ci's */
  4    57        2 active			bit (1) aligned,	/* 0 means journal not being used */
  4    58        2 time_header_updated		fixed bin (71),
  4    59        2 earliest_meaningful_time	fixed bin (71),	/* time stamp on first valid control interval */
  4    60        2 update_frequency		fixed bin,	/* Not used yet, probably will be how many CIs */
  4    61        2 last_rec_id		bit (36),		/* rec id of the last logical record in journal */
  4    62        2 n_processes		fixed bin,	/* Number of processes using this BJ */
  4    63        2 n_txn			fixed bin,	/* Number of txn in progress using this BJ */
  4    64        2 last_ci_info		aligned,
  4    65          3 last_ci_buffered		fixed bin (24) uns, /* Last ci encached in the buffer */
  4    66          3 last_ci_put		fixed bin (24) uns, /* Last ci put in the BJ */
  4    67          3 last_ci_flushed		fixed bin (24) uns, /* Last ci for which flush initiated */
  4    68          3 last_ci_on_disk		fixed bin (24) uns, /* Last ci of that portion of the BJ known to be ... */
  4    69 						/* .. completely on disk */
  4    70          3 stamp_for_last_ci_put	fixed bin (71),	/* Time stamp associated with the last ci put in the BJ */
  4    71          3 stamp_for_last_ci_on_disk	fixed bin (71),	/* Time stamp associated with the last ci on disk in the BJ */
  4    72        2 n_bi_still_unsafe		fixed bin,	/* number of bi's still not on disk */
  4    73        2 n_bi_being_saved		fixed bin,	/* number of bi's for which flush initiated */
  4    74        2 buffer_offset		fixed bin (18) uns, /* Now allocated in the bj_pst segment */
  4    75        2 txn_storage_limit		fixed bin (35),	/* # of bytes a single txn may write */
  4    76        2 cl			aligned,		/* Circular List */
  4    77          3 origin_ci		fixed bin (24) uns,
  4    78          3 lowest_ci		fixed bin (24) uns,
  4    79          3 highest_ci		fixed bin (24) uns,
  4    80          3 number_ci		fixed bin (24) uns,
  4    81        2 append_state		aligned,
  4    82          3 current_operation		char (4),		/* equal to "appe" when append in progress */
  4    83          3 pending_n_txn		fixed bin,	/* n_txn value when append done */
  4    84          3 pending_last_rec_id	bit (36),		/* last_rec_id value after append done */
  4    85          3 pending_last_element_id	bit (36),		/* last element id after append done */
  4    86          3 txte_rec_id_relp		bit (18),		/* rel ptr into seg containing TXT for txte.pending_bj_rec_id */
  4    87        2 pad_to_even_word1		bit (36) aligned,
  4    88        2 meters			aligned,		/* dim (10) fixed bin (71), */
  4    89          3 n_bi_written		fixed bin (71),	/* meter (1) */
  4    90          3 n_bi_bytes_written		fixed bin (71),	/* meter (2) */
  4    91          3 n_journal_full		fixed bin (71),	/* meter (3) */
  4    92          3 n_successful_recycles	fixed bin (71),	/* meter (4) */
  4    93          3 n_ci_recycled		fixed bin (71),	/* meter (5) */
  4    94          3 n_txn_started		fixed bin (71),	/* meter (6) */
  4    95          3 n_non_null_txn		fixed bin (71),	/* meter (7) */
  4    96          3 n_txn_storage_limit_hits	fixed bin (71),	/* meter (8) */
  4    97          3 meter			(9:10) fixed bin (71),
  4    98 						/* meter (9) - meter (10) */
  4    99        2 pad_to_64_words		(6) bit (36);	/* 64 is even (see below) */
  4   100 
  4   101 
  4   102 /*  END INCLUDE FILE:	dm_bj_pste.incl.pl1	*/
      240 
      241  /* BEGIN INCLUDE FILE:	dm_bj_ci.incl.pl1	*/
  5     2 /*
  5     3*Layout of a BJ control interval excluding the actual data records.
  5     4*
  5     5*Written  by Andre Bensoussan  07/02/1982
  5     6*Modified:
  5     7*08/15/82 by Andre Bensoussan:  For implementing the flush function;
  5     8*	  header2.reserved_1 has been renamed first_rec_id.
  5     9*01nov82  by M. Pandolf to eliminate reserved_2 (after first_rec_id)
  5    10*	  and to add n_bi, and more reserved space.
  5    11**/
  5    12 
  5    13 /* format: style4,indattr,idind33,^indcomtxt */
  5    14 
  5    15 dcl  bj_ci_ptr		        ptr;
  5    16 
  5    17 dcl  1 bj_ci		        based (bj_ci_ptr) aligned, /* Structure of any CI in BJ except CI zero */
  5    18        2 header1		        like ci_header,	/* Standard PF CI header */
  5    19        2 header2,					/* Header specific to BJ CI */
  5    20          3 layout_type	        bit (36),
  5    21          3 first_rec_id	        bit (36),		/* Relevant only if first_is_contn = 1 */
  5    22 
  5    23          3 n_slots		        fixed bin (17) unal,	/* n_slots, first, last in same word ... */
  5    24          3 first_is_contn	        bit (1) unal,	/* ..so that they can be changed all ... */
  5    25          3 last_is_contd	        bit (1) unal,	/* ..at the same time in one instruction */
  5    26          3 pad		        bit (16) unal,
  5    27 
  5    28          3 n_bi		        fixed bin (35),	/* number of BI's in buffer*/
  5    29          3 reserved		        bit (36) dim (4),
  5    30 
  5    31        2 slot		        dim (1:1000),
  5    32          3 offset		        fixed bin (18) uns unal,    /* In number of bytes */
  5    33          3 length		        fixed bin (18) uns unal;    /* In number of bytes */
  5    34 
  5    35 dcl  1 header2		        like bj_ci.header2 aligned; /* Used for size calculation */
  5    36 
  5    37 /* END INCLUDE FILE:	dm_bj_ci.incl.pl1	*/
  5    38 
  5    39 
  5    40 
  5    41 
  5    42 
  5    43 
  5    44 
  5    45 
  5    46 
  5    47 
      241 
      242  /* BEGIN INCLUDE FILE:  dm_ci_header.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*
  6     5*        This include file contains various structures which make up the
  6     6*   header and trailer of a control interval.
  6     7*   
  6     8*   ****  NOTE:  The include file dm_ci.incl.pl1 is heavily dependent ****
  6     9*   ****  on this include file.  When changing this include file,     ****
  6    10*   ****  check dm_ci.incl.pl1 to see if it is affected.              ****
  6    11**/
  6    12 
  6    13 /* HISTORY:
  6    14*Written by Jeffrey D. Ives, 03/02/82.
  6    15*  (Design by Andre Bensoussan and Jeffrey D. Ives)
  6    16*Modified:
  6    17*11/02/84 by Matthew Pierret:  Re-organized so that dm_ci.incl.pl1 and
  6    18*            dm_ci_header.incl.pl1 do not duplicate structures or constants.
  6    19**/
  6    20 
  6    21 /* format: style2,ind3 */
  6    22 
  6    23 /* ci_header is the first four words of a control interval. Its contents
  6    24*   are used to verify that a control interval is in an expected format,
  6    25*   to identify the control interval and the file to which the control
  6    26*   interval belongs, and to maintain information for the synchronization
  6    27*   of disk I/O between DM file control intervals and associated before
  6    28*   journal control intervals.  The first two words are the time stamp for
  6    29*   synchronization; the latter two identify the control interval. */
  6    30 
  6    31      dcl	   ci_header_ptr	      ptr;
  6    32      dcl	   1 ci_header	      aligned based (ci_header_ptr),
  6    33 	     2 stamp	      like ci_stamp,
  6    34 	     2 id		      like ci_id;
  6    35 
  6    36 /* ci_trailer is the last two words of a control interval and must match
  6    37*   the first two words (ci_header.stamp). */
  6    38 
  6    39      dcl	   ci_trailer_ptr	      ptr;
  6    40      dcl	   1 ci_trailer	      like ci_header.stamp aligned based (ci_trailer_ptr);
  6    41 
  6    42 
  6    43 /* ci_stamp is a two-word date/time modified stamp, consisting of:
  6    44*     version: a 9-bit version string for the structure
  6    45*     bj_idx:  before journal index for I/O synchronization
  6    46*     time_modified:  Multics clock time of last modification */
  6    47 
  6    48      dcl	   1 ci_stamp	      aligned based,
  6    49 	     3 version	      bit (9) unal,
  6    50 	     3 bj_idx	      fixed bin (9) uns unal,
  6    51 	     3 time_modified      fixed bin (53) unal;
  6    52 
  6    53      dcl	   CI_HEADER_STAMP_VERSION_1
  6    54 			      bit (9) aligned static options (constant) init ("641"b3);
  6    55 
  6    56 /* ci_id is a two-word identification of the control interval, which
  6    57*   rarely changes and consists of:
  6    58*     uid:   DM file unique identifier
  6    59*     size_code:  the control interval size in bytes, in an encoded
  6    60*                 form (see ci_size_code below).
  6    61*     num:   the control interval number.  0 is the number of the first
  6    62*            control interval of a file. */
  6    63 
  6    64      dcl	   1 ci_id	      aligned based,
  6    65 	     3 uid	      bit (36),
  6    66 	     3 size_code	      bit (9) unal,
  6    67 	     3 num	      fixed bin (27) uns unal;
  6    68 
  6    69 /* ci_size_code is the structure which defines the content of ci_id.size_code.
  6    70*   The size in bytes of a control interval is equal to 
  6    71*   (2 ** ci_size_code.exponent * (64 + 8 * ci_size_code.addon)).  */
  6    72 
  6    73      dcl	   1 ci_size_code	      aligned based,
  6    74 	     2 exponent	      fixed bin (6) uns unal,
  6    75 	     2 addon	      fixed bin (3) uns unal;
  6    76 
  6    77 /* ci_header_chunks is a structure which can be used to update the
  6    78*   ci_stamp or ci_id in one memory cycle. */
  6    79 
  6    80      dcl	   1 ci_header_chunks     aligned based (ci_header_ptr),
  6    81 	     2 stamp	      fixed bin (71),
  6    82 	     2 id		      fixed bin (71);
  6    83 
  6    84 /* ci_trailer_chunk is a structure which can e used to update the
  6    85*   ci_trailer in one memory cycle. */
  6    86 
  6    87      dcl	   1 ci_trailer_chunk     aligned based,
  6    88 	     2 stamp	      fixed bin (71);
  6    89 
  6    90 
  6    91 /*  END INCLUDE FILE:  dm_ci_header.incl.pl1  */
      242 
      243  /*  BEGIN INCLUDE FILE:  dm_ci_parts.incl.pl1  */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*
  7     5*        This include file contains the ci_parts structure.  This structure
  7     6*   is used across the file_manager_ interface to specify the parts of a
  7     7*   control interval to get or put.  If the number_of parts is equal to 0,
  7     8*   modules which take ci_parts interpret this case to mean to do everything
  7     9*   except the actual requested operation, i.e., lock the control interval
  7    10*   but don't get anything.  offset_in_bytes is the 0-originned offset in
  7    11*   bytes from the beginning of the addressable portion of the control interval.
  7    12*   An offset_in_bytes which is in the addressable portion is in error.
  7    13*   Likewise, if offset_in_bytes + length_in_bytes is outside of the addressable
  7    14*   portion, it is in error.
  7    15**/
  7    16 
  7    17 /* HISTORY:
  7    18*Written by Matthew Pierret, 01/28/82.
  7    19*  (01/28/82 Andre Bensoussan, Design.)
  7    20*Modified:
  7    21*11/07/84 by Matthew Pierret:  To add must_be_zero, initial attributes on
  7    22*            automatic storge.
  7    23**/
  7    24 
  7    25 /* format: style2,ind3 */
  7    26 
  7    27      dcl	   1 ci_parts	      aligned based (ci_parts_ptr),
  7    28 	     2 number_of_parts    fixed bin (17),
  7    29 	     2 must_be_zero	      fixed bin,
  7    30 	     2 part	      (cip_number_of_parts refer (ci_parts.number_of_parts)),
  7    31 	       3 offset_in_bytes  fixed bin (17),
  7    32 	       3 length_in_bytes  fixed bin (17),
  7    33 	       3 local_ptr	      ptr;
  7    34 
  7    35      dcl	   ci_parts_ptr	      ptr init (null ());
  7    36      dcl	   cip_number_of_parts    fixed bin (17) init (0);
  7    37 
  7    38 
  7    39 /*  BEGIN INCLUDE FILE:   dm_ci_parts.incl.pl1   */
      243 
      244 
      245      end bj_storage_get;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0915.5  bj_storage_get.pl1                >spec>on>7192.pbf-04/04/85>bj_storage_get.pl1
237          1    01/07/85  0857.8  dm_bj_static.incl.pl1             >ldd>include>dm_bj_static.incl.pl1
238          2    01/07/85  0857.6  dm_bj_ppt.incl.pl1                >ldd>include>dm_bj_ppt.incl.pl1
239          3    01/07/85  0857.7  dm_bj_pst.incl.pl1                >ldd>include>dm_bj_pst.incl.pl1
240          4    04/04/85  0819.1  dm_bj_pste.incl.pl1               >spec>on>7192.pbf-04/04/85>dm_bj_pste.incl.pl1
241          5    01/07/85  0857.3  dm_bj_ci.incl.pl1                 >ldd>include>dm_bj_ci.incl.pl1
242          6    01/07/85  0900.5  dm_ci_header.incl.pl1             >ldd>include>dm_ci_header.incl.pl1
243          7    01/07/85  0900.8  dm_ci_parts.incl.pl1              >ldd>include>dm_ci_parts.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ME                              000000 constant        char(14)                 initial unaligned dcl 80 set ref 215*
RECORD_STRING                          based           char                     unaligned dcl 66 set ref 187* 187
addcharno                                              builtin function         dcl 70 ref 187 187
addrel                                                 builtin function         dcl 70 ref 232
bj_ci                                  based           structure                level 1 dcl 5-17
bj_ci_ptr                       000126 automatic       pointer                  dcl 5-15 set ref 113* 121 160* 164* 171 171 178 178
                                                                                  184 185 187 192 192
bj_oid_util$get_ptr             000014 constant        entry                    external dcl 88 ref 111
bj_ppte                                based           structure                level 1 dcl 2-39
bj_ppte_ptr                     000122 automatic       pointer                  dcl 2-37 set ref 111* 112 117 229
bj_pste                                based           structure                level 1 dcl 4-48
bj_pste_lock$lock               000010 constant        entry                    external dcl 86 ref 117
bj_pste_lock$unlock             000012 constant        entry                    external dcl 87 ref 204
bj_pste_ptr               4            based           pointer                  level 2 in structure "bj_ppte" dcl 2-39 in procedure
                                                                                  "bj_storage_get" ref 112
bj_pste_ptr                     000124 automatic       pointer                  dcl 4-45 in procedure "bj_storage_get" set ref 112*
                                                                                  113 113 117* 121 154* 154 154* 164 164 164 194*
                                                                                  204*
bj_report_err                   000016 constant        entry                    external dcl 89 ref 215
bj_storage_util$distance        000020 constant        entry                    external dcl 90 ref 154 154
bj_storage_util$next_used_ci    000022 constant        entry                    external dcl 92 ref 194
bj_uid                    4            based           bit(36)                  level 2 in structure "bj_pste" dcl 4-48 in procedure
                                                                                  "bj_storage_get" ref 121
bj_uid                    1            based           bit(36)                  level 2 in structure "bj_ppte" dcl 2-39 in procedure
                                                                                  "bj_storage_get" set ref 117*
buffer_offset            32            based           fixed bin(18,0)          level 2 unsigned dcl 4-48 ref 113 164
ci_header                              based           structure                level 1 dcl 6-32 ref 187 232
ci_header_ptr                          automatic       pointer                  dcl 6-31 ref 187 232
ci_id                                  based           structure                level 1 dcl 6-64
ci_no                           000100 automatic       fixed bin(24,0)          unsigned dcl 49 in procedure "bj_storage_get" set
                                                                                  ref 143* 154* 160* 164 194* 194*
ci_no                           000112 automatic       fixed bin(24,0)          level 2 in structure "rec_id" packed unsigned
                                                                                  unaligned dcl 60 in procedure "bj_storage_get" set
                                                                                  ref 143
ci_parts_ptr                    000130 automatic       pointer                  initial dcl 7-35 set ref 7-35*
ci_stamp                               based           structure                level 1 dcl 6-48
cip_number_of_parts             000132 automatic       fixed bin(17,0)          initial dcl 7-36 set ref 7-36*
cleanup                         000114 stack reference condition                dcl 75 ref 150
code                            000101 automatic       fixed bin(35,0)          dcl 50 set ref 229* 230 230*
cu_$level_get                   000024 constant        entry                    external dcl 94 ref 148
cu_$level_set                   000026 constant        entry                    external dcl 95 ref 150 159 161 216
curr_bytes                      000102 automatic       fixed bin(17,0)          dcl 51 set ref 140* 184* 187 187 190
curr_offset                     000103 automatic       fixed bin(17,0)          dcl 52 set ref 185* 187
current_ring                    000111 automatic       fixed bin(3,0)           dcl 58 set ref 147* 159
dm_error_$bj_bad_buffer_uid     000034 external static fixed bin(35,0)          dcl 103 set ref 121*
dm_error_$bj_bad_continuation_flag
                                000040 external static fixed bin(35,0)          dcl 105 set ref 171* 178*
dm_error_$bj_bad_rec_id         000036 external static fixed bin(35,0)          dcl 104 set ref 169*
dm_error_$bj_logic_err          000042 external static fixed bin(35,0)          dcl 106 set ref 167*
error_code                             parameter       fixed bin(35,0)          dcl 213 set ref 210 215*
file_manager_$get_ci_ptr        000030 constant        entry                    external dcl 96 ref 229
first_is_contn            6(18)        based           bit(1)                   level 3 packed unaligned dcl 5-17 ref 171 178
get_ci_idx                             parameter       fixed bin(24,0)          unsigned dcl 225 ref 222 229
get_ci_ptr                      000150 automatic       pointer                  dcl 226 set ref 229* 232* 232 234
get_ring_                       000032 constant        entry                    external dcl 98 ref 147
header1                                based           structure                level 2 dcl 5-17
header2                   4            based           structure                level 2 dcl 5-17
id                        2            based           structure                level 3 dcl 5-17
last_ci_buffered         20            based           fixed bin(24,0)          level 3 unsigned dcl 4-48 ref 164
last_ci_info             20            based           structure                level 2 dcl 4-48
last_ci_put              21            based           fixed bin(24,0)          level 3 unsigned dcl 4-48 set ref 154*
last_is_contd             6(19)        based           bit(1)                   level 3 packed unaligned dcl 5-17 ref 192
length                   14(18)        based           fixed bin(18,0)          array level 3 packed unsigned unaligned dcl 5-17 ref
                                                                                  184
more_to_be_gotten               000104 automatic       bit(1)                   unaligned dcl 53 set ref 152* 153 198*
n_slots                   6            based           fixed bin(17,0)          level 3 packed unaligned dcl 5-17 ref 171 178 192
null                                                   builtin function         dcl 70 ref 7-35
offset                   14            based           fixed bin(18,0)          array level 3 packed unsigned unaligned dcl 5-17 ref
                                                                                  185
p_bj_oid                               parameter       bit(36)                  dcl 40 set ref 35 111*
p_rec_bytes                            parameter       fixed bin(17,0)          dcl 43 set ref 35 202*
p_rec_id                               parameter       bit(36)                  dcl 41 ref 35 142
p_rec_ptr                              parameter       pointer                  dcl 42 ref 35 187
pf_oid                    2            based           bit(36)                  level 2 dcl 2-39 ref 229
prev_bytes                      000105 automatic       fixed bin(17,0)          dcl 54 set ref 139* 171 187 190* 190 202
ptr                                                    builtin function         dcl 70 ref 113 164
rec_id                          000112 automatic       structure                level 1 dcl 60 set ref 142*
rel_distance                    000106 automatic       fixed bin(35,0)          dcl 55 set ref 154* 157 164
saved_level                     000110 automatic       fixed bin(17,0)          initial dcl 57 set ref 57* 148* 150* 161* 216 216*
size                                                   builtin function         dcl 70 ref 187 232
sl_no                           000107 automatic       fixed bin(12,0)          unsigned dcl 56 in procedure "bj_storage_get" set
                                                                                  ref 144* 171 171 171 178 178 184 185 192 195*
sl_no                     0(24) 000112 automatic       fixed bin(12,0)          level 2 in structure "rec_id" packed unsigned
                                                                                  unaligned dcl 60 in procedure "bj_storage_get" set
                                                                                  ref 144
slot                     14            based           structure                array level 2 dcl 5-17
stamp                                  based           structure                level 3 in structure "bj_ci" dcl 5-17 in procedure
                                                                                  "bj_storage_get"
stamp                                  based           structure                level 2 in structure "ci_header" dcl 6-32
                                                                                  in procedure "bj_storage_get"
uid                       2            based           bit(36)                  level 4 dcl 5-17 ref 121
unspec                                                 builtin function         dcl 70 set ref 142*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BJ_PPTE_VERSION_1                      internal static fixed bin(17,0)          initial dcl 2-14
BJ_PPT_VERSION_1                       internal static fixed bin(17,0)          initial dcl 2-13
BJ_PSTE_VERSION_2                      internal static fixed bin(17,0)          initial dcl 4-42
BJ_PST_VERSION_1                       internal static fixed bin(17,0)          initial dcl 3-14
CI_HEADER_STAMP_VERSION_1              internal static bit(9)                   initial dcl 6-53
bj_ppt                                 based           structure                level 1 dcl 2-18
bj_ppt_ptr                             automatic       pointer                  dcl 2-16
bj_pst                                 based           structure                level 1 dcl 3-18
bj_pst_ptr                             automatic       pointer                  dcl 3-16
ci_header_chunks                       based           structure                level 1 dcl 6-80
ci_parts                               based           structure                level 1 dcl 7-27
ci_size_code                           based           structure                level 1 dcl 6-73
ci_trailer                             based           structure                level 1 dcl 6-40
ci_trailer_chunk                       based           structure                level 1 dcl 6-87
ci_trailer_ptr                         automatic       pointer                  dcl 6-39
dm_system_data_$bj_max_n_journals      external static fixed bin(17,0)          dcl 1-8
dm_system_data_$bj_max_n_processes     external static fixed bin(17,0)          dcl 1-9
dm_system_data_$max_n_transactions     external static fixed bin(17,0)          dcl 1-10
header2                                automatic       structure                level 1 dcl 5-35

NAMES DECLARED BY EXPLICIT CONTEXT.
ERROR_RETURN                    000436 constant        entry                    internal dcl 210 ref 121 167 169 171 178 230
GET_CI                          000470 constant        entry                    internal dcl 222 ref 160
MAIN_RETURN                     000435 constant        label                    dcl 206 ref 218
bj_storage_get                  000025 constant        entry                    external dcl 35

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       754        1020     543         764
Length      1352     543        44         316     211           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
bj_storage_get                      144 external procedure  is an external procedure.  
on unit on line 150                  68 on unit               
ERROR_RETURN                            internal procedure  shares stack frame of external procedure bj_storage_get.  
GET_CI                                  internal procedure  shares stack frame of external procedure bj_storage_get.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
bj_storage_get           000100 ci_no                       bj_storage_get
                         000101 code                        bj_storage_get
                         000102 curr_bytes                  bj_storage_get
                         000103 curr_offset                 bj_storage_get
                         000104 more_to_be_gotten           bj_storage_get
                         000105 prev_bytes                  bj_storage_get
                         000106 rel_distance                bj_storage_get
                         000107 sl_no                       bj_storage_get
                         000110 saved_level                 bj_storage_get
                         000111 current_ring                bj_storage_get
                         000112 rec_id                      bj_storage_get
                         000122 bj_ppte_ptr                 bj_storage_get
                         000124 bj_pste_ptr                 bj_storage_get
                         000126 bj_ci_ptr                   bj_storage_get
                         000130 ci_parts_ptr                bj_storage_get
                         000132 cip_number_of_parts         bj_storage_get
                         000150 get_ci_ptr                  GET_CI

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              enable              ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
bj_oid_util$get_ptr           bj_pste_lock$lock             bj_pste_lock$unlock           bj_report_err
bj_storage_util$distance      bj_storage_util$next_used_ci  cu_$level_get                 cu_$level_set
file_manager_$get_ci_ptr      get_ring_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bj_bad_buffer_uid   dm_error_$bj_bad_continuation_flag                          dm_error_$bj_bad_rec_id
dm_error_$bj_logic_err




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     35 000020        57 000032    7   35 000034    7   36 000036       111 000037       112 000050       113 000053
    117 000057       121 000071       139 000105       140 000106       142 000107       143 000112       144 000115
    147 000120       148 000127       150 000136       152 000162       153 000164       154 000166       157 000220
    159 000221       160 000232       161 000234       162 000243       164 000244       167 000257       169 000267
    171 000276       176 000323       178 000324       184 000346       185 000353       187 000356       190 000373
    192 000375       194 000404       195 000416       196 000420       198 000421       200 000422       202 000423
    204 000426       206 000435       210 000436       215 000440       216 000455       218 000467       222 000470
    229 000472       230 000514       232 000520       234 000524


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
