	COMPILATION LISTING OF SEGMENT delete
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 02/27/89  1053.3 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(86-07-17,Houck), approve(86-07-17,MCR7487), audit(86-08-14,Wong),
       13*     install(86-09-04,MR12.0-1148):
       14*     Changed the query_each_sw and -query_all_sw switches so that the
       15*     -query_each and -query_all arguments would be processed as per Multics
       16*     argument processing conventions.
       17*  2) change(88-07-06,TLNguyen), approve(88-07-06,MCR7922),
       18*     audit(88-07-08,Parisek), install(88-07-12,MR12.2-1055):
       19*     Change the delete command to use error_table_$bad_file_name to report an
       20*     error when a null characters string is specified in place of path
       21*     argument.
       22*  3) change(89-01-16,TLNguyen), approve(89-01-27,MCR8047),
       23*     audit(89-02-06,Parisek), install(89-02-27,MR12.3-1015):
       24*     Issue an extra query to protect directories whose safety switches are
       25*     set and a starname is specified in place of a directory path.
       26*                                                   END HISTORY COMMENTS */
       27 
       28 
       29 /* format: style2,idind30,indcomtxt */
       30 
       31 delete:
       32 dl:
       33      procedure options (variable);
       34 
       35 /**** Implements these commands:
       36*
       37*      delete file_paths {-control_args}
       38*
       39*      l_delete file_paths {-control_args}
       40*
       41*      delete_dir directory_paths {-control_args}
       42*
       43*      unlink link_paths {-control_args}
       44*
       45*      and the obsolete delete_force command equivalent to "delete -force".
       46*      Rewritten 01/11/80 by S. Herbst */
       47 /* Modified: 30 June 1980 by G. Palter to fix bug where error messages are meaningless */
       48 /* Fixed bugs and added -absolute_pathname and -entryname 07/19/82 S. Herbst */
       49 /* Fixed nomatch error message 11/08/82 S. Herbst */
       50 /* Fixed "dl ** -qye -long" to print individual queries 12/13/82 S. Herbst */
       51 /* Modified 2/20/83 Jay Pattin for object_type_ */
       52 /* Modified 6/9/83 Jay Pattin. Added l_delete, Changed to use delete_options, added -no_force */
       53 /* 830927 BIM for object_type_ --> fs_util_ */
       54 /* Fixed dl -chase to delete segments 06/25/84 S. Herbst */
       55 /* Modified 12/03/84 by Matthew Pierret: to print helpful message if the
       56*   directory could not be deleted because it contained a protected
       57*   data management file and a transaction is in progress (code
       58*   returned from delete_ is error_table_$no_delete_dir_transaction).
       59*   This means that the actual file deletion will be done when the
       60*   transaction completes. */
       61 /* Modified 850206 MSharpe to replace -fcnt with -inase/inaee */
       62 
       63 /* format: off */
       64  /* BEGIN INCLUDE FILE:  delete_options.incl.pl1 */
  1     2 
  1     3 /* control flag bit string passed to delete_$path and delete_$ptr
  1     4*
  1     5*   Jay Pattin 6/6/83 */
  1     6 
  1     7 declare   1 delete_options,
  1     8           2 force                       bit (1) unaligned,  /* ON = delete w/o asking is safety switch on */
  1     9           2 question                    bit (1) unaligned,  /* ON = ask user if safety switch on */
  1    10           2 directory                   bit (1) unaligned,  /* ON = delete directories */
  1    11           2 segment                     bit (1) unaligned,  /* ON = delete segments */
  1    12           2 link                        bit (1) unaligned,  /* ON = delete links */
  1    13           2 chase                       bit (1) unaligned,  /* ON = delete through links */
  1    14           2 library                     bit (1) unaligned,  /* ON = use installation_tools_ */
  1    15           2 raw                         bit (1) unaligned,  /* ON = use hcs_, not object_type_ */
  1    16           2 mbz                         bit (28) unaligned;
  1    17 
  1    18 /* END INCLUDE FILE:  delete_options.incl.pl1 */
       64 
       65       declare		/* Structure returned by hcs_$status_long */
  2     2 
  2     3 	1 branch_status aligned,				/* automatic: hcs_$status uses a pointer */
  2     4 
  2     5 	  2 type bit(2) unaligned,				/* type of entry: link, segment, dir */
  2     6 	  2 number_names bit(16) unaligned,			/* unused by directory_status_ */
  2     7 	  2 names_rel_pointer bit(18) unaligned,		/* unused by directory_status_ */
  2     8 	  2 date_time_modified bit(36) unaligned,		/* date time modified */
  2     9 	  2 date_time_used bit(36) unaligned,			/* date time entry used */
  2    10 	  2 mode bit(5) unaligned,				/* effective access of caller */
  2    11 	  2 raw_mode bit(5) unaligned,
  2    12 	  2 pad1 bit(8) unaligned,
  2    13 	  2 records bit(18) unaligned,			/* number of records in use */
  2    14 	  2 date_time_dumped bit(36) unaligned,			/* date time last dumped */
  2    15 	  2 date_time_entry_modified bit(36) unaligned,		/* date time entry modified */
  2    16 	  2 lvid bit(36) unaligned,				/* logical volume id */
  2    17 	  2 current_length bit(12) unaligned,			/* number of blocks currently allocated */
  2    18 	  2 bit_count bit(24) unaligned,			/* bit count of entry */
  2    19 	  2 pad3 bit(8) unaligned,
  2    20 	  2 copy_switch bit(1) unaligned,			/* the copy switch */
  2    21 	  2 tpd bit(1) unaligned,				/* transparent to paging device */
  2    22 	  2 mdir bit(1) unaligned,				/* master directory switch */
  2    23 	  2 damaged_switch bit (1) unaligned,			/* true if contents damaged */
  2    24 	  2 synchronized_switch bit (1) unaligned,		/* true if a DM synchronized file */
  2    25 	  2 pad4 bit(5) unaligned,
  2    26 	  2 ring_brackets (0:2) bit(6) unaligned,		/* branch ring brackets */
  2    27 	  2 unique_id bit(36) unaligned,			/* entry unique id */
  2    28 
  2    29 
  2    30 	     /* The types of each class of branch */
  2    31 	segment_type bit(2) aligned internal static initial ("01"b),
  2    32 	directory_type bit(2) aligned internal static initial ("10"b),
  2    33 	msf_type bit(2) aligned internal static initial ("10"b),	/* will eventually be different */
  2    34 	link_type bit(2) aligned internal static initial ("00"b);
  2    35 
  2    36 
       65 
       66  /* BEGIN INCLUDE FILE . . . star_structures.incl.pl1 */
  3     2 
  3     3 /* This include file contains structures for the hcs_$star_,
  3     4*   hcs_$star_list_ and hcs_$star_dir_list_ entry points.
  3     5*
  3     6*   Written 23 October 1978 by Monte Davidoff.
  3     7*   Modified January 1979 by Michael R. Jordan to use unsigned and different pointers for different structures.
  3     8*   Modified June 1981 by C. Hornig to count link pathnames more efficiently.
  3     9**/
  3    10 
  3    11 /* automatic */
  3    12 
  3    13 declare  star_branch_count fixed binary;		/* hcs_$star_list_, hcs_$star_dir_list_: matching branch count */
  3    14 declare  star_entry_count fixed binary;			/* hcs_$star_: number of matching entries */
  3    15 declare  star_entry_ptr pointer;			/* hcs_$star_: pointer to array of entry information */
  3    16 declare  star_list_branch_ptr pointer;			/* hcs_$star_list_, hcs_$star_dir_list_: ptr to array of info */
  3    17 declare  star_link_count fixed binary;			/* hcs_$star_list_, hcs_$star_dir_list_: matching link count */
  3    18 declare  star_linkx fixed binary;			/* hcs_$star_list_, hcs_$star_dir_list_: index into star_links */
  3    19 declare  star_names_ptr pointer;			/* hcs_$star_: pointer to array of entry names */
  3    20 declare  star_list_names_ptr pointer;			/* hcs_$star_list_, hcs_$star_dir_list_: ptr to entry names */
  3    21 declare  star_select_sw fixed binary (3);		/* hcs_$star_list_, hcs_$star_dir_list_: what info to return */
  3    22 
  3    23 /* based */
  3    24 
  3    25 /* hcs_$star_ entry structure */
  3    26 
  3    27 declare 1 star_entries (star_entry_count) aligned based (star_entry_ptr),
  3    28         2 type fixed binary (2) unsigned unaligned,
  3    29 						/* storage system type */
  3    30         2 nnames fixed binary (16) unsigned unaligned,
  3    31 						/* number of names of entry that match star_name */
  3    32         2 nindex fixed binary (18) unsigned unaligned;
  3    33 						/* index of first name in star_names */
  3    34 
  3    35 /* hcs_$star_ name structure */
  3    36 
  3    37 declare  star_names (sum (star_entries (*).nnames)) char (32) based (star_names_ptr);
  3    38 
  3    39 /* hcs_$star_list_ branch structure */
  3    40 
  3    41 declare 1 star_list_branch (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
  3    42         2 type fixed binary (2) unsigned unaligned,
  3    43 						/* storage system type */
  3    44         2 nnames fixed binary (16) unsigned unaligned,
  3    45 						/* number of names of entry that match star_name */
  3    46         2 nindex fixed binary (18) unsigned unaligned,
  3    47 						/* index of first name in star_list_names */
  3    48         2 dtcm bit (36) unaligned,			/* date-time contents of branch were last modified */
  3    49         2 dtu bit (36) unaligned,			/* date-time branch was last used */
  3    50         2 mode bit (5) unaligned,			/* user's access mode to the branch */
  3    51         2 raw_mode bit (5) unaligned,			/* user's ACL access mode */
  3    52         2 master_dir bit (1) unaligned,			/* is branch a master directory */
  3    53         2 pad bit (7) unaligned,
  3    54         2 records fixed binary (18) unsigned unaligned;
  3    55 						/* records used by branch */
  3    56 
  3    57 /* hcs_$star_dir_list_ branch structure */
  3    58 
  3    59 declare 1 star_dir_list_branch (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
  3    60         2 type fixed binary (2) unsigned unaligned,
  3    61 						/* storage system type */
  3    62         2 nnames fixed binary (16) unsigned unaligned,
  3    63 						/* number of names of entry that match star_name */
  3    64         2 nindex fixed binary (18) unsigned unaligned,
  3    65 						/* index of first name in star_list_names */
  3    66         2 dtem bit (36) unaligned,			/* date-time directory entry of branch was last modified */
  3    67         2 pad bit (36) unaligned,
  3    68         2 mode bit (5) unaligned,			/* user's access mode to the branch */
  3    69         2 raw_mode bit (5) unaligned,			/* user's ACL access mode */
  3    70         2 master_dir bit (1) unaligned,			/* is branch a master directory */
  3    71         2 bit_count fixed binary (24) unaligned;
  3    72 						/* bit count of the branch */
  3    73 
  3    74 /* hcs_$star_list_ and hcs_$star_dir_list_ link structure */
  3    75 
  3    76 declare 1 star_links (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
  3    77         2 type fixed binary (2) unsigned unaligned,
  3    78 						/* storage system type */
  3    79         2 nnames fixed binary (16) unsigned unaligned,
  3    80 						/* number of names of entry that match star_name */
  3    81         2 nindex fixed binary (18) unsigned unaligned,
  3    82 						/* index of first name in star_list_names */
  3    83         2 dtem bit (36) unaligned,			/* date-time link was last modified */
  3    84         2 dtd bit (36) unaligned,			/* date-time the link was last dumped */
  3    85         2 pathname_len fixed binary (18) unsigned unaligned,
  3    86 						/* length of the pathname of the link */
  3    87         2 pathname_index fixed binary (18) unsigned unaligned;
  3    88 						/* index of start of pathname in star_list_names */
  3    89 
  3    90 /* hcs_$star_list_ and hcs_$star_dir_list_ name array */
  3    91 
  3    92 declare  star_list_names char (32) based (star_list_names_ptr)
  3    93 	dimension (star_links (star_branch_count + star_link_count).nindex
  3    94 	 + star_links (star_branch_count + star_link_count).nnames
  3    95 	 + divide (star_links (star_branch_count + star_link_count).pathname_len + 31, 32, 17, 0)
  3    96 	   * binary (
  3    97 	     (star_links (star_branch_count + star_link_count).type = star_LINK)
  3    98 	     & (star_select_sw >= star_LINKS_ONLY_WITH_LINK_PATHS), 1));
  3    99 
  3   100 /* hcs_$star_list_ and hcs_$star_dir_list_ link pathname */
  3   101 
  3   102 declare  star_link_pathname char (star_links (star_linkx).pathname_len)
  3   103          based (addr (star_list_names (star_links (star_linkx).pathname_index)));
  3   104 
  3   105 /* internal static */
  3   106 
  3   107 /* star_select_sw values */
  3   108 
  3   109 declare  star_LINKS_ONLY fixed binary (2) internal static options (constant) initial (1);
  3   110 declare  star_BRANCHES_ONLY fixed binary (2) internal static options (constant) initial (2);
  3   111 declare  star_ALL_ENTRIES fixed binary (2) internal static options (constant) initial (3);
  3   112 declare  star_LINKS_ONLY_WITH_LINK_PATHS
  3   113          fixed binary (3) internal static options (constant) initial (5);
  3   114 declare  star_ALL_ENTRIES_WITH_LINK_PATHS
  3   115          fixed binary (3) internal static options (constant) initial (7);
  3   116 
  3   117 /* storage system types */
  3   118 
  3   119 declare  star_LINK fixed binary (2) unsigned internal static options (constant) initial (0);
  3   120 declare  star_SEGMENT fixed binary (2) unsigned internal static options (constant) initial (1);
  3   121 declare  star_DIRECTORY fixed binary (2) unsigned internal static options (constant) initial (2);
  3   122 
  3   123 /* END INCLUDE FILE . . . star_structures.incl.pl1 */
       66 
       67  /* BEGIN INCLUDE FILE: suffix_info.incl.pl1 */
  4     2 /* format: style3,indcomtxt,idind30 */
  4     3 /**** Jay Pattin 2/13/83
  4     4*      M. Pandolf 1984.11.30 to set FS_OBJECT_TYPE_MSF to -multisegment_file
  4     5*
  4     6*      The include file copy_flags.incl.pl1 must be included in any program using this include file.
  4     7*
  4     8*      This structure is returned by the suffix_XXX_$suffix_info subroutines */
  4     9 
  4    10 declare   suffix_info_ptr               ptr;
  4    11 
  4    12 declare   1 suffix_info                 aligned based (suffix_info_ptr),
  4    13             2 version                   char (8),
  4    14             2 type                      char (32) unaligned,
  4    15             2 type_name                 char (32) unaligned,          /* Singular name of the object type, e.g. "mailbox" */
  4    16             2 plural_name               char (32) unaligned,          /* Plural of above, e.g. "mailboxes" */
  4    17             2 flags                     unaligned,
  4    18               3 standard_object         bit (1) unaligned,  /* ON if not an extended object (no suffix_XXX_) */
  4    19               3 extended_acl            bit (1) unaligned,  /* ON if uses extended ACLs, off if regular ACLs */
  4    20               3 has_switches            bit (1) unaligned,  /* ON if supports switches for objects */
  4    21               3 mbz1                    bit (33) unaligned,
  4    22             2 modes                     char (36),          /* correspondence between bits and chars for extended modes */
  4    23             2 max_mode_len              fixed bin,          /* maximum number of modes on an object */
  4    24             2 num_ring_brackets         fixed bin,          /* number of ring brackets on object */
  4    25             2 copy_flags                like copy_flags,    /* See copy_flags.incl.pl1 */
  4    26             2 info_pathname             char (168) unaligned;
  4    27                                                             /* pathname of info segment containing more info */
  4    28 
  4    29 declare   SUFFIX_INFO_VERSION_1         char (8) static options (constant) init ("SUFFIX01");
  4    30 
  4    31 /* This information is returned by the suffix_XXX_$list_switches subroutines */
  4    32 
  4    33 declare   switch_list_ptr               ptr,
  4    34           alloc_switch_count            fixed bin,
  4    35           alloc_switch_name_count       fixed bin;
  4    36 
  4    37 declare   1 switch_list                 aligned based (switch_list_ptr),
  4    38             2 version                   char (8),           /* SWITCH_LIST_VERSION_1 */
  4    39             2 switch_count              fixed bin,          /* total number of switches */
  4    40             2 switch_name_count         fixed bin,          /* total number of names */
  4    41             2 switches                  (alloc_switch_count refer (switch_list.switch_count)),
  4    42               3 name_index              fixed bin,          /* index of first name for this switch */
  4    43               3 name_count              fixed bin,          /* number of names for this switch */
  4    44               3 default_value           bit (1) aligned,    /* default setting for this switch */
  4    45               3 mbz1                    bit (36) aligned,   /* reserved for future use */
  4    46             2 names                     (alloc_switch_name_count refer (switch_list.switch_name_count)) char (32);
  4    47 
  4    48 declare   SWITCH_LIST_VERSION_1         char (8) static options (constant) init ("SWLIST01");
  4    49 
  4    50 declare   (
  4    51           FS_OBJECT_TYPE_SEGMENT        init ("-segment"),
  4    52           FS_OBJECT_TYPE_DIRECTORY      init ("-directory"),
  4    53           FS_OBJECT_TYPE_MSF            init ("-multisegment_file"),
  4    54           FS_OBJECT_TYPE_DM_FILE        init ("-dm_file"),
  4    55           FS_OBJECT_TYPE_LINK           init ("-link")
  4    56           )                             char (32) unaligned int static options (constant);
  4    57 
  4    58 /* END INCLUDE FILE: suffix_info.incl.pl1 */
       67 
       68  /* BEGIN INCLUDE FILE:  copy_flags.incl.pl1 */
  5     2 
  5     3 /* Flags for attributes that should/may be copied by the copy_ subroutine. This include file is
  5     4*   required by suffix_info.incl.pl1 and copy_options.incl.pl1
  5     5*
  5     6*   Jay Pattin 6/23/83 */
  5     7 
  5     8 declare   1 copy_flags                  aligned based,      /* ON means that this attribute may be copied by copy_ */
  5     9           2 names                       bit (1) unaligned,
  5    10           2 acl                         bit (1) unaligned,
  5    11           2 ring_brackets               bit (1) unaligned,
  5    12           2 max_length                  bit (1) unaligned,
  5    13           2 copy_switch                 bit (1) unaligned,
  5    14           2 safety_switch               bit (1) unaligned,
  5    15           2 dumper_switches             bit (1) unaligned,
  5    16           2 entry_bound                 bit (1) unaligned,  /* only for vanilla object segments */
  5    17           2 extend                      bit (1) unaligned,  /* copy_ may append to end of existing object */
  5    18           2 update                      bit (1) unaligned,  /* copy_ may replace contents of existing object */
  5    19           2 mbz                         bit (26) unaligned;
  5    20 
  5    21 /* END INCLUDE FILE:  copy_flags.incl.pl1 */
       68 
       69 
       70 
       71 /* format: on */
       72 	dcl     1 si		        aligned like suffix_info;
       73 
       74 	dcl     1 query_array	        (query_bound) based (query_ptr),
       75 		2 query_dn	        char (168),
       76 		2 query_en	        char (32);
       77 
       78 	dcl     (old_query_ptr, query_ptr)    ptr;
       79 	dcl     (new_query_bound, old_query_bound, query_bound, query_count)
       80 				        fixed bin;
       81 
       82 
       83 	dcl     1 entries		        (ecount) based (entries_ptr),
       84 		2 type		        bit (2) unaligned,
       85 		2 nnames		        bit (16) unaligned,
       86 		2 nindex		        bit (18) unaligned;
       87 
       88 	dcl     names		        (99 /* arbitrary */) char (32) aligned based (names_ptr);
       89 
       90 	dcl     arg		        char (arg_len) based (arg_ptr);
       91 	dcl     fs_util_type	        char (32);
       92 	dcl     (dn, print_path, target_dn)   char (168);
       93 	dcl     (en, myname, starname, target_en, thing, things, what)
       94 				        char (32);
       95 
       96 	dcl     area		        area based (area_ptr);
       97 
       98 	dcl     (absp_sw, brief_sw, chase_sw, chased, force_sw, force_no_type_sw, long_sw, query_sw, query_all_sw,
       99 	        query_each_sw, safety_sw, same_dir_sw, saved_force_sw, some_args, some_matches, yes_sw)
      100 				        bit (1);
      101 
      102 	dcl     (area_ptr, arg_ptr, entries_ptr, names_ptr)
      103 				        ptr;
      104           dcl     QUERY_LIMIT fixed bin int static options (constant) init (20);
      105 
      106 	dcl     (
      107 	        NO_CHASE		        init (0),
      108 	        CHASE		        init (1)
      109 	        )			        fixed bin (1) int static options (constant);
      110 	dcl     (
      111                   NO_STAR_NAME                  init (0),
      112 	        STAR_NAME		        init (1),
      113 	        STAR_STAR_NAME	        init (2)
      114 	        )			        fixed bin (35) int static options (constant);
      115 
      116 	dcl     entry_type		        fixed bin (2);
      117 	dcl     (arg_count, arg_len, ecount, i, j)
      118 				        fixed bin;
      119 	dcl     bit_count		        fixed bin (24);
      120 	dcl     (code, star_code)	        fixed bin (35);
      121 
      122 	dcl     error_table_$action_not_performed
      123 				        fixed bin (35) ext;
      124           dcl     error_table_$bad_file_name    fixed bin (35) ext;
      125 	dcl     error_table_$badopt	        fixed bin (35) ext;
      126 	dcl     error_table_$incorrect_access fixed bin (35) ext;
      127 	dcl     dm_error_$no_delete_dir_transaction
      128 				        fixed bin (35) ext;
      129 	dcl     error_table_$no_info	        fixed bin (35) ext;
      130 	dcl     error_table_$no_s_permission  fixed bin (35) ext;
      131 	dcl     error_table_$noentry	        fixed bin (35) ext;
      132 	dcl     error_table_$nomatch	        fixed bin (35) ext;
      133 	dcl     error_table_$root	        fixed bin (35) ext;
      134 
      135 	dcl     (
      136 	        com_err_,
      137 	        com_err_$suppress_name
      138 	        )			        entry options (variable);
      139 	dcl     check_star_name_$entry        entry (char (*), fixed bin (35));
      140 	dcl     command_query_$yes_no	        entry options (variable);
      141 	dcl     cu_$arg_count	        entry (fixed bin, fixed bin (35));
      142 	dcl     cu_$arg_ptr		        entry (fixed bin, ptr, fixed bin, fixed bin (35));
      143 	dcl     delete_$path	        entry (char (*), char (*), bit (36) aligned, char (*), fixed bin (35));
      144 	dcl     dl_handler_$dblstar	        entry (char (*), char (*), char (*), fixed bin (35));
      145 	dcl     dl_handler_$dirdelete	        entry (char (*), char (*), char (*), fixed bin (35));
      146 	dcl     expand_pathname_	        entry (char (*), char (*), char (*), fixed bin (35));
      147 	dcl     get_system_free_area_	        entry returns (ptr);
      148 	dcl     get_wdir_		        entry returns (char (168));
      149 	dcl     hcs_$get_link_target	        entry (char (*), char (*), char (*), char (*), fixed bin (35));
      150 	dcl     hcs_$get_safety_sw	        entry (char (*), char (*), bit (1), fixed bin (35));
      151 	dcl     hcs_$star_		        entry (char (*), char (*), fixed bin (2), ptr, fixed bin, ptr, ptr,
      152 				        fixed bin (35));
      153 	dcl     hcs_$status_long	        entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
      154 	dcl     hcs_$status_minf	        entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24),
      155 				        fixed bin (35));
      156 	dcl     ioa_		        entry options (variable);
      157 	dcl     installation_tools_$delentry_file
      158 				        entry (char (*), char (*), fixed bin (35));
      159 	dcl     fs_util_$get_type	        entry (character (*), character (*), character (*), fixed binary (35));
      160 	dcl     fs_util_$suffix_info_for_type entry (character (*), pointer, fixed binary (35));
      161 	dcl     pathname_		        entry (char (*), char (*)) returns (char (168));
      162 
      163 	dcl     (addr, codeptr, fixed, index, null, string, substr, unspec)
      164 				        builtin;
      165 
      166 	dcl     (cleanup, linkage_error)      condition;	/*						*/
      167 	myname = "delete";
      168 	thing = "file";
      169 	things = "files";
      170 	string (delete_options) = ""b;
      171 	delete_options.question, delete_options.segment = "1"b;
      172 	force_sw = "0"b;
      173 	go to COMMON;
      174 
      175 l_delete:
      176 ldl:
      177      entry;
      178 
      179 	myname = "l_delete";
      180 	thing = "file";
      181 	things = "files";
      182 	string (delete_options) = ""b;
      183 	force_sw = "1"b;
      184 	delete_options.question, delete_options.force, delete_options.segment, delete_options.library,
      185 	     delete_options.raw = "1"b;
      186 	go to COMMON;
      187 
      188 delete_force:
      189 deleteforce:
      190 df:
      191      entry;					/* OBSOLETE */
      192 
      193 	myname = "delete_force";
      194 	thing = "file";
      195 	things = "files";
      196 	string (delete_options) = ""b;
      197 	force_sw = "1"b;
      198 	delete_options.force, delete_options.segment = "1"b;
      199 	go to COMMON;
      200 
      201 delete_dir:
      202 dd:
      203      entry options (variable);
      204 
      205 	myname = "delete_dir";
      206 	thing = "directory";
      207 	things = "directories";
      208 	string (delete_options) = ""b;
      209 	delete_options.force, delete_options.question, delete_options.directory = "1"b;
      210 	force_sw = "0"b;
      211 	go to COMMON;
      212 
      213 unlink:
      214 ul:
      215      entry options (variable);
      216 
      217 	myname = "unlink";
      218 	thing = "link";
      219 	things = "links";
      220 	string (delete_options) = ""b;
      221 	delete_options.link = "1"b;
      222 	force_sw = "0"b;
      223 
      224 
      225 COMMON:
      226 	call cu_$arg_count (arg_count, code);
      227 	if code ^= 0
      228 	then do;
      229 		call com_err_ (code, myname);
      230 		return;
      231 	     end;
      232 
      233 	si.version = SUFFIX_INFO_VERSION_1;
      234 	entries_ptr, names_ptr, query_ptr = null;
      235 
      236 	absp_sw, brief_sw, chase_sw, force_no_type_sw, long_sw, query_sw, query_all_sw, query_each_sw, some_args = "0"b;
      237 	if delete_options.library
      238 	then force_no_type_sw = "1"b;
      239 
      240 	do i = 1 to arg_count;
      241 
      242 	     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
      243 	     if code ^= 0 then do;
      244 		call com_err_ (code, myname);
      245 		return;
      246 	     end;
      247 
      248 	     if index (arg, "-") ^= 1
      249 	     then some_args = "1"b;
      250 
      251 	     else if arg = "-absolute_pathname" | arg = "-absp"
      252 	     then absp_sw = "1"b;
      253 	     else if arg = "-brief" | arg = "-bf"
      254 	     then brief_sw = "1"b;
      255 	     else if arg = "-chase" & myname = "delete"
      256 	     then chase_sw = "1"b;
      257 	     else if arg = "-no_chase" & myname = "delete"
      258 	     then chase_sw = "0"b;
      259 	     else if arg = "-entryname" | arg = "-etnm"
      260 	     then absp_sw = "0"b;
      261 	     else if arg = "-force" | arg = "-fc"
      262 	     then delete_options.force, force_sw = "1"b;
      263 	     else if arg = "-no_force" | arg = "-nfc"
      264 	     then delete_options.force, force_sw = "0"b;
      265 	     else if arg = "-interpret_as_standard_entry" | arg = "-inase"
      266 	     then force_no_type_sw, delete_options.raw = "1"b;
      267 	     else if arg = "-interpret_as_extended_entry" | arg = "-inaee"
      268 	     then force_no_type_sw, delete_options.raw = "0"b;
      269 	     else if arg = "-long" | arg = "-lg"
      270 	     then long_sw = "1"b;
      271 	     else if arg = "-name" | arg = "-nm"
      272 	     then do;
      273 		     i = i + 1;
      274 		     if i > arg_count
      275 		     then do;
      276 			     call com_err_ (0, myname, "No value specified for -name");
      277 			     return;
      278 			end;
      279 		     some_args = "1"b;
      280 		end;
      281 	     else if arg = "-query_each" | arg = "-qye"
      282 	     then do;
      283 
      284 		     query_each_sw, query_sw = "1"b;
      285 		     query_all_sw = "0"b;
      286 		end;
      287 	     else if arg = "-query_all" | arg = "-qya"
      288 	     then do;
      289 
      290 		     query_all_sw, query_sw = "1"b;
      291 		     query_each_sw = "0"b;
      292 		end;
      293 
      294 
      295 	     else do;
      296 		     call com_err_ (error_table_$badopt, myname, "^a", arg);
      297 		     return;
      298 		end;
      299 	end;
      300 
      301 	if ^some_args
      302 	then do;
      303 		call com_err_$suppress_name (0, myname, "Usage:  ^a ^a_paths {-control_args}", myname, thing);
      304 		return;
      305 	     end;
      306 
      307 	if delete_options.library
      308 	then do;
      309 		on linkage_error
      310 		     begin;			/* check for installation_tools_ access */
      311 			call com_err_ (0, myname, "This command requires access to the installation_tools_ gate.");
      312 			goto MAIN_RETURN;
      313 		     end;
      314 
      315 		arg_ptr = codeptr (installation_tools_$delentry_file);
      316 						/* provoke linkage error */
      317 		revert linkage_error;
      318 	     end;
      319 
      320 	on cleanup
      321 	     begin;
      322 		call star_cleanup;
      323 		if query_ptr ^= null
      324 		then free query_array in (area);
      325 	     end;
      326 
      327 	if query_all_sw
      328 	then do;
      329 		query_bound = QUERY_LIMIT;
      330 		area_ptr = get_system_free_area_ ();
      331 
      332 		allocate query_array in (area) set (query_ptr);
      333 		query_count = 0;
      334 	     end;
      335 	else area_ptr = null;
      336 
      337 	do i = 1 to arg_count;
      338 
      339 	     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
      340 
      341 	     if index (arg, "-") = 1
      342 	     then if arg = "-name" | arg = "-nm"
      343 		then do;
      344 			i = i + 1;
      345 			call cu_$arg_ptr (i, arg_ptr, arg_len, code);
      346 
      347 			dn = get_wdir_ ();
      348 			en, starname = arg;
      349 			go to NO_STARS;
      350 		     end;
      351 		else go to NEXT_ARG;
      352 
      353 	     if arg = ""                         /* a null string such as "", " ", "    "  is specified
      354*		                                  in place of path argument */
      355 	     then do;
      356 		     call com_err_ (error_table_$bad_file_name, myname, """""");
      357 		     go to NEXT_ARG;
      358 		end;
      359 
      360 	     call expand_pathname_ (arg, dn, starname, code);
      361 	     if code ^= 0
      362 	     then do;
      363 		     call com_err_ (code, myname, "^a", arg);
      364 		     go to NEXT_ARG;
      365 		end;
      366 
      367 	     call check_star_name_$entry (starname, star_code);
      368 	     if star_code = NO_STAR_NAME
      369 	     then do;
      370 
      371 		     en = starname;
      372 
      373 NO_STARS:
      374 		     chased = "0"b;
      375 
      376 STATUS:
      377 		     call hcs_$status_minf (dn, en, NO_CHASE, entry_type, bit_count, code);
      378 		     if code ^= 0
      379 		     then do;
      380 PATH_ERROR:
      381 			     if ^brief_sw | (code ^= error_table_$noentry & code ^= error_table_$nomatch)
      382 			     then call com_err_ (code, myname, "^a", pathname_ (dn, en));
      383 			     go to NEXT_ARG;
      384 			end;
      385 
      386 		     if ^force_no_type_sw & entry_type ^= star_LINK
      387 		     then do;
      388 			     call fs_util_$get_type (dn, en, fs_util_type, code);
      389 			     if code = 0 & fs_util_type ^= FS_OBJECT_TYPE_DIRECTORY
      390 			     then do;
      391 				     entry_type = star_SEGMENT;
      392 				     if ^delete_options.segment
      393 				     then do;
      394 					     call fs_util_$suffix_info_for_type (fs_util_type, addr (si), (0));
      395 					     call com_err_ (code, myname, "^a is a ^a. Use delete.",
      396 						pathname_ (dn, en), si.type_name);
      397 					     goto NEXT_ARG;
      398 					end;
      399 				end;
      400 			end;
      401 
      402 		     if entry_type = star_LINK
      403 		     then do;
      404 			     if ^delete_options.link
      405 			     then do;
      406 				     if chase_sw & ^chased
      407 				     then do;
      408 					     call hcs_$get_link_target (dn, en, target_dn, target_en, code);
      409 					     if code ^= 0
      410 					     then do;
      411 						     call com_err_ (code, myname, "Unable to chase link ^a",
      412 							pathname_ (dn, en));
      413 						     go to NEXT_ARG;
      414 						end;
      415 					     dn = target_dn;
      416 					     en = target_en;
      417 					     chased = "1"b;
      418 					     go to STATUS;
      419 					end;
      420 				     call com_err_ (0, myname, "^a is a link. Use unlink.", pathname_ (dn, en));
      421 				     go to NEXT_ARG;
      422 				end;
      423 			end;
      424 
      425 		     else if entry_type = star_DIRECTORY & bit_count = 0
      426 		     then do;
      427 			     if ^delete_options.directory
      428 			     then do;
      429 				     call com_err_ (0, myname, "^a is a directory. Use delete_dir.",
      430 					pathname_ (dn, en));
      431 				     go to NEXT_ARG;
      432 				end;
      433 			     if ^force_sw
      434 			     then do;
      435 				     if ^modify (dn, en)
      436 				     then go to NEXT_ARG;
      437 						/* ^modify prints err msg */
      438 				     if ^query_sw
      439 				     then do;
      440 					     call dl_handler_$dirdelete (myname, dn, en, code);
      441 						/* Do you want to delete the directory dn>en? */
      442 					     if code ^= 0
      443 					     then go to NEXT_ARG;
      444 					end;
      445 				end;
      446 			end;
      447 
      448 		     else do;			/* segment or MSF */
      449 			     if ^delete_options.segment
      450 			     then do;
      451 				     call com_err_ (0, myname,
      452 					"^a is a ^[multisegment file^;segment^]. Use delete.",
      453 					pathname_ (dn, en), entry_type = star_DIRECTORY);
      454 				     go to NEXT_ARG;
      455 				end;
      456 			end;
      457 
      458 		     if absp_sw
      459 		     then print_path = pathname_ (dn, en);
      460 		     else print_path = en;
      461 
      462 		     call delete_one;
      463 
      464 		end;
      465 
      466 	     else if star_code = STAR_NAME | star_code = STAR_STAR_NAME
      467 	     then do;				/* star convention */
      468 
      469 		     if area_ptr = null
      470 		     then area_ptr = get_system_free_area_ ();
      471 		     entries_ptr, names_ptr = null;
      472 
      473 		     if delete_options.link | chase_sw
      474 		     then entry_type = star_ALL_ENTRIES;
      475 		     else entry_type = star_BRANCHES_ONLY;
      476 
      477 		     call hcs_$star_ (dn, starname, entry_type, area_ptr, ecount, entries_ptr, names_ptr, code);
      478 		     if code ^= 0
      479 		     then do;
      480 			     if ^brief_sw | code ^= error_table_$nomatch
      481 			     then call com_err_ (code, myname, "^a", pathname_ (dn, starname));
      482 			     go to NEXT_ARG;
      483 			end;
      484 
      485 		     if (delete_options.directory | star_code = STAR_STAR_NAME) & ^force_sw
      486 		     then do;			/* dd, dl **, or ul **  */
      487 			     if ^modify (dn, starname)
      488 			     then go to NEXT_ARG;
      489 			     if long_sw & ^query_each_sw
      490 			     then do;		/* combine the ** or dd query with -long query */
      491 				     long_sw = "0"b;
      492 				     query_all_sw, query_sw = "1"b;
      493 				     if query_ptr = null
      494 				     then do;
      495 					     query_bound = QUERY_LIMIT;
      496 					     area_ptr = get_system_free_area_ ();
      497 
      498 					     allocate query_array in (area) set (query_ptr);
      499 					     query_count = 0;
      500 					end;
      501 				end;
      502 			     if ^query_sw
      503 			     then do;
      504 				     call dl_handler_$dblstar (myname, dn, starname, code);
      505 						/* Do you want to delete/unlink 'starname' in dn? */
      506 				     if code ^= 0
      507 				     then go to NEXT_ARG;
      508 				end;
      509 
      510 						/* query again for protected dirs because a starname is specified. */
      511 			     if delete_options.directory & (star_code = STAR_NAME | star_code = STAR_STAR_NAME)
      512 			     then delete_options.force = "0"b;
      513 
      514 			end;
      515 
      516 		     some_matches = "0"b;
      517 
      518 		     do j = 1 to ecount;
      519 
      520 			en = names (fixed (entries.nindex (j), 17));
      521 
      522 			if ^force_no_type_sw & entries.type (j) ^= link_type
      523 			then do;
      524 				call fs_util_$get_type (dn, en, fs_util_type, code);
      525 				if code = 0 & fs_util_type ^= FS_OBJECT_TYPE_DIRECTORY
      526 				then entries.type (j) = segment_type;
      527 			     end;
      528 
      529 			if entries.type (j) = link_type
      530 			then do;
      531 				if chase_sw
      532 				then do;
      533 					some_matches = "1"b;
      534 					call hcs_$get_link_target (dn, en, target_dn, target_en, code);
      535 					if code ^= 0
      536 					then do;
      537 						call com_err_ (code, myname, "Unable to chase link ^a",
      538 						     pathname_ (dn, en));
      539 						go to NEXT_MATCH;
      540 					     end;
      541 					dn = target_dn;
      542 					en = target_en;
      543 					call hcs_$status_minf (dn, en, NO_CHASE, entry_type, bit_count, code);
      544 					if entry_type = star_LINK
      545 					     | (entry_type = star_DIRECTORY & bit_count = 0)
      546 					then go to NEXT_MATCH;
      547 				     end;
      548 				else if ^delete_options.link
      549 				then go to NEXT_MATCH;
      550 			     end;
      551 			else if entries.type (j) = segment_type
      552 			then do;
      553 FILE:
      554 				if ^delete_options.segment
      555 				then go to NEXT_MATCH;
      556 			     end;
      557 			else do;			/* directory or MSF */
      558 				call hcs_$status_minf (dn, en, NO_CHASE, entry_type, bit_count, code);
      559 				if bit_count ^= 0
      560 				then go to FILE;
      561 				if ^delete_options.directory
      562 				then go to NEXT_MATCH;
      563 			     end;
      564 
      565 			some_matches = "1"b;
      566 
      567 			if absp_sw
      568 			then print_path = pathname_ (dn, en);
      569 			else print_path = en;
      570 
      571 			call delete_one;
      572 
      573 			if code = error_table_$incorrect_access | code = error_table_$no_info
      574 			then do;
      575 				call star_cleanup;
      576 				go to NEXT_ARG;
      577 			     end;
      578 NEXT_MATCH:
      579 		     end;
      580 
      581 		     call star_cleanup;
      582 
      583 		     if ^some_matches
      584 		     then do;
      585 			     if ^brief_sw
      586 			     then call com_err_ (0, myname, "No ^a selected by starname.  ^a", things,
      587 				     pathname_ (dn, starname));
      588 			     go to NEXT_ARG;
      589 			end;
      590 		end;
      591 	     else call com_err_ (star_code, myname, "^a", pathname_ (dn, starname));
      592 
      593 NEXT_ARG:
      594 	end;
      595 
      596 	if query_all_sw & query_count > 0
      597 	then do;
      598 
      599 		if myname = "delete" | myname = "delete_force"
      600 		then what = "Files";
      601 		else if myname = "delete_dir"
      602 		then what = "Directories";
      603 		else what = "Links";
      604 
      605 		same_dir_sw = "1"b;
      606 		do i = 2 to query_count;
      607 		     if query_dn (i) ^= query_dn (1)
      608 		     then same_dir_sw = "0"b;
      609 		end;
      610 
      611 		call ioa_ ("^a to be deleted^[ in ^a^]:", what, same_dir_sw, query_dn (1));
      612 
      613 		do i = 1 to query_count;
      614 		     if same_dir_sw
      615 		     then call ioa_ ("^3x^a", query_en (i));
      616 		     else call ioa_ ("^3x^a", pathname_ (query_dn (i), query_en (i)));
      617 		end;
      618 
      619 		call command_query_$yes_no (yes_sw, 0, myname, "", "Delete?");
      620 
      621 		if yes_sw
      622 		then do i = 1 to query_count;
      623 			call delete_$path (query_dn (i), query_en (i), string (delete_options), myname, code);
      624 			if code = 0 | code = error_table_$action_not_performed
      625 			then do;
      626 				if long_sw
      627 				then if absp_sw
      628 				     then call ioa_ ("Deleted ^a", pathname_ (query_dn (i), query_en (i)));
      629 				     else call ioa_ ("Deleted ^a", query_en (i));
      630 			     end;
      631 			else if code = dm_error_$no_delete_dir_transaction
      632 			then call com_err_ (code, myname, "^/The contents of ^a ^a^/^a^/^a",
      633 				pathname_ (query_dn (i), query_en (i)), "which do not need to wait until the",
      634 				"transaction commits have been deleted.  The directory itself can be",
      635 				"deleted after the transaction ends.");
      636 
      637 			else call com_err_ (code, myname, "^a", pathname_ (query_dn (i), query_en (i)));
      638 
      639 		     end;
      640 	     end;
      641 
      642 	if query_all_sw
      643 	then do;
      644 		free query_array in (area);
      645 		query_ptr = null;
      646 	     end;
      647 
      648 MAIN_RETURN:
      649 	return;					/*						*/
      650 delete_one:
      651      proc;
      652 
      653 /* This internal procedure remembers the pathname dn>en if -query_all,
      654*   else implements -query_each and -long and deletes the single entry dn>en. */
      655 
      656 	code = 0;
      657 
      658 	if query_all_sw
      659 	then do;
      660 		query_count = query_count + 1;
      661 		if query_count > query_bound
      662 		then call grow_query_array;
      663 		query_dn (query_count) = dn;
      664 		query_en (query_count) = en;
      665 		return;
      666 	     end;
      667 
      668 	saved_force_sw = delete_options.force;
      669 
      670 	if query_each_sw
      671 	then do;
      672 		safety_sw = "0"b;
      673 		if ^delete_options.link
      674 		then do;
      675 			call hcs_$get_safety_sw (dn, en, safety_sw, 0);
      676 			call hcs_$status_long (dn, en, NO_CHASE, addr (branch_status), null, 0);
      677 		     end;
      678 
      679 		call command_query_$yes_no (yes_sw, 0, myname, "",
      680 		     "^[Unlink^;Delete^] ^a ?^[^[ (safety switch is on)^]^[ (copy switch is on)^]^]",
      681 		     delete_options.link, print_path, ^delete_options.link, safety_sw, branch_status.copy_switch);
      682 
      683 		if ^yes_sw
      684 		then return;
      685 
      686 		if safety_sw | branch_status.copy_switch
      687 		then delete_options.force = "1"b;
      688 	     end;
      689 
      690 	call delete_$path (dn, en, string (delete_options), myname, code);
      691 	if code ^= 0
      692 	then do;
      693 		if code = dm_error_$no_delete_dir_transaction
      694 		then call com_err_ (code, myname, "^/The contents of ^a ^a^/^a^/^a", pathname_ (dn, en),
      695 			"which do not need to wait until the",
      696 			"transaction commits have been deleted.  The directory itself can be",
      697 			"deleted after the transaction ends.");
      698 		else if code ^= error_table_$action_not_performed
      699 		then call com_err_ (code, myname, "^a", pathname_ (dn, en));
      700 	     end;
      701 
      702 	else if long_sw & ^query_each_sw
      703 	then call ioa_ ("Deleted ^a ^a", thing, print_path);
      704 
      705 	delete_options.force = saved_force_sw;
      706 
      707      end delete_one;				/*						*/
      708 modify:
      709      proc (a_dn, a_en) returns (bit (1));
      710 
      711 /* This internal procedure returns "1"b if the user has modify on the directory a_dn */
      712 
      713 	dcl     (a_dn, a_en)	        char (*);
      714 
      715 	call hcs_$status_long (a_dn, "", CHASE, addr (branch_status), null, code);
      716 	if code = error_table_$root
      717 	then return ("1"b);				/* ignore and let hardcore catch moderr */
      718 	if code ^= 0 & code ^= error_table_$no_s_permission
      719 	then do;
      720 		call com_err_ (code, myname, "Unable to check access to ^a", a_dn);
      721 		return ("0"b);
      722 	     end;
      723 	if substr (branch_status.mode, 4, 1)
      724 	then return ("1"b);
      725 	call com_err_ (error_table_$incorrect_access, myname, "^a", pathname_ (a_dn, a_en));
      726 	return ("0"b);
      727 
      728      end modify;
      729 
      730 
      731 
      732 grow_query_array:
      733      proc;
      734 
      735 /* This internal procedure doubles the size of query_array */
      736 
      737 	old_query_ptr = query_ptr;
      738 	old_query_bound = query_bound;
      739 	query_bound, new_query_bound = query_bound * 2;
      740 	allocate query_array in (area) set (query_ptr);
      741 	query_bound = old_query_bound;
      742 	unspec (query_ptr -> query_array) = unspec (old_query_ptr -> query_array);
      743 	free old_query_ptr -> query_array in (area);
      744 	query_bound = new_query_bound;
      745 
      746      end grow_query_array;
      747 
      748 
      749 
      750 star_cleanup:
      751      proc;
      752 
      753 	if entries_ptr ^= null
      754 	then free entries in (area);
      755 	if names_ptr ^= null
      756 	then free names in (area);
      757 	entries_ptr, names_ptr = null;
      758 
      759      end star_cleanup;
      760 
      761 
      762      end delete;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    02/27/89  1051.0  delete.pl1                        >spec>install>1015>delete.pl1
64           1    10/14/83  1606.7  delete_options.incl.pl1           >ldd>include>delete_options.incl.pl1
65           2    11/22/82  0955.6  branch_status.incl.pl1            >ldd>include>branch_status.incl.pl1
66           3    06/10/82  1045.5  star_structures.incl.pl1          >ldd>include>star_structures.incl.pl1
67           4    03/05/85  1807.3  suffix_info.incl.pl1              >ldd>include>suffix_info.incl.pl1
68           5    10/14/83  1606.7  copy_flags.incl.pl1               >ldd>include>copy_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CHASE                           000063 constant        fixed bin(1,0)           initial dcl 106 set ref 715*
FS_OBJECT_TYPE_DIRECTORY        000000 constant        char(32)                 initial packed unaligned dcl 4-50 ref 389 525
NO_CHASE                        000056 constant        fixed bin(1,0)           initial dcl 106 set ref 376* 543* 558* 676*
NO_STAR_NAME                           constant        fixed bin(35,0)          initial dcl 110 ref 368
QUERY_LIMIT                            constant        fixed bin(17,0)          initial dcl 104 ref 329 495
STAR_NAME                              constant        fixed bin(35,0)          initial dcl 110 ref 466 511
STAR_STAR_NAME                         constant        fixed bin(35,0)          initial dcl 110 ref 466 485 511
SUFFIX_INFO_VERSION_1           000010 constant        char(8)                  initial packed unaligned dcl 4-29 ref 233
a_dn                                   parameter       char                     packed unaligned dcl 713 set ref 708 715* 720* 725*
                                                                                  725*
a_en                                   parameter       char                     packed unaligned dcl 713 set ref 708 725* 725*
absp_sw                         000542 automatic       bit(1)                   packed unaligned dcl 98 set ref 236* 251* 259* 458
                                                                                  567 626
addr                                                   builtin function         dcl 163 ref 394 394 676 676 715 715
area                                   based           area(1024)               dcl 96 ref 323 332 498 644 740 743 753 755
area_ptr                        000562 automatic       pointer                  dcl 102 set ref 323 330* 332 335* 469 469* 477* 496*
                                                                                  498 644 740 743 753 755
arg                                    based           char                     packed unaligned dcl 90 set ref 248 251 251 253 253
                                                                                  255 257 259 259 261 261 263 263 265 265 267 267
                                                                                  269 269 271 271 281 281 287 287 296* 341 341 341
                                                                                  348 353 360* 363*
arg_count                       000573 automatic       fixed bin(17,0)          dcl 117 set ref 225* 240 274 337
arg_len                         000574 automatic       fixed bin(17,0)          dcl 117 set ref 242* 248 251 251 253 253 255 257 259
                                                                                  259 261 261 263 263 265 265 267 267 269 269 271
                                                                                  271 281 281 287 287 296 296 339* 341 341 341 345*
                                                                                  348 353 360 360 363 363
arg_ptr                         000564 automatic       pointer                  dcl 102 set ref 242* 248 251 251 253 253 255 257 259
                                                                                  259 261 261 263 263 265 265 267 267 269 269 271
                                                                                  271 281 281 287 287 296 315* 339* 341 341 341 345*
                                                                                  348 353 360 363
bit_count                       000600 automatic       fixed bin(24,0)          dcl 119 set ref 376* 425 543* 544 558* 559
branch_status                   000101 automatic       structure                level 1 dcl 2-1 set ref 676 676 715 715
brief_sw                        000543 automatic       bit(1)                   packed unaligned dcl 98 set ref 236* 253* 380 480
                                                                                  585
chase_sw                        000544 automatic       bit(1)                   packed unaligned dcl 98 set ref 236* 255* 257* 406
                                                                                  473 531
chased                          000545 automatic       bit(1)                   packed unaligned dcl 98 set ref 373* 406 417*
check_star_name_$entry          000040 constant        entry                    external dcl 139 ref 367
cleanup                         000604 stack reference condition                dcl 166 ref 320
code                            000601 automatic       fixed bin(35,0)          dcl 120 set ref 225* 227 229* 242* 243 244* 339*
                                                                                  345* 360* 361 363* 376* 378 380 380 380* 388* 389
                                                                                  395* 408* 409 411* 440* 442 477* 478 480 480* 504*
                                                                                  506 524* 525 534* 535 537* 543* 558* 573 573 623*
                                                                                  624 624 631 631* 637* 656* 690* 691 693 693* 698
                                                                                  698* 715* 716 718 718 720*
codeptr                                                builtin function         dcl 163 ref 315
com_err_                        000034 constant        entry                    external dcl 135 ref 229 244 276 296 311 356 363 380
                                                                                  395 411 420 429 451 480 537 585 591 631 637 693
                                                                                  698 720 725
com_err_$suppress_name          000036 constant        entry                    external dcl 135 ref 303
command_query_$yes_no           000042 constant        entry                    external dcl 140 ref 619 679
copy_flags                             based           structure                level 1 dcl 5-8
copy_switch              10(08) 000101 automatic       bit(1)                   level 2 packed packed unaligned dcl 2-1 set ref 679*
                                                                                  686
cu_$arg_count                   000044 constant        entry                    external dcl 141 ref 225
cu_$arg_ptr                     000046 constant        entry                    external dcl 142 ref 242 339 345
delete_$path                    000050 constant        entry                    external dcl 143 ref 623 690
delete_options                  000100 automatic       structure                level 1 packed packed unaligned dcl 1-7 set ref 170*
                                                                                  182* 196* 208* 220* 623 623 690 690
directory                 0(02) 000100 automatic       bit(1)                   level 2 packed packed unaligned dcl 1-7 set ref 209*
                                                                                  427 485 511 561
dl_handler_$dblstar             000052 constant        entry                    external dcl 144 ref 504
dl_handler_$dirdelete           000054 constant        entry                    external dcl 145 ref 440
dm_error_$no_delete_dir_transaction
                                000020 external static fixed bin(35,0)          dcl 127 ref 631 693
dn                              000254 automatic       char(168)                packed unaligned dcl 92 set ref 347* 360* 376* 380*
                                                                                  380* 388* 395* 395* 408* 411* 411* 415* 420* 420*
                                                                                  429* 429* 435* 440* 451* 451* 458* 477* 480* 480*
                                                                                  487* 504* 524* 534* 537* 537* 541* 543* 558* 567*
                                                                                  585* 585* 591* 591* 663 675* 676* 690* 693* 693*
                                                                                  698* 698*
ecount                          000575 automatic       fixed bin(17,0)          dcl 117 set ref 477* 518 753
en                              000452 automatic       char(32)                 packed unaligned dcl 93 set ref 348* 371* 376* 380*
                                                                                  380* 388* 395* 395* 408* 411* 411* 416* 420* 420*
                                                                                  429* 429* 435* 440* 451* 451* 458* 460 520* 524*
                                                                                  534* 537* 537* 542* 543* 558* 567* 569 664 675*
                                                                                  676* 690* 693* 693* 698* 698*
entries                                based           structure                array level 1 packed packed unaligned dcl 83 set ref
                                                                                  753
entries_ptr                     000566 automatic       pointer                  dcl 102 set ref 234* 471* 477* 520 522 525 529 551
                                                                                  753 753 757*
entry_type                      000572 automatic       fixed bin(2,0)           dcl 116 set ref 376* 386 391* 402 425 451 473* 475*
                                                                                  477* 543* 544 544 558*
error_table_$action_not_performed
                                000010 external static fixed bin(35,0)          dcl 122 ref 624 698
error_table_$bad_file_name      000012 external static fixed bin(35,0)          dcl 124 set ref 356*
error_table_$badopt             000014 external static fixed bin(35,0)          dcl 125 set ref 296*
error_table_$incorrect_access   000016 external static fixed bin(35,0)          dcl 126 set ref 573 725*
error_table_$no_info            000022 external static fixed bin(35,0)          dcl 129 ref 573
error_table_$no_s_permission    000024 external static fixed bin(35,0)          dcl 130 ref 718
error_table_$noentry            000026 external static fixed bin(35,0)          dcl 131 ref 380
error_table_$nomatch            000030 external static fixed bin(35,0)          dcl 132 ref 380 480
error_table_$root               000032 external static fixed bin(35,0)          dcl 133 ref 716
expand_pathname_                000056 constant        entry                    external dcl 146 ref 360
fixed                                                  builtin function         dcl 163 ref 520
force                           000100 automatic       bit(1)                   level 2 packed packed unaligned dcl 1-7 set ref 184*
                                                                                  198* 209* 261* 263* 511* 668 686* 705*
force_no_type_sw                000547 automatic       bit(1)                   packed unaligned dcl 98 set ref 236* 237* 265* 267*
                                                                                  386 522
force_sw                        000546 automatic       bit(1)                   packed unaligned dcl 98 set ref 172* 183* 197* 210*
                                                                                  222* 261* 263* 433 485
fs_util_$get_type               000102 constant        entry                    external dcl 159 ref 388 524
fs_util_$suffix_info_for_type   000104 constant        entry                    external dcl 160 ref 394
fs_util_type                    000244 automatic       char(32)                 packed unaligned dcl 91 set ref 388* 389 394* 524*
                                                                                  525
get_system_free_area_           000060 constant        entry                    external dcl 147 ref 330 469 496
get_wdir_                       000062 constant        entry                    external dcl 148 ref 347
hcs_$get_link_target            000064 constant        entry                    external dcl 149 ref 408 534
hcs_$get_safety_sw              000066 constant        entry                    external dcl 150 ref 675
hcs_$star_                      000070 constant        entry                    external dcl 151 ref 477
hcs_$status_long                000072 constant        entry                    external dcl 153 ref 676 715
hcs_$status_minf                000074 constant        entry                    external dcl 154 ref 376 543 558
i                               000576 automatic       fixed bin(17,0)          dcl 117 set ref 240* 242* 273* 273 274* 337* 339*
                                                                                  344* 344 345* 606* 607* 613* 614 616 616 616 616*
                                                                                  621* 623 623 626 626 626 626 629 631 631 631 631
                                                                                  637 637 637 637*
index                                                  builtin function         dcl 163 ref 248 341
installation_tools_$delentry_file
                                000100 constant        entry                    external dcl 157 ref 315
ioa_                            000076 constant        entry                    external dcl 156 ref 611 614 616 626 629 702
j                               000577 automatic       fixed bin(17,0)          dcl 117 set ref 518* 520 522 525 529 551*
library                   0(06) 000100 automatic       bit(1)                   level 2 packed packed unaligned dcl 1-7 set ref 184*
                                                                                  237 307
link                      0(04) 000100 automatic       bit(1)                   level 2 packed packed unaligned dcl 1-7 set ref 221*
                                                                                  404 473 548 673 679* 679
link_type                              constant        bit(2)                   initial dcl 2-1 ref 522 529
linkage_error                   000612 stack reference condition                dcl 166 ref 309 317
long_sw                         000550 automatic       bit(1)                   packed unaligned dcl 98 set ref 236* 269* 489 491*
                                                                                  626 702
mode                      3     000101 automatic       bit(5)                   level 2 packed packed unaligned dcl 2-1 set ref 723
myname                          000462 automatic       char(32)                 packed unaligned dcl 93 set ref 167* 179* 193* 205*
                                                                                  217* 229* 244* 255 257 276* 296* 303* 303* 311*
                                                                                  356* 363* 380* 395* 411* 420* 429* 440* 451* 480*
                                                                                  504* 537* 585* 591* 599 599 601 619* 623* 631*
                                                                                  637* 679* 690* 693* 698* 720* 725*
names                                  based           char(32)                 array dcl 88 ref 520 755
names_ptr                       000570 automatic       pointer                  dcl 102 set ref 234* 471* 477* 520 755 755 757*
new_query_bound                 000240 automatic       fixed bin(17,0)          dcl 79 set ref 739* 744
nindex                    0(18)        based           bit(18)                  array level 2 packed packed unaligned dcl 83 ref 520
null                                                   builtin function         dcl 163 ref 234 323 335 469 471 493 645 676 676 715
                                                                                  715 753 755 757
old_query_bound                 000241 automatic       fixed bin(17,0)          dcl 79 set ref 738* 741
old_query_ptr                   000234 automatic       pointer                  dcl 78 set ref 737* 742 743
pathname_                       000106 constant        entry                    external dcl 161 ref 380 380 395 395 411 411 420 420
                                                                                  429 429 451 451 458 480 480 537 537 567 585 585
                                                                                  591 591 616 616 626 626 631 631 637 637 693 693
                                                                                  698 698 725 725
print_path                      000326 automatic       char(168)                packed unaligned dcl 92 set ref 458* 460* 567* 569*
                                                                                  679* 702*
query_all_sw                    000552 automatic       bit(1)                   packed unaligned dcl 98 set ref 236* 285* 290* 327
                                                                                  492* 596 642 658
query_array                            based           structure                array level 1 packed packed unaligned dcl 74 set ref
                                                                                  323 332 498 644 740 742* 742 743
query_bound                     000242 automatic       fixed bin(17,0)          dcl 79 set ref 323 329* 332 495* 498 644 661 738 739
                                                                                  739* 740 741* 742 742 743 744*
query_count                     000243 automatic       fixed bin(17,0)          dcl 79 set ref 333* 499* 596 606 613 621 660* 660
                                                                                  661 663 664
query_dn                               based           char(168)                array level 2 packed packed unaligned dcl 74 set ref
                                                                                  607 607 611* 616* 616* 623* 626* 626* 631* 631*
                                                                                  637* 637* 663*
query_each_sw                   000553 automatic       bit(1)                   packed unaligned dcl 98 set ref 236* 284* 291* 489
                                                                                  670 702
query_en                 52            based           char(32)                 array level 2 packed packed unaligned dcl 74 set ref
                                                                                  614* 616* 616* 623* 626* 626* 629* 631* 631* 637*
                                                                                  637* 664*
query_ptr                       000236 automatic       pointer                  dcl 78 set ref 234* 323 323 332* 493 498* 607 607
                                                                                  611 614 616 616 616 616 623 623 626 626 626 626
                                                                                  629 631 631 631 631 637 637 637 637 644 645* 663
                                                                                  664 737 740* 742
query_sw                        000551 automatic       bit(1)                   packed unaligned dcl 98 set ref 236* 284* 290* 438
                                                                                  492* 502
question                  0(01) 000100 automatic       bit(1)                   level 2 packed packed unaligned dcl 1-7 set ref 171*
                                                                                  184* 209*
raw                       0(07) 000100 automatic       bit(1)                   level 2 packed packed unaligned dcl 1-7 set ref 184*
                                                                                  265* 267*
safety_sw                       000554 automatic       bit(1)                   packed unaligned dcl 98 set ref 672* 675* 679* 686
same_dir_sw                     000555 automatic       bit(1)                   packed unaligned dcl 98 set ref 605* 607* 611* 614
saved_force_sw                  000556 automatic       bit(1)                   packed unaligned dcl 98 set ref 668* 705
segment                   0(03) 000100 automatic       bit(1)                   level 2 packed packed unaligned dcl 1-7 set ref 171*
                                                                                  184* 198* 392 449 553
segment_type                    005754 constant        bit(2)                   initial dcl 2-1 ref 525 551
si                              000113 automatic       structure                level 1 dcl 72 set ref 394 394
some_args                       000557 automatic       bit(1)                   packed unaligned dcl 98 set ref 236* 248* 279* 301
some_matches                    000560 automatic       bit(1)                   packed unaligned dcl 98 set ref 516* 533* 565* 583
star_ALL_ENTRIES                       constant        fixed bin(2,0)           initial dcl 3-111 ref 473
star_BRANCHES_ONLY                     constant        fixed bin(2,0)           initial dcl 3-110 ref 475
star_DIRECTORY                         constant        fixed bin(2,0)           initial unsigned dcl 3-121 ref 425 451 544
star_LINK                              constant        fixed bin(2,0)           initial unsigned dcl 3-119 ref 386 402 544
star_SEGMENT                           constant        fixed bin(2,0)           initial unsigned dcl 3-120 ref 391
star_code                       000602 automatic       fixed bin(35,0)          dcl 120 set ref 367* 368 466 466 485 511 511 591*
starname                        000472 automatic       char(32)                 packed unaligned dcl 93 set ref 348* 360* 367* 371
                                                                                  477* 480* 480* 487* 504* 585* 585* 591* 591*
string                                                 builtin function         dcl 163 set ref 170* 182* 196* 208* 220* 623 623 690
                                                                                  690
substr                                                 builtin function         dcl 163 ref 723
suffix_info                            based           structure                level 1 dcl 4-12
target_dn                       000400 automatic       char(168)                packed unaligned dcl 92 set ref 408* 415 534* 541
target_en                       000502 automatic       char(32)                 packed unaligned dcl 93 set ref 408* 416 534* 542
thing                           000512 automatic       char(32)                 packed unaligned dcl 93 set ref 168* 180* 194* 206*
                                                                                  218* 303* 702*
things                          000522 automatic       char(32)                 packed unaligned dcl 93 set ref 169* 181* 195* 207*
                                                                                  219* 585*
type                                   based           bit(2)                   array level 2 packed packed unaligned dcl 83 set ref
                                                                                  522 525* 529 551
type_name                12     000113 automatic       char(32)                 level 2 packed packed unaligned dcl 72 set ref 395*
unspec                                                 builtin function         dcl 163 set ref 742* 742
version                         000113 automatic       char(8)                  level 2 dcl 72 set ref 233*
what                            000532 automatic       char(32)                 packed unaligned dcl 93 set ref 599* 601* 603* 611*
yes_sw                          000561 automatic       bit(1)                   packed unaligned dcl 98 set ref 619* 621 679* 683

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
FS_OBJECT_TYPE_DM_FILE                 internal static char(32)                 initial packed unaligned dcl 4-50
FS_OBJECT_TYPE_LINK                    internal static char(32)                 initial packed unaligned dcl 4-50
FS_OBJECT_TYPE_MSF                     internal static char(32)                 initial packed unaligned dcl 4-50
FS_OBJECT_TYPE_SEGMENT                 internal static char(32)                 initial packed unaligned dcl 4-50
SWITCH_LIST_VERSION_1                  internal static char(8)                  initial packed unaligned dcl 4-48
alloc_switch_count                     automatic       fixed bin(17,0)          dcl 4-33
alloc_switch_name_count                automatic       fixed bin(17,0)          dcl 4-33
directory_type                         internal static bit(2)                   initial dcl 2-1
msf_type                               internal static bit(2)                   initial dcl 2-1
star_ALL_ENTRIES_WITH_LINK_PATHS       internal static fixed bin(3,0)           initial dcl 3-114
star_LINKS_ONLY                        internal static fixed bin(2,0)           initial dcl 3-109
star_LINKS_ONLY_WITH_LINK_PATHS        internal static fixed bin(3,0)           initial dcl 3-112
star_branch_count                      automatic       fixed bin(17,0)          dcl 3-13
star_dir_list_branch                   based           structure                array level 1 dcl 3-59
star_entries                           based           structure                array level 1 dcl 3-27
star_entry_count                       automatic       fixed bin(17,0)          dcl 3-14
star_entry_ptr                         automatic       pointer                  dcl 3-15
star_link_count                        automatic       fixed bin(17,0)          dcl 3-17
star_link_pathname                     based           char                     packed unaligned dcl 3-102
star_links                             based           structure                array level 1 dcl 3-76
star_linkx                             automatic       fixed bin(17,0)          dcl 3-18
star_list_branch                       based           structure                array level 1 dcl 3-41
star_list_branch_ptr                   automatic       pointer                  dcl 3-16
star_list_names                        based           char(32)                 array packed unaligned dcl 3-92
star_list_names_ptr                    automatic       pointer                  dcl 3-20
star_names                             based           char(32)                 array packed unaligned dcl 3-37
star_names_ptr                         automatic       pointer                  dcl 3-19
star_select_sw                         automatic       fixed bin(3,0)           dcl 3-21
suffix_info_ptr                        automatic       pointer                  dcl 4-10
switch_list                            based           structure                level 1 dcl 4-37
switch_list_ptr                        automatic       pointer                  dcl 4-33

NAMES DECLARED BY EXPLICIT CONTEXT.
COMMON                          000725 constant        label                    dcl 225 ref 173 186 199 211
FILE                            003567 constant        label                    dcl 553 ref 559
MAIN_RETURN                     004705 constant        label                    dcl 648 ref 312
NEXT_ARG                        004040 constant        label                    dcl 593 ref 341 357 364 383 397 413 421 431 435 442
                                                                                  454 482 487 506 576 588
NEXT_MATCH                      003701 constant        label                    dcl 578 ref 539 544 548 553 561
NO_STARS                        002050 constant        label                    dcl 373 ref 349
PATH_ERROR                      002110 constant        label                    dcl 380
STATUS                          002051 constant        label                    dcl 376 ref 418
dd                              000635 constant        entry                    external dcl 201
delete                          000476 constant        entry                    external dcl 31
delete_dir                      000644 constant        entry                    external dcl 201
delete_force                    000606 constant        entry                    external dcl 188
delete_one                      004706 constant        entry                    internal dcl 650 ref 462 571
deleteforce                     000577 constant        entry                    external dcl 188
df                              000570 constant        entry                    external dcl 188
dl                              000467 constant        entry                    external dcl 31
grow_query_array                005630 constant        entry                    internal dcl 732 ref 661
l_delete                        000533 constant        entry                    external dcl 175
ldl                             000524 constant        entry                    external dcl 175
modify                          005403 constant        entry                    internal dcl 708 ref 435 487
star_cleanup                    005665 constant        entry                    internal dcl 750 ref 322 575 581
ul                              000674 constant        entry                    external dcl 213
unlink                          000703 constant        entry                    external dcl 213

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6462        6572    5755        6472
Length      7200    5755       110         371     504           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
dl                                  845 external procedure  is an external procedure.  
on unit on line 309                  96 on unit               
on unit on line 320                  64 on unit               
delete_one                              internal procedure  shares stack frame of external procedure dl.  
modify                                  internal procedure  shares stack frame of external procedure dl.  
grow_query_array                        internal procedure  shares stack frame of external procedure dl.  
star_cleanup                         66 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
dl                       000100 delete_options              dl
                         000101 branch_status               dl
                         000113 si                          dl
                         000234 old_query_ptr               dl
                         000236 query_ptr                   dl
                         000240 new_query_bound             dl
                         000241 old_query_bound             dl
                         000242 query_bound                 dl
                         000243 query_count                 dl
                         000244 fs_util_type                dl
                         000254 dn                          dl
                         000326 print_path                  dl
                         000400 target_dn                   dl
                         000452 en                          dl
                         000462 myname                      dl
                         000472 starname                    dl
                         000502 target_en                   dl
                         000512 thing                       dl
                         000522 things                      dl
                         000532 what                        dl
                         000542 absp_sw                     dl
                         000543 brief_sw                    dl
                         000544 chase_sw                    dl
                         000545 chased                      dl
                         000546 force_sw                    dl
                         000547 force_no_type_sw            dl
                         000550 long_sw                     dl
                         000551 query_sw                    dl
                         000552 query_all_sw                dl
                         000553 query_each_sw               dl
                         000554 safety_sw                   dl
                         000555 same_dir_sw                 dl
                         000556 saved_force_sw              dl
                         000557 some_args                   dl
                         000560 some_matches                dl
                         000561 yes_sw                      dl
                         000562 area_ptr                    dl
                         000564 arg_ptr                     dl
                         000566 entries_ptr                 dl
                         000570 names_ptr                   dl
                         000572 entry_type                  dl
                         000573 arg_count                   dl
                         000574 arg_len                     dl
                         000575 ecount                      dl
                         000576 i                           dl
                         000577 j                           dl
                         000600 bit_count                   dl
                         000601 code                        dl
                         000602 star_code                   dl

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          tra_ext_1           enable_op           shorten_stack       ext_entry           int_entry
op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
check_star_name_$entry        com_err_                      com_err_$suppress_name        command_query_$yes_no
cu_$arg_count                 cu_$arg_ptr                   delete_$path                  dl_handler_$dblstar
dl_handler_$dirdelete         expand_pathname_              fs_util_$get_type             fs_util_$suffix_info_for_type
get_system_free_area_         get_wdir_                     hcs_$get_link_target          hcs_$get_safety_sw
hcs_$star_                    hcs_$status_long              hcs_$status_minf
installation_tools_$delentry_file                           ioa_                          pathname_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$no_delete_dir_transaction                         error_table_$action_not_performed
error_table_$bad_file_name    error_table_$badopt           error_table_$incorrect_access error_table_$no_info
error_table_$no_s_permission  error_table_$noentry          error_table_$nomatch          error_table_$root




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     31 000466       167 000503       168 000506       169 000511       170 000514       171 000515       172 000521
    173 000522       175 000523       179 000540       180 000543       181 000546       182 000551       183 000552
    184 000554       186 000566       188 000567       193 000613       194 000616       195 000621       196 000624
    197 000625       198 000627       199 000633       201 000634       205 000651       206 000654       207 000657
    208 000662       209 000663       210 000671       211 000672       213 000673       217 000710       218 000713
    219 000716       220 000721       221 000722       222 000724       225 000725       227 000736       229 000740
    230 000755       233 000756       234 000761       236 000765       237 000776       240 001003       242 001013
    243 001030       244 001032       245 001047       248 001050       251 001067       253 001102       255 001115
    257 001132       259 001142       261 001154       263 001171       265 001205       267 001222       269 001236
    271 001251       273 001261       274 001262       276 001265       277 001312       279 001313       280 001315
    281 001316       284 001326       285 001331       286 001332       287 001333       290 001343       291 001346
    292 001347       296 001350       297 001402       299 001403       301 001405       303 001407       304 001442
    307 001443       309 001446       311 001462       312 001507       315 001512       317 001515       320 001516
    322 001532       323 001537       325 001550       327 001551       329 001553       330 001555       332 001564
    333 001572       334 001573       335 001574       337 001576       339 001605       341 001622       344 001646
    345 001647       347 001664       348 001673       349 001707       353 001711       356 001715       357 001740
    360 001741       361 001771       363 001773       364 002025       367 002026       368 002043       371 002045
    373 002050       376 002051       378 002106       380 002110       383 002166       386 002167       388 002173
    389 002217       391 002225       392 002227       394 002232       395 002256       397 002334       402 002335
    404 002337       406 002342       408 002346       409 002375       411 002377       413 002452       415 002453
    416 002456       417 002461       418 002463       420 002464       421 002535       423 002536       425 002537
    427 002543       429 002546       431 002617       433 002620       435 002622       438 002630       440 002632
    442 002656       446 002660       449 002661       451 002664       454 002745       458 002746       460 002771
    462 002774       464 002775       466 002776       469 003002       471 003015       473 003020       475 003030
    477 003032       478 003075       480 003077       482 003153       485 003154       487 003164       489 003172
    491 003176       492 003177       493 003202       495 003206       496 003210       498 003217       499 003225
    502 003226       504 003230       506 003254       511 003256       516 003270       518 003271       520 003301
    522 003316       524 003326       525 003352       529 003366       531 003376       533 003400       534 003402
    535 003431       537 003433       539 003506       541 003507       542 003512       543 003515       544 003552
    547 003560       548 003561       550 003564       551 003565       553 003567       556 003572       558 003573
    559 003630       561 003632       565 003635       567 003637       569 003662       571 003665       573 003666
    575 003674       576 003700       578 003701       581 003703       583 003707       585 003711       588 003767
    590 003770       591 003771       593 004040       596 004042       599 004046       601 004062       603 004072
    605 004075       606 004077       607 004105       609 004117       611 004121       613 004153       614 004163
    616 004213       617 004262       619 004264       621 004320       623 004333       624 004375       626 004402
    629 004460       630 004506       631 004507       637 004615       639 004673       642 004675       644 004677
    645 004703       648 004705       650 004706       656 004707       658 004710       660 004712       661 004713
    663 004717       664 004726       665 004733       668 004734       670 004737       672 004741       673 004742
    675 004745       676 004773       679 005034       683 005123       686 005127       690 005137       691 005171
    693 005173       698 005272       700 005342       702 005343       705 005376       707 005402       708 005403
    715 005421       716 005463       718 005475       720 005501       721 005532       723 005540       725 005551
    726 005622       732 005630       737 005631       738 005633       739 005635       740 005640       741 005646
    742 005650       743 005657       744 005661       746 005663       750 005664       753 005672       755 005701
    757 005710       759 005714


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
