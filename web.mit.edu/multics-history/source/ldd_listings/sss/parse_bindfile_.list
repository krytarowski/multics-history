	COMPILATION LISTING OF SEGMENT parse_bindfile_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 07/16/86  1213.1 mst Wed
	    Options: optimize map

        1 
        2 
        3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
        4 	/*							*/
        5 	/* COMPILED OUTPUT OF SEGMENT  parse_bindfile_.rd              	*/
        6 	/* Compiled by:  reduction_compiler, Version 2.5 of Oct 21, 1985      */
        7 	/* Compiled on:  07/16/86  1213.1 mst Wed                             */
        8 	/*							*/
        9 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       10 
       11 /* ***********************************************************
       12*   *                                                         *
       13*   * Copyright, (C) Honeywell Information Systems Inc., 1984 *
       14*   *                                                         *
       15*   *********************************************************** */
       16 
       17 /* HISTORY COMMENTS:
       18*  1) change(85-09-24,Elhard), approve(85-09-24,MCR7198),
       19*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
       20*     Change error messages to use the caller supplied name instead of
       21*     "parse_bindfile_", changed to produce a reasonable error message when
       22*     parsing a bindfile with no tokens or a zero length bindfile, and to give a
       23*     warning if the obsolete "indirect" keyword is used in a "global" or
       24*     "Global" statement.
       25*                                                   END HISTORY COMMENTS */
       26 
       27 /*++ 
       28*INCLUDE NEXT_STMT	\
       29*INCLUDE LEX	\
       30*INCLUDE ERROR	\
       31*
       32*BEGIN
       33*stmt	/			/[keyword_idx = 0]          /         \
       34*2	/<no-token>		/epilogue		        /RETURN   \
       35*3	/ ;			/LEX		        /stmt     \
       36*4	/<keyword>		/	 	        /KEYWORD  \
       37*5	/<any-token>		/[if keyword_idx = 0
       38*				  then call ERROR (1)]
       39*				NEXT_STMT		        /stmt     \
       40*KEYWORD
       41*6	/Addname			/Addname    LEX	        /ADDNAME  \
       42*
       43*7	/Force_Order : <long_name>	/LEX (2)
       44*				 [arg_ptr = Ptoken;
       45*				  arg_count = 0]	        /ORD_list \
       46*8	/Force_Order		/LEX		        /bad_syntax\
       47*
       48*9	/Global : <globe_arg> ;	/LEX (2)   Global
       49*				 NEXT_STMT	        /stmt     \
       50*10	/Global : <globe_arg>	/LEX (2)   ERROR (7)
       51*				 NEXT_STMT	        /stmt     \
       52*11	/Global			/LEX		        /bad_syntax\
       53*
       54*12	/Ignore : <long_name>	/LEX (2)
       55*				 [arg_ptr = Ptoken;
       56*				  arg_count = 0]	        /ORD_list \
       57*13	/Ignore			/LEX		        /bad_syntax\
       58*14	/No_Table			/LEX		        /noarg_stmt\
       59*
       60*15	/Objectname : <long_name> ;	/LEX (2)   Objectname
       61*				 NEXT_STMT	        /stmt     \
       62*16	/Objectname : <long_name>	/LEX (2)   ERROR(7)
       63*				 NEXT_STMT	        /stmt     \
       64*17	/Objectname		/LEX		        /bad_syntax\
       65*
       66*18	/Order : <long_name>	/LEX (2)
       67*				 [arg_ptr = Ptoken;
       68*				  arg_count = 0]	        /ORD_list \
       69*19	/Order			/LEX		        /bad_syntax\
       70*
       71*20	/Partial_Order : <long_name>	/LEX (2)
       72*				 [arg_ptr = Ptoken;
       73*				  arg_count = 0]	        /ORD_list \
       74*21	/Partial_Order		/LEX		        /bad_syntax\
       75*22	/Perprocess_Static		/LEX		        /noarg_stmt\
       76*
       77*23	/delete : <long_name>	/delete   LEX (2)	        /ENTRY_list\
       78*24	/delete			/LEX		        /bad_syntax\
       79*25	/global : <globe_arg> ;	/LEX (2)   global
       80*				 NEXT_STMT	        /stmt     \
       81*26	/global : <globe_arg>	/LEX (2)   ERROR(7)
       82*				 NEXT_STMT	        /stmt     \
       83*27	/global			/LEX		        /bad_syntax\
       84*28	/indirect : <long_name>	/indirect   LEX (2)	        /ENTRY_list\
       85*29	/indirect			/LEX		        /bad_syntax\
       86*
       87*30	/no_link : <long_name>	/no_link   LEX (2)	        /ENTRY_list\
       88*31	/no_link			/LEX		        /bad_syntax\
       89*
       90*32	/objectname : <long_name> ;	/LEX (2)   objectname
       91*				 NEXT_STMT	        /stmt     \
       92*33	/objectname : <long_name>	/LEX (2)   ERROR (7)
       93*				 NEXT_STMT	        /stmt     \
       94*34	/objectname		/LEX		        /bad_syntax\
       95*35	/retain : <long_name>	/retain   LEX (2)	        /ENTRY_list\
       96*36	/retain			/LEX		        /bad_syntax\
       97*
       98*37	/synonym : <long_name>	/synonym   LEX (2)	        /SEG_list \
       99*38	/synonym			/LEX		        /bad_syntax\
      100*
      101*39	/table			/LEX		        /noarg_stmt\
      102*
      103*
      104*ADDNAME  	/;			/LEX		        /stmt     \
      105*41	/: ;			/LEX (2)		        /stmt     \
      106*42	/: <long_name>		/[an.n_an = 0]   LEX        /ADN_list \
      107*
      108*bad_syntax 
      109*43	/: <any-token>		/LEX ERROR (2) NEXT_STMT    /stmt     \
      110*44	/: <no-token>		/ERROR (3) LEX	        /stmt     \
      111*45	/<any-token>		/ERROR (4) NEXT_STMT        /stmt     \
      112*46	/<no-token>		/ERROR (3)	        /stmt     \
      113*
      114*noarg_stmt
      115*47	/ ;			/LEX  perform_noarg	        /stmt     \
      116*48	/ : ;			/LEX (2)  perform_noarg     /stmt     \
      117*49	/ : <any-token>		/ERROR (6) NEXT_STMT        /stmt     \
      118*50	/ : <no-token>		/ERROR (3) LEX	        /stmt     \
      119*51	/<any-token>		/ERROR (4) NEXT_STMT        /stmt     \
      120*52	/<no-token>		/ERROR (3)	        /stmt     \
      121*
      122*
      123*ADN_list	/<seg_name> ,		/[an.n_an = an.n_an + 1;
      124*				  if an.n_an > an.max_size
      125*				  then call ERROR (13);
      126*				  else an.syn (an.n_an) = token_value]
      127*				 LEX (2)		        
      128*						        /ADN_list \
      129*54	/<seg_name> ;		/[an.n_an = an.n_an + 1;
      130*				  if an.n_an > an.max_size
      131*				  then call ERROR (13);
      132*				  else an.syn (an.n_an) = token_value]
      133*				 NEXT_STMT	        /stmt     \
      134*55	/<seg_name>		/ERROR (7)   NEXT_STMT      /stmt     \
      135*56	/<long_name> ,		/ERROR (8)   LEX(2)	        /ADN_list \
      136*57	/<long_name> ;		/ERROR (8)   NEXT_STMT      /stmt     \
      137*58	/<any-token>		/ERROR (2)   NEXT_STMT      /stmt     \
      138*59	/<no-token>		/ERROR (3)	        /stmt     \
      139*
      140*
      141*ORD_list	/<long_name> ,		/[if segname_too_long
      142*				  then call ERROR (8);
      143*				  else arg_count = arg_count + 1]
      144*				 LEX (2)		        /ORD_list \
      145*61	/<long_name> ;		/[if segname_too_long
      146*				  then call ERROR (8);
      147*				  else arg_count = arg_count + 1]
      148*				 perform_order NEXT_STMT    /stmt     \
      149*62	/<long_name> 		/[if segname_too_long
      150*				  then call ERROR (8);
      151*				  else call ERROR (7)]
      152*				  NEXT_STMT	        /stmt     \
      153*63	/<any-token>		/ERROR (2) 
      154*				 [if arg_count > 0 then do;
      155*				    ARG_list_error = "1"b;
      156*				    call perform_order ();
      157*				  end]	NEXT_STMT	        /stmt     \
      158*64	/<no-token>		/ERROR (3)
      159*				 [if arg_count > 0 then do;
      160*				    ARG_list_error = "1"b;
      161*				    call perform_order ();
      162*				  end]	NEXT_STMT	        /stmt     \
      163*
      164*SEG_list	/<seg_name> ,		/FILL_OPTION_ENTRY
      165*				 LEX (2)		        /SEG_list \
      166*66	/<seg_name> ;		/FILL_OPTION_ENTRY
      167*				 GET_OPTION_TOTALS
      168*				 NEXT_STMT	        /stmt     \
      169*67	/<long_name> ,		/ERROR (8)   LEX (2)        /SEG_list \
      170*68	/<long_name> ;		/ERROR (8)   GET_OPTION_TOTALS
      171*				 NEXT_STMT	        /stmt     \
      172*69	/<long_name> 		/[if segname_too_long
      173*				  then call ERROR (8);
      174*				  else call ERROR (7)]
      175*				  NEXT_STMT	        /stmt     \
      176*70	/<any-token>		/ERROR (2)   NEXT_STMT      /stmt     \
      177*71	/<no-token>		/ERROR (3)	        /stmt     \
      178*
      179*ENTRY_list
      180*72	/<long_name> ,		/[if ^entryname_too_long
      181*				  then call FILL_OPTION_ENTRY]
      182*				 LEX (2)		        /ENTRY_list\
      183*73	/<long_name> ;		/[if ^entryname_too_long
      184*				  then call FILL_OPTION_ENTRY]
      185*				 GET_OPTION_TOTALS
      186*				 NEXT_STMT	        /stmt     \
      187*74	/<long_name>		/ERROR (5)  NEXT_STMT       /stmt     \
      188*75	/<any-token>		/ERROR (2)  NEXT_STMT       /stmt     \
      189*76	/<no-token>		/ERROR (3)	        /stmt     \
      190*
      191*
      192*++*/
      193 /* format: style3,^indnoniterdo */
      194 
      195 /* Parse Bind File - procedure to go through optional bindfile and extract
      196*the bind parameters from it.
      197*
      198*Newly coded by Michael J. Spier, November 23, 1971		*/
      199 /* modified 75.06.24 by M. Weaver to remove no_old_alm keyword */
      200 /* modified 77.08.16 by M. Weaver to add Perprocess_Static keyword */
      201 /* Modified 01/14/81 W. Olin Sibert for new format of input structure, and -force_order */
      202 
      203 /* Rewritten 9/20/84 by M.Sharpe to use the reduction compiler, and implement
      204*     the Ignore and Partial_Order statements 
      205*   Modified 01/23/83 by M.Sharpe to correct problem with unrecognized 
      206*     "no_link" attribute on "global" and "Global" statements.
      207**/
      208 
      209 np:
      210 parse_bindfile_:
      211      proc;
      212 
      213 /*  Automatic  */
      214 
      215 declare	breaks		char (9) var aligned,
      216 	ignored_breaks	char (6) var aligned,
      217 	lex_delims	char (70) var aligned,
      218 	lex_control_chars	char (70) var aligned,
      219 	Linput		fixed bin (21),
      220 	Linput_ignore	fixed bin (21) init (0),
      221 	(Pfirst_stmt_descriptor, Pfirst_token_descriptor, Pinput, Psegment)
      222 			ptr init (null ());
      223 
      224 declare	MYNAME		char (32);
      225 declare	arg_count		fixed bin;
      226 declare	code		fixed bin (35);
      227 declare	(
      228 	ORDER		init (1),
      229 	FORCE_ORDER	init (2),
      230 	PARTIAL_ORDER	init (3)
      231 	)		fixed bin;
      232 declare	order_type	fixed bin init (0);
      233 declare	(i, j, k)		fixed bin;
      234 declare	keyword_idx	fixed bin;
      235 declare	Word_extent	fixed bin init (0);
      236 declare	new_nobj		fixed bin;
      237 declare	obj_idx		fixed bin init (0);
      238 declare	opt_counter	fixed bin;
      239 declare	partial_order_number
      240 			fixed bin init (0);
      241 declare	stmt_error	(17) fixed bin init ((17) (0));
      242 
      243 declare	opt_code		char (1);
      244 
      245 declare	ARG_list_error	bit (1) init ("0"b);
      246 declare	entryname_too_long	bit (1) init ("0"b);
      247 declare	ignore_seen	bit (1) init ("0"b);
      248 declare	MAX_error		bit (1) init ("0"b);
      249 declare	no_parameters	bit (1);
      250 declare	order_error	bit (1) init ("0"b);
      251 declare	Parameters	bit (1);
      252 declare	segname_too_long	bit (1) init ("0"b);
      253 
      254 
      255 declare	(arg_ptr, p, p1, inpp, optp, copyp, areap)
      256 			ptr init (null);
      257 
      258 
      259 /*  Based  */
      260 
      261 declare	arg		char (arg_ptr -> token.Lvalue) based (arg_ptr -> token.Pvalue);
      262 declare	1 acc_ope		aligned based (p),		/* like op but uses acc format char) */
      263 	  2 symb_len	fixed bin (9) unsigned unaligned,
      264 	  2 symb		char (256) unaligned,
      265 	  2 code		char (1) aligned,
      266 	  2 lng		fixed bin;
      267 
      268 declare	Word		(Word_extent) fixed bin based;
      269 declare	reset		bit (2313) based (p);
      270 
      271 
      272 /*  Static  */
      273 
      274 /* format: off */
      275 
      276 declare	1 error_control_table
      277 			(25) internal static options (constant),
      278 	  2 severity	fixed bin (17) init ((8) 3, 1, 2, (12) 3, (3) 1),
      279 	  2 Soutput_stmt	bit (1) unaligned
      280 			init ((4) ("1"b), "0"b, "1"b, "1"b, "0"b, (3) ("1"b), (12) ("0"b), (2) ("1"b)),
      281 	  2 message	char (90) varying init (
      282 /*   1  */ "'^a ' is not a legal keyword.",
      283 /*   2  */ "Invalid parameter.  '^a'",
      284 /*   3  */ "Bindfile ends with an incomplete statement.",
      285 /*   4  */ "Keyword not delimited by colon.  '^a'",
      286 /*   5  */ "Entryname is longer than 255 characters  '^a.'",
      287 /*   6  */ "This statement does not accept parameters.",
      288 /*   7  */ "Improper delimiter after '^a'.",
      289 /*   8  */ "Possible segment name is longer than 32 characters  '^a'.",
      290 /*   9  */ "'indirect:' is an obsolete keyword.
      291 It should be replaced by 'retain:'.",
      292 /*  10  */ "Duplicate statement.  Statement is ignored.",
      293 /*  11  */ "This statement must follow an 'objectname:' statement.",
      294 /*  12  */ "'Order', 'Force_Order', and 'Partial_Order' are mutually exclusive.",
      295 /*  13  */ "Too many addnames supplied.  Maximum of 128 addnames is allowed.",
      296 /*  14  */ "Duplicate objectname statement for ^a.",
      297 /*  15  */ "Objectname ^a repeated in this statement.",
      298 /*  16  */ "Objectname ^a not found in any archive.",
      299 /*  17  */ "Zero-length object ^a mentioned in objectname statement.",
      300 /*  18  */ "Zero-length object ^a mentioned in Order/Force_Order/Partial_Order statement.",
      301 /*  19  */ "Objectname ^a mentioned in 'objectname' statement but not in Force_Order statement",
      302 /*  20  */ "Objectname ^a mentioned both in Ignore and Order/Force_Order/Partial_Order statements.",
      303 /*  21  */ "Objectname ^a mentioned both in Ignore and objectname statements.",
      304 /*  22  */ "Objectname ^a not mentioned in Order statement.",
      305 /*  23  */ "Objectname ^a ignored because of zero bitcount.",
      306 /*  24  */ "'indirect' is an obsolete Global option
      307 It should be replaced by 'retain'.",
      308 /*  25  */ "'indirect' is an obsolete global option
      309 It should be replaced by 'retain'."),
      310 	  2 brief_message	char (1) varying init ((25) (" "));
      311 						/* brief messages aren't used */
      312 
      313 /* format: on */
      314 
      315 declare	ERROR_OUTPUT	char (12) int static init ("error_output");
      316 
      317 declare	(
      318 	Addname_idx	init (1),
      319 	FOrder_idx	init (2),
      320 	Global_idx	init (3),
      321 	Ignore_idx	init (4),
      322 	No_Table_idx	init (5),
      323 	Objectname_idx	init (6),
      324 	Order_idx		init (7),
      325 	POrder_idx	init (8),
      326 	PStatic_idx	init (9),
      327 	delete_idx	init (10),
      328 	global_idx	init (11),
      329 	indirect_idx	init (12),
      330 	no_link_idx	init (13),
      331 	objectname_idx	init (14),
      332 	retain_idx	init (15),
      333 	synonym_idx	init (16),
      334 	table_idx		init (17)
      335 	)		fixed bin;
      336 
      337 declare	(
      338 	DUP_stmt		init (10),
      339 	NO_obj		init (11),
      340 	EXCLUSIVE_stmt	init (12),
      341 	DUP_objectname	init (14),
      342 	NO_such_seg	init (16),
      343 	SKIP_stmt		init (99)
      344 	)		fixed bin internal static;
      345 
      346 /*  External  */
      347 
      348 declare	error_table_$zero_length_seg
      349 			external fixed bin (35);
      350 
      351 /*  Builtin  */
      352 
      353 declare	(addr, addrel, bin, bit, collate, dimension, divide, fixed, max, null, rel, size, substr)
      354 			builtin;
      355 
      356 
      357 /*  Entry  */
      358 
      359 declare	com_err_		entry () options (variable),
      360 	ioa_$ioa_stream	entry () options (variable),
      361 	lex_string_$lex	entry (ptr, fixed bin (21), fixed bin (21), ptr, bit (*), char (*), char (*), char (*),
      362 			char (*), char (*), char (*) var aligned, char (*) var aligned, char (*) var aligned,
      363 			char (*) var aligned, ptr, ptr, fixed bin (35)),
      364 	lex_string_$init_lex_delims
      365 			entry (char (*), char (*), char (*), char (*), char (*), bit (*), char (*) var aligned,
      366 			char (*) var aligned, char (*) var aligned, char (*) var aligned),
      367 	temp_mgr_$reserve	entry (pointer),
      368 	translator_temp_$get_segment
      369 			entry (char (*), ptr, fixed bin (35)),
      370 	translator_temp_$release_all_segments
      371 			entry (ptr, fixed bin (35));
      372 
      373 
      374 /*  Condition  */
      375 
      376 declare	cleanup		condition;
      377 
      378 	on cleanup
      379 	     begin;
      380 		if Psegment ^= null
      381 		then call translator_temp_$release_all_segments (Psegment, code);
      382 		bx_$fatal_error = 1;
      383 	     end;
      384 
      385 	if bx_$debug = 1
      386 	then MYNAME = "parse_bindfile_";
      387 	else MYNAME = bx_$caller;
      388 	inpp = bx_$inpp;
      389 	NTOTAL = inp.ntotal;			/* used for allocating copy area */
      390 	NOBJ = inp.nobj;				/* ditto */
      391 	bx_$bound_segname = inp.bound_seg_name;		/* remember in case of abort */
      392 	if inp.bindfilep = null | inp.bindfile_bc = 0
      393 	then do;
      394 	     bx_$optp = null;			/* indicate there are no bind options */
      395 	     bx_$addname = 0;
      396 	     bx_$adnp = null;
      397 	     if ^inp.zeroseg_seen
      398 	     then return;
      399 
      400 	     copyp = bx_$freep;			/* allocate area for archive reorder */
      401 	     call temp_mgr_$reserve (addrel (copyp, size (inp)));
      402 						/* allocate with respect to NTOTAL and NOBJ */
      403 	     call CHECK_CONFLICTS;			/* make new structure, removing zero-length segments */
      404 	     return;
      405 	end;
      406 
      407 
      408 	call translator_temp_$get_segment (MYNAME, Psegment, code);
      409 						/* reduction compiler needs this */
      410 	if code ^= 0
      411 	then do;
      412 	     call com_err_ (code, MYNAME, "Could not get temp segment.  Report to maintainer.");
      413 	     bx_$fatal_error = 1;
      414 	     return;
      415 	end;
      416 
      417 	SERROR_CONTROL = "11"b;			/* use long error messages every time */
      418 	call INIT_PARSE;
      419 	if Linput = 0
      420 	then do;
      421 	     call com_err_ (error_table_$zero_length_seg, MYNAME, inp.bindfile_name);
      422 	     goto Return;
      423 	end;
      424 
      425 	if bx_$brief = 1
      426 	then MIN_PRINT_SEVERITY = 2;			/* Don't print warnings if -brief was specified.  */
      427 
      428 	ignored_breaks = substr (collate, 10, 5) || " ";
      429 	breaks = ignored_breaks || ",:;";
      430 	call lex_string_$init_lex_delims ("""", """", "/*", "*/", ";", "10"b, breaks, ignored_breaks, lex_delims,
      431 	     lex_control_chars);
      432 	call lex_string_$lex (Pinput, Linput, Linput_ignore, Psegment, "1100"b, """", """", "/*", "*/", ";", breaks,
      433 	     ignored_breaks, lex_delims, lex_control_chars, Pfirst_stmt_descriptor, Pfirst_token_descriptor, code);
      434 
      435 	Pthis_token = Pfirst_token_descriptor;
      436 
      437 	if code ^= 0
      438 	then do;
      439 	     if Pthis_token = null
      440 	     then do;
      441 		if code = error_table_$zero_length_seg
      442 		then call com_err_ (0, MYNAME, "No tokens found in bindfile. ^a", inp.bindfile_name);
      443 		else call com_err_ (code, MYNAME);
      444 		go to Return;
      445 	     end;					/*	     if code = error_table_$no_stmt_delim | code = error_table_$unbalanced_quotes 
      446*	     error messages which can specify the location of the error are printed during the semantic analysis */
      447 	end;
      448 
      449 	call SEMANTIC_ANALYSIS ();
      450 Return:
      451 	if Psegment ^= null
      452 	then call translator_temp_$release_all_segments (Psegment, code);
      453 	return;
      454 
      455 
      456 /*****************************************************************************/
      457 
      458 /*  These 4 entries are auxiliary scanner/lexical routines */
      459 
      460 FUNCTIONS:
      461      proc returns (bit (1) aligned);			/* this entry returns "1"b if a valid parameter has been specified
      462*   to the Global/global keywords; "0"b otherwise.  */
      463 
      464 globe_arg:
      465      entry returns (bit (1) aligned);
      466 
      467 	if token_value = "delete" | token_value = "indirect" | token_value = "no_link" | token_value = "retain"
      468 	then return ("1"b);
      469 
      470 	else return ("0"b);
      471 
      472 
      473 /*  This entry returns "1"b if the current token consists of only alphanumeric
      474*    characters allowed in an entryname.  It also performs asemantic function.
      475*    If the token is longer than 32 characters the segname_too_long flag is
      476*    set; if it is longer than 255 characters the entryname_too_long flag is
      477*    also set.  This reduces the number of reductins necessary for parsing the
      478*    bindfile.  */
      479 
      480 long_name:
      481      entry returns (bit (1) aligned);
      482 
      483 	segname_too_long, entryname_too_long = "0"b;
      484 
      485 
      486 	if token.Lvalue > 32
      487 	then segname_too_long = "1"b;
      488 	if token.Lvalue > 255
      489 	then entryname_too_long = "1"b;
      490 
      491 	return ("1"b);
      492 
      493 
      494 /*  This entry returns "1"b if the current token is an appropriate segment name */
      495 
      496 seg_name:
      497      entry returns (bit (1) aligned);
      498 
      499 	segname_too_long = "0"b;
      500 
      501 	if token.Lvalue > 32
      502 	then do;
      503 	     segname_too_long = "1"b;
      504 	     call ERROR (8);
      505 	     return ("0"b);
      506 	end;
      507 
      508 	return ("1"b);
      509 
      510 
      511 /*  This entry determines if the current token is a valid keyword.  If so
      512*    keyword_idx is set accordingly; otherwise, keyword_idx is set to 0 and
      513*    "0"b is returned.  Some semantic analysis is also perfomed here.  If a
      514*    token is recognized as a keyword, but one whose presence in the
      515*    bindfile constitues a semantic error, e.g., duplicate master keyword,
      516*    the proper error message is issued here and "0"b is returned.  The
      517*    reduction routine ignores the entire statement if "0"b is returned; it
      518*    issues errors only if keyword_idx is set to 0.   */
      519 
      520 keyword:
      521      entry () returns (bit (1) aligned);
      522 
      523 	if token_value = "Addname"
      524 	then keyword_idx = Addname_idx;
      525 	else if token_value = "Force_Order"
      526 	then keyword_idx = FOrder_idx;
      527 	else if token_value = "Global"
      528 	then keyword_idx = Global_idx;
      529 	else if token_value = "Ignore"
      530 	then keyword_idx = Ignore_idx;
      531 	else if token_value = "No_Table"
      532 	then keyword_idx = No_Table_idx;
      533 	else if token_value = "Objectname"
      534 	then keyword_idx = Objectname_idx;
      535 	else if token_value = "Order"
      536 	then keyword_idx = Order_idx;
      537 	else if token_value = "Partial_Order"
      538 	then keyword_idx = POrder_idx;
      539 	else if token_value = "Perprocess_Static"
      540 	then keyword_idx = PStatic_idx;
      541 	else if token_value = "delete"
      542 	then keyword_idx = delete_idx;
      543 	else if token_value = "global"
      544 	then keyword_idx = global_idx;
      545 	else if token_value = "indirect"
      546 	then keyword_idx = indirect_idx;
      547 	else if token_value = "no_link"
      548 	then keyword_idx = no_link_idx;
      549 	else if token_value = "objectname"
      550 	then keyword_idx = objectname_idx;
      551 	else if token_value = "retain"
      552 	then keyword_idx = retain_idx;
      553 	else if token_value = "synonym"
      554 	then keyword_idx = synonym_idx;
      555 	else if token_value = "table"
      556 	then keyword_idx = table_idx;
      557 	else return ("0"b);
      558 
      559 	if stmt_error (keyword_idx) = 0
      560 	then return ("1"b);
      561 	else if stmt_error (keyword_idx) = SKIP_stmt
      562 	then return ("0"b);				/* Skip these silently */
      563 
      564 	call ERROR (stmt_error (keyword_idx));
      565 	return ("0"b);
      566 
      567 
      568      end FUNCTIONS;
      569 
      570 
      571 /*****************************************************************************/
      572 
      573 /*  The following are the semantic analysis routines.  The entries beginning
      574*    with "Addname" up to "table" correspond to bindfile keywords.  Others are
      575*    auxiliary routines.  */
      576 
      577 ACTION:
      578      proc;
      579 
      580 
      581 perform_order:
      582      entry ();
      583 
      584 	if keyword_idx = Order_idx
      585 	then call Order ();
      586 	else if keyword_idx = FOrder_idx
      587 	then call Force_Order ();
      588 	else if keyword_idx = POrder_idx
      589 	then call Partial_Order ();
      590 	else if keyword_idx = Ignore_idx
      591 	then call Ignore ();
      592 
      593 	else ;					/* should never happen */
      594 	return;
      595 
      596 
      597 perform_noarg:
      598      entry ();
      599 
      600 	if keyword_idx = No_Table_idx
      601 	then call No_Table ();
      602 	else if keyword_idx = PStatic_idx
      603 	then call Perprocess_Static ();
      604 	else if keyword_idx = table_idx
      605 	then call table ();
      606 
      607 	return;
      608 
      609 
      610 Addname:
      611      entry ();
      612 
      613 
      614 	stmt_error (Addname_idx) = DUP_stmt;
      615 	Parameters = "1"b;
      616 	bx_$addname = 1;
      617 
      618 	return;
      619 
      620 
      621 Force_Order:
      622      entry ();
      623 
      624 	stmt_error (FOrder_idx) = DUP_stmt;		/* Don't use this again */
      625 	stmt_error (Order_idx) = EXCLUSIVE_stmt;	/* And this one is mutually exclusive with Force_Order */
      626 	stmt_error (POrder_idx) = EXCLUSIVE_stmt;	/* ... and so's this one */
      627 
      628 	order_type = FORCE_ORDER;
      629 	call REORDER_ARCHIVE ();
      630 
      631 	return;
      632 
      633 
      634 Global:
      635      entry ();
      636 
      637 	stmt_error (Global_idx) = DUP_stmt;
      638 	if token_value = "delete"
      639 	then g_delete = "d";			/* This scheme was kept from the original program */
      640 	else if token_value = "retain"
      641 	then g_retain = "r";			/* because it is integral to other parts of the */
      642 	else if token_value = "no_link"
      643 	then g_nolink = "l";			/* binder software */
      644 	else if token_value = "indirect"
      645 	then do;
      646 	     call ERROR (24);
      647 	     g_indirect = "i";
      648 	end;
      649 	else do;
      650 	     call ERROR (2);
      651 	     return;
      652 	end;
      653 
      654 	Parameters = "1"b;
      655 
      656 	return;
      657 
      658 
      659 Ignore:
      660      entry ();
      661 
      662 /*  The reduction routine checks the syntax of the "Ignore" statement;
      663*	     if it's OK, it sets arg_ptr to the addr of the 1st parameter and arg_count
      664*	     to the number of parameters.  Because the parameters are separated by commans,
      665*	     every other token is skipped when getting the next parameter */
      666 
      667 	stmt_error (Ignore_idx) = DUP_stmt;
      668 	ignore_seen = "1"b;
      669 	p1 = Pthis_token;				/* save it */
      670 	Pthis_token = arg_ptr;			/* allows the correct component names to appear in
      671*						   the error messages in the followin loop */
      672 
      673 
      674 	do i = 1 to arg_count;			/* Lookup input structure to match parameter */
      675 
      676 	     if arg_ptr -> token.Lvalue > 32
      677 	     then goto next_ignore_arg;
      678 
      679 	     do j = 1 to bx_$ncomp;
      680 		p = addr (inp.obj (j));
      681 		if obj.filename = arg
      682 		then goto ignore_it;
      683 	     end;
      684 
      685 	     call ERROR (NO_such_seg);		/* the segment is not among the components specified by user */
      686 	     goto next_ignore_arg;
      687 
      688 ignore_it:
      689 	     if (obj.to_be_ignored & obj.bitcount ^= 0)
      690 	     then do;				/* Duplicated in Ignore statement */
      691 		call ERROR (15);
      692 		goto next_ignore_arg;
      693 	     end;
      694 
      695 	     obj.to_be_ignored = "1"b;
      696 next_ignore_arg:
      697 	     Pthis_token, arg_ptr = arg_ptr -> token.Pnext -> token.Pnext;
      698 						/* skip the delimiter between two args */
      699 						/* see opening comments for ignore */
      700 	end;
      701 	Pthis_token = p1;				/* restore to end of Ignore stmt */
      702 
      703 	return;
      704 
      705 
      706 No_Table:
      707      entry ();
      708 
      709 /*  The option table entries are filled by FILL_OPTION_ENTRY by the
      710*	     reduction routine after we return from here.   */
      711 
      712 	stmt_error (No_Table_idx) = DUP_stmt;
      713 	option.g_notable = "t";
      714 	no_parameters = "0"b;
      715 	return;
      716 
      717 
      718 Objectname:
      719      entry ();
      720 
      721 	stmt_error (Objectname_idx) = DUP_stmt;
      722 	if token.Lvalue > 32
      723 	then call ERROR (8);
      724 	else bx_$bound_segname = token_value;
      725 
      726 	return;
      727 
      728 
      729 Order:
      730      entry ();
      731 
      732 	stmt_error (Order_idx) = DUP_stmt;
      733 	stmt_error (FOrder_idx) = EXCLUSIVE_stmt;
      734 	stmt_error (POrder_idx) = EXCLUSIVE_stmt;
      735 
      736 	if bx_$force_order ^= 0
      737 	then order_type = FORCE_ORDER;		/* Order becomes Force_Order if -force_order
      738*							   is specified in the command line */
      739 	else order_type = ORDER;
      740 	call REORDER_ARCHIVE ();
      741 
      742 	return;
      743 
      744 
      745 Partial_Order:
      746      entry ();
      747 
      748 	stmt_error (POrder_idx) = DUP_stmt;
      749 	stmt_error (FOrder_idx) = EXCLUSIVE_stmt;
      750 	stmt_error (Order_idx) = EXCLUSIVE_stmt;
      751 
      752 	order_type = PARTIAL_ORDER;
      753 	call REORDER_ARCHIVE ();
      754 
      755 	return;
      756 
      757 
      758 Perprocess_Static:
      759      entry ();
      760 
      761 	stmt_error (PStatic_idx) = DUP_stmt;
      762 	bx_$perprocess_static = 1;
      763 	Parameters = "1"b;
      764 	return;
      765 
      766 
      767 delete:
      768      entry ();
      769 
      770 /*  The option table entries are filled by FILL_OPTION_ENTRY by the
      771*	     reduction routine after we return from here.   */
      772 
      773 	stmt_error (delete_idx) = DUP_stmt;
      774 	opt_counter = 0;
      775 	opt_code = "d";
      776 	no_parameters = "0"b;
      777 	return;
      778 
      779 
      780 global:
      781      entry ();
      782 
      783 	stmt_error (global_idx) = DUP_stmt;
      784 	if token_value = "delete"
      785 	then op.delete = "d";
      786 	else if token_value = "retain"
      787 	then op.retain = "r";
      788 	else if token_value = "no_link"
      789 	then op.no_link = "l";
      790 	else if token_value = "indirect"
      791 	then do;
      792 	     call ERROR (25);
      793 	     op.indirect = "i";
      794 	end;
      795 	else do;
      796 	     call ERROR (2);
      797 	     return;
      798 	end;
      799 
      800 	no_parameters = "0"b;
      801 
      802 	return;
      803 
      804 
      805 indirect:
      806      entry ();
      807 
      808 /*  The option table entries are filled by FILL_OPTION_ENTRY by the
      809*	     reduction routine after we return from here.   */
      810 
      811 	stmt_error (indirect_idx) = DUP_stmt;
      812 	if bx_$brief = 0
      813 	then call ERROR (9);			/* This is an obsolete keyword; it now functions like "retain" */
      814 	opt_counter = 0;
      815 	opt_code = "i";
      816 	no_parameters = "0"b;
      817 	return;
      818 
      819 
      820 no_link:
      821      entry ();
      822 
      823 /*  The option table entries are filled by FILL_OPTION_ENTRY by the
      824*	     reduction routine after we return from here.   */
      825 
      826 	stmt_error (no_link_idx) = DUP_stmt;
      827 	opt_counter = 0;
      828 	opt_code = "l";
      829 	no_parameters = "0"b;
      830 	return;
      831 
      832 
      833 objectname:
      834      entry ();
      835 
      836 	stmt_error (objectname_idx) = 0;
      837 	call CLOSE_ENTRY;				/* start a new option table entry, etc. */
      838 
      839 	if segname_too_long
      840 	then do;
      841 	     call ERROR (8);
      842 	     goto skip_objname;
      843 	end;
      844 	do obj_idx = 1 to bx_$ncomp;
      845 	     if token_value = inp.obj (obj_idx).filename
      846 	     then go to OPEN_ENTRY;
      847 	end;
      848 	call ERROR (NO_such_seg);
      849 
      850 	goto skip_objname;
      851 
      852 OPEN_ENTRY:
      853 	if inp.obj (obj_idx).bitcount = 0
      854 	then do;
      855 	     call ERROR (17);			/* zero-length segs can't be specified in any statements */
      856 	     goto skip_objname;
      857 	end;
      858 
      859 	if inp.obj (obj_idx).option ^= "0"b
      860 	then do;					/* Another objectname statement for this obj specified earlier */
      861 	     call ERROR (DUP_objectname);
      862 skip_objname:					/* Ignore any attributes pertaining to this rejected */
      863 	     stmt_error (delete_idx),			/*   objectname.  The errors cause the corresponding */
      864 		stmt_error (global_idx),		/*   statements to be ignored (See keyword FUNCTION) */
      865 		stmt_error (indirect_idx),		/*   until the next objectname statement is seen */
      866 		stmt_error (no_link_idx),		/*   when all are reset to 0  */
      867 		stmt_error (retain_idx), stmt_error (synonym_idx), stmt_error (table_idx) = SKIP_stmt;
      868 
      869 	     return;
      870 	end;
      871 
      872 	op.n_retain, op.n_indirect, op.n_nolink, op.n_options, op.n_synonyms, op.n_delete = 0;
      873 						/* reset structure */
      874 	op.table, op.retain, op.indirect, op.no_link, op.delete = " ";
      875 						/* ... */
      876 	inp.obj (obj_idx).objectname_stmt = "1"b;	/* Now it cannot be Ignore'd or omitted
      877*						   from Order / Force_Order lists */
      878 	no_parameters = "1"b;			/* indicate no params specified yet */
      879 
      880 	stmt_error (delete_idx) = 0;			/* reset errors for attribute statements, since any errors */
      881 	stmt_error (global_idx) = 0;			/*   were for previous object and we've got a new one now */
      882 	stmt_error (indirect_idx) = 0;
      883 	stmt_error (no_link_idx) = 0;
      884 	stmt_error (retain_idx) = 0;
      885 	stmt_error (synonym_idx) = 0;
      886 	stmt_error (table_idx) = 0;
      887 
      888 
      889 /* put objectname into structure, tag it as synonym */
      890 
      891 	opt_counter = 0;
      892 	opt_code = "s";				/* pretend it's a synonym */
      893 	call FILL_OPTION_ENTRY;
      894 	op.n_synonyms = 1;
      895 
      896 	return;
      897 
      898 
      899 retain:
      900      entry ();
      901 
      902 /*  The option table entries are filled by FILL_OPTION_ENTRY by the
      903*	     reduction routine after we return from here.   */
      904 
      905 	stmt_error (retain_idx) = DUP_stmt;
      906 	opt_counter = 0;
      907 	opt_code = "r";
      908 	no_parameters = "0"b;
      909 	return;
      910 
      911 synonym:
      912      entry ();
      913 
      914 /*  The option table entries are filled by FILL_OPTION_ENTRY by the
      915*	     reduction routine after we return from here.   */
      916 
      917 	stmt_error (synonym_idx) = DUP_stmt;
      918 	opt_counter = 0;
      919 	opt_code = "s";
      920 	no_parameters = "0"b;
      921 	return;
      922 
      923 
      924 table:
      925      entry ();
      926 
      927 	stmt_error (table_idx) = DUP_stmt;
      928 	op.table = "t";
      929 	no_parameters = "0"b;
      930 	return;
      931 
      932 
      933 REORDER_ARCHIVE:
      934      entry ();
      935 
      936 /*  The argument processing is same as Ignore */
      937 
      938 	k = 0;
      939 	order_error = ARG_list_error;
      940 	p1 = Pthis_token;				/* save it */
      941 	Pthis_token = arg_ptr;			/*  This will allow the correct component name to be 
      942*						    printed in error messages inside this loop */
      943 
      944 	do i = 1 to arg_count;			/* Lookup input structure to match parameter */
      945 
      946 	     if arg_ptr -> token.Lvalue > 32
      947 	     then goto next_arg;
      948 	     do j = 1 to bx_$ncomp;
      949 		p = addr (inp.obj (j));
      950 		if obj.filename = arg
      951 		then goto match_found;
      952 	     end;
      953 
      954 	     call ERROR (NO_such_seg);
      955 	     order_error = "1"b;
      956 	     goto next_arg;
      957 
      958 match_found:
      959 	     if obj.flag = "1"b
      960 	     then do;				/* repeated in order-ing statement */
      961 		call ERROR (15);
      962 		order_error = "1"b;
      963 		goto next_arg;
      964 	     end;
      965 
      966 	     if obj.bitcount = 0
      967 	     then do;				/* zero-length obj has no business here */
      968 		call ERROR (18);
      969 		order_error = "1"b;
      970 		goto next_arg;
      971 	     end;
      972 
      973 	     obj.flag = "1"b;
      974 	     k = k + 1;				/* increment index */
      975 	     obj.new_order = k;			/* remember the new order index */
      976 next_arg:
      977 	     arg_ptr, Pthis_token = arg_ptr -> token.Pnext -> token.Pnext;
      978 						/* skip the delimiter between two args */
      979 	end;
      980 
      981 	Pthis_token = p1;				/* restore to end of the Order stmt */
      982 
      983 	if order_type = PARTIAL_ORDER
      984 	then partial_order_number = k;		/* the number of objects so far "ordered".  The rest will be
      985*						   given order numbers, beginning with partial_order_number +1,
      986*						   in the order they appear in the input structure */
      987 
      988 	if order_error
      989 	then bx_$fatal_error = 1;
      990 	return;
      991 
      992 
      993 FILL_OPTION_ENTRY:
      994      entry ();
      995 
      996 	opt_counter = opt_counter + 1;
      997 	op.n_options = op.n_options + 1;
      998 	p = addr (op.opes (op.n_options));
      999 	reset = "0"b;				/* want trailer nulls instead of blanks */
     1000 	acc_ope.symb_len = token.Lvalue;
     1001 	substr (acc_ope.symb, 1, token.Lvalue) = token_value;
     1002 	acc_ope.code = opt_code;
     1003 	acc_ope.lng = token.Lvalue + 1;
     1004 
     1005 	return;
     1006 
     1007 GET_OPTION_TOTALS:
     1008      entry ();
     1009 
     1010 /* routine to set the counter for the particular option */
     1011 
     1012 	if keyword_idx = no_link_idx
     1013 	then n_nolink = n_nolink + opt_counter;
     1014 	else if keyword_idx = indirect_idx
     1015 	then n_indirect = n_indirect + opt_counter;
     1016 	else if keyword_idx = retain_idx
     1017 	then n_retain = n_retain + opt_counter;
     1018 	else if keyword_idx = delete_idx
     1019 	then n_delete = n_delete + opt_counter;
     1020 	else if keyword_idx = synonym_idx
     1021 	then n_synonyms = n_synonyms + opt_counter;	/*	 else;		should never happen.  */
     1022 
     1023 	return;
     1024 
     1025 
     1026 
     1027 epilogue:
     1028      entry ();
     1029 
     1030 	call CLOSE_ENTRY;
     1031 	if order_type > 0 | ignore_seen | zeroseg_seen
     1032 	then call CHECK_CONFLICTS;
     1033 
     1034 	if MERROR_SEVERITY > 2
     1035 	then do;
     1036 	     bx_$fatal_error = 1;
     1037 	     return;
     1038 	end;
     1039 
     1040 	if Parameters = "0"b
     1041 	then do;
     1042 	     bx_$adnp = null;			/* ... */
     1043 	     bx_$addname = 0;			/* ... */
     1044 	     Word_extent = fixed (rel (optp), 18) - fixed (rel (areap), 18) + 128;
     1045 	     areap -> Word (*) = 0;			/* reset allocated table area  */
     1046 	end;
     1047 
     1048 	call temp_mgr_$reserve (addr (op.opes (opt_counter + 1)));
     1049 						/* Mark the extent of the option table */
     1050 	return;
     1051 
     1052 
     1053 CLOSE_ENTRY:
     1054      entry ();
     1055 
     1056 	stmt_error (delete_idx),			/* These statements can't appear again BEFORE */
     1057 	     stmt_error (global_idx),			/*    the next objectname stmt */
     1058 	     stmt_error (indirect_idx), stmt_error (no_link_idx), stmt_error (retain_idx), stmt_error (synonym_idx),
     1059 	     stmt_error (table_idx) = NO_obj;
     1060 
     1061 
     1062 	if no_parameters
     1063 	then /* virgin entry */
     1064 	     do;
     1065 	     if obj_idx ^= 0
     1066 	     then inp.obj (obj_idx).option = "0"b;	/* reset option pointer */
     1067 	     return;
     1068 	end;
     1069 
     1070 	if obj_idx ^= 0
     1071 	then inp.obj (obj_idx).option = bit (bin (fixed (rel (optp), 18) - fixed (rel (areap), 18), 18), 18);
     1072 	Parameters = "1"b;
     1073 	no_parameters = "1"b;			/* indicate no objectname parameters */
     1074 	if op.n_options = 1
     1075 	then do;					/* No options; just the objectname used as synonym.  */
     1076 	     op.n_options, op.n_synonyms, op.n_options = 0;
     1077 	end;
     1078 	if obj_idx > 0
     1079 	then optp = addr (op.opes (op.n_options + 1));	/* prepare pointer to next option structure */
     1080 	obj_idx = 0;
     1081 
     1082 	return;
     1083 
     1084 
     1085 /*
     1086* *   It is the responsibility of this routine to examine the inp structure,
     1087* *   verifying that the Ignore, Order, Force_Order and Partial_Order
     1088* *   statements have been used in a consistent fashion.
     1089* *   If no errors are detected, a new copy of the inp structure
     1090* *   is built (in the area reserved and pointed to by copyp) and the
     1091* *   desired objectnames are placed in the new structure, in the
     1092* *   desired order.
     1093* *
     1094* *   It is assumed that the caller has already checked the ignore, order and
     1095* *   zeroseg_seen flags, so this routine is not called when it is not needed.
     1096* */
     1097 
     1098 CHECK_CONFLICTS:
     1099      entry ();
     1100 
     1101 declare	erring_token_value	char (32);
     1102 
     1103 
     1104 	j = 0;					/*  reset index that is used if no Order-ing statements in bindfile   */
     1105 
     1106 	new_nobj = 0;				/*   reset counter of kept object segments   */
     1107 
     1108 	do i = 1 to bx_$ncomp;			/*   examine every objectname known, looking for errors   */
     1109 
     1110 	     p = addr (inp.obj (i));
     1111 	     erring_token_value = obj.filename;
     1112 
     1113 	     if obj.bitcount = 0 /* Warn about zero-lengt segs except where . . . */
     1114 		& obj.new_order = 0 /* 1) there's a coflict with order (already handled) */
     1115 		& ^obj.objectname_stmt /* 2) there's a conflict with objectname stmt (ditto) */ & bx_$brief = 0
     1116 	     then do;				/* 3) they've asked us to keep quiet */
     1117 		MERROR_SEVERITY = max (1, MERROR_SEVERITY);
     1118 		call ioa_$ioa_stream (ERROR_OUTPUT, "^/WARNING 23^/" || error_control_table.message (23) || "^/",
     1119 		     erring_token_value);
     1120 	     end;
     1121 
     1122 	     else if obj.to_be_ignored
     1123 	     then do;				/* appeared in Ignore stmt */
     1124 		if obj.new_order > 0
     1125 		then do;				/* ... AND some order stmt */
     1126 		     MERROR_SEVERITY = 3;
     1127 		     call ioa_$ioa_stream (ERROR_OUTPUT,
     1128 			"^/ERROR 20 SEVERITY 3^/" || error_control_table.message (20) || "^/", erring_token_value);
     1129 		end;
     1130 
     1131 		if obj.objectname_stmt
     1132 		then do;				/* ... AND/OR in an objectname stmt */
     1133 		     MERROR_SEVERITY = 3;
     1134 		     call ioa_$ioa_stream (ERROR_OUTPUT,
     1135 			"^/ERROR 21 SEVERITY 3^/" || error_control_table.message (21) || "^/", erring_token_value);
     1136 		end;
     1137 
     1138 
     1139 	     end;
     1140 	     if order_type = FORCE_ORDER & obj.objectname_stmt /* obj was in an objectname stmt... */
     1141 		& obj.new_order = 0			/*    but not in the Force_Order stmt */
     1142 	     then do;
     1143 		MERROR_SEVERITY = 3;
     1144 		call ioa_$ioa_stream (ERROR_OUTPUT,
     1145 		     "^/ERROR 19 SEVERITY 3^/" || error_control_table.message (19) || "^/", erring_token_value);
     1146 	     end;
     1147 
     1148 	     if order_type = ORDER & obj.new_order = 0 /* object not in Order stmt ... */ & ^obj.to_be_ignored
     1149 						/*   and had no excuse for not being there */
     1150 	     then do;
     1151 		MERROR_SEVERITY = 3;
     1152 		call ioa_$ioa_stream (ERROR_OUTPUT,
     1153 		     "^/ERROR 22 SEVERITY 3^/" || error_control_table.message (22) || "^/", erring_token_value);
     1154 	     end;
     1155 
     1156 	     if order_type = PARTIAL_ORDER & ^obj.to_be_ignored & obj.new_order = 0
     1157 						/* objects not in Partial_Order stmt ... */
     1158 	     then do;				/*   will be assigned orders as we catch them */
     1159 		partial_order_number = partial_order_number + 1;
     1160 		obj.new_order = partial_order_number;
     1161 	     end;
     1162 
     1163 /*
     1164*	 *   Assign an order to this module if we had no
     1165*	 *   type of Order statement and if this module is
     1166*	 *   not to be ignored.
     1167*	 */
     1168 
     1169 	     if order_type = 0 & ^obj.to_be_ignored
     1170 	     then do;				/*   assign an order index to this not-to-be-ignored object   */
     1171 		j = j + 1;
     1172 		obj.new_order = j;
     1173 	     end;
     1174 
     1175 	     if obj.new_order > 0
     1176 	     then new_nobj = new_nobj + 1;
     1177 	end;
     1178 
     1179 /*   Now we can fill in the copy of the inp structure and switch pointers, if there were no errors.   */
     1180 
     1181 	if MERROR_SEVERITY < 3
     1182 	then do;
     1183 	     Word_extent = fixed (fixed (rel (addr (inp.obj (1).filename)), 18) - fixed (rel (inpp), 18), 18);
     1184 						/* get size of input structure */
     1185 	     copyp -> Word (*) = inpp -> Word (*);	/* copy input structure */
     1186 
     1187 	     do i = 1 to bx_$ncomp;
     1188 		p = addr (inp.obj (i).filename);
     1189 		if obj.new_order > 0
     1190 		then do;
     1191 		     p1 = addr (copyp -> inp.obj (obj.new_order).filename);
     1192 		     p1 -> obj = p -> obj;
     1193 		end;
     1194 	     end;
     1195 
     1196 	     bx_$ncomp, copyp -> inp.nobj = new_nobj;
     1197 	     inpp, bx_$inpp = copyp;
     1198 
     1199 	end;
     1200 
     1201 	return;
     1202 
     1203      end ACTION;
     1204 
     1205 
     1206 /**************************************************************************************************************************/
     1207 INIT_PARSE:
     1208      proc ();
     1209 
     1210 
     1211 	Pinput = inp.bindfilep;			/* copy pointer to bindfile */
     1212 
     1213 	Linput = divide (inp.bindfile_bc + 8, 9, 17, 0);	/* compute length in characters */
     1214 	Parameters = "0"b;
     1215 	no_parameters = "1"b;
     1216 
     1217 	copyp = bx_$freep;				/* allocate area for possible archive reorder */
     1218 	call temp_mgr_$reserve (addrel (copyp, size (inp)));
     1219 						/* allocate with respect to NTOTAL and NOBJ */
     1220 
     1221 	adnp, bx_$adnp = bx_$freep;			/* beginning of addname table */
     1222 	call temp_mgr_$reserve (addrel (adnp, (bx_$addname_limit + 2) * 9));
     1223 						/* reserve table */
     1224 	an.n_an = 0;
     1225 	an.max_size = bx_$addname_limit;
     1226 
     1227 	areap, bx_$optp = bx_$freep;			/* beginning of option table */
     1228 						/* we shouldn't run off the end of the temp seg by th time the option table 
     1229*				   is full.  The temp area for the table is "reserved (actually marked) 
     1230*				   before we leave, i.e., when we KNOW how much space is needed. */
     1231 
     1232 /* initialize various variables */
     1233 
     1234 	g_notable, g_retain, g_indirect, g_nolink, g_delete = " ";
     1235 						/* reset options structure */
     1236 	optp = addr (option.structures);		/* pointer to first structure */
     1237 
     1238 	stmt_error (delete_idx),			/* Can't have any of these stmts until AFTER the next objectname stmt */
     1239 	     stmt_error (global_idx), stmt_error (indirect_idx), stmt_error (no_link_idx), stmt_error (retain_idx),
     1240 	     stmt_error (synonym_idx), stmt_error (table_idx) = NO_obj;
     1241 
     1242 	if bx_$force_order = 1
     1243 	then stmt_error (POrder_idx) = EXCLUSIVE_stmt;	/* if -forcer_order specified on cmmand line, "Order" is "translated" to
     1244*					   Force_Order; Partial_Order,however, is not allowed in the bindfile */
     1245 	return;
     1246 
     1247      end INIT_PARSE;
     1248 
     1249 /*	  The binder include files (1:4) and the code generated
     1250*		 by the reduction compiler follows.		   */
     1251 
     1252 
  1     1 /* BEGIN INCLUDE FILE ... binder_input.incl.pl1 ... 01/14/81 W. Olin Sibert */
  1     2 /* Input structure for binder_. Modified to contain more useful information 01/14/81 */
  1     3 
  1     4 /* This file is used only by bind.pl1, bind_.pl1 and parse_bindfile_.pl1 */
  1     5 
  1     6 /* Modified 9/24/84 by M Sharpe to hold a few new flags (originally done
  1     7*   by Henry Bodzin, Ford Motor Co.), and to allow "unlimited" number of 
  1     8*   input archives/segments and object components. */
  1     9 
  1    10 dcl 1 inp aligned based (inpp),			/* Really based on bx_$inpp */
  1    11     2 version char (4) aligned,
  1    12     2 caller_name char (32) unaligned,			/* Name of command on whose behalf binder is being invoked */
  1    13 
  1    14     2 bound_seg_name char (32) unaligned,		/* name of new bound segment */
  1    15 
  1    16     2 narc fixed bin,				/* number of input archive files */
  1    17     2 nupd fixed bin,				/* number of update archive files */
  1    18     2 ntotal fixed bin,				/* total number of input and update files */
  1    19     2 nobj fixed bin,				/* number of objects to be bound */
  1    20 
  1    21     2 bindfilep pointer,				/* pointer to bindfile */
  1    22     2 bindfile_bc fixed bin (24),			/* bitcount of bindfile */
  1    23     2 bindfile_name char (32) unaligned,		/* name of bindfile */
  1    24     2 bindfile_time_up fixed bin (71),			/* date updated in archive */
  1    25     2 bindfile_time_mod fixed bin (71),			/* date last modified */
  1    26     2 bindfile_idx fixed bin,				/* index of archive bindfile was in */
  1    27 
  1    28     2 options aligned,
  1    29       3 debug bit (1) unaligned,			/* 1-> debug option ON */
  1    30       3 list_seg bit (1) unaligned,			/* 1 -> make list seg */
  1    31       3 map_opt bit (1) unaligned,			/* 1 -> map option  */
  1    32       3 list_opt bit (1) unaligned,			/* 1 -> list option */
  1    33       3 brief_opt bit (1) unaligned,			/* 1 -> brief option */
  1    34       3 force_order_opt bit (1) unaligned,		/* 1 -> force_order option from command line */
  1    35       3 zeroseg_seen bit (1) unaligned,			/* 1 -> a zero-length object is in the obj array */
  1    36       3 flags_pad bit(29) unaligned,
  1    37 						/* ---- any additions to the include file must be made before
  1    38*						   the "archive" substructure, as inp.ntotal is incremented
  1    39*						   and the structure is extended as we pick up the names of
  1    40*						   archives/segs from the command line arguments. Similarly,
  1    41*						   after inp.ntotal is determined, the "obj" substructure is
  1    42*						   filled and inp.nobj is incremented as we open up each
  1    43*						   archive and take the necessary information from the
  1    44*						   components.  To allocate the structure, the user must first
  1    45*						   set NTOTAL and NOBJ, allocate the structure and then set
  1    46*						   inp.notal and inp.nobj; otherwise, this structure must be
  1    47*						   declared in a temporary segment.  */
  1    48 
  1    49     2 archive (NTOTAL refer (inp.ntotal)) aligned,	/* info about input archives/segs, for source map, etc. */
  1    50       3 path char (168) unaligned,			/* for identifying archive */
  1    51       3 real_path char (168) unaligned,			/* determined by translator_info_ */
  1    52       3 ptr pointer,				/* pointer to archive */
  1    53       3 bc fixed bin (24),				/* and its bitcount */
  1    54       3 standalone_seg bit (1) unaligned,		/* 1 -> standalone_seg;0 -> archive */
  1    55       3 entryname char (32),				/* entryname of segment */
  1    56       3 uid bit (36) aligned,				/* unique id of archive */
  1    57       3 dtm fixed bin (71),				/* date-time modified of archive */
  1    58 
  1    59 
  1    60     2 obj (NOBJ refer (inp.nobj)) aligned like obj;
  1    61 
  1    62 
  1    63 dcl 1 obj aligned based (p),				/* declaration of single input entry */
  1    64     2 filename char (32) unaligned,
  1    65     2 base pointer,					/* pointer to base of object segment */
  1    66     2 bitcount fixed bin (24),			/* bitcount of object segment */
  1    67     2 option bit (18) unaligned,			/* pointer into option structure */
  1    68     2 new_order fixed bin(9) unsigned unaligned,		/* new position from XXX_Order statement */
  1    69     2 to_be_ignored bit(1) unaligned,			/* mentioned in Ignore statement or is zero-length */
  1    70     2 objectname_stmt bit(1) unaligned,			/* mentioned in objectname: statement */
  1    71     2 flag bit (1) unaligned,				/* This word of unaligned bits ought to be a substructure, */
  1    72     2 pad bit (6) unaligned,				/* but if it is, pl1 scope-of-names stupidly rejects refs */
  1    73 						/* to obj.flag as "ambiguous", because of inp.obj.flag */
  1    74     2 archive_idx fixed bin,				/* index of archive from which this component comes */
  1    75     2 time_mod fixed bin (71),			/* DTCM of component (from archive) */
  1    76     2 time_up fixed bin (71); 			/* Time updated in archive */
  1    77 
  1    78 
  1    79 dcl  BINDER_INPUT_VERSION_2 char (4) aligned internal static options (constant) init ("BI.2");
  1    80 dcl  (NOBJ, NTOTAL)    fixed bin init (0);
  1    81 
  1    82 
  1    83 /* END INCLUDE FILE ... binder_input.incl.pl1 */
     1253 
     1254 
  2     1 	/* Include file option.incl.pl1 */
  2     2 
  2     3 declare	1 option aligned based(areap),
  2     4 
  2     5 	2 g_retain char(1) unaligned,		/* global retain option */
  2     6 	2 g_indirect char(1) unaligned,	/* global indirect */
  2     7 	2 g_delete char(1) unaligned,		/* global delete */
  2     8 	2 g_nolink char(1) unaligned,		/* global no_link */
  2     9 	2 g_notable char(1) unaligned,	/* global no_table */
  2    10 	2 structures fixed bin;		/* beginning of option structures */
  2    11 
  2    12 declare	1 op aligned based(optp),		/* declaration of an option structure */
  2    13 
  2    14 	2 n_options fixed bin,		/* number of symbols in structure */
  2    15 	2 retain char(1) unaligned,		/* global retain for this object */
  2    16 	2 indirect char(1) unaligned,		/* global indirect for this object */
  2    17 	2 delete char(1) unaligned,		/* global delete for this object */
  2    18 	2 no_link char(1) unaligned,		/* global no_link for this object */
  2    19 	2 table char(1) unaligned,		/* keep table for this object */
  2    20 	2 n_synonyms fixed bin,		/* synonym(s) of component segment */
  2    21 	2 n_retain fixed bin,		/* number of definitions to be retained */
  2    22 	2 n_indirect fixed bin,		/* number of symbols to remain unsnapped */
  2    23 	2 n_delete fixed bin,		/* number of symbols to be deleted */
  2    24 	2 n_nolink fixed bin,		/* number of symbols not to be prelinked */
  2    25 	2 opes(1000) aligned,		/* the symbols */
  2    26 	  3 symb char(257) aligned,
  2    27 	  3 code char(1) aligned,		/* code indicating type of option */
  2    28 	  3 lng fixed bin;
  2    29 
  2    30 declare	1 ope aligned based(p),
  2    31 	2 symb char(257) aligned,
  2    32 	2 code char(1) aligned,
  2    33 	2 lng fixed bin;
  2    34 
     1255 
     1256 
  3     1 	/* Include file bndtbl.incl.pl1 */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(85-09-24,Elhard), approve(85-09-24,MCR7198),
  3     6*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
  3     7*     Added link_regeneration_table and eliminated the use of "p" as a pointer
  3     8*     to base structures on..
  3     9*                                                   END HISTORY COMMENTS */
  3    10 
  3    11 	/* DIVERSE BINDER TABLES */
  3    12 
  3    13 	/* Modified Oct 1978 by David Spector for hash coding snt and strm */
  3    14 	/* Modified Dec 1978 by David Spector for making repatch table
  3    15*	   automatically extensible */
  3    16 	
  3    17 declare	(sntp, adnp, odnp, rptp, rptep, strmp, lrtp) pointer;
  3    18 
  3    19 	/* The SEGNAME table  -  segnames and synonyms of all components */
  3    20 
  3    21 declare	1 snt aligned based(sntp),
  3    22 	2 hash_table (0:210) unaligned ptr,	/* prime length */
  3    23 	2 max_size fixed bin,		/* size limit of allocated segname table */
  3    24 	2 n_names fixed bin,		/* number of segname-table entries used */
  3    25 	2 entry(1000) like seg;
  3    26 
  3    27 	/* declaration of a SEGNAME entry */
  3    28 
  3    29 declare	1 seg aligned based,		/* redeclaration of a single segname */
  3    30 	  2 name char(33) aligned,		/* segname in ACC string format */
  3    31 	  2 lng fixed bin,			/* length of segname, incl ACC count */
  3    32 	  2 addname fixed bin,		/* 1-> add name to bound segment */
  3    33 	  2 defrel bit(18),			/* offset in defs of new definition */
  3    34 	  2 comp pointer,			/* pointer to associated component table */
  3    35 	  2 hash_thread ptr;		/* thread to next "seg" in bucket */
  3    36 
  3    37 
  3    38 	/* the ADDNAME table  - list of names specified by "Addname" statement */
  3    39 
  3    40 declare	1 an aligned based(adnp),
  3    41 	2 max_size fixed bin,		/* size limit of addname table */
  3    42 	2 n_an fixed bin,			/* number of names to add */
  3    43 	2 syn(1000) char(32) aligned;		/* contains the names to be added */
  3    44 
  3    45 
  3    46 	/* The ODDNAME table  -  scratchpad memory to suppress redundant error messages */
  3    47 
  3    48 declare	1 od aligned based(odnp),
  3    49 	2 max_size fixed bin,		/* max size of table */
  3    50 	2 n_odds fixed bin,			/* current size of table */
  3    51 	2 entry(1000),
  3    52 	  3 name char(289) aligned;
  3    53 
  3    54 
  3    55 	/* The REPATCH table  -  of halfwords to be relocated at a later time */
  3    56 
  3    57 declare	1 rpt aligned based(rptp),
  3    58 	2 thread unaligned ptr,			/* To next rpt (null at end) */
  3    59 	2 npt fixed bin,
  3    60 	2 entry(1000) like rpte aligned;
  3    61 
  3    62 
  3    63 declare	1 rpte aligned based(rptep),		/* declaration of single repatch table entry */
  3    64 	2 poffset bit(18) unaligned,		/* offset into text of word to be patched */
  3    65 	2 pexpr bit(18) unaligned,		/* value to add to patched halfword */
  3    66 	2 halfword char(3) aligned,		/* designates wordhalf to be patched */
  3    67 	2 pbase char(1) unaligned,		/* section designator of word to be patched */
  3    68 	2 code char(1) unaligned;		/* code of section base to be used as patch value */
  3    69 
  3    70 
  3    71 	/* The STRINGMAP table - to avoid redundant strings in definition section */
  3    72 
  3    73 declare	1 strm aligned based(strmp),
  3    74 	2 hash_table (0:862) fixed bin(17),	/* prime length */
  3    75 	2 max_size fixed bin,
  3    76 	2 nstr fixed bin,
  3    77 	2 entry(2048) unaligned,
  3    78 	  3 map bit(18),			/* rel pointer to string in def section */
  3    79 	  3 hash_thread fixed bin(17);	/* index of next strm.entry in hash bucket */
  3    80 
  3    81 	/* The LINK_REGENERATION table - to flag links which have and  */
  3    82 	/* have not been regenerated to insure generation of all links */
  3    83 	
  3    84 declare	1 lrt		aligned based (lrtp),
  3    85 	  2 count		fixed bin,
  3    86 	  2 start_offset	fixed bin (18) unsigned,
  3    87 	  2 regenerated (0 refer (lrt.count))
  3    88 			bit (18) unaligned;
  3    89 
  3    90 declare	UNRESOLVED	bit (18) static options (constant) init ("000000"b3);
  3    91 declare	INTERNALLY_RESOLVED	bit (18) static options (constant) init ("777777"b3);
     1257 
     1258 
  4     1 /****  START OF:	bindext.incl.pl1			 *  *  *  *  *  */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(86-06-14,Elhard), approve(86-06-14,MCR7198),
  4     6*     audit(86-06-30,Weaver):
  4     7*     Added declarations for bx_$caller and bx_$temp_bsegp.
  4     8*                                                   END HISTORY COMMENTS */
  4     9 
  4    10 /* DECLARATION OF BINDER'S MAIN DATABASE */
  4    11 
  4    12 /* include file bindext.incl.pl1 */
  4    13 
  4    14 /* Modified Sept 1978 by David Spector for using "get_temp_segment_" in temp_mgr_ */
  4    15 /* Modified Dec 1978 by David Spector for making repatch table automatically extensible */
  4    16 /* Modified 01/15/81 W. Olin Sibert for new options */
  4    17 
  4    18 declare  bx_$vers_name char (168) aligned external;	/* ASCII version name, in ACC form */
  4    19 declare  bx_$vers_number fixed bin external;		/* integer part of version number */
  4    20 declare  bx_$size fixed bin external;			/* size of main data base, for resetting */
  4    21 declare  bx_$snt_limit fixed bin external;		/* preset limit for segname table */
  4    22 declare  bx_$oddname_limit fixed bin external;		/* preset limit for oddname table */
  4    23 declare  bx_$stringmap_limit fixed bin external;		/* preset limit for stringmap table */
  4    24 declare  bx_$addname_limit fixed bin external;		/* preset limit for addname table */
  4    25 declare  bx_$area_begin fixed bin (18) external;		/* beginning of main data base */
  4    26 declare  bx_$ctp pointer external;			/* pointer to component table */
  4    27 declare  bx_$freep pointer external;			/* pointer to beginning of free area */
  4    28 declare  bx_$isp pointer external;			/* pointer to first insym table */
  4    29 declare  bx_$inpp pointer external;			/* pointer to binder's input structure */
  4    30 declare  bx_$bsegp pointer external;			/* pointer to base of new object segment */
  4    31 declare  bx_$temp pointer external;			/* pointer to threaded list of temp segments */
  4    32 declare  bx_$optp pointer external;			/* pointer to options table */
  4    33 declare  bx_$odnp pointer external;			/* pointer to oddname table */
  4    34 declare  bx_$first_rptp pointer external;		/* pointer to first chunk of repatch table */
  4    35 declare  bx_$last_rptp pointer external;		/* pointer to current chunk of threaded repatch table */
  4    36 declare  bx_$adnp pointer external;			/* pointer to addname table */
  4    37 declare  bx_$bindmap_def pointer external;		/* pointer to new object's "bind_map" definition */
  4    38 declare  bx_$bdefp pointer external;			/* pointer to new object's definition section */
  4    39 declare  bx_$bstatp pointer external;			/* pointer to new object's static section */
  4    40 declare  bx_$blnkp pointer external;			/* pointer to new object's linkage section */
  4    41 declare  bx_$bsymp pointer external;			/* pointer to new object's symbol section */
  4    42 declare  bx_$sntp pointer external;			/* pointer to segname table */
  4    43 declare  bx_$tdefp pointer external;			/* pointer to temporary new definition section */
  4    44 declare  bx_$tintp pointer external;			/* pointer to temporary new internal static */
  4    45 declare  bx_$tlinkp pointer external;			/* pointer to temporary new linkage section */
  4    46 declare  bx_$strmp pointer external;			/*  pointer to stringmap table */
  4    47 declare  bx_$n_firstrefs fixed bin external;		/* count of components with firstref traps */
  4    48 declare  bx_$bound_segname char (32) aligned external;	/* name of new bound object */
  4    49 declare  bx_$fatal_error fixed bin external;		/* 1 -> fatal error was detected */
  4    50 declare  bx_$bseg_acinfop pointer external;		/* new object's acinfop for "tssi_" */
  4    51 declare  bx_$bseg_bitcount fixed bin (24) external;	/* new object's bitcount */
  4    52 declare  bx_$o_lng fixed bin (19) external;		/* length of new bound object */
  4    53 declare  bx_$t_lng fixed bin (18) external;		/* length of new text section */
  4    54 declare  bx_$d_lng fixed bin (18) external;		/* length of new definition section */
  4    55 declare  bx_$i_lng fixed bin external;			/* length of new static section */
  4    56 declare  bx_$l_lng fixed bin external;			/* length of new linkage section */
  4    57 declare  bx_$s_lng fixed bin (18) external;		/* length of new symbol section */
  4    58 declare  bx_$addname fixed bin external;		/* 1 -> addname option specified */
  4    59 declare  bx_$debug fixed bin external;			/* 1 -> debug option was specified */
  4    60 declare  bx_$brief fixed bin external;			/* 1 -> brief option was specified */
  4    61 declare  bx_$force_order fixed bin external;		/* 1 -> -force_order specified on command line */
  4    62 declare  bx_$has_sep_stat fixed bin external;		/* 1 -> a comp has nonzero sep static */
  4    63 declare  bx_$has_comb_stat fixed bin external;		/* 1 -> a comp has nonzero combined static */
  4    64 declare  bx_$bound_sep_stat fixed bin external;		/* 1 -> bound segment has separate static */
  4    65 declare  bx_$perprocess_static fixed bin external;	/* 1 -> bound segment has perprocess static switch on */
  4    66 declare  bx_$standard fixed bin external;		/* 1 -> bound seg is in standard format */
  4    67 declare  bx_$bproc fixed bin external;			/* 1 -> at least one component is a procedure */
  4    68 declare  bx_$textlng fixed bin (18) external;		/* length of new pure text portion */
  4    69 declare  bx_$curdeflng fixed bin (18) external;		/* current length of new definition section */
  4    70 declare  bx_$tintlng fixed bin external;		/* current length of new internal static */
  4    71 declare  bx_$maxlinklng fixed bin external;		/* maximum size linkage section may attain */
  4    72 declare  bx_$maxdeflng fixed bin (18) external;		/* maximum size definition section may attain */
  4    73 declare  bx_$tlinklng fixed bin external;		/* current size of linkage section */
  4    74 declare  bx_$ncomp fixed bin external;			/* number of component objects to be bound */
  4    75 declare  bx_$v_lng fixed bin external;			/* length of version name string */
  4    76 declare  bx_$n_lng fixed bin external;			/* length of bound segment name string */
  4    77 declare  bx_$nsymdefs fixed bin external;		/* count of non-null symbol definitions */
  4    78 declare  bx_$nsegdefs fixed bin external;		/* count of non-null segment name definitions */
  4    79 declare  bx_$temp_bsegp ptr external;			/* pointer to the temporary bound seg in the process dir */
  4    80 declare  bx_$caller char (32) aligned external;		/* name of the caller of bind_ for error messages */
  4    81 
  4    82 /****  END OF:	bindext.incl.pl1			 *  *  *  *  *  */
     1259 
     1260 
     1261 
     1262 
     1263      dcl	TRACING			bit(1) aligned int static init("0"b);
     1264 
     1265 
  5     1 	/* START OF:	rdc_start_.incl.pl1		  *  *  *  *  *  *  */
  5     2 
  5     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5     4 	/*							*/
  5     5 	/* N__a_m_e:  rdc_start_.incl.pl1					*/
  5     6 	/*							*/
  5     7 	/*      This include segment is used by compilers generated by the	*/
  5     8 	/* reduction_compiler.  Such compilers include a SEMANTIC_ANALYSIS	*/
  5     9 	/* subroutine generated by the reduction_compiler.  This subroutine	*/
  5    10 	/* compares a chain of input tokens with token requirements		*/
  5    11 	/* specified in reductions.  This include segment declares the 	*/
  5    12 	/* structure of the input tokens (which are generated by lex_string_),*/
  5    13 	/* defines the beginning of the SEMANTIC_ANALYSIS procedure, and	*/
  5    14 	/* declares Pthis_token, a global pointer variable which points to	*/
  5    15 	/* the "current" token being referenced by SEMANTIC_ANALYSIS.	*/
  5    16 	/*							*/
  5    17 	/* S__t_a_t_u_s							*/
  5    18 	/*							*/
  5    19 	/* 0) Created:  April, 1974 by G. C. Dixon			*/
  5    20 	/*							*/
  5    21 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5    22 
  5    23      dcl	Pthis_token		ptr;		/* ptr to the "current" token being acted upon.	*/
  5    24 
  6     1 	/*  START OF:	lex_descriptors_.incl.pl1	  *  *  *  *  *  *  */
  6     2 	
  6     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6     4 	/*							*/
  6     5 	/* Name:  lex_descriptors_.incl.pl1				*/
  6     6 	/*							*/
  6     7 	/*      This include segment defines the structure of the token	*/
  6     8 	/* descriptor, statement descriptor, and comment descriptor created	*/
  6     9 	/* by the lex_string_ program.				*/
  6    10 	/*							*/
  6    11 	/* Status:						*/
  6    12 	/*							*/
  6    13 	/* 0) Created:  Dec, 1973 by G. C. Dixon			*/
  6    14 	/*							*/
  6    15 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6    16 	
  6    17 	
  6    18 	
  6    19 	
  6    20      dcl	
  6    21 	1 comment			aligned based (Pcomment),
  6    22 						/* descriptor for a comment.			*/
  6    23 	  2 group1		unaligned,
  6    24 	    3 version		fixed bin(17),	/* comment descriptor version.		*/
  6    25 	    3 size		fixed bin(17),	/* comment descriptor size (in words).		*/
  6    26 	  2 Pnext			ptr unal,		/* ptr to next comment descriptor.		*/
  6    27 	  2 Plast			ptr unal,		/* ptr to last comment descriptor.		*/
  6    28 	  2 Pvalue		ptr unal,		/* ptr to comment.				*/
  6    29 	  2 Lvalue		fixed bin(18),	/* length of comment.			*/
  6    30 	  2 group2		unaligned,
  6    31 	    3 line_no		fixed bin(17),	/* line no of line containing comment.		*/
  6    32 	    3 S,					/* switches:				*/
  6    33 	      4 before_stmt		bit(1),		/* comment is before 1st token of stmt.		*/
  6    34 	      4 contiguous		bit(1),		/* no tokens between this and last comment.	*/
  6    35 	      4 pad		bit(16),
  6    36 	comment_value		char(comment.Lvalue) based (comment.Pvalue),
  6    37 						/* body of comment.				*/
  6    38 	Pcomment			ptr;		/* ptr to comment descriptor.			*/
  6    39 	
  6    40      dcl	
  6    41 	1 stmt			aligned based (Pstmt),
  6    42 						/* descriptor for a statement.		*/
  6    43 	  2 group1		unaligned,
  6    44 	    3 version		fixed bin(17),	/* statement descriptor version.		*/
  6    45 	    3 size		fixed bin(17),	/* statement descriptor size (in words).	*/
  6    46 	  2 Pnext			ptr unal,		/* ptr to next statement descriptor.		*/
  6    47 	  2 Plast			ptr unal,		/* ptr to last statement descriptor.		*/
  6    48 	  2 Pvalue		ptr unal,		/* ptr to statement.			*/
  6    49 	  2 Lvalue		fixed bin(18),	/* length of statement.			*/
  6    50 	  2 Pfirst_token		ptr unal,		/* ptr to 1st token of statement.		*/
  6    51 	  2 Plast_token		ptr unal,		/* ptr to last token of statement.		*/
  6    52 	  2 Pcomments		ptr unal,		/* ptr to comments in statement.		*/
  6    53 	  2 Puser			ptr unal,		/* user-defined ptr.			*/
  6    54 	  2 group2		unaligned,
  6    55 	    3 Ntokens		fixed bin(17),	/* number of tokens in statement.		*/
  6    56 	    3 line_no		fixed bin(17),	/* line no of line on which statement begins.	*/
  6    57 	    3 Istmt_in_line		fixed bin(17),	/* number of stmts in line containing this stmt.	*/
  6    58 						/* (the number includes this stmt.)		*/
  6    59 	    3 semant_type		fixed bin(17),	/* semantic type of the statement.		*/
  6    60 	    3 S,					/* switches:				*/
  6    61 	      4 error_in_stmt	bit(1),		/* stmt contains a syntactic error.		*/
  6    62 	      4 output_in_err_msg	bit(1),		/* stmt has been output in previous error message.*/
  6    63 	      4 pad		bit(34),
  6    64 	stmt_value		char(stmt.Lvalue) based (stmt.Pvalue),
  6    65 						/* text of the statement.			*/
  6    66 	Pstmt			ptr;		/* ptr to a stmt descriptor. 			*/
  6    67 	
  6    68      dcl	
  6    69 	1 token			aligned based (Ptoken),
  6    70 						/* descriptor for a token.			*/
  6    71 	  2 group1		unaligned,
  6    72 	    3 version		fixed bin(17),	/* token descriptor version.			*/
  6    73 	    3 size		fixed bin(17),	/* token descriptor size (in words).		*/
  6    74 	  2 Pnext			ptr unal,		/* ptr to next token descriptor.		*/
  6    75 	  2 Plast			ptr unal,		/* ptr to last token descriptor.		*/
  6    76 	  2 Pvalue		ptr unal,		/* ptr to token.				*/
  6    77 	  2 Lvalue		fixed bin(18),	/* length of token.				*/
  6    78 	  2 Pstmt			ptr unal,		/* ptr to descriptor of stmt containing token.	*/
  6    79 	  2 Psemant		ptr unal,		/* ptr to descriptor(s) of token's semantic value.*/
  6    80 	  2 group2		unaligned,
  6    81 	    3 Itoken_in_stmt	fixed bin(17),	/* position of token within its statement.	*/
  6    82 	    3 line_no		fixed bin(17),	/* line number of the line containing the token.	*/
  6    83 	    3 Nvalue		fixed bin(35),	/* numeric value of decimal-integer tokens.	*/
  6    84 	    3 S,					/* switches:				*/
  6    85 	      4 end_of_stmt		bit(1),		/* token is an end-of-stmt token.		*/
  6    86 	      4 quoted_string	bit(1),		/* token is a quoted string.			*/
  6    87 	      4 quotes_in_string	bit(1),		/* on if quote-close delimiters appear in quoted	*/
  6    88 						/* string (as doubled quotes on input.)		*/
  6    89 	      4 quotes_doubled	bit(1),		/* on if quotes in the string are doubled after	*/
  6    90 						/* string has been lexed into a token.		*/
  6    91 	      4 pad2		bit(32),
  6    92 	token_value		char(token.Lvalue) based (token.Pvalue),
  6    93 						/* value of the token.			*/
  6    94 	Ptoken			ptr;		/* ptr to a token descriptor.			*/
  6    95 
  6    96 	/*  END OF:	lex_descriptors_.incl.pl1	  *  *  *  *  *  *  */
  5    25 
  5    26 
  5    27 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5    28 
  5    29 
  5    30 SEMANTIC_ANALYSIS:	procedure;			/* procedure which analyzes the syntax and	*/
  5    31 						/* semantics of the tokens in the input list.	*/
  5    32 
  5    33      dcl						/*	automatic variables			*/
  5    34 	LTOKEN_REQD_VALUE		fixed bin(18),	/* length of a token requirement.		*/
  5    35 	NRED			fixed bin,	/* number of the reduction tokens are being	*/
  5    36 						/* compared to.				*/
  5    37 	PRED			ptr,		/* ptr to the reduction tokens are being	*/
  5    38 						/* compared to.				*/
  5    39 	PTOKEN_REQD		ptr,		/* ptr to token requirement descriptor associated	*/
  5    40 						/* with reduction tokens are being compared to.	*/
  5    41 	PTOKEN_REQD_VALUE		ptr,		/* ptr to a token requirement.		*/
  5    42 	STOKEN_FCN		bit(1) aligned,	/* return value from a relative syntax function.	*/
  5    43 	CODE			fixed bin(35),	/* an error code.				*/
  5    44 	I			fixed bin,	/* a do-group index.			*/
  5    45 	NUMBER			fixed bin(35);	/* fixed binary representation of a decimal 	*/
  5    46 						/* number character string.			*/
  5    47 
  5    48      dcl						/*	based variables			*/
  5    49 	1 RED			aligned based (PRED),
  5    50 						/* descriptor for reduction tokens are being 	*/
  5    51 						/* compared to.				*/
  5    52 	  2 TOKEN_REQD		unaligned,
  5    53 	    3 IFIRST		fixed bin(17) unal,	/* index of first token requirement.		*/
  5    54 	    3 ILAST		fixed bin(17) unal,	/* index of last  token requirement associated	*/
  5    55 						/* with this reduction.			*/
  5    56 	1 TOKEN_REQD		aligned based (PTOKEN_REQD),
  5    57 						/* a token requirement descriptor.		*/
  5    58 	  2 FORM			fixed bin(17) unal,	/* form of the token requirement:		*/
  5    59 						/*  -1 = relative token requirement function;	*/
  5    60 						/*       TYPE = index of the particular token	*/
  5    61 						/*	      function in the token_fcn array.	*/
  5    62 						/*   0 = built-in token requirement function;	*/
  5    63 						/*       TYPE = as defined below.		*/
  5    64 						/*  >0 = absolute token requirement:		*/
  5    65 						/*       FORM = index(TOKEN_STRINGS,TOKEN_REQD);	*/
  5    66 						/*       TYPE = length(TOKEN_REQD);		*/
  5    67 	  2 TYPE			fixed bin(17) unal,	/* TYPE of built-in token requirement function:	*/
  5    68 						/*   1 = compile test to see if input token 	*/
  5    69 						/*       chain is exhausted (<no-token>).	*/
  5    70 						/*   2 = compile test for any token value	*/
  5    71 						/*       (<any-token>).			*/
  5    72 						/*   3 = compile test for a PL/I identifier	*/
  5    73 						/*       (<name>) of 32 or fewer characters.	*/
  5    74 						/*   4 = compile test for token which is a	*/
  5    75 						/*       <decimal-integer>.			*/
  5    76 						/*   5 = compile test for token which is a single	*/
  5    77 						/*       backspace character (<BS>).		*/
  5    78 						/*   6 = compile test for a token which is a	*/
  5    79 						/*       <quoted-string>.			*/
  5    80 
  5    81 	1 TOKEN_REQD_STRING		aligned based (PTOKEN_REQD),
  5    82 						/* overlay for an absolute token requirement	*/
  5    83 						/* descriptor.				*/
  5    84 	  2 I			fixed bin(17) unal,	/* index into list of token strings of the	*/
  5    85 						/* absolute token string assoc w/ descriptor.	*/
  5    86 	  2 L			fixed bin(17) unal,	/* length of the absolute token string.		*/
  5    87 	TOKEN_REQD_VALUE		char(LTOKEN_REQD_VALUE) based (PTOKEN_REQD_VALUE);
  5    88 						/* absolute token string which token is reqd	*/
  5    89 						/* to match in order for tokens which are	*/
  5    90 						/* "current" on the list to match the reduction.	*/
  5    91 
  5    92      dcl						/*	builtin functions			*/
  5    93          (addr, max, null, search, substr, verify)
  5    94 				builtin;
  5    95 
  5    96      dcl						/*	entries				*/
  5    97 	cv_dec_check_		entry (char(*), fixed bin(35)) returns (fixed bin(35));
  5    98 
  5    99      dcl						/*	static variables			*/
  5   100 	BACKSPACE			char(1) aligned int static init ("");
  5   101 
  5   102 	/* END OF:	rdc_start_.incl.pl1		  *  *  *  *  *  *  */
     1266 
     1267 
     1268      dcl	DIRECTION			fixed bin init(+1);	/* direction in which tokens compared.		*/
     1269 
     1270 
     1271      dcl	1 REDUCTION (76)		unaligned based (addr (REDUCTIONS)),
     1272 						/* object reductions.			*/
     1273 	  2 TOKEN_REQD,
     1274 	    3 IFIRST		fixed bin(17),	/* index of first required token.		*/
     1275 	    3 ILAST		fixed bin(17),	/* index of last required token.		*/
     1276 
     1277 	REDUCTIONS  (152)		fixed bin(17) unaligned internal static options(constant) initial (
     1278 	         1,     0,	/*     1/                                                                       */
     1279 	         1,     1,	/*     2/  <no-token>                                                           */
     1280 	         2,     2,	/*     3/  ;                                                                    */
     1281 	         3,     3,	/*     4/  <keyword>                                                            */
     1282 	         4,     4,	/*     5/  <any-token>                                                          */
     1283 	         5,     5,	/*     6/  Addname                                                              */
     1284 	         6,     8,	/*     7/  Force_Order : <long_name>                                            */
     1285 	         6,     6,	/*     8/  Force_Order                                                          */
     1286 	         9,    12,	/*     9/  Global : <globe_arg> ;                                               */
     1287 	         9,    11,	/*    10/  Global : <globe_arg>                                                 */
     1288 	         9,     9,	/*    11/  Global                                                               */
     1289 	        13,    15,	/*    12/  Ignore : <long_name>                                                 */
     1290 	        13,    13,	/*    13/  Ignore                                                               */
     1291 	        16,    16,	/*    14/  No_Table                                                             */
     1292 	        17,    20,	/*    15/  Objectname : <long_name> ;                                           */
     1293 	        17,    19,	/*    16/  Objectname : <long_name>                                             */
     1294 	        17,    17,	/*    17/  Objectname                                                           */
     1295 	        21,    23,	/*    18/  Order : <long_name>                                                  */
     1296 	        21,    21,	/*    19/  Order                                                                */
     1297 	        24,    26,	/*    20/  Partial_Order : <long_name>                                          */
     1298 	        24,    24,	/*    21/  Partial_Order                                                        */
     1299 	        27,    27,	/*    22/  Perprocess_Static                                                    */
     1300 	        28,    30,	/*    23/  delete : <long_name>                                                 */
     1301 	        28,    28,	/*    24/  delete                                                               */
     1302 	        31,    34,	/*    25/  global : <globe_arg> ;                                               */
     1303 	        31,    33,	/*    26/  global : <globe_arg>                                                 */
     1304 	        31,    31,	/*    27/  global                                                               */
     1305 	        35,    37,	/*    28/  indirect : <long_name>                                               */
     1306 	        35,    35,	/*    29/  indirect                                                             */
     1307 	        38,    40,	/*    30/  no_link : <long_name>                                                */
     1308 	        38,    38,	/*    31/  no_link                                                              */
     1309 	        41,    44,	/*    32/  objectname : <long_name> ;                                           */
     1310 	        41,    43,	/*    33/  objectname : <long_name>                                             */
     1311 	        41,    41,	/*    34/  objectname                                                           */
     1312 	        45,    47,	/*    35/  retain : <long_name>                                                 */
     1313 	        45,    45,	/*    36/  retain                                                               */
     1314 	        48,    50,	/*    37/  synonym : <long_name>                                                */
     1315 	        48,    48,	/*    38/  synonym                                                              */
     1316 	        51,    51,	/*    39/  table                                                                */
     1317 	         2,     2,	/*    40/  ;                                                                    */
     1318 	        52,    53,	/*    41/  : ;                                                                  */
     1319 	         7,     8,	/*    42/  : <long_name>                                                        */
     1320 	        54,    55,	/*    43/  : <any-token>                                                        */
     1321 	        56,    57,	/*    44/  : <no-token>                                                         */
     1322 	         4,     4,	/*    45/  <any-token>                                                          */
     1323 	         1,     1,	/*    46/  <no-token>                                                           */
     1324 	         2,     2,	/*    47/  ;                                                                    */
     1325 	        52,    53,	/*    48/  : ;                                                                  */
     1326 	        54,    55,	/*    49/  : <any-token>                                                        */
     1327 	        56,    57,	/*    50/  : <no-token>                                                         */
     1328 	         4,     4,	/*    51/  <any-token>                                                          */
     1329 	         1,     1,	/*    52/  <no-token>                                                           */
     1330 	        58,    59,	/*    53/  <seg_name> ,                                                         */
     1331 	        60,    61,	/*    54/  <seg_name> ;                                                         */
     1332 	        58,    58,	/*    55/  <seg_name>                                                           */
     1333 	        62,    63,	/*    56/  <long_name> ,                                                        */
     1334 	        19,    20,	/*    57/  <long_name> ;                                                        */
     1335 	         4,     4,	/*    58/  <any-token>                                                          */
     1336 	         1,     1,	/*    59/  <no-token>                                                           */
     1337 	        62,    63,	/*    60/  <long_name> ,                                                        */
     1338 	        19,    20,	/*    61/  <long_name> ;                                                        */
     1339 	         8,     8,	/*    62/  <long_name>                                                          */
     1340 	         4,     4,	/*    63/  <any-token>                                                          */
     1341 	         1,     1,	/*    64/  <no-token>                                                           */
     1342 	        58,    59,	/*    65/  <seg_name> ,                                                         */
     1343 	        60,    61,	/*    66/  <seg_name> ;                                                         */
     1344 	        62,    63,	/*    67/  <long_name> ,                                                        */
     1345 	        19,    20,	/*    68/  <long_name> ;                                                        */
     1346 	         8,     8,	/*    69/  <long_name>                                                          */
     1347 	         4,     4,	/*    70/  <any-token>                                                          */
     1348 	         1,     1,	/*    71/  <no-token>                                                           */
     1349 	        62,    63,	/*    72/  <long_name> ,                                                        */
     1350 	        19,    20,	/*    73/  <long_name> ;                                                        */
     1351 	         8,     8,	/*    74/  <long_name>                                                          */
     1352 	         4,     4,	/*    75/  <any-token>                                                          */
     1353 	         1,     1);	/*    76/  <no-token>                                                           */
     1354 
     1355      dcl	1 TOKEN_REQUIREMENT (63)	unaligned based (addr (TOKEN_REQUIREMENTS)),
     1356 						/* object token requirements.			*/
     1357 	  2 FORM			fixed bin(17),	/* form of the token requirement:		*/
     1358 						/*  -1 = relative token requirement function;	*/
     1359 						/*       TYPE = index of the particular token	*/
     1360 						/*	      function in the token_fcn array.	*/
     1361 						/*   0 = built-in token requirement function;	*/
     1362 						/*       TYPE = as defined below.		*/
     1363 						/*  >0 = absolute token requirement:		*/
     1364 						/*       FORM = index(TOKEN_STRINGS,TOKEN_REQD);	*/
     1365 						/*       TYPE = length(TOKEN_REQD);		*/
     1366 	  2 TYPE			fixed bin(17) unal,	/* type of the built-in token requirement	*/
     1367 						/* function:				*/
     1368 						/*   1 = compile test to see if input token 	*/
     1369 						/*       chain is exhausted (<no-token>).	*/
     1370 						/*   2 = compile test for any token value	*/
     1371 						/*       (<any-token>).			*/
     1372 						/*   3 = compile test for a PL/I identifier	*/
     1373 						/*       (<name>) of 32 or fewer characters.	*/
     1374 						/*   4 = compile test for token which is a	*/
     1375 						/*       <decimal-integer>.			*/
     1376 						/*   5 = compile test for token which is a single	*/
     1377 						/*       backspace character (<BS>).		*/
     1378 						/*   6 = compile test for a token which is a	*/
     1379 						/*       <quoted-string>.			*/
     1380 
     1381 	TOKEN_REQUIREMENTS  (126)	fixed bin(17) unaligned internal static options(constant) initial (
     1382 	         0,    1,       1,    1,      -1,    1,       0,    2,       2,    7,       9,   11,      20,    1,   
     1383 	        -1,    2,      21,    6,      20,    1,      -1,    3,       1,    1,      27,    6,      20,    1,   
     1384 	        -1,    2,      33,    8,      41,   10,      20,    1,      -1,    2,       1,    1,      15,    5,   
     1385 	        20,    1,      -1,    2,      51,   13,      20,    1,      -1,    2,      64,   17,      81,    6,   
     1386 	        20,    1,      -1,    2,      87,    6,      20,    1,      -1,    3,       1,    1,      93,    8,   
     1387 	        20,    1,      -1,    2,     101,    7,      20,    1,      -1,    2,     108,   10,      20,    1,   
     1388 	        -1,    2,       1,    1,     118,    6,      20,    1,      -1,    2,     124,    7,      20,    1,   
     1389 	        -1,    2,     131,    5,      20,    1,       1,    1,      20,    1,       0,    2,      20,    1,   
     1390 	         0,    1,      -1,    4,     136,    1,      -1,    4,       1,    1,      -1,    2,     136,    1);
     1391 
     1392 
     1393      dcl	TOKEN_STRINGS		char(136) aligned based (addr (TOKEN_STRING_ARRAYS)),
     1394 						/* object token values.			*/
     1395 	TOKEN_STRING_ARRAYS (2)	char(100) aligned internal static options(constant) initial (
     1396 	     ";AddnameForce_Order:GlobalIgnoreNo_TableObjectnamePartial_OrderPerprocess_Staticdeleteglobalindirect",
     1397 	     "no_linkobjectnameretainsynonymtable,");
     1398 
     1399 	/* START OF:	rdc_end_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  7     2 
  7     3 
  7     4 /****^  HISTORY COMMENTS:
  7     5*  1) change(86-02-14,GWMay), approve(), audit(), install():
  7     6*     old history comments:
  7     7*      0) Created: April, 1974 by G. C. Dixon
  7     8*      1) Modified: Feb, 1975  by G. C. Dixon
  7     9*         a) support for Version 2.0 of reduction_compiler.
  7    10*      2) Modified: Feb, 1981  by G. C. Dixon
  7    11*         a) support for Version  2.2 of reduction_compiler
  7    12*      3) Modified: Aug, 1983  by G. C. Dixon - support for Version 2.3 of
  7    13*                        reductions command.
  7    14*  2) change(86-03-04,GDixon), approve(86-03-04,MCR7362), audit(86-03-17,GWMay),
  7    15*     install(86-03-17,MR12.0-1032):
  7    16*     Changed how the PUSH DOWN LANGUAGE (SPDL) definition of <no-token> is
  7    17*     implemented to avoid references through a null pointer.  The two
  7    18*     accepted uses are:
  7    19*     
  7    20*        / <no-token>               / ... / ... \
  7    21*                    A
  7    22*                    |
  7    23*           Pthis_token (points to top of push down stack)
  7    24*     
  7    25*     which checks to see if the push down stack is totally exhausted (ie,
  7    26*     Ptoken = null); and:
  7    27*     
  7    28*        / SPEC1 ... SPECN <no-token>         / ... / ... \
  7    29*                           A
  7    30*                           |
  7    31*                 Pthis_token (points to top of push down stack)
  7    32*     
  7    33*     which checks to see whether SPECN is topmost on the push down stack
  7    34*     AND is the final token in the input list.
  7    35*                                                   END HISTORY COMMENTS */
  7    36 
  7    37 
  7    38 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    39 	/*									*/
  7    40 	/* NAME:  rdc_end_.incl.pl1							*/
  7    41 	/*									*/
  7    42 	/*      This include segment is used by compilers generated by the reduction_compiler.	*/
  7    43 	/* Such compilers include a SEMANTIC_ANALYSIS subroutine generated by the		*/
  7    44 	/* reduction_compiler.  This subroutine compares a chain of input tokens with token	*/
  7    45 	/* requirements specified in reductions.  The code in this include segment performs the	*/
  7    46 	/* actual comparisons.  This code is the middle part of the SEMANTIC_ANALYSIS procedure.	*/
  7    47 	/*									*/
  7    48 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    49 
  7    50 	TRACING = TRACING;				/* Kludge to prevent pl1 from making TRACING	*/
  7    51 						/*   options(constant) because it is never set.	*/
  7    52 	NRED = 1;
  7    53 	go to RD_TEST_REDUCTION;
  7    54 
  7    55 RD_NEXT_REDUCTION:
  7    56 	NRED = NRED + 1;
  7    57 
  7    58 RD_TEST_REDUCTION:
  7    59 	PRED = addr(REDUCTION(NRED));
  7    60 	Ptoken = Pthis_token;
  7    61 
  7    62 	do I = RED.TOKEN_REQD.IFIRST to RED.TOKEN_REQD.ILAST by DIRECTION;
  7    63 	     PTOKEN_REQD = addr(TOKEN_REQUIREMENT(I));
  7    64 	     if Ptoken = null then do;
  7    65 		if TOKEN_REQD.FORM = 0 then		/* No more tokens.  Only matches <no-token> spec.	*/
  7    66 		     if TOKEN_REQD.TYPE = 1 then
  7    67 			go to RD_TEST_TOKEN(1);
  7    68 		go to RD_NEXT_REDUCTION;
  7    69 		end;
  7    70 	     if TOKEN_REQD.FORM = 0 then do;		/* built-in syntax function.			*/
  7    71 		go to RD_TEST_TOKEN(TOKEN_REQD.TYPE);
  7    72 
  7    73 RD_TEST_TOKEN(1):   if SPDL then			/* <no-token>				*/
  7    74 						/* In push-down-language, there are 2 		*/
  7    75 						/*   interpretations of <no-token>.		*/
  7    76 		     if      RED.TOKEN_REQD.IFIRST = RED.TOKEN_REQD.ILAST &
  7    77 			   Ptoken = null then	/* When <no-token> is only spec, the spec asks 	*/
  7    78 			go to RD_MATCH_NO_TOKEN;	/* "Is push down stack empty (all input gone)?"   */
  7    79 		     else if RED.TOKEN_REQD.IFIRST^= RED.TOKEN_REQD.ILAST &
  7    80 			   RED.TOKEN_REQD.IFIRST = I &
  7    81 			   token.Pnext = null then	/* For SPEC1 ... SPECN <no-token>, the spec asks  */
  7    82 			go to RD_MATCH_NO_TOKEN;	/* "Are the topmost tokens on stack SPEC1 - SPECN,*/
  7    83 						/*  and is SPECN the final input token?"	*/
  7    84 		     else go to RD_NEXT_REDUCTION;	/* Those are the only two defs allowed in push	*/
  7    85 						/* down language mode for <no-token>.		*/
  7    86 		else if Ptoken = null then
  7    87 		     go to RD_MATCH_NO_TOKEN;
  7    88 		go to RD_NEXT_REDUCTION;
  7    89 
  7    90 RD_TEST_TOKEN(2):	go to RD_MATCH;			/* <any-token>				*/
  7    91 
  7    92 RD_TEST_TOKEN(3):	if token.Lvalue > 0 &		/* <name>					*/
  7    93 		   token.Lvalue <= 32 & ^token.S.quoted_string then
  7    94 		     if search(substr(token_value,1,1),"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
  7    95 		     > 0 then
  7    96 			if verify(token_value,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_$")
  7    97 			= 0 then
  7    98 			     go to RD_MATCH;
  7    99 		go to RD_NEXT_REDUCTION;
  7   100 
  7   101 RD_TEST_TOKEN(4):					/* <decimal-integer>			*/
  7   102 		if token.Nvalue ^= 0 then		/* token already determined to be a number.	*/
  7   103 		     go to RD_MATCH;
  7   104 		if token.S.quoted_string then
  7   105 		     go to RD_NEXT_REDUCTION;
  7   106 		NUMBER = cv_dec_check_ (token_value, CODE);
  7   107 		if CODE = 0 then do;
  7   108 		     token.Nvalue = NUMBER;
  7   109 		     go to RD_MATCH;
  7   110 		     end;
  7   111 		go to RD_NEXT_REDUCTION;
  7   112 
  7   113 RD_TEST_TOKEN(5):	if token.Lvalue = 1 then		/* <BS>					*/
  7   114 		     if token_value = BACKSPACE & ^token.S.quoted_string then
  7   115 			go to RD_MATCH;
  7   116 		go to RD_NEXT_REDUCTION;
  7   117 
  7   118 RD_TEST_TOKEN(6):	if token.S.quoted_string then		/* <quoted-string>				*/
  7   119 		     go to RD_MATCH;
  7   120 		go to RD_NEXT_REDUCTION;
  7   121 		end;
  7   122 
  7   123 	     else if TOKEN_REQD.FORM > 0 then do;	/* absolute syntax specification.		*/
  7   124 		if token.S.quoted_string then
  7   125 		     go to RD_NEXT_REDUCTION;
  7   126 		PTOKEN_REQD_VALUE = addr(substr(TOKEN_STRINGS,TOKEN_REQD_STRING.I));
  7   127 		LTOKEN_REQD_VALUE = TOKEN_REQD_STRING.L;
  7   128 		if token_value = TOKEN_REQD_VALUE then
  7   129 		     go to RD_MATCH;
  7   130 		go to RD_NEXT_REDUCTION;
  7   131 		end;
  7   132 
  7   133 	/* END OF:	rdc_end_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1399 
     1400 
     1401 	     else do;				/* relative syntax function.			*/
     1402 		go to RD_TOKEN_FCN(TOKEN_REQD.TYPE);
     1403 
     1404 RD_TOKEN_FCN(1):	STOKEN_FCN = keyword();
     1405 		go to RD_TEST_RESULT;
     1406 RD_TOKEN_FCN(2):	STOKEN_FCN = long_name();
     1407 		go to RD_TEST_RESULT;
     1408 RD_TOKEN_FCN(3):	STOKEN_FCN = globe_arg();
     1409 		go to RD_TEST_RESULT;
     1410 RD_TOKEN_FCN(4):	STOKEN_FCN = seg_name();
     1411 		go to RD_TEST_RESULT;
     1412 
     1413 RD_TEST_RESULT:	if STOKEN_FCN then go to RD_MATCH;
     1414 		else go to RD_NEXT_REDUCTION;
     1415 		end;
     1416 
     1417 RD_MATCH:      Ptoken = token.Pnext;
     1418 RD_MATCH_NO_TOKEN:
     1419 	     end;
     1420 	Ptoken = Pthis_token;
     1421 	go to RD_ACTION(NRED);
     1422 
     1423 
     1424 RD_ACTION(1):					/* /					*/
     1425 						     keyword_idx = 0;
     1426 	go to RD_NEXT_REDUCTION;			/* /	\				*/
     1427 
     1428 RD_ACTION(2):					/* /					*/
     1429 	call					     epilogue();
     1430 	return;					/* / RETURN	\			*/
     1431 
     1432 RD_ACTION(3):					/* /					*/
     1433 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1434 	NRED = 1;
     1435 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1436 
     1437 RD_ACTION(4):					/* /					*/
     1438 	NRED = 6;
     1439 	go to RD_TEST_REDUCTION;			/* / KEYWORD \                         		*/
     1440 
     1441 RD_ACTION(5):					/* /					*/
     1442 						     if keyword_idx = 0 then call ERROR ( 1 );
     1443 	call					     NEXT_STMT();
     1444 	NRED = 1;
     1445 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1446 
     1447 RD_ACTION(6):					/* /					*/
     1448 	call					     Addname();
     1449 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1450 	NRED = 40;
     1451 	go to RD_TEST_REDUCTION;			/* / ADDNAME \                         		*/
     1452 
     1453 RD_ACTION(7):					/* /					*/
     1454 	call 					     LEX ( 2 );
     1455 						     arg_ptr = Ptoken;
     1456 						     arg_count = 0;
     1457 	NRED = 60;
     1458 	go to RD_TEST_REDUCTION;			/* / ORD_list \                        		*/
     1459 
     1460 RD_ACTION(8):					/* /					*/
     1461 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1462 	NRED = 43;
     1463 	go to RD_TEST_REDUCTION;			/* / bad_syntax \                      		*/
     1464 
     1465 RD_ACTION(9):					/* /					*/
     1466 	call 					     LEX ( 2 );
     1467 	call					     Global();
     1468 	call					     NEXT_STMT();
     1469 	NRED = 1;
     1470 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1471 
     1472 RD_ACTION(10):					/* /					*/
     1473 	call 					     LEX ( 2 );
     1474 	call 					     ERROR ( 7 );
     1475 	call					     NEXT_STMT();
     1476 	NRED = 1;
     1477 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1478 
     1479 RD_ACTION(11):					/* /					*/
     1480 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1481 	NRED = 43;
     1482 	go to RD_TEST_REDUCTION;			/* / bad_syntax \                      		*/
     1483 
     1484 RD_ACTION(12):					/* /					*/
     1485 	call 					     LEX ( 2 );
     1486 						     arg_ptr = Ptoken;
     1487 						     arg_count = 0;
     1488 	NRED = 60;
     1489 	go to RD_TEST_REDUCTION;			/* / ORD_list \                        		*/
     1490 
     1491 RD_ACTION(13):					/* /					*/
     1492 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1493 	NRED = 43;
     1494 	go to RD_TEST_REDUCTION;			/* / bad_syntax \                      		*/
     1495 
     1496 RD_ACTION(14):					/* /					*/
     1497 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1498 	NRED = 47;
     1499 	go to RD_TEST_REDUCTION;			/* / noarg_stmt \                      		*/
     1500 
     1501 RD_ACTION(15):					/* /					*/
     1502 	call 					     LEX ( 2 );
     1503 	call					     Objectname();
     1504 	call					     NEXT_STMT();
     1505 	NRED = 1;
     1506 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1507 
     1508 RD_ACTION(16):					/* /					*/
     1509 	call 					     LEX ( 2 );
     1510 	call 					     ERROR ( 7 );
     1511 	call					     NEXT_STMT();
     1512 	NRED = 1;
     1513 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1514 
     1515 RD_ACTION(17):					/* /					*/
     1516 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1517 	NRED = 43;
     1518 	go to RD_TEST_REDUCTION;			/* / bad_syntax \                      		*/
     1519 
     1520 RD_ACTION(18):					/* /					*/
     1521 	call 					     LEX ( 2 );
     1522 						     arg_ptr = Ptoken;
     1523 						     arg_count = 0;
     1524 	NRED = 60;
     1525 	go to RD_TEST_REDUCTION;			/* / ORD_list \                        		*/
     1526 
     1527 RD_ACTION(19):					/* /					*/
     1528 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1529 	NRED = 43;
     1530 	go to RD_TEST_REDUCTION;			/* / bad_syntax \                      		*/
     1531 
     1532 RD_ACTION(20):					/* /					*/
     1533 	call 					     LEX ( 2 );
     1534 						     arg_ptr = Ptoken;
     1535 						     arg_count = 0;
     1536 	NRED = 60;
     1537 	go to RD_TEST_REDUCTION;			/* / ORD_list \                        		*/
     1538 
     1539 RD_ACTION(21):					/* /					*/
     1540 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1541 	NRED = 43;
     1542 	go to RD_TEST_REDUCTION;			/* / bad_syntax \                      		*/
     1543 
     1544 RD_ACTION(22):					/* /					*/
     1545 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1546 	NRED = 47;
     1547 	go to RD_TEST_REDUCTION;			/* / noarg_stmt \                      		*/
     1548 
     1549 RD_ACTION(23):					/* /					*/
     1550 	call					     delete();
     1551 	call 					     LEX ( 2 );
     1552 	NRED = 72;
     1553 	go to RD_TEST_REDUCTION;			/* / ENTRY_list \                      		*/
     1554 
     1555 RD_ACTION(24):					/* /					*/
     1556 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1557 	NRED = 43;
     1558 	go to RD_TEST_REDUCTION;			/* / bad_syntax \                      		*/
     1559 
     1560 RD_ACTION(25):					/* /					*/
     1561 	call 					     LEX ( 2 );
     1562 	call					     global();
     1563 	call					     NEXT_STMT();
     1564 	NRED = 1;
     1565 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1566 
     1567 RD_ACTION(26):					/* /					*/
     1568 	call 					     LEX ( 2 );
     1569 	call 					     ERROR ( 7 );
     1570 	call					     NEXT_STMT();
     1571 	NRED = 1;
     1572 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1573 
     1574 RD_ACTION(27):					/* /					*/
     1575 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1576 	NRED = 43;
     1577 	go to RD_TEST_REDUCTION;			/* / bad_syntax \                      		*/
     1578 
     1579 RD_ACTION(28):					/* /					*/
     1580 	call					     indirect();
     1581 	call 					     LEX ( 2 );
     1582 	NRED = 72;
     1583 	go to RD_TEST_REDUCTION;			/* / ENTRY_list \                      		*/
     1584 
     1585 RD_ACTION(29):					/* /					*/
     1586 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1587 	NRED = 43;
     1588 	go to RD_TEST_REDUCTION;			/* / bad_syntax \                      		*/
     1589 
     1590 RD_ACTION(30):					/* /					*/
     1591 	call					     no_link();
     1592 	call 					     LEX ( 2 );
     1593 	NRED = 72;
     1594 	go to RD_TEST_REDUCTION;			/* / ENTRY_list \                      		*/
     1595 
     1596 RD_ACTION(31):					/* /					*/
     1597 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1598 	NRED = 43;
     1599 	go to RD_TEST_REDUCTION;			/* / bad_syntax \                      		*/
     1600 
     1601 RD_ACTION(32):					/* /					*/
     1602 	call 					     LEX ( 2 );
     1603 	call					     objectname();
     1604 	call					     NEXT_STMT();
     1605 	NRED = 1;
     1606 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1607 
     1608 RD_ACTION(33):					/* /					*/
     1609 	call 					     LEX ( 2 );
     1610 	call 					     ERROR ( 7 );
     1611 	call					     NEXT_STMT();
     1612 	NRED = 1;
     1613 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1614 
     1615 RD_ACTION(34):					/* /					*/
     1616 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1617 	NRED = 43;
     1618 	go to RD_TEST_REDUCTION;			/* / bad_syntax \                      		*/
     1619 
     1620 RD_ACTION(35):					/* /					*/
     1621 	call					     retain();
     1622 	call 					     LEX ( 2 );
     1623 	NRED = 72;
     1624 	go to RD_TEST_REDUCTION;			/* / ENTRY_list \                      		*/
     1625 
     1626 RD_ACTION(36):					/* /					*/
     1627 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1628 	NRED = 43;
     1629 	go to RD_TEST_REDUCTION;			/* / bad_syntax \                      		*/
     1630 
     1631 RD_ACTION(37):					/* /					*/
     1632 	call					     synonym();
     1633 	call 					     LEX ( 2 );
     1634 	NRED = 65;
     1635 	go to RD_TEST_REDUCTION;			/* / SEG_list \                        		*/
     1636 
     1637 RD_ACTION(38):					/* /					*/
     1638 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1639 	NRED = 43;
     1640 	go to RD_TEST_REDUCTION;			/* / bad_syntax \                      		*/
     1641 
     1642 RD_ACTION(39):					/* /					*/
     1643 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1644 	NRED = 47;
     1645 	go to RD_TEST_REDUCTION;			/* / noarg_stmt \                      		*/
     1646 
     1647 RD_ACTION(40):					/* /					*/
     1648 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1649 	NRED = 1;
     1650 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1651 
     1652 RD_ACTION(41):					/* /					*/
     1653 	call 					     LEX ( 2 );
     1654 	NRED = 1;
     1655 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1656 
     1657 RD_ACTION(42):					/* /					*/
     1658 						     an.n_an = 0;
     1659 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1660 	NRED = 53;
     1661 	go to RD_TEST_REDUCTION;			/* / ADN_list \                        		*/
     1662 
     1663 RD_ACTION(43):					/* /					*/
     1664 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1665 	call 					     ERROR ( 2 );
     1666 	call					     NEXT_STMT();
     1667 	NRED = 1;
     1668 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1669 
     1670 RD_ACTION(44):					/* /					*/
     1671 	call 					     ERROR ( 3 );
     1672 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1673 	NRED = 1;
     1674 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1675 
     1676 RD_ACTION(45):					/* /					*/
     1677 	call 					     ERROR ( 4 );
     1678 	call					     NEXT_STMT();
     1679 	NRED = 1;
     1680 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1681 
     1682 RD_ACTION(46):					/* /					*/
     1683 	call 					     ERROR ( 3 );
     1684 	NRED = 1;
     1685 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1686 
     1687 RD_ACTION(47):					/* /					*/
     1688 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1689 	call					     perform_noarg();
     1690 	NRED = 1;
     1691 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1692 
     1693 RD_ACTION(48):					/* /					*/
     1694 	call 					     LEX ( 2 );
     1695 	call					     perform_noarg();
     1696 	NRED = 1;
     1697 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1698 
     1699 RD_ACTION(49):					/* /					*/
     1700 	call 					     ERROR ( 6 );
     1701 	call					     NEXT_STMT();
     1702 	NRED = 1;
     1703 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1704 
     1705 RD_ACTION(50):					/* /					*/
     1706 	call 					     ERROR ( 3 );
     1707 	Ptoken, Pthis_token = Pthis_token -> token.Pnext;	/*   LEX					*/
     1708 	NRED = 1;
     1709 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1710 
     1711 RD_ACTION(51):					/* /					*/
     1712 	call 					     ERROR ( 4 );
     1713 	call					     NEXT_STMT();
     1714 	NRED = 1;
     1715 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1716 
     1717 RD_ACTION(52):					/* /					*/
     1718 	call 					     ERROR ( 3 );
     1719 	NRED = 1;
     1720 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1721 
     1722 RD_ACTION(53):					/* /					*/
     1723 						     an.n_an = an.n_an +1;
     1724 						     if an.n_an > an.max_size then call ERROR ( 13 );
     1725 						     else an.syn ( an.n_an ) = token_value;
     1726 	call 					     LEX ( 2 );
     1727 	NRED = 53;
     1728 	go to RD_TEST_REDUCTION;			/* / ADN_list \                        		*/
     1729 
     1730 RD_ACTION(54):					/* /					*/
     1731 						     an.n_an = an.n_an +1;
     1732 						     if an.n_an > an.max_size then call ERROR ( 13 );
     1733 						     else an.syn ( an.n_an ) = token_value;
     1734 	call					     NEXT_STMT();
     1735 	NRED = 1;
     1736 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1737 
     1738 RD_ACTION(55):					/* /					*/
     1739 	call 					     ERROR ( 7 );
     1740 	call					     NEXT_STMT();
     1741 	NRED = 1;
     1742 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1743 
     1744 RD_ACTION(56):					/* /					*/
     1745 	call 					     ERROR ( 8 );
     1746 	call 					     LEX ( 2 );
     1747 	NRED = 53;
     1748 	go to RD_TEST_REDUCTION;			/* / ADN_list \                        		*/
     1749 
     1750 RD_ACTION(57):					/* /					*/
     1751 	call 					     ERROR ( 8 );
     1752 	call					     NEXT_STMT();
     1753 	NRED = 1;
     1754 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1755 
     1756 RD_ACTION(58):					/* /					*/
     1757 	call 					     ERROR ( 2 );
     1758 	call					     NEXT_STMT();
     1759 	NRED = 1;
     1760 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1761 
     1762 RD_ACTION(59):					/* /					*/
     1763 	call 					     ERROR ( 3 );
     1764 	NRED = 1;
     1765 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1766 
     1767 RD_ACTION(60):					/* /					*/
     1768 						     if segname_too_long then call ERROR ( 8 );
     1769 						     else arg_count = arg_count +1;
     1770 	call 					     LEX ( 2 );
     1771 	NRED = 60;
     1772 	go to RD_TEST_REDUCTION;			/* / ORD_list \                        		*/
     1773 
     1774 RD_ACTION(61):					/* /					*/
     1775 						     if segname_too_long then call ERROR ( 8 );
     1776 						     else arg_count = arg_count +1;
     1777 	call					     perform_order();
     1778 	call					     NEXT_STMT();
     1779 	NRED = 1;
     1780 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1781 
     1782 RD_ACTION(62):					/* /					*/
     1783 						     if segname_too_long then call ERROR ( 8 );
     1784 						     else call ERROR ( 7 );
     1785 	call					     NEXT_STMT();
     1786 	NRED = 1;
     1787 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1788 
     1789 RD_ACTION(63):					/* /					*/
     1790 	call 					     ERROR ( 2 );
     1791 						     if arg_count > 0 then do;
     1792 						     ARG_list_error = "1"b;
     1793 						     call perform_order ( );
     1794 						     end;
     1795 	call					     NEXT_STMT();
     1796 	NRED = 1;
     1797 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1798 
     1799 RD_ACTION(64):					/* /					*/
     1800 	call 					     ERROR ( 3 );
     1801 						     if arg_count > 0 then do;
     1802 						     ARG_list_error = "1"b;
     1803 						     call perform_order ( );
     1804 						     end;
     1805 	call					     NEXT_STMT();
     1806 	NRED = 1;
     1807 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1808 
     1809 RD_ACTION(65):					/* /					*/
     1810 	call					     FILL_OPTION_ENTRY();
     1811 	call 					     LEX ( 2 );
     1812 	NRED = 65;
     1813 	go to RD_TEST_REDUCTION;			/* / SEG_list \                        		*/
     1814 
     1815 RD_ACTION(66):					/* /					*/
     1816 	call					     FILL_OPTION_ENTRY();
     1817 	call					     GET_OPTION_TOTALS();
     1818 	call					     NEXT_STMT();
     1819 	NRED = 1;
     1820 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1821 
     1822 RD_ACTION(67):					/* /					*/
     1823 	call 					     ERROR ( 8 );
     1824 	call 					     LEX ( 2 );
     1825 	NRED = 65;
     1826 	go to RD_TEST_REDUCTION;			/* / SEG_list \                        		*/
     1827 
     1828 RD_ACTION(68):					/* /					*/
     1829 	call 					     ERROR ( 8 );
     1830 	call					     GET_OPTION_TOTALS();
     1831 	call					     NEXT_STMT();
     1832 	NRED = 1;
     1833 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1834 
     1835 RD_ACTION(69):					/* /					*/
     1836 						     if segname_too_long then call ERROR ( 8 );
     1837 						     else call ERROR ( 7 );
     1838 	call					     NEXT_STMT();
     1839 	NRED = 1;
     1840 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1841 
     1842 RD_ACTION(70):					/* /					*/
     1843 	call 					     ERROR ( 2 );
     1844 	call					     NEXT_STMT();
     1845 	NRED = 1;
     1846 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1847 
     1848 RD_ACTION(71):					/* /					*/
     1849 	call 					     ERROR ( 3 );
     1850 	NRED = 1;
     1851 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1852 
     1853 RD_ACTION(72):					/* /					*/
     1854 						     if ^ entryname_too_long then call FILL_OPTION_ENTRY;
     1855 	call 					     LEX ( 2 );
     1856 	NRED = 72;
     1857 	go to RD_TEST_REDUCTION;			/* / ENTRY_list \                      		*/
     1858 
     1859 RD_ACTION(73):					/* /					*/
     1860 						     if ^ entryname_too_long then call FILL_OPTION_ENTRY;
     1861 	call					     GET_OPTION_TOTALS();
     1862 	call					     NEXT_STMT();
     1863 	NRED = 1;
     1864 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1865 
     1866 RD_ACTION(74):					/* /					*/
     1867 	call 					     ERROR ( 5 );
     1868 	call					     NEXT_STMT();
     1869 	NRED = 1;
     1870 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1871 
     1872 RD_ACTION(75):					/* /					*/
     1873 	call 					     ERROR ( 2 );
     1874 	call					     NEXT_STMT();
     1875 	NRED = 1;
     1876 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1877 
     1878 RD_ACTION(76):					/* /					*/
     1879 	call 					     ERROR ( 3 );
     1880 	NRED = 1;
     1881 	go to RD_TEST_REDUCTION;			/* / stmt \                            		*/
     1882 
     1883 
     1884 	end SEMANTIC_ANALYSIS;
     1885 
     1886 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1887 
     1888      dcl	SPDL			bit(1) aligned init ("0"b);
     1889 						/* off: This compiler parses a non-PUSH DOWN	*/
     1890 						/*      LANGUAGE.				*/
     1891 	/* START OF:	rdc_lex_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  8     2 
  8     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  8     4 	/*									*/
  8     5 	/* N__a_m_e:  rdc_lex_.incl.pl1							*/
  8     6 	/*									*/
  8     7 	/*      This include segment is used by compilers generated by the reduction_compiler.	*/
  8     8 	/* It contains the LEX subroutine which is used to manipulate the pointer to the	*/
  8     9 	/* "current" token, Pthis_token.						*/
  8    10 	/*									*/
  8    11 	/* E__n_t_r_y:  LEX								*/
  8    12 	/*									*/
  8    13 	/*      This entry makes the |_nth|-next (or -preceding) token the "current" token, where	*/
  8    14 	/* _n is its positive (or negative) input argument.				*/
  8    15 	/*									*/
  8    16 	/* U__s_a_g_e									*/
  8    17 	/*									*/
  8    18 	/*      call LEX(n);							*/
  8    19 	/*									*/
  8    20 	/* 1) n   is the number of the token to be made the "current" token, relative to the	*/
  8    21 	/*        token identified by Pthis_token (the present "current" token).  If n is	*/
  8    22 	/*        positive, the nth token following the "current" token made "current".  If n	*/
  8    23 	/*        is negative, the nth token preceding the "current" token is made "current".	*/
  8    24 	/*									*/
  8    25 	/* S__t_a_t_u_s									*/
  8    26 	/*									*/
  8    27 	/* 0) Created by:  G. C. Dixon  in  February, 1975				*/
  8    28 	/*									*/
  8    29 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  8    30 
  8    31 LEX:	procedure (n);
  8    32 
  8    33      dcl	n			fixed bin,
  8    34 	i			fixed bin;
  8    35 
  8    36 	Ptoken = Pthis_token;			/* do everything relative to "current" token.	*/
  8    37 	if Ptoken = null then return;			/* can't lex if token list exhausted.		*/
  8    38 	if n >= 0 then do;				/* new "current" token will follow present one.	*/
  8    39 	     do i = 1 to n while (token.Pnext ^= null);	/* find new "current" token, taking care not to	*/
  8    40 		Ptoken = token.Pnext;		/*   run off end of token list.		*/
  8    41 		end;
  8    42 	     if ^SPDL then if i <= n then Ptoken = null;	/* if not in 'PUSH DOWN LANGUAGE' mode, allow	*/
  8    43 						/*   running off end of token list.		*/
  8    44 	     end;
  8    45 	else					/* new "current" token precedes present one.	*/
  8    46 	     do i = -1 to n by -1 while (token.Plast ^= null);
  8    47 		Ptoken = token.Plast;
  8    48 		end;
  8    49 	Pthis_token = Ptoken;			/* simple wasn't it.			*/
  8    50 
  8    51 	end LEX;
  8    52 
  8    53 /* END OF:	rdc_lex_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1891 
     1892 
     1893 		/* START OF:	rdc_error_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  9     2 
  9     3      dcl	MERROR_SEVERITY		fixed bin init (0),	/* Severity of highest-severity error.		*/
  9     4 	SERROR_CONTROL		bit(2) init ("00"b),/* Global switches control error message format.	*/
  9     5 	SERROR_PRINTED (dimension (error_control_table,1))
  9     6 				bit(1) unaligned init ((dimension (error_control_table,1))(1)"0"b),
  9     7 						/* Array bit is on if corresponding error message	*/
  9     8 						/* in error_control_table has already been printed*/
  9     9 	MIN_PRINT_SEVERITY		fixed bin init (0), /* Mimimum severity message that will be printed	*/
  9    10 	PRINT_SEVERITY_CONTROL	bit(2) init ("11"b);/* Action if severity < MIN_PRINT_SEVERITY	*/
  9    11 
  9    12 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  9    13 	/*									*/
  9    14 	/* N__a_m_e:  rdc_error_.incl.pl1							*/
  9    15 	/*									*/
  9    16 	/*      This include segment is used by compilers generated by the reduction_compiler.	*/
  9    17 	/* It defines a procedure which the compilers can use to print error messages.  	*/
  9    18 	/*									*/
  9    19 	/* E__n_t_r_y:  ERROR								*/
  9    20 	/*									*/
  9    21 	/*      Given an error number, this procedure prints a corresponding error message.	*/
  9    22 	/* The message is stored in a compiler-defined error_control_table, along with an integer	*/
  9    23 	/* which specifies the severity level of the error, and a switch which specifies whether	*/
  9    24 	/* the source statement in which the error occurred (if any) should be printed after the	*/
  9    25 	/* error message.  The printing of the error message may be supressed for all messages	*/
  9    26 	/* having a severity less than a specified (MIN_PRINT_SEVERITY) value.  The ERROR	*/
  9    27 	/*  procedure calls the lex_error_ subroutine to perform the formatting and printing of	*/
  9    28 	/*  the error message.							*/
  9    29 	/*									*/
  9    30 	/* U__s_a_g_e									*/
  9    31 	/*									*/
  9    32 	/*      call ERROR (error_number);						*/
  9    33 	/*									*/
  9    34 	/* 1) error_number	is the index of one of the structures in the error_control_table	*/
  9    35 	/*		which defines the error message to be printed.			*/
  9    36 	/*									*/
  9    37 	/* N__o_t_e_s									*/
  9    38 	/*									*/
  9    39 	/*      The format of the error_control_table is shown below.			*/
  9    40 	/*									*/
  9    41 	/*   dcl	1 error_control_table (2)	aligned internal static,			*/
  9    42 	/*	  2 severity		fixed bin(17) unaligned init (2,3),		*/
  9    43 	/*	  2 Soutput_stmt		bit(1) unaligned initial ("0"b,"1"b),		*/
  9    44 	/*	  2 message		char(252) varying initial (			*/
  9    45 	/*		"The reduction source segment does not contain any reductions.",	*/
  9    46 	/*		"Reduction label  '^a'  is invalid."),				*/
  9    47 	/*	  2 brief_message		char(100) varying initial (			*/
  9    48 	/*		"", "'^a'");						*/
  9    49 	/*									*/
  9    50 	/* error_control_table is an array of structures, with one array element per error.	*/
  9    51 	/* Each structure contains: a severity level for the error; a switch which specifies	*/
  9    52 	/* whether the source statement being processed should be output after the error message;	*/
  9    53 	/* the long form of the error message text;  and the brief form of the error message text.*/
  9    54 	/* The dimension of the error_control_table array of structures, and the lengths of	*/
  9    55 	/* message (long message) and brief_message (brief message), are compiler-defined.	*/
  9    56 	/* structures and the lengths of the message and brief_message are compiler-defined.	*/
  9    57 	/* The only requirement is that the messages be 256 characters or less in length.	*/
  9    58 	/* (Remember that the longest character string which can be used in an initial attribute	*/
  9    59 	/* is 254 characters in length.)						*/
  9    60 	/*									*/
  9    61 	/*      The severity number causes the error message to be preceded by a herald which	*/
  9    62 	/* includes one of the following prefixes:					*/
  9    63 	/*									*/
  9    64 	/*       _s_e_v  _p_r_e_f_i_x 		  _e_x_p_l_a_n_a_t_i_o_n				*/
  9    65 	/*	0 = COMMENT		- this is a comment.			*/
  9    66 	/*	1 = WARNING		- a possible error has been detected.  The	*/
  9    67 	/*				  compiler will still generate an object segment.	*/
  9    68 	/*	2 = ERROR			- a probable error has been detected.  The	*/
  9    69 	/*				  compiler will still generate an object segment.	*/
  9    70 	/*	3 = FATAL ERROR		- an error has been detected which is so severe 	*/
  9    71 	/*				  that no object segment will be generated.	*/
  9    72 	/*	4 = TRANSLATOR ERROR	- an error has been detected in the operation of	*/
  9    73 	/*				  the compiler or translator.  No object segment	*/
  9    74 	/*				  will be generated.			*/
  9    75 	/*									*/
  9    76 	/* Full error messages are of the form:						*/
  9    77 	/*									*/
  9    78 	/*	_p_r_e_f_i_x _e_r_r_o_r__n_u_m_b_e_r, SEVERITY _s_e_v_e_r_i_t_y IN STATEMENT _n OF LINE _m		*/
  9    79 	/*	_t_e_x_t__o_f__e_r_r_o_r__m_e_s_s_a_g_e						*/
  9    80 	/*	SOURCE:								*/
  9    81 	/*	_s_o_u_r_c_e__s_t_a_t_e_m_e_n_t							*/
  9    82 	/*									*/
  9    83 	/* If only one statement appears in line _m, then "STATEMENT _n OF" is omitted.		*/
  9    84 	/* If the source statement has been printed in a previous error message, it is omitted.	*/
  9    85 	/*									*/
  9    86 	/*      The reduction compiler declares a bit string, SERROR_CONTROL, which controls the	*/
  9    87 	/* text of an error message.  The compiler may set this bit string, as shown below.	*/
  9    88 	/*									*/
  9    89 	/*   SERROR_CONTROL		_m_e_a_n_i_n_g						*/
  9    90 	/*	"00"b		the first time a particular error occurs, the long message	*/
  9    91 	/*			is printed; the brief message is used in subsequent	*/
  9    92 	/*			occurrences of that error.				*/
  9    93 	/*        "10"b or "11"b	the long error message is always used.			*/
  9    94 	/*	"01"b		the brief error message is always used.			*/
  9    95 	/* The initial value of SERROR_CONTROL is "00"b.					*/
  9    96 	/*									*/
  9    97 	/*      The reduction_compiler creates a declaration for SERROR_PRINTED, an array	*/
  9    98 	/* of switches (one per error).  The switch corresponding to a particular error is	*/
  9    99 	/* turned on whenever the error message is printed.  This allows lex_error_ to detect	*/
  9   100 	/* subsequent occurrences of that same error.					*/
  9   101 	/*									*/
  9   102 	/*      The reduction_compiler creates MERROR_SEVERITY, a fixed bin(17) integer		*/
  9   103 	/* in which the severity of the highest-severity error encountered is maintained.	*/
  9   104 	/* The compiler may reference this integer.					*/
  9   105 	/*									*/
  9   106 	/*      The reduction_compiler creates MIN_PRINT_SEVERITY, a fixed bin (17) integer	*/
  9   107 	/* which controls the printing of error messages by the ERROR procedure.		*/
  9   108 	/* Errors having a severity less than MIN_PRINT_SEVERITY will not cause lex_error_ to be	*/
  9   109 	/* and no error will be printed.  The behaviour of the ERROR procedure for such errors	*/
  9   110 	/* is controlled by the value of PRINT_SEVERITY_CONTROL, described below.		*/
  9   111 	/* The compiler may set the value of MIN_PRINT_SEVERITY; its initial value is 0.	*/
  9   112 
  9   113 	/*									*/
  9   114 	/*      The reduction_compiler declares a bit string, PRINT_SEVERITY_CONTROL, which 	*/
  9   115 	/* controls the updating of MERROR_SEVERITY and SERROR_PRINTED when the severity of an	*/
  9   116 	/* error is less than MIN_PRINT_SEVERITY.  In such cases, the lex_error_ procedure is not	*/
  9   117 	/* invoked, and the ERROR procedure must update these values as though lex_error_ were	*/
  9   118 	/* called.  The compiler may set this bit string, as shown below.			*/
  9   119 	/*									*/
  9   120 	/* PRINT_SEVERITY_CONTROL	_m_e_a_n_i_n_g						*/
  9   121 	/*	"00"b		update neither SERROR_PRINTED nor MERROR_SEVERITY.	*/
  9   122 	/*	"01"b		update SERROR_PRINTED to reflect the error.		*/
  9   123 	/*	"10"b		update MERROR_SEVERITY to reflect the error severity.	*/
  9   124 	/*	"11"b		update SERROR_PRINTED and MERROR_SEVERITY appropriately.	*/
  9   125 	/*The initial value of PRINT_SEVERITY_CONTROL is "11"b.				*/
  9   126 	/*									*/
  9   127 	/*      The ERROR procedure is simple to use, but it does limit the flexibility of the	*/
  9   128 	/* error message.  A compiler action routine can output more flexible error messages	*/
  9   129 	/* by calling lex_error_ directly.  See lex_error_ documentation for more details.	*/
  9   130 	/*									*/
  9   131 	/* S__t_a_t_u_s									*/
  9   132 	/*									*/
  9   133 	/* 0) Created:  April, 1974 by G. C. Dixon					*/
  9   134 	/* 1) Modified: April, 1982 by E. N. Kittlitz.  Added MIN_PRINT_SEVERITY, 		*/
  9   135 	/*		PRINT_SEVERITY_CONTROL.					*/
  9   136 	/*									*/
  9   137 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  9   138 
  9   139 ERROR:	procedure (Nerror);
  9   140 
  9   141      dcl	Nerror			fixed bin;	/* Number of the error which was detected. (In)	*/
  9   142 
  9   143      dcl	Pstmt			ptr,
  9   144 	1 erring_token		aligned based (Perring_token) like token,
  9   145 	Perring_token		ptr,
  9   146 	erring_token_value		char(erring_token.Lvalue) based (erring_token.Pvalue);
  9   147 
  9   148      dcl 	(max, null)		builtin;
  9   149 
  9   150      dcl	lex_error_		entry options (variable);
  9   151 
  9   152 
  9   153 	if error_control_table.severity(Nerror) < MIN_PRINT_SEVERITY then do; /* don't print		*/
  9   154 	     if PRINT_SEVERITY_CONTROL & "1"b then	/* update MERROR_SEVERITY			*/
  9   155 		MERROR_SEVERITY = max (MERROR_SEVERITY, error_control_table.severity(Nerror));
  9   156 	     if PRINT_SEVERITY_CONTROL & "01"b then	/* update SERROR_PRINTED			*/
  9   157 		SERROR_PRINTED(Nerror) = "1"b;
  9   158 	     return;
  9   159 	end;
  9   160 	Perring_token = Pthis_token;			/* address the current erring_token.		*/
  9   161 	if error_control_table.Soutput_stmt(Nerror) then
  9   162 	     if Perring_token = null then
  9   163 		Pstmt = null;
  9   164 	     else
  9   165 		Pstmt = erring_token.Pstmt;		/* address the statement descriptor.		*/
  9   166 	else
  9   167 	     Pstmt = null;
  9   168 	if Perring_token = null then
  9   169 	     call lex_error_ (Nerror, SERROR_PRINTED(Nerror), (error_control_table.severity(Nerror)),
  9   170 		MERROR_SEVERITY, Pstmt, Perring_token, SERROR_CONTROL, (error_control_table.message(Nerror)),
  9   171 		(error_control_table.brief_message(Nerror)));
  9   172 	else
  9   173 	     call lex_error_ (Nerror, SERROR_PRINTED(Nerror), (error_control_table.severity(Nerror)),
  9   174 		MERROR_SEVERITY, Pstmt, Perring_token, SERROR_CONTROL, (error_control_table.message(Nerror)),
  9   175 		(error_control_table.brief_message(Nerror)), erring_token_value, erring_token_value, erring_token_value);
  9   176 
  9   177 	end ERROR;
  9   178 
  9   179 	/* END OF:	rdc_error_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1893 
     1894 
     1895 		/* START OF:	rdc_next_stmt_.incl.pl1	  *  *  *  *  *  *  */
 10     2 
 10     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 10     4 	/*							*/
 10     5 	/* N__a_m_e:  rdc_next_stmt_.incl.pl1				*/
 10     6 	/*							*/
 10     7 	/*      This include segment is used by compilers generated by the	*/
 10     8 	/* reduction_compiler.  It includes a procedure which shifts the	*/
 10     9 	/* compilation process to the next source statement.		*/
 10    10 	/*							*/
 10    11 	/* S__t_a_t_u_s							*/
 10    12 	/*							*/
 10    13 	/* 0) Created:  April, 1974 by G. C. Dixon			*/
 10    14 	/*							*/
 10    15 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 10    16 
 10    17 
 10    18 NEXT_STMT:	procedure;			/* invoked to begin parsing the next statement of	*/
 10    19 						/* the input tokens.			*/
 10    20 
 10    21      dcl	null			builtin,
 10    22 	Ssearching		bit(1) aligned;
 10    23 
 10    24 	Ptoken = Pthis_token;			/* make sure these pointers are the same.	*/
 10    25 	Pstmt = token.Pstmt;			/* address "current" statement's descriptor.	*/
 10    26 	Ssearching = "1"b;				/* start scanning forward for next statement.	*/
 10    27 	do while (Ssearching & token.Pnext ^= null);
 10    28 	     Ptoken = token.Pnext;
 10    29 	     if token.Pstmt = Pstmt then;
 10    30 	     else Ssearching = "0"b;
 10    31 	     end;
 10    32 	if token.Pstmt = Pstmt then			/* if there is no next statement, and		*/
 10    33 	     if SPDL then				/*   in PUSH DOWN LANGUAGE mode, can't run off	*/
 10    34 		Ptoken = Ptoken;			/*   end of input list.			*/
 10    35 	     else Ptoken, Pthis_token = null;		/*   otherwise, input list exhausted.		*/
 10    36 	else Pthis_token = Ptoken;			/* normally, next statement exists and Ptoken	*/
 10    37 						/*   points to its 1st _n_o_n-__d_e_l_e_t_e_d token.	*/
 10    38 
 10    39 	end NEXT_STMT;
 10    40 
 10    41 	/* END OF:	rdc_next_stmt_.incl.pl1	  *  *  *  *  *  *  */
     1895 
     1896 
     1897 	end parse_bindfile_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/16/86  1213.2  parse_bindfile_.pl1               >spec>install>1094>parse_bindfile_.pl1
1253         1    12/18/84  0934.2  binder_input.incl.pl1             >ldd>include>binder_input.incl.pl1
1255         2    07/23/74  1840.0  option.incl.pl1                   >ldd>include>option.incl.pl1
1257         3    07/16/86  0845.5  bndtbl.incl.pl1                   >spec>install>1094>bndtbl.incl.pl1
1259         4    07/16/86  0841.5  bindext.incl.pl1                  >spec>install>1094>bindext.incl.pl1
1266         5    04/18/75  1242.4  rdc_start_.incl.pl1               >ldd>include>rdc_start_.incl.pl1
5-25         6    04/18/75  1242.4  lex_descriptors_.incl.pl1         >ldd>include>lex_descriptors_.incl.pl1
1399         7    03/17/86  1534.3  rdc_end_.incl.pl1                 >ldd>include>rdc_end_.incl.pl1
1891         8    04/18/75  1242.4  rdc_lex_.incl.pl1                 >ldd>include>rdc_lex_.incl.pl1
1893         9    08/15/83  1511.7  rdc_error_.incl.pl1               >ldd>include>rdc_error_.incl.pl1
1895        10    04/18/75  1242.4  rdc_next_stmt_.incl.pl1           >ldd>include>rdc_next_stmt_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ARG_list_error                  000241 automatic       bit(1)                   initial unaligned dcl 245 set ref 245* 939 1792*
                                                                                  1802*
Addname_idx                     000270 automatic       fixed bin(17,0)          initial dcl 317 set ref 317* 523 614
BACKSPACE                       011541 constant        char(1)                  initial dcl 5-99 ref 7-113
CODE                            000405 automatic       fixed bin(35,0)          dcl 5-33 set ref 7-106* 7-107
DIRECTION                       000410 automatic       fixed bin(17,0)          initial dcl 1268 set ref 7-62 1268*
DUP_objectname                  000013 internal static fixed bin(17,0)          initial dcl 337 set ref 861*
DUP_stmt                               constant        fixed bin(17,0)          initial dcl 337 ref 614 624 637 667 712 721 732 748
                                                                                  761 773 783 811 826 905 917 927
ERROR_OUTPUT                    000010 internal static char(12)                 initial unaligned dcl 315 set ref 1118* 1127* 1134*
                                                                                  1144* 1152*
EXCLUSIVE_stmt                         constant        fixed bin(17,0)          initial dcl 337 ref 625 626 733 734 749 750 1242
FORCE_ORDER                     000203 automatic       fixed bin(17,0)          initial dcl 227 set ref 227* 628 736 1140
FORM                                   based           fixed bin(17,0)          level 2 packed unaligned dcl 5-48 ref 7-65 7-70
                                                                                  7-123
FOrder_idx                      000271 automatic       fixed bin(17,0)          initial dcl 317 set ref 317* 525 586 624 733 749
Global_idx                      000272 automatic       fixed bin(17,0)          initial dcl 317 set ref 317* 527 637
I                                      based           fixed bin(17,0)          level 2 in structure "TOKEN_REQD_STRING" packed
                                                                                  unaligned dcl 5-48 in procedure
                                                                                  "SEMANTIC_ANALYSIS" ref 7-126
I                               000406 automatic       fixed bin(17,0)          dcl 5-33 in procedure "SEMANTIC_ANALYSIS" set ref
                                                                                  7-62* 7-63 7-79*
IFIRST                                 based           fixed bin(17,0)          level 3 packed unaligned dcl 5-48 ref 7-62 7-73 7-79
                                                                                  7-79
ILAST                     0(18)        based           fixed bin(17,0)          level 3 packed unaligned dcl 5-48 ref 7-62 7-73 7-79
Ignore_idx                      000273 automatic       fixed bin(17,0)          initial dcl 317 set ref 317* 529 590 667
L                         0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 5-48 ref 7-127
LTOKEN_REQD_VALUE               000374 automatic       fixed bin(18,0)          dcl 5-33 set ref 7-127* 7-128
Linput                          000155 automatic       fixed bin(21,0)          dcl 215 set ref 419 432* 1213*
Linput_ignore                   000156 automatic       fixed bin(21,0)          initial dcl 215 set ref 215* 432*
Lvalue                    4            based           fixed bin(18,0)          level 2 in structure "token" dcl 6-68 in procedure
                                                                                  "parse_bindfile_" ref 467 467 467 467 486 488 501
                                                                                  523 525 527 529 531 533 535 537 539 541 543 545
                                                                                  547 549 551 553 555 638 640 642 644 676 681 722
                                                                                  724 784 786 788 790 845 946 950 1000 1001 1001
                                                                                  1003 7-92 7-92 7-92 7-92 7-106 7-106 7-113 7-113
                                                                                  7-128 1725 1733
Lvalue                    4            based           fixed bin(18,0)          level 2 in structure "erring_token" dcl 9-143
                                                                                  in procedure "ERROR" ref 9-172 9-172 9-172 9-172
                                                                                  9-172 9-172
MAX_error                       000244 automatic       bit(1)                   initial unaligned dcl 248 set ref 248*
MERROR_SEVERITY                 000333 automatic       fixed bin(17,0)          initial dcl 9-3 set ref 9-3* 1034 1117* 1117 1126*
                                                                                  1133* 1143* 1151* 1181 9-154* 9-154 9-168* 9-172*
MIN_PRINT_SEVERITY              000335 automatic       fixed bin(17,0)          initial dcl 9-3 set ref 425* 9-3* 9-153
MYNAME                          000170 automatic       char(32)                 unaligned dcl 224 set ref 385* 387* 408* 412* 421*
                                                                                  441* 443*
NOBJ                            000320 automatic       fixed bin(17,0)          initial dcl 1-80 set ref 390* 401 401 1-80* 1218
                                                                                  1218
NO_obj                                 constant        fixed bin(17,0)          initial dcl 337 ref 1056 1238
NO_such_seg                     000014 internal static fixed bin(17,0)          initial dcl 337 set ref 685* 848* 954*
NRED                            000375 automatic       fixed bin(17,0)          dcl 5-33 set ref 7-52* 7-55* 7-55 7-58 1421 1434*
                                                                                  1437* 1444* 1450* 1457* 1462* 1469* 1476* 1481*
                                                                                  1488* 1493* 1498* 1505* 1512* 1517* 1524* 1529*
                                                                                  1536* 1541* 1546* 1552* 1557* 1564* 1571* 1576*
                                                                                  1582* 1587* 1593* 1598* 1605* 1612* 1617* 1623*
                                                                                  1628* 1634* 1639* 1644* 1649* 1654* 1660* 1667*
                                                                                  1673* 1679* 1684* 1690* 1696* 1702* 1708* 1714*
                                                                                  1719* 1727* 1735* 1741* 1747* 1753* 1759* 1764*
                                                                                  1771* 1779* 1786* 1796* 1806* 1812* 1819* 1825*
                                                                                  1832* 1839* 1845* 1850* 1856* 1863* 1869* 1875*
                                                                                  1880*
NTOTAL                          000321 automatic       fixed bin(17,0)          initial dcl 1-80 set ref 389* 401 401 1-80* 1218
                                                                                  1218
NUMBER                          000407 automatic       fixed bin(35,0)          dcl 5-33 set ref 7-106* 7-108
Nerror                                 parameter       fixed bin(17,0)          dcl 9-141 set ref 9-139 9-153 9-154 9-156 9-161
                                                                                  9-168* 9-168 9-168 9-168 9-168 9-172* 9-172 9-172
                                                                                  9-172 9-172
No_Table_idx                    000274 automatic       fixed bin(17,0)          initial dcl 317 set ref 317* 531 600 712
Nvalue                   10            based           fixed bin(35,0)          level 3 packed unaligned dcl 6-68 set ref 7-101
                                                                                  7-108*
ORDER                           000202 automatic       fixed bin(17,0)          initial dcl 227 set ref 227* 739 1148
Objectname_idx                  000275 automatic       fixed bin(17,0)          initial dcl 317 set ref 317* 533 721
Order_idx                       000276 automatic       fixed bin(17,0)          initial dcl 317 set ref 317* 535 584 625 732 750
PARTIAL_ORDER                   000204 automatic       fixed bin(17,0)          initial dcl 227 set ref 227* 752 983 1156
POrder_idx                      000277 automatic       fixed bin(17,0)          initial dcl 317 set ref 317* 537 588 626 734 748
                                                                                  1242
PRED                            000376 automatic       pointer                  dcl 5-33 set ref 7-58* 7-62 7-62 7-73 7-73 7-79 7-79
                                                                                  7-79
PRINT_SEVERITY_CONTROL          000336 automatic       bit(2)                   initial unaligned dcl 9-3 set ref 9-3* 9-154 9-156
PStatic_idx                     000300 automatic       fixed bin(17,0)          initial dcl 317 set ref 317* 539 602 761
PTOKEN_REQD                     000400 automatic       pointer                  dcl 5-33 set ref 7-63* 7-65 7-65 7-70 7-71 7-123
                                                                                  7-126 7-127 1402
PTOKEN_REQD_VALUE               000402 automatic       pointer                  dcl 5-33 set ref 7-126* 7-128
Parameters                      000247 automatic       bit(1)                   unaligned dcl 251 set ref 615* 654* 763* 1040 1072*
                                                                                  1214*
Perring_token                   000102 automatic       pointer                  dcl 9-143 set ref 9-160* 9-161 9-164 9-168 9-168*
                                                                                  9-172* 9-172 9-172 9-172 9-172 9-172 9-172 9-172
                                                                                  9-172 9-172
Pfirst_stmt_descriptor          000160 automatic       pointer                  initial dcl 215 set ref 215* 432*
Pfirst_token_descriptor         000162 automatic       pointer                  initial dcl 215 set ref 215* 432* 435
Pinput                          000164 automatic       pointer                  initial dcl 215 set ref 215* 432* 1211*
Plast                     2            based           pointer                  level 2 packed unaligned dcl 6-68 ref 8-45 8-47
Pnext                     1            based           pointer                  level 2 packed unaligned dcl 6-68 ref 696 696 976
                                                                                  976 7-79 1417 1432 1449 1460 1479 1491 1496 1515
                                                                                  1527 1539 1544 1555 1574 1585 1596 1615 1626 1637
                                                                                  1642 1647 1659 1663 1672 1687 1707 8-39 8-40 10-27
                                                                                  10-28
Psegment                        000166 automatic       pointer                  initial dcl 215 set ref 215* 380 380* 408* 432* 450
                                                                                  450*
Pstmt                           000326 automatic       pointer                  dcl 6-40 in procedure "parse_bindfile_" set ref
                                                                                  10-25* 10-29 10-32
Pstmt                     5            based           pointer                  level 2 in structure "token" packed unaligned
                                                                                  dcl 6-68 in procedure "parse_bindfile_" ref 10-25
                                                                                  10-29 10-32
Pstmt                           000100 automatic       pointer                  dcl 9-143 in procedure "ERROR" set ref 9-161* 9-164*
                                                                                  9-166* 9-168* 9-172*
Pstmt                     5            based           pointer                  level 2 in structure "erring_token" packed unaligned
                                                                                  dcl 9-143 in procedure "ERROR" ref 9-164
Pthis_token                     000324 automatic       pointer                  dcl 5-23 set ref 435* 439 669 670* 696* 701* 940
                                                                                  941* 976* 981* 7-60 1420 1432 1432* 1449 1449*
                                                                                  1460 1460* 1479 1479* 1491 1491* 1496 1496* 1515
                                                                                  1515* 1527 1527* 1539 1539* 1544 1544* 1555 1555*
                                                                                  1574 1574* 1585 1585* 1596 1596* 1615 1615* 1626
                                                                                  1626* 1637 1637* 1642 1642* 1647 1647* 1659 1659*
                                                                                  1663 1663* 1672 1672* 1687 1687* 1707 1707* 8-36
                                                                                  8-49* 9-160 10-24 10-35* 10-36*
Ptoken                          000330 automatic       pointer                  dcl 6-68 set ref 467 467 467 467 467 467 467 467 486
                                                                                  488 501 523 523 525 525 527 527 529 529 531 531
                                                                                  533 533 535 535 537 537 539 539 541 541 543 543
                                                                                  545 545 547 547 549 549 551 551 553 553 555 555
                                                                                  638 638 640 640 642 642 644 644 722 724 724 784
                                                                                  784 786 786 788 788 790 790 845 845 1000 1001 1001
                                                                                  1001 1003 7-60* 7-64 7-73 7-79 7-86 7-92 7-92 7-92
                                                                                  7-92 7-92 7-92 7-92 7-101 7-104 7-106 7-106 7-106
                                                                                  7-108 7-113 7-113 7-113 7-113 7-118 7-124 7-128
                                                                                  7-128 1417* 1417 1420* 1432* 1449* 1455 1460*
                                                                                  1479* 1486 1491* 1496* 1515* 1522 1527* 1534 1539*
                                                                                  1544* 1555* 1574* 1585* 1596* 1615* 1626* 1637*
                                                                                  1642* 1647* 1659* 1663* 1672* 1687* 1707* 1725
                                                                                  1725 1733 1733 8-36* 8-37 8-39 8-40* 8-40 8-42*
                                                                                  8-45 8-47* 8-47 8-49 10-24* 10-25 10-27 10-28*
                                                                                  10-28 10-29 10-32 10-32* 10-32 10-35* 10-36
Pvalue                    3            based           pointer                  level 2 in structure "erring_token" packed unaligned
                                                                                  dcl 9-143 in procedure "ERROR" ref 9-172 9-172
                                                                                  9-172
Pvalue                    3            based           pointer                  level 2 in structure "token" packed unaligned
                                                                                  dcl 6-68 in procedure "parse_bindfile_" ref 467
                                                                                  467 467 467 523 525 527 529 531 533 535 537 539
                                                                                  541 543 545 547 549 551 553 555 638 640 642 644
                                                                                  681 724 784 786 788 790 845 950 1001 7-92 7-92
                                                                                  7-106 7-113 7-128 1725 1733
RED                                    based           structure                level 1 dcl 5-48
REDUCTION                              based           structure                array level 1 packed unaligned dcl 1271 set ref 7-58
REDUCTIONS                      001603 constant        fixed bin(17,0)          initial array unaligned dcl 1271 set ref 7-58
S                        11            based           structure                level 3 packed unaligned dcl 6-68
SERROR_CONTROL                  000334 automatic       bit(2)                   initial unaligned dcl 9-3 set ref 417* 9-3* 9-168*
                                                                                  9-172*
SERROR_PRINTED                  000335 automatic       bit(1)                   initial array unaligned dcl 9-3 set ref 9-3* 9-156*
                                                                                  9-168* 9-172*
SKIP_stmt                              constant        fixed bin(17,0)          initial dcl 337 ref 561 862
SPDL                            000332 automatic       bit(1)                   initial dcl 1888 set ref 1888* 7-73 8-42 10-32
STOKEN_FCN                      000404 automatic       bit(1)                   dcl 5-33 set ref 1404* 1406* 1408* 1410* 1413
Soutput_stmt              1     000000 constant        bit(1)                   initial array level 2 packed unaligned dcl 276 ref
                                                                                  9-161
Ssearching                      000454 automatic       bit(1)                   dcl 10-21 set ref 10-26* 10-27 10-30*
TOKEN_REQD                             based           structure                level 2 in structure "RED" packed unaligned dcl 5-48
                                                                                  in procedure "SEMANTIC_ANALYSIS"
TOKEN_REQD                             based           structure                level 1 dcl 5-48 in procedure "SEMANTIC_ANALYSIS"
TOKEN_REQD_STRING                      based           structure                level 1 dcl 5-48
TOKEN_REQD_VALUE                       based           char                     unaligned dcl 5-48 ref 7-128
TOKEN_REQUIREMENT                      based           structure                array level 1 packed unaligned dcl 1355 set ref 7-63
TOKEN_REQUIREMENTS              001504 constant        fixed bin(17,0)          initial array unaligned dcl 1355 set ref 7-63
TOKEN_STRINGS                          based           char(136)                dcl 1393 set ref 7-126
TOKEN_STRING_ARRAYS             001422 constant        char(100)                initial array dcl 1393 set ref 7-126
TRACING                         000015 internal static bit(1)                   initial dcl 1263 set ref 7-50* 7-50
TYPE                      0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 5-48 ref 7-65 7-71 1402
Word                                   based           fixed bin(17,0)          array dcl 268 set ref 1045* 1185* 1185
Word_extent                     000212 automatic       fixed bin(17,0)          initial dcl 235 set ref 235* 1044* 1045 1183* 1185
acc_ope                                based           structure                level 1 dcl 262
addr                                                   builtin function         dcl 5-92 in procedure "SEMANTIC_ANALYSIS" ref 7-58
                                                                                  7-58 7-63 7-63 7-126 7-126
addr                                                   builtin function         dcl 353 in procedure "parse_bindfile_" ref 680 949
                                                                                  998 1048 1048 1078 1110 1183 1188 1191 1236
addrel                                                 builtin function         dcl 353 ref 401 401 1218 1218 1222 1222
adnp                            000322 automatic       pointer                  dcl 3-17 set ref 1221* 1222 1222 1224 1225 1657 1722
                                                                                  1722 1724 1724 1725 1725 1730 1730 1732 1732 1733
                                                                                  1733
an                                     based           structure                level 1 dcl 3-40
areap                           000266 automatic       pointer                  initial dcl 255 set ref 255* 638 640 642 647 713
                                                                                  1044 1045 1070 1227* 1234 1234 1234 1234 1234 1236
arg                                    based           char                     unaligned dcl 261 ref 681 950
arg_count                       000200 automatic       fixed bin(17,0)          dcl 225 set ref 674 944 1456* 1487* 1523* 1535*
                                                                                  1769* 1769 1776* 1776 1791 1801
arg_ptr                         000252 automatic       pointer                  initial dcl 255 set ref 255* 670 676 681 681 696
                                                                                  696* 941 946 950 950 976 976* 1455* 1486* 1522*
                                                                                  1534*
bin                                                    builtin function         dcl 353 ref 1070
bindfile_bc              30            based           fixed bin(24,0)          level 2 dcl 1-10 ref 392 1213
bindfile_name            31            based           char(32)                 level 2 packed unaligned dcl 1-10 set ref 421* 441*
bindfilep                26            based           pointer                  level 2 dcl 1-10 ref 392 1211
bit                                                    builtin function         dcl 353 ref 1070
bitcount                               based           fixed bin(24,0)          array level 3 in structure "inp" dcl 1-10
                                                                                  in procedure "parse_bindfile_" set ref 852
bitcount                 12            based           fixed bin(24,0)          level 2 in structure "obj" dcl 1-63 in procedure
                                                                                  "parse_bindfile_" set ref 688 966 1113
bound_seg_name           11            based           char(32)                 level 2 packed unaligned dcl 1-10 ref 391
breaks                          000100 automatic       varying char(9)          dcl 215 set ref 429* 430* 432*
brief_message            32     000000 constant        varying char(1)          initial array level 2 dcl 276 ref 9-168 9-172
bx_$addname                     000054 external static fixed bin(17,0)          dcl 4-58 set ref 395* 616* 1043*
bx_$addname_limit               000036 external static fixed bin(17,0)          dcl 4-24 ref 1222 1222 1225
bx_$adnp                        000046 external static pointer                  dcl 4-36 set ref 396* 1042* 1221*
bx_$bound_segname               000050 external static char(32)                 dcl 4-48 set ref 391* 724*
bx_$brief                       000060 external static fixed bin(17,0)          dcl 4-60 ref 425 812 1113
bx_$caller                      000070 external static char(32)                 dcl 4-80 ref 387
bx_$debug                       000056 external static fixed bin(17,0)          dcl 4-59 ref 385
bx_$fatal_error                 000052 external static fixed bin(17,0)          dcl 4-49 set ref 382* 413* 988* 1036*
bx_$force_order                 000062 external static fixed bin(17,0)          dcl 4-61 ref 736 1242
bx_$freep                       000040 external static pointer                  dcl 4-27 ref 400 1217 1221 1227
bx_$inpp                        000042 external static pointer                  dcl 4-29 set ref 388 1197*
bx_$ncomp                       000066 external static fixed bin(17,0)          dcl 4-74 set ref 679 844 948 1108 1187 1196*
bx_$optp                        000044 external static pointer                  dcl 4-32 set ref 394* 1227*
bx_$perprocess_static           000064 external static fixed bin(17,0)          dcl 4-65 set ref 762*
cleanup                         000312 stack reference condition                dcl 376 ref 378
code                    101            based           char(1)                  level 2 in structure "acc_ope" dcl 262 in procedure
                                                                                  "parse_bindfile_" set ref 1002*
code                            000201 automatic       fixed bin(35,0)          dcl 226 in procedure "parse_bindfile_" set ref 380*
                                                                                  408* 410 412* 432* 437 441 443* 450*
collate                                                builtin function         dcl 353 ref 428
com_err_                        000020 constant        entry                    external dcl 359 ref 412 421 441 443
copyp                           000264 automatic       pointer                  initial dcl 255 set ref 255* 400* 401 401 1185 1191
                                                                                  1196 1197 1217* 1218 1218
cv_dec_check_                   000072 constant        entry                    external dcl 5-96 ref 7-106
delete                    1(18)        based           char(1)                  level 2 packed unaligned dcl 2-12 set ref 784* 874*
delete_idx                      000301 automatic       fixed bin(17,0)          initial dcl 317 set ref 317* 541 773 862 880 1018
                                                                                  1056 1238
dimension                                              builtin function         dcl 353 ref 9-3 9-3
divide                                                 builtin function         dcl 353 ref 1213
entryname_too_long              000242 automatic       bit(1)                   initial unaligned dcl 246 set ref 246* 483* 488*
                                                                                  1853 1859
erring_token                           based           structure                level 1 dcl 9-143
erring_token_value              000100 automatic       char(32)                 unaligned dcl 1101 in procedure "ACTION" set ref
                                                                                  1111* 1118* 1127* 1134* 1144* 1152*
erring_token_value                     based           char                     unaligned dcl 9-143 in procedure "ERROR" set ref
                                                                                  9-172* 9-172* 9-172*
error_control_table             000000 constant        structure                array level 1 unaligned dcl 276 ref 9-3 9-3
error_table_$zero_length_seg    000016 external static fixed bin(35,0)          dcl 348 set ref 421* 441
filename                               based           char(32)                 array level 3 in structure "inp" packed unaligned
                                                                                  dcl 1-10 in procedure "parse_bindfile_" set ref
                                                                                  845 1183 1188 1191
filename                               based           char(32)                 level 2 in structure "obj" packed unaligned dcl 1-63
                                                                                  in procedure "parse_bindfile_" set ref 681 950
                                                                                  1111
fixed                                                  builtin function         dcl 353 ref 1044 1044 1070 1070 1183 1183 1183
flag                     13(29)        based           bit(1)                   level 2 packed unaligned dcl 1-63 set ref 958 973*
g_delete                  0(18)        based           char(1)                  level 2 packed unaligned dcl 2-3 set ref 638* 1234*
g_indirect                0(09)        based           char(1)                  level 2 packed unaligned dcl 2-3 set ref 647* 1234*
g_nolink                  0(27)        based           char(1)                  level 2 packed unaligned dcl 2-3 set ref 642* 1234*
g_notable                 1            based           char(1)                  level 2 packed unaligned dcl 2-3 set ref 713* 1234*
g_retain                               based           char(1)                  level 2 packed unaligned dcl 2-3 set ref 640* 1234*
global_idx                      000302 automatic       fixed bin(17,0)          initial dcl 317 set ref 317* 543 783 862 881 1056
                                                                                  1238
group2                    7            based           structure                level 2 packed unaligned dcl 6-68
i                               000206 automatic       fixed bin(17,0)          dcl 233 in procedure "parse_bindfile_" set ref 674*
                                                                                  944* 1108* 1110* 1187* 1188*
i                               000442 automatic       fixed bin(17,0)          dcl 8-33 in procedure "LEX" set ref 8-39* 8-42 8-45*
ignore_seen                     000243 automatic       bit(1)                   initial unaligned dcl 247 set ref 247* 668* 1031
ignored_breaks                  000104 automatic       varying char(6)          dcl 215 set ref 428* 429 430* 432*
indirect                  1(09)        based           char(1)                  level 2 packed unaligned dcl 2-12 set ref 793* 874*
indirect_idx                    000303 automatic       fixed bin(17,0)          initial dcl 317 set ref 317* 545 811 862 882 1014
                                                                                  1056 1238
inp                                    based           structure                level 1 dcl 1-10 set ref 401 401 1218 1218
inpp                            000260 automatic       pointer                  initial dcl 255 set ref 255* 388* 389 390 391 392
                                                                                  392 397 401 401 421 441 680 845 852 859 876 949
                                                                                  1031 1065 1070 1110 1183 1183 1185 1188 1197* 1211
                                                                                  1213 1218 1218
ioa_$ioa_stream                 000022 constant        entry                    external dcl 359 ref 1118 1127 1134 1144 1152
j                               000207 automatic       fixed bin(17,0)          dcl 233 set ref 679* 680* 948* 949* 1104* 1171* 1171
                                                                                  1172
k                               000210 automatic       fixed bin(17,0)          dcl 233 set ref 938* 974* 974 975 983
keyword_idx                     000211 automatic       fixed bin(17,0)          dcl 234 set ref 523* 525* 527* 529* 531* 533* 535*
                                                                                  537* 539* 541* 543* 545* 547* 549* 551* 553* 555*
                                                                                  559 561 564 584 586 588 590 600 602 604 1012 1014
                                                                                  1016 1018 1020 1424* 1441
lex_control_chars               000132 automatic       varying char(70)         dcl 215 set ref 430* 432*
lex_delims                      000107 automatic       varying char(70)         dcl 215 set ref 430* 432*
lex_error_                      000074 constant        entry                    external dcl 9-150 ref 9-168 9-172
lex_string_$init_lex_delims     000026 constant        entry                    external dcl 359 ref 430
lex_string_$lex                 000024 constant        entry                    external dcl 359 ref 432
lng                     102            based           fixed bin(17,0)          level 2 dcl 262 set ref 1003*
max                                                    builtin function         dcl 353 in procedure "parse_bindfile_" ref 1117
max                                                    builtin function         dcl 9-148 in procedure "ERROR" ref 9-154
max_size                               based           fixed bin(17,0)          level 2 dcl 3-40 set ref 1225* 1724 1732
message                   2     000000 constant        varying char(90)         initial array level 2 dcl 276 ref 1118 1127 1134
                                                                                  1144 1152 9-168 9-172
n                                      parameter       fixed bin(17,0)          dcl 8-33 ref 8-31 8-38 8-39 8-42 8-45
n_an                      1            based           fixed bin(17,0)          level 2 dcl 3-40 set ref 1224* 1657* 1722* 1722 1724
                                                                                  1725 1730* 1730 1732 1733
n_delete                  6            based           fixed bin(17,0)          level 2 dcl 2-12 set ref 872* 1018* 1018
n_indirect                5            based           fixed bin(17,0)          level 2 dcl 2-12 set ref 872* 1014* 1014
n_nolink                  7            based           fixed bin(17,0)          level 2 dcl 2-12 set ref 872* 1012* 1012
n_options                              based           fixed bin(17,0)          level 2 dcl 2-12 set ref 872* 997* 997 998 1074
                                                                                  1076* 1076* 1078
n_retain                  4            based           fixed bin(17,0)          level 2 dcl 2-12 set ref 872* 1016* 1016
n_synonyms                3            based           fixed bin(17,0)          level 2 dcl 2-12 set ref 872* 894* 1020* 1020 1076*
new_nobj                        000213 automatic       fixed bin(17,0)          dcl 236 set ref 1106* 1175* 1175 1196
new_order                13(18)        based           fixed bin(9,0)           level 2 packed unsigned unaligned dcl 1-63 set ref
                                                                                  975* 1113 1124 1140 1148 1156 1160* 1172* 1175
                                                                                  1189 1191
no_link                   1(27)        based           char(1)                  level 2 packed unaligned dcl 2-12 set ref 788* 874*
no_link_idx                     000304 automatic       fixed bin(17,0)          initial dcl 317 set ref 317* 547 826 862 883 1012
                                                                                  1056 1238
no_parameters                   000245 automatic       bit(1)                   unaligned dcl 249 set ref 714* 776* 800* 816* 829*
                                                                                  878* 908* 920* 929* 1062 1073* 1215*
nobj                     24            based           fixed bin(17,0)          level 2 dcl 1-10 set ref 390 1196*
ntotal                   23            based           fixed bin(17,0)          level 2 dcl 1-10 ref 389 680 845 852 859 876 949
                                                                                  1065 1070 1110 1183 1188 1191
null                                                   builtin function         dcl 5-92 in procedure "SEMANTIC_ANALYSIS" ref 7-64
                                                                                  7-73 7-79 7-86
null                                                   builtin function         dcl 353 in procedure "parse_bindfile_" ref 215 215
                                                                                  215 215 255 255 255 255 255 255 255 380 392 394
                                                                                  396 439 450 1042 8-37 8-39 8-42 8-45
null                                                   builtin function         dcl 9-148 in procedure "ERROR" ref 9-161 9-161 9-166
                                                                                  9-168
null                                                   builtin function         dcl 10-21 in procedure "NEXT_STMT" ref 10-27 10-35
obj                                    based           structure                level 1 dcl 1-63 in procedure "parse_bindfile_" set
                                                                                  ref 1192* 1192
obj                                    based           structure                array level 2 in structure "inp" dcl 1-10
                                                                                  in procedure "parse_bindfile_" set ref 680 949
                                                                                  1110
obj_idx                         000214 automatic       fixed bin(17,0)          initial dcl 237 set ref 237* 844* 845* 852 859 876
                                                                                  1065 1065 1070 1070 1078 1080*
objectname_idx                  000305 automatic       fixed bin(17,0)          initial dcl 317 set ref 317* 549 836
objectname_stmt                        based           bit(1)                   array level 3 in structure "inp" packed unaligned
                                                                                  dcl 1-10 in procedure "parse_bindfile_" set ref
                                                                                  876*
objectname_stmt          13(28)        based           bit(1)                   level 2 in structure "obj" packed unaligned dcl 1-63
                                                                                  in procedure "parse_bindfile_" set ref 1113 1131
                                                                                  1140
op                                     based           structure                level 1 dcl 2-12
opes                     10            based           structure                array level 2 dcl 2-12 set ref 998 1048 1048 1078
opt_code                        000240 automatic       char(1)                  unaligned dcl 243 set ref 775* 815* 828* 892* 907*
                                                                                  919* 1002
opt_counter                     000215 automatic       fixed bin(17,0)          dcl 238 set ref 774* 814* 827* 891* 906* 918* 996*
                                                                                  996 1012 1014 1016 1018 1020 1048 1048
option                                 based           bit(18)                  array level 3 in structure "inp" packed unaligned
                                                                                  dcl 1-10 in procedure "parse_bindfile_" set ref
                                                                                  859 1065* 1070*
option                                 based           structure                level 1 dcl 2-3 in procedure "parse_bindfile_"
options                  47            based           structure                level 2 dcl 1-10
optp                            000262 automatic       pointer                  initial dcl 255 set ref 255* 784 786 788 793 872 872
                                                                                  872 872 872 872 874 874 874 874 874 894 928 997
                                                                                  997 998 998 1012 1012 1014 1014 1016 1016 1018
                                                                                  1018 1020 1020 1044 1048 1048 1070 1074 1076 1076
                                                                                  1076 1078* 1078 1078 1236*
order_error                     000246 automatic       bit(1)                   initial unaligned dcl 250 set ref 250* 939* 955*
                                                                                  962* 969* 988
order_type                      000205 automatic       fixed bin(17,0)          initial dcl 232 set ref 232* 628* 736* 739* 752* 983
                                                                                  1031 1140 1148 1156 1169
p                               000254 automatic       pointer                  initial dcl 255 set ref 255* 680* 681 688 688 695
                                                                                  949* 950 958 966 973 975 998* 999 1000 1001 1002
                                                                                  1003 1110* 1111 1113 1113 1113 1122 1124 1131 1140
                                                                                  1140 1148 1148 1156 1156 1160 1169 1172 1175 1188*
                                                                                  1189 1191 1192
p1                              000256 automatic       pointer                  initial dcl 255 set ref 255* 669* 701 940* 981 1191*
                                                                                  1192
partial_order_number            000216 automatic       fixed bin(17,0)          initial dcl 239 set ref 239* 983* 1159* 1159 1160
quoted_string            11(01)        based           bit(1)                   level 4 packed unaligned dcl 6-68 ref 7-92 7-104
                                                                                  7-113 7-118 7-124
rel                                                    builtin function         dcl 353 ref 1044 1044 1070 1070 1183 1183
reset                                  based           bit(2313)                unaligned dcl 269 set ref 999*
retain                    1            based           char(1)                  level 2 packed unaligned dcl 2-12 set ref 786* 874*
retain_idx                      000306 automatic       fixed bin(17,0)          initial dcl 317 set ref 317* 551 862 884 905 1016
                                                                                  1056 1238
rpte                                   based           structure                level 1 dcl 3-63
search                                                 builtin function         dcl 5-92 ref 7-92
seg                                    based           structure                level 1 dcl 3-29
segname_too_long                000250 automatic       bit(1)                   initial unaligned dcl 252 set ref 252* 483* 486*
                                                                                  499* 503* 839 1767 1774 1782 1835
severity                        000000 constant        fixed bin(17,0)          initial array level 2 dcl 276 ref 9-153 9-154 9-168
                                                                                  9-172
size                                                   builtin function         dcl 353 ref 401 401 1218 1218
stmt_error                      000217 automatic       fixed bin(17,0)          initial array dcl 241 set ref 241* 559 561 564* 614*
                                                                                  624* 625* 626* 637* 667* 712* 721* 732* 733* 734*
                                                                                  748* 749* 750* 761* 773* 783* 811* 826* 836* 862*
                                                                                  862* 862* 862* 862* 862* 862* 880* 881* 882* 883*
                                                                                  884* 885* 886* 905* 917* 927* 1056* 1056* 1056*
                                                                                  1056* 1056* 1056* 1056* 1238* 1238* 1238* 1238*
                                                                                  1238* 1238* 1238* 1242*
structures                2            based           fixed bin(17,0)          level 2 dcl 2-3 set ref 1236
substr                                                 builtin function         dcl 5-92 in procedure "SEMANTIC_ANALYSIS" ref 7-92
                                                                                  7-126
substr                                                 builtin function         dcl 353 in procedure "parse_bindfile_" set ref 428
                                                                                  1001*
symb                      0(09)        based           char(256)                level 2 packed unaligned dcl 262 set ref 1001*
symb_len                               based           fixed bin(9,0)           level 2 packed unsigned unaligned dcl 262 set ref
                                                                                  1000*
syn                       2            based           char(32)                 array level 2 dcl 3-40 set ref 1725* 1733*
synonym_idx                     000307 automatic       fixed bin(17,0)          initial dcl 317 set ref 317* 553 862 885 917 1020
                                                                                  1056 1238
table                     2            based           char(1)                  level 2 packed unaligned dcl 2-12 set ref 874* 928*
table_idx                       000310 automatic       fixed bin(17,0)          initial dcl 317 set ref 317* 555 604 862 886 927
                                                                                  1056 1238
temp_mgr_$reserve               000030 constant        entry                    external dcl 359 ref 401 1048 1218 1222
to_be_ignored            13(27)        based           bit(1)                   level 2 packed unaligned dcl 1-63 set ref 688 695*
                                                                                  1122 1148 1156 1169
token                                  based           structure                level 1 dcl 6-68
token_value                            based           char                     unaligned dcl 6-68 set ref 467 467 467 467 523 525
                                                                                  527 529 531 533 535 537 539 541 543 545 547 549
                                                                                  551 553 555 638 640 642 644 724 784 786 788 790
                                                                                  845 1001 7-92 7-92 7-106* 7-113 7-128 1725 1733
translator_temp_$get_segment    000032 constant        entry                    external dcl 359 ref 408
translator_temp_$release_all_segments
                                000034 constant        entry                    external dcl 359 ref 380 450
verify                                                 builtin function         dcl 5-92 ref 7-92
zeroseg_seen             47(06)        based           bit(1)                   level 3 packed unaligned dcl 1-10 ref 397 1031

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BINDER_INPUT_VERSION_2                 internal static char(4)                  initial dcl 1-79
INTERNALLY_RESOLVED                    internal static bit(18)                  initial unaligned dcl 3-91
Pcomment                               automatic       pointer                  dcl 6-20
UNRESOLVED                             internal static bit(18)                  initial unaligned dcl 3-90
bx_$area_begin                         external static fixed bin(18,0)          dcl 4-25
bx_$bdefp                              external static pointer                  dcl 4-38
bx_$bindmap_def                        external static pointer                  dcl 4-37
bx_$blnkp                              external static pointer                  dcl 4-40
bx_$bound_sep_stat                     external static fixed bin(17,0)          dcl 4-64
bx_$bproc                              external static fixed bin(17,0)          dcl 4-67
bx_$bseg_acinfop                       external static pointer                  dcl 4-50
bx_$bseg_bitcount                      external static fixed bin(24,0)          dcl 4-51
bx_$bsegp                              external static pointer                  dcl 4-30
bx_$bstatp                             external static pointer                  dcl 4-39
bx_$bsymp                              external static pointer                  dcl 4-41
bx_$ctp                                external static pointer                  dcl 4-26
bx_$curdeflng                          external static fixed bin(18,0)          dcl 4-69
bx_$d_lng                              external static fixed bin(18,0)          dcl 4-54
bx_$first_rptp                         external static pointer                  dcl 4-34
bx_$has_comb_stat                      external static fixed bin(17,0)          dcl 4-63
bx_$has_sep_stat                       external static fixed bin(17,0)          dcl 4-62
bx_$i_lng                              external static fixed bin(17,0)          dcl 4-55
bx_$isp                                external static pointer                  dcl 4-28
bx_$l_lng                              external static fixed bin(17,0)          dcl 4-56
bx_$last_rptp                          external static pointer                  dcl 4-35
bx_$maxdeflng                          external static fixed bin(18,0)          dcl 4-72
bx_$maxlinklng                         external static fixed bin(17,0)          dcl 4-71
bx_$n_firstrefs                        external static fixed bin(17,0)          dcl 4-47
bx_$n_lng                              external static fixed bin(17,0)          dcl 4-76
bx_$nsegdefs                           external static fixed bin(17,0)          dcl 4-78
bx_$nsymdefs                           external static fixed bin(17,0)          dcl 4-77
bx_$o_lng                              external static fixed bin(19,0)          dcl 4-52
bx_$oddname_limit                      external static fixed bin(17,0)          dcl 4-22
bx_$odnp                               external static pointer                  dcl 4-33
bx_$s_lng                              external static fixed bin(18,0)          dcl 4-57
bx_$size                               external static fixed bin(17,0)          dcl 4-20
bx_$snt_limit                          external static fixed bin(17,0)          dcl 4-21
bx_$sntp                               external static pointer                  dcl 4-42
bx_$standard                           external static fixed bin(17,0)          dcl 4-66
bx_$stringmap_limit                    external static fixed bin(17,0)          dcl 4-23
bx_$strmp                              external static pointer                  dcl 4-46
bx_$t_lng                              external static fixed bin(18,0)          dcl 4-53
bx_$tdefp                              external static pointer                  dcl 4-43
bx_$temp                               external static pointer                  dcl 4-31
bx_$temp_bsegp                         external static pointer                  dcl 4-79
bx_$textlng                            external static fixed bin(18,0)          dcl 4-68
bx_$tintlng                            external static fixed bin(17,0)          dcl 4-70
bx_$tintp                              external static pointer                  dcl 4-44
bx_$tlinklng                           external static fixed bin(17,0)          dcl 4-73
bx_$tlinkp                             external static pointer                  dcl 4-45
bx_$v_lng                              external static fixed bin(17,0)          dcl 4-75
bx_$vers_name                          external static char(168)                dcl 4-18
bx_$vers_number                        external static fixed bin(17,0)          dcl 4-19
comment                                based           structure                level 1 dcl 6-20
comment_value                          based           char                     unaligned dcl 6-20
lrt                                    based           structure                level 1 dcl 3-84
lrtp                                   automatic       pointer                  dcl 3-17
max                                                    builtin function         dcl 5-92
od                                     based           structure                level 1 dcl 3-48
odnp                                   automatic       pointer                  dcl 3-17
ope                                    based           structure                level 1 dcl 2-30
rpt                                    based           structure                level 1 dcl 3-57
rptep                                  automatic       pointer                  dcl 3-17
rptp                                   automatic       pointer                  dcl 3-17
snt                                    based           structure                level 1 dcl 3-21
sntp                                   automatic       pointer                  dcl 3-17
stmt                                   based           structure                level 1 dcl 6-40
stmt_value                             based           char                     unaligned dcl 6-40
strm                                   based           structure                level 1 dcl 3-73
strmp                                  automatic       pointer                  dcl 3-17

NAMES DECLARED BY EXPLICIT CONTEXT.
ACTION                          003540 constant        entry                    internal dcl 577
Addname                         003657 constant        entry                    internal dcl 610 ref 1447
CHECK_CONFLICTS                 005635 constant        entry                    internal dcl 1098 ref 403 1031
CLOSE_ENTRY                     005520 constant        entry                    internal dcl 1053 ref 837 1030
ERROR                           010752 constant        entry                    internal dcl 9-139 ref 504 564 646 650 685 691 722
                                                                                  792 796 812 841 848 855 861 954 961 968 1441 1474
                                                                                  1510 1569 1610 1665 1670 1676 1682 1699 1705 1711
                                                                                  1717 1724 1732 1738 1744 1750 1756 1762 1767 1774
                                                                                  1782 1784 1789 1799 1822 1828 1835 1837 1842 1848
                                                                                  1866 1872 1878
FILL_OPTION_ENTRY               005303 constant        entry                    internal dcl 993 ref 893 1809 1815 1853 1859
FUNCTIONS                       003200 constant        entry                    internal dcl 460
Force_Order                     003677 constant        entry                    internal dcl 621 ref 586
GET_OPTION_TOTALS               005343 constant        entry                    internal dcl 1007 ref 1817 1830 1861
Global                          003726 constant        entry                    internal dcl 634 ref 1467
INIT_PARSE                      006430 constant        entry                    internal dcl 1207 ref 418
Ignore                          004034 constant        entry                    internal dcl 659 ref 590
LEX                             010664 constant        entry                    internal dcl 8-31 ref 1453 1465 1472 1484 1501 1508
                                                                                  1520 1532 1551 1560 1567 1581 1592 1601 1608 1622
                                                                                  1633 1652 1693 1726 1746 1770 1811 1824 1855
NEXT_STMT                       011262 constant        entry                    internal dcl 10-18 ref 1443 1468 1475 1504 1511 1563
                                                                                  1570 1604 1611 1666 1678 1701 1713 1734 1740 1752
                                                                                  1758 1778 1785 1795 1805 1818 1831 1838 1844 1862
                                                                                  1868 1874
No_Table                        004174 constant        entry                    internal dcl 706 ref 600
OPEN_ENTRY                      004654 constant        label                    dcl 852 ref 845
Objectname                      004213 constant        entry                    internal dcl 718 ref 1503
Order                           004252 constant        entry                    internal dcl 729 ref 584
Partial_Order                   004307 constant        entry                    internal dcl 745 ref 588
Perprocess_Static               004336 constant        entry                    internal dcl 758 ref 602
RD_ACTION                       001306 constant        label                    array(76) dcl 1424 ref 1421
RD_MATCH                        007102 constant        label                    dcl 1417 ref 7-90 7-92 7-101 7-109 7-113 7-118 7-128
                                                                                  1413
RD_MATCH_NO_TOKEN               007105 constant        label                    dcl 1418 ref 7-73 7-79 7-86
RD_NEXT_REDUCTION               006575 constant        label                    dcl 7-55 ref 7-68 7-84 7-88 7-99 7-104 7-111 7-116
                                                                                  7-120 7-124 7-130 1414 1426
RD_TEST_REDUCTION               006576 constant        label                    dcl 7-58 ref 7-53 1435 1439 1445 1451 1458 1463 1470
                                                                                  1477 1482 1489 1494 1499 1506 1513 1518 1525 1530
                                                                                  1537 1542 1547 1553 1558 1565 1572 1577 1583 1588
                                                                                  1594 1599 1606 1613 1618 1624 1629 1635 1640 1645
                                                                                  1650 1655 1661 1668 1674 1680 1685 1691 1697 1703
                                                                                  1709 1715 1720 1728 1736 1742 1748 1754 1760 1765
                                                                                  1772 1780 1787 1797 1807 1813 1820 1826 1833 1840
                                                                                  1846 1851 1857 1864 1870 1876 1881
RD_TEST_RESULT                  007076 constant        label                    dcl 1413 ref 1405 1407 1409 1411
RD_TEST_TOKEN                   001274 constant        label                    array(6) dcl 7-73 ref 7-65 7-71
RD_TOKEN_FCN                    001302 constant        label                    array(4) dcl 1404 ref 1402
REORDER_ARCHIVE                 005104 constant        entry                    internal dcl 933 ref 629 740 753
Return                          003162 constant        label                    dcl 450 ref 422 444
SEMANTIC_ANALYSIS               006565 constant        entry                    internal dcl 5-30 ref 449
delete                          004356 constant        entry                    internal dcl 767 ref 1549
epilogue                        005411 constant        entry                    internal dcl 1027 ref 1428
global                          004375 constant        entry                    internal dcl 780 ref 1562
globe_arg                       003203 constant        entry                    internal dcl 464 ref 1408
ignore_it                       004136 constant        label                    dcl 688 ref 681
indirect                        004502 constant        entry                    internal dcl 805 ref 1579
keyword                         003311 constant        entry                    internal dcl 520 ref 1404
long_name                       003237 constant        entry                    internal dcl 480 ref 1406
match_found                     005207 constant        label                    dcl 958 ref 950
next_arg                        005256 constant        label                    dcl 976 ref 946 956 963 970
next_ignore_arg                 004157 constant        label                    dcl 696 ref 676 686 692
no_link                         004536 constant        entry                    internal dcl 820 ref 1590
np                              002372 constant        entry                    external dcl 209
objectname                      004555 constant        entry                    internal dcl 833 ref 1603
parse_bindfile_                 002362 constant        entry                    external dcl 209
perform_noarg                   003617 constant        entry                    internal dcl 597 ref 1689 1695
perform_order                   003547 constant        entry                    internal dcl 581 ref 1777 1793 1803
retain                          005027 constant        entry                    internal dcl 899 ref 1620
seg_name                        003261 constant        entry                    internal dcl 496 ref 1410
skip_objname                    004712 constant        label                    dcl 862 ref 842 850 856
synonym                         005046 constant        entry                    internal dcl 911 ref 1631
table                           005065 constant        entry                    internal dcl 924 ref 604

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     12304       12402   11543       12314
Length     13116   11543        76         477     540           6

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
parse_bindfile_                     492 external procedure  is an external procedure.  
on unit on line 378                  70 on unit               
FUNCTIONS                               internal procedure  shares stack frame of external procedure parse_bindfile_.  
ACTION                              108 internal procedure  calls itself recursively.  
INIT_PARSE                              internal procedure  shares stack frame of external procedure parse_bindfile_.  
SEMANTIC_ANALYSIS                       internal procedure  shares stack frame of external procedure parse_bindfile_.  
LEX                                     internal procedure  shares stack frame of external procedure parse_bindfile_.  
ERROR                               168 internal procedure  is called by several nonquick procedures.  
NEXT_STMT                               internal procedure  shares stack frame of external procedure parse_bindfile_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 ERROR_OUTPUT                parse_bindfile_
000013 DUP_objectname              parse_bindfile_
000014 NO_such_seg                 parse_bindfile_
000015 TRACING                     parse_bindfile_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ACTION                   000100 erring_token_value          ACTION
ERROR                    000100 Pstmt                       ERROR
                         000102 Perring_token               ERROR
parse_bindfile_          000100 breaks                      parse_bindfile_
                         000104 ignored_breaks              parse_bindfile_
                         000107 lex_delims                  parse_bindfile_
                         000132 lex_control_chars           parse_bindfile_
                         000155 Linput                      parse_bindfile_
                         000156 Linput_ignore               parse_bindfile_
                         000160 Pfirst_stmt_descriptor      parse_bindfile_
                         000162 Pfirst_token_descriptor     parse_bindfile_
                         000164 Pinput                      parse_bindfile_
                         000166 Psegment                    parse_bindfile_
                         000170 MYNAME                      parse_bindfile_
                         000200 arg_count                   parse_bindfile_
                         000201 code                        parse_bindfile_
                         000202 ORDER                       parse_bindfile_
                         000203 FORCE_ORDER                 parse_bindfile_
                         000204 PARTIAL_ORDER               parse_bindfile_
                         000205 order_type                  parse_bindfile_
                         000206 i                           parse_bindfile_
                         000207 j                           parse_bindfile_
                         000210 k                           parse_bindfile_
                         000211 keyword_idx                 parse_bindfile_
                         000212 Word_extent                 parse_bindfile_
                         000213 new_nobj                    parse_bindfile_
                         000214 obj_idx                     parse_bindfile_
                         000215 opt_counter                 parse_bindfile_
                         000216 partial_order_number        parse_bindfile_
                         000217 stmt_error                  parse_bindfile_
                         000240 opt_code                    parse_bindfile_
                         000241 ARG_list_error              parse_bindfile_
                         000242 entryname_too_long          parse_bindfile_
                         000243 ignore_seen                 parse_bindfile_
                         000244 MAX_error                   parse_bindfile_
                         000245 no_parameters               parse_bindfile_
                         000246 order_error                 parse_bindfile_
                         000247 Parameters                  parse_bindfile_
                         000250 segname_too_long            parse_bindfile_
                         000252 arg_ptr                     parse_bindfile_
                         000254 p                           parse_bindfile_
                         000256 p1                          parse_bindfile_
                         000260 inpp                        parse_bindfile_
                         000262 optp                        parse_bindfile_
                         000264 copyp                       parse_bindfile_
                         000266 areap                       parse_bindfile_
                         000270 Addname_idx                 parse_bindfile_
                         000271 FOrder_idx                  parse_bindfile_
                         000272 Global_idx                  parse_bindfile_
                         000273 Ignore_idx                  parse_bindfile_
                         000274 No_Table_idx                parse_bindfile_
                         000275 Objectname_idx              parse_bindfile_
                         000276 Order_idx                   parse_bindfile_
                         000277 POrder_idx                  parse_bindfile_
                         000300 PStatic_idx                 parse_bindfile_
                         000301 delete_idx                  parse_bindfile_
                         000302 global_idx                  parse_bindfile_
                         000303 indirect_idx                parse_bindfile_
                         000304 no_link_idx                 parse_bindfile_
                         000305 objectname_idx              parse_bindfile_
                         000306 retain_idx                  parse_bindfile_
                         000307 synonym_idx                 parse_bindfile_
                         000310 table_idx                   parse_bindfile_
                         000320 NOBJ                        parse_bindfile_
                         000321 NTOTAL                      parse_bindfile_
                         000322 adnp                        parse_bindfile_
                         000324 Pthis_token                 parse_bindfile_
                         000326 Pstmt                       parse_bindfile_
                         000330 Ptoken                      parse_bindfile_
                         000332 SPDL                        parse_bindfile_
                         000333 MERROR_SEVERITY             parse_bindfile_
                         000334 SERROR_CONTROL              parse_bindfile_
                         000335 MIN_PRINT_SEVERITY          parse_bindfile_
                         000335 SERROR_PRINTED              parse_bindfile_
                         000336 PRINT_SEVERITY_CONTROL      parse_bindfile_
                         000374 LTOKEN_REQD_VALUE           SEMANTIC_ANALYSIS
                         000375 NRED                        SEMANTIC_ANALYSIS
                         000376 PRED                        SEMANTIC_ANALYSIS
                         000400 PTOKEN_REQD                 SEMANTIC_ANALYSIS
                         000402 PTOKEN_REQD_VALUE           SEMANTIC_ANALYSIS
                         000404 STOKEN_FCN                  SEMANTIC_ANALYSIS
                         000405 CODE                        SEMANTIC_ANALYSIS
                         000406 I                           SEMANTIC_ANALYSIS
                         000407 NUMBER                      SEMANTIC_ANALYSIS
                         000410 DIRECTION                   SEMANTIC_ANALYSIS
                         000442 i                           LEX
                         000454 Ssearching                  NEXT_STMT

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            unpk_to_pk          cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this
call_int_other      return              alloc_auto_adj      enable              shorten_stack       ext_entry
int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cv_dec_check_                 ioa_$ioa_stream               lex_error_
lex_string_$init_lex_delims   lex_string_$lex               temp_mgr_$reserve             translator_temp_$get_segment
translator_temp_$release_all_segments

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
bx_$addname                   bx_$addname_limit             bx_$adnp                      bx_$bound_segname
bx_$brief                     bx_$caller                    bx_$debug                     bx_$fatal_error
bx_$force_order               bx_$freep                     bx_$inpp                      bx_$ncomp
bx_$optp                      bx_$perprocess_static         error_table_$zero_length_seg




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    215 002207       227 002215       232 002223       235 002224       237 002225       239 002226       241 002227
    245 002241       246 002242       247 002243       248 002244       250 002245       252 002246       255 002247
    317 002257    1   80 002321      1888 002323    9    3 002324    9  168 002355       209 002361       378 002400
    380 002414       382 002431       383 002434       385 002435       387 002445       388 002451       389 002454
    390 002457       391 002461       392 002465       394 002473       395 002475       396 002476       397 002477
    400 002502       401 002505       403 002525       404 002531       408 002532       410 002552       412 002554
    413 002600       414 002603       417 002604       418 002606       419 002607       421 002611       422 002632
    425 002633       428 002641       429 002655       430 002677       432 002763       435 003077       437 003101
    439 003103       441 003107       443 003144       444 003160       449 003161       450 003162       453 003177
    460 003200       464 003202       467 003205       470 003235       480 003237       483 003241       486 003243
    488 003251       491 003255       496 003261       499 003263       501 003264       503 003270       504 003272
    505 003302       508 003305       520 003311       523 003313       525 003327       527 003336       529 003345
    531 003354       533 003363       535 003372       537 003401       539 003410       541 003417       543 003426
    545 003435       547 003444       549 003453       551 003462       553 003471       555 003500       557 003507
    559 003512       561 003520       564 003525       565 003534       577 003537       581 003545       584 003554
    586 003566       588 003576       590 003606       594 003615       597 003616       600 003624       602 003636
    604 003646       607 003655       610 003656       614 003664       615 003670       616 003672       618 003675
    621 003676       624 003704       625 003710       626 003713       628 003715       629 003717       631 003724
    634 003725       637 003733       638 003737       640 003754       642 003764       644 003774       646 004000
    647 004011       648 004015       650 004016       651 004027       654 004030       656 004032       659 004033
    667 004041       668 004045       669 004047       670 004051       674 004053       676 004064       679 004070
    680 004102       681 004113       683 004123       685 004125       686 004135       688 004136       691 004143
    692 004154       695 004155       696 004157       700 004166       701 004170       703 004172       706 004173
    712 004201       713 004205       714 004210       715 004211       718 004212       721 004220       722 004224
    724 004242       726 004250       729 004251       732 004257       733 004263       734 004266       736 004270
    739 004276       740 004300       742 004305       745 004306       748 004314       749 004320       750 004323
    752 004325       753 004327       755 004334       758 004335       761 004343       762 004347       763 004352
    764 004354       767 004355       773 004363       774 004367       775 004370       776 004372       777 004373
    780 004374       783 004402       784 004406       786 004423       788 004433       790 004443       792 004447
    793 004460       794 004464       796 004465       797 004476       800 004477       802 004500       805 004501
    811 004507       812 004513       814 004527       815 004531       816 004533       817 004534       820 004535
    826 004543       827 004547       828 004550       829 004552       830 004553       833 004554       836 004562
    837 004565       839 004572       841 004575       842 004606       844 004607       845 004620       847 004641
    848 004643       850 004653       852 004654       855 004662       856 004673       859 004674       861 004702
    862 004712       869 004732       872 004733       874 004742       876 004754       878 004771       880 004773
    881 004775       882 004777       883 005001       884 005003       885 005005       886 005007       891 005011
    892 005012       893 005014       894 005021       896 005025       899 005026       905 005034       906 005040
    907 005041       908 005043       909 005044       911 005045       917 005053       918 005057       919 005060
    920 005062       921 005063       924 005064       927 005072       928 005076       929 005101       930 005102
    933 005103       938 005111       939 005113       940 005115       941 005117       944 005121       946 005132
    948 005136       949 005150       950 005161       952 005171       954 005173       955 005203       956 005206
    958 005207       961 005214       962 005225       963 005230       966 005231       968 005233       969 005244
    970 005247       973 005250       974 005252       975 005253       976 005256       979 005263       981 005265
    983 005267       988 005274       990 005301       993 005302       996 005310       997 005312       998 005313
    999 005320      1000 005323      1001 005327      1002 005334      1003 005336      1005 005341      1007 005342
   1012 005350      1014 005360      1016 005366      1018 005374      1020 005402      1023 005407      1027 005410
   1030 005416      1031 005423      1034 005441      1036 005445      1037 005450      1040 005451      1042 005453
   1043 005456      1044 005457      1045 005467      1048 005502      1050 005516      1053 005517      1056 005525
   1062 005545      1065 005547      1067 005562      1070 005563      1072 005611      1073 005613      1074 005614
   1076 005617      1078 005623      1080 005632      1082 005633      1098 005634      1104 005642      1106 005644
   1108 005645      1110 005656      1111 005667      1113 005672      1117 005710      1118 005715      1120 005761
   1122 005763      1124 005766      1126 005770      1127 005772      1129 006037      1131 006040      1133 006045
   1134 006047      1136 006114      1140 006115      1143 006131      1144 006133      1146 006200      1148 006201
   1151 006215      1152 006217      1154 006264      1156 006265      1159 006304      1160 006305      1169 006310
   1171 006314      1172 006315      1175 006320      1177 006325      1181 006327      1183 006332      1185 006345
   1187 006352      1188 006365      1189 006376      1191 006402      1192 006413      1194 006416      1196 006420
   1197 006425      1201 006427      1207 006430      1211 006431      1213 006434      1214 006441      1215 006442
   1217 006444      1218 006450      1221 006470      1222 006475      1224 006511      1225 006513      1227 006516
   1234 006522      1236 006535      1238 006537      1242 006556      1245 006564    5   30 006565      1268 006566
 7   50 006570    7   52 006573    7   53 006574    7   55 006575    7   58 006576    7   60 006601    7   62 006603
 7   63 006626    7   64 006631    7   65 006635    7   68 006645    7   70 006646    7   71 006652    7   73 006654
 7   79 006673    7   84 006704    7   86 006705    7   88 006711    7   90 006712    7   92 006713    7   99 006747
 7  101 006750    7  104 006753    7  106 006756    7  107 007002    7  108 007004    7  109 007007    7  111 007010
 7  113 007011    7  116 007025    7  118 007026    7  120 007032    7  123 007033    7  124 007034    7  126 007040
 7  127 007045    7  128 007051    7  130 007057      1402 007060      1404 007062      1405 007064      1406 007065
   1407 007067      1408 007070      1409 007072      1410 007073      1411 007075      1413 007076      1414 007101
   1417 007102      1418 007105      1420 007110      1421 007112      1424 007114      1426 007115      1428 007116
   1430 007122      1432 007123      1434 007126      1435 007130      1437 007131      1439 007133      1441 007134
   1443 007146      1444 007147      1445 007151      1447 007152      1449 007156      1450 007162      1451 007164
   1453 007165      1455 007171      1456 007173      1457 007174      1458 007176      1460 007177      1462 007202
   1463 007204      1465 007205      1467 007211      1468 007215      1469 007216      1470 007220      1472 007221
   1474 007225      1475 007235      1476 007236      1477 007240      1479 007241      1481 007244      1482 007246
   1484 007247      1486 007253      1487 007255      1488 007256      1489 007260      1491 007261      1493 007264
   1494 007266      1496 007267      1498 007272      1499 007274      1501 007275      1503 007301      1504 007305
   1505 007306      1506 007310      1508 007311      1510 007315      1511 007325      1512 007326      1513 007330
   1515 007331      1517 007334      1518 007336      1520 007337      1522 007343      1523 007345      1524 007346
   1525 007350      1527 007351      1529 007354      1530 007356      1532 007357      1534 007363      1535 007365
   1536 007366      1537 007370      1539 007371      1541 007374      1542 007376      1544 007377      1546 007402
   1547 007404      1549 007405      1551 007411      1552 007415      1553 007417      1555 007420      1557 007423
   1558 007425      1560 007426      1562 007432      1563 007436      1564 007437      1565 007441      1567 007442
   1569 007446      1570 007456      1571 007457      1572 007461      1574 007462      1576 007465      1577 007467
   1579 007470      1581 007474      1582 007500      1583 007502      1585 007503      1587 007506      1588 007510
   1590 007511      1592 007515      1593 007521      1594 007523      1596 007524      1598 007527      1599 007531
   1601 007532      1603 007536      1604 007542      1605 007543      1606 007545      1608 007546      1610 007552
   1611 007562      1612 007563      1613 007565      1615 007566      1617 007571      1618 007573      1620 007574
   1622 007600      1623 007604      1624 007606      1626 007607      1628 007612      1629 007614      1631 007615
   1633 007621      1634 007625      1635 007627      1637 007630      1639 007633      1640 007635      1642 007636
   1644 007641      1645 007643      1647 007644      1649 007647      1650 007651      1652 007652      1654 007656
   1655 007660      1657 007661      1659 007663      1660 007666      1661 007670      1663 007671      1665 007674
   1666 007704      1667 007705      1668 007707      1670 007710      1672 007720      1673 007724      1674 007726
   1676 007727      1678 007737      1679 007740      1680 007742      1682 007743      1684 007753      1685 007755
   1687 007756      1689 007761      1690 007765      1691 007767      1693 007770      1695 007774      1696 010000
   1697 010002      1699 010003      1701 010013      1702 010014      1703 010016      1705 010017      1707 010027
   1708 010033      1709 010035      1711 010036      1713 010046      1714 010047      1715 010051      1717 010052
   1719 010062      1720 010064      1722 010065      1724 010067      1725 010103      1726 010114      1727 010120
   1728 010122      1730 010123      1732 010125      1733 010141      1734 010152      1735 010153      1736 010155
   1738 010156      1740 010166      1741 010167      1742 010171      1744 010172      1746 010202      1747 010206
   1748 010210      1750 010211      1752 010221      1753 010222      1754 010224      1756 010225      1758 010235
   1759 010236      1760 010240      1762 010241      1764 010251      1765 010253      1767 010254      1769 010267
   1770 010270      1771 010274      1772 010276      1774 010277      1776 010312      1777 010313      1778 010317
   1779 010320      1780 010322      1782 010323      1784 010336      1785 010346      1786 010347      1787 010351
   1789 010352      1791 010362      1792 010364      1793 010366      1795 010372      1796 010373      1797 010375
   1799 010376      1801 010406      1802 010410      1803 010412      1805 010416      1806 010417      1807 010421
   1809 010422      1811 010426      1812 010432      1813 010434      1815 010435      1817 010441      1818 010445
   1819 010446      1820 010450      1822 010451      1824 010461      1825 010465      1826 010467      1828 010470
   1830 010500      1831 010504      1832 010505      1833 010507      1835 010510      1837 010523      1838 010533
   1839 010534      1840 010536      1842 010537      1844 010547      1845 010550      1846 010552      1848 010553
   1850 010563      1851 010565      1853 010566      1855 010574      1856 010600      1857 010602      1859 010603
   1861 010611      1862 010615      1863 010616      1864 010620      1866 010621      1868 010631      1869 010632
   1870 010634      1872 010635      1874 010645      1875 010646      1876 010650      1878 010651      1880 010661
   1881 010663    8   31 010664    8   36 010666    8   37 010670    8   38 010675    8   39 010677    8   40 010711
 8   41 010713    8   42 010715    8   44 010725    8   45 010726    8   47 010741    8   48 010743    8   49 010746
 8   51 010750    9  139 010751    9  153 010757    9  154 010767    9  156 010776    9  158 011005    9  160 011006
 9  161 011010    9  164 011023    9  166 011027    9  168 011031    9  172 011133    9  177 011260   10   18 011262
10   24 011263   10   25 011265   10   26 011270   10   27 011272   10   28 011300   10   29 011302   10   30 011307
10   31 011310   10   32 011311   10   35 011322   10   36 011326   10   39 011327


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
