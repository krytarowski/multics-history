ASSEMBLY LISTING OF SEGMENT >special_ldd>install>MR12.0-1206>sort_items_.alm                 
ASSEMBLED ON:	11/05/86  1038.5 mst Wed
OPTIONS USED:	list 
ASSEMBLED BY:	ALM Version  6.7  October 1986  
ASSEMBLER CREATED:	10/08/86  1557.5 mst Wed

                                     1  " **********************************************************************
                                     2  " *                                                                    *
                                     3  " * This is in the PUBLIC DOMAIN and may be copied without permission. *
                                     4  " *                                                                    *
                                     5  " **********************************************************************
    000000                           6  sort_items_:				"just a program label
                                     7  
    000000                           8  	name sort_items_			"define objectname
                                     9  
                                    10  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                                    11  "This is an ALM version of sort_items_.pl1, written at AFDSC/CMMS.  The
                                    12  "   program provides a generalized sorting facility for several unique data
                                    13  "   types.  It uses a vector of unaligned pointers to the items to be sorted.
                                    14  "   The program then sorts the pointers, leaving the data untouched.  This
                                    15  "   program is written to replace the system program sort_items_.  Entry
                                    16  "   points are identical, with only the algorithm changed.
                                    17  "The outstanding feature of sort_items_.alm is its heavy dependence on
                                    18  "   hardware registers as program storage.  This reduces the necessity
                                    19  "   to access main memory and allows the program to operate more directly
                                    20  "   on the hardware.
                                    21  "The algorithm used by the program is the heapsort algorithm as stated by
                                    22  "   Knuth's "The Art of Computer Programming", (vol. 3, pp 146-147) with
                                    23  "   the modification suggested in Exercise 18 (problem pg 158, answer pg 618).
                                    24  "There are three major coding sections: init, fix_heap, and sort_heap.
                                    25  "   Each section will document current register usage.
                                    26  "The maximum number of data items is 261119!!
                                    27  
                                    28  "Converted from PL/I March 1982  @ AFDSC/CMMS by LT F. Patrick Clark,
                                    29  "   USAF and Lee A. Newcomb, HISI.
                                    30  "Modified April, 1983 by LT F. Patrick Clark (AFDSC/CMMS) to change
                                    31  "   sub_err_ flag parameter and clean up documentation.
                                    32  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                                    33  "
                                    34  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                                    35  "ENTRIES:
                                    36  "   1) sort_items_$fixed_bin - sorts fixed bin (35) numbers
                                    37  "   declaration --> declare sort_items_$fixed_bin entry (ptr);
                                    38  "   usage --> call sort_items_$fixed_bin (vec_ptr);
                                    39  "
                                    40  "   2) sort_items_$float_bin - sorts float bin (63) numbers
                                    41  "   declaration --> declare sort_items_$float_bin entry (ptr);
                                    42  "   usage --> call sort_items_$float_bin (vec_ptr);
                                    43  "
                                    44  "   3) sort_items_$char - sorts nonvarying character strings
                                    45  "   declaration --> declare sort_items_$char entry (ptr, fixed bin (24));
                                    46  "   usage --> call sort_items_$char (vec_ptr, str_length);
                                    47  "
                                    48  "   4) sort_items_$bit - sorts nonvarying bit strings
                                    49  "   declaration --> declare sort_items_$bit entry (ptr, fixed bin (24));
                                    50  "   usage --> call sort_items_$bit (vec_ptr, str_length);
                                    51  "
                                    52  "   5) sort_items_$varying_char -- sorts varying character strings
                                    53  "   declaration --> declare sort_items_$varying_char entry (ptr);
                                    54  "   usage --> call sort_items_$varying_char (vec_ptr);
                                    55  "
                                    56  "   6) sort_items_$general -- sorts items based on a user defined function
                                    57  "   declaration --> declare sort_items_$general entry (ptr, entry);
                                    58  "   usage --> call sort_items_$general (vec_ptr, function_name);
                                    59  "
                                    60  "   where:
                                    61  "      vec_ptr - points to a structure of pointers of items to be sorted.  It has
                                    62  "	the form:
                                    63  "		dcl 01 vec aligned,
                                    64  "		       02 n fixed bin (24),
                                    65  "		       02 vector (vec.n) ptr unaligned;
                                    66  "      str_length - data string length for $bit or $char entries.
                                    67  "      function_name - name of a user defined function which states the
                                    68  "	relationship between two data items.  It must have the following
                                    69  "	format:
                                    70  "	declaration --> declare function entry (ptr unaligned, ptr unaligned)
                                    71  "			returns (fixed bin (1));
                                    72  "	usage --> value = function (ptr_1st_item, ptr_2nd_item);
                                    73  "
                                    74  "	where:
                                    75  "	   ptr_1st_item - is an unaligned ptr to the first data item
                                    76  "	   ptr_2nd_item - is an unaligned ptr to the second data item
                                    77  "	   value - is the result of comparing the two items.  It can be:
                                    78  "	      < 0 => first item < second item
                                    79  "	      >=0 => first item >= second item
                                    80  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                                    81  "
                                    82  "the six entries
                        000115      83  	 entry fixed_bin,float_bin,char,bit,varying_char,general
                                    84  
                                    85  "define stack frame temporaries, largest first
                                    86  	temp8	arg_list_1,arg_list_2,arg_list_3	"area for arg lists
                                    87  	tempd	arg_list_4		"arg list area, connected to temp8's above
                                    88  	temp	general_pptr_1,general_pptr_2,general_value	"$general function args
                                    89  	temp	N_in_upper		"loop index temporary
                                    90  	temp	error_value		"error value for sub_err_
                                    91  
                                    92  "define constants for sub_err_ call
    000000                          93  total_items_err_msg:
    000000  aa  111 164 145 155     94  	aci	/Item count outside legal bounds./
    000001  aa  040 143 157 165
    000002  aa  156 164 040 157
    000003  aa  165 164 163 151
    000004  aa  144 145 040 154
    000005  aa  145 147 141 154
    000006  aa  040 142 157 165
    000007  aa  156 144 163 056
                                    95  
    000010                          96  string_length_err_msg:
    000010  aa  104 141 164 141     97  	aci	/Data length ouside legal bounds./
    000011  aa  040 154 145 156
    000012  aa  147 164 150 040
    000013  aa  157 165 163 151
    000014  aa  144 145 040 154
    000015  aa  145 147 141 154
    000016  aa  040 142 157 165
    000017  aa  156 144 163 056
                                    98  
    000020                          99  program_name:
    000020  aa  163 157 162 164    100  	aci	/sort_items_/
    000021  aa  137 151 164 145
    000022  aa  155 163 137 000
                                   101  
    000023                         102  sub_err_flag:
    000023  aa   000000 000000     103  	oct	000000000000
                                   104  
    000024                         105  fixed_35_desc:
    000024  aa   404000 000043     106  	oct	404000000043
                                   107  
    000025                         108  program_name_desc:
    000025  aa   526000 000013     109  	oct	526000000013
                                   110  
    000026                         111  sub_err_flag_desc:
    000026  aa   516000 000044     112  	oct	516000000044
                                   113  
    000027                         114  ptr_desc:
    000027  aa   464000 000000     115  	oct	464000000000
                                   116  
    000030                         117  err_msg_desc:
    000030  aa   526000 000040     118  	oct	526000000040
                                   119  "
                                   120  	include	stack_header
                                   1-1  "	BEGIN INCLUDE FILE ... stack_header.incl.alm  3/72  Bill Silver
                                   1-2  "
                                   1-3  "	modified 7/76 by M. Weaver for *system links and more system use of areas
                                   1-4  "	modified 3/77 by M. Weaver  to add rnt_ptr
                                   1-5  "	modified 7/77 by S. Webber to add run_unit_depth and assign_linkage_ptr
                                   1-6  "	modified 6/83 by J. Ives to add trace_frames and in_trace.
                                   1-7  
                                   1-8  " HISTORY COMMENTS:
                                   1-9  "  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
                                  1-10  "     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
                                  1-11  "     added the heap_header_ptr definition
                                  1-12  "  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
                                  1-13  "     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
                                  1-14  "     Modified to support control point management.  These changes were
                                  1-15  "     actually made in February 1985 by G. Palter.
                                  1-16  "  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
                                  1-17  "     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
                                  1-18  "     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
                                  1-19  "     bit pad after cur_lot_size for the cpm_enabled. This was done to save
                                  1-20  "     some space int the stack header and change the cpd_ptr unal to
                                  1-21  "     cpm_data_ptr (ITS pair).
                                  1-22  "                                                      END HISTORY COMMENTS
                                  1-23  
                        000004    1-24  	equ	stack_header.cpm_data_ptr,4		ptr to control point for this stack
                        000006    1-25  	equ	stack_header.combined_stat_ptr,6	ptr to separate static area
                                  1-26  
                        000010    1-27  	equ	stack_header.clr_ptr,8		ptr to area containing linkage sections
                        000012    1-28  	equ	stack_header.max_lot_size,10		number of words allowed in lot (DU)
                        000012    1-29  	equ	stack_header.main_proc_invoked,10	nonzero if main proc was invoked in run unit (DL)
                        000012    1-30  	equ	stack_header.run_unit_depth,10	number of active run units stacked (DL)
                        000013    1-31  	equ	stack_header.cur_lot_size,11		DU number of words (entries) in lot
                        000013    1-32            equ	stack_header.cpm_enabled,11		DL  non-zero if control point management is enabled
                        000014    1-33  	equ	stack_header.system_free_ptr,12	ptr to system storage area
                        000016    1-34  	equ	stack_header.user_free_ptr,14		ptr to user storage area
                                  1-35  
                        000020    1-36  	equ	stack_header.parent_ptr,16		ptr to parent stack or null
                        000022    1-37  	equ	stack_header.stack_begin_ptr,18	ptr to first stack frame
                        000024    1-38  	equ	stack_header.stack_end_ptr,20		ptr to next useable stack frame
                        000026    1-39  	equ	stack_header.lot_ptr,22		ptr to the lot for the current ring
                                  1-40  
                        000030    1-41  	equ	stack_header.signal_ptr,24		ptr to signal proc for current ring
                        000032    1-42  	equ	stack_header.bar_mode_sp,26		value of sp before entering bar mode
                        000034    1-43  	equ	stack_header.pl1_operators_ptr,28	ptr: pl1_operators_$operator_table
                        000036    1-44  	equ	stack_header.call_op_ptr,30		ptr to standard call operator
                                  1-45  
                        000040    1-46  	equ	stack_header.push_op_ptr,32		ptr to standard push operator
                        000042    1-47  	equ	stack_header.return_op_ptr,34		ptr to standard return operator
                        000044    1-48  	equ	stack_header.ret_no_pop_op_ptr,36	ptr: stand. return/ no pop operator
                        000046    1-49  	equ	stack_header.entry_op_ptr,38		ptr to standard entry operator
                                  1-50  
                        000050    1-51  	equ	stack_header.trans_op_tv_ptr,40	ptr to table of translator operator ptrs
                        000052    1-52  	equ	stack_header.isot_ptr,42		pointer to ISOT
                        000054    1-53  	equ	stack_header.sct_ptr,44		pointer to System Condition Table
                        000056    1-54  	equ	stack_header.unwinder_ptr,46		pointer to unwinder for current ring
                                  1-55  
                        000060    1-56  	equ	stack_header.sys_link_info_ptr,48	ptr to *system link name table
                        000062    1-57  	equ	stack_header.rnt_ptr,50		ptr to reference name table
                        000064    1-58  	equ	stack_header.ect_ptr,52		ptr to event channel table
                        000066    1-59  	equ	stack_header.assign_linkage_ptr,54	ptr to area for hcs_$assign_linkage calls
                        000070    1-60  	equ	stack_header.heap_header_ptr,56	ptr to heap header.
                        000072    1-61  	equ	stack_header.trace_frames,58		stack of trace_catch_ frames
                        000073    1-62  	equ	stach_header.trace_top_ptr,59		trace pointer
                        000074    1-63  	equ	stack_header.in_trace,60		trace antirecurse bit
                        000100    1-64  	equ	stack_header_end,64			length of stack header
                                  1-65  
                                  1-66  
                                  1-67  
                                  1-68  
                        000000    1-69  	equ	trace_frames.count,0		number of trace frames on stack
                        000001    1-70  	equ	trace_frames.top_ptr,1		packed pointer to top one
                                  1-71  
                                  1-72  "	The  following constant is an offset within the  pl1  operators table.
                                  1-73  "	It  references a  transfer vector table.
                                  1-74  
                        000551    1-75  	bool	tv_offset,551
                                  1-76  
                                  1-77  
                                  1-78  "	The  following constants are offsets within this transfer vector table.
                                  1-79  
                        001170    1-80  	equ	call_offset,tv_offset+271
                        001171    1-81  	equ	push_offset,tv_offset+272
                        001172    1-82  	equ	return_offset,tv_offset+273
                        001173    1-83  	equ	return_no_pop_offset,tv_offset+274
                        001174    1-84  	equ	entry_offset,tv_offset+275
                                  1-85  
                                  1-86  
                                  1-87  " 	END INCLUDE FILE stack_header.incl.alm
                                   121  "
                                   122  	include	stack_frame
                                   2-1  "
                                   2-2  "	BEGIN INCLUDE FILE ... stack_frame.incl.alm   6/72 RBS
                                   2-3  "
                                   2-4  " Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr
                                   2-5  " Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager_bit & main_proc_bit
                                   2-6  " Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr
                                   2-7  "
                        000020     2-8  	equ	stack_frame.prev_sp,16
                        000020     2-9  	equ	stack_frame.condition_word,16
                        000022    2-10  	equ	stack_frame.next_sp,18
                        000022    2-11  	equ	stack_frame.signaller_word,18
                        000024    2-12  	equ	stack_frame.return_ptr,20
                        000026    2-13  	equ	stack_frame.entry_ptr,22
                        000030    2-14  	equ	stack_frame.operator_ptr,24
                        000030    2-15  	equ	stack_frame.lp_ptr,24
                        000032    2-16  	equ	stack_frame.arg_ptr,26
                        000034    2-17  	equ	stack_frame.static_ptr,28
                        000035    2-18  	equ	stack_frame.support_ptr,29	" only used by fortran I/O
                        000036    2-19  	equ	stack_frame.on_unit_rel_ptrs,30
                        000037    2-20  	equ	stack_frame.operator_ret_ptr,31
                        000037    2-21  	equ	stack_frame.translator_id,31
                        000040    2-22  	equ	stack_frame.regs,32
                        000060    2-23  	equ	stack_frame.min_length,48
                        000020    2-24  	equ	stack_frame.flag_word,16
                        020000    2-25  	bool	stack_frame.main_proc_bit,020000	(DL)
                        010000    2-26  	bool	stack_frame.run_unit_manager,010000	(DL)
                        004000    2-27  	bool	stack_frame.signal_bit,004000		(DL)
                        002000    2-28  	bool	stack_frame.crawl_out_bit,002000	(DL)
                        001000    2-29  	bool	stack_frame.signaller_bit,001000	(DL)
                        000400    2-30  	bool	stack_frame.link_trap_bit,000400	(DL)
                        000200    2-31  	bool	stack_frame.support_bit,000200	(DL)
                        000100    2-32  	bool	stack_frame.condition_bit,000100	(DL)
                                  2-33  
                                  2-34  "
                                  2-35  "	END INCLUDE FILE  ... stack_frame.incl.alm
                                  2-36  "
                                   123  "
                                   124  "We use label arrays similar to those used by PL/1 in code generation.
    000031                         125  label_vec_A:				"for 1st case statement
    000031  0a   000254 7100 00    126  	tra  	compare0_A
    000032  0a   000304 7100 00    127  	tra	compare1_A
    000033  0a   000320 7100 00    128  	tra	compare2_A
    000034  0a   000334 7100 00    129  	tra	compare3_A
    000035  0a   000352 7100 00    130  	tra	compare4_A
    000036  0a   000370 7100 00    131  	tra	compare5_A
                                   132  
    000037                         133  label_vec_B:				"for 2nd case statement
    000037  0a   000267 7100 00    134  	tra	compare0_B
    000040  0a   000311 7100 00    135  	tra	compare1_B
    000041  0a   000325 7100 00    136  	tra	compare2_B
    000042  0a   000342 7100 00    137  	tra	compare3_B
    000043  0a   000360 7100 00    138  	tra	compare4_B
    000044  0a   000400 7100 00    139  	tra	compare5_B
                                   140  
    000045                         141  label_vec_C:				"for 3rd case statement
    000045  0a   000444 7100 00    142  	tra	compare0_C
    000046  0a   000503 7100 00    143  	tra	compare1_C
    000047  0a   000526 7100 00    144  	tra	compare2_C
    000050  0a   000551 7100 00    145  	tra	compare3_C
    000051  0a   000576 7100 00    146  	tra	compare4_C
    000052  0a   000623 7100 00    147  	tra	compare5_C
                                   148  
    000053                         149  label_vec_D:				"for 4th case statemtent
    000053  0a   000462 7100 00    150  	tra	compare0_D
    000054  0a   000513 7100 00    151  	tra	compare1_D
    000055  0a   000536 7100 00    152  	tra	compare2_D
    000056  0a   000562 7100 00    153  	tra	compare3_D
    000057  0a   000607 7100 00    154  	tra	compare4_D
    000060  0a   000636 7100 00    155  	tra	compare5_D
                                   156  "
    000061                         157  init:					"just a section label
                                   158  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                                   159  "This is the init section of sort_items_.  Each of the six possible entries
                                   160  "   pushes a stack frame and sets registers as needed.  The parameters
                                   161  "   of the entry points are found and put in registers or local storage
                                   162  "   in order to eliminate the parameter passing mechanisms usually needed
                                   163  "   for each reference.
                                   164  "This section also gets and verifies the second parameter of the entries
                                   165  "   that have one.  The $char and $bit entries put the parameter
                                   166  "   in $A, WHICH MUST NOT BE CHANGED BY ANY OTHER PART OF THOSE ENTRIES!!
                                   167  "   The $general entry creates the function argument list and sets $PR0 to
                                   168  "   point to it, and set $PR2 to point to the function entry value.
                                   169  "   Register usage is as follows:
                                   170  "   PR0 -- initially is addr (agrument list)
                                   171  "	 later has addr (arg_list) {$general entry ONLY!!}
                                   172  "   PR2 -- function entry ptr {$general entry ONLY!!}
                                   173  "   PR4 -- addr (linkage section)
                                   174  "   PR5 -- addr (ptr array base)
                                   175  "   PR6 -- addr (stack frame)
                                   176  "   PR7 -- addr (stack base)
                                   177  "   X7 -- data type as defined by entry point called
                                   178  "   A -- data string length {$char, $bit entries ONLY!!}
                                   179  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                                   180  "
                                   181  "* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    000061                         182  fixed_bin:				"entry (vec_ptr)
    000061  aa   000120 6270 00    183  	push
    000062  aa  7 00040 2721 20
    000063  aa   000001 2270 03    184  	ldx7	1,du			"data type by definition
    000064  aa   000123 7100 04    185  	tra	common-*,ic		"go get parameter
                                   186  "* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    000065                         187  float_bin:				"entry (vec_ptr)
    000065  aa   000120 6270 00    188  	push
    000066  aa  7 00040 2721 20
    000067  aa   000002 2270 03    189  	ldx7	2,du			"data type by definition
    000070  aa   000117 7100 04    190  	tra	common-*,ic		"go get parameter
                                   191  "* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    000071                         192  char:					"entry (vec_ptr, str_length)
    000071  aa   000120 6270 00    193  	push
    000072  aa  7 00040 2721 20
    000073  aa   000003 2270 03    194  	ldx7	3,du			"data type by definition
    000074  aa  0 00004 3515 20    195  	epp1	pr0|4,*			"addr (data string length)
    000075  aa  1 00000 2361 00    196  	ldq	pr1|0			"data string length
    000076  aa   000042 6040 04    197  	tmi	string_length_err-*,ic	"if < 0, got bad arg
    000077  aa   000002 7320 00    198  	qrs	2			"convert characters to words
    000100  aa   000036 7100 04    199  	tra	string_length_compare-*,ic	"validate arg
                                   200  "* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    000101                         201  bit:					"entry (vec_ptr, str_length)
    000101  aa   000120 6270 00    202  	push
    000102  aa  7 00040 2721 20
    000103  aa   000004 2270 03    203  	ldx7	4,du			"data type by definition
    000104  aa  0 00004 3515 20    204  	epp1	pr0|4,*			"addr (data string length)
    000105  aa  1 00000 2361 00    205  	ldq	pr1|0			"data string length
    000106  aa   000032 6040 04    206  	tmi	string_length_err-*,ic	"if < 0, got bad arg
    000107  aa   000044 5060 07    207  	div	36,dl			"convert bits to words
    000110  aa   000026 7100 04    208  	tra	string_length_compare-*,ic	"validate arg
                                   209  "* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    000111                         210  varying_char:				"entry (vec_ptr)
    000111  aa   000120 6270 00    211  	push
    000112  aa  7 00040 2721 20
    000113  aa   000005 2270 03    212  	ldx7	5,du			"data type by definition
    000114  aa   000073 7100 04    213  	tra	common-*,ic		"go get parameter
                                   214  "* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    000115                         215  general:					"entry (vec_ptr, function)
    000115  aa   000120 6270 00    216  	push
    000116  aa  7 00040 2721 20
    000117  aa   000000 2270 03    217  	ldx7	0,du			"data type by definition
    000120  aa  0 00004 3515 20    218  	epp1	pr0|4,*			"addr (addr (entry pair))
    000121  aa  1 00002 3521 20    219  	epp2	pr1|2,*			"environment ptr
    000122  aa  6 00060 2521 00    220  	spri2	arg_list_2		"store in arg list
    000123  aa  1 00000 3521 20    221  	epp2	pr1|0,*			"addr (user function)
    000124  aa   014000 4310 07    222  	fld	6144,dl			"get arg list header
    000125  aa   000010 2750 07    223  	ora	8,dl			"call type where environment ptr is used
    000126  aa  6 00050 7571 00    224  	staq	arg_list_1		"store arg list header
    000127  aa  6 00104 3515 00    225  	epp1	general_value		"addr (return value)
    000130  aa  6 00056 2515 00    226  	spri1	arg_list_1+6		"store as 3rd parameter
    000131  aa  6 00102 3515 00    227  	epp1	general_pptr_1		"addr (1st packed ptr)
    000132  aa  6 00052 2515 00    228  	spri1	arg_list_1+2		"store as 1st parameter
    000133  aa  6 00103 3515 00    229  	epp1	general_pptr_2		"addr (2nd packed ptr)
    000134  aa  6 00054 2515 00    230  	spri1	arg_list_1+4		"store as 2nd parameter
    000135  aa   000052 7100 04    231  	tra	common-*,ic		"go get parameter
                                   232  "
    000136                         233  string_length_compare:			"verify string length
    000136  4a  4 00012 1161 20    234  	cmpq	sys_info$max_seg_size	"larger than a segment??
    000137  aa   000047 6044 04    235  	tmoz	length_good-*,ic		"no, set data length
                                   236  
    000140                         237  string_length_err:
    000140  aa   777650 3534 04    238  	epp3	string_length_err_msg-*,ic	"get error message
    000141  aa  6 00064 2535 00    239  	spri3	arg_list_2+4		"store in arg list
                                   240  
    000142                         241  sub_err_call:
    000142  4a  4 00014 2361 20    242  	ldq	error_table_$out_of_bounds	"get error value
    000143  aa  6 00106 7561 00    243  	stq	error_value		"save for sub_err_ call
    000144  aa   000014 2350 03    244  	lda	12,du			"get number of args
    000145  aa   000004 2750 07    245  	ora	4,dl			"get call type
    000146  aa   000014 2360 03    246  	ldq	12,du			"get number of descriptors
    000147  aa  6 00050 7571 00    247  	staq	arg_list_1		"store arg list header
    000150  aa  6 00106 3535 00    248  	epp3	error_value		"addr (error value)
    000151  aa  6 00052 2535 00    249  	spri3	arg_list_1+2		"store in arg list
    000152  aa   777646 3534 04    250  	epp3	program_name-*,ic		"addr (program name)
    000153  aa  6 00054 2535 00    251  	spri3	arg_list_1+4		"store in arg list
    000154  aa   777647 3534 04    252  	epp3	sub_err_flag-*,ic		"addr (sub_err_ flag)
    000155  aa  6 00056 2535 00    253  	spri3	arg_list_1+6		"store in arg list
    000156  aa  7 00020 3535 00    254  	epp3	pr7|stack_header.parent_ptr	"addr (null ptr)
    000157  aa  6 00060 2535 00    255  	spri3	arg_list_2		"store in arg list
    000160  aa  6 00104 3535 00    256  	epp3	general_value		"addr (return value)
    000161  aa  3 00000 4501 00    257  	stz	pr3|0			"zero return value
    000162  aa  6 00062 2535 00    258  	spri3	arg_list_2+2		"store in arg list
    000163  aa   777641 3534 04    259  	epp3	fixed_35_desc-*,ic		"addr (fixed bin (35) descriptor))
    000164  aa  6 00066 2535 00    260  	spri3	arg_list_2+6		"store in arg list
    000165  aa  6 00076 2535 00    261  	spri3	arg_list_3+6		"store again for return value
    000166  aa   777637 3534 04    262  	epp3	program_name_desc-*,ic	"addr (character string descriptor)
    000167  aa  6 00070 2535 00    263  	spri3	arg_list_3		"store in arg list
    000170  aa   777636 3534 04    264  	epp3	sub_err_flag_desc-*,ic	"addr (character string descriptor)
    000171  aa  6 00072 2535 00    265  	spri3	arg_list_3+2		"store in arg list
    000172  aa   777635 3534 04    266  	epp3	ptr_desc-*,ic		"addr (ptr descriptor)
    000173  aa  6 00074 2535 00    267  	spri3	arg_list_3+4		"store in arg list
    000174  aa   777634 3534 04    268  	epp3	err_msg_desc-*,ic		"get error message descriptor
    000175  aa  6 00100 2535 00    269  	spri3	arg_list_4		"store in arg list
    000176  aa  6 00000 2541 00    270  	call	sub_err_$sub_err_(arg_list_1)	"call sub_err_
    000177  aa  6 00050 3501 00
    000200  4a  4 00010 3521 20
    000201  aa  6 00040 7531 00
    000202  aa  7 00036 6701 20
    000203  aa  6 00000 1731 00
    000204  aa  6 00040 0731 00
    000205  aa  7 00042 7101 20    271  	return				"leave program
                                   272  "
    000206                         273  length_good:				"set data length in $A!!
    000206  aa  1 00000 2351 00    274  	lda	pr1|0			"get data length
                                   275  
    000207                         276  common:					"verify array ptr size is in bounds
    000207  aa  0 00002 3715 20    277  	epp5	pr0|2,*			"addr (addr (ptr array base))
    000210  aa  5 00000 3715 20    278  	epp5	pr5|0,*			"addr (ptr array base)
    000211  aa  5 00000 2361 00    279  	ldq	pr5|0			"number of items to sort
    000212  aa   000003 6040 04    280  	tmi	items_err-*,ic		"if < 0, got bad arg
    000213  4a  4 00012 1161 20    281  	cmpq	sys_info$max_seg_size	"larger than a segment??
    000214  aa   000004 6040 04    282  	tmi	n_elems_ok-*,ic		"no, continue processing
                                   283  
    000215                         284  items_err:				"have error, can't go on
    000215  aa   777563 3534 04    285  	epp3	total_items_err_msg-*,ic	"get error message
    000216  aa  6 00064 2535 00    286  	spri3	arg_list_2+4		"put in arg list
    000217  aa   777723 7100 04    287  	tra	sub_err_call-*,ic		"report problems
                                   288  
    000220                         289  n_elems_ok:
    000220  aa   000002 1160 07    290  	cmpq	2,dl			"0 or 1 item in array??
    000221  aa   000002 6030 04    291  	trc	store_vars-*,ic		"no, have to do sort
    000222  aa  7 00042 7101 20    292  	return				"yes, sort finished
                                   293  
    000223                         294  store_vars: 
    000223  aa   000022 7360 00    295  	qls	18			"move total items to $QU
    000224  aa  6 00105 7561 00    296  	stq	N_in_upper		"store total items count
    000225  aa   000000 1070 03    297  	cmpx7	0,du			"is it $general entry??
    000226  aa   000002 6010 04    298  	tnz	fix_heap-*,ic		"no, start sort
    000227  aa  6 00050 3501 00    299  	epp0	arg_list_1		"yes, set $PR0 to arg list
                                   300  "
    000230                         301  fix_heap:					"just a section label
                                   302  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                                   303  "This is the fix_heap section of sort_items_indirect_.  It creates a
                                   304  "   heap, which is an almost complete binary tree in which each node is
                                   305  "   less than or equal to its father.  Register usage is as follows:
                                   306  "   PR0 -- addr (arg_list) {$general entry ONLY!!}
                                   307  "   PR1 -- right son ptr (if one exists)
                                   308  "   PR2 -- function entry ptr {$general entry ONLY!!}
                                   309  "   PR3 -- larger son ptr (initially assumed to be left son)
                                   310  "   PR4 -- parent ptr
                                   311  "   PR5 -- addr (ptr array base)
                                   312  "   PR6 -- addr (stack frame)
                                   313  "   PR7 -- addr (stack base)
                                   314  "   X4 -- larger child index (initially assumed to be left son index)
                                   315  "   X5 -- parent index
                                   316  "   X6 -- FH_do_i loop control variable
                                   317  "   X7 -- data type as defined by entry point
                                   318  "   A -- data string length {$char, $bit entries ONLY!!}
                                   319  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                                   320  
    000230  aa  5 00000 2361 00    321  	ldq	pr5|0			"put total items in $Q
    000231  aa   000001 7720 00    322  	qrl	1			"divide by shifting bits right
    000232  aa   000000 6260 06    323  	eax6	0,ql			"load loop start value from $Q
    000233  aa   000003 7100 04    324  	tra	FH_loop_start-*,ic		"goto loop start
                                   325  
    000234                         326  FH_do_i:					"start of do i loop, or
    000234                         327  compareB_else:				"no switch was made this time, or
    000234                         328  FH_do_while_end:				"do while done, try do i again
    000234  aa  5 00000 5441 15    329  	sprp4	pr5|0,x5			"son ptr = parent ptr
    000235  aa   000001 1260 03    330  	sblx6	1,du			"decrement loop index by 1
                                   331  
    000236                         332  FH_loop_start:
    000236  aa   000154 6000 04    333  	tze	sort_heap-*,ic		"loop finished, go to sort_heap
    000237  aa   000000 6250 16    334  	eax5	0,x6			"loop index is parent index
    000240  aa  5 00000 7641 15    335  	lprp4	pr5|0,x5			"get parent ptr
                                   336  
    000241                         337  FH_do_while:				"walk parent branch, swap up if son > parent
    000241  aa   000000 6360 15    338  	eaq	0,x5			"put parent index in $Q
    000242  aa   000001 7360 00    339  	qls	1			"*2, gives left son index
    000243  aa   000000 6240 02    340  	eax4	0,qu			"assume left son is larger
    000244  aa  6 00105 1041 00    341  	cmpx4	N_in_upper		"is left son index <= ptr array bound??
    000245  aa   000004 6020 04    342  	tnc	FH_two_sons-*,ic		"have two sons
    000246  aa   777766 6010 04    343  	tnz	FH_do_while_end-*,ic	"too big, try do i loop again
    000247  aa  5 00000 7631 14    344  	lprp3	pr5|0,x4			"get left son ptr
    000250  0a   000037 7100 37    345  	tra	label_vec_B,x7*		"find larger of son and parent
                                   346  
    000251                         347  FH_two_sons:
    000251  aa  5 00000 7631 14    348  	lprp3	pr5|0,x4			"get left son ptr
    000252  aa  5 00001 7611 14    349  	lprp1	pr5|1,x4			"get right son ptr
    000253  0a   000031 7100 37    350  	tra	label_vec_A,x7*		"find larger of sons
                                   351  "
    000254                         352  compare0_A:				"for $general entry
    000254  aa  6 00102 5431 00    353  	sprp3	general_pptr_1		"store left son ptr
    000255  aa  6 00103 5411 00    354  	sprp1	general_pptr_2		"store right son ptr
                                   355  	"call pseudo-op simulated to call function
    000256  aa  6 00000 2541 00    356  	spri	pr6|0			"save all PR's
    000257  aa  6 00040 7531 00    357  	sreg	pr6|stack_frame.regs	"save rest of registers
    000260  aa  7 00036 6701 20    358  	tsp4	pr7|stack_header.call_op_ptr,*     "use stack header ptr to call
    000261  aa  6 00000 1731 00    359  	lpri	pr6|0			"reclaim our PR's
    000262  aa  6 00040 0731 00    360  	lreg	pr6|stack_frame.regs	"reclaim rest of registers
                                   361  	"test function return value
    000263  aa  6 00104 2341 00    362  	szn	general_value		"is left son data < right son data??
    000264  aa   000003 6050 04    363  	tpl	compare0_B-*,ic		"no, left son is larger
    000265  aa   000001 0240 03    364  	adlx4	1,du			"larger son index = right son index
    000266  aa  1 00000 3535 00    365  	epp3	pr1|0			"larger son ptr = right son ptr
                                   366  
    000267                         367  compare0_B:				"for $general entry
    000267  aa  6 00102 5441 00    368  	sprp4	general_pptr_1		"store parent ptr
    000270  aa  6 00103 5431 00    369  	sprp3	general_pptr_2		"store son ptr
                                   370  	"call pseudo-op simulated to call function
    000271  aa  6 00000 2541 00    371  	spri	pr6|0			"save all PR's
    000272  aa  6 00040 7531 00    372  	sreg	pr6|stack_frame.regs	"save rest of registers
    000273  aa  7 00036 6701 20    373  	tsp4	pr7|stack_header.call_op_ptr,*     "use stack header ptr to call
    000274  aa  6 00000 1731 00    374  	lpri	pr6|0			"reclaim our PR's
    000275  aa  6 00040 0731 00    375  	lreg	pr6|stack_frame.regs	"reclaim rest of registers
                                   376  	"test function return value
    000276  aa  6 00104 2341 00    377  	szn	general_value		"is parent data < son data??
    000277  aa   777735 6050 04    378  	tpl	compareB_else-*,ic		"no, parent is larger
    000300  aa  5 00000 5431 15    379  	sprp3	pr5|0,x5			"parent ptr = son ptr
    000301  aa   000000 6250 14    380  	eax5	0,x4			"parent index = son index
    000302  aa   777737 6050 04    381  	tpl	FH_do_while-*,ic		"compare parent with new sons
    000303  aa   777731 7100 04    382  	tra	FH_do_while_end-*,ic	"if bit 0 on, parent index *2 BIG, quit
                                   383  "
    000304                         384  compare1_A:				"for $fixed_bin entry
    000304  aa  3 00000 2361 00    385  	ldq	pr3|0			"left son data
    000305  aa  1 00000 1161 00    386  	cmpq	pr1|0			"is left son data < right son data??
    000306  aa   000003 6050 04    387  	tpl	compare1_B-*,ic		"no, left son is larger
    000307  aa   000001 0240 03    388  	adlx4	1,du			"larger son index = right son index
    000310  aa  1 00000 3535 00    389  	epp3	pr1|0			"larger son ptr = right son ptr
                                   390  
    000311                         391  compare1_B:				"for $fixed_bin entry
    000311  aa  4 00000 2361 00    392  	ldq	pr4|0			"parent data
    000312  aa  3 00000 1161 00    393  	cmpq	pr3|0			"is parent data < son data??
    000313  aa   777721 6050 04    394  	tpl	compareB_else-*,ic		"no, parent is larger
    000314  aa  5 00000 5431 15    395  	sprp3	pr5|0,x5			"parent ptr = son ptr
    000315  aa   000000 6250 14    396  	eax5	0,x4			"parent index = son index
    000316  aa   777723 6050 04    397  	tpl	FH_do_while-*,ic		"compare parent with new sons
    000317  aa   777715 7100 04    398  	tra	FH_do_while_end-*,ic	"if bit 0 on, parent index *2 BIG, quit
                                   399  "
    000320                         400  compare2_A:				"for $float_bin entry
    000320  aa  3 00000 4331 00    401  	dfld	pr3|0			"left son data
    000321  aa  1 00000 5171 00    402  	dfcmp	pr1|0			"is left son data < right son data??
    000322  aa   000003 6050 04    403  	tpl	compare2_B-*,ic		"no, left son is larger
    000323  aa   000001 0240 03    404  	adlx4	1,du			"larger son index = right son index
    000324  aa  1 00000 3535 00    405  	epp3	pr1|0			"larger son ptr = right son ptr
                                   406  
    000325                         407  compare2_B:				"for $float_bin entry
    000325  aa  4 00000 4331 00    408  	dfld	pr4|0			"parent data
    000326  aa  3 00000 5171 00    409  	dfcmp	pr3|0			"is parent data < son data??
    000327  aa   777705 6050 04    410  	tpl	compareB_else-*,ic		"no, parent is larger
    000330  aa  5 00000 5431 15    411  	sprp3	pr5|0,x5			"parent ptr = son ptr
    000331  aa   000000 6250 14    412  	eax5	0,x4			"parent index = son index
    000332  aa   777707 6050 04    413  	tpl	FH_do_while-*,ic		"compare parent with new sons
    000333  aa   777701 7100 04    414  	tra	FH_do_while_end-*,ic	"if bit 0 on, parent index *2 BIG, quit
                                   415  "
    000334                         416  compare3_A:				"for $char entry
                                   417  	"N. B. data string length is in $A, DO NOT DESTROY!!
    000334  aa  0 40140 1065 40    418  	cmpc	(pr,rl),(pr,rl),fill(040)	"compare two strings
    000335  aa   300000 000005     419  	  desc9a	pr3|0,al			"left son data
    000336  aa   100000 000005     420  	  desc9a	pr1|0,al			"right son data
    000337  aa   000003 6030 04    421  	trc	compare3_B-*,ic		"left son is larger
    000340  aa   000001 0240 03    422  	adlx4	1,du			"larger son index = right son index
    000341  aa  1 00000 3535 00    423  	epp3	pr1|0			"larger son ptr = right son ptr
                                   424  
    000342                         425  compare3_B:				"for $char entry
                                   426  	"N. B. data string length is in $A, DO NOT DESTROY!!
    000342  aa  0 40140 1065 40    427  	cmpc	(pr,rl),(pr,rl),fill(040)	"compare two strings
    000343  aa   400000 000005     428  	  desc9a	pr4|0,al			"parent data
    000344  aa   300000 000005     429  	  desc9a	pr3|0,al			"son data
    000345  aa   777667 6030 04    430  	trc	compareB_else-*,ic		"parent is larger
    000346  aa  5 00000 5431 15    431  	sprp3	pr5|0,x5			"parent ptr = son ptr
    000347  aa   000000 6250 14    432  	eax5	0,x4			"parent index = son index
    000350  aa   777671 6050 04    433  	tpl	FH_do_while-*,ic		"compare parent with new sons
    000351  aa   777663 7100 04    434  	tra	FH_do_while_end-*,ic	"if bit 0 on, parent index *2 BIG, quit
                                   435  "
    000352                         436  compare4_A:				"for $bit entry
                                   437  	"N. B. data string length is in $A, DO NOT DESTROY!!
    000352  aa  0 00140 0665 40    438  	cmpb	(pr,rl),(pr,rl),fill(0)	"compare two bit strings
    000353  aa   300000 000005     439  	  descb	pr3|0,al			"left son data
    000354  aa   100000 000005     440  	  descb	pr1|0,al			"right son data
    000355  aa   000003 6030 04    441  	trc	compare4_B-*,ic		"left son is larger
    000356  aa   000001 0240 03    442  	adlx4	1,du			"larger son index = right son index
    000357  aa  1 00000 3535 00    443  	epp3	pr1|0			"larger son ptr = right son ptr
                                   444  
    000360                         445  compare4_B:				"for $bit entry
                                   446  	"N. B. data string length is in $A, DO NOT DESTROY!!
    000360  aa  0 00140 0665 40    447  	cmpb	(pr,rl),(pr,rl),fill(0)	"compare two bit strings
    000361  aa   400000 000005     448  	  descb	pr4|0,al			"parent data
    000362  aa   300000 000005     449  	  descb	pr3|0,al			"son data
    000363  aa   777651 6030 04    450  	trc	compareB_else-*,ic		"parent is larger
    000364  aa  5 00000 5431 15    451  	sprp3	pr5|0,x5			"parent ptr = son ptr
    000365  aa   000000 6250 14    452  	eax5	0,x4			"parent index = son index
    000366  aa   777653 6050 04    453  	tpl	FH_do_while-*,ic		"compare parent with new sons
    000367  aa   777645 7100 04    454  	tra	FH_do_while_end-*,ic	"if bit 0 on, parent index *2 BIG, quit
                                   455  "
    000370                         456  compare5_A:				"for $varying_char entry
    000370  aa  3 00000 2351 00    457  	lda	pr3|0			"left son data length
    000371  aa  1 00000 2361 00    458  	ldq	pr1|0			"right son data length
    000372  aa  0 40140 1065 40    459  	cmpc	(pr,rl),(pr,rl),fill(040)	"compare two strings
    000373  aa   300001 000005     460  	  desc9a	pr3|1,al			"left son data
    000374  aa   100001 000006     461  	  desc9a	pr1|1,ql			"right son data
    000375  aa   000003 6030 04    462  	trc	compare5_B-*,ic		"left son is larger
    000376  aa   000001 0240 03    463  	adlx4	1,du			"larger son index = right son index
    000377  aa  1 00000 3535 00    464  	epp3	pr1|0			"larger son ptr = right son ptr
                                   465  
    000400                         466  compare5_B:				"for $varying_char entry
    000400  aa  4 00000 2351 00    467  	lda	pr4|0			"parent data length
    000401  aa  3 00000 2361 00    468  	ldq	pr3|0			"son data length
    000402  aa  0 40140 1065 40    469  	cmpc	(pr,rl),(pr,rl),fill(040)	"compare the two strings
    000403  aa   400001 000005     470  	  desc9a	pr4|1,al			"parent data
    000404  aa   300001 000006     471  	  desc9a	pr3|1,ql			"son data
    000405  aa   777627 6030 04    472  	trc	compareB_else-*,ic		"parent is larger
    000406  aa  5 00000 5431 15    473  	sprp3	pr5|0,x5			"parent ptr = son ptr
    000407  aa   000000 6250 14    474  	eax5	0,x4			"parent index = son index
    000410  aa   777631 6050 04    475  	tpl	FH_do_while-*,ic		"compare parent with new sons
    000411  aa   777623 7100 04    476  	tra	FH_do_while_end-*,ic	"if bit 0 on, parent index *2 BIG, quit
                                   477  "
    000412                         478  sort_heap:				"just a program label
                                   479  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                                   480  "This is the sort_heap section of sort_items_.  It sorts the heap by
                                   481  "   putting the root node value in its proper place and adjusting the
                                   482  "   remaining heap, producing a new root node value.  Register
                                   483  "   usage is as follows:
                                   484  "   PR0 -- addr (arg_list) {$general entry ONLY!!}
                                   485  "   PR1 -- right son ptr (if one exists)
                                   486  "   PR2 -- function entry ptr {$general entry ONLY!!}
                                   487  "   PR3 -- larger son ptr for compare C (initially assumed to be left son)
                                   488  "	 parent ptr for compare D
                                   489  "   PR3 -- larger son ptr (initially assumed to be left son)
                                   490  "   PR4 -- last leaf ptr
                                   491  "   PR5 -- addr (ptr array base)
                                   492  "   PR6 -- addr (stack frame)
                                   493  "   PR7 -- addr (stack base)
                                   494  "   X4 -- larger child index (initially assumed to be left son index)
                                   495  "   X5 -- parent index
                                   496  "   X6 -- SH_do_i loop control variable
                                   497  "   X7 -- data type as defined by entry point
                                   498  "   A -- data string length {$char, $bit entries ONLY!!}
                                   499  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                                   500  "
    000412  aa  6 00105 2261 00    501  	ldx6	N_in_upper		"put total items in loop counter
    000413  aa   000002 7100 04    502  	tra	SH_loop_start-*,ic		"goto loop start
                                   503  
    000414                         504  SH_do_i:					"start of do i loop, or
    000414                         505  compareD_then:				"finished backing up tree, or
    000414                         506  SH_do_while_end:				"do while done, try do i again
    000414  aa  5 00000 5441 14    507  	sprp4	pr5|0,x4			"son ptr = last leaf ptr
                                   508  
    000415                         509  SH_loop_start:
    000415  aa   000001 1260 03    510  	sblx6	1,du			"decrement loop index by 1
    000416  aa   000236 6000 04    511  	tze	sort_end-*,ic		"loop done, goto sort_end
    000417  aa  6 00105 7461 00    512  	stx6	N_in_upper		"store counter index bound
    000420  aa  5 00001 7641 16    513  	lprp4	pr5|1,x6			"get last leaf ptr
    000421  aa  5 00001 2361 00    514  	ldq	pr5|1			"get root ptr
    000422  aa  5 00001 7561 16    515  	stq	pr5|1,x6			"last leaf storage = root ptr
    000423  aa   000001 2250 03    516  	ldx5	1,du			"parent index = 1
                                   517  
    000424                         518  SH_do_while:				"walk tree, swap up if son > last leaf
    000424  aa   000000 6360 15    519  	eaq	0,x5			"put parent index in $Q
    000425  aa   000001 7360 00    520  	qls	1			"multiply by 2
    000426  aa   000000 6240 02    521  	eax4	0,qu			"put in larger child index
    000427  aa  6 00105 1041 00    522  	cmpx4	N_in_upper		"is larger son index <= loop index??
    000430  aa   000004 6020 04    523  	tnc	SH_two_sons-*,ic		"have two sons
    000431  aa   000006 6000 04    524  	tze	SH_one_son-*,ic		"have one son
    000432  aa   000000 6240 15    525  	eax4	0,x5			"too big, get old value
    000433  0a   000053 7100 37    526  	tra	label_vec_D,x7*		"go back up tree
                                   527  
    000434                         528  SH_two_sons:
    000434  aa  5 00000 7631 14    529  	lprp3	pr5|0,x4			"get left son ptr
    000435  aa  5 00001 7611 14    530  	lprp1	pr5|1,x4			"get right son ptr
    000436  0a   000045 7100 37    531  	tra	label_vec_C,x7*		"find larger of sons
                                   532  
    000437                         533  SH_one_son:
    000437  aa  5 00000 7631 14    534  	lprp3	pr5|0,x4			"get larger son ptr
    000440  aa  5 00000 5431 15    535  	sprp3	pr5|0,x5			"parent ptr = son ptr
    000441  aa   000000 6250 14    536  	eax5	0,x4			"parent index = son index
    000442  aa   777762 6050 04    537  	tpl	SH_do_while-*,ic		"compare parent with new sons
    000443  0a   000053 7100 37    538  	tra	label_vec_D,x7*		"else go back up tree
                                   539  "
    000444                         540  compare0_C:				"for $general entry
    000444  aa  6 00102 5431 00    541  	sprp3	general_pptr_1		"left son ptr
    000445  aa  6 00103 5411 00    542  	sprp1	general_pptr_2		"right son ptr
                                   543  	"call pseudo-op simulated to call function
    000446  aa  6 00000 2541 00    544  	spri	pr6|0			"save all PR's
    000447  aa  6 00040 7531 00    545  	sreg	pr6|stack_frame.regs	"save rest of registers
    000450  aa  7 00036 6701 20    546  	tsp4	pr7|stack_header.call_op_ptr,*     "use stack header ptr to call
    000451  aa  6 00000 1731 00    547  	lpri	pr6|0			"reclaim our PR's
    000452  aa  6 00040 0731 00    548  	lreg	pr6|stack_frame.regs	"reclaim rest of registers
                                   549  	"test function return value
    000453  aa  6 00104 2341 00    550  	szn	general_value		"is left son data < right son data??
    000454  aa   000003 6050 04    551  	tpl	assignment0_C-*,ic		"no, left son is larger
    000455  aa   000001 0240 03    552  	adlx4	1,du			"larger son index = right son index
    000456  aa  1 00000 3535 00    553  	epp3	pr1|0			"larger son ptr = right son ptr
                                   554  
    000457                         555  assignment0_C:
    000457  aa  5 00000 5431 15    556  	sprp3	pr5|0,x5			"parent ptr = son ptr
    000460  aa   000000 6250 14    557  	eax5	0,x4			"parent index = son index
    000461  aa   777743 6050 04    558  	tpl	SH_do_while-*,ic		"compare parent with new sons
                                   559  
    000462                         560  compare0_D:				"for $general entry
    000462  aa   000000 6360 14    561  	eaq	0,x4			"put son index in $Q
    000463  aa   000001 7720 00    562  	qrl	1			"divide by shifting bits right
    000464  aa   000000 6250 02    563  	eax5	0,qu			"put in parent index
    000465  aa   777727 6000 04    564  	tze	compareD_then-*,ic		"if = 0, try do i loop again
    000466  aa  5 00000 7631 15    565  	lprp3	pr5|0,x5			"get parent ptr
    000467  aa  6 00102 5431 00    566  	sprp3	general_pptr_1		"set parent ptr
    000470  aa  6 00103 5441 00    567  	sprp4	general_pptr_2		"set last leaf ptr
                                   568  	"call pseudo-op simulated to call function
    000471  aa  6 00000 2541 00    569  	spri	pr6|0			"save all PR's
    000472  aa  6 00040 7531 00    570  	sreg	pr6|stack_frame.regs	"save rest of registers
    000473  aa  7 00036 6701 20    571  	tsp4	pr7|stack_header.call_op_ptr,*     "use stack header ptr to call
    000474  aa  6 00000 1731 00    572  	lpri	pr6|0			"reclaim our PR's
    000475  aa  6 00040 0731 00    573  	lreg	pr6|stack_frame.regs	"reclaim rest of registers
                                   574  	"test function return value
    000476  aa  6 00104 2341 00    575  	szn	general_value		"is parent data < last leaf data??
    000477  aa   777715 6050 04    576  	tpl	compareD_then-*,ic		"no, parent is larger
    000500  aa  5 00000 5431 14    577  	sprp3	pr5|0,x4			"son ptr = parent ptr
    000501  aa   000000 6240 15    578  	eax4	0,x5			"son index = parent index
    000502  aa   777760 7100 04    579  	tra	compare0_D-*,ic		"go back up tree
                                   580  "
    000503                         581  compare1_C:				"for $fixed_bin entry
    000503  aa  3 00000 2361 00    582  	ldq	pr3|0			"left son data
    000504  aa  1 00000 1161 00    583  	cmpq	pr1|0			"is left son data < right son data??
    000505  aa   000003 6050 04    584  	tpl	assignment1_C-*,ic		"left son is larger
    000506  aa   000001 0240 03    585  	adlx4	1,du			"larger son index = right son index
    000507  aa  1 00000 3535 00    586  	epp3	pr1|0			"larger son ptr = right son ptr
                                   587  
    000510                         588  assignment1_C:
    000510  aa  5 00000 5431 15    589  	sprp3	pr5|0,x5			"parent ptr = son ptr
    000511  aa   000000 6250 14    590  	eax5	0,x4			"parent index = son index
    000512  aa   777712 6050 04    591  	tpl	SH_do_while-*,ic		"compare parent with new sons
                                   592  
    000513                         593  compare1_D:				"for $fixed_bin entry
    000513  aa   000000 6360 14    594  	eaq	0,x4			"put son index in $Q
    000514  aa   000001 7720 00    595  	qrl	1			"divide by shifting bits right
    000515  aa   000000 6250 02    596  	eax5	0,qu			"put in parent index
    000516  aa   777676 6000 04    597  	tze	compareD_then-*,ic		"if = 0, try do i loop again
    000517  aa  5 00000 7631 15    598  	lprp3	pr5|0,x5			"get parent ptr
    000520  aa  3 00000 2361 00    599  	ldq	pr3|0			"parent data
    000521  aa  4 00000 1161 00    600  	cmpq	pr4|0			"is parent data < last leaf data??
    000522  aa   777672 6050 04    601  	tpl	compareD_then-*,ic		"no, parent is larger
    000523  aa  5 00000 5431 14    602  	sprp3	pr5|0,x4			"son ptr = parent ptr
    000524  aa   000000 6240 15    603  	eax4	0,x5			"son index = parent index
    000525  aa   777766 7100 04    604  	tra	compare1_D-*,ic		"go back up tree
                                   605  "
    000526                         606  compare2_C:				"for $float_bin entry
    000526  aa  3 00000 4331 00    607  	dfld	pr3|0			"left son data
    000527  aa  1 00000 5171 00    608  	dfcmp	pr1|0			"is left son data < right son data??
    000530  aa   000003 6050 04    609  	tpl	assignment2_C-*,ic		"no, left son is larger
    000531  aa   000001 0240 03    610  	adlx4	1,du			"larger son index = right son index
    000532  aa  1 00000 3535 00    611  	epp3	pr1|0			"larger son ptr = right son ptr
                                   612  
    000533                         613  assignment2_C:
    000533  aa  5 00000 5431 15    614  	sprp3	pr5|0,x5			"parent ptr = son ptr
    000534  aa   000000 6250 14    615  	eax5	0,x4			"parent index = son index
    000535  aa   777667 6050 04    616  	tpl	SH_do_while-*,ic		"compare parent with new sons
                                   617  
    000536                         618  compare2_D:				"for $float_bin entry
    000536  aa   000000 6360 14    619  	eaq	0,x4			"put son index in $Q
    000537  aa   000001 7720 00    620  	qrl	1			"divide by shifting bits right
    000540  aa   000000 6250 02    621  	eax5	0,qu			"put in parent index
    000541  aa   777653 6000 04    622  	tze	compareD_then-*,ic		"if = 0, try do i loop again
    000542  aa  5 00000 7631 15    623  	lprp3	pr5|0,x5			"get parent ptr
    000543  aa  3 00000 4331 00    624  	dfld	pr3|0			"parent data
    000544  aa  4 00000 5171 00    625  	dfcmp	pr4|0			"is parent data < last leaf data??
    000545  aa   777647 6050 04    626  	tpl	compareD_then-*,ic		"no, parent is larger
    000546  aa  5 00000 5431 14    627  	sprp3	pr5|0,x4			"son index = parent index
    000547  aa   000000 6240 15    628  	eax4	0,x5			"son index = parent index
    000550  aa   777766 7100 04    629  	tra	compare2_D-*,ic		"go back up tree
                                   630  "
    000551                         631  compare3_C:				"for $char entry
                                   632  	"N. B. data string length is in $A, DO NOT DESTROY!!
    000551  aa  0 40140 1065 40    633  	cmpc	(pr,rl),(pr,rl),fill(040)	"compare two strings
    000552  aa   300000 000005     634  	  desc9a	pr3|0,al			"left son data
    000553  aa   100000 000005     635  	  desc9a	pr1|0,al			"right son data
    000554  aa   000003 6030 04    636  	trc	assignment3_C-*,ic		"left son is larger
    000555  aa   000001 0240 03    637  	adlx4	1,du			"larger son index = right son index
    000556  aa  1 00000 3535 00    638  	epp3	pr1|0			"larger son ptr = right son ptr
                                   639  
    000557                         640  assignment3_C:
    000557  aa  5 00000 5431 15    641  	sprp3	pr5|0,x5			"parent ptr = son ptr
    000560  aa   000000 6250 14    642  	eax5	0,x4			"parent index = son index
    000561  aa   777643 6050 04    643  	tpl	SH_do_while-*,ic		"compare parent with new sons
                                   644  
    000562                         645  compare3_D:				"for $char entry
    000562  aa   000000 6360 14    646  	eaq	0,x4			"put son index in $Q
    000563  aa   000001 7720 00    647  	qrl	1			"divide by shifting bits right
    000564  aa   000000 6250 02    648  	eax5	0,qu			"put in parent index
    000565  aa   777627 6000 04    649  	tze	compareD_then-*,ic		"if = 0, try do i loop again
    000566  aa  5 00000 7631 15    650  	lprp3	pr5|0,x5			"get parent ptr
                                   651  	"N. B. data string length is in $A, DO NOT DESTROY!!
    000567  aa  0 40140 1065 40    652  	cmpc	(pr,rl),(pr,rl),fill(040)	"compare two strings
    000570  aa   300000 000005     653  	  desc9a	pr3|0,al			"parent data
    000571  aa   400000 000005     654  	  desc9a	pr4|0,al			"last leaf data
    000572  aa   777622 6030 04    655  	trc	compareD_then-*,ic		"parent is larger
    000573  aa  5 00000 5431 14    656  	sprp3	pr5|0,x4			"son ptr = parent ptr
    000574  aa   000000 6240 15    657  	eax4	0,x5			"son index = parent index
    000575  aa   777765 7100 04    658  	tra	compare3_D-*,ic		"go back up tree
                                   659  "
    000576                         660  compare4_C:				"for $bit entry
                                   661  	"N. B. data string length is in $A, DO NOT DESTROY!!
    000576  aa  0 00140 0665 40    662  	cmpb	(pr,rl),(pr,rl),fill(0)	"compare two bit strings
    000577  aa   300000 000005     663  	  descb	pr3|0,al			"left son data
    000600  aa   100000 000005     664  	  descb	pr1|0,al			"right son data
    000601  aa   000003 6030 04    665  	trc	assignment4_C-*,ic		"left son is larger
    000602  aa   000001 0240 03    666  	adlx4	1,du			"larger son index = right son index
    000603  aa  1 00000 3535 00    667  	epp3	pr1|0			"larger son ptr = right son ptr
                                   668  
    000604                         669  assignment4_C:
    000604  aa  5 00000 5431 15    670  	sprp3	pr5|0,x5			"parent ptr = son ptr
    000605  aa   000000 6250 14    671  	eax5	0,x4			"parent index = son index
    000606  aa   777616 6050 04    672  	tpl	SH_do_while-*,ic		"compare parent with new sons
                                   673  
    000607                         674  compare4_D:				"for $bit entry
    000607  aa   000000 6360 14    675  	eaq	0,x4			"put son index in $Q
    000610  aa   000001 7720 00    676  	qrl	1			"divide by shifting bits right
    000611  aa   000000 6250 02    677  	eax5	0,qu			"put in parent index
    000612  aa   777602 6000 04    678  	tze	compareD_then-*,ic		"if = 0, try do i loop again
    000613  aa  5 00000 7631 15    679  	lprp3	pr5|0,x5			"get parent ptr
                                   680  	"N. B. data string length is in $A, DO NOT DESTROY!!
    000614  aa  0 00140 0665 40    681  	cmpb	(pr,rl),(pr,rl),fill(0)	"compare two bit strings
    000615  aa   300000 000005     682  	  descb	pr3|0,al			"parent data
    000616  aa   400000 000005     683  	  descb	pr4|0,al			"last leaf data
    000617  aa   777575 6030 04    684  	trc	compareD_then-*,ic		"parent is larger
    000620  aa  5 00000 5431 14    685  	sprp3	pr5|0,x4			"son ptr = parent ptr
    000621  aa   000000 6240 15    686  	eax4	0,x5			"son index = parent index
    000622  aa   777765 7100 04    687  	tra	compare4_D-*,ic		"go back up tree
                                   688  "
    000623                         689  compare5_C:				"for $varying_char entry
    000623  aa  3 00000 2351 00    690  	lda	pr3|0			"left son data length
    000624  aa  1 00000 2361 00    691  	ldq	pr1|0			"right son data length
    000625  aa  0 40140 1065 40    692  	cmpc	(pr,rl),(pr,rl),fill(040)	"compare two strings
    000626  aa   300001 000005     693  	  desc9a	pr3|1,al			"left son data
    000627  aa   100001 000006     694  	  desc9a	pr1|1,ql			"right son data
    000630  aa   000003 6030 04    695  	trc	assignment5_C-*,ic		"left son is larger
    000631  aa   000001 0240 03    696  	adlx4	1,du			"larger son index = right son index
    000632  aa  1 00000 3535 00    697  	epp3	pr1|0			"larger son ptr = right son ptr
                                   698  
    000633                         699  assignment5_C:
    000633  aa  5 00000 5431 15    700  	sprp3	pr5|0,x5			"parent ptr = son ptr
    000634  aa   000000 6250 14    701  	eax5	0,x4			"parent index = son index
    000635  aa   777567 6050 04    702  	tpl	SH_do_while-*,ic		"compare parent with new sons
                                   703  
    000636                         704  compare5_D:				"for $varying_char entry
    000636  aa   000000 6360 14    705  	eaq	0,x4			"put son index in $Q
    000637  aa   000001 7720 00    706  	qrl	1			"divide by shifting bits right
    000640  aa   000000 6250 02    707  	eax5	0,qu			"put in parent index
    000641  aa   777553 6000 04    708  	tze	compareD_then-*,ic		"if = 0, try do i loop again
    000642  aa  5 00000 7631 15    709  	lprp3	pr5|0,x5			"get parent ptr
    000643  aa  3 00000 2351 00    710  	lda	pr3|0			"parent data length
    000644  aa  4 00000 2361 00    711  	ldq	pr4|0			"last leaf data length
    000645  aa  0 40140 1065 40    712  	cmpc	(pr,rl),(pr,rl),fill(040)	"compare two strings
    000646  aa   300001 000005     713  	  desc9a	pr3|1,al			"parent data
    000647  aa   400001 000006     714  	  desc9a	pr4|1,ql			"last leaf data
    000650  aa   777544 6030 04    715  	trc	compareD_then-*,ic		"parent is larger
    000651  aa  5 00000 5431 14    716  	sprp3	pr5|0,x4			"son ptr = parent ptr
    000652  aa   000000 6240 15    717  	eax4	0,x5			"son index = parent index
    000653  aa   777763 7100 04    718  	tra	compare5_D-*,ic		"go back up tree
                                   719  
    000654                         720  sort_end:					"sort finished, go home
    000654  aa  7 00042 7101 20    721  	return
                                   722  	end				"program done
ENTRY SEQUENCES
     
    000655  5a   000044 0000 00
    000656  aa  7 00046 2721 20
    000657  0a   000061 7100 00
    000660  5a   000036 0000 00
    000661  aa  7 00046 2721 20
    000662  0a   000065 7100 00
    000663  5a   000031 0000 00
    000664  aa  7 00046 2721 20
    000665  0a   000071 7100 00
    000666  5a   000025 0000 00
    000667  aa  7 00046 2721 20
    000670  0a   000101 7100 00
    000671  5a   000016 0000 00
    000672  aa  7 00046 2721 20
    000673  0a   000111 7100 00
    000674  5a   000011 0000 00
    000675  aa  7 00046 2721 20
    000676  0a   000115 7100 00

NO LITERALS
     
NAME DEFINITIONS FOR ENTRY POINTS AND SEGDEFS

    000700  5a   000003 000000 
    000701  5a   000061 600000 
    000702  aa   000000 000000 
    000703  55   000011 000002 
    000704  5a   000002 400003 
    000705  55   000006 000011 
    000706  aa  013 163 157 162
    000707  aa  164 137 151 164
    000710  aa  145 155 163 137
    000711  55   000016 000003 
    000712  0a   000675 500000 
    000713  55   000014 000003 
    000714  aa  007 147 145 156         general
    000715  aa  145 162 141 154
    000716  55   000025 000011 
    000717  0a   000672 500000 
    000720  55   000021 000003 
    000721  aa  014 166 141 162         varying_char
    000722  aa  171 151 156 147
    000723  aa  137 143 150 141
    000724  aa  162 000 000 000
    000725  55   000031 000016 
    000726  0a   000667 500000 
    000727  55   000030 000003 
    000730  aa  003 142 151 164         bit
    000731  55   000036 000025 
    000732  0a   000664 500000 
    000733  55   000034 000003 
    000734  aa  004 143 150 141         char
    000735  aa  162 000 000 000
    000736  55   000044 000031 
    000737  0a   000661 500000 
    000740  55   000041 000003 
    000741  aa  011 146 154 157         float_bin
    000742  aa  141 164 137 142
    000743  aa  151 156 000 000
    000744  55   000052 000036 
    000745  0a   000656 500000 
    000746  55   000047 000003 
    000747  aa  011 146 151 170         fixed_bin
    000750  aa  145 144 137 142
    000751  aa  151 156 000 000
    000752  55   000002 000044 
    000753  6a   000000 400002 
    000754  55   000055 000003 
    000755  aa  014 163 171 155         symbol_table
    000756  aa  142 157 154 137
    000757  aa  164 141 142 154
    000760  aa  145 000 000 000

DEFINITIONS HASH TABLE

    000761  aa   000000 000015 
    000762  aa   000000 000000 
    000763  aa   000000 000000 
    000764  aa   000000 000000 
    000765  aa   000000 000000 
    000766  5a   000031 000000 
    000767  5a   000016 000000 
    000770  5a   000044 000000 
    000771  5a   000052 000000 
    000772  5a   000025 000000 
    000773  5a   000011 000000 
    000774  5a   000036 000000 
    000775  aa   000000 000000 
    000776  aa   000000 000000 

EXTERNAL NAMES

    000777  aa  015 157 165 164         out_of_bounds
    001000  aa  137 157 146 137
    001001  aa  142 157 165 156
    001002  aa  144 163 000 000
    001003  aa  014 145 162 162         error_table_
    001004  aa  157 162 137 164
    001005  aa  141 142 154 145
    001006  aa  137 000 000 000
    001007  aa  014 155 141 170         max_seg_size
    001010  aa  137 163 145 147
    001011  aa  137 163 151 172
    001012  aa  145 000 000 000
    001013  aa  010 163 171 163         sys_info
    001014  aa  137 151 156 146
    001015  aa  157 000 000 000
    001016  aa  010 163 165 142         sub_err_
    001017  aa  137 145 162 162
    001020  aa  137 000 000 000

NO TRAP POINTER WORDS

TYPE PAIR BLOCKS

    001021  aa   000004 000000 
    001022  55   000103 000077 
    001023  aa   000004 000000 
    001024  55   000113 000107 
    001025  aa   000004 000000 
    001026  55   000116 000116 
    001027  aa   000001 000000 
    001030  aa   000000 000000 

INTERNAL EXPRESSION WORDS

    001031  5a   000121 000000 
    001032  5a   000123 000000 
    001033  5a   000125 000000 
LINKAGE INFORMATION
      
    000000  aa   000000 000000 
    000001  0a   000700 000000 
    000002  aa   000000 000000 
    000003  aa   000000 000000 
    000004  aa   000000 000000 
    000005  aa   000000 000000 
    000006  22   000010 000016 
    000007  a2   000000 000000 
    000010  9a   777770 0000 46         sub_err_|sub_err_
    000011  5a   000133 0000 00
    000012  9a   777766 0000 46         sys_info|max_seg_size
    000013  5a   000132 0000 00
    000014  9a   777764 0000 46         error_table_|out_of_bounds
    000015  5a   000131 0000 00
SYMBOL INFORMATION
     
SYMBOL TABLE HEADER
     
    000000  aa   000000 000001 
    000001  aa   163171 155142 
    000002  aa   164162 145145 
    000003  aa   000000 000004 
    000004  aa   000000 114732 
    000005  aa   732732 062314 
    000006  aa   000000 114775 
    000007  aa   664605 201345 
    000010  aa   141154 155040 
    000011  aa   040040 040040 
    000012  aa   000024 000040 
    000013  aa   000034 000040 
    000014  aa   000044 000100 
    000015  aa   000002 000002 
    000016  aa   000064 000000 
    000017  aa   000000 000221 
    000020  aa   000000 000145 
    000021  aa   000000 000205 
    000022  aa   000211 000145 
    000023  aa   000064 000000 
    000024  aa   101114 115040 
    000025  aa   126145 162163 
    000026  aa   151157 156040 
    000027  aa   040066 056067 
    000030  aa   040040 117143 
    000031  aa   164157 142145 
    000032  aa   162040 061071 
    000033  aa   070066 040040 
    000034  aa   107112 157150 
    000035  aa   156163 157156 
    000036  aa   056123 171163 
    000037  aa   115141 151156 
    000040  aa   164056 141040 
    000041  aa   040040 040040 
    000042  aa   040040 040040 
    000043  aa   040040 040040 
    000044  aa   154151 163164 
    000045  aa   040040 040040 
    000046  aa   040040 040040 
    000047  aa   040040 040040 
    000050  aa   040040 040040 
    000051  aa   040040 040040 
    000052  aa   040040 040040 
    000053  aa   040040 040040 
    000054  aa   040040 040040 
    000055  aa   040040 040040 
    000056  aa   040040 040040 
    000057  aa   040040 040040 
    000060  aa   040040 040040 
    000061  aa   040040 040040 
    000062  aa   040040 040040 
    000063  aa   040040 040040 
    000064  aa   000000 000001 
    000065  aa   000000 000003 
    000066  aa   000102 000060 
    000067  aa   147740 446027 
    000070  aa   000000 114774 
    000071  aa   460564 400000 
    000072  aa   000116 000066 
    000073  aa   147714 750316 
    000074  aa   000000 114774 
    000075  aa   453561 000000 
    000076  aa   000134 000041 
    000077  aa   052721 247134 
    000100  aa   000000 105272 
    000101  aa   317215 400000 
    000102  aa   076163 160145          >special_ldd>install>MR12.0-1206>sort_items_.alm
    000103  aa   143151 141154 
    000104  aa   137154 144144 
    000105  aa   076151 156163 
    000106  aa   164141 154154 
    000107  aa   076115 122061 
    000110  aa   062056 060055 
    000111  aa   061062 060066 
    000112  aa   076163 157162 
    000113  aa   164137 151164 
    000114  aa   145155 163137 
    000115  aa   056141 154155 
    000116  aa   076163 160145          >special_ldd>install>MR12.0-1206>stack_header.incl.alm
    000117  aa   143151 141154 
    000120  aa   137154 144144 
    000121  aa   076151 156163 
    000122  aa   164141 154154 
    000123  aa   076115 122061 
    000124  aa   062056 060055 
    000125  aa   061062 060066 
    000126  aa   076163 164141 
    000127  aa   143153 137150 
    000130  aa   145141 144145 
    000131  aa   162056 151156 
    000132  aa   143154 056141 
    000133  aa   154155 040040 
    000134  aa   076154 144144          >ldd>include>stack_frame.incl.alm
    000135  aa   076151 156143 
    000136  aa   154165 144145 
    000137  aa   076163 164141 
    000140  aa   143153 137146 
    000141  aa   162141 155145 
    000142  aa   056151 156143 
    000143  aa   154056 141154 
    000144  aa   155040 040040 
               MULTICS ASSEMBLY CROSS REFERENCE LISTING

   Value        Symbol                   Source file   Line number

          50    arg_list_1               sort_items_:   86,  224,  226,  228,  230,  247,  249,  251,  253,  270,  299.
          60    arg_list_2               sort_items_:   86,  220,  239,  255,  258,  260,  286.
          70    arg_list_3               sort_items_:   86,  261,  263,  265,  267.
         100    arg_list_4               sort_items_:   87,  269.
         457    assignment0_C            sort_items_:  551,  555.
         510    assignment1_C            sort_items_:  584,  588.
         533    assignment2_C            sort_items_:  609,  613.
         557    assignment3_C            sort_items_:  636,  640.
         604    assignment4_C            sort_items_:  665,  669.
         633    assignment5_C            sort_items_:  695,  699.
         101    bit                      sort_items_:   83,  201.
        1170    call_offset              stack_header:        80.
          71    char                     sort_items_:   83,  192.
         207    common                   sort_items_:  185,  190,  213,  231,  276.
         254    compare0_A               sort_items_:  126,  352.
         267    compare0_B               sort_items_:  134,  363,  367.
         444    compare0_C               sort_items_:  142,  540.
         462    compare0_D               sort_items_:  150,  560,  579.
         304    compare1_A               sort_items_:  127,  384.
         311    compare1_B               sort_items_:  135,  387,  391.
         503    compare1_C               sort_items_:  143,  581.
         513    compare1_D               sort_items_:  151,  593,  604.
         320    compare2_A               sort_items_:  128,  400.
         325    compare2_B               sort_items_:  136,  403,  407.
         526    compare2_C               sort_items_:  144,  606.
         536    compare2_D               sort_items_:  152,  618,  629.
         334    compare3_A               sort_items_:  129,  416.
         342    compare3_B               sort_items_:  137,  421,  425.
         551    compare3_C               sort_items_:  145,  631.
         562    compare3_D               sort_items_:  153,  645,  658.
         352    compare4_A               sort_items_:  130,  436.
         360    compare4_B               sort_items_:  138,  441,  445.
         576    compare4_C               sort_items_:  146,  660.
         607    compare4_D               sort_items_:  154,  674,  687.
         370    compare5_A               sort_items_:  131,  456.
         400    compare5_B               sort_items_:  139,  462,  466.
         623    compare5_C               sort_items_:  147,  689.
         636    compare5_D               sort_items_:  155,  704,  718.
         234    compareB_else            sort_items_:  327,  378,  394,  410,  430,  450,  472.
         414    compareD_then            sort_items_:  505,  564,  576,  597,  601,  622,  626,  649,  655,  678,  684,  708,  715.
        1174    entry_offset             stack_header:        84.
                error_table_             sort_items_:  242.
         106    error_value              sort_items_:   90,  243,  248.
          30    err_msg_desc             sort_items_:  117,  268.
         234    FH_do_i                  sort_items_:  326.
         241    FH_do_while              sort_items_:  337,  381,  397,  413,  433,  453,  475.
         234    FH_do_while_end          sort_items_:  328,  343,  382,  398,  414,  434,  454,  476.
         236    FH_loop_start            sort_items_:  324,  332.
         251    FH_two_sons              sort_items_:  342,  347.
          24    fixed_35_desc            sort_items_:  105,  259.
          61    fixed_bin                sort_items_:   83,  182.
         230    fix_heap                 sort_items_:  298,  301.
          65    float_bin                sort_items_:   83,  187.
         115    general                  sort_items_:   83,  215.
         102    general_pptr_1           sort_items_:   88,  227,  353,  368,  541,  566.
         103    general_pptr_2           sort_items_:   88,  229,  354,  369,  542,  567.
         104    general_value            sort_items_:   88,  225,  256,  362,  377,  550,  575.
          61    init                     sort_items_:  157.
         215    items_err                sort_items_:  280,  284.
          31    label_vec_A              sort_items_:  125,  350.
          37    label_vec_B              sort_items_:  133,  345.
          45    label_vec_C              sort_items_:  141,  531.
          53    label_vec_D              sort_items_:  149,  526,  538.
         206    length_good              sort_items_:  235,  273.
                max_seg_size             sort_items_:  234,  281.
         220    n_elems_ok               sort_items_:  282,  289.
         105    N_in_upper               sort_items_:   89,  296,  341,  501,  512,  522.
                out_of_bounds            sort_items_:  242.
          20    program_name             sort_items_:   99,  250.
          25    program_name_desc        sort_items_:  108,  262.
          27    ptr_desc                 sort_items_:  114,  266.
        1171    push_offset              stack_header:        81.
        1173    return_no_pop_offset     stack_header:        83.
        1172    return_offset            stack_header:        82.
         414    SH_do_i                  sort_items_:  504.
         424    SH_do_while              sort_items_:  518,  537,  558,  591,  616,  643,  672,  702.
         414    SH_do_while_end          sort_items_:  506.
         415    SH_loop_start            sort_items_:  502,  509.
         437    SH_one_son               sort_items_:  524,  533.
         434    SH_two_sons              sort_items_:  523,  528.
         654    sort_end                 sort_items_:  511,  720.
         412    sort_heap                sort_items_:  333,  478.
           0    sort_items_              sort_items_:    6.
          73    stach_header.trace_top_ptr     stack_header:        62.
          32    stack_frame.arg_ptr      stack_frame:   16.
         100    stack_frame.condition_bit      stack_frame:   32.
          20    stack_frame.condition_word     stack_frame:    9.
        2000    stack_frame.crawl_out_bit      stack_frame:   28.
          26    stack_frame.entry_ptr    stack_frame:   13.
          20    stack_frame.flag_word    stack_frame:   24.
         400    stack_frame.link_trap_bit      stack_frame:   30.
          30    stack_frame.lp_ptr       stack_frame:   15.
       20000    stack_frame.main_proc_bit      stack_frame:   25.
          60    stack_frame.min_length   stack_frame:   23.
          22    stack_frame.next_sp      stack_frame:   10.
          36    stack_frame.on_unit_rel_ptrs   stack_frame:   19.
          30    stack_frame.operator_ptr       stack_frame:   14.
          37    stack_frame.operator_ret_ptr   stack_frame:   20.
          20    stack_frame.prev_sp      stack_frame:    8.
          40    stack_frame.regs         sort_items_:  357,  360,  372,  375,  545,  548,  570,  573,
                                         stack_frame:   22.
          24    stack_frame.return_ptr   stack_frame:   12.
       10000    stack_frame.run_unit_manager   stack_frame:   26.
        1000    stack_frame.signaller_bit      stack_frame:   29.
          22    stack_frame.signaller_word     stack_frame:   11.
        4000    stack_frame.signal_bit   stack_frame:   27.
          34    stack_frame.static_ptr   stack_frame:   17.
         200    stack_frame.support_bit  stack_frame:   31.
          35    stack_frame.support_ptr  stack_frame:   18.
          37    stack_frame.translator_id      stack_frame:   21.
          66    stack_header.assign_linkage_ptr      stack_header:        59.
          32    stack_header.bar_mode_sp       stack_header:        42.
          36    stack_header.call_op_ptr       sort_items_:  358,  373,  546,  571,
                                               stack_header:        44.
          10    stack_header.clr_ptr     stack_header:        27.
           6    stack_header.combined_stat_ptr       stack_header:        25.
           4    stack_header.cpm_data_ptr      stack_header:        24.
          13    stack_header.cpm_enabled       stack_header:        32.
          13    stack_header.cur_lot_size      stack_header:        31.
          64    stack_header.ect_ptr     stack_header:        58.
          46    stack_header.entry_op_ptr      stack_header:        49.
          70    stack_header.heap_header_ptr   stack_header:        60.
          74    stack_header.in_trace    stack_header:        63.
          52    stack_header.isot_ptr    stack_header:        52.
          26    stack_header.lot_ptr     stack_header:        39.
          12    stack_header.main_proc_invoked       stack_header:        29.
          12    stack_header.max_lot_size      stack_header:        28.
          20    stack_header.parent_ptr  sort_items_:  254,
                                         stack_header:        36.
          34    stack_header.pl1_operators_ptr       stack_header:        43.
          40    stack_header.push_op_ptr       stack_header:        46.
          42    stack_header.return_op_ptr     stack_header:        47.
          44    stack_header.ret_no_pop_op_ptr       stack_header:        48.
          62    stack_header.rnt_ptr     stack_header:        57.
          12    stack_header.run_unit_depth    stack_header:        30.
          54    stack_header.sct_ptr     stack_header:        53.
          30    stack_header.signal_ptr  stack_header:        41.
          22    stack_header.stack_begin_ptr   stack_header:        37.
          24    stack_header.stack_end_ptr     stack_header:        38.
          14    stack_header.system_free_ptr   stack_header:        33.
          60    stack_header.sys_link_info_ptr       stack_header:        56.
          72    stack_header.trace_frames      stack_header:        61.
          50    stack_header.trans_op_tv_ptr   stack_header:        51.
          56    stack_header.unwinder_ptr      stack_header:        54.
          16    stack_header.user_free_ptr     stack_header:        34.
         100    stack_header_end         stack_header:        64.
         223    store_vars               sort_items_:  291,  294.
         136    string_length_compare    sort_items_:  199,  208,  233.
         140    string_length_err        sort_items_:  197,  206,  237.
          10    string_length_err_msg    sort_items_:   96,  238.
                sub_err_                 sort_items_:  270.
         142    sub_err_call             sort_items_:  241,  287.
          23    sub_err_flag             sort_items_:  102,  252.
          26    sub_err_flag_desc        sort_items_:  111,  264.
                sys_info                 sort_items_:  234,  281.
           0    total_items_err_msg      sort_items_:   93,  285.
           0    trace_frames.count       stack_header:        69.
           1    trace_frames.top_ptr     stack_header:        70.
         551    tv_offset                stack_header:        75,   80,   81,   82,   83,   84.
         111    varying_char             sort_items_:   83,  210.


NO FATAL ERRORS


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
