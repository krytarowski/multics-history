	COMPILATION LISTING OF SEGMENT print_data_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 08/19/86  1422.6 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /* DESCRIPTION:
        8*
        9*   This program is for printing p_stuff, a string produced by a "put data",
       10*   in a special format.  print_data_info, based on print_data_info_ptr, is
       11*   used to control the format, as well as select the output switch.
       12**/
       13 /* HISTORY:
       14*
       15*   Written by Lindsey L. Spratt.
       16*   Modified:
       17*   06/21/79 by Lindsey Spratt; add rtrim(ltrim()) of intervals, check for
       18*   correct print_data_info version, add error code reporting.
       19*   10/29/83 by Benson I. Margulies: for $rs, .hex
       20**/
       21 
       22 
       23 /****^  HISTORY COMMENTS:
       24*  1) change(86-06-18,Kissel), approve(86-07-31,MCR7468), audit(86-07-31,Wong),
       25*     install(86-08-19,MR12.0-1133):
       26*     Changed to better handle the printing of array values.
       27*                                                   END HISTORY COMMENTS */
       28 
       29 
       30 /* format: style2,idind30,indcomtxt */
       31 
       32 print_data_:
       33      proc (p_stuff, print_data_info_ptr, p_code);
       34 
       35 /* Automatic */
       36 
       37 	dcl     idx		        fixed bin;
       38 	dcl     start_scan_idx	        fixed bin (24);
       39 	dcl     scan_length		        fixed bin (24);
       40 	dcl     code		        fixed bin (35);
       41 	dcl     p_code		        fixed bin (35);
       42 	dcl     more_intervals	        bit (1);
       43 	dcl     first_interval	        bit (1);
       44 
       45 	dcl     array_id		        char (256) varying;
       46 	dcl     first_storage_id	        char (256) varying;
       47 	dcl     previous_storage_id	        char (256) varying;
       48 	dcl     storage_id_before_pad	        char (256) varying;
       49 	dcl     first_array_id	        char (256) varying;
       50 	dcl     first_value		        char (1024) varying;
       51 	dcl     array_elem_no	        fixed bin;
       52 	dcl     left_par_idx	        fixed bin;
       53 
       54 	dcl     1 item,
       55 		2 storage_id	        char (256) varying,
       56 		2 value		        char (1024) varying;
       57 	dcl     storage_id_pad	        char (256) varying;
       58 	dcl     interval_spec	        char (256) varying;
       59 	dcl     first_blank		        fixed bin (35);
       60 	dcl     temp_seg_ptrs	        (2) ptr;
       61 	dcl     target_ptr		        ptr;
       62 	dcl     source_ptr		        ptr;
       63 	dcl     current_period	        fixed bin (35);
       64 	dcl     current_quote	        fixed bin (35);
       65 	dcl     following_quote	        fixed bin (35);
       66 	dcl     following_double_quote        fixed bin (35);
       67 	dcl     temp_value		        char (32) varying;
       68 	dcl     more		        bit (1);
       69 	dcl     null		        builtin;
       70 	dcl     found		        bit (1);
       71 	dcl     level		        fixed bin;
       72 	dcl     root_of_level_list	        ptr;
       73 	dcl     p_stuff		        char (*) varying;
       74 	dcl     p_return_string	        char (*) varying;
       75 	dcl     rs_entry		        bit (1) aligned;
       76 
       77 /* Based */
       78 
       79 	dcl     temp_seg		        char (sys_info$max_seg_size * 4) varying based;
       80 
       81 /* External */
       82 
       83 	dcl     sys_info$max_seg_size	        fixed bin (35) ext;
       84 	dcl     error_table_$unimplemented_version
       85 				        fixed bin (35) ext;
       86 
       87 /* Entry */
       88 
       89 	dcl     ioa_$rsnnl		        entry options (variable);
       90 	dcl     get_temp_segments_	        entry (char (*), pointer dimension (*), fixed bin (35));
       91 	dcl     release_temp_segments_        entry (char (*), pointer dimension (*), fixed bin (35));
       92 
       93 	dcl     index		        builtin;
       94 	dcl     substr		        builtin;
       95 
       96 
       97 	rs_entry = "0"b;
       98 	go to COMMON;
       99 
      100 rs:
      101      entry (p_stuff, print_data_info_ptr, p_return_string, p_code);
      102 
      103 	rs_entry = "1"b;
      104 	p_return_string = "";
      105 
      106 COMMON:
      107 	if print_data_info.version ^= print_data_info_version_1
      108 	then do;
      109 		p_code = error_table_$unimplemented_version;
      110 		return;
      111 	     end;
      112 	call get_temp_segments_ ("print_data", temp_seg_ptrs, code);
      113 	source_ptr = temp_seg_ptrs (1);
      114 	target_ptr = temp_seg_ptrs (2);
      115 	source_ptr -> temp_seg = p_stuff;
      116 	target_ptr -> temp_seg = "";
      117 
      118 	array_id = "";
      119 	first_storage_id = "";
      120 	previous_storage_id = "";
      121 	storage_id_before_pad = "";
      122 	first_array_id = "";
      123 	first_value = "";
      124 	array_elem_no = 0;
      125 
      126 
      127 	more_intervals = "1"b;
      128 	interval_spec = rtrim (ltrim (print_data_info.intervals));
      129 	start_scan_idx = 1;
      130 	call setup_interval (start_scan_idx);
      131 	first_interval = "1"b;
      132 	do while (more_intervals | first_interval);
      133 	     first_interval = "0"b;			/* The following loop parses a storage_id and a value out of p_stuff.
      134*						   first_blank identifies the end of the storage_id which begins p_stuff. */
      135 
      136 	     first_blank = index (source_ptr -> temp_seg, "=");
      137 	     root_of_level_list = null;
      138 	     do while (first_blank > 0);
      139 		item.storage_id = substr (source_ptr -> temp_seg, 1, first_blank);
      140 						/* p_stuff is set up to begin with the storage_id. */
      141 		current_period = index (item.storage_id, ".");
      142 						/* The storage id is indented two spaces for each level in the id. */
      143 		storage_id_pad = "";
      144 		do level = 1 by 1 while (current_period > 0);
      145 		     temp_value = substr (item.storage_id, 1, current_period - 1);
      146 		     call check_level (temp_value, level, found);
      147 		     item.storage_id = substr (item.storage_id, current_period + 1);
      148 		     if ^found
      149 		     then do;
      150 			     temp_value = storage_id_pad || temp_value;
      151 
      152 			     if array_elem_no = 0
      153 			     then call output ("^a", temp_value);
      154 			     else do;
      155 				     if array_elem_no = 1
      156 				     then do;
      157 					     call output ("^a^vt^a", first_storage_id,
      158 						print_data_info.value_column, first_value);
      159 					end;
      160 				     else do;
      161 					     first_storage_id =
      162 						substr (first_storage_id, 1, length (first_storage_id) - 1);
      163 					     call output ("^a thru ^a^vt^a", first_storage_id,
      164 						ltrim (previous_storage_id), print_data_info.value_column,
      165 						first_value);
      166 
      167 					end;
      168 				     call output ("^a", temp_value);
      169 				     array_elem_no = 0;
      170 				end;
      171 			end;
      172 
      173 		     storage_id_pad = copy (" ", print_data_info.indentation) || storage_id_pad;
      174 		     current_period = index (item.storage_id, ".");
      175 		end;
      176 		call check_level (item.storage_id, level, found);
      177 		storage_id_before_pad = item.storage_id;
      178 		item.storage_id = storage_id_pad || item.storage_id;
      179 		target_ptr -> temp_seg = ltrim (substr (source_ptr -> temp_seg, first_blank + 1));
      180 		call switch_source_and_target;	/*  The string is processed for quotes, and quote doubling.  */
      181 
      182 		if substr (source_ptr -> temp_seg, 1, 1) = """"
      183 		then do;
      184 			current_quote = 1;
      185 			more = "1"b;
      186 			do while (more);
      187 			     following_quote =
      188 				index (substr (source_ptr -> temp_seg, current_quote + 1), """") + current_quote;
      189 			     following_double_quote =
      190 				index (substr (source_ptr -> temp_seg, current_quote + 1), """""")
      191 				+ current_quote;
      192 			     if following_double_quote = current_quote | following_quote < following_double_quote
      193 			     then more = "0"b;
      194 			     else current_quote = following_quote;
      195 			end;
      196 			item.value = substr (source_ptr -> temp_seg, 1, following_quote);
      197 			source_ptr -> temp_seg = ltrim (substr (source_ptr -> temp_seg, following_quote + 1));
      198 
      199 			if index (source_ptr -> temp_seg, "b") = 1
      200 			then do;			/*  Allow for bit strings. */
      201 				item.value = item.value || "b";
      202 				if print_data_info.flags.octal & (mod (length (item.value) - 3, 3) = 0)
      203 				then do;
      204 					call ioa_$rsnnl ("^oo", item.value, (0),
      205 					     bin (
      206 					     bit (substr (item.value, 2, length (item.value) - 3),
      207 					     length (item.value) - 3)));
      208 				     end;
      209 				else if print_data_info.flags.hex & (mod (length (item.value) - 3, 4) = 0)
      210 				then do;
      211 					call ioa_$rsnnl ("^.4bx", item.value, (0),
      212 					     bit (substr (item.value, 2, length (item.value) - 3),
      213 					     length (item.value) - 3));
      214 				     end;
      215 
      216 				target_ptr -> temp_seg = ltrim (substr (source_ptr -> temp_seg, 2));
      217 				call switch_source_and_target;
      218 			     end;
      219 		     end;
      220 		else do;
      221 			first_blank = index (source_ptr -> temp_seg, " ");
      222 			if first_blank = 0
      223 			then first_blank = length (source_ptr -> temp_seg);
      224 			item.value = substr (source_ptr -> temp_seg, 1, first_blank);
      225 			target_ptr -> temp_seg = ltrim (substr (source_ptr -> temp_seg, first_blank));
      226 			call switch_source_and_target;
      227 		     end;
      228 
      229 		left_par_idx = index (storage_id_before_pad, "(");
      230 		if left_par_idx ^= 0
      231 		then do;
      232 			array_id = substr (storage_id_before_pad, 1, left_par_idx);
      233 			if array_elem_no = 0
      234 			then do;
      235 				first_array_id = array_id;
      236 				first_storage_id = item.storage_id;
      237 				first_value = item.value;
      238 				array_elem_no = 1;
      239 			     end;
      240 			else do;
      241 				if array_id = first_array_id & item.value = first_value
      242 				then do;
      243 					array_elem_no = array_elem_no + 1;
      244 					previous_storage_id = item.storage_id;
      245 				     end;
      246 				else do;
      247 					if array_elem_no = 1
      248 					then do;
      249 						call output ("^a^vt^a", first_storage_id,
      250 						     print_data_info.value_column, first_value);
      251 					     end;
      252 					else do;
      253 						first_storage_id =
      254 						     substr (first_storage_id, 1,
      255 						     length (first_storage_id) - 1);
      256 						call output ("^a thru ^a^vt^a", first_storage_id,
      257 						     ltrim (previous_storage_id),
      258 						     print_data_info.value_column, first_value);
      259 					     end;
      260 					first_array_id = array_id;
      261 					first_storage_id = item.storage_id;
      262 					first_value = item.value;
      263 					array_elem_no = 1;
      264 				     end;
      265 
      266 			     end;
      267 
      268 		     end;
      269 
      270 		else do;
      271 			if array_elem_no = 0
      272 			then call output ("^a^vt^a", item.storage_id, print_data_info.value_column, item.value);
      273 			else do;
      274 				if array_elem_no = 1
      275 				then do;
      276 					call output ("^a^vt^a", first_storage_id, print_data_info.value_column,
      277 					     first_value);
      278 				     end;
      279 				else do;
      280 					first_storage_id =
      281 					     substr (first_storage_id, 1, length (first_storage_id) - 1);
      282 					call output ("^a thru ^a^vt^a", first_storage_id,
      283 					     ltrim (previous_storage_id), print_data_info.value_column,
      284 					     first_value);
      285 
      286 				     end;
      287 				call output ("^a^vt^a", item.storage_id, print_data_info.value_column, item.value)
      288 				     ;
      289 				array_elem_no = 0;
      290 			     end;
      291 		     end;
      292 
      293 		first_blank = index (source_ptr -> temp_seg, "=");
      294 	     end;
      295 	     call setup_interval (start_scan_idx);
      296 	end;
      297 
      298 	if array_elem_no ^= 0
      299 	then do;
      300 
      301 		if array_elem_no = 1
      302 		then call output ("^a^vt^a", first_storage_id, print_data_info.value_column, first_value);
      303 
      304 		else do;
      305 			first_storage_id = substr (first_storage_id, 1, length (first_storage_id) - 1);
      306 			call output ("^a thru ^a^vt^a", first_storage_id, ltrim (previous_storage_id),
      307 			     print_data_info.value_column, first_value);
      308 		     end;
      309 	     end;
      310 
      311 	call release_temp_segments_ ("print_data", temp_seg_ptrs, code);
      312 	return;					/* End of print_data main proc. */
      313 
      314 switch_source_and_target:
      315      proc;
      316 	dcl     temp_ptr		        ptr;
      317 	temp_ptr = target_ptr;
      318 	target_ptr = source_ptr;
      319 	source_ptr = temp_ptr;
      320      end;
      321 
      322 check_level:
      323      proc (p_str, p_level, p_found);
      324 	dcl     p_str		        char (*) varying;
      325 	dcl     p_level		        fixed bin;
      326 	dcl     p_found		        bit (1);
      327 	dcl     idx		        fixed bin;
      328 	dcl     next_level_ptr	        ptr;
      329 	dcl     current_level_ptr	        ptr;
      330 	dcl     1 level_id		        based,
      331 		2 str		        char (32) varying,
      332 		2 next		        ptr;
      333 
      334 	current_level_ptr, next_level_ptr = root_of_level_list;
      335 	do idx = 1 to p_level while (next_level_ptr ^= null);
      336 	     current_level_ptr = next_level_ptr;
      337 	     next_level_ptr = current_level_ptr -> level_id.next;
      338 	end;
      339 	if next_level_ptr ^= null			/* Implies p_level is less than length of level_list. */
      340 	then do;
      341 		if current_level_ptr -> level_id.str = p_str
      342 		then do;
      343 			p_found = "1"b;
      344 			return;
      345 		     end;
      346 		else do;				/* Already printed component at this level is different than current component,
      347*						   so the rest (higher levels) of the level_list is no longer appropriate. */
      348 			current_level_ptr -> level_id.str = p_str;
      349 			current_level_ptr -> level_id.next = null;
      350 			current_level_ptr = next_level_ptr;
      351 			do while (current_level_ptr ^= null);
      352 			     next_level_ptr = current_level_ptr -> level_id.next;
      353 			     free current_level_ptr -> level_id;
      354 			     current_level_ptr = next_level_ptr;
      355 			end;
      356 			p_found = "0"b;
      357 		     end;
      358 	     end;
      359 	else if idx = p_level
      360 	then do;					/* This implies level_list is one shorter than p_level. */
      361 		allocate level_id set (next_level_ptr);
      362 		if current_level_ptr ^= null
      363 		then current_level_ptr -> level_id.next = next_level_ptr;
      364 		else root_of_level_list = next_level_ptr;
      365 		next_level_ptr -> level_id.str = p_str;
      366 		next_level_ptr -> level_id.next = null;
      367 		p_found = "0"b;
      368 	     end;
      369 	else do;					/* idx > p_level */
      370 		current_level_ptr -> level_id.str = p_str;
      371 		p_found = "0"b;
      372 	     end;
      373      end check_level;
      374 
      375 setup_interval:
      376      proc (p_scan_idx);
      377 	dcl     p_scan_idx		        fixed bin (24);
      378 	dcl     start_scan_idx	        fixed bin (24);
      379 	dcl     scan_length		        fixed bin (24);
      380 
      381 	start_scan_idx = p_scan_idx;
      382 	call get_interval (start_scan_idx, scan_length, more_intervals);
      383 	p_scan_idx = scan_length + start_scan_idx;
      384 	source_ptr -> temp_seg = rtrim (ltrim (substr (p_stuff, start_scan_idx, scan_length)));
      385 
      386 /* All occurences of =" are expanded to =<SP>", ("=""" -> "= """).  Since this
      387*   doesn't change number or ordering of quotes, this change does not alter the
      388*   parsing of quoted strings.  It is necessary to insure proper parsing of
      389*   storage id's from their values when their values are strings, bit or
      390*   character.  */
      391 
      392 	start_scan_idx = 1;
      393 	target_ptr -> temp_seg = "";
      394 	scan_length = index (source_ptr -> temp_seg, "=""");
      395 	do while (scan_length > 0);
      396 	     target_ptr -> temp_seg =
      397 		target_ptr -> temp_seg || substr (source_ptr -> temp_seg, start_scan_idx, scan_length);
      398 	     target_ptr -> temp_seg = target_ptr -> temp_seg || " ";
      399 	     start_scan_idx = scan_length + start_scan_idx;
      400 	     scan_length = index (substr (source_ptr -> temp_seg, start_scan_idx), "=""");
      401 	end;
      402 
      403 	target_ptr -> temp_seg = target_ptr -> temp_seg || substr (source_ptr -> temp_seg, start_scan_idx);
      404 	call switch_source_and_target;
      405      end;
      406 
      407 
      408 
      409 get_interval:
      410      proc (p_start_scan_idx, p_scan_length, p_more_intervals);
      411 	dcl     p_start_scan_idx	        fixed bin (24);
      412 	dcl     p_scan_length	        fixed bin (24);
      413 	dcl     p_more_intervals	        bit (1);
      414 	dcl     interval		        char (256) varying;
      415 	dcl     interval_idx	        fixed bin;
      416 	dcl     delimiter_idx	        fixed bin;
      417 	dcl     start_scan_idx	        fixed bin (35);
      418 	dcl     scan_length		        fixed bin (35);
      419 
      420 	if interval_spec = ""
      421 	then do;
      422 		p_more_intervals = "0"b;
      423 		p_scan_length = length (p_stuff) - p_start_scan_idx;
      424 		return;
      425 	     end;
      426 	interval_idx = index (interval_spec, " ") - 1;
      427 	if interval_idx = -1
      428 	then interval_idx = length (interval_spec);
      429 	interval = substr (interval_spec, 1, interval_idx);
      430 	interval_spec = ltrim (substr (interval_spec, interval_idx + 1));
      431 	delimiter_idx = index (interval, "|");
      432 	if delimiter_idx = 0
      433 	then do;
      434 		p_start_scan_idx = index (substr (p_stuff, p_start_scan_idx), interval);
      435 		p_start_scan_idx = p_start_scan_idx - index (reverse (substr (p_stuff, 1, p_start_scan_idx)), " ");
      436 		source_ptr -> temp_seg = substr (p_stuff, p_start_scan_idx);
      437 		p_scan_length = length (p_stuff);
      438 		interval_spec = "";
      439 		p_more_intervals = "0"b;
      440 		return;
      441 	     end;
      442 	else if delimiter_idx = 1
      443 	then do;
      444 		p_scan_length = index (substr (p_stuff, p_start_scan_idx), substr (interval, 2));
      445 		p_scan_length =
      446 		     p_scan_length - index (reverse (substr (p_stuff, p_start_scan_idx, p_scan_length)), " ");
      447 		source_ptr -> temp_seg = ltrim (rtrim (substr (p_stuff, p_start_scan_idx, p_scan_length)));
      448 		p_scan_length = p_start_scan_idx + p_scan_length - 1;
      449 		if interval_spec = ""
      450 		then p_more_intervals = "0"b;
      451 		else p_more_intervals = "1"b;
      452 		return;
      453 	     end;
      454 	else if delimiter_idx = length (interval)
      455 	then do;
      456 		p_start_scan_idx = index (substr (p_stuff, p_start_scan_idx), interval);
      457 		p_start_scan_idx = p_start_scan_idx - index (reverse (substr (p_stuff, 1, p_start_scan_idx)), " ");
      458 		source_ptr -> temp_seg = substr (p_stuff, p_start_scan_idx);
      459 		p_scan_length = length (p_stuff);
      460 		interval_spec = "";
      461 		p_more_intervals = "0"b;
      462 		return;
      463 	     end;
      464 	else do;					/* Both a beginning and an end are given for the interval. */
      465 		start_scan_idx = index (substr (p_stuff, p_start_scan_idx), substr (interval, 1, delimiter_idx - 1));
      466 		start_scan_idx =
      467 		     start_scan_idx - index (reverse (substr (p_stuff, p_start_scan_idx, start_scan_idx)), " ");
      468 		p_start_scan_idx = start_scan_idx;
      469 		scan_length = index (substr (p_stuff, p_start_scan_idx), substr (interval, delimiter_idx + 1));
      470 		scan_length = scan_length - index (reverse (substr (p_stuff, p_start_scan_idx, scan_length)), " ");
      471 		p_scan_length = scan_length;
      472 		if interval_spec = ""
      473 		then p_more_intervals = "0"b;
      474 		else p_more_intervals = "1"b;
      475 		return;
      476 	     end;
      477      end;
      478 
      479 	declare an_output		        char (1024);
      480 
      481 output:
      482      procedure options (variable);
      483 
      484 	declare cu_$generate_call	        entry (entry, ptr);
      485 	declare cu_$arg_list_ptr	        entry returns (ptr);
      486 	declare ioa_$general_rs	        entry (ptr, fixed bin, fixed bin, char (*), fixed bin (21),
      487 				        bit (1) aligned, bit (1) aligned);
      488 	declare ioa_		        entry () options (variable);
      489 	declare iox_$put_chars	        entry (ptr, ptr, fixed bin (21), fixed bin (35));
      490 	declare used_length		        fixed bin (21);
      491 	if rs_entry | (print_data_info.output_switch ^= null ())
      492 	then do;
      493 		call ioa_$general_rs (cu_$arg_list_ptr (), 1, 2, an_output, used_length, "0"b, "1"b);
      494 		if rs_entry
      495 		then p_return_string = p_return_string || substr (an_output, 1, used_length);
      496 		else call iox_$put_chars (print_data_info.output_switch, addr (an_output), used_length, (0));
      497 	     end;
      498 	else call cu_$generate_call (ioa_, cu_$arg_list_ptr ());
      499 	return;
      500      end output;
      501 
  1     1 /* BEGIN INCLUDE FILE -- print_data_info.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*          This structure is used by print_data to set various parameters
  1     5*     controlling the format of the output it produces.
  1     6*
  1     7*/* HISTORY:
  1     8*
  1     9*Written by Lindsey L. Spratt, 06/05/79.
  1    10*Modified:
  1    11*02/08/85 by Lindsey L. Spratt:  Fixed the HISTORY and DESCRIPTION sections.
  1    12**/
  1    13 
  1    14 /* format: style3,idind30,indcomtxt */
  1    15 dcl	print_data_info_version_1	fixed bin options (constant) init (1) internal static;
  1    16 
  1    17 dcl	print_data_info_ptr		ptr;
  1    18 dcl	1 print_data_info		based (print_data_info_ptr),
  1    19 	  2 version		fixed bin,
  1    20 	  2 indentation		fixed bin,	/* This sets the number of spaces by which structure level names are indented. */
  1    21 	  2 value_column		fixed bin,	/* This is the column in which the printing of values begins. */
  1    22 	  2 output_switch		ptr,		/* If null, user_output is used. */
  1    23 	  2 flags,
  1    24 	    3 octal		bit (1) unal,	/* Convert bit strings to octal. */
  1    25 	    3 hex			bit (1) unal,	/* hex, ditto */
  1    26 	    3 pad			bit (34) unaligned,
  1    27 	  2 intervals		char (256) varying;
  1    28 
  1    29 /* End include file print_data_info.incl.pl1 */
      502 
      503      end print_data_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/19/86  1422.6  print_data_.pl1                   >spec>install>1133>print_data_.pl1
502          1    03/06/85  1031.4  print_data_info.incl.pl1          >ldd>include>print_data_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
an_output                       002155 automatic       char(1024)               unaligned dcl 479 set ref 493* 494 496 496
array_elem_no                   001212 automatic       fixed bin(17,0)          dcl 51 set ref 124* 152 155 169* 233 238* 243* 243
                                                                                  247 263* 271 274 289* 298 301
array_id                        000104 automatic       varying char(256)        dcl 45 set ref 118* 232* 235 241 260
code                            000101 automatic       fixed bin(35,0)          dcl 40 set ref 112* 311*
cu_$arg_list_ptr                000024 constant        entry                    external dcl 485 ref 493 493 498 498
cu_$generate_call               000022 constant        entry                    external dcl 484 ref 498
current_level_ptr               002602 automatic       pointer                  dcl 329 set ref 334* 336* 337 341 348 349 350* 351
                                                                                  352 353 354* 362 362 370
current_period                  002132 automatic       fixed bin(35,0)          dcl 63 set ref 141* 144 145 147 174*
current_quote                   002133 automatic       fixed bin(35,0)          dcl 64 set ref 184* 187 187 189 189 192 194*
delimiter_idx                   002726 automatic       fixed bin(17,0)          dcl 416 set ref 431* 432 442 454 465 469
error_table_$unimplemented_version
                                000012 external static fixed bin(35,0)          dcl 84 ref 109
first_array_id                  000510 automatic       varying char(256)        dcl 49 set ref 122* 235* 241 260*
first_blank                     002120 automatic       fixed bin(35,0)          dcl 59 set ref 136* 138 139 179 221* 222 222* 224
                                                                                  225 293*
first_interval                  000103 automatic       bit(1)                   unaligned dcl 43 set ref 131* 132 133*
first_storage_id                000205 automatic       varying char(256)        dcl 46 set ref 119* 157* 161* 161 161 163* 236* 249*
                                                                                  253* 253 253 256* 261* 276* 280* 280 280 282* 301*
                                                                                  305* 305 305 306*
first_value                     000611 automatic       varying char(1024)       dcl 50 set ref 123* 157* 163* 237* 241 249* 256*
                                                                                  262* 276* 282* 301* 306*
flags                     6            based           structure                level 2 packed unaligned dcl 1-18
following_double_quote          002135 automatic       fixed bin(35,0)          dcl 66 set ref 189* 192 192
following_quote                 002134 automatic       fixed bin(35,0)          dcl 65 set ref 187* 192 194 196 197
found                           002150 automatic       bit(1)                   unaligned dcl 70 set ref 146* 148 176*
get_temp_segments_              000016 constant        entry                    external dcl 90 ref 112
hex                       6(01)        based           bit(1)                   level 3 packed unaligned dcl 1-18 ref 209
idx                             002576 automatic       fixed bin(17,0)          dcl 327 set ref 335* 359
indentation               1            based           fixed bin(17,0)          level 2 dcl 1-18 ref 173
index                                                  builtin function         dcl 93 ref 136 141 174 187 189 199 221 229 293 394
                                                                                  400 426 431 434 435 444 445 456 457 465 466 469
                                                                                  470
interval                        002624 automatic       varying char(256)        dcl 414 set ref 429* 431 434 444 454 456 465 469
interval_idx                    002725 automatic       fixed bin(17,0)          dcl 415 set ref 426* 427 427* 429 430
interval_spec                   002017 automatic       varying char(256)        dcl 58 set ref 128* 420 426 427 429 430* 430 438*
                                                                                  449 460* 472
intervals                 7            based           varying char(256)        level 2 dcl 1-18 ref 128
ioa_                            000030 constant        entry                    external dcl 488 ref 498 498
ioa_$general_rs                 000026 constant        entry                    external dcl 486 ref 493
ioa_$rsnnl                      000014 constant        entry                    external dcl 89 ref 204 211
iox_$put_chars                  000032 constant        entry                    external dcl 489 ref 496
item                            001214 automatic       structure                level 1 unaligned dcl 54
left_par_idx                    001213 automatic       fixed bin(17,0)          dcl 52 set ref 229* 230 232
level                           002151 automatic       fixed bin(17,0)          dcl 71 set ref 144* 146* 176*
level_id                               based           structure                level 1 unaligned dcl 330 set ref 353 361
more                            002147 automatic       bit(1)                   unaligned dcl 68 set ref 185* 186 192*
more_intervals                  000102 automatic       bit(1)                   unaligned dcl 42 set ref 127* 132 382*
next                     12            based           pointer                  level 2 dcl 330 set ref 337 349* 352 362* 366*
next_level_ptr                  002600 automatic       pointer                  dcl 328 set ref 334* 335 336 337* 339 350 352* 354
                                                                                  361* 362 364 365 366
null                                                   builtin function         dcl 69 ref 137 335 339 349 351 362 366 491
octal                     6            based           bit(1)                   level 3 packed unaligned dcl 1-18 ref 202
output_switch             4            based           pointer                  level 2 dcl 1-18 set ref 491 496*
p_code                                 parameter       fixed bin(35,0)          dcl 41 set ref 32 100 109*
p_found                                parameter       bit(1)                   unaligned dcl 326 set ref 322 343* 356* 367* 371*
p_level                                parameter       fixed bin(17,0)          dcl 325 ref 322 335 359
p_more_intervals                       parameter       bit(1)                   unaligned dcl 413 set ref 409 422* 439* 449* 451*
                                                                                  461* 472* 474*
p_return_string                        parameter       varying char             dcl 74 set ref 100 104* 494* 494
p_scan_idx                             parameter       fixed bin(24,0)          dcl 377 set ref 375 381 383*
p_scan_length                          parameter       fixed bin(24,0)          dcl 412 set ref 409 423* 437* 444* 445* 445 445 447
                                                                                  448* 448 459* 471*
p_start_scan_idx                       parameter       fixed bin(24,0)          dcl 411 set ref 409 423 434* 434 435* 435 435 436
                                                                                  444 445 447 448 456* 456 457* 457 457 458 465 466
                                                                                  468* 469 470
p_str                                  parameter       varying char             dcl 324 ref 322 341 348 365 370
p_stuff                                parameter       varying char             dcl 73 ref 32 100 115 384 423 434 435 436 437 444
                                                                                  445 447 456 457 458 459 465 466 469 470
previous_storage_id             000306 automatic       varying char(256)        dcl 47 set ref 120* 163 163 244* 256 256 282 282 306
                                                                                  306
print_data_info                        based           structure                level 1 unaligned dcl 1-18
print_data_info_ptr                    parameter       pointer                  dcl 1-17 ref 32 100 106 128 157 163 173 202 209 249
                                                                                  256 271 276 282 287 301 306 491 496
print_data_info_version_1              constant        fixed bin(17,0)          initial dcl 1-15 ref 106
release_temp_segments_          000020 constant        entry                    external dcl 91 ref 311
root_of_level_list              002152 automatic       pointer                  dcl 72 set ref 137* 334 364*
rs_entry                        002154 automatic       bit(1)                   dcl 75 set ref 97* 103* 491 494
scan_length                     002730 automatic       fixed bin(35,0)          dcl 418 in procedure "get_interval" set ref 469*
                                                                                  470* 470 470 471
scan_length                     002615 automatic       fixed bin(24,0)          dcl 379 in procedure "setup_interval" set ref 382*
                                                                                  383 384 394* 395 396 399 400*
source_ptr                      002130 automatic       pointer                  dcl 62 set ref 113* 115 136 139 179 182 187 189 196
                                                                                  197 197 199 216 221 222 224 225 293 318 319* 384
                                                                                  394 396 400 403 436 447 458
start_scan_idx                  002727 automatic       fixed bin(35,0)          dcl 417 in procedure "get_interval" set ref 465*
                                                                                  466* 466 466 468
start_scan_idx                  000100 automatic       fixed bin(24,0)          dcl 38 in procedure "print_data_" set ref 129* 130*
                                                                                  295*
start_scan_idx                  002614 automatic       fixed bin(24,0)          dcl 378 in procedure "setup_interval" set ref 381*
                                                                                  382* 383 384 392* 396 399* 399 400 403
storage_id                      001214 automatic       varying char(256)        level 2 dcl 54 set ref 139* 141 145 147* 147 174
                                                                                  176* 177 178* 178 236 244 261 271* 287*
storage_id_before_pad           000407 automatic       varying char(256)        dcl 48 set ref 121* 177* 229 232
storage_id_pad                  001716 automatic       varying char(256)        dcl 57 set ref 143* 150 173* 173 178
str                                    based           varying char(32)         level 2 dcl 330 set ref 341 348* 365* 370*
substr                                                 builtin function         dcl 94 ref 139 145 147 161 179 182 187 189 196 197
                                                                                  204 204 211 211 216 224 225 232 253 280 305 384
                                                                                  396 400 403 429 430 434 435 436 444 444 445 447
                                                                                  456 457 458 465 465 466 469 469 470 494
sys_info$max_seg_size           000010 external static fixed bin(35,0)          dcl 83 ref 115 116 179 197 216 225 384 393 396 398
                                                                                  403 436 447 458
target_ptr                      002126 automatic       pointer                  dcl 61 set ref 114* 116 179 216 225 317 318* 393 396
                                                                                  396 398 398 403 403
temp_ptr                        002566 automatic       pointer                  dcl 316 set ref 317* 319
temp_seg                               based           varying char             dcl 79 set ref 115* 116* 136 139 179* 179 182 187
                                                                                  189 196 197* 197 199 216* 216 221 222 224 225* 225
                                                                                  293 384* 393* 394 396* 396 396 398* 398 400 403*
                                                                                  403 403 436* 447* 458*
temp_seg_ptrs                   002122 automatic       pointer                  array dcl 60 set ref 112* 113 114 311*
temp_value                      002136 automatic       varying char(32)         dcl 67 set ref 145* 146* 150* 150 152* 168*
used_length                     000100 automatic       fixed bin(21,0)          dcl 490 set ref 493* 494 496*
value                   101     001214 automatic       varying char(1024)       level 2 dcl 54 set ref 196* 201* 201 202 204* 204
                                                                                  204 204 204 204 204 209 211* 211 211 211 211 211
                                                                                  211 224* 237 241 262 271* 287*
value_column              2            based           fixed bin(17,0)          level 2 dcl 1-18 set ref 157* 163* 249* 256* 271*
                                                                                  276* 282* 287* 301* 306*
version                                based           fixed bin(17,0)          level 2 dcl 1-18 ref 106

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
idx                                    automatic       fixed bin(17,0)          dcl 37
scan_length                            automatic       fixed bin(24,0)          dcl 39

NAMES DECLARED BY EXPLICIT CONTEXT.
COMMON                          000132 constant        label                    dcl 106 ref 98
check_level                     002321 constant        entry                    internal dcl 322 ref 146 176
get_interval                    002733 constant        entry                    internal dcl 409 ref 382
output                          003511 constant        entry                    internal dcl 481 ref 152 157 163 168 249 256 271 276
                                                                                  282 287 301 306
print_data_                     000055 constant        entry                    external dcl 32
rs                              000102 constant        entry                    external dcl 100
setup_interval                  002520 constant        entry                    internal dcl 375 ref 130 295
switch_source_and_target        002311 constant        entry                    internal dcl 314 ref 180 217 226 404

NAMES DECLARED BY CONTEXT OR IMPLICATION.
addr                                                   builtin function         ref 496 496
bin                                                    builtin function         ref 204 204
bit                                                    builtin function         ref 204 204 211 211
copy                                                   builtin function         ref 173
length                                                 builtin function         ref 161 202 204 204 204 204 209 211 211 211 211 222
                                                                                  253 280 305 423 427 437 454 459
ltrim                                                  builtin function         ref 128 163 163 179 197 216 225 256 256 282 282 306
                                                                                  306 384 430 447
mod                                                    builtin function         ref 202 209
reverse                                                builtin function         ref 435 445 457 466 470
rtrim                                                  builtin function         ref 128 384 447

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4132        4166    3755        4142
Length      4376    3755        34         173     154           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
print_data_                        1742 external procedure  is an external procedure.  
switch_source_and_target                internal procedure  shares stack frame of external procedure print_data_.  
check_level                             internal procedure  shares stack frame of external procedure print_data_.  
setup_interval                          internal procedure  shares stack frame of external procedure print_data_.  
get_interval                            internal procedure  shares stack frame of external procedure print_data_.  
output                              106 internal procedure  is called during a stack extension, and is declared options(variable).  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
output                   000100 used_length                 output
print_data_              000100 start_scan_idx              print_data_
                         000101 code                        print_data_
                         000102 more_intervals              print_data_
                         000103 first_interval              print_data_
                         000104 array_id                    print_data_
                         000205 first_storage_id            print_data_
                         000306 previous_storage_id         print_data_
                         000407 storage_id_before_pad       print_data_
                         000510 first_array_id              print_data_
                         000611 first_value                 print_data_
                         001212 array_elem_no               print_data_
                         001213 left_par_idx                print_data_
                         001214 item                        print_data_
                         001716 storage_id_pad              print_data_
                         002017 interval_spec               print_data_
                         002120 first_blank                 print_data_
                         002122 temp_seg_ptrs               print_data_
                         002126 target_ptr                  print_data_
                         002130 source_ptr                  print_data_
                         002132 current_period              print_data_
                         002133 current_quote               print_data_
                         002134 following_quote             print_data_
                         002135 following_double_quote      print_data_
                         002136 temp_value                  print_data_
                         002147 more                        print_data_
                         002150 found                       print_data_
                         002151 level                       print_data_
                         002152 root_of_level_list          print_data_
                         002154 rs_entry                    print_data_
                         002155 an_output                   print_data_
                         002566 temp_ptr                    switch_source_and_target
                         002576 idx                         check_level
                         002600 next_level_ptr              check_level
                         002602 current_level_ptr           check_level
                         002614 start_scan_idx              setup_interval
                         002615 scan_length                 setup_interval
                         002624 interval                    get_interval
                         002725 interval_idx                get_interval
                         002726 delimiter_idx               get_interval
                         002727 start_scan_idx              get_interval
                         002730 scan_length                 get_interval

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     alloc_bit_temp      cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc
return_mac          longbs_to_fx2       mdfx1               shorten_stack       ext_entry_desc      int_entry
set_chars_eis       set_bits_eis        index_chars_eis     any_to_any_truncate_alloc_storage       op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$arg_list_ptr              cu_$generate_call             get_temp_segments_            ioa_
ioa_$general_rs               ioa_$rsnnl                    iox_$put_chars                release_temp_segments_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$unimplemented_version                          sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     32 000051        97 000073        98 000074       100 000075       103 000125       104 000127       106 000132
    109 000137       110 000142       112 000143       113 000170       114 000172       115 000174       116 000212
    118 000213       119 000214       120 000215       121 000216       122 000217       123 000220       124 000221
    127 000222       128 000224       129 000262       130 000264       131 000266       132 000270       133 000275
    136 000276       137 000311       138 000313       139 000316       141 000326       143 000340       144 000341
    145 000346       146 000356       147 000361       148 000373       150 000376       152 000421       155 000443
    157 000445       159 000476       161 000477       163 000505       167 000570       168 000571       169 000607
    173 000610       174 000640       175 000653       176 000655       177 000660       178 000665       179 000710
    180 000752       182 000753       184 000760       185 000762       186 000764       187 000766       189 001007
    192 001025       194 001033       195 001035       196 001036       197 001047       199 001106       201 001121
    202 001130       204 001144       208 001221       209 001223       211 001232       214 001305       216 001306
    217 001340       219 001341       221 001342       222 001354       224 001357       225 001366       226 001436
    229 001437       230 001451       232 001452       233 001461       235 001463       236 001470       237 001475
    238 001502       239 001504       241 001505       243 001521       244 001522       245 001527       247 001530
    249 001532       251 001563       253 001564       256 001572       259 001655       260 001656       261 001663
    262 001670       263 001675       268 001677       271 001700       274 001734       276 001736       278 001767
    280 001770       282 001776       286 002061       287 002062       289 002113       293 002114       294 002127
    295 002130       296 002132       298 002133       301 002135       305 002171       306 002177       308 002262
    311 002263       312 002310       314 002311       317 002312       318 002314       319 002316       320 002320
    322 002321       334 002332       335 002335       336 002351       337 002353       338 002356       339 002360
    341 002364       343 002375       344 002401       348 002402       349 002412       350 002414       351 002416
    352 002422       353 002425       354 002427       355 002431       356 002432       358 002437       359 002440
    361 002444       362 002450       364 002457       365 002460       366 002472       367 002474       368 002500
    370 002501       371 002513       373 002517       375 002520       381 002522       382 002524       383 002526
    384 002532       392 002602       393 002604       394 002605       395 002617       396 002622       398 002646
    399 002655       400 002657       401 002676       403 002677       404 002731       405 002732       409 002733
    420 002735       422 002742       423 002746       424 002753       426 002754       427 002765       429 002771
    430 003000       431 003032       432 003044       434 003045       435 003066       436 003101       437 003123
    438 003125       439 003126       440 003132       442 003133       444 003135       445 003163       447 003177
    448 003246       449 003252       451 003264       452 003270       454 003271       456 003273       457 003314
    458 003327       459 003351       460 003353       461 003354       462 003360       465 003361       466 003403
    468 003424       469 003425       470 003450       471 003470       472 003471       474 003503       475 003507
    481 003510       491 003516       493 003530       494 003606       496 003626       497 003651       498 003652
    499 003675


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
