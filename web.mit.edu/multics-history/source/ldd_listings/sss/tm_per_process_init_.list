	COMPILATION LISTING OF SEGMENT tm_per_process_init_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 05/17/85  1457.1 mst Fri
	    Options: optimize map

        1 
        2 /* ***********************************************************
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        5*   *                                                         *
        6*   *********************************************************** */
        7 
        8 /* DESCRIPTION:
        9*
       10*	tm_per_process_init_ is the first-reference trap for all Data
       11*     Management (DM) inner ring transfer vectors (*_firstref_tv_.alm),
       12*     except for those which MAY NOT do DM per-process init
       13*     (*_no_firstref_tv_.alm).  There are four parts of this routine:
       14*
       15*     1.  Does initialization common to all inner ring DM (replacing
       16*     dm_common_init_).  It initializes dm_data_ cells used by all managers,
       17*     initiates dm_system_data_ in the per-bootload directory.  For testing,
       18*     when get_ring_ () ^= sys_info$data_management_ringno, a fake
       19*     dm_journal_seg_ is initiated.  The real dm_journal_seg_ is not avaliable
       20*     outside of ring 0.  Also, fake versions of dm_hcs_ and dm_hphcs_
       21*     are made known, instead of the real hardcore gates.  IF THIS AND
       22*     STEP 2 HAVE COMPLETED, WE RETURN WITHOUT EXECUTING THE REMAINING 
       23*     STEPS (an internal static variable is used to do this); this is
       24*     because all the DM *_firstref_tv_'s use this program as their
       25*     first-reference trap, but are eventually invoked by this program
       26*     in step 3; steps one and two should not be redone for each time
       27*     the first-reference goes off.
       28*
       29*     2.  This step does transaction_manager_ initialization.  It calculates
       30*     dm_data_$tm_tdt_ptr from dm_system_data_$tm_tdt_relp, notifies the
       31*     Daemon about TDT entries for dead processes, reserves a TDT entry for
       32*     the process and puts its index in dm_data_$my_tdt_index.  We also set
       33*     the internal static variable to indicate this and the previous step
       34*     have been done; this is necessary since we will set off the first
       35*     reference traps of the other DM managers' inner rig TV's with fref
       36*     traps.
       37*
       38*     3.  Calls the other inner ring managers' initialization routines.
       39*
       40*     4.  Notifies the DM caretaker Daemon if the process running this
       41*     first-reference trap needs to be sent the dm_shutdown_scheduled_ IPS.
       42*     If no DM shutdown is scheduled, we skip this step.
       43*
       44*	There are two methods of error reporting from this module.
       45*     Because it is the target of all DM first-reference traps, we can only
       46*     use signals to report errors.  We use sub_err_ calls to report errors
       47*     which should not happen (or which the Daemon should have picked up on
       48*     in per-system initialization, at least).  An example is an invalid
       49*     Transaction Definition Table (TDT) version.  This is all handled in
       50*     the internal procedure ERROR_RETURN.  We also use sub_err_ to warn
       51*     a person testing DMS in the user ring, with default restart.
       52*
       53*	The second error case is when no DMS exists for the process to
       54*     use; and is reported via the dm_not_available_ condition.  This may
       55*     happen when there is no DMS bootload, the DMS has been shutdown, or
       56*     there is no room in the TDT to record the required data about the
       57*     process starting its use of DM.  The process recorded as the
       58*     initializer process in dm_system_data_ is given more flexibility since
       59*     it may be bringing up or shutting down the system; normal users will
       60*     always take an error when the DMS state in dm_system_data_ does not
       61*     indicate running.  All DM commands should handle the dm_not_available_
       62*     condition, call transaction_manager_$user_shutdown, and report the
       63*     error to the user.  This program handles dm_not_available_ by
       64*     terminating any reference names it has initiated and deleting the event
       65*     channel it has created.
       66*
       67*	NOTES	NOTES	NOTES	NOTES
       68*	If this procedure is executed in a ring greater than the DM ring,
       69*     we simply return as we can only do init in the DM ring.  We use the
       70*     read bracket of dm_gate_ as the indicator of the DM ring in case the
       71*     user is running a test DMS.
       72*	In the clean up of this procedure, we try to terminate various
       73*     things we may have initiated (e.g., dm_hcs_fake_ with refname of
       74*     dm_hcs_, dm_system_data_).  We must take care to do any terminations
       75*     as dm_misc_util_$terminate_dm does; we MAY NOT call the dm_misc_util_
       76*     entry as it would terminate the firstref modules, causing the linker
       77*     to fail when it tries to do the same thing when we unwind.
       78**/
       79 
       80 /* HISTORY:
       81*
       82*Written by Steve Herbst, 08/16/82.
       83*Modified:
       84*09/09/82 by Steve Herbst: Added code to find dead processes and reserve
       85*	  a TDT entry for the process.
       86*11/01/82 by Steve Herbst: Changed to call dm_send_request_$adjust_tdt when
       87*	  it finds a dead process.
       88*11/01/82 by Steve Herbst: Also changed to set up an event channel
       89*	  and put its id in the TDT entry.
       90*11/22/82 by Steve Herbst: Made to zero dm_data_$suspended_txn_(id index).
       91*11/22/82 by Steve Herbst: Fixed to call dm_send_request_$adjust_txn only
       92*	  if txn_id (i) ^= "0"b.
       93*12/07/82 by Steve Herbst: Changed to call tm_adjust_tdt rather than duplicate
       94*	  its code to check dead processes.
       95*01/12/83 by Steve Herbst: Made to store process' Person.Project in the TDT entry.
       96*03/03/83 by Steve Herbst: Changed for new initialization scheme.
       97*03/07/83 by Steve Herbst: Changed to set validation level to current ring.
       98*09/07/83 by Lee A. Newcomb: Added trailing "_" to main procedure name.
       99*10/17/84 by Steve Herbst: Changed in response to audit comments.
      100*11/20/84 by Lee A. Newcomb:  Merged dm_common_init_ into this module so this
      101*            will be the target of all DM transfer vectors with fref traps.
      102*            Fixed up error handling in general and added signalling of the
      103*            dm_not_available_ condition if no DMS is to be found.  Changed to
      104*            not fail if the new_process_notifications request to the Daemon
      105*            fails.  Also changed to only set validation level where needed.
      106*01/24/84 by R. Michael Tague: Changed the name of dm_send_request_$ entry
      107*            new_process_notifications to new_process_notifies.
      108*01/28/85 by Steve Herbst: Changed to signal dm_not_available_ with the
      109*	  standard structure specifying "DM is not running" and no-restart.
      110*02/04/85 by Steve Herbst: Added dm_not_available_ handler to terminate
      111*	  initiated reference names and delete created event channel.
      112*02/15/85 by Steve Herbst: Addressed audit comment by initializing
      113*	  callers_validation_level to -1 and resetting only if not -1.
      114*03/03/85 by Lee A. Newcomb:  Removed handler of dm_not_available_ condition so
      115*            it would get back to users; changed to do terminations as in
      116*            dm_misc_util_$terminate_dm and to only do term_$single_refname for
      117*            dm_hcs_ and dm_hphcs_ in case user had init'd the fake versions.
      118*03/05/85 by Lee A. Newcomb:  Created CLEAN_UP proc from first half of proc to
      119*            signal dm_not_available_ so the operations therein may be used in
      120*            all cleanup cases.  Fixed to just return if ring of execution is
      121*            greater than DM ring and use cu_$arg_ptr_rel in ERROR_RETURN
      122*            instead of using the arg_list directly.
      123*03/05/85 by Steve Herbst: Replaced dm_log_ with dm_misc_util_$log.
      124*05/15/85 by R. Michael Tague: Changed to not try to initiate dm_journal_seg_
      125*            when not testing.
      126**/
      127 
      128 /* format: style2,ll79,ind3,^indprocbody,ifthendo,ifthen,^indnoniterdo */
      129 /* format: ^inddcls,dclind5,idind35,linecom */
      130 
      131 tm_per_process_init_:
      132    proc;
      133 
      134 /* DECLARATIONS */
      135 
      136 /* Parameters */
      137 /* Automatic */
      138 dcl  (
      139      1 auto_condition_info		aligned like condition_info_header,
      140      bootload_dir_path		char (168) init (""),
      141      callers_validation_level		fixed bin init (-1),
      142      channel_id			fixed bin (71) init (0),
      143      code				fixed bin (35) init (0),
      144      current_ring			fixed bin init (-1),
      145      dir_path			char (168) init (""),
      146      dm_gate_dir			char (168) init (""),
      147      dm_gate_dir_length		fixed bin init (0),
      148      dm_gate_ptr			ptr init (null),
      149      dm_hcs_fake_ptr		ptr init (null),
      150      dm_hphcs_fake_ptr		ptr init (null),
      151      dm_system_data_ptr		ptr init (null),
      152      entry_name			char (32) init (""),
      153      ldn				fixed bin init (0),
      154      process_group_id		char (32) init (""),
      155      ring_brackets			dim (3) fixed bin (3)
      156 				init (-1, -1, -1),
      157      txn_index			fixed bin init (-1),
      158      using_test_data_management_system	bit (1) aligned init (""b)
      159      )				automatic;
      160 
      161 /* Based */
      162 /* Builtins */
      163 dcl  (addr, codeptr, index, null, pointer, size, stac, substr, unspec)
      164 				builtin;
      165 
      166 /* Condition */
      167 dcl  cleanup			condition;
      168 
      169 /* Constants */
      170 dcl  (
      171      DM_GATE_NAME			char (32) init ("dm_gate_"),
      172      DM_HCS_FAKE_NAME		char (32) init ("dm_hcs_fake_"),
      173      DM_HCS_REFNAME			char (32) init ("dm_hcs_"),
      174      DM_HPHCS_FAKE_NAME		char (32) init ("dm_hphcs_fake_"),
      175      DM_HPHCS_REFNAME		char (32) init ("dm_hphcs_"),
      176      DM_JOURNAL_SEG_NAME		char (32) init ("dm_journal_seg_"),
      177      DM_NOT_AVAILABLE_INFO_VERSION_1	fixed bin init (1),
      178      DM_PER_PROCESS_INIT_STARTED	char (8) aligned init ("STARTED"),
      179      DM_PER_PROCESS_INIT_THROUGH_TM_COMPLETE
      180 				char (8) aligned init ("COMPLETE"),
      181      DM_SYSTEM_DATA_REFNAME		char (32) init ("dm_system_data_"),
      182      DM_SYSTEM_DATA_ENTRYNAME		char (32) init ("dm_system_data_"),
      183      IOA_GENERAL_RS_NO_NEW_LINE	bit (1) aligned init ("0"b),
      184      IOA_GENERAL_RS_DONT_PAD		bit (1) aligned init ("1"b),
      185      MYNAME			char (32) init ("tm_per_process_init_")
      186      )				internal static options (constant);
      187 
      188 /* Entry */
      189 dcl  (
      190      before_journal_manager_$per_process_init
      191 				entry (),
      192      cu_$arg_list_ptr		entry (ptr),
      193      cu_$arg_ptr_rel		entry (fixed bin, ptr, fixed bin (21),
      194 				fixed bin (35), ptr),
      195      cu_$level_get			entry (fixed bin),
      196      cu_$level_set			entry (fixed bin),
      197      dm_misc_util_$log		entry options (variable),
      198      dm_misc_util_$get_begin_shutdown_time
      199 				entry returns (fixed bin (71)),
      200      dm_misc_util_$get_bootload_dir	entry (char (*)),
      201      dm_per_system_$initiate		entry (char (*), char (*), ptr),
      202      dm_send_request_$new_process_notifies
      203 				entry (fixed bin (35)),
      204      file_manager_$per_process_init	entry (),
      205      get_group_id_$tag_star		entry () returns (char (32)),
      206      get_process_id_		entry () returns (bit (36)),
      207      get_ring_			entry returns (fixed bin (3)),
      208      get_system_free_area_		entry () returns (ptr),
      209      hcs_$fs_get_path_name		entry (ptr, char (*), fixed bin,
      210 				char (*), fixed bin (35)),
      211      hcs_$get_ring_brackets		entry (char (*), char (*),
      212 				(3) fixed bin (3), fixed bin (35)),
      213      hcs_$initiate			entry (char (*), char (*), char (*),
      214 				fixed bin (1), fixed bin (2), ptr,
      215 				fixed bin (35)),
      216      hcs_$make_ptr			entry (ptr, char (*), char (*), ptr,
      217 				fixed bin (35)),
      218      hcs_$terminate_noname		entry (ptr, fixed bin (35)),
      219      ioa_$general_rs		entry (ptr, fixed bin, fixed bin,
      220 				char (*), fixed bin (21),
      221 				bit (1) aligned, bit (1) aligned),
      222      ipc_$create_ev_chn		entry (fixed bin (71), fixed bin (35)),
      223      ipc_$delete_ev_chn		entry (fixed bin (71), fixed bin (35)),
      224      lock_manager_$per_process_init	entry (),
      225      pathname_			entry (char (*), char (*))
      226 				returns (char (168)),
      227      signal_			entry options (variable),
      228      sub_err_			entry options (variable),
      229      term_$refname			entry (char (*), fixed bin (35)),
      230      term_$single_refname		entry (char (*), fixed bin (35)),
      231      tm_adjust_tdt			entry
      232      )				external;
      233 
      234 /* External */
      235 dcl  (
      236      dm_data_$area_ptr		ptr,
      237      dm_data_$current_txn_id		bit (36) aligned,
      238      dm_data_$current_txn_index	fixed bin,
      239      dm_data_$dm_journal_segp		ptr,
      240      dm_data_$initialization_state	char (8) aligned,
      241      dm_data_$my_process_id		bit (36),
      242      dm_data_$my_tdt_index		fixed bin,
      243      dm_data_$suspended_txn_id	bit (36) aligned,
      244      dm_data_$suspended_txn_index	fixed bin,
      245      dm_data_$tm_tdt_ptr		ptr,
      246      dm_system_data_$,
      247      dm_system_data_$current_dm_state	char (4) aligned,
      248      dm_system_data_$initializer_name	char (32) aligned,
      249      dm_system_data_$tm_tdt_relp	bit (18),
      250      error_table_$unimplemented_version fixed bin (35),
      251      sys_info$data_management_ringno	fixed bin
      252      )				external static;
      253 
      254 /* END OF DECLARATIONS */
      255 
      256    current_ring = get_ring_ ();
      257 
      258 RETURN_IF_HIGHER_THAN_DM_RING:
      259    do;
      260 
      261       call hcs_$make_ptr (codeptr (tm_per_process_init_), DM_GATE_NAME, "",
      262 	 dm_gate_ptr, code);
      263       if dm_gate_ptr = null () then
      264          call ERROR_RETURN (code, "^/Returned by hcs_$make_ptr for ^a.",
      265 	    DM_GATE_NAME);
      266 
      267       call hcs_$fs_get_path_name (dm_gate_ptr, dm_gate_dir, dm_gate_dir_length,
      268 	 "" /* already know dm_gate_'s name */, code);
      269       if code ^= 0 then
      270          call ERROR_RETURN (code,
      271 	    "^/Returned by hcs_$fs_get_path_name using ^p.", dm_gate_ptr);
      272 
      273       call hcs_$get_ring_brackets (substr (dm_gate_dir, 1, dm_gate_dir_length),
      274 	 DM_GATE_NAME, ring_brackets, code);
      275       if code ^= 0 then
      276          call ERROR_RETURN (code, "^/Cannot get the ring brackets of ^a.",
      277 	    pathname_ (dm_gate_dir, DM_GATE_NAME));
      278 
      279       if current_ring > ring_brackets (2) then		/* nothing to do */
      280          call RETURN ();
      281 
      282    end RETURN_IF_HIGHER_THAN_DM_RING;
      283 
      284 
      285 IS_GENERAL_AND_TM_SETUP_DONE:
      286    do;
      287 
      288 /* See if this is another DM inner ring transfer vector's first reference */
      289 /* trap going off after the initial trap being sprung.  If so, we must    */
      290 /* have completed the first two steps and should return.		    */
      291 
      292       if dm_data_$initialization_state
      293 	 = DM_PER_PROCESS_INIT_THROUGH_TM_COMPLETE then	/* steps 1 & 2 are done */
      294          call RETURN ();
      295    end IS_GENERAL_AND_TM_SETUP_DONE;
      296 
      297    using_test_data_management_system =
      298         (current_ring > sys_info$data_management_ringno);
      299 WARN_IF_NOT_IN_REAL_DATA_MANAGEMENT:
      300    if using_test_data_management_system then
      301       call sub_err_ (0, MYNAME, ACTION_DEFAULT_RESTART, null (), (0),
      302 	 " CAUTION: You are initiating a ring ^d data management system in which files can not be fully protected.",
      303 	 current_ring);
      304 
      305 SETUP_IN_CASE_DM_NOT_AVAILABLE:
      306    dm_data_$dm_journal_segp = null ();
      307 
      308 
      309 GENERAL_DM_SETUP:
      310    do;
      311       dm_data_$initialization_state = DM_PER_PROCESS_INIT_STARTED;
      312 
      313       call dm_misc_util_$get_bootload_dir (bootload_dir_path);
      314 
      315       call cu_$level_get (callers_validation_level);
      316       on cleanup call CLEAN_UP ();
      317       call cu_$level_set (current_ring);
      318 
      319       call hcs_$initiate (bootload_dir_path, DM_SYSTEM_DATA_ENTRYNAME,
      320 	 DM_SYSTEM_DATA_REFNAME, 0, 0, dm_system_data_ptr, code);
      321       if dm_system_data_ptr = null () then
      322          call DM_SYSTEM_NOT_AVAILABLE ();
      323 
      324       process_group_id = get_group_id_$tag_star ();
      325       if process_group_id = dm_system_data_$initializer_name then
      326 CHECK_SYSTEM_STATE_FOR_DM_DAEMON:
      327          do;
      328          if dm_system_data_$current_dm_state ^= DM_SYSTEM_STATE_RUNNING
      329 	    & dm_system_data_$current_dm_state
      330 	    ^= DM_SYSTEM_STATE_INITIALIZING
      331 	    & dm_system_data_$current_dm_state ^= DM_SYSTEM_STATE_RECOVERING
      332 	    & dm_system_data_$current_dm_state
      333 	    ^= DM_SYSTEM_STATE_SHUTDOWN_BEGUN
      334 	    & dm_system_data_$current_dm_state
      335 	    ^= DM_SYSTEM_STATE_SHUTDOWN_BUMP_USERS then
      336 	  call DM_SYSTEM_NOT_AVAILABLE ();
      337       end CHECK_SYSTEM_STATE_FOR_DM_DAEMON;
      338       else
      339 CHECK_SYSTEM_STATE_FOR_NORMAL_USERS:
      340          do;
      341          if dm_system_data_$current_dm_state ^= DM_SYSTEM_STATE_RUNNING then
      342 	  call DM_SYSTEM_NOT_AVAILABLE;
      343       end CHECK_SYSTEM_STATE_FOR_NORMAL_USERS;
      344 
      345       dm_data_$area_ptr = get_system_free_area_ ();	/* AKA dm_data_$inner_ring_areap */
      346       dm_data_$my_process_id = get_process_id_ ();
      347 
      348       if using_test_data_management_system then
      349 INIT_FAKE_HARDCORE_FILES:
      350          do;
      351 INIT_DM_HCS_FAKE_GATE:
      352          do;
      353 	  call hcs_$make_ptr (codeptr (tm_per_process_init_),
      354 	       DM_HCS_FAKE_NAME, "", dm_hcs_fake_ptr, code);
      355 	  if dm_hcs_fake_ptr = null () then
      356 	     call ERROR_RETURN (code, "Returned by hcs_$make_ptr for ^a.",
      357 		DM_HCS_FAKE_NAME);
      358 
      359 	  call hcs_$fs_get_path_name (dm_hcs_fake_ptr, dir_path, ldn,
      360 	       entry_name, code);
      361 	  if code ^= 0 then
      362 	     call ERROR_RETURN (code,
      363 		"Returned by hcs_$fs_get_path_name using ^p.",
      364 		dm_hcs_fake_ptr);
      365 
      366 	  call hcs_$terminate_noname (dm_hcs_fake_ptr, 0);
      367 	  dm_hcs_fake_ptr = null;
      368 
      369 	  call hcs_$initiate (dir_path, entry_name, DM_HCS_REFNAME, 0, 0,
      370 	       dm_hcs_fake_ptr, code);
      371 	  if dm_hcs_fake_ptr = null () then
      372 	     call ERROR_RETURN (code,
      373 		"Unable to initiate ^a, with the reference name ^a.",
      374 		pathname_ (dir_path, entry_name), DM_HCS_REFNAME);
      375          end INIT_DM_HCS_FAKE_GATE;
      376 
      377 INIT_DM_HPHCS_FAKE_GATE:
      378          do;
      379 	  call hcs_$make_ptr (codeptr (tm_per_process_init_),
      380 	       DM_HPHCS_FAKE_NAME, "", dm_hphcs_fake_ptr, code);
      381 	  if dm_hphcs_fake_ptr = null () then
      382 	     call ERROR_RETURN (code, "Returned by hcs_$make_ptr for ^a.",
      383 		DM_HPHCS_FAKE_NAME);
      384 
      385 	  call hcs_$fs_get_path_name (dm_hphcs_fake_ptr, dir_path, ldn,
      386 	       entry_name, code);
      387 	  if code ^= 0 then
      388 	     call ERROR_RETURN (code,
      389 		"Returned by hcs_$fs_get_path_name using ^p.",
      390 		dm_hphcs_fake_ptr);
      391 
      392 	  call hcs_$terminate_noname (dm_hphcs_fake_ptr, 0);
      393 	  dm_hphcs_fake_ptr = null;
      394 
      395 	  call hcs_$initiate (dir_path, entry_name, DM_HPHCS_REFNAME, 0, 0,
      396 	       dm_hphcs_fake_ptr, code);
      397 	  if dm_hphcs_fake_ptr = null () then
      398 	     call ERROR_RETURN (code,
      399 		"Unable to initiate ^a with the reference name ^a.",
      400 		pathname_ (dir_path, entry_name), DM_HPHCS_REFNAME);
      401          end INIT_DM_HPHCS_FAKE_GATE;
      402 
      403 INIT_TESTING_DM_JOURNAL_SEGMENT:
      404          do;
      405 	  call dm_per_system_$initiate ("dm_journal_seg_", "dm_journal_seg_",
      406 	       dm_data_$dm_journal_segp);
      407          end INIT_TESTING_DM_JOURNAL_SEGMENT;
      408 
      409       end INIT_FAKE_HARDCORE_FILES;
      410 
      411       call RESET_VALIDATION_LEVEL ();			/* we don't need validaton level set anymore */
      412 
      413    end GENERAL_DM_SETUP;
      414 
      415 
      416 TRANSACTION_MANAGER_SPECIFIC_SETUP:
      417    do;
      418 
      419       dm_data_$current_txn_id, dm_data_$suspended_txn_id = "0"b;
      420       dm_data_$current_txn_index, dm_data_$suspended_txn_index = 0;
      421 
      422       dm_data_$tm_tdt_ptr, tm_tdt_ptr = pointer (addr (dm_system_data_$),
      423 						/* TDT is allocated in dm_system_data_ segment */
      424 	 dm_system_data_$tm_tdt_relp);
      425 
      426       if tm_tdt.version ^= TM_TDT_VERSION_3 then
      427          call ERROR_RETURN (error_table_$unimplemented_version,
      428 	    "Expected version ^a of TDT, received ^a.", TM_TDT_VERSION_3,
      429 	    tm_tdt.version);
      430 
      431 CHECK_FOR_AND_CLEANUP_DEAD_PROCESSES:
      432       call tm_adjust_tdt ();
      433 
      434       dm_data_$my_tdt_index = 0;
      435 FIND_FREE_TDT_ENTRY:
      436       do txn_index = 1 to tm_tdt.entry_count while (dm_data_$my_tdt_index = 0);
      437 
      438          tm_tdt_entry_ptr = addr (tm_tdt.entry (txn_index));
      439 
      440          if stac (addr (tm_tdt_entry.process_id), dm_data_$my_process_id) then
      441 RESERVE_FREE_TDT_ENTRY:				/* we found one */
      442 	  do;					/* reserve it */
      443 	  unspec (tm_tdt_entry.transaction) = "0"b;	/* just to be safe; entry should be zero already */
      444 
      445 	  tm_tdt_entry.owner_name =
      446 	       substr (process_group_id, 1,
      447 	       index (process_group_id, ".*") - 1);
      448 
      449 	  call cu_$level_set (current_ring);		/* only needed for channel creation */
      450 	  call ipc_$create_ev_chn (channel_id, code);
      451 	  call RESET_VALIDATION_LEVEL ();
      452 	  if code = 0 then
      453 	     tm_tdt_entry.event_channel = channel_id;
      454 
      455 	  dm_data_$my_tdt_index = txn_index;
      456          end RESERVE_FREE_TDT_ENTRY;
      457       end FIND_FREE_TDT_ENTRY;
      458 
      459       if txn_index > tm_tdt.entry_count then		/* no free slots */
      460          call DM_SYSTEM_NOT_AVAILABLE ();
      461 
      462       dm_data_$initialization_state = DM_PER_PROCESS_INIT_THROUGH_TM_COMPLETE;
      463 						/* don't redo the previous work */
      464    end TRANSACTION_MANAGER_SPECIFIC_SETUP;
      465 
      466 
      467 DO_OTHER_MANAGERS_SETUP:
      468    do;
      469       call lock_manager_$per_process_init ();
      470       call file_manager_$per_process_init ();
      471       call before_journal_manager_$per_process_init ();
      472    end DO_OTHER_MANAGERS_SETUP;
      473 
      474 /* ask Daemon to tell us if a shutdown is scheduled */
      475 /* if we fail, we let user continue, but log fact   */
      476 /* Daemon was not present.			  */
      477    if dm_misc_util_$get_begin_shutdown_time () ^= 0 then
      478 ASK_DAEMON_FOR_SHUTDOWN_IPS:
      479       do;
      480       call dm_send_request_$new_process_notifies (code);
      481       if code ^= 0 then
      482          call dm_misc_util_$log (LOG_SV, code, MYNAME,
      483 	    "A DMS shutdown is scheduled, but could not tell Daemon to send the dm_shutdown_scheduled_ IPS."
      484 	    );
      485    end ASK_DAEMON_FOR_SHUTDOWN_IPS;
      486 
      487    call RETURN ();
      488 
      489 MAIN_RETURN:
      490    return;




      491 
      492 RETURN:
      493    proc ();
      494 
      495    go to MAIN_RETURN;
      496 
      497    end RETURN;




      498 
      499 ERROR_RETURN:
      500    proc options (variable);
      501 
      502 dcl  (
      503      er_arg_list_ptr		ptr,
      504      er_code_ptr			ptr,
      505      er_message			char (1024),
      506      er_message_length		fixed bin (21)
      507      )				automatic;
      508 
      509 dcl  (
      510      er_code			fixed bin (35) based (er_code_ptr),
      511      er_message_overlay		char (er_message_length)
      512      )				based;
      513 
      514    call cu_$arg_list_ptr (er_arg_list_ptr);
      515    call cu_$arg_ptr_rel (1, er_code_ptr, (0), (0), er_arg_list_ptr);
      516 						/* get status code */
      517 
      518    call ioa_$general_rs (er_arg_list_ptr, 2, 3, er_message, er_message_length,
      519         IOA_GENERAL_RS_DONT_PAD, IOA_GENERAL_RS_NO_NEW_LINE);
      520    call sub_err_ (er_code, MYNAME, ACTION_CANT_RESTART, null (), 0,
      521         addr (er_message) -> er_message_overlay);
      522 
      523    end ERROR_RETURN;
      524 
      525 CLEAN_UP:
      526    proc ();
      527 
      528 /* We are unwinding out of this module, probably because of	*/
      529 /* the dm_not_available_ condition, or because of a sub_err_*/
      530 /* call or fault.  Cleanup any of various things we may have*/
      531 /* done.  This is an attempt to leave the process address	*/
      532 /* space close to how we found it (or expect it next try).	*/
      533 
      534    call term_$refname (DM_SYSTEM_DATA_REFNAME, 0);
      535    call term_$refname (DM_JOURNAL_SEG_NAME, 0);
      536    if dm_hcs_fake_ptr ^= null then
      537       call term_$single_refname (DM_HCS_REFNAME, 0);
      538    if dm_hphcs_fake_ptr ^= null then
      539       call term_$single_refname (DM_HPHCS_REFNAME, 0);
      540    if channel_id ^= 0 then
      541       call ipc_$delete_ev_chn (channel_id, 0);		/* shouldn't be necessary, but...*/
      542 
      543    call RESET_VALIDATION_LEVEL ();
      544 
      545    return;
      546    end CLEAN_UP;




      547 
      548 RESET_VALIDATION_LEVEL:
      549    proc ();
      550 
      551    if callers_validation_level ^= -1 then
      552       call cu_$level_set (callers_validation_level);
      553 
      554    return;
      555 
      556    end RESET_VALIDATION_LEVEL;
      557 
      558 DM_SYSTEM_NOT_AVAILABLE:
      559    proc ();
      560 
      561 /* now build condition info struct and tell user no dice */
      562 
      563    unspec (auto_condition_info) = "0"b;
      564    auto_condition_info.length = size (auto_condition_info);
      565    auto_condition_info.version = DM_NOT_AVAILABLE_INFO_VERSION_1;
      566    auto_condition_info.cant_restart = "1"b;
      567    auto_condition_info.info_string =
      568         "The Data Management system is not currently running.";
      569 
      570    call signal_ ("dm_not_available_", null, addr (auto_condition_info));
      571 
      572    call ERROR_RETURN (0,
      573         "Unexpected return from signalling dm_not_available_.");
      574 
      575    end DM_SYSTEM_NOT_AVAILABLE;
      576 
  1     1 /* BEGIN INCLUDE FILE condition_info_header.incl.pl1 BIM 1981 */
  1     2 /* format: style2 */
  1     3 
  1     4      declare condition_info_header_ptr
  1     5 			      pointer;
  1     6      declare 1 condition_info_header
  1     7 			      aligned based (condition_info_header_ptr),
  1     8 	     2 length	      fixed bin,		/* length in words of this structure */
  1     9 	     2 version	      fixed bin,		/* version number of this structure */
  1    10 	     2 action_flags	      aligned,		/* tell handler how to proceed */
  1    11 	       3 cant_restart     bit (1) unaligned,	/* caller doesn't ever want to be returned to */
  1    12 	       3 default_restart  bit (1) unaligned,	/* caller can be returned to with no further action */
  1    13 	       3 quiet_restart    bit (1) unaligned,	/* return, and print no message */
  1    14 	       3 support_signal   bit (1) unaligned,	/* treat this signal as if the signalling procedure had the support bit set */
  1    15 						/* if the signalling procedure had the support bit set, do the same for its caller */
  1    16 	       3 pad	      bit (32) unaligned,
  1    17 	     2 info_string	      char (256) varying,	/* may contain printable message */
  1    18 	     2 status_code	      fixed bin (35);	/* if^=0, code interpretable by com_err_ */
  1    19 
  1    20 /* END INCLUDE FILE condition_info_header.incl.pl1 */
      577 
      578 
  2     1 /* BEGIN INCLUDE FILE - dm_system_states.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*	This include file gives all defined values that
  2     6*     dm_system_data_$current_dm_state may have.
  2     7**/
  2     8 
  2     9 /* HISTORY:
  2    10*Written by Lee A. Newcomb, CISL, 11/04/82
  2    11*Modified:
  2    12*03/02/84 by Lee A. Newcomb:  added DM_SYSTEM_STATE_SHUTDOWN_WARNING and
  2    13*	  DM_SYSTEM_STATE_USER_SHUTDOWN; also renamed from dm_statuses to
  2    14*	  dm_system_states.incl.pl1.
  2    15*04/06/84 by Lindsey Spratt:  Added DM_SYSTEM_STATE_SYSTEM_SHUTDOWN.
  2    16*09/05/84 by Lee A. Newcomb:  renamed DM_SYSTEM_STATE_SHUTDOWN_WARNING do
  2    17*            ...SHUTDOWN_BEGUN and ...SYSTEM_SHUTDOWN to
  2    18*            ...SHUTDOWN_BUMP_USERS; deleted ...USER_SHUTDOWN.
  2    19**/
  2    20 /* format:  style2,^inddcls,linecom,ifthendo,ifthen,^indnoniterdo,dclind5,idind35 */
  2    21 
  2    22 dcl  (						/* valid statuses of data management */
  2    23 						/* ordered to expected sequence of use */
  2    24      DM_SYSTEM_STATE_UNDEFINED	init ("undf"),	/* found in a template dm_system_data_ */
  2    25      DM_SYSTEM_STATE_INITIALIZING	init ("init"),
  2    26      DM_SYSTEM_STATE_RECOVERING	init ("rcov"),
  2    27      DM_SYSTEM_STATE_RUNNING		init ("run "),
  2    28      DM_SYSTEM_STATE_SHUTDOWN_BEGUN	init ("sbgn"),
  2    29      DM_SYSTEM_STATE_SHUTDOWN_BUMP_USERS
  2    30 				init ("sbmp"),
  2    31      DM_SYSTEM_STATE_NORMAL_SHUTDOWN	init ("shut")
  2    32      )				char (4) aligned int static options (constant);
  2    33 
  2    34 /* END INCLUDE FILE - dm_system_states.incl.pl1 */
      579 
      580 
  3     1 /*  START OF:	dm_tm_tdt.incl.pl1		*/
  3     2 
  3     3 /* Transaction Definition Table for transaction_manager_ */
  3     4 /* This structure is used to reference the TDT. The process_id field for the
  3     5*   i'th TDT entry, for example, is usually referenced as tm_tdt.process_id (i).
  3     6*   A TDT entry is in use by a process when its process_id field is nonzero.
  3     7*   An entry is reserved by using the stacq builtin to set process_id, if and
  3     8*   only if it is already zero. The entry is being used for a transaction when
  3     9*   tm_tdt.txn_id (i) is nonzero. The possible values of tm_tdt.state (i) are
  3    10*   listed in dm_tm_states.incl.pl1. If state = 0, no operation has been
  3    11*   performed yet on the transaction. */
  3    12 
  3    13 
  3    14 /* HISTORY:
  3    15*Designed by Matt Pierret, 01/26/82.
  3    16*Coded by Steve Herbst, 07/27/82.
  3    17*Modified:
  3    18*08/05/82 by Steve Herbst: Added tm_tdt.operation and padded last_uid to full word.
  3    19*08/05/82 by Steve Herbst: Changed creator_process_id to bit (36).
  3    20*08/16/82 by Steve Herbst: Added contents of dm_tm_tdt_entry.incl.pl1.
  3    21*09/09/82 by Steve Herbst: Removed in_use flag from TDT entry and rearranged fields.
  3    22*09/20/82 by Steve Herbst: Removed tm_tdt.operation.
  3    23*11/01/82 by Steve Herbst: Added event_channel and error_sw to tm_tdt_entry.
  3    24*11/05/82 by Steve Herbst: Added suspended_sw and error_code to tm_tdt_entry.
  3    25*11/11/82 by Steve Herbst: Deleted tm_tdt_entry.alloc_complete.
  3    26*11/23/82 by Steve Herbst: Compacted, changed some numbers to unsigned.
  3    27*12/14/82 by Steve Herbst: Added tm_tdt_entry.daemon_error_sw.
  3    28*01/11/83 by Steve Herbst: Added owner_name, abandoned_sw & kill_sw to tm_tdt_entry.
  3    29*01/24/83 by Steve Herbst: Replaced daemon_error_sw with daemon_adjust_count.
  3    30*01/25/83 by Steve Herbst: Moved abandoned_sw from transaction portion to entry header portion.
  3    31*05/13/83 by Steve Herbst: Version 3, changed all fixed bin (18) unal uns numbers to fixed bin (17) unaligned.
  3    32*05/26/83 by Steve Herbst: Added rollback_count and checkpoint_id.
  3    33**/
  3    34 
  3    35 dcl	tm_tdt_ptr	ptr;
  3    36 dcl	tdt_max_count	fixed bin;
  3    37 
  3    38 dcl TM_TDT_VERSION_3 char (8) int static options (constant) init ("TM-TDT 3");
  3    39 
  3    40 
  3    41 dcl  1	tm_tdt		aligned based (tm_tdt_ptr),
  3    42       2	version char (8),				/* = "TM-TDT 3" */
  3    43       2	lock fixed bin (71),			/* (currently not used) */
  3    44       2	last_uid		bit (27) aligned,		/* last transaction uid assigned */
  3    45       2	flags,
  3    46        3	no_begins		bit (1) unaligned,		/* ON => only priv process can begin transaction */
  3    47        3	mbz1		bit (35) unaligned,
  3    48       2	entry_count	fixed bin,		/* number of slots allocated */
  3    49       2	mbz2		fixed bin,		/* for even word boundary */
  3    50       2	entry  (tdt_max_count refer (tm_tdt.entry_count))
  3    51 			like tm_tdt_entry;
  3    52 
  3    53 
  3    54 
  3    55 /* TDT entries: */
  3    56 
  3    57 dcl	tm_tdt_entry_ptr	ptr;
  3    58 
  3    59 dcl  1	tm_tdt_entry	aligned based (tm_tdt_entry_ptr),
  3    60       2	event_channel	fixed bin (71),		/* for communication with the process */
  3    61       2	process_id	bit (36) aligned,		/* process for which this entry is reserved */
  3    62       2	owner_name	char (32),		/* person.project of owner process */
  3    63       2	entry_flags,
  3    64        3	abandoned_sw	bit (1) unaligned,		/* ON => owner has called tm_$abandon on this entry */
  3    65        3	mbz3		bit (35) unaligned,
  3    66       2	transaction	unaligned,
  3    67        3	txn_id		bit (36) aligned,		/* unique identifier assigned at begin time */
  3    68        3	date_time_created	fixed bin (71) aligned,
  3    69        3	mode		fixed bin (17) unaligned,	/* mode specified with transaction begin */
  3    70        3	state		fixed bin (17) unaligned,	/* state transaction is currently in */
  3    71        3  error_code	fixed bin (35) aligned,	/* goes along with error_sw and error state */
  3    72        3 	checkpoint_id	fixed bin (17) unaligned,	/* identifier of the current rollback checkpoint */
  3    73        3	rollback_count	fixed bin (17) unaligned,	/* number of times bjm_$rollback has been called */
  3    74        3	daemon_adjust_count	fixed bin (17) unaligned,	/* number of times daemon has tried to adjust since user */
  3    75        3	return_idx	fixed bin (17) unaligned,	/* parent transaction, or zero */
  3    76        3	flags,
  3    77         4 dead_process_sw	bit (1) unaligned,		/* ON => treat process as dead even if it isn't yet */
  3    78         4 suspended_sw	bit (1) unaligned,		/* ON => suspended by tm_$suspend_txn */
  3    79         4 error_sw		bit (1) unaligned,		/* ON => state is one of the error states */
  3    80         4 kill_sw		bit (1) unaligned,		/* ON => being processed by tm_$kill */
  3    81         4	mbz4		bit (29) unaligned,
  3    82        3	post_commit_flags,
  3    83         4 (fmgr,
  3    84 	 bjmgr,
  3    85 	 ajmgr)	 	 bit (1) unaligned,
  3    86        3	mbz4		fixed bin;
  3    87 
  3    88 
  3    89 /*  END OF:	dm_tm_tdt.incl.pl1		*/
      581 
      582 
  4     1 /* BEGIN INCLUDE FILE dm_log_sv_codes.incl.pl1 */
  4     2 
  4     3 /* format: ^indcom */
  4     4 
  4     5 /* DESCRIPTION:
  4     6*   These are the severity codes used by the dms daemon when calling its logger.
  4     7*   The severity is ranked thusly:
  4     8*
  4     9*   severity log write situation
  4    10*   -------- --- ----- ---------
  4    11*          0 no  yes   standard output, query, etc.
  4    12*          1 yes yes   fatal error, terminate dms daemon.
  4    13*          2 yes yes   nonfatal error.
  4    14*          3 yes yes   informative message.
  4    15*          4 yes no    log information only.
  4    16**/
  4    17 
  4    18 /* HISTORY:
  4    19*
  4    20*Written by M. Pandolf, 10/06/82.
  4    21*Modified:
  4    22*12/10/84 by R. Michael Tague: Rename and reformat description/history.
  4    23*01/13/85 by Lee A. Newcomb:  Renamed to dm_log_sv_codes from
  4    24*            dm_daemon_sv_codes as the severity codes for the DM log are not
  4    25*            restrained to the DM Daemon's use.
  4    26*01/24/85 by Lee A. Newcomb:  Fixed to say dm_log_sv_codes.incl.pl1 in the
  4    27*            BEGIN and END INCLUDE comments, instead of dm_daemon_sv_codes.==.
  4    28**/
  4    29 
  4    30 /* format: style5 */
  4    31 
  4    32      dcl	   (PRINT_SV, QUERY_SV)    fixed bin internal static
  4    33 			       options (constant) init (0);
  4    34      dcl	   (CRASH_SV, FATAL_SV)    fixed bin internal static
  4    35 			       options (constant) init (1);
  4    36      dcl	   ERROR_SV	       fixed bin internal static
  4    37 			       options (constant) init (2);
  4    38      dcl	   INFORM_SV	       fixed bin internal static
  4    39 			       options (constant) init (3);
  4    40      dcl	   LOG_SV		       fixed bin internal static
  4    41 			       options (constant) init (4);
  4    42 
  4    43 /* END INCLUDE FILE dm_log_sv_codes.incl.pl1 */
      583 
      584 
  5     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  5     2 /* format: style3 */
  5     3 
  5     4 /* These constants are to be used for the flags argument of sub_err_ */
  5     5 /* They are just "string (condition_info_header.action_flags)" */
  5     6 
  5     7 declare	(
  5     8 	ACTION_CAN_RESTART	init (""b),
  5     9 	ACTION_CANT_RESTART init ("1"b),
  5    10 	ACTION_DEFAULT_RESTART
  5    11 			init ("01"b),
  5    12 	ACTION_QUIET_RESTART
  5    13 			init ("001"b),
  5    14 	ACTION_SUPPORT_SIGNAL
  5    15 			init ("0001"b)
  5    16 	)		bit (36) aligned internal static options (constant);
  5    17 
  5    18 /* End include file */
      585 
      586 
      587 
      588    end tm_per_process_init_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/17/85  1328.6  tm_per_process_init_.pl1          >spec>online>pbf-05/17/85>tm_per_process_init_.pl1
577          1    03/24/82  1347.2  condition_info_header.incl.pl1    >ldd>include>condition_info_header.incl.pl1
579          2    01/07/85  0900.0  dm_system_states.incl.pl1         >ldd>include>dm_system_states.incl.pl1
581          3    01/07/85  0900.1  dm_tm_tdt.incl.pl1                >ldd>include>dm_tm_tdt.incl.pl1
583          4    03/06/85  1031.1  dm_log_sv_codes.incl.pl1          >ldd>include>dm_log_sv_codes.incl.pl1
585          5    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000130 constant        bit(36)                  initial dcl 5-7 set ref 520*
ACTION_DEFAULT_RESTART          000000 constant        bit(36)                  initial dcl 5-7 set ref 299*
DM_GATE_NAME                    000116 constant        char(32)                 initial unaligned dcl 170 set ref 261* 263* 273*
                                                                                  275* 275*
DM_HCS_FAKE_NAME                000106 constant        char(32)                 initial unaligned dcl 170 set ref 353* 355*
DM_HCS_REFNAME                  000076 constant        char(32)                 initial unaligned dcl 170 set ref 369* 371* 536*
DM_HPHCS_FAKE_NAME              000066 constant        char(32)                 initial unaligned dcl 170 set ref 379* 381*
DM_HPHCS_REFNAME                000056 constant        char(32)                 initial unaligned dcl 170 set ref 395* 397* 538*
DM_JOURNAL_SEG_NAME             000046 constant        char(32)                 initial unaligned dcl 170 set ref 535*
DM_NOT_AVAILABLE_INFO_VERSION_1        constant        fixed bin(17,0)          initial dcl 170 ref 565
DM_PER_PROCESS_INIT_STARTED     000044 constant        char(8)                  initial dcl 170 ref 311
DM_PER_PROCESS_INIT_THROUGH_TM_COMPLETE
                                000042 constant        char(8)                  initial dcl 170 ref 292 462
DM_SYSTEM_DATA_ENTRYNAME        000021 constant        char(32)                 initial unaligned dcl 170 set ref 319*
DM_SYSTEM_DATA_REFNAME          000031 constant        char(32)                 initial unaligned dcl 170 set ref 319* 534*
DM_SYSTEM_STATE_INITIALIZING    000010 constant        char(4)                  initial dcl 2-22 ref 328
DM_SYSTEM_STATE_RECOVERING      000007 constant        char(4)                  initial dcl 2-22 ref 328
DM_SYSTEM_STATE_RUNNING         000006 constant        char(4)                  initial dcl 2-22 ref 328 341
DM_SYSTEM_STATE_SHUTDOWN_BEGUN  000005 constant        char(4)                  initial dcl 2-22 ref 328
DM_SYSTEM_STATE_SHUTDOWN_BUMP_USERS
                                000004 constant        char(4)                  initial dcl 2-22 ref 328
IOA_GENERAL_RS_DONT_PAD         000130 constant        bit(1)                   initial dcl 170 set ref 518*
IOA_GENERAL_RS_NO_NEW_LINE      000170 constant        bit(1)                   initial dcl 170 set ref 518*
LOG_SV                          000001 constant        fixed bin(17,0)          initial dcl 4-40 set ref 481*
MYNAME                          000011 constant        char(32)                 initial unaligned dcl 170 set ref 299* 481* 520*
TM_TDT_VERSION_3                000002 constant        char(8)                  initial unaligned dcl 3-38 set ref 426 426*
action_flags              2     000100 automatic       structure                level 2 dcl 138
addr                                                   builtin function         dcl 163 ref 422 438 440 520 570 570
auto_condition_info             000100 automatic       structure                level 1 dcl 138 set ref 563* 564 570 570
before_journal_manager_$per_process_init
                                000010 constant        entry                    external dcl 189 ref 471
bootload_dir_path               000205 automatic       char(168)                initial unaligned dcl 138 set ref 138* 313* 319*
callers_validation_level        000257 automatic       fixed bin(17,0)          initial dcl 138 set ref 138* 315* 551 551*
cant_restart              2     000100 automatic       bit(1)                   level 3 packed unaligned dcl 138 set ref 566*
channel_id                      000260 automatic       fixed bin(71,0)          initial dcl 138 set ref 138* 450* 452 540 540*
cleanup                         000450 stack reference condition                dcl 167 ref 316
code                            000262 automatic       fixed bin(35,0)          initial dcl 138 set ref 138* 261* 263* 267* 269 269*
                                                                                  273* 275 275* 319* 353* 355* 359* 361 361* 369*
                                                                                  371* 379* 381* 385* 387 387* 395* 397* 450* 452
                                                                                  480* 481 481*
codeptr                                                builtin function         dcl 163 ref 261 261 353 353 379 379
condition_info_header                  based           structure                level 1 dcl 1-6
cu_$arg_list_ptr                000012 constant        entry                    external dcl 189 ref 514
cu_$arg_ptr_rel                 000014 constant        entry                    external dcl 189 ref 515
cu_$level_get                   000016 constant        entry                    external dcl 189 ref 315
cu_$level_set                   000020 constant        entry                    external dcl 189 ref 317 449 551
current_ring                    000263 automatic       fixed bin(17,0)          initial dcl 138 set ref 138* 256* 279 297 299* 317*
                                                                                  449*
dir_path                        000264 automatic       char(168)                initial unaligned dcl 138 set ref 138* 359* 369*
                                                                                  371* 371* 385* 395* 397* 397*
dm_data_$area_ptr               000104 external static pointer                  dcl 235 set ref 345*
dm_data_$current_txn_id         000106 external static bit(36)                  dcl 235 set ref 419*
dm_data_$current_txn_index      000110 external static fixed bin(17,0)          dcl 235 set ref 420*
dm_data_$dm_journal_segp        000112 external static pointer                  dcl 235 set ref 305* 405*
dm_data_$initialization_state   000114 external static char(8)                  dcl 235 set ref 292 311* 462*
dm_data_$my_process_id          000116 external static bit(36)                  unaligned dcl 235 set ref 346* 440
dm_data_$my_tdt_index           000120 external static fixed bin(17,0)          dcl 235 set ref 434* 435 455*
dm_data_$suspended_txn_id       000122 external static bit(36)                  dcl 235 set ref 419*
dm_data_$suspended_txn_index    000124 external static fixed bin(17,0)          dcl 235 set ref 420*
dm_data_$tm_tdt_ptr             000126 external static pointer                  dcl 235 set ref 422*
dm_gate_dir                     000336 automatic       char(168)                initial unaligned dcl 138 set ref 138* 267* 273 273
                                                                                  275* 275*
dm_gate_dir_length              000410 automatic       fixed bin(17,0)          initial dcl 138 set ref 138* 267* 273 273
dm_gate_ptr                     000412 automatic       pointer                  initial dcl 138 set ref 138* 261* 263 267* 269*
dm_hcs_fake_ptr                 000414 automatic       pointer                  initial dcl 138 set ref 138* 353* 355 359* 361* 366*
                                                                                  367* 369* 371 536
dm_hphcs_fake_ptr               000416 automatic       pointer                  initial dcl 138 set ref 138* 379* 381 385* 387* 392*
                                                                                  393* 395* 397 538
dm_misc_util_$get_begin_shutdown_time
                                000024 constant        entry                    external dcl 189 ref 477
dm_misc_util_$get_bootload_dir  000026 constant        entry                    external dcl 189 ref 313
dm_misc_util_$log               000022 constant        entry                    external dcl 189 ref 481
dm_per_system_$initiate         000030 constant        entry                    external dcl 189 ref 405
dm_send_request_$new_process_notifies
                                000032 constant        entry                    external dcl 189 ref 480
dm_system_data_$                000130 external static fixed bin(17,0)          dcl 235 set ref 422
dm_system_data_$current_dm_state
                                000132 external static char(4)                  dcl 235 ref 328 328 328 328 328 341
dm_system_data_$initializer_name
                                000134 external static char(32)                 dcl 235 ref 325
dm_system_data_$tm_tdt_relp     000136 external static bit(18)                  unaligned dcl 235 ref 422
dm_system_data_ptr              000420 automatic       pointer                  initial dcl 138 set ref 138* 319* 321
entry                    10            based           structure                array level 2 dcl 3-41 set ref 438
entry_count               6            based           fixed bin(17,0)          level 2 dcl 3-41 ref 435 459
entry_name                      000422 automatic       char(32)                 initial unaligned dcl 138 set ref 138* 359* 369*
                                                                                  371* 371* 385* 395* 397* 397*
er_arg_list_ptr                 000100 automatic       pointer                  dcl 502 set ref 514* 515* 518*
er_code                                based           fixed bin(35,0)          dcl 509 set ref 520*
er_code_ptr                     000102 automatic       pointer                  dcl 502 set ref 515* 520
er_message                      000104 automatic       char(1024)               unaligned dcl 502 set ref 518* 520
er_message_length               000504 automatic       fixed bin(21,0)          dcl 502 set ref 518* 520 520
er_message_overlay                     based           char                     unaligned dcl 509 set ref 520*
error_table_$unimplemented_version
                                000140 external static fixed bin(35,0)          dcl 235 set ref 426*
event_channel                          based           fixed bin(71,0)          level 2 dcl 3-59 set ref 452*
file_manager_$per_process_init  000034 constant        entry                    external dcl 189 ref 470
get_group_id_$tag_star          000036 constant        entry                    external dcl 189 ref 324
get_process_id_                 000040 constant        entry                    external dcl 189 ref 346
get_ring_                       000042 constant        entry                    external dcl 189 ref 256
get_system_free_area_           000044 constant        entry                    external dcl 189 ref 345
hcs_$fs_get_path_name           000046 constant        entry                    external dcl 189 ref 267 359 385
hcs_$get_ring_brackets          000050 constant        entry                    external dcl 189 ref 273
hcs_$initiate                   000052 constant        entry                    external dcl 189 ref 319 369 395
hcs_$make_ptr                   000054 constant        entry                    external dcl 189 ref 261 353 379
hcs_$terminate_noname           000056 constant        entry                    external dcl 189 ref 366 392
index                                                  builtin function         dcl 163 ref 445
info_string               3     000100 automatic       varying char(256)        level 2 dcl 138 set ref 567*
ioa_$general_rs                 000060 constant        entry                    external dcl 189 ref 518
ipc_$create_ev_chn              000062 constant        entry                    external dcl 189 ref 450
ipc_$delete_ev_chn              000064 constant        entry                    external dcl 189 ref 540
ldn                             000432 automatic       fixed bin(17,0)          initial dcl 138 set ref 138* 359* 385*
length                          000100 automatic       fixed bin(17,0)          level 2 dcl 138 set ref 564*
lock_manager_$per_process_init  000066 constant        entry                    external dcl 189 ref 469
null                                                   builtin function         dcl 163 ref 138 138 138 138 263 299 299 305 321 355
                                                                                  367 371 381 393 397 520 520 536 538 570 570
owner_name                3            based           char(32)                 level 2 dcl 3-59 set ref 445*
pathname_                       000070 constant        entry                    external dcl 189 ref 275 275 371 371 397 397
pointer                                                builtin function         dcl 163 ref 422
process_group_id                000433 automatic       char(32)                 initial unaligned dcl 138 set ref 138* 324* 325 445
                                                                                  445
process_id                2            based           bit(36)                  level 2 dcl 3-59 set ref 440
ring_brackets                   000443 automatic       fixed bin(3,0)           initial array dcl 138 set ref 138* 138* 138* 273*
                                                                                  279
signal_                         000072 constant        entry                    external dcl 189 ref 570
size                                                   builtin function         dcl 163 ref 564
stac                                                   builtin function         dcl 163 ref 440
sub_err_                        000074 constant        entry                    external dcl 189 ref 299 520
substr                                                 builtin function         dcl 163 ref 273 273 445
sys_info$data_management_ringno 000142 external static fixed bin(17,0)          dcl 235 ref 297
term_$refname                   000076 constant        entry                    external dcl 189 ref 534 535
term_$single_refname            000100 constant        entry                    external dcl 189 ref 536 538
tm_adjust_tdt                   000102 constant        entry                    external dcl 189 ref 431
tm_tdt                                 based           structure                level 1 dcl 3-41
tm_tdt_entry                           based           structure                level 1 dcl 3-59
tm_tdt_entry_ptr                000460 automatic       pointer                  dcl 3-57 set ref 438* 440 443 445 452
tm_tdt_ptr                      000456 automatic       pointer                  dcl 3-35 set ref 422* 426 426 435 438 459
transaction              14            based           structure                level 2 unaligned dcl 3-59 set ref 443*
txn_index                       000446 automatic       fixed bin(17,0)          initial dcl 138 set ref 138* 435* 438 455* 459
unspec                                                 builtin function         dcl 163 set ref 443* 563*
using_test_data_management_system
                                000447 automatic       bit(1)                   initial dcl 138 set ref 138* 297* 299 348
version                                based           char(8)                  level 2 in structure "tm_tdt" dcl 3-41 in procedure
                                                                                  "tm_per_process_init_" set ref 426 426*
version                   1     000100 automatic       fixed bin(17,0)          level 2 in structure "auto_condition_info" dcl 138
                                                                                  in procedure "tm_per_process_init_" set ref 565*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 5-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 5-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 5-7
CRASH_SV                               internal static fixed bin(17,0)          initial dcl 4-34
DM_SYSTEM_STATE_NORMAL_SHUTDOWN        internal static char(4)                  initial dcl 2-22
DM_SYSTEM_STATE_UNDEFINED              internal static char(4)                  initial dcl 2-22
ERROR_SV                               internal static fixed bin(17,0)          initial dcl 4-36
FATAL_SV                               internal static fixed bin(17,0)          initial dcl 4-34
INFORM_SV                              internal static fixed bin(17,0)          initial dcl 4-38
PRINT_SV                               internal static fixed bin(17,0)          initial dcl 4-32
QUERY_SV                               internal static fixed bin(17,0)          initial dcl 4-32
condition_info_header_ptr              automatic       pointer                  dcl 1-4
tdt_max_count                          automatic       fixed bin(17,0)          dcl 3-36

NAMES DECLARED BY EXPLICIT CONTEXT.
ASK_DAEMON_FOR_SHUTDOWN_IPS     002336 constant        label                    dcl 477
CHECK_FOR_AND_CLEANUP_DEAD_PROCESSES
                                002165 constant        label                    dcl 431
CHECK_SYSTEM_STATE_FOR_DM_DAEMON
                                001240 constant        label                    dcl 325
CHECK_SYSTEM_STATE_FOR_NORMAL_USERS
                                001255 constant        label                    dcl 338
CLEAN_UP                        002551 constant        entry                    internal dcl 525 ref 316
DM_SYSTEM_NOT_AVAILABLE         002720 constant        entry                    internal dcl 558 ref 321 328 341 459
DO_OTHER_MANAGERS_SETUP         002307 constant        label                    dcl 467
ERROR_RETURN                    002404 constant        entry                    internal dcl 499 ref 263 269 275 355 361 371 381 387
                                                                                  397 426 572
FIND_FREE_TDT_ENTRY             002174 constant        label                    dcl 435
GENERAL_DM_SETUP                001104 constant        label                    dcl 309
INIT_DM_HCS_FAKE_GATE           001301 constant        label                    dcl 351
INIT_DM_HPHCS_FAKE_GATE         001571 constant        label                    dcl 377
INIT_FAKE_HARDCORE_FILES        001301 constant        label                    dcl 348
INIT_TESTING_DM_JOURNAL_SEGMENT 002061 constant        label                    dcl 403
IS_GENERAL_AND_TM_SETUP_DONE    001016 constant        label                    dcl 285
MAIN_RETURN                     002400 constant        label                    dcl 489 ref 495
RESERVE_FREE_TDT_ENTRY          002223 constant        label                    dcl 440
RESET_VALIDATION_LEVEL          002700 constant        entry                    internal dcl 548 ref 411 451 543
RETURN                          002401 constant        entry                    internal dcl 492 ref 279 292 487
RETURN_IF_HIGHER_THAN_DM_RING   000551 constant        label                    dcl 258
SETUP_IN_CASE_DM_NOT_AVAILABLE  001101 constant        label                    dcl 305
TRANSACTION_MANAGER_SPECIFIC_SETUP
                                002115 constant        label                    dcl 416
WARN_IF_NOT_IN_REAL_DATA_MANAGEMENT
                                001032 constant        label                    dcl 299
tm_per_process_init_            000461 constant        entry                    external dcl 131 ref 261 261 353 353 379 379

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3642        4006    3013        3652
Length      4406    3013       144         363     627           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
tm_per_process_init_                478 external procedure  is an external procedure.  
on unit on line 316                  82 on unit               
RETURN                                  internal procedure  shares stack frame of external procedure tm_per_process_init_.  
ERROR_RETURN                        376 internal procedure  is declared options(variable).  
CLEAN_UP                                internal procedure  shares stack frame of on unit on line 316.  
RESET_VALIDATION_LEVEL               68 internal procedure  is called by several nonquick procedures.  
DM_SYSTEM_NOT_AVAILABLE                 internal procedure  shares stack frame of external procedure tm_per_process_init_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ERROR_RETURN             000100 er_arg_list_ptr             ERROR_RETURN
                         000102 er_code_ptr                 ERROR_RETURN
                         000104 er_message                  ERROR_RETURN
                         000504 er_message_length           ERROR_RETURN
tm_per_process_init_     000100 auto_condition_info         tm_per_process_init_
                         000205 bootload_dir_path           tm_per_process_init_
                         000257 callers_validation_level    tm_per_process_init_
                         000260 channel_id                  tm_per_process_init_
                         000262 code                        tm_per_process_init_
                         000263 current_ring                tm_per_process_init_
                         000264 dir_path                    tm_per_process_init_
                         000336 dm_gate_dir                 tm_per_process_init_
                         000410 dm_gate_dir_length          tm_per_process_init_
                         000412 dm_gate_ptr                 tm_per_process_init_
                         000414 dm_hcs_fake_ptr             tm_per_process_init_
                         000416 dm_hphcs_fake_ptr           tm_per_process_init_
                         000420 dm_system_data_ptr          tm_per_process_init_
                         000422 entry_name                  tm_per_process_init_
                         000432 ldn                         tm_per_process_init_
                         000433 process_group_id            tm_per_process_init_
                         000443 ring_brackets               tm_per_process_init_
                         000446 txn_index                   tm_per_process_init_
                         000447 using_test_data_management_system
                                                            tm_per_process_init_
                         000456 tm_tdt_ptr                  tm_per_process_init_
                         000460 tm_tdt_entry_ptr            tm_per_process_init_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               alloc_cs            call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this
call_int_other      return              stac                enable              shorten_stack       ext_entry
int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
before_journal_manager_$per_process_init                    cu_$arg_list_ptr              cu_$arg_ptr_rel
cu_$level_get                 cu_$level_set                 dm_misc_util_$get_begin_shutdown_time
dm_misc_util_$get_bootload_dir                              dm_misc_util_$log             dm_per_system_$initiate
dm_send_request_$new_process_notifies                       file_manager_$per_process_init
get_group_id_$tag_star        get_process_id_               get_ring_                     get_system_free_area_
hcs_$fs_get_path_name         hcs_$get_ring_brackets        hcs_$initiate                 hcs_$make_ptr
hcs_$terminate_noname         ioa_$general_rs               ipc_$create_ev_chn            ipc_$delete_ev_chn
lock_manager_$per_process_init                              pathname_                     signal_
sub_err_                      term_$refname                 term_$single_refname          tm_adjust_tdt

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_data_$area_ptr             dm_data_$current_txn_id       dm_data_$current_txn_index    dm_data_$dm_journal_segp
dm_data_$initialization_state dm_data_$my_process_id        dm_data_$my_tdt_index         dm_data_$suspended_txn_id
dm_data_$suspended_txn_index  dm_data_$tm_tdt_ptr           dm_system_data_$
dm_system_data_$current_dm_state                            dm_system_data_$initializer_name
dm_system_data_$tm_tdt_relp   error_table_$unimplemented_version
sys_info$data_management_ringno




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    131 000460       138 000466       256 000541       261 000551       263 000603       267 000632       269 000663
    273 000710       275 000744       279 001012       292 001016       297 001025       299 001032       305 001101
    311 001104       313 001110       315 001120       316 001127       317 001145       319 001154       321 001216
    324 001223       325 001232       328 001240       337 001254       341 001255       345 001261       346 001270
    348 001277       353 001301       355 001333       359 001362       361 001413       366 001440       367 001452
    369 001454       371 001516       379 001571       381 001623       385 001652       387 001703       392 001730
    393 001742       395 001744       397 002006       405 002061       411 002111       419 002115       420 002120
    422 002122       426 002131       431 002165       434 002172       435 002174       438 002210       440 002215
    443 002223       445 002227       449 002241       450 002247       451 002260       452 002264       455 002270
    457 002273       459 002275       462 002302       469 002307       470 002313       471 002320       477 002325
    480 002336       481 002345       487 002377       489 002400       492 002401       495 002402       499 002403
    514 002411       515 002417       518 002442       520 002505       523 002550       525 002551       534 002552
    535 002570       536 002606       538 002631       540 002654       543 002671       545 002676       548 002677
    551 002705       554 002717       558 002720       563 002721       564 002724       565 002726       566 002730
    567 002732       570 002737       572 002771       575 003011


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
