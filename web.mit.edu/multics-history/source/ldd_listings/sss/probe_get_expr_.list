	COMPILATION LISTING OF SEGMENT probe_get_expr_
	Compiled by: Multics PL/I Compiler, Release 32d, of September 19, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 09/21/89  1240.7 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        6*        *                                                         *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        8*        *                                                         *
        9*        * Copyright (c) 1972 by Massachusetts Institute of        *
       10*        * Technology and Honeywell Information Systems, Inc.      *
       11*        *                                                         *
       12*        *********************************************************** */
       13 
       14 
       15 
       16 /****^  HISTORY COMMENTS:
       17*  1) change(88-05-25,WAAnderson), approve(88-10-18,MCR7952),
       18*     audit(88-10-18,JRGray), install(88-10-24,MR12.2-1184):
       19*     Added the internal procedures 'account_for_c_indirection' and
       20*     'trace_c_indirection' to handle the C_INDIRECTION operator.The
       21*     C_INDIRECTION operator and the TIMES operator are both represented
       22*     graphically by the * character.
       23*  2) change(88-05-27,WAAnderson), approve(88-10-18,MCR7952),
       24*     audit(88-10-18,JRGray), install(88-10-24,MR12.2-1184):
       25*     Added support for the AMPERSAND operator in 'get_factor'.
       26*  3) change(88-06-13,WAAnderson), approve(88-10-18,MCR7952),
       27*     audit(88-10-18,JRGray), install(88-10-24,MR12.2-1184):
       28*     Modified 'get_bexpr' to handle the C_LEFT_SHIFT and C_RIGHT_SHIFT
       29*     operators.
       30*  4) change(88-09-07,WAAnderson), approve(88-10-18,MCR7952),
       31*     audit(88-10-18,JRGray), install(88-10-24,MR12.2-1184):
       32*     Added format control comment to make the source more readable.
       33*  5) change(88-11-30,WAAnderson), approve(88-12-05,MECR0006),
       34*     audit(88-12-02,JRGray), install(88-12-05,MR12.2-1220):
       35*     Added code to ensure probe chases the linked list of runtime_symbol
       36*     structures whose head runtime_symbol structure is of type c_typeref_dtype
       37*     ONLY when the program being probed has been generated by the C compiler.
       38*     Prior to this change, Pascal enumerated types were being confused with
       39*     c_typeref_dtypes, resulting in an infinite loop.
       40*  6) change(89-09-18,WAAnderson), approve(89-09-18,MCR8042),
       41*     audit(89-09-18,JRGray), install(89-09-21,MR12.3-1070):
       42*     See above.  Closing out MECR006.
       43*                                                   END HISTORY COMMENTS */
       44 
       45 
       46 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       47 
       48 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       49 
       50 probe_get_expr_:
       51   proc (P_probe_info_ptr, P_reference, P_code);
       52 
       53   /* This marvel can not only get expressions, it can get expressions using
       54*   precedence ! Written at 6AM after an all-nighter, and is no doubt a crock
       55*
       56*   JRDavis 13 Fri July 79
       57*
       58*   Well, it was close...
       59*
       60*   Modified 13 Nov 79 JRD
       61*
       62*   BEXP := EXP << EXP
       63*   EXP := TERM [+ TERM]...
       64*   TERM := FACTOR [* FACTOR]...
       65*   FACTOR := VALUE | (EXP)
       66*
       67*   where <<, + or * can also be >>, - or /,% respectively, and "..."
       68*   denotes arbitrary number of repitions of the stuff in the brackets,
       69*   and a VALUE is what probe_get_$value returns.
       70**/
       71   /* * 09 Sep 81, S.Herbst:
       72*    *    Fixed to handle "v (2+2)" and print better errmsg for "v -1|0".
       73*    * ?? Jun 83, JMAthane:
       74*    *    To know PASCAL array indices between brackets.
       75*    * ?? Apr 88, Hinatsu:
       76*    *    To add C operators "% << >>".
       77*    *  */
       78 
       79   dcl (
       80       P_probe_info_ptr	ptr,
       81       1 P_reference		aligned like reference_node,
       82       P_code		fixed bin (35)
       83       )			parameter;
       84 
       85   dcl code		fixed bin (35);
       86   dcl pre_op_code		char (1) aligned;
       87   dcl saved_ct		ptr;
       88 
       89   dcl probe_create_reference_$init
       90 			entry (ptr, ptr);
       91   dcl probe_builtins_$addr_builtin
       92 			entry (ptr, ptr, fixed bin (35));
       93   dcl probe_operate_$infix	entry (ptr, char (1) aligned,
       94 			1 structure aligned like reference_node,
       95 			1 structure aligned like reference_node,
       96 			1 structure aligned like reference_node,
       97 			fixed bin (35));
       98   dcl probe_operate_$prefix	entry (ptr, char (1) aligned,
       99 			1 structure aligned like reference_node,
      100 			1 structure aligned like reference_node,
      101 			fixed bin (35));
      102 
      103   dcl (
      104       probe_et_$recorded_message,
      105       probe_et_$bad_section,
      106       probe_et_$bad_expression
      107       )			fixed bin (35) external static;
      108 
      109   dcl probe_error_$record	entry options (variable);
      110 
      111   dcl (addr, addrel, fixed, null)
      112 			builtin;
      113   dcl c_indirect_count	(40) fixed bin;
      114   dcl c_indirect_ix		fixed bin;
      115   dcl ptr_overlay		ptr based;
      116 
      117 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      118 
      119 account_for_c_indirection:
      120   proc ();
      121 
      122   dcl not_done_indirection	bit (1);
      123 
      124   if probe_info.language_type ^= C_lang_type  then return;
      125   c_indirect_ix = c_indirect_ix + 1;
      126   c_indirect_count (c_indirect_ix) = 0;
      127   not_done_indirection = "1"b;
      128   do while (not_done_indirection);
      129     if probe_info.ct -> token.type < probe_info.token_info.end_token
      130          & probe_info.ct -> token.type > OPERATOR_TYPE then do;
      131         if probe_info.ct -> token.type = C_INDIRECTION then do;
      132 	  c_indirect_count (c_indirect_ix) =
      133 	       c_indirect_count (c_indirect_ix) + 1;
      134 	  probe_info.ct = probe_info.ct -> token.next;
      135 	end;
      136 	else not_done_indirection = "0"b;
      137       end;
      138       else not_done_indirection = "0"b;
      139   end;
      140   probe_info.ct = probe_info.ct -> token.prev;
      141 
      142   end account_for_c_indirection;
      143 
      144 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      145 
      146 trace_c_indirection:
      147   proc (ref_node_ptr);
      148 
      149   dcl ref_node_ptr		ptr;
      150   dcl 01 temp_ref		aligned like reference_node
      151 			based (ref_node_ptr);
      152 
      153   if probe_info.language_type ^= C_lang_type then return;
      154   if (c_indirect_ix <= 0)
      155     then return;
      156   do while (c_indirect_count (c_indirect_ix) > 0);
      157     c_indirect_count (c_indirect_ix) = c_indirect_count (c_indirect_ix) - 1;
      158     if temp_ref.symbol_ptr -> runtime_symbol.son ^= "0"b then do;
      159         temp_ref.symbol_ptr =
      160 	   addrel (temp_ref.symbol_ptr,
      161 	   fixed (temp_ref.symbol_ptr -> runtime_symbol.son));
      162 				/* typeref */
      163         do while (fixed (temp_ref.symbol_ptr -> runtime_symbol.type)
      164 	   = c_typeref_dtype);
      165 	temp_ref.symbol_ptr =
      166 	     addrel (temp_ref.symbol_ptr,
      167 	     fixed (temp_ref.symbol_ptr -> runtime_symbol.son));
      168         end;
      169         temp_ref.type = fixed (temp_ref.symbol_ptr -> runtime_symbol.type);
      170         temp_ref.address_ptr = temp_ref.address_ptr -> ptr_overlay;
      171         temp_ref.precision = temp_ref.symbol_ptr -> runtime_symbol.size;
      172       end;
      173   end;
      174   if c_indirect_ix > 0
      175     then c_indirect_ix = c_indirect_ix - 1;
      176   end trace_c_indirection;
      177 
      178 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      179 
      180   pre_op_code = "?";
      181   probe_info_ptr = P_probe_info_ptr;
      182   P_code = 0;
      183   code = 0;
      184   saved_ct = ct;
      185   c_indirect_ix = 0;
      186 
      187   if ct -> token.type >= OPERATOR_TYPE then do;
      188       if probe_info.ct -> token.type = PLUS
      189         then pre_op_code = "+";
      190       else if probe_info.ct -> token.type = MINUS
      191         then pre_op_code = "-";
      192       else if probe_info.ct -> token.type = AMPERSAND
      193 	 & (probe_info.language_type = C_lang_type)
      194         then pre_op_code = "?";
      195       else if probe_info.ct -> token.type = C_INDIRECTION
      196 	 & (probe_info.language_type = C_lang_type) then do;
      197 	call account_for_c_indirection ();
      198 	pre_op_code = "*";
      199         end;
      200       else if probe_info.ct -> token.type
      201 	 ^= LEFT_PAREN /* don't confuse ( with prefix ops */
      202 	 &
      203 	 ^(probe_info.language_type = PASCAL_lang_type
      204 	 & probe_info.ct -> token.type = LEFT_BRACKET)
      205         then do;
      206 
      207 	code = probe_et_$bad_expression;
      208 	goto LOSS;
      209         end;
      210       if ct -> token.type ^= LEFT_PAREN
      211 	 & ct -> token.type ^= LEFT_BRACKET &
      212 	 ct -> token.type ^= AMPERSAND
      213         then ct = ct -> token.next;
      214     end;
      215 GET_EXPR:
      216 
      217   call get_bexpr (P_reference);
      218   if pre_op_code ^= "?"
      219     then
      220          if P_reference.type = pointer_dtype & c_indirect_ix = 0
      221 	    & pre_op_code ^= "*" then do;
      222 				/* might be -1|0, etc. */
      223 
      224 	   pre_op_code = "?";
      225 	   ct = saved_ct;		/* reparse with "-" as part of ptr */
      226 	   go to GET_EXPR;
      227 	 end;
      228          else if P_reference.flags.cross_section
      229 	 then goto SECTION_LOSS;
      230          else if pre_op_code = "*" & c_indirect_ix > 0
      231 	 then
      232 	      call trace_c_indirection (addr (P_reference));
      233 
      234          else if probe_info.execute & pre_op_code ^= "*"
      235 	 then
      236 	      call probe_operate_$prefix (probe_info_ptr, pre_op_code,
      237 		 P_reference, P_reference, code);
      238 
      239 LOSS:
      240 
      241   P_code = code;
      242   return;
      243 
      244 SECTION_LOSS:
      245   code = probe_et_$bad_section;
      246   goto LOSS;
      247 
      248 SINISTER_ERROR:
      249 
      250   call probe_error_$record (probe_info_ptr, probe_et_$bad_expression,
      251        "Too many left parentheses");
      252   code = probe_et_$recorded_message;
      253   return;
      254 
      255 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      256 
      257 get_bexpr:
      258   proc (bfirst);
      259 
      260   dcl 1 bfirst		aligned like reference_node parameter;
      261   dcl 1 bsecond_ref_block	aligned like ref_block automatic;
      262   dcl op_code		char (1) aligned;
      263 
      264   call probe_create_reference_$init (probe_info_ptr, addr (bsecond_ref_block))
      265        ;
      266 
      267   call get_expr (bfirst);
      268   do while ((probe_info.ct -> token.type = C_LEFT_SHIFT |
      269        probe_info.ct -> token.type = C_RIGHT_SHIFT |
      270        probe_info.ct -> token.type = C_INDIRECTION) &
      271        probe_info.language_type = C_lang_type);
      272 
      273     if probe_info.ct -> token.type = C_LEFT_SHIFT
      274       then op_code = "<";
      275     else if probe_info.ct -> token.type = C_RIGHT_SHIFT
      276       then op_code = ">";
      277     if (probe_info.ct -> token.type = C_LEFT_SHIFT
      278          | probe_info.ct -> token.type = C_RIGHT_SHIFT)
      279       then
      280 	 ct = ct -> token.next;
      281 
      282     if probe_info.ct -> token.type = C_INDIRECTION
      283       then do;
      284         call account_for_c_indirection ();
      285         ct = ct -> token.next;
      286       end;
      287     if bfirst.cross_section
      288       then
      289 	 goto SECTION_LOSS;
      290 
      291     call get_expr (bsecond_ref_block.ref_node);
      292     if bsecond_ref_block.ref_node.cross_section
      293       then
      294 	 goto SECTION_LOSS;
      295 
      296     if probe_info.execute
      297       then do;
      298         if bsecond_ref_block.ref_node.type = pointer_dtype
      299 	then
      300 	     call trace_c_indirection (addr (bsecond_ref_block.ref_node));
      301         if bfirst.type = pointer_dtype
      302 	then
      303 	     call trace_c_indirection (addr (bfirst));
      304         call probe_operate_$infix (probe_info_ptr, op_code, bfirst,
      305 	   bsecond_ref_block.ref_node, bfirst, code);
      306         if code ^= 0
      307 	then
      308 	     goto LOSS;
      309       end;
      310   end;
      311 
      312   end get_bexpr;
      313 
      314 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      315 
      316 get_expr:
      317   proc (first);
      318 
      319   dcl 1 first		aligned like reference_node parameter;
      320   dcl 1 second_ref_block	aligned like ref_block automatic;
      321   dcl op_code		char (1) aligned;
      322 
      323   call probe_create_reference_$init (probe_info_ptr, addr (second_ref_block));
      324 
      325   call get_term (first);
      326   do while (probe_info.ct -> token.type = PLUS |
      327        probe_info.ct -> token.type = MINUS |
      328        probe_info.ct -> token.type = C_INDIRECTION);
      329 
      330     if probe_info.ct -> token.type = PLUS
      331       then op_code = "+";
      332     else if probe_info.ct -> token.type = MINUS
      333       then op_code = "-";
      334     if (probe_info.ct -> token.type = PLUS
      335          | probe_info.ct -> token.type = MINUS)
      336       then
      337 	 ct = ct -> token.next;
      338 
      339     if probe_info.ct -> token.type = C_INDIRECTION
      340       then do;
      341         call account_for_c_indirection ();
      342         ct = ct -> token.next;
      343       end;
      344 
      345     if first.cross_section
      346       then
      347 	 goto SECTION_LOSS;
      348 
      349     call get_term (second_ref_block.ref_node);
      350     if second_ref_block.ref_node.cross_section
      351       then
      352 	 goto SECTION_LOSS;
      353 
      354     if probe_info.execute
      355       then do;
      356         if second_ref_block.ref_node.type = pointer_dtype
      357 	then
      358 	     call trace_c_indirection (addr (second_ref_block.ref_node));
      359         if first.type = pointer_dtype
      360 	then
      361 	     call trace_c_indirection (addr (first));
      362         call probe_operate_$infix (probe_info_ptr, op_code, first,
      363 	   second_ref_block.ref_node, first, code);
      364         if code ^= 0
      365 	then
      366 	     goto LOSS;
      367       end;
      368   end;				/* otherwise loop back for another */
      369 
      370   end get_expr;
      371 
      372 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      373 
      374 get_term:
      375   proc (alpha);
      376 
      377   dcl 1 alpha		aligned like reference_node parameter;
      378   dcl 1 beta_ref_block	aligned like ref_block automatic;
      379   dcl term_op_code		char (1) aligned;
      380 
      381   call probe_create_reference_$init (probe_info_ptr, addr (beta_ref_block));
      382   call get_factor (alpha);
      383 
      384   do while (probe_info.ct -> token.type = TIMES |
      385        probe_info.ct -> token.type = SLASH |
      386        (probe_info.ct -> token.type = PERCENT
      387        & probe_info.language_type = C_lang_type));
      388     if probe_info.ct -> token.type = TIMES
      389       then term_op_code = "*";
      390     else if probe_info.ct -> token.type = SLASH
      391       then term_op_code = "/";
      392     else if probe_info.ct -> token.type = PERCENT
      393       then term_op_code = "%";
      394 
      395     probe_info.ct = probe_info.ct -> token.next;
      396 
      397     if (probe_info.ct -> token.type = C_INDIRECTION) then do;
      398         call account_for_c_indirection ();
      399         probe_info.ct = probe_info.ct -> token.next;
      400       end;
      401 
      402     if alpha.cross_section
      403       then
      404 	 goto SECTION_LOSS;
      405 
      406     call get_factor (beta_ref_block.ref_node);
      407     if beta_ref_block.ref_node.cross_section
      408       then
      409 	 goto SECTION_LOSS;
      410 
      411     if probe_info.execute
      412       then do;
      413         if beta_ref_block.ref_node.type = pointer_dtype
      414 	then
      415 	     call trace_c_indirection (addr (beta_ref_block.ref_node));
      416         if alpha.type = pointer_dtype
      417 	then
      418 	     call trace_c_indirection (addr (alpha));
      419         call probe_operate_$infix (probe_info_ptr, term_op_code, alpha,
      420 	   beta_ref_block.ref_node, alpha, code);
      421         if code ^= 0
      422 	then
      423 	     goto LOSS;
      424       end;
      425 
      426   end;				/* looping through all consequtive TERMS */
      427   end get_term;
      428 
      429 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      430 
      431 get_factor:
      432   proc (val);
      433 
      434   dcl 1 val		aligned like reference_node parameter;
      435   dcl probe_get_$value	entry (ptr,
      436 			1 structure aligned like reference_node,
      437 			bit (36) aligned, fixed bin (35));
      438   dcl indir_flag		bit (1);
      439   dcl defer_ampersand	bit (1);
      440   dcl 01 sub_refs		aligned like subscript_reference_ptrs;
      441   dcl probe_create_reference_ entry (ptr, ptr);
      442   dcl temp_node_ptr		ptr;
      443 
      444   indir_flag = "0"b;
      445 
      446   if ct -> token.type = LEFT_PAREN then do;
      447       ct = ct -> token.next;
      448       if ct -> token.type >= RIGHT_PAREN
      449         then
      450 	   goto SINISTER_ERROR;
      451       if (ct -> token.type = C_INDIRECTION)
      452         then
      453 	   call account_for_c_indirection ();
      454       call get_expr (val);
      455       if code ^= 0
      456         then
      457 	   goto LOSS;
      458       if ct -> token.type ^= RIGHT_PAREN
      459         then
      460 	   goto SINISTER_ERROR;
      461       ct = ct -> token.next;
      462     end;
      463     else do;
      464       if (ct -> token.type = C_INDIRECTION) then do;
      465 	indir_flag = "1"b;
      466 	ct = ct -> token.next;
      467         end;
      468       if ct -> token.type = AMPERSAND then do;
      469 	ct = ct -> token.next;
      470 	call probe_create_reference_ (probe_info_ptr, temp_node_ptr);
      471 	temp_node_ptr -> reference_node.name = "<<<constant>>>";
      472 	temp_node_ptr -> reference_node.source_info_ptr =
      473 	     val.source_info_ptr;
      474 				/* Set the c_symbol_ptr to any non-null value because get_value will null the
      475*   symbol_ptr field if the symbol is a char array */
      476 	val.c_symbol_ptr = addr (val);
      477 	defer_ampersand = "1"b;
      478         end;
      479         else defer_ampersand = "0"b;
      480 
      481       call probe_get_$value (probe_info_ptr, val, "000"b, code);
      482 
      483       if code ^= 0
      484         then
      485 	   goto LOSS;
      486       if (val.symbol_ptr ^= null ()) then do;
      487 	if (fixed (val.symbol_ptr -> runtime_symbol.type)
      488 	     = c_enum_const_dtype) & probe_info.language_type = C_lang_type then do;
      489 	    val.type = real_fix_bin_1_dtype;
      490 	    val.precision = 35;
      491 	    val.symbol_ptr = null ();
      492 	  end;
      493 	else if (fixed (val.symbol_ptr -> runtime_symbol.type)
      494 	     = c_typeref_dtype & probe_info.language_type = C_lang_type)
      495 	  then do;
      496 	    do while (fixed (val.symbol_ptr -> runtime_symbol.type)
      497 	         = c_typeref_dtype);
      498 	      val.symbol_ptr =
      499 		 addrel (val.symbol_ptr,
      500 		 fixed (val.symbol_ptr -> runtime_symbol.son, 17));
      501 	    end;
      502 	    if (fixed (val.symbol_ptr -> runtime_symbol.type)
      503 	         = c_enum_dtype) then do;
      504 	        val.type = real_fix_bin_1_dtype;
      505 	        val.precision = 35;
      506 				/*	         val.symbol_ptr = null();*/
      507 	      end;
      508 	      else do;
      509 	        val.type =
      510 		   fixed (val.symbol_ptr -> runtime_symbol.type, 35);
      511 	        val.precision =
      512 		   fixed (val.symbol_ptr -> runtime_symbol.size, 35);
      513 	        val.flags.packed =
      514 		   val.symbol_ptr -> runtime_symbol.bits.packed;
      515 	      end;
      516 	  end;
      517         end;
      518       if (indir_flag)
      519         then
      520 	   call trace_c_indirection (addr (val));
      521       else if (defer_ampersand) then do;
      522 	sub_refs (1, 1).ptr = addr (val);
      523 	temp_node_ptr -> reference_node.optional_info.n_subscripts = 1;
      524 	temp_node_ptr -> reference_node.subscript_refs_ptr =
      525 	     addr (sub_refs);
      526 	call probe_builtins_$addr_builtin (probe_info_ptr, temp_node_ptr,
      527 	     code);
      528 	temp_node_ptr -> reference_node.optional_info.n_subscripts = 0;
      529 	temp_node_ptr -> reference_node.c_symbol_ptr = val.symbol_ptr;
      530 	val = temp_node_ptr -> reference_node;
      531         end;
      532 
      533     end;
      534   return;
      535 
      536   end get_factor;
      537 
      538 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      539 
  1     1 /*	BEGIN INCLUDE FILE probe_info.incl.pl1		*/
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(88-10-24,WAAnderson), approve(88-10-24,MCR7952),
  1     7*     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
  1     8*     Added field 'retry_using_main' to add new C feature.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* Created: 04/22/79 W. Olin Sibert, from subsystem_info	
  1    13*   Modified: 22 Sept 79 JRd to remove: 	default (ptr & (auto|based)) init (null ());
  1    14*   Added flags.setting_break 08/22/83 Steve Herbst
  1    15*   Added flags.executing_quit_request 01/15/85 Steve Herbst
  1    16**/
  1    17 
  1    18 dcl 1 probe_info aligned based (probe_info_ptr),		/* standard data for a probe invocation */
  1    19     2 probe_info_version fixed bin,			/* version of this structure */
  1    20 
  1    21     2 static_info_ptr pointer unaligned,		/* pointer to static information structure */
  1    22     2 modes_ptr pointer unaligned,			/* pointer to probe_modes structure */
  1    23 
  1    24     2 ptr_to_current_source ptr,			/* current_source is based on this */
  1    25     2 ptr_to_initial_source ptr,			/* initial_source is based on this */
  1    26     2 machine_cond_ptr pointer,			/* pointer to machine conditions, if we faulted to get here */
  1    27 
  1    28     2 token_info aligned,				/* information about token chain currently being processed */
  1    29       3 first_token pointer unaligned,			/* first token in chain */
  1    30       3 ct pointer unaligned, 			/* pointer to current token; updated in MANY places */
  1    31       3 end_token bit (18) aligned,			/* token type at which to stop scanning token chain */
  1    32       3 buffer_ptr pointer unaligned,			/* pointer to input buffer */
  1    33       3 buffer_lth fixed bin (21),			/* and length */
  1    34 
  1    35     2 random_info aligned,
  1    36       3 current_stack_frame pointer unaligned,		/* stack frame pointer for frame in which probe was invoked */
  1    37       3 input_type fixed bin, 			/* current input type */
  1    38       3 language_type fixed bin,			/* current language being processed */
  1    39       3 return_method fixed bin,			/* how we should return after exiting probe */
  1    40       3 entry_method fixed bin,			/* how we got here in the first place */
  1    41       3 pad1 (19) bit (36) aligned,
  1    42 
  1    43     2 break_info,					/* break info -- only interesting if we got here via a break */
  1    44       3 break_slot_ptr pointer,			/* pointer to break slot -- non-null IFF at a break */
  1    45       3 last_break_slot_ptr pointer unaligned,		/* pointer to previous break slot, not presently used */
  1    46       3 break_reset bit (1) aligned,			/* this break has been reset by somebody further on */
  1    47       3 real_break_return_loc pointer,			/* where to REALLY return to, modulo previous bit */
  1    48 
  1    49     2 probe_area_info,				/* information about various probe areas */
  1    50       3 break_segment_ptr pointer unaligned,		/* pointer to Personid.probe */
  1    51       3 break_area_ptr pointer unaligned,		/* pointer to area in break segment */
  1    52       3 scratch_area_ptr pointer unaligned,		/* pointer to probe scratch seg in process dir */
  1    53       3 probe_area_ptr pointer unaligned,		/* This area lasts as long as an invocation of probe. */
  1    54       3 work_area_ptr pointer unaligned,		/* This area lasts as long as the current request line */
  1    55       3 expression_area_ptr pointer unaligned,		/* This area lasts as long as the current command */
  1    56 
  1    57     2 flags aligned,				/* this, in particular, should be saved and restored correctly */
  1    58      (3 execute,					/* "1"b => execute requests, "0"b => just check syntax */
  1    59       3 in_listener,				/* ON => in probe listener loop */
  1    60       3 executing_request,				/* ON => executing a request */
  1    61       3 in_interpret_line,				/* executing in probe_listen_$interpret_line */
  1    62       3 setting_break,				/* executing "after" or "before": check syntax of "if" */
  1    63       3 executing_quit_request,			/* to prevent error looping during "quit" request */
  1    64       3 pad (30)) bit (1) unaligned,
  1    65 
  1    66     2 io_switches,					/* switches probe will do normal I/O on */
  1    67       3 input_switch pointer,
  1    68       3 output_switch pointer,
  1    69 
  1    70     2 error_info,					/* information about the last error saved for later printing */
  1    71       3 error_code fixed bin (35),
  1    72       3 error_message char (300) varying,
  1    73 
  1    74     2 listener_info,				/* internal use by probe listener */
  1    75       3 request_name character (32) varying,		/* primary name of the request being processed */
  1    76       3 abort_probe_label label variable,
  1    77       3 abort_line_label label variable,
  1    78       3 depth fixed binary,				/* count of active invocations of probe */
  1    79       3 previous pointer unaligned,			/* -> previous invocation's info */
  1    80       3 next pointer unaligned,
  1    81 
  1    82     2 end_of_probe_info pointer aligned,
  1    83     2 retry_using_main fixed bin aligned;
  1    84    
  1    85 
  1    86 dcl  probe_info_ptr pointer;
  1    87 
  1    88 dcl  probe_info_version fixed bin static options (constant) initial (1);
  1    89 
  1    90 dcl  probe_info_version_1 fixed bin static options (constant) initial (1);
  1    91 
  1    92 dcl  scratch_area area based (probe_info.scratch_area_ptr);
  1    93 dcl  probe_area area based (probe_info.probe_area_ptr);
  1    94 dcl  work_area area based (probe_info.work_area_ptr);
  1    95 dcl  expression_area area based (probe_info.expression_area_ptr);
  1    96 
  1    97 /*	END INCLUDE FILE probe_info.incl.pl1		*/
      540 
      541 
  2     1 /*	BEGIN INCLUDE FILE probe_references.incl.pl1	*/
  2     2 
  2     3 /****^  HISTORY COMMENTS:
  2     4*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  2     5*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  2     6*     Added new field (c_symbol) for C-Probe support.
  2     7*  2) change(88-10-28,WAAnderson), approve(88-10-28,MCR7952),
  2     8*     audit(88-10-31,RWaters), install(88-11-11,MR12.2-1210):
  2     9*     Added new field (c_sub_c_ptr) for C-Probe_support.
  2    10*                                                   END HISTORY COMMENTS */
  2    11 
  2    12 /*	Split out of probe_tokens, 04/22/79 WOS 	*/
  2    13 /*       modified for probe variables Feb 19 80 JRD         */
  2    14 /*   Modified June 83 JMAthane to add "type_ptr" and "builtin" fields */
  2    15 
  2    16      dcl	   1 reference_node	      aligned based,	/* information about a reference */
  2    17 	     2 symbol_ptr	      pointer aligned,	/* to symbol table entry for reference */
  2    18 	     2 type_ptr	      pointer aligned,	/* to symbol table entry for type (null if none) */
  2    19 	     2 address_ptr	      pointer aligned,	/* to location of variable */
  2    20 	     2 base_addr	      pointer aligned,	/* pointer on which whole symbol is based */
  2    21 	     2 source_info_ptr    pointer aligned,	/* to symbol structure for reference */
  2    22 
  2    23 	     2 name	      char (256) unaligned varying, /* symbol name */
  2    24 
  2    25 	     2 type	      fixed bin (35),	/* data type */
  2    26 	     2 descriptor	      fixed bin (35),	/* type || packed */
  2    27 	     2 precision	      fixed bin (35),	/* scale and precision */
  2    28 	     2 flags,
  2    29 	       3 packed	      bit (1) unal,		/* data is in packed format */
  2    30 	       3 constant	      bit (1) unal,		/* data is really a constant */
  2    31 	       3 cross_section    bit (1) unal,		/* reference is an array cross-section */
  2    32 	       3 function	      bit (1) unal,		/* reference is function value */
  2    33 	       3 octal	      bit (1) unal,		/* indicates that this is the octal bif */
  2    34 	       3 star_extent      bit (1) unal,		/* reference is a star subscript for father */
  2    35 	       3 have_generation  bit (1) unal,		/* this reference has an explicitly specified generation */
  2    36 	       3 pseudo_var	      bit (1) unal,		/* it is ok to assign to it */
  2    37 	       3 probe_variable   bit (1) unal,
  2    38 	       3 path	      bit (1) unal,		/* it's a pathname/virtual entry */
  2    39 	       3 builtin	      bit (1) unal,		/* probe builtinvalue */
  2    40 	       3 c_ptr_to_char    bit (1)  unal,
  2    41                  3 c_sub_c_ptr      bit (1)  unal,
  2    42 	       3 pad2	      bit (23) unal,
  2    43 
  2    44 	     2 optional_info,			/* information which may or may not be present */
  2    45 	       3 argument_list    pointer unaligned,	/* pointer to reference_arg_list */
  2    46 	       3 subscript_ptr    pointer unaligned,	/* pointer to reference_subscripts */
  2    47 	       3 n_arguments      fixed bin,		/* number of arguments in argument list */
  2    48 	       3 n_subscripts     fixed bin,		/* number of subscripts present */
  2    49 
  2    50 	     2 constant_token_ptr pointer unaligned,	/* pointer to constant token if this is a constant */
  2    51 	     2 subscript_refs_ptr pointer unaligned,	/* pointer to array of subscript reference node pointers */
  2    52 	     2 invocation_level   fixed bin,		/* invocation level number ("[-17]") for this reference */
  2    53 	     2 probe_var_info_ptr ptr unal,		/* only if flags.probe_variable */
  2    54                2 c_symbol_ptr  ptr unal,
  2    55 	     2 pad1	      (9) pointer unaligned,
  2    56 	     2 end_of_reference_node pointer aligned;
  2    57 
  2    58 
  2    59      dcl	   1 reference_arg_list   aligned based,	/* argument list; based on reference.argument_list */
  2    60 	     2 number	      fixed bin,		/* number of arguments actually present */
  2    61 	     2 node	      (16) pointer aligned;	/* reference node pointers for each argument */
  2    62 
  2    63 
  2    64      dcl	   1 reference_subscripts aligned based,	/* subscript array; based on reference.subscript_ptr */
  2    65 	     2 number	      fixed bin,		/* number actually present */
  2    66 	     2 value	      (2, 16) fixed bin (24); /* values for lower and upper bound for each */
  2    67 
  2    68 
  2    69      dcl	   1 subscript_reference_ptrs aligned based,	/* array of pointers to subscript reference nodes */
  2    70 	     2 ptr	      (2, 16) pointer aligned;
  2    71 
  2    72 /*	END INCLUDE FILE probe_references.incl.pl1	*/
      542 
      543 
  3     1 /*	BEGIN INCLUDE FILE probe_ref_block.incl.pl1	*/
  3     2 
  3     3 /* *	This declares all the necessary storage for a reference node and the
  3     4*   *	things it points to. Programs which create reference nodes should either
  3     5*   *	declare automatic ref_blocks like ref_block, and call probe_create_reference_$init
  3     6*   *	to initialize the automatic copies, or call probe_create_reference_ directly
  3     7*   *	to allocate them in expression_area and initialize the, returning a pointer
  3     8*   *	which will be valid for the duration of the request. */
  3     9 
  3    10 dcl  ref_block_ptr pointer;
  3    11 
  3    12 dcl 1 ref_block aligned based (ref_block_ptr),		/* we allocate this in the area and fill it in */
  3    13     2 ref_node aligned like reference_node,
  3    14     2 subscripts aligned like reference_subscripts,
  3    15     2 arglist aligned like reference_arg_list,
  3    16     2 source_info aligned like source_info,
  3    17     2 sub_refs aligned like subscript_reference_ptrs;
  3    18 
  3    19 /*	END INCLUDE FILE probe_ref_block.incl.pl1	*/
      544 
      545 
  4     1 /* BEGIN INCLUDE FILE ... probe_source_info.incl.pl1
  4     2*
  4     3*  James R. Davis 2 July 79 */
  4     4 
  4     5 dcl 1 source_info based aligned,
  4     6       2 stmnt_map_entry_index fixed bin,		/* index in stmnt map for this stmnt */
  4     7       2 instruction_ptr ptr,				/* to last instruction executed  */
  4     8       2 block_ptr ptr,				/* to runtime_block node */
  4     9       2 stack_ptr ptr,				/* to a stack frame */
  4    10       2 entry_ptr ptr,				/* to entry seq. for this proc */
  4    11       2 seg_info_ptr ptr;				/* to seg_info */
  4    12 
  4    13 dcl 1 current_source aligned like source_info based (probe_info.ptr_to_current_source);
  4    14 dcl 1 initial_source aligned like source_info based (probe_info.ptr_to_initial_source);
  4    15 
  4    16 /* END INCLUDE FILE ... probe_source_info.incl.pl1 */
      546 
      547 
  5     1 /*	BEGIN INCLUDE FILE probe_tokens.incl.pl1	*/
  5     2 /*	Split up into probe_tokens and probe_references, 04/22/79 WOS */
  5     3 
  5     4 dcl 1 token_header aligned based,			/* header information common to all tokens */
  5     5     2 next pointer unaligned,				/* pointer to next token in chain */
  5     6     2 prev pointer unaligned,				/* same for previous token */
  5     7     2 type bit (18) aligned,
  5     8     2 buffer_ptr pointer unaligned,			/* pointer to beginning of input buffer */
  5     9     2 location fixed bin (17) unal,			/* offset in input buffer */
  5    10     2 length fixed bin (17) unal,
  5    11     2 flags aligned,
  5    12      (3 leading_whitespace,				/* there is whitespace before thios token */
  5    13       3 trailing_whitespace) bit (1) unaligned,		/* and same for after */
  5    14       3 pad1 bit (34) unaligned;
  5    15 
  5    16 dcl 1 token aligned based,				/* produced by scan_probe_input_ */
  5    17     2 header aligned like token_header;			/* that's all there is */
  5    18 
  5    19 dcl 1 identifier aligned based,			/* keyword or identifier token */
  5    20     2 header aligned like token_header,
  5    21     2 length fixed bin,				/* length of name */
  5    22     2 name pointer unaligned;				/* to string in buffer containing name */
  5    23 
  5    24 dcl 1 operator aligned based,				/* for punctuation */
  5    25     2 header aligned like token_header;			/* nothing but a header here */
  5    26 
  5    27 dcl 1 constant aligned based,				/* for strings pointers numbers etc */
  5    28     2 header aligned like token_header,
  5    29     2 encoded_precision aligned,			/* encoded precision kludge for assign_ */
  5    30       3 scale fixed bin (17) unaligned,			/* arithmetic scale */
  5    31       3 precision fixed bin (17) unaligned,		/* arithmetic precision or other size */
  5    32     2 scale_and_precision fixed bin (35),		/* An identical copy of the two values above */
  5    33     2 data_type fixed bin,				/* standard data type code + packed bit */
  5    34     2 data_ptr pointer unaligned;
  5    35 
  5    36 
  5    37 dcl (OPERATOR_TYPE init ("100"b),			/* types for above */
  5    38      NAME_TYPE init ("010"b),
  5    39      CONSTANT_TYPE init ("001"b)) bit (18) internal static options (constant);
  5    40 
  5    41 
  5    42 dcl  current_identifier_name				/* Overlays for looking at the current tokens */
  5    43      char (probe_info.ct -> identifier.length) based (probe_info.ct -> identifier.name);
  5    44 dcl 1 current_constant aligned like constant based (probe_info.ct);
  5    45 dcl 1 current_token aligned like token based (probe_info.ct);
  5    46 
  5    47 /*	END INCLUDE FILE probe_tokens.incl.pl1		*/
      548 
      549 
  6     1 /* BEGIN INCLUDE FILE ... probe_operators.incl.pl1 */
  6     2 
  6     3 
  6     4 
  6     5 /****^  HISTORY COMMENTS:
  6     6*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  6     7*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  6     8*     Added new C operators.
  6     9*                                                   END HISTORY COMMENTS */
  6    10 
  6    11 
  6    12 /* These are the operator.types for each defined operator */
  6    13 /* Modified June 83 JMAthane for PASCAL_ARROW new operator */
  6    14 /* Added PASCAL_RANGE and PASCAL_ASSIGN 07/26/83 S. Herbst */
  6    15 /* Modified April 88 Hinatsu Addition of C types */
  6    16 
  6    17      dcl	   (PLUS		      init ("400001"b3), MINUS init ("400002"b3),
  6    18 	   TIMES		      init ("400003"b3), SLASH init ("400004"b3),
  6    19 	   OR_BAR		      init ("400005"b3), NOT_SIGN init ("400006"b3),
  6    20 	   LESS_THAN	      init ("400007"b3), GREATER_THAN init ("400010"b3),
  6    21 	   EQUALS		      init ("400011"b3), NOT_EQUALS init ("400012"b3),
  6    22 	   NOT_GREATER_THAN	      init ("400013"b3), NOT_LESS_THAN init ("400014"b3),
  6    23 	   PERIOD		      init ("400015"b3), COLON init ("400016"b3),
  6    24 	   AMPERSAND	      init ("400017"b3), PERCENT init ("400020"b3),
  6    25 	   DOLLAR_SIGN	      init ("400021"b3), LEFT_BRACKET init ("400022"b3),
  6    26 	   RIGHT_BRACKET	      init ("400023"b3), ARROW init ("400024"b3),
  6    27 	   COMMA		      init ("400025"b3), QUESTION_MARK init ("400026"b3),
  6    28 	   PASCAL_ARROW	      init ("400027"b3), PASCAL_RANGE init ("400030"b3),
  6    29 	   PASCAL_ASSIGN	      init ("400031"b3),
  6    30 
  6    31 /* Additons to support C types */
  6    32 	   C_LEFT_SHIFT           init ("400032"b3), C_RIGHT_SHIFT init ("400033"b3),
  6    33 
  6    34 /* operator 28 are left for future expansion */
  6    35 
  6    36 	   LEFT_PAREN	      init ("400035"b3), RIGHT_PAREN init ("400036"b3),
  6    37              C_EQUAL                init ("400037"b3), C_NOT_EQUAL init ("400040"b3),
  6    38 	   SEMI_COLON	      init ("400041"b3), NEW_LINE init ("400042"b3),
  6    39 	   C_INDIRECTION          init ("400034"b3)
  6    40 
  6    41 	   )		      bit (18) aligned internal static options (constant);
  6    42 
  6    43      dcl	   OPERATOR_VALUES	      (0:34) char (4) varying internal static options (constant) init
  6    44 			      ("????", "+", "-", "*", "/", "|", "^", "<",
  6    45 			      ">", "=", "^=", "<=", ">=", ".", ":", "&",
  6    46 			      "%", "$", "[", "]", "->", ",", "?", "^",
  6    47 			      "..", ":=", "<<", ">>", "*", "(", ")",
  6    48 			      "==", "!=", ";","
  6    49 ");
  6    50 
  6    51 /* END INCLUDE FILE ... probe_operators.incl.pl1 */
      550 
      551 
  7     1 /* BEGIN INCLUDE FILE  ... probe_lang_types.incl.pl1
  7     2*
  7     3*   JRD 26 June 79
  7     4*   MBW 31 July 1981 to add algol68 */
  7     5 
  7     6 
  7     7 /****^  HISTORY COMMENTS:
  7     8*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  7     9*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  7    10*     Added C Language type.
  7    11*                                                   END HISTORY COMMENTS */
  7    12 
  7    13 
  7    14 /*   Modified June 83 JMAthane to add PASCAL language type */
  7    15 /*   Modified April 88 Hinatsu to add C language type */
  7    16 
  7    17      dcl	   (UNKNOWN_lang_type     init (1),
  7    18 	   OTHER_lang_type	      init (2),
  7    19 	   PL1_lang_type	      init (3),
  7    20 	   FORTRAN_lang_type      init (4),
  7    21 	   COBOL_lang_type	      init (5),
  7    22 	   ALM_lang_type	      init (6),
  7    23 	   ALGOL68_lang_type      init (7),
  7    24 	   PASCAL_lang_type	      init (8),
  7    25 	   C_lang_type	      init (9)) fixed bin internal static options (constant);
  7    26 
  7    27      dcl	   official_language_names (9) char (32) internal static options (constant) init
  7    28 			      ("Unknown", "other", "PL/I", "FORTRAN", "COBOL", "ALM", "Algol 68", "Pascal", "C");
  7    29 
  7    30      dcl	   palatable_language_names (9) char (32) internal static options (constant) init
  7    31 			      ("Unknown", "Other", "pl1", "fortran", "cobol", "alm", "algol68", "pascal", "c");
  7    32 
  7    33 /* END INCLUDE FILE ... probe_lang_types.incl.pl1 */
      552 
      553 
  8     1 /* BEGIN INCLUDE FILE ... std_descriptor_types.incl.pl1 */
  8     2 
  8     3 
  8     4 /****^  HISTORY COMMENTS:
  8     5*  1) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
  8     6*     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1208):
  8     7*     Added pascal_string_type_dtype descriptor type.  Its number is 87.
  8     8*     Objects of this type are PASCAL string types.
  8     9*  2) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  8    10*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  8    11*     Added the new C types.
  8    12*                                                   END HISTORY COMMENTS */
  8    13 
  8    14 /* This include file defines mnemonic names for the Multics
  8    15*   standard descriptor types, using both pl1 and cobol terminology.
  8    16*   PG 780613
  8    17*   JRD 790530
  8    18*   JRD 791016
  8    19*   MBW 810731
  8    20*   TGO 830614 Add hex types.
  8    21*   Modified June 83 JMAthane to add PASCAL data types
  8    22*   TGO 840120 Add float dec extended and generic, float binary generic
  8    23**/
  8    24 
  8    25      dcl	   (real_fix_bin_1_dtype  init (1),
  8    26 	   real_fix_bin_2_dtype   init (2),
  8    27 	   real_flt_bin_1_dtype   init (3),
  8    28 	   real_flt_bin_2_dtype   init (4),
  8    29 	   cplx_fix_bin_1_dtype   init (5),
  8    30 	   cplx_fix_bin_2_dtype   init (6),
  8    31 	   cplx_flt_bin_1_dtype   init (7),
  8    32 	   cplx_flt_bin_2_dtype   init (8),
  8    33 	   real_fix_dec_9bit_ls_dtype init (9),
  8    34 	   real_flt_dec_9bit_dtype init (10),
  8    35 	   cplx_fix_dec_9bit_ls_dtype init (11),
  8    36 	   cplx_flt_dec_9bit_dtype init (12),
  8    37 	   pointer_dtype	      init (13),
  8    38 	   offset_dtype	      init (14),
  8    39 	   label_dtype	      init (15),
  8    40 	   entry_dtype	      init (16),
  8    41 	   structure_dtype	      init (17),
  8    42 	   area_dtype	      init (18),
  8    43 	   bit_dtype	      init (19),
  8    44 	   varying_bit_dtype      init (20),
  8    45 	   char_dtype	      init (21),
  8    46 	   varying_char_dtype     init (22),
  8    47 	   file_dtype	      init (23),
  8    48 	   real_fix_dec_9bit_ls_overp_dtype init (29),
  8    49 	   real_fix_dec_9bit_ts_overp_dtype init (30),
  8    50 	   real_fix_bin_1_uns_dtype init (33),
  8    51 	   real_fix_bin_2_uns_dtype init (34),
  8    52 	   real_fix_dec_9bit_uns_dtype init (35),
  8    53 	   real_fix_dec_9bit_ts_dtype init (36),
  8    54 	   real_fix_dec_4bit_uns_dtype init (38),	/* digit-aligned */
  8    55 	   real_fix_dec_4bit_ts_dtype init (39),	/* byte-aligned */
  8    56 	   real_fix_dec_4bit_bytealigned_uns_dtype init (40), /* COBOL */
  8    57 	   real_fix_dec_4bit_ls_dtype init (41),	/* digit-aligned */
  8    58 	   real_flt_dec_4bit_dtype init (42),		/* digit-aligned */
  8    59 	   real_fix_dec_4bit_bytealigned_ls_dtype init (43),
  8    60 	   real_flt_dec_4bit_bytealigned_dtype init (44),
  8    61 	   cplx_fix_dec_4bit_bytealigned_ls_dtype init (45),
  8    62 	   cplx_flt_dec_4bit_bytealigned_dtype init (46),
  8    63 	   real_flt_hex_1_dtype   init (47),
  8    64 	   real_flt_hex_2_dtype   init (48),
  8    65 	   cplx_flt_hex_1_dtype   init (49),
  8    66 	   cplx_flt_hex_2_dtype   init (50),
  8    67 	   c_typeref_dtype        init (54),
  8    68 	   c_enum_dtype           init (55),
  8    69              c_enum_const_dtype     init (56),
  8    70 	   c_union_dtype          init (57),
  8    71 	   algol68_straight_dtype init (59),
  8    72 	   algol68_format_dtype   init (60),
  8    73 	   algol68_array_descriptor_dtype init (61),
  8    74 	   algol68_union_dtype    init (62),
  8    75 
  8    76 	   cobol_comp_6_dtype     init (1),
  8    77 	   cobol_comp_7_dtype     init (1),
  8    78 	   cobol_display_ls_dtype init (9),
  8    79 	   cobol_structure_dtype  init (17),
  8    80 	   cobol_char_string_dtype init (21),
  8    81 	   cobol_display_ls_overp_dtype init (29),
  8    82 	   cobol_display_ts_overp_dtype init (30),
  8    83 	   cobol_display_uns_dtype init (35),
  8    84 	   cobol_display_ts_dtype init (36),
  8    85 	   cobol_comp_8_uns_dtype init (38),		/* digit aligned */
  8    86 	   cobol_comp_5_ts_dtype  init (39),		/* byte aligned */
  8    87 	   cobol_comp_5_uns_dtype init (40),
  8    88 	   cobol_comp_8_ls_dtype  init (41),		/* digit aligned */
  8    89 	   real_flt_dec_extended_dtype init (81),	/* 9-bit exponent */
  8    90 	   cplx_flt_dec_extended_dtype init (82),	/* 9-bit exponent */
  8    91 	   real_flt_dec_generic_dtype init (83),	/* generic float decimal */
  8    92 	   cplx_flt_dec_generic_dtype init (84),
  8    93 	   real_flt_bin_generic_dtype init (85),	/* generic float binary */
  8    94 	   cplx_flt_bin_generic_dtype init (86)) fixed bin internal static options (constant);
  8    95 
  8    96      dcl	   (ft_integer_dtype      init (1),
  8    97 	   ft_real_dtype	      init (3),
  8    98 	   ft_double_dtype	      init (4),
  8    99 	   ft_complex_dtype	      init (7),
  8   100 	   ft_complex_double_dtype init (8),
  8   101 	   ft_external_dtype      init (16),
  8   102 	   ft_logical_dtype	      init (19),
  8   103 	   ft_char_dtype	      init (21),
  8   104 	   ft_hex_real_dtype      init (47),
  8   105 	   ft_hex_double_dtype    init (48),
  8   106 	   ft_hex_complex_dtype   init (49),
  8   107 	   ft_hex_complex_double_dtype init (50)
  8   108 	   )		      fixed bin internal static options (constant);
  8   109 
  8   110      dcl	   (algol68_short_int_dtype init (1),
  8   111 	   algol68_int_dtype      init (1),
  8   112 	   algol68_long_int_dtype init (2),
  8   113 	   algol68_real_dtype     init (3),
  8   114 	   algol68_long_real_dtype init (4),
  8   115 	   algol68_compl_dtype    init (7),
  8   116 	   algol68_long_compl_dtype init (8),
  8   117 	   algol68_bits_dtype     init (19),
  8   118 	   algol68_bool_dtype     init (19),
  8   119 	   algol68_char_dtype     init (21),
  8   120 	   algol68_byte_dtype     init (21),
  8   121 	   algol68_struct_struct_char_dtype init (22),
  8   122 	   algol68_struct_struct_bool_dtype init (20)
  8   123 	   )		      fixed bin internal static options (constant);
  8   124 
  8   125      dcl	   (label_constant_runtime_dtype init (24),
  8   126 	   int_entry_runtime_dtype init (25),
  8   127 	   ext_entry_runtime_dtype init (26),
  8   128 	   ext_procedure_runtime_dtype init (27),
  8   129 	   picture_runtime_dtype  init (63)
  8   130 	   )		      fixed bin internal static options (constant);
  8   131 
  8   132      dcl	   (pascal_integer_dtype  init (1),
  8   133 	   pascal_real_dtype      init (4),
  8   134 	   pascal_label_dtype     init (24),
  8   135 	   pascal_internal_procedure_dtype init (25),
  8   136 	   pascal_exportable_procedure_dtype init (26),
  8   137 	   pascal_imported_procedure_dtype init (27),
  8   138 	   pascal_typed_pointer_type_dtype init (64),
  8   139 	   pascal_char_dtype      init (65),
  8   140 	   pascal_boolean_dtype   init (66),
  8   141 	   pascal_record_file_type_dtype init (67),
  8   142 	   pascal_record_type_dtype init (68),
  8   143 	   pascal_set_dtype	      init (69),
  8   144 	   pascal_enumerated_type_dtype init (70),
  8   145 	   pascal_enumerated_type_element_dtype init (71),
  8   146 	   pascal_enumerated_type_instance_dtype init (72),
  8   147 	   pascal_user_defined_type_dtype init (73),
  8   148 	   pascal_user_defined_type_instance_dtype init (74),
  8   149 	   pascal_text_file_dtype init (75),
  8   150 	   pascal_procedure_type_dtype init (76),
  8   151 	   pascal_variable_formal_parameter_dtype init (77),
  8   152 	   pascal_value_formal_parameter_dtype init (78),
  8   153 	   pascal_entry_formal_parameter_dtype init (79),
  8   154 	   pascal_parameter_procedure_dtype init (80),
  8   155 	   pascal_string_type_dtype init (87)) fixed bin int static options (constant);
  8   156 
  8   157 
  8   158 /* END INCLUDE FILE ... std_descriptor_types.incl.pl1 */
      554 
      555 
  9     1 /*	BEGIN INCLUDE FILE ... runtime_symbol.incl.pl1 ... Modified 07/79 */
  9     2 
  9     3 dcl	1 runtime_symbol	aligned based,
  9     4 	2 flag		unal bit(1),	/* always "1"b for Version II */
  9     5 	2 use_digit	unal bit(1),	/* if "1"b and units are half words units are really digits */
  9     6 	2 array_units	unal bit(2),
  9     7 	2 units		unal bit(2),	/* addressing units */
  9     8 	2 type		unal bit(6),	/* data type */
  9     9 	2 level		unal bit(6),	/* structure level */
  9    10 	2 ndims		unal bit(6),	/* number of dimensions */
  9    11 	2 bits		unal,
  9    12 	  3 aligned	bit(1),
  9    13 	  3 packed	bit(1),
  9    14 	  3 simple	bit(1),
  9    15 	2 skip		unal bit(1),
  9    16 	2 scale		unal bit(8),	/* arithmetic scale factor */
  9    17 	2 name		unal bit(18),	/* rel ptr to acc name */
  9    18 	2 brother		unal bit(18),	/* rel ptr to brother entry */
  9    19 	2 father		unal bit(18),	/* rel ptr to father entry */
  9    20 	2 son		unal bit(18),	/* rel ptr to son entry */
  9    21 	2 address		unal,
  9    22 	  3 location	bit(18),		/* location in storage class */
  9    23 	  3 class		bit(4),		/* storage class */
  9    24 	  3 next		bit(14),		/* rel ptr to next of same class */
  9    25 	2 size		fixed bin(35),	/* encoded string|arith size */
  9    26 	2 offset		fixed bin(35),	/* encoded offset from address */
  9    27 	2 virtual_org	fixed bin(35),
  9    28 	2 bounds(1),
  9    29 	  3 lower		fixed bin(35),	/* encoded lower bound */
  9    30 	  3 upper		fixed bin(35),	/* encoded upper bound */
  9    31 	  3 multiplier	fixed bin(35);	/* encoded multiplier */
  9    32 
  9    33 dcl	1 runtime_bound	based,
  9    34 	2 lower		fixed bin(35),
  9    35 	2 upper		fixed bin(35),
  9    36 	2 multiplier	fixed bin(35);
  9    37 
  9    38 dcl	1 runtime_block	aligned based,
  9    39 	2 flag		unal bit(1),	/* always "1"b for Version II */
  9    40 	2 quick		unal bit(1),	/* "1"b if quick block */
  9    41 	2 fortran		unal bit(1),	/* "1"b if fortran program */
  9    42 	2 standard	unal bit(1),	/* "1"b if program has std obj segment */
  9    43 	2 owner_flag	unal bit(1),	/* "1"b if block has valid owner field */
  9    44 	2 skip		unal bit(1),
  9    45 	2 type		unal bit(6),	/* = 0 for a block node */
  9    46 	2 number		unal bit(6),	/* begin block number */
  9    47 	2 start		unal bit(18),	/* rel ptr to start of symbols */
  9    48 	2 name		unal bit(18),	/* rel ptr to name of proc */
  9    49 	2 brother		unal bit(18),	/* rel ptr to brother block */
  9    50 	2 father		unal bit(18),	/* rel ptr to father block */
  9    51 	2 son		unal bit(18),	/* rel ptr to son block */
  9    52 	2 map		unal,
  9    53 	  3 first		bit(18),		/* rel ptr to first word of map */
  9    54 	  3 last		bit(18),		/* rel ptr to last word of map */
  9    55 	2 entry_info	unal bit(18),	/* info about entry of quick block */
  9    56 	2 header		unal bit(18),	/* rel ptr to symbol header */
  9    57 	2 chain(4)	unal bit(18),	/* chain(i) is rel ptr to first symbol
  9    58*					   on start list with length >= 2**i */
  9    59 	2 token(0:5)	unal bit(18),	/* token(i) is rel ptr to first token
  9    60*					   on list with length >= 2 ** i */
  9    61 	2 owner		unal bit(18);	/* rel ptr to owner block */
  9    62 
  9    63 dcl	1 runtime_token	aligned based,
  9    64 	2 next		unal bit(18),	/* rel ptr to next token */
  9    65 	2 dcl		unal bit(18),	/* rel ptr to first dcl of this token */
  9    66 	2 name,				/* ACC */
  9    67 	  3 size		unal unsigned fixed bin (9), /* number of chars in token */
  9    68 	  3 string	unal char(n refer(runtime_token.size));
  9    69 
  9    70 dcl	1 encoded_value	aligned based,
  9    71 	2 flag		bit (2) unal,
  9    72 	2 code		bit (4) unal,
  9    73 	2 n1		bit (6) unal,
  9    74 	2 n2		bit (6) unal,
  9    75 	2 n3		bit (18) unal;
  9    76 
  9    77 /*	END INCLUDE FILE ... runtime_symbol.incl.pl1 */
      556 
      557 
      558   end probe_get_expr_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    09/21/89  1240.6  probe_get_expr_.pl1               >spec>install>1070>probe_get_expr_.pl1
540          1    10/27/88  1339.2  probe_info.incl.pl1               >ldd>include>probe_info.incl.pl1
542          2    11/11/88  1601.5  probe_references.incl.pl1         >ldd>include>probe_references.incl.pl1
544          3    11/26/79  1320.7  probe_ref_block.incl.pl1          >ldd>include>probe_ref_block.incl.pl1
546          4    11/26/79  1320.6  probe_source_info.incl.pl1        >ldd>include>probe_source_info.incl.pl1
548          5    11/26/79  1320.6  probe_tokens.incl.pl1             >ldd>include>probe_tokens.incl.pl1
550          6    10/26/88  1255.5  probe_operators.incl.pl1          >ldd>include>probe_operators.incl.pl1
552          7    10/26/88  1255.5  probe_lang_types.incl.pl1         >ldd>include>probe_lang_types.incl.pl1
554          8    10/26/88  1255.5  std_descriptor_types.incl.pl1     >ldd>include>std_descriptor_types.incl.pl1
556          9    11/26/79  1320.6  runtime_symbol.incl.pl1           >ldd>include>runtime_symbol.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
AMPERSAND                              constant        bit(18)                  initial dcl 6-17 ref 192 210 468
C_INDIRECTION                          constant        bit(18)                  initial dcl 6-17 ref 131 195 268 282 326 339 397 451
                                                                                  464
C_LEFT_SHIFT                           constant        bit(18)                  initial dcl 6-17 ref 268 273 277
C_RIGHT_SHIFT                          constant        bit(18)                  initial dcl 6-17 ref 268 275 277
C_lang_type                            constant        fixed bin(17,0)          initial dcl 7-17 ref 124 153 192 195 268 384 487 493
LEFT_BRACKET                           constant        bit(18)                  initial dcl 6-17 ref 200 210
LEFT_PAREN                             constant        bit(18)                  initial dcl 6-17 ref 200 210 446
MINUS                                  constant        bit(18)                  initial dcl 6-17 ref 190 326 332 334
OPERATOR_TYPE                          constant        bit(18)                  initial packed unaligned dcl 5-37 ref 129 187
PASCAL_lang_type                       constant        fixed bin(17,0)          initial dcl 7-17 ref 200
PERCENT                                constant        bit(18)                  initial dcl 6-17 ref 384 392
PLUS                                   constant        bit(18)                  initial dcl 6-17 ref 188 326 330 334
P_code                                 parameter       fixed bin(35,0)          dcl 79 set ref 50 182* 239*
P_probe_info_ptr                       parameter       pointer                  dcl 79 ref 50 181
P_reference                            parameter       structure                level 1 dcl 79 set ref 50 215* 230 230 234* 234*
RIGHT_PAREN                            constant        bit(18)                  initial dcl 6-17 ref 448 458
SLASH                                  constant        bit(18)                  initial dcl 6-17 ref 384 390
TIMES                                  constant        bit(18)                  initial dcl 6-17 ref 384 388
addr                                                   builtin function         dcl 111 ref 230 230 264 264 298 298 301 301 323 323
                                                                                  356 356 359 359 381 381 413 413 416 416 476 518
                                                                                  518 522 524
addrel                                                 builtin function         dcl 111 ref 159 165 498
address_ptr               4            based           pointer                  level 2 dcl 150 set ref 170* 170
alpha                                  parameter       structure                level 1 dcl 377 set ref 374 382* 416 416 419* 419*
beta_ref_block                  000474 automatic       structure                level 1 dcl 378 set ref 381 381
bfirst                                 parameter       structure                level 1 dcl 260 set ref 257 267* 301 301 304* 304*
bits                      0(24)        based           structure                level 2 packed packed unaligned dcl 9-3
bsecond_ref_block               000166 automatic       structure                level 1 dcl 261 set ref 264 264
c_enum_const_dtype                     constant        fixed bin(17,0)          initial dcl 8-25 ref 487
c_enum_dtype                           constant        fixed bin(17,0)          initial dcl 8-25 ref 502
c_indirect_count                000104 automatic       fixed bin(17,0)          array dcl 113 set ref 126* 132* 132 156 157* 157
c_indirect_ix                   000154 automatic       fixed bin(17,0)          dcl 114 set ref 125* 125 126 132 132 154 156 157 157
                                                                                  174 174* 174 185* 218 230
c_symbol_ptr            127            parameter       pointer                  level 2 in structure "val" packed packed unaligned
                                                                                  dcl 434 in procedure "get_factor" set ref 476*
c_symbol_ptr            127            based           pointer                  level 2 in structure "reference_node" packed packed
                                                                                  unaligned dcl 2-16 in procedure "probe_get_expr_"
                                                                                  set ref 529*
c_typeref_dtype                        constant        fixed bin(17,0)          initial dcl 8-25 ref 163 493 496
code                            000100 automatic       fixed bin(35,0)          dcl 85 set ref 183* 207* 234* 239 244* 252* 304* 306
                                                                                  362* 364 419* 421 455 481* 483 526*
constant                               based           structure                level 1 dcl 5-27
cross_section           116(02) 000166 automatic       bit(1)                   level 4 in structure "bsecond_ref_block" packed
                                                                                  packed unaligned dcl 261 in procedure "get_bexpr"
                                                                                  set ref 292
cross_section           116(02)        parameter       bit(1)                   level 3 in structure "first" packed packed unaligned
                                                                                  dcl 319 in procedure "get_expr" set ref 345
cross_section           116(02) 000474 automatic       bit(1)                   level 4 in structure "beta_ref_block" packed packed
                                                                                  unaligned dcl 378 in procedure "get_term" set ref
                                                                                  407
cross_section           116(02) 000100 automatic       bit(1)                   level 4 in structure "second_ref_block" packed
                                                                                  packed unaligned dcl 320 in procedure "get_expr"
                                                                                  set ref 350
cross_section           116(02)        parameter       bit(1)                   level 3 in structure "P_reference" packed packed
                                                                                  unaligned dcl 79 in procedure "probe_get_expr_"
                                                                                  set ref 228
cross_section           116(02)        parameter       bit(1)                   level 3 in structure "bfirst" packed packed
                                                                                  unaligned dcl 260 in procedure "get_bexpr" set ref
                                                                                  287
cross_section           116(02)        parameter       bit(1)                   level 3 in structure "alpha" packed packed unaligned
                                                                                  dcl 377 in procedure "get_term" set ref 402
ct                       13            based           pointer                  level 3 packed packed unaligned dcl 1-18 set ref 129
                                                                                  129 131 134* 134 140* 140 184 187 188 190 192 195
                                                                                  200 200 210 210 210 210* 210 225* 268 268 268 273
                                                                                  275 277 277 277* 277 282 285* 285 326 326 326 330
                                                                                  332 334 334 334* 334 339 342* 342 384 384 384 388
                                                                                  390 392 395* 395 397 399* 399 446 447* 447 448 451
                                                                                  458 461* 461 464 466* 466 468 469* 469
defer_ampersand                 001071 automatic       bit(1)                   packed unaligned dcl 439 set ref 477* 479* 521
end_token                14            based           bit(18)                  level 3 dcl 1-18 ref 129
execute                  64            based           bit(1)                   level 3 packed packed unaligned dcl 1-18 ref 234 296
                                                                                  354 411
first                                  parameter       structure                level 1 dcl 319 set ref 316 325* 359 359 362* 362*
fixed                                                  builtin function         dcl 111 ref 159 163 165 169 487 493 496 498 502 509
                                                                                  511
flags                   116            parameter       structure                level 2 in structure "val" dcl 434 in procedure
                                                                                  "get_factor"
flags                   116            parameter       structure                level 2 in structure "P_reference" dcl 79
                                                                                  in procedure "probe_get_expr_"
flags                   116     000166 automatic       structure                level 3 in structure "bsecond_ref_block" dcl 261
                                                                                  in procedure "get_bexpr"
flags                   116     000474 automatic       structure                level 3 in structure "beta_ref_block" dcl 378
                                                                                  in procedure "get_term"
flags                   116            parameter       structure                level 2 in structure "alpha" dcl 377 in procedure
                                                                                  "get_term"
flags                   116            parameter       structure                level 2 in structure "bfirst" dcl 260 in procedure
                                                                                  "get_bexpr"
flags                   116     000100 automatic       structure                level 3 in structure "second_ref_block" dcl 320
                                                                                  in procedure "get_expr"
flags                   116            parameter       structure                level 2 in structure "first" dcl 319 in procedure
                                                                                  "get_expr"
flags                    64            based           structure                level 2 in structure "probe_info" dcl 1-18
                                                                                  in procedure "probe_get_expr_"
header                                 based           structure                level 2 dcl 5-16
indir_flag                      001070 automatic       bit(1)                   packed unaligned dcl 438 set ref 444* 465* 518
language_type            21            based           fixed bin(17,0)          level 3 dcl 1-18 ref 124 153 192 195 200 268 384 487
                                                                                  493
n_subscripts            122            based           fixed bin(17,0)          level 3 dcl 2-16 set ref 523* 528*
name                     12            based           varying char(256)        level 2 dcl 2-16 set ref 471*
next                                   based           pointer                  level 3 packed packed unaligned dcl 5-16 ref 134 210
                                                                                  277 285 334 342 395 399 447 461 466 469
not_done_indirection            000100 automatic       bit(1)                   packed unaligned dcl 122 set ref 127* 128 136* 138*
null                                                   builtin function         dcl 111 ref 486 491
op_code                         000464 automatic       char(1)                  dcl 321 in procedure "get_expr" set ref 330* 332*
                                                                                  362*
op_code                         000552 automatic       char(1)                  dcl 262 in procedure "get_bexpr" set ref 273* 275*
                                                                                  304*
optional_info           117            based           structure                level 2 dcl 2-16
packed                    0(25)        based           bit(1)                   level 3 in structure "runtime_symbol" packed packed
                                                                                  unaligned dcl 9-3 in procedure "probe_get_expr_"
                                                                                  ref 513
packed                  116            parameter       bit(1)                   level 3 in structure "val" packed packed unaligned
                                                                                  dcl 434 in procedure "get_factor" set ref 513*
pointer_dtype                          constant        fixed bin(17,0)          initial dcl 8-25 ref 218 298 301 356 359 413 416
pre_op_code                     000101 automatic       char(1)                  dcl 86 set ref 180* 188* 190* 192* 198* 218 218 224*
                                                                                  230 234 234*
precision               115            based           fixed bin(35,0)          level 2 in structure "temp_ref" dcl 150 in procedure
                                                                                  "trace_c_indirection" set ref 171*
precision               115            parameter       fixed bin(35,0)          level 2 in structure "val" dcl 434 in procedure
                                                                                  "get_factor" set ref 490* 505* 511*
prev                      1            based           pointer                  level 3 packed packed unaligned dcl 5-16 ref 140
probe_builtins_$addr_builtin    000012 constant        entry                    external dcl 91 ref 526
probe_create_reference_         000032 constant        entry                    external dcl 441 ref 470
probe_create_reference_$init    000010 constant        entry                    external dcl 89 ref 264 323 381
probe_error_$record             000026 constant        entry                    external dcl 109 ref 248
probe_et_$bad_expression        000024 external static fixed bin(35,0)          dcl 103 set ref 207 248*
probe_et_$bad_section           000022 external static fixed bin(35,0)          dcl 103 ref 244
probe_et_$recorded_message      000020 external static fixed bin(35,0)          dcl 103 ref 252
probe_get_$value                000030 constant        entry                    external dcl 435 ref 481
probe_info                             based           structure                level 1 dcl 1-18
probe_info_ptr                  000156 automatic       pointer                  dcl 1-86 set ref 124 129 129 129 131 134 134 140 140
                                                                                  153 181* 184 187 188 190 192 192 195 195 200 200
                                                                                  200 210 210 210 210 210 225 234 234* 248* 264* 268
                                                                                  268 268 268 273 275 277 277 277 277 282 285 285
                                                                                  296 304* 323* 326 326 326 330 332 334 334 334 334
                                                                                  339 342 342 354 362* 381* 384 384 384 384 388 390
                                                                                  392 395 395 397 399 399 411 419* 446 447 447 448
                                                                                  451 458 461 461 464 466 466 468 469 469 470* 481*
                                                                                  487 493 526*
probe_operate_$infix            000014 constant        entry                    external dcl 93 ref 304 362 419
probe_operate_$prefix           000016 constant        entry                    external dcl 98 ref 234
ptr                             001072 automatic       pointer                  array level 2 dcl 440 set ref 522*
ptr_overlay                            based           pointer                  dcl 115 ref 170
random_info              17            based           structure                level 2 dcl 1-18
real_fix_bin_1_dtype                   constant        fixed bin(17,0)          initial dcl 8-25 ref 489 504
ref_block                              based           structure                level 1 dcl 3-12
ref_node                        000474 automatic       structure                level 2 in structure "beta_ref_block" dcl 378
                                                                                  in procedure "get_term" set ref 406* 413 413 419*
ref_node                        000166 automatic       structure                level 2 in structure "bsecond_ref_block" dcl 261
                                                                                  in procedure "get_bexpr" set ref 291* 298 298 304*
ref_node                        000100 automatic       structure                level 2 in structure "second_ref_block" dcl 320
                                                                                  in procedure "get_expr" set ref 349* 356 356 362*
ref_node_ptr                           parameter       pointer                  dcl 149 ref 146 158 159 159 159 163 165 165 165 169
                                                                                  169 170 170 171 171
reference_arg_list                     based           structure                level 1 dcl 2-59
reference_node                         based           structure                level 1 dcl 2-16 set ref 530
reference_subscripts                   based           structure                level 1 dcl 2-64
runtime_symbol                         based           structure                level 1 dcl 9-3
saved_ct                        000102 automatic       pointer                  dcl 87 set ref 184* 225
second_ref_block                000100 automatic       structure                level 1 dcl 320 set ref 323 323
size                      4            based           fixed bin(35,0)          level 2 dcl 9-3 ref 171 511
son                       2(18)        based           bit(18)                  level 2 packed packed unaligned dcl 9-3 ref 158 159
                                                                                  165 498
source_info                            based           structure                level 1 dcl 4-5
source_info_ptr          10            based           pointer                  level 2 in structure "reference_node" dcl 2-16
                                                                                  in procedure "probe_get_expr_" set ref 472*
source_info_ptr          10            parameter       pointer                  level 2 in structure "val" dcl 434 in procedure
                                                                                  "get_factor" set ref 472
sub_refs                        001072 automatic       structure                level 1 dcl 440 set ref 524
subscript_reference_ptrs               based           structure                level 1 dcl 2-69
subscript_refs_ptr      124            based           pointer                  level 2 packed packed unaligned dcl 2-16 set ref
                                                                                  524*
symbol_ptr                             based           pointer                  level 2 in structure "temp_ref" dcl 150 in procedure
                                                                                  "trace_c_indirection" set ref 158 159* 159 159 163
                                                                                  165* 165 165 169 171
symbol_ptr                             parameter       pointer                  level 2 in structure "val" dcl 434 in procedure
                                                                                  "get_factor" set ref 486 487 491* 493 496 498* 498
                                                                                  498 502 509 511 513 529
temp_node_ptr                   001172 automatic       pointer                  dcl 442 set ref 470* 471 472 523 524 526* 528 529
                                                                                  530
temp_ref                               based           structure                level 1 dcl 150
term_op_code                    001060 automatic       char(1)                  dcl 379 set ref 388* 390* 392* 419*
token                                  based           structure                level 1 dcl 5-16
token_header                           based           structure                level 1 dcl 5-4
token_info               12            based           structure                level 2 dcl 1-18
type                    113            parameter       fixed bin(35,0)          level 2 in structure "val" dcl 434 in procedure
                                                                                  "get_factor" set ref 489* 504* 509*
type                    113            parameter       fixed bin(35,0)          level 2 in structure "P_reference" dcl 79
                                                                                  in procedure "probe_get_expr_" set ref 218
type                    113            parameter       fixed bin(35,0)          level 2 in structure "first" dcl 319 in procedure
                                                                                  "get_expr" set ref 359
type                    113            based           fixed bin(35,0)          level 2 in structure "temp_ref" dcl 150 in procedure
                                                                                  "trace_c_indirection" set ref 169*
type                    113     000166 automatic       fixed bin(35,0)          level 3 in structure "bsecond_ref_block" dcl 261
                                                                                  in procedure "get_bexpr" set ref 298
type                    113     000474 automatic       fixed bin(35,0)          level 3 in structure "beta_ref_block" dcl 378
                                                                                  in procedure "get_term" set ref 413
type                      2            based           bit(18)                  level 3 in structure "token" dcl 5-16 in procedure
                                                                                  "probe_get_expr_" ref 129 129 131 187 188 190 192
                                                                                  195 200 200 210 210 210 268 268 268 273 275 277
                                                                                  277 282 326 326 326 330 332 334 334 339 384 384
                                                                                  384 388 390 392 397 446 448 451 458 464 468
type                      0(06)        based           bit(6)                   level 2 in structure "runtime_symbol" packed packed
                                                                                  unaligned dcl 9-3 in procedure "probe_get_expr_"
                                                                                  ref 163 169 487 493 496 502 509
type                    113     000100 automatic       fixed bin(35,0)          level 3 in structure "second_ref_block" dcl 320
                                                                                  in procedure "get_expr" set ref 356
type                    113            parameter       fixed bin(35,0)          level 2 in structure "alpha" dcl 377 in procedure
                                                                                  "get_term" set ref 416
type                    113            parameter       fixed bin(35,0)          level 2 in structure "bfirst" dcl 260 in procedure
                                                                                  "get_bexpr" set ref 301
val                                    parameter       structure                level 1 dcl 434 set ref 431 454* 476 481* 518 518
                                                                                  522 530*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALGOL68_lang_type                      internal static fixed bin(17,0)          initial dcl 7-17
ALM_lang_type                          internal static fixed bin(17,0)          initial dcl 7-17
ARROW                                  internal static bit(18)                  initial dcl 6-17
COBOL_lang_type                        internal static fixed bin(17,0)          initial dcl 7-17
COLON                                  internal static bit(18)                  initial dcl 6-17
COMMA                                  internal static bit(18)                  initial dcl 6-17
CONSTANT_TYPE                          internal static bit(18)                  initial packed unaligned dcl 5-37
C_EQUAL                                internal static bit(18)                  initial dcl 6-17
C_NOT_EQUAL                            internal static bit(18)                  initial dcl 6-17
DOLLAR_SIGN                            internal static bit(18)                  initial dcl 6-17
EQUALS                                 internal static bit(18)                  initial dcl 6-17
FORTRAN_lang_type                      internal static fixed bin(17,0)          initial dcl 7-17
GREATER_THAN                           internal static bit(18)                  initial dcl 6-17
LESS_THAN                              internal static bit(18)                  initial dcl 6-17
NAME_TYPE                              internal static bit(18)                  initial packed unaligned dcl 5-37
NEW_LINE                               internal static bit(18)                  initial dcl 6-17
NOT_EQUALS                             internal static bit(18)                  initial dcl 6-17
NOT_GREATER_THAN                       internal static bit(18)                  initial dcl 6-17
NOT_LESS_THAN                          internal static bit(18)                  initial dcl 6-17
NOT_SIGN                               internal static bit(18)                  initial dcl 6-17
OPERATOR_VALUES                        internal static varying char(4)          initial array dcl 6-43
OR_BAR                                 internal static bit(18)                  initial dcl 6-17
OTHER_lang_type                        internal static fixed bin(17,0)          initial dcl 7-17
PASCAL_ARROW                           internal static bit(18)                  initial dcl 6-17
PASCAL_ASSIGN                          internal static bit(18)                  initial dcl 6-17
PASCAL_RANGE                           internal static bit(18)                  initial dcl 6-17
PERIOD                                 internal static bit(18)                  initial dcl 6-17
PL1_lang_type                          internal static fixed bin(17,0)          initial dcl 7-17
QUESTION_MARK                          internal static bit(18)                  initial dcl 6-17
RIGHT_BRACKET                          internal static bit(18)                  initial dcl 6-17
SEMI_COLON                             internal static bit(18)                  initial dcl 6-17
UNKNOWN_lang_type                      internal static fixed bin(17,0)          initial dcl 7-17
algol68_array_descriptor_dtype         internal static fixed bin(17,0)          initial dcl 8-25
algol68_bits_dtype                     internal static fixed bin(17,0)          initial dcl 8-110
algol68_bool_dtype                     internal static fixed bin(17,0)          initial dcl 8-110
algol68_byte_dtype                     internal static fixed bin(17,0)          initial dcl 8-110
algol68_char_dtype                     internal static fixed bin(17,0)          initial dcl 8-110
algol68_compl_dtype                    internal static fixed bin(17,0)          initial dcl 8-110
algol68_format_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
algol68_int_dtype                      internal static fixed bin(17,0)          initial dcl 8-110
algol68_long_compl_dtype               internal static fixed bin(17,0)          initial dcl 8-110
algol68_long_int_dtype                 internal static fixed bin(17,0)          initial dcl 8-110
algol68_long_real_dtype                internal static fixed bin(17,0)          initial dcl 8-110
algol68_real_dtype                     internal static fixed bin(17,0)          initial dcl 8-110
algol68_short_int_dtype                internal static fixed bin(17,0)          initial dcl 8-110
algol68_straight_dtype                 internal static fixed bin(17,0)          initial dcl 8-25
algol68_struct_struct_bool_dtype       internal static fixed bin(17,0)          initial dcl 8-110
algol68_struct_struct_char_dtype       internal static fixed bin(17,0)          initial dcl 8-110
algol68_union_dtype                    internal static fixed bin(17,0)          initial dcl 8-25
area_dtype                             internal static fixed bin(17,0)          initial dcl 8-25
bit_dtype                              internal static fixed bin(17,0)          initial dcl 8-25
c_union_dtype                          internal static fixed bin(17,0)          initial dcl 8-25
char_dtype                             internal static fixed bin(17,0)          initial dcl 8-25
cobol_char_string_dtype                internal static fixed bin(17,0)          initial dcl 8-25
cobol_comp_5_ts_dtype                  internal static fixed bin(17,0)          initial dcl 8-25
cobol_comp_5_uns_dtype                 internal static fixed bin(17,0)          initial dcl 8-25
cobol_comp_6_dtype                     internal static fixed bin(17,0)          initial dcl 8-25
cobol_comp_7_dtype                     internal static fixed bin(17,0)          initial dcl 8-25
cobol_comp_8_ls_dtype                  internal static fixed bin(17,0)          initial dcl 8-25
cobol_comp_8_uns_dtype                 internal static fixed bin(17,0)          initial dcl 8-25
cobol_display_ls_dtype                 internal static fixed bin(17,0)          initial dcl 8-25
cobol_display_ls_overp_dtype           internal static fixed bin(17,0)          initial dcl 8-25
cobol_display_ts_dtype                 internal static fixed bin(17,0)          initial dcl 8-25
cobol_display_ts_overp_dtype           internal static fixed bin(17,0)          initial dcl 8-25
cobol_display_uns_dtype                internal static fixed bin(17,0)          initial dcl 8-25
cobol_structure_dtype                  internal static fixed bin(17,0)          initial dcl 8-25
cplx_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
cplx_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
cplx_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 8-25
cplx_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
current_constant                       based           structure                level 1 dcl 5-44
current_identifier_name                based           char                     packed unaligned dcl 5-42
current_source                         based           structure                level 1 dcl 4-13
current_token                          based           structure                level 1 dcl 5-45
encoded_value                          based           structure                level 1 dcl 9-70
entry_dtype                            internal static fixed bin(17,0)          initial dcl 8-25
expression_area                        based           area(1024)               dcl 1-95
ext_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 8-125
ext_procedure_runtime_dtype            internal static fixed bin(17,0)          initial dcl 8-125
file_dtype                             internal static fixed bin(17,0)          initial dcl 8-25
ft_char_dtype                          internal static fixed bin(17,0)          initial dcl 8-96
ft_complex_double_dtype                internal static fixed bin(17,0)          initial dcl 8-96
ft_complex_dtype                       internal static fixed bin(17,0)          initial dcl 8-96
ft_double_dtype                        internal static fixed bin(17,0)          initial dcl 8-96
ft_external_dtype                      internal static fixed bin(17,0)          initial dcl 8-96
ft_hex_complex_double_dtype            internal static fixed bin(17,0)          initial dcl 8-96
ft_hex_complex_dtype                   internal static fixed bin(17,0)          initial dcl 8-96
ft_hex_double_dtype                    internal static fixed bin(17,0)          initial dcl 8-96
ft_hex_real_dtype                      internal static fixed bin(17,0)          initial dcl 8-96
ft_integer_dtype                       internal static fixed bin(17,0)          initial dcl 8-96
ft_logical_dtype                       internal static fixed bin(17,0)          initial dcl 8-96
ft_real_dtype                          internal static fixed bin(17,0)          initial dcl 8-96
identifier                             based           structure                level 1 dcl 5-19
initial_source                         based           structure                level 1 dcl 4-14
int_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 8-125
label_constant_runtime_dtype           internal static fixed bin(17,0)          initial dcl 8-125
label_dtype                            internal static fixed bin(17,0)          initial dcl 8-25
official_language_names                internal static char(32)                 initial array packed unaligned dcl 7-27
offset_dtype                           internal static fixed bin(17,0)          initial dcl 8-25
operator                               based           structure                level 1 dcl 5-24
palatable_language_names               internal static char(32)                 initial array packed unaligned dcl 7-30
pascal_boolean_dtype                   internal static fixed bin(17,0)          initial dcl 8-132
pascal_char_dtype                      internal static fixed bin(17,0)          initial dcl 8-132
pascal_entry_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 8-132
pascal_enumerated_type_dtype           internal static fixed bin(17,0)          initial dcl 8-132
pascal_enumerated_type_element_dtype   internal static fixed bin(17,0)          initial dcl 8-132
pascal_enumerated_type_instance_dtype  internal static fixed bin(17,0)          initial dcl 8-132
pascal_exportable_procedure_dtype      internal static fixed bin(17,0)          initial dcl 8-132
pascal_imported_procedure_dtype        internal static fixed bin(17,0)          initial dcl 8-132
pascal_integer_dtype                   internal static fixed bin(17,0)          initial dcl 8-132
pascal_internal_procedure_dtype        internal static fixed bin(17,0)          initial dcl 8-132
pascal_label_dtype                     internal static fixed bin(17,0)          initial dcl 8-132
pascal_parameter_procedure_dtype       internal static fixed bin(17,0)          initial dcl 8-132
pascal_procedure_type_dtype            internal static fixed bin(17,0)          initial dcl 8-132
pascal_real_dtype                      internal static fixed bin(17,0)          initial dcl 8-132
pascal_record_file_type_dtype          internal static fixed bin(17,0)          initial dcl 8-132
pascal_record_type_dtype               internal static fixed bin(17,0)          initial dcl 8-132
pascal_set_dtype                       internal static fixed bin(17,0)          initial dcl 8-132
pascal_string_type_dtype               internal static fixed bin(17,0)          initial dcl 8-132
pascal_text_file_dtype                 internal static fixed bin(17,0)          initial dcl 8-132
pascal_typed_pointer_type_dtype        internal static fixed bin(17,0)          initial dcl 8-132
pascal_user_defined_type_dtype         internal static fixed bin(17,0)          initial dcl 8-132
pascal_user_defined_type_instance_dtype
                                       internal static fixed bin(17,0)          initial dcl 8-132
pascal_value_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 8-132
pascal_variable_formal_parameter_dtype internal static fixed bin(17,0)          initial dcl 8-132
picture_runtime_dtype                  internal static fixed bin(17,0)          initial dcl 8-125
probe_area                             based           area(1024)               dcl 1-93
probe_info_version                     internal static fixed bin(17,0)          initial dcl 1-88
probe_info_version_1                   internal static fixed bin(17,0)          initial dcl 1-90
real_fix_bin_1_uns_dtype               internal static fixed bin(17,0)          initial dcl 8-25
real_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
real_fix_bin_2_uns_dtype               internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_4bit_bytealigned_uns_dtype
                                       internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_4bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_4bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_4bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_9bit_ls_overp_dtype       internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_9bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_9bit_ts_overp_dtype       internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_9bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 8-25
real_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
real_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
real_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 8-25
real_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 8-25
real_flt_dec_4bit_dtype                internal static fixed bin(17,0)          initial dcl 8-25
real_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 8-25
real_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 8-25
real_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 8-25
real_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
real_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
ref_block_ptr                          automatic       pointer                  dcl 3-10
runtime_block                          based           structure                level 1 dcl 9-38
runtime_bound                          based           structure                level 1 unaligned dcl 9-33
runtime_token                          based           structure                level 1 dcl 9-63
scratch_area                           based           area(1024)               dcl 1-92
structure_dtype                        internal static fixed bin(17,0)          initial dcl 8-25
varying_bit_dtype                      internal static fixed bin(17,0)          initial dcl 8-25
varying_char_dtype                     internal static fixed bin(17,0)          initial dcl 8-25
work_area                              based           area(1024)               dcl 1-94

NAMES DECLARED BY EXPLICIT CONTEXT.
GET_EXPR                        000207 constant        label                    dcl 215 ref 226
LOSS                            000314 constant        label                    dcl 239 ref 208 246 306 364 421 455 483
SECTION_LOSS                    000320 constant        label                    dcl 244 set ref 228 287 292 345 350 402 407
SINISTER_ERROR                  000324 constant        label                    dcl 248 ref 448 458
account_for_c_indirection       000355 constant        entry                    internal dcl 119 ref 197 284 341 398 451
get_bexpr                       000533 constant        entry                    internal dcl 257 ref 215
get_expr                        000740 constant        entry                    internal dcl 316 ref 267 291 454
get_factor                      001372 constant        entry                    internal dcl 431 ref 382 406
get_term                        001157 constant        entry                    internal dcl 374 ref 325 349
probe_get_expr_                 000075 constant        entry                    external dcl 50
trace_c_indirection             000433 constant        entry                    internal dcl 146 ref 230 298 301 356 359 413 416 518

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2162        2216    1764        2172
Length      2604    1764        34         351     175           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
probe_get_expr_                     422 external procedure  is an external procedure.  
account_for_c_indirection            68 internal procedure  is called by several nonquick procedures.  
trace_c_indirection                  66 internal procedure  is called by several nonquick procedures.  
get_bexpr                               internal procedure  shares stack frame of external procedure probe_get_expr_.  
get_expr                            704 internal procedure  calls itself recursively.  
get_term                                internal procedure  shares stack frame of internal procedure get_expr.  
get_factor                              internal procedure  shares stack frame of internal procedure get_expr.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
account_for_c_indirection
                         000100 not_done_indirection        account_for_c_indirection
get_expr                 000100 second_ref_block            get_expr
                         000464 op_code                     get_expr
                         000474 beta_ref_block              get_term
                         001060 term_op_code                get_term
                         001070 indir_flag                  get_factor
                         001071 defer_ampersand             get_factor
                         001072 sub_refs                    get_factor
                         001172 temp_node_ptr               get_factor
probe_get_expr_          000100 code                        probe_get_expr_
                         000101 pre_op_code                 probe_get_expr_
                         000102 saved_ct                    probe_get_expr_
                         000104 c_indirect_count            probe_get_expr_
                         000154 c_indirect_ix               probe_get_expr_
                         000156 probe_info_ptr              probe_get_expr_
                         000166 bsecond_ref_block           get_bexpr
                         000552 op_code                     get_bexpr

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          tra_ext_1           ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
probe_builtins_$addr_builtin  probe_create_reference_       probe_create_reference_$init  probe_error_$record
probe_get_$value              probe_operate_$infix          probe_operate_$prefix

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
probe_et_$bad_expression      probe_et_$bad_section         probe_et_$recorded_message




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     50 000071       180 000102       181 000104       182 000110       183 000111       184 000112       185 000114
    187 000115       188 000121       190 000127       192 000134       195 000145       197 000152       198 000156
    199 000160       200 000161       207 000170       208 000172       210 000173       215 000207       218 000216
    224 000235       225 000237       226 000242       228 000243       230 000250       234 000267       239 000314
    242 000317       244 000320       246 000323       248 000324       252 000350       253 000353       119 000354
    124 000362       125 000367       126 000370       127 000372       128 000374       129 000376       131 000410
    132 000412       134 000415       135 000417       136 000420       137 000421       138 000422       139 000423
    140 000424       142 000431       146 000432       153 000440       154 000445       156 000447       157 000454
    158 000456       159 000465       163 000470       165 000503       168 000510       169 000511       170 000514
    171 000517       173 000525       174 000526       176 000532       257 000533       264 000535       267 000550
    268 000557       273 000604       275 000612       277 000616       282 000622       284 000626       285 000632
    287 000637       291 000644       292 000652       296 000655       298 000661       301 000674       304 000711
    306 000733       310 000735       312 000736       316 000737       323 000745       325 000760       326 000767
    330 001011       332 001017       334 001023       339 001027       341 001033       342 001040       345 001045
    349 001055       350 001057       354 001065       356 001072       359 001106       362 001124       364 001147
    368 001155       370 001156       374 001157       381 001161       382 001175       384 001204       388 001222
    390 001227       392 001234       395 001240       397 001242       398 001246       399 001253       402 001260
    406 001270       407 001272       411 001300       413 001305       416 001321       419 001337       421 001362
    426 001370       427 001371       431 001372       444 001374       446 001375       447 001404       448 001406
    451 001416       454 001427       455 001437       458 001445       461 001457       462 001463       464 001464
    465 001466       466 001470       468 001472       469 001477       470 001501       471 001513       472 001521
    476 001525       477 001527       478 001531       479 001532       481 001533       483 001554       486 001562
    487 001567       489 001610       490 001613       491 001615       492 001617       493 001620       496 001626
    498 001642       501 001650       502 001651       504 001655       505 001660       507 001662       509 001663
    511 001667       513 001672       518 001677       521 001713       522 001715       523 001717       524 001722
    526 001724       528 001741       529 001743       530 001747       534 001753


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
