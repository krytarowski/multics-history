	COMPILATION LISTING OF SEGMENT copy_
	Compiled by: Multics PL/I Compiler, Release 33a, of May 30, 1990
	Compiled at: ACTC Technologies Inc.          
	Compiled on: 10/14/90  0920.9 mdt Sun
	    Options: optimize map

        1 /****^  **************************************************************
        2*        *                                                            *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1990      *
        4*        *                                                            *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1983    *
        6*        *                                                            *
        7*        * Copyright, (C) Massachusetts Institute of Technology, 1983 *
        8*        *                                                            *
        9*        ************************************************************** */
       10 
       11 
       12 
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(88-10-03,Flegel), approve(88-11-16,MCR8020), audit(89-01-16,Lee),
       17*     install(89-01-24,MR12.3-1012):
       18*     phx19616 - created procedure change_source_dir, see function header for
       19*                info.
       20*     phx20481 - repaired ioa_ control strings for calls to error and
       21*                warning so that all 3 arguments are properly accounted for.
       22*     phx21214 - reorder the copying of characteristics so that the ACL is
       23*                copied last and the ring_brackets are second last.
       24*  2) change(88-11-10,Flegel), approve(88-12-22,MCR8028), audit(89-01-16,Lee),
       25*     install(89-01-24,MR12.3-1012):
       26*     phx21056 / phx21147 - ignore error_table_$action_not_performed when
       27*                setting max_length and allow suffix_XXX_ to set the
       28*                max_length appropriately when the copy is first perfomed.
       29*  3) change(89-01-31,Flegel), approve(89-03-08,PBF8020), audit(89-03-09,Lee),
       30*     install(89-03-13,MR12.3-1023):
       31*     Post Bug Fix - The call to sub_error_ had control string backwards in
       32*     respect to the pathnames that were to be used based on the value of
       33*     switch.
       34*  4) change(89-11-15,Flegel), approve(89-11-16,MECR0014),
       35*     audit(89-11-15,LZimmerman), install(89-11-16,MR12.3-1118):
       36*     Repair "change_source_dir" subroutine to verify that the target is a real
       37*     directory (which excludes MSFs).
       38*  5) change(89-12-14,Flegel), approve(89-12-14,MCR8151),
       39*     audit(89-12-14,LZimmerman), install(90-04-19,MR12.4-1007):
       40*     Install MECR0014 through regular installation procedures.
       41*  6) change(90-09-04,Huen), approve(90-09-04,MCR8195), audit(90-09-26,Vu),
       42*     install(90-10-14,MR12.4-1039):
       43*     phx21348 (cmds_837) - Fix the error handling of the copy/move commands by
       44*     intercepting the "sub_error" condition.
       45*                                                   END HISTORY COMMENTS */
       46 
       47 
       48 /* format: style2,indcomtxt,idind30 */
       49 
       50 copy_:
       51      proc (P_copy_options_ptr);
       52 
       53 /* This is the primitive used to copy (and move) segments.
       54*
       55*   Jay Pattin 6/2/83 */
       56 
       57 /****
       58*      BIM 830923 rework of object_type_ to fs_util_ */
       59 /**** BIM 831022 split into fs_copy_ and copy_. */
       60 /**** BIM 831031 fixed raw mode to use source type instead of target. */
       61 /**** BIM 1984-07-27 fix copying with the raw switch. */
       62 /**** C Spitzer 841102 fix bug in sub_err_ call */
       63 /**** MSharpe 850206 to check the hcs type of the source before calling nd_handler_ */
       64 
       65 /**** * copy_ is the advertised interface for copying objects.
       66*      copy_ uses fs_util_$copy to copy the contents,
       67*      and then various copy_XXX_ utilities to copy other
       68*      atrributes. In raw mode, it forcibly uses segment or
       69*      msf copying in fs_standard_object_, and does
       70*      attributes appropriately. */
       71 
       72 	declare P_copy_options_ptr	        ptr parameter;
       73 
       74 	declare errsw		        bit (1) aligned;
       75 	declare forced_access	        bit (1) aligned;
       76 	declare max_length		        fixed bin (19);
       77 	declare raw		        bit (1) aligned;
       78 	declare same_dir_sw		        bit (1) aligned;
       79 	declare ring_brackets	        (64) fixed bin (3);
       80 	declare source_dir		        char (168);
       81 	declare source_name		        char (32);
       82 	declare source_type		        char (32);
       83 	declare target_dir		        char (168);
       84 	declare target_name		        char (32);
       85 	declare (source_uid, target_uid)      bit (36) aligned;
       86 	declare fs_type		        char (32);
       87 	declare (source_hcs_type, target_hcs_type)
       88 				        fixed bin (2);
       89 	declare old_source_dir	        char (168);
       90 
       91 	declare 1 bks		        aligned like status_for_backup;
       92 	declare 1 si		        aligned like suffix_info;
       93 	declare 1 cei		        aligned like copy_error_info;
       94 
       95 	declare (
       96 	        error_table_$nonamerr,
       97 	        error_table_$dirseg,
       98 	        error_table_$namedup,
       99 	        error_table_$noentry,
      100 	        error_table_$no_info,
      101 	        error_table_$sameseg,
      102 	        error_table_$segnamedup,
      103 	        error_table_$unimplemented_version,
      104 	        error_table_$unsupported_operation,
      105 	        error_table_$action_not_performed
      106 	        )			        fixed bin (35) external;
      107 
      108 	declare copy_acl_		        entry (char (*), char (*), char (*), char (*), bit (1) aligned,
      109 				        fixed bin (35));
      110 	declare copy_names_		        entry (char (*), char (*), char (*), char (*), char (*), bit (1) aligned,
      111 				        fixed bin (35));
      112 	declare delete_$path	        entry (char (*), char (*), bit (36) aligned, char (*), fixed bin (35));
      113 	declare expand_pathname_	        entry (char (*), char (*), char (*), fixed bin (35));
      114 	declare (
      115 	        hcs_$chname_file,
      116 	        fs_util_$chname_file
      117 	        )			        entry (char (*), char (*), char (*), char (*), fixed bin (35));
      118 	declare hcs_$get_link_target	        entry (char (*), char (*), char (*), char (*), fixed bin (35));
      119 	declare hcs_$get_uid_file	        entry (char (*), char (*), bit (36) aligned, fixed bin (35));
      120 	declare hcs_$status_minf	        entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24),
      121 				        fixed bin (35));
      122 	declare hcs_$set_entry_bound	        entry (char (*), char (*), fixed bin (14), fixed bin (35));
      123 	declare hcs_$status_for_backup        entry (char (*), char (*), ptr, fixed bin (35));
      124 	declare move_names_		        entry (char (*), char (*), char (*), char (*), char (*), bit (1) aligned,
      125 				        fixed bin (35));
      126 	declare nd_handler_$switches	        entry (char (*), char (*), char (*), bit (36) aligned, fixed bin (35));
      127 
      128 	declare get_shortest_path_	        entry (char (*)) returns (char (168));
      129 	declare get_system_free_area_	        entry () returns (ptr);
      130 	declare hcs_$status_	        entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
      131 
      132 	declare 1 entries		        aligned,
      133 		2 (
      134 		copy_entry	        entry (ptr, fixed bin (35)),
      135 	        (get_ml_entry, set_ml_entry)  entry (char (*), char (*), fixed bin (19), fixed bin (35)),
      136 	        (get_rb_entry, set_rb_entry)  entry (char (*), char (*), (*) fixed bin (3), fixed bin (35)),
      137 	        (get_switch_entry, set_switch_entry)
      138 				        entry (char (*), char (*), char (*), bit (1) aligned, fixed bin (35))
      139 	        )			        variable;
      140 
      141 	declare fs_util_$suffix_info_for_type entry (char (*), ptr, fixed bin (35));
      142 	declare fs_util_$get_type	        entry (char (*), char (*), char (*), fixed bin (35));
      143 	declare fs_util_$make_entry_for_type  entry (char (*), char (*), entry, fixed bin (35));
      144 						/*	declare fs_util_$copy	        entry (pointer, fixed bin (35));
      145*						*/
      146 	declare sub_err_		        entry options (variable);
      147 	declare pathname_		        entry (char (*), char (*)) returns (char (168));
      148 	declare code		        fixed bin (35);
      149 
      150 	declare (addr, fixed, rtrim, string, index, length, pointer, substr)
      151 				        builtin;	/* format: off */
      152 
      153  /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
  1     2 
  1     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
  1     4 
  1     5 /* This include file contains branch and link structures returned by
  1     6*   hcs_$status_ and hcs_$status_long. */
  1     7 
  1     8 dcl 1 status_branch aligned based (status_ptr),
  1     9     2 short aligned,
  1    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
  1    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
  1    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
  1    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
  1    14       3 dtu bit (36) unaligned,			/* date/time last used */
  1    15       3 mode bit (5) unaligned,			/* caller's effective access */
  1    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
  1    17       3 pad1 bit (8) unaligned,
  1    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
  1    19 
  1    20 /* Limit of information returned by hcs_$status_ */
  1    21 
  1    22     2 long aligned,
  1    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
  1    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
  1    25       3 lvid bit (36) unaligned,			/* logical volume ID */
  1    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
  1    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
  1    28       3 pad2 bit (8) unaligned,
  1    29       3 copy_switch bit (1) unaligned,			/* copy switch */
  1    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
  1    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
  1    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
  1    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
  1    34       3 pad3 bit (5) unaligned,
  1    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
  1    36       3 uid bit (36) unaligned;			/* unique ID */
  1    37 
  1    38 dcl 1 status_link aligned based (status_ptr),
  1    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
  1    40     2 nnames fixed bin (16) unaligned unsigned,
  1    41     2 names_relp bit (18) unaligned,
  1    42     2 dtem bit (36) unaligned,
  1    43     2 dtd bit (36) unaligned,
  1    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
  1    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
  1    46 
  1    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
  1    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
  1    49 						/* array of names returned */
  1    50      status_pathname character (status_link.pathname_length) aligned
  1    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
  1    52 						/* link target path */
  1    53      status_area_ptr pointer,
  1    54      status_ptr pointer;
  1    55 
  1    56 dcl (Link initial (0),
  1    57      Segment initial (1),
  1    58      Directory initial (2)) fixed bin internal static options (constant);
  1    59 						/* values for type fields declared above */
  1    60 
  1    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
      153 
      154  /* --------------- BEGIN include file status_for_backup.incl.pl1 --------------- */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(86-05-20,Lippard), approve(86-06-02,MCR7427),
  2     6*     audit(86-06-17,Farley), install(86-06-17,MR12.0-1077):
  2     7*      Change non-returned information into pad fields.
  2     8*                                                   END HISTORY COMMENTS */
  2     9 
  2    10 
  2    11 dcl 1 status_for_backup aligned based,
  2    12     2 version fixed bin,
  2    13     2 pad1 bit (108),
  2    14     2 switches unaligned,
  2    15       3 safety bit (1) unaligned,
  2    16       3 entrypt bit (1) unaligned,
  2    17       3 security_oosw bit (1) unaligned,
  2    18       3 audit_flag bit (1) unaligned,
  2    19       3 multiple_class bit (1) unaligned,
  2    20       3 pad2 bit (2) unaligned,
  2    21       3 master_dir bit (1) unaligned,
  2    22       3 tpd bit (1) unaligned,
  2    23       3 pad13 bit (13) unaligned,
  2    24     2 entrypt_bound bit (14) unaligned,
  2    25     2 access_class bit (72),
  2    26     2 spad bit (36),
  2    27     2 author char (32),
  2    28     2 bc_author char (32),
  2    29     2 lvid bit (36),
  2    30     2 pvid bit (36),
  2    31     2 pad3 bit (216);
  2    32 
  2    33 dcl  status_for_backup_version_2 fixed bin initial (2) static options (constant);
  2    34 
  2    35 /* ---------------- END include file status_for_backup.incl.pl1 ---------------- */
      154 
      155  /* BEGIN INCLUDE FILE: suffix_info.incl.pl1 */
  3     2 /* format: style3,indcomtxt,idind30 */
  3     3 /**** Jay Pattin 2/13/83
  3     4*      M. Pandolf 1984.11.30 to set FS_OBJECT_TYPE_MSF to -multisegment_file
  3     5*
  3     6*      The include file copy_flags.incl.pl1 must be included in any program using this include file.
  3     7*
  3     8*      This structure is returned by the suffix_XXX_$suffix_info subroutines */
  3     9 
  3    10 declare   suffix_info_ptr               ptr;
  3    11 
  3    12 declare   1 suffix_info                 aligned based (suffix_info_ptr),
  3    13             2 version                   char (8),
  3    14             2 type                      char (32) unaligned,
  3    15             2 type_name                 char (32) unaligned,          /* Singular name of the object type, e.g. "mailbox" */
  3    16             2 plural_name               char (32) unaligned,          /* Plural of above, e.g. "mailboxes" */
  3    17             2 flags                     unaligned,
  3    18               3 standard_object         bit (1) unaligned,  /* ON if not an extended object (no suffix_XXX_) */
  3    19               3 extended_acl            bit (1) unaligned,  /* ON if uses extended ACLs, off if regular ACLs */
  3    20               3 has_switches            bit (1) unaligned,  /* ON if supports switches for objects */
  3    21               3 mbz1                    bit (33) unaligned,
  3    22             2 modes                     char (36),          /* correspondence between bits and chars for extended modes */
  3    23             2 max_mode_len              fixed bin,          /* maximum number of modes on an object */
  3    24             2 num_ring_brackets         fixed bin,          /* number of ring brackets on object */
  3    25             2 copy_flags                like copy_flags,    /* See copy_flags.incl.pl1 */
  3    26             2 info_pathname             char (168) unaligned;
  3    27                                                             /* pathname of info segment containing more info */
  3    28 
  3    29 declare   SUFFIX_INFO_VERSION_1         char (8) static options (constant) init ("SUFFIX01");
  3    30 
  3    31 /* This information is returned by the suffix_XXX_$list_switches subroutines */
  3    32 
  3    33 declare   switch_list_ptr               ptr,
  3    34           alloc_switch_count            fixed bin,
  3    35           alloc_switch_name_count       fixed bin;
  3    36 
  3    37 declare   1 switch_list                 aligned based (switch_list_ptr),
  3    38             2 version                   char (8),           /* SWITCH_LIST_VERSION_1 */
  3    39             2 switch_count              fixed bin,          /* total number of switches */
  3    40             2 switch_name_count         fixed bin,          /* total number of names */
  3    41             2 switches                  (alloc_switch_count refer (switch_list.switch_count)),
  3    42               3 name_index              fixed bin,          /* index of first name for this switch */
  3    43               3 name_count              fixed bin,          /* number of names for this switch */
  3    44               3 default_value           bit (1) aligned,    /* default setting for this switch */
  3    45               3 mbz1                    bit (36) aligned,   /* reserved for future use */
  3    46             2 names                     (alloc_switch_name_count refer (switch_list.switch_name_count)) char (32);
  3    47 
  3    48 declare   SWITCH_LIST_VERSION_1         char (8) static options (constant) init ("SWLIST01");
  3    49 
  3    50 declare   (
  3    51           FS_OBJECT_TYPE_SEGMENT        init ("-segment"),
  3    52           FS_OBJECT_TYPE_DIRECTORY      init ("-directory"),
  3    53           FS_OBJECT_TYPE_MSF            init ("-multisegment_file"),
  3    54           FS_OBJECT_TYPE_DM_FILE        init ("-dm_file"),
  3    55           FS_OBJECT_TYPE_LINK           init ("-link")
  3    56           )                             char (32) unaligned int static options (constant);
  3    57 
  3    58 /* END INCLUDE FILE: suffix_info.incl.pl1 */
      155 
      156  /* BEGIN INCLUDE FILE: copy_options.incl.pl1 */
  4     2 
  4     3 /* This structure declares the input structure used by the copy_ subroutine.
  4     4*
  4     5*   NOTE: This include file depends on declarations in the include file
  4     6*   copy_flags.incl.pl1.
  4     7*
  4     8*   Jay Pattin 6/1/83 */
  4     9 
  4    10 declare   copy_options_ptr              ptr;
  4    11 
  4    12 declare   1 copy_options                aligned based (copy_options_ptr),
  4    13           2 version                     char (8),           /* currently COPY_OPTIONS_VERSION_1 */
  4    14           2 caller_name                 char (32) unal,     /* Used in nd_handler_ call */
  4    15           2 source_dir                  char (168) unal,
  4    16           2 source_name                 char (32) unal,
  4    17           2 target_dir                  char (168) unal,
  4    18           2 target_name                 char (32) unal,
  4    19           2 flags,
  4    20             3 no_name_dup               bit (1) unaligned,  /* ON = don't call nd_handler_ */
  4    21             3 raw                       bit (1) unaligned,  /* ON = don't call object_type_, use hcs_ */
  4    22             3 force                     bit (1) unaligned,  /* ON = delete or force access to target */
  4    23             3 delete                    bit (1) unaligned,  /* ON = delete original after copy (for move) */
  4    24             3 target_err_switch         bit (1) unaligned,
  4    25             3 mbz                       bit (31) unaligned,
  4    26           2 copy_items                  like copy_flags;    /* see copy_flags.incl.pl1 */
  4    27 
  4    28 declare   COPY_OPTIONS_VERSION_1        char (8) static options (constant) init ("CPOPT001");
  4    29 
  4    30 /* END INCLUDE FILE: copy_options.incl.pl1 */
      156 
      157  /* BEGIN INCLUDE FILE:  copy_flags.incl.pl1 */
  5     2 
  5     3 /* Flags for attributes that should/may be copied by the copy_ subroutine. This include file is
  5     4*   required by suffix_info.incl.pl1 and copy_options.incl.pl1
  5     5*
  5     6*   Jay Pattin 6/23/83 */
  5     7 
  5     8 declare   1 copy_flags                  aligned based,      /* ON means that this attribute may be copied by copy_ */
  5     9           2 names                       bit (1) unaligned,
  5    10           2 acl                         bit (1) unaligned,
  5    11           2 ring_brackets               bit (1) unaligned,
  5    12           2 max_length                  bit (1) unaligned,
  5    13           2 copy_switch                 bit (1) unaligned,
  5    14           2 safety_switch               bit (1) unaligned,
  5    15           2 dumper_switches             bit (1) unaligned,
  5    16           2 entry_bound                 bit (1) unaligned,  /* only for vanilla object segments */
  5    17           2 extend                      bit (1) unaligned,  /* copy_ may append to end of existing object */
  5    18           2 update                      bit (1) unaligned,  /* copy_ may replace contents of existing object */
  5    19           2 mbz                         bit (26) unaligned;
  5    20 
  5    21 /* END INCLUDE FILE:  copy_flags.incl.pl1 */
      157 
      158  /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  6     2*
  6     3*   Values for the "access mode" argument so often used in hardcore
  6     4*   James R. Davis 26 Jan 81  MCR 4844
  6     5*   Added constants for SM access 4/28/82 Jay Pattin
  6     6*   Added text strings 03/19/85 Chris Jones
  6     7**/
  6     8 
  6     9 
  6    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  6    11 dcl	(
  6    12 	N_ACCESS		   init ("000"b),
  6    13 	R_ACCESS		   init ("100"b),
  6    14 	E_ACCESS		   init ("010"b),
  6    15 	W_ACCESS		   init ("001"b),
  6    16 	RE_ACCESS		   init ("110"b),
  6    17 	REW_ACCESS	   init ("111"b),
  6    18 	RW_ACCESS		   init ("101"b),
  6    19 	S_ACCESS		   init ("100"b),
  6    20 	M_ACCESS		   init ("010"b),
  6    21 	A_ACCESS		   init ("001"b),
  6    22 	SA_ACCESS		   init ("101"b),
  6    23 	SM_ACCESS		   init ("110"b),
  6    24 	SMA_ACCESS	   init ("111"b)
  6    25 	)		   bit (3) internal static options (constant);
  6    26 
  6    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  6    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  6    29 
  6    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  6    31 			   static options (constant);
  6    32 
  6    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  6    34 			   static options (constant);
  6    35 
  6    36 dcl	(
  6    37 	N_ACCESS_BIN	   init (00000b),
  6    38 	R_ACCESS_BIN	   init (01000b),
  6    39 	E_ACCESS_BIN	   init (00100b),
  6    40 	W_ACCESS_BIN	   init (00010b),
  6    41 	RW_ACCESS_BIN	   init (01010b),
  6    42 	RE_ACCESS_BIN	   init (01100b),
  6    43 	REW_ACCESS_BIN	   init (01110b),
  6    44 	S_ACCESS_BIN	   init (01000b),
  6    45 	M_ACCESS_BIN	   init (00010b),
  6    46 	A_ACCESS_BIN	   init (00001b),
  6    47 	SA_ACCESS_BIN	   init (01001b),
  6    48 	SM_ACCESS_BIN	   init (01010b),
  6    49 	SMA_ACCESS_BIN	   init (01011b)
  6    50 	)		   fixed bin (5) internal static options (constant);
  6    51 
  6    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      158 
      159  /* BEGIN INCLUDE FILE:  delete_options.incl.pl1 */
  7     2 
  7     3 /* control flag bit string passed to delete_$path and delete_$ptr
  7     4*
  7     5*   Jay Pattin 6/6/83 */
  7     6 
  7     7 declare   1 delete_options,
  7     8           2 force                       bit (1) unaligned,  /* ON = delete w/o asking is safety switch on */
  7     9           2 question                    bit (1) unaligned,  /* ON = ask user if safety switch on */
  7    10           2 directory                   bit (1) unaligned,  /* ON = delete directories */
  7    11           2 segment                     bit (1) unaligned,  /* ON = delete segments */
  7    12           2 link                        bit (1) unaligned,  /* ON = delete links */
  7    13           2 chase                       bit (1) unaligned,  /* ON = delete through links */
  7    14           2 library                     bit (1) unaligned,  /* ON = use installation_tools_ */
  7    15           2 raw                         bit (1) unaligned,  /* ON = use hcs_, not object_type_ */
  7    16           2 mbz                         bit (28) unaligned;
  7    17 
  7    18 /* END INCLUDE FILE:  delete_options.incl.pl1 */
      159 
      160  /* BEGIN INCLUDE FILE: nd_handler_options.incl.pl1 */
  8     2 
  8     3 /* This structure is used as the switches argument to nd_handler_$switches
  8     4*
  8     5*   Jay Pattin 2/27/83 */
  8     6 
  8     7 declare   1 nd_handler_options,
  8     8           2 force                       bit (1) unaligned,  /* ON = delete without query if removing last name */
  8     9           2 delete                      bit (1) unaligned,  /* ON = query to delete regardless of number of names */
  8    10           2 delete_force                bit (1) unaligned,  /* ON = always delete without query */
  8    11           2 raw                         bit (1) unaligned,  /* ON = call hcs_, not object_type_ */
  8    12           2 library                     bit (1) unaligned,  /* ON = call installation_tools_ for chname */
  8    13           2 mbz                         bit (31) unaligned;
  8    14 
  8    15 /* END INCLUDE FILE: nd_handler_options.incl.pl1 */
      160 
      161  /* BEGIN INCLUDE FILE sub_error_info.incl.pl1 */
  9     2 /* format: style2 */
  9     3 
  9     4 /* The include file condition_info_header must be used with this file */
  9     5 
  9     6      declare sub_error_info_ptr     pointer;
  9     7      declare 1 sub_error_info	      aligned based (sub_error_info_ptr),
  9     8 	     2 header	      aligned like condition_info_header,
  9     9 	     2 retval	      fixed bin (35),	/* return value */
  9    10 	     2 name	      char (32),		/* module name */
  9    11 	     2 info_ptr	      ptr;
  9    12 
  9    13      declare sub_error_info_version_1
  9    14 			      internal static options (constant) fixed bin init (1);
  9    15 
  9    16 /* END INCLUDE FILE sub_error_info.incl.pl1 */
      161 
      162  /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
 10     2 /* format: style3 */
 10     3 
 10     4 /* These constants are to be used for the flags argument of sub_err_ */
 10     5 /* They are just "string (condition_info_header.action_flags)" */
 10     6 
 10     7 declare	(
 10     8 	ACTION_CAN_RESTART	init (""b),
 10     9 	ACTION_CANT_RESTART init ("1"b),
 10    10 	ACTION_DEFAULT_RESTART
 10    11 			init ("01"b),
 10    12 	ACTION_QUIET_RESTART
 10    13 			init ("001"b),
 10    14 	ACTION_SUPPORT_SIGNAL
 10    15 			init ("0001"b)
 10    16 	)		bit (36) aligned internal static options (constant);
 10    17 
 10    18 /* End include file */
      162 
      163  /* BEGIN INCLUDE FILE condition_info_header.incl.pl1 BIM 1981 */
 11     2 /* format: style2 */
 11     3 
 11     4      declare condition_info_header_ptr
 11     5 			      pointer;
 11     6      declare 1 condition_info_header
 11     7 			      aligned based (condition_info_header_ptr),
 11     8 	     2 length	      fixed bin,		/* length in words of this structure */
 11     9 	     2 version	      fixed bin,		/* version number of this structure */
 11    10 	     2 action_flags	      aligned,		/* tell handler how to proceed */
 11    11 	       3 cant_restart     bit (1) unaligned,	/* caller doesn't ever want to be returned to */
 11    12 	       3 default_restart  bit (1) unaligned,	/* caller can be returned to with no further action */
 11    13 	       3 quiet_restart    bit (1) unaligned,	/* return, and print no message */
 11    14 	       3 support_signal   bit (1) unaligned,	/* treat this signal as if the signalling procedure had the support bit set */
 11    15 						/* if the signalling procedure had the support bit set, do the same for its caller */
 11    16 	       3 pad	      bit (32) unaligned,
 11    17 	     2 info_string	      char (256) varying,	/* may contain printable message */
 11    18 	     2 status_code	      fixed bin (35);	/* if^=0, code interpretable by com_err_ */
 11    19 
 11    20 /* END INCLUDE FILE condition_info_header.incl.pl1 */
      163 
      164  /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
 12     2 
 12     3 /* Structure for find_condition_info_.
 12     4*
 12     5*   Written 1-Mar-79 by M. N. Davidoff.
 12     6**/
 12     7 
 12     8 /* automatic */
 12     9 
 12    10      declare condition_info_ptr     pointer;
 12    11 
 12    12 /* based */
 12    13 
 12    14      declare 1 condition_info	      aligned based (condition_info_ptr),
 12    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
 12    16 	     2 version	      fixed binary,		/* Must be 1 */
 12    17 	     2 condition_name     char (32) varying,	/* name of condition */
 12    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
 12    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
 12    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
 12    21 	     2 flags	      unaligned,
 12    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
 12    23 	       3 pad1	      bit (35),
 12    24 	     2 pad2	      bit (36),
 12    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
 12    26 	     2 pad3	      (4) bit (36);
 12    27 
 12    28 /* internal static */
 12    29 
 12    30      declare condition_info_version_1
 12    31 			      fixed binary internal static options (constant) initial (1);
 12    32 
 12    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
      164 
      165  /* BEGIN INCLUDE FILE:  copy_error_info.incl.pl1
 13     2*
 13     3*   This is the structure pointed to by sub_error_info.info_ptr when copy_
 13     4*   signals the sub_err_ condition.
 13     5*
 13     6*   Jay Pattin 6/13/83 */
 13     7 
 13     8 declare   1 copy_error_info             aligned based (sub_error_info.info_ptr),
 13     9           2 copy_options_ptr            ptr,                /* Pointer to input argument of copy_ */
 13    10           2 operation                   char (32),          /* Name of operation that failed. */
 13    11           2 target_err_switch           bit (1) aligned;    /* ON = error was on the target */
 13    12 
 13    13 /* END INCLUDE FILE:  copy_error_info.incl.pl1 */
      165 
      166  /* Begin include file file_system_operations.incl.pl1 BIM 8309 */
 14     2 /* format: style3,indcomtxt,idind30 */
 14     3 
 14     4 /**** Operation names to be passed to fs_util_$make_entry */
 14     5 
 14     6 declare   (
 14     7           FS_ADD_ACL_ENTRIES            init ("add_acl_entries"),
 14     8           FS_ADD_EXTENDED_ACL_ENTRIES   init ("add_extended_acl_entries"),
 14     9           FS_CHNAME_FILE                init ("chname_file"),
 14    10           FS_COPY                       init ("copy"),
 14    11           FS_DELENTRY_FILE              init ("delentry_file"),
 14    12           FS_DELETE_ACL_ENTRIES         init ("delete_acl_entries"),
 14    13           FS_GET_BIT_COUNT              init ("get_bit_count"),
 14    14           FS_GET_MAX_LENGTH             init ("get_max_length"),
 14    15           FS_GET_RING_BRACKETS          init ("get_ring_brackets"),
 14    16           FS_GET_SWITCH                 init ("get_switch"),
 14    17           FS_GET_USER_ACCESS_MODES      init ("get_user_access_modes"),
 14    18           FS_LIST_ACL                   init ("list_acl"),
 14    19           FS_LIST_EXTENDED_ACL          init ("list_extended_acl"),
 14    20           FS_LIST_SWITCHES              init ("list_switches"),
 14    21           FS_REPLACE_ACL                init ("replace_acl"),
 14    22           FS_REPLACE_EXTENDED_ACL       init ("replace_extended_acl"),
 14    23           FS_SET_BIT_COUNT              init ("set_bit_count"),
 14    24           FS_SET_MAX_LENGTH             init ("set_max_length"),
 14    25           FS_SET_RING_BRACKETS          init ("set_ring_brackets"),
 14    26           FS_SET_SWITCH                 init ("set_switch"),
 14    27           FS_SUFFIX_INFO                init ("suffix_info"),
 14    28           FS_VALIDATE                   init ("validate")
 14    29           )                             char (64) int static options (constant);
 14    30 
 14    31 /* End include file file_system_operations.incl.pl1 */
      166 
      167 /* format: on */
      168 
      169 
      170 
      171 	entries = Dummy_Procedure;			/* aggregately */
      172 	old_source_dir = "";			/* No source dir change */
      173 	copy_options_ptr = P_copy_options_ptr;
      174 	if copy_options.version ^= COPY_OPTIONS_VERSION_1
      175 	then call copy_error (error_table_$unimplemented_version, "0"b);
      176 
      177 	if copy_options.extend & copy_options.update
      178 	then call fatal (0, "contents", "0"b, "The extend and update switches may not both be specified.");
      179 
      180 	source_dir = copy_options.source_dir;
      181 	source_name = copy_options.source_name;
      182 	target_dir = copy_options.target_dir;
      183 	target_name = copy_options.target_name;
      184 
      185 	raw = copy_options.raw;
      186 	forced_access = "0"b;
      187 
      188 	call hcs_$status_minf (source_dir, source_name, 1 /* chase */, source_hcs_type, (0), code);
      189 	if code ^= 0
      190 	then if code ^= error_table_$no_info		/* may not be true for inner-ring entries;
      191*						   fs_util_$get_type will catch this anyway */
      192 	     then call copy_error (code, "0"b);
      193 
      194 	call fs_util_$get_type (source_dir, source_name, source_type, code);
      195 	if code = 0 & source_type = FS_OBJECT_TYPE_DIRECTORY
      196 	then code = error_table_$dirseg;
      197 	if code ^= 0
      198 	then call copy_error (code, "0"b);
      199 
      200 	call hcs_$status_minf (target_dir, target_name, 0, target_hcs_type, (0), code);
      201 						/* does target already exist? */
      202 	if code = error_table_$noentry
      203 	then /* Has to if updating or extending */
      204 	     if copy_options.extend | copy_options.update
      205 	     then call copy_error (code, "1"b);
      206 	     else ;
      207 	else do;					/* check if source = target */
      208 		if code ^= 0
      209 		then call copy_error (code, "1"b);
      210 		call hcs_$get_uid_file (source_dir, source_name, source_uid, (0));
      211 		call hcs_$get_uid_file (target_dir, target_name, target_uid, (0));
      212 		if source_uid = target_uid
      213 		then if target_hcs_type ^= Link
      214 		     then call copy_error (error_table_$sameseg, "1"b);
      215 		     else do;			/* in case we delete the link, get real source path */
      216 			     call hcs_$get_link_target (copy_options.source_dir, copy_options.source_name,
      217 				source_dir, source_name, code);
      218 			     if code ^= 0
      219 			     then call copy_error (code, "0"b);
      220 
      221 			     copy_options.source_dir = source_dir;
      222 			     copy_options.source_name = source_name;
      223 			end;
      224 
      225 		if ^copy_options.no_name_dup & ^copy_options.extend & ^copy_options.update
      226 		then do;
      227 
      228 /* MF - phx19616 - make sure pathname in source will not change */
      229 
      230 			call change_source_dir ();
      231 			string (nd_handler_options) = ""b;
      232 			nd_handler_options.delete_force = copy_options.force;
      233 			nd_handler_options.raw = raw;
      234 			call nd_handler_$switches (copy_options.caller_name, target_dir, target_name,
      235 			     string (nd_handler_options), code);
      236 			if code ^= 0
      237 			then do;
      238 				if code = error_table_$action_not_performed
      239 				then code = error_table_$namedup;
      240 				call copy_error (code, "1"b);
      241 			     end;
      242 		     end;
      243 	     end;					/* name duplication */
      244 
      245 	if raw
      246 	then /* we could use a GET_REAL_TYPE, ... */
      247 	     if source_hcs_type = Segment
      248 	     then fs_type = FS_OBJECT_TYPE_SEGMENT;
      249 	     else fs_type = FS_OBJECT_TYPE_MSF;
      250 	else fs_type = source_type;
      251 
      252 	call fs_util_$make_entry_for_type (fs_type, FS_COPY, copy_entry, (0));
      253 	call fs_util_$make_entry_for_type (fs_type, FS_GET_RING_BRACKETS, get_rb_entry, (0));
      254 	call fs_util_$make_entry_for_type (fs_type, FS_SET_RING_BRACKETS, set_rb_entry, (0));
      255 	call fs_util_$make_entry_for_type (fs_type, FS_GET_MAX_LENGTH, get_ml_entry, (0));
      256 	call fs_util_$make_entry_for_type (fs_type, FS_SET_MAX_LENGTH, set_ml_entry, (0));
      257 	call fs_util_$make_entry_for_type (fs_type, FS_GET_SWITCH, get_switch_entry, (0));
      258 	call fs_util_$make_entry_for_type (fs_type, FS_SET_SWITCH, set_switch_entry, (0));
      259 
      260 	si.version = SUFFIX_INFO_VERSION_1;
      261 	call fs_util_$suffix_info_for_type (fs_type, addr (si), code);
      262 	if code ^= 0
      263 	then call copy_error (code, "0"b);
      264 
      265 	if (copy_options.extend & ^si.copy_flags.extend) | (copy_options.update & ^si.copy_flags.update)
      266 	then call copy_error (error_table_$unsupported_operation, "0"b);
      267 
      268 /* phx21348 - use original if no source dir change */
      269 	if (old_source_dir = "") /* No source_dir change */
      270 	     then call copy_entry (copy_options_ptr, code);     /* Grab the contents */
      271 	else begin; /* pass modified copy of struc that contains a valid source_dir */
      272 /* MF - phx19616 - need to use a local version of copy_options so we don't
      273*   * change the original passed into us when there is a source_dir change */
      274 	declare 1 co		        aligned like copy_options;
      275 	declare sub_error_		        condition;
      276 	     co = copy_options;
      277 	     co.source_dir = source_dir;     /* source_dir change */
      278 
      279 /* phx21348 - If the sub_error_ condition occurs and the error was caused
      280* * using the modifed copy of the copy_options struc (co) then we patch
      281* * copy_error_info.copy_options_ptr to point back to the original version.
      282* * This is necessary because the handler in the 'copy' command uses this
      283* * value to determine whether to handle the condition. */
      284                on sub_error_  begin;
      285 		declare 1 ci                          aligned like condition_info;
      286 		declare continue_to_signal_           entry (fixed bin(35));
      287 		declare find_condition_info_	        entry (ptr, ptr, fixed bin(35));
      288 		declare null                          builtin;
      289 
      290 		ci.version = condition_info_version_1;
      291 		call find_condition_info_ (null (), addr (ci), (0));
      292 		sub_error_info_ptr = ci.info_ptr;
      293 		if sub_error_info.name = "copy_" &
      294 		   copy_error_info.copy_options_ptr = addr(co) then
      295 		     copy_error_info.copy_options_ptr = P_copy_options_ptr;
      296 	          call continue_to_signal_ ((0));
      297 	     end;	/* of sub_error_ patch handler */
      298 
      299 	     call copy_entry (addr (co), code);	      /* Grab the contents */
      300 	end;
      301 	if code ^= 0
      302 	then call copy_error (code, (copy_options.target_err_switch));
      303 
      304 /* MF - phx21214 - reorganized the characteristic copying section so that
      305*   * the ACL is last (except for source deletion) and the ring_brackets are
      306*   * second last. */
      307 
      308 	if copy_options.max_length
      309 	then if ^si.copy_flags.max_length
      310 	     then call unsup ("max length");
      311 	     else do;
      312 		     call get_ml_entry (source_dir, source_name, max_length, code);
      313 		     if code ^= 0
      314 		     then call error (code, "max length", "0"b, "Getting max length on ^[^s^a^;^a^s^].");
      315 		     else do;
      316 			     call set_ml_entry (target_dir, target_name, max_length, code);
      317 
      318 /* MF - phx21056 - ignore action_not_performed error code */
      319 
      320 			     if code ^= 0 & code ^= error_table_$action_not_performed
      321 			     then call error (code, "max length", "1"b, "Setting max length on ^[^s^a^;^a^s^].");
      322 			end;
      323 		end;
      324 
      325 	if copy_options.copy_switch
      326 	then if ^si.copy_flags.copy_switch
      327 	     then call unsup ("copy switch");
      328 	     else call copy_switch ("copy");
      329 
      330 	if copy_options.safety_switch
      331 	then if ^si.copy_flags.safety_switch
      332 	     then call unsup ("safety switch");
      333 	     else call copy_switch ("safety");
      334 
      335 	if copy_options.dumper_switches
      336 	then if ^si.copy_flags.dumper_switches
      337 	     then call unsup ("dumper switches");
      338 	     else do;
      339 		     call copy_switch ("complete_volume_dump");
      340 		     call copy_switch ("incremental_volume_dump");
      341 		end;
      342 	if copy_options.entry_bound
      343 	then do;
      344 		if fs_type ^= FS_OBJECT_TYPE_SEGMENT
      345 		then goto NOT_GATE;
      346 		bks.version = status_for_backup_version_2;
      347 		call hcs_$status_for_backup (source_dir, source_name, addr (bks), code);
      348 		if code ^= 0
      349 		then call error (code, "entry bound", "0"b, "Getting entry bound on ^[^s^a^;^a^s^].");
      350 		else if ^bks.entrypt
      351 		then
      352 NOT_GATE:
      353 		     call error (error_table_$unsupported_operation, "entry bound", "0"b,
      354 			"Entry has no entry bound to copy. ^[^s^a^;^a^s^]");
      355 		else do;
      356 			call hcs_$set_entry_bound (target_dir, target_name, fixed (bks.entrypt_bound), code);
      357 			if code ^= 0
      358 			then call error (code, "entry bound", "1"b, "Setting entry bound on ^[^s^a^;^a^s^].");
      359 		     end;
      360 	     end;
      361 
      362 	if copy_options.ring_brackets
      363 	then if ^si.copy_flags.ring_brackets
      364 	     then call unsup ("ring brackets");
      365 	     else do;
      366 		     call get_rb_entry (source_dir, source_name, ring_brackets, code);
      367 		     if code ^= 0
      368 		     then call error (code, "ring brackets", "0"b, "Getting ring brackets on ^[^s^a^;^a^s^].");
      369 		     else do;
      370 			     call set_rb_entry (target_dir, target_name, ring_brackets, code);
      371 			     if code ^= 0
      372 			     then call error (code, "ring brackets", "1"b,
      373 				     "Setting ring brackets on ^[^s^a^;^a^s^].");
      374 			end;
      375 		end;
      376 
      377 /**** NOTE -- since we don't have copy_XXX_$raw yet, we have to skip these! */
      378 
      379 	if ^raw
      380 	then do;
      381 		if copy_options.acl
      382 		then if ^si.copy_flags.acl
      383 		     then call unsup ("ACL");
      384 		     else do;
      385 			     call copy_acl_ (source_dir, source_name, target_dir, target_name, errsw, code);
      386 			     if code ^= 0
      387 			     then call error (code, "ACL", errsw, "Copying ACL ^[from ^a^s^;to ^s^a^].");
      388 			end;
      389 
      390 		if copy_options.names
      391 		then if ^si.copy_flags.names
      392 		     then call unsup ("names");
      393 		     else do;
      394 			     same_dir_sw = same_dirp ();
      395 			     if same_dir_sw
      396 			     then do;		/* If in same dir, have to move names */
      397 				     if ^copy_options.delete
      398 				     then call warning (0, "names", "1"b,
      399 					     "Source and target are in the same directory. Names will be moved instead of copied."
      400 					     );
      401 				     call move_names_ (source_dir, source_name, target_dir, target_name,
      402 					copy_options.caller_name, errsw, code);
      403 				end;
      404 			     else call copy_names_ (source_dir, source_name, target_dir, target_name,
      405 				     copy_options.caller_name, errsw, code);
      406 
      407 			     if code ^= 0 & code ^= error_table_$namedup & code ^= error_table_$segnamedup
      408 			     then call error (code, "names", errsw, "Copying names ^[from ^a^s^;to ^s^a^].");
      409 			end;
      410 
      411 	     end;
      412 
      413 	if copy_options.delete
      414 	then do;
      415 		string (delete_options) = ""b;
      416 		delete_options.segment, delete_options.link, delete_options.chase, delete_options.question = "1"b;
      417 		delete_options.force = copy_options.force;
      418 		delete_options.raw = raw;
      419 		call delete_$path (source_dir, source_name, string (delete_options), copy_options.caller_name, code);
      420 		if code ^= 0
      421 		then if code ^= error_table_$action_not_performed
      422 		     then call error (code, "delete", "0"b, "Deleting ^[^s^a^;^a^s^].");
      423 
      424 		if copy_options.names & same_dir_sw
      425 		then do;
      426 			if raw
      427 			then call hcs_$chname_file (target_dir, target_name, "", source_name, code);
      428 			else call fs_util_$chname_file (target_dir, target_name, "", source_name, code);
      429 			if code ^= 0
      430 			then call error (code, "names", "1"b, "Copying names to ^[^s^a^;^a^s^].");
      431 		     end;
      432 	     end;
      433 
      434 MAIN_RETURN:
      435 	return;
      436 
      437 same_dirp:
      438      proc returns (bit (1) aligned);
      439 
      440 	declare dir_dir		        char (168),
      441 	        dir_ent		        char (32);
      442 
      443 	if source_dir = target_dir
      444 	then return ("1"b);
      445 
      446 	call expand_pathname_ (source_dir, dir_dir, dir_ent, (0));
      447 	call hcs_$get_uid_file (dir_dir, dir_ent, source_uid, (0));
      448 
      449 	call expand_pathname_ (target_dir, dir_dir, dir_ent, (0));
      450 	call hcs_$get_uid_file (dir_dir, dir_ent, target_uid, (0));
      451 
      452 	return (source_uid = target_uid);
      453      end same_dirp;
      454 
      455 
      456 copy_switch:
      457      proc (switch_name);
      458 
      459 	declare switch_name		        char (*),
      460 	        value		        bit (1) aligned;
      461 
      462 	call get_switch_entry (source_dir, source_name, switch_name, value, code);
      463 	if code ^= 0
      464 	then call error (code, rtrim (switch_name) || "switch", "0"b, "Getting switch from ^[^s^a^;^a^s^].");
      465 	else do;
      466 		call set_switch_entry (target_dir, target_name, switch_name, value, code);
      467 		if code ^= 0
      468 		then call error (code, rtrim (switch_name) || "switch", "1"b, "Setting switch on ^[^s^a^;^a^s^].");
      469 	     end;
      470 
      471 	return;
      472      end copy_switch;
      473 
      474 change_source_dir:
      475      proc ();
      476 
      477 /* FUNCTION
      478*
      479*   phx19616 - Determine whether or not there will be a conflict in names
      480*   between a target pathname and some component of the source directory.  If
      481*   there is, then the source dir will be changed so that a new name is inserted
      482*   where the conflict occurs.  If there are no other names to use, then it will
      483*   merely return to let nd_handler and the user resolve what to do.
      484**/
      485 
      486 /* MISC VARIABLES */
      487 	declare short_target_path	        char (168) var;
      488 	declare short_target_dir	        char (168) var;
      489 	declare short_source_dir	        char (168) var;
      490 	declare target_type		        char (32);
      491 	declare done		        bit (1);
      492 	declare i			        fixed bin;
      493 	declare 1 sb		        aligned like status_branch;
      494 
      495 /* INIT */
      496 	short_target_dir = rtrim (get_shortest_path_ (target_dir));
      497 	short_source_dir = rtrim (get_shortest_path_ (source_dir));
      498 	short_target_path = rtrim (pathname_ (rtrim (short_target_dir), target_name));
      499 
      500 /* MAIN */
      501 
      502 /* Find out what type of file we are targetting to */
      503 
      504 	call fs_util_$get_type (target_dir, target_name, target_type, code);
      505 	if (code ^= 0) then do;
      506 	     call error (code, "copy_", "1"b, "Getting file system type of ^[^s^a^;^a^s^]");
      507 	     return;
      508 	end;
      509 
      510 /* A target DIRECTORY contained in the source DIRECTORY is potential */
      511 
      512 	if (target_type = FS_OBJECT_TYPE_DIRECTORY)
      513 	     & (index (short_source_dir, short_target_path) > 0)
      514 	then do;
      515 		status_ptr = addr (sb);
      516 		status_area_ptr = get_system_free_area_ ();
      517 
      518 		call hcs_$status_ (target_dir, target_name, 0, status_ptr, status_area_ptr, code);
      519 		if (code ^= 0)
      520 		then call error (code, "status", "0"b, "Getting status on ^[^s^a^;^a^s^]");
      521 
      522 		done = "0"b;			/* Is there really a contention? */
      523 		do i = 1 to status_branch.short.nnames;
      524 		     if status_entry_names (i) = target_name
      525 		     then do;			/* Found, so get out of the loop */
      526 			     done = "1"b;
      527 			     i = status_branch.short.nnames;
      528 			end;
      529 		end;
      530 		if ^done
      531 		then do;				/* No, then get out */
      532 			free status_entry_names;
      533 			return;
      534 		     end;
      535 
      536 		i = 1;				/* Look for another name to use */
      537 		done = "0"b;
      538 		do while (^done);
      539 		     if (i > status_branch.short.nnames)
      540 		     then /* None at all */
      541 			done = "1"b;
      542 		     else if (status_entry_names (i) ^= target_name)
      543 		     then /* Found */
      544 			done = "1"b;
      545 		     else /* Keep trying */
      546 			i = i + 1;
      547 		end;
      548 
      549 		if (i > status_branch.short.nnames)
      550 		then do;				/* Oh-oh, can't continue */
      551 			free status_entry_names;
      552 			call fatal (error_table_$nonamerr, "copy_", "1"b,
      553 			     "^s^s^a. Source will be deleted before copy completed.");
      554 			return;
      555 		     end;
      556 
      557 /* Rearrange the names so that there will be no contention */
      558 
      559 		old_source_dir = source_dir;
      560 		source_dir = short_target_dir || ">" || rtrim (status_entry_names (i));
      561 		if length (short_target_path) < length (short_source_dir)
      562 		then source_dir = rtrim (source_dir) || substr (short_source_dir, length (short_target_path) + 1);
      563 
      564 		free status_entry_names;
      565 	     end;
      566 
      567      end change_source_dir;
      568 
      569 
      570 
      571 copy_error:
      572      proc (status, switch);
      573 
      574 	declare status		        fixed bin (35),
      575 	        switch		        bit (1) aligned;
      576 
      577 	cei.copy_options_ptr = copy_options_ptr;
      578 	cei.operation = "contents";
      579 	cei.target_err_switch = switch;
      580 
      581 	do while ("1"b);
      582 	     call sub_err_ (status, "copy_", ACTION_CANT_RESTART, addr (cei), (0), "^[^a^s^;^s^a^]", switch,
      583 		pathname_ (target_dir, target_name), pathname_ (source_dir, source_name));
      584 
      585 	end;
      586 
      587      end copy_error;
      588 
      589 unsup:
      590      proc (op);
      591 
      592 	declare op		        char (32);
      593 
      594 	cei.copy_options_ptr = copy_options_ptr;
      595 	cei.operation = op;
      596 	cei.target_err_switch = "0"b;
      597 
      598 	call sub_err_ (error_table_$unsupported_operation, "copy_", ACTION_CAN_RESTART, addr (cei), (0),
      599 	     "The ^a object type does not support the copying of ^a. ^a", si.type_name, op,
      600 	     pathname_ (source_dir, source_name));
      601 
      602 	return;
      603      end unsup;
      604 
      605 
      606 error:
      607      proc (status, op, switch, message);
      608 
      609 	declare flags		        bit (36) aligned,
      610 	        status		        fixed bin (35),
      611 	        op		        char (*),
      612 	        switch		        bit (1) aligned,
      613 	        message		        char (*);
      614 
      615 	flags = ACTION_CAN_RESTART;
      616 	goto COMMON;
      617 
      618 fatal:
      619      entry (status, op, switch, message);
      620 
      621 	flags = ACTION_CANT_RESTART;
      622 	goto COMMON;
      623 
      624 warning:
      625      entry (status, op, switch, message);
      626 
      627 	flags = ACTION_DEFAULT_RESTART;
      628 COMMON:
      629 	cei.copy_options_ptr = copy_options_ptr;
      630 	cei.operation = op;
      631 	cei.target_err_switch = switch;
      632 
      633 	call sub_err_ (status, "copy_", flags, addr (cei), (0), message, switch, pathname_ (source_dir, source_name),
      634 	     pathname_ (target_dir, target_name));
      635 
      636 	return;
      637 
      638      end error;
      639 
      640 Dummy_Procedure:
      641      procedure options (non_quick);
      642 
      643 	declare cu_$arg_count	        entry (fixed bin, fixed bin (35));
      644 	declare cu_$arg_ptr		        entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
      645 	declare last_arg_x		        fixed bin;
      646 	declare code_ptr		        pointer;
      647 	declare code		        fixed bin (35) based (code_ptr);
      648 	declare error_table_$no_operation     fixed bin (35) ext static;
      649 
      650 	call cu_$arg_count (last_arg_x, (0));
      651 	call cu_$arg_ptr (last_arg_x, code_ptr, (0), (0));
      652 	code = error_table_$no_operation;
      653 	return;
      654      end Dummy_Procedure;
      655 
      656      end copy_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/14/90  0915.0  copy_.pl1                         >spec>install>1039>copy_.pl1
153          1    11/22/82  1055.7  status_structures.incl.pl1        >ldd>include>status_structures.incl.pl1
154          2    06/17/86  1613.1  status_for_backup.incl.pl1        >ldd>include>status_for_backup.incl.pl1
155          3    03/05/85  1907.3  suffix_info.incl.pl1              >ldd>include>suffix_info.incl.pl1
156          4    10/14/83  1706.7  copy_options.incl.pl1             >ldd>include>copy_options.incl.pl1
157          5    10/14/83  1706.7  copy_flags.incl.pl1               >ldd>include>copy_flags.incl.pl1
158          6    04/11/85  1552.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
159          7    10/14/83  1706.7  delete_options.incl.pl1           >ldd>include>delete_options.incl.pl1
160          8    10/14/83  1706.7  nd_handler_options.incl.pl1       >ldd>include>nd_handler_options.incl.pl1
161          9    07/18/81  1200.0  sub_error_info.incl.pl1           >ldd>include>sub_error_info.incl.pl1
162         10    04/16/82  1058.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
163         11    03/24/82  1447.2  condition_info_header.incl.pl1    >ldd>include>condition_info_header.incl.pl1
164         12    06/28/79  1304.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
165         13    10/14/83  1706.7  copy_error_info.incl.pl1          >ldd>include>copy_error_info.incl.pl1
166         14    10/14/83  1706.7  file_system_operations.incl.pl1   >ldd>include>file_system_operations.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000253 constant        bit(36)                  initial dcl 10-7 set ref 582* 621
ACTION_CAN_RESTART              000263 constant        bit(36)                  initial dcl 10-7 set ref 598* 615
ACTION_DEFAULT_RESTART                 constant        bit(36)                  initial dcl 10-7 ref 627
COPY_OPTIONS_VERSION_1          000160 constant        char(8)                  initial packed unaligned dcl 4-28 ref 174
FS_COPY                         000140 constant        char(64)                 initial packed unaligned dcl 14-6 set ref 252*
FS_GET_MAX_LENGTH               000120 constant        char(64)                 initial packed unaligned dcl 14-6 set ref 255*
FS_GET_RING_BRACKETS            000100 constant        char(64)                 initial packed unaligned dcl 14-6 set ref 253*
FS_GET_SWITCH                   000060 constant        char(64)                 initial packed unaligned dcl 14-6 set ref 257*
FS_OBJECT_TYPE_DIRECTORY        000172 constant        char(32)                 initial packed unaligned dcl 3-50 ref 195 512
FS_OBJECT_TYPE_MSF              000162 constant        char(32)                 initial packed unaligned dcl 3-50 ref 249
FS_OBJECT_TYPE_SEGMENT          000202 constant        char(32)                 initial packed unaligned dcl 3-50 ref 245 344
FS_SET_MAX_LENGTH               000040 constant        char(64)                 initial packed unaligned dcl 14-6 set ref 256*
FS_SET_RING_BRACKETS            000020 constant        char(64)                 initial packed unaligned dcl 14-6 set ref 254*
FS_SET_SWITCH                   000000 constant        char(64)                 initial packed unaligned dcl 14-6 set ref 258*
Link                                   constant        fixed bin(17,0)          initial dcl 1-56 ref 212
P_copy_options_ptr                     parameter       pointer                  dcl 72 ref 50 173 293
SUFFIX_INFO_VERSION_1           000212 constant        char(8)                  initial packed unaligned dcl 3-29 ref 260
Segment                                constant        fixed bin(17,0)          initial dcl 1-56 ref 245
acl                      46(01) 000507 automatic       bit(1)                   level 3 in structure "si" packed packed unaligned
                                                                                  dcl 92 in procedure "copy_" set ref 381
acl                     157(01)        based           bit(1)                   level 3 in structure "copy_options" packed packed
                                                                                  unaligned dcl 4-12 in procedure "copy_" ref 381
addr                                                   builtin function         dcl 150 ref 261 261 291 291 293 299 299 347 347 515
                                                                                  582 582 598 598 633 633
bks                             000447 automatic       structure                level 1 dcl 91 set ref 347 347
caller_name               2            based           char(32)                 level 2 packed packed unaligned dcl 4-12 set ref
                                                                                  234* 401* 404* 419*
cei                             000630 automatic       structure                level 1 dcl 93 set ref 582 582 598 598 633 633
chase                     0(05) 000710 automatic       bit(1)                   level 2 packed packed unaligned dcl 7-7 set ref 416*
ci                              000100 automatic       structure                level 1 dcl 285 set ref 291 291
co                              000100 automatic       structure                level 1 dcl 274 set ref 276* 293 299 299
code                                   based           fixed bin(35,0)          dcl 647 in procedure "Dummy_Procedure" set ref 652*
code                            000700 automatic       fixed bin(35,0)          dcl 148 in procedure "copy_" set ref 188* 189 189
                                                                                  189* 194* 195 195* 197 197* 200* 202 202* 208 208*
                                                                                  216* 218 218* 234* 236 238 238* 240* 261* 262 262*
                                                                                  269* 299* 301 301* 312* 313 313* 316* 320 320 320*
                                                                                  347* 348 348* 356* 357 357* 366* 367 367* 370* 371
                                                                                  371* 385* 386 386* 401* 404* 407 407 407 407* 419*
                                                                                  420 420 420* 426* 428* 429 429* 462* 463 463* 466*
                                                                                  467 467* 504* 505 506* 518* 519 519*
code_ptr                        000102 automatic       pointer                  dcl 646 set ref 651* 652
condition_info                         based           structure                level 1 dcl 12-14
condition_info_header                  based           structure                level 1 dcl 11-6
condition_info_version_1               constant        fixed bin(17,0)          initial dcl 12-30 ref 290
continue_to_signal_             000106 constant        entry                    external dcl 286 ref 296
copy_acl_                       000034 constant        entry                    external dcl 108 ref 385
copy_entry                      000644 automatic       entry variable           level 2 dcl 132 set ref 252* 269 299
copy_error_info                        based           structure                level 1 dcl 13-8
copy_flags                             based           structure                level 1 dcl 5-8 in procedure "copy_"
copy_flags               46     000507 automatic       structure                level 2 in structure "si" dcl 92 in procedure
                                                                                  "copy_"
copy_items              157            based           structure                level 2 dcl 4-12
copy_names_                     000036 constant        entry                    external dcl 110 ref 404
copy_options                           based           structure                level 1 dcl 4-12 set ref 276
copy_options_ptr                000630 automatic       pointer                  level 2 in structure "cei" dcl 93 in procedure
                                                                                  "copy_" set ref 577* 594* 628*
copy_options_ptr                000706 automatic       pointer                  dcl 4-10 in procedure "copy_" set ref 173* 174 177
                                                                                  177 180 181 182 183 185 202 202 216 216 221 222
                                                                                  225 225 225 232 234 265 265 269* 276 301 308 325
                                                                                  330 335 342 362 381 390 397 401 404 413 417 419
                                                                                  424 577 594 628
copy_options_ptr                       based           pointer                  level 2 in structure "copy_error_info" dcl 13-8
                                                                                  in procedure "copy_" set ref 293 293*
copy_switch             157(04)        based           bit(1)                   level 3 in structure "copy_options" packed packed
                                                                                  unaligned dcl 4-12 in procedure "copy_" ref 325
copy_switch              46(04) 000507 automatic       bit(1)                   level 3 in structure "si" packed packed unaligned
                                                                                  dcl 92 in procedure "copy_" set ref 325
cu_$arg_count                   000112 constant        entry                    external dcl 643 ref 650
cu_$arg_ptr                     000114 constant        entry                    external dcl 644 ref 651
delete                  156(03)        based           bit(1)                   level 3 packed packed unaligned dcl 4-12 ref 397 413
delete_$path                    000040 constant        entry                    external dcl 112 ref 419
delete_force              0(02) 000711 automatic       bit(1)                   level 2 packed packed unaligned dcl 8-7 set ref 232*
delete_options                  000710 automatic       structure                level 1 packed packed unaligned dcl 7-7 set ref 415*
                                                                                  419 419
dir_dir                         000722 automatic       char(168)                packed unaligned dcl 440 set ref 446* 447* 449* 450*
dir_ent                         000774 automatic       char(32)                 packed unaligned dcl 440 set ref 446* 447* 449* 450*
done                            001233 automatic       bit(1)                   packed unaligned dcl 491 set ref 522* 526* 530 537*
                                                                                  538 539* 542*
dumper_switches         157(06)        based           bit(1)                   level 3 in structure "copy_options" packed packed
                                                                                  unaligned dcl 4-12 in procedure "copy_" ref 335
dumper_switches          46(06) 000507 automatic       bit(1)                   level 3 in structure "si" packed packed unaligned
                                                                                  dcl 92 in procedure "copy_" set ref 335
entries                         000644 automatic       structure                level 1 dcl 132 set ref 171*
entry_bound             157(07)        based           bit(1)                   level 3 packed packed unaligned dcl 4-12 ref 342
entrypt                   4(01) 000447 automatic       bit(1)                   level 3 packed packed unaligned dcl 91 set ref 350
entrypt_bound             4(22) 000447 automatic       bit(14)                  level 2 packed packed unaligned dcl 91 set ref 356
                                                                                  356
error_table_$action_not_performed
                                000032 external static fixed bin(35,0)          dcl 95 ref 238 320 420
error_table_$dirseg             000012 external static fixed bin(35,0)          dcl 95 ref 195
error_table_$namedup            000014 external static fixed bin(35,0)          dcl 95 ref 238 407
error_table_$no_info            000020 external static fixed bin(35,0)          dcl 95 ref 189
error_table_$no_operation       000116 external static fixed bin(35,0)          dcl 648 ref 652
error_table_$noentry            000016 external static fixed bin(35,0)          dcl 95 ref 202
error_table_$nonamerr           000010 external static fixed bin(35,0)          dcl 95 set ref 552*
error_table_$sameseg            000022 external static fixed bin(35,0)          dcl 95 set ref 212*
error_table_$segnamedup         000024 external static fixed bin(35,0)          dcl 95 ref 407
error_table_$unimplemented_version
                                000026 external static fixed bin(35,0)          dcl 95 set ref 174*
error_table_$unsupported_operation
                                000030 external static fixed bin(35,0)          dcl 95 set ref 265* 350* 598*
errsw                           000100 automatic       bit(1)                   dcl 74 set ref 385* 386* 401* 404* 407*
expand_pathname_                000042 constant        entry                    external dcl 113 ref 446 449
extend                   46(08) 000507 automatic       bit(1)                   level 3 in structure "si" packed packed unaligned
                                                                                  dcl 92 in procedure "copy_" set ref 265
extend                  157(08)        based           bit(1)                   level 3 in structure "copy_options" packed packed
                                                                                  unaligned dcl 4-12 in procedure "copy_" ref 177
                                                                                  202 225 265
find_condition_info_            000110 constant        entry                    external dcl 287 ref 291
fixed                                                  builtin function         dcl 150 ref 356 356
flags                   156            based           structure                level 2 in structure "copy_options" dcl 4-12
                                                                                  in procedure "copy_"
flags                           000100 automatic       bit(36)                  dcl 609 in procedure "error" set ref 615* 621* 627*
                                                                                  633*
force                   156(02)        based           bit(1)                   level 3 in structure "copy_options" packed packed
                                                                                  unaligned dcl 4-12 in procedure "copy_" ref 232
                                                                                  417
force                           000710 automatic       bit(1)                   level 2 in structure "delete_options" packed packed
                                                                                  unaligned dcl 7-7 in procedure "copy_" set ref
                                                                                  417*
forced_access                   000101 automatic       bit(1)                   dcl 75 set ref 186*
fs_type                         000363 automatic       char(32)                 packed unaligned dcl 86 set ref 245* 249* 250* 252*
                                                                                  253* 254* 255* 256* 257* 258* 261* 344
fs_util_$chname_file            000046 constant        entry                    external dcl 114 ref 428
fs_util_$get_type               000076 constant        entry                    external dcl 142 ref 194 504
fs_util_$make_entry_for_type    000100 constant        entry                    external dcl 143 ref 252 253 254 255 256 257 258
fs_util_$suffix_info_for_type   000074 constant        entry                    external dcl 141 ref 261
get_ml_entry              4     000644 automatic       entry variable           level 2 dcl 132 set ref 255* 312
get_rb_entry             14     000644 automatic       entry variable           level 2 dcl 132 set ref 253* 366
get_shortest_path_              000066 constant        entry                    external dcl 128 ref 496 497
get_switch_entry         24     000644 automatic       entry variable           level 2 dcl 132 set ref 257* 462
get_system_free_area_           000070 constant        entry                    external dcl 129 ref 516
hcs_$chname_file                000044 constant        entry                    external dcl 114 ref 426
hcs_$get_link_target            000050 constant        entry                    external dcl 118 ref 216
hcs_$get_uid_file               000052 constant        entry                    external dcl 119 ref 210 211 447 450
hcs_$set_entry_bound            000056 constant        entry                    external dcl 122 ref 356
hcs_$status_                    000072 constant        entry                    external dcl 130 ref 518
hcs_$status_for_backup          000060 constant        entry                    external dcl 123 ref 347
hcs_$status_minf                000054 constant        entry                    external dcl 120 ref 188 200
i                               001234 automatic       fixed bin(17,0)          dcl 492 set ref 523* 524 527* 536* 539 542 545* 545
                                                                                  549 560
index                                                  builtin function         dcl 150 ref 512
info_ptr                 14     000100 automatic       pointer                  level 2 in structure "ci" dcl 285
                                                                                  in on unit on line 284 set ref 292
info_ptr                116            based           pointer                  level 2 in structure "sub_error_info" dcl 9-7
                                                                                  in procedure "copy_" ref 293 293
last_arg_x                      000100 automatic       fixed bin(17,0)          dcl 645 set ref 650* 651*
length                                                 builtin function         dcl 150 ref 561 561 561
link                      0(04) 000710 automatic       bit(1)                   level 2 packed packed unaligned dcl 7-7 set ref 416*
max_length              157(03)        based           bit(1)                   level 3 in structure "copy_options" packed packed
                                                                                  unaligned dcl 4-12 in procedure "copy_" ref 308
max_length                      000102 automatic       fixed bin(19,0)          dcl 76 in procedure "copy_" set ref 312* 316*
max_length               46(03) 000507 automatic       bit(1)                   level 3 in structure "si" packed packed unaligned
                                                                                  dcl 92 in procedure "copy_" set ref 308
message                                parameter       char                     packed unaligned dcl 609 set ref 606 618 624 633*
move_names_                     000062 constant        entry                    external dcl 124 ref 401
name                    106            based           char(32)                 level 2 dcl 9-7 ref 293
names                   157            based           bit(1)                   level 3 in structure "copy_options" packed packed
                                                                                  unaligned dcl 4-12 in procedure "copy_" ref 390
                                                                                  424
names                    46     000507 automatic       bit(1)                   level 3 in structure "si" packed packed unaligned
                                                                                  dcl 92 in procedure "copy_" set ref 390
names_relp                0(18)        based           bit(18)                  level 3 packed packed unaligned dcl 1-8 ref 524 532
                                                                                  542 551 560 564
nd_handler_$switches            000064 constant        entry                    external dcl 126 ref 234
nd_handler_options              000711 automatic       structure                level 1 packed packed unaligned dcl 8-7 set ref 231*
                                                                                  234 234
nnames                    0(02)        based           fixed bin(16,0)          level 3 packed packed unsigned unaligned dcl 1-8 ref
                                                                                  523 527 532 539 549 551 564
no_name_dup             156            based           bit(1)                   level 3 packed packed unaligned dcl 4-12 ref 225
null                                                   builtin function         dcl 288 ref 291 291
old_source_dir                  000375 automatic       char(168)                packed unaligned dcl 89 set ref 172* 269 559*
op                                     parameter       char(32)                 packed unaligned dcl 592 in procedure "unsup" set
                                                                                  ref 589 595 598*
op                                     parameter       char                     packed unaligned dcl 609 in procedure "error" ref
                                                                                  606 618 624 630
operation                 2     000630 automatic       char(32)                 level 2 dcl 93 set ref 578* 595* 630*
pathname_                       000104 constant        entry                    external dcl 147 ref 498 582 582 582 582 598 598 633
                                                                                  633 633 633
pointer                                                builtin function         dcl 150 ref 524 532 542 551 560 564
question                  0(01) 000710 automatic       bit(1)                   level 2 packed packed unaligned dcl 7-7 set ref 416*
raw                     156(01)        based           bit(1)                   level 3 in structure "copy_options" packed packed
                                                                                  unaligned dcl 4-12 in procedure "copy_" ref 185
raw                       0(07) 000710 automatic       bit(1)                   level 2 in structure "delete_options" packed packed
                                                                                  unaligned dcl 7-7 in procedure "copy_" set ref
                                                                                  418*
raw                       0(03) 000711 automatic       bit(1)                   level 2 in structure "nd_handler_options" packed
                                                                                  packed unaligned dcl 8-7 in procedure "copy_" set
                                                                                  ref 233*
raw                             000103 automatic       bit(1)                   dcl 77 in procedure "copy_" set ref 185* 233 245 379
                                                                                  418 426
ring_brackets           157(02)        based           bit(1)                   level 3 in structure "copy_options" packed packed
                                                                                  unaligned dcl 4-12 in procedure "copy_" ref 362
ring_brackets            46(02) 000507 automatic       bit(1)                   level 3 in structure "si" packed packed unaligned
                                                                                  dcl 92 in procedure "copy_" set ref 362
ring_brackets                   000105 automatic       fixed bin(3,0)           array dcl 79 in procedure "copy_" set ref 366* 370*
rtrim                                                  builtin function         dcl 150 ref 463 467 496 497 498 498 498 560 561
safety_switch           157(05)        based           bit(1)                   level 3 in structure "copy_options" packed packed
                                                                                  unaligned dcl 4-12 in procedure "copy_" ref 330
safety_switch            46(05) 000507 automatic       bit(1)                   level 3 in structure "si" packed packed unaligned
                                                                                  dcl 92 in procedure "copy_" set ref 330
same_dir_sw                     000104 automatic       bit(1)                   dcl 78 set ref 394* 395 424
sb                              001235 automatic       structure                level 1 dcl 493 set ref 515
segment                   0(03) 000710 automatic       bit(1)                   level 2 packed packed unaligned dcl 7-7 set ref 416*
set_ml_entry             10     000644 automatic       entry variable           level 2 dcl 132 set ref 256* 316
set_rb_entry             20     000644 automatic       entry variable           level 2 dcl 132 set ref 254* 370
set_switch_entry         30     000644 automatic       entry variable           level 2 dcl 132 set ref 258* 466
short                                  based           structure                level 2 dcl 1-8
short_source_dir                001150 automatic       varying char(168)        dcl 489 set ref 497* 512 561 561
short_target_dir                001075 automatic       varying char(168)        dcl 488 set ref 496* 498 498 560
short_target_path               001022 automatic       varying char(168)        dcl 487 set ref 498* 512 561 561
si                              000507 automatic       structure                level 1 dcl 92 set ref 261 261
source_dir                      000205 automatic       char(168)                packed unaligned dcl 80 in procedure "copy_" set ref
                                                                                  180* 188* 194* 210* 216* 221 312* 347* 366* 385*
                                                                                  401* 404* 419* 443 446* 462* 497* 559 560* 561*
                                                                                  561 582* 582* 598* 598* 633* 633*
source_dir               12            based           char(168)                level 2 in structure "copy_options" packed packed
                                                                                  unaligned dcl 4-12 in procedure "copy_" set ref
                                                                                  180 216* 221*
source_dir               12     000100 automatic       char(168)                level 2 in structure "co" packed packed unaligned
                                                                                  dcl 274 in begin block on line 271 set ref 277*
                                                                                  277
source_hcs_type                 000373 automatic       fixed bin(2,0)           dcl 87 set ref 188* 245
source_name                     000257 automatic       char(32)                 packed unaligned dcl 81 in procedure "copy_" set ref
                                                                                  181* 188* 194* 210* 216* 222 312* 347* 366* 385*
                                                                                  401* 404* 419* 426* 428* 462* 582* 582* 598* 598*
                                                                                  633* 633*
source_name              64            based           char(32)                 level 2 in structure "copy_options" packed packed
                                                                                  unaligned dcl 4-12 in procedure "copy_" set ref
                                                                                  181 216* 222*
source_type                     000267 automatic       char(32)                 packed unaligned dcl 82 set ref 194* 195 250
source_uid                      000361 automatic       bit(36)                  dcl 85 set ref 210* 212 447* 452
status                                 parameter       fixed bin(35,0)          dcl 574 in procedure "copy_error" set ref 571 582*
status                                 parameter       fixed bin(35,0)          dcl 609 in procedure "error" set ref 606 618 624
                                                                                  633*
status_area_ptr                 000702 automatic       pointer                  dcl 1-47 set ref 516* 518* 524 532 542 551 560 564
status_branch                          based           structure                level 1 dcl 1-8
status_entry_names                     based           char(32)                 array dcl 1-47 ref 524 532 542 551 560 564
status_for_backup                      based           structure                level 1 dcl 2-11
status_for_backup_version_2            constant        fixed bin(17,0)          initial dcl 2-33 ref 346
status_ptr                      000704 automatic       pointer                  dcl 1-47 set ref 515* 518* 523 524 527 532 532 539
                                                                                  542 549 551 551 560 564 564
string                                                 builtin function         dcl 150 set ref 231* 234 234 415* 419 419
sub_err_                        000102 constant        entry                    external dcl 146 ref 582 598 633
sub_error_                      000260 stack reference condition                dcl 275 ref 284
sub_error_info                         based           structure                level 1 dcl 9-7
sub_error_info_ptr              000712 automatic       pointer                  dcl 9-6 set ref 292* 293 293 293
substr                                                 builtin function         dcl 150 ref 561
suffix_info                            based           structure                level 1 dcl 3-12
switch                                 parameter       bit(1)                   dcl 574 in procedure "copy_error" set ref 571 579
                                                                                  582*
switch                                 parameter       bit(1)                   dcl 609 in procedure "error" set ref 606 618 624 631
                                                                                  633*
switch_name                            parameter       char                     packed unaligned dcl 459 set ref 456 462* 463 466*
                                                                                  467
switches                  4     000447 automatic       structure                level 2 packed packed unaligned dcl 91
target_dir                      000277 automatic       char(168)                packed unaligned dcl 83 in procedure "copy_" set ref
                                                                                  182* 200* 211* 234* 316* 356* 370* 385* 401* 404*
                                                                                  426* 428* 443 449* 466* 496* 504* 518* 582* 582*
                                                                                  633* 633*
target_dir               74            based           char(168)                level 2 in structure "copy_options" packed packed
                                                                                  unaligned dcl 4-12 in procedure "copy_" ref 182
target_err_switch        12     000630 automatic       bit(1)                   level 2 in structure "cei" dcl 93 in procedure
                                                                                  "copy_" set ref 579* 596* 631*
target_err_switch       156(04)        based           bit(1)                   level 3 in structure "copy_options" packed packed
                                                                                  unaligned dcl 4-12 in procedure "copy_" ref 301
target_hcs_type                 000374 automatic       fixed bin(2,0)           dcl 87 set ref 200* 212
target_name                     000351 automatic       char(32)                 packed unaligned dcl 84 in procedure "copy_" set ref
                                                                                  183* 200* 211* 234* 316* 356* 370* 385* 401* 404*
                                                                                  426* 428* 466* 498* 504* 518* 524 542 582* 582*
                                                                                  633* 633*
target_name             146            based           char(32)                 level 2 in structure "copy_options" packed packed
                                                                                  unaligned dcl 4-12 in procedure "copy_" ref 183
target_type                     001223 automatic       char(32)                 packed unaligned dcl 490 set ref 504* 512
target_uid                      000362 automatic       bit(36)                  dcl 85 set ref 211* 212 450* 452
type_name                12     000507 automatic       char(32)                 level 2 packed packed unaligned dcl 92 set ref 598*
update                  157(09)        based           bit(1)                   level 3 in structure "copy_options" packed packed
                                                                                  unaligned dcl 4-12 in procedure "copy_" ref 177
                                                                                  202 225 265
update                   46(09) 000507 automatic       bit(1)                   level 3 in structure "si" packed packed unaligned
                                                                                  dcl 92 in procedure "copy_" set ref 265
value                           001012 automatic       bit(1)                   dcl 459 set ref 462* 466*
version                         000447 automatic       fixed bin(17,0)          level 2 in structure "bks" dcl 91 in procedure
                                                                                  "copy_" set ref 346*
version                                based           char(8)                  level 2 in structure "copy_options" dcl 4-12
                                                                                  in procedure "copy_" ref 174
version                   2     000100 automatic       fixed bin(17,0)          level 2 in structure "ci" dcl 285
                                                                                  in on unit on line 284 set ref 290*
version                         000507 automatic       char(8)                  level 2 in structure "si" dcl 92 in procedure
                                                                                  "copy_" set ref 260*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 10-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 10-7
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 6-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 6-33
Directory                              internal static fixed bin(17,0)          initial dcl 1-56
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 6-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
FS_ADD_ACL_ENTRIES                     internal static char(64)                 initial packed unaligned dcl 14-6
FS_ADD_EXTENDED_ACL_ENTRIES            internal static char(64)                 initial packed unaligned dcl 14-6
FS_CHNAME_FILE                         internal static char(64)                 initial packed unaligned dcl 14-6
FS_DELENTRY_FILE                       internal static char(64)                 initial packed unaligned dcl 14-6
FS_DELETE_ACL_ENTRIES                  internal static char(64)                 initial packed unaligned dcl 14-6
FS_GET_BIT_COUNT                       internal static char(64)                 initial packed unaligned dcl 14-6
FS_GET_USER_ACCESS_MODES               internal static char(64)                 initial packed unaligned dcl 14-6
FS_LIST_ACL                            internal static char(64)                 initial packed unaligned dcl 14-6
FS_LIST_EXTENDED_ACL                   internal static char(64)                 initial packed unaligned dcl 14-6
FS_LIST_SWITCHES                       internal static char(64)                 initial packed unaligned dcl 14-6
FS_OBJECT_TYPE_DM_FILE                 internal static char(32)                 initial packed unaligned dcl 3-50
FS_OBJECT_TYPE_LINK                    internal static char(32)                 initial packed unaligned dcl 3-50
FS_REPLACE_ACL                         internal static char(64)                 initial packed unaligned dcl 14-6
FS_REPLACE_EXTENDED_ACL                internal static char(64)                 initial packed unaligned dcl 14-6
FS_SET_BIT_COUNT                       internal static char(64)                 initial packed unaligned dcl 14-6
FS_SUFFIX_INFO                         internal static char(64)                 initial packed unaligned dcl 14-6
FS_VALIDATE                            internal static char(64)                 initial packed unaligned dcl 14-6
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 6-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 6-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 6-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 6-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 6-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 6-36
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 6-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 6-36
R_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 6-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 6-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 6-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 6-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 6-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 6-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 6-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 6-36
SWITCH_LIST_VERSION_1                  internal static char(8)                  initial packed unaligned dcl 3-48
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 6-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 6-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 6-36
alloc_switch_count                     automatic       fixed bin(17,0)          dcl 3-33
alloc_switch_name_count                automatic       fixed bin(17,0)          dcl 3-33
condition_info_header_ptr              automatic       pointer                  dcl 11-4
condition_info_ptr                     automatic       pointer                  dcl 12-10
status_link                            based           structure                level 1 dcl 1-38
status_pathname                        based           char                     dcl 1-47
sub_error_info_version_1               internal static fixed bin(17,0)          initial dcl 9-13
suffix_info_ptr                        automatic       pointer                  dcl 3-10
switch_list                            based           structure                level 1 dcl 3-37
switch_list_ptr                        automatic       pointer                  dcl 3-33

NAMES DECLARED BY EXPLICIT CONTEXT.
COMMON                          005567 constant        label                    dcl 628 ref 616 622
Dummy_Procedure                 005726 constant        entry                    internal dcl 640 ref 171
MAIN_RETURN                     003707 constant        label                    dcl 434
NOT_GATE                        002575 constant        label                    dcl 350 ref 344
change_source_dir               004326 constant        entry                    internal dcl 474 ref 230
copy_                           000705 constant        entry                    external dcl 50
copy_error                      005223 constant        entry                    internal dcl 571 ref 174 189 197 202 208 212 218 240
                                                                                  262 265 301
copy_switch                     004055 constant        entry                    internal dcl 456 ref 328 333 339 340
error                           005476 constant        entry                    internal dcl 606 ref 313 320 348 350 357 367 371 386
                                                                                  407 420 429 463 467 506 519
fatal                           005521 constant        entry                    internal dcl 618 ref 177 552
same_dirp                       003710 constant        entry                    internal dcl 437 ref 394
unsup                           005362 constant        entry                    internal dcl 589 ref 308 325 330 335 362 381 390
warning                         005545 constant        entry                    internal dcl 624 ref 397

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6522        6642    6045        6532
Length      7412    6045       120         533     454           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
copy_                              1216 external procedure  is an external procedure.  
begin block on line 271             192 begin block         enables or reverts conditions.  
on unit on line 284                 104 on unit               
same_dirp                               internal procedure  shares stack frame of external procedure copy_.  
copy_switch                             internal procedure  shares stack frame of external procedure copy_.  
change_source_dir                       internal procedure  shares stack frame of external procedure copy_.  
copy_error                              internal procedure  shares stack frame of external procedure copy_.  
unsup                                   internal procedure  shares stack frame of external procedure copy_.  
error                               208 internal procedure  is called during a stack extension.  
Dummy_Procedure                      86 internal procedure  is assigned to an entry variable, and is declared options(non_quick).  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
Dummy_Procedure          000100 last_arg_x                  Dummy_Procedure
                         000102 code_ptr                    Dummy_Procedure
begin block on line 271  000100 co                          begin block on line 271
copy_                    000100 errsw                       copy_
                         000101 forced_access               copy_
                         000102 max_length                  copy_
                         000103 raw                         copy_
                         000104 same_dir_sw                 copy_
                         000105 ring_brackets               copy_
                         000205 source_dir                  copy_
                         000257 source_name                 copy_
                         000267 source_type                 copy_
                         000277 target_dir                  copy_
                         000351 target_name                 copy_
                         000361 source_uid                  copy_
                         000362 target_uid                  copy_
                         000363 fs_type                     copy_
                         000373 source_hcs_type             copy_
                         000374 target_hcs_type             copy_
                         000375 old_source_dir              copy_
                         000447 bks                         copy_
                         000507 si                          copy_
                         000630 cei                         copy_
                         000644 entries                     copy_
                         000700 code                        copy_
                         000702 status_area_ptr             copy_
                         000704 status_ptr                  copy_
                         000706 copy_options_ptr            copy_
                         000710 delete_options              copy_
                         000711 nd_handler_options          copy_
                         000712 sub_error_info_ptr          copy_
                         000722 dir_dir                     same_dirp
                         000774 dir_ent                     same_dirp
                         001012 value                       copy_switch
                         001022 short_target_path           change_source_dir
                         001075 short_target_dir            change_source_dir
                         001150 short_source_dir            change_source_dir
                         001223 target_type                 change_source_dir
                         001233 done                        change_source_dir
                         001234 i                           change_source_dir
                         001235 sb                          change_source_dir
error                    000100 flags                       error
on unit on line 284      000100 ci                          on unit on line 284

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     cat_realloc_chars   enter_begin_block   leave_begin_block   call_ent_var_desc
call_ent_var        call_ext_out_desc   call_ext_out        call_int_this_desc  return_mac          enable_op
shorten_stack       ext_entry           int_entry           int_entry_desc      set_chars_eis       index_chars_eis
op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
continue_to_signal_           copy_acl_                     copy_names_                   cu_$arg_count
cu_$arg_ptr                   delete_$path                  expand_pathname_              find_condition_info_
fs_util_$chname_file          fs_util_$get_type             fs_util_$make_entry_for_type  fs_util_$suffix_info_for_type
get_shortest_path_            get_system_free_area_         hcs_$chname_file              hcs_$get_link_target
hcs_$get_uid_file             hcs_$set_entry_bound          hcs_$status_                  hcs_$status_for_backup
hcs_$status_minf              move_names_                   nd_handler_$switches          pathname_
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$dirseg           error_table_$namedup
error_table_$no_info          error_table_$no_operation     error_table_$noentry          error_table_$nonamerr
error_table_$sameseg          error_table_$segnamedup       error_table_$unimplemented_version
error_table_$unsupported_operation




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     50 000702       171 000712       172 000731       173 000734       174 000740       177 000756       180 001017
    181 001023       182 001026       183 001031       185 001034       186 001040       188 001041       189 001101
    194 001112       195 001136       197 001147       200 001155       202 001214       206 001230       208 001231
    210 001237       211 001265       212 001313       216 001334       218 001364       221 001372       222 001376
    225 001401       230 001410       231 001411       232 001412       233 001417       234 001424       236 001456
    238 001460       240 001465       245 001471       249 001502       250 001506       252 001511       253 001537
    254 001565       255 001613       256 001641       257 001667       258 001715       260 001743       261 001746
    262 001771       265 001777       269 002027       271 002044       276 002047       277 002054       284 002057
    290 002073       291 002075       292 002114       293 002120       296 002141       297 002151       299 002152
    300 002165       301 002166       308 002177       312 002214       313 002240       316 002301       320 002325
    325 002370       328 002405       330 002412       333 002427       335 002434       339 002451       340 002462
    342 002470       344 002474       346 002500       347 002502       348 002531       350 002572       356 002635
    357 002665       362 002725       366 002742       367 002766       370 003026       371 003052       379 003111
    381 003113       385 003130       386 003163       390 003216       394 003233       395 003235       397 003240
    401 003300       403 003337       404 003340       407 003377       413 003437       415 003443       416 003444
    417 003454       418 003461       419 003466       420 003520       424 003560       426 003567       428 003622
    429 003652       434 003707       437 003710       443 003712       446 003721       447 003746       449 003774
    450 004021       452 004047       456 004055       462 004066       463 004120       465 004205       466 004206
    467 004240       469 004324       471 004325       474 004326       496 004327       497 004363       498 004417
    504 004501       505 004526       506 004530       507 004563       512 004564       515 004577       516 004601
    518 004610       519 004645       522 004702       523 004703       524 004715       526 004730       527 004732
    529 004736       530 004740       532 004742       533 004755       536 004756       537 004760       538 004761
    539 004764       542 004774       545 005014       547 005015       549 005016       551 005024       552 005034
    554 005070       559 005071       560 005074       561 005156       564 005215       567 005222       571 005223
    577 005225       578 005227       579 005232       581 005235       582 005236       585 005360       587 005361
    589 005362       594 005364       595 005366       596 005372       598 005373       602 005474       606 005475
    615 005516       616 005517       618 005520       621 005541       622 005543       624 005544       627 005565
    628 005567       630 005573       631 005601       633 005604       636 005724       640 005725       650 005733
    651 005744       652 005763       653 005766


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
