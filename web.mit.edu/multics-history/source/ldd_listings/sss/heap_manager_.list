	COMPILATION LISTING OF SEGMENT heap_manager_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/20/86  1201.5 mst Thu
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 
        8 
        9 /****^  HISTORY COMMENTS:
       10*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7395), audit(86-11-14,Zwick),
       11*     install(86-11-20,MR12.0-1222):
       12*     implemented heap_manager_
       13*                                                   END HISTORY COMMENTS */
       14 
       15 
       16 /* format: ind3,ifthen,^inddcls,^elsestmt,indbegin,comcol68 */
       17 
       18 
       19 /* this series of routines handle the heap acessed via *heap links
       20*   (type 5 class 6).
       21*
       22*   push_heap_level    : pushes a new heap level with a clean heap area.
       23*		    chains previous heap levels together.
       24*   pop_heap_level     : releases the current heap level and resets the
       25*		    heap to the previous level.
       26*   get_heap_level     : gets the current execution level from the current
       27*		    heap header.
       28*   get_heap_header	  : gets a pointer to the heap header at the passed
       29*		    execution level
       30*   get_heap_area	  : get a pointer to the heap area at the passed level
       31*   create_heap_for_set_ext_var 
       32*   		  : creates a heap level 0. This entrypoint is for the
       33*		    use of set_ext_variable_ only.
       34*
       35**/
       36 
       37 
       38 heap_manager_: procedure;
       39 
       40 /* parameters */
       41 
       42 dcl     a_exe_level		 fixed bin (17) parameter;	       /* execution level */
       43 dcl     a_heap_area_ptr	 pointer parameter;		       /* ptr to heap area */
       44 dcl     a_heap_header_ptr	 pointer parameter;		       /* ptr to heap header */
       45 dcl     a_code		 fixed bin (35) parameter;	       /* system error code */
       46 
       47 dcl     a_sb		 pointer parameter;		       /* pointer to stack header */
       48 dcl     a_ring_no		 fixed bin parameter;	       /* ring number of faulting ring */
       49 
       50 /* automatic */
       51 
       52 dcl     done		 bit (1) automatic;		       /* specifes a loop end condition */
       53 dcl     heap_p		 pointer automatic;		       /* temp ptr to heap header*/
       54 dcl     heap_area_p		 pointer automatic;		       /* temp ptr to heap area*/
       55 dcl     heap_header_ptr	 pointer automatic;		       /* ptr to heap header */
       56 dcl     ring_no		 fixed bin automatic;	       /* is our validation level */
       57 dcl     temp_ptr		 pointer automatic;		       /* a temp ptr */
       58 
       59 
       60 /* conditions */
       61 
       62 dcl     cleanup		 condition;
       63 
       64 
       65 /* external routines */
       66 
       67 dcl     cu_$level_get	 entry (fixed bin);
       68 dcl     define_area_	 entry (ptr, fixed bin (35));
       69 dcl     release_area_	 entry (ptr);
       70 
       71 /* external variables */
       72 
       73 dcl     (
       74         error_table_$no_heap_defined,
       75         error_table_$invalid_heap,
       76         error_table_$null_info_ptr
       77         )			 ext fixed bin (35);
       78 
       79 
       80 dcl     sys_info$max_seg_size	 fixed bin (19) ext;
       81 
       82 
       83 /* builtins */
       84 
       85 dcl     (addr, char, ltrim, null, unspec) builtin;
       86 
       87 /**/
       88 
       89 
       90 /* return if heap_manager_ is called
       91**/
       92 
       93       return;
       94 
       95 /**/
       96 
       97 /* push heap level creates a new heap chaining the previous levels heap
       98*   in the list of heaps
       99*
      100*     parameters
      101*     a_sb        ptr to stack header (Input)
      102*     a_exe_level new execution level (Output)
      103*     a_code      system error code (Output)
      104*
      105**/
      106 
      107 push_heap_level: entry (a_sb, a_exe_level, a_code);
      108 
      109 
      110 /* initialize required area pointers to null so we can tell when
      111*   they have been set validly
      112**/
      113 
      114       a_code = 0;
      115       heap_p = null ();
      116       a_exe_level = -1;
      117 
      118       if a_sb = null () then
      119          do;
      120 	  a_code = error_table_$null_info_ptr;
      121 	  return;
      122          end;
      123 
      124       heap_header_ptr = a_sb -> stack_header.heap_header_ptr;
      125 
      126 
      127 /* get our ring number so that the heap area has a unique suffix identifying
      128*   the owning ring
      129**/
      130 
      131       call cu_$level_get (ring_no);
      132 
      133 
      134 
      135 /* set up a cleanup handler so that if we are interupted we can release 
      136*   the areas and reset the heap environment
      137**/
      138 
      139       on condition (cleanup)
      140          begin;
      141 
      142 /* we have to have a cleanup handler here in case we get caught between
      143*   the setting of exe_level and the return. If we get caught while in
      144*   create_heap, it will do all of the work cleaning up and will set heap_p
      145*   to null so we won't do our cleanup. If on the other hand we do get caught
      146*   prior to our return we have to cleanup everything. Even though we
      147*   can guarantee everything will be valid in this case we check it out anyway.
      148**/
      149 
      150 	  if heap_p ^= null () then
      151 	     do;
      152 	        if (a_sb -> stack_header.heap_header_ptr ^= null ()) &
      153 		   (heap_p = a_sb -> stack_header.heap_header_ptr) then
      154 		 a_sb -> stack_header.heap_header_ptr = heap_header_ptr;
      155 	        if heap_p -> heap_header.area_ptr ^= null () then
      156 		 call release_area_ (heap_p -> heap_header.area_ptr);
      157 	     end;
      158 
      159 /* because we have done the cleanup we set the returned exe_level to 
      160*   what we were passed so that if a cleanup handler exists at a previous
      161*   level ie. main_ it will be able to tell that everything is cleaned
      162*   up. ie. If the a_exe_level is the same on return as it was when we
      163*   were called then nothing has been allocated and its cleanup handler
      164*   should not have to cleanup the heap.
      165**/
      166 	  a_exe_level = -1;
      167 
      168          end;
      169 
      170 
      171 /* either generate a heap level exe_level + 1 or 1. level 0 is left for
      172*   set_ext_variable_
      173**/
      174 
      175       if heap_header_ptr = null () then
      176          call create_heap (a_sb, ring_no, 1, heap_header_ptr, heap_p,
      177 	    a_code);
      178 
      179       else
      180          call create_heap (a_sb, ring_no,
      181 	    (heap_header_ptr -> heap_header.execution_level + 1),
      182 	    heap_header_ptr, heap_p, a_code);
      183 
      184 /* set the return execution level */
      185 
      186       if a_code = 0 then
      187          a_exe_level = heap_p -> heap_header.execution_level;
      188 
      189       return;
      190 
      191 /**/
      192 /* pop heap level releases the current heap level and resets the heap
      193*   to the previous level.
      194*
      195*     parameters
      196*     a_sb        ptr to stack header (Input)
      197*     a_code      system error code (Output)
      198**/
      199 
      200 pop_heap_level: entry (a_sb, a_code);
      201 
      202       a_code = 0;
      203 
      204       if a_sb = null () then
      205          do;
      206 	  a_code = error_table_$no_heap_defined;
      207 	  return;
      208          end;
      209 
      210       heap_p = a_sb -> stack_header.heap_header_ptr;
      211       if heap_p = null () then
      212          do;
      213 	  a_code = error_table_$no_heap_defined;
      214 	  return;
      215          end;
      216 
      217       if (heap_p -> heap_header.version ^= heap_header_version_1) then
      218          do;
      219 	  a_code = error_table_$invalid_heap;
      220 	  return;
      221          end;
      222 
      223       heap_area_p = heap_p -> heap_header.area_ptr;
      224 
      225 
      226 /* set up cleanup handler so that we can reset the environment if we 
      227*   get interrupted
      228**/
      229 
      230       on condition (cleanup)
      231          begin;
      232 
      233 /* heap_p is set prior to the condition handler to non null. If 
      234*   heap_p is equal to the sb heap_header we have not unthreaded it 
      235*   from the heap_header list. if heap_area_p is not null then
      236*   we have not released the area.
      237**/
      238 
      239 	  if heap_p = a_sb -> stack_header.heap_header_ptr then
      240 	     a_sb -> stack_header.heap_header_ptr =
      241 		heap_p -> heap_header.previous_heap_ptr;
      242 
      243 	  if heap_area_p ^= null () then
      244 	     call release_area_ (heap_area_p);
      245 
      246          end;
      247 
      248 /* unthread our heap level from the heap list */
      249 
      250       a_sb -> stack_header.heap_header_ptr = heap_p -> heap_header.previous_heap_ptr;
      251 
      252 
      253 /* Free the heap.  The routine release_area_ will also delete the segments
      254*   it created for the heap.  The heap header and variable table are
      255*   allocated within the heap area and are destroyed along with the heap.
      256**/
      257 
      258       if heap_area_p ^= null () then
      259          call release_area_ (heap_area_p);
      260 
      261       return;
      262 
      263 /**/
      264 /* get heap level returns the current execution level from the current
      265*   heap header
      266*
      267*     parameters
      268*     a_sb         ptr to stack header (Input)
      269*     a_exe_level  execution level (Output)
      270*     a_code       system error code (Output)
      271*
      272**/
      273 
      274 get_heap_level: entry (a_sb) returns (fixed bin (17));
      275 
      276       if a_sb = null () then
      277          return (-1);
      278 
      279       heap_header_ptr = a_sb -> stack_header.heap_header_ptr;
      280       if heap_header_ptr = null () then
      281          return (-1);
      282 
      283       if (heap_header_ptr -> heap_header.version ^=
      284 	 heap_header_version_1) then
      285          return (-1);
      286 
      287       return (heap_header_ptr -> heap_header.execution_level);
      288 
      289 /**/
      290 
      291 /* get heap header returns a pointer to the heap header at the passed 
      292*   execution level
      293*
      294*     parameters
      295*     a_exe_level         execution level (Input)
      296*     a_sb		     ptr to stack header (Input)
      297*     a_heap_header_ptr   ptr to heap header (Output)
      298*     a_code	     system error code (Output)
      299*
      300**/
      301 
      302 get_heap_header: entry (a_sb, a_exe_level, a_heap_header_ptr, a_code);
      303 
      304       a_code = 0;
      305       a_heap_header_ptr = null ();
      306 
      307       if a_sb = null () then
      308          do;
      309 	  a_code = error_table_$null_info_ptr;
      310 	  return;
      311          end;
      312 
      313       heap_header_ptr = a_sb -> stack_header.heap_header_ptr;
      314 
      315       if heap_header_ptr = null () then
      316          do;
      317 	  a_code = error_table_$no_heap_defined;
      318 	  return;
      319          end;
      320 
      321       if (heap_header_ptr -> heap_header.version ^=
      322 	 heap_header_version_1) then
      323          do;
      324 	  a_code = error_table_$invalid_heap;
      325 	  return;
      326          end;
      327 
      328       if (heap_header_ptr -> heap_header.execution_level < a_exe_level) |
      329 	 (a_exe_level < -1) then
      330          do;
      331 	  a_code = error_table_$no_heap_defined;
      332 	  return;
      333          end;
      334 
      335       if a_exe_level = -1 then
      336          do;					       /* if exe_level = -1 then use current level */
      337 	  a_heap_header_ptr = heap_header_ptr;
      338 	  return;
      339          end;
      340 
      341       temp_ptr = heap_header_ptr;
      342       done = "0"b;
      343       do while (^done);
      344 
      345          if (temp_ptr = null ()) then
      346 	  done = "1"b;
      347 
      348          else if (a_exe_level = temp_ptr -> heap_header.execution_level) then
      349 	  done = "1"b;
      350 
      351          else
      352 	  temp_ptr = temp_ptr -> heap_header.previous_heap_ptr;
      353       end;
      354 
      355       if temp_ptr = null () then
      356          a_code = error_table_$no_heap_defined;
      357 
      358       else
      359          a_heap_header_ptr = temp_ptr;
      360 
      361       return;
      362 						       /**/
      363 
      364 /* get heap area returns a pointer to the heap area at the passed 
      365*   execution level. The pointer returned points to an area of 
      366*   max_segsize - 50
      367*
      368*
      369*     parameters
      370*     a_exe_level       execution level (Input)
      371*     a_sb		   ptr to stack header (Input)
      372*     a_heap_area_ptr   ptr to heap area (Output)
      373*     a_code	   system error code (Output)
      374*
      375**/
      376 
      377 get_heap_area: entry (a_sb, a_exe_level, a_heap_area_ptr, a_code);
      378 
      379       a_code = 0;
      380       a_heap_area_ptr = null ();
      381 
      382 
      383       if a_sb = null () then
      384          do;
      385 	  a_code = error_table_$null_info_ptr;
      386 	  return;
      387          end;
      388 
      389       heap_header_ptr = a_sb -> stack_header.heap_header_ptr;
      390       if heap_header_ptr = null () then
      391          do;
      392 	  a_code = error_table_$no_heap_defined;
      393 	  return;
      394          end;
      395 
      396       if (heap_header_ptr -> heap_header.version ^=
      397 	 heap_header_version_1) then
      398          do;
      399 	  a_code = error_table_$invalid_heap;
      400 	  return;
      401          end;
      402 
      403       if (a_exe_level > heap_header_ptr -> heap_header.execution_level) |
      404 	 (a_exe_level < -1) then
      405          do;
      406 	  a_code = error_table_$no_heap_defined;
      407 	  return;
      408          end;
      409 
      410       if a_exe_level = -1 then
      411          do;					       /* if exe_level = -1 then use current level */
      412 	  a_heap_area_ptr = heap_header_ptr -> heap_header.area_ptr;
      413 	  return;
      414          end;
      415 
      416       temp_ptr = heap_header_ptr;
      417       done = "0"b;
      418       do while (^done);
      419 
      420          if (temp_ptr = null ()) then
      421 	  done = "1"b;
      422 
      423          else if (a_exe_level = temp_ptr -> heap_header.execution_level) then
      424 	  done = "1"b;
      425 
      426          else
      427 	  temp_ptr = temp_ptr -> heap_header.previous_heap_ptr;
      428       end;
      429 
      430       if temp_ptr = null () then
      431          a_code = error_table_$no_heap_defined;
      432 
      433       else
      434          a_heap_area_ptr = temp_ptr -> heap_header.area_ptr;
      435 
      436       return;
      437 
      438 /**/
      439 
      440 /* create_heap_for_set_ext_var
      441*   creates a heap level 0 for set_ext_variable_. This heap is used for
      442*   programs that don't have a main_ as defined for C.
      443*
      444*   parameters
      445*   a_sb               a pointer to the stack of the calling routine
      446*   a_ring_no          the ring number of the calling routine. ie of the 
      447*		  faulting ring from set_ext_var. (Input)
      448*   a_heap_header_ptr  a pointer to the heap_header. (Output)
      449*   a_code		  an error_code. (Output)
      450**/
      451 
      452 create_heap_for_set_ext_var: entry (a_sb, a_ring_no, a_heap_header_ptr, a_code);
      453 
      454       if a_sb = null () then
      455          do;
      456 	  a_code = error_table_$null_info_ptr;
      457 	  return;
      458          end;
      459 
      460 
      461       call create_heap (a_sb, a_ring_no, 0, null (), a_heap_header_ptr, a_code);
      462 
      463       return;
      464 
      465 /**/
      466 /* Internal Procedures */
      467 /* create_heap
      468*   allocates a heap via define_area_ and sets up the heap header.
      469**/
      470 
      471 create_heap: procedure (sb, ring_no, exe_level, current_heap_header_ptr, new_heap_header_ptr, error_code);
      472 
      473 /* parameters */
      474 
      475 dcl     sb		 pointer parameter;		       /* Input */
      476 dcl     ring_no		 fixed bin parameter;	       /* Input */
      477 dcl     exe_level		 fixed bin (17) parameter;	       /* Input */
      478 dcl     current_heap_header_ptr pointer parameter;	       /* Input */
      479 dcl     new_heap_header_ptr	 pointer parameter;		       /* Output */
      480 dcl     error_code		 fixed bin (35) parameter;	       /* Output */
      481 
      482 /* structures */
      483 
      484 dcl     1 new_area		 like area_info automatic;
      485 
      486 /* based */
      487 
      488 dcl     area_block		 area based;
      489 
      490 
      491 
      492 /* initialize the area info */
      493 
      494       unspec (new_area.control) = ""b;
      495       new_area.control.extend = "1"b;
      496       new_area.control.zero_on_alloc = "1"b;
      497       new_area.control.system = "1"b;
      498       new_area.areap = null ();
      499 
      500 /* the owner field is placed as a suffix on the area name.  The heap level
      501*   and owning ring are placed in the owner string so that the heap segments
      502*   and their owners may be identified by the segment name.
      503**/
      504 
      505       new_area.owner = "Heap_" || ltrim (char (exe_level)) ||
      506 	 "r" || ltrim (char (ring_no));
      507 
      508       new_area.areap = null ();
      509       new_area.version = area_info_version_1;
      510       new_area.size = sys_info$max_seg_size - 50;
      511 
      512 
      513 /* set up a cleanup handler so that if we are interupted we can release 
      514*   the areas and reset the heap environment
      515**/
      516 
      517       on condition (cleanup)
      518          begin;
      519 
      520 /* if stack is not set then we have not completed initializing the heap.
      521*   if new_heap_header_ptr is set we have allocated the heap and
      522*   possibly have chained it in with the heap header list.  If the
      523*   heap area is set we have at least allocated the heap.  The heap
      524*   area would be allocated via the call to define_area.
      525**/
      526 	  if new_heap_header_ptr ^= null () then
      527 	     do;
      528 	        if (a_sb -> stack_header.heap_header_ptr ^= null ()) &
      529 		   (new_heap_header_ptr = a_sb -> stack_header.heap_header_ptr) then
      530 		 a_sb -> stack_header.heap_header_ptr = current_heap_header_ptr;
      531 
      532 /* set new_heap_header_ptr to null so that the previous level can tell
      533*   that everything is cleaned up.
      534**/
      535 
      536 	        new_heap_header_ptr = null ();
      537 
      538 	     end;
      539 
      540 /* check and see if area needs to be dumped */
      541 
      542 	  if new_area.areap ^= null () then
      543 	     call release_area_ (new_area.areap);
      544          end;
      545 
      546 
      547 /* set up an area where the heap can reside. use define area to specify it 
      548*   as extensible and zero on alloc.
      549**/
      550 
      551       call define_area_ (addr (new_area), error_code);
      552       if error_code ^= 0 then
      553          return;
      554 
      555 
      556 /* allocate and set up the heap header for this heap level in the heap
      557*   area.
      558**/
      559 
      560       allocate heap_header in (new_area.areap -> area_block) set (new_heap_header_ptr);
      561 
      562       new_heap_header_ptr -> heap_header.area_ptr = new_area.areap;
      563       new_heap_header_ptr -> heap_header.version = heap_header_version_1;
      564       new_heap_header_ptr -> heap_header.heap_name_list_ptr = null ();
      565       new_heap_header_ptr -> heap_header.previous_heap_ptr = current_heap_header_ptr;
      566       new_heap_header_ptr -> heap_header.execution_level = exe_level;
      567 
      568 /* thread the new heap header into the heap header list */
      569 
      570       sb -> stack_header.heap_header_ptr = new_heap_header_ptr;
      571 
      572 
      573    end create_heap;
      574 
      575 /* Include Files */
  1     1 /* BEGIN INCLUDE FILE ... system_link_names.incl.pl1 */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396), audit(86-11-12,Zwick),
  1     6*     install(86-11-20,MR12.0-1222):
  1     7*     added the declaration of the heap_header.
  1     8*  2) change(86-10-20,DGHowe), approve(86-10-20,MCR7420), audit(86-11-12,Zwick),
  1     9*     install(86-11-20,MR12.0-1222):
  1    10*     add the seg ptr to the variable node structure.
  1    11*                                                   END HISTORY COMMENTS */
  1    12 
  1    13 
  1    14 /* created by M. Weaver 7/28/76 */
  1    15 /* Modified: 82-11-19 by T. Oke to add LIST_TEMPLATE_INIT. */
  1    16 /* Modified 02/11/83 by M. Weaver to add have_vla_variables flag */
  1    17 
  1    18 
  1    19 dcl 1 variable_table_header aligned based,	/* header for name table */
  1    20      2 hash_table (0:63) ptr unaligned,		/* hash table for variable nodes */
  1    21      2 total_search_time fixed bin (71),	/* total time to search for variables */
  1    22      2 total_allocation_time fixed bin (71),	/* total time spent allocating and initializing nodes and variables */
  1    23      2 number_of_searches fixed bin,		/* number of times names were looked up */
  1    24      2 number_of_variables fixed bin (35),	/* number of variables allocated by the linker, incl deletions */
  1    25      2 flags unaligned,
  1    26         3 have_vla_variables bit (1) unaligned,	/* on if some variables are > sys_info$max_seg_size */
  1    27         3 pad bit (11) unaligned,
  1    28      2 cur_num_of_variables fixed bin (24) unal,	/* current number of variables allocated */
  1    29      2 number_of_steps fixed bin,		/* total number of nodes looked at */
  1    30      2 total_allocated_size fixed bin (35);	/* current amount of storage in user area */
  1    31 
  1    32 
  1    33 dcl 1 variable_node aligned based,		/* individual variable information */
  1    34      2 forward_thread ptr unaligned,		/* thread to next node off same hash bucket */
  1    35      2 vbl_size fixed bin (24) unsigned unaligned, /* length in words of variable */
  1    36      2 init_type fixed bin (11) unaligned,	/* 0=not init; 3=init template; 4=area 5=list_template*/
  1    37      2 time_allocated fixed bin (71),		/* time when variable was allocated */
  1    38      2 vbl_ptr ptr,				/* pointer to variable's storage */
  1    39      2 init_ptr ptr,			/* pointer to original init info in object seg */
  1    40      2 name_size fixed bin(21) aligned,		/* length of name in characters */
  1    41      2 name char (nchars refer (variable_node.name_size)), /* name of variable */
  1    42      2 seg_ptr  pointer;
  1    43 
  1    44 /* variable_node.seg_ptr
  1    45*   Is a pointer to the segment containing the initialization information
  1    46*   for this variable. It is used as a segment base pointer for external
  1    47*   pointer initialization via list_init_.
  1    48*
  1    49*   The init_ptr can not be used as a reference to the defining segment
  1    50*   due to the possibility of set_fortran_common being used to initialize
  1    51*   the external variables. sfc will generate an initialization information
  1    52*   structure if multiple intialization sizes are found in the specified 
  1    53*   segments. sfc stores the address of this structure in the init_ptr field.
  1    54*   This is one reason why sfc does not perform external pointer 
  1    55*   initialization.
  1    56*
  1    57*   The seg_ptr is set to point at the segment used to define the 
  1    58*   initialization information. term_ sets this field to null on termination
  1    59*   due to the possiblity of executing a different segment which defines
  1    60*   initialization information. In this way the seg_ptr field will either
  1    61*   be valid or null.
  1    62**/
  1    63 
  1    64 dcl 1 heap_header based,
  1    65      2 version            char(8),                /* specifies the verison of the header */
  1    66      2 heap_name_list_ptr pointer,		/* points to the variable_table_header for this heap */
  1    67      2 previous_heap_ptr  pointer,		/* points to the previous heap or is null */
  1    68      2 area_ptr	      pointer,		/* points to the heap area */
  1    69      2 execution_level    fixed bin (17);	/* specifies the execution level this header deals with */
  1    70 
  1    71 dcl heap_header_version_1 char(8) static options (constant)
  1    72 			    init ("Heap_v01");
  1    73 	
  1    74 
  1    75 /* END INCLUDE FILE ... system_link_names.incl.pl1 */
      576 
      577 
      578 
  2     1 /* Begin include file ... system_link_init_info.incl.pl1 ... 5/6/80 MRJ */
  2     2 
  2     3 
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  2     7*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
  2     8*     Modified to declare DEFERRED_INIT type constant.
  2     9*  2) change(86-06-24,DGHowe), approve(86-06-24,MCR7420), audit(86-11-12,Zwick),
  2    10*     install(86-11-20,MR12.0-1222):
  2    11*     added the external pointer initialization structure and the constants
  2    12*     required to use them.
  2    13*                                                   END HISTORY COMMENTS */
  2    14 
  2    15 
  2    16 /* Modified: 82-11-17 by T. Oke to add list_init_info and LIST_TEMPLATE_INIT. */
  2    17 
  2    18 /* format: style3,idind25 */
  2    19 
  2    20 /* NOTE --------------------------------------------------
  2    21*   the following structures defining initialization information can also
  2    22*   be found in fortran_storage.incl.pl1  definition_dcls.incl.pl1
  2    23*   and should be kept equivalent
  2    24*   -------------------------------------------------------
  2    25**/
  2    26 
  2    27 dcl	init_info_ptr	     ptr;			/* ptr to structure below */
  2    28 dcl	init_size		     fixed bin (35);	/* size (in words) of initialization template */
  2    29 
  2    30 dcl	1 init_info	     aligned based (init_info_ptr),
  2    31 	  2 size		     fixed bin (35),	/* size (in words) of data */
  2    32 	  2 type		     fixed bin,		/* type of initialization: see below */
  2    33 	  2 init_template	     (init_size refer (init_info.size)) fixed bin (35);
  2    34 
  2    35 dcl	1 init_info_single_word  aligned based (init_info_ptr),
  2    36 						/* for convenience of people like ssi */
  2    37 	  2 size		     fixed bin (19),	/* = 1 */
  2    38 	  2 type		     fixed bin,		/* = TEMPLATE_INIT */
  2    39 	  2 init_template	     (1) fixed bin (35);	/* = value */
  2    40 
  2    41 dcl	1 list_init_info	     aligned based,
  2    42 	  2 size		     fixed bin (35),	/* length of variable */
  2    43 	  2 type		     fixed bin,		/* LIST_TEMPLATE_INIT */
  2    44 	  2 pad		     bit (18) unaligned,
  2    45 	  2 list_size	     fixed bin (18) unsigned unaligned,
  2    46 						/* size in words of template */
  2    47 	  2 template	     (0 refer (list_init_info.list_size)) bit (36);
  2    48 						/* first create_entry position */
  2    49 
  2    50 /* A list template consists of a series of entries with the following
  2    51*   description, concatenated together.  n_bits and datum are bit items,
  2    52*   to permit a wide range of inputs.
  2    53*
  2    54*   1.  A 'repeat' of '0' signifies skipping of 'n_bits' bits.
  2    55*   2.  A 'n_bits' of '0' signifies the last item of the list.
  2    56*
  2    57*   COMMON, VLA's, and LA's are presumed to start at the base pointer
  2    58*   of their particular storage section. */
  2    59 
  2    60 dcl	1 list_template_entry    aligned based,
  2    61 	  2 n_bits	     fixed bin (35) aligned,	/* size of datum */
  2    62 	  2 mbz		     bit (3) unaligned,	/* future expansion */
  2    63 	  2 init_type	     fixed bin (3) unsigned unaligned, /* 0 normal init, 1 ptr init, 2 packed ptr init */
  2    64 	  2 repeat	     fixed bin (30) unsigned unaligned,
  2    65 						/* number of times to repeat datum */
  2    66 	  2 datum		     bit (init_n_bits_in_datum refer (list_template_entry.n_bits));
  2    67 
  2    68 /* list_template_entry_ptr is defined such that it can be used as an
  2    69*   automatic definition overlay with a fixed size datum. it has a declared 
  2    70*   size of 72 to allow for the its pointer sixe of 72 bits.
  2    71**/
  2    72 
  2    73 dcl	1 list_template_entry_ptr	aligned based,
  2    74 	  2 n_bits	     fixed bin (35) aligned,
  2    75 	  2 mbz		     bit(3) unaligned,
  2    76 	  2 init_type	     fixed bin (3) unsigned unaligned,
  2    77 	  2 repeat	     fixed bin (30) unsigned unaligned,
  2    78 	  2 datum		     bit(72);
  2    79 
  2    80 /* the pointer_init_template represents the initialization information
  2    81*   for ITS and packed pointers.  Both pointer types require the entire
  2    82*   72 bit structure.
  2    83**/
  2    84 
  2    85 dcl       1 pointer_init_template  based,
  2    86 	  2 ptr_type	     fixed bin (18) unsigned unaligned,  /* 0 text section, 1 linkage section, 2 static section */
  2    87 	  2 section_offset	     fixed bin (18) unsigned unaligned,  /* offset to item in specified section */
  2    88 	  2 word_offset	     fixed bin (18) unsigned unaligned,  /* word offset from section item to target */
  2    89 	  2 mbz		     bit (12) unaligned,
  2    90 	  2 bit_offset	     fixed bin (6) unsigned unaligned;   /* bit offset from section item|word offset to target */
  2    91 
  2    92 
  2    93 dcl	init_n_bits_in_datum     fixed bin (35);
  2    94 
  2    95 dcl	NO_INIT		     fixed bin static options (constant) init (0);
  2    96 dcl	TEMPLATE_INIT	     fixed bin static options (constant) init (3);
  2    97 dcl	EMPTY_AREA_INIT	     fixed bin static options (constant) init (4);
  2    98 dcl	LIST_TEMPLATE_INIT	     fixed bin static options (constant) init (5);
  2    99 dcl	INIT_DEFERRED	     fixed bin static options (constant) init (6);
  2   100 dcl	ITS_PTR_INIT	     fixed bin (3) unsigned static options (constant) init(1);
  2   101 dcl	PACKED_PTR_INIT	     fixed bin (3) unsigned static options (constant) init(2);
  2   102 dcl	PTR_INIT_TEXT	     fixed bin (17) static options (constant) init(0);
  2   103 dcl	PTR_INIT_LOT	     fixed bin (17) static options (constant) init(1);
  2   104 dcl	PTR_INIT_ISOT	     fixed bin (17) static options (constant) init(2);
  2   105 	
  2   106 
  2   107 /* End include file ... system_link_init_info.incl.pl1 */
      579 
      580 
      581 
  3     1 /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
  3     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
  3     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
  3     4 /*	Modified April 1983 by C. Hornig for tasking */
  3     5 
  3     6 /****^  HISTORY COMMENTS:
  3     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
  3     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
  3     9*     added the heap_header_ptr definition.
  3    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  3    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
  3    12*     Modified to support control point management.  These changes were actually
  3    13*     made in February 1985 by G. Palter.
  3    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
  3    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
  3    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
  3    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
  3    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
  3    19*     (ITS pair).
  3    20*                                                   END HISTORY COMMENTS */
  3    21 
  3    22 /* format: style2 */
  3    23 
  3    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
  3    25 
  3    26      dcl	   1 stack_header	      based (sb) aligned,
  3    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
  3    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
  3    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
  3    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
  3    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
  3    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
  3    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
  3    34 	     2 pad4	      bit (2) unal,
  3    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
  3    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
  3    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
  3    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
  3    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
  3    40 	     2 null_ptr	      ptr,		/*  (16)  */
  3    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
  3    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
  3    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
  3    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
  3    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
  3    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
  3    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
  3    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
  3    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
  3    50 	     2 return_no_pop_op_ptr
  3    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
  3    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
  3    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
  3    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
  3    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
  3    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
  3    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
  3    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
  3    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
  3    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
  3    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
  3    62 	     2 trace,
  3    63 	       3 frames,
  3    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
  3    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
  3    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
  3    67 	     2 pad2	      bit (36),		/*  (61) */
  3    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
  3    69 
  3    70 /*	The following offset refers to a table within the  pl1  operator table.  */
  3    71 
  3    72      dcl	   tv_offset	      fixed bin init (361) internal static;
  3    73 						/* (551) octal */
  3    74 
  3    75 
  3    76 /*	The following constants are offsets within this transfer vector table.  */
  3    77 
  3    78      dcl	   (
  3    79 	   call_offset	      fixed bin init (271),
  3    80 	   push_offset	      fixed bin init (272),
  3    81 	   return_offset	      fixed bin init (273),
  3    82 	   return_no_pop_offset   fixed bin init (274),
  3    83 	   entry_offset	      fixed bin init (275)
  3    84 	   )		      internal static;
  3    85 
  3    86 
  3    87 
  3    88 
  3    89 
  3    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
  3    91*	move the whole stack header should use this overlay.
  3    92**/
  3    93 
  3    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
  3    95 
  3    96 
  3    97 
  3    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
      582 
      583 
      584 
  4     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  4     2 
  4     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  4     4 
  4     5 dcl  area_infop ptr;
  4     6 
  4     7 dcl 1 area_info aligned based (area_infop),
  4     8     2 version fixed bin,				/* version number for this structure is 1 */
  4     9     2 control aligned like area_control,		/* control bits for the area */
  4    10     2 owner char (32) unal,				/* creator of the area */
  4    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  4    12     2 size fixed bin (18),				/* size of the area in words */
  4    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  4    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  4    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  4    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  4    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  4    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  4    19 
  4    20 dcl 1 area_control aligned based,
  4    21     2 extend bit (1) unal,				/* says area is extensible */
  4    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  4    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  4    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  4    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  4    26     2 system bit (1) unal,				/* says area is managed by system */
  4    27     2 pad bit (30) unal;
  4    28 
  4    29 /* END INCLUDE FILE area_info.incl.pl1 */
      585 
      586 
      587    end heap_manager_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/20/86  1145.9  heap_manager_.pl1                 >special_ldd>install>MR12.0-1222>heap_manager_.pl1
576          1    11/20/86  1035.4  system_link_names.incl.pl1        >special_ldd>install>MR12.0-1222>system_link_names.incl.pl1
579          2    11/20/86  1035.4  system_link_init_info.incl.pl1    >special_ldd>install>MR12.0-1222>system_link_init_info.incl.pl1
582          3    11/07/86  1550.3  stack_header.incl.pl1             >ldd>include>stack_header.incl.pl1
585          4    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_code                                 parameter       fixed bin(35,0)          dcl 45 set ref 107 114* 120* 175* 179* 186 200 202*
                                                                                  206* 213* 219* 302 304* 309* 317* 324* 331* 355*
                                                                                  377 379* 385* 392* 399* 406* 430* 452 456* 461*
a_exe_level                            parameter       fixed bin(17,0)          dcl 42 set ref 107 116* 166* 186* 302 328 328 335
                                                                                  348 377 403 403 410 423
a_heap_area_ptr                        parameter       pointer                  dcl 43 set ref 377 380* 412* 433*
a_heap_header_ptr                      parameter       pointer                  dcl 44 set ref 302 305* 337* 358* 452 461*
a_ring_no                              parameter       fixed bin(17,0)          dcl 48 set ref 452 461*
a_sb                                   parameter       pointer                  dcl 47 set ref 107 118 124 152 152 152 175* 179* 200
                                                                                  204 210 239 239 250 274 276 279 302 307 313 377
                                                                                  383 389 452 454 461* 528 528 528
addr                                                   builtin function         dcl 85 ref 551 551
area_block                             based           area(1024)               dcl 488 ref 560
area_control                           based           structure                level 1 dcl 4-20
area_info                              based           structure                level 1 dcl 4-7
area_info_version_1                    constant        fixed bin(17,0)          initial dcl 4-3 ref 509
area_ptr                  6            based           pointer                  level 2 dcl 1-64 set ref 155 155* 223 412 433 562*
areap                    16     000100 automatic       pointer                  level 2 dcl 484 set ref 498* 508* 542 542* 560 562
char                                                   builtin function         dcl 85 ref 505 505
cleanup                         000114 stack reference condition                dcl 62 ref 139 230 517
control                   1     000100 automatic       structure                level 2 dcl 484 set ref 494*
cu_$level_get                   000010 constant        entry                    external dcl 67 ref 131
current_heap_header_ptr                parameter       pointer                  dcl 478 ref 471 528 565
define_area_                    000012 constant        entry                    external dcl 68 ref 551
done                            000100 automatic       bit(1)                   unaligned dcl 52 set ref 342* 343 345* 348* 417* 418
                                                                                  420* 423*
error_code                             parameter       fixed bin(35,0)          dcl 480 set ref 471 551* 552
error_table_$invalid_heap       000020 external static fixed bin(35,0)          dcl 73 ref 219 324 399
error_table_$no_heap_defined    000016 external static fixed bin(35,0)          dcl 73 ref 206 213 317 331 355 392 406 430
error_table_$null_info_ptr      000022 external static fixed bin(35,0)          dcl 73 ref 120 309 385 456
exe_level                              parameter       fixed bin(17,0)          dcl 477 ref 471 505 566
execution_level          10            based           fixed bin(17,0)          level 2 dcl 1-64 set ref 179 186 287 328 348 403 423
                                                                                  566*
extend                    1     000100 automatic       bit(1)                   level 3 packed unaligned dcl 484 set ref 495*
heap_area_p                     000104 automatic       pointer                  dcl 54 set ref 223* 243 243* 258 258*
heap_header                            based           structure                level 1 unaligned dcl 1-64 set ref 560
heap_header_ptr                 000106 automatic       pointer                  dcl 55 in procedure "heap_manager_" set ref 124* 152
                                                                                  175 175* 179 179* 279* 280 283 287 313* 315 321
                                                                                  328 337 341 389* 390 396 403 412 416
heap_header_ptr          70            based           pointer                  level 2 in structure "stack_header" dcl 3-26
                                                                                  in procedure "heap_manager_" set ref 124 152 152
                                                                                  152* 210 239 239* 250* 279 313 389 528 528 528*
                                                                                  570*
heap_header_version_1           000000 constant        char(8)                  initial unaligned dcl 1-71 ref 217 283 321 396 563
heap_name_list_ptr        2            based           pointer                  level 2 dcl 1-64 set ref 564*
heap_p                          000102 automatic       pointer                  dcl 53 set ref 115* 150 152 155 155 175* 179* 186
                                                                                  210* 211 217 223 239 239 250
ltrim                                                  builtin function         dcl 85 ref 505 505
new_area                        000100 automatic       structure                level 1 unaligned dcl 484 set ref 551 551
new_heap_header_ptr                    parameter       pointer                  dcl 479 set ref 471 526 528 536* 560* 562 563 564
                                                                                  565 566 570
null                                                   builtin function         dcl 85 ref 115 118 150 152 155 175 204 211 243 258
                                                                                  276 280 305 307 315 345 355 380 383 390 420 430
                                                                                  454 461 461 498 508 526 528 536 542 564
owner                     2     000100 automatic       char(32)                 level 2 packed unaligned dcl 484 set ref 505*
previous_heap_ptr         4            based           pointer                  level 2 dcl 1-64 set ref 239 250 351 426 565*
release_area_                   000014 constant        entry                    external dcl 69 ref 155 243 258 542
ring_no                                parameter       fixed bin(17,0)          dcl 476 in procedure "create_heap" ref 471 505
ring_no                         000110 automatic       fixed bin(17,0)          dcl 56 in procedure "heap_manager_" set ref 131*
                                                                                  175* 179*
sb                                     parameter       pointer                  dcl 475 ref 471 570
size                     13     000100 automatic       fixed bin(18,0)          level 2 dcl 484 set ref 510*
stack_header                           based           structure                level 1 dcl 3-26
sys_info$max_seg_size           000024 external static fixed bin(19,0)          dcl 80 ref 510
system                    1(05) 000100 automatic       bit(1)                   level 3 packed unaligned dcl 484 set ref 497*
temp_ptr                        000112 automatic       pointer                  dcl 57 set ref 341* 345 348 351* 351 355 358 416*
                                                                                  420 423 426* 426 430 433
unspec                                                 builtin function         dcl 85 set ref 494*
version                                based           char(8)                  level 2 in structure "heap_header" packed unaligned
                                                                                  dcl 1-64 in procedure "heap_manager_" set ref 217
                                                                                  283 321 396 563*
version                         000100 automatic       fixed bin(17,0)          level 2 in structure "new_area" dcl 484 in procedure
                                                                                  "create_heap" set ref 509*
zero_on_alloc             1(01) 000100 automatic       bit(1)                   level 3 packed unaligned dcl 484 set ref 496*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
EMPTY_AREA_INIT                        internal static fixed bin(17,0)          initial dcl 2-97
INIT_DEFERRED                          internal static fixed bin(17,0)          initial dcl 2-99
ITS_PTR_INIT                           internal static fixed bin(3,0)           initial unsigned dcl 2-100
LIST_TEMPLATE_INIT                     internal static fixed bin(17,0)          initial dcl 2-98
NO_INIT                                internal static fixed bin(17,0)          initial dcl 2-95
PACKED_PTR_INIT                        internal static fixed bin(3,0)           initial unsigned dcl 2-101
PTR_INIT_ISOT                          internal static fixed bin(17,0)          initial dcl 2-104
PTR_INIT_LOT                           internal static fixed bin(17,0)          initial dcl 2-103
PTR_INIT_TEXT                          internal static fixed bin(17,0)          initial dcl 2-102
TEMPLATE_INIT                          internal static fixed bin(17,0)          initial dcl 2-96
area_infop                             automatic       pointer                  dcl 4-5
call_offset                            internal static fixed bin(17,0)          initial dcl 3-78
entry_offset                           internal static fixed bin(17,0)          initial dcl 3-78
init_info                              based           structure                level 1 dcl 2-30
init_info_ptr                          automatic       pointer                  dcl 2-27
init_info_single_word                  based           structure                level 1 dcl 2-35
init_n_bits_in_datum                   automatic       fixed bin(35,0)          dcl 2-93
init_size                              automatic       fixed bin(35,0)          dcl 2-28
list_init_info                         based           structure                level 1 dcl 2-41
list_template_entry                    based           structure                level 1 dcl 2-60
list_template_entry_ptr                based           structure                level 1 dcl 2-73
pointer_init_template                  based           structure                level 1 packed unaligned dcl 2-85
push_offset                            internal static fixed bin(17,0)          initial dcl 3-78
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 3-78
return_offset                          internal static fixed bin(17,0)          initial dcl 3-78
sb                                     automatic       pointer                  dcl 3-24
stack_header_overlay                   based           fixed bin(17,0)          array dcl 3-94
tv_offset                              internal static fixed bin(17,0)          initial dcl 3-72
variable_node                          based           structure                level 1 dcl 1-33
variable_table_header                  based           structure                level 1 dcl 1-19

NAMES DECLARED BY EXPLICIT CONTEXT.
create_heap                     001245 constant        entry                    internal dcl 471 ref 175 179 461
create_heap_for_set_ext_var     001161 constant        entry                    external dcl 452
get_heap_area                   000762 constant        entry                    external dcl 377
get_heap_header                 000563 constant        entry                    external dcl 302
get_heap_level                  000463 constant        entry                    external dcl 274
heap_manager_                   000023 constant        entry                    external dcl 38
pop_heap_level                  000271 constant        entry                    external dcl 200
push_heap_level                 000044 constant        entry                    external dcl 107

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1762        2010    1540        1772
Length      2322    1540        26         275     222           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
heap_manager_                       110 external procedure  is an external procedure.  
on unit on line 139                  68 on unit               
on unit on line 230                  68 on unit               
create_heap                         110 internal procedure  enables or reverts conditions.  
on unit on line 517                  68 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
create_heap              000100 new_area                    create_heap
heap_manager_            000100 done                        heap_manager_
                         000102 heap_p                      heap_manager_
                         000104 heap_area_p                 heap_manager_
                         000106 heap_header_ptr             heap_manager_
                         000110 ring_no                     heap_manager_
                         000112 temp_ptr                    heap_manager_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out        call_int_this       return_mac          signal_op
enable_op           shorten_stack       ext_entry           int_entry           op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$level_get                 define_area_                  release_area_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$invalid_heap     error_table_$no_heap_defined  error_table_$null_info_ptr    sys_info$max_seg_size


CONSTANTS
001534  aa  403 040 022 146	 f
001535  aa  040 321 000 000	 

000000  aa  110 145 141 160	Heap
000001  aa  137 166 060 061	_v01

001536  aa  162 000 000 000	r

001537  aa     777777777777

000002  aa     404000000043

000003  aa     464000000000

000004  aa     404000000021

000006  aa  110 145 141 160	Heap
000007  aa  137 000 000 000	_

000010  aa     077777000043
000011  aa     000001000000

000012  aa  143 154 145 141	clea
000013  aa  156 165 160 000	nup

000014  aa  162 145 164 165	retu
000015  aa  162 156 137 143	rn_c
000016  aa  157 156 166 145	onve
000017  aa  162 163 151 157	rsio
000020  aa  156 137 145 162	n_er
000021  aa  162 157 162 000	ror

BEGIN PROCEDURE heap_manager_
ENTRY TO heap_manager_                                      STATEMENT 1 ON LINE 38
heap_manager_: procedure;

000022  da     000111200000
000023  aa   000160 6270 00	eax7 	112
000024  aa  7 00034 3521 20	epp2 	pr7|28,*
000025  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000026  aa     000000000000
000027  aa     000000000000
000030  aa   000001 2360 07	ldq  	1,dl
000031  aa  6 00122 7561 00	stq  	pr6|82
						STATEMENT 1 ON LINE 93
      return;

000032  aa   000005 6010 04	tnz  	5,ic		000037
000033  aa   000027 7260 07	lxl6 	23,dl
000034  aa   777760 3520 04	epp2 	-16,ic		000014 = 162145164165
000035  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
000036  aa  0 00631 7101 00	tra  	pr0|409		return_mac
000037  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO push_heap_level                                    STATEMENT 1 ON LINE 107
push_heap_level: entry (a_sb, a_exe_level, a_code);

000040  at     000003000003
000041  tt     000004000002
000042  ta     000040000000
000043  da     000120300000
000044  aa   000160 6270 00	eax7 	112
000045  aa  7 00034 3521 20	epp2 	pr7|28,*
000046  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000047  aa     000006000000
000050  aa     000000000000
000051  aa  6 00032 3735 20	epp7 	pr6|26,*
000052  aa  7 00006 3715 20	epp5 	pr7|6,*
000053  aa  6 00124 6515 00	spri5	pr6|84
000054  aa   000001 2360 07	ldq  	1,dl
000055  aa  6 00122 7561 00	stq  	pr6|82
						STATEMENT 1 ON LINE 114
      a_code = 0;

000056  aa  6 00124 4501 20	stz  	pr6|84,*		a_code
						STATEMENT 1 ON LINE 115
      heap_p = null ();

000057  aa   777731 2370 04	ldaq 	-39,ic		000010 = 077777000043 000001000000
000060  aa  6 00102 7571 00	staq 	pr6|66		heap_p
						STATEMENT 1 ON LINE 116
      a_exe_level = -1;

000061  aa   000001 3360 07	lcq  	1,dl
000062  aa  6 00032 3735 20	epp7 	pr6|26,*
000063  aa  7 00004 7561 20	stq  	pr7|4,*		a_exe_level
						STATEMENT 1 ON LINE 118
      if a_sb = null () then
         do;

000064  aa  7 00002 2371 20	ldaq 	pr7|2,*		a_sb
000065  aa   777723 6770 04	eraq 	-45,ic		000010 = 077777000043 000001000000
000066  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000067  aa   000013 6010 04	tnz  	11,ic		000102
						STATEMENT 1 ON LINE 120
	  a_code = error_table_$null_info_ptr;

000070  aa  6 00044 3701 20	epp4 	pr6|36,*
000071  la  4 00022 2361 20	ldq  	pr4|18,*		error_table_$null_info_ptr
000072  aa  6 00124 7561 20	stq  	pr6|84,*		a_code
						STATEMENT 1 ON LINE 121
	  return;

000073  aa  6 00122 2361 00	ldq  	pr6|82
000074  aa   000005 6010 04	tnz  	5,ic		000101
000075  aa   000027 7260 07	lxl6 	23,dl
000076  aa   777716 3520 04	epp2 	-50,ic		000014 = 162145164165
000077  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
000100  aa  0 00631 7101 00	tra  	pr0|409		return_mac
000101  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 122
         end;

						STATEMENT 1 ON LINE 124
      heap_header_ptr = a_sb -> stack_header.heap_header_ptr;

000102  aa  7 00002 3715 20	epp5 	pr7|2,*		a_sb
000103  aa  5 00000 3715 20	epp5 	pr5|0,*		a_sb
000104  aa  5 00070 3535 20	epp3 	pr5|56,*		stack_header.heap_header_ptr
000105  aa  6 00106 2535 00	spri3	pr6|70		heap_header_ptr
						STATEMENT 1 ON LINE 131
      call cu_$level_get (ring_no);

000106  aa  6 00110 3521 00	epp2 	pr6|72		ring_no
000107  aa  6 00130 2521 00	spri2	pr6|88
000110  aa  6 00126 6211 00	eax1 	pr6|86
000111  aa   004000 4310 07	fld  	2048,dl
000112  aa  6 00044 3701 20	epp4 	pr6|36,*
000113  la  4 00010 3521 20	epp2 	pr4|8,*		cu_$level_get
000114  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 139
      on condition (cleanup)
         begin;

000115  aa   000007 7260 07	lxl6 	7,dl
000116  aa   777674 3520 04	epp2 	-68,ic		000012 = 143154145141
000117  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
000120  aa   000004 7100 04	tra  	4,ic		000124
000121  aa     000114000000
000122  aa   000051 7100 04	tra  	41,ic		000173
BEGIN CONDITION cleanup.1
ENTRY TO cleanup.1                                          STATEMENT 1 ON LINE 139
      on condition (cleanup)
         begin;

000123  da     000126200000
000124  aa   000120 6270 00	eax7 	80
000125  aa  7 00034 3521 20	epp2 	pr7|28,*
000126  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000127  aa     000000000000
000130  aa     000000000000
						STATEMENT 1 ON LINE 150
	  if heap_p ^= null () then
	     do;

000131  aa  6 00040 3735 20	epp7 	pr6|32,*
000132  aa  7 00102 2371 00	ldaq 	pr7|66		heap_p
000133  aa   777655 6770 04	eraq 	-83,ic		000010 = 077777000043 000001000000
000134  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000135  aa   000031 6000 04	tze  	25,ic		000166
						STATEMENT 1 ON LINE 152
	        if (a_sb -> stack_header.heap_header_ptr ^= null ()) &
		   (heap_p = a_sb -> stack_header.heap_header_ptr) then
		 a_sb -> stack_header.heap_header_ptr = heap_header_ptr;

000136  aa  7 00032 3715 20	epp5 	pr7|26,*
000137  aa  5 00002 3535 20	epp3 	pr5|2,*		a_sb
000140  aa  3 00000 3535 20	epp3 	pr3|0,*		a_sb
000141  aa  3 00070 2371 00	ldaq 	pr3|56		stack_header.heap_header_ptr
000142  aa   777646 6770 04	eraq 	-90,ic		000010 = 077777000043 000001000000
000143  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000144  aa   000007 6000 04	tze  	7,ic		000153
000145  aa  7 00102 2371 00	ldaq 	pr7|66		heap_p
000146  aa  3 00070 6771 00	eraq 	pr3|56		stack_header.heap_header_ptr
000147  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000150  aa   000003 6010 04	tnz  	3,ic		000153
000151  aa  7 00106 3515 20	epp1 	pr7|70,*		heap_header_ptr
000152  aa  3 00070 2515 00	spri1	pr3|56		stack_header.heap_header_ptr
						STATEMENT 1 ON LINE 155
	        if heap_p -> heap_header.area_ptr ^= null () then
		 call release_area_ (heap_p -> heap_header.area_ptr);

000153  aa  7 00102 3515 20	epp1 	pr7|66,*		heap_p
000154  aa  1 00006 2371 00	ldaq 	pr1|6		heap_header.area_ptr
000155  aa   777633 6770 04	eraq 	-101,ic		000010 = 077777000043 000001000000
000156  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000157  aa   000007 6000 04	tze  	7,ic		000166
000160  aa  1 00006 3521 00	epp2 	pr1|6		heap_header.area_ptr
000161  aa  6 00102 2521 00	spri2	pr6|66
000162  aa  6 00100 6211 00	eax1 	pr6|64
000163  aa   004000 4310 07	fld  	2048,dl
000164  la  4 00014 3521 20	epp2 	pr4|12,*		release_area_
000165  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 157
	     end;

						STATEMENT 1 ON LINE 166
	  a_exe_level = -1;

000166  aa   000001 3360 07	lcq  	1,dl
000167  aa  6 00040 3735 20	epp7 	pr6|32,*
000170  aa  7 00032 3715 20	epp5 	pr7|26,*
000171  aa  5 00004 7561 20	stq  	pr5|4,*		a_exe_level
						STATEMENT 1 ON LINE 168
         end;

000172  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END CONDITION cleanup.1
						STATEMENT 1 ON LINE 175
      if heap_header_ptr = null () then
         call create_heap (a_sb, ring_no, 1, heap_header_ptr, heap_p,
	    a_code);

000173  aa  6 00106 2371 00	ldaq 	pr6|70		heap_header_ptr
000174  aa   777614 6770 04	eraq 	-116,ic		000010 = 077777000043 000001000000
000175  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000176  aa   000025 6010 04	tnz  	21,ic		000223
000177  aa   000001 2360 07	ldq  	1,dl
000200  aa  6 00132 7561 00	stq  	pr6|90
000201  aa  6 00032 3735 20	epp7 	pr6|26,*
000202  aa  7 00002 3521 20	epp2 	pr7|2,*		a_sb
000203  aa  6 00136 2521 00	spri2	pr6|94
000204  aa  6 00110 3521 00	epp2 	pr6|72		ring_no
000205  aa  6 00140 2521 00	spri2	pr6|96
000206  aa  6 00132 3521 00	epp2 	pr6|90
000207  aa  6 00142 2521 00	spri2	pr6|98
000210  aa  6 00106 3521 00	epp2 	pr6|70		heap_header_ptr
000211  aa  6 00144 2521 00	spri2	pr6|100
000212  aa  6 00102 3521 00	epp2 	pr6|66		heap_p
000213  aa  6 00146 2521 00	spri2	pr6|102
000214  aa  6 00124 3521 20	epp2 	pr6|84,*		a_code
000215  aa  6 00150 2521 00	spri2	pr6|104
000216  aa  6 00134 6211 00	eax1 	pr6|92
000217  aa   030000 4310 07	fld  	12288,dl
000220  aa   001025 3520 04	epp2 	533,ic		001245 = 000160627000
000221  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
000222  aa   000026 7100 04	tra  	22,ic		000250
						STATEMENT 1 ON LINE 179
      else
         call create_heap (a_sb, ring_no,
	    (heap_header_ptr -> heap_header.execution_level + 1),
	    heap_header_ptr, heap_p, a_code);

000223  aa  6 00106 3735 20	epp7 	pr6|70,*		heap_header_ptr
000224  aa  7 00010 2361 00	ldq  	pr7|8		heap_header.execution_level
000225  aa   000001 0760 07	adq  	1,dl
000226  aa  6 00132 7561 00	stq  	pr6|90
000227  aa  6 00032 3715 20	epp5 	pr6|26,*
000230  aa  5 00002 3521 20	epp2 	pr5|2,*		a_sb
000231  aa  6 00136 2521 00	spri2	pr6|94
000232  aa  6 00110 3521 00	epp2 	pr6|72		ring_no
000233  aa  6 00140 2521 00	spri2	pr6|96
000234  aa  6 00132 3521 00	epp2 	pr6|90
000235  aa  6 00142 2521 00	spri2	pr6|98
000236  aa  6 00106 3521 00	epp2 	pr6|70		heap_header_ptr
000237  aa  6 00144 2521 00	spri2	pr6|100
000240  aa  6 00102 3521 00	epp2 	pr6|66		heap_p
000241  aa  6 00146 2521 00	spri2	pr6|102
000242  aa  6 00124 3521 20	epp2 	pr6|84,*		a_code
000243  aa  6 00150 2521 00	spri2	pr6|104
000244  aa  6 00134 6211 00	eax1 	pr6|92
000245  aa   030000 4310 07	fld  	12288,dl
000246  aa   000777 3520 04	epp2 	511,ic		001245 = 000160627000
000247  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 186
      if a_code = 0 then
         a_exe_level = heap_p -> heap_header.execution_level;

000250  aa  6 00124 2361 20	ldq  	pr6|84,*		a_code
000251  aa   000005 6010 04	tnz  	5,ic		000256
000252  aa  6 00102 3735 20	epp7 	pr6|66,*		heap_p
000253  aa  7 00010 2361 00	ldq  	pr7|8		heap_header.execution_level
000254  aa  6 00032 3715 20	epp5 	pr6|26,*
000255  aa  5 00004 7561 20	stq  	pr5|4,*		a_exe_level
						STATEMENT 1 ON LINE 189
      return;

000256  aa  6 00122 2361 00	ldq  	pr6|82
000257  aa   000005 6010 04	tnz  	5,ic		000264
000260  aa   000027 7260 07	lxl6 	23,dl
000261  aa   777533 3520 04	epp2 	-165,ic		000014 = 162145164165
000262  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
000263  aa  0 00631 7101 00	tra  	pr0|409		return_mac
000264  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO pop_heap_level                                     STATEMENT 1 ON LINE 200
pop_heap_level: entry (a_sb, a_code);

000265  at     000002000003
000266  ta     000002000000
000267  ta     000265000000
000270  da     000135300000
000271  aa   000160 6270 00	eax7 	112
000272  aa  7 00034 3521 20	epp2 	pr7|28,*
000273  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000274  aa     000004000000
000275  aa     000000000000
000276  aa  6 00032 3735 20	epp7 	pr6|26,*
000277  aa  7 00004 3715 20	epp5 	pr7|4,*
000300  aa  6 00124 6515 00	spri5	pr6|84
000301  aa   000001 2360 07	ldq  	1,dl
000302  aa  6 00122 7561 00	stq  	pr6|82
						STATEMENT 1 ON LINE 202
      a_code = 0;

000303  aa  6 00124 4501 20	stz  	pr6|84,*		a_code
						STATEMENT 1 ON LINE 204
      if a_sb = null () then
         do;

000304  aa  6 00032 3735 20	epp7 	pr6|26,*
000305  aa  7 00002 2371 20	ldaq 	pr7|2,*		a_sb
000306  aa   777502 6770 04	eraq 	-190,ic		000010 = 077777000043 000001000000
000307  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000310  aa   000013 6010 04	tnz  	11,ic		000323
						STATEMENT 1 ON LINE 206
	  a_code = error_table_$no_heap_defined;

000311  aa  6 00044 3701 20	epp4 	pr6|36,*
000312  la  4 00016 2361 20	ldq  	pr4|14,*		error_table_$no_heap_defined
000313  aa  6 00124 7561 20	stq  	pr6|84,*		a_code
						STATEMENT 1 ON LINE 207
	  return;

000314  aa  6 00122 2361 00	ldq  	pr6|82
000315  aa   000005 6010 04	tnz  	5,ic		000322
000316  aa   000027 7260 07	lxl6 	23,dl
000317  aa   777475 3520 04	epp2 	-195,ic		000014 = 162145164165
000320  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
000321  aa  0 00631 7101 00	tra  	pr0|409		return_mac
000322  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 208
         end;

						STATEMENT 1 ON LINE 210
      heap_p = a_sb -> stack_header.heap_header_ptr;

000323  aa  7 00002 3715 20	epp5 	pr7|2,*		a_sb
000324  aa  5 00000 3715 20	epp5 	pr5|0,*		a_sb
000325  aa  5 00070 3535 20	epp3 	pr5|56,*		stack_header.heap_header_ptr
000326  aa  6 00102 2535 00	spri3	pr6|66		heap_p
						STATEMENT 1 ON LINE 211
      if heap_p = null () then
         do;

000327  aa  6 00102 2371 00	ldaq 	pr6|66		heap_p
000330  aa   777460 6770 04	eraq 	-208,ic		000010 = 077777000043 000001000000
000331  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000332  aa   000013 6010 04	tnz  	11,ic		000345
						STATEMENT 1 ON LINE 213
	  a_code = error_table_$no_heap_defined;

000333  aa  6 00044 3701 20	epp4 	pr6|36,*
000334  la  4 00016 2361 20	ldq  	pr4|14,*		error_table_$no_heap_defined
000335  aa  6 00124 7561 20	stq  	pr6|84,*		a_code
						STATEMENT 1 ON LINE 214
	  return;

000336  aa  6 00122 2361 00	ldq  	pr6|82
000337  aa   000005 6010 04	tnz  	5,ic		000344
000340  aa   000027 7260 07	lxl6 	23,dl
000341  aa   777453 3520 04	epp2 	-213,ic		000014 = 162145164165
000342  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
000343  aa  0 00631 7101 00	tra  	pr0|409		return_mac
000344  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 e_area_ (heap_area_p);

000435  aa  6 00104 2371 00	ldaq 	pr6|68		heap_area_p
000436  aa   777352 6770 04	eraq 	-278,ic		000010 = 077777000043 000001000000
000437  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000440  aa   000010 6000 04	tze  	8,ic		000450
000441  aa  6 00104 3521 00	epp2 	pr6|68		heap_area_p
000442  aa  6 00130 2521 00	spri2	pr6|88
000443  aa  6 00126 6211 00	eax1 	pr6|86
000444  aa   004000 4310 07	fld  	2048,dl
000445  aa  6 00044 3701 20	epp4 	pr6|36,*
000446  la  4 00014 3521 20	epp2 	pr4|12,*		release_area_
000447  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 261
      return;

000450  aa  6 00122 2361 00	ldq  	pr6|82
000451  aa   000005 6010 04	tnz  	5,ic		000456
000452  aa   000027 7260 07	lxl6 	23,dl
000453  aa   777341 3520 04	epp2 	-287,ic		000014 = 162145164165
000454  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
000455  aa  0 00631 7101 00	tra  	pr0|409		return_mac
000456  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO get_heap_level                                     STATEMENT 1 ON LINE 274
get_heap_level: entry (a_sb) returns (fixed bin (17));

000457  at     000002000003
000460  ta     000004000000
000461  ta     000457000000
000462  da     000152320000
000463  aa   000160 6270 00	eax7 	112
000464  aa  7 00034 3521 20	epp2 	pr7|28,*
000465  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000466  aa     000004000000
000467  aa     000000000000
000470  aa  6 00122 4501 00	stz  	pr6|82
						STATEMENT 1 ON LINE 276
      if a_sb = null () then
         return (-1);

000471  aa  6 00032 3735 20	epp7 	pr6|26,*
000472  aa  7 00002 2371 20	ldaq 	pr7|2,*		a_sb
000473  aa   777315 6770 04	eraq 	-307,ic		000010 = 077777000043 000001000000
000474  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000475  aa   000012 6010 04	tnz  	10,ic		000507
000476  aa  6 00122 2361 00	ldq  	pr6|82
000477  aa   000004 6010 04	tnz  	4,ic		000503
000500  aa   000001 3360 07	lcq  	1,dl
000501  aa  7 00004 7561 20	stq  	pr7|4,*
000502  aa  0 00631 7101 00	tra  	pr0|409		return_mac
000503  aa   000027 7260 07	lxl6 	23,dl
000504  aa   777310 3520 04	epp2 	-312,ic		000014 = 162145164165
000505  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
000506  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 279
      heap_header_ptr = a_sb -> stack_header.heap_header_ptr;

000507  aa  7 00002 3715 20	epp5 	pr7|2,*		a_sb
000510  aa  5 00000 3715 20	epp5 	pr5|0,*		a_sb
000511  aa  5 00070 3535 20	epp3 	pr5|56,*		stack_header.heap_header_ptr
000512  aa  6 00106 2535 00	spri3	pr6|70		heap_header_ptr
						STATEMENT 1 ON LINE 280
      if heap_header_ptr = null () then
         return (-1);

000513  aa  6 00106 2371 00	ldaq 	pr6|70		heap_header_ptr
000514  aa   777274 6770 04	eraq 	-324,ic		000010 = 077777000043 000001000000
000515  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000516  aa   000012 6010 04	tnz  	10,ic		000530
000517  aa  6 00122 2361 00	ldq  	pr6|82
000520  aa   000004 6010 04	tnz  	4,ic		000524
000521  aa   000001 3360 07	lcq  	1,dl
000522  aa  7 00004 7561 20	stq  	pr7|4,*
000523  aa  0 00631 7101 00	tra  	pr0|409		return_mac
000524  aa   000027 7260 07	lxl6 	23,dl
000525  aa   777267 3520 04	epp2 	-329,ic		000014 = 162145164165
000526  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
000527  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 283
      if (heap_header_ptr -> heap_header.version ^=
	 heap_header_version_1) then
         return (-1);

000530  aa  3 00000 2351 00	lda  	pr3|0		heap_header.version
000531  aa  3 00001 2361 00	ldq  	pr3|1		heap_header.version
000532  aa   777246 1170 04	cmpaq	-346,ic		000000 = 110145141160 137166060061
000533  aa   000012 6000 04	tze  	10,ic		000545
000534  aa  6 00122 2361 00	ldq  	pr6|82
000535  aa   000004 6010 04	tnz  	4,ic		000541
000536  aa   000001 3360 07	lcq  	1,dl
000537  aa  7 00004 7561 20	stq  	pr7|4,*
000540  aa  0 00631 7101 00	tra  	pr0|409		return_mac
000541  aa   000027 7260 07	lxl6 	23,dl
000542  aa   777252 3520 04	epp2 	-342,ic		000014 = 162145164165
000543  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
000544  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 287
      return (heap_header_ptr -> heap_header.execution_level);

000545  aa  6 00122 2361 00	ldq  	pr6|82
000546  aa   000004 6010 04	tnz  	4,ic		000552
000547  aa  3 00010 2361 00	ldq  	pr3|8		heap_header.execution_level
000550  aa  7 00004 7561 20	stq  	pr7|4,*
000551  aa  0 00631 7101 00	tra  	pr0|409		return_mac
000552  aa   000027 7260 07	lxl6 	23,dl
000553  aa   777241 3520 04	epp2 	-351,ic		000014 = 162145164165
000554  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
000555  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO get_heap_header                                    STATEMENT 1 ON LINE 302
get_heap_header: entry (a_sb, a_exe_level, a_heap_header_ptr, a_code);

000556  at     000004000003
000557  tt     000004000003
000560  ta     000002000000
000561  ta     000556000000
000562  da     000161300000
000563  aa   000160 6270 00	eax7 	112
000564  aa  7 00034 3521 20	epp2 	pr7|28,*
000565  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000566  aa     000010000000
000567  aa     000000000000
000570  aa  6 00032 3735 20	epp7 	pr6|26,*
000571  aa  7 00010 3715 20	epp5 	pr7|8,*
000572  aa  6 00124 6515 00	spri5	pr6|84
000573  aa   000001 2360 07	ldq  	1,dl
000574  aa  6 00122 7561 00	stq  	pr6|82
						STATEMENT 1 ON LINE 304
      a_code = 0;

000575  aa  6 00124 4501 20	stz  	pr6|84,*		a_code
						STATEMENT 1 ON LINE 305
      a_heap_header_ptr = null ();

000576  aa   777212 2370 04	ldaq 	-374,ic		000010 = 077777000043 000001000000
000577  aa  6 00032 3735 20	epp7 	pr6|26,*
000600  aa  7 00006 7571 20	staq 	pr7|6,*		a_heap_header_ptr
						STATEMENT 1 ON LINE 307
      if a_sb = null () then
         do;

000601  aa  7 00002 6771 20	eraq 	pr7|2,*		a_sb
000602  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000603  aa   000013 6010 04	tnz  	11,ic		000616
						STATEMENT 1 ON LINE 309
	  a_code = error_table_$null_info_ptr;

000604  aa  6 00044 3701 20	epp4 	pr6|36,*
000605  la  4 00022 2361 20	ldq  	pr4|18,*		error_table_$null_info_ptr
000606  aa  6 00124 7561 20	stq  	pr6|84,*		a_code
						STATEMENT 1 ON LINE 310
	  return;

000607  aa  6 00122 2361 00	ldq  	pr6|82
000610  aa   000005 6010 04	tnz  	5,ic		000615
000611  aa   000027 7260 07	lxl6 	23,dl
000612  aa   777202 3520 04	epp2 	-382,ic		000014 = 162145164165
000613  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
000614  aa  0 00631 7101 00	tra  	pr0|409		return_mac
000615  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 311
         end;

						STATEMENT 1 ON LINE 313
      heap_header_ptr = a_sb -> stack_header.heap_header_ptr;

000616  aa  7 00002 3715 20	epp5 	pr7|2,*		a_sb
000617  aa  5 00000 3715 20	epp5 	pr5|0,*		a_sb
000620  aa  5 00070 3535 20	epp3 	pr5|56,*		stack_header.heap_header_ptr
000621  aa  6 00106 2535 00	spri3	pr6|70		heap_header_ptr
						STATEMENT 1 ON LINE 315
      if heap_header_ptr = null () then
         do;

000622  aa  6 00106 2371 00	ldaq 	pr6|70		heap_header_ptr
000623  aa   777165 6770 04	eraq 	-395,ic		000010 = 077777000043 000001000000
000624  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000625  aa   000013 6010 04	tnz  	11,ic		000640
						STATEMENT 1 ON LINE 317
	  a_code = error_table_$no_heap_defined;

000626  aa  6 00044 3701 20	epp4 	pr6|36,*
000627  la  4 00016 2361 20	ldq  	pr4|14,*		error_table_$no_heap_defined
000630  aa  6 00124 7561 20	stq  	pr6|84,*		a_code
						STATEMENT 1 ON LINE 318
	  return;

000631  aa  6 00122 2361 00	ldq  	pr6|82
000632  aa   000005 6010 04	tnz  	5,ic		000637
000633  aa   000027 7260 07	lxl6 	23,dl
000634  aa   777160 3520 04	epp2 	-400,ic		000014 = 162145164165
000635  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
000636  aa  0 00631 7101 00	tra  	pr0|409		return_mac
000637  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 319
         end;

						STATEMENT 1 ON LINE 321
      if (heap_header_ptr -> heap_header.version ^=
	 heap_header_version_1) then
         do;

000640  aa  3 00000 2351 00	lda  	pr3|0		heap_header.version
000641  aa  3 00001 2361 00	ldq  	pr3|1		heap_header.version
000642  aa   777136 1170 04	cmpaq	-418,ic		000000 = 110145141160 137166060061
000643  aa   000013 6000 04	tze  	11,ic		000656
						STATEMENT 1 ON LINE 324
	  a_code = error_table_$invalid_heap;

000644  aa  6 00044 3701 20	epp4 	pr6|36,*
000645  la  4 00020 2361 20	ldq  	pr4|16,*		error_table_$invalid_heap
000646  aa  6 00124 7561 20	stq  	pr6|84,*		a_code
						STATEMENT 1 ON LINE 325
	  return;

000647  aa  6 00122 2361 00	ldq  	pr6|82
000650  aa   000005 6010 04	tnz  	5,ic		000655
000651  aa   000027 7260 07	lxl6 	23,dl
000652  aa   777142 3520 04	epp2 	-414,ic		000014 = 162145164165
000653  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
000654  aa  0 00631 7101 00	tra  	pr0|409		return_mac
000655  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 326
         end;

						STATEMENT 1 ON LINE 328
      if (heap_header_ptr -> heap_header.execution_level < a_exe_level) |
	 (a_exe_level < -1) then
         do;

000656  aa  3 00010 2361 00	ldq  	pr3|8		heap_header.execution_level
000657  aa  7 00004 1161 20	cmpq 	pr7|4,*		a_exe_level
000660  aa   000004 6040 04	tmi  	4,ic		000664
000661  aa  7 00004 2361 20	ldq  	pr7|4,*		a_exe_level
000662  aa   000655 1160 04	cmpq 	429,ic		001537 = 777777777777
000663  aa   000013 6050 04	tpl  	11,ic		000676
						STATEMENT 1 ON LINE 331
	  a_code = error_table_$no_heap_defined;

000664  aa  6 00044 3701 20	epp4 	pr6|36,*
000665  la  4 00016 2361 20	ldq  	pr4|14,*		error_table_$no_heap_defined
000666  aa  6 00124 7561 20	stq  	pr6|84,*		a_code
						STATEMENT 1 ON LINE 332
	  return;

000667  aa  6 00122 2361 00	ldq  	pr6|82
000670  aa   000005 6010 04	tnz  	5,ic		000675
000671  aa   000027 7260 07	lxl6 	23,dl
000672  aa   777122 3520 04	epp2 	-430,ic		000014 = 162145164165
000673  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
000674  aa  0 00631 7101 00	tra  	pr0|409		return_mac
000675  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 333
         end;

						STATEMENT 1 ON LINE 335
      if a_exe_level = -1 then
         do;

000676  aa   000011 6010 04	tnz  	9,ic		000707
						STATEMENT 1 ON LINE 337
	  a_heap_header_ptr = heap_header_ptr;

000677  aa  7 00006 2535 20	spri3	pr7|6,*		a_heap_header_ptr
						STATEMENT 1 ON LINE 338
	  return;

000700  aa  6 00122 2361 00	ldq  	pr6|82
000701  aa   000005 6010 04	tnz  	5,ic		000706
000702  aa   000027 7260 07	lxl6 	23,dl
000703  aa   777111 3520 04	epp2 	-439,ic		000014 = 162145164165
000704  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
000705  aa  0 00631 7101 00	tra  	pr0|409		return_mac
000706  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 339
         end;

						STATEMENT 1 ON LINE 341
      temp_ptr = heap_header_ptr;

000707  aa  6 00112 2535 00	spri3	pr6|74		temp_ptr
						STATEMENT 1 ON LINE 342
      done = "0"b;

000710  aa  6 00100 4501 00	stz  	pr6|64		done
						STATEMENT 1 ON LINE 343
      do while (^done);

000711  aa   000000 0110 03	nop  	0,du
000712  aa  6 00100 2351 00	lda  	pr6|64		done
000713  aa   000023 6010 04	tnz  	19,ic		000736
						STATEMENT 1 ON LINE 345
         if (temp_ptr = null ()) then
	  done = "1"b;

000714  aa  6 00112 2371 00	ldaq 	pr6|74		temp_ptr
000715  aa   777073 6770 04	eraq 	-453,ic		000010 = 077777000043 000001000000
000716  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000717  aa   000004 6010 04	tnz  	4,ic		000723
000720  aa   400000 2350 03	lda  	131072,du
000721  aa  6 00100 7551 00	sta  	pr6|64		done
000722  aa   777770 7100 04	tra  	-8,ic		000712
						STATEMENT 1 ON LINE 348
         else if (a_exe_level = temp_ptr -> heap_header.execution_level) then
	  done = "1"b;

000723  aa  6 00032 3735 20	epp7 	pr6|26,*
000724  aa  7 00004 2361 20	ldq  	pr7|4,*		a_exe_level
000725  aa  6 00112 3715 20	epp5 	pr6|74,*		temp_ptr
000726  aa  5 00010 1161 00	cmpq 	pr5|8		heap_header.execution_level
000727  aa   000004 6010 04	tnz  	4,ic		000733
000730  aa   400000 2350 03	lda  	131072,du                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                077
001024  aa   000013 6010 04	tnz  	11,ic		001037
						STATEMENT 1 ON LINE 392
	  a_code = error_table_$no_heap_defined;

001025  aa  6 00044 3701 20	epp4 	pr6|36,*
001026  la  4 00016 2361 20	ldq  	pr4|14,*		error_table_$no_heap_defined
001027  aa  6 00124 7561 20	stq  	pr6|84,*		a_code
						STATEMENT 1 ON LINE 393
	  return;

001030  aa  6 00122 2361 00	ldq  	pr6|82
001031  aa   000005 6010 04	tnz  	5,ic		001036
001032  aa   000027 7260 07	lxl6 	23,dl
001033  aa   776761 3520 04	epp2 	-527,ic		000014 = 162145164165
001034  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
001035  aa  0 00631 7101 00	tra  	pr0|409		return_mac
001036  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 394
         end;

						STATEMENT 1 ON LINE 396
      if (heap_header_ptr -> heap_header.version ^=
	 heap_header_version_1) then
         do;

001037  aa  3 00000 2351 00	lda  	pr3|0		heap_header.version
001040  aa  3 00001 2361 00	ldq  	pr3|1		heap_header.version
001041  aa   776737 1170 04	cmpaq	-545,ic		000000 = 110145141160 137166060061
001042  aa   000013 6000 04	tze  	11,ic		001055
						STATEMENT 1 ON LINE 399
	  a_code = error_table_$invalid_heap;

001043  aa  6 00044 3701 20	epp4 	pr6|36,*
001044  la  4 00020 2361 20	ldq  	pr4|16,*		error_table_$invalid_heap
001045  aa  6 00124 7561 20	stq  	pr6|84,*		a_code
						STATEMENT 1 ON LINE 400
	  return;

001046  aa  6 00122 2361 00	ldq  	pr6|82
001047  aa   000005 6010 04	tnz  	5,ic		001054
001050  aa   000027 7260 07	lxl6 	23,dl
001051  aa   776743 3520 04	epp2 	-541,ic		000014 = 162145164165
001052  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
001053  aa  0 00631 7101 00	tra  	pr0|409		return_mac
001054  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 401
         end;

						STATEMENT 1 ON LINE 403
      if (a_exe_level > heap_header_ptr -> heap_header.execution_level) |
	 (a_exe_level < -1) then
         do;

001055  aa  7 00004 2361 20	ldq  	pr7|4,*		a_exe_level
001056  aa  3 00010 1161 00	cmpq 	pr3|8		heap_header.execution_level
001057  aa   000003 6054 04	tpnz 	3,ic		001062
001060  aa   000457 1160 04	cmpq 	303,ic		001537 = 777777777777
001061  aa   000013 6050 04	tpl  	11,ic		001074
						STATEMENT 1 ON LINE 406
	  a_code = error_table_$no_heap_defined;

001062  aa  6 00044 3701 20	epp4 	pr6|36,*
001063  la  4 00016 2361 20	ldq  	pr4|14,*		error_table_$no_heap_defined
001064  aa  6 00124 7561 20	stq  	pr6|84,*		a_code
						STATEMENT 1 ON LINE 407
	  return;

001065  aa  6 00122 2361 00	ldq  	pr6|82
001066  aa   000005 6010 04	tnz  	5,ic		001073
001067  aa   000027 7260 07	lxl6 	23,dl
001070  aa   776724 3520 04	epp2 	-556,ic		000014 = 162145164165
001071  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
001072  aa  0 00631 7101 00	tra  	pr0|409		return_mac
001073  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 408
         end;

						STATEMENT 1 ON LINE 410
      if a_exe_level = -1 then
         do;

001074  aa   000012 6010 04	tnz  	10,ic		001106
						STATEMENT 1 ON LINE 412
	  a_heap_area_ptr = heap_header_ptr -> heap_header.area_ptr;

001075  aa  3 00006 3515 20	epp1 	pr3|6,*		heap_header.area_ptr
001076  aa  7 00006 2515 20	spri1	pr7|6,*		a_heap_area_ptr
						STATEMENT 1 ON LINE 413
	  return;

001077  aa  6 00122 2361 00	ldq  	pr6|82
001100  aa   000005 6010 04	tnz  	5,ic		001105
001101  aa   000027 7260 07	lxl6 	23,dl
001102  aa   776712 3520 04	epp2 	-566,ic		000014 = 162145164165
001103  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
001104  aa  0 00631 7101 00	tra  	pr0|409		return_mac
001105  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 414
         end;

						STATEMENT 1 ON LINE 416
      temp_ptr = heap_header_ptr;

001106  aa  6 00112 2535 00	spri3	pr6|74		temp_ptr
						STATEMENT 1 ON LINE 417
      done = "0"b;

001107  aa  6 00100 4501 00	stz  	pr6|64		done
						STATEMENT 1 ON LINE 418
      do while (^done);

001110  aa  6 00100 2351 00	lda  	pr6|64		done
001111  aa   000023 6010 04	tnz  	19,ic		001134
						STATEMENT 1 ON LINE 420
         if (temp_ptr = null ()) then
	  done = "1"b;

001112  aa  6 00112 2371 00	ldaq 	pr6|74		temp_ptr
001113  aa   776675 6770 04	eraq 	-579,ic		000010 = 077777000043 000001000000
001114  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001115  aa   000004 6010 04	tnz  	4,ic		001121
001116  aa   400000 2350 03	lda  	131072,du
001117  aa  6 00100 7551 00	sta  	pr6|64		done
001120  aa   777770 7100 04	tra  	-8,ic		001110
						STATEMENT 1 ON LINE 423
         else if (a_exe_level = temp_ptr -> heap_header.execution_level) then
	  done = "1"b;

001121  aa  6 00032 3735 20	epp7 	pr6|26,*
001122  aa  7 00004 2361 20	ldq  	pr7|4,*		a_exe_level
001123  aa  6 00112 3715 20	epp5 	pr6|74,*		temp_ptr
001124  aa  5 00010 1161 00	cmpq 	pr5|8		heap_header.execution_level
001125  aa   000004 6010 04	tnz  	4,ic		001131
001126  aa   400000 2350 03	lda  	131072,du
001127  aa  6 00100 7551 00	sta  	pr6|64		done
001130  aa   777760 7100 04	tra  	-16,ic		001110
						STATEMENT 1 ON LINE 426
         else
	  temp_ptr = temp_ptr -> heap_header.previous_heap_ptr;

001131  aa  5 00004 3535 20	epp3 	pr5|4,*		heap_header.previous_heap_ptr
001132  aa  6 00112 2535 00	spri3	pr6|74		temp_ptr
						STATEMENT 1 ON LINE 428
      end;

001133  aa   777755 7100 04	tra  	-19,ic		001110
						STATEMENT 1 ON LINE 430
      if temp_ptr = null () then
         a_code = error_table_$no_heap_defined;

001134  aa  6 00112 2371 00	ldaq 	pr6|74		temp_ptr
001135  aa   776653 6770 04	eraq 	-597,ic		000010 = 077777000043 000001000000
001136  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001137  aa   000005 6010 04	tnz  	5,ic		001144
001140  aa  6 00044 3701 20	epp4 	pr6|36,*
001141  la  4 00016 2361 20	ldq  	pr4|14,*		error_table_$no_heap_defined
001142  aa  6 00124 7561 20	stq  	pr6|84,*		a_code
001143  aa   000005 7100 04	tra  	5,ic		001150
						STATEMENT 1 ON LINE 433
      else
         a_heap_area_ptr = temp_ptr -> heap_header.area_ptr;

001144  aa  6 00112 3735 20	epp7 	pr6|74,*		temp_ptr
001145  aa  7 00006 3735 20	epp7 	pr7|6,*		heap_header.area_ptr
001146  aa  6 00032 3715 20	epp5 	pr6|26,*
001147  aa  5 00006 6535 20	spri7	pr5|6,*		a_heap_area_ptr
						STATEMENT 1 ON LINE 436
      return;

001150  aa  6 00122 2361 00	ldq  	pr6|82
001151  aa   000005 6010 04	tnz  	5,ic		001156
001152  aa   000027 7260 07	lxl6 	23,dl
001153  aa   776641 3520 04	epp2 	-607,ic		000014 = 162145164165
001154  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
001155  aa  0 00631 7101 00	tra  	pr0|409		return_mac
001156  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO create_heap_for_set_ext_var                        STATEMENT 1 ON LINE 452
create_heap_for_set_ext_var: entry (a_sb, a_ring_no, a_heap_header_ptr, a_code);

001157  ta     000556000000
001160  da     000202300000
001161  aa   000160 6270 00	eax7 	112
001162  aa  7 00034 3521 20	epp2 	pr7|28,*
001163  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001164  aa     000010000000
001165  aa     000000000000
001166  aa  6 00032 3735 20	epp7 	pr6|26,*
001167  aa  7 00010 3715 20	epp5 	pr7|8,*
001170  aa  6 00124 6515 00	spri5	pr6|84
001171  aa   000001 2360 07	ldq  	1,dl
001172  aa  6 00122 7561 00	stq  	pr6|82
						STATEMENT 1 ON LINE 454
      if a_sb = null () then
         do;

001173  aa  6 00032 3735 20	epp7 	pr6|26,*
001174  aa  7 00002 2371 20	ldaq 	pr7|2,*		a_sb
001175  aa   776613 6770 04	eraq 	-629,ic		000010 = 077777000043 000001000000
001176  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001177  aa   000013 6010 04	tnz  	11,ic		001212
						STATEMENT 1 ON LINE 456
	  a_code = error_table_$null_info_ptr;

001200  aa  6 00044 3701 20	epp4 	pr6|36,*
001201  la  4 00022 2361 20	ldq  	pr4|18,*		error_table_$null_info_ptr
001202  aa  6 00124 7561 20	stq  	pr6|84,*		a_code
						STATEMENT 1 ON LINE 457
	  return;

001203  aa  6 00122 2361 00	ldq  	pr6|82
001204  aa   000005 6010 04	tnz  	5,ic		001211
001205  aa   000027 7260 07	lxl6 	23,dl
001206  aa   776606 3520 04	epp2 	-634,ic		000014 = 162145164165
001207  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
001210  aa  0 00631 7101 00	tra  	pr0|409		return_mac
001211  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 458
         end;

						STATEMENT 1 ON LINE 461
      call create_heap (a_sb, a_ring_no, 0, null (), a_heap_header_ptr, a_code);

001212  aa  6 00132 4501 00	stz  	pr6|90
001213  aa   776575 3714 24	epp5 	-643,ic*
001214  aa  6 00154 6515 00	spri5	pr6|108
001215  aa  7 00002 3521 20	epp2 	pr7|2,*		a_sb
001216  aa  6 00136 2521 00	spri2	pr6|94
001217  aa  7 00004 3521 20	epp2 	pr7|4,*		a_ring_no
001220  aa  6 00140 2521 00	spri2	pr6|96
001221  aa  6 00132 3521 00	epp2 	pr6|90
001222  aa  6 00142 2521 00	spri2	pr6|98
001223  aa  6 00154 3521 00	epp2 	pr6|108
001224  aa  6 00144 2521 00	spri2	pr6|100
001225  aa  7 00006 3521 20	epp2 	pr7|6,*		a_heap_header_ptr
001226  aa  6 00146 2521 00	spri2	pr6|102
001227  aa  6 00124 3521 20	epp2 	pr6|84,*		a_code
001230  aa  6 00150 2521 00	spri2	pr6|104
001231  aa  6 00134 6211 00	eax1 	pr6|92
001232  aa   030000 4310 07	fld  	12288,dl
001233  aa   000012 3520 04	epp2 	10,ic		001245 = 000160627000
001234  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 463
      return;

001235  aa  6 00122 2361 00	ldq  	pr6|82
001236  aa   000005 6010 04	tnz  	5,ic		001243
001237  aa   000027 7260 07	lxl6 	23,dl
001240  aa   776554 3520 04	epp2 	-660,ic		000014 = 162145164165
001241  aa  0 00716 7001 00	tsx0 	pr0|462		signal_op
001242  aa  0 00631 7101 00	tra  	pr0|409		return_mac
001243  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 587
   end heap_manager_;

BEGIN PROCEDURE create_heap
ENTRY TO create_heap                                        STATEMENT 1 ON LINE 471
create_heap: procedure (sb, ring_no, exe_level, current_heap_header_ptr, new_heap_header_ptr, error_code);

001244  da     000210200000
001245  aa   000160 6270 00	eax7 	112
001246  aa  7 00034 3521 20	epp2 	pr7|28,*
001247  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
001250  aa     000014000000
001251  aa     000000000000
						STATEMENT 1 ON LINE 494
      unspec (new_area.control) = ""b;

001252  aa  6 00101 4501 00	stz  	pr6|65
						STATEMENT 1 ON LINE 495
      new_area.control.extend = "1"b;

001253  aa   400000 2350 03	lda  	131072,du
001254  aa  6 00101 2551 00	orsa 	pr6|65		new_area.extend
						STATEMENT 1 ON LINE 496
      new_area.control.zero_on_alloc = "1"b;

001255  aa   200000 2350 03	lda  	65536,du
001256  aa  6 00101 2551 00	orsa 	pr6|65		new_area.zero_on_alloc
						STATEMENT 1 ON LINE 497
      new_area.control.system = "1"b;

001257  aa   010000 2350 03	lda  	4096,du
001260  aa  6 00101 2551 00	orsa 	pr6|65		new_area.system
						STATEMENT 1 ON LINE 498
      new_area.areap = null ();

001261  aa   776527 2370 04	ldaq 	-681,ic		000010 = 077777000043 000001000000
001262  aa  6 00116 7571 00	staq 	pr6|78		new_area.areap
						STATEMENT 1 ON LINE 505
      new_area.owner = "Heap_" || ltrim (char (exe_level)) ||
	 "r" || ltrim (char (ring_no));

001263  aa  6 00032 3735 20	epp7 	pr6|26,*
001264  aa  7 00004 3715 20	epp5 	pr7|4,*
001265  aa  000 100 301 500	btd  	(pr),(pr)
001266  aa  5 00000 00 0004	desc9a	pr5|0,4		ring_no
001267  aa  6 00136 01 0010	desc9ls	pr6|94,8,0
001270  aa  100 004 024 500	mvne 	(pr),(ic),(pr)
001271  aa  6 00136 01 0010	desc9ls	pr6|94,8,0
001272  aa   000244 00 0006	desc9a	164,6		001534 = 403040022146
001273  aa  6 00132 00 0012	desc9a	pr6|90,10
001274  aa  000 000 164 500	tct  	(pr)
001275  aa  6 00132 00 0012	desc9a	pr6|90,10
001276  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
001277  aa  6 00056 0001 00	arg  	pr6|46
001300  aa  6 00056 2361 00	ldq  	pr6|46
001301  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
001302  aa  6 00135 7561 00	stq  	pr6|93
001303  aa   000012 2360 07	ldq  	10,dl
001304  aa  6 00135 1761 00	sbq  	pr6|93
001305  aa  7 00006 3535 20	epp3 	pr7|6,*
001306  aa  000 100 301 500	btd  	(pr),(pr)
001307  aa  3 00000 00 0004	desc9a	pr3|0,4		exe_level
001310  aa  6 00136 01 0010	desc9ls	pr6|94,8,0
001311  aa  100 004 024 500	mvne 	(pr),(ic),(pr)
001312  aa  6 00136 01 0010	desc9ls	pr6|94,8,0
001313  aa   000223 00 0006	desc9a	147,6		001534 = 403040022146
001314  aa  6 00140 00 0012	desc9a	pr6|96,10
001315  aa  6 00143 7561 00	stq  	pr6|99
001316  aa  000 000 164 500	tct  	(pr)
001317  aa  6 00140 00 0012	desc9a	pr6|96,10
001320  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
001321  aa  6 00056 0001 00	arg  	pr6|46
001322  aa  6 00056 2361 00	ldq  	pr6|46
001323  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
001324  aa  6 00144 7561 00	stq  	pr6|100
001325  aa   000012 2360 07	ldq  	10,dl
001326  aa  6 00144 1761 00	sbq  	pr6|100
001327  aa  6 00145 7561 00	stq  	pr6|101
001330  aa   000005 0760 07	adq  	5,dl
001331  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
001332  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
001333  aa   776454 00 0005	desc9a	-724,5		000006 = 110145141160
001334  aa  2 00000 00 0005	desc9a	pr2|0,5
001335  aa  6 00144 2351 00	lda  	pr6|100
001336  aa  6 00146 7561 00	stq  	pr6|102
001337  aa  6 00145 2361 00	ldq  	pr6|101
001340  aa  040 140 100 545	mlr  	(pr,rl,al),(pr,rl),fill(040)
001341  aa  6 00140 00 0006	desc9a	pr6|96,ql
001342  aa  2 00001 20 0006	desc9a	pr2|1(1),ql
001343  aa  6 00146 2361 00	ldq  	pr6|102
001344  aa   000001 0760 07	adq  	1,dl
001345  aa  6 00144 7561 00	stq  	pr6|100
001346  aa  0 00606 7001 00	tsx0 	pr0|390		cat_realloc_chars
001347  aa  6 00146 2351 00	lda  	pr6|102
001350  aa  040 105 100 404	mlr  	(ic),(pr,al),fill(040)
001351  aa   000166 00 0001	desc9a	118,1		001536 = 162000000000
001352  aa  2 00000 00 0001	desc9a	pr2|0,1
001353  aa  6 00144 2361 00	ldq  	pr6|100
001354  aa  6 00143 0761 00	adq  	pr6|99
001355  aa  6 00146 7561 00	stq  	pr6|102
001356  aa  0 00606 7001 00	tsx0 	pr0|390		cat_realloc_chars
001357  aa  6 00144 2351 00	lda  	pr6|100
001360  aa  6 00135 2361 00	ldq  	pr6|93
001361  aa  6 00132 3515 00	epp1 	pr6|90
001362  aa  1 00000 5005 06	a9bd 	pr1|0,ql
001363  aa  6 00143 2361 00	ldq  	pr6|99
001364  aa  040 145 100 540	mlr  	(pr,rl),(pr,rl,al),fill(040)
001365  aa  1 00000 00 0006	desc9a	pr1|0,ql
001366  aa  2 00000 00 0006	desc9a	pr2|0,ql
001367  aa  6 00146 2351 00	lda  	pr6|102
001370  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
001371  aa  2 00000 00 0005	desc9a	pr2|0,al
001372  aa  6 00102 00 0040	desc9a	pr6|66,32		new_area.owner
						STATEMENT 1 ON LINE 508
      new_area.areap = null ();

001373  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
						STATEMENT 1 ON LINE 509
      new_area.version = area_info_version_1;

001374  aa   000001 2360 07	ldq  	1,dl
001375  aa  6 00100 7561 00	stq  	pr6|64		new_area.version
						STATEMENT 1 ON LINE 510
      new_area.size = sys_info$max_seg_size - 50;

001376  la  4 00024 2361 20	ldq  	pr4|20,*		sys_info$max_seg_size
001377  aa   000062 1760 07	sbq  	50,dl
001400  aa  6 00113 7561 00	stq  	pr6|75		new_area.size
						STATEMENT 1 ON LINE 517
      on condition (cleanup)
         begin;

001401  aa   000007 7260 07	lxl6 	7,dl
001402  aa   776410 3520 04	epp2 	-760,ic		000012 = 143154145141
001403  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
001404  aa   000004 7100 04	tra  	4,ic		001410
001405  aa     000124000000
001406  aa   000052 7100 04	tra  	42,ic		001460
BEGIN CONDITION cleanup.3
ENTRY TO cleanup.3                                          STATEMENT 1 ON LINE 517
      on condition (cleanup)
         begin;

001407  da     000216200000
001410  aa   000120 6270 00	eax7 	80
001411  aa  7 00034 3521 20	epp2 	pr7|28,*
001412  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
001413  aa     000000000000
001414  aa     000000000000
						STATEMENT 1 ON LINE 526
	  if new_heap_header_ptr ^= null () then
	     do;

001415  aa  6 00040 3735 20	epp7 	pr6|32,*
001416  aa  7 00032 3715 20	epp5 	pr7|26,*
001417  aa  5 00012 2371 20	ldaq 	pr5|10,*		new_heap_header_ptr
001420  aa   776370 6770 04	eraq 	-776,ic		000010 = 077777000043 000001000000
001421  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001422  aa   000022 6000 04	tze  	18,ic		001444
						STATEMENT 1 ON LINE 528
	        if (a_sb -> stack_header.heap_header_ptr ^= null ()) &
		   (new_heap_header_ptr = a_sb -> stack_header.heap_header_ptr) then
		 a_sb -> stack_header.heap_header_ptr = current_heap_header_ptr;

001423  aa  7 00040 3535 20	epp3 	pr7|32,*
001424  aa  3 00032 3515 20	epp1 	pr3|26,*
001425  aa  1 00002 3735 20	epp7 	pr1|2,*		a_sb
001426  aa  7 00000 3735 20	epp7 	pr7|0,*		a_sb
001427  aa  7 00070 2371 00	ldaq 	pr7|56		stack_header.heap_header_ptr
001430  aa   776360 6770 04	eraq 	-784,ic		000010 = 077777000043 000001000000
001431  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001432  aa   000010 6000 04	tze  	8,ic		001442
001433  aa  5 00012 2371 20	ldaq 	pr5|10,*		new_heap_header_ptr
001434  aa  7 00070 6771 00	eraq 	pr7|56		stack_header.heap_header_ptr
001435  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001436  aa   000004 6010 04	tnz  	4,ic		001442
001437  aa  5 00010 3535 20	epp3 	pr5|8,*		current_heap_header_ptr
001440  aa  3 00000 3535 20	epp3 	pr3|0,*		current_heap_header_ptr
001441  aa  7 00070 2535 00	spri3	pr7|56		stack_header.heap_header_ptr
						STATEMENT 1 ON LINE 536
	        new_heap_header_ptr = null ();

001442  aa   776346 2370 04	ldaq 	-794,ic		000010 = 077777000043 000001000000
001443  aa  5 00012 7571 20	staq 	pr5|10,*		new_heap_header_ptr
						STATEMENT 1 ON LINE 538
	     end;

						STATEMENT 1 ON LINE 542
	  if new_area.areap ^= null () then
	     call release_area_ (new_area.areap);

001444  aa  6 00040 3735 20	epp7 	pr6|32,*
001445  aa  7 00116 2371 00	ldaq 	pr7|78		new_area.areap
001446  aa   776342 6770 04	eraq 	-798,ic		000010 = 077777000043 000001000000
001447  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001450  aa   000007 6000 04	tze  	7,ic		001457
001451  aa  7 00116 3521 00	epp2 	pr7|78		new_area.areap
001452  aa  6 00102 2521 00	spri2	pr6|66
001453  aa  6 00100 6211 00	eax1 	pr6|64
001454  aa   004000 4310 07	fld  	2048,dl
001455  la  4 00014 3521 20	epp2 	pr4|12,*		release_area_
001456  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 544
         end;

001457  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END CONDITION cleanup.3
						STATEMENT 1 ON LINE 551
      call define_area_ (addr (new_area), error_code);

001460  aa  6 00100 3735 00	epp7 	pr6|64		new_area
001461  aa  6 00136 6535 00	spri7	pr6|94
001462  aa  6 00136 3521 00	epp2 	pr6|94
001463  aa  6 00152 2521 00	spri2	pr6|106
001464  aa  6 00032 3715 20	epp5 	pr6|26,*
001465  aa  5 00014 3521 20	epp2 	pr5|12,*		error_code
001466  aa  6 00154 2521 00	spri2	pr6|108
001467  aa  6 00150 6211 00	eax1 	pr6|104
001470  aa   010000 4310 07	fld  	4096,dl
001471  aa  6 00044 3701 20	epp4 	pr6|36,*
001472  la  4 00012 3521 20	epp2 	pr4|10,*		define_area_
001473  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 552
      if error_code ^= 0 then
         return;

001474  aa  6 00032 3735 20	epp7 	pr6|26,*
001475  aa  7 00014 2361 20	ldq  	pr7|12,*		error_code
001476  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 560
      allocate heap_header in (new_area.areap -> area_block) set (new_heap_header_ptr);

001477  aa   000011 2360 07	ldq  	9,dl
001500  aa  6 00116 3521 20	epp2 	pr6|78,*		area_block
001501  aa  0 01402 7001 00	tsx0 	pr0|770		op_alloc_
001502  aa   777775 7100 04	tra  	-3,ic		001477
001503  aa  6 00032 3735 20	epp7 	pr6|26,*
001504  aa  7 00012 2521 20	spri2	pr7|10,*		new_heap_header_ptr
						STATEMENT 1 ON LINE 562
      new_heap_header_ptr -> heap_header.area_ptr = new_area.areap;

001505  aa  6 00116 3715 20	epp5 	pr6|78,*		new_area.areap
001506  aa  2 00006 6515 00	spri5	pr2|6		heap_header.area_ptr
						STATEMENT 1 ON LINE 563
      new_heap_header_ptr -> heap_header.version = heap_header_version_1;

001507  aa   776271 2370 04	ldaq 	-839,ic		000000 = 110145141160 137166060061
001510  aa  7 00012 3715 20	epp5 	pr7|10,*		new_heap_header_ptr
001511  aa  5 00000 3715 20	epp5 	pr5|0,*		new_heap_header_ptr
001512  aa  5 00000 7551 00	sta  	pr5|0		heap_header.version
001513  aa  5 00001 7561 00	stq  	pr5|1		heap_header.version
						STATEMENT 1 ON LINE 564
      new_heap_header_ptr -> heap_header.heap_na

                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
