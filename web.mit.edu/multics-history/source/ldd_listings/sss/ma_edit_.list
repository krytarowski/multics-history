	COMPILATION LISTING OF SEGMENT ma_edit_
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/04/82  1817.6 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 ma_edit_: proc (a_info_ptr); default (fixed&^precision&^constant) precision (21); /* DEFAULT */
       12 	default (constant&real&^decimal) binary;
       13 
       14 /* MA_EDIT_ performs simple editing for merge_ascii subsystem */
       15 /* Recoded RE Mullen Spring '77 */
       16 /* Modified "x" request to print archive cpt THVV 1980 */
       17 
       18 dcl  a_info_ptr ptr;
       19 
       20 dcl (i, j, k) fixed bin;
       21 dcl  code fixed bin (35);
       22 dcl (ioa_, ioa_$nnl) entry options (variable);
       23 dcl (iox_$user_input, iox_$user_output) ptr ext;
       24 dcl  iox_$control entry (ptr, char (*) aligned, ptr, fixed bin (35));
       25 dcl  iox_$put_chars entry (ptr, ptr, fixed bin, fixed bin (35));
       26 dcl  iox_$get_line entry (ptr, ptr, fixed bin, fixed bin, fixed bin (35));
       27 dcl  cv_dec_check_ entry (char (*), fixed bin (35), fixed bin);
       28 dcl  cu_$cp entry (ptr, fixed bin, fixed bin (35));
       29 
       30 dcl  skipchars (0:1) char (1) unal based;
       31 dcl  ch char (999) based;
       32 
       33 dcl (start_line, end_line) fixed bin;
       34 dcl  nl char (1) init ("
       35 ");
       36 
       37 dcl  temp_ptr ptr;					/* temps for dealing with block of text */
       38 dcl  dirn char (168);
       39 dcl  en char (32);
       40 dcl  cpt char (32);
       41 dcl  temp_chars fixed bin;
       42 dcl  temp_lines fixed bin;
       43 
       44 
       45 dcl (rbuff, buff) char (200);
       46 dcl (rnc, nc) fixed bin;
       47 dcl  n fixed bin;
       48 dcl  req char (n) based (addr (buff));
       49 						/* ENDCL */
       50 
       51 /*  */
  1     1 /* BEGIN INCLUDE FILE ... merge_ascii_info.incl.pl1 ... REM Winter '77 */
  1     2 /* Modified for archive component convention THVV 1980 */
  1     3 /* Added output_iocb_ptr for cpa -output_file */
  1     4 
  1     5 dcl  ma_info_ptr ptr;
  1     6 
  1     7 /* programs modifiying variables are supplied im most comments */
  1     8 /* ma_info.control.*** modified by ma unless otherwise noted */
  1     9 /* ma_info.per_text(output).*** usually set by ma_edit_ instead */
  1    10 /* ma=merge_ascii ma_=merge_ascii_ mar_=ma_resynch_ maa_=ma_analyze_ mae_=ma_edit_ */
  1    11 
  1    12 dcl 1 ma_info aligned based (ma_info_ptr),
  1    13     2 control aligned,				/* stuff controling program action */
  1    14       3 minlines fixed bin,				/* ma: resynch block must have >= minlines */
  1    15       3 minchars fixed bin,				/* ma: resynch block must have >= minchars */
  1    16       3 lo fixed bin,				/* ma: lowest seg_index to resynch */
  1    17       3 hi fixed bin,				/* ma: highest seg_index to resynch */
  1    18       3 eof bit (1),				/* set by mar_ and ma_.skip_same for ma_ */
  1    19       3 synchlen fixed bin,				/* mar_: chars between resynch start and next diff */
  1    20       3 synchlines fixed bin,				/* mar_: lines between resynch start and next diff */
  1    21       3 have_orig bit (1),				/* "1"b if original provided */
  1    22       3 have_output bit (1),				/* ma_: "1"b if merge and have got path */
  1    23       3 have_edit bit (1),				/* if any "-edit" segs */
  1    24       3 convergence_ok bit (1) aligned,			/* "1"b => ok to pick up identical changes */
  1    25       3 brief_mode bit (1) aligned,			/* UNUSED */
  1    26       3 total_differences fixed bin,			/* ma_: number of time synch lost */
  1    27       3 total_lines_differing fixed bin,		/* ma_: summed over all diff in all texts */
  1    28       3 totals_only bit (1),				/* ma: dont print differences */
  1    29       3 print_heading bit (1),			/* ma: print heading before start */
  1    30       3 no_line_numbers bit (1),			/* ma: dont print linnos with diffs */
  1    31       3 print_new_lines bit (1),			/* ma: dont print context or old with diff */
  1    32       3 no_totals bit (1),				/* ma: dont print totals line when done */
  1    33       3 abort_label label,				/* goto abort label to bust out */
  1    34       3 op_dirname char (168),			/* info about desired output seg */
  1    35       3 op_ename char (32),
  1    36       3 op_ptr ptr,
  1    37       3 output_iocb_ptr ptr,
  1    38     2 per_text_info (8) aligned,			/* 1=output_temp, 2=orig, 3+=updates */
  1    39       3 tptr ptr,					/* ma: base of each text */
  1    40       3 tchars fixed bin,				/* ma: chars in each text */
  1    41       3 tlines fixed bin,				/* UNUSED */
  1    42       3 cp ptr,					/* ma_: ->current position, next char to process */
  1    43       3 len fixed bin,				/* ma_: chars remaining to process */
  1    44       3 line fixed bin,				/* ma_: line number cp points at */
  1    45       3 difflen fixed bin,				/* mar_: chars between synchs */
  1    46       3 difflines fixed bin,				/* mar_: lines between synchs */
  1    47       3 same_as fixed bin,				/* mar_: seg_index of lowest seg with identical diff */
  1    48       3 textid char (1) aligned,			/* ma: char to identify text in display */
  1    49       3 edit bit (1) aligned,				/* ma: not take automatically */
  1    50       3 pad_t (3) fixed bin,				/* make 16 wds for indexing speed */
  1    51     2 text_id (8) aligned,				/* names of the stff */
  1    52       3 dirname char (168),
  1    53       3 ename char (32),
  1    54       3 component char (32);
  1    55 
  1    56 dcl  ma_text_ids char (8) init ("mabcdefg")int static options (constant);
  1    57 dcl  MA_TEXT_IDS char (8) init ("MABCDEFG")int static options (constant);
  1    58 dcl  ma_max_texts fixed bin int static options (constant) init (8);
  1    59 
  1    60 /* END INCLUDE FILE ... merge_ascii_info.incl.pl1 */
       52 
       53 /*  */
       54 
       55 	ma_info_ptr = a_info_ptr;
       56 
       57 	difflen (1) = 0;
       58 	difflines (1) = 0;
       59 	line (1) = tlines (1) + 1;
       60 
       61 pedit:	call ioa_ ("EDIT");
       62 	rnc = 0;
       63 
       64 read_loop:
       65 
       66 /* DEBUGGING */
       67 /*
       68*   call ioa_ ("
       69*   i	tp	tl	tc	cp	dl	dc	line");
       70*   do i = 1 to hi;
       71*   call ioa_ ("^10d  ^p^-^10d^10d  ^p^-^10d^10d^10d",
       72*   i,
       73*   tptr (i), tlines (i), tchars (i), cp (i), difflines (i), difflen (i), line (i));
       74*   end;
       75*   /* END DEBUGGING */
       76 	if rnc = 0 then do;
       77 	     call iox_$get_line (iox_$user_input, addr (rbuff), 200, rnc, code);
       78 	end;
       79 
       80 	if substr (rbuff, 1, 2) = "e " then do;		/* EXECUTE --- call cp with rest of line */
       81 	     substr (rbuff, 1, 1) = "";
       82 	     call cu_$cp (addr (rbuff), rnc, code);
       83 	     rnc = 0;
       84 	     go to read_loop;
       85 	end;
       86 
       87 	nc = index (substr (rbuff, 1, rnc), " ");
       88 	if nc = 0 then nc = rnc;
       89 	substr (buff, 1, nc) = substr (rbuff, 1, nc);
       90 	if nc ^= rnc then substr (rbuff, 1, rnc-nc)
       91 	     = substr (rbuff, nc + 1, rnc-nc);		/* shift whats left */
       92 	rnc = rnc - nc;				/* accout for what we took */
       93 
       94 	n = nc - 1;				/* get real number of chars in req */
       95 
       96 
       97 	if req = "" then;				/* ignore null req */
       98 	else if n = 1 then do;			/* some one char req */
       99 	     if req = "x" then do;			/* STATUS --- relate texids to paths, etc. */
      100 		call ioa_ ("text   line nos.^-path");
      101 		do i = 2 to ma_max_texts, 1;
      102 		     if tptr (i) ^= null () then do;
      103 			if i = 1 then do;		/* print true output path, not temp */
      104 			     dirn = op_dirname;
      105 			     en = op_ename;
      106 			     cpt = "";
      107 			end;
      108 			else do;
      109 			     dirn = dirname (i);
      110 			     en = ename (i);
      111 			     cpt = component (i);
      112 			end;
      113 			if difflines (i) = 0 then
      114 			     call ioa_ ("^a^-^-^a>^a^[::^a^;^s^]",
      115 			     textid (i), dirn, en, (cpt ^= ""), cpt);
      116 			else if difflines (i) = 1 then
      117 			     call ioa_ ("^a^9d^-^a>^a^[::^a^;^s^]",
      118 			     textid (i), line (i), dirn, en, (cpt ^= ""), cpt);
      119 			else call ioa_ ("^a^9d,^d^-^a>^a^[::^a^;^s^]",
      120 			     textid (i), line (i), line (i) + difflines (i) - 1, dirn, en, (cpt ^= ""), cpt);
      121 		     end;
      122 		end;
      123 	     end;
      124 	     else go to UNREQ;			/* no other single char is valid req */
      125 	end;
      126 	else if req = "input" then do;		/* INPUT --- accept "none of the above" */
      127 	     if rnc > 0 then go to MB_LAST;
      128 	     call ioa_ ("INPUT");
      129 i_loop:	     call iox_$get_line (iox_$user_input, addr (rbuff), 200, rnc, code);
      130 	     if rnc = 2 then if substr (rbuff, 1, 1) = "." then go to pedit;
      131 	     substr (cp (1) -> ch, difflen (1) + 1, rnc) = substr (rbuff, 1, rnc);
      132 	     tchars (1) = tchars (1) + rnc;
      133 	     tlines (1) = tlines (1) + 1;
      134 	     difflen (1) = difflen (1) + rnc;
      135 	     difflines (1) = difflines (1) + 1;
      136 	     go to i_loop;
      137 	end;
      138 	else if req = "go" then do;			/* GO --- return from editor to compare loop */
      139 	     if rnc > 0 then do;
      140 MB_LAST:		call ioa_ ("^a must be the last request on a line.", req);
      141 		go to RESET;
      142 	     end;
      143 	     cp (1) = addr (cp (1) -> skipchars (difflen (1)));
      144 	     return;
      145 	end;
      146 	else if req = "help" then do;			/* HELP --- tell requests possible */
      147 	     call ioa_ ("Edit requests:");
      148 	     call ioa_ ("bk	copy previously printed block from text b.");
      149 	     call ioa_ ("bx,yk	copy lines x though y from segment b.");
      150 	     call ioa_ ("bx,yp	print lines x through y from segment b.");
      151 	     call ioa_ ("md	undo all edit requests since changes last displayed.");
      152 	     call ioa_ ("input	enter input mode.");
      153 	     call ioa_ (".	return from input mode to edit mode.");
      154 	     call ioa_ ("go	exit editor and continue comparison.");
      155 	     call ioa_ ("quit	abort merge.");
      156 	     call ioa_ ("e <command_line> execute rest of line.");
      157 	     call ioa_ ("x	provide text status.");
      158 	     call ioa_ ("help	provide help to user.");
      159 	end;
      160 	else if req = "quit" then do;			/* QUIT --- abort this merge */
      161 	     if rnc > 0 then go to MB_LAST;
      162 	     go to abort_label;
      163 	end;
      164 	else if substr (req, n, 1) = "p" then do;	/* PRINT --- display lines */
      165 	     call GET_ADDR;
      166 	     call PRINTEMPS (i);
      167 	end;
      168 	else if substr (req, n, 1) = "k" then do;	/* KOPY --- take specified lines */
      169 	     call GET_ADDR;
      170 	     call TAKE_TEMPS;
      171 	end;
      172 	else if substr (req, n, 1) = "d" then do;	/* DELETE --- undo recent choices */
      173 	     if n ^= 2 then do;
      174 DELIMP:		call ioa_ ("cannot ""^a"": the only delete request possible is ""md""", req);
      175 		go to RESET;
      176 	     end;
      177 	     if substr (req, 1, 1) ^= "m" then go to DELIMP;
      178 	     tchars (1) = tchars (1) - difflen (1);
      179 	     tlines (1) = tlines (1) - difflines (1);
      180 	     difflen (1), difflines (1) = 0;
      181 	end;
      182 	else do;					/* LOSE */
      183 UNREQ:	     call ioa_ ("cannot ""^a"": unrecognized request", req);
      184 	     go to RESET;
      185 NO_BLOCK:	     call ioa_ ("cannot ""^a"": current block is empty", req);
      186 	     go to RESET;
      187 RESET:	     code = 0;
      188 	     rnc = 0;
      189 	     call iox_$control (iox_$user_input, "resetread", null (), 0);
      190 	end;
      191 	go to read_loop;
      192 
      193 /*  */
      194 
      195 GET_ADDR:	proc;					/* IP to determine addressed lines */
      196 
      197 	     i = index (ma_text_ids, substr (req, 1, 1));
      198 	     if i = 0 then do;
      199 BAD_TID:		call ioa_ ("cannot ""^a"": invalid text identifier ""^a""", req, substr (req, 1, 1));
      200 		go to RESET;
      201 	     end;
      202 	     if tptr (i) = null () then go to BAD_TID;
      203 	     if n = 2 then do;			/* entire block */
      204 		if difflen (i) = 0 then go to NO_BLOCK; /* null block */
      205 		temp_chars = difflen (i);
      206 		temp_lines = difflines (i);
      207 		temp_ptr = cp (i);
      208 		start_line = line (i);
      209 	     end;
      210 	     else do;
      211 		call READ_LINNOS (i, 1);
      212 		call SET_TEMPS (i);
      213 	     end;
      214 
      215 	end GET_ADDR;
      216 
      217 /*  */
      218 
      219 TAKE_TEMPS: proc ;					/* IP to pick up changed text */
      220 
      221 
      222 	     if temp_chars = 0 then return;		/* evid was nothing there */
      223 
      224 	     substr (cp (1) -> ch, difflen (1) + 1, temp_chars)
      225 		= substr (temp_ptr -> ch, 1, temp_chars);
      226 	     tchars (1) = tchars (1) + temp_chars;
      227 	     tlines (1) = tlines (1) + temp_lines;
      228 	     difflen (1) = difflen (1) + temp_chars;
      229 	     difflines (1) = difflines (1) + temp_lines;
      230 
      231 	end TAKE_TEMPS;
      232 
      233 /*  */
      234 
      235 READ_LINNOS: proc (segx, oplen);
      236 dcl  segx fixed bin;				/* segment index */
      237 dcl  oplen fixed bin;				/* length of operator: eg "p" */
      238 dcl  LC fixed bin;
      239 dcl  cv_dec_check_ entry (char (*) aligned, fixed bin (35)) returns (fixed bin);
      240 
      241 dcl  x fixed bin;
      242 
      243 	     LC = n - oplen - 1;			/* subtract oplen and textid from req len */
      244 
      245 	     if difflen (segx) = 0 then do;		/* "<" and ">" are undefined */
      246 		if index (substr (buff, 2, LC), "<") > 0 then go to NO_BLOCK;
      247 		else if index (substr (buff, 2, LC), ">") > 0 then go to NO_BLOCK;
      248 	     end;
      249 
      250 	     x = index (substr (buff, 2, LC), ",");
      251 	     if x = 1 then do;
      252 		call ioa_ ("cannot ""^a"": no numeral before comma", req);
      253 		go to RESET;
      254 	     end;
      255 	     else if x = LC then do;
      256 		call ioa_ ("cannot ""^a"": no numeral after comma", req);
      257 		go to RESET;
      258 	     end;
      259 	     else if x = 0 then do;			/* only one number given */
      260 		if substr (buff, 2, LC) = "<" then start_line = line (segx);
      261 		else if substr (buff, 2, LC) = ">" then start_line = line (segx) + difflines (segx) -1;
      262 		else do;
      263 		     start_line = cv_dec_check_ (substr (buff, 2, LC), code);
      264 		     if code ^= 0 then do;
      265 			call ioa_ ("cannot ""^a"": bad line number ^a", req, substr (buff, 2, LC));
      266 			go to RESET;
      267 		     end;
      268 		end;
      269 		end_line = start_line;
      270 	     end;
      271 	     else do;				/* comma and two numbers? */
      272 		if substr (buff, 2, x-1) = "<" then start_line = line (segx);
      273 		else do;				/* ">,N" not accepted */
      274 		     start_line = cv_dec_check_ (substr (buff, 2, x-1), code);
      275 		     if code ^= 0 then do;
      276 			call ioa_ ("cannot ""^a"": bad line number ^a", req, substr (buff, 2, x-1));
      277 			go to RESET;
      278 		     end;
      279 		end;
      280 		if substr (buff, 2+x, LC-x) = ">" then end_line = line (segx) + difflines (segx) - 1;
      281 		else do;				/* "N,<" not accepted */
      282 		     end_line = cv_dec_check_ (substr (buff, 2+x, LC - x), code);
      283 		     if code ^= 0 then do;
      284 			call ioa_ ("cannot ""^a"": bad line number ^a", req, substr (buff, 2+x, LC-x));
      285 			go to RESET;
      286 		     end;
      287 		end;
      288 	     end;
      289 
      290 	     if start_line <= 0 then do;
      291 		call ioa_ ("cannot ""^a"": neg line number ^d", req, start_line);
      292 		go to RESET;
      293 	     end;
      294 
      295 	     if end_line - start_line < 0 then do;
      296 		call ioa_ ("cannot ""^a"": start ^d  > end ^d", req, start_line, end_line);
      297 		go to RESET;
      298 	     end;
      299 
      300 	end READ_LINNOS;
      301 
      302 /*  */
      303 
      304 SET_TEMPS: proc (x);				/* IP to set (global) tp, tc, temp_lines  */
      305 dcl  x fixed bin;
      306 dcl  xptr ptr;
      307 dcl  xchars fixed bin;				/* total chars */
      308 						/* */
      309 dcl  tsc fixed bin;
      310 dcl  N fixed bin;
      311 
      312 dcl (i, j, k) fixed bin;
      313 
      314 	     xptr = tptr (x);
      315 	     xchars = tchars (x);
      316 	     k = 0;
      317 
      318 	     do i = 1 to end_line;
      319 		if k >= xchars then do;
      320 		     call ioa_ ("cannot ""^a"": seg ^a has ^d lines", req, textid (x), i - 1);
      321 		     go to RESET;
      322 		end;
      323 		if i = start_line then do;		/* make temp_ptr point at start of this line */
      324 		     temp_ptr = addr (xptr -> skipchars (k));
      325 		     tsc = k;
      326 		end;
      327 		j = index (substr (xptr -> ch, k + 1, xchars - k), nl);
      328 		if j = 0 then j = xchars - k;		/* take all if no newline */
      329 		k = k + j;
      330 	     end;
      331 
      332 	     temp_chars = k - tsc;
      333 	     temp_lines = end_line - start_line + 1;
      334 
      335 	end SET_TEMPS;
      336 
      337 
      338 /*  */
      339 
      340 PRINTEMPS: proc (x);				/* IP to print (temp_ptr , temp_chars) */
      341 
      342 dcl (i, j, k) fixed bin;
      343 dcl  x fixed bin;
      344 
      345 	     k = 0;
      346 
      347 	     do i = 1 to temp_lines;
      348 		j = index (substr (temp_ptr -> ch, k+1, temp_chars - k), nl);
      349 		if j = 0 then j = temp_chars - k;
      350 		call ioa_$nnl ("^a^d^-^a",
      351 		     textid (x), start_line + i - 1, substr (temp_ptr -> ch, k+1, j));
      352 		k = k + j;
      353 	     end;
      354 	     if k ^= temp_chars then call ioa_ ("PRINTEMPS: k ^= temp_chars"); /* DEBUG */
      355 
      356 	end PRINTEMPS;
      357 
      358 
      359      end ma_edit_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/82  1627.5  ma_edit_.pl1                      >dumps>old>recomp>ma_edit_.pl1
52           1    09/28/82  1437.6  merge_ascii_info.incl.pl1         >ldd>include>merge_ascii_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
LC                              000404 automatic       fixed bin(21,0)          dcl 238 set ref 243* 246 247 250 255 260 261 263 263
                                                                                  265 265 280 282 282 284 284
a_info_ptr                             parameter       pointer                  dcl 18 ref 11 55
abort_label              24            based           label variable           level 3 dcl 1-12 ref 162
buff                            000266 automatic       char(200)                unaligned dcl 45 set ref 89* 97 99 126 138 140 146
                                                                                  160 164 168 172 174 177 183 185 197 199 199 199
                                                                                  246 247 250 252 256 260 261 263 263 265 265 265
                                                                                  272 274 274 276 276 276 280 282 282 284 284 284
                                                                                  291 296 320
ch                                     based           char(999)                unaligned dcl 31 set ref 131* 224* 224 327 348 350
                                                                                  350
code                            000101 automatic       fixed bin(35,0)          dcl 21 set ref 77* 82* 129* 187* 263* 264 274* 275
                                                                                  282* 283
component               400            based           char(32)                 array level 3 dcl 1-12 ref 111
control                                based           structure                level 2 dcl 1-12
cp                      122            based           pointer                  array level 3 dcl 1-12 set ref 131 143* 143 207 224
cpt                             000172 automatic       char(32)                 unaligned dcl 40 set ref 106* 111* 113 113* 116 116*
                                                                                  119 119*
cu_$cp                          000022 constant        entry                    external dcl 28 ref 82
cv_dec_check_                   000024 constant        entry                    external dcl 239 ref 263 274 282
difflen                 126            based           fixed bin(21,0)          array level 3 dcl 1-12 set ref 57* 131 134* 134 143
                                                                                  178 180* 204 205 224 228* 228 245
difflines               127            based           fixed bin(21,0)          array level 3 dcl 1-12 set ref 58* 113 116 119 135*
                                                                                  135 179 180* 206 229* 229 261 280
dirn                            000110 automatic       char(168)                unaligned dcl 38 set ref 104* 109* 113* 116* 119*
dirname                 316            based           char(168)                array level 3 dcl 1-12 ref 109
en                              000162 automatic       char(32)                 unaligned dcl 39 set ref 105* 110* 113* 116* 119*
ename                   370            based           char(32)                 array level 3 dcl 1-12 ref 110
end_line                        000103 automatic       fixed bin(21,0)          dcl 33 set ref 269* 280* 282* 295 296* 318 333
i                               000100 automatic       fixed bin(21,0)          dcl 20 in procedure "ma_edit_" set ref 101* 102 103
                                                                                  109 110 111 113 113 116 116 116 119 119 119 119*
                                                                                  166* 197* 198 202 204 205 206 207 208 211* 212*
i                               000432 automatic       fixed bin(21,0)          dcl 342 in procedure "PRINTEMPS" set ref 347* 350*
i                               000420 automatic       fixed bin(21,0)          dcl 312 in procedure "SET_TEMPS" set ref 318* 320
                                                                                  323*
ioa_                            000010 constant        entry                    external dcl 22 ref 61 100 113 116 119 128 140 147
                                                                                  148 149 150 151 152 153 154 155 156 157 158 174
                                                                                  183 185 199 252 256 265 276 284 291 296 320 354
ioa_$nnl                        000012 constant        entry                    external dcl 22 ref 350
iox_$control                    000016 constant        entry                    external dcl 24 ref 189
iox_$get_line                   000020 constant        entry                    external dcl 26 ref 77 129
iox_$user_input                 000014 external static pointer                  dcl 23 set ref 77* 129* 189*
j                               000433 automatic       fixed bin(21,0)          dcl 342 in procedure "PRINTEMPS" set ref 348* 349
                                                                                  349* 350 350 352
j                               000421 automatic       fixed bin(21,0)          dcl 312 in procedure "SET_TEMPS" set ref 327* 328
                                                                                  328* 329
k                               000434 automatic       fixed bin(21,0)          dcl 342 in procedure "PRINTEMPS" set ref 345* 348
                                                                                  348 349 350 350 352* 352 354
k                               000422 automatic       fixed bin(21,0)          dcl 312 in procedure "SET_TEMPS" set ref 316* 319
                                                                                  324 325 327 327 328 329* 329 332
line                    125            based           fixed bin(21,0)          array level 3 dcl 1-12 set ref 59* 116* 119* 119 208
                                                                                  260 261 272 280
ma_info                                based           structure                level 1 dcl 1-12
ma_info_ptr                     000354 automatic       pointer                  dcl 1-5 set ref 55* 57 58 59 59 102 104 105 109 110
                                                                                  111 113 113 116 116 116 119 119 119 119 131 131
                                                                                  132 132 133 133 134 134 135 135 143 143 143 162
                                                                                  178 178 178 179 179 179 180 180 202 204 205 206
                                                                                  207 208 224 224 226 226 227 227 228 228 229 229
                                                                                  245 260 261 261 272 280 280 314 315 320 350
ma_max_texts                           constant        fixed bin(21,0)          initial dcl 1-58 ref 101
ma_text_ids                     000000 constant        char(8)                  initial unaligned dcl 1-56 ref 197
n                               000352 automatic       fixed bin(21,0)          dcl 47 set ref 94* 97 98 99 126 138 140 140 146 160
                                                                                  164 164 168 168 172 172 173 174 174 177 183 183
                                                                                  185 185 197 199 199 199 199 203 243 252 252 256
                                                                                  256 265 265 276 276 284 284 291 291 296 296 320
                                                                                  320
nc                              000351 automatic       fixed bin(21,0)          dcl 46 set ref 87* 88 88* 89 89 90 90 90 90 92 94
nl                              000104 automatic       char(1)                  initial unaligned dcl 34 set ref 34* 327 348
op_dirname               30            based           char(168)                level 3 dcl 1-12 ref 104
op_ename                102            based           char(32)                 level 3 dcl 1-12 ref 105
oplen                                  parameter       fixed bin(21,0)          dcl 237 ref 235 243
per_text_info           116            based           structure                array level 2 dcl 1-12
rbuff                           000204 automatic       char(200)                unaligned dcl 45 set ref 77 77 80 81* 82 82 87 89
                                                                                  90* 90 129 129 130 131
req                                    based           char                     unaligned dcl 48 set ref 97 99 126 138 140* 146 160
                                                                                  164 168 172 174* 177 183* 185* 197 199* 199 199
                                                                                  252* 256* 265* 276* 284* 291* 296* 320*
rnc                             000350 automatic       fixed bin(21,0)          dcl 46 set ref 62* 64 77* 82* 83* 87 88 90 90 90 92*
                                                                                  92 127 129* 130 131 131 132 134 139 161 188*
segx                                   parameter       fixed bin(21,0)          dcl 236 ref 235 245 260 261 261 272 280 280
skipchars                              based           char(1)                  array unaligned dcl 30 set ref 143 324
start_line                      000102 automatic       fixed bin(21,0)          dcl 33 set ref 208* 260* 261* 263* 269 272* 274* 290
                                                                                  291* 295 296* 323 333 350
tchars                  120            based           fixed bin(21,0)          array level 3 dcl 1-12 set ref 132* 132 178* 178
                                                                                  226* 226 315
temp_chars                      000202 automatic       fixed bin(21,0)          dcl 41 set ref 205* 222 224 224 226 228 332* 348 349
                                                                                  354
temp_lines                      000203 automatic       fixed bin(21,0)          dcl 42 set ref 206* 227 229 333* 347
temp_ptr                        000106 automatic       pointer                  dcl 37 set ref 207* 224 324* 348 350 350
text_id                 316            based           structure                array level 2 dcl 1-12
textid                  131            based           char(1)                  array level 3 dcl 1-12 set ref 113* 116* 119* 320*
                                                                                  350*
tlines                  121            based           fixed bin(21,0)          array level 3 dcl 1-12 set ref 59 133* 133 179* 179
                                                                                  227* 227
tptr                    116            based           pointer                  array level 3 dcl 1-12 ref 102 202 314
tsc                             000417 automatic       fixed bin(21,0)          dcl 309 set ref 325* 332
x                               000405 automatic       fixed bin(21,0)          dcl 241 in procedure "READ_LINNOS" set ref 250* 251
                                                                                  255 259 272 274 274 276 276 280 280 282 282 282
                                                                                  282 284 284 284 284
x                                      parameter       fixed bin(21,0)          dcl 305 in procedure "SET_TEMPS" ref 304 314 315 320
x                                      parameter       fixed bin(21,0)          dcl 343 in procedure "PRINTEMPS" ref 340 350
xchars                          000416 automatic       fixed bin(21,0)          dcl 307 set ref 315* 319 327 328
xptr                            000414 automatic       pointer                  dcl 306 set ref 314* 324 327

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
MA_TEXT_IDS                            internal static char(8)                  initial unaligned dcl 1-57
N                                      automatic       fixed bin(21,0)          dcl 310
cv_dec_check_                   000000 constant        entry                    external dcl 27
iox_$put_chars                  000000 constant        entry                    external dcl 25
iox_$user_output                       external static pointer                  dcl 23
j                                      automatic       fixed bin(21,0)          dcl 20
k                                      automatic       fixed bin(21,0)          dcl 20

NAMES DECLARED BY EXPLICIT CONTEXT.
BAD_TID                         001742 constant        label                    dcl 199 ref 202
DELIMP                          001562 constant        label                    dcl 174 ref 177
GET_ADDR                        001727 constant        entry                    internal dcl 195 ref 165 169
MB_LAST                         001236 constant        label                    dcl 140 ref 127 161
NO_BLOCK                        001645 constant        label                    dcl 185 ref 204 246 247
PRINTEMPS                       002774 constant        entry                    internal dcl 340 ref 166
READ_LINNOS                     002054 constant        entry                    internal dcl 235 ref 211
RESET                           001671 constant        label                    dcl 187 ref 141 175 184 186 200 253 257 266 277 285
                                                                                  292 297 321
SET_TEMPS                       002636 constant        entry                    internal dcl 304 ref 212
TAKE_TEMPS                      002031 constant        entry                    internal dcl 219 ref 170
UNREQ                           001622 constant        label                    dcl 183 set ref 99
i_loop                          001162 constant        label                    dcl 129 ref 136
ma_edit_                        000446 constant        entry                    external dcl 11
pedit                           000466 constant        label                    dcl 61 ref 130
read_loop                       000502 constant        label                    dcl 64 ref 84 191

NAMES DECLARED BY CONTEXT OR IMPLICATION.
addr                                                   builtin function         ref 77 77 82 82 97 99 126 129 129 138 140 143 146
                                                                                  160 164 168 172 174 177 183 185 197 199 199 199
                                                                                  252 256 265 276 284 291 296 320 324
index                                                  builtin function         ref 87 197 246 247 250 327 348
null                                                   builtin function         ref 102 189 189 202
substr                                                 builtin function         set ref 80 81* 87 89* 89 90* 90 130 131* 131 164 168
                                                                                  172 177 197 199 199 224* 224 246 247 250 260 261
                                                                                  263 263 265 265 272 274 274 276 276 280 282 282
                                                                                  284 284 327 348 350 350

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3236        3264    3142        3246
Length      3476    3142        26         176      74           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ma_edit_                            548 external procedure  is an external procedure.  
GET_ADDR                                internal procedure  shares stack frame of external procedure ma_edit_.  
TAKE_TEMPS                              internal procedure  shares stack frame of external procedure ma_edit_.  
READ_LINNOS                             internal procedure  shares stack frame of external procedure ma_edit_.  
SET_TEMPS                               internal procedure  shares stack frame of external procedure ma_edit_.  
PRINTEMPS                               internal procedure  shares stack frame of external procedure ma_edit_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ma_edit_                 000100 i                           ma_edit_
                         000101 code                        ma_edit_
                         000102 start_line                  ma_edit_
                         000103 end_line                    ma_edit_
                         000104 nl                          ma_edit_
                         000106 temp_ptr                    ma_edit_
                         000110 dirn                        ma_edit_
                         000162 en                          ma_edit_
                         000172 cpt                         ma_edit_
                         000202 temp_chars                  ma_edit_
                         000203 temp_lines                  ma_edit_
                         000204 rbuff                       ma_edit_
                         000266 buff                        ma_edit_
                         000350 rnc                         ma_edit_
                         000351 nc                          ma_edit_
                         000352 n                           ma_edit_
                         000354 ma_info_ptr                 ma_edit_
                         000404 LC                          READ_LINNOS
                         000405 x                           READ_LINNOS
                         000414 xptr                        SET_TEMPS
                         000416 xchars                      SET_TEMPS
                         000417 tsc                         SET_TEMPS
                         000420 i                           SET_TEMPS
                         000421 j                           SET_TEMPS
                         000422 k                           SET_TEMPS
                         000432 i                           PRINTEMPS
                         000433 j                           PRINTEMPS
                         000434 k                           PRINTEMPS

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_cs            call_ext_out_desc   call_ext_out        return              tra_label_var
shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$cp                        cv_dec_check_                 ioa_                          ioa_$nnl
iox_$control                  iox_$get_line

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
iox_$user_input




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000443        34 000453        55 000455        57 000461        58 000462        59 000463        61 000466
     62 000501        64 000502        77 000504        80 000527        81 000533        82 000535        83 000552
     84 000553        87 000554        88 000566        89 000571        90 000574        92 000604        94 000606
     97 000611        98 000620        99 000622       100 000626       101 000645       102 000656       103 000666
    104 000671       105 000674       106 000677       107 000702       109 000703       110 000710       111 000714
    113 000720       116 000773       119 001051       122 001130       125 001140       126 001141       127 001145
    128 001147       129 001162       130 001205       131 001214       132 001223       133 001224       134 001225
    135 001226       136 001227       138 001230       139 001234       140 001236       141 001261       143 001262
    144 001267       146 001270       147 001274       148 001313       149 001327       150 001343       151 001357
    152 001373       153 001412       154 001426       155 001442       156 001456       157 001472       158 001511
    159 001525       160 001526       161 001532       162 001534       164 001537       165 001545       166 001546
    167 001550       168 001551       169 001553       170 001554       171 001555       172 001556       173 001560
    174 001562       175 001605       177 001606       178 001612       179 001615       180 001617       181 001621
    183 001622       184 001644       185 001645       186 001670       187 001671       188 001672       189 001673
    191 001726       195 001727       197 001730       198 001741       199 001742       200 001774       202 001775
    203 002004       204 002007       205 002012       206 002013       207 002015       208 002017       209 002021
    211 002022       212 002026       215 002030       219 002031       222 002032       224 002035       226 002044
    227 002045       228 002047       229 002051       231 002053       235 002054       243 002056       245 002062
    246 002070       247 002102       250 002113       251 002125       252 002127       253 002152       255 002153
    256 002155       257 002200       259 002201       260 002203       261 002213       263 002225       264 002255
    265 002260       266 002316       269 002320       270 002322       272 002323       274 002335       275 002364
    276 002367       277 002425       280 002427       282 002451       283 002501       284 002504       285 002543
    290 002545       291 002547       292 002576       295 002577       296 002602       297 002634       300 002635
    304 002636       314 002640       315 002645       316 002650       318 002651       319 002660       320 002663
    321 002726       323 002727       324 002732       325 002736       327 002740       328 002755       329 002761
    330 002762       332 002764       333 002767       335 002773       340 002774       345 002776       347 002777
    348 003006       349 003023       350 003027       352 003076       353 003101       354 003103       356 003122


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
