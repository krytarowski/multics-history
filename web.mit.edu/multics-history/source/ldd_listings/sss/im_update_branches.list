	COMPILATION LISTING OF SEGMENT im_update_branches
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 05/08/85  1045.2 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION:
        8*
        9*          This program updates (some subset of) the parent node_id's recorded
       10*     in the children of a specified parent node.  There are two entrypoints,
       11*     im_update_branches$im_update_branches and im_update_branches$single.  The
       12*     latter entrypoint, $single, is used to update the parent node_id of
       13*     exactly one child node.  The main entrypoint is used to update a
       14*     contiguous interval of branches (the children pointed to by branches
       15*     p_index through key_range.last of the specified parent node).
       16*     
       17*     The assumed need for updating (in the $im_update_branches entrypoint
       18*     case) is that all of the slots in the specified parent node were shifted
       19*     to a higher numbered slot from their old position, starting with the
       20*     branch now at p_index slot.
       21**/
       22 
       23 /* HISTORY:
       24*Written by Lindsey Spratt, 05/06/82.
       25*Modified:
       26*06/16/82 by Matthew Pierret: Removed the beginning_offset argument from
       27*            calls to collection_manager_$put_element.
       28*08/09/82 by Matthew Pierret: Removed offset and length arguments from calls
       29*            to collection_manager_$get_element.
       30*09/17/82 by Lindsey Spratt:  Changed to accept p_index = 0 as a valid request
       31*	  to start the "update" from the low_branch_id.  Accordingly changed
       32*	  to jump the index from 0 to the key_range.first value in the
       33*	  CHILD_NODE_LOOP.  Also, changed to call sub_err_ if invoked on a
       34*	  leaf node.
       35*09/22/82 by Lindsey Spratt:  Added the "single" entry, for updating just one
       36*	  branch, the one specified in p_index.
       37*11/08/83 by Lindsey L. Spratt:  Changed to use the "buffered" access method on
       38*            the parent node.  Calls of the $single entry with a p_index = 0
       39*            (update the low_branch_id branch) can have a null
       40*            p_node_buffer_ptr, all other calls must have a valid
       41*            p_node_buffer_ptr.
       42*05/10/84 by Matthew Pierret:  Changed to align local_key_buffer on an
       43*            even-word boundary.  Made to use key_index instead of
       44*            addr(key_id_string)->element_id.index to avoid a compiler bug.
       45*06/07/84 by Matthew Pierret:  Re-named cm_$simple_get_buffered_element
       46*            to cm_$simple_get_from_ci_buffer, cm_$get_element to cm_$get,
       47*            cm_$put_element to cm_$modify,
       48*10/10/84 by Lindsey L. Spratt:  Added a DESCRIPTION and various comments.
       49*04/19/85 by Lindsey L. Spratt:  Fixed to work in the case where the multiple
       50*            key entrypoint is used, but there is only one branch which is the
       51*            low_branch_id.
       52**/
       53 
       54 /* format: style2,ind3 */
       55 
       56 im_update_branches:
       57    proc (p_node_buffer_ptr, p_file_opening_id, p_collection_id, p_common_ci_header_ptr, p_ci, p_index, p_code);
       58 
       59 /* START OF DECLARATIONS */
       60 /* Parameter */
       61 
       62       dcl	    p_node_buffer_ptr      ptr parameter;
       63       dcl	    p_file_opening_id      bit (36) aligned parameter;
       64       dcl	    p_collection_id	       bit (36) aligned parameter;
       65       dcl	    p_common_ci_header_ptr ptr;
       66       dcl	    p_ci		       fixed bin (24) unsigned unaligned;
       67       dcl	    p_index	       fixed bin (12) unsigned unaligned;
       68       dcl	    p_code	       fixed bin (35);
       69 
       70 /* Automatic */
       71 
       72       dcl	    (child_header_id_string, key_id_string)
       73 			       bit (36) aligned;
       74       dcl	    single_update	       bit (1) aligned init ("0"b);
       75       dcl	    last_index	       fixed bin (18) uns;
       76       dcl	    key_index	       fixed bin (12) uns;
       77 
       78       dcl	    local_header_buffer    bit (max (LEAF_CI_HEADER_LENGTH_IN_BITS, BRANCH_CI_HEADER_LENGTH_IN_BITS)) aligned;
       79       dcl	    local_key_buffer       (DOUBLE_WORDS_PER_PAGE) fixed bin (71);
       80       dcl	    key_buffer_length      fixed bin (35) init (BITS_PER_PAGE);
       81       dcl	    branch_key_length      fixed bin (35);
       82       dcl	    child_header_ptr       ptr;
       83       dcl	    child_header_length    fixed bin (35);
       84 
       85 /* Based */
       86 /* Builtin */
       87 
       88       dcl	    (max, null, length, addr)
       89 			       builtin;
       90 
       91 /* Controlled */
       92 /* Constant */
       93 
       94       dcl	    BITS_PER_PAGE	       init (36 * 1024) fixed bin (17) internal static options (constant);
       95       dcl	    DOUBLE_WORDS_PER_PAGE  init (512) fixed bin (17) internal static options (constant);
       96       dcl	    myname	       init ("im_update_branches") char (18) internal static options (constant);
       97 
       98 /* Entry */
       99 
      100       dcl	    sub_err_	       entry () options (variable);
      101 
      102 /* External */
      103 
      104       dcl	    dm_error_$programming_error
      105 			       fixed bin (35) ext;
      106 
      107 /* END OF DECLARATIONS */
      108 
      109       single_update = "0"b;
      110       goto JOIN;
      111 
      112 single:
      113    entry (p_node_buffer_ptr, p_file_opening_id, p_collection_id, p_common_ci_header_ptr, p_ci, p_index, p_code);
      114       single_update = "1"b;
      115 
      116 JOIN:
      117       common_ci_header_ptr = p_common_ci_header_ptr;
      118       if common_ci_header.is_leaf
      119       then call sub_err_ (dm_error_$programming_error, myname, "s", null, 0,
      120 	      "^/This program may only be invoked on branch nodes.  It was invoked on the
      121 leaf node with id ^d.", p_ci);
      122       else branch_ci_header_ptr = common_ci_header_ptr;
      123 
      124       addr (child_header_id_string) -> element_id.index = DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT;
      125 
      126       addr (key_id_string) -> element_id.control_interval_id = p_ci;
      127       if single_update
      128       then last_index = p_index;
      129       else last_index = common_ci_header.key_range.last;
      130 
      131 CHILD_NODE_LOOP:
      132       do key_index = p_index to last_index;
      133 
      134          addr (key_id_string) -> element_id.index = key_index;
      135 
      136 /* A slot_index of 0 indicates that the child node pointed at by the
      137*low_branch_id of the parent node is to be updated.
      138*
      139*Other values of slot_index are actual indexes into the slot table, identifying
      140*real elements.
      141**/
      142 
      143          if addr (key_id_string) -> element_id.index = 0
      144          then
      145 	  do;
      146 
      147 	     if common_ci_header.key_range.first > 0
      148 	     then key_index = common_ci_header.key_range.first - 1;
      149 						/* This sets key_index so it will be key_range.first for the next loop.*/
      150 	     else ;				/* last_index is 0, so this will be a one-pass loop because */
      151 						/* key_index is going to be incremented to 1 at its bottom. */
      152 
      153 	     addr (child_header_id_string) -> element_id.control_interval_id = branch_ci_header.low_branch_id;
      154 	  end;
      155          else
      156 	  do;
      157 
      158 /* To find out what the node_id of the child node identified by the current
      159*branch is, it's necessary to pick up the branch key.
      160**/
      161 
      162 	     branch_key_ptr = addr (local_key_buffer);
      163 	     call collection_manager_$simple_get_from_ci_buffer (p_node_buffer_ptr, p_collection_id, key_id_string,
      164 		branch_key_ptr, key_buffer_length, branch_key_length, p_code);
      165 
      166 	     if p_code ^= 0
      167 	     then call ERROR_RETURN (p_code);
      168 
      169 	     bk_string_length = branch_key_length - BRANCH_KEY_HEADER_LENGTH_IN_BITS;
      170 
      171 	     addr (child_header_id_string) -> element_id.control_interval_id = branch_key.branch_id;
      172 	  end;
      173 
      174 
      175 /* Now the child node's parent id string is actually updated.  First the
      176*ci_header for the child node is retrieved, then the parent_node_id is changed,
      177*and finally the updated ci_header is replaced in the child node.
      178**/
      179 
      180          call collection_manager_$get (p_file_opening_id, p_collection_id, child_header_id_string, 0,
      181 	    addr (local_header_buffer), length (local_header_buffer), null, "0"b, child_header_ptr, child_header_length,
      182 	    p_code);
      183 
      184          if p_code ^= 0
      185          then call ERROR_RETURN (p_code);
      186 
      187          child_header_ptr -> common_ci_header.parent_id_string = key_id_string;
      188 
      189          call collection_manager_$modify (p_file_opening_id, p_collection_id, child_header_ptr, child_header_length,
      190 	    child_header_id_string, 0, p_code);
      191          if p_code ^= 0
      192          then call ERROR_RETURN (p_code);
      193 
      194       end CHILD_NODE_LOOP;
      195 
      196 MAIN_RETURN:
      197       return;
      198 
      199 
      200 ERROR_RETURN:
      201    proc (er_p_code);
      202       dcl	    er_p_code	       fixed bin (35);
      203 
      204       p_code = er_p_code;
      205       goto MAIN_RETURN;
      206    end ERROR_RETURN;
      207 
  1     1 /* BEGIN INCLUDE FILE - dm_im_key.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*          There are two formats for keys, the leaf_key structure and the
  1     6*     branch_key structure. The branch_key has two more pieces of information
  1     7*     than the leaf_key. One is the control interval id of the
  1     8*     node for all keys greater than the value of the branch key.  The other is
  1     9*     the number of fields for which there are values in the "string" portion
  1    10*     of the key.  This allows for the storing of only as much data as is needed
  1    11*     to discriminate between the children being split by the branch key.
  1    12**/
  1    13 
  1    14 /* HISTORY:
  1    15*
  1    16*Written by Lindsey Spratt, 03/29/82.
  1    17*Modified:
  1    18*10/25/84 by Lindsey L. Spratt:  Added history and description sections.
  1    19**/
  1    20 
  1    21 /* format: style2,ind3 */
  1    22      dcl	   key_string	      bit (key_string_length) based (key_string_ptr);
  1    23      dcl	   key_string_length      fixed bin (35);
  1    24      dcl	   key_string_ptr	      ptr;
  1    25 
  1    26      dcl	   1 leaf_key	      based (leaf_key_ptr) unaligned,
  1    27 	     2 string	      bit (lk_string_length) unal;
  1    28 
  1    29      dcl	   lk_string_length	      fixed bin (35);
  1    30      dcl	   leaf_key_ptr	      ptr;
  1    31 
  1    32      dcl	   1 branch_key	      based (branch_key_ptr) unaligned,
  1    33 	     2 branch_id	      fixed bin (24) unsigned unaligned,
  1    34 	     2 last_field_idx     fixed bin (12) unaligned unsigned,
  1    35 	     2 string	      bit (bk_string_length) unal;
  1    36 
  1    37      dcl	   BRANCH_KEY_HEADER_LENGTH_IN_BITS
  1    38 			      init (36) fixed bin (35) internal static options (constant);
  1    39      dcl	   bk_string_length	      fixed bin (35);
  1    40      dcl	   branch_key_ptr	      ptr;
  1    41 
  1    42 /* END INCLUDE FILE - dm_im_key.incl.pl1 */
      208 
      209 
  2     1 /* BEGIN INCLUDE FILE - dm_im_ci_header.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*          Each node (control interval) in the index has a header which
  2     6*     describes the contents of that node.  Although there are two different
  2     7*     kinds of headers, leaf and branch, they have a great deal in common, the
  2     8*     common_ci_header.  The common_ci_header states which slots are used by
  2     9*     the keys (leaf or branch) in the key_range substructure.  There is an
  2    10*     "upward pointer" to the node's parent branch key (parent_id_string).
  2    11*     There are pointers to the previous and next nodes (previous_id and
  2    12*     next_id) on the same level to facilitate rotation of keys, and sequential
  2    13*     searching.  There is also a count of how much space is in use by the keys.
  2    14*
  2    15**/
  2    16 
  2    17 /* HISTORY:
  2    18*
  2    19*Written by Lindsey Spratt, 03/29/82.
  2    20*Modified:
  2    21*10/25/84 by Lindsey L. Spratt:  Added a description and fixed the history
  2    22*            section format.
  2    23**/
  2    24 
  2    25 /* format: style2,ind3 */
  2    26      dcl	   1 common_ci_header     based (common_ci_header_ptr),
  2    27 	     2 flags	      unaligned,
  2    28 	       3 is_leaf	      bit (1) unaligned,	/* ON for leaf_ci, OFF for branch_ci. */
  2    29 	       3 pad	      bit (17) unaligned,	/* Must be zero. */
  2    30 	     2 key_tail_space_used_since_last_prefix_compaction
  2    31 			      fixed bin (18) unsigned unal,
  2    32 	     2 key_range	      unaligned,
  2    33 	       3 first	      fixed bin (18) unsigned,
  2    34 	       3 last	      fixed bin (18) unsigned,
  2    35 	     2 parent_id_string   bit (36) aligned,
  2    36 	     2 previous_id	      fixed bin (24) unsigned unaligned,
  2    37 	     2 next_id	      fixed bin (24) unsigned unaligned,
  2    38 	     2 pad	      bit (24) unaligned;
  2    39 
  2    40 
  2    41      dcl	   common_ci_header_ptr   ptr;
  2    42 
  2    43      dcl	   1 leaf_ci_header	      based (leaf_ci_header_ptr),
  2    44 	     2 common	      like common_ci_header;
  2    45 
  2    46      dcl	   leaf_ci_header_ptr     ptr;
  2    47 
  2    48      dcl	   1 branch_ci_header     based (branch_ci_header_ptr),
  2    49 	     2 common	      like common_ci_header,
  2    50 	     2 low_branch_id      fixed bin (24) unsigned unaligned,
  2    51 	     2 pad	      bit (12) unaligned;
  2    52 
  2    53      dcl	   branch_ci_header_ptr   ptr;
  2    54 
  2    55 
  2    56      dcl	   (
  2    57 	   DEFAULT_INITIAL_KEY_SLOT
  2    58 			      init (2),
  2    59 	   DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT
  2    60 			      init (1),
  2    61 	   LEAF_CI_HEADER_LENGTH_IN_BITS
  2    62 			      init (180),
  2    63 	   BRANCH_CI_HEADER_LENGTH_IN_BITS
  2    64 			      init (216)
  2    65 	   )		      internal static options (constant) fixed bin;
  2    66 
  2    67 /* END INCLUDE FILE - dm_im_ci_header.incl.pl1 */
      210 
      211 
  3     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*
  3     5*        Contains the declaration of an element identifier.  Element
  3     6*   identifiers consist of two parts, the id (number) of the control interval
  3     7*   in which the element resides, and the index into the slot table of
  3     8*   the element in the control interval.  The declaration of the element_id 
  3     9*   structure reflects this division of the element identifier.  The structure 
  3    10*   is based on the automatic bit string element_id_string because programs
  3    11*   generally pass bit strings (element_id_string) to each other, then 
  3    12*   interpret the bit string by overlaying the element_id structure ony if
  3    13*   it is necessary to access the parts of the id.  Basing element_id on
  3    14*   addr(element_id_string) instead of on a pointer removes the necessity
  3    15*   for always setting that pointer explicitly and guarantees that changes
  3    16*   made to the string or structure do not get inconsistent.
  3    17*
  3    18*   Changes made to element_id must also be made to datum_id, declared in 
  3    19*   dm_cm_datum.incl.pl1.
  3    20**/
  3    21 
  3    22 /* HISTORY:
  3    23*Written by Matthew Pierret, 04/01/82.
  3    24*Modified:
  3    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  3    26**/
  3    27 
  3    28 /* format: style2,ind3,ll79 */
  3    29 
  3    30      dcl	   element_id_string      bit (36) aligned;
  3    31 
  3    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  3    33 	     2 control_interval_id
  3    34 			      fixed bin (24) unal unsigned,
  3    35 	     2 index	      fixed bin (12) unal unsigned;
  3    36 
  3    37 
  3    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      212 
      213 
  4     1 /* BEGIN INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*     This include file contains declarations of all collection_manager_ 
  4     5*     entrypoints.
  4     6**/
  4     7 
  4     8 /* HISTORY:
  4     9*Written by Matthew Pierret 
  4    10*Modified:
  4    11*04/14/82 by Lindsey Spratt: Changed the control_interval_id parameter of the
  4    12*	  allocate_control_interval operation to be unaligned, as well as
  4    13*	  unsigned.
  4    14*06/17/82 by Matthew Pierret: Added the put_element_portion opertion and
  4    15*            removed the beginning_location parameter from the put_element
  4    16*            operation. Added the create_page_file_operation.
  4    17*08/09/82 by Matthew Pierret: Changed "fixed bin (17)"s to "bit (36) aligned"s
  4    18*            wherever collection_id was required.
  4    19*            Also changed the control_interval_id parameter of the 
  4    20*            allocate_control_interval operation back to be aligned. So there.
  4    21*10/20/82 by Matthew Pierret: Changed $create_page_file to $create_file,
  4    22*            added the argument file_create_info_ptr to $create_file.
  4    23*12/13/82 by Lindsey Spratt:  Corrected $free_control_interval to
  4    24*	  include the zero_on_free bit.
  4    25*12/17/82 by Matthew Pierret: Added cm_$get_id.
  4    26*01/07/83 by Matthew Pierret: Added cm_$put_element_buffered, 
  4    27*            cm_$allocate_element_buffered, cm_$free_element_buffered.
  4    28*04/27/83 by Matthew Pierret: Added cm_$put_unprotected_element,
  4    29*            cm_$put_unprotected_header.
  4    30*11/07/83 by Matthew Pierret: Added $get_element_portion_buffered,
  4    31*             $simple_get_buffered_element.
  4    32*02/08/84 by Matthew Pierret:  Changed $get_id to have only one bit(1)aligned
  4    33*            parameter for specifying absolute/relative nature of search.
  4    34*03/16/84 by Matthew Pierret:  Added cm_$get_control_interval_ptr,
  4    35*            $get_element_ptr, $get_element_portion_ptr, $simple_get_element_ptr
  4    36*04/03/84 by Matthew Pierret:  Added cm_$compact_control_interval.
  4    37*06/06/84 by Matthew Pierret:  Re-named free_element* to delete and
  4    38*            delete_from_ci_buffer.
  4    39*            Re-named *_buffered_ci to =_ci_buffer.
  4    40*            get entries.
  4    41*            modify entries.
  4    42*            Changed calling sequence of modify entries to have a ptr/length
  4    43*            instead of length/ptr parameter pair.
  4    44*03/11/85 by R. Michael Tague:  Added $postcommit_increments.
  4    45**/
  4    46 
  4    47 /* This include file contains declarations of collection_manager_ entrypoints */
  4    48 
  4    49 /* format: style2,ind3 */
  4    50      dcl	   collection_manager_$allocate_control_interval
  4    51 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  4    52      dcl	   collection_manager_$compact_control_interval
  4    53 			      entry (bit (36) aligned, fixed bin (24) uns, fixed bin (35));
  4    54      dcl	   collection_manager_$create_collection
  4    55 			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  4    56      dcl	   collection_manager_$create_file
  4    57 			      entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
  4    58      dcl	   collection_manager_$destroy_collection
  4    59 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  4    60      dcl	   collection_manager_$free_control_interval
  4    61 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, bit (1) aligned,
  4    62 			      fixed bin (35));
  4    63 
  4    64      dcl	   collection_manager_$delete
  4    65 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  4    66 			      fixed bin (35));
  4    67      dcl	   collection_manager_$delete_from_ci_buffer
  4    68 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  4    69 			      fixed bin (35));
  4    70 
  4    71      dcl	   collection_manager_$get
  4    72 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  4    73 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  4    74      dcl	   collection_manager_$get_control_interval_ptr
  4    75 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, ptr,
  4    76 			      fixed bin (35));
  4    77      dcl	   collection_manager_$get_from_ci_buffer
  4    78 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  4    79 			      ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  4    80      dcl	   collection_manager_$get_by_ci_ptr
  4    81 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  4    82 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), ptr, fixed bin (35));
  4    83      dcl	   collection_manager_$get_header
  4    84 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (17), ptr, bit (1) aligned,
  4    85 			      ptr, fixed bin (35), fixed bin (35));
  4    86      dcl	   collection_manager_$get_id
  4    87 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17),
  4    88 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  4    89      dcl	   collection_manager_$get_portion
  4    90 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  4    91 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  4    92 			      fixed bin (35), fixed bin (35));
  4    93      dcl	   collection_manager_$get_portion_from_ci_buffer
  4    94 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  4    95 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  4    96 			      fixed bin (35));
  4    97      dcl	   collection_manager_$get_portion_by_ci_ptr
  4    98 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  4    99 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  4   100 			      fixed bin (35));
  4   101      dcl	   collection_manager_$modify
  4   102 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  4   103 			      fixed bin (35), fixed bin (35));
  4   104      dcl	   collection_manager_$modify_unprotected
  4   105 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  4   106 			      fixed bin (35), fixed bin (35));
  4   107      dcl	   collection_manager_$modify_in_ci_buffer
  4   108 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  4   109 			      fixed bin (35), fixed bin (35));
  4   110      dcl	   collection_manager_$modify_portion
  4   111 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35), ptr,
  4   112 			      fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  4   113      dcl	   collection_manager_$postcommit_increments
  4   114 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  4   115      dcl	   collection_manager_$put
  4   116 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  4   117 			      fixed bin (35), fixed bin (35));
  4   118      dcl	   collection_manager_$put_in_ci_buffer
  4   119 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  4   120 			      fixed bin (35), fixed bin (35));
  4   121      dcl	   collection_manager_$put_header
  4   122 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  4   123      dcl	   collection_manager_$put_unprotected_header
  4   124 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  4   125 
  4   126      dcl	   collection_manager_$replace_ci_buffer
  4   127 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  4   128 			      fixed bin (35));
  4   129      dcl	   collection_manager_$setup_ci_buffer
  4   130 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  4   131 			      fixed bin (35));
  4   132      dcl	   collection_manager_$simple_get_by_ci_ptr
  4   133 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  4   134 			      fixed bin (35));
  4   135      dcl	   collection_manager_$simple_get_from_ci_buffer
  4   136 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  4   137 			      fixed bin (35));
  4   138 
  4   139 /* END INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
      214 
      215    end im_update_branches;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/08/85  1034.9  im_update_branches.pl1            >special_ldd>online>dm.5.5-05/08/85>im_update_branches.pl1
208          1    01/07/85  0858.9  dm_im_key.incl.pl1                >ldd>include>dm_im_key.incl.pl1
210          2    01/07/85  0858.8  dm_im_ci_header.incl.pl1          >ldd>include>dm_im_ci_header.incl.pl1
212          3    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
214          4    04/05/85  0924.4  dm_collmgr_entry_dcls.incl.pl1    >ldd>include>dm_collmgr_entry_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BITS_PER_PAGE                          constant        fixed bin(17,0)          initial dcl 94 ref 80
BRANCH_CI_HEADER_LENGTH_IN_BITS        constant        fixed bin(17,0)          initial dcl 2-56 ref 78
BRANCH_KEY_HEADER_LENGTH_IN_BITS       constant        fixed bin(35,0)          initial dcl 1-37 ref 169
DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT
                                       constant        fixed bin(17,0)          initial dcl 2-56 ref 124
DOUBLE_WORDS_PER_PAGE                  constant        fixed bin(17,0)          initial dcl 95 ref 79
LEAF_CI_HEADER_LENGTH_IN_BITS          constant        fixed bin(17,0)          initial dcl 2-56 ref 78
addr                                                   builtin function         dcl 88 ref 124 126 134 143 153 162 171 180 180
bk_string_length                000113 automatic       fixed bin(35,0)          dcl 1-39 set ref 169*
branch_ci_header                       based           structure                level 1 unaligned dcl 2-48
branch_ci_header_ptr            000120 automatic       pointer                  dcl 2-53 set ref 122* 153
branch_id                              based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 1-32 ref 171
branch_key                             based           structure                level 1 packed unaligned dcl 1-32
branch_key_length               000107 automatic       fixed bin(35,0)          dcl 81 set ref 163* 169
branch_key_ptr                  000114 automatic       pointer                  dcl 1-40 set ref 162* 163* 171
child_header_id_string          000100 automatic       bit(36)                  dcl 72 set ref 124 153 171 180* 189*
child_header_length             000112 automatic       fixed bin(35,0)          dcl 83 set ref 180* 189*
child_header_ptr                000110 automatic       pointer                  dcl 82 set ref 180* 187 189*
collection_manager_$get         000014 constant        entry                    external dcl 4-71 ref 180
collection_manager_$modify      000016 constant        entry                    external dcl 4-101 ref 189
collection_manager_$simple_get_from_ci_buffer
                                000020 constant        entry                    external dcl 4-135 ref 163
common_ci_header                       based           structure                level 1 unaligned dcl 2-26
common_ci_header_ptr            000116 automatic       pointer                  dcl 2-41 set ref 116* 118 122 129 147 147
control_interval_id                    based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 3-32 set ref
                                                                                  126* 153* 171*
dm_error_$programming_error     000012 external static fixed bin(35,0)          dcl 104 set ref 118*
element_id                             based           structure                level 1 dcl 3-32
er_p_code                              parameter       fixed bin(35,0)          dcl 202 ref 200 204
first                     1            based           fixed bin(18,0)          level 3 packed unsigned unaligned dcl 2-26 ref 147
                                                                                  147
flags                                  based           structure                level 2 packed unaligned dcl 2-26
index                     0(24)        based           fixed bin(12,0)          level 2 packed unsigned unaligned dcl 3-32 set ref
                                                                                  124* 134* 143
is_leaf                                based           bit(1)                   level 3 packed unaligned dcl 2-26 ref 118
key_buffer_length               000106 automatic       fixed bin(35,0)          initial dcl 80 set ref 80* 163*
key_id_string                   000101 automatic       bit(36)                  dcl 72 set ref 126 134 143 163* 187
key_index                       000104 automatic       fixed bin(12,0)          unsigned dcl 76 set ref 131* 134 147*
key_range                 1            based           structure                level 2 packed unaligned dcl 2-26
last                      1(18)        based           fixed bin(18,0)          level 3 packed unsigned unaligned dcl 2-26 ref 129
last_index                      000103 automatic       fixed bin(18,0)          unsigned dcl 75 set ref 127* 129* 131
length                                                 builtin function         dcl 88 ref 180 180
local_header_buffer             000105 automatic       bit                      dcl 78 set ref 180 180 180 180
local_key_buffer                000106 automatic       fixed bin(71,0)          array dcl 79 set ref 162
low_branch_id             5            based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 2-48 ref 153
max                                                    builtin function         dcl 88 ref 78
myname                          000000 constant        char(18)                 initial unaligned dcl 96 set ref 118*
null                                                   builtin function         dcl 88 ref 118 118 180 180
p_ci                                   parameter       fixed bin(24,0)          unsigned unaligned dcl 66 set ref 56 112 118* 126
p_code                                 parameter       fixed bin(35,0)          dcl 68 set ref 56 112 163* 166 166* 180* 184 184*
                                                                                  189* 191 191* 204*
p_collection_id                        parameter       bit(36)                  dcl 64 set ref 56 112 163* 180* 189*
p_common_ci_header_ptr                 parameter       pointer                  dcl 65 ref 56 112 116
p_file_opening_id                      parameter       bit(36)                  dcl 63 set ref 56 112 180* 189*
p_index                                parameter       fixed bin(12,0)          unsigned unaligned dcl 67 ref 56 112 127 131
p_node_buffer_ptr                      parameter       pointer                  dcl 62 set ref 56 112 163*
parent_id_string          2            based           bit(36)                  level 2 dcl 2-26 set ref 187*
single_update                   000102 automatic       bit(1)                   initial dcl 74 set ref 74* 109* 114* 127
sub_err_                        000010 constant        entry                    external dcl 100 ref 118

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DEFAULT_INITIAL_KEY_SLOT               internal static fixed bin(17,0)          initial dcl 2-56
collection_manager_$allocate_control_interval
                                000000 constant        entry                    external dcl 4-50
collection_manager_$compact_control_interval
                                000000 constant        entry                    external dcl 4-52
collection_manager_$create_collection
                                000000 constant        entry                    external dcl 4-54
collection_manager_$create_file 000000 constant        entry                    external dcl 4-56
collection_manager_$delete      000000 constant        entry                    external dcl 4-64
collection_manager_$delete_from_ci_buffer
                                000000 constant        entry                    external dcl 4-67
collection_manager_$destroy_collection
                                000000 constant        entry                    external dcl 4-58
collection_manager_$free_control_interval
                                000000 constant        entry                    external dcl 4-60
collection_manager_$get_by_ci_ptr
                                000000 constant        entry                    external dcl 4-80
collection_manager_$get_control_interval_ptr
                                000000 constant        entry                    external dcl 4-74
collection_manager_$get_from_ci_buffer
                                000000 constant        entry                    external dcl 4-77
collection_manager_$get_header  000000 constant        entry                    external dcl 4-83
collection_manager_$get_id      000000 constant        entry                    external dcl 4-86
collection_manager_$get_portion 000000 constant        entry                    external dcl 4-89
collection_manager_$get_portion_by_ci_ptr
                                000000 constant        entry                    external dcl 4-97
collection_manager_$get_portion_from_ci_buffer
                                000000 constant        entry                    external dcl 4-93
collection_manager_$modify_in_ci_buffer
                                000000 constant        entry                    external dcl 4-107
collection_manager_$modify_portion
                                000000 constant        entry                    external dcl 4-110
collection_manager_$modify_unprotected
                                000000 constant        entry                    external dcl 4-104
collection_manager_$postcommit_increments
                                000000 constant        entry                    external dcl 4-113
collection_manager_$put         000000 constant        entry                    external dcl 4-115
collection_manager_$put_header  000000 constant        entry                    external dcl 4-121
collection_manager_$put_in_ci_buffer
            @                        „ªÈqÛî2®â~2r        o  r      Ð ¤ ¶         @                                                                                                   = L          SwX‘                                                   Tw     >  ™ÿ            &   H   ‚               &         Ú                                                                               z                                                 „ªÈq Ò    &„ªÈlDøÛ2    z z ¶ Äa          r ,    Attendees                           „ªÈlRyÈÄ    G›Lä%              ’   b Þ ¶ Äa               „ªÈq     L È      *@          „ªÈl       ü         TOBSWE                              „ªÈq 6 Ž   –  *@  €       „ªÈl       –         Zwick                               „ªÈq( T         Multics                             „ªÈq  r  &„ªÈ{BÙ–$    Ú Ú ¶ Äa          Ò     Transactions                        „ªÈ{D¨l=    Gžûã ¡              ’   ø ø ¶ Äa               „ªÈq              *@          „ªÈ{    6 L     >*@          „ªÈl       Ò  &„ªÈtBÙ–%      ¶ Äa           .    Proceedings.1                       „ªÈtD¨l;    G›LäG              ’   . . ¶ Äa               „ªÈq              *@          „ªÈt     À ®   ²  *@  €       „ªÈl     ü(         PLASTICS                            „ªÈq   ˜     T*@          „ªÈl     Ä         MSGD                                „ªÈq x     j  *@  €       „ªÈl     ² Ð         Lee                                 „ªÈq Ž b   ¶  *@  À       „ªÈl     æ ²         MAgar                               „ªÈq ® x   €  *@  €       „ªÈl     ¶ æ         PANakaska                           „ªÈq           DEVM                                „ªÈq € j         Luk                                 „ªÈq È 6   Ð  *@  €       „ªÈl     ˜ À   æ  *@  €       „ªÈl     j           Gray                                „ªÈq   ô      *@          „ªÈl     – €         Mabey                               „ªÈq Þ
     ü*@          „ªÈl       >         STDSPPT                             „ªÈq ô     *@          „ªÈl     T ¤         EngAdmin                            „ªÈq
6    (*@          „ªÈl     > Ä         NMLPROD                             „ªÈq        ¤*@          „ªÈl                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            oc_auto_adj      ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
collection_manager_$get       collection_manager_$modify    collection_manager_$simple_get_from_ci_buffer
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$programming_error




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     74 000051        78 000052        79 000064        80 000072        56 000076       109 000112       110 000113
    112 000114       114 000124       116 000126       118 000132       122 000207       124 000210       126 000212
    127 000217       129 000231       131 000235       134 000251       143 000252       147 000254       153 000263
    154 000266       162 000267       163 000271       166 000315       169 000326       171 000334       180 000340
    184 000405       187 000416       189 000421       191 000446       194 000457       196 000461       200 000462
    204 000464       205 000467


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
