	COMPILATION LISTING OF SEGMENT mu_database_index
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1328.4 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 mu_database_index: procedure (index, dbcb_ptr); index = 0; dbcb_ptr = null (); return; /* invalid entry */
       19 
       20 /* DESCRIPTION:
       21*
       22*   this routine manages the  database  opening  index  table,  which
       23*   contains  pointers  to the resultant models created at open time.
       24*   the database index is the  array  address  of  the  corresponding
       25*   dbcb_ptr(database  control block pointer in the resultant model).
       26*   their are six entries, set_dbcb_ptr to enter a dbcb_ptr into  the
       27*   table  and  get  a  new opening index. clear_dbcb_ptr to remove a
       28*   dbcb_ptr from the table and make it's index reusable get_dbcb_ptr
       29*   to  get  the resultant model dbcb pointer given an opening index.
       30*   num_db_open to return the number of databases open by the calling
       31*   process.  any_new_open to return true if any new version database
       32*   is open. set_dbcb_flag to set a flag in  the  table  and  reserve
       33*   that  slot  from  use  by a new version database, once a database
       34*   index for an old version has been obtained.  NOTE:  this  routine
       35*   needs  to  be  rewritten  to  avoid  the  critical  region due to
       36*   recursion via a quit/re-invoke
       37*
       38**/
       39 
       40 /* PARAMETERS:
       41*
       42*   index - - (input for clear, get, set_flag and output for set_ptr)
       43*   fixed bin(35) database opening index.
       44*
       45*   dbcb_ptr - - (output for clear and get/ input for set) pointer to
       46*   the  resultant  model  non_secure  segment known as dbcb(database
       47*   control block).
       48*
       49*   num_dbcb - - (output  for  num_db_open)  the  current  number  of
       50*   databases open for this process, declared fixed bin(17).
       51*
       52*   new_db_open - - (output) bit(1) aligned, output from any_new_open
       53*   entry, on if any new version database is open.
       54*
       55**/
       56 
       57 /* HISTORY:
       58*
       59*   rewritten by Jim Gray - - August 1979 to 1) document module logic
       60*   2)  correct  num_db_open entry to reflect current table status 3)
       61*   correct logic of set_dbcb_ptr 4) make name change so calls are of
       62*   form db_index$set, db_index$get, etc.
       63*
       64*   Modified by  Jim  Gray  -  -  March  1980,  to  add  the  entries
       65*   any_new_open,  set_dbcb_flag,  to build the logic for determining
       66*   old/new version databases from their database index.
       67*
       68*   Modified by Jim Gray - - June 1980, to pass  back  paths  of  old
       69*   version   databases   in  phony  version  of  resultant  used  by
       70*   dsl_$list_dbs.
       71*
       72*   81-1-9 Jim Gray : changed to use actual include files for old and
       73*   new  resultant  structures, also added more info to phony version
       74*   of new version resultant, that  is  taken  from  an  old  version
       75*   resultant  for  old  version  databases. This included open_mode,
       76*   dbc_ptr,  db_version.  Thus  the  legimate  values  that  can  be
       77*   obtained  from  the  phony  resultant,  for  old version database
       78*   openings are: in the dbcb open_mode - dbc_ptr - rdbi_ptr  in  the
       79*   rm_db_info  db_path - sm_path(always = db_path) - db_version This
       80*   solves the problem with  DMOD  not  being  able  to  display  old
       81*   version   databases   open   modes,  and  provides  for  the  new
       82*   display_mrds_scope_settings  to  be  able  to  display  the   dbc
       83*   structure version (as concurrency control version)
       84*
       85*   81-04-24 Jim Gray :  changed  internal  static  tables  to  based
       86*   arrays  in  a  temp  segment,  so  that  mrds_data_$max_dbs could
       87*   automatically change the maximum number of openings allowed.
       88*
       89*   81-04-27 Jim Gray :  extended  old  resultant  to  hold  submodel
       90*   opening  information,  thus the phony resultant now has good info
       91*   for dbcb.dsm_sw, rm_db_info.sm_ath & sm_version
       92*
       93*   83-06-21 Davids: Eliminated the dbcb_flag_table which kept track of
       94*   old/new version database openings (old version databases can no longer
       95*   be opened). This eliminated a lot of overhead two entries were also
       96*   deleted - set_dbcb_flag and any_new_open. 
       97**/
       98 
       99 set_dbcb_ptr: get_database_index: entry (index, dbcb_ptr);
      100 
      101 	if ^index_table_ready then
      102 	     call init_index_table ();
      103 
      104 /* given a dbcb pointer(resultant model control block segment pointer),
      105*   find an empty space in the database index table, put the pointer
      106*   their, and return the index value as the database index for this opening.
      107*   0 is returned as an index, if the table is full. */
      108 
      109 	index = 0;
      110 	found = OFF;
      111 	i = 1;
      112 
      113 	do while (^found);
      114 
      115 /* note: the flag table says whether an old version db_index is using the slot */
      116 
      117 	     if dbcb_ptr_table (i) = null () then do;
      118 		     found = ON;
      119 		     dbcb_ptr_table (i) = dbcb_ptr;
      120 		     index = i;
      121 		end;
      122 
      123 	     else if i < mrds_data_$max_dbs then /* not an empty slot */
      124 		i = i + 1;			/* go to next slot */
      125 	     else found = ON;			/* end of table reached, => table full */
      126 
      127 	end;
      128 
      129 	return;
      130 
      131 clear_dbcb_ptr: reset_resultant_model_pointer: entry (index, dbcb_ptr);
      132 
      133 	if ^index_table_ready then
      134 	     call init_index_table ();
      135 
      136 /* given a database index, find the corresponding resultant
      137*   model control block segment pointer in the table, and
      138*   set the dbcb_ptr to the value found their, at the same
      139*   time setting that table entry to null, thus deleting
      140*   that database index as a valid entry.
      141*   an index outside the table limits returns a null pointer. */
      142 
      143 
      144 	if index < 1 | index > mrds_data_$max_dbs then
      145 	     dbcb_ptr = null ();
      146 	else do;
      147 		dbcb_ptr = dbcb_ptr_table (index);
      148 		dbcb_ptr_table (index) = null ();
      149 	     end;
      150 
      151 	return;
      152 
      153 get_dbcb_ptr: get_resultant_model_pointer: entry (index, dbcb_ptr);
      154 
      155 	if ^index_table_ready then
      156 	     call init_index_table ();
      157 
      158 /* given a database index, look
      159*   in the dbcb pointer table for the
      160*   resultant model control block segment
      161*   pointer corresponding to that index.
      162*   a index beyond table limits results
      163*   in a null pointer being returned. */
      164 
      165 
      166 	if index < 1 | index > mrds_data_$max_dbs
      167 	then dbcb_ptr = null ();			/* not valid index */
      168 	else dbcb_ptr = dbcb_ptr_table (index);		/* new version */
      169 
      170 	return;
      171 
      172 num_db_open: get_number_open_dbs: entry returns (fixed bin);
      173 
      174 	if ^index_table_ready then
      175 	     call init_index_table ();
      176 
      177 /* count the number of "good" database indexes already used in the
      178*   dbcb pointer table, and return this as number of
      179*   databases open by the caller process */
      180 
      181 
      182 	num_dbcb = 0;
      183 	do i = 1 by 1 to mrds_data_$max_dbs;
      184 	     if dbcb_ptr_table (i) ^= null ()
      185 	     then num_dbcb = num_dbcb + 1;
      186 	end;
      187 
      188 	return (num_dbcb);
      189 
      190 init_index_table: procedure ();
      191 
      192 /* this routine gets temp space for the db_index arrays,
      193*   and initializes the two arrays involved.
      194*   The arrays are made based, rather than internal static,
      195*   so that the mrds_data_$max_dbs can be changed to automatically
      196*   change the limit on the number of permissible openings.
      197*   This temp space will remain around for the life of the process. */
      198 
      199 	call get_temp_segment_ (caller_name, temp_seg_ptr, code);
      200 	if code ^= 0 then
      201 	     call sub_err_ (code, caller_name, continue, info_ptr, return_value, "^/^a",
      202 		"Unable to get a temp segment for managing the database opening indexes.");
      203 	else do;
      204 
      205 		temp_seg_ptr -> index_area = empty ();
      206 
      207 		allocate dbcb_ptr_table set (dbcb_ptr_table_ptr) in (index_area);
      208 
      209 		do i = 1 to mrds_data_$max_dbs;
      210 
      211 		     dbcb_ptr_table (i) = null ();
      212 
      213 		end;
      214 
      215 		index_table_ready = ON;
      216 
      217 	     end;
      218 
      219      end;
      220 
      221 	declare OFF		 bit (1) init ("0"b) int static options (constant); /* false value */
      222 	declare ON		 bit (1) init ("1"b) int static options (constant); /* true value */
      223 	declare caller_name		 char (20) init ("mu_database_index"); /* name of calling routine */
      224 	declare code		 fixed bin (35);	/* for sub_err_ */
      225 	declare continue		 char (1) init ("c") int static options (constant); /* dont stop after printing mesg */
      226 	declare dbcb_ptr_table	 (1:mrds_data_$max_dbs) ptr based (dbcb_ptr_table_ptr); /* table of dbcb ptrs */
      227 	declare dbcb_ptr_table_ptr	 ptr init (null ()) int static; /* points to dbcb_ptr_table */
      228 	declare found		 bit (1);		/* on => can exit search loop */
      229 	declare get_temp_segment_	 entry (char (*), ptr, fixed bin (35)); /* gets index space */
      230 	declare i			 fixed bin;
      231 	declare index		 fixed bin (35);	/* index into table of dbcb pointers */
      232 	declare index_area		 area (sys_info$max_seg_size) based (temp_seg_ptr); /* space for index tables */
      233 	declare index_table_ready	 bit (1) int static init ("0"b); /* on => index arrays already init */
      234 	declare info_ptr		 ptr init (null ());/* unused */
      235 	declare mrds_data_$max_dbs	 fixed bin ext;	/* max number of openings allowed */
      236 	declare num_dbcb		 fixed bin;	/* num dbcb pointers in table */
      237 	declare return_value	 fixed bin (35) init (0); /* unused */
      238 	declare sub_err_		 entry options (variable); /* reports subroutine errors */
      239 	declare sys_info$max_seg_size	 fixed bin (35) ext;/* largest segment size */
      240 	declare temp_seg_ptr	 ptr;		/* points to temp index space */
      241 	declare (empty, null)	 builtin;
      242 
  1     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  1     9*     Nguyen. The scopes_changed flag was added to make checking for this
  1    10*     more efficient (mrds error list #137).
  1    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  1    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  1    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  1    14*     care if multiple txns use the same selection_expression. (mrds #156)
  1    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  1    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  1    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  1    18*                                                   END HISTORY COMMENTS */
  1    19 
  1    20 
  1    21 /* WARNING
  1    22*          If the dbcb structure is changed then the mrds_data_
  1    23*          item saved_res_version MUST be incremented to invalidate all
  1    24*          existing saved resultants
  1    25**/
  1    26 
  1    27 /* HISTORY :
  1    28*
  1    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  1    30*   tid_list management
  1    31*
  1    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  1    33*   phony resultant in mu_database_index, without having the area dcl
  1    34*   included.
  1    35*
  1    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  1    37*   mrds_dsl_store
  1    38*
  1    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  1    40*   switches
  1    41*
  1    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  1    43*   expression,  so  that relation statistics can be updated relative
  1    44*   to number of selection expressions seem. Also  removed  init  for
  1    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  1    46*   mrds_dsl_init_res.
  1    47*
  1    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  1    49*
  1    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  1    51*   for the conversion to the relation manager.
  1    52*
  1    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  1    54*   substructures so that the entries and costs can change
  1    55*   depending on the type of database that is opened.
  1    56*
  1    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  1    58*   since modify uses a different vector type (general) than does store.
  1    59*
  1    60*   82-09-20 Davids: changed names of (store modify)_vector to
  1    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  1    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  1    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  1    64*   during the first call.
  1    65*
  1    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  1    67*   since it deals with the pointers to the cursors and not the cursors
  1    68*   themelves and added the element cursor_storage_area_ptr which points
  1    69*   to the area where the cursors are kept.
  1    70*
  1    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  1    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  1    73*   anything.
  1    74*
  1    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  1    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  1    77*   by mrds_dsl_define_temp_rel.
  1    78*
  1    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  1    80*   is needed by mu_store.
  1    81*
  1    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  1    83*   bin to float bin since the values are not integers.
  1    84*
  1    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  1    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  1    87*   added to the end of the structure to allow modules that don't use
  1    88*   the element to continue to reference the dbcb structure without recompiling.
  1    89*
  1    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  1    91*   are needed so that temp rels can be created with the same file attributes
  1    92*   as the permanent relations.
  1    93*
  1    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  1    95*   added the resultant_in_pdir bit.
  1    96*
  1    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  1    98*   added the res_already_made element.
  1    99*
  1   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  1   101*
  1   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  1   103*   one of the unused pointers.
  1   104*
  1   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  1   106*
  1   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  1   108*   leaving unused_ptrs(1).
  1   109*
  1   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  1   111*   unused_ptrs (1).
  1   112*
  1   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  1   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  1   115*   spare ptrs, entries and reserved storages for future enhancement, since
  1   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  1   117*
  1   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  1   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  1   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  1   121**/
  1   122 
  1   123 
  1   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  1   125*   that constitutes the non-secure portion of the resultant model that is
  1   126*   created during the opening of a database. it contains variables that
  1   127*   are used during the runtime access of the database, and an area
  1   128*   for evaluation of requests. it points to four other
  1   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  1   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  1   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  1   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  1   133*   used in the elimination of duplicate tuples during a retrieve.
  1   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  1   135*   that is used when the database is using the file scope mechanism
  1   136*   for concurrency control over file readying. the segment overlayed via
  1   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  1   138*   across database openings. the pointer to this dbcb structure is kept in a table
  1   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  1   140*   opening instances of resultant models. (see mu_database_index routine) */
  1   141 
  1   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  1   143 	     2 data	      like dbcb_data,
  1   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  1   145 
  1   146      dcl	   dbcb_ptr	      ptr;
  1   147 
  1   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  1   149*						   like references can avoid getting the area declaration */
  1   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  1   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  1   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  1   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  1   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  1   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  1   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  1   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  1   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  1   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  1   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  1   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  1   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  1   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  1   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  1   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  1   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  1   167*						   for eliminating duplicate tuples. */
  1   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  1   169*						   for eliminating duplicate tuples. */
  1   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  1   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  1   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  1   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  1   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  1   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  1   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  1   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  1   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  1   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  1   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  1   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  1   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  1   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  1   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  1   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  1   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  1   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  1   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  1   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  1   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  1   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  1   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  1   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  1   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  1   195 	     2 val_del	      bit (1) unal,		/* for delete */
  1   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  1   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  1   198*                                                                     not imply that the database is of type page_file */
  1   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  1   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  1   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  1   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  1   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  1   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  1   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  1   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  1   207*						   inside a sequence of -another selection expression. */
  1   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  1   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  1   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  1   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  1   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  1   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  1   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  1   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  1   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  1   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  1   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  1   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  1   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  1   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  1   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  1   223 	     2 relmgr_entries,			/* relation manager entries */
  1   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  1   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  1   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  1   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  1   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  1   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  1   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  1   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  1   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  1   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  1   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  1   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  1   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  1   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  1   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  1   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  1   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  1   241 	       3 reserved_entries (5) entry (),
  1   242 	     2 access_costs,			/* access costs for permute */
  1   243 	       3 total_primary_key_cost float bin,
  1   244 	       3 access_cost      float bin,
  1   245 	       3 access_overhead  float bin,
  1   246 	       3 us_access_cost   float bin,
  1   247 	       3 os_access_cost   float bin,
  1   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  1   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  1   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  1   251 
  1   252 /* END mrds_dbcb.incl.pl1 */
  1   253 
  1   254 
      243 
      244 
  2     1 /* BEGIN mdbm_rm_db_info.incl.pl1 -- jaw, 11/7/78 */
  2     2 
  2     3 
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(86-08-13,Hergert),, approve(88-06-28,MCR7903),
  2     7*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  2     8*     Removed change of 84-11-02. i.e. replaced even_word_pad.
  2     9*                                                   END HISTORY COMMENTS */
  2    10 
  2    11 
  2    12 /* WARNING
  2    13*          If the rm_db_info structure is changed then the mrds_data_
  2    14*          item saved_res_version MUST be incremented to invalidate all
  2    15*          existing saved resultants
  2    16**/
  2    17 
  2    18 /*  DESCRIPTION:  This  structure   is   based   on   a   segment
  2    19*   {unique_name}.mrds.rdbi that represents the secure portion of the
  2    20*   resultant model that is created partially at database open  time,
  2    21*   (the rm_file_array, and rm_rel_array) and partially at ready_file
  2    22*   time,    (the    rm_file_info,     rm_rel_info,     rm_attr_info,
  2    23*   rm_domain_info, rm_plink_info and rm_clink_info). it's purpose is
  2    24*   to  provide  an  efficient  means  of  accessing  database  model
  2    25*   information, as seen from the possibly submodel view of the user,
  2    26*   and his current state of "files readied". it is the  secure  part
  2    27*   because  it  contains  the  model  information  which needs to be
  2    28*   protected  from  general  knowledge,  and   this   segment   will
  2    29*   eventually  be  capable  of  being in a lower ring. the structure
  2    30*   itself points to four arrays that are  allocated  in  it's  area,
  2    31*   that  in  turn point to the other structures mentions above, also
  2    32*   allocated in  the  rm_db_info.static_area.  the  arrays  are  the
  2    33*   rm_file_array,  and  rm_rel_array. their are a pair for temporary
  2    34*   relations,  initially  empty,  and  a  pair  for   normal   model
  2    35*   files/relations.  the  normal  rm_file_array  is initialized to a
  2    36*   list of all known file names, the rm_rel_array only gets relation
  2    37*   names   as   files  are  readied.  the  rm_file_array  points  to
  2    38*   rm_file_infos for each file (see mdbm_rm_file_info.incl.pl1)  and
  2    39*   the   rm_rel_array   points  to  rm_rel_info  for  each  relation
  2    40*   "readied". (see mdbm_rm_rel_info.incl.pl1). (the  arrays  are  in
  2    41*   mdbm_rm_file_array.incl.pl1  and mdbm_rm_rel_array.incl.pl1). the
  2    42*   file infos point to contained rel infos, the rel infos  point  to
  2    43*   contained  attr  infos,  and  those in turn to domain infos. (see
  2    44*   mdbm_rm_attr_info.incl.pl1   and    mdbm_rm_domain_info.incl.pl1)
  2    45*   foreign     keys    are    represented    by    the    structures
  2    46*   mdbm_rm_plink_info.incl.pl1, and mdbm_rm_clink_info.incl.pl1. the
  2    47*   pathnames  of the model and submodel, if any, are also maintained
  2    48*   in rm_db_info. the pointer to this rm_db_info segment is obtained
  2    49*   from  the  dbcb  segment tructure(see mrds_dbcb.incl.pl1) see the
  2    50*   individual include files for  further  organization  information,
  2    51*   and particular data structures.
  2    52*
  2    53*   HISTORY:
  2    54*
  2    55*   80-02-01 Jim Gray : Modified to put area on even  word  boundary,
  2    56*   so that define_area_ could be used to make it an extensible area
  2    57*
  2    58*   81-1-9 Jim  Gray  :  added  like  reference  to  make  the  phony
  2    59*   resultant in mu_database_index easier to keep, since no reference
  2    60*   to the area is needed.
  2    61*
  2    62*   81-1-12 Jim Gray : added version of submodel used in  opening  to
  2    63*   resultant.
  2    64*
  2    65*   81-05-13 Rickie E. Brinegar: added the administrator bit  to  the
  2    66*   structure.
  2    67*
  2    68*   81-05-28 Jim Gray : removed pointers to file_arrays,  since  they
  2    69*   are  now  combined  into  the rel_array. Removed the control file
  2    70*   info which was unused. Added pointer  to  head  of  domain  list,
  2    71*   which is to be used to insure only one copy of each domain info.
  2    72*
  2    73*   83-05-19 Davids: Added the  saved_res_version element.
  2    74*
  2    75*   84-11-02 Thanh Nguyen:   Replaced  the  even_word_pad   by   the 
  2    76*   ref_name_proc_ptr  to point  to list  of reference  name of  the
  2    77*   check, encode, or decode proc.
  2    78*
  2    79*   CAUTION: The structure entries from db_version to sm_path  should
  2    80*   not  be moved or have their declarations changed because they are
  2    81*   used in the handling of old version database openings.
  2    82*
  2    83*
  2    84**/
  2    85 
  2    86      dcl	   1 rm_db_info	      aligned based (rdbi_ptr), /* data base info, located at base of res. dm. seg. */
  2    87 	     2 data	      like rm_db_info_data,
  2    88 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (rm_db_info.static_area))));
  2    89 
  2    90      dcl	   rdbi_ptr	      ptr;
  2    91 
  2    92      declare 1 rm_db_info_data      based,		/* separate declaration of info, so others can use
  2    93*						   like reference to it without getting the area as well */
  2    94 	     2 db_version	      fixed bin,		/* version no. of db */
  2    95 	     2 sm_version	      fixed bin unal,	/* version of submodel used unal, 0 if model opening */
  2    96 	     2 val_level	      fixed bin unal,	/* validation level for this db. */
  2    97 	     2 db_path	      char (168),		/* abs. path of db. */
  2    98 	     2 sm_path	      char (168),		/* path of submodel or model */
  2    99 	     2 mdbm_secured	      bit (1) unal,		/* ON => database is secured */
  2   100 	     2 administrator      bit (1) unal,		/* ON => user is an administrator */
  2   101 	     2 pad	      bit (34) unal,	/* for future use */
  2   102 	     2 saved_res_version  char (8),		/* version of the saved resultant in the 
  2   103*                                                               dbcb and rdbi segments in the db dir */
  2   104 	     2 domain_list_ptr    ptr,		/* pointer to head of list of domain_info's */
  2   105 	     2 ra_ptr	      ptr,		/* pointer to rel. array */
  2   106 	     2 tra_ptr	      ptr,		/* to rel array for temp rels */
  2   107 	     2 even_word_pad      fixed bin (71) aligned; /* padding to put area on even word boundary */
  2   108 
  2   109 /* END mdbm_rm_db_info.incl.pl1 */
  2   110 
  2   111 
      245 
      246 
      247      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1314.3  mu_database_index.pl1             >special_ldd>install>MR12.2-1073>mu_database_index.pl1
243          1    08/01/88  1300.0  mrds_dbcb.incl.pl1                >special_ldd>install>MR12.2-1073>mrds_dbcb.incl.pl1
245          2    08/01/88  1310.7  mdbm_rm_db_info.incl.pl1          >special_ldd>install>MR12.2-1073>mdbm_rm_db_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
OFF                                    constant        bit(1)                   initial packed unaligned dcl 221 ref 110
ON                                     constant        bit(1)                   initial packed unaligned dcl 222 ref 118 125 215
caller_name                     000100 automatic       char(20)                 initial packed unaligned dcl 223 set ref 199* 200*
                                                                                  223*
code                            000105 automatic       fixed bin(35,0)          dcl 224 set ref 199* 200 200*
continue                        000000 constant        char(1)                  initial packed unaligned dcl 225 set ref 200*
dbcb_data                              based           structure                level 1 unaligned dcl 1-148
dbcb_ptr                               parameter       pointer                  dcl 1-146 set ref 18 18* 99 99 119 131 131 144* 147*
                                                                                  153 153 166* 168*
dbcb_ptr_table                         based           pointer                  array dcl 226 set ref 117 119* 147 148* 168 184 207
                                                                                  211*
dbcb_ptr_table_ptr              000010 internal static pointer                  initial dcl 227 set ref 117 119 147 148 168 184 207*
                                                                                  211
empty                                                  builtin function         dcl 241 ref 205
found                           000106 automatic       bit(1)                   packed unaligned dcl 228 set ref 110* 113 118* 125*
get_temp_segment_               000014 constant        entry                    external dcl 229 ref 199
i                               000107 automatic       fixed bin(17,0)          dcl 230 set ref 111* 117 119 120 123 123* 123 183*
                                                                                  184* 209* 211*
index                                  parameter       fixed bin(35,0)          dcl 231 set ref 18 18* 99 99 109* 120* 131 131 144
                                                                                  144 147 148 153 153 166 166 168
index_area                             based           area                     dcl 232 set ref 205* 207
index_table_ready               000012 internal static bit(1)                   initial packed unaligned dcl 233 set ref 101 133 155
                                                                                  174 215*
info_ptr                        000110 automatic       pointer                  initial dcl 234 set ref 200* 234*
mrds_data_$max_dbs              000016 external static fixed bin(17,0)          dcl 235 ref 123 144 166 183 207 209
null                                                   builtin function         dcl 241 ref 18 117 144 148 166 184 211 234
num_dbcb                        000112 automatic       fixed bin(17,0)          dcl 236 set ref 182* 184* 184 188
return_value                    000113 automatic       fixed bin(35,0)          initial dcl 237 set ref 200* 237*
rm_db_info_data                        based           structure                level 1 unaligned dcl 2-92
sub_err_                        000020 constant        entry                    external dcl 238 ref 200
sys_info$max_seg_size           000022 external static fixed bin(35,0)          dcl 239 ref 205
temp_seg_ptr                    000114 automatic       pointer                  dcl 240 set ref 199* 205 207

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
dbcb                                   based           structure                level 1 dcl 1-142
rdbi_ptr                               automatic       pointer                  dcl 2-90
rm_db_info                             based           structure                level 1 dcl 2-86

NAMES DECLARED BY EXPLICIT CONTEXT.
clear_dbcb_ptr                  000231 constant        entry                    external dcl 131
get_database_index              000113 constant        entry                    external dcl 99
get_dbcb_ptr                    000313 constant        entry                    external dcl 153
get_number_open_dbs             000357 constant        entry                    external dcl 172
get_resultant_model_pointer     000300 constant        entry                    external dcl 153
init_index_table                000441 constant        entry                    internal dcl 190 ref 101 133 155 174
mu_database_index               000066 constant        entry                    external dcl 18
num_db_open                     000371 constant        entry                    external dcl 172
reset_resultant_model_pointer   000216 constant        entry                    external dcl 131
set_dbcb_ptr                    000126 constant        entry                    external dcl 99

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       762        1006     573         772
Length      1256     573        24         233     166           4

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mu_database_index                   152 external procedure  is an external procedure.  
init_index_table                        internal procedure  shares stack frame of external procedure mu_database_index.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 dbcb_ptr_table_ptr          mu_database_index
000012 index_table_ready           mu_database_index

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mu_database_index        000100 caller_name                 mu_database_index
                         000105 code                        mu_database_index
                         000106 found                       mu_database_index
                         000107 i                           mu_database_index
                         000110 info_ptr                    mu_database_index
                         000112 num_dbcb                    mu_database_index
                         000113 return_value                mu_database_index
                         000114 temp_seg_ptr                mu_database_index

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   return_mac          signal_op           ext_entry           op_alloc_           op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_temp_segment_             sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
mrds_data_$max_dbs            sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    223 000052       234 000055       237 000057        18 000062        18 000076        18 000100        18 000102
     99 000111       101 000136       109 000142       110 000144       111 000145       113 000147       117 000152
    118 000163       119 000165       120 000172       121 000174       123 000175       125 000202       127 000204
    129 000205       131 000214       133 000241       144 000245       147 000257       148 000263       151 000267
    153 000276       155 000323       166 000327       168 000341       170 000345       172 000354       174 000400
    182 000404       183 000405       184 000415       186 000425       188 000427       190 000441       199 000442
    200 000463       205 000533       207 000537       209 000547       211 000557       213 000565       215 000567
    219 000572


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
