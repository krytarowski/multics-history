	COMPILATION LISTING OF SEGMENT im_get_opening_info
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 04/02/87  1309.3 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION:
        8*
        9*         This  subroutine returns a pointer to the im_opening_info structure,
       10*     given a file  opening_id  and  a  collection  id.    If  no  opening_info
       11*     structure  has been creted for this collection in this process, then this
       12*     module  will  create  it.    The   opening_info   is   managed   by   the
       13*     opening_manager_.
       14**/
       15 
       16 /* HISTORY:
       17*
       18*Written by Lindsey L. Spratt, 10/28/82.
       19*Modified:
       20*12/08/82 by Lindsey Spratt:  Fixed static_opening_table_ptr to be declared
       21*	  with the internal static  attributes.  Changed to use
       22*	  dm_data_$area_ptr to set the work_area_ptr.  Fixed to only
       23*	  "put_opening" when there was no pre-existing allocation of the
       24*	  index_opening_info structure.
       25*12/10/82 by Lindsey Spratt:  Protect frees of old index_header and field_table
       26*	  when the pointers are null.
       27*03/21/83 by Lindsey Spratt:  Changed to not use dm_data_ $area_ptr or
       28*	  $current_txn_id, but get_dm_free_area_ and
       29*	  transaction_manager_$get_current_current_txn_id instead.
       30*	  Also, made the work_area_ptr internal static.
       31*03/23/83 by Lindsey Spratt:  Changed to use version 2 of the field_table.
       32*05/04/84 by Matthew Pierret:  Changed to use FIELD_TABLE_VERSION_3.  Added
       33*            ERROR_RETURN subroutine for returning with non-zero p_code.
       34*            Changed to use local copies of the file_opening_id and the
       35*            collection_id and the code.
       36*06/07/84 by Matthew Pierret:  Re-named cm_get_element to cm_$get.
       37*10/27/84 by Lindsey L. Spratt:  Changed to handl version 2 index_opening_info,
       38*            and version 4 index_header.  Also handles version 3 index_headers.
       39*03/07/85 by R. Michael Tague:  Changed opening info version to version 3 and
       40*	  changed to set index_opening_info.flags.key_count_postcommt_written
       41*	  to zero for new transactons and rollbacks.  Removed index_header
       42*	  version conversion code.
       43**/
       44 
       45 /* format: style2,ind3 */
       46 
       47 im_get_opening_info:
       48    proc (p_file_opening_id, p_collection_id, p_index_opening_info_ptr, p_code);
       49 
       50 
       51 /* START OF DECLARATIONS */
       52 /* Parameter */
       53 
       54       dcl	    p_file_opening_id      bit (36) aligned parameter;
       55       dcl	    p_collection_id	       bit (36) aligned parameter;
       56       dcl	    p_index_opening_info_ptr
       57 			       ptr parameter;
       58       dcl	    p_code	       fixed bin (35) parameter;
       59 
       60 /* Automatic */
       61 
       62       dcl	    code		       fixed bin (35);
       63       dcl	    new_buffer_was_allocated
       64 			       bit (1) aligned init ("0"b);
       65       dcl	    (collection_id, file_opening_id, current_txn_id)
       66 			       bit (36) aligned;
       67       dcl	    current_rollback_count fixed bin;
       68 
       69 /* Based */
       70 
       71       dcl	    work_area	       area based (work_area_ptr);
       72 
       73 /* Builtin */
       74 
       75       dcl	    (addr, bin, null, unspec)
       76 			       builtin;
       77 
       78 /* Constant */
       79 
       80       dcl	    myname	       init ("im_get_opening_info") char (32) varying internal static options (constant);
       81 
       82       dcl	    NUMBER_OF_BUCKETS      init (101) fixed bin (17) internal static options (constant);
       83       dcl	    HEADER_COLLECTION_ID   bit (36) aligned init ("000000000001"b3) internal static options (constant);
       84       dcl	    INDEX_HEADER_VERSION_3 init (3) fixed bin (35) internal static options (constant);
       85 
       86 /* Entry */
       87 
       88       dcl	    opening_manager_$init  entry (fixed bin, ptr, fixed bin (35));
       89       dcl	    opening_manager_$get_opening
       90 			       entry (ptr, bit (*), ptr, fixed bin (35));
       91       dcl	    opening_manager_$put_opening
       92 			       entry (ptr, bit (*), ptr, fixed bin (35));
       93 
       94       dcl	    get_dm_free_area_      entry () returns (ptr);
       95       dcl	    transaction_manager_$get_current_ids
       96 			       entry (bit (36) aligned, fixed bin, fixed bin, fixed bin (35));
       97 
       98       dcl	    sub_err_	       entry () options (variable);
       99 
      100 /* External */
      101 
      102       dcl	    error_table_$unimplemented_version
      103 			       fixed bin (35) ext;
      104 
      105 /* Static */
      106 
      107       dcl	    static_opening_table_ptr
      108 			       ptr init (null) static internal;
      109       dcl	    work_area_ptr	       ptr init (null) static internal;
      110 
      111 /* END OF DECLARATIONS */
      112 
      113       p_code = 0;
      114       p_index_opening_info_ptr = null;
      115       file_opening_id = p_file_opening_id;
      116       collection_id = p_collection_id;
      117       index_header_ptr, field_table_ptr, index_opening_info_ptr = null;
      118 
      119       call transaction_manager_$get_current_ids (current_txn_id, (0), current_rollback_count, (0));
      120 
      121       code = 0;
      122 
      123       if static_opening_table_ptr = null
      124       then
      125          do;
      126 	  call opening_manager_$init (NUMBER_OF_BUCKETS, static_opening_table_ptr, code);
      127 	  if code ^= 0
      128 	  then call ERROR_RETURN (code);
      129          end;
      130       else
      131          do;
      132 	  call opening_manager_$get_opening (static_opening_table_ptr, (file_opening_id || collection_id),
      133 	       p_index_opening_info_ptr, code);
      134 	  if code = 0
      135 	  then if p_index_opening_info_ptr -> index_opening_info.current_txn_id = bin (current_txn_id, 35, 0)
      136 		  & p_index_opening_info_ptr -> index_opening_info.current_rollback_count = current_rollback_count
      137 	       then call RETURN ();			/* ** Got the opening info. ** */
      138 	       else index_opening_info_ptr = p_index_opening_info_ptr;
      139          end;
      140 
      141       if work_area_ptr = null
      142       then work_area_ptr = get_dm_free_area_ ();
      143 
      144       if index_opening_info_ptr ^= null
      145       then
      146          do;
      147 	  call CHECK_VERSION (index_opening_info.version, INDEX_OPENING_INFO_VERSION_3, "index_opening_info");
      148 	  if index_opening_info.index_header_ptr ^= null
      149 	  then
      150 	     do;
      151 	        call CHECK_VERSION (index_opening_info.index_header_ptr -> index_header.version, INDEX_HEADER_VERSION_4,
      152 		   "index_header");
      153 	        free index_opening_info.index_header_ptr -> index_header in (work_area);
      154 	     end;
      155 	  if index_opening_info.key_count_array_ptr ^= null
      156 	  then
      157 	     do;
      158 	        call CHECK_VERSION (index_opening_info.key_count_array_ptr -> key_count_array.version,
      159 		   KEY_COUNT_ARRAY_VERSION_2, "key_count_array");
      160 	        free index_opening_info.key_count_array_ptr -> key_count_array in (work_area);
      161 	     end;
      162 	  if index_opening_info.field_table_ptr ^= null
      163 	  then
      164 	     do;
      165 	        call CHECK_VERSION (index_opening_info.field_table_ptr -> field_table.version, FIELD_TABLE_VERSION_3,
      166 		   "field_table");
      167 	        free index_opening_info.field_table_ptr -> field_table in (work_area);
      168 	     end;
      169 	  if index_opening_info.key_count_increments_ptr ^= null
      170 	  then call CHECK_VERSION (index_opening_info.key_count_increments_ptr -> key_count_array.version,
      171 		  KEY_COUNT_ARRAY_VERSION_2, "key_count_increments_array");
      172 						/* Note: Do not free the increment array */
      173          end;
      174       else
      175          do;
      176 	  alloc index_opening_info in (work_area);
      177 	  index_opening_info.version = INDEX_OPENING_INFO_VERSION_3;
      178 	  index_opening_info.collection_id = collection_id;
      179 	  index_opening_info.file_opening_id = file_opening_id;
      180 	  index_opening_info.key_count_increments_ptr = null;
      181          end;
      182 
      183       call GET_INDEX_HEADER ();
      184       call collection_manager_$get (file_opening_id, HEADER_COLLECTION_ID, unspec (index_header.field_table_element_id),
      185 	 0, null, (0), work_area_ptr, new_buffer_was_allocated, field_table_ptr, 0, code);
      186       if code ^= 0
      187       then call ERROR_RETURN (code);
      188 
      189       index_opening_info.index_header_ptr = index_header_ptr;
      190       index_opening_info.field_table_ptr = field_table_ptr;
      191       index_opening_info.key_count_array_ptr = key_count_array_ptr;
      192       index_opening_info.flags.key_count_postcommit_written = "0"b;
      193       index_opening_info.current_txn_id = bin (current_txn_id, 35, 0);
      194       index_opening_info.current_rollback_count = current_rollback_count;
      195 
      196       if p_index_opening_info_ptr = null
      197       then
      198          do;
      199 	  call opening_manager_$put_opening (static_opening_table_ptr, (file_opening_id || collection_id),
      200 	       index_opening_info_ptr, code);
      201 	  if code ^= 0
      202 	  then call ERROR_RETURN (code);
      203 
      204 	  p_index_opening_info_ptr = index_opening_info_ptr;
      205          end;
      206 
      207       call RETURN ();
      208 MAIN_RETURN:
      209       return;
      210 
      211 RETURN:
      212    proc ();
      213       p_code = 0;
      214       call FINISH ();
      215       goto MAIN_RETURN;
      216    end RETURN;
      217 
      218 
      219 ERROR_RETURN:
      220    proc (er_p_code);
      221 
      222       dcl	    er_p_code	       fixed bin (35);
      223 
      224       p_code = er_p_code;
      225       call FINISH;
      226       go to MAIN_RETURN;
      227 
      228    end ERROR_RETURN;
      229 
      230 
      231 
      232 FINISH:
      233    proc;
      234       if (p_index_opening_info_ptr ^= index_opening_info_ptr | p_index_opening_info_ptr = null) & work_area_ptr ^= null
      235       then
      236          do;
      237 	  if index_opening_info_ptr ^= null
      238 	  then free index_opening_info in (work_area);
      239 	  if index_header_ptr ^= null
      240 	  then free index_header in (work_area);
      241 	  if key_count_array_ptr ^= null
      242 	  then free key_count_array in (work_area);
      243 	  if field_table_ptr ^= null
      244 	  then free field_table in (work_area);
      245          end;
      246    end FINISH;
      247 
      248 CHECK_VERSION:
      249    proc (p_received_version, p_expected_version, p_structure_name);
      250       dcl	    (p_expected_version, p_received_version)
      251 			       char (8) aligned parameter;
      252       dcl	    p_structure_name       char (*) parameter;
      253 
      254       if p_expected_version ^= p_received_version
      255       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      256 	      "^/Expected version ^a of the ^a structure.  
      257 Received version ^a, instead.", p_expected_version, p_structure_name, p_received_version);
      258    end CHECK_VERSION;
      259 
      260 GET_INDEX_HEADER:
      261    proc ();
      262       dcl	    gih_code	       fixed bin (35);
      263       call collection_manager_$get_header (file_opening_id, collection_id, null, (0), work_area_ptr,
      264 	 new_buffer_was_allocated, index_header_ptr, (0), code);
      265       if code ^= 0
      266       then call ERROR_RETURN (code);
      267 
      268       call CHECK_VERSION (index_header.version, INDEX_HEADER_VERSION_4, "index_header");
      269       call collection_manager_$get (file_opening_id, HEADER_COLLECTION_ID,
      270 	 unspec (index_header.key_count_array_element_id), 0, null, (0), work_area_ptr, new_buffer_was_allocated,
      271 	 key_count_array_ptr, 0, gih_code);
      272       if gih_code ^= 0
      273       then call ERROR_RETURN (gih_code);
      274    end GET_INDEX_HEADER;
      275 
  1     1 /* BEGIN INCLUDE FILE - dm_im_opening_info.incl.pl1 */
  1     2 
  1     3 /* DESRIPTION:
  1     4*
  1     5*          The index_opening_info is per-process information, stored in a
  1     6*     hash_table managed by the opening_manager_, which allows the
  1     7*     index_manager_ to quickly reference certain unchanging pieces of
  1     8*     information rapidly.
  1     9**/
  1    10 
  1    11 /* HISTORY:
  1    12*
  1    13*Written by Lindsey Spratt, 10/28/82.
  1    14*Modified:
  1    15*10/26/84 by Lindsey L. Spratt:  Changed version to char(8).  Added a
  1    16*            description.  Added the current_rollback_count.  Added the
  1    17*	  key_count_array_ptr.
  1    18*03/07/85 by R. Michael Tague:  Added key_count_increments_ptr and 
  1    19*	  key_counts_postcommit_written.  Changed to version 3.
  1    20*03/25/85 by R. Michael Tague:  Added key_count_unprotected_file.  This
  1    21*	  flag is used by im_update_opening_info to help it maintain the
  1    22*	  key count array info.
  1    23**/
  1    24 
  1    25 /* format: style2,ind3 */
  1    26      dcl	   1 index_opening_info   based (index_opening_info_ptr) aligned,
  1    27 	     2 version	      char (8) aligned,
  1    28 	     2 file_opening_id    bit (36) aligned,
  1    29 	     2 collection_id      bit (36) aligned,
  1    30 	     2 index_header_ptr   ptr init (null),
  1    31 	     2 field_table_ptr    ptr init (null),
  1    32 	     2 key_count_array_ptr
  1    33 			      ptr init (null),
  1    34 	     2 key_count_increments_ptr
  1    35 			      ptr init (null),
  1    36 	     2 flags,
  1    37 	       3 key_count_postcommit_written
  1    38 			      bit (1) unal init ("0"b),
  1    39 	       3 key_count_unprotected_file
  1    40 			      bit (1) unal init ("0"b),
  1    41 	       3 pad	      bit (34) unal init (""b),
  1    42 	     2 current_txn_id     fixed bin (35) init (0),
  1    43 	     2 current_rollback_count
  1    44 			      fixed bin (35) init (0);
  1    45 
  1    46      dcl	   index_opening_info_ptr ptr init (null);
  1    47      dcl	   INDEX_OPENING_INFO_VERSION_3
  1    48 			      init ("IdxOpn 3") char (8) aligned internal static options (constant);
  1    49 
  1    50 /* END INCLUDE FILE - dm_im_opening_info.incl.pl1 */
      276 
      277 
  2     1 /* BEGIN INCLUDE FILE - dm_im_header.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*          The index_header structure is stored in the header element of an
  2     6*     index collection and describes basic information about the index.
  2     7**/
  2     8 
  2     9 /* HISTORY:
  2    10*
  2    11*Written by Lindsey Spratt, 04/02/82.
  2    12*Modified:
  2    13*10/28/82 by Lindsey Spratt:  Changed to version 3.  Added the key_count_array.
  2    14*	  count(0) is the number of keys in the index.  count(N) is the
  2    15*	  number of keys in the index which have at least fields 1 through N
  2    16*	  having the same value as another key in the index, i.e. count(N)
  2    17*	  is the number of partial duplicates with number of partial
  2    18*	  duplication fields equal to N.
  2    19*10/24/84 by Lindsey L. Spratt:  Added a description. Converted to version 4.
  2    20*	  Replaced the key_count_array with a key_count_array_element_id.
  2    21*	  Changed the version field to char(8).  Aligned the structure.
  2    22**/
  2    23 
  2    24 /* format: style2,ind3 */
  2    25      dcl	   1 index_header	      aligned based (index_header_ptr),
  2    26 	     2 version	      char (8) aligned,
  2    27 	     2 field_table_element_id
  2    28 			      like element_id,
  2    29 	     2 root_id	      fixed bin (24) unsigned unaligned,
  2    30 	     2 pad1	      bit (12) unaligned,
  2    31 	     2 number_of_duplication_fields
  2    32 			      fixed bin (17) unal,
  2    33 	     2 pad2	      bit (18) unal,
  2    34 	     2 key_count_array_element_id
  2    35 			      like element_id;
  2    36 
  2    37      dcl	   index_header_ptr	      ptr;
  2    38      dcl	   INDEX_HEADER_VERSION_4 init ("IdxHdr 4") char (8) aligned internal static options (constant);
  2    39 
  2    40 /* END INCLUDE FILE - dm_im_header.incl.pl1 */
      278 
      279 
  3     1 /* ********** BEGIN INCLUDE FILE dm_field_table.incl.pl1 ********** */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*
  3     5*          The field_table describes the layout of a set of fields in a
  3     6*     formatted data string.  Such a string is the stored representation of a
  3     7*     record or a key.  Fields are placed side-by-side in the string in the
  3     8*     order they appear in the field_table.field array.  The string is divided
  3     9*     into the fixed portion and the varying portion.  In the fixed portion
  3    10*     appear fixed-length fields and fixed-size length-fields for
  3    11*     varying-length fields.  In the varying portion appear varying length
  3    12*     fields.  The length-field for a varying-length field contains the length
  3    13*     of the field values either in bits or in characters, depending on the
  3    14*     data type of the field.
  3    15**/
  3    16 
  3    17 /* HISTORY:
  3    18*Written by Matthew Pierret, 04/01/82.
  3    19*Modified:
  3    20*04/20/82 by Matthew Pierret: Added length_is_in_characters, meaning, if on,
  3    21*	  that if the field is varying, its length is expressed in
  3    22*	  bytes/characters.
  3    23*03/22/83 by Lindsey Spratt:  Changed lofvf to have a precision of 35 instead
  3    24*	  of 17, changed version to 2, changed version field to char(8) from
  3    25*	  fixed bin (17).
  3    26*05/01/84 by Matthew Pierret:  Changed version to 3. Removed field.name and
  3    27*            put field names in one string (field_names) at the end of the 
  3    28*            structure. Added field.location_of_name and field.length_of_name
  3    29*            for locating the field name in field_names. Aligned all "fixed bin"
  3    30*            structure elements.  Changed maximum_field_name_length to 
  3    31*            length_of_field_names.
  3    32**/
  3    33 
  3    34 /* format: style2 */
  3    35 
  3    36      dcl	   1 field_table	      aligned based (field_table_ptr),
  3    37 	     2 version	      char (8) aligned init (FIELD_TABLE_VERSION_3),
  3    38 	     2 number_of_fields   fixed bin (17),
  3    39 	     2 length_of_field_names
  3    40 			      fixed bin (17),	/* length of field_names in characters */
  3    41 	     2 location_of_first_varying_field
  3    42 			      fixed bin (35),	/* location of first bit in the varying portion of the formatted string */
  3    43 	     2 field	      (ft_number_of_fields refer (field_table.number_of_fields)),
  3    44 	       3 flags	      aligned,
  3    45 	         4 descriptor_is_varying
  3    46 			      bit (1) unal,		/* if on, the descriptor is not limited to the standard 36 bits */
  3    47 						/* and is stored in a stand-alone fashion, with field.descriptor */
  3    48 						/* containing the id of the element in which the descriptor is stored. */
  3    49 	         4 length_is_in_characters
  3    50 			      bit (1) unal,		/* if field is varying, the length field describes its length */
  3    51 						/* in characters instead of in bits */
  3    52 	         4 must_be_zero   bit (34) unal,
  3    53 	       3 descriptor	      bit (36) aligned,
  3    54 	       3 location	      fixed bin (35),	/* location of first bit of field in formatted string */
  3    55 	       3 length_in_bits   fixed bin (35),	/* length of field in bits */
  3    56 	     3 location_of_name   fixed bin (17),	/* location of first character of field name in field_names */
  3    57 	     3 length_of_name     fixed bin (17),	/* length of name in characters */
  3    58 	     2 varying_field_map  (ft_number_of_fields refer (field_table.number_of_fields)),
  3    59 	       3 field_id	      fixed bin (17),	/* field_id of Nth varying field */
  3    60 	       3 varying_field_index
  3    61 			      fixed bin (17),	/* ordinality among varying fields of field N */
  3    62 	     2 field_names	      char (ft_length_of_field_names refer (field_table.length_of_field_names));
  3    63 
  3    64 
  3    65      dcl	   field_table_ptr	      ptr;
  3    66      dcl	   ft_length_of_field_names
  3    67 			      fixed bin;
  3    68      dcl	   ft_number_of_fields    fixed bin;
  3    69      dcl	   FIELD_TABLE_VERSION_3  char (8) aligned init ("FldTbl 3") internal static options (constant);
  3    70 
  3    71 dcl field_name char (field_name_length) based (field_name_ptr);
  3    72 
  3    73 dcl field_name_length fixed bin;
  3    74 dcl field_name_ptr ptr;
  3    75 
  3    76 /* END INCLUDE FILE dm_field_table.incl.pl1 */
      280 
      281 
  4     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*        Contains the declaration of an element identifier.  Element
  4     6*   identifiers consist of two parts, the id (number) of the control interval
  4     7*   in which the element resides, and the index into the slot table of
  4     8*   the element in the control interval.  The declaration of the element_id 
  4     9*   structure reflects this division of the element identifier.  The structure 
  4    10*   is based on the automatic bit string element_id_string because programs
  4    11*   generally pass bit strings (element_id_string) to each other, then 
  4    12*   interpret the bit string by overlaying the element_id structure ony if
  4    13*   it is necessary to access the parts of the id.  Basing element_id on
  4    14*   addr(element_id_string) instead of on a pointer removes the necessity
  4    15*   for always setting that pointer explicitly and guarantees that changes
  4    16*   made to the string or structure do not get inconsistent.
  4    17*
  4    18*   Changes made to element_id must also be made to datum_id, declared in 
  4    19*   dm_cm_datum.incl.pl1.
  4    20**/
  4    21 
  4    22 /* HISTORY:
  4    23*Written by Matthew Pierret, 04/01/82.
  4    24*Modified:
  4    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  4    26**/
  4    27 
  4    28 /* format: style2,ind3,ll79 */
  4    29 
  4    30      dcl	   element_id_string      bit (36) aligned;
  4    31 
  4    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  4    33 	     2 control_interval_id
  4    34 			      fixed bin (24) unal unsigned,
  4    35 	     2 index	      fixed bin (12) unal unsigned;
  4    36 
  4    37 
  4    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      282 
      283 
  5     1 /* BEGIN INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*     This include file contains declarations of all collection_manager_ 
  5     5*     entrypoints.
  5     6**/
  5     7 
  5     8 /* HISTORY:
  5     9*Written by Matthew Pierret 
  5    10*Modified:
  5    11*04/14/82 by Lindsey Spratt: Changed the control_interval_id parameter of the
  5    12*	  allocate_control_interval operation to be unaligned, as well as
  5    13*	  unsigned.
  5    14*06/17/82 by Matthew Pierret: Added the put_element_portion opertion and
  5    15*            removed the beginning_location parameter from the put_element
  5    16*            operation. Added the create_page_file_operation.
  5    17*08/09/82 by Matthew Pierret: Changed "fixed bin (17)"s to "bit (36) aligned"s
  5    18*            wherever collection_id was required.
  5    19*            Also changed the control_interval_id parameter of the 
  5    20*            allocate_control_interval operation back to be aligned. So there.
  5    21*10/20/82 by Matthew Pierret: Changed $create_page_file to $create_file,
  5    22*            added the argument file_create_info_ptr to $create_file.
  5    23*12/13/82 by Lindsey Spratt:  Corrected $free_control_interval to
  5    24*	  include the zero_on_free bit.
  5    25*12/17/82 by Matthew Pierret: Added cm_$get_id.
  5    26*01/07/83 by Matthew Pierret: Added cm_$put_element_buffered, 
  5    27*            cm_$allocate_element_buffered, cm_$free_element_buffered.
  5    28*04/27/83 by Matthew Pierret: Added cm_$put_unprotected_element,
  5    29*            cm_$put_unprotected_header.
  5    30*11/07/83 by Matthew Pierret: Added $get_element_portion_buffered,
  5    31*             $simple_get_buffered_element.
  5    32*02/08/84 by Matthew Pierret:  Changed $get_id to have only one bit(1)aligned
  5    33*            parameter for specifying absolute/relative nature of search.
  5    34*03/16/84 by Matthew Pierret:  Added cm_$get_control_interval_ptr,
  5    35*            $get_element_ptr, $get_element_portion_ptr, $simple_get_element_ptr
  5    36*04/03/84 by Matthew Pierret:  Added cm_$compact_control_interval.
  5    37*06/06/84 by Matthew Pierret:  Re-named free_element* to delete and
  5    38*            delete_from_ci_buffer.
  5    39*            Re-named *_buffered_ci to =_ci_buffer.
  5    40*            get entries.
  5    41*            modify entries.
  5    42*            Changed calling sequence of modify entries to have a ptr/length
  5    43*            instead of length/ptr parameter pair.
  5    44*03/11/85 by R. Michael Tague:  Added $postcommit_increments.
  5    45**/
  5    46 
  5    47 /* This include file contains declarations of collection_manager_ entrypoints */
  5    48 
  5    49 /* format: style2,ind3 */
  5    50      dcl	   collection_manager_$allocate_control_interval
  5    51 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  5    52      dcl	   collection_manager_$compact_control_interval
  5    53 			      entry (bit (36) aligned, fixed bin (24) uns, fixed bin (35));
  5    54      dcl	   collection_manager_$create_collection
  5    55 			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  5    56      dcl	   collection_manager_$create_file
  5    57 			      entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
  5    58      dcl	   collection_manager_$destroy_collection
  5    59 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  5    60      dcl	   collection_manager_$free_control_interval
  5    61 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, bit (1) aligned,
  5    62 			      fixed bin (35));
  5    63 
  5    64      dcl	   collection_manager_$delete
  5    65 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  5    66 			      fixed bin (35));
  5    67      dcl	   collection_manager_$delete_from_ci_buffer
  5    68 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  5    69 			      fixed bin (35));
  5    70 
  5    71      dcl	   collection_manager_$get
  5    72 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  5    73 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  5    74      dcl	   collection_manager_$get_control_interval_ptr
  5    75 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, ptr,
  5    76 			      fixed bin (35));
  5    77      dcl	   collection_manager_$get_from_ci_buffer
  5    78 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  5    79 			      ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  5    80      dcl	   collection_manager_$get_by_ci_ptr
  5    81 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  5    82 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), ptr, fixed bin (35));
  5    83      dcl	   collection_manager_$get_header
  5    84 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (17), ptr, bit (1) aligned,
  5    85 			      ptr, fixed bin (35), fixed bin (35));
  5    86      dcl	   collection_manager_$get_id
  5    87 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17),
  5    88 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  5    89      dcl	   collection_manager_$get_portion
  5    90 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  5    91 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  5    92 			      fixed bin (35), fixed bin (35));
  5    93      dcl	   collection_manager_$get_portion_from_ci_buffer
  5    94 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  5    95 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  5    96 			      fixed bin (35));
  5    97      dcl	   collection_manager_$get_portion_by_ci_ptr
  5    98 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  5    99 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  5   100 			      fixed bin (35));
  5   101      dcl	   collection_manager_$modify
  5   102 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   103 			      fixed bin (35), fixed bin (35));
  5   104      dcl	   collection_manager_$modify_unprotected
  5   105 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   106 			      fixed bin (35), fixed bin (35));
  5   107      dcl	   collection_manager_$modify_in_ci_buffer
  5   108 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   109 			      fixed bin (35), fixed bin (35));
  5   110      dcl	   collection_manager_$modify_portion
  5   111 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35), ptr,
  5   112 			      fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  5   113      dcl	   collection_manager_$postcommit_increments
  5   114 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  5   115      dcl	   collection_manager_$put
  5   116 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   117 			      fixed bin (35), fixed bin (35));
  5   118      dcl	   collection_manager_$put_in_ci_buffer
  5   119 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   120 			      fixed bin (35), fixed bin (35));
  5   121      dcl	   collection_manager_$put_header
  5   122 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  5   123      dcl	   collection_manager_$put_unprotected_header
  5   124 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  5   125 
  5   126      dcl	   collection_manager_$replace_ci_buffer
  5   127 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  5   128 			      fixed bin (35));
  5   129      dcl	   collection_manager_$setup_ci_buffer
  5   130 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  5   131 			      fixed bin (35));
  5   132      dcl	   collection_manager_$simple_get_by_ci_ptr
  5   133 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  5   134 			      fixed bin (35));
  5   135      dcl	   collection_manager_$simple_get_from_ci_buffer
  5   136 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  5   137 			      fixed bin (35));
  5   138 
  5   139 /* END INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
      284 
      285 
  6     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  6     2 /* format: style3 */
  6     3 
  6     4 /* These constants are to be used for the flags argument of sub_err_ */
  6     5 /* They are just "string (condition_info_header.action_flags)" */
  6     6 
  6     7 declare	(
  6     8 	ACTION_CAN_RESTART	init (""b),
  6     9 	ACTION_CANT_RESTART init ("1"b),
  6    10 	ACTION_DEFAULT_RESTART
  6    11 			init ("01"b),
  6    12 	ACTION_QUIET_RESTART
  6    13 			init ("001"b),
  6    14 	ACTION_SUPPORT_SIGNAL
  6    15 			init ("0001"b)
  6    16 	)		bit (36) aligned internal static options (constant);
  6    17 
  6    18 /* End include file */
      286 
      287 
  7     1 /* BEGIN INCLUDE FILE - dm_key_count_array.incl.pl1 */
  7     2 
  7     3 
  7     4 
  7     5 /****^  HISTORY COMMENTS:
  7     6*  1) change(87-01-15,Hergert), approve(87-04-01,MCR7632),
  7     7*     audit(87-02-09,Dupuis), install(87-04-02,MR12.1-1020):
  7     8*     Added the KEY_COUNT_OFFSET_IN_CHARACTERS. This is the offset from the
  7     9*     beginning of the structure to the element key_count_array.count in
  7    10*     characters. Using this it is possible to calculate the key_count_array_ptr
  7    11*     given the "addr (key_count_array.count (0))".
  7    12*                                                   END HISTORY COMMENTS */
  7    13 
  7    14 
  7    15 /* DESCRIPTION:
  7    16*
  7    17*          The key_count_array holds counts of the number of unique key values
  7    18*     in an index.  These values are used by the search optimization done by
  7    19*     MRDS.  count(0) is the number of keys in the index.  count(N) is the
  7    20*     number of keys in the index which have at least fields 1 through N
  7    21*     having the same value as another key in the index, i.e. count(N)
  7    22*     is the number of partial duplicates with number of partial
  7    23*     duplication fields equal to N.
  7    24*
  7    25**/
  7    26 
  7    27 /* HISTORY:
  7    28*
  7    29*Written by Lindsey Spratt, 11/09/82.
  7    30*Modified:
  7    31*10/27/84 by Lindsey L. Spratt:  Changed the version to char(8) aligned.
  7    32*	  Added a description, fixed the history section.
  7    33**/
  7    34 
  7    35 /* format: style2,ind3 */
  7    36      dcl	   1 key_count_array      aligned based (key_count_array_ptr),
  7    37 	     2 version	      char (8) aligned,
  7    38 	     2 number_of_counts   fixed bin (17) unal,
  7    39 	     2 pad	      bit (18) unal,
  7    40 	     2 count	      (0:kca_number_of_counts refer (key_count_array.number_of_counts)) fixed
  7    41 			      bin (35) aligned;
  7    42 
  7    43      dcl	   KEY_COUNT_ARRAY_VERSION_2
  7    44 			      init ("KeyCnt 2") char (8) aligned internal static options (constant);
  7    45      dcl     KEY_COUNT_OFFSET_IN_CHARACTERS
  7    46 			      init (12) fixed bin internal static options (constant);
  7    47 
  7    48      dcl	   key_count_array_ptr    ptr init (null);
  7    49      dcl	   kca_number_of_counts   fixed bin (17) init (0);
  7    50 
  7    51 
  7    52 /* END INCLUDE FILE - dm_key_count_array.incl.pl1 */
      288 
      289    end im_get_opening_info;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/02/87  1304.9  im_get_opening_info.pl1           >spec>install>MR12.1-1020>im_get_opening_info.pl1
276          1    04/05/85  0924.4  dm_im_opening_info.incl.pl1       >ldd>include>dm_im_opening_info.incl.pl1
278          2    01/07/85  0858.9  dm_im_header.incl.pl1             >ldd>include>dm_im_header.incl.pl1
280          3    01/07/85  0858.8  dm_field_table.incl.pl1           >ldd>include>dm_field_table.incl.pl1
282          4    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
284          5    04/05/85  0924.4  dm_collmgr_entry_dcls.incl.pl1    >ldd>include>dm_collmgr_entry_dcls.incl.pl1
286          6    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
288          7    04/02/87  1300.6  dm_key_count_array.incl.pl1       >spec>install>MR12.1-1020>dm_key_count_array.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000002 constant        bit(36)                  initial dcl 6-7 set ref 254*
FIELD_TABLE_VERSION_3           000004 constant        char(8)                  initial dcl 3-69 set ref 165*
HEADER_COLLECTION_ID            000041 constant        bit(36)                  initial dcl 83 set ref 184* 269*
INDEX_HEADER_VERSION_4          000006 constant        char(8)                  initial dcl 2-38 set ref 151* 268*
INDEX_OPENING_INFO_VERSION_3    000010 constant        char(8)                  initial dcl 1-47 set ref 147* 177
KEY_COUNT_ARRAY_VERSION_2       000000 constant        char(8)                  initial dcl 7-43 set ref 158* 169*
NUMBER_OF_BUCKETS               000012 constant        fixed bin(17,0)          initial dcl 82 set ref 126*
bin                                                    builtin function         dcl 75 ref 134 193
code                            000100 automatic       fixed bin(35,0)          dcl 62 set ref 121* 126* 127 127* 132* 134 184* 186
                                                                                  186* 199* 201 201* 263* 265 265*
collection_id             3            based           bit(36)                  level 2 in structure "index_opening_info" dcl 1-26
                                                                                  in procedure "im_get_opening_info" set ref 178*
collection_id                   000102 automatic       bit(36)                  dcl 65 in procedure "im_get_opening_info" set ref
                                                                                  116* 132 178 199 263*
collection_manager_$get         000032 constant        entry                    external dcl 5-71 ref 184 269
collection_manager_$get_header  000034 constant        entry                    external dcl 5-83 ref 263
current_rollback_count          000105 automatic       fixed bin(17,0)          dcl 67 in procedure "im_get_opening_info" set ref
                                                                                  119* 134 194
current_rollback_count
                         16            based           fixed bin(35,0)          initial level 2 in structure "index_opening_info"
                                                                                  dcl 1-26 in procedure "im_get_opening_info" set
                                                                                  ref 134 176* 194*
current_txn_id           15            based           fixed bin(35,0)          initial level 2 in structure "index_opening_info"
                                                                                  dcl 1-26 in procedure "im_get_opening_info" set
                                                                                  ref 134 176* 193*
current_txn_id                  000104 automatic       bit(36)                  dcl 65 in procedure "im_get_opening_info" set ref
                                                                                  119* 134 193
element_id                             based           structure                level 1 dcl 4-32
er_p_code                              parameter       fixed bin(35,0)          dcl 222 ref 219 224
error_table_$unimplemented_version
                                000030 external static fixed bin(35,0)          dcl 102 set ref 254*
field_table                            based           structure                level 1 dcl 3-36 set ref 167 243
field_table_element_id
                          2            based           structure                level 2 dcl 2-25 ref 184 184
field_table_ptr                 000112 automatic       pointer                  dcl 3-65 in procedure "im_get_opening_info" set ref
                                                                                  117* 184* 190 243 243
field_table_ptr           6            based           pointer                  initial level 2 in structure "index_opening_info"
                                                                                  dcl 1-26 in procedure "im_get_opening_info" set
                                                                                  ref 162 165 167 176* 190*
file_opening_id           2            based           bit(36)                  level 2 in structure "index_opening_info" dcl 1-26
                                                                                  in procedure "im_get_opening_info" set ref 179*
file_opening_id                 000103 automatic       bit(36)                  dcl 65 in procedure "im_get_opening_info" set ref
                                                                                  115* 132 179 184* 199 263* 269*
flags                    14            based           structure                level 2 dcl 1-26
get_dm_free_area_               000022 constant        entry                    external dcl 94 ref 141
gih_code                        000156 automatic       fixed bin(35,0)          dcl 262 set ref 269* 272 272*
index_header                           based           structure                level 1 dcl 2-25 set ref 153 239
index_header_ptr          4            based           pointer                  initial level 2 in structure "index_opening_info"
                                                                                  dcl 1-26 in procedure "im_get_opening_info" set
                                                                                  ref 148 151 153 176* 189*
index_header_ptr                000110 automatic       pointer                  dcl 2-37 in procedure "im_get_opening_info" set ref
                                                                                  117* 184 184 189 239 239 263* 268 269 269
index_opening_info                     based           structure                level 1 dcl 1-26 set ref 176 237
index_opening_info_ptr          000106 automatic       pointer                  initial dcl 1-46 set ref 117* 138* 144 147 148 151
                                                                                  153 155 158 160 162 165 167 169 169 176* 177 178
                                                                                  179 180 189 190 191 192 193 194 199* 204 1-46* 234
                                                                                  237 237
kca_number_of_counts            000116 automatic       fixed bin(17,0)          initial dcl 7-49 set ref 7-49*
key_count_array                        based           structure                level 1 dcl 7-36 set ref 160 241
key_count_array_element_id
                          5            based           structure                level 2 dcl 2-25 ref 269 269
key_count_array_ptr             000114 automatic       pointer                  initial dcl 7-48 in procedure "im_get_opening_info"
                                                                                  set ref 191 7-48* 241 241 269*
key_count_array_ptr      10            based           pointer                  initial level 2 in structure "index_opening_info"
                                                                                  dcl 1-26 in procedure "im_get_opening_info" set
                                                                                  ref 155 158 160 176* 191*
key_count_increments_ptr
                         12            based           pointer                  initial level 2 dcl 1-26 set ref 169 169 176* 180*
key_count_postcommit_written
                         14            based           bit(1)                   initial level 3 packed unaligned dcl 1-26 set ref
                                                                                  176* 192*
key_count_unprotected_file
                         14(01)        based           bit(1)                   initial level 3 packed unaligned dcl 1-26 set ref
                                                                                  176*
length_of_field_names
                          3            based           fixed bin(17,0)          level 2 dcl 3-36 ref 167 243
myname                          000013 constant        varying char(32)         initial dcl 80 set ref 254*
new_buffer_was_allocated        000101 automatic       bit(1)                   initial dcl 63 set ref 63* 184* 263* 269*
null                                                   builtin function         dcl 75 ref 114 117 123 141 144 148 155 162 169 176
                                                                                  176 176 176 180 184 184 196 1-46 7-48 234 234 237
                                                                                  239 241 243 254 254 263 263 269 269
number_of_counts          2            based           fixed bin(17,0)          level 2 packed unaligned dcl 7-36 ref 160 241
number_of_fields          2            based           fixed bin(17,0)          level 2 dcl 3-36 ref 167 167 243 243
opening_manager_$get_opening    000016 constant        entry                    external dcl 89 ref 132
opening_manager_$init           000014 constant        entry                    external dcl 88 ref 126
opening_manager_$put_opening    000020 constant        entry                    external dcl 91 ref 199
p_code                                 parameter       fixed bin(35,0)          dcl 58 set ref 47 113* 213* 224*
p_collection_id                        parameter       bit(36)                  dcl 55 ref 47 116
p_expected_version                     parameter       char(8)                  dcl 250 set ref 248 254 254*
p_file_opening_id                      parameter       bit(36)                  dcl 54 ref 47 115
p_index_opening_info_ptr               parameter       pointer                  dcl 56 set ref 47 114* 132* 134 134 138 196 204* 234
                                                                                  234
p_received_version                     parameter       char(8)                  dcl 250 set ref 248 254 254*
p_structure_name                       parameter       char                     unaligned dcl 252 set ref 248 254*
pad                      14(02)        based           bit(34)                  initial level 3 packed unaligned dcl 1-26 set ref
                                                                                  176*
static_opening_table_ptr        000010 internal static pointer                  initial dcl 107 set ref 123 126* 132* 199*
sub_err_                        000026 constant        entry                    external dcl 98 ref 254
transaction_manager_$get_current_ids
                                000024 constant        entry                    external dcl 95 ref 119
unspec                                                 builtin function         dcl 75 ref 184 184 269 269
version                                based           char(8)                  initial level 2 in structure "field_table" dcl 3-36
                                                                                  in procedure "im_get_opening_info" set ref 165*
version                                based           char(8)                  level 2 in structure "index_header" dcl 2-25
                                                                                  in procedure "im_get_opening_info" set ref 151*
                                                                                  268*
version                                based           char(8)                  level 2 in structure "index_opening_info" dcl 1-26
                                                                                  in procedure "im_get_opening_info" set ref 147*
                                                                                  177*
version                                based           char(8)                  level 2 in structure "key_count_array" dcl 7-36
                                                                                  in procedure "im_get_opening_info" set ref 158*
                                                                                  169*
work_area                              based           area(1024)               dcl 71 ref 153 160 167 176 237 239 241 243
work_area_ptr                   000012 internal static pointer                  initial dcl 109 set ref 141 141* 153 160 167 176
                                                                                  184* 234 237 239 241 243 263* 269*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 6-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 6-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 6-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 6-7
INDEX_HEADER_VERSION_3                 internal static fixed bin(35,0)          initial dcl 84
KEY_COUNT_OFFSET_IN_CHARACTERS         internal static fixed bin(17,0)          initial dcl 7-45
addr                                                   builtin function         dcl 75
collection_manager_$allocate_control_interval
                                000000 constant        entry                    external dcl 5-50
collection_manager_$compact_control_interval
                                000000 constant        entry                    external dcl 5-52
collection_manager_$create_collection
                                000000 constant        entry                    external dcl 5-54
collection_manager_$create_file 000000 constant        entry                    external dcl 5-56
collection_manager_$delete      000000 constant        entry                    external dcl 5-64
collection_manager_$delete_from_ci_buffer
                                000000 constant        entry                    external dcl 5-67
collection_manager_$destroy_collection
                                000000 constant        entry                    external dcl 5-58
collection_manager_$free_control_interval
                                000000 constant        entry                    external dcl 5-60
collection_manager_$get_by_ci_ptr
                                000000 constant        entry                    external dcl 5-80
collection_manager_$get_control_interval_ptr
                                000000 constant        entry                    external dcl 5-74
collection_manager_$get_from_ci_buffer
                                000000 constant        entry                    external dcl 5-77
collection_manager_$get_id      000000 constant        entry                    external dcl 5-86
collection_manager_$get_portion 000000 constant        entry                    external dcl 5-89
collection_manager_$get_portion_by_ci_ptr
                                000000 constant        entry                    external dcl 5-97
collection_manager_$get_portion_from_ci_buffer
                                000000 constant        entry                    external dcl 5-93
collection_manager_$modify      000000 constant        entry                    external dcl 5-101
collection_manager_$modify_in_ci_buffer
                                000000 constant        entry                    external dcl 5-107
collection_manager_$modify_portion
                                000000 constant        entry                    external dcl 5-110
collection_manager_$modify_unprotected
                                000000 constant        entry                    external dcl 5-104
collection_manager_$postcommit_increments
                                000000 constant        entry                    external dcl 5-113
collection_manager_$put         000000 constant        entry                    external dcl 5-115
collection_manager_$put_header  000000 constant        entry                    external dcl 5-121
collection_manager_$put_in_ci_buffer
                                000000 constant        entry                    external dcl 5-118
collection_manager_$put_unprotected_header
                                000000 constant        entry                    external dcl 5-123
collection_manager_$replace_ci_buffer
                                000000 constant        entry                    external dcl 5-126
collection_manager_$setup_ci_buffer
                                000000 constant        entry                    external dcl 5-129
collection_manager_$simple_get_by_ci_ptr
                                000000 constant        entry                    external dcl 5-132
collection_manager_$simple_get_from_ci_buffer
                                000000 constant        entry                    external dcl 5-135
element_id_string                      automatic       bit(36)                  dcl 4-30
field_name                             based           char                     unaligned dcl 3-71
field_name_length                      automatic       fixed bin(17,0)          dcl 3-73
field_name_ptr                         automatic       pointer                  dcl 3-74
ft_length_of_field_names               automatic       fixed bin(17,0)          dcl 3-66
ft_number_of_fields                    automatic       fixed bin(17,0)          dcl 3-68

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   001013 constant        entry                    internal dcl 248 ref 147 151 158 165 169 268
ERROR_RETURN                    000713 constant        entry                    internal dcl 219 ref 127 186 201 265 272
FINISH                          000722 constant        entry                    internal dcl 232 ref 214 225
GET_INDEX_HEADER                001115 constant        entry                    internal dcl 260 ref 183
MAIN_RETURN                     000705 constant        label                    dcl 208 ref 215 226
RETURN                          000706 constant        entry                    internal dcl 211 ref 134 207
im_get_opening_info             000124 constant        entry                    external dcl 47

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1430        1466    1264        1440
Length      2024    1264        36         321     143           4

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
im_get_opening_info                 300 external procedure  is an external procedure.  
RETURN                                  internal procedure  shares stack frame of external procedure im_get_opening_info.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure im_get_opening_info.  
FINISH                                  internal procedure  shares stack frame of external procedure im_get_opening_info.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure im_get_opening_info.  
GET_INDEX_HEADER                        internal procedure  shares stack frame of external procedure im_get_opening_info.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 static_opening_table_ptr    im_get_opening_info
000012 work_area_ptr               im_get_opening_info

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
im_get_opening_info      000100 code                        im_get_opening_info
                         000101 new_buffer_was_allocated    im_get_opening_info
                         000102 collection_id               im_get_opening_info
                         000103 file_opening_id             im_get_opening_info
                         000104 current_txn_id              im_get_opening_info
                         000105 current_rollback_count      im_get_opening_info
                         000106 index_opening_info_ptr      im_get_opening_info
                         000110 index_header_ptr            im_get_opening_info
                         000112 field_table_ptr             im_get_opening_info
                         000114 key_count_array_ptr         im_get_opening_info
                         000116 kca_number_of_counts        im_get_opening_info
                         000156 gih_code                    GET_INDEX_HEADER

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry           op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
collection_manager_$get       collection_manager_$get_header                              get_dm_free_area_
opening_manager_$get_opening  opening_manager_$init         opening_manager_$put_opening  sub_err_
transaction_manager_$get_current_ids

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     47 000117        63 000131    1   46 000132    7   48 000134    7   49 000135       113 000136       114 000140
    115 000141       116 000143       117 000145       119 000151       121 000167       123 000170       126 000175
    127 000207       129 000213       132 000214       134 000243       138 000261       141 000262       144 000275
    147 000301       148 000326       151 000333       153 000357       155 000362       158 000367       160 000412
    162 000421       165 000426       167 000451       169 000471       173 000520       176 000521       177 000544
    178 000547       179 000551       183 000553       184 000554       186 000617       189 000623       190 000626
    191 000630       192 000632       193 000634       194 000637       196 000641       199 000646       201 000675
    204 000701       207 000704       208 000705       211 000706       213 000707       214 000711       215 000712
    219 000713       224 000715       225 000720       226 000721       232 000722       234 000723       237 000741
    239 000747       241 000755       243 000767       246 001012       248 001013       254 001024       258 001114
    260 001115       263 001116       265 001151       268 001155       269 001201       272 001244       274 001250


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
