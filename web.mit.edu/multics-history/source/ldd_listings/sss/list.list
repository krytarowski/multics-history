	COMPILATION LISTING OF SEGMENT list
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-17_1938.55_Mon_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1989                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
       17*     audit(86-09-04,DGHowe), install(86-11-20,MR12.0-1222):
       18*     Modified to extract the mode on a multisegment file from the mode on
       19*     component 0.
       20*  2) change(89-01-31,TLNguyen), approve(89-01-31,MCR8045),
       21*     audit(89-02-23,RBarstad), install(89-03-01,MR12.3-1018):
       22*     1. Remove trailing white spaces in the pathname that gets printed in the
       23*        error message "Directory empty.".
       24*     2. The returned error message now includes specified invalid control
       25*        argument that a user typed in on the command line.
       26*     3. For the case of no entries matching a starname, list prints out
       27*        "Use of star convention resulted in no match.  STARNAME."
       28*     4. Modify the existing internal procedure "check_for_msf" to return
       29*        correct information of a specified multisegment-file (MSF).
       30*                                                   END HISTORY COMMENTS */
       31 
       32 
       33 /* list (ls) ... Standard Service System directory-listing command */
       34 
       35 /* Completely rewritten by T. Casey, March 1975, replacing the 1969 version by R.C.Daley
       36*   Modified for NSS by T. Casey, January 1976. (Rev 33)
       37*   Modified by T. Casey April 1976 to fix bugs. (Rev 36)
       38*   Modified by T. Casey November 1976 to fix bugs and add ability to give pathnames without -pn. (Rev 37)
       39*   Modified by T. Casey August 1977 to fix bugs in msf access, listing the root, and allow 4 cols for records. (Rev 38)
       40*   Modified by C. Hornig June 1981 to pay attention to link pathname length.
       41*   Modified by M. Pandolf August 1984 to support DM files by special casing MSFs.
       42*   Modified by M. Pandolf September 1984 to support DM file control args.
       43*   Modified by JAFalksen 1984-09-18 to use date_time_$format("^<date> ^<time>",...
       44*   Modified by M. Pandolf October 1984 to let inner ring MSFs be...
       45*   Modified by M. Pandolf November 1984 to die when invoked as an AF.
       46*   Modified by Steve Herbst 11/20/84 to assume -all if no other type args and all nonstarnames.
       47*   Modified by M. Sharpe 2/21/85 to indent addnames by 2 if only names are listed-- bug introduced by the date_time changes
       48**/
       49 
       50 ls:
       51 list:
       52      procedure options (variable);
       53 
       54 /* system_free_area - used by directory listing primitives to return information,
       55*   and by list to allocate the starnames and sort_ix arrays */
       56 
       57 dcl  system_free_area area based (system_free_ptr);
       58 dcl  system_free_ptr ptr;
       59 
       60 dcl  aloc_ptr (6) ptr;				/* pointers to storage allocated in system_free_area,
       61*						   which must be freed by the cleanup handler */
       62 dcl  ep ptr defined (aloc_ptr (1));
       63 dcl  np ptr defined (aloc_ptr (2));
       64 dcl  msf_ep ptr defined (aloc_ptr (3));
       65 dcl  msf_np ptr defined (aloc_ptr (4));
       66 dcl  starptr ptr defined (aloc_ptr (5));
       67 dcl  sort_index_ptr ptr defined (aloc_ptr (6));
       68 
       69 /* Misc. pointers, init (null) */
       70 
       71 dcl  lp ptr init (null);				/* link pathname pointer */
       72 
       73 /* Misc. fixed bin init (0) */
       74 
       75 dcl  (bc, ec, err_opt, first, from_to_date_ix, lc, ni, n_listed, nn, nnames, not_found_count, pathl, records, tpix, tx, dmf_count, dmf_rec_count)
       76 	fixed bin init (0);
       77 
       78 /* Misc. fixed bin not initialized */
       79 
       80 dcl  (dir_bc, dir_ec, dir_lc, first_br, first_et, first_lk, hdng_index, i, ia, ib, ix, last_br, last_et, last_lk, msf_count, msf_rec_count)
       81 	fixed bin;
       82 
       83 dcl msf_bc fixed bin;
       84 
       85 /* Variables related to the four entry types: segs, dirs, msfs, and links */
       86 
       87 dcl  (
       88      tcount (0:3),
       89      trecs (0:3)
       90      ) fixed bin;					/* tcount holds no. of links,segs,dirs,msfs while
       91*						   trecs contains page totals */
       92 						/* trecs(0) is unused, and is declared only to make
       93*						   tcount(i),trecs(i) legal for i = 0,1,2,3 */
       94 dcl  tsws (0:3) bit (1) aligned;			/* switches saying which types are to be listed */
       95 dcl  (
       96      linksw defined tsws (0),				/* give a name to each element in the array of switches */
       97      segsw defined tsws (1),
       98      dirsw defined tsws (2),
       99      multisegsw defined tsws (3)
      100      ) bit (1) aligned;
      101 
      102 dcl  type_ix (5) fixed bin static options (constant) init (1, 3, 3, 2, 0);
      103 						/* since the order of entry types in the listing is: */
      104 dcl  LINK fixed bin static options (constant) init (0);	/* segs, msfs, dirs, links */
      105 dcl  SEG fixed bin static options (constant) init (1);	/* the do loop would read do i = 1,3,2,0 */
      106 dcl  DIR fixed bin static options (constant) init (2);	/* which generates messy code */
      107 dcl  MSF fixed bin static options (constant) init (3);	/* so we use this array of entry types instead */
      108 
      109 /* switches, init ("1"b) */
      110 
      111 dcl  (default_col, default_type, lnsw) bit (1) aligned init ("1"b);
      112 
      113 /* switches init ("0"b) - see also the two arrays of switches: tsws(0:3) and colsw(7) */
      114 
      115 dcl  (allsw, bfsw, branchsort, branchsw, dtem_arg_sw, excludesw, filesw, fromsw, got_all_branch_info, got_branch_info,
      116      includesw, length_arg_sw, link_path_arg, matchsw, error_flag, noheadsw, pathsw, pbranchsw, 
      117      pdmfilesw, pmultisegsw, prisw, read_vtoc_sw,
      118      real_dtm_sw, real_record_sw, revsw, shortsw, sort_vtoc_sw, sortsw, tosw, totalsw) bit (1) aligned init ("0"b);
      119 
      120 dcl  colsw (7) bit (1) aligned;
      121 dcl  dtmsw bit (1) aligned defined (colsw (1));
      122 dcl  dtusw bit (1) aligned defined (colsw (2));
      123 dcl  modesw bit (1) aligned defined (colsw (3));
      124 dcl  recordsw bit (1) aligned defined (colsw (4));
      125 dcl  namesw bit (1) aligned defined (colsw (5));
      126 dcl  countsw bit (1) aligned defined (colsw (6));
      127 dcl  lkpathsw bit (1) aligned defined (colsw (7));
      128 
      129 dcl  msf_pass2 bit (1) aligned;
      130 
      131 /* Variables used in argument processing */
      132 
      133 dcl  argptr ptr;
      134 dcl  (argno, arglen, nargs) fixed bin;
      135 dcl  targ char (arglen) based (argptr);
      136 
      137 dcl  ch8 char (8) aligned;				/* place to put short control args, for best
      138*						   comparison code generation (ldaq, cmpaq) */
      139 dcl  ch4 char (4) aligned based (addr (ch8));		/* overlay to get lda, cmpa for
      140*						   arguments of 4 chars or less */
      141 
      142 dcl  ch20 char (20) aligned;				/* for args > 8 chars, at least put it in the stack and
      143*						   avoid page faults during comparisons */
      144 dcl  (
      145      ch12 char (12),
      146      ch16 char (16)
      147      ) aligned based (addr (ch20));
      148 
      149 dcl  (path, dirname) char (168);
      150 
      151 /* Control arguments.  Look them up in arrays, instead of having a separate
      152*   CMPC instruction for each one (there are 74) */
      153 
      154 dcl  c4arg (40) char (4) aligned static options (constant) init ("-a",
      155 						/* 1 */
      156 	"-all",					/* 2 */
      157 	"-b",					/* 3 */
      158 	"-bf",					/* 4 */
      159 	"-br",					/* 5 */
      160 	"-d",					/* 6 */
      161 	"-dr",					/* 7 */
      162 	"-dtm",					/* 8 */
      163 	"-dtu",					/* 9 */
      164 	"-f",					/* 10 */
      165 	"-fi",					/* 11 */
      166 	"-l",					/* 12 */
      167 	"-lk",					/* 13 */
      168 	"-lks",					/* 14 */
      169 	"-msf",					/* 15 */
      170 	"-nm",					/* 16 */
      171 	"-p",					/* 17 */
      172 	"-pn",					/* 18 */
      173 	"-pri",					/* 19 */
      174 	"-prn",					/* 20 */
      175 	"-rec",					/* 21 */
      176 	"-rev",					/* 22 */
      177 	"-rv",					/* 23 */
      178 	"-s",					/* 24 */
      179 	"-sh",					/* 25 */
      180 	"-sm",					/* 26 */
      181 						/* new ones - out of order */
      182 	"-ct",					/* 27 */
      183 	"-ex",					/* 28 */
      184 	"-fm",					/* 29 */
      185 	"-md",					/* 30 */
      186 	"-nhe",					/* 31 */
      187 	"-nh",					/* 32 */
      188 	"-sr",					/* 33 */
      189 	"-to",					/* 34 */
      190 	"-tt",					/* 35 */
      191 	"-ft",					/* 36 */
      192 	"-lp",					/* 37 */
      193 	"-dir",					/* 38 */
      194 	"-ln",					/* 39 */
      195           "-dmf");					/* 40 */
      196 
      197 dcl  c8arg (26) char (8) aligned static options (constant) init ("-branch",
      198 						/* 1 */
      199 	"-brief",					/* 2 */
      200 	"-file",					/* 3 */
      201 	"-files",					/* 4 */
      202 	"-link",					/* 5 */
      203 	"-name",					/* 6 */
      204 	"-names",					/* 7 */
      205 	"-primary",				/* 8 */
      206 	"-record",				/* 9 */
      207 	"-records",				/* 10 */
      208 	"-reverse",				/* 11 */
      209 	"-segment",				/* 12 */
      210 	"-short",					/* 13 */
      211 						/* new ones - out of order */
      212 	"-count",					/* 14 */
      213 	"-exclude",				/* 15 */
      214 	"-from",					/* 16 */
      215 	"-match",					/* 17 */
      216 	"-mode",					/* 18 */
      217 	"-sort",					/* 19 */
      218 	"-total",					/* 20 */
      219 	"-totals",				/* 21 */
      220 	"-links",					/* 22 */
      221 	"-first",					/* 23 */
      222 	"-dtcm",					/* 24 */
      223 	"-dtem",					/* 25 */
      224 	"-length");				/* 26 */
      225 
      226 dcl  c12arg (5) char (12) aligned static options (constant) init ("-directory",
      227 						/* 1 */
      228 	"-pathname",				/* 2 */
      229 	"-no_header",				/* 3 */
      230 	"-link_path",				/* 4 */
      231 	"-link_paths");				/* 5 */
      232 
      233 dcl  c16arg (1) char (16) aligned static options (constant) init ("-date_time_used");
      234 						/* 1 */
      235 
      236 dcl  c20arg (2) char (20) aligned static options (constant) init ("-date_time_modified",
      237 						/* 1 */
      238 	"-multisegment_file");			/* 2 */
      239 
      240 dcl  c28arg (3) char (28) aligned static options (constant) init ("-date_time_contents_modified",
      241 						/* 1 */
      242 	"-date_time_entry_modified",			/* 2 */
      243           "-data_management_file");			/* 3 */
      244 
      245 /* Variables connected with sort argument processing, and sorting */
      246 
      247 dcl  c4key (11) char (4) aligned static options (constant) init (
      248 						/* sort keys */
      249 	"ct",					/* 6 */
      250 	"md",					/* 3 */
      251 	"mode",					/* 3 */
      252 	"name",					/* 5 */
      253 	"nm",					/* 5 */
      254 						/* first 5 are not involved in VTOC-or-directory question */
      255 	"dtm",					/* 1 */
      256 	"dtem",					/* 1 */
      257 	"ln",					/* 4 */
      258 						/* numbers 6, 7, and 8 are directory items */
      259 	"dtu",					/* 2 */
      260 	"dtcm",					/* 1 */
      261 	"rec");					/* 4 */
      262 						/* numbers 9, 10, and 11 are VTOC items */
      263 
      264 dcl  c4key_value (11) fixed bin static options (constant) init (6, 3, 3, 5, 5, 1, 1, 4, 2, 1, 4);
      265 dcl  sort_key fixed bin init (0);			/* remember the given sort key as a code number */
      266 
      267 dcl  DEFAULT fixed bin static options (constant) init (0);
      268 
      269 /* The following named values are used for two purposes:
      270*   1) values of sort_key, to determine which column to sort on;
      271*   2) references to the colsw array, to determine which columns to print (and to set up format strings for).
      272**/
      273 
      274 dcl  DTM fixed bin static options (constant) init (1);
      275 dcl  DTU fixed bin static options (constant) init (2);
      276 dcl  REC fixed bin static options (constant) init (4);
      277 dcl  NAME fixed bin static options (constant) init (5);
      278 dcl  CT fixed bin static options (constant) init (6);
      279 
      280 /* This array holds indices of entries. It is allocated large enough to hold indices of all entries in the directory,
      281*   but only the indices of entries selected (by star matching, etc.) for listing are actually placed in it.
      282*   Sorting, if specified by the user, is accomplished by reordering the indices, rather than the entries themselves. */
      283 
      284 dcl  sort_ix (dir_ec) fixed bin aligned based (sort_index_ptr);
      285 
      286 /* Variables connected with starname argument processing and star matching */
      287 
      288 dcl  1 starnames (alloc_len) aligned based (starptr),	/* this structure has one entry per starname */
      289        2 type fixed bin,				/* see below */
      290        2 action fixed bin,				/* for possible values of these two variables */
      291        2 length fixed bin,				/* length in characters of the starname */
      292        2 matched bit (1) aligned,			/* = "1"b after star matching, if any entries matched this name */
      293        2 name char (32) unaligned;			/* the starname itself */
      294 
      295 dcl  1 stack_starnames (4) like starnames aligned automatic;/* the starnames structure usually overlays this */
      296 dcl  alloc_len fixed bin;				/* but if there are > 4, we allocate enough room for them */
      297 dcl  starname_idx fixed bin;
      298 dcl  all_nonstarred_sw bit (1);
      299 
      300 /* Here are the values that starnames.type can have */
      301 
      302 dcl  ENTRY_NAME fixed bin static options (constant) init (0);
      303 dcl  DOUBLE_STAR fixed bin static options (constant) init (2);
      304 
      305 /* Here are the values that starnames.action can have */
      306 
      307 dcl  INCLUDE fixed bin static options (constant) init (10);
      308 dcl  EXCLUDE fixed bin static options (constant) init (11);
      309 
      310 dcl  starname_count fixed bin init (0);			/* number of starnames given on command line */
      311 
      312 /* Variables used in accessing information returned by the directory listing primitives */
      313 
      314 dcl  type bit (2);
      315 
      316 dcl  lkpath char (168) based (lp);
      317 
      318 dcl  mode char (4);					/* for printing "sma" or "rew" */
      319 dcl  mode_array (3) char (1) unaligned based (addr (mode)); /* for storing mode letters in mode */
      320 dcl  file_mode char (4) static options (constant) init ("rew ");
      321 						/* mode letters for files */
      322 dcl  dir_mode char (4) static options (constant) init ("s ma");
      323 						/* mode letters for directories */
      324 dcl  mode_ptr ptr;					/* points to one of the mode letter strings */
      325 dcl  et_mode (4) char (1) unaligned based (mode_ptr);	/* for picking up mode letters from one of the strings */
      326 dcl  mode_bits (4) bit (1) unaligned;			/* copy of the "rewa" mode bits, from the branch */
      327 
      328 /* This should use star_structures.incl.pl1 */
      329 
      330 dcl  name (16384) char (32) based (np);			/* name array as returned from star_list */
      331 						/* 16384 is the longest array that could be allocated
      332*						   in system_free_area */
      333 
      334 dcl  1 br (dir_ec) based (ep) aligned,			/* branch array */
      335        2 type bit (2) unaligned,
      336        2 nname fixed bin (15) unaligned,
      337        2 nindex fixed bin (17) unaligned,
      338        2 (dtm, dtu) bit (36) aligned,			/* really bit (36) - all 36 bits are data - no sign bit */
      339        2 mode unaligned,				/* see explanation in the get_date internal procedure */
      340          3 (t, r, e, w, a) bit (1) unaligned,
      341        2 pad bit (6) unaligned,
      342        2 records fixed bin (24) unaligned;
      343 
      344 dcl  1 branch automatic aligned,
      345        2 type bit (2) unaligned,
      346        2 nname fixed bin (15) unaligned,
      347        2 nindex fixed bin (17) unaligned,
      348        2 (dtm, dtu) bit (36) aligned,			/* really bit (36) - all 36 bits are data - no sign bit */
      349        2 mode unaligned,				/* see explanation in the get_date internal procedure */
      350          3 (t, r, e, w, a) bit (1) unaligned,
      351        2 pad bit (13) unaligned,
      352        2 records fixed bin (17) unaligned;
      353 
      354 dcl  1 et (dir_ec) based (ep) aligned,			/* overlay for br and lk structures, to pick up date and mode */
      355        2 et_pad1 fixed bin,				/* pick up the dates out of an array, in a do loop */
      356        2 date (2) bit (36) aligned,			/* really bit 36 ... */
      357        2 et_pad2 bit (1) unaligned,			/* ignore "t" mode */
      358        2 mode bit (4) unaligned,			/* "rewa" */
      359        2 et_pad3 bit (31) unaligned;
      360 
      361 dcl  1 lk (dir_ec) based (ep) aligned,			/* link entry array */
      362        2 type bit (2) unaligned,
      363        2 nname fixed bin (15) unaligned,
      364        2 nindex fixed bin (17) unaligned,
      365        2 (dtm, dtd) bit (36) aligned,			/* really bit 36 ... */
      366        2 (pln, pnindex) fixed bin (17) unaligned;
      367 
      368 /* Variables used in accessing and formatting date information */
      369 
      370 dcl  (from_date, to_date) bit (36) aligned;
      371 dcl  fb71 fixed bin (71);
      372 dcl  cdate (2) char (64)var;                               /* hold dtm value (either dtcm or dtem) and dtu value */
      373 dcl  cdtm char (64)var defined (cdate (1));                /* either dtcm value (for -dtcm) or dtem value (for -dtem).
      374*                                                              But not both values because of inconsitency */
      375 dcl  cdtu char (64)var defined (cdate (2));                /* dtu value for -dtu */
      376      
      377 
      378 /* Variables used for formatting and printing output */
      379 
      380 dcl  ioa_control_string char (256) varying;		/* used for all ioa_ calls */
      381 
      382 /* ioa_ control string values for printing headings */
      383 
      384 dcl  1 hdng aligned int static options (constant),	/* pack headings into unaligned strings: 423 chars (106 words) */
      385        (
      386        2 lkbfze char (8) init ("Links=0."),		/* The length and offset arrays occupy a total of 44 words. */
      387        2 smbfze char (7) init ("Segs=0;"),		/* The (single) statement that copies the right heading into */
      388 	  2 drbfze char (7) init ("Dirs=0;"),		/* ioa_control_string generates 10 words of code. */
      389        2 msbfze char (7) init ("Msfs=0;"),		/* Total: 160 words used by this method. */
      390 						/* An array of char(44) strings would use 242 words (no good). */
      391 	  2 lkbfnz char (9) init ("Links=^d."),		/* Stored as aligned strings (generated for literal constants) */
      392 	  2 smbfnz char (16) init ("Segs=^d,recs=^d;"),	/* the headings would use 111 words. */
      393        2 drbfnz char (16) init ("Dirs=^d,recs=^d;"),	/* The code to assign the strings as constants would be */
      394        2 msbfnz char (16) init ("Msfs=^d,recs=^d;"),	/* 7 words per string: 3-word mlr, ldq-stq to set the length */
      395 	  2 lklgze char (12) init ("^/Links = 0."),	/* of the varying string, tra around the other assignments, */
      396        2 smlgze char (15) init ("^/Segments = 0."),	/* and one word in a transfer vector to get to */
      397        2 drlgze char (18) init ("^/Directories = 0."),	/* the right assignment. Total: 7*22=154, */
      398        2 mslgze char (25) init ("^/Multisegment-files = 0."),
      399 						/* plus the 111 words to store the strings, totaling 265 words. */
      400 	  2 lklgnz char (16) init ("^/Links = ^d.^2/"),	/* Saving: 265-160=105 words. */
      401        2 smlgnz char (33) init ("^/Segments = ^d, Records = ^d.^2/"),
      402        2 drlgnz char (36) init ("^/Directories = ^d, Records = ^d.^2/"),
      403        2 mslgnz char (43) init ("^/Multisegment-files = ^d, Records = ^d.^2/"),
      404        2 smbfxx char (16) init ("Segs=^d,lths=^d;"),
      405        2 drbfxx char (8) init ("Dirs=^d;"),
      406        2 msbfxx char (16) init ("Msfs=^d,lths=^d;"),
      407        2 smlgxx char (33) init ("^/Segments = ^d, Lengths = ^d.^2/"),
      408        2 drlgxx char (22) init ("^/Directories = ^d.^2/"),
      409        2 mslgxx char (43) init ("^/Multisegment-files = ^d, Lengths = ^d.^2/")
      410        ) unaligned;
      411 
      412 dcl  hdng_len (0:21) fixed bin unaligned static options (constant)
      413 	init (8, 7, 7, 7, 9, 16, 16, 16, 12, 15, 18, 25, 16, 33, 36, 43, 16, 8, 16, 33, 22, 43);
      414 dcl  hdng_offset (0:21) fixed bin unaligned static options (constant)
      415 	init (1, 9, 16, 23, 30, 39, 55, 71, 87, 99, 114, 132, 157, 173, 206, 242, 285, 301, 309, 325, 358, 380);
      416 						/* 380+43=423 */
      417 
      418 dcl  dmf_control_string dim (0:21) char (64) internal static options (constant)
      419      init ("", "", "", "Dmfs=0;", "", "", "", "Dmfs=^d,recs=^d;",
      420            "", "", "", "^/Data Management files = 0.", "", "", "", "^/Data Management files = ^d, Records = ^d.^2/",
      421            "", "", "Dmfs=^d,cis=^d;", "", "", "^/Data Management files = ^d, Control Intervals = ^d.^2/");
      422 
      423 /* Variables used in constructing ioa_ format strings */
      424 
      425 /* max_day is "1999-12-31  23:59:59.999999 gmt Fri"		       */
      426 /* None of the component values have leading or trailing zeroes, so no       */
      427 /*  matter what kind of space or zero suppression has been called for in a   */
      428 /*  user's default formats, this value will cause a max-length result from   */
      429 /*  date_time_$format.					       */
      430 dcl max_day fixed bin (71) int static options (constant) init (3124137599999999);
      431 dcl date_format char (15) int static options (constant) init ("^<date> ^<time>");
      432 dcl  dt_len fixed bin;
      433 dcl  dt_len_pic pic"99";
      434 
      435 
      436 dcl  col_fmt (6) char (8) int static options (constant) init (
      437      	"^2x^__a",				/* dtm */
      438 	"^2x^__a",				/* dtu */
      439 	"^2x^3a",					/* mode */
      440 	"^1x^4d",					/* records */
      441 	"^2x^a",					/* name */
      442 	"^2x(^d)");				/* count */
      443 
      444 dcl  col_fmt_ln (6) fixed bin static options (constant) init (7, 7, 6, 6, 5, 7);
      445 dcl  branch_fmt (2) char (35);			/* for files and directories, respectively */
      446 dcl  branch_fmt_ln (2) fixed bin init ((2) 0);
      447 dcl  branch_fmt_ix fixed bin;
      448 
      449 
      450 dcl  name_indent fixed bin init (0);			/* how far to indent addnames */
      451 
      452 dcl  name_fmt (0:2) char (8);				/* name formats for links, files, and dirs, respectively */
      453 dcl  name_fmt_ln (0:2) fixed bin;			/* their lengths */
      454 
      455 dcl  link_fmt (2) char (24);				/* two link formats, for singly- and multiply-named links */
      456 dcl  link_fmt_ln (2) fixed bin;			/* their lengths */
      457 
      458 /* Variables used in error message printing */
      459 
      460 dcl  (
      461      code,
      462      (
      463      error_table_$nomatch,				/* no match error for star name (or entry name) */
      464      error_table_$bigarg,				/* arg too long */
      465      error_table_$logical_volume_not_connected,		/* tried to read VTOC but the volume is not available */
      466      error_table_$logical_volume_not_defined,		/* unavailable for a different reason */
      467      error_table_$null_dir,				/* Directory is empty */
      468      error_table_$root,				/* can't list the root as a dir itself */
      469      error_table_$inconsistent,			/* inconsistent combination of args */
      470      error_table_$badopt
      471      ) ext
      472      ) fixed bin (35);				/* unrecognized option error */
      473 
      474 dcl  message char (68) varying;			/* ioa_ control string for com_err_ calls */
      475 dcl  errname char (168) aligned init ("");		/* path name variable for com_err_ calls */
      476 
      477 /* External Entries */
      478 
      479 dcl  iox_$error_output ext ptr;
      480 
      481 dcl  absolute_pathname_ entry (char (*), char(*), fixed bin (35));
      482 dcl  (
      483      com_err_,
      484      ioa_,
      485      ioa_$nnl,
      486      ioa_$ioa_switch
      487      ) entry options (variable);
      488 dcl  cu_$arg_count entry (fixed bin, fixed bin(35));
      489 dcl  cu_$arg_ptr entry (fixed bin (17), ptr, fixed bin (17), fixed bin (35));
      490 dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin);
      491 dcl  cv_fstime_ entry (bit (36) aligned) returns (fixed bin (71));
      492 dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
      493 dcl  date_time_$format entry (char(*), fixed bin(71), char(*), char(*)) returns(char(250) var);
      494 dcl  file_manager_$validate entry (char(*), char(*), fixed bin(35));
      495 dcl  fs_util_$get_user_access_modes entry (char(*), char(*), char(*), fixed bin, bit(36) aligned,
      496 	bit(36) aligned, fixed bin(35));
      497 dcl hcs_$get_user_access_modes entry (char(*), char(*), char(*), fixed bin, bit(36) aligned,
      498 	bit(36) aligned, fixed bin(35));
      499 dcl  hcs_$star_dir_list_
      500 	entry (char (*), char (*) aligned, fixed bin (3), ptr, fixed bin, fixed bin, ptr, ptr, fixed bin (35));
      501 dcl  hcs_$status_ entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
      502 dcl  hcs_$status_minf entry (char(*), char(*), fixed bin(1), fixed bin(2), fixed bin(24), fixed bin(35));
      503 dcl  get_system_free_area_ entry returns (ptr);
      504 dcl  check_star_name_$entry ext entry (char (*), fixed bin (35));
      505 dcl  match_star_name_ ext entry (char (*), char (*), fixed bin (35));
      506 dcl  convert_date_to_binary_ ext entry (char (*), fixed bin (71), fixed bin (35));
      507 
      508 /* Conditions and builtins */
      509 
      510 dcl  cleanup condition;
      511 
      512 dcl  (addr, bin, bit, convert, divide, fixed, hbound, index, length, mod, null, rtrim, search, string, substr) builtin;
      513 
      514 /**/
      515                                                             /* set variables to initial values to avoid unexpected values */
      516           msf_bc = 0;
      517           dirname = "";
      518 
      519 	system_free_ptr = get_system_free_area_ ();	/* get pointer to free storage area */
      520 
      521 	tcount (1), tcount (2), tcount (3), tcount (0) = 0;
      522 						/* inits of automatic arrays compile inefficiently */
      523 	trecs (1), trecs (2), trecs (3), trecs (0) = 0;
      524 	tsws (1), tsws (2), tsws (3), tsws (0) = "0"b;
      525 	name_fmt_ln (0), name_fmt_ln (1) = 0;
      526 	link_fmt_ln (1), link_fmt_ln (2) = 0;
      527 
      528 	colsw (1), colsw (2), colsw (3), colsw (4), colsw (6) = "0"b;
      529 	namesw = "1"b;				/* turn on colsw (5) - the names column is always printed */
      530 	lkpathsw = "1"b;				/* turn on colsw (7) - link paths are printed, by default */
      531 
      532 	aloc_ptr (1), aloc_ptr (2), aloc_ptr (3), aloc_ptr (4), aloc_ptr (6) = null;
      533 	starptr = addr (stack_starnames);		/* aloc_ptr (5) starts out pointing at a small stack array */
      534 
      535 /* All allocation pointers must be initialized or nulled before we establish the cleanup handler */
      536 
      537 	on condition (cleanup) call cleanup_proc;
      538 
      539 	call cu_$arg_count (nargs, code);		/* pick up command argument count */
      540 	if code ^= 0 then do;
      541 	     call com_err_ (code, "list");
      542 	     return;                                      /* quit */
      543 	     end;
      544 	do argno = 1 to nargs;			/* begin option processing loop */
      545 	     call get_arg_ptr;			/* call cu_$arg_ptr to pick up next argument */
      546 	     if arglen = 0 then go to endopt;		/* ignore null strings */
      547 	     if substr (targ, 1, 1) = "-" then do;	/* check for control argument */
      548 ctl_arg:
      549 		if arglen > 8 then goto arglong;	/* arg <= 8 chars gets special treatment */
      550 		ch8 = targ;			/* copy into double-word-aligned string */
      551 		if arglen > 4 then goto argl8;	/* go compare using ldaq, cmpaq */
      552 						/* else fall thru and compare using lda, cmpa */
      553 		do i = 1 to hbound (c4arg, 1);
      554 		     if ch4 = c4arg (i) then goto c4lab (i);
      555 		end;
      556 		goto badopt;			/* if no match */
      557 
      558 argl8:
      559 		do i = 1 to hbound (c8arg, 1);
      560 		     if ch8 = c8arg (i) then goto c8lab (i);
      561 		end;
      562 		goto badopt;
      563 
      564 arglong:
      565 		if arglen > 20 then goto arglong2;
      566 		ch20 = targ;			/* at least avoid page faults during comparisons */
      567 
      568 		if arglen <= 12 then do;
      569 		     do i = 1 to hbound (c12lab, 1);
      570 			if ch12 = c12arg (i) then goto c12lab (i);
      571 		     end;
      572 		     goto badopt;
      573 		     end;
      574 
      575 /* for the 5 arguments longer than 12 characters, individual cmpb's occupy less space than do loops would */
      576 
      577 		if ch20 = c20arg (1) then goto c20lab1;
      578 		if ch20 = c20arg (2) then goto c20lab2;
      579 		if ch16 = c16arg (1) then goto c16lab1;
      580 		goto badopt;
      581 
      582 arglong2:
      583 		if targ = c28arg (1) then goto c28lab1;
      584 		if targ = c28arg (2) then goto c28lab2;
      585 		goto badopt;
      586 
      587 
      588 /* Set switches as specified by control arguments */
      589 
      590 
      591 c4lab (1):					/* -a */
      592 c4lab (2):					/* -all */
      593 		pbranchsw, allsw, segsw, dirsw, multisegsw, pmultisegsw, pdmfilesw, linksw = "1"b;
      594 reset_default_type:
      595 		default_type = "0"b;
      596 		goto endopt;
      597 
      598 c4lab (3):					/* -b */
      599 c4lab (5):					/* -br */
      600 c8lab (1):					/* -branch */
      601 		branchsw, pbranchsw, segsw, dirsw, multisegsw, pmultisegsw, pdmfilesw = "1"b;
      602 		goto reset_default_type;
      603 
      604 c4lab (4):					/* -bf */
      605 c8lab (2):					/* -brief */
      606 		bfsw = "1"b;
      607 		lkpathsw = "0"b;			/* -brief suppresses link pathnames */
      608 reset_default_col:
      609 		default_col = "0"b;
      610 		goto endopt;
      611 
      612 c4lab (27):					/* -ct */
      613 c8lab (14):					/* -count */
      614 		countsw = "1"b;
      615 		goto endopt;
      616 
      617 c4lab (6):					/* -d */
      618 c4lab (7):					/* -dr */
      619 c4lab (38):					/* -dir */
      620 c12lab (1):					/* -directory */
      621 		dirsw, pbranchsw = "1"b;
      622 		goto reset_default_type;
      623 
      624 c4lab (40):					/* -dmf */
      625 c28lab3:						/* -data_management_file */
      626 		pdmfilesw, multisegsw, pbranchsw = "1"b;
      627 		goto reset_default_type;
      628 
      629 c8lab (24):					/* -dtcm */
      630 c28lab1:						/* -date_time_contents_modified */
      631 		if dtem_arg_sw then goto vtoc_conflict;
      632 		real_dtm_sw, read_vtoc_sw = "1"b;
      633 		goto set_dtm_sw;
      634 
      635 c8lab (25):					/* -dtem */
      636 c28lab2:						/* -date_time_entry_modified */
      637 c4lab (8):					/* -dtm */
      638 c20lab1:						/* -date_time_modified */
      639 		if real_dtm_sw then goto vtoc_conflict;
      640 		dtem_arg_sw = "1"b;
      641 set_dtm_sw:
      642 		dtmsw = "1"b;
      643 		lnsw = "0"b;
      644 		goto endopt;
      645 
      646 c4lab (9):					/* -dtu */
      647 c16lab1:						/* -date_time_used */
      648 		dtusw = "1"b;
      649 		read_vtoc_sw = "1"b;
      650 		lnsw = "0"b;
      651 		goto endopt;
      652 
      653 c4lab (28):					/* -ex */
      654 c8lab (15):					/* -exclude */
      655 		argno = argno + 1;
      656 		call get_arg_ptr;
      657 		call get_starname;
      658 		starnames (starname_count).action = EXCLUDE;
      659 						/* remember to exclude entries that match this one */
      660 		excludesw = "1"b;
      661 		goto endopt;
      662 
      663 c4lab (10):					/* -f */
      664 c4lab (11):					/* -fi */
      665 c8lab (3):					/* -file */
      666 c8lab (4):					/* -files */
      667 		filesw, segsw, multisegsw, pmultisegsw, pdmfilesw, pbranchsw = "1"b;
      668 		goto reset_default_type;
      669 
      670 c4lab (36):					/* -ft */
      671 c8lab (23):					/* -first */
      672 		argno = argno + 1;			/* get next arg, which must be decimal number */
      673 		call get_arg_ptr;			/* if none there, get_arg_ptr calls com_err_ */
      674 		first = cv_dec_check_ (targ, code);
      675 		if code ^= 0 then do;		/* bad char in decimal arg */
      676 		     code = 0;			/* not error_table_ code - com_err_ dislikes it */
      677 		     call com_err_ (code, "list", "Illegal character in decimal argument: ^a.", targ);
      678 
      679 		     err_opt = err_opt + 1;             /* indicate that errors in options */
      680 		     end;
      681 		goto endopt;
      682 
      683 c4lab (15):					/* -msf */
      684 c20lab2:						/* -multisegment_file */
      685 		multisegsw, pmultisegsw, pbranchsw = "1"b;
      686 		goto reset_default_type;
      687 
      688 c4lab (29):					/* -fm */
      689 c8lab (16):					/* -from */
      690 		fromsw = "1"b;
      691 		call get_date (from_date, "from");	/* internal procedure used by -from and -to */
      692 		goto endopt;
      693 
      694 c4lab (39):					/* -ln */
      695 c8lab (26):					/* -length */
      696 		if real_record_sw then goto vtoc_conflict;
      697 		length_arg_sw, recordsw = "1"b;
      698 		lnsw = "0"b;
      699 		goto reset_default_col;
      700 
      701 c4lab (14):					/* -lks */
      702 		shortsw = "1"b;			/* fall thru to set link switch */
      703 
      704 c4lab (12):					/* -l */
      705 c4lab (13):					/* -lk */
      706 c8lab (5):					/* -link */
      707 c8lab (22):					/* -links */
      708 		linksw = "1"b;
      709 		goto reset_default_type;
      710 
      711 c4lab (37):					/* -lp */
      712 c12lab (4):					/* -link_path */
      713 c12lab (5):					/* -link_paths */
      714 		link_path_arg = "1"b;
      715 		goto endopt;
      716 
      717 c8lab (17):					/* -match */
      718 		matchsw = "1"b;
      719 		goto endopt;
      720 
      721 c4lab (30):					/* -md */
      722 c8lab (18):					/* -mode */
      723 		modesw = "1"b;
      724 		lnsw = "0"b;
      725 		goto reset_default_col;
      726 
      727 c4lab (16):					/* -nm */
      728 c8lab (6):					/* -name */
      729 c8lab (7):					/* -names */
      730 		namesw = "1"b;
      731 		goto reset_default_col;
      732 
      733 c4lab (31):					/* -nh */
      734 c4lab (32):					/* -nhe */
      735 c12lab (3):					/* -no_header */
      736 		noheadsw = "1"b;
      737 		goto endopt;
      738 
      739 c4lab (17):					/* -p */
      740 c4lab (18):					/* -pn */
      741 c12lab (2):					/* -pathname */
      742 		argno = argno + 1;			/* next arg is the directory pathname */
      743 		call get_arg_ptr;			/* get ptr to it */
      744 		dirname = targ;			/* copy it into temp */
      745 		if pathsw
      746 		then				/* if a directory path already given */
      747 		     if path ^= dirname then do;	/* and this one is different */
      748 two_pn_error:
      749 			code = 0;			/* complain */
      750 			call com_err_ (code, "list", "More than one directory specified: ^a and ^a.",
      751 			     rtrim (path), rtrim (dirname));		/* print the earlier pathname too */
      752 
      753 			err_opt = err_opt + 1;        /* indicate that errors in options */
      754 			goto endopt;
      755 			end;
      756 		path = dirname;			/* save directory path */
      757 		path = targ;			/* copy it into char (168) */
      758 		pathl = arglen;			/* remember its actual length */
      759 		pathsw = "1"b;			/* remember to print it if not found or null dir errors occur */
      760 		goto endopt;
      761 
      762 c4lab (20):					/* -prn */
      763 		countsw = "1"b;			/* fall thru to set primary switch */
      764 
      765 c4lab (19):					/* -pri */
      766 c8lab (8):					/* -primary */
      767 		prisw = "1"b;
      768 		goto endopt;
      769 
      770 c4lab (21):					/* -rec */
      771 c8lab (9):					/* -record */
      772 c8lab (10):					/* -records */
      773 		if length_arg_sw then goto vtoc_conflict;
      774 		recordsw = "1"b;
      775 		real_record_sw, read_vtoc_sw = "1"b;
      776 		lnsw = "0"b;
      777 		goto reset_default_col;
      778 
      779 c4lab (22):					/* -rev */
      780 c4lab (23):					/* -rv */
      781 c8lab (11):					/* -reverse */
      782 		revsw = "1"b;
      783 		goto endopt;
      784 
      785 c4lab (24):					/* -s */
      786 c4lab (26):					/* -sm */
      787 c8lab (12):					/* -segment */
      788 		segsw, pbranchsw = "1"b;
      789 		goto reset_default_type;
      790 
      791 c4lab (25):					/* -sh */
      792 c8lab (13):					/* -short */
      793 		shortsw = "1"b;
      794 		goto endopt;
      795 
      796 c4lab (33):					/* -sr */
      797 c8lab (19):					/* -sort */
      798 		sortsw = "1"b;
      799 		argno = argno + 1;			/* look at next arg, which MIGHT be a sort key */
      800 		if argno > nargs then goto endopt;	/* but only if there is a next arg */
      801 		call get_arg_ptr;
      802 		if substr (targ, 1, 1) = "-" then goto ctl_arg;
      803 						/* not sort key */
      804 		if arglen <= 4 then do;		/* look up short keys in array, for efficiency */
      805 		     ch4 = targ;			/* copy it into stack var */
      806 		     do i = 1 to hbound (c4key, 1) while (ch4 ^= c4key (i));
      807 		     end;
      808 		     if i = 1 + hbound (c4key, 1) then goto star_arg;
      809 						/* not sort key - must be starname */
      810 		     sort_key = c4key_value (i);	/* remember the sort key number corresponding to this key */
      811 
      812 		     if i > 5
      813 		     then				/* this is a VTOC-or-directory item */
      814 			goto sort_lab (i - 5);	/* check consistency and set switches */
      815 		     goto endopt;
      816 
      817 sort_lab (1):					/* dtm */
      818 sort_lab (2):					/* dtem */
      819 		     if real_dtm_sw then goto vtoc_conflict;
      820 		     dtem_arg_sw = "1"b;
      821 		     goto endopt;
      822 
      823 sort_lab (3):					/* ln */
      824 		     if real_record_sw then goto vtoc_conflict;
      825 		     length_arg_sw = "1"b;
      826 		     goto endopt;
      827 
      828 sort_lab (4):					/* dtu */
      829 		     read_vtoc_sw, sort_vtoc_sw = "1"b;
      830 		     goto endopt;
      831 
      832 sort_lab (5):					/* dtcm */
      833 		     if dtem_arg_sw then goto vtoc_conflict;
      834 		     real_dtm_sw = "1"b;
      835 		     goto sort_lab (4);
      836 
      837 sort_lab (6):					/* rec */
      838 		     if length_arg_sw then goto vtoc_conflict;
      839 		     real_record_sw = "1"b;
      840 		     goto sort_lab (4);
      841 
      842 		     end;
      843 
      844 		else if arglen <= 20 then do;		/* arg longer than 4 chars */
      845 			ch20 = targ;		/* copy into 20-char stack variable */
      846 			if ch20 = "date_time_modified" then do;
      847 			     sort_key = DTM;
      848 			     goto sort_lab (1);
      849 			     end;
      850 			else if ch20 = "date_time_used" then do;
      851 				sort_key = DTU;
      852 				goto sort_lab (4);
      853 				end;
      854 			     else if substr (ch20, 1, 6) = "record" then do;
      855 						/* match "record" or "records" */
      856 				     sort_key = REC;
      857 				     goto sort_lab (6);
      858 				     end;
      859 				else if ch20 = "length" then do;
      860 					sort_key = REC;
      861 					goto sort_lab (3);
      862 					end;
      863 				     else if ch20 = "count"
      864 					then sort_key = CT;
      865 					else if ch20 = "names"
      866 					     then sort_key = NAME;
      867 					     else goto star_arg;
      868 						/* not sort key - must be starname */
      869 			end;			/* end of <= 20 char do group */
      870 
      871 		     else if arglen <= 28 then do;
      872 			     if targ = "date_time_contents_modified" then do;
      873 				sort_key = DTM;
      874 				goto sort_lab (5);
      875 				end;
      876 			     else if targ = "date_time_entry_modified" then do;
      877 				     sort_key = DTM;
      878 				     goto sort_lab (1);
      879 				     end;
      880 				else goto star_arg;
      881 			     end;
      882 
      883 			else goto star_arg;		/* too long to be sort key - must be starname */
      884 
      885 		goto endopt;			/* exit after picking up sort key and falling thru to here */
      886 
      887 c4lab (34):					/* -to */
      888 		tosw = "1"b;
      889 		call get_date (to_date, "to");	/* share code with -from */
      890 		goto endopt;
      891 
      892 c4lab (35):					/* -tt */
      893 c8lab (20):					/* -total */
      894 c8lab (21):					/* -totals */
      895 		totalsw = "1"b;
      896 		goto endopt;
      897 
      898 /* Come here for inconsistent arguments: VTOC and directory */
      899 
      900 vtoc_conflict:
      901 		code = error_table_$inconsistent;
      902 		call com_err_ (code, "list", "^a and a previous sort or column argument.", targ);
      903 
      904 		err_opt = err_opt + 1;                  /* indicate errors in options. */
      905 		goto endopt;
      906 
      907 /* Come here for unrecognized control args */
      908 
      909 badopt:
      910 		code = error_table_$badopt;		/* unrecognized control argument */
      911 badarg:
      912 		call com_err_ (code, "list", "^a", targ);
      913 
      914 		err_opt = err_opt + 1;		/* indicate errors in options */
      915 		end;
      916 
      917 	     else do;				/* arg does not begin with "-" so it must be a starname */
      918 star_arg:
      919 		call get_starname;			/* internal procedure */
      920 		if starnames (starname_count).action = 0 then do;
      921 						/* unless it was set by get_starname */
      922 		     starnames (starname_count).action = INCLUDE;
      923 						/* starname not preceeded by one of the special */
      924 		     includesw = "1"b;		/* control args gets matching entries included in the listing */
      925 		     end;
      926 		end;
      927 
      928 endopt:
      929 	end;					/* end of option handling section */
      930 
      931 	if err_opt ^= 0				/* If errors in options, leave now */
      932 	then go to error_return;
      933 
      934 /* If no errors, set up for processing: examine results of argument processing, set some defaults,
      935*   go get information out of directory, and then set up ioa_ control strings needed to print it */
      936 
      937 	if default_type then do;			/* if no entry type arguments were given */
      938 
      939 	     if starname_count > 0 then do;		/* check if all specified names are non-starnames */
      940 		all_nonstarred_sw = "1"b;
      941 		do starname_idx = 1 to starname_count while (all_nonstarred_sw);
      942 		     call check_star_name_$entry (starnames.name (starname_idx), code);
      943 		     if code ^= 0 then all_nonstarred_sw = "0"b;
      944 		end;
      945 	     end;
      946 	     else all_nonstarred_sw = "0"b;
      947 
      948 	     if all_nonstarred_sw then		/* enforce -all in this case */
      949 		pbranchsw, allsw, segsw, dirsw, multisegsw, pmultisegsw, pdmfilesw, linksw = "1"b;
      950 	     else filesw, segsw, multisegsw, pmultisegsw, pdmfilesw, pbranchsw = "1"b; /* the default is -file */
      951 	end;
      952 
      953 	if default_col then do;			/* if no arguments were given to override the default columns */
      954 	     namesw, modesw, recordsw = "1"b;		/* default is names, mode, and records */
      955 	     lnsw = "0"b;
      956 	     end;
      957 
      958 	if sortsw then do;				/* if -sort was given */
      959 	     if sort_key = DEFAULT then do;		/* but not followed by a keyword */
      960 		if dtmsw then do;			/* if dtm being printed */
      961 		     sort_key = DTM;		/* then sort on it */
      962 		     if real_dtm_sw then sort_vtoc_sw = "1"b;
      963 						/* remember to read VTOCs before sorting */
      964 		     end;
      965 		else if dtusw then do;		/* otherwise if dtu is being printed */
      966 			sort_key = DTU;		/* then sort on it */
      967 			sort_vtoc_sw = "1"b;
      968 			end;
      969 		     else sort_key = NAME;		/* otherwise sort on primary names */
      970 		end;
      971 
      972 	     if linksw
      973 	     then					/* if printing links */
      974 		if sort_key < NAME
      975 		then				/* and sorting on something that only a branch has */
      976 		     if sort_key > DTM
      977 		     then				/* we don't want to sort links on garbage */
      978 			branchsort = "1"b;		/* so remember to sort only branches */
      979 	     end;
      980 
      981 	if fromsw | tosw then do;			/* figure out which date to use for from-to comparisons */
      982 	     if dtmsw | sort_key = DTM
      983 	     then					/* if dtm being printed or sorted on */
      984 		from_to_date_ix = DTM;		/* use it for from-to comparison */
      985 	     else if dtusw | sort_key = DTU
      986 		then				/* otherwise, if dtu being printed or sorted on */
      987 		     from_to_date_ix = DTU;		/* use that for from-to comparison */
      988 		else				/* but if neither date being printed or sorted on */
      989 		     from_to_date_ix = DTM;		/* use dtm for from-to comparison */
      990 	     end;
      991 
      992 	if fromsw
      993 	then if tosw
      994 	     then					/* if both given */
      995 		if from_date >= to_date then do;	/* from must be before to */
      996 		     call com_err_ (error_table_$inconsistent, "list", "from-date must be BEFORE to-date.");
      997 		     goto error_return;                 /* call cleanup_proc internal procedure and quit */
      998 		     end;
      999 
     1000 	if lnsw
     1001 	then					/* if printing only names (like old ln command) */
     1002 	     lkpathsw = "0"b;			/* then don't print link pathnames */
     1003 						/* (-brief also suppresses linkpaths; that is checked above) */
     1004 
     1005 	if link_path_arg
     1006 	then					/* but if -link_path given */
     1007 	     lkpathsw = "1"b;			/* print link paths no matter what else */
     1008 
     1009 /* All the information related to selection of entries to be printed has now been analyzed.
     1010*   Go get the information out of the directory now, so that, knowing what we do and
     1011*   do not have to print, we can omit construction of unneeded format strings. */
     1012 
     1013 	call get_list;				/* internal procedure, for historical reasons;
     1014*						   also to make the main procedure shorter and more readable */
     1015 
     1016 	if error_flag
     1017 	then					/* if get_list returned nothing, and told user why */
     1018 	     goto error_return;			/* don't rub it in with lots of "<thing>s = 0" messages */
     1019 
     1020 /* Set up ioa_ format strings for printing branch information, link information, and secondary names.
     1021*   All of these formats are a function of which columns the user wants printed, and what was found in the directory. */
     1022 
     1023 	if ^totalsw then do;			/* don't waste time if only totals being printed */
     1024 	     if dtmsw | dtusw
     1025 	     then dt_len = length (date_time_$format (date_format, max_day, "", ""));
     1026 	     else dt_len = 1;
     1027 
     1028 
     1029 /* Set up branch format */
     1030 
     1031 	     if pbranchsw & bc > 0 then do;		/* only if at least one branch type is to be printed */
     1032 
     1033 		call set_branch_fmt (1);		/* set up format string for files */
     1034 
     1035 		if dirsw
     1036 		then				/* if listing directories */
     1037 		     if recordsw
     1038 		     then				/* and printing the records column */
     1039 			if ^real_record_sw then do;	/* but not real records */
     1040 			     recordsw = ""b;	/* turn off the records column switch */
     1041 			     call set_branch_fmt (2); /* and build a format string without the records column */
     1042 			     recordsw = "1"b;	/* and turn it back on again */
     1043 			     end;			/* but don't bother if the file format will be ok for dirs */
     1044 
     1045 		end;
     1046 
     1047 /* Set up link format. The possible items to be printed are:
     1048*   dtm, name, count, and linkpath. In addition, the presence or absence
     1049*   of the -short argument determines how linkpath is lined up. We must build
     1050*   two format strings (only when both linkpaths and counts are being printed),
     1051*   to be used for singly- and multiply-named links, since count is not printed
     1052*   when it is = 1. We did not have to do this for branches, because count is the
     1053*   last column, for branches, and we just chop the format item for count off
     1054*   the end of (a copy of) the format string, when count = 1. */
     1055 
     1056 	     if linksw & lc > 0 then do;		/* only if links are to be printed */
     1057 
     1058 		if dtmsw then do;			/* if dtm to be printed for links */
     1059 		     link_fmt (1) = "^__a^2x";
     1060 		     substr (link_fmt (1), 2, 2) = convert (dt_len_pic, dt_len);
     1061 		     link_fmt_ln (1) = 7;
     1062 		     end;
     1063 		else do;
     1064 		     link_fmt (1) = "^s";
     1065 		     link_fmt_ln (1) = 2;
     1066 		     end;
     1067 
     1068 		if ^lkpathsw
     1069 		then				/* if not printing linkpaths */
     1070 		     goto lkshort1;			/* then don't bother with the long format */
     1071 		if shortsw then do;
     1072 lkshort1:
     1073 		     substr (link_fmt (1), link_fmt_ln (1) + 1) = "^a";
     1074 						/* save printing time by not padding names to 32 char */
     1075 		     link_fmt_ln (1) = link_fmt_ln (1) + 2;
     1076 		     end;
     1077 		else do;
     1078 		     substr (link_fmt (1), link_fmt_ln (1) + 1) = "^32a";
     1079 						/* pad names, to line up link paths */
     1080 		     link_fmt_ln (1) = link_fmt_ln (1) + 4;
     1081 		     end;
     1082 
     1083 		if countsw then do;			/* if printing counts, we have to have two format strings */
     1084 		     link_fmt (2) = link_fmt (1);	/* the second one is for when there are no secondary names */
     1085 		     link_fmt_ln (2) = link_fmt_ln (1); /* its left half is just like the first one */
     1086 
     1087 		     if ^lkpathsw
     1088 		     then				/* if linkpaths not to be printed */
     1089 			goto lkshort2;		/* don't pad count to constant length */
     1090 		     if shortsw then do;		/* if -short given */
     1091 lkshort2:						/* also don't pad count to constant length */
     1092 			substr (link_fmt (1), link_fmt_ln (1) + 1) = "^2x(^d)";
     1093 			link_fmt_ln (1) = link_fmt_ln (1) + 7;
     1094 			end;
     1095 		     else do;			/* pad count to constant length, to keep linkpaths lined up */
     1096 			substr (link_fmt (1), link_fmt_ln (1) + 1) = "^2x(^3d)";
     1097 			link_fmt_ln (1) = link_fmt_ln (1) + 8;
     1098 			end;
     1099 
     1100 		     if lkpathsw then do;		/* if lkpaths to be printed, put a ^s in the second format,
     1101*						   preceeding the ^a for the linkpath */
     1102 			if shortsw
     1103 			then			/* if -short, don't bother lining things up */
     1104 			     substr (link_fmt (2), link_fmt_ln (2) + 1) = "^2x^s";
     1105 			else			/* otherwise, line up linkpaths */
     1106 			     substr (link_fmt (2), link_fmt_ln (2) + 1) = "^9x^s";
     1107 			link_fmt_ln (2) = link_fmt_ln (2) + 5;
     1108 						/* in either case, 5 chars were added to the format string */
     1109 			end;
     1110 		     end;				/* end of if countsw do group */
     1111 
     1112 		if lkpathsw then do;		/* if linkpaths to be printed, set up their formats */
     1113 		     if countsw then do;		/* if counts being printed, there is a second format string */
     1114 			substr (link_fmt (2), link_fmt_ln (2) + 1) = "^a";
     1115 						/* so put format for linkpaths into it */
     1116 			link_fmt_ln (2) = link_fmt_ln (2) + 2;
     1117 			end;
     1118 		     else do;			/* but if counts not being printed */
     1119 			substr (link_fmt (1), link_fmt_ln (1) + 1) = "^s";
     1120 						/* skip over the count argument */
     1121 			link_fmt_ln (1) = link_fmt_ln (1) + 2;
     1122 						/* in the first (and only) string */
     1123 			end;
     1124 
     1125 		     substr (link_fmt (1), link_fmt_ln (1) + 1) = "^2x^a";
     1126 						/* in either case, */
     1127 		     link_fmt_ln (1) = link_fmt_ln (1) + 5;
     1128 						/* put the link path format into the first string */
     1129 		     end;				/* end of if lkpathsw do group */
     1130 
     1131 /* Set up format for secondary names of links */
     1132 
     1133 		if ^prisw then do;			/* only if they will be printed */
     1134 		     if dtmsw then do;		/* if dtm being printed */
     1135 			name_fmt (0) = "^18x^a";	/* indent secondary names 18 spaces */
     1136 			name_fmt_ln (0) = 6;
     1137 			end;
     1138 		     else do;
     1139 			name_fmt (0) = "^2x^a";	/* otherwise, indent 2 spaces, just for readability */
     1140 			name_fmt_ln (0) = 5;
     1141 			end;
     1142 		     end;				/* end of if ^prisw do group */
     1143 		end;				/* end of if linksw do group */
     1144 	     end;					/* end of if ^totalsw do group */
     1145 
     1146 /* End of setting up of formats */
     1147 
     1148 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
     1149 
     1150 
     1151 /* Make adjustments for MSF/DMF ambiguity */
     1152 
     1153 	msf_count = tcount (MSF) - dmf_count;
     1154 	tcount (MSF) = msf_count;
     1155 	msf_rec_count = trecs (MSF) + dmf_rec_count;
     1156 	trecs (MSF) = msf_rec_count;
     1157 
     1158 /* Finished setting up. Now start printing the stuff */
     1159 
     1160 	if totalsw then do;				/* if only totals being printed */
     1161 	     if noheadsw
     1162 	     then goto brief_totals;			/* inconsistent - but why quibble? */
     1163 	     else if bfsw
     1164 		then				/* this is the correct way to say it */
     1165 brief_totals:
     1166 		     do;				/* ls -tt -bf gets a very brief (one line) answer */
     1167 			do tx = 1 to 5;
     1168 
     1169 			     msf_pass2 = (tx=3);
     1170 			     if msf_pass2 then do;
     1171 				tcount (MSF) = dmf_count;
     1172 				trecs (MSF) = dmf_rec_count;
     1173 				end;
     1174 
     1175 			     tpix = type_ix (tx);	/* segs, dirs, msfs, links */
     1176 			     if tsws (tpix) then do;	/* if user wants info on this entry type */
     1177 				if tcount (tpix) = 0
     1178 				then hdng_index = tpix;
     1179 						/* "<entry type>=0;" */
     1180 				else do;
     1181 				     hdng_index = tpix + 4;
     1182 						/* "<entry type>=^d,recs=^d;" */
     1183 				     if ^real_record_sw
     1184 				     then		/* if printing lengths rather than records */
     1185 					if hdng_index >= 5
     1186 					then	/* and this is a branch (5, 6, or 7) */
     1187 					     hdng_index = hdng_index + 11;
     1188 						/* use one of the "lths=" headings (16, 17, or 18) */
     1189 						/* but note that 17 is just "Dirs=^d;" */
     1190 				     end;
     1191 				call print_heading;
     1192 				end;		/* end this type wanted do group */
     1193 			end;			/* end do loop on tpix */
     1194 			ioa_control_string = "";
     1195 			call print_message;		/* put newline onto end of brief total line */
     1196 			goto return;		/* all done */
     1197 		     end brief_totals;
     1198 		else goto start_list;		/* go print normal totals */
     1199 	     end;
     1200 
     1201 	else if (noheadsw				/* if headers are not to be printed */
     1202 		| default_type) then do;		/* or if user did not specify type */
     1203 						/* make sure we are going to print some entries,
     1204*						   rather than nothing, or "<thing>s = 0" */
     1205 		do i = 0 to 3;
     1206 		     if tsws (i)
     1207 		     then				/* if user wants info on this type */
     1208 			if tcount (i) > 0
     1209 			then			/* and there are entries of this type */
     1210 			     goto start_list;	/* then something will be printed */
     1211 		end;
     1212 		if dmf_count > 0			/* special case DMFs here */
     1213 		then goto start_list;
     1214 
     1215 		if default_type
     1216 		then				/* if user did not say "ls -<entry type>" */
     1217 		     tsws (0), tsws (1), tsws (2), tsws (3) = "1"b;
     1218 						/* simulate "ls -tt -a -bf" */
     1219 		goto brief_totals;			/* we were about to print nothing, or "<thing>s = 0" */
     1220 		end;
     1221 
     1222 start_list:
     1223 	if branchsw then do;
     1224 	     if bc = 0 then do;
     1225 		ioa_control_string = "^/Branches = 0.";
     1226 		call print_message;
     1227 		end;
     1228 	     end;
     1229 	else if filesw then do;
     1230 		if tcount (SEG) + tcount (MSF) + dmf_count = 0 then do;
     1231 		     ioa_control_string = "^/Files = 0.";
     1232 		     call print_message;
     1233 		     end;
     1234 		end;
     1235 
     1236 /* Readjust MSF count for next loop */
     1237 
     1238 	tcount (MSF) = msf_count;
     1239 	trecs (MSF) = msf_rec_count;
     1240 
     1241 /* Start outer loop on entry types */
     1242 
     1243 type_loop:
     1244 	do tx = 1 to 5;
     1245 	     msf_pass2 = (tx=3);			/* second msf pass is for DMFs */
     1246 	     tpix = type_ix (tx);			/* list segs, msfs, dirs, and links, in that order */
     1247 	     if ^tsws (tpix) then goto end_type_loop;	/* if user does not want this entry type listed */
     1248 	     if tpix = MSF
     1249 	     then if msf_pass2
     1250 		then if ^pdmfilesw
     1251 		     then goto end_type_loop;
     1252 		     else;
     1253 		else if ^pmultisegsw
     1254 		     then goto end_type_loop;
     1255 		     else;
     1256 	     else;
     1257 
     1258 	     type = bit (fixed (tpix, 2));
     1259 
     1260 	     if msf_pass2 then do;
     1261 		tcount (MSF) = dmf_count;
     1262 		trecs (MSF) = dmf_rec_count;
     1263 		end;
     1264 
     1265 	     if noheadsw then goto no_heading;
     1266 	     if tcount (tpix) = 0 then do;
     1267 		if allsw then goto no_heading;	/* don't print ...=0 when -all given */
     1268 		if tpix > 0 then do;		/* branches */
     1269 		     if branchsw then goto no_heading;	/* don't print ...=0 when -branch given */
     1270 		     if tpix ^= DIR
     1271 		     then				/* if not directories */
     1272 			if filesw then goto no_heading;
     1273 						/* don't print ...=0 when -files given */
     1274 		     end;				/* end branches */
     1275 		hdng_index = tpix + 8;		/* "^/<entry type> = 0." */
     1276 		call print_heading;
     1277 		end;				/* end count = 0 do group */
     1278 
     1279 	     else do;				/* count ^= 0 */
     1280 		hdng_index = tpix + 12;		/* "^/<entry type> = ^d, Records = ^d.^2/" */
     1281 		if ^real_record_sw |		/* if printing lengths rather than records, or */
     1282 		     first > 0
     1283 		then				/* if just reading VTOCs of first N entries */
     1284 		     if hdng_index >= 13
     1285 		     then				/* and this is a branch (13, 14, or 15) */
     1286 			hdng_index = hdng_index + 6;	/* use the "Lengths =" headings (19, 20, or 21) */
     1287 						/* but note that 20 is just "Directories = ^d." */
     1288 		call print_heading;
     1289 		end;				/* end count ^= 0 */
     1290 
     1291 no_heading:					/* come here to skip printing of heading */
     1292 						/* Decide whether we have to go through the entries, on this pass. */
     1293 	     if totalsw then goto end_type_loop;	/* if -totals given, don't print entries */
     1294 
     1295 	     if tcount (tpix) = 0 then goto end_type_loop;/* if no entries of this type,
     1296*						   skip the inner loop to save time */
     1297 
     1298 /* We will go through all the entries. Initialize for it. */
     1299 
     1300 	     if branchsort then do;			/* if we sorted only on branches */
     1301 		if tpix = LINK then do;		/* links got put at the other end of the array */
     1302 		     first_et = first_lk;		/* so pick up indices of where they are */
     1303 		     last_et = last_lk;
     1304 		     end;
     1305 		else do;				/* this is a branch */
     1306 		     first_et = first_br;		/* pick up branch indices */
     1307 		     last_et = last_br;
     1308 		     end;
     1309 		end;				/* first_et and last_et are already set,
     1310*						   unless we sorted by branch only */
     1311 
     1312 	     n_listed = 0;				/* this makes "-first N" list first N of each type */
     1313 
     1314 /* Start inner loop on entries. Only those of the type specified in the outer loop will be listed. */
     1315 
     1316 list_entries:
     1317 	     do i = first_et to last_et;
     1318 		ix = sort_ix (i);			/* pick up index of entry to be listed in position "i" */
     1319 
     1320 		if br (ix).type ^= type
     1321 		then				/* if this entry is not the type we are listing now */
     1322 		     goto end_list_entries;		/* skip it */
     1323 
     1324 		if tpix = MSF
     1325 		then if msf_pass2
     1326 		     then				/* we are reporting DMFs */
     1327 			if br (ix).records >= 0	/* so skip MSFs */
     1328 			then
     1329 			     goto  end_list_entries;
     1330 			else br (ix).records = -br (ix).records;
     1331 		     else				/* we are reporting MSFs */
     1332 			if br (ix).records < 0	/* so skip DMFs */
     1333 			then
     1334 			     goto end_list_entries;
     1335 			else;
     1336 		else;
     1337 
     1338 		if first > 0
     1339 		then				/* if -first given */
     1340 		     if n_listed >= first
     1341 		     then				/* and we have already printed the first N of this type */
     1342 			goto end_type_loop;		/* get out of inner loop and start on next type */
     1343 		     else n_listed = n_listed + 1;
     1344 
     1345 		ni = br (ix).nindex;		/* get index to start of name array for this entry */
     1346 		nnames = br (ix).nname;		/* pick up count of names for this entry */
     1347 		nn = ni + nnames - 1;		/* compute index of last name for this entry */
     1348 
     1349 		if lnsw then do;			/* if listing nothing but names, special-case it */
     1350 		     if countsw
     1351 		     then				/* but if printing counts */
     1352 			if nnames > 1
     1353 			then			/* and count is nonzero */
     1354 			     goto not_just_names;	/* we can't special-case it */
     1355 		     ioa_control_string = "^a";
     1356 		     call print_name;
     1357 		     branch_fmt_ix = 1;		/* to select format for additional names */
     1358 		     goto additional_names;
     1359 		     end;
     1360 
     1361 not_just_names:					/* Format date(s) for both branches and links, if they are to be printed */
     1362 		ia = 1;				/* dtm is valid for branches and links */
     1363 		if tpix ^= LINK then do;
     1364 		     ia = 2;			/* dtu is valid only for branches */
     1365 		     if read_vtoc_sw
     1366 		     then				/* if we have to read the VTOC */
     1367 			if ^got_all_branch_info
     1368 			then			/* and we did not do it in get_list */
     1369 			     if tpix ^= MSF
     1370 			     then			/* (which we definitely did for an MSF) */
     1371 				call get_branch_info (ix);
     1372 						/* do it now */
     1373 		     end;
     1374 
     1375 		do ib = 1 to ia;
     1376 		     if colsw (ib)
     1377 		     then                               /* if this date is to be printed */
     1378 			cdate (ib) = date_time_$format (date_format, cv_fstime_ (et (ix).date (ib)), "", "");
     1379 		end;
     1380 
     1381 /* If this is a branch, print branch info */
     1382 
     1383 		if tpix ^= LINK then do;
     1384 
     1385 		     if modesw then do;		/* if printing modes, format them */
     1386 			if (type = "10"b) & (msf_bc = 0)
     1387 			then			/* if directory */
     1388 			     mode_ptr = addr (dir_mode);
     1389 						/* use "sma" */
     1390 			else mode_ptr = addr (file_mode);
     1391 						/* else use "rew" */
     1392 			mode = "";		/* blank out the mode string */
     1393 			ia, ib = 1;		/* input, output indices start at 1 */
     1394 			string (mode_bits) = et (ix).mode;
     1395 						/* copy mode bits into word in stack */
     1396 
     1397 mode_loop:
     1398 			if mode_bits (ia)
     1399 			then			/* if entry has this mode */
     1400 			     mode_array (ib) = et_mode (ia);
     1401 						/* put its character into the string */
     1402 next_col:
     1403 			ib = ib + 1;		/* move output column index */
     1404 			if ib = 4 then goto end_mode_loop;
     1405 						/* done, if we filled in 3 cols */
     1406 next_bit:
     1407 			ia = ia + 1;		/* move input bit index */
     1408 			if ia = 2 then do;		/* if bit 2 (e) */
     1409 			     if type = "10"b
     1410 			     then			/* if directory, e mode is not used */
     1411 				goto next_bit;	/* skip bit but not column */
     1412 			     end;
     1413 			goto mode_loop;		/* go back for next one */
     1414 end_mode_loop:
     1415 			end;
     1416 
     1417 		     if recordsw
     1418 		     then				/* if records to be printed */
     1419 			records = br (ix).records;	/* pick up record count */
     1420 
     1421 /* Pick up the format string for branches, built above. If printing counts,
     1422*   but this branch has only one name, chop the trailing "^2x(^d)" off the format,
     1423*   to avoid printing "(1)" after the primary name */
     1424 
     1425 		     branch_fmt_ix = 1;		/* use the format string for files */
     1426 		     if tpix = DIR
     1427 		     then				/* unless this is a directory */
     1428 			if recordsw
     1429 			then			/* and the records column is in the file format string */
     1430 			     if ^real_record_sw
     1431 			     then			/* but real records are not being printed */
     1432 				branch_fmt_ix = 2;	/* then use format string that omits records column for dirs */
     1433 
     1434 		     ia = branch_fmt_ln (branch_fmt_ix);/* don't chop off anything, by default */
     1435 		     if countsw
     1436 		     then				/* if printing counts */
     1437 			if nnames = 1
     1438 			then			/* but count = 1 */
     1439 			     ia = ia - 7;		/* chop off last 7 chars of format */
     1440 
     1441 		     ioa_control_string = substr (branch_fmt (branch_fmt_ix), 1, ia);
     1442 
     1443 		     call print_branch;		/* now go print the selected branch information */
     1444 		     end;				/* end of list branch information */
     1445 
     1446 /* Otherwise it is a link, so print link info */
     1447 
     1448 		else do;
     1449 		     if lkpathsw
     1450 		     then				/* if printing linkpaths */
     1451 			lp = addr (name (lk (ix).pnindex));
     1452 						/* get pointer to link pathname */
     1453 
     1454 /* Pick up the format string for links. Choose one of the two that were built above,
     1455*   depending on whether name count is being printed, and how many names the link has */
     1456 
     1457 		     ia = 1;			/* use the first format string */
     1458 		     if countsw
     1459 		     then				/* except when printing counts */
     1460 			if nnames = 1
     1461 			then			/* and the count = 1 */
     1462 			     ia = 2;		/* when the second format string must be used */
     1463 		     ioa_control_string = substr (link_fmt (ia), 1, link_fmt_ln (ia));
     1464 
     1465 		     call ioa_ (ioa_control_string, cdtm, name (ni), nnames, substr (lkpath, 1, lk (ix).pln));
     1466 		     end;				/* end list link info */
     1467 
     1468 additional_names:					/* do we want to print additional names ? */
     1469 		if ^prisw
     1470 		then				/* if user wants to see them */
     1471 		     if nnames > 1 then do;		/* and there are some, print them */
     1472 
     1473 /* Pick up the name format constructed above */
     1474 
     1475 			if tpix = LINK
     1476 			then			/* if this is a link */
     1477 			     ia = 0;		/* then use format (0) */
     1478 			else ia = branch_fmt_ix;	/* else use format (1) or format (2) */
     1479 			ioa_control_string = substr (name_fmt (ia), 1, name_fmt_ln (ia));
     1480 			do ni = (ni + 1) to nn;	/* ni is index of primary name, set above */
     1481 			     call print_name;
     1482 			end;
     1483 			end;
     1484 
     1485 end_list_entries:
     1486 	     end list_entries;			/* end inner loop (on i) over all entries */
     1487 
     1488 end_type_loop:
     1489 	end type_loop;				/* end outer loop (on tx) over the 4 entry types */
     1490 
     1491 return:
     1492 	if ^totalsw
     1493 	then					/* if we printed some entries (not just totals) */
     1494 	     if ^noheadsw then do;			/* and user did not say -no_header */
     1495 		ioa_control_string = "";		/* print an extra blank line at the end */
     1496 		call print_message;
     1497 		end;
     1498 
     1499 error_return:
     1500 	call cleanup_proc;				/* go free any allocated storage */
     1501 
     1502 	return;					/* return to caller */
     1503 
     1504 /* ****************************************************************************************************************** */
     1505 /**/
     1506 
     1507 
     1508 /* INTERNAL PROCEDURES, IN ALPHABETIC ORDER */
     1509 
     1510 
     1511 cleanup_proc:
     1512      proc;					/* Cleanup handler */
     1513 dcl  dummy based;
     1514 dcl  i fixed bin;
     1515 
     1516 	do i = 1 to hbound (aloc_ptr, 1);
     1517 	     if aloc_ptr (i) ^= null
     1518 	     then if aloc_ptr (i) ^= addr (stack_starnames) then free aloc_ptr (i) -> dummy in (system_free_area);
     1519 	end;
     1520 
     1521      end cleanup_proc;
     1522 
     1523 /* ****************************************************************************************************************** */
     1524 
     1525 
     1526 get_arg_ptr:
     1527      proc;					/* replaces 7 cu_$arg_ptr calls (105 words) */
     1528 
     1529 	if argno > 1
     1530 	then					/* if there was a previous argument */
     1531 	     errname = targ;			/* save it for possible error message */
     1532 
     1533 	call cu_$arg_ptr (argno, argptr, arglen, code);
     1534 	if code ^= 0 then do;			/* it can only be "expected argument missing" */
     1535 	     if argno > 1
     1536 	     then call com_err_ (code, "list", "after ""^a""", rtrim (errname));
     1537 	     else call com_err_ (code, "list");
     1538 
     1539 	     goto error_return;                          /* call cleanup_proc internal procedure and quit. */
     1540 	     end;
     1541 
     1542 	return;
     1543 
     1544      end get_arg_ptr;
     1545 
     1546 /* ****************************************************************************************************************** */
     1547 
     1548 
     1549 get_branch_info:
     1550      proc (ix);
     1551 
     1552 dcl  ix fixed bin;
     1553 dcl  (temp_ep, temp_np) ptr;
     1554 
     1555 	if ep -> br (ix).type = "00"b
     1556 	then					/* some times we get called for a link, by accident */
     1557 	     goto say_we_got_it;			/* when that happens, just return, to avoid clobbering anything */
     1558 	temp_ep = ep;				/* get pointer to array of directory entries */
     1559 	temp_np = np;				/* and their entry names */
     1560 
     1561 get_info_common:
     1562 	call hcs_$status_ (dirname, temp_np -> name (temp_ep -> br (ix).nindex), (0), addr (branch), null (), code);
     1563 	if code ^= 0 then do;
     1564 
     1565 	     if code = error_table_$logical_volume_not_connected | code = error_table_$logical_volume_not_defined
     1566 	     then	do;			          /* give up if pack not mounted */
     1567 		call com_err_ (code, "list", "^a", rtrim (dirname));
     1568 		goto error_return;                      /* call cleanup_proc internal procedure and quit */
     1569 		end;
     1570 
     1571 	     errname = temp_np -> name (temp_ep -> br (ix).nindex);
     1572 	     call com_err_ (code, "list", "^a in ^a", rtrim (errname), rtrim (dirname));
     1573 
     1574 	     code = 0;
     1575 	     goto say_we_got_it;			/* to avoid trying again later */
     1576 	     end;
     1577 
     1578 	if real_record_sw then temp_ep -> br (ix).records = branch.records;
     1579 
     1580 	if real_dtm_sw then temp_ep -> br (ix).dtm = branch.dtm;
     1581 						/* dtu is always the real thing */
     1582 	temp_ep -> br (ix).dtu = branch.dtu;
     1583 
     1584 say_we_got_it:
     1585 	got_branch_info = "1"b;
     1586 
     1587 	return;                                           /* return from get_branch_info */
     1588 
     1589 /* ********** */
     1590 
     1591 get_msf_records:
     1592      entry (ix);
     1593 
     1594 	temp_ep = msf_ep;				/* get pointer to array of msf components */
     1595 	temp_np = msf_np;				/* and their entry names */
     1596 
     1597 	goto get_info_common;
     1598 
     1599      end get_branch_info;
     1600 
     1601 /* ****************************************************************************************************************** */
     1602 
     1603 
     1604 get_date:
     1605      proc (date, from_to);				/* procedure to pick up and convert -from and -to dates */
     1606 dcl  date bit (36) aligned;
     1607 dcl  from_to char (*);
     1608 
     1609 dcl  1 clock aligned based,				/* the calendar clock is a 52-bit unsigned integer */
     1610        2 pad bit (20) unaligned,			/* only the high-order 36 bits are kept in the file system */
     1611        2 fstime bit (36) unaligned,			/* the truncation is 2**16 (=64K) microseconds (0.064 sec) */
     1612        2 pad2 bit (16) unaligned;			/* leaving a value that is accurate within about 0.1 second */
     1613 
     1614 
     1615 	argno = argno + 1;
     1616 	call get_arg_ptr;
     1617 	call convert_date_to_binary_ (targ, fb71, code);
     1618 	if code ^= 0 then goto badarg;
     1619 
     1620 /* The following code adjusts the from or to date as necessary, to make the
     1621*   date matching appear to be exact, to within the 0.1 minute accuracy with which
     1622*   file system date-times are printed. The problem is that every date-time value typed
     1623*   by the user will, if not adjusted somehow, be rounded down to the next lower
     1624*   tenth of a minute, by the truncation of its low order 16 bits during conversion
     1625*   to an fstime.
     1626*
     1627*   The from date is adjusted upward to produce the smallest fstime that will convert
     1628*   to its corresponding date-time string (e.g. a date-time ending in 1800.0 might
     1629*   be adjusted upward to 1800.0271828, so that it still converts to 1800.0 after
     1630*   being truncated, instead of converting to 1759.9).
     1631*
     1632*   The to date is adjusted upward to produce the largest fstime that will convert
     1633*   to its corresponding date-time string (e.g. 1800.0 might be adjusted upward
     1634*   to 1800.0999999, so that all date_times less than 1800.1 will compare <= to it,
     1635*   and be included in the listing). */
     1636 
     1637 	fb71 = fb71 - mod (fb71, 6000000);		/* first, round down to an exact 0.1 minute */
     1638 
     1639 	if from_to = "to" then do;			/* adjust to-date upward to next tenth of a minute */
     1640 	     fb71 = fb71 + 6000000;			/* in the unlikely event that this leaves 16 trailing zero bits */
     1641 	     fb71 = fb71 - 10000000000000000b;		/* truncation will not decrease its value  */
     1642 	     end;					/* so subtract 1 from fstime, and fall thru, to add it */
     1643 						/* back again, except when value ends in 16 zero bits. */
     1644 						/* ... */
     1645 						/* For both from and to dates, */
     1646 	if string (addr (fb71) -> clock.pad2) ^= ""b
     1647 	then					/* if there are any nonzero bits that will be truncated, */
     1648 	     fb71 = fb71 + 10000000000000000b;		/* add 1 to fstime. */
     1649 
     1650 	date = addr (fb71) -> clock.fstime;		/* convert 52-bit date to 36-bit date */
     1651 
     1652 	return;
     1653      end get_date;
     1654 
     1655 /* ****************************************************************************************************************** */
     1656 
     1657 get_list:
     1658      procedure;					/* procedure to list directory, do star matching, and sorting */
     1659 
     1660 dcl  type fixed bin;
     1661 dcl  pbl fixed bin (3);
     1662 
     1663 dcl  bitcnt fixed bin (24);
     1664 dcl  dirname_len fixed bin;
     1665 dcl  msename char (32);
     1666 
     1667 dcl  dir_ix fixed bin;
     1668 dcl  name_ix fixed bin;
     1669 dcl  star_ix fixed bin;
     1670 
     1671 dcl  br_ix fixed bin;
     1672 dcl  lk_ix fixed bin based (lk_ix_ptr);
     1673 dcl  lk_ix_ptr ptr;
     1674 dcl  lk_ix_automatic fixed bin;
     1675 dcl  ix_inc fixed bin;
     1676 dcl  f_t_ix fixed bin;
     1677 dcl  match_ix fixed bin;
     1678 dcl  action fixed bin;
     1679 dcl  (first_name, last_name) fixed bin;
     1680 
     1681 dcl  include_match bit (1) aligned;
     1682 dcl  matched bit (1) aligned;
     1683 dcl  count_other_types bit (1) aligned;
     1684 dcl  check_msf_sw bit (1) aligned;
     1685 dcl  skip_it bit (1) aligned;
     1686 dcl  all_starnames_matched bit (1) aligned;
     1687 dcl  from_to_found bit (1) aligned;
     1688 
     1689 /* Get full pathname of directory to be listed */
     1690 
     1691 	call absolute_pathname_ (substr (path, 1, pathl), dirname, code);
     1692 						/* if -pn not given, pathl=0, which implies working_dir */
     1693 						/* arg4 = null means put full path in dirname */
     1694 	if code ^= 0 then do;
     1695 	     error_flag = "1"b;                           /* set error flag before return to the caller */
     1696 
     1697 	     call com_err_ (code, "list", "^a", rtrim (path));
     1698 	     return;
     1699 	     end;
     1700 
     1701 	dirname_len = index (dirname, " ");		/* find first vacant char */
     1702 
     1703 /* Set up for, and call, hcs_$star_list */
     1704 	pbl = 3;					/* request branches and links no matter what user wants, so we
     1705*						   can handle "not found" and "directory empty" consistently. */
     1706 	if linksw
     1707 	then					/* check for link option */
     1708 	     if lkpathsw
     1709 	     then					/* if linkpaths wanted */
     1710 		if ^totalsw
     1711 		then				/* and they really will be printed */
     1712 		     pbl = pbl + 4;			/* ask star_list to return them */
     1713 	call star_list (dir_bc, dir_lc, ep, np);	/* go call hcs_$star_list */
     1714 
     1715 	if code ^= 0 then do;
     1716 	     error_flag = "1"b;			/* set error flag before return to the caller */
     1717 
     1718 	     if code = error_table_$nomatch then do;	/* since we said "**" this is an empty directory */
     1719 		ioa_control_string = "Directory empty: " || rtrim (dirname);
     1720 
     1721 		call print_message;			/* write on user_output, not error_output */
     1722 		end;
     1723 	     else call com_err_ (code, "list", "^a", rtrim (dirname));
     1724 
     1725 	     return;
     1726 	     end;					/* end code ^= 0 */
     1727 
     1728 	dir_ec = dir_bc + dir_lc;			/* compute total entries (branches + links) */
     1729 
     1730 /* Allocate array in which to put indices that select entries. It can hold all the entries (it is dir_ec elements long) */
     1731 	allocate sort_ix in (system_free_area) set (sort_index_ptr);
     1732 
     1733 /* Initialize for pass through all entries in directory, selecting those to be listed */
     1734 
     1735 	if branchsort then do;			/* if we will sort by a branch-only item */
     1736 	     lk_ix_ptr = addr (lk_ix_automatic);	/* put links out of the way, at the other end of the array */
     1737 	     first_br, first_et = 1;			/* first_et and last_et specify the entries to be sorted */
     1738 	     last_br, last_et = dir_bc;		/* later, they will be set to specify the entries to be printed */
     1739 	     first_lk = last_br + 1;
     1740 	     last_lk = dir_ec;
     1741 	     end;
     1742 
     1743 	else do;					/* otherwise intermix branches and links */
     1744 	     lk_ix_ptr = addr (br_ix);		/* by having br_ix and lk_ix actually be the same word */
     1745 	     first_br, first_lk, first_et = 1;
     1746 	     last_br, last_lk, last_et = dir_ec;
     1747 	     end;
     1748 
     1749 /* hcs_$star_list returns entries in the order created, oldest first.
     1750*   By default, we want to list them in the reverse of that order, newest first.
     1751*   Therefore we fill in the sort_ix array from right to left (reverse order),
     1752*   unless the user said -reverse, in which case we fill it in from left to right. */
     1753 
     1754 	if revsw then do;				/* if reverse, fill it in left to right */
     1755 	     br_ix = first_br - 1;			/* set indices to left of first entry */
     1756 	     lk_ix = first_lk - 1;
     1757 	     ix_inc = 1;				/* and increment to the right */
     1758 	     end;
     1759 
     1760 	else do;					/* fill it in from right to left */
     1761 	     br_ix = last_br + 1;			/* set indices to right of last entry */
     1762 	     lk_ix = last_lk + 1;
     1763 	     ix_inc = -1;				/* and increment to the left */
     1764 	     end;
     1765 
     1766 /* Set some switches */
     1767 	if default_type
     1768 	then					/* if user did not give any entry type arguments */
     1769 	     count_other_types = "1"b;		/* we want to be able to say "Files = 0. Links = N" */
     1770 	else count_other_types = "0"b;		/* if that happens. (Suggested by Jerry Saltzer) */
     1771 
     1772 	check_msf_sw = "1"b;			/* usually have to check all dirs to see if really msfs */
     1773 	if ^tsws (DIR)
     1774 	then					/* but if not listing dirs */
     1775 	     if ^tsws (MSF)
     1776 	     then					/* or msfs */
     1777 		check_msf_sw = "0"b;		/* we don't care, so skip it and save time */
     1778 
     1779 	if from_to_date_ix > 0
     1780 	then from_to_found = "0"b;			/* this is analogous to the matched switch for each starname */
     1781 	else from_to_found = "1"b;			/* it lets us say why nothing is being listed, if that happens */
     1782 
     1783 	if starname_count > 0
     1784 	then					/* if any starnames were given, we will check later */
     1785 	     all_starnames_matched = ""b;		/* to be sure they were all matched */
     1786 	else all_starnames_matched = "1"b;		/* if none given, skip over those checks */
     1787 
     1788 /* Go thru all entries in directory, doing star matching and other testing, to determine which ones will be listed */
     1789 
     1790 	do dir_ix = 1 to dir_ec;
     1791 	     type = bin (br (dir_ix).type);		/* pick up entry type */
     1792 
     1793 /* Note that we have not yet separated msfs from directories. We put that off as long as possible */
     1794 
     1795 /* Try to eliminate each entry as early as possible. Start with cheapest tests. */
     1796 
     1797 	     skip_it = "0"b;			/* assume entry will be listed, until we find a reason not to */
     1798 	     got_branch_info = ""b;			/* we have not read the VTOC for this branch yet */
     1799 
     1800 /* First, try to eliminate on basis of type */
     1801 
     1802 	     if ^check_msf_sw
     1803 	     then					/* if not listing dirs or msfs */
     1804 		if ^count_other_types
     1805 		then				/* and not counting them either */
     1806 		     goto check_type;		/* we could eliminate dirs without making msf check */
     1807 	     if type ^= DIR
     1808 	     then					/* otherwise we can't eliminate dirs, 'cause they might be msfs */
     1809 check_type:
     1810 		if ^tsws (type)
     1811 		then				/* if we are not listing this type */
     1812 		     if ^count_other_types
     1813 		     then				/* and not counting unlisted types */
     1814 			skip_it = "1"b;		/* we can probably skip the rest of the tests */
     1815 
     1816 /* Next, try from-to dates, if given */
     1817 
     1818 	     if skip_it
     1819 	     then					/* but get out of it if we can */
     1820 		if from_to_found
     1821 		then				/* if entries within given dates found (or none were given) */
     1822 		     goto skip_date_check;		/* then we can get out of it */
     1823 						/* otherwise we must check, to be able to print right err. msg. */
     1824 
     1825 	     if from_to_date_ix > 0 then do;		/* if either from or to was given */
     1826 		if type = LINK
     1827 		then				/* links have only DTM */
     1828 		     f_t_ix = DTM;
     1829 		else				/* branches have both */
     1830 		     f_t_ix = from_to_date_ix;	/* and which one to use was decided earlier */
     1831 
     1832 		if type ^= LINK
     1833 		then				/* if a branch */
     1834 		     if f_t_ix = 2 | real_dtm_sw then do;
     1835 						/* if using a date from the VTOC */
     1836 			call get_branch_info (dir_ix);
     1837 			got_all_branch_info = "1"b;	/* we will have, by the time we're through */
     1838 			end;
     1839 
     1840 		if fromsw
     1841 		then if et (dir_ix).date (f_t_ix) < from_date then do;
     1842 			skip_it = "1"b;
     1843 			goto skip_date_check;
     1844 			end;
     1845 		if tosw
     1846 		then if et (dir_ix).date (f_t_ix) > to_date then do;
     1847 			skip_it = "1"b;
     1848 			goto skip_date_check;
     1849 			end;
     1850 		from_to_found = "1"b;		/* at least one entry fell within the from-to dates */
     1851 		end;
     1852 skip_date_check:					/* Finally, try star matching */
     1853 	     if starname_count = 0
     1854 	     then					/* get out of it if we can */
     1855 		if skip_it
     1856 		then goto skip_entry;
     1857 		else goto keep_entry;
     1858 
     1859 	     if skip_it
     1860 	     then					/* if we already know we are skipping this entry */
     1861 		if all_starnames_matched
     1862 		then				/* and  we don't need to check for starnames not found */
     1863 		     goto skip_entry;		/* skip over star matching to save time */
     1864 
     1865 	     all_starnames_matched = "1"b;		/* gets turned off if we fail to match an unmatched starname */
     1866 
     1867 /* We will start comparing all the names of the entry with all the given starnames,
     1868*   but stop as soon as we know whether or not to list this entry. */
     1869 
     1870 	     if includesw
     1871 	     then					/* if any INCLUDE starnames were given */
     1872 		include_match = "0"b;		/* we have to turn this on by matching one of them */
     1873 	     else include_match = "1"b;		/* else pretend we matched one */
     1874 
     1875 /* Make starnames the outer loop for efficiency, in case the plan to optimize
     1876*   match_star_name_ for repeated calls using the same starname is ever implemented. */
     1877 
     1878 	     do star_ix = 1 to starname_count;		/* go thru all starnames */
     1879 		action = starnames (star_ix).action;	/* code might not be that much better */
     1880 		matched = starnames (star_ix).matched;	/* but "action" and "matched" are easier to type */
     1881 
     1882 		if action = EXCLUDE
     1883 		then				/* if this is an exclude starname */
     1884 		     if skip_it
     1885 		     then				/* and we already know we are skipping this entry */
     1886 			goto next_starname;		/* save time by skipping inner loop */
     1887 
     1888 /* Inner loop on names of entry */
     1889 
     1890 		first_name = br (dir_ix).nindex;
     1891 		last_name = first_name + br (dir_ix).nname - 1;
     1892 
     1893 		do name_ix = first_name to last_name;
     1894 		     if action = EXCLUDE then do;
     1895 			if names_match ()
     1896 			then			/* internal procedure to match the various types of starname */
     1897 			     skip_it = "1"b;	/* if they match, exclude this entry */
     1898 			end;
     1899 
     1900 		     else do;			/* action must = INCLUDE */
     1901 			if ^matched then goto try_include_match;
     1902 						/* if starname never been matched, keep trying */
     1903 			if ^skip_it
     1904 			then			/* if we have not already decided to skip this entry */
     1905 			     if ^include_match
     1906 			     then			/* but it hasn't matched any INCLUDE starname yet */
     1907 try_include_match:
     1908 				if names_match () then do;
     1909 						/* go see if this one matches */
     1910 				     include_match = "1"b;
     1911 						/* and remember it, if it matches */
     1912 				     starnames (star_ix).matched = "1"b;
     1913 						/* some entry matched this starname */
     1914 				     goto next_starname;
     1915 						/* no need to look at rest of entrynames */
     1916 				     end;
     1917 			end;
     1918 		end;				/* end inner loop on names of entry */
     1919 
     1920 		if ^starnames (star_ix).matched
     1921 		then				/* if this starname has never been matched */
     1922 		     all_starnames_matched = "0"b;	/* remember to keep trying to find a match for it */
     1923 
     1924 next_starname:
     1925 	     end;					/* end outer loop on starnames */
     1926 
     1927 	     if skip_it then goto skip_entry;		/* if we found a positive reason for skipping it */
     1928 	     if ^include_match then goto skip_entry;	/* or if it just did not match any of the INCLUDE starnames */
     1929 
     1930 /* come here if we THINK we want to keep the entry (still not completely sure) */
     1931 
     1932 keep_entry:
     1933 	     if type = DIR
     1934 	     then				          /* if a directory made it through all the above */
     1935 		call check_for_msf (type);		/* we can't get out of checking to see if it's an msf */
     1936 
     1937 	     if ^tsws (type)
     1938 	     then					/* if not listing this type */
     1939 		if ^count_other_types
     1940 		then				/* and not counting other types */
     1941 		     goto skip_entry;		/* skip the following to save time */
     1942 
     1943 /* This entry will be listed (or maybe just counted). Increment counts, and put its index into sort_ix array */
     1944 
     1945 	     tcount (type) = tcount (type) + 1;		/* count entries of this type */
     1946 
     1947 	     if tsws (type) then do;			/* if we are really going to list it */
     1948 		count_other_types = "0"b;		/* we no longer have to count other types (if we were doing so) */
     1949 		ec = ec + 1;			/* count number of entries really being listed */
     1950 
     1951 /* This do group implements -match */
     1952 
     1953 		if matchsw
     1954 		then				/* if only matching names are to be printed */
     1955 		     if br (dir_ix).nname > 1 then do;	/* and this entry has multiple names */
     1956 			match_ix = br (dir_ix).nindex;/* get index of its first name */
     1957 			do name_ix = match_ix to match_ix + br (dir_ix).nname - 1;
     1958 						/* go thru entry names */
     1959 			     do star_ix = 1 to starname_count;
     1960 						/* go thru starnames */
     1961 				if starnames (star_ix).action ^= EXCLUDE
     1962 				then		/* except for EXCLUDE names */
     1963 				     if names_match () then do;
     1964 						/* if name matches, keep it */
     1965 					if match_ix < name_ix
     1966 					then	/* if we removed any previous names */
     1967 					     name (match_ix) = name (name_ix);
     1968 						/* move this one up */
     1969 					match_ix = match_ix + 1;
     1970 						/* move index to next vacant position */
     1971 					goto kept_name;
     1972 						/* get out of loop on starnames */
     1973 					end;	/* end of "keep this name" do group */
     1974 			     end;			/* end loop on starnames */
     1975 kept_name:
     1976 			end;			/* end loop on entry names */
     1977 			br (dir_ix).nname = match_ix - br (dir_ix).nindex;
     1978 						/* save new name count */
     1979 			end;			/* end implementation of -match */
     1980 		end;				/* end of "really going to list it" do group */
     1981 
     1982 /* Increment counters, and store index, for branch or link, whichever this is */
     1983 
     1984 	     if type = LINK then do;
     1985 		if tsws (LINK) then do;		/* if we are really listing links and not just counting them */
     1986 		     lk_ix = lk_ix + ix_inc;
     1987 		     sort_ix (lk_ix) = dir_ix;	/* then store the index of this one */
     1988 		     lc = lc + 1;			/* and increment the really-being-listed counter for links */
     1989 		     end;
     1990 		end;
     1991 
     1992 	     else do;				/* branch */
     1993 
     1994 /* We want to avoid unnecessary VTOC reading. If a VTOC item is to be printed but -first N was given,
     1995*   we can sometimes get away with reading the VTOCEs of only the first N entries. If real records are to
     1996*   be printed, we can compute the total lengths from the bitcounts, for printing in the header, to avoid
     1997*   reading all the VTOCEs. Although this makes the figure printed in the header inconsistent, in a sense, with
     1998*   the figures printed for each entry, the saving is worth it - and the total length figure printed when
     1999*   -first N is given is not very useful anyway - only the total entries figure is interesting in that case.
     2000*
     2001*   However, if we have to sort by a VTOC item before we can determine which are the first N entries
     2002*   to be listed, we might as well read the VTOCEs now, and print a correct total records figure in the heading.
     2003*
     2004**/
     2005 
     2006 		if first = 0 | sort_vtoc_sw
     2007 		then				/* if -first not given, or sorting by VTOC item */
     2008 		     if real_record_sw
     2009 		     then				/* and real records are to be printed */
     2010 			if ^got_branch_info then do;	/* if we haven't already read the vtoc, do it now */
     2011 			     call get_branch_info (dir_ix);
     2012 						/* before updating total records */
     2013 			     got_all_branch_info = "1"b;
     2014 						/* we will have, before we're through */
     2015 			     end;
     2016 
     2017 		trecs (type) = trecs (type) + br (dir_ix).records;
     2018 						/* count records even if just counting */
     2019 		if tsws (type) then do;		/* but if really listing this type */
     2020 		     br_ix = br_ix + ix_inc;
     2021 		     sort_ix (br_ix) = dir_ix;	/* then store the index of this one */
     2022 		     bc = bc + 1;			/* and increment the really-being-listed counter for branches */
     2023 		     end;
     2024 		end;
     2025 skip_entry:
     2026 	end;					/* end loop on all entries */
     2027 
     2028 /* Tell user if anything was not found. */
     2029 
     2030 	if ^from_to_found then do;
     2031 	     error_flag = "1"b;                           /* set error flag before return to the caller */
     2032 
     2033 	     errname = "Entries within given dates";	/* "Entries within given dates not found" */
     2034 	     call print_not_found;
     2035 	     return;
     2036 	     end;
     2037 
     2038 
     2039 	if ^all_starnames_matched then do;		/* if there were any unmatched starnames */
     2040 						/* tell user, and check for nothing to list */
     2041 
     2042 	     if includesw
     2043 	     then					/* if any include starnames were given */
     2044 		include_match = "0"b;		/* assume none matched, until we find one that did */
     2045 	     else include_match = "1"b;		/* else pretend "**" was given, which always matches */
     2046 
     2047 	     do star_ix = 1 to starname_count;		/* look at all starnames */
     2048 		if starnames (star_ix).action ^= EXCLUDE then do;
     2049 						/* except EXCLUDE names */
     2050 		     if ^starnames (star_ix).matched then do;
     2051 						/* if it was never matched */
     2052 			errname = starnames (star_ix).name;
     2053 
     2054 			if starnames (star_ix).type = 0
     2055 			     then starname_count = 0; /* because no starname is specified */
     2056 
     2057 			call print_not_found;	/* "<starname> not found" */
     2058 			end;
     2059 		     else				/* if an INCLUDE name was matched */
     2060 			include_match = "1"b;	/* remember that we found one that was */
     2061 		     end;
     2062 	     end;
     2063 
     2064 	     if ^include_match then do;		/* if no INCLUDE names were matched */
     2065 		error_flag = "1"b;			/* nothing will be printed */
     2066 		return;
     2067 		end;
     2068 	     end;
     2069 
     2070 	if error_flag then return;			/* quit now if nothing to list */
     2071 	if ec = 0 then return;			/* or if only "<thing>s = 0" messages to print */
     2072 
     2073 /* Compute and store positions of the sets: branches, and links, in the sort_ix array,
     2074*   for use by sort, and by main printing loop */
     2075 
     2076 	if branchsort then do;			/* if we put links at the other end of the array */
     2077 	     if revsw then do;			/* if array was filled in left to right */
     2078 		last_et, last_br = br_ix;
     2079 		last_lk = lk_ix;
     2080 		end;
     2081 	     else do;				/* it was filled in right to left */
     2082 		first_et, first_br = br_ix;
     2083 		first_lk = lk_ix;
     2084 		end;
     2085 	     end;
     2086 
     2087 	else do;					/* links and branches mixed */
     2088 	     if revsw
     2089 	     then last_et, last_br, last_lk = br_ix;	/* left to right */
     2090 	     else first_et, first_br, first_lk = br_ix;	/* right to left */
     2091 	     end;
     2092 
     2093 	if sort_vtoc_sw
     2094 	then					/* if sorting by a vtoc item */
     2095 	     if ^got_all_branch_info then do;		/* and we have not read the VTOCs yet */
     2096 		do dir_ix = first_br to last_br;	/* do so now */
     2097 		     call get_branch_info (sort_ix (dir_ix));
     2098 		end;
     2099 		got_all_branch_info = "1"b;		/* remember not to do it again */
     2100 		end;
     2101 	if sortsw then call shell_sort;		/* default */
     2102 
     2103 	return;					/* normal return from get_list */
     2104 
     2105 /* ********** */
     2106 
     2107 
     2108 /* Note that these internal procedures are internal to get_list */
     2109 
     2110 check_for_msf: proc (para_type);
     2111 
     2112 /* procedure to see if a dir is really an msf, and if it is, count up     */
     2113 /* records used by its components, msf_ep and msf_np are declared in      */
     2114 /* the main procedure, so the cleanup handler can access them.            */
     2115 
     2116 dcl para_type fixed bin parameter;
     2117 
     2118 dcl MSF_COMPONENT_ZERO fixed bin static options (constant) init (0);
     2119 
     2120 dcl  msf_lc fixed bin;
     2121 dcl  xcode fixed bin (35);				/* for local status processing */
     2122 dcl  msf_dir_count fixed bin init (0);
     2123 dcl  msf_rec_count fixed bin;				/* no need to init this - it starts out = rec count of dir */
     2124 dcl  k fixed bin;
     2125 dcl (raw_mode, ex_mode) bit (36) aligned;
     2126 dcl temp_dir_ec fixed bin;                                  /* for MSF, this variable temporarily holds the dir_ec value to avoid */
     2127                                                             /* subcriptrange in et array after updating dir_ec in star_list */
     2128 
     2129 dcl component_name char (32) varying;
     2130 dcl msf_last_component fixed bin;
     2131 dcl msf_index fixed bin;
     2132 
     2133 dcl 1 msf_info aligned,				/* status for MSF components */
     2134      2 type bit (2) unaligned,
     2135      2 nnames bit (16) unaligned,
     2136      2 names_offset bit (18) unaligned,
     2137      2 dtcm bit (36) unaligned,
     2138      2 dtu bit (36) unaligned,
     2139      2 mode bit (5) unaligned,
     2140      2 pad bit (13) unaligned,
     2141      2 records fixed bin (17) unaligned,
     2142      2 dtd bit (36) unaligned,
     2143      2 dtem bit (36) unaligned,
     2144      2 pad3 bit (36) unaligned,
     2145      2 current_length fixed bin (11) unaligned,
     2146      2 bit_count bit (24) unaligned,
     2147      2 pad2 bit (18) unaligned,
     2148      2 rbs (0:2) fixed bin (5) unaligned,
     2149      2 pad4 bit (36) unaligned;
     2150 
     2151 dcl hcs_$status_long entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
     2152 
     2153 dcl (convert, ltrim) builtin;
     2154 	
     2155                                                             /* set variables to initial values to avoid unexpected values */
     2156 	     temp_dir_ec = 0;
     2157 	     msf_bc = 0;
     2158 
     2159 	     msename = name (br (dir_ix).nindex);	/* pick up its name, for status_minf call */
     2160 
     2161 	     call hcs_$status_minf (dirname, msename, 0, (0), bitcnt, xcode);
     2162 	     if xcode = 0
     2163 	     then					/* Could have disappeared, if so say it's a dir */
     2164 		if bitcnt ^= 0 then do;		/* non-zero bit-count indicates multi-segment-file */
     2165 
     2166 		     if ^tsws (MSF) then goto set_msftype;
     2167 						/* if not listing msfs, don't count recs, just set type */
     2168 
     2169 		     if read_vtoc_sw
     2170 		     then				/* if using anything from vtoc, possibly including records */
     2171 			if ^got_branch_info
     2172 			then			/* and we have not already read the VTOC */
     2173 			     call get_branch_info (dir_ix);
     2174 						/* do it, before computing msf size */
     2175 		     msf_rec_count = br (dir_ix).records;
     2176 						/* get size of msf directory */
     2177 
     2178 						/* build pathname of msf dir for star_list call */
     2179 		     substr (dirname, dirname_len, 1) = ">";
     2180 		     substr (dirname, dirname_len + 1, 32) = msename;
     2181 		     pbl = 2;			/* branches only */
     2182 		     temp_dir_ec = dir_ec;
     2183 		     
     2184 		     call star_list (msf_bc, msf_lc, msf_ep, msf_np);
     2185 		     if code ^= 0 then do;		/* Check for errors */
     2186 			if code ^= error_table_$nomatch
     2187 			then if code ^= error_table_$null_dir then do;
     2188 				call file_manager_$validate (substr (dirname, 1, dirname_len-1), msename, xcode);
     2189 				if xcode ^= 0
     2190 				then do;
     2191 				     msf_rec_count = 0;
     2192 				     code = 0;
     2193 				     end;
     2194 				else do;
     2195 				     dmf_count = dmf_count + 1;
     2196 				     dmf_rec_count = dmf_rec_count + br (dir_ix).records;
     2197 				     msf_rec_count = -br (dir_ix).records;
     2198 				     call fs_util_$get_user_access_modes (substr (dirname, 1, dirname_len-1), msename, "",
     2199 					- 1, raw_mode, ex_mode, xcode);
     2200 				     if xcode = 0 then et (dir_ix).mode = substr (raw_mode, 1, 3);
     2201 				     end;
     2202 				end;
     2203 			goto msfempty;
     2204 			end;
     2205 		     else do;
     2206 			                              /* extract the mode of a MSF from the mode of MSF component 0 */
     2207 		          call hcs_$get_user_access_modes (dirname, "0", "", -1,
     2208 			     raw_mode, ex_mode, xcode);
     2209 			if xcode = 0 then do;
     2210 			     dir_ec = temp_dir_ec;    /* restore the limit index of et array which was saved earlier */
     2211 
     2212 			     et (dir_ix).mode = substr (raw_mode, 1, 3);
     2213 			     end;
     2214 
     2215 			if msf_bc > 0 then do;
     2216                                                             /* currently, got MSF directory's dtm and dtu values. */
     2217                                                             /* But we want MSF component's dtm and dtu information. */
     2218                                                             /* So, must reset these flags before loading MSF component's dtm and dtu */
     2219 			     br (dir_ix).dtm = "0"b;
     2220 			     br (dir_ix).dtu = "0"b;
     2221 
     2222 			     msf_last_component = msf_bc - 1;
     2223 			     do msf_index = MSF_COMPONENT_ZERO to msf_last_component;
     2224 
     2225                                                            /* call hcs_$status_long to get most user_accessible informattion */
     2226                                                            /* about a specified MSF component */
     2227 			                             /* if the returned code is not zero in value then go get */
     2228                                                            /* the next msf component.  Do not return to the caller. */
     2229 				component_name = convert (component_name, msf_index);
     2230 				component_name = ltrim (component_name);
     2231 
     2232 				call hcs_$status_long (dirname, (component_name), 1, addr (msf_info), null, code);
     2233 				if code = 0
     2234 				then do;
     2235 				     if real_dtm_sw
     2236 				     then do;
     2237 					if fixed (msf_info.dtcm) > fixed (br (dir_ix).dtm)
     2238 					then br (dir_ix).dtm = msf_info.dtcm;
     2239 					end;
     2240 
     2241 				     if dtem_arg_sw
     2242 				     then do;
     2243 					if fixed (msf_info.dtem) > fixed (br (dir_ix).dtm)
     2244 					then br (dir_ix).dtm = msf_info.dtem;
     2245 					end;
     2246 
     2247 				     if fixed (msf_info.dtu) > fixed (br (dir_ix).dtm)
     2248 				     then br (dir_ix).dtu = msf_info.dtu;
     2249 				     end;
     2250 				end;               /* go get the next MSF component */
     2251 			     end;                    /* specified entryname is a MSF */
     2252 			end;                         /* else do */
     2253 
     2254 		     do k = 1 to msf_bc;
     2255                                                            /* if msf contains director(y ies) then count how many */
     2256 			if msf_ep -> br (k).type = "10"b
     2257 			then msf_dir_count = msf_dir_count + 1;
     2258 
     2259 				                   /* if using real records then go read vtoc of msf component */
     2260 			if real_record_sw
     2261 			then call get_msf_records (k);
     2262 
     2263 					        /* add up length of this msf component */
     2264 			msf_rec_count = msf_rec_count + msf_ep -> br (k).records;
     2265 	               end;
     2266 
     2267 		     if msf_dir_count > 0 then do;	/* if msf contained director(y ies) */
     2268 			code = 0;
     2269 			call com_err_ (code, "list", "Multisegment-file: ^a contains director^[y^;ies^].", rtrim (msename), msf_dir_count = 1);
     2270 			end;
     2271 
     2272 		     free msf_ep -> br in (system_free_area);
     2273 		     free msf_np -> name in (system_free_area);
     2274 
     2275 msfempty:
     2276 		     substr (dirname, dirname_len, 33) = "";
     2277 						/* blank out msf name */
     2278 		     br (dir_ix).records = msf_rec_count;
     2279 						/* store total msf length */
     2280 
     2281 set_msftype:
     2282                                                             /* set type to msf in the branch array entry for this branch */
     2283 		     br (dir_ix).type = bit (fixed (MSF, 2));
     2284 		     para_type = 3;			/* also set the variable used by the caller (get_list) */
     2285 		     end;				/* end it-was-an-msf do group */
     2286 
     2287 	     return;
     2288 	end check_for_msf;
     2289 
     2290 /* ********** */
     2291 
     2292 
     2293 in_order:
     2294 	proc (ix1, ix2) returns (bit (1) aligned);
     2295 
     2296 dcl  (ix1, ix2) fixed bin;
     2297 
     2298 	     goto comparison (sort_key);		/* go compare the thing to be sorted on */
     2299 
     2300 comparison (1):					/* dtm */
     2301 						/* normal order for dates is high to low (newest to oldest) */
     2302 	     if br (ix2).dtm > br (ix1).dtm
     2303 	     then					/* if they are reversed */
     2304 		goto items_reversed;
     2305 	     else goto items_in_order;
     2306 
     2307 comparison (2):					/* dtu */
     2308 						/* normal order for dates is high to low (newest to oldest) */
     2309 	     if br (ix2).dtu > br (ix1).dtu
     2310 	     then goto items_reversed;
     2311 	     else goto items_in_order;
     2312 
     2313 comparison (3):					/* mode */
     2314 						/* it is not clear what the right order for modes is */
     2315 	     if string (br (ix1).mode) > string (br (ix2).mode)
     2316 	     then					/* but this puts null (blank) first */
     2317 		goto items_reversed;		/* rew or sma last */
     2318 	     else if string (br (ix2).mode) = string (br (ix1).mode)
     2319 		then				/* and rw before re */
     2320 		     goto return_in_order;		/* if equal, do not reorder */
     2321 		else goto items_in_order;
     2322 
     2323 comparison (4):					/* records */
     2324 						/* normal order for records is high to low (large to small) */
     2325 	     if br (ix2).records > br (ix1).records
     2326 	     then					/* if they are out of order */
     2327 		goto items_reversed;		/* go see if we want them that way */
     2328 	     else if br (ix2).records = br (ix1).records
     2329 		then				/* check for equality (which is likely with records) */
     2330 		     goto return_in_order;		/* if equal, do not reorder */
     2331 		else goto items_in_order;
     2332 
     2333 comparison (5):					/* name */
     2334 						/* normal order for names is low to high (a to z) */
     2335 	     if name (br (ix1).nindex) > name (br (ix2).nindex)
     2336 	     then					/* if they are reversed */
     2337 		goto items_reversed;		/* go see if we want them that way */
     2338 	     else goto items_in_order;		/* names will never be equal */
     2339 
     2340 comparison (6):					/* count */
     2341 						/* normal order for count is high to low (most names to fewest) */
     2342 	     if br (ix2).nname > br (ix1).nname
     2343 	     then					/* if they are reversed */
     2344 		goto items_reversed;
     2345 	     else if br (ix2).nname = br (ix1).nname
     2346 		then				/* if they are equal */
     2347 		     goto return_in_order;		/* if equal, do not reorder */
     2348 		else goto items_in_order;
     2349 
     2350 
     2351 items_reversed:
     2352 	     if revsw
     2353 	     then goto return_in_order;
     2354 	     else goto return_out_of_order;
     2355 
     2356 items_in_order:
     2357 	     if revsw
     2358 	     then
     2359 return_out_of_order:
     2360 		return ("0"b);
     2361 	     else
     2362 return_in_order:
     2363 		return ("1"b);
     2364 
     2365 	end in_order;
     2366 
     2367 /* ********** */
     2368 
     2369 
     2370 /* The code in this internal procedure could be written more compactly as something like
     2371*   the following, which more closely resembles the Knuth algorithm (see comments in shell_sort).
     2372*   However, the generated code would waste a lot of time doing bookkeeping, as
     2373*   noted in the comments, and that overhead has been avoided by the hand-coded
     2374*   logic that has been used.
     2375**/
     2376 
     2377 /*     do j = first_et+h to last_et;			/* add h to first_et to get j */
     2378 /*	ix2 = sort_ix (j);				/* */
     2379 /*	do i = j-h repeat i-h			/* subtract h each time around the loop */
     2380 /*	   while (i >= first_et			/* if i<first_et, sort_ix(i) is garbage, but pl1 keeps */
     2381 /*						/* evaluating "and" expressions after finding a false term */
     2382 /*	   & ^in_order (sort_ix (i), ix2));		/* if in order on first try, all the do loop bookkeeping */
     2383 /*						/* was a waste of time */
     2384 /*	   sort_ix (i+h) = sort_ix (i);		/* add h back again */
     2385 /*	end;					/* */
     2386 /*	sort_ix (i+h) = ix2;			/* add h back again */
     2387 /*     end;					/* */
     2388 
     2389 
     2390 insertion_sort:
     2391 	proc (h);
     2392 
     2393 dcl  h fixed bin;					/* >1 for early shell sort passes */
     2394 
     2395 dcl  (i, j, k) fixed bin;
     2396 dcl  (ix1, ix2) fixed bin;
     2397 
     2398 	     i = first_et;				/* position of first entry in sort_ix */
     2399 	     ix1 = sort_ix (i);			/* index of first entry */
     2400 
     2401 	     do j = first_et + h to last_et;		/* look at each entry to right of first */
     2402 		k = j;				/* remember its (soon to be vacant) position */
     2403 		ix2 = sort_ix (j);			/* pick up its index */
     2404 
     2405 compare:
     2406 		if ^in_order (ix1, ix2) then do;	/* if it's not in order with the one on its left */
     2407 		     sort_ix (k) = ix1;		/* move the latter to the right, into the vacant position */
     2408 		     k = i;			/* the vacant position is now where we moved it from */
     2409 		     i = i - h;			/* look further to the left */
     2410 		     if i >= first_et then do;	/* if not past left end of array, keep going */
     2411 			ix1 = sort_ix (i);		/* pick up index of new entry */
     2412 			goto compare;		/* and go compare it with one we're trying to find a place for */
     2413 			end;			/* fall thru if at left end of array */
     2414 		     end;				/* fall thru if it's in order with the one on the left */
     2415 
     2416 		if j ^= k then do;			/* save time by doing this only if we moved something */
     2417 		     sort_ix (k) = ix2;		/* store it in the vacant spot */
     2418 		     ix1 = sort_ix (j);		/* index of entry to left of next sort_ix(j) */
     2419 						/* (if at top of loop, would be "ix1=sort_ix(j-h)") */
     2420 		     end;
     2421 		else ix1 = ix2;			/* if we did not move anything */
     2422 		i = j;				/* index of entry to left of next sort_ix(j) */
     2423 						/* (if at top of loop, would be "i=j-1") */
     2424 	     end;					/* end loop on j. go back for next one to the right */
     2425 
     2426 	     return;
     2427 	end insertion_sort;
     2428 
     2429 /* ********** */
     2430 
     2431 names_match:
     2432 	proc returns (bit (1) aligned);		/* procedure to see if one starname matches one entry name */
     2433 						/* implicit arguments are star_ix and name_ix */
     2434 dcl  star_code fixed bin (35);
     2435 
     2436 	     if starnames (star_ix).type = DOUBLE_STAR
     2437 	     then goto match;
     2438 
     2439 	     else if starnames (star_ix).type = ENTRY_NAME then do;
     2440 		     if starnames (star_ix).name = name (name_ix) then goto match;
     2441 		     end;
     2442 
     2443 
     2444 		else do;				/* must be regular starname */
     2445 		     call match_star_name_ (name (name_ix), starnames (star_ix).name, star_code);
     2446 		     if star_code = 0 then goto match;
     2447 		     end;
     2448 
     2449 nomatch:
     2450 	     return ("0"b);				/* no match */
     2451 match:
     2452 	     return ("1"b);
     2453 	end names_match;
     2454 
     2455 /* ********** */
     2456 
     2457 shell_sort:
     2458 	proc;
     2459 
     2460 dcl  (n, incr, next_incr) fixed bin;
     2461 
     2462 /* This sorting algorithm is taken from Knuth, The Art of Computer Programming,
     2463*   Volume 3, "Sorting and Searching", pp. 80-95 and p. 379.
     2464*   The Shell sort is Algorithm 5.2.1D (Diminishing increment sort) on p. 85.
     2465*   The internal procedure, insertion_sort (see above) is the inner loop of 5.2.1D,
     2466*   which also happens to be Algorithm 5.2.1S (Straight insertion sort),
     2467*   generalized for use as the inner loop of the Shell sort.
     2468*
     2469*   The increment computation is taken from equation (8) on p 95:
     2470*
     2471*   "Let h(1)=1, h(s+1) = 3*h(s)+1, and stop with h(t) when h(t+2) >= N. (8)"
     2472*
     2473*   we use incr for h(s),
     2474*   next_incr for h(s+1),
     2475*   and we stop with next_incr=h(t+2) and incr=h(t+1),
     2476*   but then we decrement from h(t+1) to h(t) before the first call to insertion_sort.
     2477*
     2478**/
     2479 
     2480 	     n = last_et - first_et + 1;		/* compute number of entries to be sorted */
     2481 	     incr = 4;				/* compute initial increment */
     2482 	     next_incr = 13;			/* the first few are: 1,4,13,40,121,364,1092,3820,9841 */
     2483 	     do while (next_incr < n);		/* Knuth recommends the Shell sort for up to 1000 items (p.379) */
     2484 		incr = next_incr;			/* directories with more than 1000 items are very rare */
     2485 		next_incr = 3 * next_incr + 1;	/* (if not completely non-existent) */
     2486 	     end;					/* so 121 will be the largest increment used */
     2487 
     2488 	     do while (incr > 1);			/* the last insertion sort is done with incr = 1 */
     2489 		incr = divide (incr - 1, 3, 17, 0);	/* decrease incr from h(s) to h(s-1) */
     2490 		call insertion_sort (incr);		/* do an insertion sort using that increment */
     2491 	     end;					/* if we just sorted with incr = 1, the array is in order */
     2492 	     return;
     2493 	end shell_sort;
     2494 
     2495 /* ********** */
     2496 
     2497 star_list:
     2498 	proc (star_bc, star_lc, star_ep, star_np);	/* replaces 2 hcs_$star_list calls (80 words) */
     2499 
     2500 dcl  (star_bc, star_lc) fixed bin;
     2501 dcl  (star_ep, star_np) ptr;
     2502 dcl  i fixed bin;
     2503 
     2504 	     call hcs_$star_dir_list_ (dirname, "**", pbl, system_free_ptr, star_bc, star_lc, star_ep, star_np, code);
     2505 	     if code = 0
     2506 	     then do;				/* caller checks code so just avoid referencing bad ptrs here */
     2507 	          dir_ec = star_bc + star_lc;
     2508 		do i = 1 to star_bc + star_lc;
     2509 		     if star_ep -> br (i).type ^= "00"b
     2510 		     then				/* if not link */
     2511 			star_ep -> br (i).records = divide (star_ep -> br (i).records + 36863, 36864, 24, 0);
     2512 		     end;
     2513 		end;
     2514 	     return;
     2515 	end star_list;
     2516 
     2517      end get_list;
     2518 
     2519 /* ****************************************************************************************************************** */
     2520 
     2521 
     2522 get_starname:
     2523      proc;					/* procedure to pick up, interpret, and store, a starname */
     2524 
     2525 
     2526 	if starptr = addr (stack_starnames)
     2527 	then					/* if we are still using the stack starnames array */
     2528 	     if starname_count = hbound (stack_starnames, 1) then do;
     2529 						/* but we have run out of room in it */
     2530 		alloc_len = nargs - argno + 5;	/* allocate a bigger one - with enough room for this arg, the
     2531*						   first 4, and all the rest, in case they are all starnames */
     2532 
     2533 		allocate starnames in (system_free_area) set (starptr);
     2534 		do i = 1 to hbound (stack_starnames, 1);
     2535 		     starnames (i) = addr (stack_starnames) -> starnames (i);
     2536 		end;
     2537 		end;
     2538 
     2539 	starname_count = starname_count + 1;
     2540 	starnames (starname_count).type = 0;
     2541 	starnames (starname_count).action = 0;
     2542 	starnames (starname_count).matched = "0"b;
     2543 
     2544 	if search (targ, "<>") > 0 then do;		/* see if it is a pathname */
     2545 	     call expand_pathname_ (targ, dirname, starnames (starname_count).name, code);
     2546 	     if code ^= 0 then goto badarg;
     2547 	     if pathsw
     2548 	     then					/* if a directory path already given */
     2549 		if path ^= dirname
     2550 		then				/* and this one is different */
     2551 		     goto two_pn_error;		/* go complain */
     2552 	     path = dirname;			/* save directory path */
     2553 	     pathsw = "1"b;				/* remember that we got one */
     2554 	     pathl = length (rtrim (path, " "));
     2555 	     starnames (starname_count).length = length (rtrim (starnames (starname_count).name, " "));
     2556 	     if path = ">" & starnames (starname_count).length = 0 then do;
     2557 		code = error_table_$root;
     2558 		goto badarg;
     2559 		end;
     2560 	     end;
     2561 
     2562 	else do;
     2563 	     starnames (starname_count).name = targ;
     2564 	     starnames (starname_count).length = arglen;
     2565 	     end;
     2566 
     2567 	if starnames (starname_count).length > 32 then do;
     2568 	     code = error_table_$bigarg;
     2569 	     goto badarg;
     2570 	     end;
     2571 
     2572 	call check_star_name_$entry (starnames (starname_count).name, code);
     2573 	if code > DOUBLE_STAR then goto badarg;		/* bad starname - code will produce message */
     2574 	starnames (starname_count).type = code;
     2575 
     2576 	return;
     2577      end get_starname;
     2578 
     2579 /* ****************************************************************************************************************** */
     2580 
     2581 
     2582 print_branch:
     2583      proc;					/* replaces 4 ioa_ calls (122 words) */
     2584 	call ioa_ (ioa_control_string, cdtm, cdtu, mode, records, np -> name (ni), nnames);
     2585 
     2586 	return;
     2587      end print_branch;
     2588 
     2589 /* ****************************************************************************************************************** */
     2590 
     2591 
     2592 print_heading:
     2593      proc;					/* replaces 12 ioa_ calls (200 words) */
     2594 	if msf_pass2
     2595 	then
     2596 	     ioa_control_string = rtrim (dmf_control_string (hdng_index));
     2597 	else
     2598 	     ioa_control_string = substr (string (hdng), hdng_offset (hdng_index), hdng_len (hdng_index));
     2599 	if hdng_index >= 8 & hdng_index < 12
     2600 	then					/* if heading is ... = 0. */
     2601 	     call print_message;			/* don't bother passing count and recs args */
     2602 	else call ioa_$nnl (ioa_control_string, tcount (tpix), trecs (tpix));
     2603 
     2604 	return;
     2605      end print_heading;
     2606 
     2607 /* ****************************************************************************************************************** */
     2608 
     2609 
     2610 print_message:
     2611      proc;					/* replaces 11 ioa_ calls (140 words) */
     2612 	call ioa_ (ioa_control_string);
     2613 
     2614 	return;
     2615      end print_message;
     2616 
     2617 /* ****************************************************************************************************************** */
     2618 
     2619 
     2620 print_name:
     2621      proc;					/* replaces 5 ioa_ calls (85 words) */
     2622 	call ioa_ (ioa_control_string, name (ni));
     2623 
     2624 	return;
     2625      end print_name;
     2626 
     2627 /* ****************************************************************************************************************** */
     2628 
     2629 
     2630 print_not_found:
     2631      proc;					/* procedure to print "<starname> not found [in <dirname>]" */
     2632 
     2633 	not_found_count = not_found_count + 1;
     2634 
     2635 	if starname_count > 0
     2636 	then message = "Use of star convention resulted in no match.  ^a";
     2637 	else message = """^a"" not found";
     2638 
     2639 	if not_found_count = 1 then do;		/* only call com_err_ and print dir for first one */
     2640 	     if pathsw
     2641 	     then do;				/* if user gave -pn arg */
     2642 		message = message || " in ^a";	/* put dir in message (user might have typed wrong dir) */
     2643 		call com_err_ (code, "list", message, rtrim (errname), rtrim (dirname));
     2644 		end;
     2645 	     else do;
     2646 		if message ="""^a"" not found"
     2647 		then message = message || ".";          /* for readable purpose, this error message is terminated by a period. */
     2648 
     2649 		call com_err_ (code, "list", message, rtrim (errname));
     2650 		end;
     2651 	     end;
     2652 
     2653 	else do;
     2654 	     if message = """^a"" not found"
     2655 	     then message = message || ".";               /* for readable purpose, this error message is terminated by a period. */
     2656 
     2657 	     call ioa_$ioa_switch (iox_$error_output, message, rtrim (errname));
     2658 						/* put all "not found" messages on same stream - error_output */
     2659 	     end;
     2660 
     2661 	return;
     2662      end print_not_found;
     2663 
     2664 /* ****************************************************************************************************************** */
     2665 
     2666 
     2667 set_branch_fmt:
     2668      proc (ix);
     2669 
     2670 dcl  ix fixed bin;
     2671 dcl  fmtx fixed bin;
     2672 
     2673 	fmtx = 4;					/* skip leading ^Nx of 1st col fmt to not indent whole thing */
     2674 	name_indent = 0;				/* initialize */
     2675 	do i = 1 to CT;				/* check switch for each column, up to count column */
     2676 	     if colsw (i) then do;			/* if we will print it, put its format into the string */
     2677 		substr (branch_fmt (ix), branch_fmt_ln (ix) + 1) = substr (col_fmt (i), fmtx);
     2678 		branch_fmt_ln (ix) = branch_fmt_ln (ix) + col_fmt_ln (i) + 1 - fmtx;
     2679 		if i < 3				/* plug in the current date/time width */
     2680 		then do;
     2681 		     substr (branch_fmt (ix), branch_fmt_ln (ix) -2, 2) = convert (dt_len_pic, dt_len);
     2682 		     name_indent = name_indent + dt_len + 2;
     2683 	          end;
     2684 		else if i=3
     2685 		then name_indent = name_indent + 5;
     2686 		else if i=4
     2687 		then name_indent = name_indent + 5;
     2688 		fmtx = 1;				/* pick up leading ^Nx of subsequent col fmts to separate cols */
     2689 		end;
     2690 	     else do;				/* if we will not print it, use "^s" to skip it */
     2691 		substr (branch_fmt (ix), branch_fmt_ln (ix) + 1) = "^s";
     2692 		branch_fmt_ln (ix) = branch_fmt_ln (ix) + 2;
     2693 		end;
     2694 	end;
     2695 
     2696 /* Set up format for printing secondary names of branches, lined up under
     2697*   the primary name, or indented 2 spaces if only names are being printed */
     2698 
     2699 	if ^prisw then do;				/* skip it if only primary names are to be printed */
     2700 	     if name_indent=5
     2701 	     then if modesw				/* if it is just mode, indent by 2 so user can distinguish */
     2702 	        then name_indent = 7;			/* secondary names from segments with null access */
     2703 	        else name_indent = 6;			/* for just records, adjust slightly */
     2704 
     2705 	else if name_indent = 0 then name_indent = 2;	/* when only names are printed, indent addnames */
     2706 
     2707 	     substr (name_fmt (ix), 1) = "^__x";
     2708 	     substr (name_fmt (ix), 2, 2) = convert (dt_len_pic, name_indent);
     2709 						/* how many spaces to indent */
     2710 	     name_fmt_ln (ix) = 4;			/* all of the format strings are 4 chars */
     2711 	     substr (name_fmt (ix), name_fmt_ln (ix) + 1) = "^a";
     2712 						/* to print the name */
     2713 	     name_fmt_ln (ix) = name_fmt_ln (ix) + 2;
     2714 	     end;
     2715 
     2716 	return;
     2717 
     2718      end set_branch_fmt;
     2719 
     2720 /* ****************************************************************************************************************** */
     2721 
     2722      end list;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/17/00  1938.5  list.pl1                          >udd>sm>ds>w>ml>list.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CT                                     constant        fixed bin(17,0)          initial dcl 278 ref 863 2675
DEFAULT                                constant        fixed bin(17,0)          initial dcl 267 ref 959
DIR                                    constant        fixed bin(17,0)          initial dcl 106 ref 1270 1426 1773 1807 1932
DOUBLE_STAR                            constant        fixed bin(17,0)          initial dcl 303 ref 2436 2573
DTM                                    constant        fixed bin(17,0)          initial dcl 274 ref 847 873 877 961 972 982 982 988
                                                                                  1826
DTU                                    constant        fixed bin(17,0)          initial dcl 275 ref 851 966 985 985
ENTRY_NAME                             constant        fixed bin(17,0)          initial dcl 302 ref 2439
EXCLUDE                                constant        fixed bin(17,0)          initial dcl 308 ref 658 1882 1894 1961 2048
INCLUDE                                constant        fixed bin(17,0)          initial dcl 307 ref 922
LINK                                   constant        fixed bin(17,0)          initial dcl 104 ref 1301 1363 1383 1475 1826 1832
                                                                                  1984 1985
MSF                                    constant        fixed bin(17,0)          initial dcl 107 ref 1153 1154 1155 1156 1171 1172
                                                                                  1230 1238 1239 1248 1261 1262 1324 1365 1773 2166
                                                                                  2281
MSF_COMPONENT_ZERO                     constant        fixed bin(17,0)          initial dcl 2118 ref 2223
NAME                                   constant        fixed bin(17,0)          initial dcl 277 ref 865 969 972
REC                                    constant        fixed bin(17,0)          initial dcl 276 ref 856 860
SEG                                    constant        fixed bin(17,0)          initial dcl 105 ref 1230
absolute_pathname_              000032 constant        entry                    external dcl 481 ref 1691
action                    1            based           fixed bin(17,0)          array level 2 in structure "starnames" dcl 288
                                                                                  in procedure "list" set ref 658* 920 922* 1879
                                                                                  1961 2048 2541*
action                          001132 automatic       fixed bin(17,0)          dcl 1678 in procedure "get_list" set ref 1879* 1882
                                                                                  1894
addr                                                   builtin function         dcl 512 ref 533 554 570 579 805 806 1386 1390 1397
                                                                                  1449 1517 1561 1561 1646 1650 1736 1744 2232 2232
                                                                                  2526 2535
all_nonstarred_sw               000474 automatic       bit(1)                   packed unaligned dcl 298 set ref 940* 941 943* 946*
                                                                                  948
all_starnames_matched           001142 automatic       bit(1)                   dcl 1686 set ref 1783* 1786* 1859 1865* 1920* 2039
alloc_len                       000472 automatic       fixed bin(17,0)          dcl 296 set ref 2530* 2533
allsw                           000201 automatic       bit(1)                   initial dcl 115 set ref 115* 591* 948* 1267
aloc_ptr                        000102 automatic       pointer                  array dcl 60 set ref 532* 532* 532* 532* 532* 533*
                                                                                  533 658 658 920 920 922 922 942 942 1318 1318 1320
                                                                                  1320 1324 1324 1330 1330 1330 1330 1331 1331 1345
                                                                                  1345 1346 1346 1376 1376 1376 1376 1394 1394 1417
                                                                                  1417 1449 1449 1449 1449 1465 1465 1465 1465 1465
                                                                                  1465 1516 1517 1517 1517 1555 1555 1558 1558 1559
                                                                                  1559 1594 1594 1595 1595 1713 1713 1713 1713 1731
                                                                                  1731 1791 1791 1840 1840 1845 1845 1879 1879 1880
                                                                                  1880 1890 1890 1891 1891 1912 1912 1920 1920 1953
                                                                                  1953 1956 1956 1957 1957 1961 1961 1965 1965 1965
                                                                                  1965 1977 1977 1977 1977 1987 1987 2017 2017 2021
                                                                                  2021 2048 2048 2050 2050 2052 2052 2054 2054 2097
                                                                                  2097 2159 2159 2159 2159 2175 2175 2184 2184 2184
                                                                                  2184 2196 2196 2197 2197 2200 2200 2212 2212 2219
                                                                                  2219 2220 2220 2237 2237 2237 2237 2243 2243 2243
                                                                                  2243 2247 2247 2247 2247 2256 2256 2264 2264 2272
                                                                                  2272 2273 2273 2278 2278 2281 2281 2300 2300 2300
                                                                                  2300 2307 2307 2307 2307 2313 2313 2313 2313 2318
                                                                                  2318 2318 2318 2323 2323 2323 2323 2328 2328 2328
                                                                                  2328 2333 2333 2333 2333 2333 2333 2333 2333 2340
                                                                                  2340 2340 2340 2345 2345 2345 2345 2399 2399 2403
                                                                                  2403 2407 2407 2411 2411 2417 2417 2418 2418 2436
                                                                                  2436 2439 2439 2440 2440 2440 2440 2445 2445 2445
                                                                                  2445 2526 2526 2533 2533 2535 2535 2540 2540 2541
                                                                                  2541 2542 2542 2545 2545 2555 2555 2555 2555 2556
                                                                                  2556 2563 2563 2564 2564 2567 2567 2572 2572 2574
                                                                                  2574 2584 2584 2622 2622
arglen                          000253 automatic       fixed bin(17,0)          dcl 134 set ref 546 547 548 550 551 564 566 568 582
                                                                                  584 674 674 677 677 744 757 758 802 804 805 844
                                                                                  845 871 872 876 902 902 911 911 1529 1533* 1617
                                                                                  1617 2544 2545 2545 2563 2564
argno                           000252 automatic       fixed bin(17,0)          dcl 134 set ref 544* 653* 653 670* 670 739* 739 799*
                                                                                  799 800* 1529 1533* 1535 1615* 1615 2530
argptr                          000250 automatic       pointer                  dcl 133 set ref 547 550 566 582 584 674 677 744 757
                                                                                  802 805 845 872 876 902 911 1529 1533* 1617 2544
                                                                                  2545 2563
bc                              000120 automatic       fixed bin(17,0)          initial dcl 75 set ref 75* 1031 1224 2022* 2022
bfsw                            000202 automatic       bit(1)                   initial dcl 115 set ref 115* 604* 1163
bin                                                    builtin function         dcl 512 ref 1791
bit                                                    builtin function         dcl 512 ref 1258 2281
bitcnt                          001106 automatic       fixed bin(24,0)          dcl 1663 set ref 2161* 2162
br                                     based           structure                array level 1 dcl 334 set ref 2272
br_ix                           001123 automatic       fixed bin(17,0)          dcl 1671 set ref 1744 1755* 1761* 2020* 2020 2021
                                                                                  2078 2082 2088 2090
branch                          000503 automatic       structure                level 1 dcl 344 set ref 1561 1561
branch_fmt                      000660 automatic       char(35)                 array packed unaligned dcl 445 set ref 1441 2677*
                                                                                  2681* 2691*
branch_fmt_ix                   000704 automatic       fixed bin(17,0)          dcl 447 set ref 1357* 1425* 1426* 1434 1441 1478
branch_fmt_ln                   000702 automatic       fixed bin(17,0)          initial array dcl 446 set ref 446* 446* 1434 2677
                                                                                  2678* 2678 2681 2691 2692* 2692
branchsort                      000203 automatic       bit(1)                   initial dcl 115 set ref 115* 972* 1300 1735 2076
branchsw                        000204 automatic       bit(1)                   initial dcl 115 set ref 115* 598* 1222 1269
c12arg                          001207 constant        char(12)                 initial array dcl 226 ref 570
c16arg                          001203 constant        char(16)                 initial array dcl 233 ref 579
c20arg                          001171 constant        char(20)                 initial array dcl 236 ref 577 578
c28arg                          001144 constant        char(28)                 initial array dcl 240 ref 582 584
c4arg                           001312 constant        char(4)                  initial array dcl 154 ref 553 554
c4key                           001131 constant        char(4)                  initial array dcl 247 ref 806 806 808
c4key_value                     001116 constant        fixed bin(17,0)          initial array dcl 264 ref 810
c8arg                           001226 constant        char(8)                  initial array dcl 197 ref 558 560
cdate                           000514 automatic       varying char(64)         array dcl 372 set ref 1376* 1465 1465 2584 2584 2584
                                                                                  2584
cdtm                                   defined         varying char(64)         dcl 373 set ref 1465* 2584*
cdtu                                   defined         varying char(64)         dcl 375 set ref 2584*
ch12                                   based           char(12)                 dcl 144 ref 570
ch16                                   based           char(16)                 dcl 144 ref 579
ch20                            000260 automatic       char(20)                 dcl 142 set ref 566* 570 577 578 579 845* 846 850
                                                                                  854 859 863 865
ch4                                    based           char(4)                  dcl 139 set ref 554 805* 806
ch8                             000256 automatic       char(8)                  dcl 137 set ref 550* 554 560 805 806
check_msf_sw                    001140 automatic       bit(1)                   dcl 1684 set ref 1772* 1773* 1802
check_star_name_$entry          000076 constant        entry                    external dcl 504 ref 942 2572
cleanup                         001034 stack reference condition                dcl 510 ref 537
clock                                  based           structure                level 1 dcl 1609
code                            000736 automatic       fixed bin(35,0)          dcl 460 set ref 539* 540 541* 674* 675 676* 677*
                                                                                  748* 750* 900* 902* 909* 911* 942* 943 1533* 1534
                                                                                  1535* 1537* 1561* 1563 1565 1565 1567* 1572* 1574*
                                                                                  1617* 1618 1691* 1694 1697* 1715 1718 1723* 2185
                                                                                  2186 2186 2192* 2232* 2233 2268* 2269* 2504* 2505
                                                                                  2545* 2546 2557* 2568* 2572* 2573 2574 2643* 2649*
col_fmt                         000303 constant        char(8)                  initial array packed unaligned dcl 436 ref 2677
col_fmt_ln                      000275 constant        fixed bin(17,0)          initial array dcl 444 ref 2678
colsw                           000237 automatic       bit(1)                   array dcl 120 set ref 528* 528* 528* 528* 528* 529*
                                                                                  529 530* 530 607* 607 612* 612 641* 641 646* 646
                                                                                  697* 697 721* 721 727* 727 762* 762 774* 774 954*
                                                                                  954 954* 954 954* 954 960 960 965 965 982 982 985
                                                                                  985 1000* 1000 1005* 1005 1024 1024 1024 1024 1035
                                                                                  1035 1040* 1040 1042* 1042 1058 1058 1068 1068
                                                                                  1083 1083 1087 1087 1100 1100 1112 1112 1113 1113
                                                                                  1134 1134 1350 1350 1376 1385 1385 1417 1417 1426
                                                                                  1426 1435 1435 1449 1449 1458 1458 1706 1706 2676
                                                                                  2700 2700
com_err_                        000034 constant        entry                    external dcl 482 ref 541 677 750 902 911 996 1535
                                                                                  1537 1567 1572 1697 1723 2269 2643 2649
component_name                  001172 automatic       varying char(32)         dcl 2129 set ref 2229* 2229 2230* 2230 2232
convert                                                builtin function         dcl 2153 in procedure "check_for_msf" ref 2229
convert                                                builtin function         dcl 512 in procedure "list" ref 1060 2681 2708
convert_date_to_binary_         000102 constant        entry                    external dcl 506 ref 1617
count_other_types               001137 automatic       bit(1)                   dcl 1683 set ref 1767* 1770* 1802 1807 1937 1948*
countsw                                defined         bit(1)                   dcl 126 set ref 612* 762* 1083 1113 1350 1435 1458
cu_$arg_count                   000044 constant        entry                    external dcl 488 ref 539
cu_$arg_ptr                     000046 constant        entry                    external dcl 489 ref 1533
cv_dec_check_                   000050 constant        entry                    external dcl 490 ref 674
cv_fstime_                      000052 constant        entry                    external dcl 491 ref 1376 1376
date                      1            based           bit(36)                  array level 2 in structure "et" dcl 354 in procedure
                                                                                  "list" set ref 1376* 1376* 1840 1845
date                                   parameter       bit(36)                  dcl 1606 in procedure "get_date" set ref 1604 1650*
date_format                     000317 constant        char(15)                 initial packed unaligned dcl 431 set ref 1024* 1376*
date_time_$format               000056 constant        entry                    external dcl 493 ref 1024 1376
default_col                     000176 automatic       bit(1)                   initial dcl 111 set ref 111* 608* 953
default_type                    000177 automatic       bit(1)                   initial dcl 111 set ref 111* 594* 937 1201 1215 1767
dir_bc                          000141 automatic       fixed bin(17,0)          dcl 80 set ref 1713* 1728 1738
dir_ec                          000142 automatic       fixed bin(17,0)          dcl 80 set ref 1728* 1731 1740 1746 1790 2182 2210*
                                                                                  2272 2507*
dir_ix                          001120 automatic       fixed bin(17,0)          dcl 1667 set ref 1790* 1791 1836* 1840 1845 1890
                                                                                  1891 1953 1956 1957 1977 1977 1987 2011* 2017
                                                                                  2021* 2096* 2097* 2159 2169* 2175 2196 2197 2200
                                                                                  2212 2219 2220 2237 2237 2243 2243 2247 2247 2278
                                                                                  2281
dir_lc                          000143 automatic       fixed bin(17,0)          dcl 80 set ref 1713* 1728
dir_mode                        001114 constant        char(4)                  initial packed unaligned dcl 322 set ref 1386
dirname                         000337 automatic       char(168)                packed unaligned dcl 149 set ref 517* 744* 745 750
                                                                                  750 756 1561* 1567 1567 1572 1572 1691* 1701 1719
                                                                                  1723 1723 2161* 2179* 2180* 2188 2188 2198 2198
                                                                                  2207* 2232* 2275* 2504* 2545* 2547 2552 2643 2643
dirname_len                     001107 automatic       fixed bin(17,0)          dcl 1664 set ref 1701* 2179 2180 2188 2188 2198 2198
                                                                                  2275
dirsw                                  defined         bit(1)                   dcl 95 set ref 591* 598* 617* 948* 1035
divide                                                 builtin function         dcl 512 ref 2489 2509
dmf_control_string              000326 constant        char(64)                 initial array packed unaligned dcl 418 ref 2594
dmf_count                       000137 automatic       fixed bin(17,0)          initial dcl 75 set ref 75* 1153 1171 1212 1230 1261
                                                                                  2195* 2195
dmf_rec_count                   000140 automatic       fixed bin(17,0)          initial dcl 75 set ref 75* 1155 1172 1262 2196* 2196
dt_len                          000657 automatic       fixed bin(17,0)          dcl 432 set ref 1024* 1026* 1060 2681 2682
dt_len_pic                             automatic       picture(2)               packed unaligned dcl 433 ref 1060 2681 2708
dtcm                      1     001205 automatic       bit(36)                  level 2 packed packed unaligned dcl 2133 set ref
                                                                                  2237 2237
dtem                      5     001205 automatic       bit(36)                  level 2 packed packed unaligned dcl 2133 set ref
                                                                                  2243 2243
dtem_arg_sw                     000205 automatic       bit(1)                   initial dcl 115 set ref 115* 629 640* 820* 832 2241
dtm                       1     000503 automatic       bit(36)                  level 2 in structure "branch" dcl 344 in procedure
                                                                                  "list" set ref 1580
dtm                       1            based           bit(36)                  array level 2 in structure "br" dcl 334 in procedure
                                                                                  "list" set ref 1580* 2219* 2237 2237* 2243 2243*
                                                                                  2247 2300 2300
dtmsw                                  defined         bit(1)                   dcl 121 set ref 641* 960 982 1024 1058 1134
dtu                       2     001205 automatic       bit(36)                  level 2 in structure "msf_info" packed packed
                                                                                  unaligned dcl 2133 in procedure "check_for_msf"
                                                                                  set ref 2247 2247
dtu                       2     000503 automatic       bit(36)                  level 2 in structure "branch" dcl 344 in procedure
                                                                                  "list" set ref 1582
dtu                       2            based           bit(36)                  array level 2 in structure "br" dcl 334 in procedure
                                                                                  "list" set ref 1582* 2220* 2247* 2307 2307
dtusw                                  defined         bit(1)                   dcl 122 set ref 646* 965 985 1024
dummy                                  based           fixed bin(17,0)          dcl 1513 ref 1517
ec                              000121 automatic       fixed bin(17,0)          initial dcl 75 set ref 75* 1949* 1949 2071
ep                                     defined         pointer                  dcl 62 set ref 1320 1324 1330 1330 1331 1345 1346
                                                                                  1376 1376 1394 1417 1449 1465 1465 1555 1558 1713*
                                                                                  1791 1840 1845 1890 1891 1953 1956 1957 1977 1977
                                                                                  2017 2159 2175 2196 2197 2200 2212 2219 2220 2237
                                                                                  2237 2243 2243 2247 2247 2278 2281 2300 2300 2307
                                                                                  2307 2313 2313 2318 2318 2323 2323 2328 2328 2333
                                                                                  2333 2340 2340 2345 2345
err_opt                         000122 automatic       fixed bin(17,0)          initial dcl 75 set ref 75* 679* 679 753* 753 904*
                                                                                  904 914* 914 931
errname                         000761 automatic       char(168)                initial dcl 475 set ref 475* 1529* 1535 1535 1571*
                                                                                  1572 1572 2033* 2052* 2643 2643 2649 2649 2657
                                                                                  2657
error_flag                      000217 automatic       bit(1)                   initial dcl 115 set ref 115* 1016 1695* 1716* 2031*
                                                                                  2065* 2070
error_table_$badopt             000026 external static fixed bin(35,0)          dcl 460 ref 909
error_table_$bigarg             000012 external static fixed bin(35,0)          dcl 460 ref 2568
error_table_$inconsistent       000024 external static fixed bin(35,0)          dcl 460 set ref 900 996*
error_table_$logical_volume_not_connected
                                000014 external static fixed bin(35,0)          dcl 460 ref 1565
error_table_$logical_volume_not_defined
                                000016 external static fixed bin(35,0)          dcl 460 ref 1565
error_table_$nomatch            000010 external static fixed bin(35,0)          dcl 460 ref 1718 2186
error_table_$null_dir           000020 external static fixed bin(35,0)          dcl 460 ref 2186
error_table_$root               000022 external static fixed bin(35,0)          dcl 460 ref 2557
et                                     based           structure                array level 1 dcl 354
et_mode                                based           char(1)                  array packed unaligned dcl 325 ref 1397
ex_mode                         001170 automatic       bit(36)                  dcl 2125 set ref 2198* 2207*
excludesw                       000206 automatic       bit(1)                   initial dcl 115 set ref 115* 660*
expand_pathname_                000054 constant        entry                    external dcl 492 ref 2545
f_t_ix                          001130 automatic       fixed bin(17,0)          dcl 1676 set ref 1826* 1829* 1832 1840 1845
fb71                            000512 automatic       fixed bin(71,0)          dcl 371 set ref 1617* 1637* 1637 1637 1640* 1640
                                                                                  1641* 1641 1646 1646* 1646 1650
file_manager_$validate          000060 constant        entry                    external dcl 494 ref 2188
file_mode                       001115 constant        char(4)                  initial packed unaligned dcl 320 set ref 1390
filesw                          000207 automatic       bit(1)                   initial dcl 115 set ref 115* 663* 950* 1229 1270
first                           000123 automatic       fixed bin(17,0)          initial dcl 75 set ref 75* 674* 1281 1338 1338 2006
first_br                        000144 automatic       fixed bin(17,0)          dcl 80 set ref 1306 1737* 1745* 1755 2082* 2090*
                                                                                  2096
first_et                        000145 automatic       fixed bin(17,0)          dcl 80 set ref 1302* 1306* 1316 1737* 1745* 2082*
                                                                                  2090* 2398 2401 2410 2480
first_lk                        000146 automatic       fixed bin(17,0)          dcl 80 set ref 1302 1739* 1745* 1756 2083* 2090*
first_name                      001133 automatic       fixed bin(17,0)          dcl 1679 set ref 1890* 1891 1893
fixed                                                  builtin function         dcl 512 ref 1258 2237 2237 2243 2243 2247 2247 2281
fmtx                            001350 automatic       fixed bin(17,0)          dcl 2671 set ref 2673* 2677 2678 2688*
from_date                       000507 automatic       bit(36)                  dcl 370 set ref 691* 992 1840
from_to                                parameter       char                     packed unaligned dcl 1607 ref 1604 1639
from_to_date_ix                 000124 automatic       fixed bin(17,0)          initial dcl 75 set ref 75* 982* 985* 988* 1779 1825
                                                                                  1829
from_to_found                   001143 automatic       bit(1)                   dcl 1687 set ref 1779* 1781* 1818 1850* 2030
fromsw                          000210 automatic       bit(1)                   initial dcl 115 set ref 115* 688* 981 992 1840
fs_util_$get_user_access_modes  000062 constant        entry                    external dcl 495 ref 2198
fstime                    0(20)        based           bit(36)                  level 2 packed packed unaligned dcl 1609 ref 1650
get_system_free_area_           000074 constant        entry                    external dcl 503 ref 519
got_all_branch_info             000211 automatic       bit(1)                   initial dcl 115 set ref 115* 1365 1837* 2013* 2093
                                                                                  2099*
got_branch_info                 000212 automatic       bit(1)                   initial dcl 115 set ref 115* 1584* 1798* 2006 2169
h                                      parameter       fixed bin(17,0)          dcl 2393 ref 2390 2401 2409
hbound                                                 builtin function         dcl 512 ref 553 558 569 806 808 1516 2526 2534
hcs_$get_user_access_modes      000064 constant        entry                    external dcl 497 ref 2207
hcs_$star_dir_list_             000066 constant        entry                    external dcl 499 ref 2504
hcs_$status_                    000070 constant        entry                    external dcl 501 ref 1561
hcs_$status_long                000104 constant        entry                    external dcl 2151 ref 2232
hcs_$status_minf                000072 constant        entry                    external dcl 502 ref 2161
hdng                            000000 constant        structure                level 1 dcl 384 ref 2597
hdng_index                      000147 automatic       fixed bin(17,0)          dcl 80 set ref 1177* 1181* 1183 1183* 1183 1275*
                                                                                  1280* 1281 1281* 1281 2594 2597 2597 2599 2599
hdng_len                        001101 constant        fixed bin(17,0)          initial array packed unaligned dcl 412 ref 2597
hdng_offset                     001066 constant        fixed bin(17,0)          initial array packed unaligned dcl 414 ref 2597
i                               000150 automatic       fixed bin(17,0)          dcl 80 in procedure "list" set ref 553* 554 554*
                                                                                  558* 560 560* 569* 570 570* 806* 806* 808 810 812
                                                                                  812 1205* 1206 1206* 1316* 1318* 2534* 2535 2535*
                                                                                  2675* 2676 2677 2678 2679 2684 2686*
i                               000100 automatic       fixed bin(17,0)          dcl 1514 in procedure "cleanup_proc" set ref 1516*
                                                                                  1517 1517 1517*
i                               001236 automatic       fixed bin(17,0)          dcl 2395 in procedure "insertion_sort" set ref 2398*
                                                                                  2399 2408 2409* 2409 2410 2411 2422*
i                               001274 automatic       fixed bin(17,0)          dcl 2502 in procedure "star_list" set ref 2508* 2509
                                                                                  2509 2509*
ia                              000151 automatic       fixed bin(17,0)          dcl 80 set ref 1361* 1364* 1375 1393* 1397 1397
                                                                                  1406* 1406 1408 1434* 1435* 1435 1441 1457* 1458*
                                                                                  1463 1463 1475* 1478* 1479 1479
ib                              000152 automatic       fixed bin(17,0)          dcl 80 set ref 1375* 1376 1376 1376 1376* 1393* 1397
                                                                                  1402* 1402 1404
include_match                   001135 automatic       bit(1)                   dcl 1681 set ref 1870* 1873* 1903 1910* 1928 2042*
                                                                                  2045* 2059* 2064
includesw                       000213 automatic       bit(1)                   initial dcl 115 set ref 115* 924* 1870 2042
incr                            001263 automatic       fixed bin(17,0)          dcl 2460 set ref 2481* 2484* 2488 2489* 2489 2490*
index                                                  builtin function         dcl 512 ref 1701
ioa_                            000036 constant        entry                    external dcl 482 ref 1465 2584 2612 2622
ioa_$ioa_switch                 000042 constant        entry                    external dcl 482 ref 2657
ioa_$nnl                        000040 constant        entry                    external dcl 482 ref 2602
ioa_control_string              000556 automatic       varying char(256)        dcl 380 set ref 1194* 1225* 1231* 1355* 1441* 1463*
                                                                                  1465* 1479* 1495* 1719* 2584* 2594* 2597* 2602*
                                                                                  2612* 2622*
iox_$error_output               000030 external static pointer                  dcl 479 set ref 2657*
ix                              000153 automatic       fixed bin(17,0)          dcl 80 in procedure "list" set ref 1318* 1320 1324
                                                                                  1330 1330 1331 1345 1346 1365* 1376 1376 1394 1417
                                                                                  1449 1465 1465
ix                                     parameter       fixed bin(17,0)          dcl 1552 in procedure "get_branch_info" ref 1549
                                                                                  1555 1561 1571 1578 1580 1582 1591
ix                                     parameter       fixed bin(17,0)          dcl 2670 in procedure "set_branch_fmt" ref 2667 2677
                                                                                  2677 2678 2678 2681 2681 2691 2691 2692 2692 2707
                                                                                  2708 2710 2711 2711 2713 2713
ix1                             001241 automatic       fixed bin(17,0)          dcl 2396 in procedure "insertion_sort" set ref 2399*
                                                                                  2405* 2407 2411* 2418* 2421*
ix1                                    parameter       fixed bin(17,0)          dcl 2296 in procedure "in_order" ref 2293 2300 2307
                                                                                  2313 2318 2323 2328 2333 2340 2345
ix2                                    parameter       fixed bin(17,0)          dcl 2296 in procedure "in_order" ref 2293 2300 2307
                                                                                  2313 2318 2323 2328 2333 2340 2345
ix2                             001242 automatic       fixed bin(17,0)          dcl 2396 in procedure "insertion_sort" set ref 2403*
                                                                                  2405* 2417 2421
ix_inc                          001127 automatic       fixed bin(17,0)          dcl 1675 set ref 1757* 1763* 1986 2020
j                               001237 automatic       fixed bin(17,0)          dcl 2395 set ref 2401* 2402 2403 2416 2418 2422*
k                               001166 automatic       fixed bin(17,0)          dcl 2124 in procedure "check_for_msf" set ref 2254*
                                                                                  2256 2260* 2264*
k                               001240 automatic       fixed bin(17,0)          dcl 2395 in procedure "insertion_sort" set ref 2402*
                                                                                  2407 2408* 2416 2417
last_br                         000154 automatic       fixed bin(17,0)          dcl 80 set ref 1307 1738* 1739 1746* 1761 2078*
                                                                                  2088* 2096
last_et                         000155 automatic       fixed bin(17,0)          dcl 80 set ref 1303* 1307* 1316 1738* 1746* 2078*
                                                                                  2088* 2401 2480
last_lk                         000156 automatic       fixed bin(17,0)          dcl 80 set ref 1303 1740* 1746* 1762 2079* 2088*
last_name                       001134 automatic       fixed bin(17,0)          dcl 1679 set ref 1891* 1893
lc                              000125 automatic       fixed bin(17,0)          initial dcl 75 set ref 75* 1056 1988* 1988
length                    2            based           fixed bin(17,0)          array level 2 in structure "starnames" dcl 288
                                                                                  in procedure "list" set ref 2555* 2556 2564* 2567
length                                                 builtin function         dcl 512 in procedure "list" ref 1024 2554 2555
length_arg_sw                   000214 automatic       bit(1)                   initial dcl 115 set ref 115* 697* 770 825* 837
link_fmt                        000717 automatic       char(24)                 array packed unaligned dcl 455 set ref 1059* 1060*
                                                                                  1064* 1072* 1078* 1084* 1084 1091* 1096* 1102*
                                                                                  1105* 1114* 1119* 1125* 1463
link_fmt_ln                     000734 automatic       fixed bin(17,0)          array dcl 456 set ref 526* 526* 1061* 1065* 1072
                                                                                  1075* 1075 1078 1080* 1080 1085* 1085 1091 1093*
                                                                                  1093 1096 1097* 1097 1102 1105 1107* 1107 1114
                                                                                  1116* 1116 1119 1121* 1121 1125 1127* 1127 1463
link_path_arg                   000215 automatic       bit(1)                   initial dcl 115 set ref 115* 711* 1005
linksw                                 defined         bit(1)                   dcl 95 set ref 591* 704* 948* 972 1056 1706
lk                                     based           structure                array level 1 dcl 361
lk_ix                                  based           fixed bin(17,0)          dcl 1672 set ref 1756* 1762* 1986* 1986 1987 2079
                                                                                  2083
lk_ix_automatic                 001126 automatic       fixed bin(17,0)          dcl 1674 set ref 1736
lk_ix_ptr                       001124 automatic       pointer                  dcl 1673 set ref 1736* 1744* 1756 1762 1986 1986
                                                                                  1987 2079 2083
lkpath                                 based           char(168)                packed unaligned dcl 316 ref 1465 1465
lkpathsw                               defined         bit(1)                   dcl 127 set ref 530* 607* 1000* 1005* 1068 1087 1100
                                                                                  1112 1449 1706
lnsw                            000200 automatic       bit(1)                   initial dcl 111 set ref 111* 643* 650* 698* 724*
                                                                                  776* 955* 1000 1349
lp                              000116 automatic       pointer                  initial dcl 71 set ref 71* 1449* 1465 1465
ltrim                                                  builtin function         dcl 2153 ref 2230
match_ix                        001131 automatic       fixed bin(17,0)          dcl 1677 set ref 1956* 1957 1957 1965 1965 1969*
                                                                                  1969 1977
match_star_name_                000100 constant        entry                    external dcl 505 ref 2445
matched                         001136 automatic       bit(1)                   dcl 1682 in procedure "get_list" set ref 1880* 1901
matched                   3            based           bit(1)                   array level 2 in structure "starnames" dcl 288
                                                                                  in procedure "list" set ref 1880 1912* 1920 2050
                                                                                  2542*
matchsw                         000216 automatic       bit(1)                   initial dcl 115 set ref 115* 717* 1953
max_day                         000324 constant        fixed bin(71,0)          initial dcl 430 set ref 1024*
message                         000737 automatic       varying char(68)         dcl 474 set ref 2635* 2637* 2642* 2642 2643* 2646
                                                                                  2646* 2646 2649* 2654 2654* 2654 2657*
mod                                                    builtin function         dcl 512 ref 1637
mode                      3            based           structure                array level 2 in structure "br" packed packed
                                                                                  unaligned dcl 334 in procedure "list" ref 2313
                                                                                  2313 2318 2318
mode                      3(01)        based           bit(4)                   array level 2 in structure "et" packed packed
                                                                                  unaligned dcl 354 in procedure "list" set ref 1394
                                                                                  2200* 2212*
mode                            000477 automatic       char(4)                  packed unaligned dcl 318 in procedure "list" set ref
                                                                                  1392* 1397 2584*
mode_array                             based           char(1)                  array packed unaligned dcl 319 set ref 1397*
mode_bits                       000502 automatic       bit(1)                   array packed unaligned dcl 326 set ref 1394* 1397
mode_ptr                        000500 automatic       pointer                  dcl 324 set ref 1386* 1390* 1397
modesw                                 defined         bit(1)                   dcl 123 set ref 721* 954* 1385 2700
msename                         001110 automatic       char(32)                 packed unaligned dcl 1665 set ref 2159* 2161* 2180
                                                                                  2188* 2198* 2269 2269
msf_bc                          000161 automatic       fixed bin(17,0)          dcl 83 set ref 516* 1386 2157* 2184* 2215 2222 2254
msf_count                       000157 automatic       fixed bin(17,0)          dcl 80 set ref 1153* 1154 1238
msf_dir_count                   001164 automatic       fixed bin(17,0)          initial dcl 2122 set ref 2122* 2256* 2256 2267 2269
msf_ep                                 defined         pointer                  dcl 64 set ref 1594 2184* 2256 2264 2272
msf_index                       001204 automatic       fixed bin(17,0)          dcl 2131 set ref 2223* 2229*
msf_info                        001205 automatic       structure                level 1 dcl 2133 set ref 2232 2232
msf_last_component              001203 automatic       fixed bin(17,0)          dcl 2130 set ref 2222* 2223
msf_lc                          001162 automatic       fixed bin(17,0)          dcl 2120 set ref 2184*
msf_np                                 defined         pointer                  dcl 65 set ref 1595 2184* 2273
msf_pass2                       000246 automatic       bit(1)                   dcl 129 set ref 1169* 1170 1245* 1248 1260 1324 2594
msf_rec_count                   000160 automatic       fixed bin(17,0)          dcl 80 in procedure "list" set ref 1155* 1156 1239
msf_rec_count                   001165 automatic       fixed bin(17,0)          dcl 2123 in procedure "check_for_msf" set ref 2175*
                                                                                  2191* 2197* 2264* 2264 2278
multisegsw                             defined         bit(1)                   dcl 95 set ref 591* 598* 624* 663* 683* 948* 950*
n                               001262 automatic       fixed bin(17,0)          dcl 2460 set ref 2480* 2483
n_listed                        000127 automatic       fixed bin(17,0)          initial dcl 75 set ref 75* 1312* 1338 1343* 1343
name                                   based           char(32)                 array packed unaligned dcl 330 in procedure "list"
                                                                                  set ref 1449 1465* 1561* 1571 1965* 1965 2159 2273
                                                                                  2333 2333 2440 2445* 2584* 2622*
name                      4            based           char(32)                 array level 2 in structure "starnames" packed packed
                                                                                  unaligned dcl 288 in procedure "list" set ref 942*
                                                                                  2052 2440 2445* 2545* 2555 2563* 2572*
name_fmt                        000706 automatic       char(8)                  array packed unaligned dcl 452 set ref 1135* 1139*
                                                                                  1479 2707* 2708* 2711*
name_fmt_ln                     000714 automatic       fixed bin(17,0)          array dcl 453 set ref 525* 525* 1136* 1140* 1479
                                                                                  2710* 2711 2713* 2713
name_indent                     000705 automatic       fixed bin(17,0)          initial dcl 450 set ref 450* 2674* 2682* 2682 2684*
                                                                                  2684 2686* 2686 2700 2700* 2703* 2705 2705* 2708
name_ix                         001121 automatic       fixed bin(17,0)          dcl 1668 set ref 1893* 1957* 1965 1965* 2440 2445
namesw                                 defined         bit(1)                   dcl 125 set ref 529* 727* 954*
nargs                           000254 automatic       fixed bin(17,0)          dcl 134 set ref 539* 544 800 2530
next_incr                       001264 automatic       fixed bin(17,0)          dcl 2460 set ref 2482* 2483 2484 2485* 2485
ni                              000126 automatic       fixed bin(17,0)          initial dcl 75 set ref 75* 1345* 1347 1465 1480*
                                                                                  1480* 2584 2622
nindex                    0(18)        based           fixed bin(17,0)          array level 2 packed packed unaligned dcl 334 ref
                                                                                  1345 1561 1571 1890 1956 1977 2159 2333 2333
nn                              000130 automatic       fixed bin(17,0)          initial dcl 75 set ref 75* 1347* 1480
nname                     0(02)        based           fixed bin(15,0)          array level 2 packed packed unaligned dcl 334 set
                                                                                  ref 1346 1891 1953 1957 1977* 2340 2340 2345 2345
nnames                          000131 automatic       fixed bin(17,0)          initial dcl 75 set ref 75* 1346* 1347 1350 1435 1458
                                                                                  1465* 1468 2584*
noheadsw                        000220 automatic       bit(1)                   initial dcl 115 set ref 115* 733* 1161 1201 1265
                                                                                  1491
not_found_count                 000132 automatic       fixed bin(17,0)          initial dcl 75 set ref 75* 2633* 2633 2639
np                                     defined         pointer                  dcl 63 set ref 1449 1465 1559 1713* 1965 1965 2159
                                                                                  2333 2333 2440 2445 2584 2622
null                                                   builtin function         dcl 512 ref 71 532 1517 1561 1561 2232 2232
pad2                      1(20)        based           bit(16)                  level 2 packed packed unaligned dcl 1609 ref 1646
para_type                              parameter       fixed bin(17,0)          dcl 2116 set ref 2110 2284*
path                            000265 automatic       char(168)                packed unaligned dcl 149 set ref 745 750 750 756*
                                                                                  757* 1691 1691 1697 1697 2547 2552* 2554 2556
pathl                           000133 automatic       fixed bin(17,0)          initial dcl 75 set ref 75* 758* 1691 1691 2554*
pathsw                          000221 automatic       bit(1)                   initial dcl 115 set ref 115* 745 759* 2547 2553*
                                                                                  2640
pbl                             001105 automatic       fixed bin(3,0)           dcl 1661 set ref 1704* 1706* 1706 2181* 2504*
pbranchsw                       000222 automatic       bit(1)                   initial dcl 115 set ref 115* 591* 598* 617* 624*
                                                                                  663* 683* 785* 948* 950* 1031
pdmfilesw                       000223 automatic       bit(1)                   initial dcl 115 set ref 115* 591* 598* 624* 663*
                                                                                  948* 950* 1248
pln                       3            based           fixed bin(17,0)          array level 2 packed packed unaligned dcl 361 ref
                                                                                  1465 1465
pmultisegsw                     000224 automatic       bit(1)                   initial dcl 115 set ref 115* 591* 598* 663* 683*
                                                                                  948* 950* 1253
pnindex                   3(18)        based           fixed bin(17,0)          array level 2 packed packed unaligned dcl 361 ref
                                                                                  1449
prisw                           000225 automatic       bit(1)                   initial dcl 115 set ref 115* 765* 1133 1468 2699
raw_mode                        001167 automatic       bit(36)                  dcl 2125 set ref 2198* 2200 2207* 2212
read_vtoc_sw                    000226 automatic       bit(1)                   initial dcl 115 set ref 115* 632* 649* 775* 828*
                                                                                  1365 2169
real_dtm_sw                     000227 automatic       bit(1)                   initial dcl 115 set ref 115* 632* 635 817 834* 962
                                                                                  1580 1832 2235
real_record_sw                  000230 automatic       bit(1)                   initial dcl 115 set ref 115* 694 775* 823 839* 1035
                                                                                  1183 1281 1426 1578 2006 2260
records                         000134 automatic       fixed bin(17,0)          initial dcl 75 in procedure "list" set ref 75* 1417*
                                                                                  2584*
records                   3(18) 000503 automatic       fixed bin(17,0)          level 2 in structure "branch" packed packed
                                                                                  unaligned dcl 344 in procedure "list" set ref 1578
records                   3(11)        based           fixed bin(24,0)          array level 2 in structure "br" packed packed
                                                                                  unaligned dcl 334 in procedure "list" set ref 1324
                                                                                  1330* 1330 1331 1417 1578* 2017 2175 2196 2197
                                                                                  2264 2278* 2323 2323 2328 2328 2509* 2509
recordsw                               defined         bit(1)                   dcl 124 set ref 697* 774* 954* 1035 1040* 1042* 1417
                                                                                  1426
revsw                           000231 automatic       bit(1)                   initial dcl 115 set ref 115* 779* 1754 2077 2088
                                                                                  2351 2356
rtrim                                                  builtin function         dcl 512 ref 750 750 750 750 1535 1535 1567 1567 1572
                                                                                  1572 1572 1572 1697 1697 1719 1723 1723 2269 2269
                                                                                  2554 2555 2594 2643 2643 2643 2643 2649 2649 2657
                                                                                  2657
search                                                 builtin function         dcl 512 ref 2544
segsw                                  defined         bit(1)                   dcl 95 set ref 591* 598* 663* 785* 948* 950*
shortsw                         000232 automatic       bit(1)                   initial dcl 115 set ref 115* 701* 791* 1071 1090
                                                                                  1102
skip_it                         001141 automatic       bit(1)                   dcl 1685 set ref 1797* 1807* 1818 1842* 1847* 1852
                                                                                  1859 1882 1895* 1903 1927
sort_index_ptr                         defined         pointer                  dcl 67 set ref 1318 1731* 1987 2021 2097 2399 2403
                                                                                  2407 2411 2417 2418
sort_ix                                based           fixed bin(17,0)          array dcl 284 set ref 1318 1731 1987* 2021* 2097*
                                                                                  2399 2403 2407* 2411 2417* 2418
sort_key                        000411 automatic       fixed bin(17,0)          initial dcl 265 set ref 265* 810* 847* 851* 856*
                                                                                  860* 863* 865* 873* 877* 959 961* 966* 969* 972
                                                                                  972 982 985 2298
sort_vtoc_sw                    000233 automatic       bit(1)                   initial dcl 115 set ref 115* 828* 962* 967* 2006
                                                                                  2093
sortsw                          000234 automatic       bit(1)                   initial dcl 115 set ref 115* 796* 958 2101
stack_starnames                 000412 automatic       structure                array level 1 dcl 295 set ref 533 1517 2526 2526
                                                                                  2534 2535
star_bc                                parameter       fixed bin(17,0)          dcl 2500 set ref 2497 2504* 2507 2508
star_code                       001252 automatic       fixed bin(35,0)          dcl 2434 set ref 2445* 2446
star_ep                                parameter       pointer                  dcl 2501 set ref 2497 2504* 2509 2509 2509
star_ix                         001122 automatic       fixed bin(17,0)          dcl 1669 set ref 1878* 1879 1880 1912 1920* 1959*
                                                                                  1961* 2047* 2048 2050 2052 2054* 2436 2439 2440
                                                                                  2445
star_lc                                parameter       fixed bin(17,0)          dcl 2500 set ref 2497 2504* 2507 2508
star_np                                parameter       pointer                  dcl 2501 set ref 2497 2504*
starname_count                  000475 automatic       fixed bin(17,0)          initial dcl 310 set ref 310* 658 920 922 939 941
                                                                                  1783 1852 1878 1959 2047 2054* 2526 2539* 2539
                                                                                  2540 2541 2542 2545 2555 2555 2556 2563 2564 2567
                                                                                  2572 2574 2635
starname_idx                    000473 automatic       fixed bin(17,0)          dcl 297 set ref 941* 942*
starnames                              based           structure                array level 1 dcl 288 set ref 2533 2535* 2535
starptr                                defined         pointer                  dcl 66 set ref 533* 658 920 922 942 1879 1880 1912
                                                                                  1920 1961 2048 2050 2052 2054 2436 2439 2440 2445
                                                                                  2526 2533* 2535 2540 2541 2542 2545 2555 2555 2556
                                                                                  2563 2564 2567 2572 2574
string                                                 builtin function         dcl 512 set ref 1394* 1646 2313 2313 2318 2318 2597
substr                                                 builtin function         dcl 512 set ref 547 802 854 1060* 1072* 1078* 1091*
                                                                                  1096* 1102* 1105* 1114* 1119* 1125* 1441 1463 1465
                                                                                  1465 1479 1691 1691 2179* 2180* 2188 2188 2198
                                                                                  2198 2200 2212 2275* 2597 2677* 2677 2681* 2691*
                                                                                  2707* 2708* 2711*
system_free_area                       based           area(1024)               dcl 57 ref 1517 1731 2272 2273 2533
system_free_ptr                 000100 automatic       pointer                  dcl 58 set ref 519* 1517 1731 2272 2273 2504* 2533
targ                                   based           char                     packed unaligned dcl 135 set ref 547 550 566 582 584
                                                                                  674* 677* 744 757 802 805 845 872 876 902* 911*
                                                                                  1529 1617* 2544 2545* 2563
tcount                          000162 automatic       fixed bin(17,0)          array dcl 87 set ref 521* 521* 521* 521* 1153 1154*
                                                                                  1171* 1177 1206 1230 1230 1238* 1261* 1266 1295
                                                                                  1945* 1945 2602*
temp_dir_ec                     001171 automatic       fixed bin(17,0)          dcl 2126 set ref 2156* 2182* 2210
temp_ep                         001064 automatic       pointer                  dcl 1553 set ref 1558* 1561 1571 1578 1580 1582
                                                                                  1594*
temp_np                         001066 automatic       pointer                  dcl 1553 set ref 1559* 1561 1571 1595*
to_date                         000510 automatic       bit(36)                  dcl 370 set ref 889* 992 1845
tosw                            000235 automatic       bit(1)                   initial dcl 115 set ref 115* 887* 981 992 1845
totalsw                         000236 automatic       bit(1)                   initial dcl 115 set ref 115* 892* 1023 1160 1291
                                                                                  1491 1706
tpix                            000135 automatic       fixed bin(17,0)          initial dcl 75 set ref 75* 1175* 1176 1177 1177 1181
                                                                                  1246* 1247 1248 1258 1266 1268 1270 1275 1280 1295
                                                                                  1301 1324 1363 1365 1383 1426 1475 2602 2602
trecs                           000166 automatic       fixed bin(17,0)          array dcl 87 set ref 523* 523* 523* 523* 1155 1156*
                                                                                  1172* 1239* 1262* 2017* 2017 2602*
tsws                            000172 automatic       bit(1)                   array dcl 94 set ref 524* 524* 524* 524* 591* 591
                                                                                  591* 591 591* 591 591* 591 598* 598 598* 598 598*
                                                                                  598 617* 617 624* 624 663* 663 663* 663 683* 683
                                                                                  704* 704 785* 785 948* 948 948* 948 948* 948 948*
                                                                                  948 950* 950 950* 950 972 972 1035 1035 1056 1056
                                                                                  1176 1206 1215* 1215* 1215* 1215* 1247 1706 1706
                                                                                  1773 1773 1807 1937 1947 1985 2019 2166
tx                              000136 automatic       fixed bin(17,0)          initial dcl 75 set ref 75* 1167* 1169 1175* 1243*
                                                                                  1245 1246*
type                            001104 automatic       fixed bin(17,0)          dcl 1660 in procedure "get_list" set ref 1791* 1807
                                                                                  1807 1826 1832 1932 1932* 1937 1945 1945 1947 1984
                                                                                  2017 2017 2019
type                                   based           bit(2)                   array level 2 in structure "br" packed packed
                                                                                  unaligned dcl 334 in procedure "list" set ref 1320
                                                                                  1555 1791 2256 2281* 2509
type                                   based           fixed bin(17,0)          array level 2 in structure "starnames" dcl 288
                                                                                  in procedure "list" set ref 2054 2436 2439 2540*
                                                                                  2574*
type                            000476 automatic       bit(2)                   packed unaligned dcl 314 in procedure "list" set ref
                                                                                  1258* 1320 1386 1409
type_ix                         001362 constant        fixed bin(17,0)          initial array dcl 102 ref 1175 1246
xcode                           001163 automatic       fixed bin(35,0)          dcl 2121 set ref 2161* 2162 2188* 2189 2198* 2200
                                                                                  2207* 2209

NAMES DECLARED BY EXPLICIT CONTEXT.
additional_names                005031 constant        label                    dcl 1468 ref 1358
argl8                           002200 constant        label                    dcl 558 ref 551
arglong                         002221 constant        label                    dcl 564 ref 548
arglong2                        002270 constant        label                    dcl 582 ref 564
badarg                          003216 constant        label                    dcl 911 ref 1618 2546 2558 2569 2573
badopt                          003213 constant        label                    dcl 909 ref 556 562 572 580 585
brief_totals                    004054 constant        label                    dcl 1163 ref 1161 1219
c12lab                          000254 constant        label                    array(5) dcl 617 ref 569 570
c16lab1                         002364 constant        label                    dcl 646 ref 579
c20lab1                         002355 constant        label                    dcl 635 ref 577
c20lab2                         002505 constant        label                    dcl 683 ref 578
c28lab1                         002347 constant        label                    dcl 629 ref 582
c28lab2                         002355 constant        label                    dcl 635 ref 584
c28lab3                         002342 constant        label                    dcl 624
c4lab                           000152 constant        label                    array(40) dcl 591 ref 554
c8lab                           000222 constant        label                    array(26) dcl 598 ref 560
check_for_msf                   007214 constant        entry                    internal dcl 2110 ref 1932
check_type                      006364 constant        label                    dcl 1807 ref 1802
cleanup_proc                    005112 constant        entry                    internal dcl 1511 ref 537 1499
compare                         010403 constant        label                    dcl 2405 ref 2412
comparison                      000267 constant        label                    array(6) dcl 2300 ref 2298
ctl_arg                         002153 constant        label                    dcl 548 ref 802
end_list_entries                005072 constant        label                    dcl 1485 ref 1320 1324 1331
end_mode_loop                   004641 constant        label                    dcl 1414 ref 1404
end_type_loop                   005074 constant        label                    dcl 1488 ref 1247 1248 1253 1291 1295 1338
endopt                          003270 constant        label                    dcl 928 ref 546 596 610 615 644 651 661 681 692 715
                                                                                  719 737 754 760 768 783 794 800 815 821 826 830
                                                                                  885 890 896 905
error_return                    005104 constant        label                    dcl 1499 ref 931 997 1016 1539 1568
get_arg_ptr                     005150 constant        entry                    internal dcl 1526 ref 545 656 673 743 801 1616
get_branch_info                 005301 constant        entry                    internal dcl 1549 ref 1365 1836 2011 2097 2169
get_date                        005631 constant        entry                    internal dcl 1604 ref 691 889
get_info_common                 005314 constant        label                    dcl 1561 ref 1597
get_list                        005732 constant        entry                    internal dcl 1657 ref 1013
get_msf_records                 005622 constant        entry                    internal dcl 1591 ref 2260
get_starname                    010707 constant        entry                    internal dcl 2522 ref 657 918
in_order                        010200 constant        entry                    internal dcl 2293 ref 2405
insertion_sort                  010360 constant        entry                    internal dcl 2390 ref 2490
items_in_order                  010351 constant        label                    dcl 2356 ref 2305 2311 2321 2331 2338 2348
items_reversed                  010346 constant        label                    dcl 2351 ref 2300 2307 2313 2323 2333 2340
keep_entry                      006624 constant        label                    dcl 1932 ref 1857
kept_name                       006740 constant        label                    dcl 1975 ref 1971
list                            001766 constant        entry                    external dcl 50
list_entries                    004336 constant        label                    dcl 1316
lkshort1                        003663 constant        label                    dcl 1072 ref 1068
lkshort2                        003717 constant        label                    dcl 1091 ref 1087
ls                              001776 constant        entry                    external dcl 50
match                           010532 constant        label                    dcl 2451 ref 2436 2440 2446
mode_loop                       004613 constant        label                    dcl 1397 ref 1413
msfempty                        010146 constant        label                    dcl 2275 ref 2203
names_match                     010451 constant        entry                    internal dcl 2431 ref 1895 1903 1961
next_bit                        004631 constant        label                    dcl 1406 ref 1409
next_col                        004625 constant        label                    dcl 1402
next_starname                   006616 constant        label                    dcl 1924 ref 1882 1914
no_heading                      004313 constant        label                    dcl 1291 ref 1265 1267 1269 1270
nomatch                         010527 constant        label                    dcl 2449
not_just_names                  004444 constant        label                    dcl 1361 ref 1350
print_branch                    011171 constant        entry                    internal dcl 2582 ref 1443
print_heading                   011235 constant        entry                    internal dcl 2592 ref 1191 1276 1288
print_message                   011352 constant        entry                    internal dcl 2610 ref 1195 1226 1232 1496 1721 2599
print_name                      011365 constant        entry                    internal dcl 2620 ref 1356 1481
print_not_found                 011407 constant        entry                    internal dcl 2630 ref 2034 2057
reset_default_col               002331 constant        label                    dcl 608 ref 699 725 731 777
reset_default_type              002313 constant        label                    dcl 594 set ref 602 622 627 668 686 709 789
return                          005076 constant        label                    dcl 1491 ref 1196
return_in_order                 010355 constant        label                    dcl 2361 ref 2318 2328 2345 2351
return_out_of_order             010353 constant        label                    dcl 2356 set ref 2354
say_we_got_it                   005617 constant        label                    dcl 1584 ref 1555 1575
set_branch_fmt                  011706 constant        entry                    internal dcl 2667 ref 1033 1041
set_dtm_sw                      002361 constant        label                    dcl 641 ref 633
set_msftype                     010162 constant        label                    dcl 2281 ref 2166
shell_sort                      010536 constant        entry                    internal dcl 2457 ref 2101
skip_date_check                 006457 constant        label                    dcl 1852 ref 1818 1843 1848
skip_entry                      007032 constant        label                    dcl 2025 ref 1852 1859 1927 1928 1937
sort_lab                        000261 constant        label                    array(6) dcl 817 ref 812 835 840 848 852 857 861 874
                                                                                  878
star_arg                        003254 constant        label                    dcl 918 ref 808 865 871 876
star_list                       010572 constant        entry                    internal dcl 2497 ref 1713 2184
start_list                      004153 constant        label                    dcl 1222 ref 1163 1206 1212
try_include_match               006570 constant        label                    dcl 1903 ref 1901
two_pn_error                    002573 constant        label                    dcl 748 ref 2547
type_loop                       004211 constant        label                    dcl 1243
vtoc_conflict                   003152 constant        label                    dcl 900 ref 629 635 694 770 817 823 832 837

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     13034       13142   12430       13044
Length     13410   12430       106         232     404           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
list                               1271 external procedure  is an external procedure.  
on unit on line 537                  64 on unit               
cleanup_proc                         68 internal procedure  is called by several nonquick procedures.  
get_arg_ptr                             internal procedure  shares stack frame of external procedure list.  
get_branch_info                         internal procedure  shares stack frame of external procedure list.  
get_date                                internal procedure  shares stack frame of external procedure list.  
get_list                                internal procedure  shares stack frame of external procedure list.  
check_for_msf                           internal procedure  shares stack frame of external procedure list.  
in_order                                internal procedure  shares stack frame of external procedure list.  
insertion_sort                          internal procedure  shares stack frame of external procedure list.  
names_match                             internal procedure  shares stack frame of external procedure list.  
shell_sort                              internal procedure  shares stack frame of external procedure list.  
star_list                               internal procedure  shares stack frame of external procedure list.  
get_starname                            internal procedure  shares stack frame of external procedure list.  
print_branch                            internal procedure  shares stack frame of external procedure list.  
print_heading                           internal procedure  shares stack frame of external procedure list.  
print_message                           internal procedure  shares stack frame of external procedure list.  
print_name                              internal procedure  shares stack frame of external procedure list.  
print_not_found                         internal procedure  shares stack frame of external procedure list.  
set_branch_fmt                          internal procedure  shares stack frame of external procedure list.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cleanup_proc             000100 i                           cleanup_proc
list                     000100 system_free_ptr             list
                         000102 aloc_ptr                    list
                         000116 lp                          list
                         000120 bc                          list
                         000121 ec                          list
                         000122 err_opt                     list
                         000123 first                       list
                         000124 from_to_date_ix             list
                         000125 lc                          list
                         000126 ni                          list
                         000127 n_listed                    list
                         000130 nn                          list
                         000131 nnames                      list
                         000132 not_found_count             list
                         000133 pathl                       list
                         000134 records                     list
                         000135 tpix                        list
                         000136 tx                          list
                         000137 dmf_count                   list
                         000140 dmf_rec_count               list
                         000141 dir_bc                      list
                         000142 dir_ec                      list
                         000143 dir_lc                      list
                         000144 first_br                    list
                         000145 first_et                    list
                         000146 first_lk                    list
                         000147 hdng_index                  list
                         000150 i                           list
                         000151 ia                          list
                         000152 ib                          list
                         000153 ix                          list
                         000154 last_br                     list
                         000155 last_et                     list
                         000156 last_lk                     list
                         000157 msf_count                   list
                         000160 msf_rec_count               list
                         000161 msf_bc                      list
                         000162 tcount                      list
                         000166 trecs                       list
                         000172 tsws                        list
                         000176 default_col                 list
                         000177 default_type                list
                         000200 lnsw                        list
                         000201 allsw                       list
                         000202 bfsw                        list
                         000203 branchsort                  list
                         000204 branchsw                    list
                         000205 dtem_arg_sw                 list
                         000206 excludesw                   list
                         000207 filesw                      list
                         000210 fromsw                      list
                         000211 got_all_branch_info         list
                         000212 got_branch_info             list
                         000213 includesw                   list
                         000214 length_arg_sw               list
                         000215 link_path_arg               list
                         000216 matchsw                     list
                         000217 error_flag                  list
                         000220 noheadsw                    list
                         000221 pathsw                      list
                         000222 pbranchsw                   list
                         000223 pdmfilesw                   list
                         000224 pmultisegsw                 list
                         000225 prisw                       list
                         000226 read_vtoc_sw                list
                         000227 real_dtm_sw                 list
                         000230 real_record_sw              list
                         000231 revsw                       list
                         000232 shortsw                     list
                         000233 sort_vtoc_sw                list
                         000234 sortsw                      list
                         000235 tosw                        list
                         000236 totalsw                     list
                         000237 colsw                       list
                         000246 msf_pass2                   list
                         000250 argptr                      list
                         000252 argno                       list
                         000253 arglen                      list
                         000254 nargs                       list
                         000256 ch8                         list
                         000260 ch20                        list
                         000265 path                        list
                         000337 dirname                     list
                         000411 sort_key                    list
                         000412 stack_starnames             list
                         000472 alloc_len                   list
                         000473 starname_idx                list
                         000474 all_nonstarred_sw           list
                         000475 starname_count              list
                         000476 type                        list
                         000477 mode                        list
                         000500 mode_ptr                    list
                         000502 mode_bits                   list
                         000503 branch                      list
                         000507 from_date                   list
                         000510 to_date                     list
                         000512 fb71                        list
                         000514 cdate                       list
                         000556 ioa_control_string          list
                         000657 dt_len                      list
                         000660 branch_fmt                  list
                         000702 branch_fmt_ln               list
                         000704 branch_fmt_ix               list
                         000705 name_indent                 list
                         000706 name_fmt                    list
                         000714 name_fmt_ln                 list
                         000717 link_fmt                    list
                         000734 link_fmt_ln                 list
                         000736 code                        list
                         000737 message                     list
                         000761 errname                     list
                         001064 temp_ep                     get_branch_info
                         001066 temp_np                     get_branch_info
                         001104 type                        get_list
                         001105 pbl                         get_list
                         001106 bitcnt                      get_list
                         001107 dirname_len                 get_list
                         001110 msename                     get_list
                         001120 dir_ix                      get_list
                         001121 name_ix                     get_list
                         001122 star_ix                     get_list
                         001123 br_ix                       get_list
                         001124 lk_ix_ptr                   get_list
                         001126 lk_ix_automatic             get_list
                         001127 ix_inc                      get_list
                         001130 f_t_ix                      get_list
                         001131 match_ix                    get_list
                         001132 action                      get_list
                         001133 first_name                  get_list
                         001134 last_name                   get_list
                         001135 include_match               get_list
                         001136 matched                     get_list
                         001137 count_other_types           get_list
                         001140 check_msf_sw                get_list
                         001141 skip_it                     get_list
                         001142 all_starnames_matched       get_list
                         001143 from_to_found               get_list
                         001162 msf_lc                      check_for_msf
                         001163 xcode                       check_for_msf
                         001164 msf_dir_count               check_for_msf
                         001165 msf_rec_count               check_for_msf
                         001166 k                           check_for_msf
                         001167 raw_mode                    check_for_msf
                         001170 ex_mode                     check_for_msf
                         001171 temp_dir_ec                 check_for_msf
                         001172 component_name              check_for_msf
                         001203 msf_last_component          check_for_msf
                         001204 msf_index                   check_for_msf
                         001205 msf_info                    check_for_msf
                         001236 i                           insertion_sort
                         001237 j                           insertion_sort
                         001240 k                           insertion_sort
                         001241 ix1                         insertion_sort
                         001242 ix2                         insertion_sort
                         001252 star_code                   names_match
                         001262 n                           shell_sort
                         001263 incr                        shell_sort
                         001264 next_incr                   shell_sort
                         001274 i                           star_list
                         001350 fmtx                        set_branch_fmt

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          mdfx3               enable_op           shorten_stack       ext_entry           int_entry
op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absolute_pathname_            check_star_name_$entry        com_err_                      convert_date_to_binary_
cu_$arg_count                 cu_$arg_ptr                   cv_dec_check_                 cv_fstime_
date_time_$format             expand_pathname_              file_manager_$validate
fs_util_$get_user_access_modes                              get_system_free_area_         hcs_$get_user_access_modes
hcs_$star_dir_list_           hcs_$status_                  hcs_$status_long              hcs_$status_minf
ioa_                          ioa_$ioa_switch               ioa_$nnl                      match_star_name_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$bigarg           error_table_$inconsistent
error_table_$logical_volume_not_connected                   error_table_$logical_volume_not_defined
error_table_$nomatch          error_table_$null_dir         error_table_$root             iox_$error_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     71 001661        75 001663       111 001704       115 001710       265 001746       310 001747       446 001750
    450 001757       475 001760        50 001765       516 002004       517 002005       519 002010       521 002017
    523 002023       524 002027       525 002033       526 002035       528 002037       529 002044       530 002046
    532 002047       533 002055       537 002057       539 002101       540 002112       541 002114       542 002133
    544 002134       545 002143       546 002144       547 002146       548 002153       550 002156       551 002162
    553 002164       554 002171       555 002175       556 002177       558 002200       560 002205       561 002216
    562 002220       564 002221       566 002223       568 002227       569 002231       570 002237       571 002250
    572 002252       577 002253       578 002257       579 002263       580 002267       582 002270       584 002275
    585 002301       591 002302       594 002313       596 002314       598 002315       602 002325       604 002326
    607 002330       608 002331       610 002332       612 002333       615 002335       617 002336       622 002341
    624 002342       627 002346       629 002347       632 002351       633 002354       635 002355       640 002357
    641 002361       643 002362       644 002363       646 002364       649 002366       650 002367       651 002370
    653 002371       656 002372       657 002373       658 002374       660 002402       661 002404       663 002405
    668 002414       670 002415       673 002416       674 002417       675 002443       676 002445       677 002446
    679 002503       681 002504       683 002505       686 002511       688 002512       691 002514       692 002521
    694 002522       697 002524       698 002527       699 002530       701 002531       704 002533       709 002535
    711 002536       715 002540       717 002541       719 002543       721 002544       724 002546       725 002547
    727 002550       731 002552       733 002553       737 002555       739 002556       743 002557       744 002560
    745 002565       748 002573       750 002574       753 002672       754 002674       756 002675       757 002700
    758 002703       759 002705       760 002707       762 002710       765 002712       768 002714       770 002715
    774 002717       775 002721       776 002723       777 002724       779 002725       783 002727       785 002730
    789 002733       791 002734       794 002736       796 002737       799 002741       800 002742       801 002745
    802 002746       804 002753       805 002756       806 002761       807 002772       808 002774       810 002777
    812 003002       815 003006       817 003007       820 003011       821 003013       823 003014       825 003016
    826 003020       828 003021       830 003024       832 003025       834 003027       835 003031       837 003032
    839 003034       840 003036       844 003037       845 003041       846 003044       847 003050       848 003052
    850 003053       851 003057       852 003061       854 003062       856 003066       857 003070       859 003071
    860 003075       861 003077       863 003100       865 003107       869 003115       871 003116       872 003120
    873 003124       874 003126       876 003127       877 003133       878 003135       885 003136       887 003137
    889 003141       890 003146       892 003147       896 003151       900 003152       902 003155       904 003211
    905 003212       909 003213       911 003216       914 003252       915 003253       918 003254       920 003255
    922 003263       924 003266       928 003270       931 003272       937 003274       939 003276       940 003300
    941 003302       942 003313       943 003335       944 003340       945 003342       946 003343       948 003344
    950 003360       953 003367       954 003371       955 003375       958 003376       959 003400       960 003402
    961 003404       962 003406       964 003412       965 003413       966 003415       967 003417       968 003421
    969 003422       972 003424       981 003434       982 003440       985 003450       988 003457       992 003461
    996 003470       997 003516      1000 003517      1005 003522      1013 003526      1016 003527      1023 003531
   1024 003533      1026 003572      1031 003574      1033 003600      1035 003604      1040 003612      1041 003613
   1042 003617      1056 003621      1058 003625      1059 003627      1060 003632      1061 003645      1062 003647
   1064 003650      1065 003653      1068 003655      1071 003661      1072 003663      1075 003671      1076 003673
   1078 003674      1080 003702      1083 003704      1084 003706      1085 003711      1087 003713      1090 003715
   1091 003717      1093 003725      1094 003727      1096 003730      1097 003736      1100 003740      1102 003742
   1105 003753      1107 003761      1112 003763      1113 003765      1114 003767      1116 003775      1117 003777
   1119 004000      1121 004006      1125 004010      1127 004016      1133 004020      1134 004022      1135 004024
   1136 004026      1137 004030      1139 004031      1140 004033      1153 004035      1154 004041      1155 004042
   1156 004045      1160 004046      1161 004050      1163 004052      1167 004054      1169 004061      1170 004064
   1171 004065      1172 004070      1175 004072      1176 004075      1177 004077      1181 004104      1183 004107
   1191 004115      1193 004116      1194 004120      1195 004121      1196 004122      1201 004123      1205 004127
   1206 004133      1211 004137      1212 004141      1215 004143      1219 004152      1222 004153      1224 004155
   1225 004157      1226 004164      1228 004165      1229 004166      1230 004170      1231 004176      1232 004203
   1238 004204      1239 004207      1243 004211      1245 004217      1246 004222      1247 004224      1248 004226
   1252 004234      1253 004235      1258 004237      1260 004244      1261 004246      1262 004251      1265 004253
   1266 004255      1267 004260      1268 004262      1269 004264      1270 004266      1275 004272      1276 004274
   1277 004275      1280 004276      1281 004301      1288 004312      1291 004313      1295 004315      1300 004320
   1301 004322      1302 004324      1303 004326      1304 004330      1306 004331      1307 004333      1312 004335
   1316 004336      1318 004345      1320 004350      1324 004357      1330 004371      1331 004377      1338 004404
   1343 004410      1345 004411      1346 004416      1347 004422      1349 004425      1350 004427      1355 004434
   1356 004440      1357 004441      1358 004443      1361 004444      1363 004446      1364 004450      1365 004452
   1375 004463      1376 004473      1379 004556      1383 004560      1385 004562      1386 004564      1390 004574
   1392 004576      1393 004600      1394 004603      1397 004613      1402 004625      1404 004626      1406 004631
   1408 004632      1409 004635      1413 004640      1417 004641      1425 004652      1426 004654      1434 004665
   1435 004670      1441 004677      1443 004712      1444 004713      1449 004714      1457 004730      1458 004732
   1463 004741      1465 004756      1466 005030      1468 005031      1475 005036      1478 005042      1479 005044
   1480 005060      1481 005067      1482 005070      1485 005072      1488 005074      1491 005076      1495 005102
   1496 005103      1499 005104      1502 005110      1511 005111      1516 005117      1517 005125      1519 005145
   1521 005147      1526 005150      1529 005151      1533 005161      1534 005176      1535 005200      1537 005257
   1539 005277      1542 005300      1549 005301      1555 005303      1558 005311      1559 005312      1561 005314
   1563 005366      1565 005370      1567 005375      1568 005445      1571 005447      1572 005464      1574 005560
   1575 005562      1578 005563      1580 005601      1582 005611      1584 005617      1587 005621      1591 005622
   1594 005624      1595 005626      1597 005630      1604 005631      1615 005642      1616 005643      1617 005644
   1618 005670      1637 005672      1639 005702      1640 005711      1641 005714      1646 005720      1650 005726
   1652 005731      1657 005732      1691 005733      1694 005763      1695 005766      1697 005770      1698 006041
   1701 006043      1704 006054      1706 006056      1713 006066      1715 006102      1716 006104      1718 006106
   1719 006111      1721 006143      1722 006145      1723 006146      1725 006216      1728 006220      1731 006223
   1735 006230      1736 006232      1737 006234      1738 006237      1739 006242      1740 006244      1741 006246
   1744 006247      1745 006251      1746 006255      1754 006261      1755 006263      1756 006266      1757 006271
   1758 006273      1761 006274      1762 006277      1763 006302      1767 006304      1770 006311      1772 006312
   1773 006314      1779 006323      1781 006327      1783 006331      1786 006335      1790 006337      1791 006347
   1797 006354      1798 006355      1802 006356      1807 006362      1818 006372      1825 006376      1826 006400
   1829 006405      1832 006407      1836 006416      1837 006420      1840 006422      1842 006434      1843 006436
   1845 006437      1847 006452      1848 006454      1850 006455      1852 006457      1857 006463      1859 006464
   1865 006470      1870 006472      1873 006476      1878 006500      1879 006507      1880 006514      1882 006516
   1890 006522      1891 006532      1893 006540      1894 006547      1895 006552      1898 006561      1901 006562
   1903 006564      1910 006575      1912 006577      1914 006604      1918 006605      1920 006607      1924 006616
   1927 006620      1928 006622      1932 006624      1937 006631      1945 006636      1947 006637      1948 006641
   1949 006642      1953 006643      1956 006656      1957 006664      1959 006675      1961 006705      1965 006717
   1969 006734      1971 006735      1974 006736      1975 006740      1977 006742      1984 006760      1985 006762
   1986 006765      1987 006767      1988 006773      1990 006774      2006 006775      2011 007005      2013 007007
   2017 007011      2019 007021      2020 007023      2021 007025      2022 007031      2025 007032      2030 007034
   2031 007036      2033 007040      2034 007043      2035 007044      2039 007045      2042 007047      2045 007053
   2047 007055      2048 007065      2050 007073      2052 007076      2054 007102      2057 007105      2058 007106
   2059 007107      2062 007111      2064 007113      2065 007115      2066 007117      2070 007120      2071 007123
   2076 007126      2077 007130      2078 007132      2079 007135      2080 007137      2082 007140      2083 007143
   2085 007145      2088 007146      2090 007155      2093 007161      2096 007165      2097 007175      2098 007204
   2099 007206      2101 007210      2103 007213      2110 007214      2122 007216      2156 007217      2157 007220
   2159 007221      2161 007235      2162 007274      2166 007300      2169 007303      2175 007311      2179 007320
   2180 007324      2181 007327      2182 007331      2184 007333      2185 007347      2186 007351      2188 007356
   2189 007407      2191 007412      2192 007413      2193 007414      2195 007415      2196 007416      2197 007426
   2198 007431      2200 007502      2203 007517      2207 007520      2209 007564      2210 007566      2212 007570
   2215 007602      2219 007604      2220 007610      2222 007611      2223 007614      2229 007623      2230 007637
   2232 007661      2233 007733      2235 007736      2237 007740      2241 007756      2243 007760      2247 007776
   2250 010014      2254 010016      2256 010025      2260 010035      2264 010041      2265 010050      2267 010052
   2268 010054      2269 010055      2270 010137      2272 010140      2273 010144      2275 010146      2278 010152
   2281 010162      2284 010174      2287 010177      2293 010200      2298 010202      2300 010204      2305 010216
   2307 010217      2311 010231      2313 010232      2318 010251      2321 010252      2323 010253      2328 010273
   2331 010274      2333 010275      2338 010323      2340 010324      2345 010344      2348 010345      2351 010346
   2354 010350      2356 010351      2361 010355      2390 010360      2398 010362      2399 010364      2401 010367
   2402 010377      2403 010400      2405 010403      2407 010410      2408 010414      2409 010416      2410 010421
   2411 010424      2412 010426      2416 010427      2417 010432      2418 010436      2420 010441      2421 010442
   2422 010444      2424 010446      2426 010450      2431 010451      2436 010453      2439 010462      2440 010465
   2441 010476      2445 010477      2446 010525      2449 010527      2451 010532      2457 010536      2480 010537
   2481 010543      2482 010545      2483 010547      2484 010553      2485 010554      2486 010557      2488 010560
   2489 010563      2490 010566      2491 010570      2492 010571      2497 010572      2504 010574      2505 010645
   2507 010647      2508 010653      2509 010663      2512 010704      2514 010706      2522 010707      2526 010710
   2530 010721      2533 010725      2534 010733      2535 010741      2536 010750      2539 010752      2540 010753
   2541 010757      2542 010760      2544 010761      2545 010776      2546 011031      2547 011033      2552 011041
   2553 011044      2554 011046      2555 011060      2556 011102      2557 011110      2558 011113      2560 011114
   2563 011115      2564 011122      2567 011124      2568 011133      2569 011136      2572 011137      2573 011157
   2574 011162      2576 011170      2582 011171      2584 011172      2586 011234      2592 011235      2594 011236
   2597 011272      2599 011321      2602 011330      2604 011351      2610 011352      2612 011353      2614 011364
   2620 011365      2622 011366      2624 011406      2630 011407      2633 011410      2635 011411      2637 011421
   2639 011426      2640 011431      2642 011433      2643 011445      2644 011540      2646 011542      2649 011556
   2650 011625      2651 011626      2654 011627      2657 011643      2659 011704      2661 011705      2667 011706
   2673 011710      2674 011712      2675 011713      2676 011723      2677 011725      2678 011753      2679 011761
   2681 011764      2682 012002      2683 012006      2684 012007      2686 012013      2688 012017      2689 012021
   2691 012022      2692 012035      2694 012037      2699 012041      2700 012043      2703 012053      2705 012056
   2707 012062      2708 012071      2710 012105      2711 012110      2713 012122      2716 012124


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
