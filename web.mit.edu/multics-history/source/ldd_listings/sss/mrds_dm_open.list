	COMPILATION LISTING OF SEGMENT mrds_dm_open
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 03/08/88  1534.0 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        6*        *                                                         *
        7*        * Copyright (c) 1976 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(88-01-19,Blair), approve(88-02-26,MCR7840), audit(88-03-03,Dupuis),
       16*     install(88-03-08,MR12.2-1034):
       17*     Add code to find the db pathname using a "mrds" searchlist. SCP6366.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 /* DESCRIPTION:
       22*
       23*   This procedure opens a data model for retrieval. A pointer to the
       24*   opened   data   model  is  returned  if  no  errors  occur.  (for
       25*   mrds_dm_open and open_dm) An opening name is associated with  the
       26*   opening for the open_model entry.
       27*
       28*   The mrds_dm_open entry is for use by internal mrds.  The  open_dm
       29*   entry  is  for  external sue by dmd_. The open_model entry is for
       30*   external use by mmi_. The external entries  check  for  the  user
       31*   being  a  DBA  if  the  database  ius secured. A DBA will get any
       32*   needed access set if an acces violation occurs.
       33*
       34**/
       35 
       36 /* PARAMETERS:
       37*
       38*   ======== open_model entry
       39*
       40*   rel_path - - (input) char(*), the relative or  absolute  pathname
       41*   of  the  database  whose  model  is  to  be  opened, no suffix is
       42*   required.
       43*
       44*   open_name - - (input) char(*), the opening name (arbitrary) to be
       45*   assoicated  with  this  opening  of  the model, and to be used in
       46*   subsequent mmi_ calls
       47*
       48*   code - - (output) fixed bin(35), the error status encoding
       49*
       50*   ======== mrds_dm_open and open_dm entries
       51*
       52*   rel_path - - (input) char(168),  the  relative  pathname  of  the
       53*   database  model  to  be  opened.  This  will be the pathname of a
       54*   directory with a msf named "data_model" under it for old  version
       55*   databases,  or  with  a segment named "db_model" under it for new
       56*   version databases, with a ".db" suffix on the directory.
       57*
       58*   mode - - (input) fixed bin, either 1 or 2, currently only mode  =
       59*   2 for retrieval from a database model is supported.
       60*
       61*   data_model_ptr - - (output) pointer, the database model  segment(
       62*   or  msf)  pointer, that is returned upon a successfull opening of
       63*   the data model.
       64*
       65*   code - -  (output)  fixed  bin(35),  the  standard  error  status
       66*   encoding, 0 unless an error occured.
       67*
       68**/
       69 
       70 /* HISTORY:
       71*
       72*   Written by RG Luebke October 1975
       73*
       74*   Modified by J. A. Weeldreyer to change header -- December, 1976.
       75*
       76*   Modified by O D Friesen to handle queued scope requests  --  July
       77*   1977
       78*
       79*   Modified by Oris Friesen to accomodate new version data bases  --
       80*   October 1978
       81*
       82*
       83*   Modified by Jim Gray - -  Jan.  1980,  to  disallow  opening  for
       84*   creation.
       85*
       86*   Rewritten by Jim Gray - - Feb. 1980,  to  correct  bad  logic  in
       87*   determining  type and version of database, and to remove obsolute
       88*   subroutine calls.
       89*
       90*   Modified by Jim Gray - - June 1980, to change  Entry  not  found.
       91*   error  message  to  the  no_database  error message, to make more
       92*   sense to higher level routines.
       93*
       94*   81-01-21 Jim Gray : modified to have access set for DBA types
       95*
       96*   81-02-12 Jim Gray : modified to have the  open_dm  entry,  called
       97*   only by dmd_, to require a DBA once the database is secured.
       98*
       99*   81-04-22 Jim Gray : added  the  open_model  entry  for  the  mmi_
      100*   interface.    Changed    path    checking    to   use   the   new
      101*   mrds_dm_check_path routine, so that suffixes  would  be  handled,
      102*   and access violation handling delayed for possible DBA setting of
      103*   needed access. The mrds_dm_open_table_mgr usage  was  removed  to
      104*   allow  the  new  open  name manager to provide the only number of
      105*   opening restrictions.
      106*
      107*   81-04-30 Jim Gray : added error_table_$no_info to codes  captured
      108*   from  hcs_$initiate  of the db_model segment, for case where user
      109*   has no acl to both db dir and db_model. This gets translated into
      110*   mrds_error_$no_model_access.
      111*
      112*   83-06-17 Davids: Replaced the generate_call to dmd_v1_$open_dm
      113*   with an error code assignment (mrds_error_$version_3_db) to indicate that
      114*   old version databases are no longer supported.
      115*
      116*   83-06-21 Davids: Removed the rest of the overhead dealing with 
      117*   old version database which is now never executed (except to decide
      118*   not to execute it).
      119**/
      120 
      121 /* BEGIN CHANGE 81-02-12 *********************************************** */
      122 
      123 mrds_dm_open: procedure (rel_path_a, mode_a, data_model_ptr_a, code_a);
      124 
      125 /* entry to be used internally by mrds code, no access restrictions */
      126 
      127 	internal_call = "1"b;
      128 	rel_path = rel_path_a;
      129 	mode = mode_a;
      130 
      131 	call common ();
      132 
      133 	data_model_ptr_a = data_model_ptr;
      134 	code_a = code;
      135 
      136 	return;
      137 
      138 
      139 
      140 
      141 
      142 
      143 
      144 open_dm: entry (rel_path_b, mode_b, data_model_ptr_b, code_b);
      145 
      146 /* entry to be called only via dmd_, never by any mrds modules,
      147*   to use this entry on a secured database, the user must be a DBA */
      148 
      149 	internal_call = "0"b;
      150 	rel_path = rel_path_b;
      151 	mode = mode_b;
      152 
      153 	call common ();
      154 
      155 	if code = 0 then
      156 	     call secured_db_check ();
      157 
      158 	data_model_ptr_b = data_model_ptr;
      159 	code_b = code;
      160 
      161 	return;
      162 
      163 /* END CHANGE 81-02-12 ********************************************* */
      164 
      165 /* BEGIN CHANGE 81-04-22 ************************************************ */
      166 
      167 open_model: entry (rel_path_c, open_name, code_c);
      168 
      169 /* this entry is called from mmi_ for opening the model,
      170*   it makes use of the open_dm entry to make sure the user
      171*   is a DBA if the database is secured. */
      172 
      173 	call open_dm ((rel_path_c), 2, model_ptr, code_c);
      174 	if code_c = 0 then do;
      175 
      176 /* opening successful, associate the model pointer with the open name */
      177 
      178 		call mu_open_name_manager$define_open_name (open_name, "m" /* model opening type */, model_ptr, code_c);
      179 
      180 	     end;
      181 
      182 	return;
      183 
      184 /* END CHANGE 81-04-22 ************************************************** */
      185 
      186 common: procedure ();
      187 
      188 /* initialize */
      189 
      190 	dbm_ptr, data_model_ptr = null ();
      191 	code = 0;
      192 
      193 /* check the opening mode given */
      194 
      195 	if mode < 1 | mode > 2 then
      196 	     code = mrds_error_$invalid_opening_mode;
      197 
      198 	else if mode = 1				/* indicates opening for creation */ then do;
      199 		code = mrds_error_$invalid_opening_mode;
      200 		call sub_err_ (code, caller_name, continue, info_ptr, return_value, "^/^a",
      201 		     "Opening database models for creation will not be allowed until a later release.");
      202 	     end;
      203 
      204 	else if mode = 2				/* open for retrieval */ then do;
      205 
      206 /* BEGIN CHANGE 81-04-22 ************************************************ */
      207 
      208 /* check on the path that was given to us, it may be
      209*   to either an old or new architecture database, and for
      210*   new databases, it may or may not have the .db suffix */
      211 
      212 		use_search_paths = "0"b;
      213 		if search (rel_path, "<>") = 0 then do;
      214 		     call search_paths_$get (MRDS_SEARCHLIST, sl_control_default, "", null (), addr(local_area),
      215 			sl_info_version_1, mrds_search_list_ptr, code);
      216 		     loop_idx = mrds_search_list_ptr -> sl_info.num_paths;
      217 		     use_search_paths = "1"b;
      218 		     end;
      219 		else do;
      220 		     call absolute_pathname_ (rel_path, abs_path, code);
      221 		     loop_idx = 1;
      222 		     end;
      223 		if code = 0 then do;
      224 		     code = 1;
      225 		     do idx = 1 to loop_idx while (code ^= 0);
      226 			if use_search_paths then abs_path = pathname_ (mrds_search_list_ptr -> sl_info.paths(idx).pathname, rel_path);
      227 			call mrds_dm_check_path (abs_path, containing_dir, db_dir, new_found, code);
      228 			if code = error_table_$incorrect_access then
      229 			     code = 0;	/* ignore access problems for right now,
      230*					              may need to set acl's for a DBA */
      231 			end;                          /* end do */
      232 		     end;
      233 
      234 		if code = 0 then do;
      235 			if ^new_found		/* old architecture */
      236 			then code = mrds_error_$version_3_db;
      237 			else do;
      238 
      239 /* now we need to get a pointer to the new architecture model segment */
      240 
      241 				db_path = rtrim (containing_dir) || ">" || db_dir;
      242 
      243 /* END CHANGE 81-04-22 ************************************************* */
      244 
      245 /* BEGIN CHANGE 81-01-21 *********************************************** */
      246 
      247 				call hcs_$initiate (db_path, "db_model", "", 0, 1, data_model_ptr, code);
      248 
      249 				if code = error_table_$moderr |
      250 				     code = error_table_$no_info then do; /* segment present */
      251 					call mrds_dm_authorization$set_needed_access
      252 					     (rtrim (db_path), code); /* if user DBA */
      253 
      254 					if code ^= 0 then
      255 					     code = mrds_error_$no_model_access; /* this used to be error_table_$moderr */
      256 					else call hcs_$initiate (db_path, "db_model", "", 0, 0, data_model_ptr, code);
      257 				     end;
      258 
      259 /* END CHANGE 81-01-21 ********************************************** */
      260 
      261 				if data_model_ptr ^= null then do;
      262 
      263 					dbm_ptr = data_model_ptr;
      264 
      265 					if db_model.version ^= 4 then
      266 					     code = error_table_$unimplemented_version;
      267 					else code = 0;
      268 
      269 
      270 				     end;
      271 			     end;
      272 		     end;
      273 
      274 	     end;
      275 
      276 	if code ^= 0 then
      277 	     data_model_ptr, dbm_ptr = null ();
      278 
      279 	return;
      280 
      281      end;
      282 
      283 /* BEGIN CHANGE 81-02-12 ********************************************* */
      284 
      285 secured_db_check: procedure ();
      286 
      287 /* routine to check for the database being is a secured state,
      288*   and if so, that the user is a DBA, and thus may use the external entry */
      289 
      290 	if code ^= 0 then ;
      291 	else if internal_call then ;
      292 	else do;
      293 
      294 /* get the secured state of the dataabase */
      295 
      296 		call mrds_dm_db_secured$get_secured_status (dbm_ptr, addr (local_area),
      297 		     database_state_structure_version, database_state_ptr, code);
      298 		if code ^= 0 then
      299 
      300 		     call sub_err_ (code, caller_name, continue, info_ptr, return_value, "^/^a^a^a",
      301 			"Unable to get the secured state of database """, db_path, """.");
      302 
      303 		else if ^database_state.secured then ;
      304 		else do;
      305 
      306 /* database secured, see if the user is a DBA */
      307 
      308 			call mrds_dm_authorization$get_user_class (rtrim (db_path), addr (local_area),
      309 			     mrds_authorization_structure_version, mrds_authorization_ptr, code);
      310 			if code ^= 0 then
      311 
      312 			     call sub_err_ (code, caller_name, continue, info_ptr, return_value, "^/^a^a^a",
      313 				"Unable to get user class for database """, db_path, """.");
      314 
      315 			else if mrds_authorization.administrator then ;
      316 			else do;
      317 
      318 /* not DBA on secured db, issue error */
      319 
      320 				code = error_table_$insufficient_access;
      321 				call sub_err_ (code, caller_name, continue, info_ptr, return_value, "^/^a^a^a ^a",
      322 				     "The database """, db_path, """ has been secured,",
      323 				     "so the caller must be a DBA to use direct model access.");
      324 
      325 			     end;
      326 
      327 		     end;
      328 
      329 	     end;
      330 
      331 	if code ^= 0 then
      332 	     data_model_ptr, dbm_ptr = null ();
      333 
      334      end;
      335 
      336 /* END CHANGE 81-02-12 ************************************************ */
      337 
      338           declare MRDS_SEARCHLIST        char (4) init ("mrds") int static options (constant);
      339           declare abs_path               char (168);
      340           declare absolute_pathname_     entry (char(*), char(*), fixed bin(35));
      341 	declare caller_name		 char (32) init ("dmd_$open_dm"); /* name of calling routine */
      342 	declare code		 fixed bin (35);	/* error return code (Output) */
      343 	declare code_a		 fixed bin (35);	/* temp for mrds_dm_open entry */
      344 	declare code_b		 fixed bin (35);	/* temp for open_dm entry */
      345 	declare code_c		 fixed bin (35);	/* error code for open_model entry */
      346 	declare containing_dir	 char (168);	/* dir over db */
      347 	declare continue		 char (1) init ("c"); /* dont stop after print mesg */
      348 	declare ctl_file		 char (32) init ("ctl_file");
      349 	declare data_model_ptr	 ptr;		/* pointer to the opened data model (Output) */
      350 	declare data_model_ptr_a	 ptr;		/* temp for mrds_dm_open entry */
      351 	declare data_model_ptr_b	 ptr;		/* temp for open_dm entry */
      352 	declare db_dir		 char (32);	/* db entry name */
      353 	declare db_path		 char (168);
      354 	declare error_table_$incorrect_access fixed bin (35) ext; /* no acl to db */
      355 	declare error_table_$insufficient_access fixed bin (35) ext; /* not DBA and db secured */
      356 	declare error_table_$moderr	 fixed bin (35) ext;/* no access */
      357 	declare error_table_$no_info	 fixed bin (35) ext;/* no acl to db dir or db_model */
      358 	declare error_table_$unimplemented_version fixed bin (35) external;
      359 	declare hcs_$initiate	 entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
      360           declare idx                    fixed bin;
      361 	declare info_ptr		 ptr init (null ());/* unused */
      362 	declare internal_call	 bit (1);		/* on => called from mrds, not by dmd_ */
      363 	declare local_area		 area (4096);	/* space for db state, user class info, and search list */
      364           declare loop_idx               fixed bin;
      365 	declare mu_open_name_manager$define_open_name entry (char (*), char (1), ptr, fixed bin (35)); /* associates name with ptr */
      366 	declare mode		 fixed bin;	/* mode of opening 1= creation 2= retrieval (Input) */
      367 	declare mode_a		 fixed bin;	/* temp for mrds_dm_open entry */
      368 	declare mode_b		 fixed bin;	/* temp for open_dm entry */
      369 	declare model_ptr		 ptr;
      370 	declare mrds_dm_authorization$get_user_class entry (char (*), ptr, fixed bin, ptr, fixed bin (35)); /* finds if DBA */
      371 	declare mrds_dm_authorization$set_needed_access entry (char (*), fixed bin (35)); /* sets access needed, if DBA */
      372 	declare mrds_dm_check_path	 entry (char (*), char (168), char (32), bit (1), fixed bin (35)); /* checks for legal db path */
      373 	declare mrds_dm_db_secured$get_secured_status entry (ptr, ptr, fixed bin, ptr, fixed bin (35)); /* gets secured bit */
      374 	declare mrds_error_$invalid_opening_mode fixed bin (35) external;
      375 	declare mrds_error_$no_model_access fixed bin (35) ext; /* no r acl on db_model */
      376 	declare mrds_error_$version_3_db fixed bin (35) ext;
      377           declare mrds_search_list_ptr   ptr;
      378 	declare new_found		 bit (1);		/* on => new version architecture */
      379 	declare open_name		 char (*);	/* user defined opening name */
      380           declare pathname_              entry (char(*), char(*)) returns(char(168));
      381 	declare rel_path		 char (168);	/* pathname of data model  (Input) */
      382 	declare rel_path_a		 char (168);	/* temp for mrds_dm_open entry */
      383 	declare rel_path_b		 char (168);	/* temp for open_dm entry */
      384 	declare rel_path_c		 char (*);	/* relative db path for open_model entry */
      385 	declare return_value	 fixed bin (35) init (0); /* unused */
      386           declare search_paths_$get      entry (char(*), bit(36), char(*), ptr, ptr, fixed bin, ptr, fixed bin(35));
      387 	declare sub_err_		 entry options (variable); /* reports errors */
      388 	declare sys_info$max_seg_size	 fixed bin (35) ext;
      389           declare use_search_paths       bit (1);
      390 	declare (addr, empty, fixed, null, rel, rtrim, search) builtin;
      391 
  1     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  1     6*     modified to save space occupied by model
  1     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  1     8*     to add mdbm_secured bit in db_model
  1     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  1    10*     collapsed the following into an unused_offset array:
  1    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  1    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  1    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  1    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  1    15*       unused_1
  1    16*     Also changed the name of unused_2 to restructuring_history_offset
  1    17*     and changed the comment on the changer structure to indicate
  1    18*     that it will contain on database creation information.
  1    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  1    20*     used one of the unused_offsets to point to a message which indicates
  1    21*     why the db is inconsistent. The offset will be null when the db is created
  1    22*     and set the first time the message is used. this is so it will be
  1    23*     consistent with existing data bases. Also added the message structure.
  1    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  1    25*     added the undo_request element to the message structure
  1    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  1    27*     changed unused_offset (12) to last_restructruring_history_offset and
  1    28*     changed restructuring_history_offset to first_restructuring_history_offset
  1    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  1    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  1    31*     1 => vfile database and 2 => page_file database. Up to this point all
  1    32*     database types were equal to 1.
  1    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  1    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  1    35*     flags. This will allow information about transactions and dm_file
  1    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  1    37*     change is compatable with all datamodels created by the released version
  1    38*     of mrds.
  1    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  1    40*     added the rollback_on flag to the db_type_flags since it appears that you
  1    41*     can have a dmfile database that requires transactions but does not have any
  1    42*     journalizing. Also switched the order of the transactions_needed and
  1    43*     concurrency_on flags - this makes the change compatable with existing
  1    44*     dmfile databases except when displaying the model since concurrency_on and
  1    45*     rollback_on will be off in the model even though the dmfile relations had
  1    46*     them on during creation.
  1    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  1    48*      Removed ctl_file_path_ptr.
  1    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  1    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  1    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  1    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  1    53*      in the flag word for rmdb copying.
  1    54*                                                   END HISTORY COMMENTS */
  1    55 
  1    56 
  1    57 /* this include file contains the structures that go into the make up
  1    58*   of the "db_model" segment in the model for the database.
  1    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  1    60*
  1    61*   the db_model structure goes at the base of the segment, and contains items unique to
  1    62*   the whole databse. in addition, it has an area of size to fill the
  1    63*   rest of a segment, that holds the lists of files and domains in the database.
  1    64*   these lists are singly forward linked lists. all "pointers" in the database model
  1    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  1    66*   since actual pointers are process dependent on segment number.
  1    67*   the remaining structures are first a path_entry one to save pathnames in,
  1    68*   and the stack_item and constent structures, used to save a boolean
  1    69*   expression in polish form, with the stack represented by a linked list.
  1    70*   the final structure is one for identifying the status of version information */
  1    71 
  1    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  1    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  1    74 	     2 db_type_flags      unal,
  1    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  1    76 	       3 unused	      (13) bit (1) unal,
  1    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  1    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  1    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  1    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  1    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  1    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  1    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  1    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  1    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  1    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  1    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  1    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  1    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  1    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  1    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  1    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  1    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  1    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  1    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  1    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  1    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  1    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  1    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  1   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  1   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  1   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  1   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  1   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  1   105 
  1   106      dcl	   dbm_ptr	      ptr;
  1   107 
  1   108 /* the files in the database each have a file_info containing
  1   109*   their name, the file_model for each file is found by initiating the
  1   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  1   111*   the file_info list is a singly linked list in definition order */
  1   112 
  1   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  1   114 	     2 file_name	      char (30),		/* name of file */
  1   115 	     2 file_id	      bit (36),		/* id number of file */
  1   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  1   117 	     2 unused	      unal bit (18);	/* for future expansion */
  1   118 
  1   119      dcl	   fi_ptr		      ptr;
  1   120 
  1   121 /* each domain used in the database will have a domain info saved in the db_model
  1   122*   segment. it describes the domain of the given name, and it's options.
  1   123*   the domain_info's form a singly linked list in definition order */
  1   124 
  1   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  1   126 	     2 name	      char (32),		/* name of domain */
  1   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  1   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  1   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  1   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  1   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  1   132 	     2 reserved	      bit (31) unal,
  1   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  1   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  1   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  1   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  1   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  1   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  1   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  1   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  1   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  1   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  1   143 	     2 str_err_path_ptr   unal bit (18),
  1   144 	     2 str_after_path_ptr unal bit (18),
  1   145 	     2 get_before_path_ptr unal bit (18),
  1   146 	     2 get_err_path_ptr   unal bit (18),
  1   147 	     2 get_after_path_ptr unal bit (18),
  1   148 	     2 mod_before_path_ptr unal bit (18),
  1   149 	     2 mod_err_path_ptr   unal bit (18),
  1   150 	     2 mod_after_path_ptr unal bit (18),
  1   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  1   152 	     2 unused_2	      unal bit (18),
  1   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  1   154 
  1   155      dcl	   di_ptr		      ptr;
  1   156 
  1   157 /* information necessary for attributes that are not used in any relation */
  1   158 
  1   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  1   160 	     2 name char (32),			/* name of attribute */
  1   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  1   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  1   163 	     2 unused (2) bit (18) unal;
  1   164 
  1   165      dcl     ua_ptr ptr;
  1   166 
  1   167 
  1   168 /* space saving pathname$entryname structure, to be allocated
  1   169*   only when a path$entry has to be saved, else only a bit(18)
  1   170*   offset takes up space in the main model structure */
  1   171 
  1   172      declare 1 path_entry	      based (path_entry_ptr),
  1   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  1   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  1   175 	     2 reserved	      unal bit (36);	/* for future use */
  1   176 
  1   177      declare path_entry_ptr	      ptr;
  1   178 
  1   179 
  1   180 
  1   181 
  1   182 
  1   183 /* declarations for model of postfix stack holding the check option boolean expression
  1   184*   the following encoding values indicate the corresponding type of stack element
  1   185*
  1   186*   1  =
  1   187*   2  ^=
  1   188*   3  >
  1   189*   4  <
  1   190*   5  >=
  1   191*   6  <=
  1   192*
  1   193*   10  and
  1   194*   20  or
  1   195*   30  not
  1   196*
  1   197*   40  - (minus)
  1   198*
  1   199*   50  domain variable(same name as domain)
  1   200*
  1   201*   60  constant(number, bit string, or character string)
  1   202*
  1   203**/
  1   204 
  1   205 
  1   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  1   207 	     2 next	      bit (18),		/* link to next in list */
  1   208 	     2 type	      fixed binary,		/* code for this element type */
  1   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  1   210*						   if this is a constant element type */
  1   211 
  1   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  1   213 
  1   214 
  1   215 
  1   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  1   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  1   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  1   219 
  1   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  1   221 
  1   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  1   223 
  1   224 /* version structure, giving status of source for CMDB/RMDB,
  1   225*   status of model, and status of resultant */
  1   226 
  1   227 /* version number is in form MM.N.Y
  1   228*   where MM is the major version number, N is the minor version alteration,
  1   229*   and Y is the lastest modification to that alteration,
  1   230*   where M and N represent numbers 0-9, and Y is a letter */
  1   231 
  1   232      declare 1 version_status	      unal based (version_status_ptr),
  1   233 	     2 cmdb_rmdb,
  1   234 	       3 major	      fixed bin,
  1   235 	       3 minor	      fixed bin,
  1   236 	       3 modification     char (4),
  1   237 	     2 model,
  1   238 	       3 major	      fixed bin,
  1   239 	       3 minor	      fixed bin,
  1   240 	       3 modification     char (4),
  1   241 	     2 resultant,
  1   242 	       3 major	      fixed bin,
  1   243 	       3 minor	      fixed bin,
  1   244 	       3 modification     char (4);
  1   245 
  1   246      declare version_status_ptr     ptr;
  1   247 
  1   248 
  1   249 /* maintains information only about the db creation */
  1   250 
  1   251      declare 1 changer	      unal based (changer_ptr),
  1   252 	     2 id		      char (32),
  1   253 	     2 time	      fixed bin (71),
  1   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  1   255 
  1   256      declare changer_ptr	      ptr;
  1   257 
  1   258 
  1   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  1   260 	     02 len	      fixed bin,		/* length of the message */
  1   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  1   262 	     02 name	      char (32),		/* name of thing that set the message */
  1   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  1   264*                                                               that caused the database to become inconsistent */
  1   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  1   266 
  1   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  1   268 
  1   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  1   270 
  1   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  1   272 
  1   273 
      392 
      393 
  2     1 /* BEGIN INCLUDE FILE mrds_authorization.incl.pl1 - - 81-01-20 Jim Gray */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*   81-01-20 Jim Gray : original created for the mmi_$get_authorization interface
  2     6*
  2     7**/
  2     8 
  2     9 /* DESCRIPTION:
  2    10*
  2    11*   this structure returns the callers user_class
  2    12*   either database administrator or normal user.
  2    13*   Note that these separate classes were used to allow
  2    14*   future expansion to the user classes, rather than
  2    15*   make them logical "not"'s of one another.
  2    16*   NOTE: a DBA is always also a normal user, thus if the caller
  2    17*   is a DBA, his normal_user bit will be on also.
  2    18*
  2    19**/
  2    20 
  2    21 
  2    22 declare 1 mrds_authorization aligned based (mrds_authorization_ptr),
  2    23         2 version fixed bin,				/* version number of this structure */
  2    24         2 administrator bit (1) unal,			/* caller is a DBA */
  2    25         2 normal_user bit (1) unal,			/* caller has no special priviledges */
  2    26         2 mbz bit (34) unal ;
  2    27 
  2    28 
  2    29 declare  mrds_authorization_ptr ptr ;			/* pointer for referring to the structure */
  2    30 
  2    31 declare  mrds_authorization_structure_version fixed bin init (1) int static options (constant) ;
  2    32 
  2    33 /* END INCLUDE FILE mrds_authorization.incl.pl1 */
      394 
      395 
  3     1 /* BEGIN INCLUDE FILE mrds_database_state.incl.pl1 - - 81-01-20 Jim Gray */
  3     2 
  3     3 /* HISTORY:
  3     4*
  3     5*   81-01-20 Jim Gray : original created for the mmi_$get_secured_status interface
  3     6*
  3     7**/
  3     8 
  3     9 /* DESCRIPTION:
  3    10*
  3    11*   This structure returns the database state (secured or unsecured)
  3    12*   for determining how commands and subroutines will behave for each case.
  3    13*   The secured bit was kept separate from the unsecured,
  3    14*   rather than it's logical "not", to allow for future extensibility
  3    15*   of database secured states.
  3    16*
  3    17**/
  3    18 
  3    19 
  3    20 declare 1 database_state aligned based (database_state_ptr),
  3    21         2 version fixed bin,				/* version number of this structure */
  3    22         2 unsecured bit (1) unal,			/* database not secured */
  3    23         2 secured bit (1) unal,			/* database has been secured */
  3    24         2 mbz bit (34) unal ;
  3    25 
  3    26 
  3    27 declare  database_state_ptr ptr ;			/* pointer for referring to the structure */
  3    28 
  3    29 declare  database_state_structure_version fixed bin init (1) int static options (constant) ;
  3    30 
  3    31 /* END INCLUDE FILE mrds_database_state.incl.pl1 */
      396 
      397 
  4     1 /* BEGIN INCLUDE FILE . . . sl_info.incl.pl1 */
  4     2 
  4     3      
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(87-11-16,Lippard), approve(87-12-21,MCR7822),
  4     7*     audit(88-02-09,Blair), install(88-02-16,MR12.2-1023):
  4     8*     Modified to add INITIATED_SEGS type.
  4     9*  2) change(87-11-19,Lippard), approve(87-12-21,MCR7822),
  4    10*     audit(88-02-09,Blair), install(88-02-16,MR12.2-1023):
  4    11*     Added uid to sl_info structure.
  4    12*                                                   END HISTORY COMMENTS */
  4    13 
  4    14 
  4    15 declare 1 sl_info	      aligned based (sl_info_p),
  4    16 	     2 version	      fixed binary,		/* Must be 1 */
  4    17 	     2 num_paths	      fixed binary,		/* Number of search paths */
  4    18 	     2 change_index_p     pointer,		/* Pointer to search list's update count */
  4    19 	     2 change_index	      fixed binary (71),	/* This search list's update count */
  4    20 	     2 pad1	      (6) bit (36),		/* Must be zero */
  4    21 	     2 paths	      (sl_info_num_paths refer (sl_info.num_paths)),
  4    22 	       3 type	      fixed binary,		/* Type of search path */
  4    23 	       3 code	      fixed binary (35),	/* Standard status code of search path */
  4    24 	       3 uid	      bit (36),		/* Unique ID */
  4    25 	       3 pathname	      char (168) unaligned;	/* Search pathname */
  4    26 
  4    27      declare sl_info_num_paths      fixed binary;
  4    28      declare sl_info_p	      pointer;
  4    29      declare sl_info_version_1      fixed binary internal static options (constant) initial (1);
  4    30 
  4    31 /* Keyword Types */
  4    32 
  4    33      declare ABSOLUTE_PATH	      fixed binary internal static options (constant) initial (0);
  4    34      declare UNEXPANDED_PATH	      fixed binary internal static options (constant) initial (1);
  4    35      declare REFERENCING_DIR	      fixed binary internal static options (constant) initial (3);
  4    36      declare WORKING_DIR	      fixed binary internal static options (constant) initial (4);
  4    37      declare PROCESS_DIR	      fixed binary internal static options (constant) initial (5);
  4    38      declare HOME_DIR	      fixed binary internal static options (constant) initial (6);
  4    39      declare INITIATED_SEGS	      fixed binary internal static options (constant) initial (7);
  4    40 
  4    41 /* END INCLUDE FILE . . . sl_info.incl.pl1 */
      398 
      399 
  5     1 /* BEGIN INCLUDE FILE . . . sl_control_s.incl.pl1 */
  5     2 
  5     3      declare 1 sl_control_s	      unaligned based (addr (sl_control)),
  5     4 	     2 af_pathname	      bit (1),		/* "1"b => expand active functions */
  5     5 	     2 pad1	      bit (1),		/* Must be zero */
  5     6 	     2 key_ref_dir	      bit (1),		/* "1"b => expand -referencing_dir keyword */
  5     7 	     2 key_work_dir	      bit (1),		/* "1"b => expand -working_dir keyword */
  5     8 	     2 key_proc_dir	      bit (1),		/* "1"b => expand -process_dir keyword */
  5     9 	     2 key_home_dir	      bit (1),		/* "1"b => expand -home_dir keyword */
  5    10 	     2 pad2	      bit (30);		/* Must be zero */
  5    11 
  5    12      declare sl_control	      bit (36);
  5    13      declare sl_control_default     bit (36) internal static options (constant) initial ("101111"b);
  5    14 
  5    15 /* END INCLUDE FILE . . . sl_control_s.incl.pl1 */
      400 
      401 
      402      end mrds_dm_open;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/08/88  1531.6  mrds_dm_open.pl1                  >spec>install>1034>mrds_dm_open.pl1
392          1    10/17/86  1404.3  mdbm_db_model.incl.pl1            >ldd>include>mdbm_db_model.incl.pl1
394          2    10/14/83  1608.8  mrds_authorization.incl.pl1       >ldd>include>mrds_authorization.incl.pl1
396          3    10/14/83  1608.8  mrds_database_state.incl.pl1      >ldd>include>mrds_database_state.incl.pl1
398          4    02/18/88  2023.8  sl_info.incl.pl1                  >ldd>include>sl_info.incl.pl1
400          5    01/09/79  1617.9  sl_control_s.incl.pl1             >ldd>include>sl_control_s.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
MRDS_SEARCHLIST                 000001 constant        char(4)                  initial packed unaligned dcl 338 set ref 214*
abs_path                        000100 automatic       char(168)                packed unaligned dcl 339 set ref 220* 226* 227*
absolute_pathname_              000010 constant        entry                    external dcl 340 ref 220
addr                                                   builtin function         dcl 390 ref 214 214 296 296 308 308
administrator             1            based           bit(1)                   level 2 packed packed unaligned dcl 2-22 ref 315
caller_name                     000152 automatic       char(32)                 initial packed unaligned dcl 341 set ref 200* 298*
                                                                                  310* 321* 341*
code                            000162 automatic       fixed bin(35,0)          dcl 342 set ref 134 155 159 191* 195* 199* 200* 214*
                                                                                  220* 223 224* 225 227* 228 228* 234 235* 247* 249
                                                                                  249 251* 254 254* 256* 265* 267* 276 290 296* 298
                                                                                  298* 308* 310 310* 320* 321* 331
code_a                                 parameter       fixed bin(35,0)          dcl 343 set ref 123 134*
code_b                                 parameter       fixed bin(35,0)          dcl 344 set ref 144 159*
code_c                                 parameter       fixed bin(35,0)          dcl 345 set ref 167 173* 174 178*
containing_dir                  000163 automatic       char(168)                packed unaligned dcl 346 set ref 227* 241
continue                        000235 automatic       char(1)                  initial packed unaligned dcl 347 set ref 200* 298*
                                                                                  310* 321* 347*
ctl_file                        000236 automatic       char(32)                 initial packed unaligned dcl 348 set ref 348*
data_model_ptr                  000246 automatic       pointer                  dcl 349 set ref 133 158 190* 247* 256* 261 263 276*
                                                                                  331*
data_model_ptr_a                       parameter       pointer                  dcl 350 set ref 123 133*
data_model_ptr_b                       parameter       pointer                  dcl 351 set ref 144 158*
database_state                         based           structure                level 1 dcl 3-20
database_state_ptr              010430 automatic       pointer                  dcl 3-27 set ref 296* 303
database_state_structure_version
                                000033 constant        fixed bin(17,0)          initial dcl 3-29 set ref 296*
db_dir                          000250 automatic       char(32)                 packed unaligned dcl 352 set ref 227* 241
db_model                               based           structure                level 1 dcl 1-72
db_path                         000260 automatic       char(168)                packed unaligned dcl 353 set ref 241* 247* 251 251
                                                                                  256* 298* 308 308 310* 321*
dbm_ptr                         010424 automatic       pointer                  dcl 1-106 set ref 190* 263* 265 276* 296* 331*
empty                                                  builtin function         dcl 390 ref 363
error_table_$incorrect_access   000012 external static fixed bin(35,0)          dcl 354 ref 228
error_table_$insufficient_access
                                000014 external static fixed bin(35,0)          dcl 355 ref 320
error_table_$moderr             000016 external static fixed bin(35,0)          dcl 356 ref 249
error_table_$no_info            000020 external static fixed bin(35,0)          dcl 357 ref 249
error_table_$unimplemented_version
                                000022 external static fixed bin(35,0)          dcl 358 ref 265
hcs_$initiate                   000024 constant        entry                    external dcl 359 ref 247 256
idx                             000332 automatic       fixed bin(17,0)          dcl 360 set ref 225* 226*
info_ptr                        000334 automatic       pointer                  initial dcl 361 set ref 200* 298* 310* 321* 361*
internal_call                   000336 automatic       bit(1)                   packed unaligned dcl 362 set ref 127* 149* 291
local_area                      000340 automatic       area(4096)               dcl 363 set ref 214 214 296 296 308 308 363*
loop_idx                        010340 automatic       fixed bin(17,0)          dcl 364 set ref 216* 221* 225
mode                            010341 automatic       fixed bin(17,0)          dcl 366 set ref 129* 151* 195 195 198 204
mode_a                                 parameter       fixed bin(17,0)          dcl 367 ref 123 129
mode_b                                 parameter       fixed bin(17,0)          dcl 368 ref 144 151
model_ptr                       010342 automatic       pointer                  dcl 369 set ref 173* 178*
mrds_authorization                     based           structure                level 1 dcl 2-22
mrds_authorization_ptr          010426 automatic       pointer                  dcl 2-29 set ref 308* 315
mrds_authorization_structure_version
                                000033 constant        fixed bin(17,0)          initial dcl 2-31 set ref 308*
mrds_dm_authorization$get_user_class
                                000030 constant        entry                    external dcl 370 ref 308
mrds_dm_authorization$set_needed_access
                                000032 constant        entry                    external dcl 371 ref 251
mrds_dm_check_path              000034 constant        entry                    external dcl 372 ref 227
mrds_dm_db_secured$get_secured_status
                                000036 constant        entry                    external dcl 373 ref 296
mrds_error_$invalid_opening_mode
                                000040 external static fixed bin(35,0)          dcl 374 ref 195 199
mrds_error_$no_model_access     000042 external static fixed bin(35,0)          dcl 375 ref 254
mrds_error_$version_3_db        000044 external static fixed bin(35,0)          dcl 376 ref 235
mrds_search_list_ptr            010344 automatic       pointer                  dcl 377 set ref 214* 216 226
mu_open_name_manager$define_open_name
                                000026 constant        entry                    external dcl 365 ref 178
new_found                       010346 automatic       bit(1)                   packed unaligned dcl 378 set ref 227* 235
null                                                   builtin function         dcl 390 ref 190 214 214 261 276 331 361
num_paths                 1            based           fixed bin(17,0)          level 2 dcl 4-15 ref 216
open_name                              parameter       char                     packed unaligned dcl 379 set ref 167 178*
pathname                 17            based           char(168)                array level 3 packed packed unaligned dcl 4-15 set
                                                                                  ref 226*
pathname_                       000046 constant        entry                    external dcl 380 ref 226
paths                    14            based           structure                array level 2 dcl 4-15
rel_path                        010347 automatic       char(168)                packed unaligned dcl 381 set ref 128* 150* 213 220*
                                                                                  226*
rel_path_a                             parameter       char(168)                packed unaligned dcl 382 ref 123 128
rel_path_b                             parameter       char(168)                packed unaligned dcl 383 ref 144 150
rel_path_c                             parameter       char                     packed unaligned dcl 384 ref 167 173
return_value                    010421 automatic       fixed bin(35,0)          initial dcl 385 set ref 200* 298* 310* 321* 385*
rtrim                                                  builtin function         dcl 390 ref 241 251 251 308 308
search                                                 builtin function         dcl 390 ref 213
search_paths_$get               000050 constant        entry                    external dcl 386 ref 214
secured                   1(01)        based           bit(1)                   level 2 packed packed unaligned dcl 3-20 ref 303
sl_control_default              000000 constant        bit(36)                  initial packed unaligned dcl 5-13 set ref 214*
sl_info                                based           structure                level 1 dcl 4-15
sl_info_version_1               000033 constant        fixed bin(17,0)          initial dcl 4-29 set ref 214*
sub_err_                        000052 constant        entry                    external dcl 387 ref 200 298 310 321
use_search_paths                010422 automatic       bit(1)                   packed unaligned dcl 389 set ref 212* 217* 226
version                                based           fixed bin(17,0)          level 2 packed packed unaligned dcl 1-72 ref 265

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSOLUTE_PATH                          internal static fixed bin(17,0)          initial dcl 4-33
HOME_DIR                               internal static fixed bin(17,0)          initial dcl 4-38
INITIATED_SEGS                         internal static fixed bin(17,0)          initial dcl 4-39
PROCESS_DIR                            internal static fixed bin(17,0)          initial dcl 4-37
REFERENCING_DIR                        internal static fixed bin(17,0)          initial dcl 4-35
UNEXPANDED_PATH                        internal static fixed bin(17,0)          initial dcl 4-34
WORKING_DIR                            internal static fixed bin(17,0)          initial dcl 4-36
alloc_length                           internal static fixed bin(35,0)          dcl 1-222
changer                                based           structure                level 1 packed packed unaligned dcl 1-251
changer_ptr                            automatic       pointer                  dcl 1-256
constant                               based           structure                level 1 unaligned dcl 1-216
constant_ptr                           automatic       pointer                  dcl 1-220
di_ptr                                 automatic       pointer                  dcl 1-155
domain_info                            based           structure                level 1 dcl 1-125
fi_ptr                                 automatic       pointer                  dcl 1-119
file_info                              based           structure                level 1 dcl 1-113
fixed                                                  builtin function         dcl 390
message_str                            based           structure                level 1 packed packed unaligned dcl 1-259
message_str_len                        automatic       fixed bin(17,0)          dcl 1-269
message_str_ptr                        automatic       pointer                  dcl 1-267
path_entry                             based           structure                level 1 packed packed unaligned dcl 1-172
path_entry_ptr                         automatic       pointer                  dcl 1-177
rel                                                    builtin function         dcl 390
sl_control                             automatic       bit(36)                  packed unaligned dcl 5-12
sl_control_s                           based           structure                level 1 packed packed unaligned dcl 5-3
sl_info_num_paths                      automatic       fixed bin(17,0)          dcl 4-27
sl_info_p                              automatic       pointer                  dcl 4-28
stack_item                             based           structure                level 1 unaligned dcl 1-206
stack_item_ptr                         automatic       pointer                  dcl 1-212
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 388
ua_ptr                                 automatic       pointer                  dcl 1-165
unreferenced_attribute                 based           structure                level 1 dcl 1-159
version_status                         based           structure                level 1 packed packed unaligned dcl 1-232
version_status_ptr                     automatic       pointer                  dcl 1-246

NAMES DECLARED BY EXPLICIT CONTEXT.
common                          000366 constant        entry                    internal dcl 186 ref 131 153
mrds_dm_open                    000201 constant        entry                    external dcl 123
open_dm                         000231 constant        entry                    external dcl 144 ref 173
open_model                      000265 constant        entry                    external dcl 167
secured_db_check                001157 constant        entry                    internal dcl 285 ref 155

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2244        2320    1746        2254
Length      2626    1746        54         272     275           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_dm_open                       4658 external procedure  is an external procedure.  
common                                  internal procedure  shares stack frame of external procedure mrds_dm_open.  
secured_db_check                        internal procedure  shares stack frame of external procedure mrds_dm_open.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_dm_open             000100 abs_path                    mrds_dm_open
                         000152 caller_name                 mrds_dm_open
                         000162 code                        mrds_dm_open
                         000163 containing_dir              mrds_dm_open
                         000235 continue                    mrds_dm_open
                         000236 ctl_file                    mrds_dm_open
                         000246 data_model_ptr              mrds_dm_open
                         000250 db_dir                      mrds_dm_open
                         000260 db_path                     mrds_dm_open
                         000332 idx                         mrds_dm_open
                         000334 info_ptr                    mrds_dm_open
                         000336 internal_call               mrds_dm_open
                         000340 local_area                  mrds_dm_open
                         010340 loop_idx                    mrds_dm_open
                         010341 mode                        mrds_dm_open
                         010342 model_ptr                   mrds_dm_open
                         010344 mrds_search_list_ptr        mrds_dm_open
                         010346 new_found                   mrds_dm_open
                         010347 rel_path                    mrds_dm_open
                         010421 return_value                mrds_dm_open
                         010422 use_search_paths            mrds_dm_open
                         010424 dbm_ptr                     mrds_dm_open
                         010426 mrds_authorization_ptr      mrds_dm_open
                         010430 database_state_ptr          mrds_dm_open

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_in         call_ext_out_desc   call_ext_out        return_mac
shorten_stack       ext_entry           ext_entry_desc      op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absolute_pathname_            hcs_$initiate                 mrds_dm_authorization$get_user_class
mrds_dm_authorization$set_needed_access                     mrds_dm_check_path
mrds_dm_db_secured$get_secured_status                       mu_open_name_manager$define_open_name
pathname_                     search_paths_$get             sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$incorrect_access error_table_$insufficient_access                            error_table_$moderr
error_table_$no_info          error_table_$unimplemented_version
mrds_error_$invalid_opening_mode                            mrds_error_$no_model_access   mrds_error_$version_3_db




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    341 000154       347 000157       348 000161       361 000164       363 000166       385 000171       123 000174
    127 000207       128 000211       129 000216       131 000220       133 000221       134 000224       136 000226
    144 000227       149 000237       150 000240       151 000245       153 000247       155 000250       158 000253
    159 000256       161 000260       167 000261       173 000306       174 000332       178 000335       182 000365
    186 000366       190 000367       191 000372       195 000373       198 000404       199 000406       200 000411
    202 000455       204 000456       212 000460       213 000461       214 000473       216 000542       217 000545
    218 000547       220 000550       221 000570       223 000572       224 000574       225 000576       226 000607
    227 000636       228 000666       231 000673       234 000675       235 000677       241 000706       247 000745
    249 001014       251 001022       254 001056       256 001065       261 001132       263 001136       265 001140
    267 001150       276 001151       279 001156       285 001157       290 001160       291 001163       296 001166
    298 001207       303 001271       308 001276       310 001350       315 001433       320 001440       321 001443
    331 001537       334 001544


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
