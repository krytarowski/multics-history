	COMPILATION LISTING OF SEGMENT im_build_interval_spec
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/02/86  1217.1 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION:
        8*
        9*         This  module  takes  a search_specification as input and produces an
       10*     interval_specification as output.  The interval_specification consists of
       11*     a series of value intervals which  are  non-overlapping,  each  of  which
       12*     "points"   at   one   or   more   of   the   and_groups   in   the  input
       13*     search_specification.
       14**/
       15 
       16 /* HISTORY:
       17*
       18*Written by Lindsey L. Spratt, 10/06/82.
       19*Modified:
       20*10/27/82 by Lindsey Spratt:  Fixed check for purely sequential and_group.
       21*12/06/82 by Lindsey Spratt:  Extended to return a single "null" interval_bead
       22*	  when there are no and_groups.  Also, added a finish proc which
       23*	  is called before returning and on cleanup.
       24*12/09/82 by Lindsey Spratt:  Fixed to initialize interval_bead.next to null.
       25*05/24/83 by Matthew Pierret: Changed to use version 4 of specification_head,
       26*            which includes constraint().value_field_id.
       27*07/11/83 by Matthew Pierret: Extended field_presence_array to keep track of
       28*            non_structural, structural equal and structural less or greater
       29*            fields.  Changed to allow number_of_equal_fields to include the
       30*            first_range_field if that field is an equal field.
       31*            Changed to allow for the possibility of first_range_field being
       32*            equal to number_of_equal_fields when setting the low and high
       33*            constraint idx in SIMPLE_RANGE_CONSTRAINT.   
       34*08/05/83 by Matthew Pierret: Fixed a bug in the setting of the low and high 
       35*            constraint idx.  In the case where the last equal field has more
       36*            than one constraint on it, one being an equal operator and the other
       37*            a range operator, the range operator should be considered to be
       38*            non-structural.  
       39*07/16/84 by Matthew C. Pierret:  Changed the CONSTRAINT_LOOP to detect that
       40*            there are multiple equal constraints on the same field, and to
       41*            consider that case to be both an equal and a non-structural
       42*            constraint.
       43*10/28/84 by Lindsey L. Spratt:  Changed to use version 2
       44*            interval_specification.  Some remodularization was done.
       45**/
       46 
       47 /* format: style2,ind3 */
       48 im_build_interval_spec:
       49    proc (p_work_area_ptr, p_search_specification_ptr, p_interval_specification_ptr, p_code);
       50 
       51 /* START OF DECLARATIONS */
       52 /* Parameter */
       53 
       54       dcl	    p_work_area_ptr	       ptr parameter;
       55       dcl	    p_search_specification_ptr
       56 			       ptr parameter;
       57       dcl	    p_interval_specification_ptr
       58 			       ptr parameter;
       59       dcl	    p_code	       fixed bin (35) parameter;
       60 
       61 /* Automatic */
       62 
       63       dcl	    first_range_field_is_not_adjacent_to_equal_fields
       64 			       bit (1) aligned init ("0"b);
       65 
       66       dcl	    old_interval_bead_ptr  ptr init (null);
       67       dcl	    root_interval_bead_ptr ptr init (null);
       68       dcl	    temp_interval_bead_ptr ptr init (null);
       69       dcl	    field_presence_array_ptr
       70 			       ptr init (null);
       71       dcl	    temp_next_ptr	       ptr init (null);
       72 
       73       dcl	    fpa_number_of_fields   fixed bin;
       74       dcl	    and_group_idx	       fixed bin;
       75       dcl	    first_range_field      fixed bin;
       76       dcl	    number_of_equal_fields fixed bin;
       77       dcl	    number_of_intervals    fixed bin init (0);
       78       dcl	    constraint_idx	       fixed bin;
       79       dcl	    (last_constraint_idx, low_constraint_idx, high_constraint_idx)
       80 			       fixed bin init (0);
       81 
       82       dcl	    constraint_field_id    fixed bin;
       83       dcl	    constraint_operator_code
       84 			       fixed bin (18) uns;
       85 
       86       dcl	    work_area_ptr	       ptr init (null);
       87 
       88 /* Based */
       89 
       90       dcl	    1 field_presence_array (fpa_number_of_fields) aligned based (field_presence_array_ptr),
       91 	      2 non_structural     bit (1) unal,
       92 	      2 structural	       unal,
       93 	        3 equal	       bit (1) unal,
       94 	        3 less_or_greater  bit (1) unal;
       95 
       96       dcl	    work_area	       based (work_area_ptr) area;
       97 
       98 /* Builtin */
       99 
      100       dcl	    (sum, null, min)       builtin;
      101 
      102 /* Condition */
      103 
      104       dcl	    cleanup	       condition;
      105 
      106 /* Constant */
      107 
      108       dcl	    myname	       init ("im_build_interval_spec") char (32) varying internal static options (constant);
      109       dcl	    (
      110 	    IS_PRESENT	       init ("1"b),
      111 	    NOT_PRESENT	       init ("0"b)
      112 	    )		       bit (1) unal internal static options (constant);
      113 
      114 /* Entry */
      115 
      116       dcl	    sub_err_	       entry () options (variable);
      117 
      118 /* External */
      119 
      120       dcl	    (
      121 	    dm_error_$programming_error,
      122 	    error_table_$unimplemented_version
      123 	    )		       fixed bin (35) ext;
      124 
      125 /* END OF DECLARATIONS */
      126 
      127       work_area_ptr = p_work_area_ptr;
      128       search_specification_ptr = p_search_specification_ptr;
      129       call CHECK_VERSION (search_specification.version, SPECIFICATION_VERSION_4, "specification");
      130       if search_specification.head.type ^= ABSOLUTE_SEARCH_SPECIFICATION_TYPE
      131 	 & search_specification.head.type ^= RELATIVE_SEARCH_SPECIFICATION_TYPE
      132       then call sub_err_ (error_table_$unimplemented_version, myname, "s", null, 0,
      133 	      "^/Expected a ""search"" type (^d or ^d) specification structure.
      134 Received a structure of type ^d, instead.", ABSOLUTE_SEARCH_SPECIFICATION_TYPE, RELATIVE_SEARCH_SPECIFICATION_TYPE,
      135 	      search_specification.head.type);
      136       p_code = 0;
      137 
      138       interval_specification_ptr = null;
      139       interval_bead_ptr = null;
      140       field_presence_array_ptr = null;
      141 
      142       on cleanup call FINISH;
      143 
      144       if search_specification.number_of_and_groups = 0
      145       then
      146          do;
      147 	  alloc interval_bead in (work_area);
      148 	  interval_bead.next = null;
      149 	  interval_bead.simple_typed_vector_ptr = null;
      150 	  interval_bead.low.value_ptr, interval_bead.high.value_ptr = null;
      151 	  interval_bead.low.operator_code, interval_bead.high.operator_code = 0;
      152 	  interval_bead.number_of_fully_structural_fields = 0;
      153 	  interval_bead.id_list_ptr = null;
      154 	  interval_bead.low.id_string, interval_bead.high.id_string = "0"b;
      155 	  root_interval_bead_ptr = interval_bead_ptr;
      156 	  number_of_intervals = 1;
      157          end;
      158       else
      159          do;
      160 	  fpa_number_of_fields = sum (search_specification.and_group.number_of_constraints) + 1;
      161 	  alloc field_presence_array in (work_area);
      162 	  string (field_presence_array (*)) = "0"b;
      163 
      164 /* For each and_group, one interval_bead is constructed.  The interval_bead */
      165 /* identifies the "low" end of the interval and the "high" end, among other */
      166 /* things. */
      167 
      168 AND_GROUP_LOOP:
      169 	  do and_group_idx = 1 to search_specification.number_of_and_groups;
      170 	     call PROCESS_AND_GROUP (and_group_idx);
      171 	  end AND_GROUP_LOOP;
      172          end;
      173 
      174       alloc interval_specification in (work_area);
      175       interval_specification.version = INTERVAL_SPECIFICATION_VERSION_2;
      176       interval_specification.number_of_intervals = number_of_intervals;
      177       interval_specification.first_interval_bead_ptr = root_interval_bead_ptr;
      178       interval_specification.last_interval_bead_ptr = interval_bead_ptr;
      179 
      180       p_interval_specification_ptr = interval_specification_ptr;
      181       call FINISH;
      182 
      183       return;
      184 
      185 CHECK_VERSION:
      186    proc (p_received_version, p_expected_version, p_structure_name);
      187       dcl	    p_received_version     fixed bin (35);
      188       dcl	    p_expected_version     fixed bin (35);
      189       dcl	    p_structure_name       char (*);
      190 
      191       if p_received_version ^= p_expected_version
      192       then call sub_err_ (error_table_$unimplemented_version, myname, "s", null, 0,
      193 	      "^/Expected version ^d of the ^a structure.
      194 Received version ^d instead.", p_expected_version, p_structure_name, p_received_version);
      195 
      196    end CHECK_VERSION;
      197 
      198 FINISH:
      199    proc;
      200       if interval_specification_ptr = null | interval_specification_ptr ^= p_interval_specification_ptr
      201       then
      202          do;
      203 	  do interval_bead_ptr = root_interval_bead_ptr repeat (temp_interval_bead_ptr)
      204 	       while (interval_bead_ptr ^= null);
      205 	     temp_interval_bead_ptr = interval_bead.next;
      206 	     if interval_bead.simple_typed_vector_ptr ^= null
      207 	     then free interval_bead.simple_typed_vector_ptr -> simple_typed_vector in (work_area);
      208 	     if interval_bead.id_list_ptr ^= null
      209 	     then free interval_bead.id_list_ptr -> id_list in (work_area);
      210 	     free interval_bead in (work_area);
      211 	  end;
      212 	  if interval_specification_ptr ^= null
      213 	  then free interval_specification in (work_area);
      214          end;
      215       if field_presence_array_ptr ^= null
      216       then free field_presence_array in (work_area);
      217    end FINISH;
      218 
      219 PROCESS_AND_GROUP:
      220    proc (pag_p_and_group_idx);
      221       dcl	    pag_p_and_group_idx    fixed bin parameter;
      222 
      223       first_range_field = search_specification.and_group (pag_p_and_group_idx).number_of_constraints + 1;
      224 CONSTRAINT_LOOP:
      225       do constraint_idx = 1 to search_specification.and_group (pag_p_and_group_idx).number_of_constraints;
      226          call PROCESS_CONSTRAINT (pag_p_and_group_idx, constraint_idx);
      227       end CONSTRAINT_LOOP;
      228 
      229       do number_of_equal_fields = 1 to min (hbound (field_presence_array, 1) - 1, first_range_field)
      230 	 while (field_presence_array (number_of_equal_fields).structural.equal = IS_PRESENT);
      231       end;
      232       if number_of_equal_fields ^= first_range_field
      233 	 | field_presence_array (number_of_equal_fields).structural.equal = NOT_PRESENT
      234       then number_of_equal_fields = number_of_equal_fields - 1;
      235 
      236       if number_of_equal_fields = first_range_field & field_presence_array (first_range_field).structural.equal
      237 	 & field_presence_array (first_range_field).structural.less_or_greater
      238       then
      239          do;
      240 	  field_presence_array (first_range_field).structural.less_or_greater = NOT_PRESENT;
      241 	  field_presence_array (first_range_field).non_structural = IS_PRESENT;
      242          end;
      243 
      244       if number_of_equal_fields = 0
      245 	 & (first_range_field > 1
      246 	 | (first_range_field = 1 & field_presence_array (first_range_field).structural.less_or_greater = NOT_PRESENT))
      247       then
      248 NON_STRUCTURAL_CONSTRAINT:
      249          do;
      250 	  p_interval_specification_ptr = null;
      251 
      252 	  do interval_bead_ptr = root_interval_bead_ptr repeat (temp_next_ptr) while (interval_bead_ptr ^= null);
      253 	     temp_next_ptr = interval_bead.next;
      254 	     if interval_bead.simple_typed_vector_ptr ^= null
      255 	     then free interval_bead.simple_typed_vector_ptr -> simple_typed_vector in (work_area);
      256 	     free interval_bead in (work_area);
      257 	  end;
      258 	  return;
      259          end NON_STRUCTURAL_CONSTRAINT;
      260 
      261       if number_of_equal_fields < first_range_field - 1
      262       then first_range_field_is_not_adjacent_to_equal_fields = "1"b;
      263 						/* There is a gap following the last equal field. */
      264 
      265       if first_range_field_is_not_adjacent_to_equal_fields
      266 	 | field_presence_array (first_range_field).structural.less_or_greater = NOT_PRESENT
      267 						/* The first_range_field has no "structural" constraint. */
      268       then
      269 EQUAL_CONSTRAINT:
      270          do;
      271 	  number_of_intervals = number_of_intervals + 1;
      272 	  old_interval_bead_ptr = interval_bead_ptr;
      273 
      274 	  alloc interval_bead in (work_area);
      275 	  interval_bead.next = null;
      276 
      277 /* Thread in the new interval_bead. */
      278 
      279 	  if old_interval_bead_ptr = null
      280 	  then root_interval_bead_ptr = interval_bead_ptr;
      281 	  else old_interval_bead_ptr -> interval_bead.next = interval_bead_ptr;
      282 
      283 /* Build the list of and_group ids for this interval. */
      284 
      285 	  il_number_of_ids = 1;
      286 	  alloc id_list in (work_area);
      287 	  id_list.version = ID_LIST_VERSION_1;
      288 	  id_list.id (1) = pag_p_and_group_idx;
      289 
      290 	  interval_bead.id_list_ptr = id_list_ptr;
      291 
      292 /* Determine the number of fully structural fields. It is possible for the 
      293*last equal field to contain a non structural constraint. This is only
      294*possible if that field is also the first range field. */
      295 
      296 	  if ^first_range_field_is_not_adjacent_to_equal_fields
      297 	       & field_presence_array (first_range_field).non_structural = IS_PRESENT
      298 	  then interval_bead.number_of_fully_structural_fields = number_of_equal_fields - 1;
      299 	  else interval_bead.number_of_fully_structural_fields = number_of_equal_fields;
      300 
      301 /* Build a simple_typed_vector containing all of the values for the dimensions
      302*defining the interval but the last.  The last defining-dimension's value will
      303*always appear in the low.value_ptr (and high.value_ptr if not doing an
      304*exact-match).
      305**/
      306 
      307 	  stv_number_of_dimensions = number_of_equal_fields;
      308 	  alloc simple_typed_vector in (work_area);
      309 	  simple_typed_vector.type = SIMPLE_TYPED_VECTOR_TYPE;
      310 	  last_constraint_idx = 0;
      311 	  do constraint_idx = 1 to search_specification.and_group (pag_p_and_group_idx).number_of_constraints;
      312 	     constraint_field_id =
      313 		search_specification.and_group (pag_p_and_group_idx).constraint (constraint_idx).field_id;
      314 	     if constraint_field_id < number_of_equal_fields & constraint_field_id > 0
      315 	     then simple_typed_vector.dimension (constraint_field_id).value_ptr =
      316 		     search_specification.and_group (pag_p_and_group_idx).constraint (constraint_idx).value_ptr;
      317 	     else if constraint_field_id = number_of_equal_fields
      318 		     & search_specification.and_group (pag_p_and_group_idx).constraint (constraint_idx).operator_code
      319 		     = EQUAL_OPERATOR_CODE
      320 	     then last_constraint_idx = constraint_idx;
      321 	  end;
      322 
      323 	  interval_bead.simple_typed_vector_ptr = simple_typed_vector_ptr;
      324 	  interval_bead.low.value_ptr =
      325 	       search_specification.and_group (pag_p_and_group_idx).constraint (last_constraint_idx).value_ptr;
      326 	  interval_bead.low.operator_code = GREATER_OR_EQUAL_OPERATOR_CODE;
      327 	  interval_bead.high.value_ptr = interval_bead.low.value_ptr;
      328 	  interval_bead.high.operator_code = LESS_OR_EQUAL_OPERATOR_CODE;
      329 
      330          end EQUAL_CONSTRAINT;
      331       else if field_presence_array (first_range_field).structural.less_or_greater = IS_PRESENT
      332       then
      333 SIMPLE_RANGE_CONSTRAINT:
      334          do;
      335 
      336 	  number_of_intervals = number_of_intervals + 1;
      337 	  old_interval_bead_ptr = interval_bead_ptr;
      338 	  alloc interval_bead in (work_area);
      339 	  interval_bead.next = null;
      340 
      341 /* Thread the new interval_bead into the list of intervals. */
      342 
      343 	  if old_interval_bead_ptr = null
      344 	  then root_interval_bead_ptr = interval_bead_ptr;
      345 	  else old_interval_bead_ptr -> interval_bead.next = interval_bead_ptr;
      346 
      347 /* Build the list of and_group ids for this interval. */
      348 
      349 	  il_number_of_ids = 1;
      350 	  alloc id_list in (work_area);
      351 	  id_list.version = ID_LIST_VERSION_1;
      352 	  id_list.id (1) = pag_p_and_group_idx;
      353 
      354 	  interval_bead.id_list_ptr = id_list_ptr;
      355 
      356 /* Determine the number of fully structural fields. The first range field
      357*is the last fully structual field if there are no non-structural contraints
      358*on that field. */
      359 
      360 	  if field_presence_array (first_range_field).non_structural = NOT_PRESENT
      361 	  then interval_bead.number_of_fully_structural_fields = first_range_field;
      362 
      363 	  else interval_bead.number_of_fully_structural_fields = first_range_field - 1;
      364 
      365 /* Build the simple_typed_vector for the interval. */
      366 
      367 	  stv_number_of_dimensions = first_range_field;
      368 	  alloc simple_typed_vector in (work_area);
      369 	  simple_typed_vector.type = SIMPLE_TYPED_VECTOR_TYPE;
      370 
      371 	  low_constraint_idx, high_constraint_idx = 0;
      372 	  do constraint_idx = 1 to search_specification.and_group (pag_p_and_group_idx).number_of_constraints;
      373 	     constraint_field_id =
      374 		search_specification.and_group (pag_p_and_group_idx).constraint (constraint_idx).field_id;
      375 	     constraint_operator_code =
      376 		search_specification.and_group (pag_p_and_group_idx).constraint (constraint_idx).operator_code;
      377 
      378 	     if constraint_field_id <= number_of_equal_fields & constraint_field_id > 0
      379 	     then simple_typed_vector.dimension (constraint_field_id).value_ptr =
      380 		     search_specification.and_group (pag_p_and_group_idx).constraint (constraint_idx).value_ptr;
      381 
      382 	     if constraint_field_id = first_range_field
      383 	     then if USES_GREATER_OPERATOR (constraint_operator_code)
      384 		then low_constraint_idx = constraint_idx;
      385 		else if USES_LESS_OPERATOR (constraint_operator_code)
      386 		then high_constraint_idx = constraint_idx;
      387 	  end;
      388 	  interval_bead.simple_typed_vector_ptr = simple_typed_vector_ptr;
      389 
      390 	  if low_constraint_idx <= 0 & high_constraint_idx <= 0
      391 	  then call sub_err_ (dm_error_$programming_error, myname, ACTION_CANT_RESTART, null, 0,
      392 		  "^/In a simple range specification the low and high constraint indices^/are not set.  One of them must be set."
      393 		  );
      394 
      395 	  if low_constraint_idx > 0
      396 	  then
      397 	     do;
      398 	        interval_bead.low.value_ptr =
      399 		   search_specification.and_group (pag_p_and_group_idx).constraint (low_constraint_idx).value_ptr;
      400 	        interval_bead.low.operator_code =
      401 		   search_specification.and_group (pag_p_and_group_idx).constraint (low_constraint_idx).operator_code;
      402 	     end;
      403 	  else
      404 	     do;
      405 	        interval_bead.low.operator_code = GREATER_OPERATOR_CODE;
      406 	        interval_bead.low.value_ptr = null;
      407 	     end;
      408 
      409 	  if high_constraint_idx > 0
      410 	  then
      411 	     do;
      412 	        interval_bead.high.value_ptr =
      413 		   search_specification.and_group (pag_p_and_group_idx).constraint (high_constraint_idx).value_ptr;
      414 	        interval_bead.high.operator_code =
      415 		   search_specification.and_group (pag_p_and_group_idx).constraint (high_constraint_idx)
      416 		   .operator_code;
      417 	     end;
      418 	  else
      419 	     do;
      420 	        interval_bead.high.operator_code = LESS_OPERATOR_CODE;
      421 	        interval_bead.high.value_ptr = null;
      422 	     end;
      423          end SIMPLE_RANGE_CONSTRAINT;
      424       else
      425 MULTIPLE_RANGE_CONSTRAINT:
      426          do;
      427 
      428 /* The use of "^=" should be addressed by building one interval_bead for */
      429 /* each "^=" present.  Currently, these are applied in the sequential */
      430 /* search. */
      431 
      432          end MULTIPLE_RANGE_CONSTRAINT;
      433    end PROCESS_AND_GROUP;
      434 
      435 PROCESS_CONSTRAINT:
      436    proc (pc_p_and_group_idx, pc_p_constraint_idx);
      437       dcl	    pc_p_and_group_idx     fixed bin parameter;
      438       dcl	    pc_p_constraint_idx    fixed bin parameter;
      439 
      440       constraint_field_id = search_specification.and_group (pc_p_and_group_idx).constraint (pc_p_constraint_idx).field_id;
      441       constraint_operator_code =
      442 	 search_specification.and_group (pc_p_and_group_idx).constraint (pc_p_constraint_idx).operator_code;
      443 
      444       if constraint_field_id <= first_range_field & constraint_field_id > 0
      445       then if constraint_operator_code = EQUAL_OPERATOR_CODE
      446 	 then if field_presence_array (constraint_field_id).structural.equal = NOT_PRESENT
      447 	      then field_presence_array (constraint_field_id).structural.equal = IS_PRESENT;
      448 	      else
      449 	         do;				/* Only one equal constraint on field can be processed structurally */
      450 		  first_range_field = min (first_range_field, constraint_field_id);
      451 		  field_presence_array (constraint_field_id).non_structural = IS_PRESENT;
      452 	         end;
      453 	 else if USES_REGULAR_EXPRESSION_OPERATOR (constraint_operator_code)
      454 		 | constraint_operator_code = NOT_EQUAL_OPERATOR_CODE
      455 		 | search_specification.and_group (pc_p_and_group_idx).constraint (pc_p_constraint_idx).value_field_id
      456 		 >= 1
      457 	 then
      458 	    do;
      459 	       first_range_field = min (first_range_field, constraint_field_id);
      460 	       field_presence_array (constraint_field_id).non_structural = IS_PRESENT;
      461 	    end;
      462 	 else if USES_LESS_OPERATOR (constraint_operator_code) | USES_GREATER_OPERATOR (constraint_operator_code)
      463 	 then
      464 	    do;
      465 	       first_range_field = min (first_range_field, constraint_field_id);
      466 	       field_presence_array (constraint_field_id).structural.less_or_greater = IS_PRESENT;
      467 	    end;
      468 	 else call sub_err_ (dm_error_$programming_error, myname, ACTION_CAN_RESTART, null, 0,
      469 		 "^/The operator code ^d is not recognized as valid.", constraint_operator_code);
      470 
      471    end PROCESS_CONSTRAINT;
      472 
  1     1 /* BEGIN INCLUDE FILE dm_specification_head.incl.pl1 */
  1     2 
  1     3 /* HISTORY:
  1     4*Written by Matthew Pierret, 05/11/83. (Extracted from dm_specification.incl.pl1)
  1     5*Modified:
  1     6*05/20/83 by Matthew Pierret: Changed to use version 4.
  1     7**/
  1     8 
  1     9 /* format: style2,ind3 */
  1    10      dcl	   1 specification_head   based (specification_head_ptr),
  1    11 	     2 version	      fixed bin (35),
  1    12 	     2 type	      fixed bin (17) unal,
  1    13 	     2 pad	      bit (18) unal,
  1    14 	     2 subset_specification_ptr
  1    15 			      ptr;
  1    16 
  1    17 
  1    18      dcl	   specification_head_ptr ptr;
  1    19      dcl	   SPECIFICATION_VERSION_4
  1    20 			      init (4) fixed bin (35) internal static options (constant);
  1    21 
  1    22      dcl	   (
  1    23 	   SEARCH_SPECIFICATION_TYPE
  1    24 			      init (1),
  1    25 	   ABSOLUTE_SEARCH_SPECIFICATION_TYPE
  1    26 			      init (1),
  1    27 	   NUMERIC_SPECIFICATION_TYPE
  1    28 			      init (2),
  1    29 	   ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
  1    30 			      init (2),
  1    31 	   RELATIVE_SEARCH_SPECIFICATION_TYPE
  1    32 			      init (3),
  1    33 	   RELATIVE_NUMERIC_SPECIFICATION_TYPE
  1    34 			      init (4),
  1    35 	   ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
  1    36 			      init (5),
  1    37 	   RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
  1    38 			      init (6),
  1    39 	   ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
  1    40 			      init (7),
  1    41 	   RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
  1    42 			      init (8)
  1    43 	   )		      fixed bin (17) internal static options (constant);
  1    44 
  1    45 
  1    46 /* END INCLUDE FILE dm_specification_head.incl.pl1 */
      473 
      474 
  2     1 /* BEGIN INCLUDE FILE - dm_specification.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*          The specification structure is used to identify sets items based on
  2     6*     the value of some of the contents of the items (the
  2     7*     search_specification), or based on the ordinal position (the
  2     8*     numeric_specification) of the first or last item in the desired set of
  2     9*     items in the set of all possible items.  It is used with the relation,
  2    10*     index and record managers.  The items for these three managers are
  2    11*     tuples, keys and records, respectively.  The sets of "all possible
  2    12*     items", for determination of ordinal position for these three managers
  2    13*     are: a relation, an index, and a record collection, respectively.
  2    14*     
  2    15*          The specification_head structure, in dm_specification_head.incl.pl1,
  2    16*     must be included in any program which uses this (the
  2    17*     dm_specification.incl.pl1) include file.
  2    18**/
  2    19 
  2    20 /* HISTORY:
  2    21*
  2    22*Written by Lindsey Spratt, 05/19/82.
  2    23*Modified:
  2    24*08/17/82 by Matthew Pierret:  Added all specification type constants.
  2    25*09/24/82 by Ronald Harvey: Changed version and added and_groups.
  2    26*10/22/82 by Lindsey Spratt:  Added the range_size to the numeric_specification.
  2    27*	  Changed the version to 3.
  2    28*05/11/83 by Matthew Pierret: Moved specification_head and and type constants
  2    29*            to dm_specification_head.incl.pl1. Added constraint.value_field_id.
  2    30*            Moved range type constants into dm_range_constants.incl.pl1.
  2    31*05/20/83 by Matthew Pierret: Added constraint.value_field_id for specifying
  2    32*            intra-key/record compares.
  2    33*10/02/84 by Lindsey L. Spratt:  Moved a misplaced journalization comment.
  2    34*            Added a DESCRIPTION comment.
  2    35**/
  2    36 
  2    37 /* format: style2,ind3 */
  2    38      dcl	   1 search_specification based (search_specification_ptr),
  2    39 	     2 head	      like specification_head,
  2    40 	     2 maximum_number_of_constraints
  2    41 			      fixed bin (17) unal,
  2    42 	     2 number_of_and_groups
  2    43 			      fixed bin (17) unal,
  2    44 	     2 range	      unal,
  2    45 	       3 type	      fixed bin (17),
  2    46 	       3 size	      fixed bin (17),
  2    47 	     2 and_group	      (ss_number_of_and_groups refer (search_specification.number_of_and_groups)),
  2    48 	       3 number_of_constraints
  2    49 			      fixed bin (17) unal,
  2    50 	       3 constraint	      (ss_maximum_number_of_constraints
  2    51 			      refer (search_specification.maximum_number_of_constraints)),
  2    52 	         4 field_id	      fixed bin (17) unal,
  2    53 	         4 operator_code  fixed bin (17) unal,
  2    54 	         4 value_field_id fixed bin (17) unal,
  2    55 	         4 pad	      bit (18) unal,
  2    56 	         4 value_ptr      ptr unal;
  2    57 
  2    58      dcl	   search_specification_ptr
  2    59 			      ptr;
  2    60      dcl	   (ss_number_of_and_groups, ss_maximum_number_of_constraints)
  2    61 			      fixed bin (17);
  2    62 
  2    63      dcl	   1 numeric_specification
  2    64 			      based (numeric_specification_ptr),
  2    65 	     2 head	      like specification_head,
  2    66 	     2 range_size	      fixed bin (35) aligned,
  2    67 	     2 position_number    fixed bin (17) unal,
  2    68 	     2 pad	      bit (18) unal;
  2    69 
  2    70      dcl	   numeric_specification_ptr
  2    71 			      ptr;
  2    72 
  2    73 /* END INCLUDE FILE - dm_specification.incl.pl1 */
      475 
      476 
  3     1 /* BEGIN INCLUDE FILE - dm_interval_spec.incl.pl1 */
  3     2 
  3     3 
  3     4 
  3     5 
  3     6 /****^  HISTORY COMMENTS:
  3     7*  1) change(86-09-19,Dupuis), approve(86-09-19,MCR7401), audit(86-09-24,Blair),
  3     8*     install(86-10-02,MR12.0-1173):
  3     9*     Changed the declaration of interval_bead to also initialize id_string and
  3    10*     id_list_ptr. The declare had initialized all of the structure but forgot
  3    11*     these elements.
  3    12*                                                   END HISTORY COMMENTS */
  3    13 
  3    14 
  3    15 
  3    16 /* DESCRIPTION:
  3    17*
  3    18*          The interval_specification is used in the index manager searching as
  3    19*     an internal (normalized) representation of the search specification.
  3    20*     Each interval_bead is a separate search problem, a separate interval.
  3    21*     The im_build_interval_spec module builds the interval_specification by
  3    22*     analyzing the search_specification.  The im_structural_search module
  3    23*     applies the interval_specification to the index.
  3    24**/
  3    25 
  3    26 /* HISTORY:
  3    27*
  3    28*Written by Lindsey Spratt, 10/06/82.
  3    29*Modified:
  3    30*10/26/84 by Lindsey L. Spratt:  Added documentation.  Changed to have a
  3    31*            char(8) version in interval_specification.
  3    32**/
  3    33 
  3    34 /* format: style2,ind3 */
  3    35      dcl	   1 interval_specification
  3    36 			      based (interval_specification_ptr) aligned,
  3    37 	     2 version	      char (8) aligned,
  3    38 	     2 number_of_intervals
  3    39 			      fixed bin (17) unaligned init (0),
  3    40 	     2 pad	      bit (18) unaligned init ("0"b),
  3    41 	     2 first_interval_bead_ptr
  3    42 			      ptr init (null),
  3    43 	     2 last_interval_bead_ptr
  3    44 			      ptr init (null);
  3    45 
  3    46      dcl	   1 interval_bead	      based (interval_bead_ptr) aligned,
  3    47 	     2 simple_typed_vector_ptr
  3    48 			      ptr init (null),
  3    49 	     2 next	      ptr init (null),
  3    50 	     2 number_of_fully_structural_fields
  3    51 			      fixed bin (17) init (0) unal,
  3    52 	     2 low,
  3    53 	       3 id_string	      bit (36) aligned init ("0"b),
  3    54 	       3 value_ptr	      ptr unaligned init (null),
  3    55 	       3 operator_code    fixed bin (18) uns unal init (0),
  3    56 	       3 pad	      bit (18) init ("0"b) unal,
  3    57 	     2 high	      like interval_bead.low,
  3    58 	     2 id_list_ptr	      ptr init (null);	/* This points at an id_list as declared in dm_id_list.incl.pl1 */
  3    59 						/* The ids in this list are of and_groups in */
  3    60 						/* the original search_specification. */
  3    61 
  3    62      dcl	   interval_specification_ptr
  3    63 			      ptr init (null);
  3    64      dcl	   interval_bead_ptr      ptr init (null);
  3    65      dcl	   INTERVAL_SPECIFICATION_VERSION_2
  3    66 			      init ("IntSpc 2") aligned char (8) internal static options (constant);
  3    67 
  3    68 
  3    69 /* END INCLUDE FILE - dm_interval_spec.incl.pl1 */
      477 
      478 
  4     1 /* ***********************************************************
  4     2*   *                                                         *
  4     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  4     4*   *                                                         *
  4     5*   *********************************************************** */
  4     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
  4     7 
  4     8 /* Written by Lindsey Spratt, 04/02/82.
  4     9*Modified:
  4    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
  4    11*	  unaligned.  Changed the type number of the simple_typed_vector to
  4    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
  4    13*	  type.
  4    14**/
  4    15 
  4    16 /* format: style2,ind3 */
  4    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
  4    18 	     2 type	      fixed bin (17) unal,
  4    19 	     2 number_of_dimensions
  4    20 			      fixed bin (17) unal,
  4    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
  4    22 	       3 value_ptr	      ptr unaligned;
  4    23 
  4    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
  4    25 	     2 type	      fixed bin (17) unal,
  4    26 	     2 number_of_dimensions
  4    27 			      fixed bin (17) unal,
  4    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
  4    29 	       3 identifier	      fixed bin (17) unal,
  4    30 	       3 pad	      bit (18) unal,
  4    31 	       3 value_ptr	      ptr unal;
  4    32 
  4    33      dcl	   simple_typed_vector_ptr
  4    34 			      ptr;
  4    35      dcl	   stv_number_of_dimensions
  4    36 			      fixed bin (17);
  4    37 
  4    38      dcl	   general_typed_vector_ptr
  4    39 			      ptr;
  4    40      dcl	   gtv_number_of_dimensions
  4    41 			      fixed bin (17);
  4    42 
  4    43      dcl	   (
  4    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
  4    45 			      init (1),		/* value_ptr was aligned. */
  4    46 	   GENERAL_TYPED_VECTOR_TYPE
  4    47 			      init (2),
  4    48 	   SIMPLE_TYPED_VECTOR_TYPE
  4    49 			      init (3)
  4    50 	   )		      fixed bin (17) internal static options (constant);
  4    51 
  4    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
      479 
      480 
  5     1 /* BEGIN INCLUDE FILE - dm_id_list.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION
  5     4*        The id_list structure is used to identify attributes, fields and
  5     5*   dimensions by various modules of the Data Management System.
  5     6**/
  5     7 
  5     8 /* HISTORY:
  5     9*Written by Matthew Pierret, '82.
  5    10*Modified:
  5    11*08/17/83 by Matthew Pierret: Made version constant 'internal static options
  5    12*            (constant)' and to initialize automatic variables.
  5    13**/
  5    14 
  5    15 /* format: style2,ind3 */
  5    16      dcl	   1 id_list	      aligned based (id_list_ptr),
  5    17 	     2 version	      fixed bin (35),
  5    18 	     2 number_of_ids      fixed bin (17),
  5    19 	     2 id		      (il_number_of_ids refer (id_list.number_of_ids)) fixed bin (17);
  5    20 
  5    21      dcl	   id_list_ptr	      ptr init (null);
  5    22      dcl	   il_number_of_ids	      fixed bin (17) init (-1);
  5    23      dcl	   ID_LIST_VERSION_1      fixed bin (17) init (1) internal static options (constant);
  5    24 
  5    25 /* END INCLUDE FILE - dm_id_list.incl.pl1 */
      481 
      482 
  6     1 /* BEGIN INCLUDE FILE - dm_operator_constants.incl.pl1 */
  6     2 
  6     3 /* Written by Lindsey Spratt, 07/07/82
  6     4*Modified:
  6     5*10/07/82 by Lindsey Spratt:  Added the GREATER, LESS, GREATER_OR_EQUAL,
  6     6*	  LESS_OR_EQUAL and REGULAR_EXPRESSION operator codes.  Also, added
  6     7*	  bit(1) arrays for determining if a given operator code "uses" a
  6     8*	  given operator.  For example, USES_LESS_OPERATOR(x) = "1"b only if
  6     9*	  x = LESS_OPERATOR_CODE or x = LESS_OR_EQUAL_OPERATOR_CODE.
  6    10**/
  6    11 
  6    12 /* format: style2,ind3 */
  6    13      dcl	   (
  6    14 	   EQUAL_OPERATOR_CODE    init (1),
  6    15 	   GREATER_OPERATOR_CODE  init (2),
  6    16 	   LESS_OPERATOR_CODE     init (7),
  6    17 	   REGULAR_EXPRESSION_OPERATOR_CODE
  6    18 			      init (8),
  6    19 	   NOT_EQUAL_OPERATOR_CODE
  6    20 			      init (5),
  6    21 	   GREATER_OR_EQUAL_OPERATOR_CODE
  6    22 			      init (3),
  6    23 	   LESS_OR_EQUAL_OPERATOR_CODE
  6    24 			      init (6),
  6    25 	   EQUAL_IDX	      init (18),
  6    26 	   GREATER_IDX	      init (17),
  6    27 	   NOT_IDX	      init (16),
  6    28 	   REGULAR_EXPRESSION_IDX init (15)
  6    29 	   )		      fixed bin internal static options (constant);
  6    30 
  6    31      dcl	   (
  6    32 	   USES_LESS_OPERATOR     init ("0"b, (5) (1)"0"b, "1"b /* <= */, "1"b /* < */, (24) (1)"0"b),
  6    33 	   USES_GREATER_OPERATOR  init ("0"b, "0"b, "1"b /* > */, "1"b /* >= */, (28) (1)"0"b),
  6    34 	   USES_EQUAL_OPERATOR    init ("0"b, "1"b /* = */, "0"b, "1"b /* >= */, "0"b, "0"b, "1"b /* <= */,
  6    35 			      (25) (1)"0"b),
  6    36 	   USES_REGULAR_EXPRESSION_OPERATOR
  6    37 			      init ("0"b, (7) (1)"0"b, "1"b /* reg exp */, (3) (1)"0"b, "1"b /* not reg exp */,
  6    38 			      (19) (1)"0"b)
  6    39 	   )		      dimension (0:31) bit (1) unaligned internal static options (constant);
  6    40 
  6    41 /* END INCLUDE FILE - dm_operator_constants.incl.pl1 */
      483 
      484 
  7     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  7     2 /* format: style3 */
  7     3 
  7     4 /* These constants are to be used for the flags argument of sub_err_ */
  7     5 /* They are just "string (condition_info_header.action_flags)" */
  7     6 
  7     7 declare	(
  7     8 	ACTION_CAN_RESTART	init (""b),
  7     9 	ACTION_CANT_RESTART init ("1"b),
  7    10 	ACTION_DEFAULT_RESTART
  7    11 			init ("01"b),
  7    12 	ACTION_QUIET_RESTART
  7    13 			init ("001"b),
  7    14 	ACTION_SUPPORT_SIGNAL
  7    15 			init ("0001"b)
  7    16 	)		bit (36) aligned internal static options (constant);
  7    17 
  7    18 /* End include file */
      485 
      486    end im_build_interval_spec;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/02/86  1204.8  im_build_interval_spec.pl1        >special_ldd>install>MR12.0-1173>im_build_interval_spec.pl1
473          1    10/14/83  1609.1  dm_specification_head.incl.pl1    >ldd>include>dm_specification_head.incl.pl1
475          2    01/07/85  0859.8  dm_specification.incl.pl1         >ldd>include>dm_specification.incl.pl1
477          3    10/02/86  1056.4  dm_interval_spec.incl.pl1         >special_ldd>install>MR12.0-1173>dm_interval_spec.incl.pl1
479          4    10/14/83  1609.1  vu_typed_vector.incl.pl1          >ldd>include>vu_typed_vector.incl.pl1
481          5    10/14/83  1609.1  dm_id_list.incl.pl1               >ldd>include>dm_id_list.incl.pl1
483          6    10/14/83  1609.1  dm_operator_constants.incl.pl1    >ldd>include>dm_operator_constants.incl.pl1
485          7    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ABSOLUTE_SEARCH_SPECIFICATION_TYPE
                                000041 constant        fixed bin(17,0)          initial dcl 1-22 set ref 130 130*
ACTION_CANT_RESTART             000023 constant        bit(36)                  initial dcl 7-7 set ref 390*
ACTION_CAN_RESTART              000032 constant        bit(36)                  initial dcl 7-7 set ref 468*
EQUAL_OPERATOR_CODE                    constant        fixed bin(17,0)          initial dcl 6-13 ref 317 444
GREATER_OPERATOR_CODE                  constant        fixed bin(17,0)          initial dcl 6-13 ref 405
GREATER_OR_EQUAL_OPERATOR_CODE         constant        fixed bin(17,0)          initial dcl 6-13 ref 326
ID_LIST_VERSION_1                      constant        fixed bin(17,0)          initial dcl 5-23 ref 287 351
INTERVAL_SPECIFICATION_VERSION_2
                                000004 constant        char(8)                  initial dcl 3-65 ref 175
IS_PRESENT                             constant        bit(1)                   initial unaligned dcl 109 ref 229 241 296 331 444
                                                                                  451 460 466
LESS_OPERATOR_CODE                     constant        fixed bin(17,0)          initial dcl 6-13 ref 420
LESS_OR_EQUAL_OPERATOR_CODE            constant        fixed bin(17,0)          initial dcl 6-13 ref 328
NOT_EQUAL_OPERATOR_CODE                constant        fixed bin(17,0)          initial dcl 6-13 ref 453
NOT_PRESENT                            constant        bit(1)                   initial unaligned dcl 109 ref 232 240 244 265 360
                                                                                  444
RELATIVE_SEARCH_SPECIFICATION_TYPE
                                000040 constant        fixed bin(17,0)          initial dcl 1-22 set ref 130 130*
SIMPLE_TYPED_VECTOR_TYPE               constant        fixed bin(17,0)          initial dcl 4-43 ref 309 369
SPECIFICATION_VERSION_4         000036 constant        fixed bin(35,0)          initial dcl 1-19 set ref 129*
USES_GREATER_OPERATOR           000001 constant        bit(1)                   initial array unaligned dcl 6-31 ref 382 462
USES_LESS_OPERATOR              000002 constant        bit(1)                   initial array unaligned dcl 6-31 ref 385 462
USES_REGULAR_EXPRESSION_OPERATOR
                                000000 constant        bit(1)                   initial array unaligned dcl 6-31 ref 453
and_group                 6            based           structure                array level 2 packed unaligned dcl 2-38
and_group_idx                   000115 automatic       fixed bin(17,0)          dcl 74 set ref 168* 170*
cleanup                         000132 stack reference condition                dcl 104 ref 142
constraint                6(18)        based           structure                array level 3 packed unaligned dcl 2-38
constraint_field_id             000125 automatic       fixed bin(17,0)          dcl 82 set ref 312* 314 314 314 317 373* 378 378 378
                                                                                  382 440* 444 444 444 444 450 451 459 460 465 466
constraint_idx                  000121 automatic       fixed bin(17,0)          dcl 78 set ref 224* 226* 311* 312 314 317 317* 372*
                                                                                  373 375 378 382 385*
constraint_operator_code        000126 automatic       fixed bin(18,0)          unsigned dcl 83 set ref 375* 382 385 441* 444 453
                                                                                  453 462 462 468*
dimension                 1            based           structure                array level 2 packed unaligned dcl 4-17
dm_error_$programming_error     000012 external static fixed bin(35,0)          dcl 120 set ref 390* 468*
equal                     0(01)        based           bit(1)                   array level 3 packed unaligned dcl 90 set ref 229
                                                                                  232 236 444 444*
error_table_$unimplemented_version
                                000014 external static fixed bin(35,0)          dcl 120 set ref 130* 191*
field_id                  6(18)        based           fixed bin(17,0)          array level 4 packed unaligned dcl 2-38 ref 312 373
                                                                                  440
field_presence_array                   based           structure                array level 1 dcl 90 set ref 161 162* 215 229
field_presence_array_ptr        000110 automatic       pointer                  initial dcl 69 set ref 69* 140* 161* 162 215 215 229
                                                                                  229 232 236 236 240 241 244 265 296 331 360 444
                                                                                  444 451 460 466
first_interval_bead_ptr
                          4            based           pointer                  initial level 2 dcl 3-35 set ref 174* 177*
first_range_field               000116 automatic       fixed bin(17,0)          dcl 75 set ref 223* 229 232 236 236 236 240 241 244
                                                                                  244 244 261 265 296 331 360 360 363 367 382 444
                                                                                  450* 450 459* 459 465* 465
first_range_field_is_not_adjacent_to_equal_fields
                                000100 automatic       bit(1)                   initial dcl 63 set ref 63* 261* 265 296
fpa_number_of_fields            000114 automatic       fixed bin(17,0)          dcl 73 set ref 160* 161 162 215 229
head                                   based           structure                level 2 unaligned dcl 2-38
high                     10            based           structure                level 2 dcl 3-46
high_constraint_idx             000124 automatic       fixed bin(17,0)          initial dcl 79 set ref 79* 371* 385* 390 409 412 414
id                        2            based           fixed bin(17,0)          array level 2 dcl 5-16 set ref 288* 352*
id_list                                based           structure                level 1 dcl 5-16 set ref 208 286 350
id_list_ptr                     000152 automatic       pointer                  initial dcl 5-21 in procedure
                                                                                  "im_build_interval_spec" set ref 5-21* 286* 287
                                                                                  288 290 350* 351 352 354
id_list_ptr              14            based           pointer                  initial level 2 in structure "interval_bead"
                                                                                  dcl 3-46 in procedure "im_build_interval_spec" set
                                                                                  ref 147* 153* 208 208 274* 290* 338* 354*
id_string                 5            based           bit(36)                  initial level 3 in structure "interval_bead"
                                                                                  dcl 3-46 in procedure "im_build_interval_spec" set
                                                                                  ref 147* 154* 274* 338*
id_string                10            based           bit(36)                  initial level 3 in structure "interval_bead"
                                                                                  dcl 3-46 in procedure "im_build_interval_spec" set
                                                                                  ref 147* 154* 274* 338*
il_number_of_ids                000154 automatic       fixed bin(17,0)          initial dcl 5-22 set ref 5-22* 285* 286 286 349* 350
                                                                                  350
interval_bead                          based           structure                level 1 dcl 3-46 set ref 147 210 256 274 338
interval_bead_ptr               000144 automatic       pointer                  initial dcl 3-64 set ref 139* 147* 148 149 150 150
                                                                                  151 151 152 153 154 154 155 178 3-64* 203* 203*
                                                                                  205 206 206 208 208 210* 252* 252* 253 254 254
                                                                                  256* 272 274* 275 279 281 290 296 299 323 324 326
                                                                                  327 327 328 337 338* 339 343 345 354 360 363 388
                                                                                  398 400 405 406 412 414 420 421
interval_specification                 based           structure                level 1 dcl 3-35 set ref 174 212
interval_specification_ptr      000142 automatic       pointer                  initial dcl 3-62 set ref 138* 174* 175 176 177 178
                                                                                  180 3-62* 200 200 212 212
last_constraint_idx             000122 automatic       fixed bin(17,0)          initial dcl 79 set ref 79* 310* 317* 324
last_interval_bead_ptr
                          6            based           pointer                  initial level 2 dcl 3-35 set ref 174* 178*
less_or_greater           0(02)        based           bit(1)                   array level 3 packed unaligned dcl 90 set ref 236
                                                                                  240* 244 265 331 466*
low                       5            based           structure                level 2 dcl 3-46
low_constraint_idx              000123 automatic       fixed bin(17,0)          initial dcl 79 set ref 79* 371* 382* 390 395 398 400
maximum_number_of_constraints
                          4            based           fixed bin(17,0)          level 2 packed unaligned dcl 2-38 ref 160 160 223
                                                                                  223 224 224 311 311 312 312 314 314 317 317 324
                                                                                  324 372 372 373 373 375 375 378 378 398 398 400
                                                                                  400 412 412 414 414 440 440 441 441 453 453
min                                                    builtin function         dcl 100 ref 229 450 459 465
myname                          000006 constant        varying char(32)         initial dcl 108 set ref 130* 191* 390* 468*
next                      2            based           pointer                  initial level 2 dcl 3-46 set ref 147* 148* 205 253
                                                                                  274* 275* 281* 338* 339* 345*
non_structural                         based           bit(1)                   array level 2 packed unaligned dcl 90 set ref 241*
                                                                                  296 360 451* 460*
null                                                   builtin function         dcl 100 ref 66 67 68 69 71 86 130 130 138 139 140
                                                                                  147 147 147 147 147 148 149 150 153 174 174 3-62
                                                                                  3-64 5-21 191 191 200 203 206 208 212 215 250 252
                                                                                  254 274 274 274 274 274 275 279 338 338 338 338
                                                                                  338 339 343 390 390 406 421 468 468
number_of_and_groups      4(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 2-38 ref 144 160 168
number_of_constraints
                          6            based           fixed bin(17,0)          array level 3 packed unaligned dcl 2-38 ref 160 223
                                                                                  224 311 372
number_of_dimensions      0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 4-17 set ref 206 254
                                                                                  308* 368*
number_of_equal_fields          000117 automatic       fixed bin(17,0)          dcl 76 set ref 229* 229* 232 232 232* 232 236 244
                                                                                  261 296 299 307 314 317 378
number_of_fully_structural_fields
                          4            based           fixed bin(17,0)          initial level 2 packed unaligned dcl 3-46 set ref
                                                                                  147* 152* 274* 296* 299* 338* 360* 363*
number_of_ids             1            based           fixed bin(17,0)          level 2 dcl 5-16 set ref 208 286* 350*
number_of_intervals       2            based           fixed bin(17,0)          initial level 2 in structure
                                                                                  "interval_specification" packed unaligned dcl 3-35
                                                                                  in procedure "im_build_interval_spec" set ref 174*
                                                                                  176*
number_of_intervals             000120 automatic       fixed bin(17,0)          initial dcl 77 in procedure "im_build_interval_spec"
                                                                                  set ref 77* 156* 176 271* 271 336* 336
old_interval_bead_ptr           000102 automatic       pointer                  initial dcl 66 set ref 66* 272* 279 281 337* 343 345
operator_code             7            based           fixed bin(18,0)          initial level 3 in structure "interval_bead" packed
                                                                                  unsigned unaligned dcl 3-46 in procedure
                                                                                  "im_build_interval_spec" set ref 147* 151* 274*
                                                                                  326* 338* 400* 405*
operator_code             7            based           fixed bin(17,0)          array level 4 in structure "search_specification"
                                                                                  packed unaligned dcl 2-38 in procedure
                                                                                  "im_build_interval_spec" ref 317 375 400 414 441
operator_code            12            based           fixed bin(18,0)          initial level 3 in structure "interval_bead" packed
                                                                                  unsigned unaligned dcl 3-46 in procedure
                                                                                  "im_build_interval_spec" set ref 147* 151* 274*
                                                                                  328* 338* 414* 420*
p_code                                 parameter       fixed bin(35,0)          dcl 59 set ref 48 136*
p_expected_version                     parameter       fixed bin(35,0)          dcl 188 set ref 185 191 191*
p_interval_specification_ptr           parameter       pointer                  dcl 57 set ref 48 180* 200 250*
p_received_version                     parameter       fixed bin(35,0)          dcl 187 set ref 185 191 191*
p_search_specification_ptr             parameter       pointer                  dcl 55 ref 48 128
p_structure_name                       parameter       char                     unaligned dcl 189 set ref 185 191*
p_work_area_ptr                        parameter       pointer                  dcl 54 ref 48 127
pad                       7(18)        based           bit(18)                  initial level 3 in structure "interval_bead" packed
                                                                                  unaligned dcl 3-46 in procedure
                                                                                  "im_build_interval_spec" set ref 147* 274* 338*
pad                       2(18)        based           bit(18)                  initial level 2 in structure
                                                                                  "interval_specification" packed unaligned dcl 3-35
                                                                                  in procedure "im_build_interval_spec" set ref 174*
pad                      12(18)        based           bit(18)                  initial level 3 in structure "interval_bead" packed
                                                                                  unaligned dcl 3-46 in procedure
                                                                                  "im_build_interval_spec" set ref 147* 274* 338*
pag_p_and_group_idx                    parameter       fixed bin(17,0)          dcl 221 set ref 219 223 224 226* 288 311 312 314 317
                                                                                  324 352 372 373 375 378 398 400 412 414
pc_p_and_group_idx                     parameter       fixed bin(17,0)          dcl 437 ref 435 440 441 453
pc_p_constraint_idx                    parameter       fixed bin(17,0)          dcl 438 ref 435 440 441 453
root_interval_bead_ptr          000104 automatic       pointer                  initial dcl 67 set ref 67* 155* 177 203 252 279*
                                                                                  343*
search_specification                   based           structure                level 1 unaligned dcl 2-38
search_specification_ptr        000140 automatic       pointer                  dcl 2-58 set ref 128* 129 130 130 130 144 160 168
                                                                                  223 224 311 312 314 317 324 372 373 375 378 398
                                                                                  400 412 414 440 441 453
simple_typed_vector                    based           structure                level 1 packed unaligned dcl 4-17 set ref 206 254
                                                                                  308 368
simple_typed_vector_ptr         000146 automatic       pointer                  dcl 4-33 in procedure "im_build_interval_spec" set
                                                                                  ref 308* 309 314 323 368* 369 378 388
simple_typed_vector_ptr                based           pointer                  initial level 2 in structure "interval_bead"
                                                                                  dcl 3-46 in procedure "im_build_interval_spec" set
                                                                                  ref 147* 149* 206 206 254 254 274* 323* 338* 388*
specification_head                     based           structure                level 1 unaligned dcl 1-10
structural                0(01)        based           structure                array level 2 packed unaligned dcl 90
stv_number_of_dimensions        000150 automatic       fixed bin(17,0)          dcl 4-35 set ref 307* 308 308 367* 368 368
sub_err_                        000010 constant        entry                    external dcl 116 ref 130 191 390 468
sum                                                    builtin function         dcl 100 ref 160
temp_interval_bead_ptr          000106 automatic       pointer                  initial dcl 68 set ref 68* 205* 211
temp_next_ptr                   000112 automatic       pointer                  initial dcl 71 set ref 71* 253* 257
type                      1            based           fixed bin(17,0)          level 3 in structure "search_specification" packed
                                                                                  unaligned dcl 2-38 in procedure
                                                                                  "im_build_interval_spec" set ref 130 130 130*
type                                   based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  unaligned dcl 4-17 in procedure
                                                                                  "im_build_interval_spec" set ref 309* 369*
value_field_id            7(18)        based           fixed bin(17,0)          array level 4 packed unaligned dcl 2-38 ref 453
value_ptr                11            based           pointer                  initial level 3 in structure "interval_bead" packed
                                                                                  unaligned dcl 3-46 in procedure
                                                                                  "im_build_interval_spec" set ref 147* 150* 274*
                                                                                  327* 338* 412* 421*
value_ptr                10(18)        based           pointer                  array level 4 in structure "search_specification"
                                                                                  packed unaligned dcl 2-38 in procedure
                                                                                  "im_build_interval_spec" ref 314 324 378 398 412
value_ptr                 6            based           pointer                  initial level 3 in structure "interval_bead" packed
                                                                                  unaligned dcl 3-46 in procedure
                                                                                  "im_build_interval_spec" set ref 147* 150* 274*
                                                                                  324* 327 338* 398* 406*
value_ptr                 1            based           pointer                  array level 3 in structure "simple_typed_vector"
                                                                                  packed unaligned dcl 4-17 in procedure
                                                                                  "im_build_interval_spec" set ref 314* 378*
version                                based           fixed bin(35,0)          level 3 in structure "search_specification" dcl 2-38
                                                                                  in procedure "im_build_interval_spec" set ref 129*
version                                based           char(8)                  level 2 in structure "interval_specification"
                                                                                  dcl 3-35 in procedure "im_build_interval_spec" set
                                                                                  ref 175*
version                                based           fixed bin(35,0)          level 2 in structure "id_list" dcl 5-16 in procedure
                                                                                  "im_build_interval_spec" set ref 287* 351*
work_area                              based           area(1024)               dcl 96 ref 147 161 174 206 208 210 212 215 254 256
                                                                                  274 286 308 338 350 368
work_area_ptr                   000130 automatic       pointer                  initial dcl 86 set ref 86* 127* 147 161 174 206 208
                                                                                  210 212 215 254 256 274 286 308 338 350 368

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSOLUTE_NUMERIC_SPECIFICATION_TYPE    internal static fixed bin(17,0)          initial dcl 1-22
ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 1-22
ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 1-22
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 7-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 7-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 7-7
EQUAL_IDX                              internal static fixed bin(17,0)          initial dcl 6-13
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 4-43
GREATER_IDX                            internal static fixed bin(17,0)          initial dcl 6-13
NOT_IDX                                internal static fixed bin(17,0)          initial dcl 6-13
NUMERIC_SPECIFICATION_TYPE             internal static fixed bin(17,0)          initial dcl 1-22
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 4-43
REGULAR_EXPRESSION_IDX                 internal static fixed bin(17,0)          initial dcl 6-13
REGULAR_EXPRESSION_OPERATOR_CODE       internal static fixed bin(17,0)          initial dcl 6-13
RELATIVE_NUMERIC_SPECIFICATION_TYPE    internal static fixed bin(17,0)          initial dcl 1-22
RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 1-22
RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 1-22
SEARCH_SPECIFICATION_TYPE              internal static fixed bin(17,0)          initial dcl 1-22
USES_EQUAL_OPERATOR                    internal static bit(1)                   initial array unaligned dcl 6-31
general_typed_vector                   based           structure                level 1 packed unaligned dcl 4-24
general_typed_vector_ptr               automatic       pointer                  dcl 4-38
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 4-40
numeric_specification                  based           structure                level 1 unaligned dcl 2-63
numeric_specification_ptr              automatic       pointer                  dcl 2-70
specification_head_ptr                 automatic       pointer                  dcl 1-18
ss_maximum_number_of_constraints       automatic       fixed bin(17,0)          dcl 2-60
ss_number_of_and_groups                automatic       fixed bin(17,0)          dcl 2-60

NAMES DECLARED BY EXPLICIT CONTEXT.
AND_GROUP_LOOP                  000544 constant        label                    dcl 168
CHECK_VERSION                   000620 constant        entry                    internal dcl 185 ref 129
CONSTRAINT_LOOP                 001054 constant        label                    dcl 224
EQUAL_CONSTRAINT                001243 constant        label                    dcl 265
FINISH                          000717 constant        entry                    internal dcl 198 ref 142 181
MULTIPLE_RANGE_CONSTRAINT       002204 constant        label                    dcl 424
NON_STRUCTURAL_CONSTRAINT       001170 constant        label                    dcl 244
PROCESS_AND_GROUP               001027 constant        entry                    internal dcl 219 ref 170
PROCESS_CONSTRAINT              002205 constant        entry                    internal dcl 435 ref 226
SIMPLE_RANGE_CONSTRAINT         001545 constant        label                    dcl 331
im_build_interval_spec          000210 constant        entry                    external dcl 48

NAMES DECLARED BY CONTEXT OR IMPLICATION.
hbound                                                 builtin function         ref 229
string                                                 builtin function         ref 162

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2526        2544    2425        2536
Length      3100    2425        16         320     100           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
im_build_interval_spec              470 external procedure  is an external procedure.  
on unit on line 142                  64 on unit               
CHECK_VERSION                           internal procedure  shares stack frame of external procedure im_build_interval_spec.  
FINISH                               64 internal procedure  is called by several nonquick procedures.  
PROCESS_AND_GROUP                       internal procedure  shares stack frame of external procedure im_build_interval_spec.  
PROCESS_CONSTRAINT                      internal procedure  shares stack frame of external procedure im_build_interval_spec.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
im_build_interval_spec   000100 first_range_field_is_not_adjacent_to_equal_fields
                                                            im_build_interval_spec
                         000102 old_interval_bead_ptr       im_build_interval_spec
                         000104 root_interval_bead_ptr      im_build_interval_spec
                         000106 temp_interval_bead_ptr      im_build_interval_spec
                         000110 field_presence_array_ptr    im_build_interval_spec
                         000112 temp_next_ptr               im_build_interval_spec
                         000114 fpa_number_of_fields        im_build_interval_spec
                         000115 and_group_idx               im_build_interval_spec
                         000116 first_range_field           im_build_interval_spec
                         000117 number_of_equal_fields      im_build_interval_spec
                         000120 number_of_intervals         im_build_interval_spec
                         000121 constraint_idx              im_build_interval_spec
                         000122 last_constraint_idx         im_build_interval_spec
                         000123 low_constraint_idx          im_build_interval_spec
                         000124 high_constraint_idx         im_build_interval_spec
                         000125 constraint_field_id         im_build_interval_spec
                         000126 constraint_operator_code    im_build_interval_spec
                         000130 work_area_ptr               im_build_interval_spec
                         000140 search_specification_ptr    im_build_interval_spec
                         000142 interval_specification_ptr  im_build_interval_spec
                         000144 interval_bead_ptr           im_build_interval_spec
                         000146 simple_typed_vector_ptr     im_build_interval_spec
                         000150 stv_number_of_dimensions    im_build_interval_spec
                         000152 id_list_ptr                 im_build_interval_spec
                         000154 il_number_of_ids            im_build_interval_spec

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out_desc   call_int_this       call_int_other      return_mac          enable_op
ext_entry           int_entry           op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$programming_error   error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     48 000203        63 000215        66 000216        67 000220        68 000221        69 000222        71 000223
     77 000224        79 000225        86 000230    3   62 000231    3   64 000232    5   21 000233    5   22 000234
    127 000236       128 000242       129 000245       130 000270       136 000357       138 000361       139 000363
    140 000364       142 000365       144 000407       147 000415       148 000446       149 000447       150 000450
    151 000453       152 000456       153 000460       154 000462       155 000464       156 000465       157 000467
    160 000470       161 000530       162 000535       168 000544       170 000557       171 000561       174 000563
    175 000577       176 000602       177 000605       178 000607       180 000611       181 000613       183 000617
    185 000620       191 000631       196 000715       198 000716       200 000724       203 000736       205 000745
    206 000750       208 000766       210 001001       211 001004       212 001011       215 001017       217 001026
    219 001027       223 001031       224 001054       226 001063       227 001074       229 001076       231 001117
    232 001121       236 001132       240 001143       241 001145       244 001147       250 001170       252 001173
    253 001202       254 001205       256 001223       257 001225       258 001230       261 001231       265 001237
    271 001243       272 001244       274 001246       275 001277       279 001300       281 001305       285 001307
    286 001311       287 001321       288 001323       290 001326       296 001330       299 001345       307 001350
    308 001352       309 001366       310 001371       311 001372       312 001421       314 001446       317 001467
    321 001503       323 001505       324 001507       326 001534       327 001536       328 001537       330 001541
    331 001542       336 001545       337 001546       338 001550       339 001601       343 001602       345 001607
    349 001611       350 001613       351 001623       352 001625       354 001630       360 001632       363 001643
    367 001647       368 001651       369 001665       371 001670       372 001672       373 001721       375 001746
    378 001755       382 001776       385 002012       387 002020       388 002022       390 002024       395 002073
    398 002075       400 002123       402 002131       405 002132       406 002135       409 002137       412 002141
    414 002167       417 002175       420 002176       421 002201       423 002203       433 002204       435 002205
    440 002207       441 002233       444 002242       450 002262       451 002267       452 002271       453 002272
    459 002311       460 002316       461 002322       462 002323       465 002334       466 002341       467 002345
    468 002346       471 002415


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
