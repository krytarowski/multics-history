	COMPILATION LISTING OF SEGMENT rcm_process_intervals
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1136.82_Tue_mdt
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION:
        8*
        9*         This     subroutine     is    similar    in    function    to    the
       10*     general_search/process_records pair of modules, except that it  takes  as
       11*     input  a list of record_ids, a search_specification to be applied against
       12*     the records in the record_id_list, and an interval_list to specify  which
       13*     and_groups  in  the  search_specification  apply  to which records in the
       14*     record_id_list.  The supported entry points are:   get,  get_id,  delete,
       15*     get_records_and_ids, and count.
       16*
       17*          The work_area supplied must be a freeing area. 
       18**/
       19 
       20 /* HISTORY:
       21*
       22*Written by Lindsey L. Spratt, 11/10/82.
       23*Modified:
       24*11/23/82 by Lindsey Spratt:  Fixed setting of typed_vector_array ptr.  Added
       25*	  support  for the get_id entry.
       26*03/16/83 by Matthew Pierret: Changed to receive the 
       27*            record_collection_opening_info structure from rm_get_opening_info.
       28*            Added the ERROR_RETURN proc
       29*            and the GET_ELEMENT_ERROR_RETURN proc (the latter translates
       30*            collection_manager_$get_element error codes into 
       31*            dm_error_$record_not_found).
       32*03/24/83 by Lindsey Spratt:  Removed the field_table include file, declared the
       33*	  field_table_ptr locally.
       34*04/22/83 by Matthew Pierret:  Added the $get_records_and_ids entry.  This
       35*            entry merges the $get and $get_id entries, returning both a
       36*            typed_vector_array and an element_id_list.  Also changed this
       37*            module to always use explicit qualifiers when accessing
       38*            element_id_lists (p_input_eil_ptr and p_output_eil_ptr), and to
       39*            set the implicit qualifier (eil_ptr) to null if the
       40*            element_id_list is not to be freed by the FINISH routine.
       41*05/23/83 by Matthew Pierret: Changed to use version 4 of specification_head.
       42*06/22/83 by Lindsey L. Spratt:  Changed to return dm_error_$record_not_found
       43*            when no matches are found.
       44*07/28/83 by Matthew Pierret: Changed name from rm_process_intervals to
       45*            rcm_process_intervals, and all rm_ prefixes to rcm_.
       46*04/13/84 by Lee Baldwin:  Changed reference to record_cursor.pf_opening_id
       47*            to record_cursor.file_opening_id.
       48*04/26/84 by Lee Baldwin:  Changed $count to not take a work_area_ptr, since
       49*            it doesn't allocate an output structure.
       50*05/10/84 by Matthew Pierret:  Changed to align record buffers on even word
       51*            boundaries.  Changed references to
       52*            data_mgmt_util_ to be to data_format_util_.
       53*06/07/84 by Matthew Pierret:  Re-named cm_$get_element to cm_$get.
       54*09/27/84 by Maggie Sharpe:  set word_area_ptr ot p_work_area_ptr in the delete
       55*            entry; check the version of element_id_list before the structure
       56*            was first used; ERROR_RETURN was called (instead of a simple
       57*            "return") in lines 245 and 260.
       58*10/28/84 by Lindsey L. Spratt:  Changed to use version 2 interval_list.
       59*10/30/84 by Lindsey L. Spratt:  Removed spurious CHECK_VERSION of
       60*            element_id_list.  It was using the (null) element_id_list_ptr,
       61*            instead of p_input_element_id_list_ptr, which was already check
       62*            elsewhere.
       63**/
       64 
       65 /* format: style2,ind3 */
       66 
       67 rcm_process_intervals:
       68    proc ();
       69 
       70       call sub_err_ (dm_error_$programming_error, myname, ACTION_CANT_RESTART, null, 0,
       71 	 "^/^a$^a is not a valid entrypoint", myname, myname);
       72 
       73 /* START OF DECLARATIONS */
       74 /* Parameter */
       75 
       76       dcl	    p_input_element_id_list_ptr
       77 			       ptr parameter;
       78       dcl	    p_id_list_ptr	       ptr parameter;
       79       dcl	    p_search_specification_ptr
       80 			       ptr parameter;
       81       dcl	    p_interval_list_ptr    ptr parameter;
       82       dcl	    p_work_area_ptr	       ptr parameter;
       83       dcl	    p_typed_vector_array_version
       84 			       fixed bin (35) parameter;
       85       dcl	    p_record_cursor_ptr    ptr parameter;
       86       dcl	    p_typed_vector_array_ptr
       87 			       ptr parameter;
       88       dcl	    p_output_element_id_list_ptr
       89 			       ptr parameter;
       90       dcl	    p_record_count	       fixed bin (35) parameter;
       91       dcl	    p_code	       fixed bin (35) parameter;
       92 
       93 /* Automatic */
       94 
       95       dcl	    (work_area_ptr, old_tva_ptr, vector_ptr, field_table_ptr)
       96 			       ptr init (null);
       97 
       98       dcl	    (get, delete, get_id, count, new_buffer_was_allocated, record_satisfies_specification)
       99 			       bit (1) aligned init ("0"b);
      100       dcl	    number_of_accepted_records
      101 			       fixed bin (35) init (0);
      102       dcl	    (interval_idx, record_id_idx, vector_slot_idx, element_id_idx)
      103 			       fixed bin init (0);
      104       dcl	    record_buffer_ptr      ptr init (null);
      105       dcl	    record_buffer_length   fixed bin (35) init (BITS_PER_PAGE);
      106       dcl	    local_record_buffer    (DOUBLE_WORDS_PER_PAGE) fixed bin (71);
      107       dcl	    record_string_ptr      ptr init (null);
      108       dcl	    record_string_length   fixed bin (35) init (0);
      109       dcl	    maximum_number_of_accepted_records
      110 			       fixed bin (35);
      111       dcl	    accepted_record_ptr    ptr aligned init (null);
      112 
      113 
      114 /* Based */
      115 
      116       dcl	    accepted_record	       (maximum_number_of_accepted_records) bit (1) unal based (accepted_record_ptr);
      117       dcl	    work_area	       based (work_area_ptr) area;
      118       dcl	    record_string	       bit (record_string_length) based (record_string_ptr);
      119       dcl	    record_buffer	       bit (record_buffer_length) based (record_buffer_ptr);
      120 
      121 /* Builtin */
      122 
      123       dcl	    (addr, string, null)   builtin;
      124 
      125 /* Constant */
      126 
      127       dcl	    DOUBLE_WORDS_PER_PAGE  init (512) fixed bin internal static options (constant);
      128       dcl	    BITS_PER_PAGE	       init (1024 * 36) fixed bin internal static options (constant);
      129       dcl	    VECTOR_SLOT_PAD	       init (200) fixed bin internal static options (constant);
      130       dcl	    DEFAULT_POSITION       init (0) fixed bin (35) internal static options (constant);
      131       dcl	    (
      132 	    DEFAULT_NUMBER_OF_FULLY_STRUCTURAL_FIELDS
      133 			       init (0),
      134 	    DEFAULT_PARTIAL_STRUCTURAL_FIELD
      135 			       init (0)
      136 	    )		       fixed bin internal static options (constant);
      137       dcl	    myname	       init ("rcm_process_intervals") char (32) varying internal static options (constant);
      138 
      139 /* Entry */
      140 
      141       dcl	    sub_err_	       entry () options (variable);
      142       dcl	    rcm_get_opening_info   entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
      143       dcl	    data_format_util_$cv_table_to_typed_array
      144 			       entry (ptr, ptr, ptr, fixed bin (35), ptr, fixed bin (35));
      145       dcl	    data_format_util_$cv_string_to_vector
      146 			       entry (ptr, ptr, ptr, fixed bin (35), ptr, ptr, fixed bin (35));
      147       dcl	    data_format_util_$compare_sequential
      148 			       entry (ptr, ptr, ptr, fixed bin, fixed bin, bit (*), bit (1) aligned, fixed bin (35))
      149 			       ;
      150 
      151 /* External */
      152 
      153       dcl	    (
      154 	    error_table_$unimplemented_version,
      155 	    dm_error_$programming_error,
      156 	    dm_error_$record_not_found,
      157 	    dm_error_$wrong_cursor_type
      158 	    )		       fixed bin (35) ext;
      159 
      160 /* END OF DECLARATIONS */
      161 
      162 get:
      163    entry (p_input_element_id_list_ptr, p_id_list_ptr, p_search_specification_ptr, p_interval_list_ptr, p_work_area_ptr,
      164         p_typed_vector_array_version, p_record_cursor_ptr, p_typed_vector_array_ptr, p_code);
      165 
      166       if p_typed_vector_array_version ^= TYPED_VECTOR_ARRAY_VERSION_2
      167       then
      168          do;
      169 	  p_code = error_table_$unimplemented_version;
      170 	  return;
      171          end;
      172 
      173       get = "1"b;
      174       work_area_ptr = p_work_area_ptr;
      175       goto JOIN;
      176 
      177 get_id:
      178    entry (p_input_element_id_list_ptr, p_search_specification_ptr, p_interval_list_ptr, p_work_area_ptr,
      179         p_record_cursor_ptr, p_output_element_id_list_ptr, p_code);
      180 
      181       get_id = "1"b;
      182       p_output_element_id_list_ptr = null;
      183       work_area_ptr = p_work_area_ptr;
      184       goto JOIN;
      185 
      186 count:
      187    entry (p_input_element_id_list_ptr, p_search_specification_ptr, p_interval_list_ptr, p_record_cursor_ptr,
      188         p_record_count, p_code);
      189 
      190       count = "1"b;
      191       goto JOIN;
      192 
      193 get_records_and_ids:
      194    entry (p_input_element_id_list_ptr, p_id_list_ptr, p_search_specification_ptr, p_interval_list_ptr, p_work_area_ptr,
      195         p_typed_vector_array_version, p_record_cursor_ptr, p_output_element_id_list_ptr, p_typed_vector_array_ptr, p_code)
      196         ;
      197 
      198       get, get_id = "1"b;
      199       if p_typed_vector_array_version ^= TYPED_VECTOR_ARRAY_VERSION_2
      200       then
      201          do;
      202 	  p_code = error_table_$unimplemented_version;
      203 	  return;
      204          end;
      205       work_area_ptr = p_work_area_ptr;
      206       goto JOIN;
      207 
      208 delete:
      209    entry (p_input_element_id_list_ptr, p_search_specification_ptr, p_interval_list_ptr, p_work_area_ptr,
      210         p_record_cursor_ptr, p_record_count, p_code);
      211 
      212       delete = "1"b;
      213       work_area_ptr = p_work_area_ptr;
      214 JOIN:
      215       p_code = 0;
      216       element_id_list_ptr, typed_vector_array_ptr = null;
      217 
      218       call CHECK_VERSION (p_input_element_id_list_ptr -> element_id_list.version, ELEMENT_ID_LIST_VERSION_1,
      219 	 "element_id_list");
      220 
      221       search_specification_ptr = p_search_specification_ptr;
      222       call CHECK_VERSION (search_specification.version, SPECIFICATION_VERSION_4, "search_specification");
      223 
      224       interval_list_ptr = p_interval_list_ptr;
      225 
      226       call CHECK_VERSION_CHAR_8 (interval_list.version, INTERVAL_LIST_VERSION_2, "interval_list");
      227 
      228       record_cursor_ptr = p_record_cursor_ptr;
      229 
      230       if record_cursor.type ^= RECORD_CURSOR_TYPE
      231       then call sub_err_ (dm_error_$wrong_cursor_type, myname, ACTION_CANT_RESTART, null, 0,
      232 	      "^/Expected a record cursor, type ^d.  Received a cursor of type ^d.", RECORD_CURSOR_TYPE,
      233 	      record_cursor.type);
      234       call CHECK_VERSION ((record_cursor.version), (RECORD_CURSOR_VERSION_2), "record_cursor");
      235 
      236       if get_id
      237       then
      238          do;
      239 	  maximum_number_of_accepted_records = p_input_element_id_list_ptr -> element_id_list.number_of_elements;
      240 	  alloc accepted_record in (work_area);
      241 	  string (accepted_record) = "0"b;
      242          end;
      243 
      244       call rcm_get_opening_info (record_cursor.file_opening_id, record_cursor.collection_id,
      245 	 record_collection_opening_info_ptr, p_code);
      246       if p_code ^= 0
      247       then call ERROR_RETURN ();
      248 
      249       call CHECK_VERSION_CHAR_8 (record_collection_opening_info.version, RECORD_COLLECTION_OPENING_INFO_VERSION_1,
      250 	 "record_collection_opening_info");
      251 
      252       field_table_ptr = record_collection_opening_info.field_table_ptr;
      253 
      254       if get
      255       then
      256          do;
      257 	  call data_format_util_$cv_table_to_typed_array (field_table_ptr, p_id_list_ptr, work_area_ptr,
      258 	       (VECTOR_SLOT_PAD), typed_vector_array_ptr, p_code);
      259 	  if p_code ^= 0
      260 	  then call ERROR_RETURN ();
      261 	  call CHECK_VERSION (typed_vector_array.version, TYPED_VECTOR_ARRAY_VERSION_2, "typed_vector_array");
      262 
      263          end;
      264 
      265       record_buffer_ptr = addr (local_record_buffer);
      266 
      267 INTERVAL_LIST_LOOP:
      268       do interval_idx = 1 to interval_list.number_of_intervals
      269 	 while (number_of_accepted_records < search_specification.range.size | search_specification.range.size = 0);
      270 RECORD_LOOP:
      271          do record_id_idx = interval_list.interval (interval_idx).low_vector_idx
      272 	    to interval_list.interval (interval_idx).high_vector_idx
      273 	    while (number_of_accepted_records < search_specification.range.size | search_specification.range.size = 0);
      274 	  call collection_manager_$get (record_cursor.file_opening_id, record_cursor.collection_id,
      275 	       p_input_element_id_list_ptr -> element_id_list.id (record_id_idx), (DEFAULT_POSITION), record_buffer_ptr,
      276 	       record_buffer_length, work_area_ptr, new_buffer_was_allocated, record_string_ptr, record_string_length,
      277 	       p_code);
      278 	  if p_code ^= 0
      279 	  then call GET_ELEMENT_ERROR_RETURN (p_code);
      280 
      281 	  if new_buffer_was_allocated
      282 	  then if record_buffer_ptr ^= addr (local_record_buffer)
      283 	       then
      284 		do;
      285 		   free record_buffer in (work_area);
      286 		   record_buffer_ptr = record_string_ptr;
      287 		   record_buffer_length = record_string_length;
      288 		end;
      289 
      290 	  call data_format_util_$compare_sequential (field_table_ptr, search_specification_ptr,
      291 	       interval_list.interval (interval_idx).and_group_id_list_ptr, DEFAULT_NUMBER_OF_FULLY_STRUCTURAL_FIELDS,
      292 	       DEFAULT_PARTIAL_STRUCTURAL_FIELD, record_string, record_satisfies_specification, p_code);
      293 	  if p_code ^= 0
      294 	  then call ERROR_RETURN;
      295 
      296 	  if record_satisfies_specification
      297 	  then
      298 	     do;
      299 	        number_of_accepted_records = number_of_accepted_records + 1;
      300 	        if get
      301 	        then call ADD_TO_ARRAY;
      302 	        if get_id
      303 	        then accepted_record (record_id_idx) = "1"b;
      304 	        else if delete
      305 	        then call DELETE_RECORD;
      306 	     end;
      307          end RECORD_LOOP;
      308       end INTERVAL_LIST_LOOP;
      309 
      310       if get & number_of_accepted_records > 0
      311       then p_typed_vector_array_ptr = typed_vector_array_ptr;
      312 
      313       else if delete | count
      314       then p_record_count = number_of_accepted_records;
      315 
      316       if get_id & number_of_accepted_records > 0
      317       then
      318          do;
      319 	  eil_number_of_elements = number_of_accepted_records;
      320 	  alloc element_id_list in (work_area);
      321 	  element_id_list.version = ELEMENT_ID_LIST_VERSION_1;
      322 	  record_id_idx = 0;
      323 	  do element_id_idx = 1 to p_input_element_id_list_ptr -> element_id_list.number_of_elements;
      324 	     if accepted_record (element_id_idx)
      325 	     then
      326 	        do;
      327 		 record_id_idx = record_id_idx + 1;
      328 		 element_id_list.id (record_id_idx) =
      329 		      p_input_element_id_list_ptr -> element_id_list.id (element_id_idx);
      330 	        end;
      331 	  end;
      332 	  p_output_element_id_list_ptr = element_id_list_ptr;
      333 	  element_id_list_ptr = null;
      334          end;
      335 
      336       if number_of_accepted_records = 0
      337       then p_code = dm_error_$record_not_found;
      338 
      339       call FINISH;
      340 RETURN:
      341       return;
      342 
      343 CHECK_VERSION:
      344    proc (p_received_version, p_expected_version, p_structure_name);
      345       dcl	    p_received_version     fixed bin (35);
      346       dcl	    p_expected_version     fixed bin (35);
      347       dcl	    p_structure_name       char (*);
      348 
      349       if p_received_version ^= p_expected_version
      350       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      351 	      "^/Expected version ^d of the ^a structure.
      352 Received version ^d instead.", p_expected_version, p_structure_name, p_received_version);
      353 
      354    end CHECK_VERSION;
      355 
      356 
      357 CHECK_VERSION_CHAR_8:
      358    proc (p_given_version, p_correct_version, p_structure_name);
      359 
      360       dcl	    p_structure_name       char (*);
      361       dcl	    p_given_version	       char (8) aligned;
      362       dcl	    p_correct_version      char (8) aligned;
      363 
      364       if p_given_version ^= p_correct_version
      365       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      366 	      "^/Expected version ""^8a"" of ^a structure; received ""^8a"".", p_correct_version, p_structure_name,
      367 	      p_given_version);
      368 
      369       return;
      370 
      371    end CHECK_VERSION_CHAR_8;
      372 
      373 DELETE_RECORD:
      374    proc;
      375    end DELETE_RECORD;
      376 
      377 ADD_TO_ARRAY:
      378    proc;
      379       call data_format_util_$cv_string_to_vector (field_table_ptr, work_area_ptr, record_string_ptr, record_string_length,
      380 	 p_id_list_ptr, vector_ptr, p_code);
      381       if p_code ^= 0
      382       then call ERROR_RETURN;
      383 
      384       typed_vector_array.number_of_vectors = typed_vector_array.number_of_vectors + 1;
      385       if typed_vector_array.number_of_vectors <= typed_vector_array.number_of_vector_slots
      386       then typed_vector_array.vector_slot (typed_vector_array.number_of_vectors) = vector_ptr;
      387       else
      388          do;
      389 	  tva_number_of_vector_slots = typed_vector_array.number_of_vectors + VECTOR_SLOT_PAD;
      390 	  tva_number_of_dimensions = typed_vector_array.number_of_dimensions;
      391 	  tva_maximum_dimension_name_length = typed_vector_array.maximum_dimension_name_length;
      392 
      393 	  old_tva_ptr = typed_vector_array_ptr;
      394 
      395 	  alloc typed_vector_array in (work_area);
      396 
      397 	  typed_vector_array.version = TYPED_VECTOR_ARRAY_VERSION_2;
      398 	  typed_vector_array.number_of_vectors = old_tva_ptr -> typed_vector_array.number_of_vectors;
      399 	  typed_vector_array.dimension_table = old_tva_ptr -> typed_vector_array.dimension_table;
      400 
      401 	  do vector_slot_idx = 1 to typed_vector_array.number_of_vectors - 1;
      402 	     typed_vector_array.vector_slot (vector_slot_idx) =
      403 		old_tva_ptr -> typed_vector_array.vector_slot (vector_slot_idx);
      404 	  end;
      405 
      406 	  typed_vector_array.vector_slot (typed_vector_array.number_of_vectors) = vector_ptr;
      407 
      408 	  do vector_slot_idx = vector_slot_idx + 1 to typed_vector_array.number_of_vector_slots;
      409 	     typed_vector_array.vector_slot (vector_slot_idx) = null;
      410 	  end;
      411 
      412 	  free old_tva_ptr -> typed_vector_array in (work_area);
      413 
      414          end;
      415       number_of_accepted_records = typed_vector_array.number_of_vectors;
      416 
      417    end ADD_TO_ARRAY;
      418 
      419 FINISH:
      420    proc;
      421       if accepted_record_ptr ^= null
      422       then free accepted_record;
      423 
      424       if element_id_list_ptr ^= null
      425       then free element_id_list;
      426 
      427       if record_buffer_ptr ^= addr (local_record_buffer) & record_buffer_ptr ^= null
      428       then free record_buffer;
      429    end FINISH;
      430 
      431 
      432 ERROR_RETURN:
      433    proc ();
      434 
      435       call FINISH ();
      436       goto RETURN;
      437 
      438    end ERROR_RETURN;
      439 
      440 GET_ELEMENT_ERROR_RETURN:
      441    proc (p_code);
      442 
      443       dcl	    p_code	       fixed bin (35);
      444       dcl	    (
      445 	    dm_error_$ci_not_allocated,
      446 	    dm_error_$ci_not_in_collection,
      447 	    dm_error_$no_element
      448 	    )		       fixed bin (35) ext;
      449 
      450       if p_code = dm_error_$no_element
      451       then p_code = dm_error_$record_not_found;
      452       if p_code = dm_error_$ci_not_in_collection
      453       then p_code = dm_error_$record_not_found;
      454       if p_code = dm_error_$ci_not_allocated
      455       then p_code = dm_error_$record_not_found;
      456 
      457       call ERROR_RETURN;
      458 
      459    end GET_ELEMENT_ERROR_RETURN;
      460 
  1     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  1     2 /* format: style3 */
  1     3 
  1     4 /* These constants are to be used for the flags argument of sub_err_ */
  1     5 /* They are just "string (condition_info_header.action_flags)" */
  1     6 
  1     7 declare	(
  1     8 	ACTION_CAN_RESTART	init (""b),
  1     9 	ACTION_CANT_RESTART init ("1"b),
  1    10 	ACTION_DEFAULT_RESTART
  1    11 			init ("01"b),
  1    12 	ACTION_QUIET_RESTART
  1    13 			init ("001"b),
  1    14 	ACTION_SUPPORT_SIGNAL
  1    15 			init ("0001"b)
  1    16 	)		bit (36) aligned internal static options (constant);
  1    17 
  1    18 /* End include file */
      461 
      462 
  2     1 /* BEGIN INCLUDE FILE dm_specification_head.incl.pl1 */
  2     2 
  2     3 /* HISTORY:
  2     4*Written by Matthew Pierret, 05/11/83. (Extracted from dm_specification.incl.pl1)
  2     5*Modified:
  2     6*05/20/83 by Matthew Pierret: Changed to use version 4.
  2     7**/
  2     8 
  2     9 /* format: style2,ind3 */
  2    10      dcl	   1 specification_head   based (specification_head_ptr),
  2    11 	     2 version	      fixed bin (35),
  2    12 	     2 type	      fixed bin (17) unal,
  2    13 	     2 pad	      bit (18) unal,
  2    14 	     2 subset_specification_ptr
  2    15 			      ptr;
  2    16 
  2    17 
  2    18      dcl	   specification_head_ptr ptr;
  2    19      dcl	   SPECIFICATION_VERSION_4
  2    20 			      init (4) fixed bin (35) internal static options (constant);
  2    21 
  2    22      dcl	   (
  2    23 	   SEARCH_SPECIFICATION_TYPE
  2    24 			      init (1),
  2    25 	   ABSOLUTE_SEARCH_SPECIFICATION_TYPE
  2    26 			      init (1),
  2    27 	   NUMERIC_SPECIFICATION_TYPE
  2    28 			      init (2),
  2    29 	   ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
  2    30 			      init (2),
  2    31 	   RELATIVE_SEARCH_SPECIFICATION_TYPE
  2    32 			      init (3),
  2    33 	   RELATIVE_NUMERIC_SPECIFICATION_TYPE
  2    34 			      init (4),
  2    35 	   ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
  2    36 			      init (5),
  2    37 	   RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
  2    38 			      init (6),
  2    39 	   ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
  2    40 			      init (7),
  2    41 	   RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
  2    42 			      init (8)
  2    43 	   )		      fixed bin (17) internal static options (constant);
  2    44 
  2    45 
  2    46 /* END INCLUDE FILE dm_specification_head.incl.pl1 */
      463 
      464 
  3     1 /* BEGIN INCLUDE FILE - dm_specification.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*
  3     5*          The specification structure is used to identify sets items based on
  3     6*     the value of some of the contents of the items (the
  3     7*     search_specification), or based on the ordinal position (the
  3     8*     numeric_specification) of the first or last item in the desired set of
  3     9*     items in the set of all possible items.  It is used with the relation,
  3    10*     index and record managers.  The items for these three managers are
  3    11*     tuples, keys and records, respectively.  The sets of "all possible
  3    12*     items", for determination of ordinal position for these three managers
  3    13*     are: a relation, an index, and a record collection, respectively.
  3    14*     
  3    15*          The specification_head structure, in dm_specification_head.incl.pl1,
  3    16*     must be included in any program which uses this (the
  3    17*     dm_specification.incl.pl1) include file.
  3    18**/
  3    19 
  3    20 /* HISTORY:
  3    21*
  3    22*Written by Lindsey Spratt, 05/19/82.
  3    23*Modified:
  3    24*08/17/82 by Matthew Pierret:  Added all specification type constants.
  3    25*09/24/82 by Ronald Harvey: Changed version and added and_groups.
  3    26*10/22/82 by Lindsey Spratt:  Added the range_size to the numeric_specification.
  3    27*	  Changed the version to 3.
  3    28*05/11/83 by Matthew Pierret: Moved specification_head and and type constants
  3    29*            to dm_specification_head.incl.pl1. Added constraint.value_field_id.
  3    30*            Moved range type constants into dm_range_constants.incl.pl1.
  3    31*05/20/83 by Matthew Pierret: Added constraint.value_field_id for specifying
  3    32*            intra-key/record compares.
  3    33*10/02/84 by Lindsey L. Spratt:  Moved a misplaced journalization comment.
  3    34*            Added a DESCRIPTION comment.
  3    35**/
  3    36 
  3    37 /* format: style2,ind3 */
  3    38      dcl	   1 search_specification based (search_specification_ptr),
  3    39 	     2 head	      like specification_head,
  3    40 	     2 maximum_number_of_constraints
  3    41 			      fixed bin (17) unal,
  3    42 	     2 number_of_and_groups
  3    43 			      fixed bin (17) unal,
  3    44 	     2 range	      unal,
  3    45 	       3 type	      fixed bin (17),
  3    46 	       3 size	      fixed bin (17),
  3    47 	     2 and_group	      (ss_number_of_and_groups refer (search_specification.number_of_and_groups)),
  3    48 	       3 number_of_constraints
  3    49 			      fixed bin (17) unal,
  3    50 	       3 constraint	      (ss_maximum_number_of_constraints
  3    51 			      refer (search_specification.maximum_number_of_constraints)),
  3    52 	         4 field_id	      fixed bin (17) unal,
  3    53 	         4 operator_code  fixed bin (17) unal,
  3    54 	         4 value_field_id fixed bin (17) unal,
  3    55 	         4 pad	      bit (18) unal,
  3    56 	         4 value_ptr      ptr unal;
  3    57 
  3    58      dcl	   search_specification_ptr
  3    59 			      ptr;
  3    60      dcl	   (ss_number_of_and_groups, ss_maximum_number_of_constraints)
  3    61 			      fixed bin (17);
  3    62 
  3    63      dcl	   1 numeric_specification
  3    64 			      based (numeric_specification_ptr),
  3    65 	     2 head	      like specification_head,
  3    66 	     2 range_size	      fixed bin (35) aligned,
  3    67 	     2 position_number    fixed bin (17) unal,
  3    68 	     2 pad	      bit (18) unal;
  3    69 
  3    70      dcl	   numeric_specification_ptr
  3    71 			      ptr;
  3    72 
  3    73 /* END INCLUDE FILE - dm_specification.incl.pl1 */
      465 
      466 
  4     1 /* BEGIN INCLUDE FILE - dm_interval_list.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*          The interval_list structure is used to describe a number of
  4     6*     intervals of keys in an associated typed_vector_array.  With each
  4     7*     interval is a list of the and_groups from the search_specification used
  4     8*     to find those keys.  All of the constraints on fields which are specified
  4     9*     in the and_groups associated with an interval and are in the keys are
  4    10*     completely satisfied by the keys in the interval.
  4    11**/
  4    12 
  4    13 /* HISTORY:
  4    14*
  4    15*Written by Lindsey Spratt, 11/09/82.
  4    16*Modified:
  4    17**/
  4    18 
  4    19 /* format: style2,ind3 */
  4    20      dcl	   1 interval_list	      based (interval_list_ptr) aligned,
  4    21 	     2 version	      char (8),		/* Must be set to INTERVAL_LIST_VERSION_2. */
  4    22 	     2 number_of_intervals
  4    23 			      fixed bin (17) unal,
  4    24 	     2 pad	      bit (18) unal,
  4    25 	     2 interval	      (intl_number_of_intervals refer (interval_list.number_of_intervals)),
  4    26 	       3 low_vector_idx   fixed bin (35),	/* The first vector in the associated typed_vector_array for this interval. */
  4    27 	       3 high_vector_idx  fixed bin (35),	/* The last vector for this interval. */
  4    28 	       3 and_group_id_list_ptr
  4    29 			      ptr;		/* points to an id_list which identifies the */
  4    30 						/* and_groups in the associated search_specification */
  4    31 						/* which apply to the vectors in this interval. */
  4    32 
  4    33      dcl	   interval_list_ptr      ptr init (null);
  4    34      dcl	   INTERVAL_LIST_VERSION_2
  4    35 			      init ("IntLst 2") char (8) aligned internal static options (constant);
  4    36      dcl	   intl_number_of_intervals
  4    37 			      fixed bin init (0);
  4    38 
  4    39 /* END INCLUDE FILE dm_interval_list.incl.pl1 */
      467 
      468 
  5     1 /* BEGIN INCLUDE FILE - dm_rcm_cursor.incl.pl1 */
  5     2 
  5     3 /* HISTORY:
  5     4*Written by Matthew Pierret, 04/05/82.
  5     5*Modified:
  5     6*08/19/82 by Matthew Pierret:  Version 2. Changed collection_id to 
  5     7*            bit (36) aligned.
  5     8*07/28/83 by Matthew Pierret: Changed name from dm_rm_cursor.incl.pl1 to
  5     9*            dm_rcm_cursor.incl.pl1.
  5    10*04/13/84 by Lee Baldwin:  Renamed pf_opening_id to file_opening_id to coincide
  5    11*            with the naming conventions used in the rcm_XX routines.
  5    12**/
  5    13 
  5    14 /* format: style2,ind3 */
  5    15      dcl	   1 record_cursor	      aligned based (record_cursor_ptr),
  5    16 	     2 type	      fixed bin (17) unaligned,
  5    17 	     2 version	      fixed bin (17) unaligned,
  5    18 	     2 flags,
  5    19 	       3 position_is_valid
  5    20 			      bit (1) unal,
  5    21 	       3 pad	      bit (35) unal,
  5    22 	     2 area_ptr	      ptr,
  5    23 	     2 file_opening_id    bit (36) aligned,
  5    24 	     2 collection_id      bit (36) aligned,
  5    25 	     2 record_id	      bit (36) aligned,
  5    26 	     2 record_check_value bit (36) aligned;
  5    27 
  5    28      dcl	   record_cursor_ptr      ptr;
  5    29      dcl	   RECORD_CURSOR_VERSION_2
  5    30 			      init (2) fixed bin int static options (constant);
  5    31      dcl	   RECORD_CURSOR_TYPE     init (1) fixed bin int static options (constant);
  5    32      dcl	   BEGINNING_OF_COLLECTION_RECORD_ID
  5    33 			      init ("0"b) bit (36) aligned int static options (constant);
  5    34 
  5    35 /* END INCLUDE FILE - dm_rcm_cursor.incl.pl1 */
      469 
      470 
  6     1 /* BEGIN INCLUDE FILE dm_rcm_opening_info.incl.pl1 */
  6     2 
  6     3 /* HISTORY:
  6     4*Written by Matthew Pierret, 03/15/83. 
  6     5*Modified:
  6     6*07/28/83 by Matthew Pierret: Changed name from dm_rm_opening_info.incl.pl1 to
  6     7*            dm_rcm_opening_info.incl.pl1.
  6     8**/
  6     9 
  6    10 /* format: style2,ind3 */
  6    11      dcl	   1 record_collection_opening_info
  6    12 			      aligned based (record_collection_opening_info_ptr),
  6    13 	     2 version	      char (8) aligned init (RECORD_COLLECTION_OPENING_INFO_VERSION_1),
  6    14 	     2 current_transaction_id
  6    15 			      bit (36) aligned init ("0"b),
  6    16 	     2 current_rollback_count
  6    17 			      fixed bin (35) init (0),
  6    18 	     2 file_opening_id    bit (36) aligned init ("0"b),
  6    19 	     2 collection_id      bit (36) aligned init ("0"b),
  6    20 	     2 field_table_ptr    ptr init (null);
  6    21 
  6    22      dcl	   record_collection_opening_info_ptr
  6    23 			      ptr init (null);
  6    24      dcl	   RECORD_COLLECTION_OPENING_INFO_VERSION_1
  6    25 			      char (8) aligned init ("rc_open1") internal static options (constant);
  6    26 
  6    27 /* BEGIN INCLUDE FILE dm_rcm_opening_info.incl.pl1 */
      471 
      472 
  7     1 /* BEGIN INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*     This include file contains declarations of all collection_manager_ 
  7     5*     entrypoints.
  7     6**/
  7     7 
  7     8 /* HISTORY:
  7     9*Written by Matthew Pierret 
  7    10*Modified:
  7    11*04/14/82 by Lindsey Spratt: Changed the control_interval_id parameter of the
  7    12*	  allocate_control_interval operation to be unaligned, as well as
  7    13*	  unsigned.
  7    14*06/17/82 by Matthew Pierret: Added the put_element_portion opertion and
  7    15*            removed the beginning_location parameter from the put_element
  7    16*            operation. Added the create_page_file_operation.
  7    17*08/09/82 by Matthew Pierret: Changed "fixed bin (17)"s to "bit (36) aligned"s
  7    18*            wherever collection_id was required.
  7    19*            Also changed the control_interval_id parameter of the 
  7    20*            allocate_control_interval operation back to be aligned. So there.
  7    21*10/20/82 by Matthew Pierret: Changed $create_page_file to $create_file,
  7    22*            added the argument file_create_info_ptr to $create_file.
  7    23*12/13/82 by Lindsey Spratt:  Corrected $free_control_interval to
  7    24*	  include the zero_on_free bit.
  7    25*12/17/82 by Matthew Pierret: Added cm_$get_id.
  7    26*01/07/83 by Matthew Pierret: Added cm_$put_element_buffered, 
  7    27*            cm_$allocate_element_buffered, cm_$free_element_buffered.
  7    28*04/27/83 by Matthew Pierret: Added cm_$put_unprotected_element,
  7    29*            cm_$put_unprotected_header.
  7    30*11/07/83 by Matthew Pierret: Added $get_element_portion_buffered,
  7    31*             $simple_get_buffered_element.
  7    32*02/08/84 by Matthew Pierret:  Changed $get_id to have only one bit(1)aligned
  7    33*            parameter for specifying absolute/relative nature of search.
  7    34*03/16/84 by Matthew Pierret:  Added cm_$get_control_interval_ptr,
  7    35*            $get_element_ptr, $get_element_portion_ptr, $simple_get_element_ptr
  7    36*04/03/84 by Matthew Pierret:  Added cm_$compact_control_interval.
  7    37*06/06/84 by Matthew Pierret:  Re-named free_element* to delete and
  7    38*            delete_from_ci_buffer.
  7    39*            Re-named *_buffered_ci to =_ci_buffer.
  7    40*            get entries.
  7    41*            modify entries.
  7    42*            Changed calling sequence of modify entries to have a ptr/length
  7    43*            instead of length/ptr parameter pair.
  7    44*03/11/85 by R. Michael Tague:  Added $postcommit_increments.
  7    45**/
  7    46 
  7    47 /* This include file contains declarations of collection_manager_ entrypoints */
  7    48 
  7    49 /* format: style2,ind3 */
  7    50      dcl	   collection_manager_$allocate_control_interval
  7    51 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  7    52      dcl	   collection_manager_$compact_control_interval
  7    53 			      entry (bit (36) aligned, fixed bin (24) uns, fixed bin (35));
  7    54      dcl	   collection_manager_$create_collection
  7    55 			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  7    56      dcl	   collection_manager_$create_file
  7    57 			      entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
  7    58      dcl	   collection_manager_$destroy_collection
  7    59 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  7    60      dcl	   collection_manager_$free_control_interval
  7    61 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, bit (1) aligned,
  7    62 			      fixed bin (35));
  7    63 
  7    64      dcl	   collection_manager_$delete
  7    65 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  7    66 			      fixed bin (35));
  7    67      dcl	   collection_manager_$delete_from_ci_buffer
  7    68 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  7    69 			      fixed bin (35));
  7    70 
  7    71      dcl	   collection_manager_$get
  7    72 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  7    73 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  7    74      dcl	   collection_manager_$get_control_interval_ptr
  7    75 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, ptr,
  7    76 			      fixed bin (35));
  7    77      dcl	   collection_manager_$get_from_ci_buffer
  7    78 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  7    79 			      ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  7    80      dcl	   collection_manager_$get_by_ci_ptr
  7    81 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  7    82 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), ptr, fixed bin (35));
  7    83      dcl	   collection_manager_$get_header
  7    84 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (17), ptr, bit (1) aligned,
  7    85 			      ptr, fixed bin (35), fixed bin (35));
  7    86      dcl	   collection_manager_$get_id
  7    87 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17),
  7    88 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  7    89      dcl	   collection_manager_$get_portion
  7    90 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  7    91 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  7    92 			      fixed bin (35), fixed bin (35));
  7    93      dcl	   collection_manager_$get_portion_from_ci_buffer
  7    94 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  7    95 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  7    96 			      fixed bin (35));
  7    97      dcl	   collection_manager_$get_portion_by_ci_ptr
  7    98 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  7    99 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  7   100 			      fixed bin (35));
  7   101      dcl	   collection_manager_$modify
  7   102 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   103 			      fixed bin (35), fixed bin (35));
  7   104      dcl	   collection_manager_$modify_unprotected
  7   105 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   106 			      fixed bin (35), fixed bin (35));
  7   107      dcl	   collection_manager_$modify_in_ci_buffer
  7   108 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   109 			      fixed bin (35), fixed bin (35));
  7   110      dcl	   collection_manager_$modify_portion
  7   111 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35), ptr,
  7   112 			      fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  7   113      dcl	   collection_manager_$postcommit_increments
  7   114 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  7   115      dcl	   collection_manager_$put
  7   116 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   117 			      fixed bin (35), fixed bin (35));
  7   118      dcl	   collection_manager_$put_in_ci_buffer
  7   119 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   120 			      fixed bin (35), fixed bin (35));
  7   121      dcl	   collection_manager_$put_header
  7   122 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  7   123      dcl	   collection_manager_$put_unprotected_header
  7   124 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  7   125 
  7   126      dcl	   collection_manager_$replace_ci_buffer
  7   127 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  7   128 			      fixed bin (35));
  7   129      dcl	   collection_manager_$setup_ci_buffer
  7   130 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  7   131 			      fixed bin (35));
  7   132      dcl	   collection_manager_$simple_get_by_ci_ptr
  7   133 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  7   134 			      fixed bin (35));
  7   135      dcl	   collection_manager_$simple_get_from_ci_buffer
  7   136 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  7   137 			      fixed bin (35));
  7   138 
  7   139 /* END INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
      473 
      474 
  8     1 /* BEGIN INCLUDE FILE  - dm_element_id_list.incl.pl1 */
  8     2 
  8     3 /* DESCRIPTION:
  8     4*          The element_id_list structure contains an array of element 
  8     5*     identifiers.  These identifiers are used as tuple, record or 
  8     6*     element identifiers.  This structure is used across the relation_manager_,
  8     7*     record_manager_ and index_manager_ interfaces.  At some time the 
  8     8*     version should be changed to be char(8)aligned, when such a conversion
  8     9*     can be coordinated with the other structures used at these interfaces.
  8    10**/
  8    11 
  8    12 /* HISTORY:
  8    13*Written by Matthew Pierret, 06/06/82.
  8    14*Modified:
  8    15*12/16/82 by Roger Lackey:  Changed number_of_elements to fixed bin (35).
  8    16*            Did not change version.
  8    17*02/11/85 by Matthew Pierret:  Added DESCRIPTION, Written by.
  8    18**/
  8    19 
  8    20 /* format: style2,ind3 */
  8    21      dcl	   1 element_id_list      aligned based (element_id_list_ptr),
  8    22 	     2 version	      fixed bin (35),
  8    23 	     2 number_of_elements fixed bin (35),
  8    24 	     2 id		      (eil_number_of_elements refer (element_id_list.number_of_elements)) bit (36) aligned;
  8    25 
  8    26      dcl	   element_id_list_ptr    ptr;
  8    27      dcl	   eil_number_of_elements fixed bin (35);
  8    28      dcl	   ELEMENT_ID_LIST_VERSION_1
  8    29 			      init (1) fixed bin (35);
  8    30 
  8    31 
  8    32 /* END INCLUDE FILE  - dm_element_id_list.incl.pl1 */
      475 
      476 
  9     1 /* ***********************************************************
  9     2*   *                                                         *
  9     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  9     4*   *                                                         *
  9     5*   *********************************************************** */
  9     6 /* BEGIN INCLUDE FILE vu_typed_vector_array.incl.pl1 */
  9     7 
  9     8 /* Written by Lindsey Spratt, 03/04/82.
  9     9*Modified:
  9    10*06/23/82 by Lindsey Spratt: Changed to version 2.  The cv entry declarations
  9    11*	  were altered.  cv_to_typed now takes ptr to the descriptor, ptr to
  9    12*	  the print_vector value (char varying), ptr to the typed_vector
  9    13*	  value location, and a code. cv_to_print now takes ptr to the
  9    14*	  descriptor, ptr to the typed_vector value, the print_vector value
  9    15*	  (char(*) varying), the maximum allowed length for the print_vector
  9    16*	  value, a temp_seg to put the value in if its to big to fit into
  9    17*	  the print_vector, and a code.
  9    18**/
  9    19 
  9    20 /* format: style2,ind3 */
  9    21      dcl	   1 typed_vector_array   based (typed_vector_array_ptr) aligned,
  9    22 	     2 version	      fixed bin (35),
  9    23 	     2 number_of_dimensions
  9    24 			      fixed bin (17),
  9    25 	     2 number_of_vectors  fixed bin (17),
  9    26 	     2 number_of_vector_slots
  9    27 			      fixed bin (17),
  9    28 	     2 maximum_dimension_name_length
  9    29 			      fixed bin (17),
  9    30 	     2 dimension_table    (tva_number_of_dimensions refer (typed_vector_array.number_of_dimensions)),
  9    31 	       3 name	      char (tva_maximum_dimension_name_length
  9    32 			      refer (typed_vector_array.maximum_dimension_name_length)) varying,
  9    33 	       3 descriptor_ptr   ptr,		/* call cv_to_print (descriptor_ptr, typed_value_ptr, */
  9    34 						/* temp_seg_ptr, max_length_for_print_value, */
  9    35 						/* print_value, code) */
  9    36 	       3 cv_to_print      entry (ptr, ptr, ptr, fixed bin (35), char (*) varying, fixed bin (35)),
  9    37 						/* call cv_to_typed (descriptor_ptr, area_ptr, */
  9    38 						/* print_value_ptr, typed_value_ptr, code) */
  9    39 	       3 cv_to_typed      entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  9    40 	     2 vector_slot	      (tva_number_of_vector_slots refer (typed_vector_array.number_of_vector_slots))
  9    41 			      pointer;
  9    42 
  9    43      dcl	   typed_vector_array_ptr ptr;
  9    44      dcl	   tva_number_of_vector_slots
  9    45 			      fixed bin;
  9    46      dcl	   tva_number_of_dimensions
  9    47 			      fixed bin;
  9    48      dcl	   tva_maximum_dimension_name_length
  9    49 			      fixed bin;
  9    50      dcl	   TYPED_VECTOR_ARRAY_VERSION_2
  9    51 			      fixed bin (35) int static options (constant) init (2);
  9    52 
  9    53 /* END INCLUDE FILE vu_typed_vector_array.incl.pl1 */
      477 
      478    end rcm_process_intervals;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1136.8  rcm_process_intervals.pl1         >udd>sm>ds>w>ml>rcm_process_intervals.pl1
461          1    04/16/82  1058.1  sub_err_flags.incl.pl1            >ldd>incl>sub_err_flags.incl.pl1
463          2    10/14/83  1709.1  dm_specification_head.incl.pl1    >ldd>incl>dm_specification_head.incl.pl1
465          3    01/07/85  0959.8  dm_specification.incl.pl1         >ldd>incl>dm_specification.incl.pl1
467          4    01/07/85  0959.0  dm_interval_list.incl.pl1         >ldd>incl>dm_interval_list.incl.pl1
469          5    01/07/85  0959.4  dm_rcm_cursor.incl.pl1            >ldd>incl>dm_rcm_cursor.incl.pl1
471          6    01/07/85  0959.4  dm_rcm_opening_info.incl.pl1      >ldd>incl>dm_rcm_opening_info.incl.pl1
473          7    04/05/85  1024.4  dm_collmgr_entry_dcls.incl.pl1    >ldd>incl>dm_collmgr_entry_dcls.incl.pl1
475          8    03/06/85  1131.5  dm_element_id_list.incl.pl1       >ldd>incl>dm_element_id_list.incl.pl1
477          9    10/14/83  1709.1  vu_typed_vector_array.incl.pl1    >ldd>incl>vu_typed_vector_array.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000033 constant        bit(36)                  initial dcl 1-7 set ref 70* 230* 349* 364*
BITS_PER_PAGE                          constant        fixed bin(17,0)          initial dcl 128 ref 105
DEFAULT_NUMBER_OF_FULLY_STRUCTURAL_FIELDS
                                000036 constant        fixed bin(17,0)          initial dcl 131 set ref 290*
DEFAULT_PARTIAL_STRUCTURAL_FIELD
                                000036 constant        fixed bin(17,0)          initial dcl 131 set ref 290*
DEFAULT_POSITION                       constant        fixed bin(35,0)          initial dcl 130 ref 274
DOUBLE_WORDS_PER_PAGE                  constant        fixed bin(17,0)          initial dcl 127 ref 106
ELEMENT_ID_LIST_VERSION_1       000153 automatic       fixed bin(35,0)          initial dcl 8-28 set ref 218* 321 8-28*
INTERVAL_LIST_VERSION_2         000002 constant        char(8)                  initial dcl 4-34 set ref 226*
RECORD_COLLECTION_OPENING_INFO_VERSION_1
                                000000 constant        char(8)                  initial dcl 6-24 set ref 249*
RECORD_CURSOR_TYPE              000044 constant        fixed bin(17,0)          initial dcl 5-31 set ref 230 230*
RECORD_CURSOR_VERSION_2                constant        fixed bin(17,0)          initial dcl 5-29 ref 234
SPECIFICATION_VERSION_4         000041 constant        fixed bin(35,0)          initial dcl 2-19 set ref 222*
TYPED_VECTOR_ARRAY_VERSION_2    000043 constant        fixed bin(35,0)          initial dcl 9-50 set ref 166 199 261* 397
VECTOR_SLOT_PAD                        constant        fixed bin(17,0)          initial dcl 129 ref 257 389
accepted_record                        based           bit(1)                   array packed unaligned dcl 116 set ref 240 241* 302*
                                                                                  324 421
accepted_record_ptr             000134 automatic       pointer                  initial dcl 111 set ref 111* 240* 241 302 324 421
                                                                                  421
addr                                                   builtin function         dcl 123 ref 265 281 427
and_group_id_list_ptr
                          6            based           pointer                  array level 3 dcl 4-20 set ref 290*
collection_id             5            based           bit(36)                  level 2 dcl 5-15 set ref 244* 274*
collection_manager_$get         000032 constant        entry                    external dcl 7-71 ref 274
count                           000113 automatic       bit(1)                   initial dcl 98 set ref 98* 190* 313
data_format_util_$compare_sequential
                                000020 constant        entry                    external dcl 147 ref 290
data_format_util_$cv_string_to_vector
                                000016 constant        entry                    external dcl 145 ref 379
data_format_util_$cv_table_to_typed_array
                                000014 constant        entry                    external dcl 143 ref 257
delete                          000111 automatic       bit(1)                   initial dcl 98 set ref 98* 212* 304 313
dimension_table           6            based           structure                array level 2 dcl 9-21 set ref 399* 399
dm_error_$ci_not_allocated      000034 external static fixed bin(35,0)          dcl 444 ref 454
dm_error_$ci_not_in_collection  000036 external static fixed bin(35,0)          dcl 444 ref 452
dm_error_$no_element            000040 external static fixed bin(35,0)          dcl 444 ref 450
dm_error_$programming_error     000024 external static fixed bin(35,0)          dcl 153 set ref 70*
dm_error_$record_not_found      000026 external static fixed bin(35,0)          dcl 153 ref 336 450 452 454
dm_error_$wrong_cursor_type     000030 external static fixed bin(35,0)          dcl 153 set ref 230*
eil_number_of_elements          000152 automatic       fixed bin(35,0)          dcl 8-27 set ref 319* 320 320
element_id_idx                  000122 automatic       fixed bin(17,0)          initial dcl 102 set ref 102* 323* 324 328*
element_id_list                        based           structure                level 1 dcl 8-21 set ref 320 424
element_id_list_ptr             000150 automatic       pointer                  dcl 8-26 set ref 216* 320* 321 328 332 333* 424 424
error_table_$unimplemented_version
                                000022 external static fixed bin(35,0)          dcl 153 set ref 169 202 349* 364*
field_table_ptr                 000106 automatic       pointer                  initial dcl 95 in procedure "rcm_process_intervals"
                                                                                  set ref 95* 252* 257* 290* 379*
field_table_ptr           6            based           pointer                  initial level 2 in structure
                                                                                  "record_collection_opening_info" dcl 6-11
                                                                                  in procedure "rcm_process_intervals" ref 252
file_opening_id           4            based           bit(36)                  level 2 dcl 5-15 set ref 244* 274*
get                             000110 automatic       bit(1)                   initial dcl 98 set ref 98* 173* 198* 254 300 310
get_id                          000112 automatic       bit(1)                   initial dcl 98 set ref 98* 181* 198* 236 302 316
head                                   based           structure                level 2 unaligned dcl 3-38
high_vector_idx           5            based           fixed bin(35,0)          array level 3 dcl 4-20 ref 270
id                        2            based           bit(36)                  array level 2 dcl 8-21 set ref 274* 328* 328
interval                  4            based           structure                array level 2 dcl 4-20
interval_idx                    000117 automatic       fixed bin(17,0)          initial dcl 102 set ref 102* 267* 270 270 290*
interval_list                          based           structure                level 1 dcl 4-20
interval_list_ptr               000140 automatic       pointer                  initial dcl 4-33 set ref 224* 226 267 270 270 290
                                                                                  4-33*
intl_number_of_intervals        000142 automatic       fixed bin(17,0)          initial dcl 4-36 set ref 4-36*
local_record_buffer             000130 automatic       fixed bin(71,0)          array dcl 106 set ref 265 281 427
low_vector_idx            4            based           fixed bin(35,0)          array level 3 dcl 4-20 ref 270
maximum_dimension_name_length
                          4            based           fixed bin(17,0)          level 2 dcl 9-21 set ref 385 391 395* 399 402 402
                                                                                  406 409 412
maximum_number_of_accepted_records
                                000133 automatic       fixed bin(35,0)          dcl 109 set ref 239* 240 241 421
myname                          000004 constant        varying char(32)         initial dcl 137 set ref 70* 70* 70* 230* 349* 364*
new_buffer_was_allocated        000114 automatic       bit(1)                   initial dcl 98 set ref 98* 274* 281
null                                                   builtin function         dcl 123 ref 70 70 95 95 95 95 104 107 111 182 216
                                                                                  230 230 333 4-33 6-22 349 349 364 364 409 421 424
                                                                                  427
number_of_accepted_records      000116 automatic       fixed bin(35,0)          initial dcl 100 set ref 100* 267 270 299* 299 310
                                                                                  313 316 319 336 415*
number_of_dimensions      1            based           fixed bin(17,0)          level 2 dcl 9-21 set ref 385 390 395* 399 402 402
                                                                                  406 409 412
number_of_elements        1            based           fixed bin(35,0)          level 2 dcl 8-21 set ref 239 320* 323 424
number_of_intervals       2            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-20 ref 267
number_of_vector_slots
                          3            based           fixed bin(17,0)          level 2 dcl 9-21 set ref 385 395* 408 412
number_of_vectors         2            based           fixed bin(17,0)          level 2 dcl 9-21 set ref 384* 384 385 385 389 398*
                                                                                  398 401 406 415
old_tva_ptr                     000102 automatic       pointer                  initial dcl 95 set ref 95* 393* 398 399 402 412
p_code                                 parameter       fixed bin(35,0)          dcl 91 in procedure "rcm_process_intervals" set ref
                                                                                  162 169* 177 186 193 202* 208 214* 244* 246 257*
                                                                                  259 274* 278 278* 290* 293 336* 379* 381
p_code                                 parameter       fixed bin(35,0)          dcl 443 in procedure "GET_ELEMENT_ERROR_RETURN" set
                                                                                  ref 440 450 450* 452 452* 454 454*
p_correct_version                      parameter       char(8)                  dcl 362 set ref 357 364 364*
p_expected_version                     parameter       fixed bin(35,0)          dcl 346 set ref 343 349 349*
p_given_version                        parameter       char(8)                  dcl 361 set ref 357 364 364*
p_id_list_ptr                          parameter       pointer                  dcl 78 set ref 162 193 257* 379*
p_input_element_id_list_ptr            parameter       pointer                  dcl 76 ref 162 177 186 193 208 218 239 274 323 328
p_interval_list_ptr                    parameter       pointer                  dcl 81 ref 162 177 186 193 208 224
p_output_element_id_list_ptr           parameter       pointer                  dcl 88 set ref 177 182* 193 332*
p_received_version                     parameter       fixed bin(35,0)          dcl 345 set ref 343 349 349*
p_record_count                         parameter       fixed bin(35,0)          dcl 90 set ref 186 208 313*
p_record_cursor_ptr                    parameter       pointer                  dcl 85 ref 162 177 186 193 208 228
p_search_specification_ptr             parameter       pointer                  dcl 79 ref 162 177 186 193 208 221
p_structure_name                       parameter       char                     packed unaligned dcl 347 in procedure
                                                                                  "CHECK_VERSION" set ref 343 349*
p_structure_name                       parameter       char                     packed unaligned dcl 360 in procedure
                                                                                  "CHECK_VERSION_CHAR_8" set ref 357 364*
p_typed_vector_array_ptr               parameter       pointer                  dcl 86 set ref 162 193 310*
p_typed_vector_array_version           parameter       fixed bin(35,0)          dcl 83 ref 162 166 193 199
p_work_area_ptr                        parameter       pointer                  dcl 82 ref 162 174 177 183 193 205 208 213
range                     5            based           structure                level 2 packed packed unaligned dcl 3-38
rcm_get_opening_info            000012 constant        entry                    external dcl 142 ref 244
record_buffer                          based           bit                      packed unaligned dcl 119 ref 285 427
record_buffer_length            000126 automatic       fixed bin(35,0)          initial dcl 105 set ref 105* 274* 285 285 287* 427
                                                                                  427
record_buffer_ptr               000124 automatic       pointer                  initial dcl 104 set ref 104* 265* 274* 281 285 286*
                                                                                  427 427 427
record_collection_opening_info         based           structure                level 1 dcl 6-11
record_collection_opening_info_ptr
                                000146 automatic       pointer                  initial dcl 6-22 set ref 244* 249 252 6-22*
record_cursor                          based           structure                level 1 dcl 5-15
record_cursor_ptr               000144 automatic       pointer                  dcl 5-28 set ref 228* 230 230 234 244 244 274 274
record_id_idx                   000120 automatic       fixed bin(17,0)          initial dcl 102 set ref 102* 270* 274 302* 322* 327*
                                                                                  327 328
record_satisfies_specification  000115 automatic       bit(1)                   initial dcl 98 set ref 98* 290* 296
record_string                          based           bit                      packed unaligned dcl 118 set ref 290*
record_string_length            000132 automatic       fixed bin(35,0)          initial dcl 108 set ref 108* 274* 287 290 290 379*
record_string_ptr               000130 automatic       pointer                  initial dcl 107 set ref 107* 274* 286 290 379*
search_specification                   based           structure                level 1 unaligned dcl 3-38
search_specification_ptr        000136 automatic       pointer                  dcl 3-58 set ref 221* 222 267 267 270 270 290*
size                      5(18)        based           fixed bin(17,0)          level 3 packed packed unaligned dcl 3-38 ref 267 267
                                                                                  270 270
specification_head                     based           structure                level 1 unaligned dcl 2-10
string                                                 builtin function         dcl 123 set ref 241*
sub_err_                        000010 constant        entry                    external dcl 141 ref 70 230 349 364
tva_maximum_dimension_name_length
                                000160 automatic       fixed bin(17,0)          dcl 9-48 set ref 391* 395 395
tva_number_of_dimensions        000157 automatic       fixed bin(17,0)          dcl 9-46 set ref 390* 395 395
tva_number_of_vector_slots      000156 automatic       fixed bin(17,0)          dcl 9-44 set ref 389* 395 395
type                                   based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-15 set ref 230
                                                                                  230*
typed_vector_array                     based           structure                level 1 dcl 9-21 set ref 395 412
typed_vector_array_ptr          000154 automatic       pointer                  dcl 9-43 set ref 216* 257* 261 310 384 384 385 385
                                                                                  385 385 389 390 391 393 395* 397 398 399 401 402
                                                                                  406 406 408 409 415
vector_ptr                      000104 automatic       pointer                  initial dcl 95 set ref 95* 379* 385 406
vector_slot                            based           pointer                  array level 2 dcl 9-21 set ref 385* 402* 402 406*
                                                                                  409*
vector_slot_idx                 000121 automatic       fixed bin(17,0)          initial dcl 102 set ref 102* 401* 402 402* 408* 408*
                                                                                  409*
version                                based           fixed bin(35,0)          level 2 in structure "typed_vector_array" dcl 9-21
                                                                                  in procedure "rcm_process_intervals" set ref 261*
                                                                                  397*
version                                based           char(8)                  level 2 in structure "interval_list" dcl 4-20
                                                                                  in procedure "rcm_process_intervals" set ref 226*
version                                based           fixed bin(35,0)          level 3 in structure "search_specification" dcl 3-38
                                                                                  in procedure "rcm_process_intervals" set ref 222*
version                                based           fixed bin(35,0)          level 2 in structure "element_id_list" dcl 8-21
                                                                                  in procedure "rcm_process_intervals" set ref 218*
                                                                                  321*
version                                based           char(8)                  initial level 2 in structure
                                                                                  "record_collection_opening_info" dcl 6-11
                                                                                  in procedure "rcm_process_intervals" set ref 249*
version                   0(18)        based           fixed bin(17,0)          level 2 in structure "record_cursor" packed packed
                                                                                  unaligned dcl 5-15 in procedure
                                                                                  "rcm_process_intervals" ref 234
work_area                              based           area(1024)               dcl 117 ref 240 285 320 395 412
work_area_ptr                   000100 automatic       pointer                  initial dcl 95 set ref 95* 174* 183* 205* 213* 240
                                                                                  257* 274* 285 320 379* 395 412

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSOLUTE_NUMERIC_SPECIFICATION_TYPE    internal static fixed bin(17,0)          initial dcl 2-22
ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 2-22
ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 2-22
ABSOLUTE_SEARCH_SPECIFICATION_TYPE     internal static fixed bin(17,0)          initial dcl 2-22
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 1-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 1-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 1-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 1-7
BEGINNING_OF_COLLECTION_RECORD_ID      internal static bit(36)                  initial dcl 5-32
NUMERIC_SPECIFICATION_TYPE             internal static fixed bin(17,0)          initial dcl 2-22
RELATIVE_NUMERIC_SPECIFICATION_TYPE    internal static fixed bin(17,0)          initial dcl 2-22
RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 2-22
RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 2-22
RELATIVE_SEARCH_SPECIFICATION_TYPE     internal static fixed bin(17,0)          initial dcl 2-22
SEARCH_SPECIFICATION_TYPE              internal static fixed bin(17,0)          initial dcl 2-22
collection_manager_$allocate_control_interval
                                000000 constant        entry                    external dcl 7-50
collection_manager_$compact_control_interval
                                000000 constant        entry                    external dcl 7-52
collection_manager_$create_collection
                                000000 constant        entry                    external dcl 7-54
collection_manager_$create_file 000000 constant        entry                    external dcl 7-56
collection_manager_$delete      000000 constant        entry                    external dcl 7-64
collection_manager_$delete_from_ci_buffer
                                000000 constant        entry                    external dcl 7-67
collection_manager_$destroy_collection
                                000000 constant        entry                    external dcl 7-58
collection_manager_$free_control_interval
                                000000 constant        entry                    external dcl 7-60
collection_manager_$get_by_ci_ptr
                                000000 constant        entry                    external dcl 7-80
collection_manager_$get_control_interval_ptr
                                000000 constant        entry                    external dcl 7-74
collection_manager_$get_from_ci_buffer
                                000000 constant        entry                    external dcl 7-77
collection_manager_$get_header  000000 constant        entry                    external dcl 7-83
collection_manager_$get_id      000000 constant        entry                    external dcl 7-86
collection_manager_$get_portion 000000 constant        entry                    external dcl 7-89
collection_manager_$get_portion_by_ci_ptr
                                000000 constant        entry                    external dcl 7-97
collection_manager_$get_portion_from_ci_buffer
                                000000 constant        entry                    external dcl 7-93
collection_manager_$modify      000000 constant        entry                    external dcl 7-101
collection_manager_$modify_in_ci_buffer
                                000000 constant        entry                    external dcl 7-107
collection_manager_$modify_portion
                                000000 constant        entry                    external dcl 7-110
collection_manager_$modify_unprotected
                                000000 constant        entry                    external dcl 7-104
collection_manager_$postcommit_increments
                                000000 constant        entry                    external dcl 7-113
collection_manager_$put         000000 constant        entry                    external dcl 7-115
collection_manager_$put_header  000000 constant        entry                    external dcl 7-121
collection_manager_$put_in_ci_buffer
                                000000 constant        entry                    external dcl 7-118
collection_manager_$put_unprotected_header
                                000000 constant        entry                    external dcl 7-123
collection_manager_$replace_ci_buffer
                                000000 constant        entry                    external dcl 7-126
collection_manager_$setup_ci_buffer
                                000000 constant        entry                    external dcl 7-129
collection_manager_$simple_get_by_ci_ptr
                                000000 constant        entry                    external dcl 7-132
collection_manager_$simple_get_from_ci_buffer
                                000000 constant        entry                    external dcl 7-135
numeric_specification                  based           structure                level 1 unaligned dcl 3-63
numeric_specification_ptr              automatic       pointer                  dcl 3-70
specification_head_ptr                 automatic       pointer                  dcl 2-18
ss_maximum_number_of_constraints       automatic       fixed bin(17,0)          dcl 3-60
ss_number_of_and_groups                automatic       fixed bin(17,0)          dcl 3-60

NAMES DECLARED BY EXPLICIT CONTEXT.
ADD_TO_ARRAY                    001733 constant        entry                    internal dcl 377 ref 300
CHECK_VERSION                   001533 constant        entry                    internal dcl 343 ref 218 222 234 261
CHECK_VERSION_CHAR_8            001627 constant        entry                    internal dcl 357 ref 226 249
DELETE_RECORD                   001731 constant        entry                    internal dcl 373 ref 304
ERROR_RETURN                    002321 constant        entry                    internal dcl 432 ref 246 259 293 381 457
FINISH                          002255 constant        entry                    internal dcl 419 ref 339 435
GET_ELEMENT_ERROR_RETURN        002324 constant        entry                    internal dcl 440 ref 278
INTERVAL_LIST_LOOP              001156 constant        label                    dcl 267
JOIN                            000603 constant        label                    dcl 214 ref 175 184 191 206
RECORD_LOOP                     001200 constant        label                    dcl 270
RETURN                          001532 constant        label                    dcl 340 ref 436
count                           000445 constant        entry                    external dcl 186
delete                          000553 constant        entry                    external dcl 208
get                             000335 constant        entry                    external dcl 162
get_id                          000404 constant        entry                    external dcl 177
get_records_and_ids             000501 constant        entry                    external dcl 193
rcm_process_intervals           000247 constant        entry                    external dcl 67

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2634        2676    2366        2644
Length      3302    2366        42         367     246           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rcm_process_intervals               418 external procedure  is an external procedure.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure rcm_process_intervals.  
CHECK_VERSION_CHAR_8                    internal procedure  shares stack frame of external procedure rcm_process_intervals.  
DELETE_RECORD                           internal procedure  shares stack frame of external procedure rcm_process_intervals.  
ADD_TO_ARRAY                            internal procedure  shares stack frame of external procedure rcm_process_intervals.  
FINISH                                  internal procedure  shares stack frame of external procedure rcm_process_intervals.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure rcm_process_intervals.  
GET_ELEMENT_ERROR_RETURN                internal procedure  shares stack frame of external procedure rcm_process_intervals.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rcm_process_intervals    000100 work_area_ptr               rcm_process_intervals
                         000102 old_tva_ptr                 rcm_process_intervals
                         000104 vector_ptr                  rcm_process_intervals
                         000106 field_table_ptr             rcm_process_intervals
                         000110 get                         rcm_process_intervals
                         000111 delete                      rcm_process_intervals
                         000112 get_id                      rcm_process_intervals
                         000113 count                       rcm_process_intervals
                         000114 new_buffer_was_allocated    rcm_process_intervals
                         000115 record_satisfies_specification
                                                            rcm_process_intervals
                         000116 number_of_accepted_records  rcm_process_intervals
                         000117 interval_idx                rcm_process_intervals
                         000120 record_id_idx               rcm_process_intervals
                         000121 vector_slot_idx             rcm_process_intervals
                         000122 element_id_idx              rcm_process_intervals
                         000124 record_buffer_ptr           rcm_process_intervals
                         000126 record_buffer_length        rcm_process_intervals
                         000130 record_string_ptr           rcm_process_intervals
                         000130 local_record_buffer         rcm_process_intervals
                         000132 record_string_length        rcm_process_intervals
                         000133 maximum_number_of_accepted_records
                                                            rcm_process_intervals
                         000134 accepted_record_ptr         rcm_process_intervals
                         000136 search_specification_ptr    rcm_process_intervals
                         000140 interval_list_ptr           rcm_process_intervals
                         000142 intl_number_of_intervals    rcm_process_intervals
                         000144 record_cursor_ptr           rcm_process_intervals
                         000146 record_collection_opening_info_ptr
                                                            rcm_process_intervals
                         000150 element_id_list_ptr         rcm_process_intervals
                         000152 eil_number_of_elements      rcm_process_intervals
                         000153 ELEMENT_ID_LIST_VERSION_1   rcm_process_intervals
                         000154 typed_vector_array_ptr      rcm_process_intervals
                         000156 tva_number_of_vector_slots  rcm_process_intervals
                         000157 tva_number_of_dimensions    rcm_process_intervals
                         000160 tva_maximum_dimension_name_length
                                                            rcm_process_intervals

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               call_ext_out_desc   call_ext_out        return_mac          alloc_auto_adj      ext_entry
op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
collection_manager_$get       data_format_util_$compare_sequential
data_format_util_$cv_string_to_vector                       data_format_util_$cv_table_to_typed_array
rcm_get_opening_info          sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$ci_not_allocated    dm_error_$ci_not_in_collection                              dm_error_$no_element
dm_error_$programming_error   dm_error_$record_not_found    dm_error_$wrong_cursor_type
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     95 000202        98 000207       100 000215       102 000216       104 000222       105 000223       106 000225
    107 000233       108 000235       111 000236    4   33 000237    4   36 000240    6   22 000241    8   28 000242
     67 000246        70 000255       162 000325       166 000360       169 000364       170 000367       173 000370
    174 000372       175 000375       177 000376       181 000427       182 000431       183 000433       184 000436
    186 000437       190 000466       191 000470       193 000471       198 000526       199 000531       202 000535
    203 000540       205 000541       206 000544       208 000545       212 000576       213 000600       214 000603
    216 000604       218 000607       221 000634       222 000637       224 000661       226 000664       228 000707
    230 000712       234 000771       236 001006       239 001010       240 001015       241 001024       244 001030
    246 001046       249 001051       252 001073       254 001076       257 001100       259 001124       261 001127
    265 001154       267 001156       270 001200       274 001224       278 001266       281 001276       285 001307
    286 001314       287 001316       290 001320       293 001373       296 001376       299 001401       300 001405
    302 001410       304 001420       307 001423       308 001425       310 001427       313 001440       316 001445
    319 001451       320 001452       321 001463       322 001465       323 001466       324 001501       327 001506
    328 001507       331 001516       332 001520       333 001522       336 001524       339 001531       340 001532
    343 001533       349 001544       354 001626       357 001627       364 001640       369 001730       373 001731
    375 001732       377 001733       379 001734       381 001760       384 001763       385 001765       389 002011
    390 002013       391 002015       393 002017       395 002020       397 002053       398 002055       399 002060
    401 002076       402 002107       404 002146       406 002150       408 002172       409 002201       410 002223
    412 002225       415 002251       417 002254       419 002255       421 002256       424 002267       427 002301
    429 002320       432 002321       435 002322       436 002323       440 002324       450 002326       452 002334
    454 002341       457 002346       459 002347


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
