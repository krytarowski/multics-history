	COMPILATION LISTING OF SEGMENT mrds_dsm_parse
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/18/85  1020.3 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 mrds_dsm_parse: proc (p_mrds_dsm_parse_info_ptr, p_code);
       10 
       11 /*
       12*   HISTORY
       13*
       14*   ??-??-?? Spratt: written
       15*
       16*   81-05-07   Davids:    modified    to    set    the    value    of
       17*   .        mrds_dsm_semantics_info.data_model_ptr, which  was  just
       18*   .        added to the structure.
       19*
       20*   .        started this history section.
       21*
       22*   81-05-08 Davids: added the phrase "PROGRAM LOGIC  ERROR"  to  the
       23*   .        message output by sub_err_ in the event that the version
       24*   .        of mrds_dsm_parse_info is wrong.
       25*
       26*   .        added a call to ioa_ in report_mdb_error to  send  error
       27*   .        messages   to   the  listing,  if  one  is  being  built
       28*   .        (listing_iocb_ptr ^= null ());
       29*
       30*   81-05-15      Davids:      added       the       setting       of
       31*   .        mrds_dsm_parse_info.highest_severity_(scanner semantics)
       32*   .        after     each     call    to    mrds_dsm_scanner    and
       33*   .        mrds_dsm_semantics.  also  removed   some   unreferenced
       34*   .        variable declarations.
       35*
       36*   81-05-20 Davids: fixed a bug in how the address of shared  tables
       37*   .        was determined in next_term, DPDA.v1 was being used when
       38*   .        it should have been DPDA.v2.
       39**/
       40 
       41 /* PARAMETER */
       42 
       43 	dcl     p_mrds_dsm_parse_info_ptr ptr;
       44 	dcl     p_code		 fixed bin (35);
       45 
       46 /* AUTOMATIC */
       47 
       48 	dcl     code		 fixed bin (35);
       49 	dcl     debug_sw		 bit (1) aligned;
       50 	dcl     db_look		 pic "99" defined (db_data.type) pos (3);
       51 	dcl     1 db_data,
       52 		2 flag		 char (1),	/* * means stacked */
       53 		2 state		 pic "zzz9",
       54 		2 fil1		 char (2),
       55 		2 type		 char (6),
       56 		2 data		 char (100);
       57 	dcl     ls_top		 fixed bin (24);	/* location of top of lexical stack */
       58 	dcl     altn		 fixed bin (24);	/* APPLY alternative number */
       59 	dcl     current_state	 fixed bin (24);	/* number of current state */
       60 	dcl     test_symbol		 fixed bin (24);	/* encoding of current symbol */
       61 	dcl     current_table	 fixed bin (24);	/* number of current table */
       62 	dcl     i			 fixed bin (24);	/* temp */
       63 	dcl     la_ct		 fixed bin (24);	/* number of terminals in look-ahead stack */
       64 	dcl     la_get		 fixed bin (24);	/* location in look_ahead stack to get next symbol */
       65 	dcl     la_need		 fixed bin (24);	/* number of look-ahead symbols needed */
       66 	dcl     la_put		 fixed bin (24);	/* location in look_ahead stack to put next symbol */
       67 	dcl     an		 fixed bin (24);
       68 	dcl     la_use		 fixed bin (24);	/* location in look-ahead stack to test with */
       69 	dcl     (m, n)		 fixed bin (24);
       70 	dcl     next_state		 fixed bin (24);	/* number of next state */
       71 	dcl     nil_sym		 fixed bin (24);
       72 	dcl     nil		 fixed bin (24);
       73 	dcl     nil_flag		 bit (1);
       74 	dcl     ps_top		 fixed bin (24);	/* location of top of parse stack */
       75 	dcl     recov_msg		 char (150) var;
       76 	dcl     rulen		 fixed bin (24);	/* APPLY rule number */
       77 	dcl     t			 fixed bin (24);
       78 	declare token_cnt		 fixed binary (24); /* number of tokens used */
       79 	declare error_mark		 fixed binary (24); /* point to get past before another local correction allowed */
       80 	dcl     work_area_ptr	 ptr;
       81 	declare message		 char (128) varying;/* message with details of error */
       82 	declare message_length	 fixed binary;	/* length of returned error message */
       83 
       84 /* BASED */
       85 
       86 	dcl     work_area		 area (sys_info$max_seg_size) based (work_area_ptr);
       87 
       88 /* BUILTIN */
       89 
       90 	dcl     (
       91 	        abs,
       92 	        addr,
       93 	        copy,
       94 	        fixed,
       95 	        hbound,
       96 	        lbound,
       97 	        length,
       98 	        ltrim,
       99 	        min,
      100 	        max,
      101 	        mod,
      102 	        null,
      103 	        sign,
      104 	        string,
      105 	        substr
      106 	        )			 builtin;
      107 
      108 /* CONDITION */
      109 
      110 	dcl     cleanup		 condition;
      111 
      112 /* CONSTANT */
      113 
      114 	dcl     MYNAME		 char (14) internal static options (constant) init ("mrds_dsm_parse");
      115 	declare end_of_input_msg	 char (18) internal static options (constant) init (" --END_OF_INPUT-- ");
      116 						/* EOI message */
      117 	dcl     DDop		 (-1:2) char (4) int static options (constant) init ("LOOK", "FINI", "READ", "ERR");
      118 
      119 /* ENTRY */
      120 
      121 	dcl     sub_err_		 entry options (variable);
      122 	declare ioa_$rs		 entry options (variable);
      123 	dcl     ioa_$ioa_switch	 entry options (variable);
      124 						/* routine to return string */
      125 	dcl     mrds_dsm_scanner$init	 entry (ptr, fixed bin (35));
      126 
      127 	dcl     mrds_dsm_scanner	 entry (ptr, ptr, fixed bin, fixed bin (35));
      128 	dcl     mrds_dsm_semantics	 entry (ptr, fixed bin (24), fixed bin (24), ptr, fixed bin (24), fixed bin (35));
      129 	dcl     ioa_$ioa_switch_nnl	 entry options (variable);
      130 
      131 /* EXTERNAL */
      132 
      133 	dcl     error_table_$unimplemented_version fixed bin (35) ext;
      134 	dcl     iox_$user_output	 ptr ext static;
      135 	declare sys_info$max_seg_size	 fixed binary (35) external; /* largest segment size */
      136 
      137 	mrds_dsm_parse_info_ptr = p_mrds_dsm_parse_info_ptr;
      138 	on cleanup call finish;
      139 	if mrds_dsm_parse_info.version ^= MRDS_DSM_PARSE_INFO_VERSION_1
      140 	then call sub_err_ (error_table_$unimplemented_version, MYNAME, "s", null, (0),
      141 		"PROGRAM LOGIC ERROR^/The wrong version of mrds_dsm_parse_info was used.");
      142 
      143 
      144 /* the call to sub_err_ will never return */
      145 
      146 	p_struct_ptr = null;
      147 	mrds_dsm_scanner_info_ptr = null;
      148 	mrds_dsm_semantics_info_ptr = null;
      149 	lex_stack_ptr = null;
      150 	cur_lex_top_ptr = null;
      151 
      152 	p_code = 0;
      153 	work_area_ptr = mrds_dsm_parse_info.work_area_ptr;
      154 
      155 	allocate lex_stack in (work_area);
      156 	allocate p_struct in (work_area);
      157 	allocate cur_lex_top in (work_area);
      158 
      159 	allocate mrds_dsm_semantics_info in (work_area);
      160 	mrds_dsm_semantics_info.version = MRDS_DSM_SEMANTICS_INFO_VERSION_1;
      161 	mrds_dsm_semantics_info.debug_semantics = mrds_dsm_parse_info.debug_semantics;
      162 	mrds_dsm_semantics_info.work_area_ptr = mrds_dsm_parse_info.work_area_ptr;
      163 	mrds_dsm_semantics_info.submodel_iocb_ptr = mrds_dsm_parse_info.submodel_iocb_ptr;
      164 	mrds_dsm_semantics_info.error_iocb_ptr = mrds_dsm_parse_info.error_iocb_ptr;
      165 	mrds_dsm_semantics_info.listing_iocb_ptr = mrds_dsm_parse_info.listing_iocb_ptr;
      166 	mrds_dsm_semantics_info.data_model_ptr = mrds_dsm_parse_info.data_model_ptr;
      167 	mrds_dsm_semantics_info.highest_severity = 0;
      168 
      169 	allocate mrds_dsm_scanner_info in (work_area);
      170 	mrds_dsm_scanner_info.version = MRDS_DSM_SCANNER_INFO_VERSION_1;
      171 	mrds_dsm_scanner_info.debug_scanner = mrds_dsm_parse_info.debug_scanner;
      172 	mrds_dsm_scanner_info.source_ptr = mrds_dsm_parse_info.source_ptr;
      173 	mrds_dsm_scanner_info.source_length = mrds_dsm_parse_info.source_length;
      174 	mrds_dsm_scanner_info.error_iocb_ptr = mrds_dsm_parse_info.error_iocb_ptr;
      175 	mrds_dsm_scanner_info.listing_iocb_ptr = mrds_dsm_parse_info.listing_iocb_ptr;
      176 	mrds_dsm_scanner_info.work_area_ptr = mrds_dsm_parse_info.work_area_ptr;
      177 	mrds_dsm_scanner_info.highest_severity = 0;
      178 
      179 	call mrds_dsm_scanner$init (mrds_dsm_scanner_info_ptr, code);
      180 
      181 	current_state = 1;
      182 	debug_sw = mrds_dsm_parse_info.debug_parse;
      183 	nil_sym = -1;				/* set nil_sym non-existant */
      184 	nil_flag = "0"b;				/* Initially not in skip error recovery */
      185 	ls_top, ps_top = 0;
      186 	la_put, la_get = 1;
      187 	la_ct = 0;
      188 	token_cnt = 0;
      189 	error_mark = -1;
      190 
      191 /* Begin parsing loop. */
      192 
      193 	do while (current_state ^= 0);
      194 
      195 	     current_table = current_state;
      196 	     string (db_data) = "";
      197 	     db_data.state = current_state;
      198 
      199 	     goto CASE (DPDA.v1 (current_table));
      200 
      201 CASE (3):
      202 	     current_table = DPDA.v2 (current_table);
      203 CASE (1):
      204 	     la_use = mod (la_get + la_need - 1, -lbound (lex_stack, 1)) + 1;
      205 	     if (la_need >= -lbound (lex_stack, 1) - 1)
      206 	     then do;
      207 		     call too_many (-lbound (lex_stack, 1), "lookahead");
      208 		     call finish_mdp;
      209 		     return;
      210 		end;
      211 	     la_need = la_need + 1;
      212 	     call read_look (p_code);
      213 	     if p_code ^= 0
      214 	     then do;
      215 		     call finish_mdp;
      216 		     return;
      217 		end;
      218 	     goto NEXT;
      219 
      220 CASE (10):					/* Shared read */
      221 	     current_table = DPDA.v2 (current_table);
      222 
      223 CASE (9):						/* Read. */
      224 	     db_data.type = "READ";
      225 	     la_need = 1;
      226 	     la_use = la_get;
      227 	     call read_look (p_code);
      228 	     if p_code ^= 0
      229 	     then do;
      230 		     call finish_mdp;
      231 		     return;
      232 		end;
      233 	     goto NEXT;
      234 
      235 CASE (2):						/* Stack and Shared read */
      236 	     current_table = DPDA.v2 (current_table);
      237 
      238 CASE (0):						/* Stack and Read. */
      239 	     db_data.type = "READ";
      240 	     db_data.flag = "*";
      241 	     la_need = 1;
      242 	     la_use = la_get;
      243 	     if (ps_top >= hbound (parse_stack, 1))
      244 	     then do;
      245 		     call too_many (hbound (parse_stack, 1), "parse");
      246 		     call finish_mdp;
      247 		     return;
      248 		end;
      249 	     ps_top = ps_top + 1;			/* Top of  parsing stack. */
      250 	     parse_stack (ps_top) = current_state;	/* Stack the current state. */
      251 	     cur_lex_top (ps_top) = ls_top;		/* save current lex top (for recovery) */
      252 	     call read_look (p_code);
      253 	     if p_code ^= 0
      254 	     then do;
      255 		     call finish_mdp;
      256 		     return;
      257 		end;
      258 	     goto NEXT;
      259 
      260 CASE (6):						/* Apply Shared */
      261 	     current_table = DPDA.v2 (current_state + 3);
      262 CASE (4):						/* Apply state. */
      263 CASE (5):						/* Apply single */
      264 	     la_need = 1;
      265 	     rulen = DPDA.v1 (current_state + 2);
      266 	     altn = DPDA.v2 (current_state + 2);
      267 	     if debug_sw
      268 	     then do;
      269 		     db_data.type = "APLY";
      270 		     db_data.data = "(";
      271 		     call ioa_$ioa_switch_nnl (iox_$user_output, "^a^i ^i)", string (db_data), rulen, altn);
      272 		end;
      273 
      274 	     if (rulen > 0) & mrds_dsm_parse_info.highest_severity < 3
      275 	     then do;
      276 		     call mrds_dsm_semantics (mrds_dsm_semantics_info_ptr, rulen, altn, lex_stack_ptr, ls_top, code);
      277 		     mrds_dsm_parse_info.highest_severity_semantics =
      278 			max (mrds_dsm_parse_info.highest_severity_semantics,
      279 			mrds_dsm_semantics_info.highest_severity);
      280 		     if code ^= 0
      281 		     then do;
      282 			     p_code = code;
      283 			     call finish_mdp;
      284 			     return;
      285 			end;
      286 		end;
      287 
      288 	     if debug_sw
      289 	     then do;
      290 		     call ioa_$ioa_switch_nnl (iox_$user_output, "^-pd=^i ld=^i(", DPDA.v1 (current_state + 1),
      291 			DPDA.v2 (current_state + 1));
      292 		     do t = ps_top to ps_top - DPDA.v1 (current_state + 1) + 1 by -1;
      293 			call ioa_$ioa_switch_nnl (iox_$user_output, " ^d", parse_stack (t));
      294 		     end;
      295 		     call ioa_$ioa_switch_nnl (iox_$user_output, ")^/");
      296 		end;
      297 
      298 	     if DPDA.v1 (current_state + 1) = -1
      299 	     then if (ps_top >= hbound (parse_stack, 1))
      300 		then do;
      301 			call too_many (hbound (parse_stack, 1), "parse");
      302 			call finish_mdp;
      303 			return;
      304 		     end;
      305 		else parse_stack (ps_top + 1) = current_state;
      306 
      307 	     ps_top = ps_top - DPDA.v1 (current_state + 1);
      308 	     ls_top = ls_top - DPDA.v2 (current_state + 1);
      309 
      310 	     if ps_top <= 0
      311 	     then do;
      312 		     call report_mdp_error (4, PARSE_FAILURE, "The parse stack is empty.");
      313 		     call finish_mdp;
      314 		     return;
      315 		end;
      316 
      317 	     do i = current_table + 4 to current_table + DPDA.v2 (current_table)
      318 		while (DPDA.v1 (i) ^= parse_stack (ps_top));
      319 	     end;
      320 
      321 	     if i > current_table + DPDA.v2 (current_table)
      322 	     then current_state = DPDA.v2 (current_table + 3);
      323 	     else current_state = DPDA.v2 (i);
      324 NEXT:
      325 	end;					/* End of parse loop. */
      326 
      327 	return;					/* Effective end of mrds_dsm_parse. */
      328 
      329 read_look:
      330      proc (p_code);
      331 
      332 	dcl     p_code		 fixed bin (35);
      333 
      334 	p_code = 0;
      335 
      336 	do while (la_ct < la_need);
      337 	     call mrds_dsm_scanner (mrds_dsm_scanner_info_ptr, addr (lex_stack), -la_put, code);
      338 	     mrds_dsm_parse_info.highest_severity_scanner =
      339 		max (mrds_dsm_parse_info.highest_severity_scanner,
      340 		mrds_dsm_scanner_info.highest_severity);
      341 	     la_put = mod (la_put, -lbound (lex_stack, 1)) + 1;
      342 	     la_ct = la_ct + 1;
      343 	end;
      344 
      345 	test_symbol = lex_stack.symbol (-la_use);
      346 	m = 0;
      347 	nil = 0;
      348 	an = test_symbol - 1;			/* The current table of the Deterministic Push-Down Automata(DPDA) must be
      349*						   looped through, looking for an entry whose v1 equals the test_symbol.
      350*						   Since the v1 column in the tables of the DPDA are arranged in ascending numberic
      351*						   order, the search can be terminated when a v1>=test_symbol is found.
      352*						   If a match is found, the next_state is set to the v2 of the matching entry and
      353*						   got_symbol is called.
      354*						   If a match is not found, an error condition has occurred and must be dealt
      355*						   with appropriately.
      356*						   */
      357 
      358 	do i = current_table + 1 to current_table + DPDA.v2 (current_table) while (an < test_symbol);
      359 	     n = DPDA.v1 (i);
      360 	     if n < 0
      361 	     then an = -n;
      362 	     else an = n;
      363 	     if an < test_symbol
      364 	     then if n < 0
      365 		then m = i;
      366 		else if n = nil_sym
      367 		then nil = i;
      368 	end;
      369 
      370 	if an = test_symbol
      371 	then do;
      372 		next_state = DPDA.v2 (i - 1);
      373 		call got_symbol (p_code);
      374 		if p_code ^= 0
      375 		then return;
      376 	     end;
      377 	else do;
      378 		if an > test_symbol
      379 		then do i = 1 to current_table + DPDA.v2 (current_table);
      380 			if abs (DPDA.v1 (i)) = nil_sym
      381 			then nil = i;
      382 		     end;
      383 
      384 		if (m > 0)
      385 		then do;
      386 			next_state = DPDA.v2 (m);
      387 			call got_symbol (p_code);
      388 		     end;
      389 
      390 		else if nil_flag & nil > 0
      391 		then do;				/* If skip recovery has just occurred
      392*						   and there is a nil symbol
      393*						   transition take the transition
      394*						   and back up to the nil
      395*						   symbol in the lookahead
      396*						   stack. */
      397 			next_state = DPDA.v2 (nil);
      398 			la_get = mod (la_get - 2, -lbound (lex_stack, 1)) + 1;
      399 			la_ct = la_ct + 1;
      400 			test_symbol = nil_sym;
      401 			call got_symbol (p_code);
      402 		     end;
      403 
      404 		else if token_cnt > error_mark
      405 		then do;
      406 			if local_recovered (p_code)
      407 			then do;
      408 				call read_look (p_code);
      409 				if p_code ^= 0
      410 				then return;
      411 			     end;
      412 			else if p_code ^= 0
      413 			then return;
      414 			else if skip_recovered (p_code)
      415 			then call report_mdp_error (3, PARSE_ERROR_RECOVERY, (recov_msg));
      416 			else if p_code ^= 0
      417 			then return;
      418 			else do;
      419 				if debug_sw
      420 				then call ioa_$ioa_switch_nnl (iox_$user_output, " ^4i  ", current_state);
      421 				call ioa_$rs ("^a ^d ^a ^a", message, message_length, "Line",
      422 				     lex_stack (-la_get).line, "symbol", getermc (test_symbol, la_get));
      423 				call report_mdp_error (2, PARSE_NO_RECOVERY, (message));
      424 				p_code = PARSE_NO_RECOVERY;
      425 			     end;
      426 		     end;
      427 
      428 		else if skip_recovered (p_code)
      429 		then call report_mdp_error (3, PARSE_ERROR_RECOVERY, (recov_msg));
      430 		else if p_code ^= 0
      431 		then return;
      432 		else do;
      433 			if debug_sw
      434 			then call ioa_$ioa_switch_nnl (iox_$user_output, " ^4i  ", current_state);
      435 			call ioa_$rs ("^a ^d ^a ^a", message, message_length, "Line", lex_stack (-la_get).line,
      436 			     "symbol", getermc (test_symbol, la_get));
      437 			call report_mdp_error (2, PARSE_NO_RECOVERY, (message));
      438 			p_code = PARSE_NO_RECOVERY;
      439 		     end;
      440 	     end;					/* End of (an ^= ts) case. */
      441 	return;					/* Effective end of read_look. */
      442 
      443 got_symbol:
      444      proc (p_code);
      445 	dcl     p_code		 fixed bin (35);
      446 	p_code = 0;
      447 	nil_flag = "0"b;				/* If skip error recovery was
      448*						   in progress, it is now
      449*						   complete. */
      450 	if debug_sw
      451 	then do;
      452 		if (next_state < 0)
      453 		then do;				/* is this a look-ahead state? */
      454 			db_data.type = "LK01";
      455 			db_look = la_need;
      456 			db_data.data = geterm (test_symbol, 0);
      457 						/* display only terminal "name" on look-ahead */
      458 			db_data.flag = " ";
      459 		     end;
      460 		else do;
      461 			db_data.data = getermc (test_symbol, la_get);
      462 						/* display terminal "name" and data, if available */
      463 		     end;
      464 		call ioa_$ioa_switch_nnl (iox_$user_output, "^a^/", string (db_data));
      465 	     end;
      466 	current_state = next_state;
      467 	if (current_state < 0)
      468 	then do;					/* Transition is a look-ahead state. */
      469 		current_state = -current_state;
      470 	     end;
      471 	else do;
      472 		if (ls_top >= hbound (lex_stack, 1))
      473 		then do;
      474 			call too_many (hbound (lex_stack, 1), "lexical");
      475 			p_code = LEX_TOO_MANY;
      476 			return;
      477 		     end;
      478 		ls_top = ls_top + 1;
      479 		lex_stack (ls_top) = lex_stack (-la_get);
      480 		la_get = mod (la_get, -lbound (lex_stack, 1)) + 1;
      481 		la_ct = la_ct - 1;
      482 		token_cnt = token_cnt + 1;
      483 	     end;
      484 
      485      end;						/* End of got_symbol. */
      486 
      487 skip_recovered:
      488      proc (p_code) returns (bit (1));
      489 
      490 /* *
      491*   Skip recovery requires that the user difine one or more  recovery
      492*   terminal symbols by means of the
      493*
      494*   -recover <nil> st1 st2 ...
      495*
      496*   control  included  in  the  lrk  source.   st1  st2 etc. are skip
      497*   terminals.  They are terminals which can  end  statements.   They
      498*   cause  a  table  to  be built for skip recovery.  This table is a
      499*   list of read or lookahead states which can follow the reading  of
      500*   a skip terminal. These states correspond to the beginnings of new
      501*   statements.
      502*
      503*   Skip  recovery  is  done  when  an  error  has occurred and local
      504*   recovery (if used) was not successful.  Basically what it does is
      505*   to skip forward in the source by calling  the  scanner  until  it
      506*   encounters  one  of  the skip terminals.  It then tries to find a
      507*   state which followed a previous occurrence of the found terminal.
      508*   If one is found it adjusts the lexical and parse stacks and  then
      509*   procedes.
      510*
      511*   Effectively  a  bad "statement" has been discarded.  In this case
      512*   "statement" means an input string bounded by two  identical  skip
      513*   terminals  (such  as  ";"  for  example)  including  the boundary
      514*   terminal on  the  right.   If  the  language  is  such  that  the
      515*   discarded  statement  is optional (syntactically) the rest of the
      516*   input can be checked for syntax errors.
      517*
      518*   When a bad "statement" is discarded the parser  is  restarted  in
      519*   the  state  in  which it began to process that statement.  If the
      520*   next input symbol encountered is not acceptable  to  this  state,
      521*   the  parser  makes  a last attempt at error recovery by replacing
      522*   the bad "statement" with the <nil> symbol defined by the -recover
      523*   control if used.
      524*
      525*   The <nil> symbol is one which the scanner must NEvER  return.  It
      526*   is  needed  because some languages do not allow all statements to
      527*   occur at every point.  This means that when you back  up  to  the
      528*   last  statement  beginning  point, you may not be allowed to have
      529*   the statement you find next.  As an example, take  this  grammar:
      530*   <g>  ::= <i> | <g> <i> !
      531*   <i>  ::= <a> | <b> !
      532*   <a>  ::= a ; <rd> !
      533*   <rd> ::= r ; | <rd> r ; !
      534*   <b>  ::= b ; <sd> !
      535*   <sd> ::= s ; | <sd> s ; !
      536*   
      537*   Then  suppose  that  you  intended to have an input like line (1)
      538*   below, but instead you got (2):
      539*
      540*   (1)  a ; r ; r ; b ; s ; s ; s ; a ; r ; r ; r ;
      541*   (2)  a ; r ; r ; b ; s ; s ; s   a ; r ; r ; r ;
      542*
      543*   Suppose that the grammar had specified
      544*   -recover <nil> ;
      545*   and local recovery  is  not  used.   When  the  "s"  "a"  ";"  is
      546*   encountered,  skip  recovery  will discard it as a bad statement.
      547*   But this then means that it will miss the fact that it should  be
      548*   entering  the  <a>  rule.   It  will  then get to the "r" but the
      549*   parser will have restarted in a state which can  read  either  an
      550*   "a",  "b",  or  "s".   So  it  will  have to skip again.  In this
      551*   example, skipping will occur, one statement at a time, until  EOI
      552*   is reached.  This means that no syntax checking is done in all of
      553*   the "r" s which are skipped.  This is not highly desireable.
      554*
      555*   However, if you add a rule like this:
      556*
      557*   <a>  ::= <nil> <rd> !
      558*   then  the  generated <nil> from skip recovery will allow the <rd>
      559*   to be correctly parsed, reducing  the  number  of  useless  error
      560*   messages by quite a bit, usually.
      561*
      562*   These <nil> rules can help parse thru misplaced statements during
      563*   error  recovery,  but  will  never  accept these statements under
      564*   normal circumstances.  The semantics on these <nil> rules  should then report an error.
      565*   */
      566 
      567 	dcl     p_code		 fixed bin (35);
      568 	dcl     (i, ii)		 fixed bin (24);
      569 	dcl     (j, jj)		 fixed bin (24);
      570 	dcl     c			 fixed bin (24);
      571 	dcl     dec4		 pic "zzz9";
      572 
      573 
      574 	p_code = 0;
      575 	if (hbound (skip_v1, 1) <= 0)
      576 	then return ("0"b);				/* no skip table */
      577 	error_mark = 0;
      578 	current_table = 1;
      579 	recov_msg = "Unuseable ";
      580 	recov_msg = recov_msg || geterm (test_symbol, la_get);
      581 	recov_msg = recov_msg || " on line ";
      582 	dec4 = lex_stack (-la_get).line;
      583 	recov_msg = recov_msg || ltrim (dec4);
      584 	recov_msg = recov_msg || ",  Skipped to ";
      585 
      586 	nil_sym = skip_v1 (2);			/* SKIP table */
      587 	c = 1;
      588 	do while (c ^= 0);
      589 	     if (la_ct < 1)
      590 	     then do;				/* if look-ahead stack is empty, get a symbol */
      591 		     call mrds_dsm_scanner (mrds_dsm_scanner_info_ptr, addr (lex_stack), -la_put, p_code);
      592 		     mrds_dsm_parse_info.highest_severity_scanner =
      593 			max (mrds_dsm_parse_info.highest_severity_scanner,
      594 			mrds_dsm_scanner_info.highest_severity);
      595 		     la_put = mod (la_put, -lbound (lex_stack, 1)) + 1;
      596 		     la_ct = 1;
      597 		end;
      598 	     c = lex_stack.symbol (-la_get);
      599 	     do i = current_table + 2 to current_table + skip_v2 (current_table);
      600 						/* SKIP table */
      601 		if (skip_v1 (i) = c)
      602 		then do;				/* SKIP table */
      603 			jj = skip_v2 (i);		/* SKIP table */
      604 			do j = ps_top to 1 by -1;
      605 			     do ii = jj + 1 to jj + skip_v2 (jj);
      606 						/* SKIP table */
      607 				if (skip_v1 (ii) = parse_stack (j))
      608 				then do;		/* SKIP table */
      609 					ps_top = j - 1;
      610 					ls_top = cur_lex_top (j);
      611 					current_state = skip_v2 (ii);
      612 						/* SKIP table */
      613 					recov_msg = recov_msg || geterm (c, 0);
      614 					recov_msg = recov_msg || " on line ";
      615 					dec4 = lex_stack (-la_get).line;
      616 					recov_msg = recov_msg || ltrim (dec4) || " " || copy ("!*!", 26);
      617 					lex_stack (-la_get).symlen = 0;
      618 						/* generate a nil symbol into the look-ahead stack */
      619 					lex_stack (-la_get).symbol = nil_sym;
      620 					la_get = mod (la_get, -lbound (lex_stack, 1)) + 1;
      621 						/* Advance past nil symbol.
      622*						   It will not be used unless
      623*						   the next symbol cannot be read. */
      624 					la_ct = la_ct - 1;
      625 					nil_flag = "1"b;
      626 					return ("1"b);
      627 				     end;
      628 			     end;
      629 			end;
      630 		     end;
      631 	     end;
      632 	     la_get = mod (la_get, -lbound (lex_stack, 1)) + 1;
      633 	     la_ct = la_ct - 1;
      634 	end;
      635 	recov_msg = recov_msg || end_of_input_msg || copy ("!*!", 26);
      636 	current_state = 0;
      637 	return ("1"b);
      638      end;						/* End of skip_recovered. */
      639 
      640 geterm:
      641      proc (idx, ids) returns (char (100) var);
      642 
      643 	dcl     (idx, ids)		 fixed bin (24);
      644 	dcl     temp		 char (100) var;
      645 	dcl     c_str		 char (20000) based;
      646 
      647 	temp = "";
      648 get_rest:
      649 	if (ids > 0)
      650 	then if (lex_stack (-ids).symlen > 0)
      651 	     then do;
      652 		     temp = temp || """";
      653 		     temp = temp || substr (lex_stack (-ids).symptr -> c_str, 1, min (50, lex_stack (-ids).symlen));
      654 		     temp = temp || """";
      655 		     return (temp);
      656 		end;
      657 	if (idx = 0)
      658 	then temp = end_of_input_msg;
      659 	else temp = substr (string (TC), TL.fc (idx), TL.ln (idx));
      660 	return (temp);
      661 getermc:
      662      entry (idx, ids) returns (char (100) var);
      663 
      664 	if (idx = 0)
      665 	then temp = end_of_input_msg;
      666 	else temp = substr (string (TC), TL.fc (idx), TL.ln (idx));
      667 	temp = temp || " ";
      668 	goto get_rest;
      669      end;						/* End of get_term and get_termc. */
      670 
      671 local_recovered:
      672      proc (p_code) returns (bit (1));
      673 
      674 /*
      675*   "    this procedure implements the LRK local error recovery (using
      676*   "    the  DPDA  table).  This  is  done by using the current (bad)
      677*   "    symbol and the next input symbol. All  possible  parses  from
      678*   "    this state are examined. These trial parses proceed until the
      679*   "    next read or lookahead state is encountered. The trial parses
      680*   "    are true simulations of what  can  happen,  apply  states are
      681*   "    chosen according to the simulated top of parse stack.
      682*
      683*   "    Given:
      684*   "         B is the current symbol (bad)
      685*   "         N is the next input symbol
      686*   "         C is the current state
      687*   "         R is a "next" read state
      688*   "    These are the conditions which can exist.
      689*   "         C( N )    R( B N )    -kind-
      690*   "            0         1 0    symbol leading to R is missing
      691*   "            0         0 1    B is a wrong symbol
      692*   "            1         1 0    B and N reversed in input
      693*   "            1         0 x    B is an extra symbol in the input
      694*   "            0         0 0    recovery fails
      695*
      696*   "    The recovery tries to find  a  useable  combination.  If  one
      697*   "    exists,  the  search  does  not  stop.  If  a  second  one is
      698*   "    encountered, the search stops, a message is  generated  which
      699*   "    says the choice is not unique, and then the first combination
      700*   "    is used.
      701*
      702*   "    The local recovery shcheme was altered in  Sept  1977  by  Al
      703*   "    Kepner  to  allow  local  recovery from errors encountered by
      704*   "    look-ahead states.  Preveously  only  errors  encountered  by
      705*   "    read states could be handled.  The error correction scheme is
      706*   "    still the same heuristic described above.
      707*   "
      708*   "    Some  complexity has been added to procedure next_term.  Note
      709*   "    the new variables la_get2 and la_use2.  These  are  necessary
      710*   "    to  handle  the  case  where  an  error  is  encountered by a
      711*   "    look-ahead state and the next state found is not a look-ahead
      712*   "    state.  In this case the next  read  state  encountered  will
      713*   "    correspond  to the "bad" symbol or a symbol to the left of it
      714*   "    (depending on how many look-ahead states preceded the error).
      715*   "    The goal is to  find  the  read  or  look-ahead  state  which
      716*   "    corresponds  to  the  input  symbol to the right of the "bad"
      717*   "    symbol.  The goal is recognized by the condition  "la_use2  =
      718*   "    la_next".   Until  this  goal  is reached look-ahead and read
      719*   "    states are simply passed through using the  look-ahead  stack
      720*   "    to find the appropriate next state.
      721*   */
      722 
      723 	p_code = 0;
      724 	if (test_symbol < 0)
      725 	then do;
      726 		call ioa_$rs ("^a ^d ^a", message, message_length, "Line", lex_stack (-la_get).line,
      727 		     "Negative terminal; cannot recover");
      728 
      729 		call report_mdp_error (2, PARSE_NO_RECOVERY, (message));
      730 		return ("0"b);
      731 	     end;
      732 	error_mark = token_cnt + la_need;
      733 	do while (la_ct < la_need + 1);
      734 
      735 	     call mrds_dsm_scanner (mrds_dsm_scanner_info_ptr, addr (lex_stack), -la_put, p_code);
      736 	     mrds_dsm_parse_info.highest_severity_scanner =
      737 		max (mrds_dsm_parse_info.highest_severity_scanner,
      738 		mrds_dsm_scanner_info.highest_severity);
      739 	     if p_code ^= 0
      740 	     then return ("0"b);
      741 
      742 	     la_put = mod (la_put, -lbound (lex_stack, 1)) + 1;
      743 	     la_ct = la_ct + 1;
      744 	end;
      745 	if hbound (skip_v1, 1) > 0
      746 	then nil_sym = skip_v1 (2);			/* SKIP table */
      747 	else nil_sym = -1;
      748 	la_next = mod (la_use, -lbound (lex_stack, 1)) + 1;
      749 	next_symbol = lex_stack (-la_next).symbol;
      750 	dcl     string		 builtin;
      751 	string (sws) = "0"b;
      752 	transit = -1;
      753 	combinations = 0;
      754 	depth = 0;
      755 	if debug_sw
      756 	then call dump_la;
      757 	do i = current_table + 1 to current_table + DPDA.v2 (current_table) while (combinations < 2);
      758 	     alt_symbol = abs (DPDA.v1 (i));
      759 	     if alt_symbol = nil_sym
      760 	     then go to try_again;
      761 	     if debug_sw
      762 	     then call ioa_$ioa_switch_nnl (iox_$user_output, "#^4i ^4a ^i ^a^/", current_state, DDop (sign (DPDA.v2 (i))),
      763 		     alt_symbol, geterm (alt_symbol, 0));
      764 	     string (cycle) = "0"b;
      765 	     if combinations < 2
      766 	     then do;
      767 		     call next_term ((ps_top), (DPDA.v2 (i)), p_code);
      768 		     if p_code ^= 0
      769 		     then return ("0"b);
      770 		end;
      771 try_again:
      772 	end;
      773 	recov_msg = "";
      774 	if (transit = -1)
      775 	then return ("0"b);
      776 	goto case (fixed (string (sws)));
      777 
      778 case (0):						/* can't resolve it */
      779 	return ("0"b);
      780 
      781 case (3):
      782 case (7):						/* cannot occur */
      783 	signal condition (logic_error);
      784 	dcl     logic_error		 condition;
      785 
      786 case (1):						/* B is wrong symbol */
      787 	recov_msg = recov_msg || geterm (transit, 0);
      788 	recov_msg = recov_msg || " used in place of erroneous ";
      789 	recov_msg = recov_msg || geterm (test_symbol, la_get);
      790 	goto set_symbol;
      791 
      792 case (2):						/* symbol leading to R is missing */
      793 	recov_msg = recov_msg || "Missing ";
      794 	recov_msg = recov_msg || geterm (transit, 0);
      795 	recov_msg = recov_msg || " is assumed before ";
      796 	recov_msg = recov_msg || geterm (test_symbol, la_get);
      797 	la_ct = la_ct + 1;
      798 	lex_stack (-la_put) = lex_stack (-la_next);
      799 	lex_stack (-la_next) = lex_stack (-la_use);
      800 	la_put = mod (la_put, -lbound (lex_stack, 1)) + 1;
      801 set_symbol:
      802 	lex_stack (-la_use).token_num = 0;		/* flag as phoney token for semantics */
      803 	la_next = la_use;
      804 	lex_stack (-la_next).symptr = addr (default_symbol);
      805 	lex_stack (-la_next).symlen = length (default_symbol);
      806 	lex_stack (-la_next).line = lex_stack (-(mod (la_put - 2, -lbound (lex_stack, 1)) + 1)).line;
      807 	lex_stack (-la_next).symbol = transit;
      808 	goto done;
      809 
      810 case (4):
      811 case (5):						/* B is an extra symbol */
      812 	recov_msg = recov_msg || "Extraneous ";
      813 	recov_msg = recov_msg || geterm (test_symbol, la_use);
      814 	recov_msg = recov_msg || " ignored before ";
      815 	recov_msg = recov_msg || geterm (next_symbol, la_next);
      816 	la_ct = la_ct - 1;
      817 	la_put = mod (la_put - 2, -lbound (lex_stack, 1)) + 1;
      818 						/* Back up one in look-ahead stack. */
      819 	lex_stack (-la_use) = lex_stack (-la_next);
      820 	goto done;
      821 
      822 case (6):						/* B and N reversed */
      823 	recov_msg = recov_msg || geterm (test_symbol, la_use);
      824 	recov_msg = recov_msg || " and ";
      825 	recov_msg = recov_msg || geterm (next_symbol, la_next);
      826 	recov_msg = recov_msg || " are reversed.";
      827 	lex_stack (ls_top + 1) = lex_stack (-la_use);
      828 	lex_stack (-la_use) = lex_stack (-la_next);
      829 	lex_stack (-la_next) = lex_stack (ls_top + 1);
      830 done:
      831 	if combinations <= 1
      832 	then ;
      833 	else recov_msg = recov_msg || copy (" ", 30) || "(choose first of many possibilities)";
      834 	call ioa_$rs ("^a ^d ^a", message, message_length, "Line", mrds_dsm_scanner_info.line_number, recov_msg);
      835 
      836 	call report_mdp_error (1, PARSE_ERROR_RECOVERY, (message));
      837 	if debug_sw
      838 	then call dump_la;
      839 	return ("1"b);				/* recovery completed */
      840 
      841 	dcl     1 sws,
      842 		2 CNf		 bit (1) unal,	/* current state contains next symbol */
      843 		2 RBNf		 bit (2) unal;	/* next read matches bad or next symbol */
      844 	dcl     combinations	 fixed bin (24);	/* useable combinations found so far */
      845 	dcl     transit		 fixed bin (24);	/* found alternate symbol to use from current state */
      846 	dcl     la_next		 fixed bin (24);	/* temporary "next" look-ahead position */
      847 	dcl     alt_symbol		 fixed bin (24);	/* current alternate symbol */
      848 	dcl     cycle		 (4000) bit (1) unal;
      849 	dcl     default_symbol	 char (13) int static init ("ERROR_SYMBOL_");
      850 	dcl     next_symbol		 fixed bin (24);
      851 	dcl     p_code		 fixed bin (35);
      852 	dcl     depth		 fixed bin (24);
      853 
      854 dump_la:
      855      proc;
      856 
      857 	dcl     ii		 fixed bin (24);
      858 	if debug_sw
      859 	then do;
      860 		ii = la_get;
      861 		do while (ii ^= la_put);
      862 		     call ioa_$ioa_switch_nnl (iox_$user_output, "#la(-^i) ^3i""^a""^/", ii, lex_stack (-ii).symbol,
      863 			geterm (lex_stack (-ii).symbol, 0));
      864 		     ii = mod (ii, -lbound (lex_stack, 1)) + 1;
      865 		end;
      866 	     end;
      867      end dump_la;					/*  */
      868 next_term:
      869      proc (top, next_state, p_code);
      870 	dcl     p_code		 fixed bin (35);
      871 
      872 	p_code = 0;
      873 
      874 	look_ahead = (next_state < 0);
      875 	if look_ahead
      876 	then do;
      877 		la_use2 = la_use;
      878 		la_get2 = la_get;
      879 	     end;
      880 	else la_use2, la_get2 = mod (la_get, -lbound (lex_stack, 1)) + 1;
      881 	depth = depth + 5;
      882 	do i = 1 to ps_top;
      883 	     parse_stack2 (i) = parse_stack (i);
      884 	end;
      885 NEXT:
      886 	if (next_state = 0)
      887 	then do;
      888 		transit = 0;
      889 		depth = depth - 5;
      890 		go to done;
      891 	     end;
      892 	next_state = abs (next_state);
      893 	cur_st = next_state;
      894 	if DPDA.v1 (cur_st) = 0 | DPDA.v1 (cur_st) = 2
      895 	then do;					/* Stack state? */
      896 		if top >= hbound (parse_stack, 1)
      897 		then do;
      898 			call too_many (hbound (parse_stack, 1), "parse");
      899 			p_code = PARSE_TOO_MANY;
      900 			return;
      901 		     end;
      902 		top = top + 1;
      903 		parse_stack (top) = cur_st;
      904 	     end;
      905 	goto CASE (DPDA.v1 (cur_st));
      906 CASE (2):						/* Stack and Shared read */
      907 CASE (3):						/* Shared look */
      908 CASE (10):					/* Shared read */
      909 	cur_st = DPDA.v2 (cur_st);
      910 CASE (0):						/* Stack and Read. */
      911 CASE (1):						/* Look. */
      912 CASE (9):						/* Read. */
      913 	if DPDA.v1 (cur_st) = 1
      914 	then la_use2 = mod (la_use2, -lbound (lex_stack, 1)) + 1;
      915 	else la_use2 = la_get2;
      916 	if la_use2 = la_next
      917 	then do;
      918 		if debug_sw
      919 		then call ioa_$ioa_switch_nnl (iox_$user_output, "#^vx^4i READ^/", depth, next_state);
      920 		rep = 0;
      921 		do s = test_symbol, next_symbol while (next_symbol ^= alt_symbol);
      922 		     rep = rep + 1;
      923 		     do i = cur_st + 1 to cur_st + DPDA.v2 (cur_st) while (combinations < 2);
      924 			if ((DPDA.v1 (i) < 0) & (-DPDA.v1 (i) <= s)) | (DPDA.v1 (i) = s)
      925 			then do;
      926 				if debug_sw
      927 				then call ioa_$ioa_switch_nnl (iox_$user_output, "#^vx(^i)^i^/", depth, rep, s);
      928 				if (combinations = 0)
      929 				then do;
      930 					combinations = 1;
      931 					transit = alt_symbol;
      932 					if (rep = 1)
      933 					then RBNf = "10"b;
      934 					else RBNf = "01"b;
      935 				     end;
      936 				else combinations = 2;
      937 			     end;
      938 		     end;
      939 		end;
      940 		if (next_symbol = alt_symbol)
      941 		then do;
      942 			if (combinations = 0)
      943 			then do;
      944 				CNf = "1"b;
      945 				do i = cur_st + 1 to cur_st + DPDA.v2 (cur_st);
      946 				     if ((DPDA.v1 (i) < 0) & (-DPDA.v1 (i) <= test_symbol))
      947 					| DPDA.v1 (i) = test_symbol
      948 				     then RBNf = "10"b;
      949 				end;
      950 				transit = alt_symbol;
      951 				combinations = 1;
      952 			     end;
      953 			else combinations = 2;
      954 		     end;
      955 done:
      956 		depth = depth - 5;
      957 		do i = 1 to ps_top;
      958 		     parse_stack (i) = parse_stack2 (i);
      959 		end;
      960 		return;
      961 	     end;
      962 	else do;
      963 		if la_use2 = la_use			/* la_use points to the bad input symbol. */
      964 		then s = alt_symbol;		/* We are considering an alternate symbol. */
      965 		else s = lex_stack (-la_use2).symbol;
      966 		marked = 0;
      967 		do i = cur_st + 1 to cur_st + DPDA.v2 (cur_st) while (abs (DPDA.v1 (i)) <= s);
      968 		     if abs (DPDA.v1 (i)) = s
      969 		     then go to found;
      970 		     else if DPDA.v1 (i) < 0
      971 		     then marked = i;
      972 		end;
      973 		if marked ^= 0
      974 		then i = marked;
      975 		else go to done;
      976 found:
      977 		next_state = DPDA.v2 (i);
      978 		if next_state >= 0
      979 		then la_get2 = mod (la_get2, -lbound (lex_stack, 1)) + 1;
      980 		go to NEXT;
      981 	     end;
      982 CASE (4):						/* Apply state. */
      983 CASE (5):						/* Apply single */
      984 CASE (6):						/* Apply Shared */
      985 	if debug_sw
      986 	then call ioa_$ioa_switch_nnl (iox_$user_output, "#^vx^4i APLY^/", depth, next_state);
      987 	if DPDA.v1 (cur_st + 1) = -1
      988 	then do;
      989 		if (top >= hbound (parse_stack, 1))
      990 		then do;
      991 			call too_many (hbound (parse_stack, 1), "parse");
      992 			p_code = PARSE_TOO_MANY;
      993 			return;
      994 		     end;
      995 		parse_stack (top + 1) = cur_st;
      996 	     end;
      997 	top = top - DPDA.v1 (cur_st + 1);
      998 	if (DPDA.v1 (cur_st) = 6)
      999 	then cur_st = DPDA.v2 (cur_st + 3);
     1000 	if top > 0
     1001 	then do i = cur_st + 4 to cur_st + DPDA.v2 (cur_st);
     1002 		if (DPDA.v1 (i) = parse_stack (top))
     1003 		then do;
     1004 			next_state = DPDA.v2 (i);
     1005 			goto NEXT;
     1006 		     end;
     1007 	     end;
     1008 	else return;
     1009 	next_state = DPDA.v2 (cur_st + 3);
     1010 	goto NEXT;
     1011 
     1012 
     1013 
     1014 
     1015 	dcl     top		 fixed bin (24);	/* top of parse stack for this invocation */
     1016 	dcl     next_state		 fixed bin (24);	/* branch to follow */
     1017 	dcl     cur_st		 fixed bin (24);	/* current state for this recursion */
     1018 	dcl     rep		 fixed bin (24);
     1019 	dcl     s			 fixed bin (24);
     1020 	dcl     look_ahead		 bit (1);
     1021 	dcl     i			 fixed bin (24);
     1022 	dcl     la_get2		 fixed bin (24);
     1023 	dcl     la_use2		 fixed bin (24);
     1024 	dcl     marked		 fixed bin (24);
     1025      end;						/* End of next_term. */
     1026      end;						/* End of  local_recovered. */
     1027 
     1028      end;						/* End of read_look. */
     1029 
     1030 too_many:
     1031      proc (x, t);
     1032 	p6 = x;
     1033 	call ioa_$rs ("^a", message, message_length, "Exceeded " || p6 || " entries of lrk " || t || " stack.");
     1034 	call report_mdp_error (4, INTERNAL_STACK_OVERFLOW, (message));
     1035 	return;
     1036 
     1037 /* *	variables for too_many:	*/
     1038 	dcl     p6		 pic "zzzzz9";
     1039 	dcl     t			 char (*) parm;
     1040 	dcl     x			 fixed bin (24) parm;
     1041      end;						/* End of too_many. */
     1042 
     1043 finish_mdp:
     1044      proc;
     1045 	if lex_stack_ptr ^= null
     1046 	then free lex_stack in (work_area);
     1047 	if mrds_dsm_scanner_info_ptr ^= null
     1048 	then free mrds_dsm_scanner_info in (work_area);
     1049 	if mrds_dsm_semantics_info_ptr ^= null
     1050 	then free mrds_dsm_semantics_info in (work_area);
     1051      end;						/* End of finish_mdp. */
     1052 
     1053 report_mdp_error: proc (p_severity, p_internal_error_code, p_message);
     1054 
     1055 	dcl     p_severity		 fixed bin (35);
     1056 	dcl     p_internal_error_code	 fixed bin (35);
     1057 	dcl     p_message		 char (*);
     1058 
     1059 	mrds_dsm_parse_info.highest_severity = max (p_severity, mrds_dsm_parse_info.highest_severity);
     1060 
     1061 	call ioa_$ioa_switch (mrds_dsm_parse_info.error_iocb_ptr, "Severity ^d, ^a^/^a", p_severity,
     1062 	     MRDS_DSM_ERROR_MESSAGE (p_internal_error_code), p_message);
     1063 
     1064 	if mrds_dsm_parse_info.listing_iocb_ptr ^= null ()
     1065 	then call ioa_$ioa_switch (mrds_dsm_parse_info.listing_iocb_ptr, "Severity ^d, ^a^/^a", p_severity,
     1066 		MRDS_DSM_ERROR_MESSAGE (p_internal_error_code), p_message);
     1067 
     1068      end;						/* End of report_mdp_error. */
     1069 
     1070 finish: proc;
     1071 
     1072 	if p_struct_ptr ^= null
     1073 	then free p_struct;
     1074 	if lex_stack_ptr ^= null
     1075 	then free lex_stack;
     1076 	if mrds_dsm_semantics_info_ptr ^= null
     1077 	then free mrds_dsm_semantics_info;
     1078 	if mrds_dsm_scanner_info_ptr ^= null
     1079 	then free mrds_dsm_scanner_info;
     1080      end;						/* End of finish. */
     1081 
  1     1 /* BEGIN INCLUDE FILE mrds_dsm_parse_stack.incl.pl1 */
  1     2 
  1     3 /* These structures are used by mrds_dsm_parse, mrds_dsm_scanner, and
  1     4*mrds_dsm_semantics.  They are very similar to the
  1     5*mrds_rst_parse_stack.incl.pl1 structures, the difference being the
  1     6*semantics_ptr in the lex_stack in this include file.
  1     7*
  1     8*Written  12/19/79  by  Lindsey L. Spratt
  1     9**/
  1    10      declare 1 lex_stack	      (-5:50) based (lex_stack_ptr),
  1    11 	     2 symptr	      ptr,		/* pointer to terminal symbol in source input */
  1    12 	     2 symlen	      fixed binary (24),	/* length of terminal symbol in input */
  1    13 	     2 line	      fixed binary (24),	/* line number in source for this symbol */
  1    14 	     2 symbol	      fixed binary (24),	/* parser's encoding value for the terminal symbol */
  1    15 	     2 val	      fixed binary (71),	/* conversion value for numbers */
  1    16 	     2 float	      float binary (63),	/* conversion value if floating point number */
  1    17 	     2 semantics_ptr      ptr,		/* Pointer to arbitrary data, not used by either parse or scan routines.*/
  1    18 	     2 line_strt	      ptr,		/* pointer to start of current line */
  1    19 	     2 line_size	      fixed binary (24),	/* current length of line */
  1    20 	     2 token_num	      fixed binary (24);	/* number of this token in current line,
  1    21*						   0 if <error_symbol> for missing or wrong symbol */
  1    22 
  1    23      declare lex_stack_ptr	      ptr;		/* pointer to lexical stack */
  1    24 
  1    25 /* on => output debug messages */
  1    26 
  1    27      dcl	   1 p_struct	      (50) aligned based (p_struct_ptr),
  1    28 	     2 parse_stack	      fixed bin (24),	/* * parse stack */
  1    29 	     2 parse_stack2	      fixed bin (24);	/* * copy of parse stack used
  1    30*						   with local error recovery */
  1    31 
  1    32      dcl	   p_struct_ptr	      ptr;
  1    33 
  1    34 
  1    35      dcl	   cur_lex_top	      (50) fixed bin (24) aligned based (cur_lex_top_ptr);
  1    36 						/* current lex top stack (with parse_stack) */
  1    37 
  1    38      declare cur_lex_top_ptr	      ptr;
  1    39 
  1    40 
  1    41 /* END INCLUDE FILE mrds_rst_parse_stack.incl.pl1 */
  1    42 
     1082 
     1083 
  2     1 /* BEGIN INCLUDE FILE  -  mrds_dsm_parse_info.incl.pl1 */
  2     2 
  2     3 /*
  2     4*This structure is used to communicate with mrds_dsm_parse.
  2     5*
  2     6*79-12-19 Spratt: written
  2     7*
  2     8*81-05-07 Davids: added the data_model_ptr element
  2     9*
  2    10*81-05-15 Davids: added the highest_severity_scanner and
  2    11*.        highest_severity_semantics elements.
  2    12**/
  2    13 
  2    14      dcl	   mrds_dsm_parse_info_ptr
  2    15 			      ptr;
  2    16      dcl	   MRDS_DSM_PARSE_INFO_VERSION_1
  2    17 			      fixed bin (17) internal static options (constant) init (1);
  2    18 
  2    19      dcl	   1 mrds_dsm_parse_info  based (mrds_dsm_parse_info_ptr) aligned,
  2    20 	     2 version	      fixed bin (35),
  2    21 	     2 flags,
  2    22 	       3 debug_parse      bit (1) unal,
  2    23 	       3 debug_semantics  bit (1) unal,
  2    24 	       3 debug_scanner    bit (1) unal,
  2    25 	       3 pad	      bit (33) unal,
  2    26 	     2 work_area_ptr      ptr,
  2    27 	     2 submodel_iocb_ptr  ptr,
  2    28 	     2 error_iocb_ptr     ptr,
  2    29 	     2 listing_iocb_ptr   ptr,
  2    30 	     2 source_ptr	      ptr,
  2    31 	     2 source_length      fixed bin (35),
  2    32 	     2 highest_severity   fixed bin,
  2    33 	     2 data_model_ptr     ptr,
  2    34 	     2 highest_severity_scanner
  2    35 			      fixed bin,
  2    36 	     2 highest_severity_semantics
  2    37 			      fixed bin;
  2    38 
  2    39 /* END INCLUDE FILE  -  mrds_dsm_parse_info.incl.pl1 */
     1084 
     1085 
  3     1 /* BEGIN INCLUDE FILE  -  mrds_dsm_sem_info.incl.pl1 */
  3     2 
  3     3 /*
  3     4*This structure is used to communicate with mrds_dsm_semantics, and to
  3     5*maintain information across calls to mrds_dsm_semantics.
  3     6*
  3     7*79-12-19 Spratt: written
  3     8*
  3     9*81-05-07 Davids: added the data_model_ptr element
  3    10**/
  3    11 
  3    12      dcl	   mrds_dsm_semantics_info_ptr
  3    13 			      ptr;
  3    14      dcl	   MRDS_DSM_SEMANTICS_INFO_VERSION_1
  3    15 			      fixed bin (17) internal static options (constant) init (1);
  3    16 
  3    17      dcl	   1 mrds_dsm_semantics_info
  3    18 			      based (mrds_dsm_semantics_info_ptr) aligned,
  3    19 	     2 version	      fixed bin (35),
  3    20 	     2 flags,
  3    21 	       3 debug_semantics  bit (1) unal,
  3    22 	       3 pad	      bit (35) unal,
  3    23 	     2 work_area_ptr      ptr,
  3    24 	     2 error_iocb_ptr     ptr,
  3    25 	     2 listing_iocb_ptr   ptr,
  3    26 	     2 highest_severity   fixed bin (35),
  3    27 	     2 submodel_iocb_ptr  ptr,
  3    28 	     2 data_model_ptr     ptr;
  3    29 
  3    30 /* END INCLUDE FILE  -  mrds_dsm_sem_info.incl.pl1 */
     1086 
     1087 
  4     1 /* BEGIN INCLUDE FILE  -  mrds_dsm_scan_info.incl.pl1 */
  4     2 
  4     3 /* This structure is used to communicate with mrds_dsm_scanner, and to
  4     4*maintain information across calls.
  4     5*
  4     6*Written  12/19/79  by  Lindsey L. Spratt
  4     7**/
  4     8 
  4     9      dcl	   mrds_dsm_scanner_info_ptr
  4    10 			      ptr;
  4    11      dcl	   MRDS_DSM_SCANNER_INFO_VERSION_1
  4    12 			      fixed bin (17) internal static options (constant) init (1);
  4    13 
  4    14      dcl	   1 mrds_dsm_scanner_info
  4    15 			      based (mrds_dsm_scanner_info_ptr) aligned,
  4    16 	     2 version	      fixed bin (35),
  4    17 	     2 flags,
  4    18 	       3 debug_scanner    bit (1) unal,
  4    19 	       3 pad	      bit (35) unal,
  4    20 	     2 work_area_ptr      ptr,
  4    21 	     2 source_ptr	      ptr,
  4    22 	     2 source_length      fixed bin (35),
  4    23 	     2 listing_iocb_ptr   ptr,
  4    24 	     2 error_iocb_ptr     ptr,
  4    25 	     2 identifier_encoding
  4    26 			      fixed bin (35),
  4    27 	     2 special_token_list_ptr
  4    28 			      ptr,
  4    29 	     2 alphanum_token_list_ptr
  4    30 			      ptr,
  4    31 	     2 token_ptr	      ptr,
  4    32 	     2 token_count	      fixed bin (35),
  4    33 	     2 token_length	      fixed bin (35),
  4    34 	     2 line_ptr	      ptr,
  4    35 	     2 line_length	      fixed bin (35),
  4    36 	     2 pos	      fixed bin (35),
  4    37 	     2 char_ptr	      ptr,
  4    38 	     2 type	      fixed bin (35),
  4    39 	     2 char	      char (1),
  4    40 	     2 highest_severity   fixed bin,
  4    41 	     2 line_number	      fixed bin (35);
     1088 
     1089 
  5     1 /* BEGIN INCLUDE FILE  -  mrds_dsm_error_info.incl.pl1 */
  5     2 
  5     3 /* This include file contains the standard error messages, and named constants
  5     4*for error codes which index into the array of messages.
  5     5*
  5     6*Written 12/19/79  by  Lindsey L. Spratt
  5     7**/
  5     8 
  5     9      dcl	   PARSE_ERROR_RECOVERY   fixed bin (35) internal static options (constant) init (1);
  5    10      dcl	   PARSE_NO_RECOVERY      fixed bin (35) internal static options (constant) init (2);
  5    11      dcl	   LEX_TOO_MANY	      fixed bin (35) internal static options (constant) init (3);
  5    12      dcl	   INTERNAL_STACK_OVERFLOW
  5    13 			      fixed bin (35) internal static options (constant) init (4);
  5    14      dcl	   PARSE_TOO_MANY	      fixed bin (35) internal static options (constant) init (5);
  5    15      dcl	   PARSE_FAILURE	      fixed bin (35) internal static options (constant) init (6);
  5    16      dcl	   LISTING_IO_ERROR	      fixed bin (35) internal static options (constant) init (7);
  5    17      dcl	   ILLEGAL_CHAR_ERROR     fixed bin (35) internal static options (constant) init (8);
  5    18      dcl	   OVERLENGTH_TOKEN_ERROR fixed bin (35) internal static options (constant) init (9);
  5    19      dcl	   NO_COMMENT_END_DELIMITER_ERROR
  5    20 			      fixed bin (35) internal static options (constant) init (10);
  5    21      dcl	   UNRECOGNIZED_CHARACTER_ERROR
  5    22 			      fixed bin (35) internal static options (constant) init (11);
  5    23      dcl	   UNRECOGNIZED_TOKEN_ERROR
  5    24 			      fixed bin (35) internal static options (constant) init (12);
  5    25      dcl	   DUPLICATE_RELATION_DEF_ERROR
  5    26 			      fixed bin (35) internal static options (constant) init (13);
  5    27 
  5    28      dcl	   DUPLICATE_ENTRY_ERROR  fixed bin (35) internal static options (constant) init (14);
  5    29 
  5    30 
  5    31      dcl	   MRDS_DSM_ERROR_MESSAGE (14) char (256) varying internal static options (constant)
  5    32 			      init ("Bad syntax, a correction has been made.",
  5    33 			      "Bad syntax, unable to make a correction.",
  5    34 			      "Translator error, the lexical stack overflowed.  Contact system personnel if problem persists."
  5    35 			      ,
  5    36 			      "Translator error, an internal stack overflowed.  Contact system personnel if problem persists."
  5    37 			      ,
  5    38 			      "Translator error, the parse stack overflowed.  Contact system personnel if problem persists."
  5    39 			      , "Unable to complete parsing.", "Unable to do I/O on the listing segment switch.",
  5    40 			      "An illegal character has been found in the source.",
  5    41 			      "A token has been found which is too long.",
  5    42 			      "A comment does not have a terminating delimiter.",
  5    43 			      "An unrecognized character has been found.", "An unrecognized token has been found.",
  5    44 			      "Multiple definitions of the same relation have been found, only the first one will be used."
  5    45 			      , "Attempt to multiply specify the same entry, only the first one will be used.");
  5    46 
  5    47 /* END INCLUDE FILE  -  mrds_dsm_error_info.incl.pl1 */
     1090 
     1091 
  6     1 /* BEGIN INCLUDE FILE ..... mrds_dsm_parse_table.incl.pl1 .....
  6     2* 5/29/81  1008.0 mst Fr. From >udd>Demo>dbm_test>new_data_bases>Davids>submodels>s>mrds_dsm_parse.lrk */
  6     3 
  6     4 dcl  1 mrds_dsm_parse_table$DPDA	ext static,
  6     5 	  2 DPDAsize	fixed bin,
  6     6 	  2 DPDA(822),
  6     7 	    3(v1,v2)	fixed bin(17)unal;
  6     8 dcl  DPDAp	ptr;
  6     9 
  6    10 /*   END INCLUDE FILE ..... mrds_dsm_parse_table.incl.pl1 ..... */
     1092 
     1093 
  7     1 /* BEGIN INCLUDE FILE mrds_dsm_skip_table.incl.pl1   (Davids Multics)  05/29/81 1008.3 mst Fri */
  7     2 
  7     3 /* lrk_pl1_dpda   05/29/81  1008.3 mst Fri
  7     4*   Input:  >udd>Demo>dbm_test>new_data_bases>Davids>submodels>s>mrds_dsm_parse
  7     5*   Output: >udd>Demo>dbm_test>new_data_bases>Davids>submodels>s>mrds_dsm_skip_table.incl.pl1
  7     6**/
  7     7 dcl  skip_v1 (2)fixed bin (24) static int options (constant) init (
  7     8      7, 2
  7     9      );
  7    10 dcl  skip_v2 (2)fixed bin (24) static int options (constant) init (
  7    11      1, 0
  7    12      );
  7    13 
  7    14 /*   END INCLUDE FILE mrds_dsm_skip_table.incl.pl1 */
     1094 
     1095 
  8     1 /* BEGIN INCLUDE FILE mrds_dsm_terminals.incl.pl1   (Davids Multics)  05/29/81 1008.2 mst Fri */
  8     2 dcl 1 mrds_dsm_terminals static internal,
  8     3     2 TC (153) char (1) init (
  8     4      "<", "i", "d", "e", "n", "t", "i", "f", "i", "e", "r", ">", ";", ":",
  8     5      ",", "(", ")", "=", "r", "e", "l", "a", "t", "i", "o", "n", "a", "t",
  8     6      "t", "r", "i", "b", "u", "t", "e", "a", "c", "c", "e", "s", "s", "r",
  8     7      "e", "l", "_", "a", "c", "c", "a", "t", "t", "r", "_", "a", "c", "c",
  8     8      "d", "e", "f", "a", "u", "l", "t", "i", "n", "w", "i", "t", "h", "d",
  8     9      "e", "l", "e", "t", "e", "a", "p", "p", "e", "n", "d", "t", "u", "p",
  8    10      "l", "e", "a", "t", "t", "r", "d", "a", "d", "e", "l", "e", "t", "e",
  8    11      "_", "t", "u", "p", "l", "e", "a", "p", "p", "e", "n", "d", "_", "t",
  8    12      "u", "p", "l", "e", "r", "e", "a", "d", "r", "e", "a", "d", "_", "a",
  8    13      "t", "t", "r", "m", "o", "d", "i", "f", "y", "m", "o", "d", "i", "f",
  8    14      "y", "_", "a", "t", "t", "r", "n", "u", "l", "l", "n", "r", "m"),
  8    15     2 TL (31),
  8    16       3 lk fixed bin (24) init (
  8    17 0, 0, 1, (6) 0, 4, (3) 0, 12,
  8    18      (3) 0, 9, 14, 15, (4) 0, 24, 0, 0, 20,
  8    19 			    17, 8, 0),
  8    20       3 fc fixed bin (24) init (
  8    21   1, 13, 14, 15, 16, 17, 18, 19, 27, 36, 42, 49, 57, 64,
  8    22 													  66, 70, 76, 82, 87, 91, 92, 93, 105, 117, 121, 130, 136, 147,
  8    23 			151, 152, 153),
  8    24       3 ln fixed bin (24) init (
  8    25 		    12, (6) 1, 8, 9, 6, 7, 8, 7, 2,
  8    26         4, 6, 6, 5, 4, 1, 1, 12, 12, 4, 9, 6, 11, 4,
  8    27      (3) 1),
  8    28     2 THL (0: 30) fixed bin (24) init (
  8    29 0, 31, 30, 19, 0, 0, 6, 0, 0, 25, 7, 21, 5, 26,
  8    30 				      23, 0, 13, 11, 16, 10, 18, 27, 2, 22, 28, 0, 29, 0,
  8    31       3, 0, 0);
  8    32 
  8    33 /*   END INCLUDE FILE mrds_dsm_terminals.incl.pl1 */
     1096 
     1097 
     1098      end;						/* End of mrds_dsm_parse. */
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/85  0906.9  mrds_dsm_parse.pl1                >special_ldd>online>mrds.pbf-04/18/85>mrds_dsm_parse.pl1
1082         1    10/14/83  1608.6  mrds_dsm_parse_stack.incl.pl1     >ldd>include>mrds_dsm_parse_stack.incl.pl1
1084         2    10/14/83  1608.9  mrds_dsm_parse_info.incl.pl1      >ldd>include>mrds_dsm_parse_info.incl.pl1
1086         3    10/14/83  1608.9  mrds_dsm_sem_info.incl.pl1        >ldd>include>mrds_dsm_sem_info.incl.pl1
1088         4    10/14/83  1608.9  mrds_dsm_scan_info.incl.pl1       >ldd>include>mrds_dsm_scan_info.incl.pl1
1090         5    10/14/83  1608.7  mrds_dsm_error_info.incl.pl1      >ldd>include>mrds_dsm_error_info.incl.pl1
1092         6    10/14/83  1608.9  mrds_dsm_parse_table.incl.pl1     >ldd>include>mrds_dsm_parse_table.incl.pl1
1094         7    10/14/83  1608.9  mrds_dsm_skip_table.incl.pl1      >ldd>include>mrds_dsm_skip_table.incl.pl1
1096         8    10/14/83  1608.9  mrds_dsm_terminals.incl.pl1       >ldd>include>mrds_dsm_terminals.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CNf                             000202 automatic       bit(1)                   level 2 packed unaligned dcl 841 set ref 944*
DDop                            002124 constant        char(4)                  initial array unaligned dcl 117 set ref 761*
DPDA                      1     000036 external static structure                array level 2 packed unaligned dcl 6-4
INTERNAL_STACK_OVERFLOW         002171 constant        fixed bin(35,0)          initial dcl 5-12 set ref 1034*
LEX_TOO_MANY                           constant        fixed bin(35,0)          initial dcl 5-11 ref 475
MRDS_DSM_ERROR_MESSAGE          000306 constant        varying char(256)        initial array dcl 5-31 set ref 1061* 1064*
MRDS_DSM_PARSE_INFO_VERSION_1          constant        fixed bin(17,0)          initial dcl 2-16 ref 139
MRDS_DSM_SCANNER_INFO_VERSION_1        constant        fixed bin(17,0)          initial dcl 4-11 ref 170
MRDS_DSM_SEMANTICS_INFO_VERSION_1      constant        fixed bin(17,0)          initial dcl 3-14 ref 160
MYNAME                          002135 constant        char(14)                 initial unaligned dcl 114 set ref 139*
PARSE_ERROR_RECOVERY            002212 constant        fixed bin(35,0)          initial dcl 5-9 set ref 414* 428* 836*
PARSE_FAILURE                   002145 constant        fixed bin(35,0)          initial dcl 5-15 set ref 312*
PARSE_NO_RECOVERY               002210 constant        fixed bin(35,0)          initial dcl 5-10 set ref 423* 424 437* 438 729*
PARSE_TOO_MANY                         constant        fixed bin(35,0)          initial dcl 5-14 ref 899 992
RBNf                      0(01) 000202 automatic       bit(2)                   level 2 packed unaligned dcl 841 set ref 932* 934*
                                                                                  946*
TC                              000013 constant        char(1)                  initial array level 2 packed unaligned dcl 8-2 ref
                                                                                  659 666
TL                       47     000013 constant        structure                array level 2 unaligned dcl 8-2
abs                                                    builtin function         dcl 90 ref 380 758 892 967 968
addr                                                   builtin function         dcl 90 ref 337 337 591 591 735 735 804
alt_symbol                      000206 automatic       fixed bin(24,0)          dcl 847 set ref 758* 759 761* 761* 931 939 940 950
                                                                                  963
altn                            000140 automatic       fixed bin(24,0)          dcl 58 set ref 266* 271* 276*
an                              000151 automatic       fixed bin(24,0)          dcl 67 set ref 348* 358 360* 362* 363 370 378
c                               000122 automatic       fixed bin(24,0)          dcl 570 set ref 587* 588 598* 601 613*
c_str                                  based           char(20000)              unaligned dcl 645 ref 653
cleanup                         000302 stack reference condition                dcl 110 ref 138
code                            000100 automatic       fixed bin(35,0)          dcl 48 set ref 179* 276* 280 282 337*
combinations                    000203 automatic       fixed bin(24,0)          dcl 844 set ref 753* 757 765 830 923 928 930* 936*
                                                                                  942 951* 953*
copy                                                   builtin function         dcl 90 ref 616 635 833
cur_lex_top                            based           fixed bin(24,0)          array dcl 1-35 set ref 157 251* 610
cur_lex_top_ptr                 000314 automatic       pointer                  dcl 1-38 set ref 150* 157* 251 610
cur_st                          000410 automatic       fixed bin(24,0)          dcl 1017 set ref 893* 894 894 903 905 906* 906 910
                                                                                  923 923 923 945 945 945 967 967 967 987 995 997
                                                                                  998 998* 998 1000 1000 1000 1009
current_state                   000141 automatic       fixed bin(24,0)          dcl 59 set ref 181* 193 195 197 250 260 265 266 290
                                                                                  290 292 298 305 307 308 321* 323* 419* 433* 466*
                                                                                  467 469* 469 611* 636* 761*
current_table                   000143 automatic       fixed bin(24,0)          dcl 61 set ref 195* 199 201* 201 220* 220 235* 235
                                                                                  260* 317 317 317 321 321 321 358 358 358 378 378
                                                                                  578* 599 599 599 757 757 757
cycle                           000207 automatic       bit(1)                   array unaligned dcl 848 set ref 764*
data                      3(09) 000102 automatic       char(100)                level 2 packed unaligned dcl 51 set ref 270* 456*
                                                                                  461*
data_model_ptr           14            based           pointer                  level 2 in structure "mrds_dsm_semantics_info"
                                                                                  dcl 3-17 in procedure "mrds_dsm_parse" set ref
                                                                                  166*
data_model_ptr           16            based           pointer                  level 2 in structure "mrds_dsm_parse_info" dcl 2-19
                                                                                  in procedure "mrds_dsm_parse" ref 166
db_data                         000102 automatic       structure                level 1 packed unaligned dcl 51 set ref 196* 271 271
                                                                                  464 464
db_look                                defined         picture(2)               unaligned dcl 50 set ref 455*
debug_parse               1            based           bit(1)                   level 3 packed unaligned dcl 2-19 ref 182
debug_scanner             1            based           bit(1)                   level 3 in structure "mrds_dsm_scanner_info" packed
                                                                                  unaligned dcl 4-14 in procedure "mrds_dsm_parse"
                                                                                  set ref 171*
debug_scanner             1(02)        based           bit(1)                   level 3 in structure "mrds_dsm_parse_info" packed
                                                                                  unaligned dcl 2-19 in procedure "mrds_dsm_parse"
                                                                                  ref 171
debug_semantics           1            based           bit(1)                   level 3 in structure "mrds_dsm_semantics_info"
                                                                                  packed unaligned dcl 3-17 in procedure
                                                                                  "mrds_dsm_parse" set ref 161*
debug_semantics           1(01)        based           bit(1)                   level 3 in structure "mrds_dsm_parse_info" packed
                                                                                  unaligned dcl 2-19 in procedure "mrds_dsm_parse"
                                                                                  ref 161
debug_sw                        000101 automatic       bit(1)                   dcl 49 set ref 182* 267 288 419 433 450 755 761 837
                                                                                  858 918 926 982
dec4                            000123 automatic       picture(4)               unaligned dcl 571 set ref 582* 583 615* 616
default_symbol                  000010 internal static char(13)                 initial unaligned dcl 849 set ref 804 805
depth                           000370 automatic       fixed bin(24,0)          dcl 852 set ref 754* 881* 881 889* 889 918* 926*
                                                                                  955* 955 982*
end_of_input_msg                002130 constant        char(18)                 initial unaligned dcl 115 ref 635 657 664
error_iocb_ptr            6            based           pointer                  level 2 in structure "mrds_dsm_parse_info" dcl 2-19
                                                                                  in procedure "mrds_dsm_parse" set ref 164 174
                                                                                  1061*
error_iocb_ptr            4            based           pointer                  level 2 in structure "mrds_dsm_semantics_info"
                                                                                  dcl 3-17 in procedure "mrds_dsm_parse" set ref
                                                                                  164*
error_iocb_ptr           12            based           pointer                  level 2 in structure "mrds_dsm_scanner_info"
                                                                                  dcl 4-14 in procedure "mrds_dsm_parse" set ref
                                                                                  174*
error_mark                      000234 automatic       fixed bin(24,0)          dcl 79 set ref 189* 404 577* 732*
error_table_$unimplemented_version
                                000032 external static fixed bin(35,0)          dcl 133 set ref 139*
fc                       50     000013 constant        fixed bin(24,0)          initial array level 3 dcl 8-2 ref 659 666
fixed                                                  builtin function         dcl 90 ref 776
flag                            000102 automatic       char(1)                  level 2 packed unaligned dcl 51 set ref 240* 458*
flags                     1            based           structure                level 2 in structure "mrds_dsm_parse_info" dcl 2-19
                                                                                  in procedure "mrds_dsm_parse"
flags                     1            based           structure                level 2 in structure "mrds_dsm_semantics_info"
                                                                                  dcl 3-17 in procedure "mrds_dsm_parse"
flags                     1            based           structure                level 2 in structure "mrds_dsm_scanner_info"
                                                                                  dcl 4-14 in procedure "mrds_dsm_parse"
hbound                                                 builtin function         dcl 90 ref 243 245 245 298 301 301 472 474 474 575
                                                                                  745 896 898 898 989 991 991
highest_severity         36            based           fixed bin(17,0)          level 2 in structure "mrds_dsm_scanner_info"
                                                                                  dcl 4-14 in procedure "mrds_dsm_parse" set ref
                                                                                  177* 338 592 736
highest_severity         15            based           fixed bin(17,0)          level 2 in structure "mrds_dsm_parse_info" dcl 2-19
                                                                                  in procedure "mrds_dsm_parse" set ref 274 1059*
                                                                                  1059
highest_severity         10            based           fixed bin(35,0)          level 2 in structure "mrds_dsm_semantics_info"
                                                                                  dcl 3-17 in procedure "mrds_dsm_parse" set ref
                                                                                  167* 277
highest_severity_scanner
                         20            based           fixed bin(17,0)          level 2 dcl 2-19 set ref 338* 338 592* 592 736* 736
highest_severity_semantics
                         21            based           fixed bin(17,0)          level 2 dcl 2-19 set ref 277* 277
i                               000116 automatic       fixed bin(24,0)          dcl 568 in procedure "skip_recovered" set ref 599*
                                                                                  601 603*
i                               000144 automatic       fixed bin(24,0)          dcl 62 in procedure "mrds_dsm_parse" set ref 317*
                                                                                  317* 321 323 358* 359 363 366* 372 378* 380 380*
                                                                                  757* 758 761 767*
i                               000414 automatic       fixed bin(24,0)          dcl 1021 in procedure "next_term" set ref 882* 883
                                                                                  883* 923* 924 924 924* 945* 946 946 946* 957* 958
                                                                                  958* 967* 967* 968 970 970* 973* 976 1000* 1002
                                                                                  1004*
ids                                    parameter       fixed bin(24,0)          dcl 643 ref 640 648 648 653 653 661
idx                                    parameter       fixed bin(24,0)          dcl 643 ref 640 657 659 659 661 664 666 666
ii                              000400 automatic       fixed bin(24,0)          dcl 857 in procedure "dump_la" set ref 860* 861 862*
                                                                                  862 862 864* 864
ii                              000117 automatic       fixed bin(24,0)          dcl 568 in procedure "skip_recovered" set ref 605*
                                                                                  607 611*
ioa_$ioa_switch                 000020 constant        entry                    external dcl 123 ref 1061 1064
ioa_$ioa_switch_nnl             000030 constant        entry                    external dcl 129 ref 271 290 293 295 419 433 464 761
                                                                                  862 918 926 982
ioa_$rs                         000016 constant        entry                    external dcl 122 ref 421 435 726 834 1033
iox_$user_output                000034 external static pointer                  dcl 134 set ref 271* 290* 293* 295* 419* 433* 464*
                                                                                  761* 862* 918* 926* 982*
j                               000120 automatic       fixed bin(24,0)          dcl 569 set ref 604* 607 609 610*
jj                              000121 automatic       fixed bin(24,0)          dcl 569 set ref 603* 605 605 605
la_ct                           000145 automatic       fixed bin(24,0)          dcl 63 set ref 187* 336 342* 342 399* 399 481* 481
                                                                                  589 596* 624* 624 633* 633 733 743* 743 797* 797
                                                                                  816* 816
la_get                          000146 automatic       fixed bin(24,0)          dcl 64 set ref 186* 203 226 242 398* 398 421 421*
                                                                                  435 435* 461* 479 480* 480 580* 582 598 615 617
                                                                                  619 620* 620 632* 632 726 789* 796* 860 878 880
la_get2                         000415 automatic       fixed bin(24,0)          dcl 1022 set ref 878* 880* 915 978* 978
la_need                         000147 automatic       fixed bin(24,0)          dcl 65 set ref 203 205 211* 211 225* 241* 262* 336
                                                                                  455 732 733
la_next                         000205 automatic       fixed bin(24,0)          dcl 846 set ref 748* 749 798 799 803* 804 805 806
                                                                                  807 815* 819 825* 828 829 916
la_put                          000150 automatic       fixed bin(24,0)          dcl 66 set ref 186* 337 341* 341 591 595* 595 735
                                                                                  742* 742 798 800* 800 806 817* 817 861
la_use                          000152 automatic       fixed bin(24,0)          dcl 68 set ref 203* 226* 242* 345 748 799 801 803
                                                                                  813* 819 822* 827 828 877 963
la_use2                         000416 automatic       fixed bin(24,0)          dcl 1023 set ref 877* 880* 910* 910 915* 916 963 965
lbound                                                 builtin function         dcl 90 ref 203 205 207 341 398 480 595 620 632 742
                                                                                  748 800 806 817 864 880 910 978
length                                                 builtin function         dcl 90 ref 805
lex_stack                              based           structure                array level 1 unaligned dcl 1-10 set ref 155 203 205
                                                                                  207 337 337 341 398 472 474 474 479* 479 480 591
                                                                                  591 595 620 632 735 735 742 748 798* 798 799* 799
                                                                                  800 806 817 819* 819 827* 827 828* 828 829* 829
                                                                                  864 880 910 978 1045 1074
lex_stack_ptr                   000310 automatic       pointer                  dcl 1-23 set ref 149* 155* 203 205 207 276* 337 337
                                                                                  341 345 398 421 435 472 474 474 479 479 480 582
                                                                                  591 591 595 598 615 617 619 620 632 648 653 653
                                                                                  726 735 735 742 748 749 798 798 799 799 800 801
                                                                                  804 805 806 806 806 807 817 819 819 827 827 828
                                                                                  828 829 829 862 862 864 880 910 965 978 1045 1045
                                                                                  1074 1074
line                      3            based           fixed bin(24,0)          array level 2 dcl 1-10 set ref 421* 435* 582 615
                                                                                  726* 806* 806
line_number              37            based           fixed bin(35,0)          level 2 dcl 4-14 set ref 834*
listing_iocb_ptr         10            based           pointer                  level 2 in structure "mrds_dsm_scanner_info"
                                                                                  dcl 4-14 in procedure "mrds_dsm_parse" set ref
                                                                                  175*
listing_iocb_ptr          6            based           pointer                  level 2 in structure "mrds_dsm_semantics_info"
                                                                                  dcl 3-17 in procedure "mrds_dsm_parse" set ref
                                                                                  165*
listing_iocb_ptr         10            based           pointer                  level 2 in structure "mrds_dsm_parse_info" dcl 2-19
                                                                                  in procedure "mrds_dsm_parse" set ref 165 175 1064
                                                                                  1064*
ln                       51     000013 constant        fixed bin(24,0)          initial array level 3 dcl 8-2 ref 659 666
logic_error                     000174 stack reference condition                dcl 784 ref 781
look_ahead                      000413 automatic       bit(1)                   unaligned dcl 1020 set ref 874* 875
ls_top                          000137 automatic       fixed bin(24,0)          dcl 57 set ref 185* 251 276* 308* 308 472 478* 478
                                                                                  479 610* 827 829
ltrim                                                  builtin function         dcl 90 ref 583 616
m                               000153 automatic       fixed bin(24,0)          dcl 69 set ref 346* 363* 384 386
marked                          000417 automatic       fixed bin(24,0)          dcl 1024 set ref 966* 970* 973 973
max                                                    builtin function         dcl 90 ref 277 338 592 736 1059
message                         000240 automatic       varying char(128)        dcl 81 set ref 421* 423 435* 437 726* 729 834* 836
                                                                                  1033* 1034
message_length                  000301 automatic       fixed bin(17,0)          dcl 82 set ref 421* 435* 726* 834* 1033*
min                                                    builtin function         dcl 90 ref 653
mod                                                    builtin function         dcl 90 ref 203 341 398 480 595 620 632 742 748 800
                                                                                  806 817 864 880 910 978
mrds_dsm_parse_info                    based           structure                level 1 dcl 2-19
mrds_dsm_parse_info_ptr         000316 automatic       pointer                  dcl 2-14 set ref 137* 139 153 161 162 163 164 165
                                                                                  166 171 172 173 174 175 176 182 274 277 277 338
                                                                                  338 592 592 736 736 1059 1059 1061 1064 1064
mrds_dsm_parse_table$DPDA       000036 external static structure                level 1 unaligned dcl 6-4
mrds_dsm_scanner                000024 constant        entry                    external dcl 127 ref 337 591 735
mrds_dsm_scanner$init           000022 constant        entry                    external dcl 125 ref 179
mrds_dsm_scanner_info                  based           structure                level 1 dcl 4-14 set ref 169 1047 1078
mrds_dsm_scanner_info_ptr       000322 automatic       pointer                  dcl 4-9 set ref 147* 169* 170 171 172 173 174 175
                                                                                  176 177 179* 337* 338 591* 592 735* 736 834 1047
                                                                                  1047 1078 1078
mrds_dsm_semantics              000026 constant        entry                    external dcl 128 ref 276
mrds_dsm_semantics_info                based           structure                level 1 dcl 3-17 set ref 159 1049 1076
mrds_dsm_semantics_info_ptr     000320 automatic       pointer                  dcl 3-12 set ref 148* 159* 160 161 162 163 164 165
                                                                                  166 167 276* 277 1049 1049 1076 1076
mrds_dsm_terminals              000013 constant        structure                level 1 unaligned dcl 8-2
n                               000154 automatic       fixed bin(24,0)          dcl 69 set ref 359* 360 360 362 363 366
next_state                      000155 automatic       fixed bin(24,0)          dcl 70 in procedure "mrds_dsm_parse" set ref 372*
                                                                                  386* 397* 452 466
next_state                             parameter       fixed bin(24,0)          dcl 1016 in procedure "next_term" set ref 868 874
                                                                                  885 892* 892 893 918* 976* 978 982* 1004* 1009*
next_symbol                     000367 automatic       fixed bin(24,0)          dcl 850 set ref 749* 815* 825* 921 939 940
nil                             000157 automatic       fixed bin(24,0)          dcl 72 set ref 347* 366* 380* 390 397
nil_flag                        000160 automatic       bit(1)                   unaligned dcl 73 set ref 184* 390 447* 625*
nil_sym                         000156 automatic       fixed bin(24,0)          dcl 71 set ref 183* 366 380 400 586* 619 745* 747*
                                                                                  759
null                                                   builtin function         dcl 90 ref 139 139 146 147 148 149 150 1045 1047
                                                                                  1049 1064 1072 1074 1076 1078
p6                              000100 automatic       picture(6)               unaligned dcl 1038 set ref 1032* 1033
p_code                                 parameter       fixed bin(35,0)          dcl 44 in procedure "mrds_dsm_parse" set ref 9 152*
                                                                                  212* 213 227* 228 252* 253 282*
p_code                                 parameter       fixed bin(35,0)          dcl 567 in procedure "skip_recovered" set ref 487
                                                                                  574* 591*
p_code                                 parameter       fixed bin(35,0)          dcl 445 in procedure "got_symbol" set ref 443 446*
                                                                                  475*
p_code                                 parameter       fixed bin(35,0)          dcl 332 in procedure "read_look" set ref 329 334*
                                                                                  373* 374 387* 401* 406* 408* 409 412 414* 416 424*
                                                                                  428* 430 438*
p_code                                 parameter       fixed bin(35,0)          dcl 870 in procedure "next_term" set ref 868 872*
                                                                                  899* 992*
p_code                                 parameter       fixed bin(35,0)          dcl 851 in procedure "local_recovered" set ref 671
                                                                                  723* 735* 739 767* 768
p_internal_error_code                  parameter       fixed bin(35,0)          dcl 1056 ref 1053 1061 1064
p_message                              parameter       char                     unaligned dcl 1057 set ref 1053 1061* 1064*
p_mrds_dsm_parse_info_ptr              parameter       pointer                  dcl 43 ref 9 137
p_severity                             parameter       fixed bin(35,0)          dcl 1055 set ref 1053 1059 1061* 1064*
p_struct                               based           structure                array level 1 dcl 1-27 set ref 156 1072
p_struct_ptr                    000312 automatic       pointer                  dcl 1-32 set ref 146* 156* 243 245 245 250 293 298
                                                                                  301 301 305 317 607 883 883 896 898 898 903 958
                                                                                  958 989 991 991 995 1002 1072 1072
parse_stack                            based           fixed bin(24,0)          array level 2 dcl 1-27 set ref 243 245 245 250* 293*
                                                                                  298 301 301 305* 317 607 883 896 898 898 903* 958*
                                                                                  989 991 991 995* 1002
parse_stack2              1            based           fixed bin(24,0)          array level 2 dcl 1-27 set ref 883* 958
ps_top                          000161 automatic       fixed bin(24,0)          dcl 74 set ref 185* 243 249* 249 250 251 292 292 298
                                                                                  305 307* 307 310 317 604 609* 767 882 957
recov_msg                       000162 automatic       varying char(150)        dcl 75 set ref 414 428 579* 580* 580 581* 581 583*
                                                                                  583 584* 584 613* 613 614* 614 616* 616 635* 635
                                                                                  773* 786* 786 788* 788 789* 789 792* 792 794* 794
                                                                                  795* 795 796* 796 810* 810 813* 813 814* 814 815*
                                                                                  815 822* 822 824* 824 825* 825 826* 826 833* 833
                                                                                  834*
rep                             000411 automatic       fixed bin(24,0)          dcl 1018 set ref 920* 922* 922 926* 932
rulen                           000231 automatic       fixed bin(24,0)          dcl 76 set ref 265* 271* 274 276*
s                               000412 automatic       fixed bin(24,0)          dcl 1019 set ref 921* 924 924 926* 963* 965* 967 968
sign                                                   builtin function         dcl 90 ref 761
skip_v1                         000304 constant        fixed bin(24,0)          initial array dcl 7-7 ref 575 586 601 607 745 745
skip_v2                         000302 constant        fixed bin(24,0)          initial array dcl 7-10 ref 599 603 605 611
source_length            14            based           fixed bin(35,0)          level 2 in structure "mrds_dsm_parse_info" dcl 2-19
                                                                                  in procedure "mrds_dsm_parse" ref 173
source_length             6            based           fixed bin(35,0)          level 2 in structure "mrds_dsm_scanner_info"
                                                                                  dcl 4-14 in procedure "mrds_dsm_parse" set ref
                                                                                  173*
source_ptr               12            based           pointer                  level 2 in structure "mrds_dsm_parse_info" dcl 2-19
                                                                                  in procedure "mrds_dsm_parse" ref 172
source_ptr                4            based           pointer                  level 2 in structure "mrds_dsm_scanner_info"
                                                                                  dcl 4-14 in procedure "mrds_dsm_parse" set ref
                                                                                  172*
state                     0(09) 000102 automatic       picture(4)               level 2 packed unaligned dcl 51 set ref 197*
string                                                 builtin function         dcl 750 in procedure "local_recovered" set ref 751*
                                                                                  764* 776
string                                                 builtin function         dcl 90 in procedure "mrds_dsm_parse" set ref 196*
                                                                                  271 271 464 464 659 666
sub_err_                        000014 constant        entry                    external dcl 121 ref 139
submodel_iocb_ptr         4            based           pointer                  level 2 in structure "mrds_dsm_parse_info" dcl 2-19
                                                                                  in procedure "mrds_dsm_parse" ref 163
submodel_iocb_ptr        12            based           pointer                  level 2 in structure "mrds_dsm_semantics_info"
                                                                                  dcl 3-17 in procedure "mrds_dsm_parse" set ref
                                                                                  163*
substr                                                 builtin function         dcl 90 ref 653 659 666
sws                             000202 automatic       structure                level 1 packed unaligned dcl 841 set ref 751* 776
symbol                    4            based           fixed bin(24,0)          array level 2 dcl 1-10 set ref 345 598 619* 749 807*
                                                                                  862* 862* 965
symlen                    2            based           fixed bin(24,0)          array level 2 dcl 1-10 set ref 617* 648 653 805*
symptr                                 based           pointer                  array level 2 dcl 1-10 set ref 653 804*
t                                      parameter       char                     unaligned dcl 1039 in procedure "too_many" ref 1030
                                                                                  1033
t                               000232 automatic       fixed bin(24,0)          dcl 77 in procedure "mrds_dsm_parse" set ref 292*
                                                                                  293*
temp                            000134 automatic       varying char(100)        dcl 644 set ref 647* 652* 652 653* 653 654* 654 655
                                                                                  657* 659* 660 664* 666* 667* 667
test_symbol                     000142 automatic       fixed bin(24,0)          dcl 60 set ref 345* 348 358 363 370 378 400* 421*
                                                                                  435* 456* 461* 580* 724 789* 796* 813* 822* 921
                                                                                  946 946
token_cnt                       000233 automatic       fixed bin(24,0)          dcl 78 set ref 188* 404 482* 482 732
token_num                17            based           fixed bin(24,0)          array level 2 dcl 1-10 set ref 801*
top                                    parameter       fixed bin(24,0)          dcl 1015 set ref 868 896 902* 902 903 989 995 997*
                                                                                  997 1000 1002
transit                         000204 automatic       fixed bin(24,0)          dcl 845 set ref 752* 774 786* 794* 807 888* 931*
                                                                                  950*
type                      1(27) 000102 automatic       char(6)                  level 2 packed unaligned dcl 51 set ref 223* 238*
                                                                                  269* 454* 455* 455
v1                        1     000036 external static fixed bin(17,0)          array level 3 packed unaligned dcl 6-4 set ref 199
                                                                                  265 290* 292 298 307 317 359 380 758 894 894 905
                                                                                  910 924 924 924 946 946 946 967 968 970 987 997
                                                                                  998 1002
v2                        1(18) 000036 external static fixed bin(17,0)          array level 3 packed unaligned dcl 6-4 set ref 201
                                                                                  220 235 260 266 290* 308 317 321 321 323 358 372
                                                                                  378 386 397 757 761 767 906 923 945 967 976 998
                                                                                  1000 1004 1009
version                                based           fixed bin(35,0)          level 2 in structure "mrds_dsm_semantics_info"
                                                                                  dcl 3-17 in procedure "mrds_dsm_parse" set ref
                                                                                  160*
version                                based           fixed bin(35,0)          level 2 in structure "mrds_dsm_scanner_info"
                                                                                  dcl 4-14 in procedure "mrds_dsm_parse" set ref
                                                                                  170*
version                                based           fixed bin(35,0)          level 2 in structure "mrds_dsm_parse_info" dcl 2-19
                                                                                  in procedure "mrds_dsm_parse" ref 139
work_area                              based           area                     dcl 86 ref 155 156 157 159 169 1045 1047 1049
work_area_ptr             2            based           pointer                  level 2 in structure "mrds_dsm_semantics_info"
                                                                                  dcl 3-17 in procedure "mrds_dsm_parse" set ref
                                                                                  162*
work_area_ptr             2            based           pointer                  level 2 in structure "mrds_dsm_scanner_info"
                                                                                  dcl 4-14 in procedure "mrds_dsm_parse" set ref
                                                                                  176*
work_area_ptr                   000236 automatic       pointer                  dcl 80 in procedure "mrds_dsm_parse" set ref 153*
                                                                                  155 156 157 159 169 1045 1047 1049
work_area_ptr             2            based           pointer                  level 2 in structure "mrds_dsm_parse_info" dcl 2-19
                                                                                  in procedure "mrds_dsm_parse" ref 153 162 176
x                                      parameter       fixed bin(24,0)          dcl 1040 ref 1030 1032

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DPDAp                                  automatic       pointer                  dcl 6-8
DUPLICATE_ENTRY_ERROR                  internal static fixed bin(35,0)          initial dcl 5-28
DUPLICATE_RELATION_DEF_ERROR           internal static fixed bin(35,0)          initial dcl 5-25
ILLEGAL_CHAR_ERROR                     internal static fixed bin(35,0)          initial dcl 5-17
LISTING_IO_ERROR                       internal static fixed bin(35,0)          initial dcl 5-16
NO_COMMENT_END_DELIMITER_ERROR         internal static fixed bin(35,0)          initial dcl 5-19
OVERLENGTH_TOKEN_ERROR                 internal static fixed bin(35,0)          initial dcl 5-18
UNRECOGNIZED_CHARACTER_ERROR           internal static fixed bin(35,0)          initial dcl 5-21
UNRECOGNIZED_TOKEN_ERROR               internal static fixed bin(35,0)          initial dcl 5-23
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 135

NAMES DECLARED BY EXPLICIT CONTEXT.
CASE                            000000 constant        label                    array(0:10) dcl 201 in procedure "mrds_dsm_parse"
                                                                                  ref 199
CASE                            000266 constant        label                    array(0:10) dcl 906 in procedure "next_term" ref 905
NEXT                            007441 constant        label                    dcl 885 in procedure "next_term" ref 980 1005 1010
NEXT                            003575 constant        label                    dcl 324 in procedure "mrds_dsm_parse" ref 218 233
                                                                                  258
case                            000256 constant        label                    array(0:7) dcl 778 set ref 776
done                            007117 constant        label                    dcl 830 in procedure "local_recovered" ref 808 820
done                            010025 constant        label                    dcl 955 in procedure "next_term" ref 890 973
dump_la                         007272 constant        entry                    internal dcl 854 ref 755 837
finish                          010667 constant        entry                    internal dcl 1070 ref 138
finish_mdp                      010505 constant        entry                    internal dcl 1043 ref 208 215 230 246 255 283 302
                                                                                  313
found                           010122 constant        label                    dcl 976 ref 968
get_rest                        005605 constant        label                    dcl 648 ref 668
geterm                          005602 constant        entry                    internal dcl 640 ref 456 580 613 761 786 789 794 796
                                                                                  813 815 822 825 862
getermc                         005717 constant        entry                    internal dcl 661 ref 421 435 461
got_symbol                      004620 constant        entry                    internal dcl 443 ref 373 387 401
local_recovered                 005755 constant        entry                    internal dcl 671 ref 406
mrds_dsm_parse                  002443 constant        entry                    external dcl 9
next_term                       007372 constant        entry                    internal dcl 868 ref 767
read_look                       003600 constant        entry                    internal dcl 329 ref 212 227 252 408
report_mdp_error                010532 constant        entry                    internal dcl 1053 ref 312 414 423 428 437 729 836
                                                                                  1034
set_symbol                      006623 constant        label                    dcl 801 ref 790
skip_recovered                  005022 constant        entry                    internal dcl 487 ref 414 428
too_many                        010334 constant        entry                    internal dcl 1030 ref 207 245 301 474 898 991
try_again                       006367 constant        label                    dcl 771 ref 759

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11174       11234   10776       11204
Length     11674   10776        40         423     175           4

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_dsm_parse                      297 external procedure  is an external procedure.  
on unit on line 138                  70 on unit               
read_look                           672 internal procedure  calls itself recursively.  
got_symbol                              internal procedure  shares stack frame of internal procedure read_look.  
skip_recovered                          internal procedure  shares stack frame of internal procedure read_look.  
geterm                                  internal procedure  shares stack frame of internal procedure read_look.  
local_recovered                         internal procedure  shares stack frame of internal procedure read_look.  
dump_la                                 internal procedure  shares stack frame of internal procedure read_look.  
next_term                               internal procedure  shares stack frame of internal procedure read_look.  
too_many                             92 internal procedure  is called by several nonquick procedures.  
finish_mdp                              internal procedure  shares stack frame of external procedure mrds_dsm_parse.  
report_mdp_error                     94 internal procedure  is called during a stack extension.  
finish                                  internal procedure  shares stack frame of on unit on line 138.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 default_symbol              local_recovered

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_dsm_parse           000100 code                        mrds_dsm_parse
                         000101 debug_sw                    mrds_dsm_parse
                         000102 db_data                     mrds_dsm_parse
                         000137 ls_top                      mrds_dsm_parse
                         000140 altn                        mrds_dsm_parse
                         000141 current_state               mrds_dsm_parse
                         000142 test_symbol                 mrds_dsm_parse
                         000143 current_table               mrds_dsm_parse
                         000144 i                           mrds_dsm_parse
                         000145 la_ct                       mrds_dsm_parse
                         000146 la_get                      mrds_dsm_parse
                         000147 la_need                     mrds_dsm_parse
                         000150 la_put                      mrds_dsm_parse
                         000151 an                          mrds_dsm_parse
                         000152 la_use                      mrds_dsm_parse
                         000153 m                           mrds_dsm_parse
                         000154 n                           mrds_dsm_parse
                         000155 next_state                  mrds_dsm_parse
                         000156 nil_sym                     mrds_dsm_parse
                         000157 nil                         mrds_dsm_parse
                         000160 nil_flag                    mrds_dsm_parse
                         000161 ps_top                      mrds_dsm_parse
                         000162 recov_msg                   mrds_dsm_parse
                         000231 rulen                       mrds_dsm_parse
                         000232 t                           mrds_dsm_parse
                         000233 token_cnt                   mrds_dsm_parse
                         000234 error_mark                  mrds_dsm_parse
                         000236 work_area_ptr               mrds_dsm_parse
                         000240 message                     mrds_dsm_parse
                         000301 message_length              mrds_dsm_parse
                         000310 lex_stack_ptr               mrds_dsm_parse
                         000312 p_struct_ptr                mrds_dsm_parse
                         000314 cur_lex_top_ptr             mrds_dsm_parse
                         000316 mrds_dsm_parse_info_ptr     mrds_dsm_parse
                         000320 mrds_dsm_semantics_info_ptr mrds_dsm_parse
                         000322 mrds_dsm_scanner_info_ptr   mrds_dsm_parse
read_look                000116 i                           skip_recovered
                         000117 ii                          skip_recovered
                         000120 j                           skip_recovered
                         000121 jj                          skip_recovered
                         000122 c                           skip_recovered
                         000123 dec4                        skip_recovered
                         000134 temp                        geterm
                         000202 sws                         local_recovered
                         000203 combinations                local_recovered
                         000204 transit                     local_recovered
                         000205 la_next                     local_recovered
                         000206 alt_symbol                  local_recovered
                         000207 cycle                       local_recovered
                         000367 next_symbol                 local_recovered
                         000370 depth                       local_recovered
                         000400 ii                          dump_la
                         000410 cur_st                      next_term
                         000411 rep                         next_term
                         000412 s                           next_term
                         000413 look_ahead                  next_term
                         000414 i                           next_term
                         000415 la_get2                     next_term
                         000416 la_use2                     next_term
                         000417 marked                      next_term
too_many                 000100 p6                          too_many

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_l_a               alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this_desc
call_int_this       call_int_other_desc call_int_other      return              sign                mod_fx1
signal              enable              shorten_stack       ext_entry           int_entry           int_entry_desc
repeat              set_cs_eis          alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_$ioa_switch               ioa_$ioa_switch_nnl           ioa_$rs                       mrds_dsm_scanner
mrds_dsm_scanner$init         mrds_dsm_semantics            sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$unimplemented_version                          iox_$user_output              mrds_dsm_parse_table$DPDA




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      9 002437       137 002450       138 002454       139 002472       146 002542       147 002544       148 002545
    149 002546       150 002547       152 002550       153 002552       155 002555       156 002562       157 002567
    159 002574       160 002601       161 002603       162 002611       163 002613       164 002615       165 002617
    166 002621       167 002623       169 002624       170 002631       171 002633       172 002641       173 002643
    174 002645       175 002647       176 002651       177 002653       179 002654       181 002665       182 002667
    183 002673       184 002675       185 002676       186 002700       187 002703       188 002704       189 002705
    193 002707       195 002712       196 002713       197 002716       199 002725       201 002730       203 002734
    205 002745       207 002751       208 002774       209 002775       211 002776       212 002777       213 003006
    215 003011       216 003012       218 003013       220 003014       223 003020       225 003023       226 003025
    227 003027       228 003036       230 003041       231 003042       233 003043       235 003044       238 003050
    240 003053       241 003055       242 003057       243 003061       245 003064       246 003104       247 003105
    249 003106       250 003107       251 003115       252 003121       253 003130       255 003133       256 003134
    258 003135       260 003136       262 003143       265 003145       266 003152       267 003160       269 003162
    270 003165       271 003170       274 003224       276 003232       277 003253       280 003262       282 003264
    283 003266       284 003267       288 003270       290 003272       292 003330       293 003347       294 003374
    295 003377       298 003416       301 003431       302 003451       303 003452       305 003453       307 003457
    308 003461       310 003471       312 003473       313 003517       314 003520       317 003521       319 003547
    321 003551       323 003570       324 003575       327 003576       329 003577       334 003605       336 003607
    337 003614       338 003635       341 003645       342 003654       343 003655       345 003656       346 003663
    347 003664       348 003665       358 003667       359 003711       360 003716       362 003722       363 003723
    366 003732       368 003736       370 003740       372 003743       373 003752       374 003761       376 003764
    378 003765       380 004004       382 004016       384 004020       386 004022       387 004027       388 004036
    390 004037       397 004043       398 004050       399 004060       400 004061       401 004063       402 004072
    404 004073       406 004076       408 004112       409 004122       411 004125       412 004126       414 004131
    416 004200       419 004204       421 004232       423 004324       424 004357       426 004363       428 004364
    430 004434       433 004440       435 004466       437 004560       438 004613       441 004617       443 004620
    446 004622       447 004623       450 004625       452 004627       454 004631       455 004634       456 004643
    458 004663       459 004665       461 004666       464 004705       466 004733       467 004736       469 004737
    470 004741       472 004742       474 004745       475 004766       476 004771       478 004772       479 004773
    480 005007       481 005016       482 005020       485 005021       487 005022       574 005024       575 005025
    577 005034       578 005036       579 005040       580 005045       581 005072       582 005104       583 005117
    584 005144       586 005156       587 005160       588 005162       589 005164       591 005170       592 005212
    595 005222       596 005231       598 005233       599 005240       601 005251       603 005254       604 005257
    605 005265       607 005277       609 005310       610 005313       611 005317       613 005321       614 005337
    615 005351       616 005364       617 005453       619 005457       620 005464       624 005473       625 005475
    626 005477       628 005505       629 005507       631 005512       632 005514       633 005524       634 005526
    635 005527       636 005572       637 005574       640 005602       647 005604       648 005605       652 005617
    653 005626       654 005647       655 005656       657 005665       659 005675       660 005710       661 005717
    664 005721       666 005732       667 005745       668 005754       671 005755       723 005757       724 005760
    726 005763       729 006032       730 006065       732 006074       733 006077       735 006105       736 006127
    739 006137       742 006147       743 006156       744 006157       745 006160       747 006165       748 006167
    749 006176       751 006203       752 006205       753 006207       754 006210       755 006211       757 006214
    758 006237       759 006247       761 006251       764 006325       765 006330       767 006333       768 006357
    771 006367       773 006372       774 006373       776 006404       778 006407       781 006415       786 006420
    788 006436       789 006450       790 006475       792 006476       794 006510       795 006526       796 006540
    797 006565       798 006566       799 006602       800 006614       801 006623       803 006627       804 006631
    805 006636       806 006642       807 006656       808 006660       810 006661       813 006673       814 006720
    815 006732       816 006747       817 006751       819 006761       820 006775       822 006776       824 007023
    825 007035       826 007052       827 007064       828 007100       829 007112       830 007117       833 007123
    834 007161       836 007224       837 007257       839 007264       854 007272       858 007273       860 007276
    861 007300       862 007304       864 007361       865 007370       867 007371       868 007372       872 007374
    874 007375       875 007400       877 007401       878 007404       879 007406       880 007407       881 007420
    882 007422       883 007431       884 007437       885 007441       888 007444       889 007445       890 007447
    892 007450       893 007454       894 007455       896 007464       898 007467       899 007510       900 007513
    902 007514       903 007515       905 007524       906 007526       910 007533       915 007550       916 007552
    918 007554       920 007606       921 007607       922 007614       923 007615       924 007636       926 007652
    928 007710       930 007712       931 007714       932 007716       934 007726       935 007732       936 007733
    938 007735       939 007737       940 007747       942 007752       944 007754       945 007756       946 007773
    949 010014       950 010016       951 010020       952 010022       953 010023       955 010025       957 010027
    958 010037       959 010045       960 010047       963 010050       965 010056       966 010063       967 010064
    968 010110       970 010111       972 010115       973 010117       976 010122       978 010131       980 010141
    982 010142       987 010174       989 010204       991 010210       992 010231       993 010234       995 010235
    997 010242       998 010245      1000 010257      1002 010275      1004 010311      1005 010315      1007 010316
   1008 010321      1009 010322      1010 010332      1030 010333      1032 010347      1033 010361      1034 010447
   1035 010503      1043 010505      1045 010506      1047 010514      1049 010522      1051 010530      1053 010531
   1059 010545      1061 010555      1064 010615      1068 010666      1070 010667      1072 010670      1074 010677
   1076 010706      1078 010715      1080 010724


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
