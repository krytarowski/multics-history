	COMPILATION LISTING OF SEGMENT mu_open_name_manager
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/18/85  1046.7 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 /* HISTORY:
       19*
       20*   Originally written by Jim Gray - - February 1981
       21*
       22**/
       23 
       24 mu_open_name_manager: procedure (); return;		/* not a legal entry */
       25 
       26 /* DESCRIPTION:
       27*
       28*   This routine provides the ability to refer the an opening
       29*   of a database (via dsl_), a model (via mmi_), or a submodel (via msmi_),
       30*   with a user defined name of arbitrary length, and to have
       31*   an arbitrary number of openings of any kind at the same time.
       32*   The result of a "name to opening correspondence" is a pointer
       33*   to the particular structure involved
       34*   (i.e. a pointer to either the resultant, db, or sub - model)
       35*   The current search method used is a binary threaded tree of names.
       36*   The internal procedures for it were copied from the
       37*   mrds_rst_tree_... routines.
       38*
       39*   There are  6 entries:
       40*   define_open_name, get_model_pointer, display_open_names,
       41*   delete_open_name, delete_all_open_names, list_all_open_names
       42*
       43*   The last returns a structure, rather than calling ioa_, like the display entry.
       44*
       45*   The delete_all_open_names entry should be used with caution,
       46*   since, not only the callers (say a model manager),
       47*   but all opening names will be deleted as well.
       48**/
       49 
       50 /* PARAMETERS:
       51*
       52*   ===== define_open_name entry
       53*
       54*   user_name - - (input) char(*), the name the user desires to give this opening,
       55*   it will be accepted as a valid name if not already in the list of open names
       56*
       57*   open_model_type - - (input) char(1), "r" => resultant model, "m" => db model,
       58*   "s" => submodel, is the type of opening being defined
       59*
       60*   model_pointer - - (input) pointer, a pointer to the resultant/db/sub model,
       61*   depending on the open_model_type, that is to be associated with this name.
       62*
       63*   ===== get_model_pointer entry
       64*
       65*   user_name - - (input) char(*), the name for which the opened model
       66*   pointer is to be retrieved.
       67*
       68*   open_model_type - - (output), char(1), same as for define_open_name entry
       69*
       70*   model_pointer - - (output), pointer, same as for define_open_name entry
       71*
       72*   ===== display_open_names entry
       73*
       74*   no inputs - - displays the (ordered by name) current set of open names,
       75*   the open type, and in debug mode, the model pointer.
       76*
       77*   ===== delete_open_name entry
       78*
       79*   user_name - - (input) char(*), removes all information associated with this
       80*   name from the list of open names
       81*
       82*   ===== delete_all_open_names entry
       83*
       84*   only error code parameter(see below), deletes all currently defined names,
       85*   the error code will be 0 if no names are defined.
       86*
       87*   ===== list_all_open_names entry
       88*
       89*   user_area_ptr - - (input) a pointer to an area in which to allocate a list
       90*   of pointers to the names in the list
       91*
       92*   open_name_list_ptr - - (output) a pointer to a singly linked list of open
       93*   names, where each element may be overlayed with the mrds_open_name_element.incl.pl1
       94*   This pointer will be null of there are no open names defined.
       95*
       96*   open_name_list_size - - (output) fixed bin (24), the number of elements
       97*   in the open name list.
       98*
       99*
      100*   *******************************************************
      101*   ***** common to all entries, but display_open_names
      102*
      103*   error_code - - (output) fixed bin (35), error status encoding, 0 unless an error occurred
      104*
      105**/
      106 
      107 /* entry to allow defing of a new opening name */
      108 
      109 define_open_name: entry (user_name, open_model_type, model_pointer, error_code);
      110 
      111 	on area begin;				/* capture name space overflow */
      112 		error_code = mdbm_error_$too_many_open_names;
      113 		goto skip_allocate;
      114 	     end;
      115 
      116 	error_code = 0;
      117 
      118 	call tree_insert (user_name, root_of_tree_ptr, node_ptr, success);
      119 
      120 	if success then
      121 	     current_number_of_names = current_number_of_names + 1;
      122 	else error_code = mdbm_error_$open_name_already_known;
      123 
      124 skip_allocate:
      125 
      126 	return;
      127 
      128 /* entry to remove an opening name from further use */
      129 
      130 delete_open_name: entry (user_name, error_code);
      131 
      132 	error_code = 0;
      133 
      134 
      135 	call tree_delete (user_name, root_of_tree_ptr, success);
      136 
      137 	if success then do;
      138 		current_number_of_names = current_number_of_names - 1;
      139 		if current_number_of_names = 0 then
      140 		     call clean_up ();
      141 	     end;
      142 
      143 	else error_code = mdbm_error_$open_name_not_known;
      144 
      145 	return;
      146 
      147 /* entry to get a pointer to the model (resultant, db or sub model)
      148*   given an opening name, also returned is the type of model */
      149 
      150 get_model_pointer: entry (user_name, open_model_type, model_pointer, error_code);
      151 
      152 	error_code = 0;
      153 	model_pointer = null ();
      154 	open_model_type = "";
      155 
      156 	call tree_search (user_name, root_of_tree_ptr, node_ptr, parent_ptr, success);
      157 
      158 	if success then do;
      159 		mrds_open_name_ptr = node_ptr;
      160 		model_pointer = mrds_open_name.mrds_info.model_pointer;
      161 		open_model_type = mrds_open_name.mrds_info.opening_type;
      162 	     end;
      163 
      164 	else error_code = mdbm_error_$open_name_not_known;
      165 
      166 	return;
      167 
      168 /* entry to display all currently known opening names */
      169 
      170 display_open_names: entry ();
      171 
      172 	node_ptr = root_of_tree_ptr;			/* convention to get first on list */
      173 
      174 	success = "1"b;
      175 
      176 	if current_number_of_names > 0 then
      177 	     call ioa_ ("^/Number of opening names:  ^d^/", current_number_of_names);
      178 
      179 	number_of_open_names = 0;
      180 
      181 /* go through the tree in order, till all names displayed */
      182 
      183 	do while (success);
      184 
      185 	     call tree_successor (root_of_tree_ptr, node_ptr, successor_ptr, successor_parent_ptr, success);
      186 
      187 	     if success then do;
      188 		     number_of_open_names = number_of_open_names + 1;
      189 		     mrds_open_name_ptr, node_ptr = successor_ptr; /* to get next in list */
      190 
      191 		     call ioa_ ("^/Opening name:  ^a", mrds_open_name.user_info.name);
      192 		     call ioa_ ("Opening type:  ^a", mrds_open_name.mrds_info.opening_type);
      193 
      194 		     if substr (db_mu_open_name_manager, 1, 1) then do; /* display debug output if switch on */
      195 
      196 			     put skip data (mrds_open_name_ptr);
      197 
      198 			     put skip data (mrds_open_name);
      199 
      200 			     put skip;
      201 
      202 			end;
      203 		end;
      204 
      205 	end;
      206 
      207 	if number_of_open_names = 0 then
      208 	     call ioa_ ("^/No opening names defined.^/");
      209 	else call ioa_ ("^/");
      210 
      211 	return;
      212 
      213 /* entry to delete all names from the lsit of open names */
      214 
      215 delete_all_open_names: entry (error_code);
      216 
      217 	error_code = 0;
      218 
      219 	success = "1"b;
      220 
      221 	do while (success);
      222 
      223 	     node_ptr = root_of_tree_ptr;		/* get first one on list each time */
      224 
      225 	     call tree_successor (root_of_tree_ptr, node_ptr, successor_ptr, successor_parent_ptr, success);
      226 
      227 	     if success then do;
      228 		     node_ptr = successor_ptr;
      229 
      230 		     call tree_delete ((node_ptr -> mrds_open_name.user_info.name), root_of_tree_ptr, success);
      231 
      232 		     if ^success then
      233 			error_code = mdbm_error_$open_name_not_known;
      234 
      235 		end;
      236 
      237 	end;
      238 
      239 	current_number_of_names = 0;
      240 
      241 	call clean_up ();
      242 
      243 	return;
      244 
      245 /* entry to return a linked list of currently defined open names */
      246 
      247 list_all_open_names: entry (user_area_ptr, structure_version, open_name_list_ptr, open_name_list_size, error_code);
      248 
      249 /* initizlize */
      250 
      251 	error_code = 0;
      252 	node_ptr = root_of_tree_ptr;
      253 	success = "1"b;
      254 	open_name_list_ptr = null ();
      255 	open_name_list_size = 0;
      256 	number_of_open_names = 0;
      257 
      258 	on area begin;
      259 		error_code = error_table_$area_too_small;
      260 		goto exit;
      261 	     end;
      262 
      263 	if user_area_ptr = null () then
      264 	     error_code = error_table_$badcall;
      265 	else if structure_version ^= mrds_open_name_element_structure_version then
      266 	     error_code = error_table_$unimplemented_version;
      267 
      268 	if error_code ^= 0 then ;
      269 	else do;
      270 
      271 /* go through the tree in reverse order, so that the list is in order */
      272 
      273 		do while (success);
      274 
      275 		     call tree_predecessor (root_of_tree_ptr, node_ptr, predecessor_ptr, predecessor_parent_ptr, success);
      276 
      277 		     if success then do;
      278 
      279 			     number_of_open_names = number_of_open_names + 1;
      280 
      281 			     mrds_open_name_ptr, node_ptr = predecessor_ptr;
      282 			     mrds_open_name_element_length_init = mrds_open_name.user_info.name_length;
      283 
      284 			     allocate mrds_open_name_element set (mrds_open_name_element_ptr) in (user_area_ptr -> work_area);
      285 
      286 			     unspec (mrds_open_name_element) = "0"b;
      287 
      288 /* fill in the details for this element in the list */
      289 
      290 			     mrds_open_name_element.version = mrds_open_name_element_structure_version;
      291 			     mrds_open_name_element.name_length = mrds_open_name_element_length_init;
      292 			     mrds_open_name_element.name = mrds_open_name.user_info.name;
      293 			     mrds_open_name_element.open_type = mrds_open_name.mrds_info.opening_type;
      294 			     mrds_open_name_element.model_pointer = mrds_open_name.mrds_info.model_pointer;
      295 
      296 /* insert the element into the linked list, at the head */
      297 
      298 			     mrds_open_name_element.next = open_name_list_ptr;
      299 			     open_name_list_ptr = mrds_open_name_element_ptr;
      300 
      301 			end;
      302 
      303 		end;
      304 
      305 	     end;
      306 
      307 	if error_code = 0 then
      308 	     open_name_list_size = number_of_open_names;
      309 
      310 exit:
      311 
      312 	return;
      313 
      314 tree_search: procedure (key, root_ptr, node_ptr, parent_ptr, success);
      315 
      316 
      317 /* HISTORY:
      318*
      319*   originally written by jim gray - - july 1978
      320*
      321**/
      322 
      323 /* DESCRIPTION:
      324*   Threaded binary tree search
      325*   Given a pointer to the desired list, do a binary search for the key.
      326*   Return either a not found indication,
      327*   or a found indication with a pointer to the key node,
      328*   and a pointer to it's parent */
      329 
      330 /* PARAMETERS:
      331*
      332*   key - - (input) word to be searched for as key to tree node
      333*
      334*   root_ptr - - (input) pointer to root node of desired tree
      335*
      336*   node_ptr - - (output) pointer to node containing key when found,
      337*   else root pointer pointer
      338*
      339*   parent_ptr - - (output) pointer to direct tree parent when key node found,
      340*   else pointer to prospective parent for insertion of key
      341*
      342*   success - - (output) bit value indicating key was found in tree(on),
      343*   or that place for it's  insertion was found(off)
      344*
      345**/
      346 
      347 
      348 /* Initialize search loop
      349*   note: parent_ptr is root_ptr when no dummy head exists,
      350*   or when the dummy head node left link is a thread
      351*   thus indicating a empty tree */
      352 
      353 	parent_ptr = root_ptr;
      354 	success = "0"b;
      355 
      356 /* if dummy node at head of tree missing,
      357*   we fail since tree was never built */
      358 
      359 	if root_ptr = null () then ;
      360 	else do;
      361 		node_ptr = root_ptr -> mrds_open_name.left.link;
      362 		thread = root_ptr -> mrds_open_name.left.thread;
      363 
      364 
      365 /* Search the tree while the data key is not found,
      366*   and branches remain to be searched .
      367*   failure to make even one loop pass means the tree is empty,
      368*   because the dummy head node left link is a thread to itself */
      369 
      370 		do while (^thread & ^success);
      371 
      372 /* Branch left for smaller or right for larger keys.
      373*   If key matches, note success and remember pointers. */
      374 
      375 		     if key > node_ptr -> mrds_open_name.user_info.name then do;
      376 			     thread = node_ptr -> mrds_open_name.right.thread;
      377 			     parent_ptr = node_ptr;
      378 			     node_ptr = node_ptr -> mrds_open_name.right.link;
      379 			end;
      380 
      381 		     else if key < node_ptr -> mrds_open_name.user_info.name then do;
      382 			     thread = node_ptr -> mrds_open_name.left.thread;
      383 			     parent_ptr = node_ptr;
      384 			     node_ptr = node_ptr -> mrds_open_name.left.link;
      385 			end;
      386 
      387 		     else success = "1"b;
      388 
      389 		end;
      390 
      391 	     end;
      392 
      393 	declare key		 char (*);	/* key to be searched for */
      394 	declare root_ptr		 ptr;		/* pointer to root of tree */
      395 	declare node_ptr		 ptr;		/* output ptr to found node */
      396 	declare parent_ptr		 ptr;		/* prospective parent node for insertion */
      397 	declare success		 bit (1);		/* on => key found, else place for insertion found */
      398 	declare thread		 bit (1);		/* on => link is a thread not pointer */
      399 
      400 
      401 
      402      end;
      403 
      404 tree_successor: procedure (root_ptr, node_ptr, successor_ptr, successor_parent_ptr, success);
      405 
      406 
      407 /* HISTORY:
      408*
      409*   originally written by jim gray - - july 1978
      410*
      411**/
      412 
      413 /* DESCRIPTION:
      414*   threaded binary tree inorder successor retrieval routine
      415*   given a pointer to the current node in the tree
      416*   ( set node_ptr = root_ptr to get first tree element )
      417*   and a pointer to the root of the tree
      418*   a pointer to it's inorder successor and that nodes parent
      419*   are returned with a success indication, or
      420*   when end of tree(no more successors) or empty tree is detected,
      421*   a failure indication is returned */
      422 
      423 /* PARAMETERS:
      424*
      425*   root_ptr - - (input) pointer to root of desired tree
      426*
      427*   node_ptr - - (input) pointer to current for which the successor is desired
      428*
      429*   successor_ptr - - (output) pointer to resulting inorder successor of current node
      430*
      431*   successor_parent_ptr - - (output) pointer to successor node direct tree parent
      432*
      433*   success - - (output) bit value that is on when successor found,
      434*   and off when end of tree or empty tree is detected
      435*
      436**/
      437 
      438 
      439 
      440 /* no current node means no successor */
      441 
      442 	if node_ptr = null () then
      443 	     success = "0"b;
      444 
      445 	else do;
      446 
      447 /* current node exists, if it's right link is a thread
      448*   it is either a pointer to the root meaning no more successors
      449*   or it points to the current node's inorder successor */
      450 
      451 		successor_parent_ptr = node_ptr;
      452 		successor_ptr = node_ptr -> mrds_open_name.right.link;
      453 
      454 		if node_ptr -> mrds_open_name.right.thread then
      455 
      456 		     if successor_ptr = root_ptr then
      457 			success = "0"b;
      458 		     else success = "1"b;
      459 
      460 		else do;
      461 
      462 /* current node's right link is not a thread,
      463*   go left from current node's right descendent until
      464*   a left thread is found and return it's owner
      465*   as the inorder successor */
      466 
      467 			do while (^successor_ptr -> mrds_open_name.left.thread);
      468 
      469 			     successor_parent_ptr = successor_ptr;
      470 			     successor_ptr = successor_ptr -> mrds_open_name.left.link;
      471 
      472 			end;
      473 
      474 /* if pointer is still to root, the dummy head node
      475*   left link was a thread indicating an empty tree */
      476 
      477 			if successor_ptr = root_ptr then
      478 			     success = "0"b;
      479 			else success = "1"b;
      480 
      481 		     end;
      482 
      483 
      484 	     end;
      485 
      486 
      487 	declare root_ptr		 ptr;		/* points to root of tree */
      488 	declare node_ptr		 ptr;		/* points to node for which successor desired */
      489 	declare successor_ptr	 ptr;		/* pointer to resulting inoder successor */
      490 	declare successor_parent_ptr	 ptr;		/* successor node direct parent ptr */
      491 	declare success		 bit (1);		/* on => successor found */
      492 
      493 
      494 
      495 
      496      end;
      497 
      498 tree_delete: procedure (key, root_ptr, success);
      499 
      500 /* HISTORY:
      501*
      502*   originally written by jim gray - - july 1978
      503*
      504**/
      505 
      506 /* DESCRIPTION:
      507*   threaded binary tree deletion routine
      508*   A search is made for the key in the tree
      509*   specified by the root pointer.
      510*   If the key is not found,
      511*   the deletion fails.
      512*   Otherwise the tree node area is unlinked
      513*   from the tree, and the space freed */
      514 
      515 /* PARAMETERS:
      516*
      517*   key - - (input) word in tree indicating node to be deleted
      518*
      519*   root_ptr - - (input/output) pointer to root node of desired tree,
      520*   may be changed if key is at root node
      521*
      522*   success - - (output) bit value indicating deletion done(on),
      523*   or attempt to delete node not in tree(off)     */
      524 
      525 /* basic algorithm
      526*
      527*   simple case - delete node has no right subtree
      528*   make delete node's left subtree the new descendent of delete node's parent
      529*
      530*   complex case - delete node has a right subtree
      531*   subcase 1 - delete node's successor is direct descendent
      532*   replace delete node with successor, giving it the
      533*   delete node's left subtree
      534*   subcase 2 - delete node's successor is not a direct descendent
      535*   same as subcase 1 but additionally
      536*   successor's parent get's successors right subtree as it's left subtree
      537*   and successor's right subtree becomes that of the delete node's */
      538 
      539 
      540 /* get pointer to node to be deleted and to it's parent */
      541 
      542 	call tree_search (key, root_ptr, node_ptr, parent_ptr, success);
      543 
      544 /* if node to be deleted is not found, deletion fails */
      545 
      546 	if ^success then ;
      547 
      548 	else do;
      549 
      550 /* node found, save data pointer, and rearrange tree links to eliminate the node */
      551 
      552 		thread = "0"b;
      553 
      554 /* fix predecessor thread
      555*
      556*   since we are replacing the delete node with it's successor(if it has one),
      557*   the delete node's predecessor must have its's right thread
      558*   point to this new node(the delete node's successor) */
      559 
      560 		if node_ptr -> mrds_open_name.right.thread then ;
      561 		else call tree_successor (root_ptr, node_ptr, successor_ptr, successor_parent_ptr, success);
      562 		if node_ptr -> mrds_open_name.left.thread then ;
      563 		else do;
      564 			call tree_predecessor (root_ptr, node_ptr, predecessor_ptr, predecessor_parent_ptr, success);
      565 			if node_ptr -> mrds_open_name.right.thread then
      566 			     predecessor_ptr -> mrds_open_name.right.link = node_ptr -> mrds_open_name.right.link;
      567 			else do;
      568 				predecessor_ptr -> mrds_open_name.right.link = successor_ptr;
      569 			     end;
      570 		     end;
      571 
      572 /* if simple case of no inorder successor(right link a thread)
      573*   then use the left subtree of delete node as his parent's new descendent,
      574*   when the left link of the delete node is not a thread,
      575*   else a left thread means that the parent link will become a thread.
      576*   the left thread of the delete node may be used as this thread unless it points
      577*   to the parent, in which case the right thread must be used. */
      578 
      579 		if node_ptr -> mrds_open_name.right.thread then
      580 		     if ^node_ptr -> mrds_open_name.left.thread then
      581 			successor_ptr = node_ptr -> mrds_open_name.left.link;
      582 		     else do;
      583 			     thread = "1"b;
      584 			     if parent_ptr ^= node_ptr -> mrds_open_name.left.link then
      585 				successor_ptr = node_ptr -> mrds_open_name.left.link;
      586 			     else successor_ptr = node_ptr -> mrds_open_name.right.link;
      587 			end;
      588 
      589 		else do;
      590 
      591 /* complex case - delete node has a successor
      592*   give the successor node a new left subtree(previously a thread)
      593*   that is the current delete node's left subtree
      594*   this is the first step in moving the successor node
      595*   into the delete node's place in the tree */
      596 
      597 			successor_ptr -> mrds_open_name.left.link = node_ptr -> mrds_open_name.left.link;
      598 			successor_ptr -> mrds_open_name.left.thread = node_ptr -> mrds_open_name.left.thread;
      599 
      600 /* for direct descendent successor, ignore right subtrees */
      601 
      602 			if node_ptr = successor_parent_ptr then ;
      603 			else do;
      604 
      605 /* for successor not a direct descendent, the successor's new right subtree
      606*   will be that of the delete node's.   The successor's old right subtree becomes
      607*   the left subtree of the successor's old parent */
      608 
      609 /* fix successor's parent's threads for case of delete node's right link not a thread,
      610*   and successor is not direct descendent of delete node,
      611*
      612*   successor node's right link a thread means that the successor node's
      613*   parent's left link must become a thread to the successor node since the successor node
      614*   is being made the predecessor of the successor node's parent.
      615*   also the successor's right thread must be changed to pointer
      616*   since it will link to delete node's right subtree(known to be nonempty).
      617*
      618*   successor node's right link not a thread means that the successor's
      619*   parent node's left link will be a pointer set equal to the successor
      620*   node's right link. (the successor parent gets as his left, the successor's rught subtree) */
      621 
      622 				if successor_ptr -> mrds_open_name.right.thread then do;
      623 					successor_parent_ptr -> mrds_open_name.left.thread = "1"b;
      624 					successor_ptr -> mrds_open_name.right.thread = "0"b;
      625 				     end;
      626 				else successor_parent_ptr -> mrds_open_name.left.link =
      627 					successor_ptr -> mrds_open_name.right.link;
      628 				successor_ptr -> mrds_open_name.right.link = node_ptr -> mrds_open_name.right.link;
      629 
      630 			     end;
      631 
      632 		     end;
      633 
      634 /* for all cases, change parent of delete node to point to it's new successor.
      635*   determine which branch of delete node parent to change.
      636*   the link from the parent will be a thread only if
      637*   the delete node's links were both threads */
      638 
      639 		if node_ptr = parent_ptr -> mrds_open_name.left.link then do;
      640 			parent_ptr -> mrds_open_name.left.link = successor_ptr;
      641 			parent_ptr -> mrds_open_name.left.thread = thread;
      642 		     end;
      643 
      644 		else do;
      645 			parent_ptr -> mrds_open_name.right.link = successor_ptr;
      646 			parent_ptr -> mrds_open_name.right.thread = thread;
      647 		     end;
      648 
      649 
      650 /* release deleted nodes space */
      651 
      652 		call node_free (length (key), node_ptr);
      653 		success = "1"b;
      654 
      655 	     end;
      656 
      657 	declare key		 char (*);	/* name to be searched for, and deleted */
      658 	declare root_ptr		 ptr;		/* pointer to root of tree */
      659 	declare success		 bit (1);		/* on => deletion accomplished */
      660 	declare successor_ptr	 ptr;		/* points to successor node */
      661 	declare successor_parent_ptr	 ptr;		/* points to successor parent */
      662 	declare thread		 bit (1);		/* on => link is a thread not pointer */
      663 	declare predecessor_ptr	 ptr;		/* pointer to previous in order */
      664 	declare predecessor_parent_ptr ptr;		/* points to aprent of predecessor */
      665 	declare parent_ptr		 ptr;		/* points to node parent */
      666 	declare node_ptr		 ptr;		/* pointer to current element in tree */
      667 
      668 
      669 
      670 
      671 
      672      end;
      673 
      674 tree_insert: procedure (key, root_ptr, node_ptr, success);
      675 
      676 
      677 /* HISTORY:
      678*
      679*   originally written by jim gray - - july 1978
      680*
      681**/
      682 
      683 /* DESCRIPTION:
      684*   Threaded binary tree insertion routine
      685*   Given a pointer to the root of the desired list, a search is made
      686*   for the key.
      687*   If the key is found, the insertion fails to
      688*   avoid duplicating keys.
      689*   A successful insertion returns a pointer to
      690*   the new tree node */
      691 
      692 /* PARAMETERS:
      693*
      694*   key - - (input) word to be inserted as key in new node
      695*
      696*   root_ptr - - (input/output) pointer to root node of tree,
      697*   will be modified on empty tree insert
      698*
      699*   node_ptr - - (output) pointer to the node just inserted
      700*
      701*   success - - (output) bit value indicating good insertion(on)
      702*   or failure due to key duplication attempt(off)
      703*
      704**/
      705 
      706 
      707 /* get pointer to inorder parent in tree */
      708 
      709 	call tree_search (key, root_ptr, node_ptr, parent_ptr, success);
      710 
      711 /*  A search success(key was found) means a duplication
      712*   of keys is being attempted, return failure */
      713 
      714 	if success then success = "0"b;
      715 
      716 /* Normal insertion, get a new list element, and fill in the blanks */
      717 
      718 	else do;
      719 		success = "1"b;
      720 
      721 		call node_allocate (length (key), node_ptr);
      722 		node_ptr -> mrds_open_name.user_info.name = key;
      723 		node_ptr -> mrds_open_name.right.thread = "1"b;
      724 		node_ptr -> mrds_open_name.left.thread = "1"b;
      725 
      726 /* Add the new element to the tree.
      727*   Change the head pointer if empty tree */
      728 
      729 		if root_ptr ^= null () then ;
      730 		else do;
      731 
      732 /* no dummy node for tree head, get new node for it,
      733*   then make its right link a pointer to itself, and
      734*   make it's left link a thread to itself thus indicating
      735*   that the tree is empty */
      736 
      737 			call node_allocate (length (key), root_ptr);
      738 
      739 			root_ptr -> mrds_open_name.right.link = root_ptr;
      740 			root_ptr -> mrds_open_name.right.thread = "0"b;
      741 
      742 			root_ptr -> mrds_open_name.left.link = root_ptr;
      743 			root_ptr -> mrds_open_name.left.thread = "1"b;
      744 
      745 		     end;
      746 
      747 /* dummy head node for tree exists for all cases now, but tree may still
      748*   be empty(dummy node left link = thread), if so then force the
      749*   dummy node to be a right parent of the new data node
      750*   this is done by making the dummy node pointer serve as the
      751*   new node parent and setting the dummy node key equal to
      752*   the new node key so the test for descendent direction
      753*   will cause a left insert to take place */
      754 
      755 		if ^root_ptr -> mrds_open_name.left.thread then ;
      756 		else do;
      757 			parent_ptr = root_ptr;
      758 			root_ptr -> mrds_open_name.user_info.name = key;
      759 		     end;
      760 
      761 /* good parent within tree, determine if node is right
      762*   or left descendent.   right descendents have a left thread
      763*   to their direct parent, and a right thread
      764*   to their inorder successor. left descendents have a right
      765*   thread to their direct parent, and a left thread
      766*   to their inorder predecessor */
      767 
      768 		if key > parent_ptr -> mrds_open_name.user_info.name then do;
      769 
      770 			node_ptr -> mrds_open_name.right.link = parent_ptr -> mrds_open_name.right.link;
      771 			node_ptr -> mrds_open_name.left.link = parent_ptr;
      772 
      773 			parent_ptr -> mrds_open_name.right.link = node_ptr;
      774 			parent_ptr -> mrds_open_name.right.thread = "0"b;
      775 
      776 		     end;
      777 
      778 		else do;
      779 
      780 			node_ptr -> mrds_open_name.left.link = parent_ptr -> mrds_open_name.left.link;
      781 			node_ptr -> mrds_open_name.right.link = parent_ptr;
      782 
      783 			parent_ptr -> mrds_open_name.left.link = node_ptr;
      784 			parent_ptr -> mrds_open_name.left.thread = "0"b;
      785 
      786 		     end;
      787 
      788 
      789 	     end;
      790 
      791 	declare key		 char (*);	/* name to be inserted */
      792 	declare root_ptr		 ptr;		/* points to root of tree */
      793 	declare node_ptr		 ptr;		/* pointer to node created */
      794 	declare success		 bit (1);		/* on => good insertion operation */
      795 	declare parent_ptr		 ptr;		/* pointer to parent of new node */
      796 
      797 
      798      end;
      799 
      800 tree_predecessor: procedure (root_ptr, node_ptr, predecessor_ptr, predecessor_parent_ptr, success);
      801 
      802 
      803 /* HISTORY:
      804*
      805*   originally written by jim gray - - july 1978
      806*
      807**/
      808 
      809 /* DESCRIPTION:
      810*   threaded binary tree inorder predecessor retrieval routine
      811*   given a pointer to the current node in the tree
      812*   ( set node_ptr = root_ptr to get last tree element )
      813*   and a pointer to the root of the tree
      814*   a pointer to it's inorder predecessor and that nodes parent
      815*   are returned with a success indication, or
      816*   when end of tree(no more predecessors) or empty tree is detected,
      817*   a failure indication is returned */
      818 
      819 /* PARAMETERS:
      820*
      821*   root_ptr - - (input) pointer to root of desired tree
      822*
      823*   node_ptr - - (input) pointer to current for which the predecessor is desired
      824*
      825*   predecessor_ptr - - (output) pointer to resulting inorder predecessor of current node
      826*
      827*   predecessor_parent_ptr - - (output) pointer to predecessor node direct tree parent
      828*
      829*   success - - (output) bit value that is on when predecessor found,
      830*   and off when end of tree or empty tree is detected
      831*
      832**/
      833 
      834 
      835 
      836 /* no current node means no predecessor */
      837 
      838 	if node_ptr = null () then
      839 	     success = "0"b;
      840 
      841 	else do;
      842 
      843 /* current node exists, if it's left link is a thread
      844*   it is either a pointer to the root meaning no more predecessors
      845*   (or empty tree when node_ptr was root_ptr)
      846*   or it points to the current node's inorder predecessor */
      847 
      848 		predecessor_parent_ptr = node_ptr;
      849 		predecessor_ptr = node_ptr -> mrds_open_name.left.link;
      850 
      851 		if node_ptr -> mrds_open_name.left.thread then
      852 
      853 		     if predecessor_ptr = root_ptr then
      854 			success = "0"b;
      855 		     else success = "1"b;
      856 
      857 		else do;
      858 
      859 /* current node's left link is not a thread,
      860*   go left from current node's left descendent until
      861*   a right thread is found and return it's owner
      862*   as the inorder predecessor */
      863 
      864 			success = "1"b;
      865 
      866 			do while (^predecessor_ptr -> mrds_open_name.right.thread);
      867 
      868 			     predecessor_parent_ptr = predecessor_ptr;
      869 			     predecessor_ptr = predecessor_ptr -> mrds_open_name.right.link;
      870 
      871 			end;
      872 
      873 		     end;
      874 
      875 
      876 	     end;
      877 
      878 
      879 	declare root_ptr		 ptr;		/* points to root of tree */
      880 	declare node_ptr		 ptr;		/* points to node predecessor desired for */
      881 	declare predecessor_ptr	 ptr;		/* pointer to preious node */
      882 	declare predecessor_parent_ptr ptr;		/* parent of previous node ptr */
      883 	declare success		 bit (1);		/* on => predecessor found */
      884 
      885 
      886 
      887 
      888      end;
      889 
      890 node_allocate: procedure (key_length, node_ptr);
      891 
      892 /* DESCRIPTION:
      893*
      894*   routine to allocate the space needed for the opening name structure.
      895*   The space where the allocations occur is a temp segment
      896*   whose location is determined by set_mrd_temp_dir
      897*   (the value before the first allocation in this routine)
      898*
      899**/
      900 
      901 /* PARAMETERS:
      902*
      903*   key_length - - (input) fixed bin(24), the length of the varying length
      904*   name in the open name structure.
      905*
      906*   open_model_type - - (input) char(1), the type of opening
      907*   "r" => resultant model, "m" => db_model, "s" => submodel
      908*
      909*   model_pointer - - (input) pointer, a pointer to the model for this opening type
      910*
      911*   node_ptr - - (output) pointer, points to the newly allocated node
      912*
      913**/
      914 
      915 /* initialize */
      916 
      917 	if area_ptr = null () then
      918 	     call init_work_area ();
      919 
      920 	mrds_open_name_length_init = key_length;
      921 
      922 	allocate mrds_open_name set (mrds_open_name_ptr) in (work_area);
      923 
      924 	unspec (mrds_open_name) = "0"b;
      925 
      926 	mrds_open_name.version = mrds_open_name_structure_version;
      927 	mrds_open_name.user_info.name_length = key_length;
      928 	mrds_open_name.mrds_info.opening_type = open_model_type;
      929 	mrds_open_name.mrds_info.model_pointer = model_pointer;
      930 
      931 	node_ptr = mrds_open_name_ptr;
      932 
      933 
      934 
      935 	declare key_length		 fixed bin (24);	/* length of name */
      936 	declare node_ptr		 ptr;		/* points to allocated tree element */
      937 
      938      end;
      939 
      940 node_free: procedure (key_length, node_ptr);
      941 
      942 /* routine to free a tree node allocated in the work area */
      943 
      944 
      945 	mrds_open_name_length_init = key_length;
      946 
      947 	free node_ptr -> mrds_open_name in (work_area);
      948 
      949 
      950 	declare node_ptr		 ptr;		/* points to an allocated tree element */
      951 	declare key_length		 fixed bin (24);	/* length of users name */
      952 
      953      end;
      954 
      955 init_work_area: procedure ();
      956 
      957 /* routine to make a temp seg in the user process dir */
      958 
      959 	call get_temp_segment_ (program_name, area_ptr, error_code);
      960 	if error_code ^= 0 then
      961 	     goto skip_allocate;
      962 
      963 	area_ptr -> work_area = empty ();
      964 
      965      end;
      966 
      967 clean_up: procedure ();
      968 
      969 /* routine to get rid of temp segment, after last name deleted
      970*   it also re-initializes all critical internal static storage */
      971 
      972 	if area_ptr ^= null () then do;
      973 
      974 		call release_temp_segment_ (program_name, area_ptr, discard);
      975 
      976 		area_ptr = null ();
      977 
      978 		root_of_tree_ptr = null ();
      979 
      980 		current_number_of_names = 0;
      981 
      982 	     end;
      983 
      984 
      985 
      986 	declare discard		 fixed bin (35);	/* unused error code */
      987 
      988      end;
      989 
      990 	declare program_name	 char (32) init ("mu_open_name_manager"); /* name of calling program */
      991 	declare root_of_tree_ptr	 ptr int static init (null ()); /* points to root of name tree */
      992 	declare user_name		 char (*);	/* users name for this opening */
      993 	declare error_code		 fixed bin (35);	/* error status endoing */
      994 	declare mdbm_error_$too_many_open_names fixed bin (35) ext; /* more than space allows */
      995 	declare mdbm_error_$open_name_not_known fixed bin (35) ext; /* name given not in tree */
      996 	declare mdbm_error_$open_name_already_known fixed bin (35) ext; /* name already in tree */
      997 	declare success		 bit (1);		/* on => operation succeded */
      998 	declare parent_ptr		 ptr;		/* pointer to parent of node */
      999 	declare model_pointer	 ptr;		/* pointer to resultant/model/submodel */
     1000 	declare open_model_type	 char (1);	/* r => resultant, m => model, s => submodel */
     1001 	declare ioa_		 entry options (variable); /* reports open name list */
     1002 	declare area_ptr		 ptr int static init (null ()); /* points to space for open names */
     1003 	declare work_area		 area (sys_info$max_seg_size) based (area_ptr); /* space for open names */
     1004 	declare sys_info$max_seg_size	 fixed bin (35) ext;/* largest segment */
     1005 	declare number_of_open_names	 fixed bin (24);	/* number of names displayed */
     1006 	declare current_number_of_names fixed bin (24) int static init (0); /* current count of names known */
     1007 	declare successor_ptr	 ptr;		/* points to next in tree "inorder" */
     1008 	declare area		 condition;	/* signaled when no space for names */
     1009 	declare get_temp_segment_	 entry (char (*), ptr, fixed bin (35)); /* gets work space */
     1010 	declare release_temp_segment_	 entry (char (*), ptr, fixed bin (35)); /* gets rid of temp pace */
     1011 	declare successor_parent_ptr	 ptr;		/* pointer to parent of next node */
     1012 	declare node_ptr		 ptr;		/* points to current node */
     1013 	declare sysprint		 file;		/* for debug output */
     1014 	declare (null, substr, length, empty, unspec) builtin;
     1015 	declare open_name_list_ptr	 ptr;		/* points to head of linked list of open names */
     1016 	declare open_name_list_size	 fixed bin (24);	/* number of elements in list */
     1017 	declare error_table_$area_too_small fixed bin (35) ext; /* not enough space in suers area */
     1018 	declare error_table_$badcall	 fixed bin (35) ext;/* null area pointer */
     1019 	declare error_table_$unimplemented_version fixed bin (35) ext; /* bad structure version */
     1020 	declare structure_version	 fixed bin;	/* desired version of structure */
     1021 	declare user_area_ptr	 ptr;		/* pointer to place to put list of names */
     1022 	declare predecessor_ptr	 ptr;		/* points to previous in list */
     1023 	declare predecessor_parent_ptr ptr;		/* points to parent of previous node */
     1024 
  1     1 /* BEGIN INCLUDE FILE mrds_open_name.incl.pl1 - - Jim Gray 81-02-04 */
  1     2 
  1     3 /* HISTORY:
  1     4*
  1     5*   81-02-04 Jim Gray : originally written for the new mrds_open_name_manager routine
  1     6*
  1     7**/
  1     8 
  1     9 /* DESCRIPTION:
  1    10*
  1    11*   This structure is an element in "in order" binary tree
  1    12*   of names that the user has given in a call to a model/submodel opening
  1    13*   routine, which he can use in future references to that opening.
  1    14*   It associates that user name with information needed internally
  1    15*   by MRDS to properly reference the particular opening involved.
  1    16*   The opening could have been made by the equivalent
  1    17*   of one of dmd_, dsmd_, or dsl_$open.
  1    18*
  1    19**/
  1    20 
  1    21 
  1    22 declare 1 mrds_open_name aligned based (mrds_open_name_ptr),
  1    23         2 version fixed bin,				/* version number of this structure */
  1    24         2 mbz1 bit (36) unal,
  1    25         2 right,
  1    26 	3 link ptr,				/* pointer to right descendent or thread to successor */
  1    27 	3 thread bit (1) unal,			/* on => link is a thread, not a pointer */
  1    28 	3 mbz2 bit (35) unal,
  1    29         2 left,
  1    30 	3 link ptr,				/* pointer to left descendent or thread to predecessor */
  1    31 	3 thread bit (1) unal,			/* on => link is a thread not a pointer */
  1    32 	3 mbz3 bit (35) unal,
  1    33         2 mrds_info,
  1    34 	3 opening_type char (1) unal,			/* "m" => user opening database model(mmi_)
  1    35*						   "s" => user opening submodel structure(msmi_)
  1    36*						   "r" => user opening database(dsl_), for data access */
  1    37 	3 mbz4 char (3) unal,
  1    38 	3 model_pointer ptr,			/* if model opening, a pointer to the data model
  1    39*						   if submodel opening, the submodel iocb pointer
  1    40*						   if database opening, the resultant model pointer */
  1    41         2 user_info,
  1    42 	3 name_length fixed bin (24),			/* the length of the users opening reference name */
  1    43 	3 mbz5 bit (36) unal,
  1    44 	3 name char (mrds_open_name_length_init refer (mrds_open_name.user_info.name_length)) ;
  1    45 
  1    46 
  1    47 declare  mrds_open_name_ptr ptr ;
  1    48 
  1    49 declare  mrds_open_name_length_init fixed bin (24) ;
  1    50 
  1    51 declare  mrds_open_name_structure_version fixed bin int static init (1) options (constant) ;
  1    52 
  1    53 /* END INCLUDE FILE mrds_open_name.incl.pl1 */
     1025 
     1026 
  2     1 /* BEGIN INCLUDE FILE mrds_open_name_element.incl.pl1 - - Jim Gray 81-02-06 */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*   81-02-06 Jim Gray : originally created for the mu_open_name_manager
  2     6*   entry list_all_open_names
  2     7*
  2     8**/
  2     9 
  2    10 /* DESCRIPTION:
  2    11*
  2    12*   This structure refers to one element in a singly linked list
  2    13*   of open names for the process. The name list is in collating sequence
  2    14*   order, and the open type is given along with the open name, and it's length.
  2    15*   The pointer passed back in the list_all_open_names entry points to the
  2    16*   first in the name list, by setting mrds_open_name_element_ptr
  2    17*   to this, the name can be obtained. Then using mrds_open_name_elem.next,
  2    18*   the next in the list can be seen, until next is a null pointer indicating end of list.
  2    19*   The open name uniqueness is determined by pl1 comparison rules.
  2    20*
  2    21**/
  2    22 
  2    23 
  2    24 declare 1 mrds_open_name_element aligned based (mrds_open_name_element_ptr),
  2    25         2 version fixed bin,				/* structure version */
  2    26         2 next ptr,					/* points to next in the singly linked list of names,
  2    27*						   this will be null if no more names appear after this one */
  2    28         2 name_length fixed bin (24),			/* length of the open name */
  2    29         2 model_pointer ptr,				/* pointer to a model/submodel or resultant model,
  2    30*						   depending on the opening type */
  2    31         2 open_type char (1) unal,			/* "r" => opening of a database via equivalent of dsl_
  2    32*						   "s" => opening of a submodel via equivalent of dsmd_ (msmi_)
  2    33*						   "m" => opening of a model via equivalent of dmd_ (mmi_) */
  2    34         2 mbz char (3) unal,
  2    35         2 open,
  2    36 	3 name char (mrds_open_name_element_length_init
  2    37          refer (mrds_open_name_element.name_length)) ;	/* the name for this particualr opening instance */
  2    38 
  2    39 
  2    40 declare  mrds_open_name_element_ptr ptr ;
  2    41 
  2    42 declare  mrds_open_name_element_length_init fixed bin (24) ;
  2    43 
  2    44 declare  mrds_open_name_element_structure_version fixed bin int static init (1) options (constant) ;
  2    45 
  2    46 /* END INCLUDE FILE mrds_open_name_element.incl.pl1 */
     1027 
     1028 
  3     1 /* BEGIN INCLUDE FILE mrds_debug_names.incl.pl1     Jim Gray 8/7/79 */
  3     2 
  3     3 /* this include file associates module names with debug switches
  3     4*   that are stored in the data segment mrds_debug_
  3     5*   each module has it's own bit(9) debug switch, to define for various
  3     6*   debug actions, with new module names to be added to the end
  3     7*   of this list using the next in order array index in mrds_debug_
  3     8*   the convention for naming is db_{module's full name}
  3     9*   for the defined declaration over mrds_debug_$switch.
  3    10*   module.name array is then changed to reflect the new
  3    11*   number of modules, with the full module name added to the bottom
  3    12*   of the initialize list for the name array.
  3    13*   the module name array is used by the command level interface that sets/resets
  3    14*   the current status of the debug switches for each module.
  3    15*   the modules themselves use the db_{module name} declared variable for
  3    16*   that module to interagate the bits for proper debug action to take.
  3    17*   the definition of the meaning of the 9-bits is up to each individual module's
  3    18*   designer. */
  3    19 
  3    20 
  3    21 /*
  3    22*   HISTORY
  3    23*
  3    24*   80-11-12 Davids: added db_mus_mod_ubtup
  3    25*
  3    26*   80-11-13 Davids: added db_mu_sec_get_tuple and db_mu_sec_get_tid
  3    27*
  3    28*   80-12-15 Jim Gray :  added  mrds_dsl_set_fscope  to  display  non
  3    29*   error  info  about  being queued, and request being granted after
  3    30*   being queued.
  3    31*
  3    32*   81-01-15 Jim Gray : added  mu_concurrency_control  bit  to  allow
  3    33*   running  MR8  and  MR9 mrds against the same database at the same
  3    34*   time.
  3    35*
  3    36*   81-02-02  Jim  Gray  :  added  bit  for  mrds_rst_dmdm  to  allow
  3    37*   displaying internal tuple format bit offset, rather than the user
  3    38*   view.
  3    39*
  3    40*   81-02-06 Jim Gray : added bit for  new  mu_open_name_manager,  to
  3    41*   dump  an  element  from  the  list, when display_open_names entry
  3    42*   called with switch set.
  3    43*
  3    44*   81-05-20 Jim Gray : added bit for  mrds_dsl_where_clause  display
  3    45*   of sub_err_ messages, when cross domain compare occurs.
  3    46*
  3    47*   81-06-17 Jim Gray : added bit for mu_open_iocb_manager to display
  3    48*   iocb slot and rel name.
  3    49*
  3    50*   81-07-08 Jim Gray : added comment for bit 4 in mrds_dsl_permute
  3    51*
  3    52*   81-07-17 Jim Gray : added comment for bit 5 in mrds_dsl_permute
  3    53*
  3    54*   81-07-18 Jim Gray : added bit 1 for  mrds_dsl_gen_srch_prog  that
  3    55*   allows  key  searches, other than than specified by permute to be
  3    56*   done as comparisons instead.
  3    57*
  3    58*   81-07-22  Jim   Gray   :   added   comment   about   bit   2   in
  3    59*   mrds_dsl_gen_srch_prog
  3    60**/
  3    61 
  3    62 declare (
  3    63          db_mrds_dsl_eval_expr bit (9) unal defined (mrds_debug_$switch (1)),
  3    64          db_mrds_dsl_get_token bit (9) unal defined (mrds_debug_$switch (2)),
  3    65          db_mrds_dsl_permute bit (9) unal defined (mrds_debug_$switch (3)),
  3    66          db_mrds_dsl_optimize bit (9) unal defined (mrds_debug_$switch (4)),
  3    67          db_mrds_dsl_search bit (9) unal defined (mrds_debug_$switch (5)),
  3    68          db_mrds_dsl_translate bit (9) unal defined (mrds_debug_$switch (6)),
  3    69          db_mu_retrieve bit (9) unal defined (mrds_debug_$switch (7)),
  3    70          db_mrds_dsl_open bit (9) unal defined (mrds_debug_$switch (8)),
  3    71          db_mrds_dsl_close bit (9) unal defined (mrds_debug_$switch (9)),
  3    72          db_mrds_dsl_init_res bit (9) unal defined (mrds_debug_$switch (10)),
  3    73          db_mu_sec_init_res bit (9) unal defined (mrds_debug_$switch (11)),
  3    74          db_mus_mod_ubtup bit (9) unal defined (mrds_debug_$switch (12)),
  3    75          db_mu_sec_get_tuple bit (9) unal defined (mrds_debug_$switch (13)),
  3    76          db_mu_sec_get_tid bit (9) unal defined (mrds_debug_$switch (14)),
  3    77          db_mrds_dsl_set_fscope bit (9) unal defined (mrds_debug_$switch (15)),
  3    78          db_mu_concurrency_control bit (9) unal defined (mrds_debug_$switch (16)),
  3    79          db_mrds_rst_dmdm bit (9) unal defined (mrds_debug_$switch (17)),
  3    80          db_mu_open_name_manager bit (9) unal defined (mrds_debug_$switch (18)),
  3    81          db_mrds_dsl_where_clause bit (9) unal defined (mrds_debug_$switch (19)),
  3    82          db_mu_open_iocb_manager bit (9) unal defined (mrds_debug_$switch (20)),
  3    83          db_mrds_dsl_gen_srch_prog bit (9) unal defined (mrds_debug_$switch (21))
  3    84          ) ;
  3    85 
  3    86 /* list of known module names, with index into name array
  3    87*   the same as that into mrds_debug_$switch,
  3    88*   number is the current count of defined module names,
  3    89*   name is the modules full name. */
  3    90 
  3    91 declare 1 module options (constant) internal static,
  3    92         2 number fixed bin init (21),
  3    93         2 name char (32) dimension (21) init (
  3    94          "mrds_dsl_eval_expr",			/* 1 => display value of each expression */
  3    95          "mrds_dsl_get_token",			/* 1 => display the current token */
  3    96          "mrds_dsl_permute",				/* each 1 => lost cost path found,
  3    97*						   2 => reverse partial path
  3    98*						   3 => use range order for path
  3    99*						   4 => display access method costs
  3   100*						   5 => display details of final low cost path */
  3   101          "mrds_dsl_optimize",				/* 1 => pred tree,
  3   102*						   2 => paths to consider, 3 => calc_cost on */
  3   103          "mrds_dsl_search",				/* 1 => display each tuple located */
  3   104          "mrds_dsl_translate",			/* 1 => display the search program */
  3   105          "mu_retrieve",				/* 1 => display values compared, 2 => display tuple data */
  3   106          "mrds_dsl_open",				/* 1 => allow cleanup sub_error_ */
  3   107          "mrds_dsl_close",				/* 1 => allow cleanup sub_error_ */
  3   108          "mrds_dsl_init_res",				/* 1 => allow cleanup sub_error_ */
  3   109          "mu_sec_init_res",				/* 1 => allow cleanup sub_error_ */
  3   110          "mus_mod_ubtup",				/* 1 => consistency checking between the old
  3   111*						   and new tuple during modifies will be done */
  3   112          "mu_sec_get_tuple",				/* 1 => attribute values
  3   113*						   will be zeroed in the tuple structure
  3   114*						   is don't have read permission. */
  3   115          "mu_sec_get_tid",				/* 1 => read permission to the key
  3   116*						   is checked (if db is secured) */
  3   117          "mrds_dsl_set_fscope",			/* 1 => display being queued,
  3   118*						   and request granted from queue messages */
  3   119          "mu_concurrency_control",			/* 1 => allow both dbc and db.control segs under db
  3   120*						   so can test both MR8 and MR9 mrds
  3   121*						   against the same database at the same time */
  3   122          "mrds_rst_dmdm",				/* 1 => allow internal form of bit offset value
  3   123*						   for attributes to be displayed, rather than user view */
  3   124          "mu_open_name_manager",			/* 1 => dump mrds_open_name tree node structure,
  3   125*						   when display_open_names entry called */
  3   126          "mrds_dsl_where_clause",			/* 1 => display details of cross domain compares */
  3   127          "mu_open_iocb_manager",			/* 1 => display relation and slot getting iocb for */
  3   128          "mrds_dsl_gen_srch_prog"			/* 1 => do additional conditions as sequential, not key searches
  3   129*						   when the original access was a key,
  3   130*						   and the additional conditions can be done as key also
  3   131*						   2 => force key searches, regardless of strategy
  3   132*						   used to decide between compare or key search */
  3   133          ) ;
  3   134 
  3   135 declare  mrds_debug_$switch (1:400) bit (9) unal ext ;	/* data segment debug array */
  3   136 
  3   137 /* END INCLUDE FILE mrds_debug_names.incl.pl1 */
  3   138 
     1029 
     1030 
     1031      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/85  0908.4  mu_open_name_manager.pl1          >special_ldd>online>mrds.pbf-04/18/85>mu_open_name_manager.pl1
1025         1    10/14/83  1608.8  mrds_open_name.incl.pl1           >ldd>include>mrds_open_name.incl.pl1
1027         2    10/14/83  1608.8  mrds_open_name_element.incl.pl1   >ldd>include>mrds_open_name_element.incl.pl1
1029         3    10/14/83  1609.0  mrds_debug_names.incl.pl1         >ldd>include>mrds_debug_names.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
area                            000120 stack reference condition                dcl 1008 ref 111 258
area_ptr                        000012 internal static pointer                  initial dcl 1002 set ref 917 922 947 959* 963 972
                                                                                  974* 976*
current_number_of_names         000014 internal static fixed bin(24,0)          initial dcl 1006 set ref 120* 120 138* 138 139 176
                                                                                  176* 239* 980*
db_mu_open_name_manager                defined         bit(9)                   unaligned dcl 3-62 ref 194
discard                         000264 automatic       fixed bin(35,0)          dcl 986 set ref 974*
empty                                                  builtin function         dcl 1014 ref 963
error_code                             parameter       fixed bin(35,0)          dcl 993 set ref 109 112* 116* 122* 130 132* 143* 150
                                                                                  152* 164* 215 217* 232* 247 251* 259* 263* 265*
                                                                                  268 307 959* 960
error_table_$area_too_small     000040 external static fixed bin(35,0)          dcl 1017 ref 259
error_table_$badcall            000042 external static fixed bin(35,0)          dcl 1018 ref 263
error_table_$unimplemented_version
                                000044 external static fixed bin(35,0)          dcl 1019 ref 265
get_temp_segment_               000032 constant        entry                    external dcl 1009 ref 959
ioa_                            000026 constant        entry                    external dcl 1001 ref 176 191 192 207 209
key                                    parameter       char                     unaligned dcl 657 in procedure "tree_delete" set ref
                                                                                  498 542* 652 652
key                                    parameter       char                     unaligned dcl 393 in procedure "tree_search" ref 314
                                                                                  375 381
key                                    parameter       char                     unaligned dcl 791 in procedure "tree_insert" set ref
                                                                                  674 709* 721 721 722 737 737 758 768
key_length                             parameter       fixed bin(24,0)          dcl 951 in procedure "node_free" ref 940 945
key_length                             parameter       fixed bin(24,0)          dcl 935 in procedure "node_allocate" ref 890 920 927
left                      6            based           structure                level 2 dcl 1-22
length                                                 builtin function         dcl 1014 ref 652 652 721 721 737 737
link                      2            based           pointer                  level 3 in structure "mrds_open_name" dcl 1-22
                                                                                  in procedure "mu_open_name_manager" set ref 378
                                                                                  452 565* 565 568* 586 626 628* 628 645* 739* 770*
                                                                                  770 773* 781* 869
link                      6            based           pointer                  level 3 in structure "mrds_open_name" dcl 1-22
                                                                                  in procedure "mu_open_name_manager" set ref 361
                                                                                  384 470 579 584 584 597* 597 626* 639 640* 742*
                                                                                  771* 780* 780 783* 849
mdbm_error_$open_name_already_known
                                000024 external static fixed bin(35,0)          dcl 996 ref 122
mdbm_error_$open_name_not_known 000022 external static fixed bin(35,0)          dcl 995 ref 143 164 232
mdbm_error_$too_many_open_names 000020 external static fixed bin(35,0)          dcl 994 ref 112
model_pointer            14            based           pointer                  level 3 in structure "mrds_open_name" dcl 1-22
                                                                                  in procedure "mu_open_name_manager" set ref 160
                                                                                  294 929*
model_pointer             6            based           pointer                  level 2 in structure "mrds_open_name_element"
                                                                                  dcl 2-24 in procedure "mu_open_name_manager" set
                                                                                  ref 294*
model_pointer                          parameter       pointer                  dcl 999 in procedure "mu_open_name_manager" set ref
                                                                                  109 150 153* 160* 929
mrds_debug_$switch              000046 external static bit(9)                   array unaligned dcl 3-135 ref 194 194
mrds_info                12            based           structure                level 2 dcl 1-22
mrds_open_name                         based           structure                level 1 dcl 1-22 set ref 198 922 924* 947
mrds_open_name_element                 based           structure                level 1 dcl 2-24 set ref 284 286*
mrds_open_name_element_length_init
                                000144 automatic       fixed bin(24,0)          dcl 2-42 set ref 282* 284 284 291
mrds_open_name_element_ptr      000142 automatic       pointer                  dcl 2-40 set ref 284* 286 290 291 292 293 294 298
                                                                                  299
mrds_open_name_element_structure_version
                                003005 constant        fixed bin(17,0)          initial dcl 2-44 ref 265 290
mrds_open_name_length_init      000140 automatic       fixed bin(24,0)          dcl 1-49 set ref 920* 922 922 945*
mrds_open_name_ptr              000136 automatic       pointer                  dcl 1-47 set ref 159* 160 161 189* 191 192 196 198
                                                                                  281* 282 292 293 294 922* 924 926 927 928 929 931
                                                                                  1-22 1-22 1-22 1-22 1-22 1-22 1-22 1-22 1-22 1-22
                                                                                  1-22 1-22 1-22 1-22 1-22 1-22 1-22 1-22 1-22
mrds_open_name_structure_version
                                003005 constant        fixed bin(17,0)          initial dcl 1-51 ref 926
name                     20            based           char                     level 3 in structure "mrds_open_name" dcl 1-22
                                                                                  in procedure "mu_open_name_manager" set ref 191*
                                                                                  230 292 375 381 722* 758* 768
name                     11            based           char                     level 3 in structure "mrds_open_name_element"
                                                                                  dcl 2-24 in procedure "mu_open_name_manager" set
                                                                                  ref 292*
name_length              16            based           fixed bin(24,0)          level 3 in structure "mrds_open_name" dcl 1-22
                                                                                  in procedure "mu_open_name_manager" set ref 191
                                                                                  191 198 230 282 292 375 381 722 758 768 922* 924
                                                                                  927* 947 1-22
name_length               4            based           fixed bin(24,0)          level 2 in structure "mrds_open_name_element"
                                                                                  dcl 2-24 in procedure "mu_open_name_manager" set
                                                                                  ref 284* 286 291* 292
next                      2            based           pointer                  level 2 dcl 2-24 set ref 298*
node_ptr                               parameter       pointer                  dcl 793 in procedure "tree_insert" set ref 674 709*
                                                                                  721* 722 723 724 770 771 773 780 781 783
node_ptr                               parameter       pointer                  dcl 395 in procedure "tree_search" set ref 314 361*
                                                                                  375 376 377 378* 378 381 382 383 384* 384
node_ptr                        000130 automatic       pointer                  dcl 1012 in procedure "mu_open_name_manager" set ref
                                                                                  118* 156* 159 172* 185* 189* 223* 225* 228* 230
                                                                                  252* 275* 281*
node_ptr                               parameter       pointer                  dcl 936 in procedure "node_allocate" set ref 890
                                                                                  931*
node_ptr                               parameter       pointer                  dcl 880 in procedure "tree_predecessor" ref 800 838
                                                                                  848 849 851
node_ptr                               parameter       pointer                  dcl 950 in procedure "node_free" ref 940 947
node_ptr                               parameter       pointer                  dcl 488 in procedure "tree_successor" ref 404 442
                                                                                  451 452 454
node_ptr                        000114 automatic       pointer                  dcl 666 in procedure "tree_delete" set ref 542* 560
                                                                                  561* 562 564* 565 565 579 579 579 584 584 586 597
                                                                                  598 602 628 639 652*
null                                                   builtin function         dcl 1014 ref 153 254 263 359 442 729 838 917 972 976
                                                                                  978
number_of_open_names            000114 automatic       fixed bin(24,0)          dcl 1005 set ref 179* 188* 188 207 256* 279* 279 307
open                     11            based           structure                level 2 dcl 2-24
open_model_type                        parameter       char(1)                  unaligned dcl 1000 set ref 109 150 154* 161* 928
open_name_list_ptr                     parameter       pointer                  dcl 1015 set ref 247 254* 298 299*
open_name_list_size                    parameter       fixed bin(24,0)          dcl 1016 set ref 247 255* 307*
open_type                10            based           char(1)                  level 2 packed unaligned dcl 2-24 set ref 293*
opening_type             12            based           char(1)                  level 3 packed unaligned dcl 1-22 set ref 161 192*
                                                                                  293 928*
parent_ptr                      000240 automatic       pointer                  dcl 795 in procedure "tree_insert" set ref 709* 757*
                                                                                  768 770 771 773 774 780 781 783 784
parent_ptr                      000112 automatic       pointer                  dcl 665 in procedure "tree_delete" set ref 542* 584
                                                                                  639 640 641 645 646
parent_ptr                      000112 automatic       pointer                  dcl 998 in procedure "mu_open_name_manager" set ref
                                                                                  156*
parent_ptr                             parameter       pointer                  dcl 396 in procedure "tree_search" set ref 314 353*
                                                                                  377* 383*
predecessor_parent_ptr                 parameter       pointer                  dcl 882 in procedure "tree_predecessor" set ref 800
                                                                                  848* 868*
predecessor_parent_ptr          000134 automatic       pointer                  dcl 1023 in procedure "mu_open_name_manager" set ref
                                                                                  275*
predecessor_parent_ptr          000110 automatic       pointer                  dcl 664 in procedure "tree_delete" set ref 564*
predecessor_ptr                        parameter       pointer                  dcl 881 in procedure "tree_predecessor" set ref 800
                                                                                  849* 851 866 868 869* 869
predecessor_ptr                 000132 automatic       pointer                  dcl 1022 in procedure "mu_open_name_manager" set ref
                                                                                  275* 281
predecessor_ptr                 000106 automatic       pointer                  dcl 663 in procedure "tree_delete" set ref 564* 565
                                                                                  568
program_name                    000100 automatic       char(32)                 initial unaligned dcl 990 set ref 959* 974* 990*
release_temp_segment_           000034 constant        entry                    external dcl 1010 ref 974
right                     2            based           structure                level 2 dcl 1-22
root_of_tree_ptr                000010 internal static pointer                  initial dcl 991 set ref 118* 135* 156* 172 185* 223
                                                                                  225* 230* 252 275* 978*
root_ptr                               parameter       pointer                  dcl 658 in procedure "tree_delete" set ref 498 542*
                                                                                  561* 564*
root_ptr                               parameter       pointer                  dcl 879 in procedure "tree_predecessor" ref 800 851
root_ptr                               parameter       pointer                  dcl 487 in procedure "tree_successor" ref 404 454
                                                                                  477
root_ptr                               parameter       pointer                  dcl 792 in procedure "tree_insert" set ref 674 709*
                                                                                  729 737* 739 739 740 742 742 743 755 757 758
root_ptr                               parameter       pointer                  dcl 394 in procedure "tree_search" ref 314 353 359
                                                                                  361 362
structure_version                      parameter       fixed bin(17,0)          dcl 1020 ref 247 265
substr                                                 builtin function         dcl 1014 ref 194
success                                parameter       bit(1)                   unaligned dcl 397 in procedure "tree_search" set ref
                                                                                  314 354* 370 387*
success                                parameter       bit(1)                   unaligned dcl 794 in procedure "tree_insert" set ref
                                                                                  674 709* 714 714* 719*
success                                parameter       bit(1)                   unaligned dcl 883 in procedure "tree_predecessor"
                                                                                  set ref 800 838* 851* 855* 864*
success                         000110 automatic       bit(1)                   unaligned dcl 997 in procedure
                                                                                  "mu_open_name_manager" set ref 118* 120 135* 137
                                                                                  156* 158 174* 183 185* 187 219* 221 225* 227 230*
                                                                                  232 253* 273 275* 277
success                                parameter       bit(1)                   unaligned dcl 659 in procedure "tree_delete" set ref
                                                                                  498 542* 546 561* 564* 653*
success                                parameter       bit(1)                   unaligned dcl 491 in procedure "tree_successor" set
                                                                                  ref 404 442* 454* 458* 477* 479*
successor_parent_ptr            000102 automatic       pointer                  dcl 661 in procedure "tree_delete" set ref 561* 602
                                                                                  623 626
successor_parent_ptr            000126 automatic       pointer                  dcl 1011 in procedure "mu_open_name_manager" set ref
                                                                                  185* 225*
successor_parent_ptr                   parameter       pointer                  dcl 490 in procedure "tree_successor" set ref 404
                                                                                  451* 469*
successor_ptr                   000100 automatic       pointer                  dcl 660 in procedure "tree_delete" set ref 561* 568
                                                                                  579* 584* 586* 597 598 622 624 626 628 640 645
successor_ptr                   000116 automatic       pointer                  dcl 1007 in procedure "mu_open_name_manager" set ref
                                                                                  185* 189 225* 228
successor_ptr                          parameter       pointer                  dcl 489 in procedure "tree_successor" set ref 404
                                                                                  452* 454 467 469 470* 470 477
sys_info$max_seg_size           000030 external static fixed bin(35,0)          dcl 1004 ref 963
sysprint                        000036 constant        file                     dcl 1013 set ref 196 198 200*
thread                          000100 automatic       bit(1)                   unaligned dcl 398 in procedure "tree_search" set ref
                                                                                  362* 370 376* 382*
thread                          000104 automatic       bit(1)                   unaligned dcl 662 in procedure "tree_delete" set ref
                                                                                  552* 583* 641 646
thread                    4            based           bit(1)                   level 3 in structure "mrds_open_name" packed
                                                                                  unaligned dcl 1-22 in procedure
                                                                                  "mu_open_name_manager" set ref 376 454 560 565 579
                                                                                  622 624* 646* 723* 740* 774* 866
thread                   10            based           bit(1)                   level 3 in structure "mrds_open_name" packed
                                                                                  unaligned dcl 1-22 in procedure
                                                                                  "mu_open_name_manager" set ref 362 382 467 562 579
                                                                                  598* 598 623* 641* 724* 743* 755 784* 851
unspec                                                 builtin function         dcl 1014 set ref 286* 924*
user_area_ptr                          parameter       pointer                  dcl 1021 ref 247 263 284
user_info                16            based           structure                level 2 dcl 1-22
user_name                              parameter       char                     unaligned dcl 992 set ref 109 118* 130 135* 150 156*
version                                based           fixed bin(17,0)          level 2 in structure "mrds_open_name_element"
                                                                                  dcl 2-24 in procedure "mu_open_name_manager" set
                                                                                  ref 290*
version                                based           fixed bin(17,0)          level 2 in structure "mrds_open_name" dcl 1-22
                                                                                  in procedure "mu_open_name_manager" set ref 926*
work_area                              based           area                     dcl 1003 set ref 284 922 947 963*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
db_mrds_dsl_close                      defined         bit(9)                   unaligned dcl 3-62
db_mrds_dsl_eval_expr                  defined         bit(9)                   unaligned dcl 3-62
db_mrds_dsl_gen_srch_prog              defined         bit(9)                   unaligned dcl 3-62
db_mrds_dsl_get_token                  defined         bit(9)                   unaligned dcl 3-62
db_mrds_dsl_init_res                   defined         bit(9)                   unaligned dcl 3-62
db_mrds_dsl_open                       defined         bit(9)                   unaligned dcl 3-62
db_mrds_dsl_optimize                   defined         bit(9)                   unaligned dcl 3-62
db_mrds_dsl_permute                    defined         bit(9)                   unaligned dcl 3-62
db_mrds_dsl_search                     defined         bit(9)                   unaligned dcl 3-62
db_mrds_dsl_set_fscope                 defined         bit(9)                   unaligned dcl 3-62
db_mrds_dsl_translate                  defined         bit(9)                   unaligned dcl 3-62
db_mrds_dsl_where_clause               defined         bit(9)                   unaligned dcl 3-62
db_mrds_rst_dmdm                       defined         bit(9)                   unaligned dcl 3-62
db_mu_concurrency_control              defined         bit(9)                   unaligned dcl 3-62
db_mu_open_iocb_manager                defined         bit(9)                   unaligned dcl 3-62
db_mu_retrieve                         defined         bit(9)                   unaligned dcl 3-62
db_mu_sec_get_tid                      defined         bit(9)                   unaligned dcl 3-62
db_mu_sec_get_tuple                    defined         bit(9)                   unaligned dcl 3-62
db_mu_sec_init_res                     defined         bit(9)                   unaligned dcl 3-62
db_mus_mod_ubtup                       defined         bit(9)                   unaligned dcl 3-62
module                          000000 constant        structure                level 1 unaligned dcl 3-91

NAMES DECLARED BY EXPLICIT CONTEXT.
clean_up                        002742 constant        entry                    internal dcl 967 ref 139 241
define_open_name                000420 constant        entry                    external dcl 109
delete_all_open_names           001271 constant        entry                    external dcl 215
delete_open_name                000526 constant        entry                    external dcl 130
display_open_names              000714 constant        entry                    external dcl 170
exit                            001613 constant        label                    dcl 310 ref 260
get_model_pointer               000611 constant        entry                    external dcl 150
init_work_area                  002711 constant        entry                    internal dcl 955 ref 917
list_all_open_names             001411 constant        entry                    external dcl 247
mu_open_name_manager            000404 constant        entry                    external dcl 24
node_allocate                   002615 constant        entry                    internal dcl 890 ref 721 737
node_free                       002673 constant        entry                    internal dcl 940 ref 652
skip_allocate                   000521 constant        label                    dcl 124 ref 113 960
tree_delete                     002035 constant        entry                    internal dcl 498 ref 135 230
tree_insert                     002305 constant        entry                    internal dcl 674 ref 118
tree_predecessor                002523 constant        entry                    internal dcl 800 ref 275 564
tree_search                     001615 constant        entry                    internal dcl 314 ref 156 542 709
tree_successor                  001731 constant        entry                    internal dcl 404 ref 185 225 561

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3344        3416    3006        3354
Length      4532    3006        52        1100     336           6

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mu_open_name_manager                294 external procedure  is an external procedure.  
on unit on line 111                  64 on unit               
on unit on line 258                  64 on unit               
tree_search                          66 internal procedure  is called by several nonquick procedures.  
tree_successor                       64 internal procedure  is called by several nonquick procedures.  
tree_delete                         110 internal procedure  is called during a stack extension.  
tree_insert                             internal procedure  shares stack frame of external procedure mu_open_name_manager.  
tree_predecessor                     64 internal procedure  is called by several nonquick procedures.  
node_allocate                           internal procedure  shares stack frame of external procedure mu_open_name_manager.  
node_free                               internal procedure  shares stack frame of internal procedure tree_delete.  
init_work_area                          internal procedure  shares stack frame of external procedure mu_open_name_manager.  
clean_up                                internal procedure  shares stack frame of external procedure mu_open_name_manager.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 root_of_tree_ptr            mu_open_name_manager
000012 area_ptr                    mu_open_name_manager
000014 current_number_of_names     mu_open_name_manager

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mu_open_name_manager     000100 program_name                mu_open_name_manager
                         000110 success                     mu_open_name_manager
                         000112 parent_ptr                  mu_open_name_manager
                         000114 number_of_open_names        mu_open_name_manager
                         000116 successor_ptr               mu_open_name_manager
                         000126 successor_parent_ptr        mu_open_name_manager
                         000130 node_ptr                    mu_open_name_manager
                         000132 predecessor_ptr             mu_open_name_manager
                         000134 predecessor_parent_ptr      mu_open_name_manager
                         000136 mrds_open_name_ptr          mu_open_name_manager
                         000140 mrds_open_name_length_init  mu_open_name_manager
                         000142 mrds_open_name_element_ptr  mu_open_name_manager
                         000144 mrds_open_name_element_length_init
                                                            mu_open_name_manager
                         000240 parent_ptr                  tree_insert
                         000264 discard                     clean_up
tree_delete              000100 successor_ptr               tree_delete
                         000102 successor_parent_ptr        tree_delete
                         000104 thread                      tree_delete
                         000106 predecessor_ptr             tree_delete
                         000110 predecessor_parent_ptr      tree_delete
                         000112 parent_ptr                  tree_delete
                         000114 node_ptr                    tree_delete
tree_search              000100 thread                      tree_search

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_int_this_desc  call_int_this       call_int_other_desc call_int_other
return              tra_ext             enable              shorten_stack       ext_entry           ext_entry_desc
int_entry           int_entry_desc      put_end             stream_io           put_data_eis        alloc_based
free_based          empty

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_temp_segment_             ioa_                          release_temp_segment_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$area_too_small   error_table_$badcall          error_table_$unimplemented_version
mdbm_error_$open_name_already_known                         mdbm_error_$open_name_not_known
mdbm_error_$too_many_open_names                             mrds_debug_$switch            sys_info$max_seg_size
sysprint                      sysprint.fsb




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    990 000362      1013 000365        24 000403        24 000412       109 000413       111 000437       112 000453
    113 000456       116 000461       118 000462       120 000510       122 000516       124 000521       130 000522
    132 000545       135 000546       137 000571       138 000574       139 000577       141 000602       143 000603
    145 000606       150 000607       152 000630       153 000631       154 000634       156 000640       158 000670
    159 000673       160 000675       161 000701       162 000706       164 000707       166 000712       170 000713
    172 000722       174 000725       176 000727       179 000750       183 000751       185 000755       187 000774
    188 000777       189 001000       191 001003       192 001032       194 001053       196 001060       198 001075
    200 001220       205 001232       207 001233       209 001252       211 001265       215 001266       217 001302
    219 001303       221 001305       223 001311       225 001314       227 001332       228 001335       230 001337
    232 001370       237 001377       239 001400       241 001402       243 001403       247 001404       251 001422
    252 001423       253 001426       254 001430       255 001433       256 001434       258 001435       259 001451
    260 001454       263 001457       265 001470       268 001476       273 001501       275 001505       277 001524
    279 001527       281 001530       282 001533       284 001536       286 001552       290 001563       291 001565
    292 001567       293 001574       294 001576       298 001600       299 001604       303 001605       307 001606
    310 001613       314 001614       353 001630       354 001634       359 001640       361 001645       362 001651
    370 001656       375 001666       376 001700       377 001703       378 001704       379 001710       381 001711
    382 001712       383 001715       384 001716       385 001722       387 001723       389 001726       402 001727
    404 001730       442 001736       451 001750       452 001753       454 001757       458 001775       467 002002
    469 002010       470 002011       472 002015       477 002016       479 002027       496 002033       498 002034
    542 002050       546 002100       552 002107       560 002110       561 002115       562 002134       564 002141
    565 002161       568 002171       579 002174       583 002205       584 002207       586 002216       587 002220
    597 002221       598 002224       602 002230       622 002235       623 002240       624 002243       625 002245
    626 002246       628 002251       639 002253       640 002260       641 002262       642 002266       645 002267
    646 002271       652 002275       653 002277       672 002304       674 002305       709 002316       714 002346
    719 002360       721 002363       722 002373       723 002404       724 002406       729 002410       737 002415
    739 002425       740 002431       742 002435       743 002436       755 002442       757 002450       758 002451
    768 002457       770 002470       771 002474       773 002477       774 002502       776 002504       780 002505
    781 002511       783 002514       784 002517       798 002521       800 002522       838 002530       848 002542
    849 002545       851 002551       855 002567       864 002574       866 002600       868 002606       869 002607
    871 002613       888 002614       890 002615       917 002617       920 002625       922 002630       924 002643
    926 002654       927 002656       928 002661       929 002666       931 002671       938 002672       940 002673
    945 002675       947 002700       953 002710       955 002711       959 002712       960 002733       963 002735
    965 002741       967 002742       972 002743       974 002750       976 002770       978 002773       980 002774
    988 002775


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
