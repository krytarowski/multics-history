	COMPILATION LISTING OF SEGMENT string_op
	Compiled by: Multics PL/I Compiler, Release 28d, of September 14, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 10/03/83  1704.1 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* this procedure compiles string expressions
       12*
       13*   Initial Version:  5 October, 1968 by BLW 
       14*	Modified:  4 September 1971 by BLW for Version II
       15*	Modified: 25 November 1972 by BLW
       16*	Modified:	4 June 1973 by RAB for EIS
       17*	Modified:	2 November 1975 by RAB to check for p3 in a
       18*	Modified:	1 April 1979 by RAB to improve code generated when
       19*		expression lengths are the same, and to add commentary
       20*		on compiling string expressions.
       21*	Modified:	20 August 1979 by RAB to improve code generated
       22*		for a & ^ b, where a and b are long strings.
       23*	Modified:	21 August 1979 by RAB to use check_lengths for andnot and
       24*		to fix a bug in check_lengths.
       25*	Modified:	30 March 1980 by RAB for reference.aligned_for_store_ref.
       26*		See prepare_operand for details.	*/
       27 
       28 string_op: proc(node_pt,refs,p_code);
       29 
       30 dcl	node_pt	ptr,		/* points at operator node */
       31 	refs(3) 	ptr,		/* ptrs to reference nodes for operands */
       32 	p_code	fixed bin(15);	/* encodes local context of operator */
       33 
       34 dcl	(cg_stat$double_temp,cg_stat$long_string_temp) ptr ext static,
       35 	cg_stat$for_test_called bit(1) ext static;
       36 
       37 dcl	(p,p1,p2,p3,q2,q3,ref(3) defined(refs)) ptr,
       38 	for_test bit(1) aligned,
       39 	doing_andnot bit(1) aligned,
       40 	code fixed bin(2),
       41 	atom(2:3) bit(1) aligned,
       42 	(s2,s3,op,k,l_op,load_double,op_code,n,which_andnot) fixed bin(15);
       43 
       44 dcl	load entry(ptr,fixed bin(15)),
       45 	c_a entry(fixed bin(31),fixed bin) returns(ptr),
       46 	aq_man$clear_q entry,
       47 	string_temp entry(ptr,ptr,ptr) returns(ptr),
       48 	expmac$eis entry(fixed bin(15),ptr),
       49 	expmac$zero entry(fixed bin(15)),
       50 	expmac entry(fixed bin(15),ptr),
       51 	expmac$one entry(fixed bin(15),ptr,fixed bin(15)),
       52 	prepare_operand entry(ptr,fixed bin,bit(1) aligned) returns(ptr),
       53 	adjust_ref_count entry(ptr,fixed bin),
       54 	compile_exp entry(ptr),
       55 	(compile_exp$save,compile_exp$save_exp) entry(ptr) returns(ptr);
       56 
       57 dcl	(bit,fixed,min,null,string,substr) builtin;
       58 
       59 dcl (	and		init(1),
       60 	not		init(4)) fixed bin int static;
       61 
       62 dcl (	era		init(52),
       63 	move_not_bits	init(335),
       64 	comp_bits		init(148),
       65 	move_xor		init(341),
       66 	ora		init(46),
       67 	move_or		init(304),
       68 	ana		init(40),
       69 	and_for_test	init(615),
       70 	move_and		init(264),
       71 	move_andnot(0:1)	init(391,392),
       72 	test_not		init(338),
       73 	test_xor		init(344),
       74 	test_or		init(331),
       75 	test_and		init(267),
       76 	test_andnot(0:1)	init(261,262),
       77 	staq		init(6)) fixed bin(15) int static;
       78 
  1     1 /* BEGIN INCLUDE FILE ... cgsystem.incl.pl1 */
  1     2 
  1     3 /* Modified: 25 Apr 1979 by PCK to implement 4-bit decimal */
  1     4 
  1     5 dcl (	bits_per_char		init(9),
  1     6 	bits_per_half		init(18),
  1     7 	bits_per_word		init(36),
  1     8 	bits_per_two_words		init(72),
  1     9 	bits_per_four_words		init(144),
  1    10 	bits_per_words(2)		init(36,72),
  1    11 	packed_digits_per_char	init(2),
  1    12 	chars_per_word		init(4),
  1    13 	packed_digits_per_word	init(8),
  1    14 
  1    15 	break_even_bits		init(216),
  1    16 	break_even_words		init(6),
  1    17 
  1    18 	label_size		init(4),
  1    19 
  1    20 	convert_size(13:14)		init(9,1),
  1    21 	max_offset(13:14)		init(27,35),
  1    22 	max_short_size(13:14)	init(8,72),
  1    23 
  1    24 	units_per_word(0:5)		init(1,36,8,4,2,1),
  1    25 
  1    26 	max_dec_scale		init(32),
  1    27 	min_dec_scale		init(-31),
  1    28 	max_p_xreg		init(18),
  1    29 	max_p_fix_bin_1		init(35),
  1    30 	max_p_flt_bin_1		init(27),
  1    31 	max_p_fix_dec		init(59),
  1    32 	max_length_p		init(24),
  1    33 	default_fix_bin_p		init(17)) fixed bin(8) int static options(constant);
  1    34 
  1    35 dcl      (convert_offset(0:5)		init(36,1,4.5,9,18,36),
  1    36 	bits_per_packed_digit	init(4.5)) fixed bin(8,1) int static options(constant);
  1    37 
  1    38 dcl	max_index_register_value	init(262143) fixed bin(31) int static options(constant);
  1    39 
  1    40 /* END INCLUDE FILE ... cgsystem.incl.pl1 */
  1    41 
       79 
  2     1 /* BEGIN INCLUDE FILE ... reference.incl.pl1 */
  2     2 
  2     3 dcl	1 reference		based aligned,
  2     4 	2 node_type		bit(9) unaligned,
  2     5 	2 array_ref		bit(1) unaligned,
  2     6 	2 varying_ref		bit(1) unaligned,
  2     7 	2 shared			bit(1) unaligned,
  2     8 	2 put_data_sw		bit(1) unaligned,
  2     9 	2 processed		bit(1) unaligned,
  2    10 	2 units			fixed(3) unaligned,
  2    11 	2 ref_count		fixed(17) unaligned,
  2    12 	2 c_offset		fixed(24),
  2    13 	2 c_length		fixed(24),
  2    14 	2 symbol			ptr unaligned,
  2    15 	2 qualifier		ptr unaligned,
  2    16 	2 offset			ptr unaligned,
  2    17 	2 length			ptr unaligned,
  2    18 	2 subscript_list		ptr unaligned,
  2    19 						/* these fields are used by the 645 code generator */
  2    20 	2 address			structure unaligned,
  2    21 	  3 base			bit(3),
  2    22 	  3 offset		bit(15),
  2    23 	  3 op			bit(9),
  2    24 	  3 no_address		bit(1),
  2    25 	  3 inhibit		bit(1),
  2    26 	  3 ext_base		bit(1),
  2    27 	  3 tag			bit(6),
  2    28 	2 info			structure unaligned,
  2    29 	  3 address_in		structure,
  2    30 	    4 b			dimension(0:7) bit(1),
  2    31 	    4 storage		bit(1),
  2    32 	  3 value_in		structure,
  2    33 	    4 a			bit(1),
  2    34 	    4 q			bit(1),
  2    35 	    4 aq			bit(1),
  2    36 	    4 string_aq		bit(1),
  2    37 	    4 complex_aq		bit(1),
  2    38 	    4 decimal_aq		bit(1),
  2    39 	    4 b			dimension(0:7) bit(1),
  2    40 	    4 storage		bit(1),
  2    41 	    4 indicators		bit(1),
  2    42 	    4 x			dimension(0:7) bit(1),
  2    43 	  3 other			structure,
  2    44 	    4 big_offset		bit(1),
  2    45 	    4 big_length		bit(1),
  2    46 	    4 modword_in_offset	bit(1),
  2    47 	2 data_type		fixed(5) unaligned,
  2    48 	2 bits			structure unaligned,
  2    49 	  3 padded_ref		bit(1),
  2    50 	  3 aligned_ref		bit(1),
  2    51 	  3 long_ref		bit(1),
  2    52 	  3 forward_ref		bit(1),
  2    53 	  3 ic_ref		bit(1),
  2    54 	  3 temp_ref		bit(1),
  2    55 	  3 defined_ref		bit(1),
  2    56 	  3 evaluated		bit(1),
  2    57 	  3 allocate		bit(1),
  2    58 	  3 allocated		bit(1),
  2    59 	  3 aliasable		bit(1),
  2    60 	  3 even			bit(1),
  2    61 	  3 perm_address		bit(1),
  2    62 	  3 aggregate		bit(1),
  2    63 	  3 hit_zero		bit(1),
  2    64 	  3 dont_save		bit(1),
  2    65 	  3 fo_in_qual		bit(1),
  2    66 	  3 hard_to_load		bit(1),
  2    67 	2 relocation		bit(12) unaligned,
  2    68 	2 more_bits		structure unaligned,
  2    69 	  3 substr		bit(1),
  2    70 	  3 padded_for_store_ref	bit(1),
  2    71 	  3 aligned_for_store_ref	bit(1),
  2    72 	  3 mbz			bit(15),
  2    73 	2 store_ins		bit(18) unaligned;
  2    74 
  2    75 /* END INCLUDE FILE ... reference.incl.pl1 */
       80 
  3     1 /* BEGIN INCLUDE FILE ... operator.incl.pl1 */
  3     2 
  3     3 /*	Modified: 2 Apr 1980 by PCK to add max_number_of_operands */
  3     4 
  3     5 /* format: style3 */
  3     6 dcl	1 operator	based aligned,
  3     7 	  2 node_type	bit (9) unaligned,
  3     8 	  2 op_code	bit (9) unaligned,
  3     9 	  2 shared	bit (1) unaligned,
  3    10 	  2 processed	bit (1) unaligned,
  3    11 	  2 optimized	bit (1) unaligned,
  3    12 	  2 number	fixed (14) unaligned,
  3    13 	  2 operand	dimension (n refer (operator.number)) ptr unaligned;
  3    14 
  3    15 dcl	max_number_of_operands
  3    16 			fixed bin (15) int static options (constant) initial (32767);
  3    17 
  3    18 /* END INCLUDE FILE ... operator.incl.pl1 */
       81 
  4     1 /* BEGIN INCLUDE FILE ... machine_state.incl.pl1 */
  4     2 
  4     3 dcl	cg_static_$m_s_p ptr ext static,
  4     4 	m_s_p ptr init(cg_static_$m_s_p);
  4     5 
  4     6 dcl	1 machine_state	aligned based(m_s_p),
  4     7 	2 node_type	bit(9),
  4     8 	2 indicators	fixed bin,
  4     9 	2 next		ptr unal,
  4    10 	2 a_reg,
  4    11 	  3 variable(10)	ptr unal,
  4    12 	  3 number	fixed bin(17),
  4    13 	  3 size		fixed bin(8),
  4    14 	  3 length	fixed bin(8),
  4    15 	  3 offset	fixed bin(8),
  4    16 	  3 constant	fixed bin(24),
  4    17 	  3 changed	fixed bin(18),
  4    18 	  3 instruction	bit(36),
  4    19 	  3 locked	bit(1) aligned,
  4    20 	  3 number_h_o	fixed bin,
  4    21 	  3 has_offset(3)	ptr unal,
  4    22 	2 q_reg,
  4    23 	  3 variable(10)	ptr unal,
  4    24 	  3 number	fixed bin(17),
  4    25 	  3 size		fixed bin(8),
  4    26 	  3 length	fixed bin(8),
  4    27 	  3 offset	fixed bin(8),
  4    28 	  3 constant	fixed bin(24),
  4    29 	  3 changed	fixed bin(18),
  4    30 	  3 instruction	bit(36),
  4    31 	  3 locked	bit(1) aligned,
  4    32 	  3 number_h_o	fixed bin,
  4    33 	  3 has_offset(3)	ptr unal,
  4    34 	2 string_reg,
  4    35 	  3 variable	ptr unal,
  4    36 	  3 size		fixed bin(8),
  4    37 	  3 offset	fixed bin(8),
  4    38 	2 complex_reg,
  4    39 	  3 variable	ptr unal,
  4    40 	  3 size		fixed bin(8),
  4    41 	  3 scale		fixed bin(8),
  4    42 	2 decimal_reg,
  4    43 	  3 variable	ptr unal,
  4    44 	  3 size		fixed bin(8),
  4    45 	  3 scale		fixed bin(8),
  4    46 	2 index_regs(0:7),
  4    47 	  3 variable	ptr unal,
  4    48 	  3 constant	fixed bin,
  4    49 	  3 type		fixed bin(8),
  4    50 	  3 used		fixed bin(18),
  4    51 	  3 changed	fixed bin(18),
  4    52 	  3 instruction	bit(36),
  4    53 	  3 filler	fixed bin,
  4    54 	2 base_regs(0:7),
  4    55 	  3 variable	ptr unal,
  4    56 	  3 constant	fixed bin,
  4    57 	  3 type		fixed bin(8),
  4    58 	  3 pad (12)	fixed bin,	/* future...room to make 5 element array for variable, constant, type */
  4    59 	  3 number	fixed bin (17),	/* future...number of valid elements in array */
  4    60 	  3 used		fixed bin(18),
  4    61 	  3 changed	fixed bin(18),
  4    62 	  3 instruction	bit(36),
  4    63 	  3 locked	fixed bin(2),
  4    64 	2 indicators_ref(2:3) ptr unal;
  4    65 
  4    66 /* Permissible values for machine_state.indicators. */
  4    67 
  4    68 dcl (	ind_known_refs	init (-2),		/* set by comparison of known, nonzero, references */
  4    69 	ind_invalid	init (-1),
  4    70 	ind_string_aq	init (0),			/* logical value in storage */
  4    71 	ind_logical	init (1),			/* logical value in A or AQ */
  4    72 	ind_arithmetic	init (2),			/* arith value in Q, AQ, or EAQ */
  4    73 	ind_x (0:7)	init (6, 7, 8, 9, 10, 11, 12, 13),
  4    74 	ind_decimal_reg	init (14)
  4    75 	) fixed bin internal static options (constant);
  4    76 
  4    77 /* END INCLUDE FILE ... machine_state.incl.pl1 */
       82 
  5     1 /* BEGIN INCLUDE FILE ... op_codes.incl.pl1 */
  5     2 
  5     3 /* Modified: 25 Apr 1979 by PCK 4-bit decimal */
  5     4 /* Modified: 6 Jun 1979 by PG to add rank and byte */
  5     5 /* Modified: 26 Dec 1979 by PCK to add assign_by_name */
  5     6 /* Modified: 26 July 82 BIM wordno, segno */
  5     7 
  5     8 dcl (	add		initial("000010001"b),	/* opnd(1) <- opnd(2)+opnd(3)		*/
  5     9 	sub		initial("000010010"b),	/* opnd(1) <- opnd(2)-opnd(3)		*/
  5    10 	mult		initial("000010011"b),	/* opnd(1) <- opnd(2)*opnd(3)		*/
  5    11 	div		initial("000010100"b),	/* opnd(1) <- opnd(2)/opnd(3)		*/
  5    12 	negate		initial("000010101"b),	/* opnd(1) <- -opnd(2)  		*/
  5    13 	exp		initial("000010110"b),	/* opnd(1) <- opnd(2) ** opnd(3)	*/
  5    14 
  5    15 	and_bits		initial("000100001"b),	/* opnd(1) <- opnd(2) & opnd(3)	*/
  5    16 	or_bits		initial("000100010"b),	/* opnd(1) <- opnd(2)|opnd(3)		*/
  5    17 	xor_bits		initial("000100011"b),	/* opnd(1) <- opnd(2) xor opnd(3)	*/
  5    18 	not_bits		initial("000100100"b),	/* opnd(1) <- ^opnd(2)		*/
  5    19 	cat_string	initial("000100101"b),	/* opnd(1) <- opnd(2)||opnd(3)	*/
  5    20 	bool_fun		initial("000100110"b),	/* opnd(1) <- bool(opnd(2),opnd(3),opnd(4)) */
  5    21 
  5    22 	assign		initial("000110001"b),	/* opnd(1) <- opnd(2)		*/
  5    23 	assign_size_ck	initial("000110010"b),	/* opnd(1) <- opnd(2)		*/
  5    24 	assign_zero	initial("000110011"b),	/* opnd(1) <- 0			*/
  5    25 	copy_words	initial("000110100"b),	/* move opnd(2) to opnd(1) by opnd(3) words */
  5    26 	copy_string	initial("000110101"b),	/* move opnd(2) to opnd(1) by opnd(3) units */
  5    27 	make_desc		initial("000110110"b),	/* opnd(1) <- descriptor(opnd(2),opnd(3)) */
  5    28 	assign_round	initial("000110111"b),	/* opnd(1) <- opnd(2) rounded		*/
  5    29 	pack		initial("000111000"b),	/* opnd(1) <- encode to picture opnd(2) */
  5    30 	unpack		initial("000111001"b),	/* opnd(1) <- decode from picture opnd(2) */
  5    31 
  5    32 	less_than		initial("001000100"b),	/* opnd(1) <- opnd(2) < opnd(3)	*/
  5    33 	greater_than	initial("001000101"b),	/* opnd(1) <- opnd(2) > opnd(3)	*/
  5    34 	equal		initial("001000110"b),	/* opnd(1) <- opnd(2) = opnd(3)	*/
  5    35 	not_equal		initial("001000111"b),	/* opnd(1) <- opnd(2) ^= opnd(3)	*/
  5    36 	less_or_equal	initial("001001000"b),	/* opnd(1) <- opnd(2) <= opnd(3)	*/
  5    37 	greater_or_equal	initial("001001001"b),	/* opnd(1) <- opnd(2) >= opnd(3)	*/
  5    38 
  5    39 	jump		initial("001010001"b),	/* go to opnd(1) unconditionally	*/
  5    40 	jump_true		initial("001010010"b),	/* go to opnd(1) if opnd(2) is not 0	*/
  5    41 	jump_false	initial("001010011"b),	/* go to opnd(1) if opnd(2) is all 0	*/
  5    42 	jump_if_lt	initial("001010100"b),	/* go to opnd(1) if opnd(2) < opnd(3)	*/
  5    43 	jump_if_gt	initial("001010101"b),	/* go to opnd(1) if opnd(2) > opnd(3)	*/
  5    44 	jump_if_eq	initial("001010110"b),	/* go to opnd(1) if opnd(2) = opnd(3)	*/
  5    45 	jump_if_ne	initial("001010111"b),	/* go to opnd(1) if opnd(2) ^= opnd(3)	*/
  5    46 	jump_if_le	initial("001011000"b),	/* go to opnd(1) if opnd(2) <= opnd(3)	*/
  5    47 	jump_if_ge	initial("001011001"b),	/* go to opnd(1) if opnd(2) >= opnd(3)	*/
  5    48 
  5    49 	std_arg_list	initial("001100001"b),	/* opnd(1) <- arglist(opnd(2) desclist(opnd(3)))	*/
  5    50 	return_words	initial("001100010"b),	/* return aggregate opnd(1), opnd(2) is length in words */
  5    51 	std_call		initial("001100011"b),	/* opnd(1) <- call opnd(2) with opnd(3)		*/
  5    52 	return_bits	initial("001100100"b),	/* return aggregate opnd(1), opnd(2) is length in bits */
  5    53 	std_entry		initial("001100101"b),	/* entry(opnd(1)... opnd(n))			*/
  5    54 	return_string	initial("001100110"b),	/* return string opnd(1) */
  5    55 	ex_prologue	initial("001100111"b),	/* execute the prologue -no operands-		*/
  5    56 	allot_auto	initial("001101000"b),	/* opnd(1) <- addrel(stack,opnd(2))		*/
  5    57 	param_ptr		initial("001101001"b),	/* opnd(1) <- ptr to opnd(2) in  block opnd(3)	*/
  5    58 	param_desc_ptr	initial("001101010"b),	/* opnd(1) <- ptr to opnd(2) in block opnd(3)	*/
  5    59 	std_return	initial("001101011"b),	/* return -no arguments-			*/
  5    60 	allot_ctl		initial("001101100"b),	/* allocate opnd(1) , length in words is opnd(2) 	*/
  5    61 	free_ctl		initial("001101101"b),	/* free opnd(1)				*/
  5    62 	stop		initial("001101110"b),	/* stop - terminate run unit			*/
  5    63 
  5    64 	mod_bit		initial("001110000"b),	/* opnd(1) <- mod(opnd(3),36),
  5    65*						   opnd(2) <- opnd(3) / 36		*/
  5    66 	mod_byte		initial("001110001"b),	/* opnd(1) <- mod(opnd(3),4),
  5    67*						   opnd(2) <- opnd(3) / 4		*/
  5    68 	mod_half		initial("001110010"b),	/* opnd(1) <- mod(opnd(3),2),
  5    69*						   opnd(2) <- opnd(3) / 2		*/
  5    70 	mod_word		initial("001110011"b),	/* TO BE DEFINED BY BLW			*/
  5    71 
  5    72 	bit_to_char	initial("010000000"b),	/* opnd(1) <- (opnd(2)+8)/9		*/
  5    73 	bit_to_word	initial("010000001"b),	/* opnd(1) <- (opnd(2)+35)/36		*/
  5    74 	char_to_word	initial("010000010"b),	/* opnd(1) <- (opnd(2)+3)/4		*/
  5    75 	half_to_word	initial("010000011"b),	/* opnd(1) <- (opnd(2)+1)/2		*/
  5    76 	word_to_mod2	initial("010000100"b),	/* opnd(1) <- (opnd(2)+1)/2*2		*/
  5    77 	word_to_mod4	initial("010000101"b),	/* opnd(1) <- (opnd(2)+3)/4*4		*/
  5    78 	word_to_mod8	initial("010000110"b),	/* opnd(1) <- (opnd(2)+7)/8*8		*/
  5    79 	rel_fun		initial("010000111"b),	/* opnd(1) <- rel(opnd(2))		*/
  5    80 	baseno_fun	initial("010001000"b),	/* opnd(1) <- baseno(opnd(2))		*/
  5    81 	desc_size		initial("010001001"b),	/* opnd(1) <- substr(opnd(2),13,24)	*/
  5    82 	bit_pointer	initial("010001010"b),	/* opnd(1) <- bit offset of opnd(2)	*/
  5    83 	index_before_fun	initial("010001011"b),	/* opnd(1) <- length of before(opnd(2),opnd(3)) */
  5    84 	index_after_fun	initial("010001100"b),	/* opnd(1) <- offset of after(opnd(2),opnd(3)) in opnd(2) */
  5    85 	verify_ltrim_fun	initial("010001101"b),	/* opnd(1) <- offset of ltrim(opnd(2),opnd(3)) in opnd(2) */
  5    86 	verify_rtrim_fun	initial("010001110"b),	/* opnd(1) <- length(opnd(2))-length(rtrim(opnd(2),opnd(3))) */
  5    87 	digit_to_bit	initial("010001111"b),	/* opnd(1) <- 9*opnd(2)/2		*/
  5    88 
  5    89 	ceil_fun		initial("010010000"b),	/* opnd(1) <- ceil(opnd(2))		*/
  5    90 	floor_fun		initial("010010001"b),	/* opnd(1) <- floor(opnd(2))		*/
  5    91 	round_fun		initial("010010010"b),	/* opnd(1) <- round(opnd(2))		*/
  5    92 	sign_fun		initial("010010011"b),	/* opnd(1) <- sign(opnd(2))		*/
  5    93 	abs_fun		initial("010010100"b),	/* opnd(1) <- abs(opnd(2))		*/
  5    94 	trunc_fun		initial("010010101"b),	/* opnd(1) <- trunc(opnd(2))		*/
  5    95 	byte_fun		initial("010010110"b),	/* opnd(1) <- byte(opnd(2))		*/
  5    96 	rank_fun		initial("010010111"b),	/* opnd(1) <- rank(opnd(2))		*/
  5    97 	index_rev_fun	initial("010011000"b),	/* opnd(1) <- index(reverse(opnd(2)),reverse(opnd(3))) */
  5    98 	search_rev_fun	initial("010011001"b),	/* opnd(1) <- search(reverse(opnd(2)),opnd(3)) */
  5    99 	verify_rev_fun	initial("010011010"b),	/* opnd(1) <- verify(reverse(opnd(2)),opnd(3)) */
  5   100 	wordno_fun	initial("010011011"b),        /* opnd(1) <- wordno (opnd(2)) */
  5   101 	segno_fun		initial("010011100"b),        /* opnd(1) <- segno (opnd(2)) */
  5   102 	bitno_fun           initial("010011101"b),        /* opnd(1) <- bitno (opnd(2)) */
  5   103 	charno_fun	initial("010011110"b),        /* opnd(1) <- charno (opnd(2)) */
  5   104 
  5   105 	index_fun		initial("010100000"b),	/* opnd(1) <- index(opnd(2),opnd(3))	*/
  5   106 	off_fun		initial("010100001"b),	/* opnd(1) <- offset(opnd(2),opnd(3))	*/
  5   107 	complex_fun	initial("010100010"b),	/* opnd(1) <- complex(opnd(2),opnd(3))	*/
  5   108 	conjg_fun		initial("010100011"b),	/* opnd(1) <- conjg(opnd(2),opnd(3))	*/
  5   109 	mod_fun		initial("010100100"b),	/* opnd(1) <- mod(opnd(2),opnd(3))	*/
  5   110 	repeat_fun	initial("010100101"b),	/* opnd(1) <- repeat(opnd(2),opnd(3))	*/
  5   111 	verify_fun	initial("010100110"b),	/* opnd(1) <- verify(opnd(2),opnd(3))	*/
  5   112 	translate_fun	initial("010100111"b),	/* opnd(1) <- translate(opnd(2),opnd(3))*/
  5   113 	real_fun   	initial("010101001"b),	/* opnd(1) <- real(opnd(2))		*/
  5   114 	imag_fun   	initial("010101010"b),	/* opnd(1) <- imag(opnd(2))		*/
  5   115 	length_fun	initial("010101011"b),	/* opnd(1) <- length(opnd(2))	*/
  5   116 	pl1_mod_fun	initial("010101100"b),	/* opnd(1) <- mod(opnd(2)) */
  5   117 	search_fun	initial("010101101"b),	/* opnd(1) <- search(opnd(2),opnd(3)) */
  5   118 	allocation_fun	initial("010101110"b),	/* opnd(1) <- allocation(opnd(2)) */
  5   119 	reverse_fun	initial("010101111"b),	/* opnd(1) <- reverse(opnd(2)) */
  5   120 
  5   121 	addr_fun		initial("010110000"b),	/* opnd(1) <- addr(opnd(2))		*/
  5   122 	addr_fun_bits	initial("010110001"b),	/* opnd(1) <- addr(opnd(2))		*/
  5   123 	ptr_fun		initial("010110010"b),	/* opnd(1) <- ptr(opnd(2),opnd(3))	*/
  5   124 	baseptr_fun	initial("010110011"b),	/* opnd(1) <- baseptr(opnd(2))	*/
  5   125 	addrel_fun	initial("010110100"b),	/* opnd(1) <- addrel(opnd(2),opnd(3))	*/
  5   126 	codeptr_fun	initial("010110101"b),	/* opnd(1) <- codeptr(opnd(2))	*/
  5   127 	environmentptr_fun	initial("010110110"b),	/* opnd(1) <- environmentptr(opnd(2))	*/
  5   128 	stackbaseptr_fun	initial("010110111"b),	/* opnd(1) is ptr to base of current stack	*/
  5   129 	stackframeptr_fun	initial("010111000"b),	/* opnd(1) is ptr to current block's stack frame	*/
  5   130 	setcharno_fun	initial("010111001"b),	/* opnd(1) <- opnd(2) with charno opnd(3) */
  5   131 	addcharno_fun	initial("010111010"b),	/* opnd(1) <- opnd(2) with charno = charno + opnd(3) */
  5   132 	setbitno_fun	initial("010111011"b),	/* setcharno for bitsno */
  5   133 	addbitno_fun	initial("010111100"b),	/* addcharno for bitno */
  5   134 
  5   135 	min_fun		initial("011000000"b),	/* opnd(1) <- min(opnd(1),opnd(2),...)	*/
  5   136 	max_fun		initial("011000001"b),	/* opnd(1) <- max(opnd(1),opnd(2),...)	*/
  5   137 
  5   138 	stack_ptr		initial("011010001"b),	/* opnd(1) <- stack frame ptr		*/
  5   139 	empty_area	initial("011010010"b),	/* empty opnd(1), length in words is opnd(2) */
  5   140 	enable_on		initial("011010100"b),	/* opnd(1) is the cond name
  5   141*						   opnd(2) is the file name
  5   142*						   opnd(3) is the block	*/
  5   143 	revert_on		initial("011010101"b),	/* opnd(1) is the cond name,
  5   144*						   opnd(2) is the file name	*/
  5   145 	signal_on		initial("011010110"b),	/* opnd(1) is the cond name
  5   146*						   opnd(2) is the file name */
  5   147 
  5   148 	lock_fun		initial("011010111"b),	/* opnd(1) <- stac(opnd(2),opnd(3))	*/
  5   149 	stacq_fun		initial("011011000"b),	/* opnd(1) is result, opnd(2) is ptr to lock word,
  5   150*						   opnd(3) is old value, (4) is new value. */
  5   151 	clock_fun		initial("011011001"b),	/* opnd(1) is the clock time		*/
  5   152 	vclock_fun	initial("011011010"b),	/* opnd(1) is the virtual clock time	*/
  5   153 
  5   154 	bound_ck		initial("011100000"b),	/* opnd(1) <- opnd(2) if opnd(3) <= opnd(2) <= opnd(4) */
  5   155 	range_ck		initial("011100001"b),	/* opnd(1) <- opnd(2) if opnd(3) <= opnd(2) <= opnd(4) */
  5   156 	loop		initial("011100010"b),	/* do opnd(1) for opnd(2) from opnd(3) to opnd(4) by 1,
  5   157*						   opnd(5) is the list */
  5   158 	join		initial("011100011"b),	/* do opnd(1), opnd(2) ... opnd(n)	*/
  5   159 	allot_based	initial("011100100"b),	/* allocate opnd(2) words in opnd(3), set opnd(1) */
  5   160 	free_based	initial("011100101"b),	/* free opnd(1) in opnd(3), length is opnd(2) words */
  5   161 
  5   162 	r_parn		initial("011110001"b),	/* format op code			*/
  5   163 	l_parn		initial("011110010"b),
  5   164 	r_format		initial("011110011"b),
  5   165 	c_format		initial("011110100"b),
  5   166 	f_format		initial("011110101"b),
  5   167 	e_format		initial("011110110"b),
  5   168 	b_format		initial("011110111"b),
  5   169 	a_format		initial("011111000"b),
  5   170 	x_format		initial("011111001"b),
  5   171 	skip_format	initial("011111010"b),
  5   172 	column_format	initial("011111011"b),
  5   173 	page_format	initial("011111100"b),
  5   174 	line_format	initial("011111101"b),
  5   175 	picture_format	initial("011111110"b),
  5   176 	bn_format		initial("011111111"b),	/* bit format, length(opnd(2)), radix factor(opnd(3)) */
  5   177 
  5   178 	get_list_trans	initial("100000000"b),	/* getlist(opnd(2) with desc(opnd(1)))	*/
  5   179 	get_edit_trans	initial("100000001"b),	/* getedit(opnd(2) with desc(opnd(1)))	*/
  5   180 	get_data_trans	initial("100000010"b),	/* getdata(opnd(1) to opnd(n))	*/
  5   181 	put_list_trans	initial("100000011"b),	/* putlist(opnd(2) with desc(opnd(1)))	*/
  5   182 	put_edit_trans	initial("100000100"b),	/* putedit(opnd(2) with desc(opnd(1)))	*/
  5   183 	put_data_trans	initial("100000101"b),	/* putdata(opnd(2)) with subscript-list opnd(1) */
  5   184 	terminate_trans	initial("100000110"b),	/* terminate stream transmission	*/
  5   185 	stream_prep	initial("100000111"b),	/* initiate stream transmission	*/
  5   186 	record_io		initial("100001000"b),	/* perform record io operation	*/
  5   187 	fortran_read	initial("100001001"b),	/* A complete read statement		*/
  5   188 	fortran_write	initial("100001010"b),	/* A complete write statement		*/
  5   189 	ftn_file_manip	initial("100001011"b),	/* endfile,backspace,rewind,etc.	*/
  5   190 	ftn_trans_loop	initial("100001100"b),	/* An implied do in i/o list		*/
  5   191 	put_control	initial("100001101"b),	/* put control opnd(1) opnd(2) times	*/
  5   192 	put_field		initial("100001110"b),	/* putlist(opnd(2)) of length(opnd(1))	*/
  5   193 	put_field_chk	initial("100001111"b),	/* putlist(op(2)) of len(op(1)) check char index(op(3)) */
  5   194 
  5   195 /* These operators are produced by the parse but are not used as input to the code generator.	*/
  5   196 /* They are processed by the semantic translator.						*/
  5   197 
  5   198 	return_value	initial("100010010"b),	/* return(opnd(1))			*/
  5   199 	allot_var		initial("100010011"b),	/* allot opnd(1) in opnd(2)		*/
  5   200 	free_var		initial("100010100"b),	/* free opnd(1) out of opnd(2)	*/
  5   201 	get_file		initial("100010101"b),	/* opnd(1) is filename,opnd(2) is copy	*/
  5   202 						/* opnd(3) is skip, opnd(4) is list	*/
  5   203 	get_string	initial("100010110"b),	/* opnd(1) is string,opnd(2) is list	*/
  5   204 	put_file		initial("100010111"b),	/* opnd(1) is filename,opnd(2) is page	*/
  5   205 						/* opnd(3) is skip,opnd(4) is line	*/
  5   206 	put_string	initial("100011000"b),	/* opnd(1) is string,opnd(2) is list	*/
  5   207 	open_file		initial("100011001"b),
  5   208 	close_file	initial("100011010"b),
  5   209 	read_file		initial("100011011"b),
  5   210 	write_file	initial("100011100"b),
  5   211 	locate_file	initial("100011101"b),
  5   212 	do_fun		initial("100011110"b),	/* opnd(1) is join of a list		*/
  5   213 						/* opnd(2) is control variable ref	*/
  5   214 						/* opnd(3) is specification operator	*/
  5   215 	do_spec		initial("100011111"b),	/* opnd(1) to opnd(2) by opnd(3) 	*/
  5   216 						/* repeat opnd(4) while opnd(5)	*/
  5   217 						/* opnd(6) is next specification	*/
  5   218 
  5   219 	rewrite_file	initial("100100000"b),
  5   220 	delete_file	initial("100100001"b),
  5   221 	unlock_file	initial("100100010"b),
  5   222 	lock_file		initial("100100011"b),
  5   223 	refer		initial("100100101"b),	/* opnd(1) refer(opnd(2))		*/
  5   224 	prefix_plus	initial("100100110"b),	/* opnd(1) <- +opnd(2)		*/
  5   225 	nop		initial("100100111"b),	/* no-op */
  5   226 	assign_by_name	initial("100101000"b),	/* opnd(1) <- opnd(2),by name		*/
  5   227 
  5   228 /* These operators are produced by the semantic translator in processing the math
  5   229*   builtin functions and are used as input to the code generator			*/
  5   230 
  5   231 	sqrt_fun		initial("100110000"b),	/* opnd(1) <- sqrt(opnd(2))	*/
  5   232 	sin_fun		initial("100110001"b),	/* opnd(1) <- sin(opnd(2))	*/
  5   233 	sind_fun		initial("100110010"b),	/* opnd(1) <- sind(opnd(2))	*/
  5   234 	cos_fun		initial("100110011"b),	/* opnd(1) <- cos(opnd(2))	*/
  5   235 	cosd_fun		initial("100110100"b),	/* opnd(1) <- cosd(opnd(2))	*/
  5   236 	tan_fun		initial("100110101"b),	/* opnd(1) <- tan(opnd(2))	*/
  5   237 	tand_fun		initial("100110110"b),	/* opnd(1) <- tand(opnd(2))	*/
  5   238 	asin_fun		initial("100110111"b),	/* opnd(1) <- asin(opnd(2))	*/
  5   239 	asind_fun		initial("100111000"b),	/* opnd(1) <- asind(opnd(2))	*/
  5   240 	acos_fun		initial("100111001"b),	/* opnd(1) <- acos(opnd(2))	*/
  5   241 	acosd_fun		initial("100111010"b),	/* opnd(1) <- acosd(opnd(2))	*/
  5   242 	atan_fun		initial("100111011"b),	/* opnd(1) <- atan(opnd(2)[,opnd(3)])	*/
  5   243 	atand_fun		initial("100111100"b),	/* opnd(1) <- atand(opnd(2)[,opnd(3)])	*/
  5   244 	log2_fun		initial("100111101"b),	/* opnd(1) <- log2(opnd(2))	*/
  5   245 	log_fun		initial("100111110"b),	/* opnd(1) <- log(opnd(2))	*/
  5   246 	log10_fun		initial("100111111"b),	/* opnd(1) <- log10(opnd(2))	*/
  5   247 
  5   248 	exp_fun		initial("101000000"b))	/* opnd(1) <- exp(opnd(2))	*/
  5   249 
  5   250 			bit(9) aligned internal static options(constant);
  5   251 
  5   252 /* END INCLUDE FILE ... op_codes.incl.pl1 */
       83 
  6     1 /* BEGIN INCLUDE FILE ... nodes.incl.pl1 */
  6     2 
  6     3 /* Modified: 26 Dec 1979 by PCK to implement by name assignment */
  6     4 
  6     5 dcl (	block_node		initial("000000001"b),
  6     6 	statement_node		initial("000000010"b),
  6     7 	operator_node		initial("000000011"b),
  6     8 	reference_node		initial("000000100"b),
  6     9 	token_node		initial("000000101"b),
  6    10 	symbol_node		initial("000000110"b),
  6    11 	context_node		initial("000000111"b),
  6    12 	array_node		initial("000001000"b),
  6    13 	bound_node		initial("000001001"b),
  6    14 	format_value_node		initial("000001010"b),
  6    15 	list_node			initial("000001011"b),
  6    16 	default_node		initial("000001100"b),
  6    17 	machine_state_node		initial("000001101"b),
  6    18 	source_node		initial("000001110"b),
  6    19 	label_node		initial("000001111"b),
  6    20 	cross_reference_node	initial("000010000"b),
  6    21 	sf_par_node		initial("000010001"b),
  6    22 	temporary_node		initial("000010010"b),
  6    23 	label_array_element_node	initial("000010011"b),
  6    24 	by_name_agg_node		initial("000010100"b))
  6    25 				bit(9) internal static aligned options(constant);
  6    26 
  6    27 dcl	1 node			based aligned,
  6    28 	2 type			unal bit(9),
  6    29 	2 source_id		unal structure,
  6    30 	  3 file_number		bit(8),
  6    31 	  3 line_number		bit(14),
  6    32 	  3 statement_number	bit(5);
  6    33 
  6    34 /* END INCLUDE FILE ... nodes.incl.pl1 */
       84 
       85 
       86 	/*  ON COMPILATION OF STRING EXPRESSIONS
       87*
       88*	   Short string expressions (those of constant length <= 2 words) are
       89*	   evaluated in the A or the AQ and present no problems of special
       90*	   interest.
       91*
       92*	   Long string expressions must be evaluated in string temporaries
       93*	   which are allocated by string_temp.  There are 2 types of string
       94*	   temps -- (1) those that are allocated in the stack at compile-
       95*	   time like short temps, (2) those that are allocated by stack
       96*	   extension at runtime.  string_temp decides which type of string
       97*	   temporary to use.  The first type of temp is used if the reference
       98*	   count of operand(1) is greater than 1 and it has a constant length.
       99*	   Otherwise, a stack extension is used.  A  temp acquired by stack
      100*	   extension is recognized by having reference.value_in.string_aq ON
      101*	   (in which case, it is considered to be in the string aq) or by having
      102*	   reference.address_in.storage ON.
      103*
      104*	   string_temp may try to save on execution time by reusing or extending
      105*	   previously allocated stack extension temporaries.  If operand(1)
      106*	   requires a stack extension, operand(2) is in the string aq, and the
      107*	   relation between the lengths of operand(2) and operand(3) is known
      108*	   at compile-time (or one of the operands is short), then string_temp
      109*	   will reuse operand(2)'s temp if the length of operand(1) and operand(2)
      110*	   is the same, or extend operand(2)'s temp otherwise.  IF the previously
      111*	   mentioned conditions are not satisfied, new temporary space must be
      112*	   allocated.
      113*
      114*	   When compile_exp is called for a long string expression, the location
      115*	   of the string temp is not saved in storage.  When compile_exp$save or
      116*	   compile_exp$save_exp is called for a long string expression and the
      117*	   temp has been acquired by stack extension, the address of the temp is
      118*	   saved in storage after expression evaluation.  This allows one to find
      119*	   the temp if new stack extensions are made.  After calling compile_exp,
      120*	   compile_exp$save, or compile_exp$save_exp on a long string expression,
      121*	   the result reference count is left unchanged.
      122*
      123*	   When string_op is processing a long string_expression,
      124*	   it may call compile_exp for at most one long string expression, since
      125*	   evaluating the other may cause other stack extensions.  compile_exp
      126*	   must not be called  if other activity may affect the string aq or PR2.
      127*	   In this latter case, compile_exp$save[_exp] must be called.  compile_exp
      128*	   is also not called unless there is a chance that string_temp will be able
      129*	   to reuse or extend an existing temp.
      130**/
      131 
      132 
      133 begin:	p = node_pt;
      134 	q2 = p -> operand(2);
      135 	code = p_code;
      136 
      137 	op_code = fixed(substr(p -> operator.op_code,6,4),4);
      138 
      139 	p1 = ref(1);
      140 	p2 = ref(2);
      141 
      142 	if op_code ^= not
      143 	then do;
      144 	     q3 = p -> operand(3);
      145 	     p3 = ref(3);
      146 	     end;
      147 
      148 	for_test = cg_stat$for_test_called;
      149 	doing_andnot = "0"b;
      150 
      151 	/* encode left size and dispatch on operator */
      152 
      153 	if p2 -> reference.long_ref | p2 -> reference.varying_ref then s2 = 3;
      154 	else s2 = 2*fixed(p2 -> reference.c_length > bits_per_word,1);
      155 
      156 	goto switch(op_code);
      157 
      158 	/* have not operation */
      159 
      160 switch(4):
      161 not_op:	if code ^= 0
      162 	then 
      163 
      164 	     /* atm, generate move-not_bits for long atm or
      165*	        load short or double operand */
      166 
      167 	     if s2 <= 2
      168 	     then do;
      169 		call load(p2,s2);
      170 complement:	call expmac$one((era),c_a((p2 -> reference.c_length),5),s2);
      171 		end;
      172 	     else do;
      173 comp_long:	p1 = string_temp(p,p2,null);
      174 		if for_test then l_op = test_not; else l_op = move_not_bits;
      175 		call expmac$eis(l_op,p2);
      176 		end;
      177 
      178 	else do;
      179 
      180 	     /* exp, compile exp then generate comp_bits op
      181*	        or actually complement bits in ac */
      182 
      183 	     call compile_exp(q2);
      184 	     if s2 > 2 then go to comp_long;
      185 	     else goto complement;
      186 	     end;
      187 
      188 	goto string_done;
      189 
      190 	/* Operation is EXCLUSIVE OR */
      191 
      192 switch(3):
      193 xor_op:	op = era;
      194 	call check_lengths;
      195 	if for_test then l_op = test_xor; else l_op = move_xor;
      196 	load_double = 2;
      197 	goto set_s3;
      198 
      199 	/* operation is OR */
      200 
      201 switch(2):
      202 or_op:	op = ora;
      203 	call check_lengths;
      204 	if for_test then l_op = test_or; else l_op = move_or;
      205 	load_double = 2;
      206 	goto set_s3;
      207 
      208 	/* operation is AND */
      209 
      210 switch(1):
      211 and_op:	if for_test
      212 	then do;
      213 	     op = and_for_test;
      214 	     l_op = test_and;
      215 	     end;
      216 	else do;
      217 	     op = ana;
      218 	     l_op = move_and;
      219 	     end;
      220 
      221 set_s3:	if p3 -> reference.long_ref | p3 -> reference.varying_ref then s3 = 3;
      222 	else s3 = 2*fixed(p3 -> reference.c_length > bits_per_word,1);
      223 
      224 	if op_code = and
      225 	then do;
      226 	     load_double = 2*fixed(s2 = s3,1);
      227 
      228 	     /* See if we have a & ^ b.  If we do, we can shorten
      229*	        3 instructions to 2 */
      230 
      231 	     if can_do_andnot(which_andnot)
      232 	     then do;
      233 		atom(2) = code >= 2;
      234 		atom(3) = mod(code,2) ^= 0;
      235 
      236 		if which_andnot = 0
      237 		     then call setup_andnot(p2,q2,s2,atom(2));
      238 		     else call setup_andnot(p3,q3,s3,atom(3));
      239 
      240 		code = fixed(atom(2) || atom(3), 2);
      241 
      242 		call check_lengths;
      243 
      244 		if for_test
      245 		     then l_op = test_andnot(which_andnot);
      246 		     else l_op = move_andnot(which_andnot);
      247 
      248 		doing_andnot = "1"b;
      249 		end;
      250 	     end;
      251 
      252 	/* at this point the left and right sizes are coded in
      253*	   s2 and s3 as 0: short, 2: double, 3: long.  now
      254*	   dispatch on context of operator node */
      255 
      256 	goto ao_sw(code);
      257 
      258 	/* operation is atom-atom, reverse operands if
      259*	   right operand longer than left */
      260 
      261 ao_sw(3):
      262 ao_aa:	if p3 -> reference.value_in.a then call flip_rands;
      263 
      264 	if s2 < s3 then call flip_rands;
      265 
      266 	/* check for long operand(s) */
      267 
      268 	if s2 > 2 then goto ao_aa_l;
      269 
      270 	/* at this point right operand is shorter or same,
      271*	   s3 = 0 for single, s3 = 2 for double */
      272 
      273 	call load(p2,load_double);
      274 ao_aa_1:	if op_code = and & s3 < s2 then call aq_man$clear_q;
      275 	call expmac$one(op,p3,s3);
      276 
      277 	goto string_done;
      278 
      279 	/* left (and possible right) operand is long */
      280 
      281 ao_aa_l:	p1 = string_temp(p,p2,p3);
      282 
      283 ao_aa_l1:	if s3 > 2 | op_code = and | ^ p1 -> reference.aligned_for_store_ref | for_test 
      284 	then do;
      285 
      286 	     /* right operand is long */
      287 
      288 	     call long_op;
      289 	     end;
      290 	else do;
      291 
      292 	     /* right operand is short, generate
      293*	        xxsa or xxsa_xxsq macro */
      294 
      295 	     call load(p3,2);
      296 ao_aa_l3:
      297 	     if p1 -> reference.temp_ref
      298 	     then if ^ p1 -> reference.shared
      299 		then p1 -> reference.ref_count = p1 -> reference.ref_count + 1;
      300 	     call expmac$one(op+3,p1,s3);
      301 	     machine_state.indicators = -1;
      302 	     end;
      303 
      304 	goto string_done;
      305 
      306 	/* operation is atom-expression, reverse */
      307 
      308 ao_sw(2):
      309 ao_ae:	call flip_rands;
      310 
      311 	/* operation is expression-atom */
      312 
      313 ao_sw(1):
      314 ao_ea:	if s2 > 2
      315 	then do;
      316 
      317 	     /* left is long, compile, then treat like
      318*	        atom-atom case */
      319 
      320 	     if p1 -> reference.length = null
      321 	      | (p2 -> reference.length = p3 -> reference.length
      322 	         & ^ p2 -> reference.varying_ref
      323 	         & ^ p3 -> reference.varying_ref)
      324 		then call compile_exp(q2);
      325 		else p2 = compile_exp$save(q2);
      326 	     go to ao_aa_l;
      327 	     end;
      328 
      329 	/* left ^long, check for right long */
      330 
      331 	if s3 > 2
      332 	then do;
      333 
      334 	     /* if right is really an expression, save value and treat
      335*	        like atom-atom case */
      336 
      337 	     p2 = compile_exp$save_exp(q2);
      338 	     call flip_rands;
      339 	     goto ao_aa_l;
      340 	     end;
      341 
      342 	/* neither operand is long */
      343 
      344 	if ^ p3 -> reference.aligned_ref then p3 = compile_exp$save(p3);
      345 	call compile_exp(q2);
      346 	if s2 < s3 | (s3 ^= s2 & op_code = and) then call aq_man$clear_q;
      347 	call expmac$one(op,p3,s3);
      348 
      349 	goto string_done;
      350 
      351 	/* operation is expression-expression */
      352 
      353 ao_sw(0):
      354 ao_ee:	if s2 < s3 then call flip_rands;
      355 
      356 	/* at this point, right operand is shorter */
      357 
      358 	if s3 > 2 then goto ao_ee_1;
      359 
      360 	/* right operand is not long, left may be */
      361 
      362 	if s2 > 2 then go to ao_ee_1;
      363 
      364 	/* left is also not long */
      365 
      366 	p3 = compile_exp$save(q3);
      367 	call compile_exp(q2);
      368 	goto ao_aa_1;
      369 
      370 	/* both are long, check for the situation where the relation between
      371*	   the lengths is unknown at compile-time */
      372 
      373 ao_ee_1:	if p2 -> reference.length ^= p3 -> reference.length
      374 	 | p2 -> reference.varying_ref
      375 	 | p3 -> reference.varying_ref
      376 	then do;
      377 
      378 	     /* compile right expression, then save temp */
      379 
      380 	     p3 = compile_exp$save(q3);
      381 
      382 	     /* compile left expression and save pointer */
      383 
      384 	     p2 = compile_exp$save(q2);
      385 
      386 	     /* since make_addressable will recognize the
      387*	        altered values of p2 and p3, we can treat like
      388*	        atom-atom case now */
      389 
      390 	     goto ao_aa_l;
      391 	     end;
      392 
      393 	if p2 -> reference.c_length < p3 -> reference.c_length then call flip_rands;
      394 
      395 	/* both strings are constant or equal size, size2 >= size3 */
      396 
      397 	p3 = compile_exp$save(q3);
      398 	call compile_exp(q2);
      399 	p1 = string_temp(p,p2,p3);
      400 	call long_op;
      401 
      402 	/* string operator done */
      403 
      404 string_done:
      405 	if ^ p1 -> reference.long_ref
      406 	     then a_reg.size = p1 -> reference.c_length;
      407 	return;
      408 
      409 can_do_andnot: proc(which_andnot) returns(bit(1) aligned);
      410 
      411 /* determines whether we have a & ^ b, which can be optimized. */
      412 
      413 dcl	     which_andnot fixed bin(15);	/* 0, if operand(2) is not_bits
      414*					   1, if operand(3) is not_bits (output) */
      415 
      416 dcl	     i fixed bin;
      417 dcl	     q ptr;
      418 
      419 	     if p1 -> reference.long_ref
      420 	     then do i = 2 to 3;
      421 		q = p -> operand(i);
      422 		if q -> node.type = operator_node
      423 		then if q -> operator.op_code = not_bits
      424 		then if ^ q -> operand(1) -> reference.evaluated
      425 		then if q -> operand(1) -> reference.ref_count <= 1
      426 		then do;
      427 		     which_andnot = i - 2;
      428 		     return("1"b);
      429 		     end;
      430 		end;
      431 
      432 	     return("0"b);
      433 
      434 	end /* can_do_andnot */;
      435 
      436 setup_andnot:  proc(p_new,q,s,atom);
      437 
      438 /* sets up string_op vars for andnot */
      439 
      440 dcl	     p_new ptr,	/* new ref node */
      441 	     q ptr,	/* new opnd */
      442 	     s fixed bin(15),	/* new length code */
      443 	     atom bit(1) aligned;
      444 
      445 	     q = p -> operand(which_andnot+2) -> operand(2);
      446 
      447 	     p_new = prepare_operand(q,1,atom);
      448 
      449 	     if p_new -> reference.long_ref | p_new -> reference.varying_ref
      450 		then s = 3;
      451 		else s = 2 * fixed(p_new -> reference.c_length > bits_per_word, 1);
      452 
      453 	     call adjust_ref_count((p -> operand(which_andnot+2) -> operand(1)), -1);
      454 
      455 	     end /* setup_andnot */;
      456 
      457 flip_rands:    proc;
      458 
      459 dcl	     p ptr, s fixed;
      460 
      461 	     p = p2; p2 = p3; p3 = p;
      462 	     p = q2; q2 = q3; q3 = p;
      463 	     s = s2; s2 = s3; s3 = s;
      464 
      465 	     if doing_andnot
      466 	     then do;
      467 		which_andnot = mod(which_andnot+1,2);
      468 		if for_test
      469 		     then l_op = test_andnot(which_andnot);
      470 		     else l_op = move_andnot(which_andnot);
      471 		end;
      472 
      473 	     end /* flip_rands */;
      474 
      475 
      476 check_lengths:	proc;
      477 
      478 	     if p1 -> reference.long_ref
      479 	     then if for_test
      480 		then if p2 -> reference.length ^= p3 -> reference.length
      481 		      | p2 -> reference.c_length ^= p3 -> reference.c_length
      482 		      | p2 -> reference.varying_ref
      483 		      | p3 -> reference.varying_ref
      484 		     then for_test, cg_stat$for_test_called = "0"b;
      485 
      486 	     end /* check_lengths */;
      487 
      488 
      489 long_op:	     proc;
      490 
      491 	     call expmac$eis(l_op,p3);
      492 
      493 	     end /* long_op */;
      494 
      495 	end /* string_op */;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/03/83  1009.4  string_op.pl1                     >spec>on>pl128d>string_op.pl1
79           1    10/25/79  1645.8  cgsystem.incl.pl1                 >ldd>include>cgsystem.incl.pl1
80           2    07/21/80  1546.3  reference.incl.pl1                >ldd>include>reference.incl.pl1
81           3    07/21/80  1546.3  operator.incl.pl1                 >ldd>include>operator.incl.pl1
82           4    11/13/79  1015.8  machine_state.incl.pl1            >ldd>include>machine_state.incl.pl1
83           5    04/07/83  1635.0  op_codes.incl.pl1                 >ldd>include>op_codes.incl.pl1
84           6    07/21/80  1546.3  nodes.incl.pl1                    >ldd>include>nodes.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a                        11(09)        based           bit(1)                   level 4 packed unaligned dcl 2-3 ref 261
a_reg                     3            based           structure                level 2 dcl 4-6
adjust_ref_count                000030 constant        entry                    external dcl 44 ref 453
aligned_for_store_ref
                         13(02)        based           bit(1)                   level 3 packed unaligned dcl 2-3 ref 283
aligned_ref              12(07)        based           bit(1)                   level 3 packed unaligned dcl 2-3 ref 344
ana                                    constant        fixed bin(15,0)          initial dcl 62 ref 217
and                                    constant        fixed bin(17,0)          initial dcl 59 ref 224 274 283 346
and_for_test                           constant        fixed bin(15,0)          initial dcl 62 ref 213
aq_man$clear_q                  000016 constant        entry                    external dcl 44 ref 274 346
atom                                   parameter       bit(1)                   dcl 440 in procedure "setup_andnot" set ref 436 447*
atom                            000120 automatic       bit(1)                   array dcl 37 in procedure "string_op" set ref 233*
                                                                                  234* 236* 238* 240 240
bits                     12(06)        based           structure                level 2 packed unaligned dcl 2-3
bits_per_word                          constant        fixed bin(8,0)           initial dcl 1-5 ref 154 222 451
c_a                             000014 constant        entry                    external dcl 44 ref 170 170
c_length                  2            based           fixed bin(24,0)          level 2 dcl 2-3 ref 154 170 170 222 393 393 404 451
                                                                                  478 478
cg_stat$for_test_called         000010 external static bit(1)                   unaligned dcl 34 set ref 148 478*
cg_static_$m_s_p                000040 external static pointer                  dcl 4-3 ref 4-3
code                            000116 automatic       fixed bin(2,0)           dcl 37 set ref 135* 160 233 234 240* 256
compile_exp                     000032 constant        entry                    external dcl 44 ref 183 320 345 367 398
compile_exp$save                000034 constant        entry                    external dcl 44 ref 325 344 366 380 384 397
compile_exp$save_exp            000036 constant        entry                    external dcl 44 ref 337
doing_andnot                    000115 automatic       bit(1)                   dcl 37 set ref 149* 248* 465
era                                    constant        fixed bin(15,0)          initial dcl 62 ref 170 192
evaluated                12(13)        based           bit(1)                   level 3 packed unaligned dcl 2-3 ref 422
expmac$eis                      000022 constant        entry                    external dcl 44 ref 175 491
expmac$one                      000024 constant        entry                    external dcl 44 ref 170 275 300 347
fixed                                                  builtin function         dcl 57 ref 137 154 222 226 240 451
for_test                        000114 automatic       bit(1)                   dcl 37 set ref 148* 174 195 204 210 244 283 468 478
                                                                                  478*
i                               000142 automatic       fixed bin(17,0)          dcl 416 set ref 419* 421 427*
indicators                1            based           fixed bin(17,0)          level 2 dcl 4-6 set ref 301*
info                     11            based           structure                level 2 packed unaligned dcl 2-3
l_op                            000125 automatic       fixed bin(15,0)          dcl 37 set ref 174* 174* 175* 195* 195* 204* 204*
                                                                                  214* 218* 244* 246* 468* 470* 491*
length                    6            based           pointer                  level 2 packed unaligned dcl 2-3 ref 320 320 320 373
                                                                                  373 478 478
load                            000012 constant        entry                    external dcl 44 ref 169 273 295
load_double                     000126 automatic       fixed bin(15,0)          dcl 37 set ref 196* 205* 226* 273*
long_ref                 12(08)        based           bit(1)                   level 3 packed unaligned dcl 2-3 ref 153 221 404 419
                                                                                  449 478
m_s_p                           000132 automatic       pointer                  initial dcl 4-3 set ref 301 404 4-3*
machine_state                          based           structure                level 1 dcl 4-6
more_bits                13            based           structure                level 2 packed unaligned dcl 2-3
move_and                               constant        fixed bin(15,0)          initial dcl 62 ref 218
move_andnot                     000012 constant        fixed bin(15,0)          initial array dcl 62 ref 246 470
move_not_bits                          constant        fixed bin(15,0)          initial dcl 62 ref 174
move_or                                constant        fixed bin(15,0)          initial dcl 62 ref 204
move_xor                               constant        fixed bin(15,0)          initial dcl 62 ref 195
node                                   based           structure                level 1 dcl 6-27
node_pt                                parameter       pointer                  dcl 30 ref 28 133
not                                    constant        fixed bin(17,0)          initial dcl 59 ref 142
not_bits                               constant        bit(9)                   initial dcl 5-8 ref 422
null                                                   builtin function         dcl 57 ref 173 173 320
op                              000124 automatic       fixed bin(15,0)          dcl 37 set ref 192* 201* 213* 217* 275* 300 347*
op_code                   0(09)        based           bit(9)                   level 2 in structure "operator" packed unaligned
                                                                                  dcl 3-6 in procedure "string_op" ref 137 422
op_code                         000127 automatic       fixed bin(15,0)          dcl 37 in procedure "string_op" set ref 137* 142 156
                                                                                  224 274 283 346
operand                   1            based           pointer                  array level 2 packed unaligned dcl 3-6 ref 134 144
                                                                                  421 422 422 445 445 453 453
operator                               based           structure                level 1 dcl 3-6
operator_node                          constant        bit(9)                   initial dcl 6-5 ref 422
ora                                    constant        fixed bin(15,0)          initial dcl 62 ref 201
p                               000162 automatic       pointer                  dcl 459 in procedure "flip_rands" set ref 461* 461
                                                                                  462* 462
p                               000100 automatic       pointer                  dcl 37 in procedure "string_op" set ref 133* 134 137
                                                                                  144 173* 281* 399* 421 445 453
p1                              000102 automatic       pointer                  dcl 37 set ref 139* 173* 281* 283 296 296 296 296
                                                                                  300* 320 399* 404 404 419 478
p2                              000104 automatic       pointer                  dcl 37 set ref 140* 153 153 154 169* 170 170 173*
                                                                                  175* 236* 273* 281* 320 320 325* 337* 373 373 384*
                                                                                  393 399* 461 461* 478 478 478
p3                              000106 automatic       pointer                  dcl 37 set ref 145* 221 221 222 238* 261 275* 281*
                                                                                  295* 320 320 344 344* 344* 347* 366* 373 373 380*
                                                                                  393 397* 399* 461 461* 478 478 478 491*
p_code                                 parameter       fixed bin(15,0)          dcl 30 ref 28 135
p_new                                  parameter       pointer                  dcl 440 set ref 436 447* 449 449 451
prepare_operand                 000026 constant        entry                    external dcl 44 ref 447
q                               000144 automatic       pointer                  dcl 417 in procedure "can_do_andnot" set ref 421*
                                                                                  422 422 422 422
q                                      parameter       pointer                  dcl 440 in procedure "setup_andnot" set ref 436 445*
                                                                                  447*
q2                              000110 automatic       pointer                  dcl 37 set ref 134* 183* 236* 320* 325* 337* 345*
                                                                                  367* 384* 398* 462 462*
q3                              000112 automatic       pointer                  dcl 37 set ref 144* 238* 366* 380* 397* 462 462*
ref                                    defined         pointer                  array dcl 37 ref 139 140 145
ref_count                 0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 2-3 set ref 296* 296
                                                                                  422
reference                              based           structure                level 1 dcl 2-3
refs                                   parameter       pointer                  array dcl 30 ref 28 139 139 140 140 145 145
s                                      parameter       fixed bin(15,0)          dcl 440 in procedure "setup_andnot" set ref 436 449*
                                                                                  451*
s                               000164 automatic       fixed bin(17,0)          dcl 459 in procedure "flip_rands" set ref 463* 463
s2                              000122 automatic       fixed bin(15,0)          dcl 37 set ref 153* 154* 160 169* 170* 184 226 236*
                                                                                  264 268 274 313 346 346 353 362 463 463*
s3                              000123 automatic       fixed bin(15,0)          dcl 37 set ref 221* 222* 226 238* 264 274 275* 283
                                                                                  300* 331 346 346 347* 353 358 463 463*
shared                    0(11)        based           bit(1)                   level 2 packed unaligned dcl 2-3 ref 296
size                     16            based           fixed bin(8,0)           level 3 dcl 4-6 set ref 404*
string_temp                     000020 constant        entry                    external dcl 44 ref 173 281 399
substr                                                 builtin function         dcl 57 ref 137
temp_ref                 12(11)        based           bit(1)                   level 3 packed unaligned dcl 2-3 ref 296
test_and                               constant        fixed bin(15,0)          initial dcl 62 ref 214
test_andnot                     000010 constant        fixed bin(15,0)          initial array dcl 62 ref 244 468
test_not                               constant        fixed bin(15,0)          initial dcl 62 ref 174
test_or                                constant        fixed bin(15,0)          initial dcl 62 ref 204
test_xor                               constant        fixed bin(15,0)          initial dcl 62 ref 195
type                                   based           bit(9)                   level 2 packed unaligned dcl 6-27 ref 422
value_in                 11(09)        based           structure                level 3 packed unaligned dcl 2-3
varying_ref               0(10)        based           bit(1)                   level 2 packed unaligned dcl 2-3 ref 153 221 320 320
                                                                                  373 373 449 478 478
which_andnot                           parameter       fixed bin(15,0)          dcl 413 in procedure "can_do_andnot" set ref 409
                                                                                  427*
which_andnot                    000130 automatic       fixed bin(15,0)          dcl 37 in procedure "string_op" set ref 231* 236 244
                                                                                  246 445 453 467* 467 468 470

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
a_format                               internal static bit(9)                   initial dcl 5-8
abs_fun                                internal static bit(9)                   initial dcl 5-8
acos_fun                               internal static bit(9)                   initial dcl 5-8
acosd_fun                              internal static bit(9)                   initial dcl 5-8
add                                    internal static bit(9)                   initial dcl 5-8
addbitno_fun                           internal static bit(9)                   initial dcl 5-8
addcharno_fun                          internal static bit(9)                   initial dcl 5-8
addr_fun                               internal static bit(9)                   initial dcl 5-8
addr_fun_bits                          internal static bit(9)                   initial dcl 5-8
addrel_fun                             internal static bit(9)                   initial dcl 5-8
allocation_fun                         internal static bit(9)                   initial dcl 5-8
allot_auto                             internal static bit(9)                   initial dcl 5-8
allot_based                            internal static bit(9)                   initial dcl 5-8
allot_ctl                              internal static bit(9)                   initial dcl 5-8
allot_var                              internal static bit(9)                   initial dcl 5-8
and_bits                               internal static bit(9)                   initial dcl 5-8
array_node                             internal static bit(9)                   initial dcl 6-5
asin_fun                               internal static bit(9)                   initial dcl 5-8
asind_fun                              internal static bit(9)                   initial dcl 5-8
assign                                 internal static bit(9)                   initial dcl 5-8
assign_by_name                         internal static bit(9)                   initial dcl 5-8
assign_round                           internal static bit(9)                   initial dcl 5-8
assign_size_ck                         internal static bit(9)                   initial dcl 5-8
assign_zero                            internal static bit(9)                   initial dcl 5-8
atan_fun                               internal static bit(9)                   initial dcl 5-8
atand_fun                              internal static bit(9)                   initial dcl 5-8
b_format                               internal static bit(9)                   initial dcl 5-8
baseno_fun                             internal static bit(9)                   initial dcl 5-8
baseptr_fun                            internal static bit(9)                   initial dcl 5-8
bit                                                    builtin function         dcl 57
bit_pointer                            internal static bit(9)                   initial dcl 5-8
bit_to_char                            internal static bit(9)                   initial dcl 5-8
bit_to_word                            internal static bit(9)                   initial dcl 5-8
bitno_fun                              internal static bit(9)                   initial dcl 5-8
bits_per_char                          internal static fixed bin(8,0)           initial dcl 1-5
bits_per_four_words                    internal static fixed bin(8,0)           initial dcl 1-5
bits_per_half                          internal static fixed bin(8,0)           initial dcl 1-5
bits_per_packed_digit                  internal static fixed bin(8,1)           initial dcl 1-35
bits_per_two_words                     internal static fixed bin(8,0)           initial dcl 1-5
bits_per_words                         internal static fixed bin(8,0)           initial array dcl 1-5
block_node                             internal static bit(9)                   initial dcl 6-5
bn_format                              internal static bit(9)                   initial dcl 5-8
bool_fun                               internal static bit(9)                   initial dcl 5-8
bound_ck                               internal static bit(9)                   initial dcl 5-8
bound_node                             internal static bit(9)                   initial dcl 6-5
break_even_bits                        internal static fixed bin(8,0)           initial dcl 1-5
break_even_words                       internal static fixed bin(8,0)           initial dcl 1-5
by_name_agg_node                       internal static bit(9)                   initial dcl 6-5
byte_fun                               internal static bit(9)                   initial dcl 5-8
c_format                               internal static bit(9)                   initial dcl 5-8
cat_string                             internal static bit(9)                   initial dcl 5-8
ceil_fun                               internal static bit(9)                   initial dcl 5-8
cg_stat$double_temp                    external static pointer                  dcl 34
cg_stat$long_string_temp               external static pointer                  dcl 34
char_to_word                           internal static bit(9)                   initial dcl 5-8
charno_fun                             internal static bit(9)                   initial dcl 5-8
chars_per_word                         internal static fixed bin(8,0)           initial dcl 1-5
clock_fun                              internal static bit(9)                   initial dcl 5-8
close_file                             internal static bit(9)                   initial dcl 5-8
codeptr_fun                            internal static bit(9)                   initial dcl 5-8
column_format                          internal static bit(9)                   initial dcl 5-8
comp_bits                              internal static fixed bin(15,0)          initial dcl 62
complex_fun                            internal static bit(9)                   initial dcl 5-8
conjg_fun                              internal static bit(9)                   initial dcl 5-8
context_node                           internal static bit(9)                   initial dcl 6-5
convert_offset                         internal static fixed bin(8,1)           initial array dcl 1-35
convert_size                           internal static fixed bin(8,0)           initial array dcl 1-5
copy_string                            internal static bit(9)                   initial dcl 5-8
copy_words                             internal static bit(9)                   initial dcl 5-8
cos_fun                                internal static bit(9)                   initial dcl 5-8
cosd_fun                               internal static bit(9)                   initial dcl 5-8
cross_reference_node                   internal static bit(9)                   initial dcl 6-5
default_fix_bin_p                      internal static fixed bin(8,0)           initial dcl 1-5
default_node                           internal static bit(9)                   initial dcl 6-5
delete_file                            internal static bit(9)                   initial dcl 5-8
desc_size                              internal static bit(9)                   initial dcl 5-8
digit_to_bit                           internal static bit(9)                   initial dcl 5-8
div                                    internal static bit(9)                   initial dcl 5-8
do_fun                                 internal static bit(9)                   initial dcl 5-8
do_spec                                internal static bit(9)                   initial dcl 5-8
e_format                               internal static bit(9)                   initial dcl 5-8
empty_area                             internal static bit(9)                   initial dcl 5-8
enable_on                              internal static bit(9)                   initial dcl 5-8
environmentptr_fun                     internal static bit(9)                   initial dcl 5-8
equal                                  internal static bit(9)                   initial dcl 5-8
ex_prologue                            internal static bit(9)                   initial dcl 5-8
exp                                    internal static bit(9)                   initial dcl 5-8
exp_fun                                internal static bit(9)                   initial dcl 5-8
expmac                          000000 constant        entry                    external dcl 44
expmac$zero                     000000 constant        entry                    external dcl 44
f_format                               internal static bit(9)                   initial dcl 5-8
floor_fun                              internal static bit(9)                   initial dcl 5-8
format_value_node                      internal static bit(9)                   initial dcl 6-5
fortran_read                           internal static bit(9)                   initial dcl 5-8
fortran_write                          internal static bit(9)                   initial dcl 5-8
free_based                             internal static bit(9)                   initial dcl 5-8
free_ctl                               internal static bit(9)                   initial dcl 5-8
free_var                               internal static bit(9)                   initial dcl 5-8
ftn_file_manip                         internal static bit(9)                   initial dcl 5-8
ftn_trans_loop                         internal static bit(9)                   initial dcl 5-8
get_data_trans                         internal static bit(9)                   initial dcl 5-8
get_edit_trans                         internal static bit(9)                   initial dcl 5-8
get_file                               internal static bit(9)                   initial dcl 5-8
get_list_trans                         internal static bit(9)                   initial dcl 5-8
get_string                             internal static bit(9)                   initial dcl 5-8
greater_or_equal                       internal static bit(9)                   initial dcl 5-8
greater_than                           internal static bit(9)                   initial dcl 5-8
half_to_word                           internal static bit(9)                   initial dcl 5-8
imag_fun                               internal static bit(9)                   initial dcl 5-8
ind_arithmetic                         internal static fixed bin(17,0)          initial dcl 4-68
ind_decimal_reg                        internal static fixed bin(17,0)          initial dcl 4-68
ind_invalid                            internal static fixed bin(17,0)          initial dcl 4-68
ind_known_refs                         internal static fixed bin(17,0)          initial dcl 4-68
ind_logical                            internal static fixed bin(17,0)          initial dcl 4-68
ind_string_aq                          internal static fixed bin(17,0)          initial dcl 4-68
ind_x                                  internal static fixed bin(17,0)          initial array dcl 4-68
index_after_fun                        internal static bit(9)                   initial dcl 5-8
index_before_fun                       internal static bit(9)                   initial dcl 5-8
index_fun                              internal static bit(9)                   initial dcl 5-8
index_rev_fun                          internal static bit(9)                   initial dcl 5-8
join                                   internal static bit(9)                   initial dcl 5-8
jump                                   internal static bit(9)                   initial dcl 5-8
jump_false                             internal static bit(9)                   initial dcl 5-8
jump_if_eq                             internal static bit(9)                   initial dcl 5-8
jump_if_ge                             internal static bit(9)                   initial dcl 5-8
jump_if_gt                             internal static bit(9)                   initial dcl 5-8
jump_if_le                             internal static bit(9)                   initial dcl 5-8
jump_if_lt                             internal static bit(9)                   initial dcl 5-8
jump_if_ne                             internal static bit(9)                   initial dcl 5-8
jump_true                              internal static bit(9)                   initial dcl 5-8
k                                      automatic       fixed bin(15,0)          dcl 37
l_parn                                 internal static bit(9)                   initial dcl 5-8
label_array_element_node               internal static bit(9)                   initial dcl 6-5
label_node                             internal static bit(9)                   initial dcl 6-5
label_size                             internal static fixed bin(8,0)           initial dcl 1-5
length_fun                             internal static bit(9)                   initial dcl 5-8
less_or_equal                          internal static bit(9)                   initial dcl 5-8
less_than                              internal static bit(9)                   initial dcl 5-8
line_format                            internal static bit(9)                   initial dcl 5-8
list_node                              internal static bit(9)                   initial dcl 6-5
locate_file                            internal static bit(9)                   initial dcl 5-8
lock_file                              internal static bit(9)                   initial dcl 5-8
lock_fun                               internal static bit(9)                   initial dcl 5-8
log10_fun                              internal static bit(9)                   initial dcl 5-8
log2_fun                               internal static bit(9)                   initial dcl 5-8
log_fun                                internal static bit(9)                   initial dcl 5-8
loop                                   internal static bit(9)                   initial dcl 5-8
machine_state_node                     internal static bit(9)                   initial dcl 6-5
make_desc                              internal static bit(9)                   initial dcl 5-8
max_dec_scale                          internal static fixed bin(8,0)           initial dcl 1-5
max_fun                                internal static bit(9)                   initial dcl 5-8
max_index_register_value               internal static fixed bin(31,0)          initial dcl 1-38
max_length_p                           internal static fixed bin(8,0)           initial dcl 1-5
max_number_of_operands                 internal static fixed bin(15,0)          initial dcl 3-15
max_offset                             internal static fixed bin(8,0)           initial array dcl 1-5
max_p_fix_bin_1                        internal static fixed bin(8,0)           initial dcl 1-5
max_p_fix_dec                          internal static fixed bin(8,0)           initial dcl 1-5
max_p_flt_bin_1                        internal static fixed bin(8,0)           initial dcl 1-5
max_p_xreg                             internal static fixed bin(8,0)           initial dcl 1-5
max_short_size                         internal static fixed bin(8,0)           initial array dcl 1-5
min                                                    builtin function         dcl 57
min_dec_scale                          internal static fixed bin(8,0)           initial dcl 1-5
min_fun                                internal static bit(9)                   initial dcl 5-8
mod_bit                                internal static bit(9)                   initial dcl 5-8
mod_byte                               internal static bit(9)                   initial dcl 5-8
mod_fun                                internal static bit(9)                   initial dcl 5-8
mod_half                               internal static bit(9)                   initial dcl 5-8
mod_word                               internal static bit(9)                   initial dcl 5-8
mult                                   internal static bit(9)                   initial dcl 5-8
n                                      automatic       fixed bin(15,0)          dcl 37
negate                                 internal static bit(9)                   initial dcl 5-8
nop                                    internal static bit(9)                   initial dcl 5-8
not_equal                              internal static bit(9)                   initial dcl 5-8
off_fun                                internal static bit(9)                   initial dcl 5-8
open_file                              internal static bit(9)                   initial dcl 5-8
or_bits                                internal static bit(9)                   initial dcl 5-8
pack                                   internal static bit(9)                   initial dcl 5-8
packed_digits_per_char                 internal static fixed bin(8,0)           initial dcl 1-5
packed_digits_per_word                 internal static fixed bin(8,0)           initial dcl 1-5
page_format                            internal static bit(9)                   initial dcl 5-8
param_desc_ptr                         internal static bit(9)                   initial dcl 5-8
param_ptr                              internal static bit(9)                   initial dcl 5-8
picture_format                         internal static bit(9)                   initial dcl 5-8
pl1_mod_fun                            internal static bit(9)                   initial dcl 5-8
prefix_plus                            internal static bit(9)                   initial dcl 5-8
ptr_fun                                internal static bit(9)                   initial dcl 5-8
put_control                            internal static bit(9)                   initial dcl 5-8
put_data_trans                         internal static bit(9)                   initial dcl 5-8
put_edit_trans                         internal static bit(9)                   initial dcl 5-8
put_field                              internal static bit(9)                   initial dcl 5-8
put_field_chk                          internal static bit(9)                   initial dcl 5-8
put_file                               internal static bit(9)                   initial dcl 5-8
put_list_trans                         internal static bit(9)                   initial dcl 5-8
put_string                             internal static bit(9)                   initial dcl 5-8
r_format                               internal static bit(9)                   initial dcl 5-8
r_parn                                 internal static bit(9)                   initial dcl 5-8
range_ck                               internal static bit(9)                   initial dcl 5-8
rank_fun                               internal static bit(9)                   initial dcl 5-8
read_file                              internal static bit(9)                   initial dcl 5-8
real_fun                               internal static bit(9)                   initial dcl 5-8
record_io                              internal static bit(9)                   initial dcl 5-8
refer                                  internal static bit(9)                   initial dcl 5-8
reference_node                         internal static bit(9)                   initial dcl 6-5
rel_fun                                internal static bit(9)                   initial dcl 5-8
repeat_fun                             internal static bit(9)                   initial dcl 5-8
return_bits                            internal static bit(9)                   initial dcl 5-8
return_string                          internal static bit(9)                   initial dcl 5-8
return_value                           internal static bit(9)                   initial dcl 5-8
return_words                           internal static bit(9)                   initial dcl 5-8
reverse_fun                            internal static bit(9)                   initial dcl 5-8
revert_on                              internal static bit(9)                   initial dcl 5-8
rewrite_file                           internal static bit(9)                   initial dcl 5-8
round_fun                              internal static bit(9)                   initial dcl 5-8
search_fun                             internal static bit(9)                   initial dcl 5-8
search_rev_fun                         internal static bit(9)                   initial dcl 5-8
segno_fun                              internal static bit(9)                   initial dcl 5-8
setbitno_fun                           internal static bit(9)                   initial dcl 5-8
setcharno_fun                          internal static bit(9)                   initial dcl 5-8
sf_par_node                            internal static bit(9)                   initial dcl 6-5
sign_fun                               internal static bit(9)                   initial dcl 5-8
signal_on                              internal static bit(9)                   initial dcl 5-8
sin_fun                                internal static bit(9)                   initial dcl 5-8
sind_fun                               internal static bit(9)                   initial dcl 5-8
skip_format                            internal static bit(9)                   initial dcl 5-8
source_node                            internal static bit(9)                   initial dcl 6-5
sqrt_fun                               internal static bit(9)                   initial dcl 5-8
stack_ptr                              internal static bit(9)                   initial dcl 5-8
stackbaseptr_fun                       internal static bit(9)                   initial dcl 5-8
stackframeptr_fun                      internal static bit(9)                   initial dcl 5-8
stacq_fun                              internal static bit(9)                   initial dcl 5-8
staq                                   internal static fixed bin(15,0)          initial dcl 62
statement_node                         internal static bit(9)                   initial dcl 6-5
std_arg_list                           internal static bit(9)                   initial dcl 5-8
std_call                               internal static bit(9)                   initial dcl 5-8
std_entry                              internal static bit(9)                   initial dcl 5-8
std_return                             internal static bit(9)                   initial dcl 5-8
stop                                   internal static bit(9)                   initial dcl 5-8
stream_prep                            internal static bit(9)                   initial dcl 5-8
string                                                 builtin function         dcl 57
sub                                    internal static bit(9)                   initial dcl 5-8
symbol_node                            internal static bit(9)                   initial dcl 6-5
tan_fun                                internal static bit(9)                   initial dcl 5-8
tand_fun                               internal static bit(9)                   initial dcl 5-8
temporary_node                         internal static bit(9)                   initial dcl 6-5
terminate_trans                        internal static bit(9)                   initial dcl 5-8
token_node                             internal static bit(9)                   initial dcl 6-5
translate_fun                          internal static bit(9)                   initial dcl 5-8
trunc_fun                              internal static bit(9)                   initial dcl 5-8
units_per_word                         internal static fixed bin(8,0)           initial array dcl 1-5
unlock_file                            internal static bit(9)                   initial dcl 5-8
unpack                                 internal static bit(9)                   initial dcl 5-8
vclock_fun                             internal static bit(9)                   initial dcl 5-8
verify_fun                             internal static bit(9)                   initial dcl 5-8
verify_ltrim_fun                       internal static bit(9)                   initial dcl 5-8
verify_rev_fun                         internal static bit(9)                   initial dcl 5-8
verify_rtrim_fun                       internal static bit(9)                   initial dcl 5-8
word_to_mod2                           internal static bit(9)                   initial dcl 5-8
word_to_mod4                           internal static bit(9)                   initial dcl 5-8
word_to_mod8                           internal static bit(9)                   initial dcl 5-8
wordno_fun                             internal static bit(9)                   initial dcl 5-8
write_file                             internal static bit(9)                   initial dcl 5-8
x_format                               internal static bit(9)                   initial dcl 5-8
xor_bits                               internal static bit(9)                   initial dcl 5-8

NAMES DECLARED BY EXPLICIT CONTEXT.
and_op                          000300 constant        label                    dcl 210
ao_aa                           000417 constant        label                    dcl 261
ao_aa_1                         000444 constant        label                    dcl 274 ref 368
ao_aa_l                         000473 constant        label                    dcl 281 ref 268 326 339 390
ao_aa_l1                        000510 constant        label                    dcl 283
ao_aa_l3                        000541 constant        label                    dcl 296
ao_ae                           000577 constant        label                    dcl 308
ao_ea                           000600 constant        label                    dcl 313
ao_ee                           000735 constant        label                    dcl 353
ao_ee_1                         000770 constant        label                    dcl 373 ref 358 362
ao_sw                           000004 constant        label                    array(0:3) dcl 261 ref 256
begin                           000042 constant        label                    dcl 133
can_do_andnot                   001100 constant        entry                    internal dcl 409 ref 231
check_lengths                   001310 constant        entry                    internal dcl 476 ref 194 203 242
comp_long                       000173 constant        label                    dcl 173 ref 184
complement                      000135 constant        label                    dcl 170 ref 185
flip_rands                      001246 constant        entry                    internal dcl 457 ref 261 264 308 338 353 393
long_op                         001341 constant        entry                    internal dcl 489 ref 288 400
not_op                          000120 constant        label                    dcl 160
or_op                           000263 constant        label                    dcl 201
set_s3                          000313 constant        label                    dcl 221 ref 197 206
setup_andnot                    001154 constant        entry                    internal dcl 436 ref 236 238
string_done                     001070 constant        label                    dcl 404 ref 188 277 304 349
string_op                       000032 constant        entry                    external dcl 28
switch                          000000 constant        label                    array(4) dcl 160 ref 156
xor_op                          000246 constant        label                    dcl 192

NAME DECLARED BY CONTEXT OR IMPLICATION.
mod                                                    builtin function         ref 234 467

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1556        1620    1411        1566
Length      2132    1411        42         275     145           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
string_op                           182 external procedure  is an external procedure.  
can_do_andnot                           internal procedure  shares stack frame of external procedure string_op.  
setup_andnot                            internal procedure  shares stack frame of external procedure string_op.  
flip_rands                              internal procedure  shares stack frame of external procedure string_op.  
check_lengths                           internal procedure  shares stack frame of external procedure string_op.  
long_op                                 internal procedure  shares stack frame of external procedure string_op.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
string_op                000100 p                           string_op
                         000102 p1                          string_op
                         000104 p2                          string_op
                         000106 p3                          string_op
                         000110 q2                          string_op
                         000112 q3                          string_op
                         000114 for_test                    string_op
                         000115 doing_andnot                string_op
                         000116 code                        string_op
                         000120 atom                        string_op
                         000122 s2                          string_op
                         000123 s3                          string_op
                         000124 op                          string_op
                         000125 l_op                        string_op
                         000126 load_double                 string_op
                         000127 op_code                     string_op
                         000130 which_andnot                string_op
                         000132 m_s_p                       string_op
                         000142 i                           can_do_andnot
                         000144 q                           can_do_andnot
                         000162 p                           flip_rands
                         000164 s                           flip_rands

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              r_ne_as             r_ge_a              call_ext_out        return
mod_fx1             ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
adjust_ref_count              aq_man$clear_q                c_a                           compile_exp
compile_exp$save              compile_exp$save_exp          expmac$eis                    expmac$one
load                          prepare_operand               string_temp

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
cg_stat$for_test_called       cg_static_$m_s_p




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     28 000026    4    3 000037       133 000042       134 000046       135 000050       137 000052       139 000056
    140 000061       142 000064       144 000066       145 000071       148 000073       149 000075       153 000076
    154 000110       156 000116       160 000120       169 000125       170 000135       171 000172       173 000173
    174 000212       174 000217       175 000221       176 000232       183 000233       184 000241       185 000244
    188 000245       192 000246       194 000250       195 000251       195 000256       196 000260       197 000262
    201 000263       203 000265       204 000266       204 000273       205 000275       206 000277       210 000300
    213 000302       214 000304       215 000306       217 000307       218 000311       221 000313       222 000325
    224 000333       226 000336       231 000344       233 000351       234 000355       236 000361       238 000366
    240 000370       242 000401       244 000402       246 000410       248 000413       256 000415       261 000417
    264 000424       268 000430       273 000433       274 000444       275 000457       277 000472       281 000473
    283 000510       288 000524       289 000525       295 000526       296 000541       300 000555       301 000573
    304 000576       308 000577       313 000600       320 000603       325 000632       326 000643       331 000644
    337 000647       338 000660       339 000661       344 000662       345 000676       346 000705       347 000721
    349 000734       353 000735       358 000741       362 000744       366 000747       367 000760       368 000767
    373 000770       380 001003       384 001014       390 001025       393 001026       397 001032       398 001043
    399 001052       400 001067       404 001070       407 001077       409 001100       419 001102       421 001113
    422 001115       427 001140       428 001144       430 001147       432 001151       436 001154       445 001156
    447 001163       449 001203       451 001217       453 001225       455 001245       457 001246       461 001247
    461 001251       461 001253       462 001255       462 001257       462 001261       463 001263       463 001265
    463 001267       465 001271       467 001273       468 001300       470 001305       473 001307       476 001310
    478 001311       486 001340       489 001341       491 001342       493 001353


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
