	COMPILATION LISTING OF SEGMENT display_argument_list_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/24/88  1528.8 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 
        8 /****^  HISTORY COMMENTS:
        9*  1) change(86-03-13,GWMay), approve(86-04-16,MCR7373),
       10*     audit(86-04-29,LJAdams), install(86-05-01,MR12.0-1051):
       11*     Changed to reference entry_desc_info_version_2 constant.
       12*  2) change(86-11-19,DGHowe), approve(86-11-19,MCR7583),
       13*     audit(86-11-24,JRGray), install(86-12-09,MR12.0-1238):
       14*     Changed to print out command_name. Modified to refer
       15*     to command_name_arglist instead of arg_list.
       16*                                                   END HISTORY COMMENTS */
       17 
       18 
       19 /* format: style4,delnl,insnl,tree,ifthenstmt,indnoniterend */
       20 display_argument_list_:
       21      procedure (Iocb, Amup, Framep, Argp, Entryp, Farg, Larg, Lmarg);
       22 
       23 /* This program is an adaptation of Steve Webber's list_arg_ routine from db,
       24*   for use by trace_stack_. */
       25 /* rewritten 8/10/81 by Melanie Weaver to use arithmetic_to_ascii_ */
       26 /* Adapted from list_frame_args_ May 1982 by C. Hornig */
       27 /* modified 7/12/83 by Jeffrey D. Ives to not print a warning if a packed arg is passed to an unpacked parm.	*/
       28 /* modified 9/05/84 by Jeffrey D. Ives to use get_entry_arg_descs_$info, use "RET VAL" before a return value,
       29*   and handle the returns (char|bit|area (*)) case. */
       30 
       31 
       32 dcl  Amup ptr parameter;				/* unused */
       33 dcl  Framep ptr parameter;
       34 dcl  Argp ptr parameter;
       35 dcl  Entryp ptr parameter;
       36 dcl  (Farg, Larg) fixed bin parameter;
       37 dcl  Lmarg fixed bin parameter;
       38 dcl  Iocb ptr parameter;
       39 
       40 dcl  (addr, addrel, character, hbound, lbound, min, null, substr, max, verify, unspec) builtin;
       41 
       42 dcl  cleanup condition;
       43 
       44 dcl  argp ptr;
       45 dcl  ep ptr;
       46 dcl  ap ptr;					/* ptr to arglist. */
       47 dcl  strp ptr;
       48 dcl  tp ptr;
       49 dcl  xdesc (64) ptr;
       50 
       51 dcl  (j, k) fixed bin;
       52 dcl  (min_arg, max_arg, type, xtype) fixed bin;
       53 dcl  (no_args, no_desc, strl, ndims, scale) fixed bin;
       54 dcl  (xstrl, xndims, xscale, xnargs) fixed bin;
       55 dcl  ec fixed bin (35);
       56 
       57 dcl  arg_id char (7);
       58 dcl  (ttype, xttype) char (40);
       59 dcl  ascii_representation char (132) varying;
       60 
       61 dcl  (packed, xpacked) bit (1) aligned;
       62 dcl  begin_block_entries (2) bit (36) aligned internal static options (constant)
       63 	init ("000614272100"b3 /* tsp2 pr0|614 */, "001376272100"b3 /* tsp2 pr0|1376 */);
       64 
       65 dcl  condition_ entry (char (*), entry);
       66 dcl  get_entry_arg_descs_$info entry (ptr, fixed bin, (*) ptr, ptr, fixed bin (35));
       67 dcl  decode_descriptor_ entry (ptr, fixed bin, fixed bin, bit (1) aligned, fixed bin, fixed bin, fixed bin);
       68 dcl  interpret_ptr_ entry (ptr, ptr, ptr);
       69 dcl  ioa_$ioa_switch entry options (variable);
       70 dcl  ioa_$ioa_switch_nnl entry options (variable);
       71 dcl  ioa_$rsnnl entry options (variable);
       72 dcl  arithmetic_to_ascii_ entry (ptr, fixed bin, bit (1) aligned, fixed bin, fixed bin, char (132) varying);
       73 dcl  display_file_value_ entry (ptr, file, fixed bin (35));
       74 
       75 dcl  based_ptr ptr based;
       76 dcl  packptr ptr based unaligned;
       77 dcl  fword (4) fixed bin (35) based (argp);
       78 dcl  bcs char (100) based (argp);
       79 dcl  char_string char (strl) based (argp);
       80 dcl  based_bit bit (36) aligned based;
       81 dcl  bit_string bit (strl) based (argp);
       82 dcl  based_file file based;
       83 
       84 dcl  1 edi like entry_desc_info aligned;
       85 
       86 dcl  1 label_variable based (argp) aligned,
       87        2 ptr ptr,
       88        2 stack ptr;
       89 
       90 dcl  LEGAL char (96) static options (constant)
       91 	init
       92 	/* Printables except PAD, but with BS */ (
       93 	" !""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~");
       94 
       95 	sp = Framep;
       96 	ep = Entryp;
       97 	ap = Argp;
       98 
       99 	if ep = null () then ep = stack_frame.entry_ptr;
      100 	if ap = null () then ap = stack_frame.arg_ptr;
      101 
      102 	if ap = null () then do;
      103 	     if ep ^= null ()
      104 	     then do j = 1 to hbound (begin_block_entries, 1);
      105 		if addrel (ep, 1) -> based_bit = begin_block_entries (j) then do;
      106 		     call ioa_$ioa_switch (Iocb, "^vxThis is a begin block.  It has no argument list.", Lmarg);
      107 		     return;
      108 		     end;
      109 	     end;
      110 
      111 	     call ioa_$ioa_switch (Iocb, "^vxNo argument list.", Lmarg);
      112 	     return;
      113 	     end;
      114 
      115 	strp = addr (strbuf);
      116 	no_args = ap -> arg_list.arg_count;		/* get the number of arguments */
      117 	no_desc = ap -> arg_list.desc_count;		/* and the number of descriptors */
      118 
      119 	if (ap -> command_name_arglist.mbz ^= ""b)
      120 	     | ((ap -> command_name_arglist.call_type ^= 4) & (ap -> command_name_arglist.call_type ^= 8))
      121 	     | ((no_desc ^= 0) & (no_desc ^= no_args)) then do;
      122 
      123 	     call ioa_$ioa_switch (Iocb, "^vxArgument list header invalid.", Lmarg);
      124 	     return;
      125 	     end;
      126 
      127 	entry_desc_info_ptr = addr (edi);
      128 	unspec (entry_desc_info) = ""b;
      129 	entry_desc_info.version = entry_desc_info_version_2;
      130 	call get_entry_arg_descs_$info (ep, xnargs, xdesc, entry_desc_info_ptr, ec);
      131 
      132 	if (xnargs > 0) & (xnargs ^= no_args)
      133 	then call ioa_$ioa_switch (Iocb, "^vxWarning: ^d arguments expected, ^d supplied.", Lmarg, xnargs, no_args);
      134 
      135 	if no_args = 0 then do;			/* check for no arguments */
      136 	     call ioa_$ioa_switch (Iocb, "^vxNo arguments.", Lmarg);
      137 	     return;
      138 	     end;
      139 
      140 /* check and see if the command name is available */
      141 
      142 	if (ap -> command_name_arglist.has_command_name) then do;
      143 	     argp = ap -> command_name_arglist.name.command_name_ptr;
      144 	     strl = ap -> command_name_arglist.name.command_name_length;
      145 	     if strl > 0 then call ioa_$ioa_switch (Iocb, "^vxCommand name: ^a", Lmarg, char_string);
      146 	     end;
      147 
      148 	if no_args > 64 then call ioa_$ioa_switch (Iocb, "^vxOnly first 64 args of ^d will be listed.", Lmarg, no_args);
      149 
      150 	min_arg = max (1, Farg);			/* print out all arguments */
      151 	max_arg = min (Larg, no_args, 64);
      152 
      153 	call condition_ ("any_other", intproc);
      154 	on cleanup ;
      155 
      156 	do j = min_arg to max_arg;			/* loop through the desired number of args */
      157 	     argp = ap -> command_name_arglist.arg_ptrs (j);
      158 						/* get pointer to the argument */
      159 	     type, xtype = -1;			/* full word octal */
      160 	     packed, xpacked = "0"b;
      161 	     ndims, xndims = 0;
      162 	     strl, xstrl = 0;
      163 	     scale, xscale = 0;
      164 	     if entry_desc_info.flags.function & j = xnargs
      165 	     then arg_id = "RET VAL";
      166 	     else call ioa_$rsnnl ("ARG ^3d", arg_id, k, j);
      167 	     if xnargs >= j & xdesc (j) ^= null () then do;
      168 						/* Do we know what this arg shd be? */
      169 		call decode_descriptor_ (xdesc (j), 0, xtype, xpacked, xndims, xstrl, xscale);
      170 		end;
      171 	     if arg_id = "RET VAL" & xstrl = 16777215 then argp = argp -> based_ptr;
      172 						/* returns (char|bit|area (*)) case */
      173 	     if no_desc ^= 0 then do;			/* if we have descriptors, look at them */
      174 		call decode_descriptor_ (ap, j, type, packed, ndims, strl, scale);
      175 		if xnargs >= j & xdesc (j) ^= null () then do;
      176 						/* Yes. We know what this arg shd be. */
      177 		     if xtype ^= type then do;
      178 			if type >= lbound (data_type_info_$info, 1) & type <= hbound (data_type_info_$info, 1)
      179 			then ttype = type_name (type);
      180 			else call ioa_$rsnnl ("type ^d", ttype, k, type);
      181 			if xtype >= lbound (data_type_info_$info, 1) & xtype <= hbound (data_type_info_$info, 1)
      182 			then xttype = type_name (xtype);
      183 			else call ioa_$rsnnl ("type ^d", xttype, k, xtype);
      184 			call ioa_$ioa_switch (Iocb, "^vxWarning: ^a is ^a, but it should be ^a.", Lmarg, arg_id,
      185 			     ttype, xttype);
      186 			end;
      187 		     if xpacked ^= packed		/* Check that packed attributes match */
      188 		     then do;
      189 			if xpacked then do;
      190 			     if xtype ^= char_dtype
      191 			     then call ioa_$ioa_switch (Iocb,
      192 				     "^vxWarning: ^a is unpacked, but it should be packed.", Lmarg, arg_id);
      193 			     end;
      194 			else call ioa_$ioa_switch (Iocb, "^vxWarning: ^a is packed, but it should be unpacked.",
      195 				Lmarg, arg_id);
      196 			end;
      197 		     if xndims ^= ndims
      198 		     then call ioa_$ioa_switch (Iocb, "^vxWarning: ^a has ^d dimensions, but it should have ^d.",
      199 			     Lmarg, arg_id, ndims, xndims);
      200 		     if xstrl ^= strl
      201 		     then if xtype < pointer_dtype
      202 			then call ioa_$ioa_switch (Iocb,
      203 				"^vxWarning: ^a has a precision of ^d, but it should be ^d.", Lmarg, arg_id, strl,
      204 				xstrl);
      205 			else if xstrl ^= 16777215
      206 			     then			/* No fuss abt char (*) */
      207 				call ioa_$ioa_switch (Iocb,
      208 				     "^vxWarning: ^a has a length of ^d, but it should be ^d.", Lmarg, arg_id,
      209 				     strl, xstrl);
      210 		     if xscale ^= scale
      211 		     then call ioa_$ioa_switch (Iocb, "^vxWarning: ^a has a scale of ^d, but it should be ^d.", Lmarg,
      212 			     arg_id, scale, xscale);
      213 		     end;
      214 		end;
      215 	     else if xnargs >= j then do;		/* Callee might have descriptors for args. */
      216 		     if xdesc (j) = null then go to guess;
      217 						/* .. and then again he might not. */
      218 		     call decode_descriptor_ (xdesc (j), 0, type, packed, ndims, strl, scale);
      219 		     end;
      220 		else do;				/* try to find out what type by heuristics */
      221 guess:
      222 		     if argp -> its.its_mod = ITS_MODIFIER
      223 		     then type = pointer_dtype;	/* assume pointer */
      224 		     else do;
      225 			strl = verify (bcs, LEGAL) - 1;
      226 						/* Scan for last legal char in string. */
      227 			if strl < 0 then strl = 100;	/* If all legal, print first 100. */
      228 			if strl >= 2
      229 			then type = char_dtype;
      230 			else strl = 0;
      231 			end;
      232 		     end;
      233 
      234 	     if /* case */ type = -1 then call ioa_$ioa_switch (Iocb, "^vx^a: ^w", Lmarg, arg_id, fword (1));
      235 						/* no descriptor; print full word octal */
      236 
      237 	     else if type < lbound (data_type_info_$info, 1) | type > hbound (data_type_info_$info, 1)
      238 	     then call ioa_$ioa_switch (Iocb, "^vx^a: (bad type ^d at ^p) ^w", Lmarg, arg_id, type, argp, fword (1));
      239 
      240 	     else if data_type_info_$info (type).arithmetic then do;
      241 		call arithmetic_to_ascii_ (argp, type, packed, strl, scale, ascii_representation);
      242 		call ioa_$ioa_switch (Iocb, "^vx^a: ^a", Lmarg, arg_id, ascii_representation);
      243 		end;
      244 
      245 	     else if type = pointer_dtype then do;	/* Pointer */
      246 		if packed then do;			/* packed ptr */
      247 		     tp = argp -> packptr;
      248 		     go to pptr;
      249 		     end;
      250 		if argp -> its.its_mod = ITS_MODIFIER then do;
      251 		     tp = argp -> based_ptr;
      252 pptr:
      253 		     call interpret_ptr_ (tp, null (), strp);
      254 		     call ioa_$ioa_switch (Iocb, "^vx^a: ^p ^a^a|^a ^a", Lmarg, arg_id, tp, struc.segment,
      255 			struc.entryn, struc.offset, struc.comment);
      256 		     end;
      257 		else call ioa_$ioa_switch (Iocb, "^vx^a: ^w  ^w", Lmarg, arg_id, fword (1), fword (2));
      258 		end;
      259 
      260 	     else if type = offset_dtype		/* Offset */
      261 	     then call ioa_$ioa_switch (Iocb, "^vx^a: ^w", Lmarg, arg_id, fword (1));
      262 
      263 	     else if type = label_dtype | type = entry_dtype
      264 						/* Label, Entry */
      265 	     then do;
      266 		call interpret_ptr_ (argp -> label_variable.ptr, argp -> label_variable.stack, strp);
      267 		call ioa_$ioa_switch (Iocb, "^vx^a: ^p, ^p ^a^a|^a ^a", Lmarg, arg_id, label_variable.ptr,
      268 		     label_variable.stack, struc.segment, struc.entryn, struc.offset, struc.comment);
      269 		end;
      270 
      271 	     else if type = bit_dtype | type = varying_bit_dtype
      272 						/* Bit string */
      273 	     then do;
      274 		if type = varying_bit_dtype then strl = addrel (argp, -1) -> fword (1);
      275 		if bit_string ^= ""b
      276 		then ascii_representation = """" || character (substr (bit_string, 1, min (strl, 72))) || """b";
      277 		else call ioa_$rsnnl ("(^d)""0""b", ascii_representation, 0, strl);
      278 
      279 		call ioa_$ioa_switch (Iocb, "^vx^a: ^a", Lmarg, arg_id, ascii_representation);
      280 		end;
      281 
      282 	     else if type = char_dtype | type = varying_char_dtype
      283 						/* Character string */
      284 	     then do;
      285 		if type = varying_char_dtype then strl = min (80, max (addrel (argp, -1) -> fword (1), 0));
      286 		call ioa_$ioa_switch (Iocb, "^vx^a: ""^va""", Lmarg, arg_id, strl, char_string);
      287 		end;
      288 
      289 	     else if type = file_dtype		/* File */
      290 	     then do;
      291 		call ioa_$ioa_switch_nnl (Iocb, "^vx^a: ", Lmarg, arg_id);
      292 		call display_file_value_ (Iocb, argp -> based_file, ec);
      293 		call ioa_$ioa_switch (Iocb, "(file at ^p)", argp);
      294 		end;
      295 
      296 	     else call ioa_$ioa_switch (Iocb, "^vx^a: (^a at ^p) ^w", Lmarg, arg_id, type_name (type), argp, fword (1));
      297 
      298 	     if ndims > 0 then call ioa_$ioa_switch (Iocb, "^-^vx(^d-dim array)", Lmarg, ndims);
      299 
      300 skiparg:
      301 	end;
      302 	return;
      303 
      304 intproc:
      305      procedure (mcp, cname, cop, infop, cont);
      306 
      307 dcl  (mcp, cop, infop) ptr,
      308      cname char (*),
      309      cont bit (1);
      310 
      311 	if (cname = "program_interrupt") | (cname = "finish") | (cname = "quit") then do;
      312 	     cont = "1"b;
      313 	     return;
      314 	     end;
      315 
      316 	if infop ^= null ()
      317 	then if infop -> condition_info_header.action_flags.quiet_restart then return;
      318 
      319 	call ioa_$ioa_switch (Iocb, "^vx^a not accessible. - ^a", Lmarg, arg_id, cname);
      320 	go to skiparg;
      321      end;
      322 
  1     1 /* BEGIN INCLUDE FILE ... arg_list.incl.pl1
  1     2*
  1     3*   James R. Davis 10 May 79 */
  1     4 
  1     5 
  1     6      
  1     7 /****^  HISTORY COMMENTS:
  1     8*  1) change(86-05-15,DGHowe), approve(86-05-15,MCR7375),
  1     9*     audit(86-07-15,Schroth):
  1    10*     added command_name_arglist declaration to allow the storage of the
  1    11*     command name given to the command processor
  1    12*                                                   END HISTORY COMMENTS */
  1    13 
  1    14      dcl	   1 arg_list	      aligned based,
  1    15 	     2 header,
  1    16 	       3 arg_count	      fixed bin (17) unsigned unal,
  1    17 	       3 pad1	      bit (1) unal,
  1    18 	       3 call_type	      fixed bin (18) unsigned unal,
  1    19 	       3 desc_count	      fixed bin (17) unsigned unal,
  1    20 	       3 pad2	      bit (19) unal,
  1    21 	     2 arg_ptrs	      (arg_list_arg_count refer (arg_list.arg_count)) ptr,
  1    22 	     2 desc_ptrs	      (arg_list_arg_count refer (arg_list.arg_count)) ptr;
  1    23 
  1    24 
  1    25      dcl	   1 command_name_arglist	      aligned based,
  1    26 	     2 header,
  1    27 	       3 arg_count	      fixed bin (17) unsigned unal,
  1    28 	       3 pad1	      bit (1) unal,
  1    29 	       3 call_type	      fixed bin (18) unsigned unal,
  1    30 	       3 desc_count	      fixed bin (17) unsigned unal,
  1    31 	       3 mbz              bit(1) unal,
  1    32                  3 has_command_name bit(1) unal,
  1    33 	       3 pad2	      bit (17) unal,
  1    34 	     2 arg_ptrs	      (arg_list_arg_count refer (command_name_arglist.arg_count)) ptr,
  1    35 	     2 desc_ptrs	      (arg_list_arg_count refer (command_name_arglist.arg_count)) ptr,
  1    36 	     2 name,
  1    37                  3 command_name_ptr         pointer,
  1    38                  3 command_name_length      fixed bin (21);
  1    39 	
  1    40 
  1    41 
  1    42      dcl	   1 arg_list_with_envptr aligned based,	/* used with non-quick int and entry-var calls */
  1    43 	     2 header,
  1    44 	       3 arg_count	      fixed bin (17) unsigned unal,
  1    45 	       3 pad1	      bit (1) unal,
  1    46 	       3 call_type	      fixed bin (18) unsigned unal,
  1    47 	       3 desc_count	      fixed bin (17) unsigned unal,
  1    48 	       3 pad2	      bit (19) unal,
  1    49 	     2 arg_ptrs	      (arg_list_arg_count refer (arg_list_with_envptr.arg_count)) ptr,
  1    50 	     2 envptr	      ptr,
  1    51 	     2 desc_ptrs	      (arg_list_arg_count refer (arg_list_with_envptr.arg_count)) ptr;
  1    52 
  1    53 
  1    54      dcl	   (
  1    55 	   Quick_call_type	      init (0),
  1    56 	   Interseg_call_type     init (4),
  1    57 	   Envptr_supplied_call_type
  1    58 			      init (8)
  1    59 	   )		      fixed bin (18) unsigned unal int static options (constant);
  1    60 
  1    61 /* The user must declare arg_list_arg_count - if an adjustable automatic structure
  1    62*   is being "liked" then arg_list_arg_count may be a parameter, in order to allocate
  1    63*   an argument list of the proper size in the user's stack
  1    64*
  1    65**/
  1    66 /* END INCLUDE FILE ... arg_list.incl.pl1 */
      323 
  2     1 /* START OF:	entry_desc_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 	
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(84-11-29,Ranzenbach), approve(86-03-12,MCR7144),
  2     7*     audit(86-03-12,GWMay), install(86-05-01,MR12.0-1051):
  2     8*     for version 2. This version allows the caller to specify a pointer to
  2     9*     the beginning of the offset and its bit count. This allows the
  2    10*     processing of archive components.
  2    11*     
  2    12*     NOTICE:
  2    13*        All applications which use this structure should be converted to
  2    14*        use version 2.  Version 1 can be retained by setting the version to
  2    15*        a value of 1. The constant entry_desc_info_version_1 has been
  2    16*        removed from the file.
  2    17*                                                   END HISTORY COMMENTS */
  2    18 
  2    19 
  2    20 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    21 	/* 									*/
  2    22 	/* Name:  entry_desc_info.incl.pl1						*/
  2    23 	/* 									*/
  2    24 	/* This include file is used by get_entry_arg_desc_$info, $text_only_info and their	*/
  2    25 	/* callers.  It declares the flag bits obtained from the entry sequence of a procedure	*/
  2    26 	/* entry point.								*/
  2    27 	/* 									*/
  2    28 	/* Status									*/
  2    29 	/* 									*/
  2    30 	/* 0)  Created in May, 1979  by  G. C. Dixon					*/
  2    31 	/*									*/
  2    32 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    33 
  2    34      dcl	1 entry_desc_info		aligned based(entry_desc_info_ptr),
  2    35 	  2 version		fixed bin,	/* version number of this structure (= 2)	*/
  2    36 	  2 flags,
  2    37 
  2    38 	   (3 basic_indicator,			/* on if this is a BASIC program.		*/
  2    39 	    3 revision_1,				/* on if program entry has stuff added after 5/75 */
  2    40 	    3 has_descriptors,			/* on if entry point had valid parm. descriptors	*/
  2    41 	    3 variable,				/* on if entry point takes undefined no. of args	*/
  2    42 	    3 function)				/* on if entry point is a function		*/
  2    43 				bit(1) unaligned,
  2    44 	    3 pad			bit(13) unaligned,
  2    45 				                    /* version 2 fields follow                        */
  2    46 	  2 object_ptr		ptr,		/* -> beginning of object segment... (INPUT)	*/
  2    47 	  2 bit_count		fixed bin (24);	/* bit count of object... (INPUT)		*/
  2    48 
  2    49      dcl	entry_desc_info_version_2	fixed bin int static options(constant) init(2),
  2    50 	entry_desc_info_ptr		ptr;
  2    51 
  2    52 /* END OF:	entry_desc_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      324 
  3     1 /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
  3     2 
  3     3 /* format: off */
  3     4 
  3     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
  3     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
  3     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
  3     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
  3     9 
  3    10 
  3    11 /****^  HISTORY COMMENTS:
  3    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
  3    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
  3    14*     Modified to add constants for the translator_id field in the stack_frame
  3    15*     structure.
  3    16*                                                   END HISTORY COMMENTS */
  3    17 
  3    18 
  3    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
  3    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
  3    21 						/* with indicators (nonzero for Fortran hexfp caller) */
  3    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
  3    23 
  3    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
  3    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
  3    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
  3    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
  3    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
  3    29 
  3    30 
  3    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
  3    32 
  3    33 dcl  stack_frame_min_length fixed bin static init(48);
  3    34 
  3    35 
  3    36 dcl 1 stack_frame based(sp) aligned,
  3    37     2 pointer_registers(0 : 7) ptr,
  3    38     2 prev_sp pointer,
  3    39     2 next_sp pointer,
  3    40     2 return_ptr pointer,
  3    41     2 entry_ptr pointer,
  3    42     2 operator_and_lp_ptr ptr,			/* serves as both */
  3    43     2 arg_ptr pointer,
  3    44     2 static_ptr ptr unaligned,
  3    45     2 support_ptr ptr unal, /* only used by fortran I/O */
  3    46     2 on_unit_relp1 bit(18) unaligned,
  3    47     2 on_unit_relp2 bit(18) unaligned,
  3    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
  3    49*						   0 => PL/I version II
  3    50*						   1 => ALM
  3    51*						   2 => PL/I version I   
  3    52*						   3 => signal caller frame
  3    53*						   4 => signaller frame */
  3    54     2 operator_return_offset bit(18) unaligned,
  3    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
  3    56     2 a bit(36),					/* accumulator */
  3    57     2 q bit(36),					/* q-register */
  3    58     2 e bit(36),					/* exponent */
  3    59     2 timer bit(27) unaligned,				/* timer */
  3    60     2 pad bit(6) unaligned,
  3    61     2 ring_alarm_reg bit(3) unaligned;
  3    62 
  3    63 
  3    64 dcl 1 stack_frame_flags based(sp) aligned,
  3    65     2 pad(0 : 7) bit(72),				/* skip over prs */
  3    66     2 xx0 bit(22) unal,
  3    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
  3    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
  3    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
  3    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
  3    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
  3    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
  3    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
  3    74     2 condition bit(1) unal,				/* on if condition established in this frame */
  3    75     2 xx0a bit(6) unal,
  3    76     2 xx1 fixed bin,
  3    77     2 xx2 fixed bin,
  3    78     2 xx3 bit(25) unal,
  3    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
  3    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
  3    81     2 xx3a bit(9) unaligned,
  3    82     2 xx4(9) bit(72) aligned,
  3    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
  3    84*						*  operator puts a pointer to the base of
  3    85*						*  the calling procedure here. (text base ptr)  */
  3    86     2 xx5 bit(72) aligned,
  3    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
  3    88 
  3    89 /* format: on */
  3    90 
  3    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
      325 
  4     1 /* BEGIN INCLUDE FILE ... interpret_ptr_struc.incl.pl1 */
  4     2 
  4     3 dcl 1 struc based (strp) aligned,			/* This useful structure is in trace_stack pgms */
  4     4     2 comment char (64),				/* name of boundseg, or thing pointed to, or .. */
  4     5     2 segment char (32),				/* name of segment, or segment number with # */
  4     6     2 entryn char (33),				/* entry name, preceded by $, or blank */
  4     7     2 offset char (6),				/* offset in segment, or blank */
  4     8     2 opname char (32),				/* may be pl1 operator name */
  4     9     2 ring char (1) unal,				/* ring number of ptr */
  4    10     2 std_flag bit (1) unal,				/* TRUE if std object. */
  4    11     2 xpad bit (26) unal,
  4    12     2 bitoff char (4),				/* bit offset */
  4    13     2 modifier char (8),				/* ptr modifier, or special code like "noaccess" */
  4    14     2 symbolp ptr,					/* ptr to symbol section */
  4    15     2 instruction_counter fixed bin,			/* binary instruction counter */
  4    16     2 sourcemap fixed bin,				/* source map offset in symbol section */
  4    17     2 compiler char (8),				/* name of compiler */
  4    18     2 text_ptr ptr,					/* ptr to segment text */
  4    19     2 stack_ptr ptr;				/* ptr to stack frame */
  4    20 
  4    21 dcl 1 strbuf aligned like struc;			/* If referenced, will make storage for struc */
  4    22 
  4    23 /* END INCLUDE FILE ... interpret_ptr_struc.incl.pl1 */
      326 
  5     1 /* BEGIN INCLUDE FILE its.incl.pl1
  5     2*   modified 27 July 79 by JRDavis to add its_unsigned
  5     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
  5     4 
  5     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
  5     6     2 pad1 bit (3) unaligned,
  5     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
  5     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
  5     9     2 pad2 bit (9) unaligned,
  5    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
  5    11 
  5    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
  5    13     2 pad3 bit (3) unaligned,
  5    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
  5    15     2 pad4 bit (3) unaligned,
  5    16     2 mod bit (6) unaligned;				/* further modification */
  5    17 
  5    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
  5    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
  5    20     2 pad1 bit (27) unaligned,
  5    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
  5    22 
  5    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
  5    24     2 pad2 bit (3) unaligned,
  5    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
  5    26     2 pad3 bit (3) unaligned,
  5    27     2 mod bit (6) unaligned;				/* further modification */
  5    28 
  5    29 
  5    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
  5    31     2 pad1 bit (3) unaligned,
  5    32     2 segno fixed bin (15) unsigned unaligned,
  5    33     2 ringno fixed bin (3) unsigned unaligned,
  5    34     2 pad2 bit (9) unaligned,
  5    35     2 its_mod bit (6) unaligned,
  5    36 
  5    37     2 offset fixed bin (18) unsigned unaligned,
  5    38     2 pad3 bit (3) unaligned,
  5    39     2 bit_offset fixed bin (6) unsigned unaligned,
  5    40     2 pad4 bit (3) unaligned,
  5    41     2 mod bit (6) unaligned;
  5    42 
  5    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
  5    44     2 pr_no fixed bin (3) unsigned unaligned,
  5    45     2 pad1 bit (27) unaligned,
  5    46     2 itp_mod bit (6) unaligned,
  5    47 
  5    48     2 offset fixed bin (18) unsigned unaligned,
  5    49     2 pad2 bit (3) unaligned,
  5    50     2 bit_offset fixed bin (6) unsigned unaligned,
  5    51     2 pad3 bit (3) unaligned,
  5    52     2 mod bit (6) unaligned;
  5    53 
  5    54 
  5    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
  5    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
  5    57 
  5    58 /* END INCLUDE FILE   its.incl.pl1 */
      327 
  6     1 /* BEGIN INCLUDE FILE ... data_type_info_.incl.pl1
  6     2*
  6     3*   attributes of each Multics data type.  You may not rely on the dimension never exceeding 64
  6     4*   James R. Davis 6 Apr 79
  6     5*   Modified JMAthane June 83 to add "type" bit field 
  6     6*   Upped bound from 64 to 80 10/18/83 S. Herbst
  6     7*   Added "hex" and "generic" bits 01/23/84 S. Herbst
  6     8*   Upped bound from 80 to 86 01/81/84 R. Gray
  6     9*   Upper bound from 86 to 87 JMAthane (for Pascal strings type dtype)
  6    10**/
  6    11 
  6    12      
  6    13 /****^  HISTORY COMMENTS:
  6    14*  1) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
  6    15*     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1208):
  6    16*     The data_type_info array now has 87 entries instead of 86 due to
  6    17*     introduction of pascal_string_type_dtype.
  6    18*                                                   END HISTORY COMMENTS */
  6    19 
  6    20 dcl	   data_type_info_$version_number fixed bin external static;
  6    21      dcl	   data_type_info_this_version fixed bin internal static options (constant) init (1);
  6    22 
  6    23      dcl	   1 data_type_info_$info (87) aligned external static,
  6    24 	     2 computational      bit (1) unal,
  6    25 	     2 arithmetic	      bit (1) unal,
  6    26 	     2 arithmetic_attributes unal,		/* only valid if arithmetic */
  6    27 	       3 fixed	      bit (1) unal,		/* PL/I type */
  6    28 	       3 complex	      bit (1) unal,		/* PL/I mode */
  6    29 	       3 decimal	      bit (1) unal,		/* PL/I base */
  6    30 	       3 signed	      bit (1) unal,
  6    31 	       3 trailing_sign    bit (1) unal,		/* only valid if signed */
  6    32 	       3 decimal_attributes unal,		/* only valid if decimal */
  6    33 	         4 packed_dec     bit (1) unal,		/* 4 bits per digit or 9 */
  6    34 	         4 digit_aligned  bit (1) unal,		/* valid for packed_dec only */
  6    35 	         4 overpunched    bit (1) unal,
  6    36 	     2 char_string	      bit (1) unal,		/* valid for non-arithmetic */
  6    37 	     2 bit_string	      bit (1) unal,		/* valid for non-arithmetic */
  6    38 	     2 varying	      bit (1) unal,		/* for bit or char only */
  6    39 	     2 type	      bit (1) unal,		/* this symbol is a type */
  6    40 	     2 hex	      bit (1) unal,		/* a hexadecimal type (eg., hex floating point) */
  6    41 	     2 generic	      bit (1) unal,		/* eg., real_flt_dec_generic_dtype */
  6    42 	     2 pad	      bit (20) unal;
  6    43 
  6    44      dcl	   data_type_info_$ninebit_sign_chars char (2) external static;
  6    45      dcl	   data_type_info_$ninebit_digit_chars char (10) external static;
  6    46      dcl	   data_type_info_$ninebit_overpunched_sign_chars char (22) external static;
  6    47 
  6    48      dcl	   data_type_info_$max_decimal_precision fixed bin external static;
  6    49      dcl	   data_type_info_$max_float_binary_precision fixed bin external static;
  6    50      dcl	   data_type_info_$max_fixed_binary_precision fixed bin external static;
  6    51 
  6    52 
  6    53 /* END INCLUDE FILE ... data_type_info_.incl.pl1 */
      328 
  7     1 /* BEGIN INCLUDE FILE condition_info_header.incl.pl1 BIM 1981 */
  7     2 /* format: style2 */
  7     3 
  7     4      declare condition_info_header_ptr
  7     5 			      pointer;
  7     6      declare 1 condition_info_header
  7     7 			      aligned based (condition_info_header_ptr),
  7     8 	     2 length	      fixed bin,		/* length in words of this structure */
  7     9 	     2 version	      fixed bin,		/* version number of this structure */
  7    10 	     2 action_flags	      aligned,		/* tell handler how to proceed */
  7    11 	       3 cant_restart     bit (1) unaligned,	/* caller doesn't ever want to be returned to */
  7    12 	       3 default_restart  bit (1) unaligned,	/* caller can be returned to with no further action */
  7    13 	       3 quiet_restart    bit (1) unaligned,	/* return, and print no message */
  7    14 	       3 support_signal   bit (1) unaligned,	/* treat this signal as if the signalling procedure had the support bit set */
  7    15 						/* if the signalling procedure had the support bit set, do the same for its caller */
  7    16 	       3 pad	      bit (32) unaligned,
  7    17 	     2 info_string	      char (256) varying,	/* may contain printable message */
  7    18 	     2 status_code	      fixed bin (35);	/* if^=0, code interpretable by com_err_ */
  7    19 
  7    20 /* END INCLUDE FILE condition_info_header.incl.pl1 */
      329 
  8     1 /* BEGIN INCLUDE FILE ... std_descriptor_types.incl.pl1 */
  8     2 
  8     3 
  8     4 /****^  HISTORY COMMENTS:
  8     5*  1) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
  8     6*     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1208):
  8     7*     Added pascal_string_type_dtype descriptor type.  Its number is 87.
  8     8*     Objects of this type are PASCAL string types.
  8     9*  2) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  8    10*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  8    11*     Added the new C types.
  8    12*                                                   END HISTORY COMMENTS */
  8    13 
  8    14 /* This include file defines mnemonic names for the Multics
  8    15*   standard descriptor types, using both pl1 and cobol terminology.
  8    16*   PG 780613
  8    17*   JRD 790530
  8    18*   JRD 791016
  8    19*   MBW 810731
  8    20*   TGO 830614 Add hex types.
  8    21*   Modified June 83 JMAthane to add PASCAL data types
  8    22*   TGO 840120 Add float dec extended and generic, float binary generic
  8    23**/
  8    24 
  8    25      dcl	   (real_fix_bin_1_dtype  init (1),
  8    26 	   real_fix_bin_2_dtype   init (2),
  8    27 	   real_flt_bin_1_dtype   init (3),
  8    28 	   real_flt_bin_2_dtype   init (4),
  8    29 	   cplx_fix_bin_1_dtype   init (5),
  8    30 	   cplx_fix_bin_2_dtype   init (6),
  8    31 	   cplx_flt_bin_1_dtype   init (7),
  8    32 	   cplx_flt_bin_2_dtype   init (8),
  8    33 	   real_fix_dec_9bit_ls_dtype init (9),
  8    34 	   real_flt_dec_9bit_dtype init (10),
  8    35 	   cplx_fix_dec_9bit_ls_dtype init (11),
  8    36 	   cplx_flt_dec_9bit_dtype init (12),
  8    37 	   pointer_dtype	      init (13),
  8    38 	   offset_dtype	      init (14),
  8    39 	   label_dtype	      init (15),
  8    40 	   entry_dtype	      init (16),
  8    41 	   structure_dtype	      init (17),
  8    42 	   area_dtype	      init (18),
  8    43 	   bit_dtype	      init (19),
  8    44 	   varying_bit_dtype      init (20),
  8    45 	   char_dtype	      init (21),
  8    46 	   varying_char_dtype     init (22),
  8    47 	   file_dtype	      init (23),
  8    48 	   real_fix_dec_9bit_ls_overp_dtype init (29),
  8    49 	   real_fix_dec_9bit_ts_overp_dtype init (30),
  8    50 	   real_fix_bin_1_uns_dtype init (33),
  8    51 	   real_fix_bin_2_uns_dtype init (34),
  8    52 	   real_fix_dec_9bit_uns_dtype init (35),
  8    53 	   real_fix_dec_9bit_ts_dtype init (36),
  8    54 	   real_fix_dec_4bit_uns_dtype init (38),	/* digit-aligned */
  8    55 	   real_fix_dec_4bit_ts_dtype init (39),	/* byte-aligned */
  8    56 	   real_fix_dec_4bit_bytealigned_uns_dtype init (40), /* COBOL */
  8    57 	   real_fix_dec_4bit_ls_dtype init (41),	/* digit-aligned */
  8    58 	   real_flt_dec_4bit_dtype init (42),		/* digit-aligned */
  8    59 	   real_fix_dec_4bit_bytealigned_ls_dtype init (43),
  8    60 	   real_flt_dec_4bit_bytealigned_dtype init (44),
  8    61 	   cplx_fix_dec_4bit_bytealigned_ls_dtype init (45),
  8    62 	   cplx_flt_dec_4bit_bytealigned_dtype init (46),
  8    63 	   real_flt_hex_1_dtype   init (47),
  8    64 	   real_flt_hex_2_dtype   init (48),
  8    65 	   cplx_flt_hex_1_dtype   init (49),
  8    66 	   cplx_flt_hex_2_dtype   init (50),
  8    67 	   c_typeref_dtype        init (54),
  8    68 	   c_enum_dtype           init (55),
  8    69              c_enum_const_dtype     init (56),
  8    70 	   c_union_dtype          init (57),
  8    71 	   algol68_straight_dtype init (59),
  8    72 	   algol68_format_dtype   init (60),
  8    73 	   algol68_array_descriptor_dtype init (61),
  8    74 	   algol68_union_dtype    init (62),
  8    75 
  8    76 	   cobol_comp_6_dtype     init (1),
  8    77 	   cobol_comp_7_dtype     init (1),
  8    78 	   cobol_display_ls_dtype init (9),
  8    79 	   cobol_structure_dtype  init (17),
  8    80 	   cobol_char_string_dtype init (21),
  8    81 	   cobol_display_ls_overp_dtype init (29),
  8    82 	   cobol_display_ts_overp_dtype init (30),
  8    83 	   cobol_display_uns_dtype init (35),
  8    84 	   cobol_display_ts_dtype init (36),
  8    85 	   cobol_comp_8_uns_dtype init (38),		/* digit aligned */
  8    86 	   cobol_comp_5_ts_dtype  init (39),		/* byte aligned */
  8    87 	   cobol_comp_5_uns_dtype init (40),
  8    88 	   cobol_comp_8_ls_dtype  init (41),		/* digit aligned */
  8    89 	   real_flt_dec_extended_dtype init (81),	/* 9-bit exponent */
  8    90 	   cplx_flt_dec_extended_dtype init (82),	/* 9-bit exponent */
  8    91 	   real_flt_dec_generic_dtype init (83),	/* generic float decimal */
  8    92 	   cplx_flt_dec_generic_dtype init (84),
  8    93 	   real_flt_bin_generic_dtype init (85),	/* generic float binary */
  8    94 	   cplx_flt_bin_generic_dtype init (86)) fixed bin internal static options (constant);
  8    95 
  8    96      dcl	   (ft_integer_dtype      init (1),
  8    97 	   ft_real_dtype	      init (3),
  8    98 	   ft_double_dtype	      init (4),
  8    99 	   ft_complex_dtype	      init (7),
  8   100 	   ft_complex_double_dtype init (8),
  8   101 	   ft_external_dtype      init (16),
  8   102 	   ft_logical_dtype	      init (19),
  8   103 	   ft_char_dtype	      init (21),
  8   104 	   ft_hex_real_dtype      init (47),
  8   105 	   ft_hex_double_dtype    init (48),
  8   106 	   ft_hex_complex_dtype   init (49),
  8   107 	   ft_hex_complex_double_dtype init (50)
  8   108 	   )		      fixed bin internal static options (constant);
  8   109 
  8   110      dcl	   (algol68_short_int_dtype init (1),
  8   111 	   algol68_int_dtype      init (1),
  8   112 	   algol68_long_int_dtype init (2),
  8   113 	   algol68_real_dtype     init (3),
  8   114 	   algol68_long_real_dtype init (4),
  8   115 	   algol68_compl_dtype    init (7),
  8   116 	   algol68_long_compl_dtype init (8),
  8   117 	   algol68_bits_dtype     init (19),
  8   118 	   algol68_bool_dtype     init (19),
  8   119 	   algol68_char_dtype     init (21),
  8   120 	   algol68_byte_dtype     init (21),
  8   121 	   algol68_struct_struct_char_dtype init (22),
  8   122 	   algol68_struct_struct_bool_dtype init (20)
  8   123 	   )		      fixed bin internal static options (constant);
  8   124 
  8   125      dcl	   (label_constant_runtime_dtype init (24),
  8   126 	   int_entry_runtime_dtype init (25),
  8   127 	   ext_entry_runtime_dtype init (26),
  8   128 	   ext_procedure_runtime_dtype init (27),
  8   129 	   picture_runtime_dtype  init (63)
  8   130 	   )		      fixed bin internal static options (constant);
  8   131 
  8   132      dcl	   (pascal_integer_dtype  init (1),
  8   133 	   pascal_real_dtype      init (4),
  8   134 	   pascal_label_dtype     init (24),
  8   135 	   pascal_internal_procedure_dtype init (25),
  8   136 	   pascal_exportable_procedure_dtype init (26),
  8   137 	   pascal_imported_procedure_dtype init (27),
  8   138 	   pascal_typed_pointer_type_dtype init (64),
  8   139 	   pascal_char_dtype      init (65),
  8   140 	   pascal_boolean_dtype   init (66),
  8   141 	   pascal_record_file_type_dtype init (67),
  8   142 	   pascal_record_type_dtype init (68),
  8   143 	   pascal_set_dtype	      init (69),
  8   144 	   pascal_enumerated_type_dtype init (70),
  8   145 	   pascal_enumerated_type_element_dtype init (71),
  8   146 	   pascal_enumerated_type_instance_dtype init (72),
  8   147 	   pascal_user_defined_type_dtype init (73),
  8   148 	   pascal_user_defined_type_instance_dtype init (74),
  8   149 	   pascal_text_file_dtype init (75),
  8   150 	   pascal_procedure_type_dtype init (76),
  8   151 	   pascal_variable_formal_parameter_dtype init (77),
  8   152 	   pascal_value_formal_parameter_dtype init (78),
  8   153 	   pascal_entry_formal_parameter_dtype init (79),
  8   154 	   pascal_parameter_procedure_dtype init (80),
  8   155 	   pascal_string_type_dtype init (87)) fixed bin int static options (constant);
  8   156 
  8   157 
  8   158 /* END INCLUDE FILE ... std_descriptor_types.incl.pl1 */
      330 
  9     1 /* BEGIN INCLUDE FILE ... probe_data_type_names.incl.pl1
  9     2*
  9     3*   Extracted from psi.pl1 by JRDavis 15 Sept 79
  9     4*   This crude gem is used by probe_print_arglist_
  9     5*   algol68 type names added 7/31/81 by MBW
  9     6*   Added pascal data type names 10/18/83 S. Herbst
  9     7*   Added hex floating point, extended, and generic types 02/08/84 S. Herbst
  9     8*
  9     9**/
  9    10 
  9    11 dcl  type_name (0:80) char (40) static options (constant) init (
  9    12      "bad type 0",					/* 0 */
  9    13      "fixed bin",					/* 1 */
  9    14      "fixed bin",					/* 2 */
  9    15      "float bin",					/* 3 */
  9    16      "float bin",					/* 4 */
  9    17      "complex fixed bin",				/* 5 */
  9    18      "complex fixed bin",				/* 6 */
  9    19      "complex float bin",				/* 7 */
  9    20      "complex float bin",				/* 8 */
  9    21      "fixed dec",					/* 9 */
  9    22      "float dec",					/* 10 */
  9    23      "complex fixed dec",				/* 11 */
  9    24      "complex float dec",				/* 12 */
  9    25      "pointer",					/* 13 */
  9    26      "offset",					/* 14 */
  9    27      "label variable",				/* 15 */
  9    28      "entry variable",				/* 16 */
  9    29      "structure",					/* 17 */
  9    30      "area",					/* 18 */
  9    31      "bit",					/* 19 */
  9    32      "varying bit",					/* 20 */
  9    33      "char",					/* 21 */
  9    34      "varying char",				/* 22 */
  9    35      "file",					/* 23 */
  9    36      "label constant",				/* 24 */
  9    37      "internal entry ",				/* 25 */
  9    38      "external entry",				/* 26 */
  9    39      "external procedure",				/* 27 */
  9    40      "bad type 28",					/* 28 */
  9    41      "overpunched ls",				/* 29 */
  9    42      "overpunched ts",				/* 30 */
  9    43      "bad type 31",					/* 31 */
  9    44      "bad type 32",					/* 32 */
  9    45      "unsigned binary",				/* 33 */
  9    46      "unsigned binary",				/* 34 */
  9    47      "unsigned dec",				/* 35 */
  9    48      "fixed dec ts",				/* 36 */
  9    49      "bad type 37",					/* 37 */
  9    50      "fixed dec digit uns",				/* 38 */
  9    51      "fixed dec digit ts",				/* 39 */
  9    52      "bad type 40",					/* 40 */
  9    53      "fixed dec  digit ls",				/* 41 */
  9    54      "float dec digit",				/* 42 */
  9    55      "fixed dec byte",				/* 43 */
  9    56      "float dec byte ",				/* 44 */
  9    57      "cmplx fixed dec byte",				/* 45 */
  9    58      "cmplx float dec byte",				/* 46 */
  9    59      "float hex",					/* 47 */
  9    60      "float hex",					/* 48 */
  9    61      "complex float hex",				/* 49 */
  9    62      "complex float hex",				/* 50 */
  9    63      "bad type 51",					/* 51 */
  9    64      "bad type 52",					/* 52 */
  9    65      "bad type 53",					/* 53 */
  9    66      "bad type 54",					/* 54 */
  9    67      "bad type 55",					/* 55 */
  9    68      "bad type 56",					/* 56 */
  9    69      "bad type 57",					/* 57 */
  9    70      "bad type 58",					/* 58 */
  9    71      "algol68 straight",				/* 59 */
  9    72      "algol68 format",				/* 60 */
  9    73      "algol68 array descriptor",			/* 61 */
  9    74      "algol68 union",				/* 62 */
  9    75      "picture",					/* 63 */
  9    76      "pascal typed pointer type",			/* 64 */
  9    77      "pascal char",					/* 65 */
  9    78      "pascal boolean",				/* 66 */
  9    79      "pascal record file type",			/* 67 */
  9    80      "pascal record type",				/* 68 */
  9    81      "pascal set type",				/* 69 */
  9    82      "pascal enumerated type",			/* 70 */
  9    83      "pascal enumerated type element",			/* 71 */
  9    84      "pascal enumerated type instance",			/* 72 */
  9    85      "pascal user defined type",			/* 73 */
  9    86      "pascal user defined type instance",		/* 74 */
  9    87      "pascal text file",				/* 75 */
  9    88      "pascal procedure type",				/* 76 */
  9    89      "pascal variable formal parameter",		/* 77 */
  9    90      "pascal value formal parameter",			/* 78 */
  9    91      "pascal entry formal parameter",			/* 79 */
  9    92      "pascal parameter procedure"			/* 80 */
  9    93      );
  9    94 
  9    95 
  9    96 /* END INCLUDE FILE probe_data_type_names.incl.pl1 */
      331 
      332 
      333      end display_argument_list_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/24/88  1400.2  display_argument_list_.pl1        >special_ldd>install>MR12.2-1184>display_argument_list_.pl1
323          1    08/05/86  0856.8  arg_list.incl.pl1                 >ldd>include>arg_list.incl.pl1
324          2    05/01/86  0849.8  entry_desc_info.incl.pl1          >ldd>include>entry_desc_info.incl.pl1
325          3    11/07/86  1550.3  stack_frame.incl.pl1              >ldd>include>stack_frame.incl.pl1
326          4    06/11/74  0602.3  interpret_ptr_struc.incl.pl1      >ldd>include>interpret_ptr_struc.incl.pl1
327          5    11/26/79  1320.6  its.incl.pl1                      >ldd>include>its.incl.pl1
328          6    11/12/86  1748.0  data_type_info_.incl.pl1          >ldd>include>data_type_info_.incl.pl1
329          7    03/24/82  1347.2  condition_info_header.incl.pl1    >ldd>include>condition_info_header.incl.pl1
330          8    10/24/88  1336.9  std_descriptor_types.incl.pl1     >special_ldd>install>MR12.2-1184>std_descriptor_types.incl.pl1
331          9    12/04/84  2012.1  probe_data_type_names.incl.pl1    >ldd>include>probe_data_type_names.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Amup                                   parameter       pointer                  dcl 32 ref 20
Argp                                   parameter       pointer                  dcl 34 ref 20 97
Entryp                                 parameter       pointer                  dcl 35 ref 20 96
Farg                                   parameter       fixed bin(17,0)          dcl 36 ref 20 150
Framep                                 parameter       pointer                  dcl 33 ref 20 95
ITS_MODIFIER                           constant        bit(6)                   initial packed unaligned dcl 5-55 ref 221 250
Iocb                                   parameter       pointer                  dcl 38 set ref 20 106* 111* 123* 132* 136* 145* 148*
                                                                                  184* 190* 194* 197* 200* 205* 210* 234* 237* 242*
                                                                                  254* 257* 260* 267* 279* 286* 291* 292* 293* 296*
                                                                                  298* 319*
LEGAL                           001452 constant        char(96)                 initial packed unaligned dcl 90 ref 225
Larg                                   parameter       fixed bin(17,0)          dcl 36 ref 20 151
Lmarg                                  parameter       fixed bin(17,0)          dcl 37 set ref 20 106* 111* 123* 132* 136* 145* 148*
                                                                                  184* 190* 194* 197* 200* 205* 210* 234* 237* 242*
                                                                                  254* 257* 260* 267* 279* 286* 291* 296* 298* 319*
action_flags              2            based           structure                level 2 dcl 7-6
addr                                                   builtin function         dcl 40 ref 115 127
addrel                                                 builtin function         dcl 40 ref 105 274 285
ap                              000112 automatic       pointer                  dcl 46 set ref 97* 100 100* 102 116 117 119 119 119
                                                                                  142 143 144 157 174*
arg_count                              based           fixed bin(17,0)          level 3 in structure "arg_list" packed packed
                                                                                  unsigned unaligned dcl 1-14 in procedure
                                                                                  "display_argument_list_" ref 116
arg_count                              based           fixed bin(17,0)          level 3 in structure "command_name_arglist" packed
                                                                                  packed unsigned unaligned dcl 1-25 in procedure
                                                                                  "display_argument_list_" ref 143 143 144 144
arg_id                          000340 automatic       char(7)                  packed unaligned dcl 57 set ref 164* 166* 171 184*
                                                                                  190* 194* 197* 200* 205* 210* 234* 237* 242* 254*
                                                                                  257* 260* 267* 279* 286* 291* 296* 319*
arg_list                               based           structure                level 1 dcl 1-14
arg_ptr                  32            based           pointer                  level 2 dcl 3-36 ref 100
arg_ptrs                  2            based           pointer                  array level 2 dcl 1-25 ref 157
argp                            000106 automatic       pointer                  dcl 44 set ref 143* 145 157* 171* 171 221 225 234
                                                                                  237* 237 241* 247 250 251 257 257 260 266 266 267
                                                                                  267 274 275 275 285 286 292 293* 296* 296
arithmetic                0(01) 000032 external static bit(1)                   array level 2 packed packed unaligned dcl 6-23 ref
                                                                                  240
arithmetic_to_ascii_            000026 constant        entry                    external dcl 72 ref 241
ascii_representation            000366 automatic       varying char(132)        dcl 59 set ref 241* 242* 275* 277* 279*
based_bit                              based           bit(36)                  dcl 80 ref 105
based_file                             based           file variable            dcl 82 set ref 292*
based_ptr                              based           pointer                  dcl 75 ref 171 251
bcs                                    based           char(100)                packed unaligned dcl 78 ref 225
begin_block_entries             001502 constant        bit(36)                  initial array dcl 62 ref 103 105
bit_dtype                              constant        fixed bin(17,0)          initial dcl 8-25 ref 271
bit_string                             based           bit                      packed unaligned dcl 81 ref 275 275
call_type                 0(18)        based           fixed bin(18,0)          level 3 packed packed unsigned unaligned dcl 1-25
                                                                                  ref 119 119
char_dtype                             constant        fixed bin(17,0)          initial dcl 8-25 ref 190 228 282
char_string                            based           char                     packed unaligned dcl 79 set ref 145* 286*
character                                              builtin function         dcl 40 ref 275
cleanup                         000100 stack reference condition                dcl 42 ref 154
cname                                  parameter       char                     packed unaligned dcl 307 set ref 304 311 311 311
                                                                                  319*
command_name_arglist                   based           structure                level 1 dcl 1-25
command_name_length                    based           fixed bin(21,0)          level 3 dcl 1-25 ref 144
command_name_ptr                       based           pointer                  level 3 dcl 1-25 ref 143
comment                                based           char(64)                 level 2 dcl 4-3 set ref 254* 267*
condition_                      000010 constant        entry                    external dcl 65 ref 153
condition_info_header                  based           structure                level 1 dcl 7-6
cont                                   parameter       bit(1)                   packed unaligned dcl 307 set ref 304 312*
cop                                    parameter       pointer                  dcl 307 ref 304
data_type_info_$info            000032 external static structure                array level 1 dcl 6-23 ref 178 178 181 181 237 237
decode_descriptor_              000014 constant        entry                    external dcl 67 ref 169 174 218
desc_count                1            based           fixed bin(17,0)          level 3 packed packed unsigned unaligned dcl 1-14
                                                                                  ref 117
display_file_value_             000030 constant        entry                    external dcl 73 ref 292
ec                              000337 automatic       fixed bin(35,0)          dcl 55 set ref 130* 292*
edi                             000432 automatic       structure                level 1 dcl 84 set ref 127
entry_desc_info                        based           structure                level 1 dcl 2-34 set ref 128*
entry_desc_info_ptr             000440 automatic       pointer                  dcl 2-49 set ref 127* 128 129 130* 164
entry_desc_info_version_2              constant        fixed bin(17,0)          initial dcl 2-49 ref 129
entry_dtype                            constant        fixed bin(17,0)          initial dcl 8-25 ref 263
entry_ptr                26            based           pointer                  level 2 dcl 3-36 ref 99
entryn                   30            based           char(33)                 level 2 dcl 4-3 set ref 254* 267*
ep                              000110 automatic       pointer                  dcl 45 set ref 96* 99 99* 103 105 130*
file_dtype                             constant        fixed bin(17,0)          initial dcl 8-25 ref 289
flags                     1            based           structure                level 2 dcl 2-34
function                  1(04)        based           bit(1)                   level 3 packed packed unaligned dcl 2-34 set ref 164
fword                                  based           fixed bin(35,0)          array dcl 77 set ref 234* 237* 257* 257* 260* 274
                                                                                  285 296*
get_entry_arg_descs_$info       000012 constant        entry                    external dcl 66 ref 130
has_command_name          1(18)        based           bit(1)                   level 3 packed packed unaligned dcl 1-25 ref 142
hbound                                                 builtin function         dcl 40 ref 103 178 181 237
header                                 based           structure                level 2 in structure "arg_list" dcl 1-14
                                                                                  in procedure "display_argument_list_"
header                                 based           structure                level 2 in structure "command_name_arglist" dcl 1-25
                                                                                  in procedure "display_argument_list_"
infop                                  parameter       pointer                  dcl 307 ref 304 316 316
interpret_ptr_                  000016 constant        entry                    external dcl 68 ref 252 266
ioa_$ioa_switch                 000020 constant        entry                    external dcl 69 ref 106 111 123 132 136 145 148 184
                                                                                  190 194 197 200 205 210 234 237 242 254 257 260
                                                                                  267 279 286 293 296 298 319
ioa_$ioa_switch_nnl             000022 constant        entry                    external dcl 70 ref 291
ioa_$rsnnl                      000024 constant        entry                    external dcl 71 ref 166 180 183 277
its                                    based           structure                level 1 dcl 5-5
its_mod                   0(30)        based           bit(6)                   level 2 packed packed unaligned dcl 5-5 ref 221 250
j                               000320 automatic       fixed bin(17,0)          dcl 51 set ref 103* 105* 156* 157 164 166* 167 167
                                                                                  169 174* 175 175 215 216 218*
k                               000321 automatic       fixed bin(17,0)          dcl 51 set ref 166* 180* 183*
label_dtype                            constant        fixed bin(17,0)          initial dcl 8-25 ref 263
label_variable                         based           structure                level 1 dcl 86
lbound                                                 builtin function         dcl 40 ref 178 181 237
max                                                    builtin function         dcl 40 ref 150 285
max_arg                         000323 automatic       fixed bin(17,0)          dcl 52 set ref 151* 156
mbz                       1(17)        based           bit(1)                   level 3 packed packed unaligned dcl 1-25 ref 119
mcp                                    parameter       pointer                  dcl 307 ref 304
min                                                    builtin function         dcl 40 ref 151 275 285
min_arg                         000322 automatic       fixed bin(17,0)          dcl 52 set ref 150* 156
name                                   based           structure                level 2 dcl 1-25
ndims                           000331 automatic       fixed bin(17,0)          dcl 53 set ref 161* 174* 197 197* 218* 298 298*
no_args                         000326 automatic       fixed bin(17,0)          dcl 53 set ref 116* 119 132 132* 135 148 148* 151
no_desc                         000327 automatic       fixed bin(17,0)          dcl 53 set ref 117* 119 119 173
null                                                   builtin function         dcl 40 ref 99 100 102 103 167 175 216 252 252 316
offset                   41            based           char(6)                  level 2 dcl 4-3 set ref 254* 267*
offset_dtype                           constant        fixed bin(17,0)          initial dcl 8-25 ref 260
packed                          000430 automatic       bit(1)                   dcl 61 set ref 160* 174* 187 218* 241* 246
packptr                                based           pointer                  packed unaligned dcl 76 ref 247
pointer_dtype                          constant        fixed bin(17,0)          initial dcl 8-25 ref 200 221 245
ptr                                    based           pointer                  level 2 dcl 86 set ref 266* 267*
quiet_restart             2(02)        based           bit(1)                   level 3 packed packed unaligned dcl 7-6 ref 316
scale                           000332 automatic       fixed bin(17,0)          dcl 53 set ref 163* 174* 210 210* 218* 241*
segment                  20            based           char(32)                 level 2 dcl 4-3 set ref 254* 267*
sp                              000442 automatic       pointer                  dcl 3-31 set ref 95* 99 100
stack                     2            based           pointer                  level 2 dcl 86 set ref 266* 267*
stack_frame                            based           structure                level 1 dcl 3-36
strbuf                          000444 automatic       structure                level 1 dcl 4-21 set ref 115
strl                            000330 automatic       fixed bin(17,0)          dcl 53 set ref 144* 145 145 145 162* 174* 200 200*
                                                                                  205* 218* 225* 227 227* 228 230* 241* 274* 275 275
                                                                                  275 277* 285* 286* 286 286
strp                            000114 automatic       pointer                  dcl 47 set ref 115* 252* 254 254 254 254 266* 267
                                                                                  267 267 267
struc                                  based           structure                level 1 dcl 4-3
substr                                                 builtin function         dcl 40 ref 275
tp                              000116 automatic       pointer                  dcl 48 set ref 247* 251* 252* 254*
ttype                           000342 automatic       char(40)                 packed unaligned dcl 58 set ref 178* 180* 184*
type                            000324 automatic       fixed bin(17,0)          dcl 52 set ref 159* 174* 177 178 178 178 180* 218*
                                                                                  221* 228* 234 237 237 237* 240 241* 245 260 263
                                                                                  263 271 271 274 282 282 285 289 296
type_name                       000000 constant        char(40)                 initial array packed unaligned dcl 9-11 set ref 178
                                                                                  181 296*
unspec                                                 builtin function         dcl 40 set ref 128*
varying_bit_dtype                      constant        fixed bin(17,0)          initial dcl 8-25 ref 271 274
varying_char_dtype                     constant        fixed bin(17,0)          initial dcl 8-25 ref 282 285
verify                                                 builtin function         dcl 40 ref 225
version                                based           fixed bin(17,0)          level 2 dcl 2-34 set ref 129*
xdesc                           000120 automatic       pointer                  array dcl 49 set ref 130* 167 169* 175 216 218*
xnargs                          000336 automatic       fixed bin(17,0)          dcl 54 set ref 130* 132 132 132* 164 167 175 215
xndims                          000334 automatic       fixed bin(17,0)          dcl 54 set ref 161* 169* 197 197*
xpacked                         000431 automatic       bit(1)                   dcl 61 set ref 160* 169* 187 189
xscale                          000335 automatic       fixed bin(17,0)          dcl 54 set ref 163* 169* 210 210*
xstrl                           000333 automatic       fixed bin(17,0)          dcl 54 set ref 162* 169* 171 200 200* 205 205*
xttype                          000354 automatic       char(40)                 packed unaligned dcl 58 set ref 181* 183* 184*
xtype                           000325 automatic       fixed bin(17,0)          dcl 52 set ref 159* 169* 177 181 181 181 183* 190
                                                                                  200

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Envptr_supplied_call_type              internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 1-54
ITP_MODIFIER                           internal static bit(6)                   initial packed unaligned dcl 5-56
Interseg_call_type                     internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 1-54
Quick_call_type                        internal static fixed bin(18,0)          initial packed unsigned unaligned dcl 1-54
RETURN_PTR_MASK                        internal static bit(72)                  initial packed unaligned dcl 3-19
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial packed unaligned dcl 3-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial packed unaligned dcl 3-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial packed unaligned dcl 3-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial packed unaligned dcl 3-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial packed unaligned dcl 3-27
algol68_array_descriptor_dtype         internal static fixed bin(17,0)          initial dcl 8-25
algol68_bits_dtype                     internal static fixed bin(17,0)          initial dcl 8-110
algol68_bool_dtype                     internal static fixed bin(17,0)          initial dcl 8-110
algol68_byte_dtype                     internal static fixed bin(17,0)          initial dcl 8-110
algol68_char_dtype                     internal static fixed bin(17,0)          initial dcl 8-110
algol68_compl_dtype                    internal static fixed bin(17,0)          initial dcl 8-110
algol68_format_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
algol68_int_dtype                      internal static fixed bin(17,0)          initial dcl 8-110
algol68_long_compl_dtype               internal static fixed bin(17,0)          initial dcl 8-110
algol68_long_int_dtype                 internal static fixed bin(17,0)          initial dcl 8-110
algol68_long_real_dtype                internal static fixed bin(17,0)          initial dcl 8-110
algol68_real_dtype                     internal static fixed bin(17,0)          initial dcl 8-110
algol68_short_int_dtype                internal static fixed bin(17,0)          initial dcl 8-110
algol68_straight_dtype                 internal static fixed bin(17,0)          initial dcl 8-25
algol68_struct_struct_bool_dtype       internal static fixed bin(17,0)          initial dcl 8-110
algol68_struct_struct_char_dtype       internal static fixed bin(17,0)          initial dcl 8-110
algol68_union_dtype                    internal static fixed bin(17,0)          initial dcl 8-25
area_dtype                             internal static fixed bin(17,0)          initial dcl 8-25
arg_list_with_envptr                   based           structure                level 1 dcl 1-42
c_enum_const_dtype                     internal static fixed bin(17,0)          initial dcl 8-25
c_enum_dtype                           internal static fixed bin(17,0)          initial dcl 8-25
c_typeref_dtype                        internal static fixed bin(17,0)          initial dcl 8-25
c_union_dtype                          internal static fixed bin(17,0)          initial dcl 8-25
cobol_char_string_dtype                internal static fixed bin(17,0)          initial dcl 8-25
cobol_comp_5_ts_dtype                  internal static fixed bin(17,0)          initial dcl 8-25
cobol_comp_5_uns_dtype                 internal static fixed bin(17,0)          initial dcl 8-25
cobol_comp_6_dtype                     internal static fixed bin(17,0)          initial dcl 8-25
cobol_comp_7_dtype                     internal static fixed bin(17,0)          initial dcl 8-25
cobol_comp_8_ls_dtype                  internal static fixed bin(17,0)          initial dcl 8-25
cobol_comp_8_uns_dtype                 internal static fixed bin(17,0)          initial dcl 8-25
cobol_display_ls_dtype                 internal static fixed bin(17,0)          initial dcl 8-25
cobol_display_ls_overp_dtype           internal static fixed bin(17,0)          initial dcl 8-25
cobol_display_ts_dtype                 internal static fixed bin(17,0)          initial dcl 8-25
cobol_display_ts_overp_dtype           internal static fixed bin(17,0)          initial dcl 8-25
cobol_display_uns_dtype                internal static fixed bin(17,0)          initial dcl 8-25
cobol_structure_dtype                  internal static fixed bin(17,0)          initial dcl 8-25
condition_info_header_ptr              automatic       pointer                  dcl 7-4
cplx_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
cplx_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
cplx_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 8-25
cplx_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
data_type_info_$max_decimal_precision  external static fixed bin(17,0)          dcl 6-48
data_type_info_$max_fixed_binary_precision
                                       external static fixed bin(17,0)          dcl 6-50
data_type_info_$max_float_binary_precision
                                       external static fixed bin(17,0)          dcl 6-49
data_type_info_$ninebit_digit_chars    external static char(10)                 packed unaligned dcl 6-45
data_type_info_$ninebit_overpunched_sign_chars
                                       external static char(22)                 packed unaligned dcl 6-46
data_type_info_$ninebit_sign_chars     external static char(2)                  packed unaligned dcl 6-44
data_type_info_$version_number         external static fixed bin(17,0)          dcl 6-20
data_type_info_this_version            internal static fixed bin(17,0)          initial dcl 6-21
ext_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 8-125
ext_procedure_runtime_dtype            internal static fixed bin(17,0)          initial dcl 8-125
ft_char_dtype                          internal static fixed bin(17,0)          initial dcl 8-96
ft_complex_double_dtype                internal static fixed bin(17,0)          initial dcl 8-96
ft_complex_dtype                       internal static fixed bin(17,0)          initial dcl 8-96
ft_double_dtype                        internal static fixed bin(17,0)          initial dcl 8-96
ft_external_dtype                      internal static fixed bin(17,0)          initial dcl 8-96
ft_hex_complex_double_dtype            internal static fixed bin(17,0)          initial dcl 8-96
ft_hex_complex_dtype                   internal static fixed bin(17,0)          initial dcl 8-96
ft_hex_double_dtype                    internal static fixed bin(17,0)          initial dcl 8-96
ft_hex_real_dtype                      internal static fixed bin(17,0)          initial dcl 8-96
ft_integer_dtype                       internal static fixed bin(17,0)          initial dcl 8-96
ft_logical_dtype                       internal static fixed bin(17,0)          initial dcl 8-96
ft_real_dtype                          internal static fixed bin(17,0)          initial dcl 8-96
int_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 8-125
itp                                    based           structure                level 1 dcl 5-18
itp_unsigned                           based           structure                level 1 dcl 5-43
its_unsigned                           based           structure                level 1 dcl 5-30
label_constant_runtime_dtype           internal static fixed bin(17,0)          initial dcl 8-125
pascal_boolean_dtype                   internal static fixed bin(17,0)          initial dcl 8-132
pascal_char_dtype                      internal static fixed bin(17,0)          initial dcl 8-132
pascal_entry_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 8-132
pascal_enumerated_type_dtype           internal static fixed bin(17,0)          initial dcl 8-132
pascal_enumerated_type_element_dtype   internal static fixed bin(17,0)          initial dcl 8-132
pascal_enumerated_type_instance_dtype  internal static fixed bin(17,0)          initial dcl 8-132
pascal_exportable_procedure_dtype      internal static fixed bin(17,0)          initial dcl 8-132
pascal_imported_procedure_dtype        internal static fixed bin(17,0)          initial dcl 8-132
pascal_integer_dtype                   internal static fixed bin(17,0)          initial dcl 8-132
pascal_internal_procedure_dtype        internal static fixed bin(17,0)          initial dcl 8-132
pascal_label_dtype                     internal static fixed bin(17,0)          initial dcl 8-132
pascal_parameter_procedure_dtype       internal static fixed bin(17,0)          initial dcl 8-132
pascal_procedure_type_dtype            internal static fixed bin(17,0)          initial dcl 8-132
pascal_real_dtype                      internal static fixed bin(17,0)          initial dcl 8-132
pascal_record_file_type_dtype          internal static fixed bin(17,0)          initial dcl 8-132
pascal_record_type_dtype               internal static fixed bin(17,0)          initial dcl 8-132
pascal_set_dtype                       internal static fixed bin(17,0)          initial dcl 8-132
pascal_string_type_dtype               internal static fixed bin(17,0)          initial dcl 8-132
pascal_text_file_dtype                 internal static fixed bin(17,0)          initial dcl 8-132
pascal_typed_pointer_type_dtype        internal static fixed bin(17,0)          initial dcl 8-132
pascal_user_defined_type_dtype         internal static fixed bin(17,0)          initial dcl 8-132
pascal_user_defined_type_instance_dtype
                                       internal static fixed bin(17,0)          initial dcl 8-132
pascal_value_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 8-132
pascal_variable_formal_parameter_dtype internal static fixed bin(17,0)          initial dcl 8-132
picture_runtime_dtype                  internal static fixed bin(17,0)          initial dcl 8-125
real_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
real_fix_bin_1_uns_dtype               internal static fixed bin(17,0)          initial dcl 8-25
real_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
real_fix_bin_2_uns_dtype               internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_4bit_bytealigned_uns_dtype
                                       internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_4bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_4bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_4bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_9bit_ls_overp_dtype       internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_9bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_9bit_ts_overp_dtype       internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_9bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 8-25
real_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
real_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
real_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 8-25
real_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 8-25
real_flt_dec_4bit_dtype                internal static fixed bin(17,0)          initial dcl 8-25
real_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 8-25
real_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 8-25
real_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 8-25
real_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
real_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
stack_frame_flags                      based           structure                level 1 dcl 3-64
stack_frame_min_length                 internal static fixed bin(17,0)          initial dcl 3-33
structure_dtype                        internal static fixed bin(17,0)          initial dcl 8-25

NAMES DECLARED BY EXPLICIT CONTEXT.
display_argument_list_          002131 constant        entry                    external dcl 20
guess                           003574 constant        label                    dcl 221 ref 216
intproc                         005022 constant        entry                    internal dcl 304 ref 153 153
pptr                            004050 constant        label                    dcl 252 ref 248
skiparg                         005016 constant        label                    dcl 300 ref 320

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5514        5550    5335        5524
Length      6172    5335        34         406     156           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
display_argument_list_              698 external procedure  is an external procedure.  
on unit on line 154                  64 on unit               
intproc                              96 internal procedure  is assigned to an entry variable.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
display_argument_list_   000106 argp                        display_argument_list_
                         000110 ep                          display_argument_list_
                         000112 ap                          display_argument_list_
                         000114 strp                        display_argument_list_
                         000116 tp                          display_argument_list_
                         000120 xdesc                       display_argument_list_
                         000320 j                           display_argument_list_
                         000321 k                           display_argument_list_
                         000322 min_arg                     display_argument_list_
                         000323 max_arg                     display_argument_list_
                         000324 type                        display_argument_list_
                         000325 xtype                       display_argument_list_
                         000326 no_args                     display_argument_list_
                         000327 no_desc                     display_argument_list_
                         000330 strl                        display_argument_list_
                         000331 ndims                       display_argument_list_
                         000332 scale                       display_argument_list_
                         000333 xstrl                       display_argument_list_
                         000334 xndims                      display_argument_list_
                         000335 xscale                      display_argument_list_
                         000336 xnargs                      display_argument_list_
                         000337 ec                          display_argument_list_
                         000340 arg_id                      display_argument_list_
                         000342 ttype                       display_argument_list_
                         000354 xttype                      display_argument_list_
                         000366 ascii_representation        display_argument_list_
                         000430 packed                      display_argument_list_
                         000431 xpacked                     display_argument_list_
                         000432 edi                         display_argument_list_
                         000440 entry_desc_info_ptr         display_argument_list_
                         000442 sp                          display_argument_list_
                         000444 strbuf                      display_argument_list_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        return_mac          tra_ext_1
enable_op           shorten_stack       ext_entry           int_entry           int_entry_desc      any_to_any_truncate_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
arithmetic_to_ascii_          condition_                    decode_descriptor_            display_file_value_
get_entry_arg_descs_$info     interpret_ptr_                ioa_$ioa_switch               ioa_$ioa_switch_nnl
ioa_$rsnnl

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
data_type_info_$info




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     20 002122        95 002136        96 002142        97 002145        99 002150       100 002156       102 002164
    103 002170       105 002201       106 002206       107 002233       109 002234       111 002236       112 002266
    115 002267       116 002271       117 002274       119 002277       123 002315       124 002340       127 002341
    128 002343       129 002346       130 002350       132 002377       135 002436       136 002440       137 002470
    142 002471       143 002475       144 002505       145 002507       148 002543       150 002576       151 002604
    153 002614       154 002640       156 002655       157 002665       159 002671       160 002674       161 002676
    162 002700       163 002702       164 002704       166 002716       167 002744       169 002757       171 003003
    173 003015       174 003017       175 003042       177 003053       178 003056       180 003071       181 003117
    183 003132       184 003160       187 003220       189 003227       190 003231       193 003265       194 003266
    197 003317       200 003361       205 003427       210 003471       214 003533       215 003534       216 003537
    218 003546       219 003573       221 003574       225 003603       227 003615       228 003620       230 003625
    234 003626       237 003671       240 003741       241 003746       242 003766       243 004024       245 004025
    246 004027       247 004032       248 004040       250 004041       251 004045       252 004050       254 004064
    256 004144       257 004145       258 004210       260 004211       263 004252       266 004256       267 004271
    269 004352       271 004353       274 004357       275 004365       277 004445       279 004475       280 004533
    282 004534       285 004540       286 004554       287 004620       289 004621       291 004623       292 004652
    293 004666       294 004713       296 004714       298 004761       300 005016       302 005020       304 005021
    311 005035       312 005053       313 005057       316 005060       319 005071       320 005127


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
