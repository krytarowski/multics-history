	COMPILATION LISTING OF SEGMENT cumulative_page_trace
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 06/04/84  1249.9 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 cumulative_page_trace: cpt: proc;
       12 
       13 /*
       14*   Additional control arguments:
       15*
       16*   -length n, -lg n  format output with line length n.
       17**/
       18 
       19 /* coded	Feb 10, 1971	J.W. Gintell */
       20 /* modified June, 1974 for new system trace in 23.10 - MCR 598  */
       21 /* modified June 1975 by John Gintell for MCR's 957,970, and 1060 */
       22 /* modified Aug 1976 by John Gintell to make cleanup condition handler work */
       23 /* modified July 1977 by John Gintell to add linkage fault trace, segment fault counting and default -int 500 */
       24 /* modified January 81 by J. Bongiovanni to avoid fatal process error due to
       25*          record quota overflow in pdir, add -temp_dir  */
       26 /* modified January 82 by J. Bongiovanni for extended page fault type */
       27 
       28 		        
       29 		        
       30 
       31 dcl  hcs_$high_low_seg_count external entry (fixed bin, fixed bin);
       32 dcl  hcs_$trace_marker entry (char (4));
       33 dcl  hcs_$make_seg external entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin(35));
       34 dcl  hcs_$truncate_seg external entry (ptr, fixed bin, fixed bin(35));
       35 dcl  hcs_$delentry_seg entry (ptr, fixed bin(35));
       36 dcl  absolute_pathname_ entry (char(*), char(*), fixed bin(35));
       37 dcl  ioa_ external entry options (variable);
       38 dcl  ioa_$rsnnl external entry options (variable);
       39 dcl  ioa_$ioa_switch external entry options (variable);
       40 dcl  page_trace$print_trace_entry entry (ptr, ptr, bit (1) aligned);
       41 dcl  cv_bin_$oct external entry (fixed bin (11)) returns (char (12) aligned);
       42 dcl  iox_$find_iocb entry (char (*), ptr, fixed bin(35));
       43 dcl  iox_$attach_iocb entry (ptr, char (*), fixed bin(35));
       44 dcl  iox_$open entry (ptr, fixed bin, bit (1) aligned, fixed bin(35));
       45 dcl  iox_$close entry (ptr, fixed bin(35));
       46 dcl  iox_$detach_iocb entry (ptr, fixed bin(35));
       47 dcl  com_err_ external entry options (variable);
       48 dcl  cv_dec_check_ external entry (char (*), fixed bin(35)) returns (fixed bin);
       49 dcl  cu_$arg_ptr external entry (fixed bin, ptr, fixed bin, fixed bin(35));
       50 dcl  cu_$arg_count external entry returns (fixed bin);
       51 dcl  cu_$cp external entry (ptr, fixed bin, fixed bin(35));
       52 dcl  hcs_$get_page_trace external entry (ptr);
       53 dcl  hcs_$fs_get_path_name external entry (ptr, char (*), fixed bin, char (*), fixed bin(35));
       54 dcl  interpret_bind_map_ entry (ptr, char (*), fixed bin, fixed bin(35));
       55 dcl  get_entry_name_ entry (ptr, char (*), fixed bin, char (8), fixed bin(35));
       56 dcl  ring0_get_$name external entry (char (*), char (*), ptr, fixed bin(35));
       57 dcl  ring0_get_$definition external entry (ptr, char (*), char (*), fixed bin, fixed bin, fixed bin(35));
       58 dcl  ring_zero_peek_ entry (ptr, ptr, fixed bin, fixed bin(35));
       59 dcl (null, addr, baseptr, max, fixed, substr, divide, ltrim, ptr, rel, binary, baseno, stackframeptr, hbound) builtin;
       60 dcl  timer_manager_$sleep external entry (fixed bin (71), bit (2));
       61 dcl  timer_manager_$cpu_call external entry (fixed bin (71), bit (2), entry);
       62 dcl  timer_manager_$reset_cpu_call external entry (entry);
       63 
       64 dcl  sys_info$max_seg_size external fixed bin (19);
       65 dcl  highpage fixed bin static;
       66 dcl  myname char (21) static options (constant) init ("cumulative_page_trace");
       67 
  1     1 /* BEGIN INCLUDE FILE trace_types.incl.pl1  --  Last modified Jan 1982 */
  1     2 
  1     3      dcl	   (page_fault_type	      init (0),
  1     4 	   seg_fault_start	      init (2),
  1     5 	   seg_fault_end	      init (3),
  1     6 	   linkage_fault_start    init (4),
  1     7 	   linkage_fault_end      init (5),
  1     8 	   boundfault_start	      init (6),
  1     9 	   boundfault_end	      init (7),
  1    10 	   signaller_type	      init (8),
  1    11 	   restart_fault_type     init (9),
  1    12 	   reschedule_type	      init (10),
  1    13 	   marker_type	      init (11),
  1    14 	   interrupt_type	      init (12),
  1    15 	   extended_page_fault_type init (15)) fixed bin int static options (constant);
  1    16 
  1    17 
  1    18 /* END INCLUDE FILE trace_types.incl.pl1 */
       68 
  2     1 /* BEGIN INCLUDE FILE sys_trace.incl.pl1  --  Last modified Jan. 1982 */
  2     2 /* Modified for new pgt_ signal technology, Benson Margulies, 83-12 */
  2     3 /* format: style3 */
  2     4 
  2     5 declare	trace_ptr		ptr;
  2     6 
  2     7 declare	1 trace		based (trace_ptr) aligned,	/* system trace data structure */
  2     8 	  2 next_free	fixed bin (17) uns unal,	/* index to next free trace entry */
  2     9 	  2 pad1		bit (19) unal,
  2    10 	  2 last_available	fixed bin (17) uns unal,	/* index to first unusable entry in list */
  2    11 	  2 pad2		bit (19) unal,
  2    12 	  2 ttime		fixed bin (71),		/* time used to figure incremental times */
  2    13 	  2 temp		bit (36),			/* temporary used by page$enter_data */
  2    14 	  2 index		bit (17),			/* index to end of post purge list */
  2    15 	  2 threshold	fixed bin (17) unsigned unaligned,
  2    16 	  2 pad3		bit (1) unaligned,		/* to halfword */
  2    17 	  2 flags		unaligned,
  2    18 	    3 send_ips	bit (1) unaligned,		/* send pgt_ when index reached threshold */
  2    19 	    3 pad		bit (17) unaligned,
  2    20 	  2 pad4		bit (36) aligned,
  2    21 	  2 data		(1024),			/* trace data entry structure */
  2    22 	    3 data_word	char (4),			/* per-type data word */
  2    23 	    3 type	fixed bin (6) uns unaligned,	/* type of trace entry */
  2    24 	    3 pad		bit (14) unaligned,
  2    25 	    3 dtime	fixed bin (16) uns unaligned; /* time increment since last trace entry (in 64 micsec) */
  2    26 
  2    27 declare	1 page_trace_entry	based (trace_ptr) aligned,	/* entry for page fault data */
  2    28 	  2 pad		bit (18) unaligned,
  2    29 	  2 ring		fixed bin (3) uns unaligned,	/* ring number fault occured in */
  2    30 	  2 segment_number	fixed bin (15) uns unaligned, /* segment number of segment getting page fault */
  2    31 	  2 type		fixed bin (6) uns unaligned,	/* MBZ for page faults */
  2    32 	  2 page_number	fixed bin (12) uns unaligned, /* page number which caused fault */
  2    33 	  2 pad1		bit (2) unal,
  2    34 	  2 time		fixed bin (16) uns unaligned; /* time increment since last trace entry (res = 64 micro-secs) */
  2    35 
  2    36 declare	1 extended_page_trace_entry
  2    37 			based (trace_ptr) aligned,	/* page fault data with more info */
  2    38 	  2 psr_segno	fixed bin (12) uns unaligned, /* segment number of proc faulting */
  2    39 	  2 psr_offset	fixed bin (18) uns unaligned, /* IC of proc faulting */
  2    40 	  2 tsr_segno_1	bit (6) unaligned,		/* 1st 6 bits of segment number faulted */
  2    41 	  2 type		fixed bin (6) uns unaligned,	/* 15 decimal */
  2    42 	  2 tsr_segno_2	bit (6) unaligned,		/* last 6 bits of segment number faulted */
  2    43 	  2 tsr_pageno	fixed bin (8) uns unaligned,	/* page number faulted */
  2    44 	  2 time		fixed bin (16) uns unaligned; /* time increment since last trace entry (res = 64 micro-secs) */
  2    45 
  2    46 
  2    47 /* END INCLUDE FILE sys_trace.incl.pl1 */
       69 
       70 
       71 
       72 dcl (cleanup, not_in_read_bracket, record_quota_overflow) condition;
       73 
       74 dcl 1 trace_copy aligned like trace;
       75 
       76 dcl  char4 char (4) based;
       77 dcl  cptb char (4);
       78 dcl  cpte char (4);					/* marker */
       79 dcl  counter fixed bin static init (0);			/* counter for marker */
       80 
       81 dcl 1 seg (0:1023) aligned based (datap),		/* array of counters, one for each page of each segment */
       82     2 any bit (1) unaligned,				/* = 1 if any pages seen in this segment */
       83     2 segf fixed bin (16) unaligned,
       84     2 total_no_page fixed bin (17) unaligned,		/* number of pages touched for this segment */
       85     2 total_no_pagef fixed bin (35),			/* total number of faults for this segment */
       86     2 page (0:255) fixed bin (8) unaligned;
       87 dcl  datap ptr static;				/* pointer to data segment */
       88 dcl  packedptr ptr unal based;
       89 dcl  unpackedptr ptr;
       90 
       91 dcl 1 linkfaults based (linkp),
       92     2 nextlp fixed bin,
       93     2 elem (0:131070),
       94       3 fromptr ptr unal,
       95       3 toptr ptr unal;
       96 dcl  linkp ptr init (null) static;
       97 
       98 dcl  seg_no fixed bin (11);
       99 dcl  type fixed bin (5);
      100 dcl  page_no fixed bin (11);
      101 dcl  beg_found bit (1);				/* used during scan to mark when in good zone */
      102 dcl  beg_found1 bit (1);
      103 dcl  end_found bit (1);				/* used during scan to indicate when end marker found */
      104 
      105 dcl  total_pages fixed bin init (0);
      106 dcl  total_segf fixed bin init (0);
      107 dcl  total_pfaults fixed bin init (0) static;
      108 
      109 dcl  flushptr (0:63) ptr init ((64) null);
      110 dcl  qoverflow bit (1) init (""b);
      111 dcl  make_seg_failed bit (1) init (""b);
      112 dcl  flushp_index fixed bin;
      113 dcl  zzzzz9 pic "zzzzz9";
      114 dcl  flushi fixed bin;
      115 dcl 1 flush_seg based aligned,
      116     2 page (0:255),
      117       3 word (0:1023) fixed bin;
      118 dcl  garbage fixed bin;
      119 dcl  nused fixed bin;
      120 dcl  nused_ptr ptr init (null);
      121 dcl  nused_offset fixed bin;
      122 dcl (last_blockno) fixed bin;
      123 dcl  deftype fixed bin;
      124 
      125 dcl  dirname char (168);
      126 dcl  ename char (32);				/* returned name of segment */
      127 dcl  comp_name char (8);
      128 dcl  callee_name char (32);
      129 dcl  caller_ename char (32);
      130 dcl  entry_name char (32);
      131 dcl  offset fixed bin;
      132 dcl  char32 char (32);
      133 dcl  path char (168);				/* pathname for ios_ call */
      134 dcl  pnum char (8);					/* string in which to put page number */
      135 dcl  pnumb char (pnumbl) based (addr (pnum));
      136 dcl  pnumbl fixed bin;				/* length of page number string */
      137 dcl  arg char (len) based (aptr);			/* argument string from cu_$arg_ptr */
      138 dcl  len fixed bin;
      139 dcl  aptr ptr;					/* pointer to argument returned by cu_$arg_ptr */
      140 dcl  iocbp ptr;					/* pointer to iocb for cpt.out */
      141 dcl  dump_iocbp ptr;				/* pointer to iocb for cpt.dump, user must attach open */
      142 dcl  command char (132);				/* command string */
      143 dcl  comptr ptr;
      144 dcl  comlen fixed bin;				/* length of command string */
      145 dcl  pstring char (256) ;				/* place in which to build page number string */
      146 dcl  pstringf char (lstr) based (addr (pstring));
      147 dcl (i, j, k, high_seg) fixed bin;
      148 dcl  code fixed bin (35);
      149 dcl  maxhigh fixed bin static init (0);
      150 dcl  timersw bit (1) init (""b);
      151 dcl  ignoreint bit (1) init ("0"b);
      152 dcl  save_ignoreint bit (1);
      153 dcl  look_for_timers bit (1) init ("0"b);
      154 dcl  look_for_restart bit (1) init ("0"b);
      155 dcl  noise bit (1) ;				/* if we suspect noise in data */
      156 dcl  tempdsw bit (1) init ("0"b);
      157 dcl  temp_dir_name char (168);
      158 
      159 dcl (countsw, loopsw, flushsw, sleepsw, printsw, totalsw, resetsw, comsw, debugsw, tracesw) bit (1) init (""b);
      160 dcl  intsw bit (1) init ("1"b);
      161 dcl (linksw, printlinksw) bit (1) init (""b);
      162 dcl  nocaller bit (1);
      163 dcl  longsw bit (1) aligned init (""b);
      164 dcl  loopcnt fixed bin init (0);			/* count of number of loops requested */
      165 dcl  totalloop fixed bin static;			/* total number of iterations */
      166 dcl  sleeptime fixed bin (71);			/* length of sleep time */
      167 dcl  inttime fixed bin (71) init (500000);		/* length of CPU interrupt interval */
      168 dcl  totalint fixed bin init (0);			/* total number of interrupts */
      169 dcl  lstr fixed bin;				/* length of page number string mod line */
      170 dcl  maxlstr fixed bin init (80);			/* max length */
      171 
      172 dcl  firstinit bit (1) static init ("1"b);		/* initialization switch */
      173 dcl  hcsc fixed bin static;				/* hardcore segment count */
      174 
      175 	if firstinit then do;			/* first time initialization */
      176 
      177 	     highpage = divide (sys_info$max_seg_size, 1024, 17, 0) - 1;
      178 	     call hcs_$high_low_seg_count (high_seg, hcsc); /* get high hardcore segment count */
      179 	     call hcs_$make_seg ("", "cpt.data", "", 01010b, datap, code);
      180 	     if datap = null then do;
      181 TEMPERR:		call com_err_ ((code), myname, "Couldn't make temp seg.");
      182 		return;
      183 	     end;
      184 	     call hcs_$make_seg ("", "cpt.link", "", 01010b, linkp, code);
      185 	     if linkp = null then goto TEMPERR;
      186 	     call reset;
      187 
      188 	     firstinit = ""b;
      189 	end;
      190 
      191 /* obtain all arguments given to command */
      192 	do i = 1 to cu_$arg_count ();
      193 
      194 	     call cu_$arg_ptr (i, aptr, len, code);
      195 	     if code = 0 then do;
      196 
      197 		if arg = "-flush" then flushsw = "1"b;
      198 		else if arg = "-trace" then do;
      199 		     tracesw = "1"b;
      200 		     call attach (iocbp, "cpt.out");
      201 		     if code ^= 0 then goto ARGERR;
      202 		end;
      203 		else if arg = "-sleep" then do;
      204 		     sleepsw = "1"b;
      205 		     i = i +1;
      206 		     call cu_$arg_ptr (i, aptr, len, code);
      207 		     if code ^= 0 then go to ARGERR;
      208 		     sleeptime = cv_dec_check_ (arg, code);
      209 		     if sleeptime <= 0 | code ^= 0 then go to ARGERR;
      210 		end;
      211 		else if arg = "-loop" then do;
      212 		     loopsw = "1"b;
      213 		     i = i +1;
      214 		     call cu_$arg_ptr (i, aptr, len, code);
      215 		     if code ^= 0 then go to ARGERR;
      216 		     loopcnt = cv_dec_check_ (arg, code);
      217 		     if loopcnt <= 0 | code ^= 0 then go to ARGERR;
      218 		end;
      219 		else if arg = "-interrupt" | arg = "-int" then do;
      220 		     intsw = "1"b;
      221 		     i = i + 1;
      222 		     call cu_$arg_ptr (i, aptr, len, code);
      223 		     if code ^= 0 then go to ARGERR;
      224 		     inttime = cv_dec_check_ (arg, code);
      225 		     if inttime < 100 | code ^= 0 then goto ARGERR;
      226 		     inttime = inttime * 1000;
      227 		end;
      228 		else if arg = "-temp_dir" | arg = "-td" then do;
      229 		     tempdsw = "1"b;
      230 		     i = i + 1;
      231 		     call cu_$arg_ptr (i, aptr, len, code);
      232 		     if code ^= 0 then goto ARGERR;
      233 		     call absolute_pathname_ (arg, temp_dir_name, code);
      234 		     if code ^= 0 then goto ARGERR;
      235 		end;
      236 		else if arg = "-reset" | arg = "-rs" then resetsw = "1"b;
      237 		else if arg = "-trace_linkage_faults" then linksw = "1"b;
      238 		else if arg = "-print_linkage_faults" then printlinksw = "1"b;
      239 		else if arg = "-count" | arg = "-ct" then countsw = "1"b;
      240 		else if arg = "-print" | arg = "-pr" then printsw = "1"b;
      241 		else if arg = "-total" | arg = "-tt" then totalsw = "1"b;
      242 		else if arg = "-shortline" | arg = "-short" | arg = "-sh" then maxlstr = 48;
      243 		else if arg = "-timers" then timersw = "1"b;
      244 		else if arg = "-long" | arg = "-lg" then longsw = "1"b;
      245 		else if arg = "-length" | arg = "-ln" then do;
      246 		     i = i + 1;
      247 		     call cu_$arg_ptr (i, aptr, len, code);
      248 		     if code ^= 0 then goto ARGERR;
      249 		     maxlstr = cv_dec_check_ (arg, code);
      250 		     if maxlstr < 48 | code ^= 0 then goto ARGERR;
      251 		     if maxlstr > 130 then goto ARGERR;
      252 		     maxlstr = maxlstr - 32;
      253 		end;
      254 		else if substr (arg, 1, 1) = "-" then goto ARGERR;
      255 		else if ^comsw then do;		/* this is command string */
      256 		     command = arg;			/* copy since must be aligned */
      257 		     comsw = "1"b;
      258 		     comlen = len;
      259 		     if ^loopsw then loopcnt = 1;
      260 		end;
      261 		else do;
      262 ARGERR:		     call com_err_ (code, myname, "Invalid argument - ^a", arg);
      263 		     return;
      264 		end;
      265 	     end;
      266 	end;
      267 
      268 	if fixed (printsw) + fixed (countsw) + fixed (totalsw) > 1 then do;
      269 	     call com_err_ ((0), myname, "Only one of -count, -print, and -total may be specified");
      270 	     return;
      271 	end;
      272 	if countsw | totalsw then printsw = "1"b;
      273 
      274 	if ^(comsw | printsw | resetsw | printlinksw) then do;
      275 	     call com_err_ ((0), myname, "No printing requests or command string was given.");
      276 	     return;
      277 	end;
      278 
      279 
      280 	if resetsw then call reset;
      281 	on condition (cleanup) call cleaner;
      282 	comptr = addr (command);
      283 
      284 /* Now start the calling and accumulation of page trace data */
      285 
      286 	do j = 1 to loopcnt;
      287 
      288 	     if intsw then do;
      289 		call timer_manager_$cpu_call (inttime, "10"b, timer);
      290 		look_for_timers = ^timersw;
      291 		ignoreint = "0"b;
      292 	     end;
      293 
      294 	     cptb = nexts ();
      295 	     cpte = nexts ();
      296 	     if flushsw then call flush;
      297 	     call hcs_$trace_marker (cptb);
      298 
      299 	     if comsw then call cu_$cp (comptr, comlen, code);
      300 
      301 	     ignoreint = "1"b;
      302 
      303 	     call hcs_$trace_marker (cpte);
      304 	     call hcs_$get_page_trace (addr (trace_copy));
      305 
      306 	     if intsw then do;
      307 		call timer_manager_$reset_cpu_call (timer);
      308 		look_for_timers = "0"b;
      309 	     end;
      310 
      311 
      312 	     call get_trace;			/* get page trace data */
      313 
      314 	     if sleepsw then if j ^= loopcnt then call timer_manager_$sleep (sleeptime, "11"b);
      315 
      316 	end;
      317 
      318 	if intsw & totalint ^= 0 then call ioa_ ("cumulative_page_trace: There were ^d interrupts.^/", totalint);
      319 	if qoverflow then call ioa_ ("cumulative_page_trace:  Insufficient quota to flush all pages.");
      320 	if printsw then call print;
      321 	if printlinksw then call printlinks;
      322 
      323 	call cleaner;
      324 
      325 cleaner:	proc;
      326 	     if intsw then call timer_manager_$reset_cpu_call (timer);
      327 	     if tracesw then call detach (iocbp, "cpt.out");
      328 	     if debugsw then call detach (dump_iocbp, "cpt.dump");
      329 	     if flushsw then do flushp_index = 0 to hbound (flushptr, 1);
      330 		if flushptr (flushp_index) ^= null then do;
      331 		     call hcs_$delentry_seg (flushptr (flushp_index), code);
      332 		     flushptr (flushp_index) = null;
      333 		end;
      334 	     end;
      335 	     
      336      return;
      337 	end cleaner;
      338 
      339 detach:	proc (a_iocbp, a_switchname);
      340 dcl  a_iocbp ptr;					/* pointer to iocb */
      341 dcl  a_switchname char (*);
      342 
      343 	     call iox_$close (a_iocbp, code);
      344 	     if code ^= 0 then call iox_err;
      345 
      346 	     call iox_$detach_iocb (a_iocbp, code);
      347 	     if code ^= 0 then call iox_err;
      348 
      349 iox_err:	     proc;
      350 
      351 		call com_err_ (code, myname, a_switchname);
      352 
      353 	     end iox_err;
      354 
      355 	end detach;
      356 
      357 attach:	proc (a_iocbp, a_switchname);
      358 
      359 dcl  a_iocbp ptr;
      360 dcl  a_switchname char (*);
      361 
      362 	     i = i + 1;
      363 	     call cu_$arg_ptr (i, aptr, len, code);
      364 	     if code ^= 0 then return;
      365 	     path = arg;
      366 	     call iox_$find_iocb (a_switchname, a_iocbp, code);
      367 	     if code ^= 0 then return;
      368 	     call iox_$attach_iocb (a_iocbp, "vfile_ "||path||" -extend", code);
      369 	     if code ^= 0 then return;
      370 	     call iox_$open (a_iocbp, 2, "0"b, code);
      371 	     if code ^= 0 then return;
      372 
      373 	end attach;
      374 
      375 get_trace: procedure;
      376 
      377 	     beg_found, beg_found1, end_found, noise = ""b;
      378 	     if tracesw then call ioa_$ioa_switch (iocbp, "^/");
      379 
      380 AGAIN:	     do i = trace_copy.next_free + 1 to trace_copy.last_available, 1 to trace_copy.next_free;
      381 
      382 		trace_ptr = addr (trace_copy.data (i));
      383 		type = page_trace_entry.type;
      384 
      385 		if type = extended_page_fault_type then do;
      386 		     seg_no = binary (extended_page_trace_entry.tsr_segno_1
      387 			|| extended_page_trace_entry.tsr_segno_2, 12);
      388 		     page_no = extended_page_trace_entry.tsr_pageno;
      389 		end;
      390 		else do;
      391 		     seg_no = page_trace_entry.segment_number;
      392 		     page_no = page_trace_entry.page_number;
      393 		end;
      394 		
      395 		if ^beg_found then do;
      396 		     if type = marker_type & addr (trace_copy.data (i)) -> char4 = cptb then do;
      397 			if look_for_restart then beg_found1 = "1"b;
      398 			else beg_found = "1"b;
      399 		     end;
      400 		     else if look_for_restart & beg_found1 then if type = restart_fault_type then beg_found = "1"b;
      401 		     goto SKIP;
      402 		end;
      403 
      404 		if type = marker_type & addr (trace_copy.data (i)) -> char4 = cpte then do;
      405 		     end_found = "1"b;
      406 		     goto DONE;
      407 		end;
      408 
      409 		else if type = signaller_type & look_for_timers & addr (trace_copy.data (i)) -> char4 = "cput" then do;
      410 		     end_found = "1"b;
      411 		     goto DONE;
      412 		end;
      413 
      414 		else if linksw & type = linkage_fault_start then call linkfaultstart;
      415 
      416 		else if linksw & type = linkage_fault_end then call linkfaultend;
      417 
      418 		else if type = seg_fault_start then do;
      419 		     seg (seg_no).segf = seg (seg_no).segf + 1;
      420 		end;
      421 
      422 		else if type = page_fault_type | type = extended_page_fault_type then do;
      423 		     if seg (seg_no).page (page_no) = 0 then seg (seg_no).total_no_page = seg (seg_no).total_no_page + 1;
      424 		     seg (seg_no).page (page_no) = seg (seg_no).page (page_no) + 1;
      425 		     seg (seg_no).any = "1"b;
      426 		     seg (seg_no).total_no_pagef = seg (seg_no).total_no_pagef + 1;
      427 		     maxhigh = max (maxhigh, seg_no);
      428 		     total_pfaults = total_pfaults + 1;
      429 		end;
      430 		if tracesw then
      431 		     call page_trace$print_trace_entry (addr (trace_copy.data (i)), iocbp, longsw);
      432 SKIP:	     end;
      433 
      434 	     if ^beg_found then do;
      435 		beg_found, noise = "1"b;
      436 		if tracesw
      437 		then call ioa_$ioa_switch (iocbp, "^/Some page faults have been missed - no beginning marker^/");
      438 		goto AGAIN;
      439 	     end;
      440 
      441 	     if ^end_found then do;
      442 		if tracesw then call ioa_$ioa_switch (iocbp, "^/Some page faults have been missed - no end marker^/");
      443 		noise = "1"b;
      444 	     end;
      445 
      446 DONE:
      447 	     if noise then call ioa_ ("cumulative_page_trace: Some page faults have been missed.");
      448 
      449 	end get_trace;
      450 
      451 timer:	procedure;
      452 
      453 	     if ignoreint then return;
      454 	     call hcs_$trace_marker (cpte);
      455 	     call hcs_$get_page_trace (addr (trace_copy));
      456 	     call get_trace;
      457 	     look_for_restart = ^timersw;		/* OK to turn on now */
      458 
      459 	     totalint = totalint + 1;
      460 	     call timer_manager_$cpu_call (inttime, "10"b, timer);
      461 
      462 	     cptb = nexts ();
      463 	     cpte = nexts ();
      464 	     if flushsw then call flush;
      465 	     call hcs_$trace_marker (cptb);
      466 
      467 	end timer;
      468 
      469 
      470 /* procedure used to reset the accumulated page trace data */
      471 reset:	procedure;
      472 
      473 	     call hcs_$truncate_seg (datap, 0, code);
      474 
      475 	     totalloop = 0;
      476 	     maxhigh = 0;
      477 	     total_pfaults = 0;
      478 	     if linkp ^= null then call hcs_$truncate_seg (linkp, 0, code);
      479 
      480 	end reset;
      481 
      482 nexts:	proc returns (char (4));
      483 
      484 dcl  zzz9 pic "zzz9";
      485 
      486 	     zzz9 = counter;
      487 	     counter = counter + 1;
      488 	     return (zzz9);
      489 
      490 	end nexts;
      491 
      492 linkfaultstart: proc;
      493 
      494 	     if toptr (nextlp) = null () then nextlp = nextlp + 1; /* didn't get an end linkage fault */
      495 	     fromptr (nextlp) = addr (trace_copy.data (i)) -> packedptr;
      496 	     toptr (nextlp) = null ();
      497 
      498 	end linkfaultstart;
      499 
      500 
      501 linkfaultend: proc;
      502 
      503 	     toptr (nextlp) = addr (trace_copy.data (i)) -> packedptr;
      504 	     nextlp = nextlp + 1;
      505 
      506 	end linkfaultend;
      507 
      508 /* procedure used to print the accumulated page trace data */
      509 print:	procedure;
      510 
      511 
      512 	     if ^totalsw then call ioa_ ("^/Segment name^-^-   page numbers^/");
      513 	     else call ioa_ ("^/Segment name ^-^- Page Faults     Segment Faults^/^-^-^- #pages  #faults  #faults^/");
      514 
      515 	     do i = 0 to maxhigh;
      516 
      517 		if seg (i).any then do;
      518 		     call getname (fixed (i, 11));
      519 
      520 		     lstr = 0;
      521 		     char32 = ename;
      522 		     total_pages = total_pages + seg (i).total_no_page;
      523 		     total_segf = total_segf + seg (i).segf;
      524 
      525 		     if totalsw then call ioa_ ("^32a^4d^9d^9d",
      526 			ename, seg (i).total_no_page, seg (i).total_no_pagef, seg (i).segf);
      527 		     else do;
      528 			do j = 0 to highpage;	/* build string of page numbers */
      529 			     if seg (i).page (j) ^= 0 then do;
      530 				if seg (i).page (j) = 1 | ^countsw then call ioa_$rsnnl ("^o ", pnum, pnumbl, j);
      531 				else call ioa_$rsnnl ("^o(^d) ", pnum, pnumbl, j, seg (i).page (j));
      532 				substr (pstring, lstr+1, pnumbl) = pnumb;
      533 				lstr = lstr + pnumbl; /* string length */
      534 				if lstr >maxlstr then do;
      535 				     call ioa_ ("^32a^a", char32, pstringf);
      536 				     char32 = "";
      537 				     lstr = 0;
      538 				end;
      539 			     end;
      540 			end;
      541 			if lstr ^= 0 then call ioa_ ("^32a^a", char32, pstringf);
      542 		     end;
      543 		end;
      544 	     end;
      545 
      546 	     call ioa_ ("^/Total number of pages: ^d, Total page faults: ^d, Total segment faults: ^d^/",
      547 		total_pages, total_pfaults, total_segf);
      548 
      549 	end print;
      550 
      551 printlinks: proc;
      552 
      553 	     call ioa_ ("^2/^2- Linkage Faults^/");
      554 
      555 	     do i = 0 to nextlp -1;
      556 
      557 		unpackedptr = fromptr (i);
      558 		if baseno (unpackedptr) = "0"b
      559 		then do;
      560 		     caller_ename = "hcs_$make_ptr call";
      561 		     nocaller = "1"b;
      562 		end;
      563 		else do;
      564 		     nocaller = "0"b;
      565 		     offset = binary (rel (unpackedptr), 18);
      566 		     entry_name = "";
      567 		     on not_in_read_bracket goto ISGATE;
      568 		     call interpret_bind_map_ (unpackedptr, entry_name, offset, code);
      569 		     revert not_in_read_bracket;
      570 ISGATE:
      571 		     if entry_name ^= "" then entry_name = ": " || entry_name;
      572 		     call getname (fixed (baseno (unpackedptr), 11));
      573 		     caller_ename = ename;
      574 		end;
      575 
      576 		unpackedptr = toptr (i);
      577 		call get_entry_name_ (unpackedptr, callee_name, binary (baseno (unpackedptr)), comp_name, code);
      578 		if callee_name = "" then callee_name = "0";
      579 		call getname (fixed (baseno (unpackedptr), 11));
      580 
      581 		call ioa_ ("^a^[^s^s^;^a|^o^]    ===>    ^a$^a",
      582 		     caller_ename, nocaller, entry_name, offset, ename, callee_name);
      583 	     end;
      584 	     call ioa_ ("");
      585 
      586 	end printlinks;
      587 
      588 getname:	procedure (segnum);
      589 
      590 dcl  segnum fixed bin (11);
      591 
      592 	     ename = "";
      593 
      594 	     if segnum < hcsc then call ring0_get_$name (dirname, ename, baseptr (segnum), code);
      595 	     else call hcs_$fs_get_path_name (baseptr (segnum), dirname, k, ename, code);
      596 	     if ename = "" then ename = ">";
      597 
      598 	     if code ^= 0 then ename = ltrim (cv_bin_$oct (segnum)); /* convert segment number */
      599 
      600 	end getname;
      601 
      602 /*  procedure called for each iteration if -flush specified.
      603*    The idea is to improve the accuracy of the data by eliminating the effect
      604*    of background system load.  This is done by flushing main memory of all
      605*    pages which we (or, for that matter, anyone else) might have touched.
      606*    The only way to do this is to fill memory with other pages.  These
      607*    pages belong to segments in the process directory, or in a user-specified
      608*    directory, and we create these segments during the
      609*    first pass through this procedure.  Note that this extraneous paging
      610*    is detrimental to system performance, and that this detriment is
      611*    evident to all users on the system.  If the flush pages are in
      612*    the process directory, strange things can happen due to record quota
      613*    overflow.  The stack might not be able to expand to handle the record
      614*    quota overflow condition, resulting in a fatal process error.
      615*    If the pages are left around between calls to cpt, someone else might
      616*    get a record quota overflow (probably on the stack).  To avoid these
      617*    problems, we do the following:
      618*          1. Touch the next page of the stack, in case we need to expand
      619*             it for any reason and no quota is left.
      620*          2. Truncate all flush segments after flushing (thus returning
      621*             their quota)
      622*    Note that these problems are not serious if the user has specified
      623*    -temp_dir.										*/
      624 	
      625 
      626 flush:	procedure;
      627 
      628 	     if qoverflow | make_seg_failed then return;	/* lost before				*/
      629 	     save_ignoreint = ignoreint;
      630 	     ignoreint = "1"b;			/* could lose interrupts */
      631 	     last_blockno = 0;
      632 	     call ring0_get_$definition (nused_ptr, "sst", "nused", nused_offset, deftype, code);
      633 	     if code = 0
      634 	     then do;
      635 		call ring_zero_peek_ (ptr (nused_ptr, nused_offset), addr (nused), 1, code);
      636 		if code ^= 0 then nused = 1024;
      637 	     end;
      638 	     else nused = 1024;
      639 
      640 	     garbage = stackframeptr () -> flush_seg.page (1).word (0); /* get page for stack expand	*/
      641 
      642 	     do flushp_index = 0 to divide (nused+highpage, highpage, 17, 0) -1;
      643 		if flushptr (flushp_index) = null then do;
      644 		     zzzzz9 = flushp_index;
      645 		     if tempdsw
      646 			then call hcs_$make_seg (temp_dir_name, "cpt.flush."||ltrim (zzzzz9), "", 01010b, flushptr (flushp_index), code);
      647 		     else call hcs_$make_seg ("", "cpt.flush."||ltrim (zzzzz9), "", 01010b, flushptr (flushp_index), code);
      648 		     if flushptr (flushp_index) = null then do;
      649 			call com_err_ (code, myname, "cpt.flush");
      650 			make_seg_failed = "1"b;
      651 			return;
      652 		     end;
      653 
      654 		end;
      655 
      656 		on record_quota_overflow begin;
      657 		     qoverflow = "1"b;
      658 		     goto NOQUOTA;
      659 		end;
      660 		do flushi = 0 to highpage;
      661 		     garbage = flushptr (flushp_index) -> flush_seg.page (flushi).word (0);
      662 		end;
      663 		revert record_quota_overflow;
      664 	     end;
      665 NOQUOTA:
      666 	     do flushp_index = 0 to divide (nused+highpage, highpage, 17, 0) -1;
      667 		if flushptr (flushp_index) ^= null()
      668 		     then call hcs_$truncate_seg (flushptr (flushp_index), 0, code);
      669 	     end;
      670 
      671 	     ignoreint = save_ignoreint;
      672 
      673 	end flush;
      674 
      675      end cumulative_page_trace;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    06/04/84  1241.7  cumulative_page_trace.pl1         >spec>temp>bce>on>cumulative_page_trace.pl1
68           1    03/29/82  1006.9  trace_types.incl.pl1              >ldd>include>trace_types.incl.pl1
69           2    06/01/84  1103.3  sys_trace.incl.pl1                >spec>temp>bce>on>sys_trace.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_iocbp                                parameter       pointer                  dcl 340 in procedure "detach" set ref 339 343* 346*
a_iocbp                                parameter       pointer                  dcl 359 in procedure "attach" set ref 357 366* 368*
                                                                                  370*
a_switchname                           parameter       char                     unaligned dcl 360 in procedure "attach" set ref 357
                                                                                  366*
a_switchname                           parameter       char                     unaligned dcl 341 in procedure "detach" set ref 339
                                                                                  351*
absolute_pathname_              000036 constant        entry                    external dcl 36 ref 233
addr                                                   builtin function         dcl 59 ref 282 304 304 382 396 404 409 430 430 455
                                                                                  455 495 503 532 535 541 635 635
any                                    based           bit(1)                   array level 2 packed unaligned dcl 81 set ref 425*
                                                                                  517
aptr                            004560 automatic       pointer                  dcl 139 set ref 194* 197 198 203 206* 208 211 214*
                                                                                  216 219 219 222* 224 228 228 231* 233 236 236 237
                                                                                  238 239 239 240 240 241 241 242 242 242 243 244
                                                                                  244 245 245 247* 249 254 256 262 363* 365
arg                                    based           char                     unaligned dcl 137 set ref 197 198 203 208* 211 216*
                                                                                  219 219 224* 228 228 233* 236 236 237 238 239 239
                                                                                  240 240 241 241 242 242 242 243 244 244 245 245
                                                                                  249* 254 256 262* 365
baseno                                                 builtin function         dcl 59 ref 558 572 572 577 577 579 579
baseptr                                                builtin function         dcl 59 ref 594 594 595 595
beg_found                       004127 automatic       bit(1)                   unaligned dcl 101 set ref 377* 395 398* 400* 434
                                                                                  435*
beg_found1                      004130 automatic       bit(1)                   unaligned dcl 102 set ref 377* 397* 400
binary                                                 builtin function         dcl 59 ref 386 565 577 577
callee_name                     004440 automatic       char(32)                 unaligned dcl 128 set ref 577* 578 578* 581*
caller_ename                    004450 automatic       char(32)                 unaligned dcl 129 set ref 560* 573* 581*
char32                          004471 automatic       char(32)                 unaligned dcl 132 set ref 521* 535* 536* 541*
char4                                  based           char(4)                  unaligned dcl 76 ref 396 404 409
cleanup                         000102 stack reference condition                dcl 72 ref 281
code                            004737 automatic       fixed bin(35,0)          dcl 148 set ref 179* 181 184* 194* 195 201 206* 207
                                                                                  208* 209 214* 215 216* 217 222* 223 224* 225 231*
                                                                                  232 233* 234 247* 248 249* 250 262* 299* 331* 343*
                                                                                  344 346* 347 351* 363* 364 366* 367 368* 369 370*
                                                                                  371 473* 478* 568* 577* 594* 595* 598 632* 633
                                                                                  635* 636 645* 647* 649* 667*
com_err_                        000064 constant        entry                    external dcl 47 ref 181 262 269 275 351 649
comlen                          004632 automatic       fixed bin(17,0)          dcl 144 set ref 258* 299*
command                         004566 automatic       char(132)                unaligned dcl 142 set ref 256* 282
comp_name                       004436 automatic       char(8)                  unaligned dcl 127 set ref 577*
comptr                          004630 automatic       pointer                  dcl 143 set ref 282* 299*
comsw                           005030 automatic       bit(1)                   initial unaligned dcl 159 set ref 159* 255 257* 274
                                                                                  299
counter                         000011 internal static fixed bin(17,0)          initial dcl 79 set ref 486 487* 487
countsw                         005021 automatic       bit(1)                   initial unaligned dcl 159 set ref 159* 239* 268 272
                                                                                  530
cptb                            004120 automatic       char(4)                  unaligned dcl 77 set ref 294* 297* 396 462* 465*
cpte                            004121 automatic       char(4)                  unaligned dcl 78 set ref 295* 303* 404 454* 463*
cu_$arg_count                   000072 constant        entry                    external dcl 50 ref 192
cu_$arg_ptr                     000070 constant        entry                    external dcl 49 ref 194 206 214 222 231 247 363
cu_$cp                          000074 constant        entry                    external dcl 51 ref 299
cv_bin_$oct                     000050 constant        entry                    external dcl 41 ref 598
cv_dec_check_                   000066 constant        entry                    external dcl 48 ref 208 216 224 249
data                     10     000110 automatic       structure                array level 2 dcl 74 set ref 382 396 404 409 430 430
                                                                                  495 503
datap                           000012 internal static pointer                  dcl 87 set ref 179* 180 419 419 423 423 423 424 424
                                                                                  425 426 426 473* 517 522 523 525 525 525 529 530
                                                                                  531
debugsw                         005031 automatic       bit(1)                   initial unaligned dcl 159 set ref 159* 328
deftype                         004352 automatic       fixed bin(17,0)          dcl 123 set ref 632*
dirname                         004353 automatic       char(168)                unaligned dcl 125 set ref 594* 595*
divide                                                 builtin function         dcl 59 ref 177 642 665
dump_iocbp                      004564 automatic       pointer                  dcl 141 set ref 328*
elem                      1            based           structure                array level 2 packed unaligned dcl 91
ename                           004425 automatic       char(32)                 unaligned dcl 126 set ref 521 525* 573 581* 592*
                                                                                  594* 595* 596 596* 598*
end_found                       004131 automatic       bit(1)                   unaligned dcl 103 set ref 377* 405* 410* 441
entry_name                      004460 automatic       char(32)                 unaligned dcl 130 set ref 566* 568* 570 570* 570
                                                                                  581*
extended_page_fault_type               constant        fixed bin(17,0)          initial dcl 1-3 ref 385 422
extended_page_trace_entry              based           structure                level 1 dcl 2-36
firstinit                       000021 internal static bit(1)                   initial unaligned dcl 172 set ref 175 188*
fixed                                                  builtin function         dcl 59 ref 268 268 268 518 518 572 572 579 579
flush_seg                              based           structure                level 1 dcl 115
flushi                          004342 automatic       fixed bin(17,0)          dcl 114 set ref 660* 661*
flushp_index                    004336 automatic       fixed bin(17,0)          dcl 112 set ref 329* 330 331 332* 642* 643 644 645
                                                                                  647 648 661* 665* 667 667*
flushptr                        004134 automatic       pointer                  initial array dcl 109 set ref 109* 329 330 331* 332*
                                                                                  643 645* 647* 648 661 667 667*
flushsw                         005023 automatic       bit(1)                   initial unaligned dcl 159 set ref 159* 197* 296 329
                                                                                  464
fromptr                   1            based           pointer                  array level 3 packed unaligned dcl 91 set ref 495*
                                                                                  557
garbage                         004343 automatic       fixed bin(17,0)          dcl 118 set ref 640* 661*
get_entry_name_                 000104 constant        entry                    external dcl 55 ref 577
hbound                                                 builtin function         dcl 59 ref 329
hcs_$delentry_seg               000034 constant        entry                    external dcl 35 ref 331
hcs_$fs_get_path_name           000100 constant        entry                    external dcl 53 ref 595
hcs_$get_page_trace             000076 constant        entry                    external dcl 52 ref 304 455
hcs_$high_low_seg_count         000024 constant        entry                    external dcl 31 ref 178
hcs_$make_seg                   000030 constant        entry                    external dcl 33 ref 179 184 645 647
hcs_$trace_marker               000026 constant        entry                    external dcl 32 ref 297 303 454 465
hcs_$truncate_seg               000032 constant        entry                    external dcl 34 ref 473 478 667
hcsc                            000022 internal static fixed bin(17,0)          dcl 173 set ref 178* 594
high_seg                        004736 automatic       fixed bin(17,0)          dcl 147 set ref 178*
highpage                        000010 internal static fixed bin(17,0)          dcl 65 set ref 177* 528 642 642 660 665 665
i                               004733 automatic       fixed bin(17,0)          dcl 147 set ref 192* 194* 205* 205 206* 213* 213
                                                                                  214* 221* 221 222* 230* 230 231* 246* 246 247*
                                                                                  362* 362 363* 380* 382 396 404 409 430 430* 495
                                                                                  503 515* 517 518 518 522 523 525 525 525 529 530
                                                                                  531* 555* 557 576*
ignoreint                       004741 automatic       bit(1)                   initial unaligned dcl 151 set ref 151* 291* 301* 453
                                                                                  629 630* 671*
interpret_bind_map_             000102 constant        entry                    external dcl 54 ref 568
intsw                           005033 automatic       bit(1)                   initial unaligned dcl 160 set ref 160* 220* 288 306
                                                                                  318 326
inttime                         005044 automatic       fixed bin(71,0)          initial dcl 167 set ref 167* 224* 225 226* 226 289*
                                                                                  460*
ioa_                            000040 constant        entry                    external dcl 37 ref 318 319 446 512 513 525 535 541
                                                                                  546 553 581 584
ioa_$ioa_switch                 000044 constant        entry                    external dcl 39 ref 378 436 442
ioa_$rsnnl                      000042 constant        entry                    external dcl 38 ref 530 531
iocbp                           004562 automatic       pointer                  dcl 140 set ref 200* 327* 378* 430* 436* 442*
iox_$attach_iocb                000054 constant        entry                    external dcl 43 ref 368
iox_$close                      000060 constant        entry                    external dcl 45 ref 343
iox_$detach_iocb                000062 constant        entry                    external dcl 46 ref 346
iox_$find_iocb                  000052 constant        entry                    external dcl 42 ref 366
iox_$open                       000056 constant        entry                    external dcl 44 ref 370
j                               004734 automatic       fixed bin(17,0)          dcl 147 set ref 286* 314* 528* 529 530 530* 531*
                                                                                  531*
k                               004735 automatic       fixed bin(17,0)          dcl 147 set ref 595*
last_available            1     000110 automatic       fixed bin(17,0)          level 2 packed unsigned unaligned dcl 74 set ref 380
last_blockno                    004351 automatic       fixed bin(17,0)          dcl 122 set ref 631*
len                             004557 automatic       fixed bin(17,0)          dcl 138 set ref 194* 197 198 203 206* 208 208 211
                                                                                  214* 216 216 219 219 222* 224 224 228 228 231* 233
                                                                                  233 236 236 237 238 239 239 240 240 241 241 242
                                                                                  242 242 243 244 244 245 245 247* 249 249 254 256
                                                                                  258 262 262 363* 365
linkage_fault_end                      constant        fixed bin(17,0)          initial dcl 1-3 ref 416
linkage_fault_start                    constant        fixed bin(17,0)          initial dcl 1-3 ref 414
linkfaults                             based           structure                level 1 unaligned dcl 91
linkp                           000014 internal static pointer                  initial dcl 96 set ref 184* 185 478 478* 494 494 494
                                                                                  494 495 495 496 496 503 503 504 504 555 557 576
linksw                          005034 automatic       bit(1)                   initial unaligned dcl 161 set ref 161* 237* 414 416
longsw                          005037 automatic       bit(1)                   initial dcl 163 set ref 163* 244* 430*
look_for_restart                004744 automatic       bit(1)                   initial unaligned dcl 154 set ref 154* 397 400 457*
look_for_timers                 004743 automatic       bit(1)                   initial unaligned dcl 153 set ref 153* 290* 308* 409
loopcnt                         005040 automatic       fixed bin(17,0)          initial dcl 164 set ref 164* 216* 217 259* 286 314
loopsw                          005022 automatic       bit(1)                   initial unaligned dcl 159 set ref 159* 212* 259
lstr                            005047 automatic       fixed bin(17,0)          dcl 169 set ref 520* 532 533* 533 534 535 535 537*
                                                                                  541 541 541
ltrim                                                  builtin function         dcl 59 ref 598 645 647
make_seg_failed                 004335 automatic       bit(1)                   initial unaligned dcl 111 set ref 111* 628 650*
marker_type                            constant        fixed bin(17,0)          initial dcl 1-3 ref 396 404
max                                                    builtin function         dcl 59 ref 427
maxhigh                         000017 internal static fixed bin(17,0)          initial dcl 149 set ref 427* 427 476* 515
maxlstr                         005050 automatic       fixed bin(17,0)          initial dcl 170 set ref 170* 242* 249* 250 251 252*
                                                                                  252 534
myname                          000000 constant        char(21)                 initial unaligned dcl 66 set ref 181* 262* 269* 275*
                                                                                  351* 649*
next_free                       000110 automatic       fixed bin(17,0)          level 2 packed unsigned unaligned dcl 74 set ref 380
                                                                                  380
nextlp                                 based           fixed bin(17,0)          level 2 dcl 91 set ref 494 494* 494 495 496 503 504*
                                                                                  504 555
nocaller                        005036 automatic       bit(1)                   unaligned dcl 162 set ref 561* 564* 581*
noise                           004745 automatic       bit(1)                   unaligned dcl 155 set ref 377* 435* 443* 446
not_in_read_bracket             000000 stack reference condition                dcl 72 ref 567 569
null                                                   builtin function         dcl 59 ref 109 120 180 185 330 332 478 494 496 643
                                                                                  648 667
nused                           004344 automatic       fixed bin(17,0)          dcl 119 set ref 635 635 636* 638* 642 665
nused_offset                    004350 automatic       fixed bin(17,0)          dcl 121 set ref 632* 635 635
nused_ptr                       004346 automatic       pointer                  initial dcl 120 set ref 120* 632* 635 635
offset                          004470 automatic       fixed bin(17,0)          dcl 131 set ref 565* 568* 581*
packedptr                              based           pointer                  unaligned dcl 88 ref 495 503
page                                   based           structure                array level 2 in structure "flush_seg" dcl 115
                                                                                  in procedure "cpt"
page                      2            based           fixed bin(8,0)           array level 2 in structure "seg" packed unaligned
                                                                                  dcl 81 in procedure "cpt" set ref 423 424* 424 529
                                                                                  530 531*
page_fault_type                        constant        fixed bin(17,0)          initial dcl 1-3 ref 422
page_no                         004126 automatic       fixed bin(11,0)          dcl 100 set ref 388* 392* 423 424 424
page_number               1(06)        based           fixed bin(12,0)          level 2 packed unsigned unaligned dcl 2-27 ref 392
page_trace$print_trace_entry    000046 constant        entry                    external dcl 40 ref 430
page_trace_entry                       based           structure                level 1 dcl 2-27
path                            004501 automatic       char(168)                unaligned dcl 133 set ref 365* 368
pnum                            004554 automatic       char(8)                  unaligned dcl 134 set ref 530* 531* 532
pnumb                                  based           char                     unaligned dcl 135 ref 532
pnumbl                          004556 automatic       fixed bin(17,0)          dcl 136 set ref 530* 531* 532 532 533
printlinksw                     005035 automatic       bit(1)                   initial unaligned dcl 161 set ref 161* 238* 274 321
printsw                         005025 automatic       bit(1)                   initial unaligned dcl 159 set ref 159* 240* 268 272*
                                                                                  274 320
pstring                         004633 automatic       char(256)                unaligned dcl 145 set ref 532* 535 541
pstringf                               based           char                     unaligned dcl 146 set ref 535* 541*
ptr                                                    builtin function         dcl 59 ref 635 635
qoverflow                       004334 automatic       bit(1)                   initial unaligned dcl 110 set ref 110* 319 628 657*
record_quota_overflow           000000 stack reference condition                dcl 72 ref 656 663
rel                                                    builtin function         dcl 59 ref 565
resetsw                         005027 automatic       bit(1)                   initial unaligned dcl 159 set ref 159* 236* 274 280
restart_fault_type                     constant        fixed bin(17,0)          initial dcl 1-3 ref 400
ring0_get_$definition           000110 constant        entry                    external dcl 57 ref 632
ring0_get_$name                 000106 constant        entry                    external dcl 56 ref 594
ring_zero_peek_                 000112 constant        entry                    external dcl 58 ref 635
save_ignoreint                  004742 automatic       bit(1)                   unaligned dcl 152 set ref 629* 671
seg                                    based           structure                array level 1 dcl 81
seg_fault_start                        constant        fixed bin(17,0)          initial dcl 1-3 ref 418
seg_no                          004124 automatic       fixed bin(11,0)          dcl 98 set ref 386* 391* 419 419 423 423 423 424 424
                                                                                  425 426 426 427
segf                      0(01)        based           fixed bin(16,0)          array level 2 packed unaligned dcl 81 set ref 419*
                                                                                  419 523 525*
segment_number            0(21)        based           fixed bin(15,0)          level 2 packed unsigned unaligned dcl 2-27 ref 391
segnum                                 parameter       fixed bin(11,0)          dcl 590 set ref 588 594 594 594 595 595 598*
signaller_type                         constant        fixed bin(17,0)          initial dcl 1-3 ref 409
sleepsw                         005024 automatic       bit(1)                   initial unaligned dcl 159 set ref 159* 204* 314
sleeptime                       005042 automatic       fixed bin(71,0)          dcl 166 set ref 208* 209 314*
stackframeptr                                          builtin function         dcl 59 ref 640
substr                                                 builtin function         dcl 59 set ref 254 532*
sys_info$max_seg_size           000122 external static fixed bin(19,0)          dcl 64 ref 177
temp_dir_name                   004747 automatic       char(168)                unaligned dcl 157 set ref 233* 645*
tempdsw                         004746 automatic       bit(1)                   initial unaligned dcl 156 set ref 156* 229* 645
timer_manager_$cpu_call         000116 constant        entry                    external dcl 61 ref 289 460
timer_manager_$reset_cpu_call   000120 constant        entry                    external dcl 62 ref 307 326
timer_manager_$sleep            000114 constant        entry                    external dcl 60 ref 314
timersw                         004740 automatic       bit(1)                   initial unaligned dcl 150 set ref 150* 243* 290 457
toptr                     2            based           pointer                  array level 3 packed unaligned dcl 91 set ref 494
                                                                                  496* 503* 576
total_no_page             0(18)        based           fixed bin(17,0)          array level 2 packed unaligned dcl 81 set ref 423*
                                                                                  423 522 525*
total_no_pagef            1            based           fixed bin(35,0)          array level 2 dcl 81 set ref 426* 426 525*
total_pages                     004132 automatic       fixed bin(17,0)          initial dcl 105 set ref 105* 522* 522 546*
total_pfaults                   000016 internal static fixed bin(17,0)          initial dcl 107 set ref 428* 428 477* 546*
total_segf                      004133 automatic       fixed bin(17,0)          initial dcl 106 set ref 106* 523* 523 546*
totalint                        005046 automatic       fixed bin(17,0)          initial dcl 168 set ref 168* 318 318* 459* 459
totalloop                       000020 internal static fixed bin(17,0)          dcl 165 set ref 475*
totalsw                         005026 automatic       bit(1)                   initial unaligned dcl 159 set ref 159* 241* 268 272
                                                                                  512 525
trace                                  based           structure                level 1 dcl 2-7
trace_copy                      000110 automatic       structure                level 1 dcl 74 set ref 304 304 455 455
trace_ptr                       000100 automatic       pointer                  dcl 2-5 set ref 382* 383 386 386 388 391 392
tracesw                         005032 automatic       bit(1)                   initial unaligned dcl 159 set ref 159* 199* 327 378
                                                                                  430 436 442
tsr_pageno                1(12)        based           fixed bin(8,0)           level 2 packed unsigned unaligned dcl 2-36 ref 388
tsr_segno_1               0(30)        based           bit(6)                   level 2 packed unaligned dcl 2-36 ref 386
tsr_segno_2               1(06)        based           bit(6)                   level 2 packed unaligned dcl 2-36 ref 386
type                      1            based           fixed bin(6,0)           level 2 in structure "page_trace_entry" packed
                                                                                  unsigned unaligned dcl 2-27 in procedure "cpt" ref
                                                                                  383
type                            004125 automatic       fixed bin(5,0)           dcl 99 in procedure "cpt" set ref 383* 385 396 400
                                                                                  404 409 414 416 418 422 422
unpackedptr                     004122 automatic       pointer                  dcl 89 set ref 557* 558 565 568* 572 572 576* 577*
                                                                                  577 577 579 579
word                                   based           fixed bin(17,0)          array level 3 dcl 115 ref 640 661
zzz9                            000100 automatic       picture(4)               unaligned dcl 484 set ref 486* 488
zzzzz9                          004340 automatic       picture(6)               unaligned dcl 113 set ref 644* 645 647

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
boundfault_end                         internal static fixed bin(17,0)          initial dcl 1-3
boundfault_start                       internal static fixed bin(17,0)          initial dcl 1-3
interrupt_type                         internal static fixed bin(17,0)          initial dcl 1-3
reschedule_type                        internal static fixed bin(17,0)          initial dcl 1-3
seg_fault_end                          internal static fixed bin(17,0)          initial dcl 1-3

NAMES DECLARED BY EXPLICIT CONTEXT.
AGAIN                           002745 constant        label                    dcl 380 ref 438
ARGERR                          001640 constant        label                    dcl 262 ref 201 207 209 215 217 223 225 232 234 248
                                                                                  250 251 254
DONE                            003347 constant        label                    dcl 446 ref 406 411
ISGATE                          004404 constant        label                    dcl 570 ref 567
NOQUOTA                         005425 constant        label                    dcl 665 ref 658
SKIP                            003245 constant        label                    dcl 432 ref 401
TEMPERR                         000677 constant        label                    dcl 181 ref 185
attach                          002533 constant        entry                    internal dcl 357 ref 200
cleaner                         002307 constant        entry                    internal dcl 325 ref 281 323
cpt                             000575 constant        entry                    external dcl 11
cumulative_page_trace           000605 constant        entry                    external dcl 11
detach                          002435 constant        entry                    internal dcl 339 ref 327 328
flush                           004755 constant        entry                    internal dcl 626 ref 296 464
get_trace                       002713 constant        entry                    internal dcl 375 ref 312 456
getname                         004611 constant        entry                    internal dcl 588 ref 518 572 579
iox_err                         002505 constant        entry                    internal dcl 349 ref 344 347
linkfaultend                    003626 constant        entry                    internal dcl 501 ref 416
linkfaultstart                  003601 constant        entry                    internal dcl 492 ref 414
nexts                           003556 constant        entry                    internal dcl 482 ref 294 295 462 463
print                           003644 constant        entry                    internal dcl 509 ref 320
printlinks                      004255 constant        entry                    internal dcl 551 ref 321
reset                           003514 constant        entry                    internal dcl 471 ref 186 280
timer                           003367 constant        entry                    internal dcl 451 ref 289 289 307 307 326 326 460 460

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6202        6326    5516        6212
Length      6676    5516       124         334     464          14

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cpt                                2820 external procedure  is an external procedure.  
on unit on line 281                  64 on unit               
cleaner                             120 internal procedure  is called by several nonquick procedures.  
detach                                  internal procedure  shares stack frame of internal procedure cleaner.  
iox_err                                 internal procedure  shares stack frame of internal procedure cleaner.  
attach                                  internal procedure  shares stack frame of external procedure cpt.  
get_trace                           147 internal procedure  is called by several nonquick procedures.  
timer                                80 internal procedure  is assigned to an entry variable.  
reset                                   internal procedure  shares stack frame of external procedure cpt.  
nexts                                68 internal procedure  is called by several nonquick procedures.  
linkfaultstart                          internal procedure  shares stack frame of internal procedure get_trace.  
linkfaultend                            internal procedure  shares stack frame of internal procedure get_trace.  
print                                   internal procedure  shares stack frame of external procedure cpt.  
printlinks                          154 internal procedure  enables or reverts conditions.  
on unit on line 567                  64 on unit               
getname                             107 internal procedure  is called by several nonquick procedures.  
flush                               124 internal procedure  enables or reverts conditions.  
on unit on line 656                  64 on unit               

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 highpage                    cpt
000011 counter                     cpt
000012 datap                       cpt
000014 linkp                       cpt
000016 total_pfaults               cpt
000017 maxhigh                     cpt
000020 totalloop                   cpt
000021 firstinit                   cpt
000022 hcsc                        cpt

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cpt                      000100 trace_ptr                   cpt
                         000110 trace_copy                  cpt
                         004120 cptb                        cpt
                         004121 cpte                        cpt
                         004122 unpackedptr                 cpt
                         004124 seg_no                      cpt
                         004125 type                        cpt
                         004126 page_no                     cpt
                         004127 beg_found                   cpt
                         004130 beg_found1                  cpt
                         004131 end_found                   cpt
                         004132 total_pages                 cpt
                         004133 total_segf                  cpt
                         004134 flushptr                    cpt
                         004334 qoverflow                   cpt
                         004335 make_seg_failed             cpt
                         004336 flushp_index                cpt
                         004340 zzzzz9                      cpt
                         004342 flushi                      cpt
                         004343 garbage                     cpt
                         004344 nused                       cpt
                         004346 nused_ptr                   cpt
                         004350 nused_offset                cpt
                         004351 last_blockno                cpt
                         004352 deftype                     cpt
                         004353 dirname                     cpt
                         004425 ename                       cpt
                         004436 comp_name                   cpt
                         004440 callee_name                 cpt
                         004450 caller_ename                cpt
                         004460 entry_name                  cpt
                         004470 offset                      cpt
                         004471 char32                      cpt
                         004501 path                        cpt
                         004554 pnum                        cpt
                         004556 pnumbl                      cpt
                         004557 len                         cpt
                         004560 aptr                        cpt
                         004562 iocbp                       cpt
                         004564 dump_iocbp                  cpt
                         004566 command                     cpt
                         004630 comptr                      cpt
                         004632 comlen                      cpt
                         004633 pstring                     cpt
                         004733 i                           cpt
                         004734 j                           cpt
                         004735 k                           cpt
                         004736 high_seg                    cpt
                         004737 code                        cpt
                         004740 timersw                     cpt
                         004741 ignoreint                   cpt
                         004742 save_ignoreint              cpt
                         004743 look_for_timers             cpt
                         004744 look_for_restart            cpt
                         004745 noise                       cpt
                         004746 tempdsw                     cpt
                         004747 temp_dir_name               cpt
                         005021 countsw                     cpt
                         005022 loopsw                      cpt
                         005023 flushsw                     cpt
                         005024 sleepsw                     cpt
                         005025 printsw                     cpt
                         005026 totalsw                     cpt
                         005027 resetsw                     cpt
                         005030 comsw                       cpt
                         005031 debugsw                     cpt
                         005032 tracesw                     cpt
                         005033 intsw                       cpt
                         005034 linksw                      cpt
                         005035 printlinksw                 cpt
                         005036 nocaller                    cpt
                         005037 longsw                      cpt
                         005040 loopcnt                     cpt
                         005042 sleeptime                   cpt
                         005044 inttime                     cpt
                         005046 totalint                    cpt
                         005047 lstr                        cpt
                         005050 maxlstr                     cpt
nexts                    000100 zzz9                        nexts

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return
move_label_var      make_label_var      tra_ext             mpfx2               enable              shorten_stack
ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absolute_pathname_            com_err_                      cu_$arg_count                 cu_$arg_ptr
cu_$cp                        cv_bin_$oct                   cv_dec_check_                 get_entry_name_
hcs_$delentry_seg             hcs_$fs_get_path_name         hcs_$get_page_trace           hcs_$high_low_seg_count
hcs_$make_seg                 hcs_$trace_marker             hcs_$truncate_seg             interpret_bind_map_
ioa_                          ioa_$ioa_switch               ioa_$rsnnl                    iox_$attach_iocb
iox_$close                    iox_$detach_iocb              iox_$find_iocb                iox_$open
page_trace$print_trace_entry  ring0_get_$definition         ring0_get_$name               ring_zero_peek_
timer_manager_$cpu_call       timer_manager_$reset_cpu_call timer_manager_$sleep

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    105 000514       106 000515       109 000516       110 000534       111 000535       120 000536       150 000540
    151 000541       153 000542       154 000543       156 000544       159 000545       160 000557       161 000561
    163 000563       164 000564       167 000565       168 000567       170 000570        11 000574       175 000613
    177 000616       178 000622       179 000632       180 000672       181 000677       182 000725       184 000726
    185 000765       186 000772       188 000773       192 000775       194 001011       195 001026       197 001030
    198 001041       199 001045       200 001047       201 001054       202 001056       203 001057       204 001063
    205 001065       206 001066       207 001103       208 001105       209 001134       210 001137       211 001140
    212 001144       213 001146       214 001147       215 001164       216 001166       217 001212       218 001216
    219 001217       220 001227       221 001231       222 001232       223 001247       224 001251       225 001300
    226 001306       227 001312       228 001313       229 001323       230 001325       231 001326       232 001343
    233 001345       234 001371       235 001373       236 001374       237 001407       238 001416       239 001425
    240 001440       241 001453       242 001466       243 001505       244 001514       245 001527       246 001537
    247 001540       248 001555       249 001557       250 001603       251 001610       252 001613       253 001615
    254 001616       255 001622       256 001624       257 001627       258 001631       259 001633       260 001637
    262 001640       263 001673       266 001674       268 001676       269 001715       270 001742       272 001743
    274 001751       275 001761       276 002006       280 002007       281 002012       282 002034       286 002036
    288 002045       289 002047       290 002067       291 002072       294 002073       295 002101       296 002107
    297 002115       299 002124       301 002141       303 002143       304 002152       306 002163       307 002165
    308 002177       312 002200       314 002204       316 002224       318 002226       319 002252       320 002270
    321 002273       323 002301       675 002305       325 002306       326 002314       327 002332       328 002353
    329 002374       330 002404       331 002412       332 002424       334 002432       336 002434       339 002435
    343 002446       344 002461       346 002465       347 002500       355 002504       349 002505       351 002506
    353 002532       357 002533       362 002544       363 002545       364 002562       365 002565       366 002572
    367 002615       368 002620       369 002660       370 002664       371 002706       373 002711       375 002712
    377 002720       378 002725       380 002745       382 002764       383 002771       385 002775       386 002777
    388 003011       389 003015       391 003016       392 003021       395 003025       396 003027       397 003036
    398 003043       399 003045       400 003046       401 003056       404 003057       405 003066       406 003070
    409 003071       410 003101       411 003103       414 003104       416 003112       418 003120       419 003122
    420 003136       422 003137       423 003143       424 003174       425 003204       426 003210       427 003215
    428 003222       430 003223       432 003245       434 003270       435 003272       436 003275       438 003317
    441 003320       442 003322       443 003344       446 003347       449 003365       451 003366       453 003374
    454 003377       455 003405       456 003417       457 003424       459 003430       460 003431       462 003453
    463 003463       464 003473       465 003503       467 003513       471 003514       473 003515       475 003531
    476 003533       477 003534       478 003535       480 003554       482 003555       486 003563       487 003572
    488 003573       492 003601       494 003602       495 003612       496 003623       498 003625       501 003626
    503 003627       504 003642       506 003643       509 003644       512 003645       513 003664       515 003700
    517 003707       518 003714       520 003724       521 003725       522 003730       523 003737       525 003745
    528 004015       529 004023       530 004042       531 004074       532 004127       533 004134       534 004136
    535 004141       536 004166       537 004171       540 004172       541 004174       544 004223       546 004225
    549 004253       551 004254       553 004262       555 004275       557 004310       558 004315       560 004320
    561 004323       562 004325       564 004326       565 004330       566 004333       567 004336       568 004355
    569 004403       570 004404       572 004424       573 004440       576 004444       577 004452       578 004506
    579 004516       581 004531       583 004573       584 004576       586 004607       588 004610       592 004616
    594 004622       595 004656       596 004711       598 004721       600 004753       626 004754       628 004762
    629 004767       630 004771       631 004773       632 004774       633 005033       635 005036       636 005063
    637 005070       638 005071       640 005073       642 005076       643 005112       644 005120       645 005130
    647 005222       648 005312       649 005322       650 005347       651 005352       656 005353       657 005367
    658 005373       660 005376       661 005410       662 005420       663 005422       664 005423       665 005425
    667 005442       669 005465       671 005470       673 005472


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
