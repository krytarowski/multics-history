	COMPILATION LISTING OF SEGMENT move_data
	Compiled by: Multics PL/I Compiler, Release 28d, of September 14, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 10/03/83  1650.6 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* Procedure to move a block of data
       12*
       13*   Modified:  3 January 1973 by BLW
       14*  Modified:  19 February 1973 by RAB
       15* Modified:  12 June 1973 by RAB for EIS
       16*Modified:	21 December 1974 by RAB to fix bug 1277
       17*Modified:	22 January 1975 by RAB to fix bug 1314
       18*Modified:	22 July 1975 by RAB to fix bug 1388
       19*Modified:	9 February 1976 by RAB to fix 1462 & change ref cnt for dec
       20*Modified:	26 May 1976 by RAB to improve determination of reference.even for structures
       21*Modified:	5 July 1976 by RAB to fix 1504
       22*   Modified: 27 October 1977 by RAB to more efficiently move packed aggregates of words
       23*   Modified: 28 October 1977 by RAB to more efficiently move an aggregate when one is on even bound
       24*	and other is on unknown bound
       25*   Modified 781127 by PG to fix bug 1801 (setting even bit when it wasn't), introduced one year ago, and just found today!
       26*   Modified 781128 by RAB to remove PG's fix to 1801 and put it in get_array_size
       27*   Modified 790523 by RAB to fix 1820 & 1836 caused by assignment to complex
       28*	binary temp other than complex_flt_bin_1
       29**/
       30 
       31 move_data: proc(pt);
       32 
       33 dcl	pt ptr;		/* points at an operator node */
       34 
       35 dcl	(p,q,q1,q2,p1,p2,s,arg(2)) ptr,
       36 	pd ptr defined(arg(1)),
       37 	ps ptr defined(arg(2)),
       38 	(adjust,atomic,big_length_hold,have_constant_length,sp_ok) bit(1) aligned,
       39 	base bit(3) aligned,
       40 	(case,i,n,amount) fixed bin,
       41 	macro fixed bin(15);
       42 
       43 dcl	(addr,addrel,bit,divide,fixed,mod,null,substr) builtin;
       44 
       45 dcl	base_man$store_ptr_to entry(ptr,ptr),
       46 	prepare_operand entry(ptr,fixed bin,bit(1) aligned) returns(ptr),
       47 	state_man$erase_reg entry(bit(19) aligned),
       48 	c_a entry(fixed bin,fixed bin) returns(ptr),
       49 	make_both_addressable entry(ptr,ptr,bit(1) aligned),
       50 	expmac$many entry(fixed bin(15),ptr,fixed bin),
       51 	expmac$one entry(fixed bin(15),ptr,fixed bin),
       52 	expmac$zero entry(fixed bin(15)),
       53 	adjust_ref_count entry(ptr,fixed bin),
       54 	generate_constant$real_fix_bin_1 entry(fixed bin) returns(ptr),
       55 	load entry(ptr,fixed bin),
       56 	compile_exp entry(ptr),
       57 	eval_exp entry(ptr,bit(1) aligned) returns(ptr),
       58 	long_op$two_eis entry(ptr,fixed bin,fixed bin(15),ptr),
       59 	expmac$two_eis entry(fixed bin(15),ptr,ptr),
       60 	expmac entry(fixed bin(15),ptr),
       61 	base_man$load_any_var_and_lock entry(fixed bin,ptr) returns(bit(3) aligned);
       62 
       63 dcl	double_data bit(24) int static init("010111110000000111111110"b);
       64 
       65 dcl	alters(0:1) bit(19) aligned static init("1"b,"11"b);
       66 
       67 dcl (	copy_mac		init(257),
       68 	set_bits		init(440),
       69 	move_words	init(481),
       70 	lda		init(1),
       71 	sta		init(4),
       72 	nop_mac		init(528),
       73 	move_3		init(568),
       74 	conv_mac(2)	init(515,26),	/* qls, dvfx1 */
       75 	copy_bits		init(476)) fixed bin(15) int static;
       76 
       77 dcl	table(0:1,0:1,3:6) fixed bin(15) int static
       78 	init(	/* odd, odd */	569, 570, 571, 0,
       79 		/* odd, even */	572, 573, 0, 0,
       80 		/* even, odd */	574, 575, 0, 0,
       81 		/* even, even */	576, 577, 578, 579);
       82 
       83 dcl	conv_factor(2) fixed bin int static
       84 	init(2,9);	/* bits, bits_per_char */
       85 
       86 dcl	fix_bin		fixed bin based;
       87 
  1     1 /* BEGIN INCLUDE FILE ... reference.incl.pl1 */
  1     2 
  1     3 dcl	1 reference		based aligned,
  1     4 	2 node_type		bit(9) unaligned,
  1     5 	2 array_ref		bit(1) unaligned,
  1     6 	2 varying_ref		bit(1) unaligned,
  1     7 	2 shared			bit(1) unaligned,
  1     8 	2 put_data_sw		bit(1) unaligned,
  1     9 	2 processed		bit(1) unaligned,
  1    10 	2 units			fixed(3) unaligned,
  1    11 	2 ref_count		fixed(17) unaligned,
  1    12 	2 c_offset		fixed(24),
  1    13 	2 c_length		fixed(24),
  1    14 	2 symbol			ptr unaligned,
  1    15 	2 qualifier		ptr unaligned,
  1    16 	2 offset			ptr unaligned,
  1    17 	2 length			ptr unaligned,
  1    18 	2 subscript_list		ptr unaligned,
  1    19 						/* these fields are used by the 645 code generator */
  1    20 	2 address			structure unaligned,
  1    21 	  3 base			bit(3),
  1    22 	  3 offset		bit(15),
  1    23 	  3 op			bit(9),
  1    24 	  3 no_address		bit(1),
  1    25 	  3 inhibit		bit(1),
  1    26 	  3 ext_base		bit(1),
  1    27 	  3 tag			bit(6),
  1    28 	2 info			structure unaligned,
  1    29 	  3 address_in		structure,
  1    30 	    4 b			dimension(0:7) bit(1),
  1    31 	    4 storage		bit(1),
  1    32 	  3 value_in		structure,
  1    33 	    4 a			bit(1),
  1    34 	    4 q			bit(1),
  1    35 	    4 aq			bit(1),
  1    36 	    4 string_aq		bit(1),
  1    37 	    4 complex_aq		bit(1),
  1    38 	    4 decimal_aq		bit(1),
  1    39 	    4 b			dimension(0:7) bit(1),
  1    40 	    4 storage		bit(1),
  1    41 	    4 indicators		bit(1),
  1    42 	    4 x			dimension(0:7) bit(1),
  1    43 	  3 other			structure,
  1    44 	    4 big_offset		bit(1),
  1    45 	    4 big_length		bit(1),
  1    46 	    4 modword_in_offset	bit(1),
  1    47 	2 data_type		fixed(5) unaligned,
  1    48 	2 bits			structure unaligned,
  1    49 	  3 padded_ref		bit(1),
  1    50 	  3 aligned_ref		bit(1),
  1    51 	  3 long_ref		bit(1),
  1    52 	  3 forward_ref		bit(1),
  1    53 	  3 ic_ref		bit(1),
  1    54 	  3 temp_ref		bit(1),
  1    55 	  3 defined_ref		bit(1),
  1    56 	  3 evaluated		bit(1),
  1    57 	  3 allocate		bit(1),
  1    58 	  3 allocated		bit(1),
  1    59 	  3 aliasable		bit(1),
  1    60 	  3 even			bit(1),
  1    61 	  3 perm_address		bit(1),
  1    62 	  3 aggregate		bit(1),
  1    63 	  3 hit_zero		bit(1),
  1    64 	  3 dont_save		bit(1),
  1    65 	  3 fo_in_qual		bit(1),
  1    66 	  3 hard_to_load		bit(1),
  1    67 	2 relocation		bit(12) unaligned,
  1    68 	2 more_bits		structure unaligned,
  1    69 	  3 substr		bit(1),
  1    70 	  3 padded_for_store_ref	bit(1),
  1    71 	  3 aligned_for_store_ref	bit(1),
  1    72 	  3 mbz			bit(15),
  1    73 	2 store_ins		bit(18) unaligned;
  1    74 
  1    75 /* END INCLUDE FILE ... reference.incl.pl1 */
       88 
  2     1 /* BEGIN INCLUDE FILE ... symbol.incl.pl1 */
  2     2 
  2     3 dcl	1 symbol			based aligned,
  2     4 	2 node_type		bit(9) unal,
  2     5 	2 source_id		structure unal,
  2     6 	  3 file_number		bit(8),
  2     7 	  3 line_number		bit(14),
  2     8 	  3 statement_number	bit(5),
  2     9 	2 location		fixed(18) unal unsigned,
  2    10 	2 allocated		bit(1) unal,
  2    11 	2 dcl_type		bit(3) unal,
  2    12 	2 reserved		bit(6) unal,
  2    13 	2 pix			unal,
  2    14 	  3 pic_fixed		bit(1) unal,
  2    15 	  3 pic_float		bit(1) unal,
  2    16 	  3 pic_char		bit(1) unal,
  2    17 	  3 pic_scale		fixed(7) unal,
  2    18 	  3 pic_size		fixed(7) unal,
  2    19 	2 level			fixed(8) unal,
  2    20 	2 boundary		fixed(3) unal,
  2    21 	2 size_units		fixed(3) unal,
  2    22 	2 scale			fixed(7) unal,
  2    23 	2 runtime			bit(18) unal,
  2    24 	2 runtime_offs(B  tapa ¿    P    )H  T˙àY @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Q  tapa Ä    h    )I  T˙à}ˆ @  @      ioi_masked$interrupt: I/O error.À@@B22     Z   tapaÄÄ  c¿çò Ä   Ä    h    )J  T˙»âK @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapaJÄÄ  c¿çò Ä        T    )K  T˙îÚœ @p @      mos_memory_check: EDAC error on mem b store a.      æ           T    )L  T˙î˜] @p @      mos_memory_check: EDAC error on mem b store b.      ^           T    )M  T˙î˚q @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^      ¿    P    )N  T˙HéÁ @  @      ioi_masked$interrupt: I/O error.¿ ¿B16     @ prta ¿    L    )O  T˙ïk	  h  @      RCP: Detached tapa_01 from Backup.SysDaemon.z        ¿    L    )P  T˙òÕ
  x  @      RCP: Unassigned tapa_01 from Backup.SysDaemon.z      Ä    h    )Q  T˙»êT @  @      ioi_masked$interrupt: I/O error.”ÄÄB22     Z   tapa*ÄÄ  c¿çò¯ Ä   ¿    P    )R  T˙ìb @  @      ioi_masked$interrupt: I/O error.œA @B16     @ prta      T    )S  T˙÷≠ @p @      mos_memory_check: EDAC error on mem b store a.      g~           T    )T  T˙€õ @p @      mos_memory_check: EDAC error on mem b store b.      ^           T    )U  T˙ﬁÊ @x @      mos_memory_check: EDAC error on mem b store b1.     æ      Ä    h    )V  T˙òM @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapabÄÄ  c¿çò Ä   ¿    P    )Y  T˙Áã @  @      ioi_masked$interrupt: I/O error.¿ ¬B22        tapa Ä    h    )Z  T˙ËÛ^ @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapa^ÇÄÄ0 c¿çò êÄ   ¿    P    )[  T˙Èr @  @      ioi_masked$interrupt: I/O error.¿ &¿B22        tapa ¿    P    )\  T˙ÈcÅ @  @      ioi_masked$interrupt: I/O error.¿ ≈B22        tapa ¿    P    )]  T˙Èò[ @  @      ioi_masked$interrupt: I/O error.¿ -¿B22        tapa ¿    P    )^  T˙È◊Ω @  @      ioi_masked$interrupt: I/O error.¿ ¿B22        tapa ¿    P    )_  T˙Í—ﬂ @  @      ioi_masked$interrupt: I/O error.¿ -B22        tapa ¿    L    )`  T˙Í÷Ò  h  @      RCP: Detached tapa_00 from Backup.SysDaemon.z        Ä    D    )a  T˙Ìü<  @  @      RCP: Errors (tapa_00, volume COM233) = 7     ¿    L    )b  T˙%;  x  @      RCP: Unassigned tapa_00 from Backup.SysDaemon.z      Ä    H    )c  T˙ÙÕe  X  @      RCP: Assigned tapa_01 to Backup.SysDaemon.zo Ä    H    )d  T˙ıTã  `  @      RCP: Attached tapa_01 for Backup.SysDaemon.z Ä    H    )e  T˙¯  H  @      RCP: Note (tapa_01) - COM234,den=6250,sysn.z @    `    )f  T˙˙ˆ ¡  @      RCP: Mount Reel COM234 with ring on tapa_01 for Backup.SysDaemon.z        T    )g  T˙Öº @p @      mos_memory_check: EDAC error on mem b store a.r     æ           T    )h  T˙Ö¿4 @p @      mos_memory_check: EDAC error on mem b store b.r     ^           T    )i  T˙Öƒ; @x @      mos_memory_check: EDAC error on mem b store b1.     æ      Ä    d    )j  T˙íå” ¡@  @      RCP: Check Mount of COM234 for writing on tapa_01 for Backup.SysDaemon.z     Ä    H    )k  T˙ñ0q  H  @      RCP: Note (tapa_01) - COM234,den=6250,sys ta      T    )l  T˙˛ü” @p @      mos_memory_check: EDAC error on mem b store a._0    æ           T    )m  T˙˛£} @p @      mos_memory_check: EDAC error on mem b store b._0    ^           T    )n  T˙˛ß¿ @x @      mos_memory_check: EDAC error on mem b store b1.0    ≈^      Ä    d    )o  T˙%µÆ ¡@  @      RCP: Check Mount of COM234 for writing on tapa_01 for Backup.SysDaemon.z     Ä    H    )p  T˙)W,  H  @      RCP: Note (tapa_01) - COM234,den=6250,sys ta      T    )q  T˙vÉ7 @p @      mos_memory_check: EDAC error on mem b store a._0    æ           T    )r  T˙váˆ @p @      mos_memory_check: EDAC error on mem b store b._0    ^           T    )s  T˙vãL @x @      mos_memory_check: EDAC error on mem b store b1.0    ≈^      Ä    d    )t  T˙πﬂ¿ ¡@  @      RCP: Check Mount of COM234 for writing on tapa_01 for Backup.SysDaemon.z     Ä    H    )u  T˙ΩÜM 	    4 overlayed		bit(1),
  2   141 	    4 error		bit(1),
  2   142 	    4 symtab_processed	bit(1),
  2   143 	    4 overlayed_by_builtin	bit(1),
  2   144 	    4 defaulted		bit(1),
  2   145 	    4 connected		bit(1);
  2   146 
  2   147 /* END INCLUDE FILE ... symbol.incl.pl1 */
       89 
  3     1 dcl	1 array			based aligned,
  3     2 	2 node_type		bit(9) unaligned,
  3     3 	2 reserved		bit(34) unaligned,
  3     4 	2 number_of_dimensions	fixed(7) unaligned,
  3     5 	2 own_number_of_dimensions	fixed(7) unaligned,
  3     6 	2 element_boundary		fixed(3) unaligned,
  3     7 	2 size_units		fixed(3) unaligned,
  3     8 	2 offset_units		fixed(3) unaligned,
  3     9 	2 interleaved		bit(1) unaligned,
  3    10 	2 c_element_size		fixed(24),
  3    11 	2 c_element_size_bits	fixed(24),
  3    12 	2 c_virtual_origin		fixed(24),
  3    13 	2 element_size		ptr unaligned,
  3    14 	2 element_size_bits		ptr unaligned,
  3    15 	2 virtual_origin		ptr unaligned,
  3    16 	2 symtab_virtual_origin	ptr unaligned,
  3    17 	2 symtab_element_size	ptr unaligned,
  3    18 	2 bounds			ptr unaligned,
  3    19 	2 element_descriptor	ptr unaligned;
  3    20 
  3    21 dcl	1 bound			based aligned,
  3    22 	2 node_type		bit(9),
  3    23 	2 c_lower			fixed(24),
  3    24 	2 c_upper			fixed(24),
  3    25 	2 c_multiplier		fixed(24),
  3    26 	2 c_desc_multiplier		fixed(24),
  3    27 	2 lower			ptr unaligned,
  3    28 	2 upper			ptr unaligned,
  3    29 	2 multiplier		ptr unaligned,
  3    30 	2 desc_multiplier		ptr unaligned,
  3    31 	2 symtab_lower		ptr unaligned,
  3    32 	2 symtab_upper		ptr unaligned,
  3    33 	2 symtab_multiplier		ptr unaligned,
  3    34 	2 next			ptr unaligned;
       90 
  4     1 /* BEGIN INCLUDE FILE ... nodes.incl.pl1 */
  4     2 
  4     3 /* Modified: 26 Dec 1979 by PCK to implement by name assignment */
  4     4 
  4     5 dcl (	block_node		initial("000000001"b),
  4     6 	statement_node		initial("000000010"b),
  4     7 	operator_node		initial("000000011"b),
  4     8 	reference_node		initial("000000100"b),
  4     9 	token_node		initial("000000101"b),
  4    10 	symbol_node		initial("000000110"b),
  4    11 	context_node		initial("000000111"b),
  4    12 	array_node		initial("000001000"b),
  4    13 	bound_node		initial("000001001"b),
  4    14 	format_value_node		initial("000001010"b),
  4    15 	list_node			initial("000001011"b),
  4    16 	default_node		initial("000001100"b),
  4    17 	machine_state_node		initial("000001101"b),
  4    18 	source_node		initial("000001110"b),
  4    19 	label_node		initial("000001111"b),
  4    20 	cross_reference_node	initial("000010000"b),
  4    21 	sf_par_node		initial("000010001"b),
  4    22 	temporary_node		initial("000010010"b),
  4    23 	label_array_element_node	initial("000010011"b),
  4    24 	by_name_agg_node		initial("000010100"b))
  4    25 				bit(9) internal static aligned options(constant);
  4    26 
  4    27 dcl	1 node			based aligned,
  4    28 	2 type			unal bit(9),
  4    29 	2 source_id		unal structure,
  4    30 	  3 file_number		bit(8),
  4    31 	  3 line_number		bit(14),
  4    32 	  3 statement_number	bit(5);
  4    33 
  4    34 /* END INCLUDE FILE ... nodes.incl.pl1 */
       91 
  5     1 dcl	bases(0:7) bit(3) aligned int static init("000"b, "010"b, "100"b,  "001"b, "011"b, "101"b, "111"b,"110"b)
  5     2 	options(constant);
  5     3 
  5     4 dcl (	ap	defined(bases(0)),
  5     5 	bp	defined(bases(1)),
  5     6 	lp	defined(bases(2)),
  5     7 	sp	defined(bases(7))) bit(3) aligned;
  5     8 
  5     9 dcl (	ab	defined(bases(3)),
  5    10 	bb	defined(bases(4)),
  5    11 	lb	defined(bases(5)),
  5    12 	sb	defined(bases(6))) bit(3) aligned;
  5    13 
  5    14 dcl	which_base(0:7) fixed bin int static init(0,3,1,4,2,5,7,6) options(constant);
       92 
  6     1 /* BEGIN INCLUDE FILE ... operator.incl.pl1 */
  6     2 
  6     3 /*	Modified: 2 Apr 1980 by PCK to add max_number_of_operands */
  6     4 
  6     5 /* format: style3 */
  6     6 dcl	1 operator	based aligned,
  6     7 	  2 node_type	bit (9) unaligned,
  6     8 	  2 op_code	bit (9) unaligned,
  6     9 	  2 shared	bit (1) unaligned,
  6    10 	  2 processed	bit (1) unaligned,
  6    11 	  2 optimized	bit (1) unaligned,
  6    12 	  2 number	fixed (14) unaligned,
  6    13 	  2 operand	dimension (n refer (operator.number)) ptr unaligned;
  6    14 
  6    15 dcl	max_number_of_operands
  6    16 			fixed bin (15) int static options (constant) initial (32767);
  6    17 
  6    18 /* END INCLUDE FILE ... operator.incl.pl1 */
       93 
  7     1 /* BEGIN INCLUDE FILE ... op_codes.incl.pl1 */
  7     2 
  7     3 /* Modified: 25 Apr 1979 by PCK 4-bit decimal */
  7     4 /* Modified: 6 Jun 1979 by PG to add rank and byte */
  7     5 /* Modified: 26 Dec 1979 by PCK to add assign_by_name */
  7     6 /* Modified: 26 July 82 BIM wordno, segno */
  7     7 
  7     8 dcl (	add		initial("000010001"b),	/* opnd(1) <- opnd(2)+opnd(3)		*/
  7     9 	sub		initial("000010010"b),	/* opnd(1) <- opnd(2)-opnd(3)		*/
  7    10 	mult		initial("000010011"b),	/* opnd(1) <- opnd(2)*opnd(3)		*/
  7    11 	div		initial("000010100"b),	/* opnd(1) <- opnd(2)/opnd(3)		*/
  7    12 	negate		initial("000010101"b),	/* opnd(1) <- -opnd(2)  		*/
  7    13 	exp		initial("000010110"b),	/* opnd(1) <- opnd(2) ** opnd(3)	*/
  7    14 
  7    15 	and_bits		initial("000100001"b),	/* opnd(1) <- opnd(2) & opnd(3)	*/
  7    16 	or_bits		initial("000100010"b),	/* opnd(1) <- opnd(2)|opnd(3)		*/
  7    17 	xor_bits		initial("000100011"b),	/* opnd(1) <- opnd(2) xor opnd(3)	*/
  7    18 	not_bits		initial("000100100"b),	/* opnd(1) <- ^opnd(2)		*/
  7    19 	cat_string	initial("000100101"b),	/* opnd(1) <- opnd(2)||opnd(3)	*/
  7    20 	bool_fun		initial("000100110"b),	/* opnd(1) <- bool(opnd(2),opnd(3),opnd(4)) */
  7    21 
  7    22 	assign		initial("000110001"b),	/* opnd(1) <- opnd(2)		*/
  7    23 	assign_size_ck	initial("000110010"b),	/* opnd(1) <- opnd(2)		*/
  7    24 	assign_zero	initial("000110011"b),	/* opnd(1) <- 0			*/
  7    25 	copy_words	initial("000110100"b),	/* move opnd(2) to opnd(1) by opnd(3) words */
  7    26 	copy_string	initial("000110101"b),	/* move opnd(2) to opnd(1) by opnd(3) units */
  7    27 	make_desc		initial("000110110"b),	/* opnd(1) <- descriptor(opnd(2),opnd(3)) */
  7    28 	assign_round	initial("000110111"b),	/* opnd(1) <- opnd(2) rounded		*/
  7    29 	pack		initial("000111000"b),	/* opnd(1) <- encode to picture opnd(2) */
  7    30 	unpack		initial("000111001"b),	/* opnd(1) <- decode from picture opnd(2) */
  7    31 
  7    32 	less_than		initial("001000100"b),	/* opnd(1) <- opnd(2) < opnd(3)	*/
  7    33 	greater_than	initial("001000101"b),	/* opnd(1) <- opnd(2) > opnd(3)	*/
  7    34 	equal		initial("001000110"b),	/* opnd(1) <- opnd(2) = opnd(3)	*/
  7    35 	not_equal		initial("001000111"b),	/* opnd(1) <- opnd(2) ^= opnd(3)	*/
  7    36 	less_or_equal	initial("001001000"b),	/* opnd(1) <- opnd(2) <= opnd(3)	*/
  7    37 	greater_or_equal	initial("001001001"b),	/* opnd(1) <- opnd(2) >= opnd(3)	*/
  7    38 
  7    39 	jump		initial("001010001"b),	/* go to opnd(1) unconditionally	*/
  7    40 	jump_true		initial("001010010"b),	/* go to opnd(1) if opnd(2) is not 0	*/
  7    41 	jump_false	initial("001010011"b),	/* go to opnd(1) if opnd(2) is all 0	*/
  7    42 	jump_if_lt	initial("001010100"b),	/* go to opnd(1) if opnd(2) < opnd(3)	*/
  7    43 	jump_if_gt	initial("001010101"b),	/* go to opnd(1) if opnd(2) > opnd(3)	*/
  7    44 	jump_if_eq	initial("001010110"b),	/* go to opnd(1) if opnd(2) = opnd(3)	*/
  7    45 	jump_if_ne	initial("001010111"b),	/* go to opnd(1) if opnd(2) ^= opnd(3)	*/
  7    46 	jump_if_le	initial("001011000"b),	/* go to opnd(1) if opnd(2) <= opnd(3)	*/
  7    47 	jump_if_ge	initial("001011001"b),	/* go to opnd(1) if opnd(2) >= opnd(3)	*/
  7    48 
  7    49 	std_arg_list	initial("001100001"b),	/* opnd(1) <- arglist(opnd(2) desclist(opnd(3)))	*/
  7    50 	return_words	initial("001100010"b),	/* return aggregate opnd(1), opnd(2) is length in words */
  7    51 	std_call		initial("001100011"b),	/* opnd(1) <- call opnd(2) with opnd(3)		*/
  7    52 	return_bits	initial("001100100"b),	/* return aggregate opnd(1), opnd(2) is length in bits */
  7    53 	std_entry		initial("001100101"b),	/* entry(opnd(1)... opnd(n))			*/
  7    54 	return_string	initial("001100110"b),	/* return string opnd(1) */
  7    55 	ex_prologue	initial("001100111"b),	/* execute the prologue -no operands-		*/
  7    56 	allot_auto	initial("001101000"b),	/* opnd(1) <- addrel(stack,opnd(2))		*/
  7    57 	param_ptr		initial("001101001"b),	/* opnd(1) <- ptr to opnd(2) in  block opnd(3)	*/
  7    58 	param_desc_ptr	initial("001101010"b),	/* opnd(1) <- ptr to opnd(2) in block opnd(3)	*/
  7    59 	std_return	initial("001101011"b),	/* return -no arguments-			*/
  7    60 	allot_ctl		initial("001101100"b),	/* allocate opnd(1) , length in words is opnd(2) 	*/
  7    61 	free_ctl		initial("001101101"b),	/* free opnd(1)				*/
  7    62 	stop		initial("001101110"b),	/* stop - terminate run unit			*/
  7    63 
  7    64 	mod_bit		initial("001110000"b),	/* opnd(1) <- mod(opnd(3),36),
  7    65*						   opnd(2) <- opnd(3) / 36		*/
  7    66 	mod_byte		initial("001110001"b),	/* opnd(1) <- mod(opnd(3),4),
  7    67*						   opnd(2) <- opnd(3) / 4		*/
  7    68 	mod_half		initial("001110010"b),	/* opnd(1) <- mod(opnd(3),2),
  7    69*						   opnd(2) <- opnd(3) / 2		*/
  7    70 	mod_word		initial("001110011"b),	/* TO BE DEFINED BY BLW			*/
  7    71 
  7    72 	bit_to_char	initial("010000000"b),	/* opnd(1) <- (opnd(2)+8)/9		*/
  7    73 	bit_to_word	initial("010000001"b),	/* opnd(1) <- (opnd(2)+35)/36		*/
  7    74 	char_to_word	initial("010000010"b),	/* opnd(1) <- (opnd(2)+3)/4		*/
  7    75 	half_to_word	initial("010000011"b),	/* opnd(1) <- (opnd(2)+1)/2		*/
  7    76 	word_to_mod2	initial("010000100"b),	/* opnd(1) <- (opnd(2)+1)/2*2		*/
  7    77 	word_to_mod4	initial("010000101"b),	/* opnd(1) <- (opnd(2)+3)/4*4		*/
  7    78 	word_to_mod8	initial("010000110"b),	/* opnd(1) <- (opnd(2)+7)/8*8		*/
  7    79 	rel_fun		initial("010000111"b),	/* opnd(1) <- rel(opnd(2))		*/
  7    80 	baseno_fun	initial("010001000"b),	/* opnd(1) <- baseno(opnd(2))		*/
  7    81 	desc_size		initial("010001001"b),	/* opnd(1) <- substr(opnd(2),13,24)	*/
  7    82 	bit_pointer	initial("010001010"b),	/* opnd(1) <- bit offset of opnd(2)	*/
  7    83 	index_before_fun	initial("010001011"b),	/* opnd(1) <- length of before(opnd(2),opnd(3)) */
  7    84 	index_after_fun	initial("010001100"b),	/* opnd(1) <- offset of after(opnd(2),opnd(3)) in opnd(2) */
  7    85 	verify_ltrim_fun	initial("010001101"b),	/* opnd(1) <- offset of ltrim(opnd(2),opnd(3)) in opnd(2) */
  7    86 	verify_rtrim_fun	initial("010001110"b),	/* opnd(1) <- length(opnd(2))-length(rtrim(opnd(2),opnd(3))) */
  7    87 	digit_to_bit	initial("010001111"b),	/* opnd(1) <- 9*opnd(2)/2		*/
  7    88 
  7    89 	ceil_fun		initial("010010000"b),	/* opnd(1) <- ceil(opnd(2))		*/
  7    90 	floor_fun		initial("010010001"b),	/* opnd(1) <- floor(opnd(2))		*/
  7    91 	round_fun		initial("010010010"b),	/* opnd(1) <- round(opnd(2))		*/
  7    92 	sign_fun		initial("010010011"b),	/* opnd(1) <- sign(opnd(2))		*/
  7    93 	abs_fun		initial("010010100"b),	/* opnd(1) <- abs(opnd(2))		*/
  7    94 	trunc_fun		initial("010010101"b),	/* opnd(1) <- trunc(opnd(2))		*/
  7    95 	byte_fun		initial("010010110"b),	/* opnd(1) <- byte(opnd(2))		*/
  7    96 	rank_fun		initial("010010111"b),	/* opnd(1) <- rank(opnd(2))		*/
  7    97 	index_rev_fun	initial("010011000"b),	/* opnd(1) <- index(reverse(opnd(2)),reverse(opnd(3))) */
  7    98 	search_rev_fun	initial("010011001"b),	/* opnd(1) <- search(reverse(opnd(2)),opnd(3)) */
  7    99 	verify_rev_fun	initial("010011010"b),	/* opnd(1) <- verify(reverse(opnd(2)),opnd(3)) */
  7   100 	wordno_fun	initial("010011011"b),        /* opnd(1) <- wordno (opnd(2)) */
  7   101 	segno_fun		initial("010011100"b),        /* opnd(1) <- segno (opnd(2)) */
  7   102 	bitno_fun           initial("010011101"b),        /* opnd(1) <- bitno (opnd(2)) */
  7   103 	charno_fun	initial("010011110"b),        /* opnd(1) <- charno (opnd(2)) */
  7   104 
  7   105 	index_fun		initial("01nterrupt: I/O error.¿ ¿B22        tapa,ÄÄ 0 c¿çò Ä        T    )£  T˙&¡∑& @p @      mos_memory_check: EDAC error on mem b store a.      æ           T    )§  T˙&¡ºQ @p @      mos_memory_check: EDAC error on mem b store b.      ^           T    )•  T˙&¡øi @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^      Ä    h    )¶  T˙'≤˝ @  @      ioi_masked$interrupt: I/O error.¿ ¡B22     Z   tapa*ÄÄ  c¿çò Ä   Ä    h    )ß  T˙'	8	 @  @      ioi_masked$interrupt: I/O error.¿ & B22     Z   tapa"ÄÄ  c¿çò Ä   Ä    h    )®  T˙(I;ï @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapa*ÄÄ  c¿çò Ä        T    )©  T˙)9V… @p @      mos_memory_check: EDAC error on mem b store a.      æ           T    )™  T˙)9[c @p @      mos_memory_check: EDAC error on mem b store b.      ^           T    )´  T˙)9_` @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^           T    )¨  T˙+≤=l @p @      mos_memory_check: EDAC error on mem b store a..     æ           T    )≠  T˙+≤Bæ @p @      mos_memory_check: EDAC error on mem b store b..     ^           T    )Æ  T˙+≤Eª @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^      ¿    P    )Ø  T˙,Ø. @  @      ioi_masked$interrupt: I/O error.¿ ¬B22        tapa Ä    h    )∞  T˙,Z∫ @  @      ioi_masked$interrupt: I/O error.¿ ¿B22        tapa@ÇÄÄ0 c¿çò êÄ   ¿    P    )±  T˙,|A @  @      ioi_masked$interrupt: I/O error.¿ &¿B22        tapa ¿    P   
 )≤  T˙,ŒT @  @      ioi_masked$interrupt: I/O error.¿ …B22        tapa ¿    P    )≥  T˙,ˇ¢ @  @      ioi_masked$interrupt: I/O error.¿ -¿B22        tapa ¿    P    )¥  T˙,?∏ @  @      ioi_masked$interrupt: I/O error.¿ ¿B22        tapa ¿    P    )µ  T˙,¯ì @  @      ioi_masked$interrupt: I/O error.¿ -B22        tapa ¿    L    )∂  T˙,˝˚  h  @      RCP: Detached tapa_00 from Backup.SysDaemon.z        Ä    D    )∑  T˙,√‰  @  @      RCP: Errors (tapa_00, volume COM235) = 8     ¿    L    )∏  T˙,Ks  x  @      RCP: Unassigned tapa_00 from Backup.SysDaemon.z      Ä    H    )π  T˙,j£  X  @      RCP: Assigned tapa_01 to Backup.SysDaemon.zo Ä    H    )∫  T˙,é  `  @      RCP: Attached tapa_01 for Backup.SysDaemon.z Ä    H    )ª  T˙,!»ÿ  H  @      RCP: Note (tapa_01) - COM236,den=6250,sysn.z      T    )º  T˙,$aE  ¿  @      RCP: Using Reel COM236 on tapa_01 for Backup.SysDaemon.z     ¿    P    )Ω  T˙,'‡ @  @      ioi_masked$interrupt: I/O error.¿0¿B22     (  tapa ¿    P    )æ  T˙,';Á @  @      ioi_masked$interrupt: I/O error.¿1¿B22     (  tapa ¿    P    )ø  T˙,(z @  @      ioi_masked$interrupt: I/O error.¿4¿B22     (B  tapa ¿    P    )¿  T˙,IXñ @  @      ioi_masked$interrupt: I/O error.¿¿B22     Q  tapa Ä    h    )¡  T˙-IZ√ @  @      ioi_masked$interrupt: I/O error.¿¿B22     Z   tapa*Ä   c¡≈ò Ä        T    )¬  T˙-*\ @p @      mos_memory_check: EDAC error on mem b store a.      æ           T    )√  T˙-*"B @p @      mos_memory_check: EDAC error on mem b store b.      ^           T    )ƒ  T˙-*%] @x @      mos_memory_check: EDAC error on mem b store b1.     Ñ>      Ä    h    )≈  T˙-I\Ù @  @      ioi_masked$interrupt: I/O error.¿¿B22        tapa Ä Ä0 c¡≈ò êÄ   ¿    L    )∆  T˙/Ñ∆Ù  Ä  @      RCP: Unloading volume COM235 from device tapa_00     @    `    )«  T˙/àw[    @      RCP: Preload volume COM237 on device tapa_00 for Backup.SysDaemon.z. Ä    h    )»  T˙/âqn @  @      ioi_masked$interrupt: I/O error.¿¿B22     Z   tapa*Ä   c¡≈ò Ä        T    )…  T˙/¢˝- @p @      mos_memory_check: EDAC error on mem b store a.      æ           T    )   T˙/£1 @p @      mos_memory_check: EDAC error on mem b store b.      ^           T    )À  T˙/£Ç @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^      Ä    h    )Ã  T˙0	wp @  @      ioi_masked$interrupt: I/O error.¿¿B22     Z   tapa*Ä   c¡≈ò Ä        T    )Œ  T˙2„C @p @      mos_memory_check: EDAC error on mem b store a.      æ           T    )œ  T˙2Ë @p @      mos_memory_check: EDAC error on mem b store b.      ^           T    )–  T˙2Î> @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^      Ä    h    )—  T˙2∏• @  @      ioi_masked$interrupt: I/O error.¿¿B22        tapa Ä Ä0 c¡≈ò êÄ   ¿    P    )“  T˙2Ñ @  @      ioi_masked$interrupt: I/O error.¿&¿B22        tapa ¿    P    )”  T˙2H> @  @      ioi_masked$interrupt: I/O error.¿ÕB22        tapa ¿    P    )‘  T˙2~_ @  @      ioi_masked$interrupt: I/O error.¿-¿B22        tapa ¿    P    )’  T˙2÷§ @  @      ioi_masked$interrupt: I/O error.¿¿B22        tapa ¿    P    )÷  T˙2DL @  @      ioi_masked$interrupt: I/O error.¿-B22        tapa ¿    L    )◊  T˙2I8  h  @      RCP: Detached tapa_01 from Backup.SysDaemon.z        Ä    D    )ÿ  T˙2¨  @  @      RCP: Errors (tapa_01, volume COM236) = 6     ¿    L    )Ÿ  T˙2ôo  x  @      RCP: Unassigned tapa_01 from Backup.SysDaemon.z      Ä    H    )⁄  T˙2ö¿¥  X  @      RCP: Assigned tapa_00 to Backup.SysDaemon.zo Ä    H    )€  T˙2õ;  `  @      RCP: Attached tapa_00 for Backup.SysDaemon.z Ä    H    )‹  T˙2û   H  @      RCP: Note (tapa_00) - COM238,den=6250,sysn.z @    `    )›  T˙2°Û. ¡  @      RCP: Mount Reel COM238 with ring on tapa_00 for Backup.SysDaemon.z   ¿    P    )ﬁ  T˙3îÖ @  @      ioi_masked$interrupt: I/O error.¿ 0¿B22     (  tapa ¿    P    )ﬂ  T˙3î3Ì @  @      ioi_masked$interrupt: I/O error.¿ 1¿B22     (  tapa ¿    P    )‡  T˙3ïÿƒ @  @      ioi_masked$interrupt: I/O error.¿ 4¿B22     (B  tapa ¿    P    )·  T˙3ú˙Ù @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Q  tapa Ä    h    )‚  T˙3ââó @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapabÄÄ  c¿çò¯ Ä        T    )‰  T˙4ì» @p @      mos_memory_check: EDAC error on mem b store a.      æ           T    )Â  T˙4ìÃ @p @      mos_memory_check: EDAC error on mem b store b.      ^           T    )Ê  T˙4ì–W @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^      Ä    h    )Á  T˙4“? @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapa*ÄÄ  c¿çò Ä   Ä    h    )Ï  T˙4≠úS @  @      ioi_masked$interrupt: I/O error.¿ &¿B22     Z   tapa*ÄÄ  c¿çò Ä   Ä    h    )Ì  T˙5…ë% @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapa¶ÄÄ 0 c¿çò Ä   Ä    h    )Ó  T˙5…îç @  @      ioi_masked$interrupt: I/O error.ﬁ  B22     Z   tapa*ÄÄ  c¿çò Ä   Ä    h    )Ô  T˙6…ñ¸ @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapa.ÄÄ 0 c¿çò Ä        T    )  T˙6≠ã @p @      mos_memory_check: EDAC error on mem b store a.      æ           T    )Ò  T˙6≤› @p @      mos_memory_check: EDAC error on mem b store b.      ^           T    )Ú  T˙6∂ @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^      Ä    h    )Û  T˙7	ôí @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapa*ÄÄ  c¿çò Ä        T    )¯  T˙8Ñé# @p @      mos_memory_check: EDAC error on mem b store a.      æ           T    )˘  T˙8Ñì @p @      mos_memory_check: EDAC error on mem b store b.      ^      Ä    h    )˙  T˙8Ñõ& @  @      ioi_masked$interrupt: I/O error.ﬁ  B22     Z   tapa2ÄÄ  c¿çò Ä   Ä    h    )˚  T˙9	ØX @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapa2ÄÄ  c¿çò Ä        T    )˝  T˙:˝j© @p @      mos_memory_check: EDAC error on mem b store a.      g~           T    )˛  T˙:˝o‚ @p @      mos_memory_check: EDAC error on mem b store b.      ^           T    )ˇ  T˙:˝s @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^      Ä    h    )   T˙;ÛHi @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapaVÄÄÄ0 c¿çò êÄ   ¿    P    )  T˙;Û›8 @  @      ioi_masked$interrupt: I/O error.¿ &¿B22        tapa ¿    P    )  T˙;Ù=´ @  @      ioi_masked$interrupt: I/O error.¿ ¬  7   226 	assign_by_name	initial("100101000"b),	/* opnd(1) <- opnd(2),by name		*/
  7   227 
  7   228 /* These operators are produced by the semantic translator in processing the math
  7   229*   builtin functions and are used as input to the code generator			*/
  7   230 
  7   231 	sqrt_fun		initial("100110000"b),	/* opnd(1) <- sqrt(opnd(2))	*/
  7   232 	sin_fun		initial("100110001"b),	/* opnd(1) <- sin(opnd(2))	*/
  7   233 	sind_fun		initial("100110010"b),	/* opnd(1) <- sind(opnd(2))	*/
  7   234 	cos_fun		initial("100110011"b),	/* opnd(1) <- cos(opnd(2))	*/
  7   235 	cosd_fun		initial("100110100"b),	/* opnd(1) <- cosd(opnd(2))	*/
  7   236 	tan_fun		initial("100110101"b),	/* opnd(1) <- tan(opnd(2))	*/
  7   237 	tand_fun		initial("100110110"b),	/* opnd(1) <- tand(opnd(2))	*/
  7   238 	asin_fun		initial("100110111"b),	/* opnd(1) <- asin(opnd(2))	*/
  7   239 	asind_fun		initial("100111000"b),	/* opnd(1) <- asind(opnd(2))	*/
  7   240 	acos_fun		initial("100111001"b),	/* opnd(1) <- acos(opnd(2))	*/
  7   241 	acosd_fun		initial("100111010"b),	/* opnd(1) <- acosd(opnd(2))	*/
  7   242 	atan_fun		initial("100111011"b),	/* opnd(1) <- atan(opnd(2)[,opnd(3)])	*/
  7   243 	atand_fun		initial("100111100"b),	/* opnd(1) <- atand(opnd(2)[,opnd(3)])	*/
  7   244 	log2_fun		initial("100111101"b),	/* opnd(1) <- log2(opnd(2))	*/
  7   245 	log_fun		initial("100111110"b),	/* opnd(1) <- log(opnd(2))	*/
  7   246 	log10_fun		initial("100111111"b),	/* opnd(1) <- log10(opnd(2))	*/
  7   247 
  7   248 	exp_fun		initial("101000000"b))	/* opnd(1) <- exp(opnd(2))	*/
  7   249 
  7   250 			bit(9) aligned internal static options(constant);
  7   251 
  7   252 /* END INCLUDE FILE ... op_codes.incl.pl1 */
       94 
  8     1 /* BEGIN INCLUDE FILE ... cgsystem.incl.pl1 */
  8     2 
  8     3 /* Modified: 25 Apr 1979 by PCK to implement 4-bit decimal */
  8     4 
  8     5 dcl (	bits_per_char		init(9),
  8     6 	bits_per_half		init(18),
  8     7 	bits_per_word		init(36),
  8     8 	bits_per_two_words		init(72),
  8     9 	bits_per_four_words		init(144),
  8    10 	bits_per_words(2)		init(36,72),
  8    11 	packed_digits_per_char	init(2),
  8    12 	chars_per_word		init(4),
  8    13 	packed_digits_per_word	init(8),
  8    14 
  8    15 	break_even_bits		init(216),
  8    16 	break_even_words		init(6),
  8    17 
  8    18 	label_size		init(4),
  8    19 
  8    20 	convert_size(13:14)		init(9,1),
  8    21 	max_offset(13:14)		init(27,35),
  8    22 	max_short_size(13:14)	init(8,72),
  8    23 
  8    24 	units_per_word(0:5)		init(1,36,8,4,2,1),
  8    25 
  8    26 	max_dec_scale		init(32),
  8    27 	min_dec_scale		init(-31),
  8    28 	max_p_xreg		init(18),
  8    29 	max_p_fix_bin_1		init(35),
  8    30 	max_p_flt_bin_1		init(27),
  8    31 	max_p_fix_dec		init(59),
  8    32 	max_length_p		init(24),
  8    33 	default_fix_bin_p		init(17)) fixed bin(8) int static options(constant);
  8    34 
  8    35 dcl      (convert_offset(0:5)		init(36,1,4.5,9,18,36),
  8    36 	bits_per_packed_digit	init(4.5)) fixed bin(8,1) int static options(constant);
  8    37 
  8    38 dcl	max_index_register_value	init(262143) fixed bin(31) int static options(constant);
  8    39 
  8    40 /* END INCLUDE FILE ... cgsystem.incl.pl1 */
  8    41 
       95 
  9     1 /* BEGIN INCLUDE FILE ... boundary.incl.pl1 */
  9     2 
  9     3 /* Modified: 26 Apr 1979 by PCK to implement 4-bit decimal */
  9     4 
  9     5 dcl (	bit_		init(1),
  9     6 	digit_		init(2),
  9     7 	character_	init(3),
  9     8 	half_		init(4),
  9     9 	word_		init(5),
  9    10 	mod2_		init(6),
  9    11 	mod4_		init(7)) fixed bin(3) int static options(constant);
  9    12 
  9    13 /* END INCLUDE FILE ... boundary.incl.pl1 */
       96 
       97 
       98 	adjust = "0"b;
       99 
      100 	p = pt;
      101 
      102 	pd = prepare_operand((p -> operand(1)),-1,atomic);
      103 	ps = prepare_operand((p -> operand(2)),-1,atomic);
      104 
      105 	have_constant_length = "0"b;
      106 	q = p -> operand(3);
      107 	if q -> node.type ^= operator_node
      108 	then if q -> reference.symbol -> symbol.constant
      109 	     then do;
      110 		have_constant_length = "1"b;
      111 		amount = q -> reference.symbol -> symbol.initial -> fix_bin;
      112 		end;
      113 
      114 	if p -> operator.op_code = copy_string
      115 	then do;
      116 
      117 	     /* we have copy_string, if the move cannot be done with
      118*	        words, go to str */
      119 
      120 	     if have_constant_length
      121 	     then if mod(amount,bits_per_word) = 0
      122 		 & ps -> reference.units = word_ & ^ ps -> reference.fo_in_qual
      123 		 & pd -> reference.units = word_ & ^ pd -> reference.fo_in_qual
      124 		then amount = divide(amount,bits_per_word,17,0);
      125 		else go to str;
      126 	     else go to str;
      127 	     end;
      128 
      129 	/* have copy words case */
      130 
      131 	if pd -> reference.temp_ref
      132 	     then pd -> reference.value_in.storage = "1"b;
      133 
      134 	if ps -> reference.varying_ref
      135 	then do;
      136 
      137 	     /* must adjust c_offset to move entire varying array */
      138 
      139 	     adjust = "1"b;
      140 	     ps -> reference.c_offset = ps -> reference.c_offset - 1;
      141 	     pd -> reference.c_offset = pd -> reference.c_offset - 1;
      142 	     end;
      143 
      144 	if have_constant_length
      145 	     then go to const;
      146 
      147 	/* have unknown amount of words to move */
      148 
      149 	case = 1;
      150 	call make_copy;
      151 
      152 	if adjust
      153 	     then call adjust_offset;
      154 
      155 	return;
      156 
      157 	/* have constant number of words to move, do it in-line using mlr instruction
      158*	   if more than 3 words (or word-pairs) have to be moved */
      159 
      160 const:	if amount > 6 then go to long;
      161 
      162 	call state_man$erase_reg((alters(fixed(amount > 1,1))));
      163 
      164 	call make_both_addressable(pd,ps,amount > 1);
      165 
      166 	do i = 1 to 2;
      167 	     if ^ arg(i) -> reference.even
      168 	     then do;
      169 		s = arg(i) -> reference.symbol;
      170 		if arg(i) -> reference.data_type > 0
      171 		then do;
      172 		     if substr(double_data,arg(i) -> reference.data_type,1)
      173 		     then if ^ s -> symbol.packed
      174 		     then arg(i) -> reference.even = "1"b;
      175 		     end;
      176 		else do;
      177 
      178 		     /* structure */
      179 
      180 		     if ^ arg(i) -> reference.array_ref & s -> symbol.array ^= null
      181 		     then if s -> symbol.array -> array.element_boundary > word_
      182 			then arg(i) -> reference.even = "1"b;
      183 			else;
      184 		     else if s -> symbol.boundary > word_
      185 			then arg(i) -> reference.even = "1"b;
      186 		     end;
      187 		end;
      188 	     end;
      189 
      190 	if amount <= 2
      191 	then do;
      192 	     if pd -> reference.temp_ref & ^ pd -> reference.aggregate
      193 	     then if pd -> reference.symbol -> symbol.decimal
      194 		 | pd -> reference.symbol -> symbol.complex	/* fixes 1820 & 1836 */
      195 		then pd -> reference.ref_count = pd -> reference.ref_count + 1;
      196 
      197 	     amount = amount - 1;
      198 	     call expmac$one((lda),ps,amount);
      199 	     call expmac$one((sta),pd,amount);
      200 	     goto done;
      201 	     end;
      202 
      203 	/* if an address is not known to be even, it may not necessarily be known
      204*	   to be odd, check to see if non-even addresses are really odd */
      205 
      206 	if ^ pd -> reference.even & ^ ps -> reference.even
      207 	 & (((pd -> address.base ^= sp & pd -> address.base ^= lp) | pd -> address.tag ^= "0"b)
      208 	  | ((ps -> address.base ^= sp & ps -> address.base ^= lp) | ps -> address.tag ^= "0"b))
      209 	then do;
      210 
      211 	     /* neither address is even and one is not known to be even or odd */
      212 
      213 	     if amount > 3 then goto long;
      214 
      215 	     macro = move_3;
      216 
      217 move:	     if pd -> reference.temp_ref & ^ pd -> reference.aggregate
      218 	     then if pd -> reference.long_ref
      219 		 | pd -> reference.symbol -> symbol.decimal
      220 		 | pd -> reference.symbol -> symbol.complex	/* fixes 1822 & 1836 */
      221 		then pd -> reference.ref_count = pd -> reference.ref_count + 1;
      222 
      223 	     call expmac$many(macro,addr(arg),2);
      224 done:	     pd -> reference.perm_address,
      225 	     ps -> reference.perm_address = "0"b;
      226 
      227 	     if adjust
      228 		then call adjust_offset;
      229 
      230 	     return;
      231 	     end;
      232 
      233 	/* either both addresses are known to be odd, or at least one address
      234*	   is known to be even, see if we have special sequence to move specified
      235*	   number of words */
      236 
      237 	if amount <= 6
      238 	then do;
      239 
      240 	     macro = table(fixed(pd -> reference.even,1),fixed(ps -> reference.even,1),amount);
      241 
      242 	     if macro ^= 0 then goto move;
      243 	     end;
      244 
      245 	/* we'll have to use an EIS instruction */
      246 
      247 /* Turn off perm address bits because we must make rands eis addressable */
      248 
      249 long:	pd -> reference.perm_address,
      250 	ps -> reference.perm_address = "0"b;
      251 
      252 /* Issue move macro */
      253 
      254 	n = chars_per_word * amount;
      255 issue_move_mac:
      256 	call long_op$two_eis(pd,n,(move_words),ps);
      257 
      258 	if adjust
      259 	     then call adjust_offset;
      260 
      261 	return;
      262 
      263 
      264 	/* have to do a string move */
      265 
      266 str:	q1 = pd;
      267 	q2 = ps;
      268 
      269 	if pd -> reference.temp_ref
      270 	     then pd -> reference.value_in.storage = "1"b;
      271 
      272 	if ps -> reference.symbol -> symbol.char
      273 	 | ps -> reference.symbol -> symbol.picture
      274 	 | ps -> reference.symbol -> symbol.decimal
      275 	then do;
      276 
      277 	     /* can use MLR for characters */
      278 
      279 	     q = p -> operand(3);
      280 
      281 	     /* q is in bits */
      282 
      283 	     if have_constant_length
      284 	     then do;
      285 		n = divide(amount,bits_per_char,17,0);
      286 		go to issue_move_mac;
      287 		end;
      288 
      289 	     case = 2;
      290 	     call make_copy;
      291 	     return;
      292 	     end;
      293 
      294 	p1 = p -> operand(3);
      295 	p1 = eval_exp(p1,"1"b);
      296 
      297 	p2 = q2 -> reference.length;
      298 	q2 -> reference.length = p1;
      299 
      300 	big_length_hold = q2 -> reference.big_length;
      301 	if p1 -> node.type = operator_node
      302 	     then p1 = p1 -> operand(1);
      303 	q2 -> reference.big_length = p1 -> reference.symbol -> symbol.c_dcl_size > max_p_xreg;
      304 
      305 	do i = 1 to 2;
      306 	     if arg(i) -> reference.units = character_
      307 	     then do;
      308 
      309 		/* since copy_bits is a CSL, we cannot allow character offset expr's */
      310 
      311 		if ^ arg(i) -> reference.shared
      312 		then arg(i) -> reference.ref_count = arg(i) -> reference.ref_count + 1;
      313 		base = base_man$load_any_var_and_lock(2,arg(i));
      314 		arg(i) -> reference.perm_address = "1"b;
      315 		end;
      316 	     end;
      317 
      318 	call expmac$two_eis((copy_bits),q1,q2);
      319 	q2 -> reference.length = p2;
      320 	q2 -> reference.big_length = big_length_hold;
      321 
      322 	q1 -> reference.perm_address,
      323 	q2 -> reference.perm_address = "0"b;
      324 
      325 	return;
      326 
      327 move_block: entry(dest,source,number);
      328 
      329 dcl	dest ptr,			/* points at ref of destination */
      330 	source ptr,		/* points at ref of source */
      331 	number fixed bin;		/* number of words to move */
      332 
      333 	pd = dest;
      334 	ps = source;
      335 	amount = number;
      336 
      337 	adjust = "0"b;
      338 
      339 	goto const;
      340 
      341 make_copy:     proc;
      342 
      343 	     /* does a copy_words or copy_string with an MLR instruction */
      344 
      345 	     /* first, load the length of the object to be moved */
      346 
      347 	     q = prepare_operand(q,1,atomic);
      348 	     if atomic then call load(q,0); else call compile_exp((p -> operand(3)));
      349 
      350 	     /* convert the length to characters */
      351 
      352 	     call expmac((conv_mac(case)),c_a((conv_factor(case)),case));
      353 
      354 	     /* finally, issue the copy macro (an MLR instruction) */
      355 
      356 	     call expmac$two_eis((copy_mac),pd,ps);
      357 
      358 	     end;
      359 
      360 
      361 adjust_offset:	proc;
      362 
      363 	     ps -> reference.c_offset = ps -> reference.c_offset + 1;
      364 	     pd -> reference.c_offset = pd -> reference.c_offset + 1;
      365 
      366 	     end;
      367 
      368 
      369 
      370 	end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/03/83  1009.0  move_data.pl1                     >spec>on>pl128d>move_data.pl1
88           1    07/21/80  1546.3  reference.incl.pl1                >ldd>include>reference.incl.pl1
89           2    10/02/83  0828.4  symbol.incl.pl1                   >spec>on>pl128d>symbol.incl.pl1
90           3    05/06/74  1741.6  array.incl.pl1                    >ldd>include>array.incl.pl1
91           4    07/21/80  1546.3  nodes.incl.pl1                    >ldd>include>nodes.incl.pl1
92           5    05/03/76  1320.8  bases.incl.pl1                    >ldd>include>bases.incl.pl1
93           6    07/21/80  1546.3  operator.incl.pl1                 >ldd>include>operator.incl.pl1
94           7    04/07/83  1635.0  op_codes.incl.pl1                 >ldd>include>op_codes.incl.pl1
95           8    10/25/79  1645.8  cgsystem.incl.pl1                 >ldd>include>cgsystem.incl.pl1
96           9    10/25/79  1645.8  boundary.incl.pl1                 >ldd>include>boundary.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
addr                                                   builtin function         dcl 43 ref 223 223
address                  10            based           structure                level 2 packed unaligned dcl 1-3
adjust                          000122 automatic       bit(1)                   dcl 35 set ref 98* 139* 152 227 258 337*
aggregate                12(19)        based           bit(1)                   level 3 packed unaligned dcl 1-3 ref 192 217
alters                          000034 constant        bit(19)                  initial array dcl 65 ref 162
amount                          000132 automatic       fixed bin(17,0)          dcl 35 set ref 111* 120 120* 120 160 162 164 190
                                                                                  197* 197 198* 199* 213 237 240 254 285 335*
arg                             000116 automatic       pointer                  array dcl 35 set ref 102* 102 103* 103 120 120 120
                                                                                  120 120 120 120 120 131 131 131 131 134 134 140
                                                                                  140 140 140 141 141 141 141 164 164 164 164 167
                                                                                  169 170 172 172 180 180 184 192 192 192 192 192
                                                                                  192 192 192 192 192 192 192 198 198 199 199 206
                                                                                  206 206 206 206 206 206 206 206 206 206 206 206
                                                                                  206 206 206 217 217 217 217 217 217 217 217 217
                                                                                  217 217 217 217 217 223 223 224 224 224 224 240
                                                                                  240 240 240 249 249 249 249 255 255 255 255 266
                                                                                  266 267 267 269 269 269 269 272 272 272 272 272
                                                                                  272 306 311 311 311 313* 314 333* 333 334* 334 356
                                                                                  356 356 356 363 363 363 363 364 364 364 364
array                                  based           structure                level 1 dcl 3-1 in procedure "move_data"
array                    12            based           pointer                  level 2 in structure "symbol" packed unaligned
                                                                                  dcl 2-3 in procedure "move_data" ref 180 180
array_ref                 0(09)        based           bit(1)                   level 2 packed unaligned dcl 1-3 ref 180
atomic                          000123 automatic       bit(1)                   dcl 35 set ref 102* 103* 347* 348
attributes               31            based           structure                level 2 dcl 2-3
base                     10            based           bit(3)                   level 3 in structure "reference" packed unaligned
                                                                                  dcl 1-3 in procedure "move_data" ref 206 206 206
                                                                                  206
base                            000126 automatic       bit(3)                   dcl 35 in procedure "move_data" set ref 313*
base_man$load_any_var_and_lock  000040 constant        entry                    external dcl 45 ref 313
bases                           000000 constant        bit(3)                   initial array dcl 5-1 ref 206 206 206 206 206 206
                                                                                  206 206
big_length               11(34)        based           bit(1)                   level 4 packed unaligned dcl 1-3 set ref 300 303*
                                                                                  320*
big_length_hold                 000124 automatic       bit(1)                   dcl 35 set ref 300* 320
bits                     12(06)        based           structure                level 2 packed unaligned dcl 1-3
bits_per_char                          constant        fixed bin(8,0)           initial dcl 8-5 ref 285
bits_per_word                   001221 constant        fixed bin(8,0)           initial dcl 8-5 ref 120 120
boundary                  2(20)        based           fixed bin(3,0)           level 2 packed unaligned dcl 2-3 ref 184
c_a                             000014 constant        entry                    external dcl 45 ref 352 352
c_dcl_size               30            based           fixed bin(24,0)          level 2 dcl 2-3 ref 303
c_offset                  1            based           fixed bin(24,0)          level 2 dcl 1-3 set ref 140* 140 141* 141 363* 363
                                                                                  364* 364
case                            000127 automatic       fixed bin(17,0)          dcl 35 set ref 149* 289* 352 352 352* 352 352*
char                     31(04)        based           bit(1)                   level 4 packed unaligned dcl 2-3 ref 272
character_                             constant        fixed bin(3,0)           initial dcl 9-5 ref 306
chars_per_word                         constant        fixed bin(8,0)           initial dcl 8-5 ref 254
compile_exp                     000026 constant        entry                    external dcl 45 ref 348
compiler_developed       32(35)        based           structure                level 3 packed unaligned dcl 2-3
complex                  31(31)        based           bit(1)                   level 4 packed unaligned dcl 2-3 ref 192 217
constant                 32(16)        based           bit(1)                   level 4 packed unaligned dcl 2-3 ref 107
conv_factor                     000010 constant        fixed bin(17,0)          initial array dcl 83 ref 352 352
conv_mac                        000032 constant        fixed bin(15,0)          initial array dcl 67 ref 352
copy_bits                              constant        fixed bin(15,0)          initial dcl 67 ref 318
copy_mac                               constant        fixed bin(15,0)          initial dcl 67 ref 356
copy_string                            constant        bit(9)                   initial dcl 7-8 ref 114
data_type                12            based           fixed bin(5,0)           level 2 in structure "reference" packed unaligned
                                                                                  dcl 1-3 in procedure "move_data" ref 170 172
data_type                31            based           structure                level 3 in structure "symbol" packed unaligned
                                                                                  dcl 2-3 in procedure "move_data"
decimal                  31(28)        based           bit(1)                   level 4 packed unaligned dcl 2-3 ref 192 217 272
dest                                   parameter       pointer                  dcl 329 ref 327 333
divide                                                 builtin function         dcl 43 ref 120 285
double_data                     000036 constant        bit(24)                  initial unaligned dcl 63 ref 172
element_boundary          1(23)        based           fixed bin(3,0)           level 2 packed unaligned dcl 3-1 ref 180
eval_exp                        000030 constant        entry                    external dcl 45 ref 295
even                     12(17)        based           bit(1)                   level 3 packed unaligned dcl 1-3 set ref 167 172*
                                                                                  180* 184* 206 206 240 240
expmac                          000036 constant        entry                    external dcl 45 ref 352
expmac$many                     000020 constant        entry                    external dcl 45 ref 223
expmac$one                      000022 constant        entry                    external dcl 45 ref 198 199
expmac$two_eis                  000034 constant        entry                    external dcl 45 ref 318 356
fix_bin                                based           fixed bin(17,0)          dcl 86 ref 111
fixed                                                  builtin function         dcl 43 ref 162 240 240
fo_in_qual               12(22)        based           bit(1)                   level 3 packed unaligned dcl 1-3 ref 120 120
have_constant_length            000125 automatic       bit(1)                   dcl 35 set ref 105* 110* 120 144 283
i                               000130 automatic       fixed bin(17,0)          dcl 35 set ref 166* 167 169 170 172 172 180 180 184*
                                                                                  305* 306 311 311 311 313 314*
info                     11            based           structure                level 2 packed unaligned dcl 1-3
initial                  11            based           pointer                  level 2 packed unaligned dcl 2-3 ref 111
lda                                    constant        fixed bin(15,0)          initial dcl 67 ref 198
length                    6            based           pointer                  level 2 packed unaligned dcl 1-3 set ref 297 298*
                                                                                  319*
load                            000024 constant        entry                    external dcl 45 ref 348
long_op$two_eis                 000032 constant        entry                    external dcl 45 ref 255
long_ref                 12(08)        based           bit(1)                   level 3 packed unaligned dcl 1-3 ref 217
lp                                     defined         bit(3)                   dcl 5-4 ref 206 206
macro                           000133 automatic       fixed bin(15,0)          dcl 35 set ref 215* 223* 240* 242
make_both_addressable           000016 constant        entry                    external dcl 45 ref 164
max_p_xreg                             constant        fixed bin(8,0)           initial dcl 8-5 ref 303
misc_attributes          31(19)        based           structure                level 3 packed unaligned dcl 2-3
mod                                                    builtin function         dcl 43 ref 120
move_3                                 constant        fixed bin(15,0)          initial dcl 67 ref 215
move_words                             constant        fixed bin(15,0)          initial dcl 67 ref 255
n                               000131 automatic       fixed bin(17,0)          dcl 35 set ref 254* 255* 285*
node                                   based           structure                level 1 dcl 4-27
null                                                   builtin function         dcl 43 ref 180
number                                 parameter       fixed bin(17,0)          dcl 329 ref 327 335
op_code                   0(09)        based           bit(9)                   level 2 packed unaligned dcl 6-6 ref 114
operand                   1            based           pointer                  array level 2 packed unaligned dcl 6-6 ref 102 103
                                                                                  106 279 294 301 348
operator                               based           structure                level 1 dcl 6-6
operator_node                          constant        bit(9)                   initial dcl 4-5 ref 107 301
other                    11(33)        based           structure                level 3 packed unaligned dcl 1-3
p                               000100 automatic       pointer                  dcl 35 set ref 100* 102 103 106 114 279 294 348
p1                              000110 automatic       pointer                  dcl 35 set ref 294* 295* 295* 298 301 301* 301 303
p2                              000112 automatic       pointer                  dcl 35 set ref 297* 319
packed                   33            based           bit(1)                   level 4 packed unaligned dcl 2-3 ref 172
pd                                     defined         pointer                  dcl 35 set ref 102* 120 120 131 131 141 141 164* 192
                                                                                  192 192 192 192 192 199* 206 206 206 206 217 217
                                                                                  217 217 217 217 217 224 240 249 255* 266 269 269
                                                                                  333* 356* 364 364
perm_address             12(18)        based           bit(1)                   level 3 packed unaligned dcl 1-3 set ref 224* 224*
                                                                                  249* 249* 314* 322* 322*
picture                  31(18)        based           bit(1)                   level 4 packed unaligned dcl 2-3 ref 272
prepare_operand                 000010 constant        entry                    external dcl 45 ref 102 103 347
ps                                     defined         pointer                  dcl 35 set ref 103* 120 120 134 140 140 164* 198*
                                                                                  206 206 206 206 224 240 249 255* 267 272 272 272
                                                                                  334* 356* 363 363
pt                                     parameter       pointer                  dcl 33 ref 31 100
q                               000102 automatic       pointer                  dcl 35 set ref 106* 107 107 111 279* 347* 347* 348*
q1                              000104 automatic       pointer                  dcl 35 set ref 266* 318* 322
q2                              000106 automatic       pointer                  dcl 35 set ref 267* 297 298 300 303 318* 319 320 322
ref_count                 0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 1-3 set ref 192* 192
                                                                                  217* 217 311* 311
reference                              based           structure                level 1 dcl 1-3
s                               000114 automatic       pointer                  dcl 35 set ref 169* 172 180 180 184
shared                    0(11)        based           bit(1)                   level 2 packed unaligned dcl 1-3 ref 311
source                                 parameter       pointer                  dcl 329 ref 327 334
sp                                     defined         bit(3)                   dcl 5-4 ref 206 206
sta                                    constant        fixed bin(15,0)          initial dcl 67 ref 199
state_man$erase_reg             000012 constant        entry                    external dcl 45 ref 162
storage                  11(23)        based           bit(1)                   level 4 packed unaligned dcl 1-3 set ref 131* 269*
storage_class            32(09)        based           structure                level 3 packed unaligned dcl 2-3
substr                                                 builtin function         dcl 43 ref 172
symbol                    3            based           pointer                  level 2 in structure "reference" packed unaligned
                                                                                  dcl 1-3 in procedure "move_data" ref 107 111 169
                                                                                  192 192 217 217 272 272 272 303
symbol                                 based           structure                level 1 dcl 2-3 in procedure "move_data"
table                           000012 constant        fixed bin(15,0)          initial array dcl 77 ref 240
tag                      10(30)        based           bit(6)                   level 3 packed unaligned dcl 1-3 ref 206 206
temp_ref                 12(11)        based           bit(1)                   level 3 packed unaligned dcl 1-3 ref 131 192 217 269
type                                   based           bit(9)                   level 2 packed unaligned dcl 4-27 ref 107 301
units                     0(14)        based           fixed bin(3,0)           level 2 packed unaligned dcl 1-3 ref 120 120 306
value_in                 11(09)        based           structure                level 3 packed unaligned dcl 1-3
varying_ref               0(10)        based           bit(1)                   level 2 packed unaligned dcl 1-3 ref 134
word_                                  constant        fixed bin(3,0)           initial dcl 9-5 ref 120 120 180 184

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
a_format                               internal static bit(9)                   initial dcl 7-8
ab                                     defined         bit(3)                   dcl 5-9
abs_fun                                internal static bit(9)                   initial dcl 7-8
acos_fun                               internal static bit(9)                   initial dcl 7-8
acosd_fun                              internal static bit(9)                   initial dcl 7-8
add                                    internal static bit(9)                   initial dcl 7-8
addbitno_fun                           internal static bit(9)                   initial dcl 7-8
addcharno_fun                          internal static bit(9)                   initial dcl 7-8
addr_fun                               internal static bit(9)                   initial dcl 7-8
addr_fun_bits                          internal static bit(9)                   initial dcl 7-8
addrel                                                 builtin function         dcl 43
addrel_fun                             internal static bit(9)                   initial dcl 7-8
adjust_ref_count                000000 constant        entry                    external dcl 45
allocation_fun                         internal static bit(9)                   initial dcl 7-8
allot_auto                             internal static bit(9)                   initial dcl 7-8
allot_based                            internal static bit(9)                   initial dcl 7-8
allot_ctl                              internal static bit(9)                   initial dcl 7-8
allot_var                              internal static bit(9)                   initial dcl 7-8
and_bits                               internal static bit(9)                   initial dcl 7-8
ap                                     defined         bit(3)                   dcl 5-4
array_node                             internal static bit(9)                   initial dcl 4-5
asin_fun                               internal static bit(9)                   initial dcl 7-8
asind_fun                              internal static bit(9)                   initial dcl 7-8
assign                                 internal static bit(9)                   initial dcl 7-8
assign_by_name                         internal static bit(9)                   initial dcl 7-8
assign_round                           internal static bit(9)                   initial dcl 7-8
assign_size_ck                         internal static bit(9)                   initial dcl 7-8
assign_zero                            internal static bit(9)                   initial dcl 7-8
atan_fun                               internal static bit(9)                   initial dcl 7-8
atand_fun                              internal static bit(9)                   initial dcl 7-8
b_format                               internal static bit(9)                   initial dcl 7-8
base_man$store_ptr_to           000000 constant        entry                    external dcl 45
baseno_fun                             internal static bit(9)                   initial dcl 7-8
baseptr_fun                            internal static bit(9)                   initial dcl 7-8
bb                                     defined         bit(3)                   dcl 5-9
bit                                                    builtin function         dcl 43
bit_                                   internal static fixed bin(3,0)           initial dcl 9-5
bit_pointer                            internal static bit(9)                   initial dcl 7-8
bit_to_char                            internal static bit(9)                   initial dcl 7-8
bit_to_word                            internal static bit(9)                   initial dcl 7-8
bitno_fun                              internal static bit(9)                   initial dcl 7-8
bits_per_four_words                    internal static fixed bin(8,0)           initial dcl 8-5
bits_per_half                          internal static fixed bin(8,0)           initial dcl 8-5
bits_per_packed_digit                  internal static fixed bin(8,1)           initial dcl 8-35
bits_per_two_words                     internal static fixed bin(8,0)           initial dcl 8-5
bits_per_words                         internal static fixed bin(8,0)           initial array dcl 8-5
block_node                             internal static bit(9)                   initial dcl 4-5
bn_format                              internal static bit(9)                   initial dcl 7-8
bool_fun                               internal static bit(9)                   initial dcl 7-8
bound                                  based           structure                level 1 dcl 3-21
bound_ck                               internal static bit(9)                   initial dcl 7-8
bound_node                             internal static bit(9)                   initial dcl 4-5
bp                                     defined         bit(3)                   dcl 5-4
break_even_bits                        internal static fixed bin(8,0)           initial dcl 8-5
break_even_words                       internal static fixed bin(8,0)           initial dcl 8-5
by_name_agg_node                       internal static bit(9)                   initial dcl 4-5
byte_fun                               internal static bit(9)                   initial dcl 7-8
c_format                               internal static bit(9)                   initial dcl 7-8
cat_string                             internal static bit(9)                   initial dcl 7-8
ceil_fun                               internal static bit(9)                   initial dcl 7-8
char_to_word                           internal static bit(9)                   initial dcl 7-8
charno_fun                             internal static bit(9)                   initial dcl 7-8
clock_fun                              internal static bit(9)                   initial dcl 7-8
close_file                             internal static bit(9)                   initial dcl 7-8
codeptr_fun                            internal static bit(9)                   initial dcl 7-8
column_format                          internal static bit(9)                   initial dcl 7-8
complex_fun                            internal static bit(9)                   initial dcl 7-8
conjg_fun                              internal static bit(9)                   initial dcl 7-8
context_node                           internal static bit(9)                   initial dcl 4-5
convert_offset                         internal static fixed bin(8,1)           initial array dcl 8-35
convert_size                           internal static fixed bin(8,0)           initial array dcl 8-5
copy_words                             internal static bit(9)                   initial dcl 7-8
cos_fun                                internal static bit(9)                   initial dcl 7-8
cosd_fun                               internal static bit(9)                   initial dcl 7-8
cross_reference_node                   internal static bit(9)                   initial dcl 4-5
default_fix_bin_p                      internal static fixed bin(8,0)           initial dcl 8-5
default_node                           internal static bit(9)                   initial dcl 4-5
delete_file                            internal static bit(9)                   initial dcl 7-8
desc_size                              internal static bit(9)                   initial dcl 7-8
digit_                                 internal static fixed bin(3,0)           initial dcl 9-5
digit_to_bit                           internal static bit(9)                   initial dcl 7-8
div                                    internal static bit(9)                   initial dcl 7-8
do_fun                                 internal static bit(9)                   initial dcl 7-8
do_spec                                internal static bit(9)                   initial dcl 7-8
e_format                               internal static bit(9)                   initial dcl 7-8
empty_area                             internal static bit(9)                   initial dcl 7-8
enable_on                              internal static bit(9)                   initial dcl 7-8
environmentptr_fun                     internal static bit(9)                   initial dcl 7-8
equal                                  internal static bit(9)                   initial dcl 7-8
ex_prologue                            internal static bit(9)                   initial dcl 7-8
exp                                    internal static bit(9)                   initial dcl 7-8
exp_fun                                internal static bit(9)                   initial dcl 7-8
expmac$zero                     000000 constant        entry                    external dcl 45
f_format                               internal static bit(9)                   initial dcl 7-8
floor_fun                              internal static bit(9)                   initial dcl 7-8
format_value_node                      internal static bit(9)                   initial dcl 4-5
fortran_read                           internal static bit(9)                   initial dcl 7-8
fortran_write                          internal static bit(9)                   iniB22        tapa Ä    h    )  T˙;ıÔ] @  @      ioi_masked$interrupt: I/O error.¿ ¿B22     Z   tapaVÇÄÄ0 c¿çò êÄ   ¿    P    )  T˙;ı8 @  @      ioi_masked$interrupt: I/O error.¿ &¿B22        tapa ¿    P    )  T˙;ˆ‚ @  @      ioi_masked$interrupt: I/O error.¿ ∆B22        tapa ¿    P    )  T˙;ˆP£ @  @      ioi_masked$interrupt: I/O error.¿ -¿B22        tapa ¿    P    )  T˙;ˆîÛ @  @      ioi_masked$interrupt: I/O error.¿ ¿B22        tapa ¿    P    )  T˙;ˆU @  @      ioi_masked$interrupt: I/O error.¿ -B22        tapa ¿    L    )	  T˙;ˆÖZ  h  @      RCP: Detached tapa_00 from Backup.SysDaemon.z        Ä    H    )
  T˙;˘P`  H  @      RCP: Errors (tapa_00, volume COM238) = 23on. ¿    L    )  T˙;¸”≠  x  @      RCP: Unassigned tapa_00 from Backup.SysDaemon.z      Ä    H    )  T˙;˛H÷  X  @      RCP: Assigned tapa_01 to Backup.SysDaemon.zo Ä    H    )  T˙;˛›W  `  @      RCP: Attached tapa_01 for Backup.SysDaemon.z Ä    H    )  T˙;ôã  H  @      RCP: Note (tapa_01) - COM239,den=6250,sysn.z @    `    )  T˙;,û ¡  @      RCP: Mount Reel COM239 with ring on tapa_01 for Backup.SysDaemon.z        T    )  T˙=uKœ @p @      mos_memory_check: EDAC error on mem b store a.r     g~           T    )  T˙=uP" @p @      mos_memory_check: EDAC error on mem b store b.r     ^           T    )  T˙=uS, @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^      Ä    d    )  T˙=õâõ ¡@  @      RCP: Check Mount of COM239 for writing on tapa_01 for Backup.SysDaemon.z     Ä    H    )  T˙=ü/b  H  @      RCP: Note (tapa_01) - COM239,den=6250,sys ta ¿    P    )  T˙=öí§ @  @      ioi_masked$interrupt: I/O error.¿0¿B22     (  tapa ¿    P    )  T˙=ö≥ó @  @      ioi_masked$interrupt: I/O error.¿1¿B22     (  tapa ¿    P    )  T˙=õfÁ @  @      ioi_masked$interrupt: I/O error.¿4¿B22     (B  tapa ¿    P    )  T˙=Ù @  @      ioi_masked$interrupt: I/O error.¿¿B22     Q  tapa ¿    L    )  T˙=˙j≤  Ä  @      RCP: Unloading volume COM238 from device tapa_00     @    `    )  T˙=˛∞î    @      RCP: Preload volume COM240 on device tapa_00 for Backup.SysDaemon.z. Ä    h    )  T˙>	”• @  @      ioi_masked$interrupt: I/O error.ﬂ B22     Z   tapaÄ   c¡≈ò Ä   Ä    h    )  T˙?	÷¸ @  @      ioi_masked$interrupt: I/O error.‰ÅÄB22     Z   tapa"Ä   c¡≈òÙ Ä        T    )  T˙?Ó/⁄ @p @      mos_memory_check: EDAC error on mem b store a.      g~           T    )  T˙?Ó4u @p @      mos_memory_check: EDAC error on mem b store b.      ^           T    )  T˙?Ó8ï @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^      Ä    h    )   T˙?	ÿ¡ @  @      ioi_masked$interrupt: I/O error.¿¿B22     Z   tapa2Ä   c¡≈òÙ Ä   Ä    h    )!  T˙@	‹] @  @      ioi_masked$interrupt: I/O error.’¡¿B22     Z   tapa*Ä   c¡≈òÙ Ä   Ä    h    )"  T˙@	ﬂú @  @      ioi_masked$interrupt: I/O error.‰ÅÄB22     Z   tapa*Ä   c¡≈òÙ Ä   Ä    h    )#  T˙A	¯d @  @      ioi_masked$interrupt: I/O error.’¡¿B22     Z   tapa*Ä   c¡≈òÙ Ä        T    )$  T˙Afå @p @      mos_memory_check: EDAC error on mem b store a.      g~           T    )%  T˙AfI @p @      mos_memory_check: EDAC error on mem b store b.      ^           T    )&  T˙Af£ @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^      Ä    h    )'  T˙AâG @  @      ioi_masked$interrupt: I/O error.¿ B22     Z   tapa*Ä   c¡≈òÙ Ä   Ä    h    )(  T˙A√ﬂ• @  @      ioi_masked$interrupt: I/O error.¿¿B22     Z   tapaéÄ  0 c¡≈òÙ Ä   Ä    h    )*  T˙B	%˙ @  @      ioi_masked$interrupt: I/O error.¿B22     Z   tapa*Ä   c¡≈òÙ Ä        T    ),  T˙Cﬁ˙\ @p @      mos_memory_check: EDAC error on mem b store a.      g~           T    )-  T˙Cﬁˇ @p @      mos_memory_check: EDAC error on mem b store b.      ^           T    ).  T˙Cﬂr @x @      mos_memory_check: EDAC error on mem b store b1.     ≈^      Ä    h    )/  T˙DÔÎu @  @               internal static bit(9)                   initial dcl 7-8
log10_fun                              internal static bit(9)                   initial dcl 7-8
log2_fun                               internal static bit(9)                   initial dcl 7-8
log_fun                                internal static bit(9)                   initial dcl 7-8
loop                                   internal static bit(9)                   initial dcl 7-8
machine_state_node                     internal static bit(9)                   initial dcl 4-5
make_desc                              internal static bit(9)                   initial dcl 7-8
max_dec_scale                          internal static fixed bin(8,0)           initial dcl 8-5
max_fun                                internal static bit(9)                   initial dcl 7-8
max_index_register_value               internal static fixed bin(31,0)          initial dcl 8-38
max_length_p                           internal static fixed bin(8,0)           initial dcl 8-5
max_number_of_operands                 internal static fixed bin(15,0)          initial dcl 6-15
max_offset                             internal static fixed bin(8,0)           initial array dcl 8-5
max_p_fix_bin_1                        internal static fixed bin(8,0)           initial dcl 8-5
max_p_fix_dec                          internal static fixed bin(8,0)           initial dcl 8-5
max_p_flt_bin_1                        internal static fixed bin(8,0)           initial dcl 8-5
max_short_size                         internal static fixed bin(8,0)           initial array dcl 8-5
min_dec_scale                          internal static fixed bin(8,0)           initial dcl 8-5
min_fun                                internal static bit(9)                   initial dcl 7-8
mod2_                                  internal static fixed bin(3,0)           initial dcl 9-5
mod4_                                  internal static fixed bin(3,0)           initial dcl 9-5
mod_bit                                internal static bit(9)                   initial dcl 7-8
mod_byte                               internal static bit(9)                   initial dcl 7-8
mod_fun                                internal static bit(9)                   initial dcl 7-8
mod_half                               internal static bit(9)                   initial dcl 7-8
mod_word                               internal static bit(9)                   initial dcl 7-8
mult                                   internal static bit(9)                   initial dcl 7-8
negate                                 internal static bit(9)                   initial dcl 7-8
nop                                    internal static bit(9)                   initial dcl 7-8
nop_mac                                internal static fixed bin(15,0)          initial dcl 67
not_bits                               internal static bit(9)                   initial dcl 7-8
not_equal                              internal static bit(9)                   initial dcl 7-8
off_fun                                internal static bit(9)                   initial dcl 7-8
open_file                              internal static bit(9)                   initial dcl 7-8
or_bits                                internal static bit(9)                   initial dcl 7-8
pack                                   internal static bit(9)                   initial dcl 7-8
packed_digits_per_char                 internal static fixed bin(8,0)           initial dcl 8-5
packed_digits_per_word                 internal static fixed bin(8,0)           initial dcl 8-5
page_format                            internal static bit(9)                   initial dcl 7-8
param_desc_ptr                         internal static bit(9)                   initial dcl 7-8
param_ptr                              internal static bit(9)                   initial dcl 7-8
picture_format                         internal static bit(9)                   initial dcl 7-8
pl1_mod_fun                            internal static bit(9)                   initial dcl 7-8
prefix_plus                            internal static bit(9)                   initial dcl 7-8
ptr_fun                                internal static bit(9)                   initial dcl 7-8
put_control                            internal static bit(9)                   initial dcl 7-8
put_data_trans                         internal static bit(9)                   initial dcl 7-8
put_edit_trans                         internal static bit(9)                   initial dcl 7-8
put_field                              internal static bit(9)                   initial dcl 7-8
put_field_chk                          internal static bit(9)                   initial dcl 7-8
put_file                               internal static bit(9)                   initial dcl 7-8
put_list_trans                         internal static bit(9)                   initial dcl 7-8
put_string                             internal static bit(9)                   initial dcl 7-8
r_format                               internal static bit(9)                   initial dcl 7-8
r_parn                                 internal static bit(9)                   initial dcl 7-8
range_ck                               internal static bit(9)                   initial dcl 7-8
rank_fun                               internal static bit(9)                   initial dcl 7-8
read_file                              internal static bit(9)                   initial dcl 7-8
real_fun                               internal static bit(9)                   initial dcl 7-8
record_io                              internal static bit(9)                   initial dcl 7-8
refer                                  internal static bit(9)                   initial dcl 7-8
reference_node                         internal static bit(9)                   initial dcl 4-5
rel_fun                                internal static bit(9)                   initial dcl 7-8
repeat_fun                             internal static bit(9)                   initial dcl 7-8
return_bits                            internal static bit(9)                   initial dcl 7-8
return_string                          internal static bit(9)                   initial dcl 7-8
return_value                           internal static bit(9)                   initial dcl 7-8
return_words                           internal static bit(9)                   initial dcl 7-8
reverse_fun                            internal static bit(9)                   initial dcl 7-8
revert_on                              internal static bit(9)                   initial dcl 7-8
rewrite_file                           internal static bit(9)                   initial dcl 7-8
round_fun                              internal static bit(9)                   initial dcl 7-8
sb                                     defined         bit(3)                   dcl 5-9
search_fun                             internal static bit(9)                   initial dcl 7-8
search_rev_fun                         internal static bit(9)                   initial dcl 7-8
segno_fun                              internal static bit(9)                   initial dcl 7-8
set_bits                               internal static fixed bin(15,0)          initial dcl 67
setbitno_fun                           internal static bit(9)                   initial dcl 7-8
setcharno_fun                          internal static bit(9)                   initial dcl 7-8
sf_par_node                            internal static bit(9)                   initial dcl 4-5
sign_fun                               internal static bit(9)                   initial dcl 7-8
signal_on                              internal static bit(9)                   initial dcl 7-8
sin_fun                                internal static bit(9)                   initial dcl 7-8
sind_fun                               internal static bit(9)                   initial dcl 7-8
skip_format                            internal static bit(9)                   initial dcl 7-8
source_node                            internal static bit(9)                   initial dcl 4-5
sp_ok                                  automatic       bit(1)                   dcl 35
sqrt_fun                               internal static bit(9)                   initial dcl 7-8
stack_ptr                              internal static bit(9)                   initial dcl 7-8
stackbaseptr_fun                       internal static bit(9)                   initial dcl 7-8
stackframeptr_fun                      internal static bit(9)                   initial dcl 7-8
stacq_fun                              internal static bit(9)                   initial dcl 7-8
statement_node                         internal static bit(9)                   initial dcl 4-5
std_arg_list                           internal static bit(9)                   initial dcl 7-8
std_call                               internal static bit(9)                   initial dcl 7-8
std_entry                              internal static bit(9)                   initial dcl 7-8
std_return                             internal static bit(9)                   initial dcl 7-8
stop                                   internal static bit(9)                   initial dcl 7-8
stream_prep                            internal static bit(9)                   initial dcl 7-8
sub                                    internal static bit(9)                   initial dcl 7-8
symbol_node                            internal static bit(9)                   initial dcl 4-5
tan_fun                                internal static bit(9)                   initial dcl 7-8
tand_fun                               internal static bit(9)                   initial dcl 7-8
temporary_node                         internal static bit(9)                   initial dcl 4-5
terminate_trans                        internal static bit(9)                   initial dcl 7-8
token_node                             internal static bit(9)                   initial dcl 4-5
translate_fun                          internal static bit(9)                   initial dcl 7-8
trunc_fun                              internal static bit(9)                   initial dcl 7-8
units_per_word                         internal static fixed bin(8,0)           initial array dcl 8-5
unlock_file                            internal static bit(9)                   initial dcl 7-8
unpack                                 internal static bit(9)                   initial dcl 7-8
vclock_fun                             internal static bit(9)                   initial dcl 7-8
verify_fun                             internal static bit(9)                   initial dcl 7-8
verify_ltrim_fun                       internal static bit(9)                   initial dcl 7-8
verify_rev_fun                         internal static bit(9)                   initial dcl 7-8
verify_rtrim_fun                       internal static bit(9)                   initial dcl 7-8
which_base                             internal static fixed bin(17,0)          initial array dcl 5-14
word_to_mod2                           internal static bit(9)                   initial dcl 7-8
word_to_mod4                           internal static bit(9)                   initial dcl 7-8
word_to_mod8                           internal static bit(9)                   initial dcl 7-8
wordno_fun                             internal static bit(9)                   initial dcl 7-8
write_file                             internal static bit(9)                   initial dcl 7-8
x_format                               internal static bit(9)                   initial dcl 7-8
xor_bits                               internal static bit(9)                   initial dcl 7-8

NAMES DECLARED BY EXPLICIT CONTEXT.
adjust_offset                   001210 constant        entry                    internal dcl 361 ref 152 227 258
const                           000237 constant        label                    dcl 160 ref 144 339
done                            000556 constant        label                    dcl 224 ref 200
issue_move_mac                  000616 constant        label                    dcl 255 ref 286
long                            000606 constant        label                    dcl 249 ref 160 213
make_copy                       001071 constant        entry                    internal dcl 341 ref 150 290
move                            000513 constant        label                    dcl 217 ref 242
move_block                      001051 constant        entry                    external dcl 327
move_data                       000047 constant        entry                    external dcl 31
str                             000641 constant        label                    dcl 266 ref 120 120

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1376        1440    1222        1406
Length      2004    1222        42         327     154           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
move_data                           134 external procedure  is an external procedure.  
make_copy                               internal procedure  shares stack frame of external procedure move_data.  
adjust_offset                           internal procedure  shares stack frame of external procedure move_data.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
move_data                000100 p                           move_data
                         000102 q                           move_data
                         000104 q1                          move_data
                         000106 q2                          move_data
                         000110 p1                          move_data
                         000112 p2                          move_data
                         000114 s                           move_data
                         000116 arg                         move_data
                         000122 adjust                      move_data
                         000123 atomic                      move_data
                         000124 big_length_hold             move_data
                         000125 have_constant_length        move_data
                         000126 base                        move_data
                         000127 case                        move_data
                         000130 i                           move_data
                         000131 n                           move_data
                         000132 amount                      move_data
                         000133 macro                       move_data

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               call_ext_out        return              mod_fx1             ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
base_man$load_any_var_and_lock                              c_a                           compile_exp
eval_exp                      expmac                        expmac$many                   expmac$one
expmac$two_eis                load                          long_op$two_eis               make_both_addressable
prepare_operand               state_man$erase_reg

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     31 000044        98 000054       100 000055       102 000061       103 000101       105 000123       106 000124
    107 000127       110 000141       111 000143       114 000146       120 000153       131 000206       134 000214
    139 000217       140 000221       141 000224       144 000226       149 000230       150 000232       152 000233
    155 000236       160 000237       162 000242       164 000256       166 000275       167 000303       169 000311
    170 000313       172 000317       175 000331       180 000332       183 000350       184 000351       188 000360
    190 000362       192 000365       197 000405       198 000407       199 000424       200 000441       206 000442
    213 000506       215 000511       217 000513       223 000537       224 000556       227 000563       230 000566
    237 000567       240 000572       242 000605       249 000606       254 000613       255 000616       258 000635
    261 000640       266 000641       267 000643       269 000645       272 000652       283 000656       285 000660
    286 000663       289 000664       290 000666       291 000667       294 000670       295 000673       297 000710
    298 000713       300 000716       301 000722       303 000730       305 000741       306 000747       311 000756
    313 000770       314 001005       316 001011       318 001013       319 001030       320 001033       322 001040
    325 001044       327 001045       333 001056       334 001062       335 001065       337 001067       339 001070
    341 001071       347 001072       348 001111       348 001127       352 001141       356 001172       358 001207
    361 001210       363 001211       364 001213       366 001215


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
