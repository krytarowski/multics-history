	COMPILATION LISTING OF SEGMENT ms_salvager_v3_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 05/09/85  1115.1 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 ms_salvager_v3_: proc (a_mptr, a_code);
       12 
       13 /* Modified for version 3 message segments by J. Stern, 10/30/74 */
       14 /* Modified to use mseg_error_ by J. Stern, 11/12/75 */
       15 /* Modified 3/77 by Charlie Davis for the installation of version 4 message segments */
       16 
       17 dcl (
       18      mseg_dir,					/* mseg directory name */
       19      comp1)					/* 1st component of directory name */
       20      char (168) aligned;
       21 
       22 dcl (
       23      mseg_name,					/* mseg entryname */
       24      comp2)					/* 2nd component of directory name */
       25      char (32) aligned;
       26 
       27 dcl (
       28      i,						/* do loop index */
       29      dir_len,					/* length of mseg directory */
       30      saved_blocks init (0),				/* number of saved message blocks */
       31      saved_messages init (0),				/* number of saved messages (internal) */
       32      original_messages,				/* number of messages before salvaging */
       33      tsaved_blocks,					/* number of saved blocks per pass */
       34      tsaved_messages)				/* number of saved messages per pass */
       35      fixed bin;
       36 
       37 dcl (alloc_len,					/* length of allocation bit string */
       38      block_offset,					/* offset to a message block */
       39      block_size,					/* size of message block */
       40      hdr_alloc_len,					/* number of allocation bits used for header */
       41      mseg_data_v3_$block_size ext,
       42      seg_size,					/* maximum size of a segment */
       43      hdr_size,					/* number of words in header before alloc_bits */
       44      trailer_offset) fixed bin (18);
       45 
       46 dcl (
       47      a_code,					/* error code (argument) */
       48      code,					/* error code, (internal) */
       49      error_table_$fatal_error ext
       50      ) fixed bin (35);
       51 
       52 dcl  reason char (40);				/* reason for salvager failure */
       53 
       54 dcl  forward bit (1) aligned;				/* ON if salvage is forward */
       55 
       56 dcl (addr, addrel, bit, divide, fixed, null, ptr, rel, size, substr) builtin;
       57 
       58 dcl (a_mptr,					/* pointer to message segment (argument) */
       59      end_ptr,					/* pointer to last message for salvage pass */
       60      last_backward_ptr init (null),			/* pointer to last saved message in backward salvage */
       61      last_forward_ptr init (null),			/* pointer to last saved message in forward salvage */
       62      last_saved_ms_ptr,				/* pointer to last message saved in a pass */
       63      salv_ptr)					/* pointer to beginning point for salvage */
       64      ptr;
       65 
       66 dcl  mseg_access_class bit (72) aligned;		/* message segment access class */
       67 
       68 dcl  hdr_ms_mask bit (36*max_hdr_ms_len) aligned based;	/* for zeroing out header message */
       69 
       70 dcl  ring_brackets (3) fixed bin(3) init(1,4,4);		/* for setting ring brackets of copy */
       71 
       72 dcl 1 new_hash_table aligned,				/* hash table regenerated by salvage */
       73     2 last_in_bucket (0:511) bit (18) unaligned init ((512) (18) "0"b);
       74 
       75 /*  */
       76 
  1     1 /* BEGIN include file mseg_hdr_v3.incl.pl1 */
  1     2 
  1     3 dcl  mptr ptr,					/* pointer to message segment */
  1     4 
  1     5      1 mseg_hdr aligned based (mptr),			/* message segment header format */
  1     6      2 lock bit (36) aligned,				/* standard file system lock */
  1     7      2 mseg_pattern bit (36) aligned,			/* to identify message segments */
  1     8      2 hdr_ms_access_class bit (72) aligned,		/* access class of header message */
  1     9      2 pad (4) fixed bin,
  1    10      2 first_ms_offset bit (18) aligned,		/* offset to first logical message */
  1    11      2 last_ms_offset bit (18) aligned,			/* offset to last logical message */
  1    12      2 alloc_len fixed bin,				/* length of allocation bit string */
  1    13      2 space_left fixed bin,				/* number of empty blocks */
  1    14      2 number_of_messages fixed bin,			/* number of messages in segment */
  1    15      2 block_size fixed bin,				/* message block size */
  1    16      2 switches,
  1    17      3 mip bit (1) unaligned,				/* ON if modification is in progress */
  1    18      3 os bit (1) unaligned,				/* ON if message segment was salvaged */
  1    19      3 ms_in_hdr bit (1) unaligned,			/* ON if there is a message in the header */
  1    20      3 sip bit (1) unaligned,				/* ON if salvage is in progress */
  1    21      3 pad2 bit (32) unaligned,
  1    22      2 version_number fixed bin,
  1    23      2 hdr_ms bit (64 * 36) aligned,			/* space for header message */
  1    24      2 hash_table aligned,				/* message ID hash table */
  1    25      3 last_in_bucket (0:511) bit (18) unaligned,		/* offset of last message in this hash table bucket */
  1    26      2 alloc_bits bit (alloc_len) aligned;		/* allocation bit string */
  1    27 
  1    28 dcl (version_number fixed bin init (3),			/* message segment version number */
  1    29      header_pattern bit (36) aligned init ((18) "01"b))	/* header identification pattern */
  1    30      internal static;
  1    31 
  1    32 /* END include file mseg_hdr_v3.incl.pl1 */
       77 
       78 
       79 
  2     1 /* BEGIN include file ms_block_trailer_v3.incl.pl1 */
  2     2 
  2     3 dcl  tr_ptr ptr,					/* pointer to message block trailer area */
  2     4 
  2     5      1 ms_block_trailer aligned based (tr_ptr),		/* message block trailer structure */
  2     6      2 tr_pattern bit (36) aligned,			/* for identifying beginning of trailer */
  2     7      2 f_offset bit (18) unaligned,			/* offset to next logical message */
  2     8      2 b_offset bit (18) unaligned,			/* offset to previous logical message */
  2     9      2 ms_size bit (18) unaligned,			/* bit count of message */
  2    10      2 back_in_bucket bit (18) unaligned,		/* offset of preceding message in same hash bucket */
  2    11      2 ms_id bit (72) aligned,			/* message id */
  2    12      2 ring_no bit (18) unaligned,			/* validation level */
  2    13      2 pad bit (18) unaligned,
  2    14      2 sender_id char (32) aligned,			/* id of message sender */
  2    15      2 sender_authorization bit (72) aligned,		/* access authorization of message sender */
  2    16      2 access_class bit (72) aligned;			/* access class of this message */
  2    17 
  2    18 dcl  trailer_pattern bit (36) aligned init ((36) "1"b)	/* trailer identification pattern */
  2    19      internal static;
  2    20 
  2    21 /* END include file ms_block_trailer_v3.incl.pl1 */
       80 
       81 
       82 
       83 dcl  admin_gate_$guaranteed_eligibility_on ext entry;
       84 
       85 dcl  expand_path_ ext entry
       86     (ptr, fixed bin, ptr, ptr, fixed bin (35));
       87 
       88 dcl  copy_seg_$no_message ext entry
       89     (char (*)aligned, char (*)aligned, char (*)aligned, char (*)aligned,
       90      char (*)aligned, bit (1)aligned, fixed bin (35));
       91 
       92 dcl  hcs_$get_max_length_seg entry (ptr, fixed bin (18), fixed bin (35));
       93 
       94 dcl  hcs_$set_ring_brackets ext entry
       95     (char (*)aligned, char (*)aligned, (3) fixed bin (3), fixed bin (35));
       96 
       97 dcl  hcs_$truncate_seg ext entry
       98     (ptr, fixed bin (18), fixed bin (35));
       99 
      100 dcl  read_allowed_ ext entry
      101     (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      102 
      103 dcl  hcs_$fs_get_path_name ext entry
      104     (ptr, char (*)aligned, fixed bin, char (*)aligned, fixed bin (35));
      105 
      106 dcl  hcs_$get_access_class_seg ext entry
      107     (ptr, bit (72) aligned, fixed bin (35));
      108 
      109 dcl  ms_salv_util_v3_ ext entry
      110     (bit (1) aligned, ptr, ptr, ptr, fixed bin (18), fixed bin (18), fixed bin (18), fixed bin (18),
      111      bit (72) aligned, fixed bin, fixed bin, ptr);
      112 
      113 dcl  mseg_error_v3_ entry options (variable);
      114 
      115 dcl  set_lock_$lock ext entry
      116     (bit (36)aligned, fixed bin, fixed bin (35));
      117 
      118 /*  */
      119 
      120 	mptr = a_mptr;				/* copy argument */
      121 
      122 	call admin_gate_$guaranteed_eligibility_on ();	/* lock the message segment in case */
      123 	call set_lock_$lock (mseg_hdr.lock, 20, code);	/* it is not already locked */
      124 
      125 	call hcs_$get_access_class_seg (mptr, mseg_access_class, code);
      126 	if code ^= 0 then do;
      127 	     reason = "Cannot get access class.";
      128 	     go to GRIPE;
      129 	end;
      130 
      131 	call hcs_$get_max_length_seg (mptr, seg_size, code);
      132 	if code ^= 0 then do;
      133 	     reason = "Cannot get max length.";
      134 	     go to GRIPE;
      135 	end;
      136 
      137 	mseg_hdr.switches.sip = "1"b;			/* turn on "salvage in progress" flag */
      138 
      139 	block_size = fixed (mseg_hdr.block_size, 18);	/* fetch block size */
      140 	if block_size <= 0 | block_size > seg_size
      141 	then block_size = fixed (mseg_data_v3_$block_size, 18); /* take default and hope it's right */
      142 
      143 	alloc_len = divide (seg_size, block_size, 18, 0); /* compute length of allocation bits */
      144 
      145 	hdr_size = divide ((fixed (rel (addr (mptr -> mseg_hdr.alloc_bits)), 18))*36 + alloc_len+35, 36, 18, 0);
      146 
      147 	if hdr_size > seg_size then do;		/* forget it */
      148 	     code = error_table_$fatal_error;
      149 	     go to FIN;
      150 	end;
      151 
      152 	hdr_alloc_len = divide (hdr_size+block_size-1, block_size, 18, 0); /* compute alloc bits used by header */
      153 
      154 	trailer_offset = fixed (block_size-size (ms_block_trailer), 18); /* compute trailer offset */
      155 
      156 	original_messages = mseg_hdr.number_of_messages;
      157 
      158 /*  */
      159 
      160 	begin;
      161 
      162 dcl  new_alloc_bits bit (alloc_len) init (""b) aligned;	/* new allocation bit string */
      163 
      164 	     do i = 1 to hdr_alloc_len;		/* turn on header allocation bits */
      165 		substr (new_alloc_bits, i, 1) = "1"b;
      166 	     end;
      167 
      168 	     if mseg_hdr.first_ms_offset ^= ""b		/* non-zero first message offset */
      169 	     then do;				/* set up for forward salvage */
      170 		salv_ptr = ptr (mptr, fixed (mseg_hdr.first_ms_offset, 18));
      171 		end_ptr = ptr (mptr, fixed (mseg_hdr.last_ms_offset, 18));
      172 		forward = "1"b;			/* first attempt forward salvage */
      173 	     end;
      174 	     else go to BACKWARD;			/* try backward salvage */
      175 
      176 /* salvage */
      177 
      178 SALVAGE_LOOP:
      179 
      180 	     tsaved_messages = 0;			/* initialize number of saved messages per pass */
      181 	     last_saved_ms_ptr = null;		/* initialize pointer to last saved message */
      182 	     call ms_salv_util_v3_
      183 		(forward, salv_ptr, addr (new_alloc_bits), addr (new_hash_table),
      184 		block_size, seg_size, alloc_len, hdr_alloc_len, mseg_access_class,
      185 		tsaved_messages, tsaved_blocks, last_saved_ms_ptr);
      186 	     saved_messages =			/* add in number of saved messages */
      187 		saved_messages + tsaved_messages;
      188 	     saved_blocks =				/* add in number of saved blocks */
      189 		saved_blocks + tsaved_blocks;
      190 	     if last_saved_ms_ptr = end_ptr		/* total success? */
      191 	     then go to REST_OF_HEADER;
      192 
      193 	     if tsaved_messages ^= 0			/* partial success? */
      194 	     then do;				/* yes */
      195 
      196 		if (forward)			/* forward salvage? */
      197 		then last_forward_ptr =		/* yes, save pointer to last good message */
      198 		     last_saved_ms_ptr;
      199 
      200 		else				/* backward salvage */
      201 		last_backward_ptr =			/* save pointer to last good message */
      202 		     last_saved_ms_ptr;
      203 
      204 	     end;
      205 
      206 	     if (forward)				/* first pass at salvaging? */
      207 	     then
      208 BACKWARD:		if mseg_hdr.last_ms_offset ^= ""b	/* non-zero last message offset */
      209 		then do;				/* yes, prepare for next pass */
      210 		     forward = "0"b;		/* set direction of salvage */
      211 		     salv_ptr = ptr (mptr, fixed (mseg_hdr.last_ms_offset, 18)); /* set salvaging pointer */
      212 		     end_ptr = ptr (mptr, fixed (mseg_hdr.first_ms_offset, 18)); /* set hopeful end of salvage ptr */
      213 		     go to SALVAGE_LOOP;
      214 		end;
      215 
      216 /*  */
      217 
      218 /* join message fragments */
      219 
      220 	     if saved_messages ^= 0			/* any success in salvaging? */
      221 	     then do;				/* yes */
      222 
      223 		if last_forward_ptr ^= null		/* forward salvage partly successful */
      224 		then do;				/* yes */
      225 
      226 		     if last_backward_ptr ^= null	/* backward salvage partly successful? */
      227 		     then do;			/* yes */
      228 			addrel (last_forward_ptr, trailer_offset) -> ms_block_trailer.f_offset =
      229 			     bit (fixed (rel (last_backward_ptr), 18), 18);
      230 			addrel (last_backward_ptr, trailer_offset) -> ms_block_trailer.b_offset =
      231 			     bit (fixed (rel (last_forward_ptr), 18), 18);
      232 		     end;
      233 
      234 		     else				/* backward salvage unsuccessful */
      235 		     do;
      236 			mseg_hdr.last_ms_offset =	/* reset last message offset in header */
      237 			     bit (fixed (rel (last_forward_ptr), 18), 18);
      238 			addrel (last_forward_ptr, trailer_offset) -> ms_block_trailer.f_offset =
      239 			     "0"b;		/* zero out next offset of new last message */
      240 		     end;
      241 
      242 		end;
      243 
      244 		else				/* forward salvage no good */
      245 		do;				/* backward salvage must have been */
      246 		     mseg_hdr.first_ms_offset =	/* reset first message offset */
      247 			bit (fixed (rel (last_backward_ptr), 18), 18);
      248 		     addrel (last_backward_ptr, trailer_offset) -> ms_block_trailer.b_offset =
      249 			"0"b;			/* zero prev message offset of new 1st message */
      250 		end;
      251 
      252 	     end;
      253 
      254 	     else					/* no messages saved */
      255 	     mseg_hdr.first_ms_offset,
      256 		mseg_hdr.last_ms_offset = (18) "0"b;	/* zero first and last offsets */
      257 
      258 REST_OF_HEADER:
      259 
      260 	     i = alloc_len - index (reverse (new_alloc_bits), "1"b) +1; /* get last used block index */
      261 	     block_offset = i * block_size;		/* get offset of end of last block */
      262 	     call hcs_$truncate_seg (mptr, block_offset, code); /* truncate to last used block */
      263 	     mseg_hdr.block_size = block_size;		/* reset block size */
      264 	     mseg_hdr.space_left =			/* reset space left */
      265 		alloc_len - hdr_alloc_len - saved_blocks;
      266 	     mseg_hdr.alloc_bits = new_alloc_bits;	/* reset allocation bit string */
      267 	     mseg_hdr.number_of_messages = saved_messages; /* set message count */
      268 	     mseg_hdr.alloc_len = alloc_len;		/* set allocation bits length */
      269 	     mseg_hdr.mseg_pattern = header_pattern;	/* set header pattern */
      270 	     mseg_hdr.version_number = version_number;	/* set version number */
      271 	     mseg_hdr.hash_table = new_hash_table;	/* copy new hash table */
      272 
      273 	     if mseg_hdr.switches.ms_in_hdr		/* header message exists */
      274 	     then if ^read_allowed_ (mseg_access_class, mseg_hdr.hdr_ms_access_class) /* bad access class */
      275 		then do;				/* wipe out header message */
      276 		     mseg_hdr.switches.ms_in_hdr = "0"b;
      277 ZERO_HDR_MS:	     mseg_hdr.hdr_ms = ""b;
      278 		     mseg_hdr.hdr_ms_access_class = (72) "0"b;
      279 		end;
      280 		else;				/* keep header message */
      281 	     else go to ZERO_HDR_MS;			/* just to be neat */
      282 
      283 	     mseg_hdr.switches.mip = "0"b;		/* turn off mip bit */
      284 	     mseg_hdr.switches.os = "1"b;		/* indicate salvage occurred */
      285 	     mseg_hdr.switches.sip = "0"b;		/* turn off salvage in progress bit */
      286 
      287 	end;					/* of BEGIN block */
      288 
      289 	if original_messages > saved_messages then
      290 	     call mseg_error_v3_ (mptr, 0, "ms_salvager_v3_", "^d message(s) may be lost.",
      291 	     original_messages - saved_messages);
      292 
      293 FIN:
      294 
      295 	a_code = code;				/* return code */
      296 	return;
      297 
      298 GRIPE:	call mseg_error_v3_ (mptr, code, "ms_salvager_v3_", reason);
      299 	go to FIN;
      300 
      301      end ms_salvager_v3_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/06/85  1619.0  ms_salvager_v3_.pl1               >spec>on>mseg>ms_salvager_v3_.pl1
77           1    05/06/85  1121.9  mseg_hdr_v3.incl.pl1              >spec>on>mseg>mseg_hdr_v3.incl.pl1
80           2    05/06/85  1121.7  ms_block_trailer_v3.incl.pl1      >spec>on>mseg>ms_block_trailer_v3.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_code                                 parameter       fixed bin(35,0)          dcl 46 set ref 11 293*
a_mptr                                 parameter       pointer                  dcl 58 ref 11 120
addr                                                   builtin function         dcl 56 ref 145 182 182 182 182
addrel                                                 builtin function         dcl 56 ref 228 230 238 248
admin_gate_$guaranteed_eligibility_on
                                000014 constant        entry                    external dcl 83 ref 122
alloc_bits              520            based           bit                      level 2 dcl 1-3 set ref 145 266*
alloc_len                       000106 automatic       fixed bin(18,0)          dcl 37 in procedure "ms_salvager_v3_" set ref 143*
                                                                                  145 145 162 182* 258 264 266 268
alloc_len                12            based           fixed bin(17,0)          level 2 in structure "mseg_hdr" dcl 1-3 in procedure
                                                                                  "ms_salvager_v3_" set ref 268*
b_offset                  1(18)        based           bit(18)                  level 2 packed unaligned dcl 2-3 set ref 230* 248*
bit                                                    builtin function         dcl 56 ref 228 230 236 246
block_offset                    000107 automatic       fixed bin(18,0)          dcl 37 set ref 261* 262*
block_size               15            based           fixed bin(17,0)          level 2 in structure "mseg_hdr" dcl 1-3 in procedure
                                                                                  "ms_salvager_v3_" set ref 139 263*
block_size                      000110 automatic       fixed bin(18,0)          dcl 37 in procedure "ms_salvager_v3_" set ref 139*
                                                                                  140 140 140* 143 152 152 154 182* 261 263
code                            000115 automatic       fixed bin(35,0)          dcl 46 set ref 123* 125* 126 131* 132 148* 262* 293
                                                                                  298*
divide                                                 builtin function         dcl 56 ref 143 145 152
end_ptr                         000132 automatic       pointer                  dcl 58 set ref 171* 190 212*
error_table_$fatal_error        000012 external static fixed bin(35,0)          dcl 46 ref 148
f_offset                  1            based           bit(18)                  level 2 packed unaligned dcl 2-3 set ref 228* 238*
first_ms_offset          10            based           bit(18)                  level 2 dcl 1-3 set ref 168 170 212 246* 254*
fixed                                                  builtin function         dcl 56 ref 139 140 145 154 170 171 211 212 228 230
                                                                                  236 246
forward                         000130 automatic       bit(1)                   dcl 54 set ref 172* 182* 196 206 210*
hash_table              120            based           structure                level 2 dcl 1-3 set ref 271*
hcs_$get_access_class_seg       000024 constant        entry                    external dcl 106 ref 125
hcs_$get_max_length_seg         000016 constant        entry                    external dcl 92 ref 131
hcs_$truncate_seg               000020 constant        entry                    external dcl 97 ref 262
hdr_alloc_len                   000111 automatic       fixed bin(18,0)          dcl 37 set ref 152* 164 182* 264
hdr_ms                   20            based           bit(2304)                level 2 dcl 1-3 set ref 277*
hdr_ms_access_class       2            based           bit(72)                  level 2 dcl 1-3 set ref 273* 278*
hdr_size                        000113 automatic       fixed bin(18,0)          dcl 37 set ref 145* 147 152
header_pattern                  000000 constant        bit(36)                  initial dcl 1-28 ref 269
i                               000100 automatic       fixed bin(17,0)          dcl 27 set ref 164* 165* 258* 261
last_backward_ptr               000134 automatic       pointer                  initial dcl 58 set ref 58* 200* 226 228 230 246 248
last_forward_ptr                000136 automatic       pointer                  initial dcl 58 set ref 58* 196* 223 228 230 236 238
last_in_bucket                  000151 automatic       bit(18)                  initial array level 2 packed unaligned dcl 72 set
                                                                                  ref 72*
last_ms_offset           11            based           bit(18)                  level 2 dcl 1-3 set ref 171 206 211 236* 254*
last_saved_ms_ptr               000140 automatic       pointer                  dcl 58 set ref 181* 182* 190 196 200
lock                                   based           bit(36)                  level 2 dcl 1-3 set ref 123*
mip                      16            based           bit(1)                   level 3 packed unaligned dcl 1-3 set ref 283*
mptr                            000552 automatic       pointer                  dcl 1-3 set ref 120* 123 125* 131* 137 139 145 156
                                                                                  168 170 170 171 171 206 211 211 212 212 236 246
                                                                                  254 254 262* 263 264 266 267 268 269 270 271 273
                                                                                  273 276 277 278 283 284 285 289* 298*
ms_block_trailer                       based           structure                level 1 dcl 2-3 set ref 154
ms_in_hdr                16(02)        based           bit(1)                   level 3 packed unaligned dcl 1-3 set ref 273 276*
ms_salv_util_v3_                000026 constant        entry                    external dcl 109 ref 182
mseg_access_class               000144 automatic       bit(72)                  dcl 66 set ref 125* 182* 273*
mseg_data_v3_$block_size        000010 external static fixed bin(18,0)          dcl 37 ref 140
mseg_error_v3_                  000030 constant        entry                    external dcl 113 ref 289 298
mseg_hdr                               based           structure                level 1 dcl 1-3
mseg_pattern              1            based           bit(36)                  level 2 dcl 1-3 set ref 269*
new_alloc_bits                  000100 automatic       bit                      initial dcl 162 set ref 162* 165* 182 182 258 266
new_hash_table                  000151 automatic       structure                level 1 dcl 72 set ref 182 182 271
null                                                   builtin function         dcl 56 ref 58 58 181 223 226
number_of_messages       14            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 156 267*
original_messages               000103 automatic       fixed bin(17,0)          dcl 27 set ref 156* 289 289
os                       16(01)        based           bit(1)                   level 3 packed unaligned dcl 1-3 set ref 284*
ptr                                                    builtin function         dcl 56 ref 170 171 211 212
read_allowed_                   000022 constant        entry                    external dcl 100 ref 273
reason                          000116 automatic       char(40)                 unaligned dcl 52 set ref 127* 133* 298*
rel                                                    builtin function         dcl 56 ref 145 228 230 236 246
ring_brackets                   000146 automatic       fixed bin(3,0)           initial array dcl 70 set ref 70* 70* 70*
salv_ptr                        000142 automatic       pointer                  dcl 58 set ref 170* 182* 211*
saved_blocks                    000101 automatic       fixed bin(17,0)          initial dcl 27 set ref 27* 188* 188 264
saved_messages                  000102 automatic       fixed bin(17,0)          initial dcl 27 set ref 27* 186* 186 220 267 289 289
seg_size                        000112 automatic       fixed bin(18,0)          dcl 37 set ref 131* 140 143 147 182*
set_lock_$lock                  000032 constant        entry                    external dcl 115 ref 123
sip                      16(03)        based           bit(1)                   level 3 packed unaligned dcl 1-3 set ref 137* 285*
size                                                   builtin function         dcl 56 ref 154
space_left               13            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 264*
substr                                                 builtin function         dcl 56 set ref 165*
switches                 16            based           structure                level 2 dcl 1-3
tr_ptr                                 automatic       pointer                  dcl 2-3 ref 154
trailer_offset                  000114 automatic       fixed bin(18,0)          dcl 37 set ref 154* 228 230 238 248
tsaved_blocks                   000104 automatic       fixed bin(17,0)          dcl 27 set ref 182* 188
tsaved_messages                 000105 automatic       fixed bin(17,0)          dcl 27 set ref 178* 182* 186 193
version_number           17            based           fixed bin(17,0)          level 2 in structure "mseg_hdr" dcl 1-3 in procedure
                                                                                  "ms_salvager_v3_" set ref 270*
version_number                         constant        fixed bin(17,0)          initial dcl 1-28 in procedure "ms_salvager_v3_" ref
                                                                                  270

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
comp1                                  automatic       char(168)                dcl 17
comp2                                  automatic       char(32)                 dcl 22
copy_seg_$no_message            000000 constant        entry                    external dcl 88
dir_len                                automatic       fixed bin(17,0)          dcl 27
expand_path_                    000000 constant        entry                    external dcl 85
hcs_$fs_get_path_name           000000 constant        entry                    external dcl 103
hcs_$set_ring_brackets          000000 constant        entry                    external dcl 94
hdr_ms_mask                            based           bit                      dcl 68
mseg_dir                               automatic       char(168)                dcl 17
mseg_name                              automatic       char(32)                 dcl 22
trailer_pattern                        internal static bit(36)                  initial dcl 2-18

NAMES DECLARED BY EXPLICIT CONTEXT.
BACKWARD                        000426 constant        label                    dcl 206 ref 168
FIN                             000747 constant        label                    dcl 293 ref 149 299
GRIPE                           000753 constant        label                    dcl 298 ref 128 134
REST_OF_HEADER                  000551 constant        label                    dcl 258 ref 190
SALVAGE_LOOP                    000333 constant        label                    dcl 178 ref 213
ZERO_HDR_MS                     000661 constant        label                    dcl 277 set ref 273
ms_salvager_v3_                 000051 constant        entry                    external dcl 11

NAMES DECLARED BY CONTEXT OR IMPLICATION.
index                                                  builtin function         ref 258
reverse                                                builtin function         ref 258

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1170        1224    1011        1200
Length      1442    1011        34         201     156           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ms_salvager_v3_                     408 external procedure  is an external procedure.  
begin block on line 160             100 begin block         uses auto adjustable storage.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 160  000100 new_alloc_bits              begin block on line 160
ms_salvager_v3_          000100 i                           ms_salvager_v3_
                         000101 saved_blocks                ms_salvager_v3_
                         000102 saved_messages              ms_salvager_v3_
                         000103 original_messages           ms_salvager_v3_
                         000104 tsaved_blocks               ms_salvager_v3_
                         000105 tsaved_messages             ms_salvager_v3_
                         000106 alloc_len                   ms_salvager_v3_
                         000107 block_offset                ms_salvager_v3_
                         000110 block_size                  ms_salvager_v3_
                         000111 hdr_alloc_len               ms_salvager_v3_
                         000112 seg_size                    ms_salvager_v3_
                         000113 hdr_size                    ms_salvager_v3_
                         000114 trailer_offset              ms_salvager_v3_
                         000115 code                        ms_salvager_v3_
                         000116 reason                      ms_salvager_v3_
                         000130 forward                     ms_salvager_v3_
                         000132 end_ptr                     ms_salvager_v3_
                         000134 last_backward_ptr           ms_salvager_v3_
                         000136 last_forward_ptr            ms_salvager_v3_
                         000140 last_saved_ms_ptr           ms_salvager_v3_
                         000142 salv_ptr                    ms_salvager_v3_
                         000144 mseg_access_class           ms_salvager_v3_
                         000146 ring_brackets               ms_salvager_v3_
                         000151 new_hash_table              ms_salvager_v3_
                         000552 mptr                        ms_salvager_v3_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
enter_begin         leave_begin         call_ext_out_desc   call_ext_out        return              alloc_auto_adj
shorten_stack       ext_entry           reverse_bs          set_bs_eis          index_bs_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
admin_gate_$guaranteed_eligibility_on                       hcs_$get_access_class_seg     hcs_$get_max_length_seg
hcs_$truncate_seg             ms_salv_util_v3_              mseg_error_v3_                read_allowed_
set_lock_$lock

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$fatal_error      mseg_data_v3_$block_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000045        27 000056        58 000060        70 000063        72 000077       120 000116       122 000122
    123 000127       125 000144       126 000157       127 000161       128 000164       131 000165       132 000200
    133 000202       134 000205       137 000206       139 000211       140 000213       143 000221       145 000224
    147 000234       148 000237       149 000242       152 000243       154 000247       156 000252       160 000254
    162 000257       164 000275       165 000306       166 000312       168 000314       170 000317       171 000323
    172 000331       178 000333       181 000335       182 000337       186 000400       188 000403       190 000405
    193 000411       196 000413       200 000421       206 000423       210 000431       211 000432       212 000437
    213 000445       220 000446       223 000450       226 000454       228 000460       230 000473       232 000507
    236 000510       238 000521       242 000526       246 000527       248 000540       252 000545       254 000546
    258 000551       261 000565       262 000570       263 000603       264 000607       266 000613       267 000621
    268 000623       269 000625       270 000627       271 000631       273 000634       276 000655       277 000661
    278 000664       283 000667       284 000673       285 000675       287 000677       289 000700       293 000747
    296 000752       298 000753       299 001004


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
