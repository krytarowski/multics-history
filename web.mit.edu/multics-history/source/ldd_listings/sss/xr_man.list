	COMPILATION LISTING OF SEGMENT xr_man
	Compiled by: Multics PL/I Compiler, Release 28d, of September 14, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 10/03/83  1705.6 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* procedure to manage index registers
       12*
       13*   Initial Version: 23 November, 1968 by BLW
       14*	Modified: 18 May, 1971 by BLW for Version II
       15*	Modified: 13 September, 1972 by BLW
       16*	Modified: 11 February, 1973 by RAB
       17*	Modified:	15 October 1975 by RAB for update_xr
       18*	Modified:	3 November 1976 to fix 1545 by RAB
       19*	Modified:	25 March 1977 by RAB to fix 1599
       20*	Modified:	14 August 1978 by RAB to fix 1727
       21*	Modified:	28 May 1979 by RAB to fix 1831 (a(b(i+j)-1) = 0;
       22*		i = b(i+j); gets ERROR 315)
       23*	Modified:	29 May 1979 by RAB to make minor changes to
       24*		get_free_index, flush_old, and load_xr_v
       25*
       26*   xr_man has the following entries:
       27*
       28*   load_any_var	tries to find an index already holding specified
       29*		variable.  if none exists, a new one is loaded.
       30*
       31*   load_any_const	tries to find an index already holding specified
       32*		constant.  if none exists, a new one is loaded
       33*
       34*   load_var	loads specified index with variable unless index
       35*		already holds variable
       36*
       37*   load_const	loads specified index with constant unless index
       38*		already holds constant
       39*
       40*   lock		"locks" a variable in the index register in which
       41*		it is known to be available;  a locked variable
       42*		will be unloaded only if all the index registers
       43*		become locked
       44*
       45*   unlock		"unlocks" a variable
       46*
       47*   super_lock	"super_locks" a variable in the index register in which it
       48*		is known to be available.  A super_locked register cannot
       49*		be unloaded.  This entry is called only from make_both_addressable.
       50*
       51*   super_unlock	unlocks a register that was "super_locked"
       52*
       53*   add_any_const	adds the contents of specified index register to specified constant
       54*		and places result in any index register
       55*
       56*   update_xr	updates the machine state to say that a variable is in the
       57*		specified index
       58*
       59*   The field "type" has the following meanings:
       60*
       61*	0	empty
       62*
       63*	1	constant
       64*
       65*	2	variable + constant
       66*
       67*	3	locked variable + constant
       68*
       69*	-n	super_locked register of type n
       70*
       71*						*/
       72 
       73 xr_man$load_any_var: proc(var,xr,base_offset);
       74 
       75 dcl	var	ptr,		/* points at var to be loaded */
       76 	xr	fixed bin,	/* specifies index to load or loaded */
       77 	base_offset fixed bin(18);	/* base offset to add to var */
       78 
       79 dcl	cg_stat$last_index_used fixed bin ext,
       80 	(cg_stat$text_pos,cg_stat$last_call) fixed bin(18) ext,
       81 	(cg_stat$text_base,cg_stat$cur_statement) ptr ext,
       82 	macro_table_$eax_array(0:15) fixed bin(15) ext static;
       83 
       84 dcl	(p,vp) ptr,
       85 	c fixed bin(18),
       86 	sta_code bit(9) int static init("111101101"b),
       87 	stq_code bit(9) int static init("111101110"b),
       88 	staq_code bit(9) int static init("111101111"b),
       89 	(i,j,k,type) fixed bin,
       90 	lock bit(1) aligned init("0"b),
       91 	expmac entry(fixed bin(15),ptr),
       92 	c_a entry(fixed bin(18),fixed bin) returns(ptr),
       93 	get_single_ref entry(ptr) returns(ptr),
       94 	stack_temp$free_temp entry(ptr),
       95 	adjust_ref_count entry(ptr,fixed bin),
       96 	m_a entry(ptr,bit(2) aligned),
       97 	error entry(fixed bin,ptr,ptr);
       98 
       99 dcl	(abs,addrel,bit,fixed,min,mod,null,ptr,rel,string,substr) builtin;
      100 
      101 dcl	word fixed bin based(p);
      102 
      103 dcl	full_word bit(36) aligned based(p);
      104 
      105 dcl	1 instruction	aligned based(p),
      106 	2 offset		unal bit(18),
      107 	2 op_code		unal bit(9),
      108 	2 rest		unal bit(9);
      109 
      110 dcl (	first_index	init(2),
      111 	last_index	init(7)) fixed bin int static;
      112 
      113 dcl	zero_mac 		init(308) fixed bin(15) int static;
      114 
  1     1 /* BEGIN INCLUDE FILE ... cgsystem.incl.pl1 */
  1     2 
  1     3 /* Modified: 25 Apr 1979 by PCK to implement 4-bit decimal */
  1     4 
  1     5 dcl (	bits_per_char		init(9),
  1     6 	bits_per_half		init(18),
  1     7 	bits_per_word		init(36),
  1     8 	bits_per_two_words		init(72),
  1     9 	bits_per_four_words		init(144),
  1    10 	bits_per_words(2)		init(36,72),
  1    11 	packed_digits_per_char	init(2),
  1    12 	chars_per_word		init(4),
  1    13 	packed_digits_per_word	init(8),
  1    14 
  1    15 	break_even_bits		init(216),
  1    16 	break_even_words		init(6),
  1    17 
  1    18 	label_size		init(4),
  1    19 
  1    20 	convert_size(13:14)		init(9,1),
  1    21 	max_offset(13:14)		init(27,35),
  1    22 	max_short_size(13:14)	init(8,72),
  1    23 
  1    24 	units_per_word(0:5)		init(1,36,8,4,2,1),
  1    25 
  1    26 	max_dec_scale		init(32),
  1    27 	min_dec_scale		init(-31),
  1    28 	max_p_xreg		init(18),
  1    29 	max_p_fix_bin_1		init(35),
  1    30 	max_p_flt_bin_1		init(27),
  1    31 	max_p_fix_dec		init(59),
  1    32 	max_length_p		init(24),
  1    33 	default_fix_bin_p		init(17)) fixed bin(8) int static options(constant);
  1    34 
  1    35 dcl      (convert_offset(0:5)		init(36,1,4.5,9,18,36),
  1    36 	bits_per_packed_digit	init(4.5)) fixed bin(8,1) int static options(constant);
  1    37 
  1    38 dcl	max_index_register_value	init(262143) fixed bin(31) int static options(constant);
  1    39 
  1    40 /* END INCLUDE FILE ... cgsystem.incl.pl1 */
  1    41 
      115 
  2     1 dcl (	real_fix_bin_1		init(1),
  2     2 	real_fix_bin_2		init(2),
  2     3 	real_flt_bin_1		init(3),
  2     4 	real_flt_bin_2		init(4),
  2     5 	complex_fix_bin_1		init(5),
  2     6 	complex_fix_bin_2		init(6),
  2     7 	complex_flt_bin_1		init(7),
  2     8 	complex_flt_bin_2		init(8),
  2     9 	real_fix_dec		init(9),
  2    10 	real_flt_dec		init(10),
  2    11 	complex_fix_dec		init(11),
  2    12 	complex_flt_dec		init(12),
  2    13 	char_string		init(13),
  2    14 	bit_string		init(14),
  2    15 	label_constant		init(15),
  2    16 	local_label_variable	init(16),
  2    17 	label_variable		init(17),
  2    18 	entry_variable		init(18),
  2    19 	ext_entry_in		init(19),
  2    20 	ext_entry_out		init(20),
  2    21 	int_entry			init(21),
  2    22 	int_entry_other		init(22),
  2    23 	unpacked_ptr		init(23),
  2    24 	packed_ptr		init(24)) fixed bin(15) int static options(constant);
      116 
  3     1 /* BEGIN INCLUDE FILE ... boundary.incl.pl1 */
  3     2 
  3     3 /* Modified: 26 Apr 1979 by PCK to implement 4-bit decimal */
  3     4 
  3     5 dcl (	bit_		init(1),
  3     6 	digit_		init(2),
  3     7 	character_	init(3),
  3     8 	half_		init(4),
  3     9 	word_		init(5),
  3    10 	mod2_		init(6),
  3    11 	mod4_		init(7)) fixed bin(3) int static options(constant);
  3    12 
  3    13 /* END INCLUDE FILE ... boundary.incl.pl1 */
      117 
  4     1 /* BEGIN INCLUDE FILE ... machine_state.incl.pl1 */
  4     2 
  4     3 dcl	cg_static_$m_s_p ptr ext static,
  4     4 	m_s_p ptr init(cg_static_$m_s_p);
  4     5 
  4     6 dcl	1 machine_state	aligned based(m_s_p),
  4     7 	2 node_type	bit(9),
  4     8 	2 indicators	fixed bin,
  4     9 	2 next		ptr unal,
  4    10 	2 a_reg,
  4    11 	  3 variable(10)	ptr unal,
  4    12 	  3 number	fixed bin(17),
  4    13 	  3 size		fixed bin(8),
  4    14 	  3 length	fixed bin(8),
  4    15 	  3 offset	fixed bin(8),
  4    16 	  3 constant	fixed bin(24),
  4    17 	  3 changed	fixed bin(18),
  4    18 	  3 instruction	bit(36),
  4    19 	  3 locked	bit(1) aligned,
  4    20 	  3 number_h_o	fixed bin,
  4    21 	  3 has_offset(3)	ptr unal,
  4    22 	2 q_reg,
  4    23 	  3 variable(10)	ptr unal,
  4    24 	  3 number	fixed bin(17),
  4    25 	  3 size		fixed bin(8),
  4    26 	  3 length	fixed bin(8),
  4    27 	  3 offset	fixed bin(8),
  4    28 	  3 constant	fixed bin(24),
  4    29 	  3 changed	fixed bin(18),
  4    30 	  3 instruction	bit(36),
  4    31 	  3 locked	bit(1) aligned,
  4    32 	  3 number_h_o	fixed bin,
  4    33 	  3 has_offset(3)	ptr unal,
  4    34 	2 string_reg,
  4    35 	  3 variable	ptr unal,
  4    36 	  3 size		fixed bin(8),
  4    37 	  3 offset	fixed bin(8),
  4    38 	2 complex_reg,
  4    39 	  3 variable	ptr unal,
  4    40 	  3 size		fixed bin(8),
  4    41 	  3 scale		fixed bin(8),
  4    42 	2 decimal_reg,
  4    43 	  3 variable	ptr unal,
  4    44 	  3 size		fixed bin(8),
  4    45 	  3 scale		fixed bin(8),
  4    46 	2 index_regs(0:7),
  4    47 	  3 variable	ptr unal,
  4    48 	  3 constant	fixed bin,
  4    49 	  3 type		fixed bin(8),
  4    50 	  3 used		fixed bin(18),
  4    51 	  3 changed	fixed bin(18),
  4    52 	  3 instruction	bit(36),
  4    53 	  3 filler	fixed bin,
  4    54 	2 base_regs(0:7),
  4    55 	  3 variable	ptr unal,
  4    56 	  3 constant	fixed bin,
  4    57 	  3 type		fixed bin(8),
  4    58 	  3 pad (12)	fixed bin,	/* future...room to make 5 element array for variable, constant, type */
  4    59 	  3 number	fixed bin (17),	/* future...number of valid elements in array */
  4    60 	  3 used		fixed bin(18),
  4    61 	  3 changed	fixed bin(18),
  4    62 	  3 instruction	bit(36),
  4    63 	  3 locked	fixed bin(2),
  4    64 	2 indicators_ref(2:3) ptr unal;
  4    65 
  4    66 /* Permissible values for machine_state.indicators. */
  4    67 
  4    68 dcl (	ind_known_refs	init (-2),		/* set by comparison of known, nonzero, references */
  4    69 	ind_invalid	init (-1),
  4    70 	ind_string_aq	init (0),			/* logical value in storage */
  4    71 	ind_logical	init (1),			/* logical value in A or AQ */
  4    72 	ind_arithmetic	init (2),			/* arith value in Q, AQ, or EAQ */
  4    73 	ind_x (0:7)	init (6, 7, 8, 9, 10, 11, 12, 13),
  4    74 	ind_decimal_reg	init (14)
  4    75 	) fixed bin internal static options (constant);
  4    76 
  4    77 /* END INCLUDE FILE ... machine_state.incl.pl1 */
      118 
  5     1 /* BEGIN INCLUDE FILE ... reference.incl.pl1 */
  5     2 
  5     3 dcl	1 reference		based aligned,
  5     4 	2 node_type		bit(9) unaligned,
  5     5 	2 array_ref		bit(1) unaligned,
  5     6 	2 varying_ref		bit(1) unaligned,
  5     7 	2 shared			bit(1) unaligned,
  5     8 	2 put_data_sw		bit(1) unaligned,
  5     9 	2 processed		bit(1) unaligned,
  5    10 	2 units			fixed(3) unaligned,
  5    11 	2 ref_count		fixed(17) unaligned,
  5    12 	2 c_offset		fixed(24),
  5    13 	2 c_length		fixed(24),
  5    14 	2 symbol			ptr unaligned,
  5    15 	2 qualifier		ptr unaligned,
  5    16 	2 offset			ptr unaligned,
  5    17 	2 length			ptr unaligned,
  5    18 	2 subscript_list		ptr unaligned,
  5    19 						/* these fields are used by the 645 code generator */
  5    20 	2 address			structure unaligned,
  5    21 	  3 base			bit(3),
  5    22 	  3 offset		bit(15),
  5    23 	  3 op			bit(9),
  5    24 	  3 no_address		bit(1),
  5    25 	  3 inhibit		bit(1),
  5    26 	  3 ext_base		bit(1),
  5    27 	  3 tag			bit(6),
  5    28 	2 info			structure unaligned,
  5    29 	  3 address_in		structure,
  5    30 	    4 b			dimension(0:7) bit(1),
  5    31 	    4 storage		bit(1),
  5    32 	  3 value_in		structure,
  5    33 	    4 a			bit(1),
  5    34 	    4 q			bit(1),
  5    35 	    4 aq			bit(1),
  5    36 	    4 string_aq		bit(1),
  5    37 	    4 complex_aq		bit(1),
  5    38 	    4 decimal_aq		bit(1),
  5    39 	    4 b			dimension(0:7) bit(1),
  5    40 	    4 storage		bit(1),
  5    41 	    4 indicators		bit(1),
  5    42 	    4 x			dimension(0:7) bit(1),
  5    43 	  3 other			structure,
  5    44 	    4 big_offset		bit(1),
  5    45 	    4 big_length		bit(1),
  5    46 	    4 modword_in_offset	bit(1),
  5    47 	2 data_type		fixed(5) unaligned,
  5    48 	2 bits			structure unaligned,
  5    49 	  3 padded_ref		bit(1),
  5    50 	  3 aligned_ref		bit(1),
  5    51 	  3 long_ref		bit(1),
  5    52 	  3 forward_ref		bit(1),
  5    53 	  3 ic_ref		bit(1),
  5    54 	  3 temp_ref		bit(1),
  5    55 	  3 defined_ref		bit(1),
  5    56 	  3 evaluated		bit(1),
  5    57 	  3 allocate		bit(1),
  5    58 	  3 allocated		bit(1),
  5    59 	  3 aliasable		bit(1),
  5    60 	  3 even			bit(1),
  5    61 	  3 perm_address		bit(1),
  5    62 	  3 aggregate		bit(1),
  5    63 	  3 hit_zero		bit(1),
  5    64 	  3 dont_save		bit(1),
  5    65 	  3 fo_in_qual		bit(1),
  5    66 	  3 hard_to_load		bit(1),
  5    67 	2 relocation		bit(12) unaligned,
  5    68 	2 more_bits		structure unaligned,
  5    69 	  3 substr		bit(1),
  5    70 	  3 padded_for_store_ref	bit(1),
  5    71 	  3 aligned_for_store_ref	bit(1),
  5    72 	  3 mbz			bit(15),
  5    73 	2 store_ins		bit(18) unaligned;
  5    74 
  5    75 /* END INCLUDE FILE ... reference.incl.pl1 */
      119 
  6     1 /* BEGIN INCLUDE FILE ... temporary.incl.pl1 */
  6     2 
  6     3 dcl	1 temporary	based,
  6     4 	2 node_type	bit(9),	/* type is "000001010"b */
  6     5 	2 size		fixed bin(18),
  6     6 	2 next		ptr,
  6     7 	2 location	fixed bin(18),
  6     8 	2 ref_count	fixed bin,
  6     9 	2 symbol		ptr unal,
  6    10 	2 last_freed	fixed bin(18);
  6    11 
  6    12 /* END INCLUDE FILE ... temporary.incl.pl1 */
      120 
  7     1 /* BEGIN INCLUDE FILE ... symbol.incl.pl1 */
  7     2 
  7     3 dcl	1 symbol			based aligned,
  7     4 	2 node_type		bit(9) unal,
  7     5 	2 source_id		structure unal,
  7     6 	  3 file_number		bit(8),
  7     7 	  3 line_number		bit(14),
  7     8 	  3 statement_number	bit(5),
  7     9 	2 location		fixed(18) unal unsigned,
  7    10 	2 allocated		bit(1) unal,
  7    11 	2 dcl_type		bit(3) unal,
  7    12 	2 reserved		bit(6) unal,
  7    13 	2 pix			unal,
  7    14 	  3 pic_fixed		bit(1) unal,
  7    15 	  3 pic_float		bit(1) unal,
  7    16 	  3 pic_char		bit(1) unal,
  7    17 	  3 pic_scale		fixed(7) unal,
  7    18 	  3 pic_size		fixed(7) unal,
  7    19 	2 level			fixed(8) unal,
  7    20 	2 boundary		fixed(3) unal,
  7    21 	2 size_units		fixed(3) unal,
  7    22 	2 scale			fixed(7) unal,
  7    23 	2 runtime			bit(18) unal,
  7    24 	2 runtime_offset		bit(18) unal,
  7    25 	2 block_node		ptr unal,
  7    26 	2 token			ptr unal,
  7    27 	2 next			ptr unal,
  7    28 	2 multi_use		ptr unal,
  7    29 	2 cross_references		ptr unal,
  7    30 	2 initial			ptr unal,
  7    31 	2 array			ptr unal,
  7    32 	2 descriptor		ptr unal,
  7    33 	2 equivalence		ptr unal,
  7    34 	2 reference		ptr unal,
  7    35 	2 general			ptr unal,
  7    36 	2 father			ptr unal,
  7    37 	2 brother			ptr unal,
  7    38 	2 son			ptr unal,
  7    39 	2 word_size		ptr unal,
  7    40 	2 bit_size		ptr unal,
  7    41 	2 dcl_size		ptr unal,
  7    42 	2 symtab_size		ptr unal,
  7    43 	2 c_word_size		fixed(24),
  7    44 	2 c_bit_size		fixed(24),
  7    45 	2 c_dcl_size		fixed(24),
  7    46 
  7    47 	2 attributes		structure aligned,
  7    48 	  3 data_type		structure unal,
  7    49 	    4 structure		bit(1) ,
  7    50 	    4 fixed		bit(1),
  7    51 	    4 float		bit(1),
  7    52 	    4 bit			bit(1),
  7    53 	    4 char		bit(1),
  7    54 	    4 ptr			bit(1),
  7    55 	    4 offset		bit(1),
  7    56 	    4 area		bit(1),
  7    57 	    4 label		bit(1),
  7    58 	    4 entry		bit(1),
  7    59 	    4 file		bit(1),
  7    60 	    4 arg_descriptor	bit(1),
  7    61 	    4 storage_block		bit(1),
  7    62 	    4 explicit_packed	bit(1), /* options(packed) */
  7    63 	    4 condition		bit(1),
  7    64 	    4 format		bit(1),
  7    65 	    4 builtin		bit(1),
  7    66 	    4 generic		bit(1),
  7    67 	    4 picture		bit(1),
  7    68 
  7    69 	  3 misc_attributes		structure unal,
  7    70 	    4 dimensioned		bit(1),
  7    71 	    4 initialed		bit(1),
  7    72 	    4 aligned		bit(1),
  7    73 	    4 unaligned		bit(1),
  7    74 	    4 signed		bit(1),
  7    75 	    4 unsigned		bit(1),
  7    76 	    4 precision		bit(1),
  7    77 	    4 varying		bit(1),
  7    78 	    4 local		bit(1),
  7    79 	    4 decimal		bit(1),
  7    80 	    4 binary		bit(1),
  7    81 	    4 real		bit(1),
  7    82 	    4 complex		bit(1),
  7    83 	    4 variable		bit(1),
  7    84 	    4 reducible		bit(1),
  7    85 	    4 irreducible		bit(1),
  7    86 	    4 returns		bit(1),
  7    87 	    4 position		bit(1),
  7    88 	    4 internal		bit(1),
  7    89 	    4 external		bit(1),
  7    90 	    4 like		bit(1),
  7    91 	    4 member		bit(1),
  7    92 	    4 non_varying		bit(1),
  7    93 	    4 options		bit(1),
  7    94 	    4 variable_arg_list 	bit(1),		/* options(variable) */
  7    95 	    4 alloc_in_text		bit(1),		/* options(constant) */
  7    96 
  7    97 	  3 storage_class		structure unal,
  7    98 	    4 auto		bit(1),
  7    99 	    4 based		bit(1),
  7   100 	    4 static		bit(1),
  7   101 	    4 controlled		bit(1),
  7   102 	    4 defined		bit(1),
  7   103 	    4 parameter		bit(1),
  7   104 	    4 param_desc		bit(1),
  7   105 	    4 constant		bit(1),
  7   106 	    4 temporary		bit(1),
  7   107 	    4 return_value		bit(1),
  7   108 
  7   109 	  3 file_attributes		structure unal,
  7   110 	    4 print		bit(1),
  7   111 	    4 input		bit(1),
  7   112 	    4 output		bit(1),
  7   113 	    4 update		bit(1),
  7   114 	    4 stream		bit(1),
  7   115 	    4 reserved_1		bit(1),
  7   116 	    4 record		bit(1),
  7   117 	    4 sequential		bit(1),
  7   118 	    4 direct		bit(1),
  7   119 	    4 interactive		bit(1),		/* env(interactive) */
  7   120 	    4 reserved_2		bit(1),
  7   121 	    4 reserved_3		bit(1),
  7   122 	    4 stringvalue		bit(1),		/* env(stringvalue) */
  7   123 	    4 keyed		bit(1),
  7   124 	    4 reserved_4		bit(1),
  7   125 	    4 environment		bit(1),
  7   126 
  7   127 	  3 compiler_developed	structure unal,
  7   128 	    4 aliasable		bit(1),
  7   129 	    4 packed		bit(1),
  7   130 	    4 passed_as_arg		bit(1),
  7   131 	    4 allocate		bit(1),
  7   132 	    4 set			bit(1),
  7   133 	    4 exp_extents		bit(1),
  7   134 	    4 refer_extents		bit(1),
  7   135 	    4 star_extents		bit(1),
  7   136 	    4 isub		bit(1),
  7   137 	    4 put_in_symtab		bit(1),
  7   138 	    4 contiguous		bit(1),
  7   139 	    4 put_data		bit(1),
  7   140 	    4 overlayed		bit(1),
  7   141 	    4 error		bit(1),
  7   142 	    4 symtab_processed	bit(1),
  7   143 	    4 overlayed_by_builtin	bit(1),
  7   144 	    4 defaulted		bit(1),
  7   145 	    4 connected		bit(1);
  7   146 
  7   147 /* END INCLUDE FILE ... symbol.incl.pl1 */
      121 
  8     1 /* BEGIN INCLUDE FILE ... operator.incl.pl1 */
  8     2 
  8     3 /*	Modified: 2 Apr 1980 by PCK to add max_number_of_operands */
  8     4 
  8     5 /* format: style3 */
  8     6 dcl	1 operator	based aligned,
  8     7 	  2 node_type	bit (9) unaligned,
  8     8 	  2 op_code	bit (9) unaligned,
  8     9 	  2 shared	bit (1) unaligned,
  8    10 	  2 processed	bit (1) unaligned,
  8    11 	  2 optimized	bit (1) unaligned,
  8    12 	  2 number	fixed (14) unaligned,
  8    13 	  2 operand	dimension (n refer (operator.number)) ptr unaligned;
  8    14 
  8    15 dcl	max_number_of_operands
  8    16 			fixed bin (15) int static options (constant) initial (32767);
  8    17 
  8    18 /* END INCLUDE FILE ... operator.incl.pl1 */
      122 
  9     1 /* BEGIN INCLUDE FILE ... nodes.incl.pl1 */
  9     2 
  9     3 /* Modified: 26 Dec 1979 by PCK to implement by name assignment */
  9     4 
  9     5 dcl (	block_node		initial("000000001"b),
  9     6 	statement_node		initial("000000010"b),
  9     7 	operator_node		initial("000000011"b),
  9     8 	reference_node		initial("000000100"b),
  9     9 	token_node		initial("000000101"b),
  9    10 	symbol_node		initial("000000110"b),
  9    11 	context_node		initial("000000111"b),
  9    12 	array_node		initial("000001000"b),
  9    13 	bound_node		initial("000001001"b),
  9    14 	format_value_node		initial("000001010"b),
  9    15 	list_node			initial("000001011"b),
  9    16 	default_node		initial("000001100"b),
  9    17 	machine_state_node		initial("000001101"b),
  9    18 	source_node		initial("000001110"b),
  9    19 	label_node		initial("000001111"b),
  9    20 	cross_reference_node	initial("000010000"b),
  9    21 	sf_par_node		initial("000010001"b),
  9    22 	temporary_node		initial("000010010"b),
  9    23 	label_array_element_node	initial("000010011"b),
  9    24 	by_name_agg_node		initial("000010100"b))
  9    25 				bit(9) internal static aligned options(constant);
  9    26 
  9    27 dcl	1 node			based aligned,
  9    28 	2 type			unal bit(9),
  9    29 	2 source_id		unal structure,
  9    30 	  3 file_number		bit(8),
  9    31 	  3 line_number		bit(14),
  9    32 	  3 statement_number	bit(5);
  9    33 
  9    34 /* END INCLUDE FILE ... nodes.incl.pl1 */
      123 
 10     1 dcl (	load_pt		init(60),
 10     2 	store_pt		init(61),
 10     3 	load_pt_reg	init(172),
 10     4 	set_ptr_to	init(268),
 10     5 	load_link_pt	init(283),
 10     6 
 10     7 	lxl0		init(64),
 10     8 	lxl1		init(65),		/* lxl0+1 */
 10     9 	lxl2		init(66),		/* lxl0+2 */
 10    10 	lxl3		init(67),		/* lxl0+3 */
 10    11 	lxl4		init(68),		/* lxl0+4 */
 10    12 	lxl5		init(69),		/* lxl0+5 */
 10    13 	lxl6		init(70),		/* lxl0+6 */
 10    14 	lxl7		init(71),		/* lxl0+7 */
 10    15 
 10    16 	ldx0		init(72),
 10    17 	ldx1		init(73),		/* ldx0+1 */
 10    18 	ldx2		init(74),		/* ldx0+2 */
 10    19 	ldx3		init(75),		/* ldx0+3 */
 10    20 	ldx4		init(76),		/* ldx0+4 */
 10    21 	ldx5		init(77),		/* ldx0+5 */
 10    22 	ldx6		init(78),		/* ldx0+6 */
 10    23 	ldx7		init(79),		/* ldx0+7 */
 10    24 
 10    25 	adx0		init(80),
 10    26 	adx1		init(81),		/* adx0+1 */
 10    27 	adx2		init(82),		/* adx0+2 */
 10    28 	adx3		init(83),		/* adx0+3 */
 10    29 	adx4		init(84),		/* adx0+4 */
 10    30 	adx5		init(85),		/* adx0+5 */
 10    31 	adx6		init(86),		/* adx0+6 */
 10    32 	adx7		init(87),		/* adx0+7 */
 10    33 
 10    34 	sxl0		init(345),
 10    35 
 10    36 	stx0		init(714),
 10    37 
 10    38 	eax0		init(353))
 10    39 				 fixed bin(15) internal static options(constant);
      124 
      125 
      126 	/* get ptr to variable */
      127 
      128 join:	vp = var;
      129 
      130 	j,k = -1;
      131 
      132 	do i = first_index to last_index;
      133 	     type = abs(index_regs(i).type);
      134 	     if type = 0 then k = i;
      135 	     else if type >= 2
      136 		then if index_regs(i).variable = vp
      137 		     then do;
      138 			j = i;
      139 			if index_regs(i).constant = base_offset then goto set_i_dec;
      140 			end;
      141 	     end;
      142 
      143 	/* must load a register */
      144 
      145 	call when_to_m_a;
      146 	call get_free_index;
      147 	c = base_offset;
      148 	call load_xr_v(k);
      149 
      150 ret_k:	xr = k;
      151 	if lock
      152 	     then index_regs(xr).type = -abs(index_regs(xr).type);
      153 	return;
      154 
      155 set_i_dec:
      156 	if ^ vp -> reference.shared then call adjust_ref_count(vp,-1);
      157 
      158 set_i:	index_regs(i).used = cg_stat$text_pos;
      159 
      160 	xr = i;
      161 	if lock
      162 	     then index_regs(xr).type = -abs(index_regs(xr).type);
      163 	return;
      164 
      165 xr_man$load_any_const: entry(const,xr);
      166 
      167 dcl	const	fixed bin(18);	/* value of constant to be loaded */
      168 
      169 	k = -1;
      170 	do i = first_index to last_index;
      171 	     type = abs(index_regs(i).type);
      172 	     if type = 0 then k = i;
      173 	     else if type = 1
      174 		then if index_regs(i).constant = const then goto set_i;
      175 	     end;
      176 
      177 	/* did not have index register holding exact value of
      178*	   the constant, must load one */
      179 
      180 	call get_free_index;
      181 	call load_xr_c(k);
      182 	goto ret_k;
      183 
      184 xr_man$load_var: entry(var,xr);
      185 
      186 	i = xr;
      187 
      188 	vp = var;
      189 
      190 	if index_regs(i).type < 2 then goto lv;
      191 	if index_regs(i).variable ^= vp then goto lv;
      192 	if index_regs(i).constant = 0
      193 	then do;
      194 	     if ^ vp -> reference.shared
      195 	     then call adjust_ref_count(vp,-1);
      196 	     goto lc_used;
      197 	     end;
      198 
      199 lv:	c = 0;
      200 	j,k = -1;
      201 	cg_stat$last_index_used = i;
      202 	call when_to_m_a;
      203 	call load_xr_v(xr);
      204 	return;
      205 
      206 xr_man$load_const:	entry(const,xr);
      207 
      208 	i = xr;
      209 	if index_regs(i).type ^= 1 then goto lc;
      210 
      211 	if index_regs(i).constant = const
      212 	then do;
      213 lc_used:	     index_regs(i).used = cg_stat$text_pos;
      214 	     return;
      215 	     end;
      216 
      217 lc:	call load_xr_c(xr);
      218 	cg_stat$last_index_used = i;
      219 	return;
      220 
      221 
      222 xr_man$lock: entry(var,xr);
      223 
      224 	i = xr;
      225 	var -> reference.value_in.x(i) = "1"b;
      226 	index_regs(i).variable = var;
      227 	index_regs(i).type = 3;
      228 	return;
      229 
      230 xr_man$unlock: entry(ix);
      231 
      232 dcl	ix fixed bin;
      233 
      234 	index_regs(ix).type = 2;
      235 	return;
      236 
      237 
      238 xr_man$super_lock:	entry(ix);
      239 
      240 	index_regs(ix).type = -abs(index_regs(ix).type);
      241 	return;
      242 
      243 
      244 xr_man$super_unlock:	entry(ix);
      245 
      246 	index_regs(ix).type = abs(index_regs(ix).type);
      247 	return;
      248 
      249 
      250 xr_man$add_any_const:	entry(const,xr,old_xr);
      251 
      252 dcl	old_xr fixed bin;
      253 
      254 	j = old_xr;
      255 	c = index_regs(j).constant + const;
      256 
      257 	if index_regs(j).type >= 2
      258 	then do;
      259 	     vp = index_regs(j).variable;
      260 
      261 	     if ^ vp -> reference.shared
      262 		then vp -> reference.ref_count = vp -> reference.ref_count + 1;
      263 
      264 	     call xr_man$load_any_var(vp,xr,c);
      265 
      266 	     end;
      267 	else call xr_man$load_any_const(c,xr);
      268 
      269 	return;
      270 
      271 
      272 xr_man$load_any_var_and_lock:	entry(var,xr,base_offset);
      273 
      274 	lock = "1"b;
      275 	go to join;
      276 
      277 
      278 xr_man$update_xr:	entry(var,xr);
      279 
      280 	vp = var;
      281 	i = xr;
      282 
      283 	call flush_old(i);
      284 
      285 	vp -> reference.value_in.x(i) = "1"b;
      286 	index_regs(i).type = 2;
      287 	index_regs(i).variable = vp;
      288 	index_regs(i).constant = 0;
      289 	index_regs(i).used = cg_stat$text_pos;
      290 	return;
      291 
      292 /*  */
      293 
      294 
      295 when_to_m_a:	proc;
      296 dcl	p ptr;
      297 
      298 /* Decide whether we must make vp addressable before looking for a free index register
      299*   and loading vp */
      300 
      301 	if j >= 0 then return;
      302 	if vp->reference.value_in.a then return;
      303 	if vp->reference.value_in.q then return;
      304 	if string(vp->reference.value_in.x) then return;
      305 	if ^ vp -> reference.no_address
      306 	     then if vp -> reference.perm_address
      307 		     then return;
      308 
      309 	do p = vp->reference.offset repeat p->reference.offset while (p ^= null);
      310 		if p->node.type = operator_node
      311 		     then p = p->operand(1);
      312 		if p->reference.ref_count > 1
      313 		 | p -> reference.temp_ref & string(p -> reference.value_in.x) = "0"b
      314 		then do;
      315 			call m_a(vp,"0"b);
      316 			vp->reference.perm_address = "1"b;
      317 			if k >= 0
      318 			     then if index_regs(k).type ^= 0
      319 				then do;
      320 					k = -1;
      321 					do i = first_index to last_index;
      322 						if index_regs(i).type = 0
      323 						     then k = i;
      324 					end;
      325 				     end;
      326 			return;
      327 		     end;
      328 	end;
      329 end;
      330 
      331 
      332 
      333 /*  */
      334 get_free_index: proc;
      335 
      336 	     /* if an empty register was found during scan use that,
      337*	        otherwise, try to pick a register containing a constant;
      338*	        if none, try to pick register containing unlocked
      339*	        variable with smallest reference count; as a last
      340*	        resort, pick locked variable with smallest reference
      341*	        count */
      342 
      343 dcl	     (i,j,cmin,ignore,n,type) fixed bin,
      344 	     p ptr;
      345 
      346 	     /* note: variable 'k' lives in outer block */
      347 
      348 	     if k >= 0
      349 	     then do;
      350 		cg_stat$last_index_used = k;
      351 		return;
      352 		end;
      353 
      354 	     ignore = 3;			/* ignore locked vars */
      355 
      356 look:	     j = -1;
      357 	     cmin = 123456;
      358 
      359 	     do i = cg_stat$last_index_used + 1 to last_index, first_index to min(cg_stat$last_index_used,last_index);
      360 
      361 		type = index_regs(i).type;
      362 
      363 		if type >= 0 & type ^= ignore
      364 		then do;
      365 
      366 		     if type = 0 | type = 1
      367 		     then do;
      368 			k, cg_stat$last_index_used = i;
      369 			return;
      370 			end;
      371 
      372 		     p = index_regs(i).variable;
      373 
      374 		     if p -> reference.shared
      375 		     then if p -> reference.temp_ref
      376 			then n = 0;
      377 			else n = 1;
      378 		     else n = p -> reference.ref_count;
      379 
      380 		     if n = 0
      381 		     then do;
      382 			k, cg_stat$last_index_used = i;
      383 			return;
      384 			end;
      385 
      386 		     if n < cmin
      387 		     then do;
      388 			j = i;
      389 			cmin = n;
      390 			end;
      391 		     else if n = cmin
      392 			then if index_regs(i).used < index_regs(j).used
      393 			     then do;
      394 				j = i;
      395 				cmin = n;
      396 				end;
      397 		     end;
      398 
      399 		end;
      400 
      401 	     if j >= 0
      402 	     then do;
      403 		k, cg_stat$last_index_used = j;
      404 		return;
      405 		end;
      406 
      407 	     /* we should never get here with ignore already = 2 */
      408 
      409 	     if ignore = 3
      410 	     then do;
      411 		ignore = 2;
      412 		goto look;
      413 		end;
      414 
      415 	     call error(328,cg_stat$cur_statement,vp);
      416 	     k = 1;
      417 	     end;
      418 
      419 /*  */
      420 load_xr_v:     proc(xr);
      421 
      422 dcl	     xr	fixed bin;	/* index to load */
      423 
      424 dcl	     (p,q,old_p,text_pt) ptr,
      425 	     x fixed bin,
      426 	     b18 bit(18),
      427 	     (n,text_pos,c1,i) fixed bin(18),
      428 	     op_code bit(9) aligned;
      429 
      430 	     x = xr;
      431 	     p, q = vp;
      432 
      433 	     c1 = c;
      434 	     if c1 < 0 then c1 = c1 + 262144;		/* 2's complement */
      435 
      436 	     if p -> reference.value_in.q
      437 	     then do;
      438 		n = 0;
      439 		goto l2;
      440 		end;
      441 
      442 	     if p -> reference.value_in.a
      443 	     then if p -> reference.aligned_ref | a_reg.offset = 0 | a_reg.offset = 18
      444 	     then do;
      445 		if ^ p -> reference.aligned_ref & a_reg.offset = 0
      446 		     then n = 16;
      447 		     else n = 8;
      448 l2:
      449 		call flush_old(x);
      450 
      451 		text_pos = cg_stat$text_pos;
      452 		cg_stat$text_pos = cg_stat$text_pos + 1;
      453 		goto l3;
      454 		end;
      455 
      456 	     if j >= 0
      457 	     then do;
      458 
      459 		/* value of variable is in another index with different
      460*		   base_offset, we can generate the instruction
      461*			eaxx	diff,j			*/
      462 
      463 		call flush_old(x);
      464 
      465 		old_p = c_a((j),8);
      466 		c1 = c - index_regs(j).constant;
      467 		if c1 < 0 then c1 = c1 + 262144;
      468 		substr(string(old_p -> reference.address),1,18) = bit(c1,18);
      469 		call expmac(eax0+x,old_p);
      470 		if ^p -> reference.shared
      471 		     then call adjust_ref_count(p,-1);
      472 		goto l4;
      473 		end;
      474 
      475 	     if p -> reference.value_in.storage then goto test;
      476 
      477 	     if ^ p -> reference.temp_ref then goto gen_lxl;
      478 
      479 	     if p -> reference.aggregate then goto gen_lxl;
      480 
      481 	     call error(315,cg_stat$cur_statement,p);
      482 
      483 test:	     if p -> reference.symbol -> symbol.c_dcl_size >= bits_per_half then goto gen_lxl;
      484 
      485 	     text_pos = fixed(p -> reference.store_ins,18);
      486 	     if text_pos < cg_stat$last_call then goto gen_lxl;
      487 
      488 	     if c ^= 0
      489 	     then if ^ p -> reference.dont_save
      490 		then go to gen_lxl;
      491 
      492 	     if index_regs(x).used >= text_pos
      493 	     then do;
      494 gen_lxl:		if p -> reference.data_type = real_fix_bin_2
      495 		     then q = get_single_ref(p);
      496 
      497 		n = lxl0;
      498 		if ^ p -> reference.aligned_ref
      499 		then if p -> reference.units = word_ 
      500 		     then n = ldx0;
      501 
      502 		if ^ q -> reference.perm_address
      503 		then do;
      504 		     call m_a(q,"00"b);
      505 		     q -> reference.perm_address = "1"b;
      506 		     end;
      507 
      508 		call flush_old(x);
      509 
      510 		call expmac(n+x,q);
      511 		if c ^= 0
      512 		then do;
      513 		     old_p = c_a(c,1);
      514 		     old_p -> reference.tag = "001"b || bit(fixed(x,3),3);
      515 		     call expmac(eax0+x,old_p);
      516 		     end;
      517 		end;
      518 
      519 	     else do;
      520 
      521 		/* the index register was not used from the point of the
      522*		   store instruction which evaluated the expression to
      523*		   the current instruction.  we'll attempt to change the
      524*		   store instruction into an eax instruction */
      525 
      526 		text_pt = addrel(cg_stat$text_base,text_pos);
      527 		op_code = text_pt -> instruction.op_code;
      528 
      529 		if op_code = sta_code then n = 8;
      530 		else if op_code = stq_code then n = 0;
      531 		     else if op_code = staq_code then n = 0;
      532 			else goto gen_lxl;
      533 
      534 		/* make sure that the value was not used from the time it was
      535*		   put in storage.  we do this by looking for the address of
      536*		   the temporary being used.  This prevents a bug which might
      537*		   occur in the sequence
      538*			dcl (a(10),b(10,10)) fixed bin;
      539*			a(k) = b(k,k);
      540*		   where we might otherwise change "stq temp" into "eaxn 0,ql"
      541*		   even though sequence for calculating b's subscript did
      542*		   "adq temp"	*/
      543 
      544 		b18 = "110"b || bit(fixed(mod(p -> reference.qualifier -> temporary.location,16384),15),15);
      545 		do i = text_pos + 1 to cg_stat$text_pos - 1;
      546 		     if b18 = addrel(cg_stat$text_base,i) -> instruction.offset then goto gen_lxl;
      547 		     end;
      548 
      549 		call flush_old(x);
      550 
      551 		call stack_temp$free_temp(p);
      552 		p -> reference.allocated = "0"b;
      553 		p -> reference.store_ins = "0"b;
      554 		p -> reference.value_in.storage = "0"b;
      555 
      556 l3:		index_regs(x).changed = text_pos;
      557 		text_pt = addrel(cg_stat$text_base,text_pos);
      558 
      559 		text_pt -> word = macro_table_$eax_array(n+x);
      560 
      561 		if c ^= 0
      562 		then do;
      563 		     if c > 0
      564 			then c1 = c;
      565 			else c1 = c + 262144;
      566 		     text_pt -> instruction.offset = bit(c1,18);
      567 		     end;
      568 
      569 		index_regs(x).instruction = text_pt -> full_word;
      570 
      571 		if ^p -> reference.shared
      572 		     then call adjust_ref_count(p,-1);
      573 		end;
      574 
      575 l4:
      576 	     index_regs(x).variable = p;
      577 	     if c = 0
      578 		then p -> reference.value_in.x(x) = "1"b;
      579 
      580 	     if p -> reference.symbol ^= null then p -> reference.perm_address = "0"b;
      581 
      582 	     index_regs(x).type = 2;
      583 	     index_regs(x).constant = c;
      584 	     index_regs(x).used = cg_stat$text_pos;
      585 	     end;
      586 
      587 
      588 
      589 
      590 load_xr_c:     proc(xr);
      591 
      592 dcl	     (x,xr) fixed bin;
      593 
      594 	     x = xr;
      595 
      596 	     call flush_old(x);
      597 
      598 	     index_regs(x).used = cg_stat$text_pos;
      599 	     call expmac(lxl0+x,c_a(const,2));
      600 	     index_regs(x).type = 1;
      601 	     index_regs(x).constant = const;
      602 	     end;
      603 
      604 
      605 /*  */
      606 flush_old:	proc(xr);
      607 
      608 dcl	     (xr,x) fixed bin;
      609 dcl	     old_p pointer;
      610 dcl	     macro fixed bin(15);
      611 
      612 	     x = xr;
      613 
      614 	     if index_regs(x).type < 2
      615 		then return;
      616 
      617 	     /* have a variable in the index register, if it is a temporary
      618*	        which doesn't exist in storage, we'll have to save it */
      619 
      620 	     old_p = index_regs(x).variable;
      621 	     old_p -> reference.value_in.x(x) = "0"b;
      622 
      623 	     if ^ old_p -> reference.temp_ref
      624 	      | old_p -> reference.value_in.storage
      625 	      | index_regs(x).constant ^= 0
      626 		then return;
      627 
      628 	     if old_p -> reference.ref_count > 0
      629 	     then do;
      630 		if old_p -> reference.symbol -> symbol.c_dcl_size >= bits_per_half
      631 		then do;
      632 		     old_p -> reference.ref_count = old_p -> reference.ref_count + 2;
      633 		     call expmac((zero_mac),old_p);
      634 		     macro = sxl0 + x;
      635 		     end;
      636 
      637 		else do;
      638 		     old_p -> reference.ref_count = old_p -> reference.ref_count + 1;
      639 
      640 		     /* convert the old reference in index register into
      641*		        a "packed" integer in storage */
      642 
      643 		     old_p -> reference.aligned_ref = "0"b;
      644 		     old_p -> reference.c_offset = 0;
      645 		     old_p -> reference.c_length = bits_per_half;
      646 		     old_p -> reference.units = word_;
      647 
      648 		     /* We set reference.dont_save as a
      649*		        kludge to fix bug 1599.  This
      650*		        prevents save_value from converting
      651*		        this back to an aligned temp,
      652*		        which could cause problems after
      653*		        an if statement. */
      654 
      655 		     old_p -> reference.dont_save = "1"b;
      656 		     macro = stx0 + x;
      657 		     end;
      658 
      659 		call expmac(macro,old_p);
      660 		old_p -> reference.value_in.storage = "1"b;
      661 
      662 		index_regs(x).used = cg_stat$text_pos;
      663 		end;
      664 	     end;
      665 
      666 
      667 	end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/03/83  1009.4  xr_man.pl1                        >spec>on>pl128d>xr_man.pl1
115          1    10/25/79  1645.8  cgsystem.incl.pl1                 >ldd>include>cgsystem.incl.pl1
116          2    05/03/76  1320.4  data_types.incl.pl1               >ldd>include>data_types.incl.pl1
117          3    10/25/79  1645.8  boundary.incl.pl1                 >ldd>include>boundary.incl.pl1
118          4    11/13/79  1015.8  machine_state.incl.pl1            >ldd>include>machine_state.incl.pl1
119          5    07/21/80  1546.3  reference.incl.pl1                >ldd>include>reference.incl.pl1
120          6    11/30/78  1227.4  temporary.incl.pl1                >ldd>include>temporary.incl.pl1
121          7    10/02/83  0828.4  symbol.incl.pl1                   >spec>on>pl128d>symbol.incl.pl1
122          8    07/21/80  1546.3  operator.incl.pl1                 >ldd>include>operator.incl.pl1
123          9    07/21/80  1546.3  nodes.incl.pl1                    >ldd>include>nodes.incl.pl1
124         10    09/14/77  1706.1  645op5.incl.pl1                   >ldd>include>645op5.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a                        11(09)        based           bit(1)                   level 4 packed unaligned dcl 5-3 ref 302 442
a_reg                     3            based           structure                level 2 dcl 4-6
abs                                                    builtin function         dcl 99 ref 133 151 161 171 240 246
addrel                                                 builtin function         dcl 99 ref 526 546 557
address                  10            based           structure                level 2 packed unaligned dcl 5-3 set ref 468
adjust_ref_count                000034 constant        entry                    external dcl 84 ref 155 194 470 571
aggregate                12(19)        based           bit(1)                   level 3 packed unaligned dcl 5-3 ref 479
aligned_ref              12(07)        based           bit(1)                   level 3 packed unaligned dcl 5-3 set ref 442 445 498
                                                                                  643*
allocated                12(15)        based           bit(1)                   level 3 packed unaligned dcl 5-3 set ref 552*
b18                             000167 automatic       bit(18)                  unaligned dcl 424 set ref 544* 546
base_offset                            parameter       fixed bin(18,0)          dcl 75 ref 73 139 147 272
bit                                                    builtin function         dcl 99 ref 468 514 544 566
bits                     12(06)        based           structure                level 2 packed unaligned dcl 5-3
bits_per_half                          constant        fixed bin(8,0)           initial dcl 1-5 ref 483 630 645
c                               000102 automatic       fixed bin(18,0)          dcl 84 set ref 147* 199* 255* 264* 267* 433 466 488
                                                                                  511 513* 561 563 563 565 577 583
c1                              000172 automatic       fixed bin(18,0)          dcl 424 set ref 433* 434 434* 434 466* 467 467* 467
                                                                                  468 563* 565* 566
c_a                             000026 constant        entry                    external dcl 84 ref 465 513 599 599
c_dcl_size               30            based           fixed bin(24,0)          level 2 dcl 7-3 ref 483 630
c_length                  2            based           fixed bin(24,0)          level 2 dcl 5-3 set ref 645*
c_offset                  1            based           fixed bin(24,0)          level 2 dcl 5-3 set ref 644*
cg_stat$cur_statement           000020 external static pointer                  dcl 79 set ref 415* 481*
cg_stat$last_call               000014 external static fixed bin(18,0)          dcl 79 ref 486
cg_stat$last_index_used         000010 external static fixed bin(17,0)          dcl 79 set ref 201* 218* 350* 359 359 368* 382* 403*
cg_stat$text_base               000016 external static pointer                  dcl 79 ref 526 546 557
cg_stat$text_pos                000012 external static fixed bin(18,0)          dcl 79 set ref 158 213 289 451 452* 452 545 584 598
                                                                                  662
cg_static_$m_s_p                000042 external static pointer                  dcl 4-3 ref 4-3
changed                  74            based           fixed bin(18,0)          array level 3 dcl 4-6 set ref 556*
cmin                            000136 automatic       fixed bin(17,0)          dcl 343 set ref 357* 386 389* 391 395*
const                                  parameter       fixed bin(18,0)          dcl 167 set ref 165 173 206 211 250 255 599* 599*
                                                                                  601
constant                 71            based           fixed bin(17,0)          array level 3 dcl 4-6 set ref 139 173 192 211 255
                                                                                  288* 466 583* 601* 623
data_type                12            based           fixed bin(5,0)           level 2 packed unaligned dcl 5-3 ref 494
dont_save                12(21)        based           bit(1)                   level 3 packed unaligned dcl 5-3 set ref 488 655*
eax0                                   constant        fixed bin(15,0)          initial dcl 10-1 ref 469 515
error                           000040 constant        entry                    external dcl 84 ref 415 481
expmac                          000024 constant        entry                    external dcl 84 ref 469 510 515 599 633 659
first_index                            constant        fixed bin(17,0)          initial dcl 110 ref 132 170 321 359
fixed                                                  builtin function         dcl 99 ref 485 514 544
full_word                              based           bit(36)                  dcl 103 ref 569
get_single_ref                  000030 constant        entry                    external dcl 84 ref 494
i                               000173 automatic       fixed bin(18,0)          dcl 424 in procedure "load_xr_v" set ref 545* 546*
i                               000103 automatic       fixed bin(17,0)          dcl 84 in procedure "xr_man$load_any_var" set ref
                                                                                  132* 133 134 135 138 139* 158 160 170* 171 172
                                                                                  173* 186* 190 191 192 201 208* 209 211 213 218
                                                                                  224* 225 226 227 281* 283* 285 286 287 288 289
                                                                                  321* 322 322*
i                               000134 automatic       fixed bin(17,0)          dcl 343 in procedure "get_free_index" set ref 359*
                                                                                  361 368 372 382 388 391 394*
ignore                          000137 automatic       fixed bin(17,0)          dcl 343 set ref 354* 363 409 411*
index_regs               70            based           structure                array level 2 dcl 4-6
info                     11            based           structure                level 2 packed unaligned dcl 5-3
instruction              75            based           bit(36)                  array level 3 in structure "machine_state" dcl 4-6
                                                                                  in procedure "xr_man$load_any_var" set ref 569*
instruction                            based           structure                level 1 dcl 105 in procedure "xr_man$load_any_var"
ix                                     parameter       fixed bin(17,0)          dcl 232 ref 230 234 238 240 240 244 246 246
j                               000135 automatic       fixed bin(17,0)          dcl 343 in procedure "get_free_index" set ref 356*
                                                                                  388* 391 394* 401 403
j                               000104 automatic       fixed bin(17,0)          dcl 84 in procedure "xr_man$load_any_var" set ref
                                                                                  130* 138* 200* 254* 255 257 259 301 456 465 466
k                               000105 automatic       fixed bin(17,0)          dcl 84 set ref 130* 134* 148* 150 169* 172* 181*
                                                                                  200* 317 317 320* 322* 348 350 368* 382* 403* 416*
last_index                             constant        fixed bin(17,0)          initial dcl 110 ref 132 170 321 359 359
ldx0                                   constant        fixed bin(15,0)          initial dcl 10-1 ref 498
location                  4            based           fixed bin(18,0)          level 2 dcl 6-3 ref 544
lock                            000107 automatic       bit(1)                   initial dcl 84 set ref 84* 151 161 274*
lxl0                                   constant        fixed bin(15,0)          initial dcl 10-1 ref 497 599
m_a                             000036 constant        entry                    external dcl 84 ref 315 504
m_s_p                           000110 automatic       pointer                  initial dcl 4-3 set ref 133 135 139 151 151 158 161
                                                                                  161 171 173 190 191 192 209 211 213 226 227 234
                                                                                  240 240 246 246 255 257 259 286 287 288 289 4-3*
                                                                                  317 322 361 372 391 391 442 442 445 466 492 556
                                                                                  569 575 582 583 584 598 600 601 614 620 623 662
machine_state                          based           structure                level 1 dcl 4-6
macro                           000220 automatic       fixed bin(15,0)          dcl 610 set ref 634* 656* 659*
macro_table_$eax_array          000022 external static fixed bin(15,0)          array dcl 79 ref 559
min                                                    builtin function         dcl 99 ref 359
mod                                                    builtin function         dcl 99 ref 544
n                               000140 automatic       fixed bin(17,0)          dcl 343 in procedure "get_free_index" set ref 374*
                                                                                  377* 378* 380 386 389 391 395
n                               000170 automatic       fixed bin(18,0)          dcl 424 in procedure "load_xr_v" set ref 438* 445*
                                                                                  447* 497* 498* 510 529* 530* 531* 559
no_address               10(27)        based           bit(1)                   level 3 packed unaligned dcl 5-3 ref 305
node                                   based           structure                level 1 dcl 9-27
null                                                   builtin function         dcl 99 ref 309 580
offset                   20            based           fixed bin(8,0)           level 3 in structure "machine_state" dcl 4-6
                                                                                  in procedure "xr_man$load_any_var" ref 442 442 445
offset                    5            based           pointer                  level 2 in structure "reference" packed unaligned
                                                                                  dcl 5-3 in procedure "xr_man$load_any_var" ref 309
                                                                                  328
offset                                 based           bit(18)                  level 2 in structure "instruction" packed unaligned
                                                                                  dcl 105 in procedure "xr_man$load_any_var" set ref
                                                                                  546 566*
old_p                           000216 automatic       pointer                  dcl 609 in procedure "flush_old" set ref 620* 621
                                                                                  623 623 628 630 632 632 633* 638 638 643 644 645
                                                                                  646 655 659* 660
old_p                           000162 automatic       pointer                  dcl 424 in procedure "load_xr_v" set ref 465* 468
                                                                                  469* 513* 514 515*
old_xr                                 parameter       fixed bin(17,0)          dcl 252 ref 250 254
op_code                         000174 automatic       bit(9)                   dcl 424 in procedure "load_xr_v" set ref 527* 529
                                                                                  530 531
op_code                   0(18)        based           bit(9)                   level 2 in structure "instruction" packed unaligned
                                                                                  dcl 105 in procedure "xr_man$load_any_var" ref 527
operand                   1            based           pointer                  array level 2 packed unaligned dcl 8-6 ref 310
operator                               based           structure                level 1 dcl 8-6
operator_node                          constant        bit(9)                   initial dcl 9-5 ref 310
p                               000122 automatic       pointer                  dcl 296 in procedure "when_to_m_a" set ref 309* 309*
                                                                                  310 310* 310 312 312 312* 328
p                               000142 automatic       pointer                  dcl 343 in procedure "get_free_index" set ref 372*
                                                                                  374 374 378
p                               000156 automatic       pointer                  dcl 424 in procedure "load_xr_v" set ref 431* 436
                                                                                  442 442 445 470 470* 475 477 479 481* 483 485 488
                                                                                  494 494* 498 498 544 551* 552 553 554 571 571* 575
                                                                                  577 580 580
perm_address             12(18)        based           bit(1)                   level 3 packed unaligned dcl 5-3 set ref 305 316*
                                                                                  502 505* 580*
q                               000160 automatic       pointer                  dcl 424 in procedure "load_xr_v" set ref 431* 494*
                                                                                  502 504* 505 510*
q                        11(10)        based           bit(1)                   level 4 in structure "reference" packed unaligned
                                                                                  dcl 5-3 in procedure "xr_man$load_any_var" ref 303
                                                                                  436
qualifier                 4            based           pointer                  level 2 packed unaligned dcl 5-3 ref 544
real_fix_bin_2                         constant        fixed bin(15,0)          initial dcl 2-1 ref 494
ref_count                 0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 5-3 set ref 261* 261
                                                                                  312 378 628 632* 632 638* 638
reference                              based           structure                level 1 dcl 5-3
shared                    0(11)        based           bit(1)                   level 2 packed unaligned dcl 5-3 ref 155 194 261 374
                                                                                  470 571
sta_code                               constant        bit(9)                   initial unaligned dcl 84 ref 529
stack_temp$free_temp            000032 constant        entry                    external dcl 84 ref 551
staq_code                              constant        bit(9)                   initial unaligned dcl 84 ref 531
storage                  11(23)        based           bit(1)                   level 4 packed unaligned dcl 5-3 set ref 475 554*
                                                                                  623 660*
store_ins                13(18)        based           bit(18)                  level 2 packed unaligned dcl 5-3 set ref 485 553*
stq_code                               constant        bit(9)                   initial unaligned dcl 84 ref 530
string                                                 builtin function         dcl 99 ref 304 312 468
stx0                                   constant        fixed bin(15,0)          initial dcl 10-1 ref 656
substr                                                 builtin function         dcl 99 set ref 468*
sxl0                                   constant        fixed bin(15,0)          initial dcl 10-1 ref 634
symbol                                 based           structure                level 1 dcl 7-3 in procedure "xr_man$load_any_var"
symbol                    3            based           pointer                  level 2 in structure "reference" packed unaligned
                                                                                  dcl 5-3 in procedure "xr_man$load_any_var" ref 483
                                                                                  580 630
tag                      10(30)        based           bit(6)                   level 3 packed unaligned dcl 5-3 set ref 514*
temp_ref                 12(11)        based           bit(1)                   level 3 packed unaligned dcl 5-3 ref 312 374 477 623
temporary                              based           structure                level 1 unaligned dcl 6-3
text_pos                        000171 automatic       fixed bin(18,0)          dcl 424 set ref 451* 485* 486 492 526 545 556 557
text_pt                         000164 automatic       pointer                  dcl 424 set ref 526* 527 557* 559 566 569
type                            000141 automatic       fixed bin(17,0)          dcl 343 in procedure "get_free_index" set ref 361*
                                                                                  363 363 366 366
type                            000106 automatic       fixed bin(17,0)          dcl 84 in procedure "xr_man$load_any_var" set ref
                                                                                  133* 134 135 171* 172 173
type                                   based           bit(9)                   level 2 in structure "node" packed unaligned
                                                                                  dcl 9-27 in procedure "xr_man$load_any_var" ref
                                                                                  310
type                     72            based           fixed bin(8,0)           array level 3 in structure "machine_state" dcl 4-6
                                                                                  in procedure "xr_man$load_any_var" set ref 133
                                                                                  151* 151 161* 161 171 190 209 227* 234* 240* 240
                                                                                  246* 246 257 286* 317 322 361 582* 600* 614
units                     0(14)        based           fixed bin(3,0)           level 2 packed unaligned dcl 5-3 set ref 498 646*
used                     73            based           fixed bin(18,0)          array level 3 dcl 4-6 set ref 158* 213* 289* 391 391
                                                                                  492 584* 598* 662*
value_in                 11(09)        based           structure                level 3 packed unaligned dcl 5-3
var                                    parameter       pointer                  dcl 75 ref 73 128 184 188 222 225 226 272 278 280
variable                 70            based           pointer                  array level 3 packed unaligned dcl 4-6 set ref 135
                                                                                  191 226* 259 287* 372 575* 620
vp                              000100 automatic       pointer                  dcl 84 set ref 128* 135 155 155* 188* 191 194 194*
                                                                                  259* 261 261 261 264* 280* 285 287 302 303 304 305
                                                                                  305 309 315* 316 415* 431
word                                   based           fixed bin(17,0)          dcl 101 set ref 559*
word_                                  constant        fixed bin(3,0)           initial dcl 3-5 ref 498 646
x                               000204 automatic       fixed bin(17,0)          dcl 592 in procedure "load_xr_c" set ref 594* 596*
                                                                                  598 599 600 601
x                               000166 automatic       fixed bin(17,0)          dcl 424 in procedure "load_xr_v" set ref 430* 448*
                                                                                  463* 469 492 508* 510 514 515 549* 556 559 569 575
                                                                                  577 582 583 584
x                        11(25)        based           bit(1)                   array level 4 in structure "reference" packed
                                                                                  unaligned dcl 5-3 in procedure
                                                                                  "xr_man$load_any_var" set ref 225* 285* 304 312
                                                                                  577* 621*
x                               000214 automatic       fixed bin(17,0)          dcl 608 in procedure "flush_old" set ref 612* 614
                                                                                  620 621 623 634 656 662
xr                                     parameter       fixed bin(17,0)          dcl 75 in procedure "xr_man$load_any_var" set ref 73
                                                                                  150* 151 151 160* 161 161 165 184 186 203* 206 208
                                                                                  217* 222 224 250 264* 267* 272 278 281
xr                                     parameter       fixed bin(17,0)          dcl 608 in procedure "flush_old" ref 606 612
xr                                     parameter       fixed bin(17,0)          dcl 422 in procedure "load_xr_v" ref 420 430
xr                                     parameter       fixed bin(17,0)          dcl 592 in procedure "load_xr_c" ref 590 594
zero_mac                               constant        fixed bin(15,0)          initial dcl 113 ref 633

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
adx0                                   internal static fixed bin(15,0)          initial dcl 10-1
adx1                                   internal static fixed bin(15,0)          initial dcl 10-1
adx2                                   internal static fixed bin(15,0)          initial dcl 10-1
adx3                                   internal static fixed bin(15,0)          initial dcl 10-1
adx4                                   internal static fixed bin(15,0)          initial dcl 10-1
adx5                                   internal static fixed bin(15,0)          initial dcl 10-1
adx6                                   internal static fixed bin(15,0)          initial dcl 10-1
adx7                                   internal static fixed bin(15,0)          initial dcl 10-1
array_node                             internal static bit(9)                   initial dcl 9-5
bit_                                   internal static fixed bin(3,0)           initial dcl 3-5
bit_string                             internal static fixed bin(15,0)          initial dcl 2-1
bits_per_char                          internal static fixed bin(8,0)           initial dcl 1-5
bits_per_four_words                    internal static fixed bin(8,0)           initial dcl 1-5
bits_per_packed_digit                  internal static fixed bin(8,1)           initial dcl 1-35
bits_per_two_words                     internal static fixed bin(8,0)           initial dcl 1-5
bits_per_word                          internal static fixed bin(8,0)           initial dcl 1-5
bits_per_words                         internal static fixed bin(8,0)           initial array dcl 1-5
block_node                             internal static bit(9)                   initial dcl 9-5
bound_node                             internal static bit(9)                   initial dcl 9-5
break_even_bits                        internal static fixed bin(8,0)           initial dcl 1-5
break_even_words                       internal static fixed bin(8,0)           initial dcl 1-5
by_name_agg_node                       internal static bit(9)                   initial dcl 9-5
char_string                            internal static fixed bin(15,0)          initial dcl 2-1
character_                             internal static fixed bin(3,0)           initial dcl 3-5
chars_per_word                         internal static fixed bin(8,0)           initial dcl 1-5
complex_fix_bin_1                      internal static fixed bin(15,0)          initial dcl 2-1
complex_fix_bin_2                      internal static fixed bin(15,0)          initial dcl 2-1
complex_fix_dec                        internal static fixed bin(15,0)          initial dcl 2-1
complex_flt_bin_1                      internal static fixed bin(15,0)          initial dcl 2-1
complex_flt_bin_2                      internal static fixed bin(15,0)          initial dcl 2-1
complex_flt_dec                        internal static fixed bin(15,0)          initial dcl 2-1
context_node                           internal static bit(9)                   initial dcl 9-5
convert_offset                         internal static fixed bin(8,1)           initial array dcl 1-35
convert_size                           internal static fixed bin(8,0)           initial array dcl 1-5
cross_reference_node                   internal static bit(9)                   initial dcl 9-5
default_fix_bin_p                      internal static fixed bin(8,0)           initial dcl 1-5
default_node                           internal static bit(9)                   initial dcl 9-5
digit_                                 internal static fixed bin(3,0)           initial dcl 3-5
entry_variable                         internal static fixed bin(15,0)          initial dcl 2-1
ext_entry_in                           internal static fixed bin(15,0)          initial dcl 2-1
ext_entry_out                          internal static fixed bin(15,0)          initial dcl 2-1
format_value_node                      internal static bit(9)                   initial dcl 9-5
half_                                  internal static fixed bin(3,0)           initial dcl 3-5
ind_arithmetic                         internal static fixed bin(17,0)          initial dcl 4-68
ind_decimal_reg                        internal static fixed bin(17,0)          initial dcl 4-68
ind_invalid                            internal static fixed bin(17,0)          initial dcl 4-68
ind_known_refs                         internal static fixed bin(17,0)          initial dcl 4-68
ind_logical                            internal static fixed bin(17,0)          initial dcl 4-68
ind_string_aq                          internal static fixed bin(17,0)          initial dcl 4-68
ind_x                                  internal static fixed bin(17,0)          initial array dcl 4-68
int_entry                              internal static fixed bin(15,0)          initial dcl 2-1
int_entry_other                        internal static fixed bin(15,0)          initial dcl 2-1
label_array_element_node               internal static bit(9)                   initial dcl 9-5
label_constant                         internal static fixed bin(15,0)          initial dcl 2-1
label_node                             internal static bit(9)                   initial dcl 9-5
label_size                             internal static fixed bin(8,0)           initial dcl 1-5
label_variable                         internal static fixed bin(15,0)          initial dcl 2-1
ldx1                                   internal static fixed bin(15,0)          initial dcl 10-1
ldx2                                   internal static fixed bin(15,0)          initial dcl 10-1
ldx3                                   internal static fixed bin(15,0)          initial dcl 10-1
ldx4                                   internal static fixed bin(15,0)          initial dcl 10-1
ldx5                                   internal static fixed bin(15,0)          initial dcl 10-1
ldx6                                   internal static fixed bin(15,0)          initial dcl 10-1
ldx7                                   internal static fixed bin(15,0)          initial dcl 10-1
list_node                              internal static bit(9)                   initial dcl 9-5
load_link_pt                           internal static fixed bin(15,0)          initial dcl 10-1
load_pt                                internal static fixed bin(15,0)          initial dcl 10-1
load_pt_reg                            internal static fixed bin(15,0)          initial dcl 10-1
local_label_variable                   internal static fixed bin(15,0)          initial dcl 2-1
lxl1                                   internal static fixed bin(15,0)          initial dcl 10-1
lxl2                                   internal static fixed bin(15,0)          initial dcl 10-1
lxl3                                   internal static fixed bin(15,0)          initial dcl 10-1
lxl4                                   internal static fixed bin(15,0)          initial dcl 10-1
lxl5                                   internal static fixed bin(15,0)          initial dcl 10-1
lxl6                                   internal static fixed bin(15,0)          initial dcl 10-1
lxl7                                   internal static fixed bin(15,0)          initial dcl 10-1
machine_state_node                     internal static bit(9)                   initial dcl 9-5
max_dec_scale                          internal static fixed bin(8,0)           initial dcl 1-5
max_index_register_value               internal static fixed bin(31,0)          initial dcl 1-38
max_length_p                           internal static fixed bin(8,0)           initial dcl 1-5
max_number_of_operands                 internal static fixed bin(15,0)          initial dcl 8-15
max_offset                             internal static fixed bin(8,0)           initial array dcl 1-5
max_p_fix_bin_1                        internal static fixed bin(8,0)           initial dcl 1-5
max_p_fix_dec                          internal static fixed bin(8,0)           initial dcl 1-5
max_p_flt_bin_1                        internal static fixed bin(8,0)           initial dcl 1-5
max_p_xreg                             internal static fixed bin(8,0)           initial dcl 1-5
max_short_size                         internal static fixed bin(8,0)           initial array dcl 1-5
min_dec_scale                          internal static fixed bin(8,0)           initial dcl 1-5
mod2_                                  internal static fixed bin(3,0)           initial dcl 3-5
mod4_                                  internal static fixed bin(3,0)           initial dcl 3-5
p                                      automatic       pointer                  dcl 84
packed_digits_per_char                 internal static fixed bin(8,0)           initial dcl 1-5
packed_digits_per_word                 internal static fixed bin(8,0)           initial dcl 1-5
packed_ptr                             internal static fixed bin(15,0)          initial dcl 2-1
ptr                                                    builtin function         dcl 99
real_fix_bin_1                         internal static fixed bin(15,0)          initial dcl 2-1
real_fix_dec                           internal static fixed bin(15,0)          initial dcl 2-1
real_flt_bin_1                         internal static fixed bin(15,0)          initial dcl 2-1
real_flt_bin_2                         internal static fixed bin(15,0)          initial dcl 2-1
real_flt_dec                           internal static fixed bin(15,0)          initial dcl 2-1
reference_node                         internal static bit(9)                   initial dcl 9-5
rel                                                    builtin function         dcl 99
set_ptr_to                             internal static fixed bin(15,0)          initial dcl 10-1
sf_par_node                            internal static bit(9)                   initial dcl 9-5
source_node                            internal static bit(9)                   initial dcl 9-5
statement_node                         internal static bit(9)                   initial dcl 9-5
store_pt                               internal static fixed bin(15,0)          initial dcl 10-1
symbol_node                            internal static bit(9)                   initial dcl 9-5
temporary_node                         internal static bit(9)                   initial dcl 9-5
token_node                             internal static bit(9)                   initial dcl 9-5
units_per_word                         internal static fixed bin(8,0)           initial array dcl 1-5
unpacked_ptr                           internal static fixed bin(15,0)          initial dcl 2-1

NAMES DECLARED BY EXPLICIT CONTEXT.
flush_old                       002123 constant        entry                    internal dcl 606 ref 283 448 463 508 549 596
gen_lxl                         001473 constant        label                    dcl 494 ref 477 479 483 486 488 531 546
get_free_index                  001032 constant        entry                    internal dcl 334 ref 146 180
join                            000030 constant        label                    dcl 128 ref 275
l2                              001311 constant        label                    dcl 448 ref 439
l3                              001737 constant        label                    dcl 556 ref 453
l4                              002012 constant        label                    dcl 575 ref 472
lc                              000403 constant        label                    dcl 217 ref 209
lc_used                         000373 constant        label                    dcl 213 ref 196
load_xr_c                       002044 constant        entry                    internal dcl 590 ref 181 217
load_xr_v                       001236 constant        entry                    internal dcl 420 ref 148 203
look                            001042 constant        label                    dcl 356 ref 412
lv                              000326 constant        label                    dcl 199 ref 190 191
ret_k                           000111 constant        label                    dcl 150 ref 182
set_i                           000147 constant        label                    dcl 158 ref 173
set_i_dec                       000131 constant        label                    dcl 155 ref 139
test                            001444 constant        label                    dcl 483 ref 475
when_to_m_a                     000676 constant        entry                    internal dcl 295 ref 145 202
xr_man$add_any_const            000541 constant        entry                    external dcl 250
xr_man$load_any_const           000201 constant        entry                    external dcl 165 ref 267
xr_man$load_any_var             000022 constant        entry                    external dcl 73 ref 264
xr_man$load_any_var_and_lock    000624 constant        entry                    external dcl 272
xr_man$load_const               000350 constant        entry                    external dcl 206
xr_man$load_var                 000256 constant        entry                    external dcl 184
xr_man$lock                     000417 constant        entry                    external dcl 222
xr_man$super_lock               000467 constant        entry                    external dcl 238
xr_man$super_unlock             000514 constant        entry                    external dcl 244
xr_man$unlock                   000447 constant        entry                    external dcl 230
xr_man$update_xr                000637 constant        entry                    external dcl 278

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2722        2766    2303        2732
Length      3416    2303        44         414     416           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
xr_man$load_any_var                 214 external procedure  is an external procedure.  
when_to_m_a                             internal procedure  shares stack frame of external procedure xr_man$load_any_var.  
get_free_index                          internal procedure  shares stack frame of external procedure xr_man$load_any_var.  
load_xr_v                               internal procedure  shares stack frame of external procedure xr_man$load_any_var.  
load_xr_c                               internal procedure  shares stack frame of external procedure xr_man$load_any_var.  
flush_old                               internal procedure  shares stack frame of external procedure xr_man$load_any_var.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
xr_man$load_any_var      000100 vp                          xr_man$load_any_var
                         000102 c                           xr_man$load_any_var
                         000103 i                           xr_man$load_any_var
                         000104 j                           xr_man$load_any_var
                         000105 k                           xr_man$load_any_var
                         000106 type                        xr_man$load_any_var
                         000107 lock                        xr_man$load_any_var
                         000110 m_s_p                       xr_man$load_any_var
                         000122 p                           when_to_m_a
                         000134 i                           get_free_index
                         000135 j                           get_free_index
                         000136 cmin                        get_free_index
                         000137 ignore                      get_free_index
                         000140 n                           get_free_index
                         000141 type                        get_free_index
                         000142 p                           get_free_index
                         000156 p                           load_xr_v
                         000160 q                           load_xr_v
                         000162 old_p                       load_xr_v
                         000164 text_pt                     load_xr_v
                         000166 x                           load_xr_v
                         000167 b18                         load_xr_v
                         000170 n                           load_xr_v
                         000171 text_pos                    load_xr_v
                         000172 c1                          load_xr_v
                         000173 i                           load_xr_v
                         000174 op_code                     load_xr_v
                         000204 x                           load_xr_c
                         000214 x                           flush_old
                         000216 old_p                       flush_old
                         000220 macro                       flush_old

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              unpk_to_pk          call_ext_in         call_ext_out        return              mod_fx1
ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
adjust_ref_count              c_a                           error                         expmac
get_single_ref                m_a                           stack_temp$free_temp

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
cg_stat$cur_statement         cg_stat$last_call             cg_stat$last_index_used       cg_stat$text_base
cg_stat$text_pos              cg_static_$m_s_p              macro_table_$eax_array




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     84 000007    4    3 000010        73 000016       128 000030       130 000034       132 000037       133 000047
    134 000057       135 000063       138 000072       139 000074       141 000100       145 000102       146 000103
    147 000104       148 000107       150 000111       151 000114       153 000130       155 000131       158 000147
    160 000156       161 000161       163 000174       165 000175       169 000207       170 000211       171 000221
    172 000231       173 000235       175 000244       180 000246       181 000247       182 000251       184 000252
    186 000264       188 000267       190 000272       191 000300       192 000305       194 000307       196 000325
    199 000326       200 000327       201 000332       202 000335       203 000336       204 000345       206 000346
    208 000356       209 000361       211 000367       213 000373       214 000402       217 000403       218 000411
    219 000414       222 000415       224 000425       225 000430       226 000435       227 000440       228 000443
    230 000444       234 000455       235 000464       238 000465       240 000475       241 000511       244 000512
    246 000522       247 000534       250 000535       254 000547       255 000552       257 000560       259 000564
    261 000566       264 000576       266 000610       267 000611       269 000621       272 000622       274 000632
    275 000634       278 000635       280 000645       281 000651       283 000653       285 000655       286 000662
    287 000670       288 000671       289 000672       290 000675       295 000676       301 000677       302 000702
    303 000707       304 000713       305 000717       309 000726       310 000734       312 000743       315 000757
    316 000772       317 000775       320 001003       321 001005       322 001015       324 001023       326 001025
    328 001026       329 001031       334 001032       348 001033       350 001035       351 001037       354 001040
    356 001042       357 001044       359 001046       361 001061       363 001067       366 001072       368 001076
    369 001102       372 001103       374 001106       377 001116       378 001121       380 001125       382 001127
    383 001133       386 001134       388 001136       389 001140       390 001142       391 001143       394 001152
    395 001154       399 001156       401 001202       403 001204       404 001207       409 001210       411 001213
    412 001215       415 001216       416 001233       417 001235       420 001236       430 001240       431 001242
    433 001245       434 001247       436 001252       438 001256       439 001257       442 001260       445 001300
    447 001307       448 001311       451 001313       452 001316       453 001317       456 001320       463 001322
    465 001324       466 001343       467 001352       468 001355       469 001363       470 001377       472 001415
    475 001416       477 001421       479 001424       481 001427       483 001444       485 001451       486 001455
    488 001460       492 001465       494 001473       497 001511       498 001513       502 001526       504 001532
    505 001545       508 001550       510 001552       511 001566       513 001570       514 001605       515 001616
    517 001632       526 001633       527 001640       529 001644       530 001651       531 001655       544 001660
    545 001673       546 001705       547 001715       549 001717       551 001721       552 001730       553 001733
    554 001735       556 001737       557 001745       559 001752       561 001756       563 001761       565 001764
    566 001766       569 001773       571 001775       575 002012       577 002017       580 002026       582 002033
    583 002036       584 002040       585 002043       590 002044       594 002046       596 002050       598 002052
    599 002061       600 002113       601 002117       602 002122       606 002123       612 002125       614 002127
    620 002136       621 002141       623 002145       628 002156       630 002162       632 002167       633 002172
    634 002205       635 002210       638 002211       643 002214       644 002216       645 002217       646 002221
    655 002225       656 002227       659 002232       660 002243       662 002246       664 002253


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
