	COMPILATION LISTING OF SEGMENT mlsys_storage_mgr_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 03/15/89  0832.4 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 
        9 /****^  HISTORY COMMENTS:
       10*  1) change(89-03-07,TLNguyen), approve(89-03-07,MCR8049),
       11*     audit(89-03-07,Parisek), install(89-03-15,MR12.3-1025):
       12*     Initialize local_cbi structure using the unspec builtin function.
       13*                                                   END HISTORY COMMENTS */
       14 
       15 
       16 /* format: off */
       17 
       18 /* Area and temporary segment manager for the inner-ring portion of the Multics Mail System */
       19 
       20 /* Created:  July 1983 by G. Palter */
       21 /* Modified: December 1984 by Keith Loepere for version 2 create_branch_info. */
       22 /* format: on,style4,delnl,insnl,ifthenstmt,ifthen */
       23 
       24 
       25 mlsys_storage_mgr_:
       26      procedure ();
       27 
       28 	return;					/* not an entrypoint */
       29 
       30 
       31 /* Control arrives here when errors are detected in code which has lowered the validation level */
       32 
       33 RESTORE_LEVEL_AND_RETURN_WITH_ERROR:
       34 	call cu_$level_set (old_validation_level);
       35 	P_code = code;
       36 	return;
       37 
       38 
       39 /* allocate Parameters */
       40 
       41 dcl  P_n_words fixed binary (18) parameter;		/* # of words in the block to be allocated */
       42 dcl  P_area_ptr pointer parameter;			/* -> area in which to allocate the block */
       43 dcl  P_allocation_ptr pointer parameter;		/* set -> the block allocated */
       44 
       45 
       46 /* get_temp_segment/release_temp_segment Parameters */
       47 
       48 dcl  P_segment_ptr pointer parameter;			/* get_temp_segment: set -> the segment just created;
       49*						   release_temp_segment: -> the segment to be released */
       50 dcl  P_code fixed binary (35) parameter;
       51 
       52 
       53 /* Local copies of parameters */
       54 
       55 dcl  requested_space (P_n_words) bit (36) aligned based (P_allocation_ptr);
       56 dcl  callers_area area based (P_area_ptr);
       57 
       58 dcl  segment_ptr pointer;
       59 dcl  code fixed binary (35);
       60 
       61 
       62 /* List of temporary segments created by the mail system:  Only the UID of each segment is maintained as it is all that is
       63*   needed to vaildate that a segment to be released was, indeed, created by this manager */
       64 
       65 dcl  1 temp_segment_list aligned based (mlsys_data_$temp_segment_list_ptr),
       66        2 n_uids fixed binary,				/* # of UID slots */
       67        2 uids (temp_segment_list_n_uids refer (temp_segment_list.n_uids)) bit (36) aligned;
       68 						/* the actual UIDs: a value of ""b indicates an unused slot */
       69 
       70 dcl  temp_segment_list_n_uids fixed binary;		/* for allocating the above */
       71 
       72 
       73 /* Remaining declarations */
       74 
       75 dcl  system_area area based (system_area_ptr);
       76 dcl  system_area_ptr pointer;
       77 
       78 dcl  1 local_ai aligned like area_info;
       79 
       80 dcl  1 local_cbi aligned like create_branch_info;
       81 
       82 dcl  old_validation_level fixed binary (3);
       83 
       84 dcl  dirname character (168);
       85 dcl  ename character (32);
       86 dcl  segment_uid bit (36) aligned;
       87 dcl  found bit (1) aligned;
       88 dcl  list_idx fixed binary;
       89 
       90 dcl  MAIL_SYSTEM_ character (32) static options (constant) initial ("mail_system_");
       91 
       92 dcl  sys_info$max_seg_size fixed binary (19) external;
       93 
       94 dcl  mlsys_et_$not_temporary_segment fixed binary (35) external;
       95 
       96 dcl  cu_$level_get entry (fixed binary (3));
       97 dcl  cu_$level_set entry (fixed binary (3));
       98 dcl  define_area_ entry (pointer, fixed binary (35));
       99 dcl  get_group_id_$tag_star entry () returns (character (32));
      100 dcl  get_pdir_ entry () returns (character (168));
      101 dcl  get_ring_ entry () returns (fixed binary (3));
      102 dcl  get_system_free_area_ entry () returns (pointer);
      103 dcl  hcs_$create_branch_ entry (character (*), character (*), pointer, fixed binary (35));
      104 dcl  hcs_$get_uid_seg entry (pointer, bit (36) aligned, fixed binary (35));
      105 dcl  initiate_file_ entry (character (*), character (*), bit (*), pointer, fixed binary (24), fixed binary (35));
      106 dcl  sub_err_ entry () options (variable);
      107 dcl  terminate_file_ entry (pointer, fixed binary (24), bit (*), fixed binary (35));
      108 dcl  unique_chars_ entry (bit (*)) returns (character (15));
      109 
      110 dcl  cleanup condition;
      111 
      112 dcl  (addr, baseno, binary, null, string, unspec) builtin;
      113 
      114 /* Per-process initialization: creates the mail system's extensible area with appropriate ring brackets */
      115 
      116 initialize:
      117      entry ();
      118 
      119 	call cu_$level_get (old_validation_level);
      120 
      121 	on condition (cleanup)
      122 	     begin;
      123 		call cu_$level_set (old_validation_level);
      124 	     end;
      125 
      126 	call cu_$level_set (get_ring_ ());
      127 
      128 	system_area_ptr = get_system_free_area_ ();
      129 
      130 	temp_segment_list_n_uids = 32;		/* probably will never have this many at a time, but ... */
      131 	allocate temp_segment_list in (system_area) set (mlsys_data_$temp_segment_list_ptr);
      132 	unspec (temp_segment_list.uids) = ""b;
      133 
      134 	string (mlsys_data_$valid_segments) = ""b;	/* nothing has been allocated anywhere yet */
      135 
      136 	call get_temp_segment (mlsys_data_$subsystem_area_ptr, code);
      137 	if code ^= 0 then do;			/* grumble: impossible to initialize the mail system ... */
      138 RESIGNAL_INITIALIZATION_FAILURE:
      139 	     call sub_err_ (code, MAIL_SYSTEM_, ACTION_CANT_RESTART, null (), (0),
      140 		"Unable to initialize the mail system storage manager.^/Contact your system programming staff.");
      141 	     go to RESIGNAL_INITIALIZATION_FAILURE;
      142 	end;
      143 
      144 	local_ai.version = area_info_version_1;
      145 	string (local_ai.control) = ""b;
      146 	local_ai.extend = "1"b;			/* an extensible area ... */
      147 	local_ai.zero_on_free = "1"b;			/* ... which is "reset" on each freeing operation ... */
      148 	local_ai.system = "1"b;			/* ... and should be extended with ring bracket copying */
      149 	local_ai.owner = MAIL_SYSTEM_;
      150 	local_ai.size = sys_info$max_seg_size;
      151 	local_ai.areap = mlsys_data_$subsystem_area_ptr;
      152 
      153 	call define_area_ (addr (local_ai), code);
      154 	if code ^= 0 then go to RESIGNAL_INITIALIZATION_FAILURE;
      155 
      156 	call cu_$level_set (old_validation_level);
      157 
      158 	return;
      159 
      160 /* Allocates a block of storage: replaces the standard PL/I allocate operator for all mail system inner-ring code through
      161*   use of the "options (rename ((alloc_, mlsys_storage_mgr_$allocate)))" clause.  In order to bypass a "bug" in the
      162*   treatment of extensible areas, this entrypoint will set the proper validation level before actually allocating the
      163*   requested storage.  In addition, this entrypoint remembers maintains a list of the segments in which it has performed
      164*   an allocation; this list is used by the remainder of the mail system to verify that a pointer supplied by the user-ring
      165*   is "valid" */
      166 
      167 allocate:
      168      entry (P_n_words, P_area_ptr, P_allocation_ptr);
      169 
      170 	call cu_$level_get (old_validation_level);
      171 
      172 	on condition (cleanup)
      173 	     begin;
      174 		call cu_$level_set (old_validation_level);
      175 	     end;
      176 
      177 	call cu_$level_set (get_ring_ ());
      178 
      179 	allocate requested_space in (callers_area) set (P_allocation_ptr);
      180 
      181 	mlsys_data_$valid_segments (binary (baseno (P_allocation_ptr), 18, 0)) = "1"b;
      182 
      183 	call cu_$level_set (old_validation_level);
      184 
      185 	return;
      186 
      187 /* Fetches a temporary segment and insures that its contents are accesible from the user-ring */
      188 
      189 get_temp_segment:
      190      entry (P_segment_ptr, P_code);
      191 
      192           unspec (local_cbi) = ""b;
      193 
      194 	local_cbi.version = create_branch_version_2;
      195 	local_cbi.parent_ac_sw = "1"b;
      196 	local_cbi.mode = RW_ACCESS;
      197 	local_cbi.rings (1) = get_ring_ ();		/* writable only to the mail system ... */
      198 	local_cbi.rings (2),			/* ... but readable in appropriate outer rings */
      199 	     local_cbi.rings (3) = mlsys_data_$highest_usable_ring;
      200 	local_cbi.userid = get_group_id_$tag_star ();
      201 
      202 	dirname = get_pdir_ ();
      203 	ename = unique_chars_ (""b) || ".temp.mail_system";
      204 
      205 	call cu_$level_get (old_validation_level);
      206 
      207 	on condition (cleanup)
      208 	     begin;
      209 		call cu_$level_set (old_validation_level);
      210 	     end;
      211 
      212 	call cu_$level_set (get_ring_ ());
      213 
      214 	call hcs_$create_branch_ (dirname, ename, addr (local_cbi), code);
      215 	if code ^= 0 then go to RESTORE_LEVEL_AND_RETURN_WITH_ERROR;
      216 
      217 	call initiate_file_ (dirname, ename, RW_ACCESS, segment_ptr, (0), code);
      218 	if code ^= 0 then go to RESTORE_LEVEL_AND_RETURN_WITH_ERROR;
      219 
      220 	call hcs_$get_uid_seg (segment_ptr, segment_uid, code);
      221 	if code ^= 0 then go to RESTORE_LEVEL_AND_RETURN_WITH_ERROR;
      222 
      223 	list_idx = find_empty_temp_segment_list_slot ();	/* will grow the list if necessary */
      224 
      225 	temp_segment_list.uids (list_idx) = segment_uid;	/* needed to validate subsequent attempts to release it */
      226 
      227 	call cu_$level_set (old_validation_level);
      228 
      229 	mlsys_data_$valid_segments (binary (baseno (segment_ptr), 18, 0)) = "1"b;
      230 
      231 	P_segment_ptr = segment_ptr;			/* success */
      232 	P_code = 0;
      233 
      234 	return;
      235 
      236 /* Releases a temporary segment obtained by a call to the above get_temp_segment entrypoint */
      237 
      238 release_temp_segment:
      239      entry (P_segment_ptr, P_code);
      240 
      241 	segment_ptr = P_segment_ptr;			/* copy parameters */
      242 	P_segment_ptr = null ();			/* so the caller won't try twice */
      243 
      244 	call cu_$level_get (old_validation_level);
      245 
      246 	on condition (cleanup)
      247 	     begin;
      248 		call cu_$level_set (old_validation_level);
      249 	     end;
      250 
      251 	call cu_$level_set (get_ring_ ());
      252 
      253 	call hcs_$get_uid_seg (segment_ptr, segment_uid, code);
      254 	if code ^= 0 then go to RESTORE_LEVEL_AND_RETURN_WITH_ERROR;
      255 
      256 	found = "0"b;				/* check that we created this segment */
      257 	do list_idx = 1 to temp_segment_list.n_uids while (^found);
      258 	     if segment_uid = temp_segment_list.uids (list_idx) then do;
      259 		temp_segment_list.uids (list_idx) = ""b;/* ... we did create it: remove it from our list now */
      260 		found = "1"b;
      261 	     end;
      262 	end;
      263 
      264 	if ^found then do;				/* not one of our temporary segments */
      265 	     code = mlsys_et_$not_temporary_segment;
      266 	     go to RESTORE_LEVEL_AND_RETURN_WITH_ERROR;
      267 	end;
      268 
      269 	call terminate_file_ (segment_ptr, 0, TERM_FILE_DELETE, code);
      270 	if code ^= 0 then go to RESTORE_LEVEL_AND_RETURN_WITH_ERROR;
      271 
      272 	call cu_$level_set (old_validation_level);
      273 
      274 	P_code = 0;				/* success */
      275 
      276 	return;
      277 
      278 /* Finds an unused slot in the list of temporary segments managed by the mail system */
      279 
      280 find_empty_temp_segment_list_slot:
      281      procedure () returns (fixed binary);
      282 
      283 dcl  (new_temp_segment_list_ptr, old_temp_segment_list_ptr) pointer;
      284 dcl  idx fixed binary;
      285 
      286 	do idx = 1 to temp_segment_list.n_uids;
      287 	     if temp_segment_list.uids (idx) = ""b then return (idx);
      288 	end;
      289 
      290 	/*** here iff there are no free slots: grow the list */
      291 
      292 	system_area_ptr = get_system_free_area_ ();
      293 
      294 	temp_segment_list_n_uids = 2 * temp_segment_list.n_uids;
      295 	allocate temp_segment_list in (system_area) set (new_temp_segment_list_ptr);
      296 
      297 	unspec (new_temp_segment_list_ptr -> temp_segment_list.uids) = ""b;
      298 
      299 	do idx = 1 to temp_segment_list.n_uids;		/* copy in the old values */
      300 	     new_temp_segment_list_ptr -> temp_segment_list.uids (idx) = temp_segment_list.uids (idx);
      301 	end;
      302 	idx = temp_segment_list.n_uids + 1;		/* first free slot */
      303 
      304 	old_temp_segment_list_ptr = mlsys_data_$temp_segment_list_ptr;
      305 	mlsys_data_$temp_segment_list_ptr = new_temp_segment_list_ptr;
      306 
      307 	free old_temp_segment_list_ptr -> temp_segment_list;
      308 
      309 	return (idx);
      310 
      311      end find_empty_temp_segment_list_slot;
      312 
  1     1 /* BEGIN INCLUDE FILE ... mlsys_internal_data.incl.pl1 */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(86-06-11,Mills), approve(86-06-11,MCR7419),
  1     6*     audit(86-06-17,Margolin), install(86-06-30,MR12.0-1080):
  1     7*     Added mlsys_data_$domains_available.
  1     8*                                                   END HISTORY COMMENTS */
  1     9 
  1    10 
  1    11 /* Created:  May 1981 by G. Palter */
  1    12 /* Modified: July 1983 by G. Palter to merge with mlsys_data_ */
  1    13 
  1    14 /* Constants used internally by the Multics mail system */
  1    15 
  1    16 dcl  mlsys_data_$max_opening_retries fixed binary external; /* maximum number of times to reopen a mailbox if it gets
  1    17*                                                               damaged and salvaged while open */
  1    18 
  1    19 dcl  mlsys_data_$max_lock_wait_retries fixed binary external;
  1    20                                                             /* maximum number of times to try to send a message while the
  1    21*                                                               mailbox is locked (being salvaged?) */
  1    22 
  1    23 
  1    24 /* Allocation overhead factors:  When allocating those structures with refer extents, insure that the variable portion of
  1    25*   the structure contains a multiple of the appropriate constant number of slots.  These extra slots will be used for
  1    26*   later additions to the structure; when a new element must be added to a full structure, add this many new slots (rather
  1    27*   than a single new slot)
  1    28*
  1    29*   The following expression should be used to determine the initial allocation:
  1    30*
  1    31*          n_slots_to_allocate = n_slots_needed + CONSTANT - mod (n_slots_needed, CONSTANT); */
  1    32 
  1    33 dcl (mlsys_data_$mailbox_allocation,                        /* mailbox.messages */
  1    34      mlsys_data_$message_body_sections_allocation,          /* message.body_sections */
  1    35      mlsys_data_$message_redistributions_list_allocation,   /* message_redistributions_list.redistributions */
  1    36      mlsys_data_$message_user_fields_allocation,            /* message_user_fields_list.user_fields */
  1    37      mlsys_data_$message_references_list_allocation,        /* message_references_list.references */
  1    38      mlsys_data_$address_list_allocation)                   /* address_list.addresses */
  1    39           fixed binary external;
  1    40 
  1    41 
  1    42 /* Static data user by the Multics mail system */
  1    43 
  1    44 dcl (mlsys_data_$forum_not_available,                       /* 1 => forum isn't available on the system or in this ring */
  1    45      mlsys_data_$ism_not_available,                         /* 1 => no inter-system mailer on this system */
  1    46      mlsys_data_$domains_available)                         /* 1 =>  domain name system software on this sytem */
  1    47           fixed binary (1) external;
  1    48 
  1    49 dcl (mlsys_data_$subsystem_ring,                            /* ring in which the mail system is secured */
  1    50      mlsys_data_$highest_usable_ring,                       /* highest ring of execution which may use the mail system */
  1    51      mlsys_data_$lowest_forum_ring)                         /* lowest ring of execution with access to forum */
  1    52           fixed binary (3) external;
  1    53 
  1    54 dcl  mlsys_data_$temp_segment_list_ptr pointer external;    /* -> list of all mail system temporary segments */
  1    55 
  1    56 dcl  mlsys_data_$valid_segments (0:4095) bit (1) unaligned external;
  1    57                                                             /* indicates which segments have been used by the mail system
  1    58*                                                               for the allocation of user-visible data in order to
  1    59*                                                               validate that pointers passed from the user-ring are OK */
  1    60 
  1    61 dcl  mlsys_area area based (mlsys_data_$subsystem_area_ptr);/* area used for all user-visible allocations ... */
  1    62 dcl  mlsys_data_$subsystem_area_ptr pointer external;       /* ... and the pointer on which it is based */
  1    63 
  1    64 dcl  mlsys_data_$hash_tables_segment_ptr pointer external;  /* -> hash tables used by the mail system */
  1    65 
  1    66 dcl  mlsys_data_$transmit_cache_ptr pointer external;       /* -> cache of recently used mailboxes for mlsys_transmit_ */
  1    67 
  1    68 dcl  mlsys_data_$user_is_anonymous bit (1) aligned external;/* ON => the user is an anonymous user */
  1    69 
  1    70 dcl  mlsys_data_$person_id character (24) varying external; /* the user's Person_id */
  1    71 dcl  mlsys_data_$project_id character (12) varying external;/* the user's Project_id */
  1    72 dcl  mlsys_data_$user_id character (32) varying external;   /* the user's User_id (Person_id.Project_id) */
  1    73 
  1    74 /* END INCLUDE FILE ... mlsys_internal_data.incl.pl1 */
      313 
      314 
  2     1 /*  BEGIN INCLUDE FILE - - - create_branch_info.incl.pl1 - - - created January 1975 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(89-01-16,TLNguyen), approve(89-01-16,MCR8049),
  2     6*     audit(89-02-03,Parisek), install(89-03-15,MR12.3-1025):
  2     7*       1. Declare version constant properly.
  2     8*       2. Remove version 1 since it was never referenced and to force
  2     9*          callers to upgrade their programs.
  2    10*                                                   END HISTORY COMMENTS */
  2    11 
  2    12 
  2    13 /* Modified December 1984 for dir_quota, Keith Loepere. */
  2    14 
  2    15 /* this include files gives the argument structure for create_branch_ */
  2    16 
  2    17 dcl 1 create_branch_info aligned based,
  2    18     2 version fixed bin,				/* set this to the largest value given below */
  2    19     2 switches unaligned,
  2    20       3 dir_sw bit (1) unaligned,			/* if on, a directory branch is wanted */
  2    21       3 copy_sw bit (1) unaligned,			/* if on, initiating segment will be done by copying */
  2    22       3 chase_sw bit (1) unaligned,			/* if on, if pathname is a link, it will be chased */
  2    23       3 priv_upgrade_sw bit (1) unaligned,		/* privileged creation (ring 1) of upgraded object */
  2    24       3 parent_ac_sw bit (1) unaligned,			/* if on, use parent's access class for seg or dir created */
  2    25       3 mbz1 bit (31) unaligned,			/* pad to full word */
  2    26     2 mode bit (3) unaligned,				/* segment or directory for acl for userid */
  2    27     2 mbz2 bit (33) unaligned,			/* pad to full word */
  2    28     2 rings (3) fixed bin (3),			/* branch's ring brackets */
  2    29     2 userid char (32),				/* user's access control name */
  2    30     2 bitcnt fixed bin (24),				/* bit count of the segment */
  2    31     2 quota fixed bin (18),				/* for directories, this am't of quota will be moved to it */
  2    32     2 access_class bit (72),				/* is the access class of the body of the branch */
  2    33     2 dir_quota fixed bin (18);			/* for directories, this am't of dir quota will be moved to it */
  2    34 
  2    35 dcl  create_branch_version_2 fixed bin int static options (constant) init (2);
  2    36 
  2    37 /* END INCLUDE FILE - - - create_branch_info.incl.pl1 - - - */
  2    38 
      315 
      316 
  3     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  3     2*
  3     3*   Values for the "access mode" argument so often used in hardcore
  3     4*   James R. Davis 26 Jan 81  MCR 4844
  3     5*   Added constants for SM access 4/28/82 Jay Pattin
  3     6*   Added text strings 03/19/85 Chris Jones
  3     7**/
  3     8 
  3     9 
  3    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  3    11 dcl	(
  3    12 	N_ACCESS		   init ("000"b),
  3    13 	R_ACCESS		   init ("100"b),
  3    14 	E_ACCESS		   init ("010"b),
  3    15 	W_ACCESS		   init ("001"b),
  3    16 	RE_ACCESS		   init ("110"b),
  3    17 	REW_ACCESS	   init ("111"b),
  3    18 	RW_ACCESS		   init ("101"b),
  3    19 	S_ACCESS		   init ("100"b),
  3    20 	M_ACCESS		   init ("010"b),
  3    21 	A_ACCESS		   init ("001"b),
  3    22 	SA_ACCESS		   init ("101"b),
  3    23 	SM_ACCESS		   init ("110"b),
  3    24 	SMA_ACCESS	   init ("111"b)
  3    25 	)		   bit (3) internal static options (constant);
  3    26 
  3    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  3    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  3    29 
  3    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  3    31 			   static options (constant);
  3    32 
  3    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  3    34 			   static options (constant);
  3    35 
  3    36 dcl	(
  3    37 	N_ACCESS_BIN	   init (00000b),
  3    38 	R_ACCESS_BIN	   init (01000b),
  3    39 	E_ACCESS_BIN	   init (00100b),
  3    40 	W_ACCESS_BIN	   init (00010b),
  3    41 	RW_ACCESS_BIN	   init (01010b),
  3    42 	RE_ACCESS_BIN	   init (01100b),
  3    43 	REW_ACCESS_BIN	   init (01110b),
  3    44 	S_ACCESS_BIN	   init (01000b),
  3    45 	M_ACCESS_BIN	   init (00010b),
  3    46 	A_ACCESS_BIN	   init (00001b),
  3    47 	SA_ACCESS_BIN	   init (01001b),
  3    48 	SM_ACCESS_BIN	   init (01010b),
  3    49 	SMA_ACCESS_BIN	   init (01011b)
  3    50 	)		   fixed bin (5) internal static options (constant);
  3    51 
  3    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      317 
      318 
  4     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  4     2 /* format: style2,^inddcls,idind32 */
  4     3 
  4     4 declare 1 terminate_file_switches	based,
  4     5 	2 truncate		bit (1) unaligned,
  4     6 	2 set_bc			bit (1) unaligned,
  4     7 	2 terminate		bit (1) unaligned,
  4     8 	2 force_write		bit (1) unaligned,
  4     9 	2 delete			bit (1) unaligned;
  4    10 
  4    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  4    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  4    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  4    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  4    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  4    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  4    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  4    18 
  4    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
      319 
      320 
  5     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  5     2 
  5     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  5     4 
  5     5 dcl  area_infop ptr;
  5     6 
  5     7 dcl 1 area_info aligned based (area_infop),
  5     8     2 version fixed bin,				/* version number for this structure is 1 */
  5     9     2 control aligned like area_control,		/* control bits for the area */
  5    10     2 owner char (32) unal,				/* creator of the area */
  5    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  5    12     2 size fixed bin (18),				/* size of the area in words */
  5    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  5    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  5    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  5    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  5    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  5    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  5    19 
  5    20 dcl 1 area_control aligned based,
  5    21     2 extend bit (1) unal,				/* says area is extensible */
  5    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  5    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  5    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  5    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  5    26     2 system bit (1) unal,				/* says area is managed by system */
  5    27     2 pad bit (30) unal;
  5    28 
  5    29 /* END INCLUDE FILE area_info.incl.pl1 */
      321 
      322 
  6     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  6     2 /* format: style3 */
  6     3 
  6     4 /* These constants are to be used for the flags argument of sub_err_ */
  6     5 /* They are just "string (condition_info_header.action_flags)" */
  6     6 
  6     7 declare	(
  6     8 	ACTION_CAN_RESTART	init (""b),
  6     9 	ACTION_CANT_RESTART init ("1"b),
  6    10 	ACTION_DEFAULT_RESTART
  6    11 			init ("01"b),
  6    12 	ACTION_QUIET_RESTART
  6    13 			init ("001"b),
  6    14 	ACTION_SUPPORT_SIGNAL
  6    15 			init ("0001"b)
  6    16 	)		bit (36) aligned internal static options (constant);
  6    17 
  6    18 /* End include file */
      323 
      324 
      325      end mlsys_storage_mgr_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/15/89  0759.4  mlsys_storage_mgr_.pl1            >special_ldd>install>MR12.3-1025>mlsys_storage_mgr_.pl1
313          1    06/30/86  2023.8  mlsys_internal_data.incl.pl1      >ldd>include>mlsys_internal_data.incl.pl1
315          2    03/15/89  0759.4  create_branch_info.incl.pl1       >special_ldd>install>MR12.3-1025>create_branch_info.incl.pl1
317          3    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
319          4    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
321          5    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
323          6    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000016 constant        bit(36)                  initial dcl 6-7 set ref 138*
MAIL_SYSTEM_                    000002 constant        char(32)                 initial packed unaligned dcl 90 set ref 138* 149
P_allocation_ptr                       parameter       pointer                  dcl 43 set ref 167 179* 181
P_area_ptr                             parameter       pointer                  dcl 42 ref 167 179
P_code                                 parameter       fixed bin(35,0)          dcl 50 set ref 35* 189 232* 238 274*
P_n_words                              parameter       fixed bin(18,0)          dcl 41 ref 167 179
P_segment_ptr                          parameter       pointer                  dcl 48 set ref 189 231* 238 241 242*
RW_ACCESS                       000001 constant        bit(3)                   initial packed unaligned dcl 3-11 set ref 196 217*
TERM_FILE_DELETE                000000 constant        bit(5)                   initial packed unaligned dcl 4-17 set ref 269*
addr                                                   builtin function         dcl 112 ref 153 153 214 214
area_control                           based           structure                level 1 dcl 5-20
area_info                              based           structure                level 1 dcl 5-7
area_info_version_1                    constant        fixed bin(17,0)          initial dcl 5-3 ref 144
areap                    16     000106 automatic       pointer                  level 2 dcl 78 set ref 151*
baseno                                                 builtin function         dcl 112 ref 181 229
binary                                                 builtin function         dcl 112 ref 181 229
callers_area                           based           area(1024)               dcl 56 ref 179
cleanup                         000244 stack reference condition                dcl 110 ref 121 172 207 246
code                            000102 automatic       fixed bin(35,0)          dcl 59 set ref 35 136* 137 138* 153* 154 214* 215
                                                                                  217* 218 220* 221 253* 254 265* 269* 270
control                   1     000106 automatic       structure                level 2 dcl 78 set ref 145*
create_branch_info                     based           structure                level 1 dcl 2-17
create_branch_version_2                constant        fixed bin(17,0)          initial dcl 2-35 ref 194
cu_$level_get                   000014 constant        entry                    external dcl 96 ref 119 170 205 244
cu_$level_set                   000016 constant        entry                    external dcl 97 ref 33 123 126 156 174 177 183 209
                                                                                  212 227 248 251 272
define_area_                    000020 constant        entry                    external dcl 98 ref 153
dirname                         000156 automatic       char(168)                packed unaligned dcl 84 set ref 202* 214* 217*
ename                           000230 automatic       char(32)                 packed unaligned dcl 85 set ref 203* 214* 217*
extend                    1     000106 automatic       bit(1)                   level 3 packed packed unaligned dcl 78 set ref 146*
found                           000241 automatic       bit(1)                   dcl 87 set ref 256* 257 260* 264
get_group_id_$tag_star          000022 constant        entry                    external dcl 99 ref 200
get_pdir_                       000024 constant        entry                    external dcl 100 ref 202
get_ring_                       000026 constant        entry                    external dcl 101 ref 126 126 177 177 197 212 212 251
                                                                                  251
get_system_free_area_           000030 constant        entry                    external dcl 102 ref 128 292
hcs_$create_branch_             000032 constant        entry                    external dcl 103 ref 214
hcs_$get_uid_seg                000034 constant        entry                    external dcl 104 ref 220 253
idx                             000266 automatic       fixed bin(17,0)          dcl 284 set ref 286* 287 287* 299* 300 300* 302* 309
initiate_file_                  000036 constant        entry                    external dcl 105 ref 217
list_idx                        000242 automatic       fixed bin(17,0)          dcl 88 set ref 223* 225 257* 258 259*
local_ai                        000106 automatic       structure                level 1 dcl 78 set ref 153 153
local_cbi                       000132 automatic       structure                level 1 dcl 80 set ref 192* 214 214
mlsys_data_$highest_usable_ring 000046 external static fixed bin(3,0)           dcl 1-49 ref 198
mlsys_data_$subsystem_area_ptr  000054 external static pointer                  dcl 1-62 set ref 136* 151
mlsys_data_$temp_segment_list_ptr
                                000050 external static pointer                  dcl 1-54 set ref 131* 132 225 257 258 259 286 287
                                                                                  294 299 300 302 304 305*
mlsys_data_$valid_segments      000052 external static bit(1)                   array packed unaligned dcl 1-56 set ref 134* 181*
                                                                                  229*
mlsys_et_$not_temporary_segment 000012 external static fixed bin(35,0)          dcl 94 ref 265
mode                      2     000132 automatic       bit(3)                   level 2 packed packed unaligned dcl 80 set ref 196*
n_uids                                 based           fixed bin(17,0)          level 2 dcl 65 set ref 131* 132 257 286 294 295* 297
                                                                                  299 302 307
new_temp_segment_list_ptr       000262 automatic       pointer                  dcl 283 set ref 295* 297 300 305
null                                                   builtin function         dcl 112 ref 138 138 242
old_temp_segment_list_ptr       000264 automatic       pointer                  dcl 283 set ref 304* 307
old_validation_level            000155 automatic       fixed bin(3,0)           dcl 82 set ref 33* 119* 123* 156* 170* 174* 183*
                                                                                  205* 209* 227* 244* 248* 272*
owner                     2     000106 automatic       char(32)                 level 2 packed packed unaligned dcl 78 set ref 149*
parent_ac_sw              1(04) 000132 automatic       bit(1)                   level 3 packed packed unaligned dcl 80 set ref 195*
requested_space                        based           bit(36)                  array dcl 55 ref 179
rings                     3     000132 automatic       fixed bin(3,0)           array level 2 dcl 80 set ref 197* 198* 198*
segment_ptr                     000100 automatic       pointer                  dcl 58 set ref 217* 220* 229 231 241* 253* 269*
segment_uid                     000240 automatic       bit(36)                  dcl 86 set ref 220* 225 253* 258
size                     13     000106 automatic       fixed bin(18,0)          level 2 dcl 78 set ref 150*
string                                                 builtin function         dcl 112 set ref 134* 145*
sub_err_                        000040 constant        entry                    external dcl 106 ref 138
switches                  1     000132 automatic       structure                level 2 packed packed unaligned dcl 80
sys_info$max_seg_size           000010 external static fixed bin(19,0)          dcl 92 ref 150
system                    1(05) 000106 automatic       bit(1)                   level 3 packed packed unaligned dcl 78 set ref 148*
system_area                            based           area(1024)               dcl 75 ref 131 295
system_area_ptr                 000104 automatic       pointer                  dcl 76 set ref 128* 131 292* 295
temp_segment_list                      based           structure                level 1 dcl 65 set ref 131 295 307
temp_segment_list_n_uids        000103 automatic       fixed bin(17,0)          dcl 70 set ref 130* 131 131 294* 295 295
terminate_file_                 000042 constant        entry                    external dcl 107 ref 269
uids                      1            based           bit(36)                  array level 2 dcl 65 set ref 132* 225* 258 259* 287
                                                                                  297* 300* 300
unique_chars_                   000044 constant        entry                    external dcl 108 ref 203
unspec                                                 builtin function         dcl 112 set ref 132* 192* 297*
userid                    6     000132 automatic       char(32)                 level 2 dcl 80 set ref 200*
version                         000132 automatic       fixed bin(17,0)          level 2 in structure "local_cbi" dcl 80 in procedure
                                                                                  "mlsys_storage_mgr_" set ref 194*
version                         000106 automatic       fixed bin(17,0)          level 2 in structure "local_ai" dcl 78 in procedure
                                                                                  "mlsys_storage_mgr_" set ref 144*
zero_on_free              1(02) 000106 automatic       bit(1)                   level 3 packed packed unaligned dcl 78 set ref 147*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 6-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 6-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 6-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 6-7
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 3-33
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 3-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 3-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 3-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
R_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 3-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 3-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 3-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 3-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 3-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
TERM_FILE_BC                           internal static bit(2)                   initial packed unaligned dcl 4-12
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial packed unaligned dcl 4-16
TERM_FILE_TERM                         internal static bit(3)                   initial packed unaligned dcl 4-14
TERM_FILE_TRUNC                        internal static bit(1)                   initial packed unaligned dcl 4-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial packed unaligned dcl 4-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial packed unaligned dcl 4-15
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
area_infop                             automatic       pointer                  dcl 5-5
mlsys_area                             based           area(1024)               dcl 1-61
mlsys_data_$address_list_allocation    external static fixed bin(17,0)          dcl 1-33
mlsys_data_$domains_available          external static fixed bin(1,0)           dcl 1-44
mlsys_data_$forum_not_available        external static fixed bin(1,0)           dcl 1-44
mlsys_data_$hash_tables_segment_ptr    external static pointer                  dcl 1-64
mlsys_data_$ism_not_available          external static fixed bin(1,0)           dcl 1-44
mlsys_data_$lowest_forum_ring          external static fixed bin(3,0)           dcl 1-49
mlsys_data_$mailbox_allocation         external static fixed bin(17,0)          dcl 1-33
mlsys_data_$max_lock_wait_retries      external static fixed bin(17,0)          dcl 1-19
mlsys_data_$max_opening_retries        external static fixed bin(17,0)          dcl 1-16
mlsys_data_$message_body_sections_allocation
                                       external static fixed bin(17,0)          dcl 1-33
mlsys_data_$message_redistributions_list_allocation
                                       external static fixed bin(17,0)          dcl 1-33
mlsys_data_$message_references_list_allocation
                                       external static fixed bin(17,0)          dcl 1-33
mlsys_data_$message_user_fields_allocation
                                       external static fixed bin(17,0)          dcl 1-33
mlsys_data_$person_id                  external static varying char(24)         dcl 1-70
mlsys_data_$project_id                 external static varying char(12)         dcl 1-71
mlsys_data_$subsystem_ring             external static fixed bin(3,0)           dcl 1-49
mlsys_data_$transmit_cache_ptr         external static pointer                  dcl 1-66
mlsys_data_$user_id                    external static varying char(32)         dcl 1-72
mlsys_data_$user_is_anonymous          external static bit(1)                   dcl 1-68
terminate_file_switches                based           structure                level 1 packed packed unaligned dcl 4-4

NAMES DECLARED BY EXPLICIT CONTEXT.
RESIGNAL_INITIALIZATION_FAILURE 000243 constant        label                    dcl 138 ref 141 154
RESTORE_LEVEL_AND_RETURN_WITH_ERROR
                                000102 constant        label                    dcl 33 ref 215 218 221 254 266 270
allocate                        000361 constant        entry                    external dcl 167
find_empty_temp_segment_list_slot
                                001203 constant        entry                    internal dcl 280 ref 223
get_temp_segment                000472 constant        entry                    external dcl 189 ref 136
initialize                      000116 constant        entry                    external dcl 116
mlsys_storage_mgr_              000074 constant        entry                    external dcl 25
release_temp_segment            001003 constant        entry                    external dcl 238

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1670        1746    1326        1700
Length      2336    1326        56         354     341           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mlsys_storage_mgr_                  252 external procedure  is an external procedure.  
on unit on line 121                  68 on unit               
on unit on line 172                  68 on unit               
on unit on line 207                  68 on unit               
on unit on line 246                  68 on unit               
find_empty_temp_segment_list_slot
                                        internal procedure  shares stack frame of external procedure mlsys_storage_mgr_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mlsys_storage_mgr_       000100 segment_ptr                 mlsys_storage_mgr_
                         000102 code                        mlsys_storage_mgr_
                         000103 temp_segment_list_n_uids    mlsys_storage_mgr_
                         000104 system_area_ptr             mlsys_storage_mgr_
                         000106 local_ai                    mlsys_storage_mgr_
                         000132 local_cbi                   mlsys_storage_mgr_
                         000155 old_validation_level        mlsys_storage_mgr_
                         000156 dirname                     mlsys_storage_mgr_
                         000230 ename                       mlsys_storage_mgr_
                         000240 segment_uid                 mlsys_storage_mgr_
                         000241 found                       mlsys_storage_mgr_
                         000242 list_idx                    mlsys_storage_mgr_
                         000262 new_temp_segment_list_ptr   find_empty_temp_segment_list_slot
                         000264 old_temp_segment_list_ptr   find_empty_temp_segment_list_slot
                         000266 idx                         find_empty_temp_segment_list_slot

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_in         call_ext_out_desc   call_ext_out        return_mac          enable_op           ext_entry
int_entry           op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$level_get                 cu_$level_set                 define_area_                  get_group_id_$tag_star
get_pdir_                     get_ring_                     get_system_free_area_         hcs_$create_branch_
hcs_$get_uid_seg              initiate_file_                sub_err_                      terminate_file_
unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
mlsys_data_$highest_usable_ring                             mlsys_data_$subsystem_area_ptr
mlsys_data_$temp_segment_list_ptr                           mlsys_data_$valid_segments
mlsys_et_$not_temporary_segment                             sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     25 000073        28 000101        33 000102        35 000111        36 000114       116 000115       119 000123
    121 000132       123 000146       124 000155       126 000156       128 000174       130 000203       131 000205
    132 000216       134 000224       136 000231       137 000241       138 000243       141 000306       144 000307
    145 000311       146 000312       147 000314       148 000316       149 000320       150 000323       151 000326
    153 000331       154 000343       156 000345       158 000354       167 000355       170 000366       172 000375
    174 000411       175 000420       177 000421       179 000437       181 000447       183 000457       185 000465
    189 000466       192 000477       194 000502       195 000504       196 000506       197 000512       198 000521
    200 000525       202 000536       203 000545       205 000570       207 000577       209 000613       210 000622
    212 000623       214 000641       215 000670       217 000672       218 000730       220 000732       221 000745
    223 000747       225 000751       227 000756       229 000764       231 000774       232 000777       234 001000
    238 001001       241 001010       242 001014       244 001016       246 001025       248 001041       249 001050
    251 001051       253 001067       254 001102       256 001104       257 001105       258 001121       259 001126
    260 001127       262 001131       264 001133       265 001135       266 001140       269 001141       270 001167
    272 001171       274 001200       276 001202       280 001203       286 001205       287 001217       288 001226
    292 001230       294 001237       295 001244       297 001254       299 001262       300 001273       301 001277
    302 001301       304 001306       305 001310       307 001312       309 001316


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
