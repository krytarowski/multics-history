	COMPILATION LISTING OF SEGMENT im_validate_cursor
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  0927.0 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION:
        8*
        9*         This   subroutine   checks   that  the  provided  cursor's  position
       10*     information is consistent.  If the cursor has a current key  value  which
       11*     doesn't  match  with  the  key  at  the  current key location, then it is
       12*     re-positioned.  Also, if the current key doesn't  exist,  the  cursor  is
       13*     re-positioned.        Re-positioning   is   achieved   by   calling   the
       14*     im_basic_search$reposition entry.
       15*
       16*     This module  does  not  attempt  to  validate  the  file  opening  id  or
       17*     collection ids.
       18**/
       19 
       20 /* HISTORY:
       21*
       22*Written by Lindsey L. Spratt, 02/23/83.
       23*Modified:
       24*03/18/83 by Matthew Pierret: Changed dm_error_$invalid_cursor to
       25*            $invalid_cursor_position.
       26*04/03/83 by Lindsey L. Spratt:  Converted to use
       27*            data_mgmt_util_$compare_string_to_string instead of
       28*            im_compare_key_and_key.
       29*05/10/84 by Matthew Pierret:  Changed to align key_buffer on an even-word
       30*            boundary.  Changed to compare key_string and the current key with
       31*            a bit-string comparison instead of calling
       32*            data_format_util_$compare_string_to_string.
       33*06/07/84 by Matthew Pierret:  Re-named cm_$get_element to cm_$get.
       34*10/28/84 by Lindsey L. Spratt:  Changed to use version 2 index_opening_info.
       35*            Changed to use ERROR_RETURN.
       36*03/07/85 by R. Michael Tague:  Changed opening info version to version 3.
       37**/
       38 
       39 /* format: style2,ind3 */
       40 
       41 im_validate_cursor:
       42    proc (p_index_opening_info_ptr, p_index_cursor_ptr, p_code);
       43 
       44 /* START OF DECLARATIONS */
       45 /* Parameter */
       46 
       47       dcl	    p_index_opening_info_ptr
       48 			       ptr parameter;
       49       dcl	    p_index_cursor_ptr     ptr parameter;
       50       dcl	    p_code	       fixed bin (35) parameter;
       51 
       52 /* Automatic */
       53 
       54       dcl	    reposition_cursor      bit (1) init ("0"b) aligned;
       55       dcl	    key_buffer	       (DOUBLE_WORDS_PER_PAGE) fixed bin (71);
       56       dcl	    key_buffer_length      fixed bin (35) init (BITS_PER_PAGE);
       57       dcl	    key_string_ptr	       ptr init (null);
       58       dcl	    key_string_length      fixed bin (35) aligned init (0);
       59       dcl	    first_inequal_field_id fixed bin;
       60       dcl	    (cursor_key_equal_to_index_key, cursor_key_less_than_index_key)
       61 			       bit (1) init ("0"b) aligned;
       62 
       63 /* Based */
       64 
       65       dcl	    key_string	       bit (key_string_length) based (key_string_ptr) aligned;
       66 
       67 /* Builtin */
       68 
       69       dcl	    (null, addr, length)   builtin;
       70 
       71 /* Constant */
       72 
       73       dcl	    myname	       init ("im_validate_cursor") char (32) varying internal static options (constant);
       74       dcl	    (
       75 	    BITS_PER_PAGE	       init (1024 * 36),
       76 	    DOUBLE_WORDS_PER_PAGE  init (512),
       77 	    DEFAULT_POSITION       init (0) fixed bin (35),
       78 	    DEFAULT_AREA	       init (null) ptr,
       79 	    ALL_FIELDS	       init (-1) fixed bin
       80 	    )		       internal static options (constant);
       81 
       82 /* Entry */
       83 
       84       dcl	    im_basic_search$reposition
       85 			       entry (ptr, ptr, ptr, fixed bin (24), fixed bin (35));
       86 
       87       dcl	    sub_err_	       entry () options (variable);
       88 
       89 /* External */
       90 
       91       dcl	    (
       92 	    error_table_$unimplemented_version,
       93 	    dm_error_$invalid_cursor_position,
       94 	    dm_error_$wrong_cursor_type
       95 	    )		       fixed bin (35) ext;
       96 
       97 /* END OF DECLARATIONS */
       98 
       99       index_cursor_ptr = p_index_cursor_ptr;
      100       p_code = 0;
      101 
      102       if index_cursor.type ^= INDEX_CURSOR_TYPE
      103       then call sub_err_ (dm_error_$wrong_cursor_type, myname, ACTION_CANT_RESTART, null, 0,
      104 	      "^/Expected an index cursor (type ^d). Received a cursor of type ^d, instead.", INDEX_CURSOR_TYPE,
      105 	      index_cursor.type);
      106 
      107       call CHECK_VERSION ((index_cursor.version), (INDEX_CURSOR_VERSION_3), "index_cursor");
      108 
      109       index_opening_info_ptr = p_index_opening_info_ptr;
      110       call CHECK_VERSION_CHAR (index_opening_info.version, INDEX_OPENING_INFO_VERSION_3, "index_opening_info");
      111 
      112       index_header_ptr = index_opening_info.index_header_ptr;
      113       call CHECK_VERSION_CHAR (index_header.version, INDEX_HEADER_VERSION_4, "index_header");
      114 
      115       if ^index_cursor.flags.is_valid
      116       then call ERROR_RETURN (dm_error_$invalid_cursor_position);
      117       else if index_cursor.flags.is_at_beginning_of_index
      118       then
      119          do;
      120 	  if index_cursor.flags.current_key_exists | index_cursor.flags.is_at_end_of_index
      121 	  then
      122 	     do;
      123 	        index_cursor.flags.is_valid = "0"b;
      124 	        call ERROR_RETURN (dm_error_$invalid_cursor_position);
      125 	     end;
      126 	  else if index_cursor.current_key_string_ptr ^= null
      127 	  then reposition_cursor = "1"b;
      128          end;
      129       else if index_cursor.flags.is_at_end_of_index
      130       then
      131          do;
      132 	  if index_cursor.flags.current_key_exists | index_cursor.flags.is_at_beginning_of_index
      133 	  then
      134 	     do;
      135 	        index_cursor.flags.is_valid = "0"b;
      136 	        call ERROR_RETURN (dm_error_$invalid_cursor_position);
      137 	     end;
      138 	  else if index_cursor.current_key_string_ptr ^= null
      139 	  then reposition_cursor = "1"b;
      140          end;
      141       else if index_cursor.current_key_string_ptr = null
      142       then
      143          do;
      144 	  index_cursor.flags.is_valid = "0"b;
      145 	  call ERROR_RETURN (dm_error_$invalid_cursor_position);
      146          end;
      147       else if ^index_cursor.current_key_exists
      148       then reposition_cursor = "1"b;
      149       else
      150          do;
      151 	  call collection_manager_$get (index_cursor.file_opening_id, index_cursor.collection_id,
      152 	       index_cursor.key_id_string, (DEFAULT_POSITION), addr (key_buffer), key_buffer_length, DEFAULT_AREA, "0"b,
      153 	       key_string_ptr, key_string_length, p_code);
      154 	  if p_code ^= 0
      155 	  then reposition_cursor = "1"b;
      156 	  else if key_string_length ^= index_cursor.current_key_string_length
      157 	  then reposition_cursor = "1"b;
      158 	  else if key_string ^= index_cursor.current_key_string_ptr -> key_string
      159 	  then reposition_cursor = "1"b;
      160          end;
      161 
      162       if reposition_cursor
      163       then
      164          do;
      165 	  p_code = 0;
      166 	  call im_basic_search$reposition (index_opening_info_ptr, index_cursor_ptr,
      167 	       index_cursor.current_key_string_ptr, (index_cursor.current_key_string_length), p_code);
      168 	  if p_code ^= 0
      169 	  then call ERROR_RETURN (p_code);
      170          end;
      171 
      172 MAIN_RETURN:
      173       return;
      174 
      175 
      176 ERROR_RETURN:
      177    proc (er_p_code);
      178       dcl	    er_p_code	       fixed bin (35) parameter;
      179 
      180       p_code = er_p_code;
      181       goto MAIN_RETURN;
      182    end ERROR_RETURN;
      183 
      184 CHECK_VERSION_CHAR:
      185    proc (p_received_version, p_expected_version, p_structure_name);
      186 
      187       dcl	    (p_expected_version, p_received_version)
      188 			       char (8) aligned parameter;
      189       dcl	    p_structure_name       char (*) parameter;
      190 
      191       if p_expected_version ^= p_received_version
      192       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      193 	      "^/Expected version ^a of the ^a structure.  
      194 Received version ^a, instead.", p_expected_version, p_structure_name, p_received_version);
      195    end CHECK_VERSION_CHAR;
      196 
      197 
      198 CHECK_VERSION:
      199    proc (p_received_version, p_expected_version, p_structure_name);
      200       dcl	    p_received_version     fixed bin (35);
      201       dcl	    p_expected_version     fixed bin (35);
      202       dcl	    p_structure_name       char (*);
      203       if p_received_version ^= p_expected_version
      204       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      205 	      "^/Expected version ^d of the ^a structure.
      206 Received version ^d instead.", p_expected_version, p_structure_name, p_received_version);
      207    end CHECK_VERSION;
      208 
  1     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  1     2 /* format: style3 */
  1     3 
  1     4 /* These constants are to be used for the flags argument of sub_err_ */
  1     5 /* They are just "string (condition_info_header.action_flags)" */
  1     6 
  1     7 declare	(
  1     8 	ACTION_CAN_RESTART	init (""b),
  1     9 	ACTION_CANT_RESTART init ("1"b),
  1    10 	ACTION_DEFAULT_RESTART
  1    11 			init ("01"b),
  1    12 	ACTION_QUIET_RESTART
  1    13 			init ("001"b),
  1    14 	ACTION_SUPPORT_SIGNAL
  1    15 			init ("0001"b)
  1    16 	)		bit (36) aligned internal static options (constant);
  1    17 
  1    18 /* End include file */
      209 
      210 
  2     1 /* BEGIN INCLUDE FILE - dm_im_cursor.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*          This structure specifies a DM file, an index collection in that DM
  2     6*file, and a position (key) in that index collection.
  2     7*
  2     8**/
  2     9 
  2    10 /* HISTORY:
  2    11*
  2    12*Written by Lindsey Spratt, 03/29/82
  2    13*Modified:
  2    14*08/09/82 by Matthew Pierret: Changed collection_id from "fixed bin (17)" to
  2    15*            "bit (35) aligned".
  2    16*08/26/82 by Lindsey Spratt:  Changed to version 2.  Added the is_valid and
  2    17*	  is_at_end_of_index flags.  Changed the key_check_value to fixed
  2    18*	  bin (35).  Added the IM_HASH_BIAS, which is used to increment the
  2    19*	  value developed by hash_index_, and IM_HASH_NUMBER_OF_BUCKETS,
  2    20*	  which is a unique number used by hash_index_ to develop the
  2    21*	  key_check_value.
  2    22*02/23/83 by Lindsey Spratt: Changed to keep the current key value in the
  2    23*	  cursor.  Also, implemented the ability to have the cursor
  2    24*	  positioned before or after the index.  
  2    25*10/23/84 by Lindsey L. Spratt:  Added a description section.
  2    26**/
  2    27 
  2    28 /* format: style2,ind3 */
  2    29      dcl	   1 index_cursor	      based (index_cursor_ptr),
  2    30 	     2 type	      fixed bin (17) unaligned,
  2    31 	     2 version	      fixed bin (17) unaligned,
  2    32 	     2 file_opening_id    bit (36) aligned,
  2    33 	     2 collection_id      bit (36) aligned,
  2    34 	     2 key_id_string      bit (36) aligned,	/* Is the location of the current key, */
  2    35 						/* if flags.current_key_exists is on. Is the location */
  2    36 						/* of the end of the index if flags.is_at_end_of_index */
  2    37 						/* is on, which is only available via an operation */
  2    38 						/* requiring the "previous" key.  Is the location of */
  2    39 						/* the "next" key, otherwise. */
  2    40 	     2 area_ptr	      ptr,		/* Area in which the cursor and key_string area allocated. */
  2    41 						/* Must be a freeing area. */
  2    42 	     2 current_key_string_ptr
  2    43 			      ptr,		/* Points to the value of the current key. */
  2    44 	     2 current_key_string_length
  2    45 			      fixed bin (24) unal,	/* Is the length of the current key in bits. */
  2    46 	     2 pad	      bit (12) unal,
  2    47 	     2 flags	      aligned,
  2    48 	       3 is_at_beginning_of_index
  2    49 			      bit (1) unaligned,	/* Only the "next" key is defined. */
  2    50 	       3 is_at_end_of_index
  2    51 			      bit (1) unaligned,	/* Only the "previous" key is defined. */
  2    52 	       3 current_key_exists
  2    53 			      bit (1) unaligned,	/* If on, indicates that the "current" key is identified */
  2    54 						/* by the key_id_string.  If off, the "current" position */
  2    55 						/* is undefined, and the key_id_string identifies the */
  2    56 						/* previous or next key, depending on whether */
  2    57 						/* flags.is_at_end_of_index is off or on, respectively. */
  2    58 	       3 is_valid	      bit (1) unaligned,	/* If off, the index_manager_ was interrupted while */
  2    59 						/* setting the cursor position and the cursor is not */
  2    60 						/* to be trusted for relative position operations. */
  2    61 	       3 pad	      bit (32) unal;
  2    62 
  2    63 
  2    64      dcl	   index_cursor_ptr	      ptr;
  2    65 
  2    66      dcl	   INDEX_CURSOR_VERSION_3 fixed bin (17) init (3) internal static options (constant);
  2    67      dcl	   INDEX_CURSOR_TYPE      init (2) fixed bin (17) internal static options (constant);
  2    68 
  2    69 /* END INCLUDE FILE - dm_im_cursor.incl.pl1 */
      211 
      212 
  3     1 /* BEGIN INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*     This include file contains declarations of all collection_manager_ 
  3     5*     entrypoints.
  3     6**/
  3     7 
  3     8 /* HISTORY:
  3     9*Written by Matthew Pierret 
  3    10*Modified:
  3    11*04/14/82 by Lindsey Spratt: Changed the control_interval_id parameter of the
  3    12*	  allocate_control_interval operation to be unaligned, as well as
  3    13*	  unsigned.
  3    14*06/17/82 by Matthew Pierret: Added the put_element_portion opertion and
  3    15*            removed the beginning_location parameter from the put_element
  3    16*            operation. Added the create_page_file_operation.
  3    17*08/09/82 by Matthew Pierret: Changed "fixed bin (17)"s to "bit (36) aligned"s
  3    18*            wherever collection_id was required.
  3    19*            Also changed the control_interval_id parameter of the 
  3    20*            allocate_control_interval operation back to be aligned. So there.
  3    21*10/20/82 by Matthew Pierret: Changed $create_page_file to $create_file,
  3    22*            added the argument file_create_info_ptr to $create_file.
  3    23*12/13/82 by Lindsey Spratt:  Corrected $free_control_interval to
  3    24*	  include the zero_on_free bit.
  3    25*12/17/82 by Matthew Pierret: Added cm_$get_id.
  3    26*01/07/83 by Matthew Pierret: Added cm_$put_element_buffered, 
  3    27*            cm_$allocate_element_buffered, cm_$free_element_buffered.
  3    28*04/27/83 by Matthew Pierret: Added cm_$put_unprotected_element,
  3    29*            cm_$put_unprotected_header.
  3    30*11/07/83 by Matthew Pierret: Added $get_element_portion_buffered,
  3    31*             $simple_get_buffered_element.
  3    32*02/08/84 by Matthew Pierret:  Changed $get_id to have only one bit(1)aligned
  3    33*            parameter for specifying absolute/relative nature of search.
  3    34*03/16/84 by Matthew Pierret:  Added cm_$get_control_interval_ptr,
  3    35*            $get_element_ptr, $get_element_portion_ptr, $simple_get_element_ptr
  3    36*04/03/84 by Matthew Pierret:  Added cm_$compact_control_interval.
  3    37*06/06/84 by Matthew Pierret:  Re-named free_element* to delete and
  3    38*            delete_from_ci_buffer.
  3    39*            Re-named *_buffered_ci to =_ci_buffer.
  3    40*            get entries.
  3    41*            modify entries.
  3    42*            Changed calling sequence of modify entries to have a ptr/length
  3    43*            instead of length/ptr parameter pair.
  3    44*03/11/85 by R. Michael Tague:  Added $postcommit_increments.
  3    45**/
  3    46 
  3    47 /* This include file contains declarations of collection_manager_ entrypoints */
  3    48 
  3    49 /* format: style2,ind3 */
  3    50      dcl	   collection_manager_$allocate_control_interval
  3    51 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  3    52      dcl	   collection_manager_$compact_control_interval
  3    53 			      entry (bit (36) aligned, fixed bin (24) uns, fixed bin (35));
  3    54      dcl	   collection_manager_$create_collection
  3    55 			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  3    56      dcl	   collection_manager_$create_file
  3    57 			      entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
  3    58      dcl	   collection_manager_$destroy_collection
  3    59 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  3    60      dcl	   collection_manager_$free_control_interval
  3    61 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, bit (1) aligned,
  3    62 			      fixed bin (35));
  3    63 
  3    64      dcl	   collection_manager_$delete
  3    65 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  3    66 			      fixed bin (35));
  3    67      dcl	   collection_manager_$delete_from_ci_buffer
  3    68 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  3    69 			      fixed bin (35));
  3    70 
  3    71      dcl	   collection_manager_$get
  3    72 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  3    73 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  3    74      dcl	   collection_manager_$get_control_interval_ptr
  3    75 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, ptr,
  3    76 			      fixed bin (35));
  3    77      dcl	   collection_manager_$get_from_ci_buffer
  3    78 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  3    79 			      ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  3    80      dcl	   collection_manager_$get_by_ci_ptr
  3    81 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  3    82 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), ptr, fixed bin (35));
  3    83      dcl	   collection_manager_$get_header
  3    84 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (17), ptr, bit (1) aligned,
  3    85 			      ptr, fixed bin (35), fixed bin (35));
  3    86      dcl	   collection_manager_$get_id
  3    87 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17),
  3    88 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  3    89      dcl	   collection_manager_$get_portion
  3    90 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  3    91 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  3    92 			      fixed bin (35), fixed bin (35));
  3    93      dcl	   collection_manager_$get_portion_from_ci_buffer
  3    94 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  3    95 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  3    96 			      fixed bin (35));
  3    97      dcl	   collection_manager_$get_portion_by_ci_ptr
  3    98 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  3    99 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  3   100 			      fixed bin (35));
  3   101      dcl	   collection_manager_$modify
  3   102 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  3   103 			      fixed bin (35), fixed bin (35));
  3   104      dcl	   collection_manager_$modify_unprotected
  3   105 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  3   106 			      fixed bin (35), fixed bin (35));
  3   107      dcl	   collection_manager_$modify_in_ci_buffer
  3   108 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  3   109 			      fixed bin (35), fixed bin (35));
  3   110      dcl	   collection_manager_$modify_portion
  3   111 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35), ptr,
  3   112 			      fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  3   113      dcl	   collection_manager_$postcommit_increments
  3   114 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  3   115      dcl	   collection_manager_$put
  3   116 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  3   117 			      fixed bin (35), fixed bin (35));
  3   118      dcl	   collection_manager_$put_in_ci_buffer
  3   119 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  3   120 			      fixed bin (35), fixed bin (35));
  3   121      dcl	   collection_manager_$put_header
  3   122 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  3   123      dcl	   collection_manager_$put_unprotected_header
  3   124 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  3   125 
  3   126      dcl	   collection_manager_$replace_ci_buffer
  3   127 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  3   128 			      fixed bin (35));
  3   129      dcl	   collection_manager_$setup_ci_buffer
  3   130 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  3   131 			      fixed bin (35));
  3   132      dcl	   collection_manager_$simple_get_by_ci_ptr
  3   133 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  3   134 			      fixed bin (35));
  3   135      dcl	   collection_manager_$simple_get_from_ci_buffer
  3   136 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  3   137 			      fixed bin (35));
  3   138 
  3   139 /* END INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
      213 
      214 
  4     1 /* BEGIN INCLUDE FILE - dm_im_header.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*          The index_header structure is stored in the header element of an
  4     6*     index collection and describes basic information about the index.
  4     7**/
  4     8 
  4     9 /* HISTORY:
  4    10*
  4    11*Written by Lindsey Spratt, 04/02/82.
  4    12*Modified:
  4    13*10/28/82 by Lindsey Spratt:  Changed to version 3.  Added the key_count_array.
  4    14*	  count(0) is the number of keys in the index.  count(N) is the
  4    15*	  number of keys in the index which have at least fields 1 through N
  4    16*	  having the same value as another key in the index, i.e. count(N)
  4    17*	  is the number of partial duplicates with number of partial
  4    18*	  duplication fields equal to N.
  4    19*10/24/84 by Lindsey L. Spratt:  Added a description. Converted to version 4.
  4    20*	  Replaced the key_count_array with a key_count_array_element_id.
  4    21*	  Changed the version field to char(8).  Aligned the structure.
  4    22**/
  4    23 
  4    24 /* format: style2,ind3 */
  4    25      dcl	   1 index_header	      aligned based (index_header_ptr),
  4    26 	     2 version	      char (8) aligned,
  4    27 	     2 field_table_element_id
  4    28 			      like element_id,
  4    29 	     2 root_id	      fixed bin (24) unsigned unaligned,
  4    30 	     2 pad1	      bit (12) unaligned,
  4    31 	     2 number_of_duplication_fields
  4    32 			      fixed bin (17) unal,
  4    33 	     2 pad2	      bit (18) unal,
  4    34 	     2 key_count_array_element_id
  4    35 			      like element_id;
  4    36 
  4    37      dcl	   index_header_ptr	      ptr;
  4    38      dcl	   INDEX_HEADER_VERSION_4 init ("IdxHdr 4") char (8) aligned internal static options (constant);
  4    39 
  4    40 /* END INCLUDE FILE - dm_im_header.incl.pl1 */
      215 
      216 
  5     1 /* BEGIN INCLUDE FILE - dm_im_opening_info.incl.pl1 */
  5     2 
  5     3 /* DESRIPTION:
  5     4*
  5     5*          The index_opening_info is per-process information, stored in a
  5     6*     hash_table managed by the opening_manager_, which allows the
  5     7*     index_manager_ to quickly reference certain unchanging pieces of
  5     8*     information rapidly.
  5     9**/
  5    10 
  5    11 /* HISTORY:
  5    12*
  5    13*Written by Lindsey Spratt, 10/28/82.
  5    14*Modified:
  5    15*10/26/84 by Lindsey L. Spratt:  Changed version to char(8).  Added a
  5    16*            description.  Added the current_rollback_count.  Added the
  5    17*	  key_count_array_ptr.
  5    18*03/07/85 by R. Michael Tague:  Added key_count_increments_ptr and 
  5    19*	  key_counts_postcommit_written.  Changed to version 3.
  5    20*03/25/85 by R. Michael Tague:  Added key_count_unprotected_file.  This
  5    21*	  flag is used by im_update_opening_info to help it maintain the
  5    22*	  key count array info.
  5    23**/
  5    24 
  5    25 /* format: style2,ind3 */
  5    26      dcl	   1 index_opening_info   based (index_opening_info_ptr) aligned,
  5    27 	     2 version	      char (8) aligned,
  5    28 	     2 file_opening_id    bit (36) aligned,
  5    29 	     2 collection_id      bit (36) aligned,
  5    30 	     2 index_header_ptr   ptr init (null),
  5    31 	     2 field_table_ptr    ptr init (null),
  5    32 	     2 key_count_array_ptr
  5    33 			      ptr init (null),
  5    34 	     2 key_count_increments_ptr
  5    35 			      ptr init (null),
  5    36 	     2 flags,
  5    37 	       3 key_count_postcommit_written
  5    38 			      bit (1) unal init ("0"b),
  5    39 	       3 key_count_unprotected_file
  5    40 			      bit (1) unal init ("0"b),
  5    41 	       3 pad	      bit (34) unal init (""b),
  5    42 	     2 current_txn_id     fixed bin (35) init (0),
  5    43 	     2 current_rollback_count
  5    44 			      fixed bin (35) init (0);
  5    45 
  5    46      dcl	   index_opening_info_ptr ptr init (null);
  5    47      dcl	   INDEX_OPENING_INFO_VERSION_3
  5    48 			      init ("IdxOpn 3") char (8) aligned internal static options (constant);
  5    49 
  5    50 /* END INCLUDE FILE - dm_im_opening_info.incl.pl1 */
      217 
      218 
  6     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*
  6     5*        Contains the declaration of an element identifier.  Element
  6     6*   identifiers consist of two parts, the id (number) of the control interval
  6     7*   in which the element resides, and the index into the slot table of
  6     8*   the element in the control interval.  The declaration of the element_id 
  6     9*   structure reflects this division of the element identifier.  The structure 
  6    10*   is based on the automatic bit string element_id_string because programs
  6    11*   generally pass bit strings (element_id_string) to each other, then 
  6    12*   interpret the bit string by overlaying the element_id structure ony if
  6    13*   it is necessary to access the parts of the id.  Basing element_id on
  6    14*   addr(element_id_string) instead of on a pointer removes the necessity
  6    15*   for always setting that pointer explicitly and guarantees that changes
  6    16*   made to the string or structure do not get inconsistent.
  6    17*
  6    18*   Changes made to element_id must also be made to datum_id, declared in 
  6    19*   dm_cm_datum.incl.pl1.
  6    20**/
  6    21 
  6    22 /* HISTORY:
  6    23*Written by Matthew Pierret, 04/01/82.
  6    24*Modified:
  6    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  6    26**/
  6    27 
  6    28 /* format: style2,ind3,ll79 */
  6    29 
  6    30      dcl	   element_id_string      bit (36) aligned;
  6    31 
  6    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  6    33 	     2 control_interval_id
  6    34 			      fixed bin (24) unal unsigned,
  6    35 	     2 index	      fixed bin (12) unal unsigned;
  6    36 
  6    37 
  6    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      219 
      220    end im_validate_cursor;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0823.5  im_validate_cursor.pl1            >spec>on>7192.pbf-04/04/85>im_validate_cursor.pl1
209          1    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
211          2    01/07/85  0858.9  dm_im_cursor.incl.pl1             >ldd>include>dm_im_cursor.incl.pl1
213          3    04/04/85  0819.0  dm_collmgr_entry_dcls.incl.pl1    >spec>on>7192.pbf-04/04/85>dm_collmgr_entry_dcls.incl.pl1
215          4    01/07/85  0858.9  dm_im_header.incl.pl1             >ldd>include>dm_im_header.incl.pl1
217          5    04/04/85  0818.8  dm_im_opening_info.incl.pl1       >spec>on>7192.pbf-04/04/85>dm_im_opening_info.incl.pl1
219          6    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000022 constant        bit(36)                  initial dcl 1-7 set ref 102* 191* 203*
BITS_PER_PAGE                          constant        fixed bin(17,0)          initial dcl 74 ref 56
DEFAULT_AREA                    000004 constant        pointer                  initial dcl 74 set ref 151*
DEFAULT_POSITION                       constant        fixed bin(35,0)          initial dcl 74 ref 151
DOUBLE_WORDS_PER_PAGE                  constant        fixed bin(17,0)          initial dcl 74 ref 55
INDEX_CURSOR_TYPE               000035 constant        fixed bin(17,0)          initial dcl 2-67 set ref 102 102*
INDEX_CURSOR_VERSION_3                 constant        fixed bin(17,0)          initial dcl 2-66 ref 107
INDEX_HEADER_VERSION_4          000002 constant        char(8)                  initial dcl 4-38 set ref 113*
INDEX_OPENING_INFO_VERSION_3    000000 constant        char(8)                  initial dcl 5-47 set ref 110*
addr                                                   builtin function         dcl 69 ref 151 151
collection_id             2            based           bit(36)                  level 2 dcl 2-29 set ref 151*
collection_manager_$get         000022 constant        entry                    external dcl 3-71 ref 151
current_key_exists       12(02)        based           bit(1)                   level 3 packed unaligned dcl 2-29 ref 120 132 147
current_key_string_length
                         10            based           fixed bin(24,0)          level 2 packed unaligned dcl 2-29 ref 156 166
current_key_string_ptr
                          6            based           pointer                  level 2 dcl 2-29 set ref 126 138 141 158 166*
cursor_key_equal_to_index_key   000107 automatic       bit(1)                   initial dcl 60 set ref 60*
cursor_key_less_than_index_key  000110 automatic       bit(1)                   initial dcl 60 set ref 60*
dm_error_$invalid_cursor_position
                                000016 external static fixed bin(35,0)          dcl 91 set ref 115* 124* 136* 145*
dm_error_$wrong_cursor_type     000020 external static fixed bin(35,0)          dcl 91 set ref 102*
element_id                             based           structure                level 1 dcl 6-32
er_p_code                              parameter       fixed bin(35,0)          dcl 178 ref 176 180
error_table_$unimplemented_version
                                000014 external static fixed bin(35,0)          dcl 91 set ref 191* 203*
file_opening_id           1            based           bit(36)                  level 2 dcl 2-29 set ref 151*
flags                    12            based           structure                level 2 dcl 2-29
im_basic_search$reposition      000010 constant        entry                    external dcl 84 ref 166
index_cursor                           based           structure                level 1 unaligned dcl 2-29
index_cursor_ptr                000112 automatic       pointer                  dcl 2-64 set ref 99* 102 102 107 115 117 120 120 123
                                                                                  126 129 132 132 135 138 141 144 147 151 151 151
                                                                                  156 158 166* 166 166
index_header                           based           structure                level 1 dcl 4-25
index_header_ptr                000114 automatic       pointer                  dcl 4-37 in procedure "im_validate_cursor" set ref
                                                                                  112* 113
index_header_ptr          4            based           pointer                  initial level 2 in structure "index_opening_info"
                                                                                  dcl 5-26 in procedure "im_validate_cursor" ref 112
index_opening_info                     based           structure                level 1 dcl 5-26
index_opening_info_ptr          000116 automatic       pointer                  initial dcl 5-46 set ref 109* 110 112 166* 5-46*
is_at_beginning_of_index
                         12            based           bit(1)                   level 3 packed unaligned dcl 2-29 ref 117 132
is_at_end_of_index       12(01)        based           bit(1)                   level 3 packed unaligned dcl 2-29 ref 120 129
is_valid                 12(03)        based           bit(1)                   level 3 packed unaligned dcl 2-29 set ref 115 123*
                                                                                  135* 144*
key_buffer                      000102 automatic       fixed bin(71,0)          array dcl 55 set ref 151 151
key_buffer_length               000102 automatic       fixed bin(35,0)          initial dcl 56 set ref 56* 151*
key_id_string             3            based           bit(36)                  level 2 dcl 2-29 set ref 151*
key_string                             based           bit                      dcl 65 ref 158 158
key_string_length               000106 automatic       fixed bin(35,0)          initial dcl 58 set ref 58* 151* 156 158 158
key_string_ptr                  000104 automatic       pointer                  initial dcl 57 set ref 57* 151* 158
myname                          000006 constant        varying char(32)         initial dcl 73 set ref 102* 191* 203*
null                                                   builtin function         dcl 69 ref 57 102 102 126 138 141 5-46 191 191 203
                                                                                  203
p_code                                 parameter       fixed bin(35,0)          dcl 50 set ref 41 100* 151* 154 165* 166* 168 168*
                                                                                  180*
p_expected_version                     parameter       fixed bin(35,0)          dcl 201 in procedure "CHECK_VERSION" set ref 198 203
                                                                                  203*
p_expected_version                     parameter       char(8)                  dcl 187 in procedure "CHECK_VERSION_CHAR" set ref
                                                                                  184 191 191*
p_index_cursor_ptr                     parameter       pointer                  dcl 49 ref 41 99
p_index_opening_info_ptr               parameter       pointer                  dcl 47 ref 41 109
p_received_version                     parameter       char(8)                  dcl 187 in procedure "CHECK_VERSION_CHAR" set ref
                                                                                  184 191 191*
p_received_version                     parameter       fixed bin(35,0)          dcl 200 in procedure "CHECK_VERSION" set ref 198 203
                                                                                  203*
p_structure_name                       parameter       char                     unaligned dcl 202 in procedure "CHECK_VERSION" set
                                                                                  ref 198 203*
p_structure_name                       parameter       char                     unaligned dcl 189 in procedure "CHECK_VERSION_CHAR"
                                                                                  set ref 184 191*
reposition_cursor               000100 automatic       bit(1)                   initial dcl 54 set ref 54* 126* 138* 147* 154* 156*
                                                                                  158* 162
sub_err_                        000012 constant        entry                    external dcl 87 ref 102 191 203
type                                   based           fixed bin(17,0)          level 2 packed unaligned dcl 2-29 set ref 102 102*
version                   0(18)        based           fixed bin(17,0)          level 2 in structure "index_cursor" packed unaligned
                                                                                  dcl 2-29 in procedure "im_validate_cursor" ref 107
version                                based           char(8)                  level 2 in structure "index_header" dcl 4-25
                                                                                  in procedure "im_validate_cursor" set ref 113*
version                                based           char(8)                  level 2 in structure "index_opening_info" dcl 5-26
                                                                                  in procedure "im_validate_cursor" set ref 110*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 1-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 1-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 1-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 1-7
ALL_FIELDS                             internal static fixed bin(17,0)          initial dcl 74
collection_manager_$allocate_control_interval
                                000000 constant        entry                    external dcl 3-50
collection_manager_$compact_control_interval
                                000000 constant        entry                    external dcl 3-52
collection_manager_$create_collection
                                000000 constant        entry                    external dcl 3-54
collection_manager_$create_file 000000 constant        entry                    external dcl 3-56
collection_manager_$delete      000000 constant        entry                    external dcl 3-64
collection_manager_$delete_from_ci_buffer
                                000000 constant        entry                    external dcl 3-67
collection_manager_$destroy_collection
                                000000 constant        entry                    external dcl 3-58
collection_manager_$free_control_interval
                                000000 constant        entry                    external dcl 3-60
collection_manager_$get_by_ci_ptr
                                000000 constant        entry                    external dcl 3-80
collection_manager_$get_control_interval_ptr
                                000000 constant        entry                    external dcl 3-74
collection_manager_$get_from_ci_buffer
                                000000 constant        entry                    external dcl 3-77
collection_manager_$get_header  000000 constant        entry                    external dcl 3-83
collection_manager_$get_id      000000 constant        entry                    external dcl 3-86
collection_manager_$get_portion 000000 constant        entry                    external dcl 3-89
collection_manager_$get_portion_by_ci_ptr
                                000000 constant        entry                    external dcl 3-97
collection_manager_$get_portion_from_ci_buffer
                                000000 constant        entry                    external dcl 3-93
collection_manager_$modify      000000 constant        entry                    external dcl 3-101
collection_manager_$modify_in_ci_buffer
                                000000 constant        entry                    external dcl 3-107
collection_manager_$modify_portion
                                000000 constant        entry                    external dcl 3-110
collection_manager_$modify_unprotected
                                000000 constant        entry                    external dcl 3-104
collection_manager_$postcommit_increments
                                000000 constant        entry                    external dcl 3-113
collection_manager_$put         000000 constant        entry                    external dcl 3-115
collection_manager_$put_header  000000 constant        entry                    external dcl 3-121
collection_manager_$put_in_ci_buffer
                                000000 constant        entry                    external dcl 3-118
collection_manager_$put_unprotected_header
                                000000 constant        entry                    external dcl 3-123
collection_manager_$replace_ci_buffer
                                000000 constant        entry                    external dcl 3-126
collection_manager_$setup_ci_buffer
                                000000 constant        entry                    external dcl 3-129
collection_manager_$simple_get_by_ci_ptr
                                000000 constant        entry                    external dcl 3-132
collection_manager_$simple_get_from_ci_buffer
                                000000 constant        entry                    external dcl 3-135
element_id_string                      automatic       bit(36)                  dcl 6-30
first_inequal_field_id                 automatic       fixed bin(17,0)          dcl 59
length                                                 builtin function         dcl 69

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   000740 constant        entry                    internal dcl 198 ref 107
CHECK_VERSION_CHAR              000636 constant        entry                    internal dcl 184 ref 110 113
ERROR_RETURN                    000630 constant        entry                    internal dcl 176 ref 115 124 136 145 168
MAIN_RETURN                     000627 constant        label                    dcl 172 ref 181
im_validate_cursor              000151 constant        entry                    external dcl 41

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1174        1220    1054        1204
Length      1534    1054        24         300     120           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
im_validate_cursor                  282 external procedure  is an external procedure.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure im_validate_cursor.  
CHECK_VERSION_CHAR                      internal procedure  shares stack frame of external procedure im_validate_cursor.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure im_validate_cursor.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
im_validate_cursor       000100 reposition_cursor           im_validate_cursor
                         000102 key_buffer                  im_validate_cursor
                         000102 key_buffer_length           im_validate_cursor
                         000104 key_string_ptr              im_validate_cursor
                         000106 key_string_length           im_validate_cursor
                         000107 cursor_key_equal_to_index_key
                                                            im_validate_cursor
                         000110 cursor_key_less_than_index_key
                                                            im_validate_cursor
                         000112 index_cursor_ptr            im_validate_cursor
                         000114 index_header_ptr            im_validate_cursor
                         000116 index_opening_info_ptr      im_validate_cursor

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              alloc_auto_adj      ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
collection_manager_$get       im_basic_search$reposition    sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$invalid_cursor_position                           dm_error_$wrong_cursor_type
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     41 000145        54 000156        55 000157        56 000165        57 000167        58 000171        60 000172
 5   46 000174        99 000175       100 000201       102 000202       107 000260       109 000276       110 000302
    112 000327       113 000332       115 000355       117 000371       120 000375       123 000400       124 000402
    125 000411       126 000412       128 000420       129 000421       132 000424       135 000431       136 000433
    137 000442       138 000443       140 000451       141 000452       144 000456       145 000460       146 000467
    147 000470       151 000476       154 000540       156 000546       158 000556       162 000567       165 000571
    166 000573       168 000616       172 000627       176 000630       180 000632       181 000635       184 000636
    191 000647       195 000737       198 000740       203 000751       207 001033


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
