	COMPILATION LISTING OF SEGMENT aq_man
	Compiled by: Multics PL/I Compiler, Release 28d, of September 14, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 10/03/83  1621.2 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* procedure to manage aq register for pl/1
       12*
       13*   Initial Version:  4 September 1971 by BLW for Version II
       14*	Modified:  2 October 1972 by BLW	
       15*	Modified:	11 June 1973 by RAB for aq_man$load_any ... 
       16*	Modified:	19 March 1977 by RAB for aq_man$left_shift
       17*		and aq_man$right_shift
       18*	Modified:	4 September 1977 by RAB to fix 1666
       19*	Modified:	10 November 1977 by RAB to prevent trimming when amt is bits_per_two_words	*/
       20 
       21 /*	These are the meanings of some important fields in the a_reg:
       22*
       23*	a_reg.size	the size of the datum in the register without
       24*			pad bits
       25*
       26*	a_reg.offset	the offset of the leftmost bit of the datum
       27*			from the left of the register
       28*
       29*	a_reg.length	the sum of a_reg.offset + a_reg.size + any known
       30*			zero_bits of padding immediately to the right of
       31*			the datum.  (Anything beyond a_reg.length in the
       32*			register is unknown.)		*/
       33 
       34 aq_man$pad_aq: proc(type,size);
       35 
       36 dcl	type fixed bin,	/* bit_string or char_string */
       37 	size fixed bin;	/* size to pad to, in bits */
       38 
       39 dcl	(cg_stat$double_temp,cg_stat$text_base) ptr ext,
       40 	cg_stat$text_pos fixed bin ext;
       41 
       42 dcl	(i,j,k,n) fixed bin,
       43 	arith bit(1),
       44 	macro fixed bin(15),
       45 	p ptr;
       46 
       47 dcl	word bit(36) aligned based;
       48 
       49 dcl	expmac entry(fixed bin(15),ptr),
       50 	expmac$zero entry(fixed bin(15)),
       51 	expmac$one entry(fixed bin(15),ptr,fixed bin),
       52 	xr_man$load_const entry(fixed bin,fixed bin),
       53 	aq_man$check_strings entry(fixed bin),
       54 	aq_man$clear_q entry,
       55 	c_a entry(fixed bin,fixed bin) returns(ptr),
       56 	copy_temp entry(ptr) returns(ptr);
       57 
       58 dcl	(abs,addrel,bit,fixed,lbound,min,null,string,substr) builtin;
       59 
       60 dcl (	anaq		init(42),
       61 	oraq		init(48),
       62 	rfb1_to_rfb2	init(88),
       63 	truncate(2)	init(520,521),
       64 	q_left_shift(2)	init(515,63),	/* qls, lls */
       65 	left_shift(2)	init(134,63),	/* als, lls */
       66 	right_shift(2)	init(245,62),	/* arl, lrl */
       67 	stfx1		init(15),
       68 	sta		init(4)) fixed bin(15) int static options(constant);
       69 
  1     1 /* BEGIN INCLUDE FILE ... cgsystem.incl.pl1 */
  1     2 
  1     3 /* Modified: 25 Apr 1979 by PCK to implement 4-bit decimal */
  1     4 
  1     5 dcl (	bits_per_char		init(9),
  1     6 	bits_per_half		init(18),
  1     7 	bits_per_word		init(36),
  1     8 	bits_per_two_words		init(72),
  1     9 	bits_per_four_words		init(144),
  1    10 	bits_per_words(2)		init(36,72),
  1    11 	packed_digits_per_char	init(2),
  1    12 	chars_per_word		init(4),
  1    13 	packed_digits_per_word	init(8),
  1    14 
  1    15 	break_even_bits		init(216),
  1    16 	break_even_words		init(6),
  1    17 
  1    18 	label_size		init(4),
  1    19 
  1    20 	convert_size(13:14)		init(9,1),
  1    21 	max_offset(13:14)		init(27,35),
  1    22 	max_short_size(13:14)	init(8,72),
  1    23 
  1    24 	units_per_word(0:5)		init(1,36,8,4,2,1),
  1    25 
  1    26 	max_dec_scale		init(32),
  1    27 	min_dec_scale		init(-31),
  1    28 	max_p_xreg		init(18),
  1    29 	max_p_fix_bin_1		init(35),
  1    30 	max_p_flt_bin_1		init(27),
  1    31 	max_p_fix_dec		init(59),
  1    32 	max_length_p		init(24),
  1    33 	default_fix_bin_p		init(17)) fixed bin(8) int static options(constant);
  1    34 
  1    35 dcl      (convert_offset(0:5)		init(36,1,4.5,9,18,36),
  1    36 	bits_per_packed_digit	init(4.5)) fixed bin(8,1) int static options(constant);
  1    37 
  1    38 dcl	max_index_register_value	init(262143) fixed bin(31) int static options(constant);
  1    39 
  1    40 /* END INCLUDE FILE ... cgsystem.incl.pl1 */
  1    41 
       70 
  2     1 /* BEGIN INCLUDE FILE ... cg_reference.incl.pl1 */
  2     2 
  2     3 dcl	1 reference		based aligned,
  2     4 	2 node_type		bit(9) unaligned,
  2     5 	2 array_ref		bit(1) unaligned,
  2     6 	2 varying_ref		bit(1) unaligned,
  2     7 	2 shared			bit(1) unaligned,
  2     8 	2 put_data_sw		bit(1) unaligned,
  2     9 	2 processed		bit(1) unaligned,
  2    10 	2 units			fixed(3) unaligned,
  2    11 	2 ref_count		fixed(17) unaligned,
  2    12 	2 c_offset		fixed(24),
  2    13 	2 c_length		fixed(24),
  2    14 	2 symbol			ptr unaligned,
  2    15 	2 qualifier		ptr unaligned,
  2    16 	2 offset			ptr unaligned,
  2    17 	2 length			ptr unaligned,
  2    18 						/* these fields are used by the 645 code generator */
  2    19 	2 c_f_offset		fixed bin(6),
  2    20 	2 address			structure unaligned,
  2    21 	  3 base			bit(3),
  2    22 	  3 offset		bit(15),
  2    23 	  3 op			bit(9),
  2    24 	  3 no_address		bit(1),
  2    25 	  3 inhibit		bit(1),
  2    26 	  3 ext_base		bit(1),
  2    27 	  3 tag			bit(6),
  2    28 	2 info			structure unaligned,
  2    29 	  3 address_in		structure,
  2    30 	    4 b			dimension(0:7) bit(1),
  2    31 	    4 storage		bit(1),
  2    32 	  3 value_in		structure,
  2    33 	    4 a			bit(1),
  2    34 	    4 q			bit(1),
  2    35 	    4 aq			bit(1),
  2    36 	    4 string_aq		bit(1),
  2    37 	    4 complex_aq		bit(1),
  2    38 	    4 decimal_aq		bit(1),
  2    39 	    4 b			dimension(0:7) bit(1),
  2    40 	    4 storage		bit(1),
  2    41 	    4 indicators		bit(1),
  2    42 	    4 x			dimension(0:7) bit(1),
  2    43 	  3 other			structure,
  2    44 	    4 big_offset		bit(1),
  2    45 	    4 big_length		bit(1),
  2    46 	    4 modword_in_offset	bit(1),
  2    47 	2 data_type		fixed(5) unaligned,
  2    48 	2 bits			structure unaligned,
  2    49 	  3 padded_ref		bit(1),
  2    50 	  3 aligned_ref		bit(1),
  2    51 	  3 long_ref		bit(1),
  2    52 	  3 forward_ref		bit(1),
  2    53 	  3 ic_ref		bit(1),
  2    54 	  3 temp_ref		bit(1),
  2    55 	  3 defined_ref		bit(1),
  2    56 	  3 evaluated		bit(1),
  2    57 	  3 allocate		bit(1),
  2    58 	  3 allocated		bit(1),
  2    59 	  3 aliasable		bit(1),
  2    60 	  3 even			bit(1),
  2    61 	  3 perm_address		bit(1),
  2    62 	  3 aggregate		bit(1),
  2    63 	  3 hit_zero		bit(1),
  2    64 	  3 dont_save		bit(1),
  2    65 	  3 fo_in_qual		bit(1),
  2    66 	  3 hard_to_load		bit(1),
  2    67 	2 relocation		bit(12) unaligned,
  2    68 	2 more_bits		structure unaligned,
  2    69 	  3 substr		bit(1),
  2    70 	  3 padded_for_store_ref	bit(1),
  2    71 	  3 aligned_for_store_ref	bit(1),
  2    72 	  3 mbz			bit(15),
  2    73 	2 store_ins		bit(18) unaligned;
  2    74 
  2    75 /* END INCLUDE FILE ... cg_reference.incl.pl1 */
       71 
  3     1 /* BEGIN INCLUDE FILE ... symbol.incl.pl1 */
  3     2 
  3     3 dcl	1 symbol			based aligned,
  3     4 	2 node_type		bit(9) unal,
  3     5 	2 source_id		structure unal,
  3     6 	  3 file_number		bit(8),
  3     7 	  3 line_number		bit(14),
  3     8 	  3 statement_number	bit(5),
  3     9 	2 location		fixed(18) unal unsigned,
  3    10 	2 allocated		bit(1) unal,
  3    11 	2 dcl_type		bit(3) unal,
  3    12 	2 reserved		bit(6) unal,
  3    13 	2 pix			unal,
  3    14 	  3 pic_fixed		bit(1) unal,
  3    15 	  3 pic_float		bit(1) unal,
  3    16 	  3 pic_char		bit(1) unal,
  3    17 	  3 pic_scale		fixed(7) unal,
  3    18 	  3 pic_size		fixed(7) unal,
  3    19 	2 level			fixed(8) unal,
  3    20 	2 boundary		fixed(3) unal,
  3    21 	2 size_units		fixed(3) unal,
  3    22 	2 scale			fixed(7) unal,
  3    23 	2 runtime			bit(18) unal,
  3    24 	2 runtime_offset		bit(18) unal,
  3    25 	2 block_node		ptr unal,
  3    26 	2 token			ptr unal,
  3    27 	2 next			ptr unal,
  3    28 	2 multi_use		ptr unal,
  3    29 	2 cross_references		ptr unal,
  3    30 	2 initial			ptr unal,
  3    31 	2 array			ptr unal,
  3    32 	2 descriptor		ptr unal,
  3    33 	2 equivalence		ptr unal,
  3    34 	2 reference		ptr unal,
  3    35 	2 general			ptr unal,
  3    36 	2 father			ptr unal,
  3    37 	2 brother			ptr unal,
  3    38 	2 son			ptr unal,
  3    39 	2 word_size		ptr unal,
  3    40 	2 bit_size		ptr unal,
  3    41 	2 dcl_size		ptr unal,
  3    42 	2 symtab_size		ptr unal,
  3    43 	2 c_word_size		fixed(24),
  3    44 	2 c_bit_size		fixed(24),
  3    45 	2 c_dcl_size		fixed(24),
  3    46 
  3    47 	2 attributes		structure aligned,
  3    48 	  3 data_type		structure unal,
  3    49 	    4 structure		bit(1) ,
  3    50 	    4 fixed		bit(1),
  3    51 	    4 float		bit(1),
  3    52 	    4 bit			bit(1),
  3    53 	    4 char		bit(1),
  3    54 	    4 ptr			bit(1),
  3    55 	    4 offset		bit(1),
  3    56 	    4 area		bit(1),
  3    57 	    4 label		bit(1),
  3    58 	    4 entry		bit(1),
  3    59 	    4 file		bit(1),
  3    60 	    4 arg_descriptor	bit(1),
  3    61 	    4 storage_block		bit(1),
  3    62 	    4 explicit_packed	bit(1), /* options(packed) */
  3    63 	    4 condition		bit(1),
  3    64 	    4 format		bit(1),
  3    65 	    4 builtin		bit(1),
  3    66 	    4 generic		bit(1),
  3    67 	    4 picture		bit(1),
  3    68 
  3    69 	  3 misc_attributes		structure unal,
  3    70 	    4 dimensioned		bit(1),
  3    71 	    4 initialed		bit(1),
  3    72 	    4 aligned		bit(1),
  3    73 	    4 unaligned		bit(1),
  3    74 	    4 signed		bit(1),
  3    75 	    4 unsigned		bit(1),
  3    76 	    4 precision		bit(1),
  3    77 	    4 varying		bit(1),
  3    78 	    4 local		bit(1),
  3    79 	    4 decimal		bit(1),
  3    80 	    4 binary		bit(1),
  3    81 	    4 real		bit(1),
  3    82 	    4 complex		bit(1),
  3    83 	    4 variable		bit(1),
  3    84 	    4 reducible		bit(1),
  3    85 	    4 irreducible		bit(1),
  3    86 	    4 returns		bit(1),
  3    87 	    4 position		bit(1),
  3    88 	    4 internal		bit(1),
  3    89 	    4 external		bit(1),
  3    90 	    4 like		bit(1),
  3    91 	    4 member		bit(1),
  3    92 	    4 non_varying		bit(1),
  3    93 	    4 options		bit(1),
  3    94 	    4 variable_arg_list 	bit(1),		/* options(variable) */
  3    95 	    4 alloc_in_text		bit(1),		/* options(constant) */
  3    96 
  3    97 	  3 storage_class		structure unal,
  3    98 	    4 auto		bit(1),
  3    99 	    4 based		bit(1),
  3   100 	    4 static		bit(1),
  3   101 	    4 controlled		bit(1),
  3   102 	    4 defined		bit(1),
  3   103 	    4 parameter		bit(1),
  3   104 	    4 param_desc		bit(1),
  3   105 	    4 constant		bit(1),
  3   106 	    4 temporary		bit(1),
  3   107 	    4 return_value		bit(1),
  3   108 
  3   109 	  3 file_attributes		structure unal,
  3   110 	    4 print		bit(1),
  3   111 	    4 input		bit(1),
  3   112 	    4 output		bit(1),
  3   113 	    4 update		bit(1),
  3   114 	    4 stream		bit(1),
  3   115 	    4 reserved_1		bit(1),
  3   116 	    4 record		bit(1),
  3   117 	    4 sequential		bit(1),
  3   118 	    4 direct		bit(1),
  3   119 	    4 interactive		bit(1),		/* env(interactive) */
  3   120 	    4 reserved_2		bit(1),
  3   121 	    4 reserved_3		bit(1),
  3   122 	    4 stringvalue		bit(1),		/* env(stringvalue) */
  3   123 	    4 keyed		bit(1),
  3   124 	    4 reserved_4		bit(1),
  3   125 	    4 environment		bit(1),
  3   126 
  3   127 	  3 compiler_developed	structure unal,
  3   128 	    4 aliasable		bit(1),
  3   129 	    4 packed		bit(1),
  3   130 	    4 passed_as_arg		bit(1),
  3   131 	    4 allocate		bit(1),
  3   132 	    4 set			bit(1),
  3   133 	    4 exp_extents		bit(1),
  3   134 	    4 refer_extents		bit(1),
  3   135 	    4 star_extents		bit(1),
  3   136 	    4 isub		bit(1),
  3   137 	    4 put_in_symtab		bit(1),
  3   138 	    4 contiguous		bit(1),
  3   139 	    4 put_data		bit(1),
  3   140 	    4 overlayed		bit(1),
  3   141 	    4 error		bit(1),
  3   142 	    4 symtab_processed	bit(1),
  3   143 	    4 overlayed_by_builtin	bit(1),
  3   144 	    4 defaulted		bit(1),
  3   145 	    4 connected		bit(1);
  3   146 
  3   147 /* END INCLUDE FILE ... symbol.incl.pl1 */
       72 
  4     1 dcl (	real_fix_bin_1		init(1),
  4     2 	real_fix_bin_2		init(2),
  4     3 	real_flt_bin_1		init(3),
  4     4 	real_flt_bin_2		init(4),
  4     5 	complex_fix_bin_1		init(5),
  4     6 	complex_fix_bin_2		init(6),
  4     7 	complex_flt_bin_1		init(7),
  4     8 	complex_flt_bin_2		init(8),
  4     9 	real_fix_dec		init(9),
  4    10 	real_flt_dec		init(10),
  4    11 	complex_fix_dec		init(11),
  4    12 	complex_flt_dec		init(12),
  4    13 	char_string		init(13),
  4    14 	bit_string		init(14),
  4    15 	label_constant		init(15),
  4    16 	local_label_variable	init(16),
  4    17 	label_variable		init(17),
  4    18 	entry_variable		init(18),
  4    19 	ext_entry_in		init(19),
  4    20 	ext_entry_out		init(20),
  4    21 	int_entry			init(21),
  4    22 	int_entry_other		init(22),
  4    23 	unpacked_ptr		init(23),
  4    24 	packed_ptr		init(24)) fixed bin(15) int static options(constant);
       73 
  5     1 /* BEGIN INCLUDE FILE ... machine_state.incl.pl1 */
  5     2 
  5     3 dcl	cg_static_$m_s_p ptr ext static,
  5     4 	m_s_p ptr init(cg_static_$m_s_p);
  5     5 
  5     6 dcl	1 machine_state	aligned based(m_s_p),
  5     7 	2 node_type	bit(9),
  5     8 	2 indicators	fixed bin,
  5     9 	2 next		ptr unal,
  5    10 	2 a_reg,
  5    11 	  3 variable(10)	ptr unal,
  5    12 	  3 number	fixed bin(17),
  5    13 	  3 size		fixed bin(8),
  5    14 	  3 length	fixed bin(8),
  5    15 	  3 offset	fixed bin(8),
  5    16 	  3 constant	fixed bin(24),
  5    17 	  3 changed	fixed bin(18),
  5    18 	  3 instruction	bit(36),
  5    19 	  3 locked	bit(1) aligned,
  5    20 	  3 number_h_o	fixed bin,
  5    21 	  3 has_offset(3)	ptr unal,
  5    22 	2 q_reg,
  5    23 	  3 variable(10)	ptr unal,
  5    24 	  3 number	fixed bin(17),
  5    25 	  3 size		fixed bin(8),
  5    26 	  3 length	fixed bin(8),
  5    27 	  3 offset	fixed bin(8),
  5    28 	  3 constant	fixed bin(24),
  5    29 	  3 changed	fixed bin(18),
  5    30 	  3 instruction	bit(36),
  5    31 	  3 locked	bit(1) aligned,
  5    32 	  3 number_h_o	fixed bin,
  5    33 	  3 has_offset(3)	ptr unal,
  5    34 	2 string_reg,
  5    35 	  3 variable	ptr unal,
  5    36 	  3 size		fixed bin(8),
  5    37 	  3 offset	fixed bin(8),
  5    38 	2 complex_reg,
  5    39 	  3 variable	ptr unal,
  5    40 	  3 size		fixed bin(8),
  5    41 	  3 scale		fixed bin(8),
  5    42 	2 decimal_reg,
  5    43 	  3 variable	ptr unal,
  5    44 	  3 size		fixed bin(8),
  5    45 	  3 scale		fixed bin(8),
  5    46 	2 index_regs(0:7),
  5    47 	  3 variable	ptr unal,
  5    48 	  3 constant	fixed bin,
  5    49 	  3 type		fixed bin(8),
  5    50 	  3 used		fixed bin(18),
  5    51 	  3 changed	fixed bin(18),
  5    52 	  3 instruction	bit(36),
  5    53 	  3 filler	fixed bin,
  5    54 	2 base_regs(0:7),
  5    55 	  3 variable	ptr unal,
  5    56 	  3 constant	fixed bin,
  5    57 	  3 type		fixed bin(8),
  5    58 	  3 pad (12)	fixed bin,	/* future...room to make 5 element array for variable, constant, type */
  5    59 	  3 number	fixed bin (17),	/* future...number of valid elements in array */
  5    60 	  3 used		fixed bin(18),
  5    61 	  3 changed	fixed bin(18),
  5    62 	  3 instruction	bit(36),
  5    63 	  3 locked	fixed bin(2),
  5    64 	2 indicators_ref(2:3) ptr unal;
  5    65 
  5    66 /* Permissible values for machine_state.indicators. */
  5    67 
  5    68 dcl (	ind_known_refs	init (-2),		/* set by comparison of known, nonzero, references */
  5    69 	ind_invalid	init (-1),
  5    70 	ind_string_aq	init (0),			/* logical value in storage */
  5    71 	ind_logical	init (1),			/* logical value in A or AQ */
  5    72 	ind_arithmetic	init (2),			/* arith value in Q, AQ, or EAQ */
  5    73 	ind_x (0:7)	init (6, 7, 8, 9, 10, 11, 12, 13),
  5    74 	ind_decimal_reg	init (14)
  5    75 	) fixed bin internal static options (constant);
  5    76 
  5    77 /* END INCLUDE FILE ... machine_state.incl.pl1 */
       74 
  6     1 dcl	bases(0:7) bit(3) aligned int static init("000"b, "010"b, "100"b,  "001"b, "011"b, "101"b, "111"b,"110"b)
  6     2 	options(constant);
  6     3 
  6     4 dcl (	ap	defined(bases(0)),
  6     5 	bp	defined(bases(1)),
  6     6 	lp	defined(bases(2)),
  6     7 	sp	defined(bases(7))) bit(3) aligned;
  6     8 
  6     9 dcl (	ab	defined(bases(3)),
  6    10 	bb	defined(bases(4)),
  6    11 	lb	defined(bases(5)),
  6    12 	sb	defined(bases(6))) bit(3) aligned;
  6    13 
  6    14 dcl	which_base(0:7) fixed bin int static init(0,3,1,4,2,5,7,6) options(constant);
       75 
  7     1 /* BEGIN INCLUDE FILE ... boundary.incl.pl1 */
  7     2 
  7     3 /* Modified: 26 Apr 1979 by PCK to implement 4-bit decimal */
  7     4 
  7     5 dcl (	bit_		init(1),
  7     6 	digit_		init(2),
  7     7 	character_	init(3),
  7     8 	half_		init(4),
  7     9 	word_		init(5),
  7    10 	mod2_		init(6),
  7    11 	mod4_		init(7)) fixed bin(3) int static options(constant);
  7    12 
  7    13 /* END INCLUDE FILE ... boundary.incl.pl1 */
       76 
       77 
       78 	if size <= a_reg.size then return;
       79 
       80 	if a_reg.length < size
       81 	then do;
       82 	     call expmac((anaq),c_a((a_reg.size),5));
       83 	     a_reg.length = bits_per_two_words;
       84 	     end;
       85 
       86 	if type = bit_string then a_reg.size = a_reg.length;
       87 	else do;
       88 	     call expmac((oraq),c_a((a_reg.size),6));
       89 	     if size < bits_per_two_words then call expmac((anaq),c_a(size,5));
       90 	     a_reg.size = size;
       91 	     end;
       92 
       93 	return;
       94 
       95 aq_man$save_aq: entry(pt,pad);
       96 
       97 dcl	pt ptr,		/* points at reference node of value in aq */
       98 	pad fixed bin;	/* ^= 0 means clear_q when storing */
       99 
      100 	p = pt;
      101 
      102 	k = p -> reference.data_type;
      103 	if k <= real_flt_bin_2
      104 	then do;
      105 	     arith = "1"b;
      106 	     macro = stfx1 - 1 + k;
      107 	     goto store;
      108 	     end;
      109 
      110 	arith = "0"b;
      111 
      112 	if a_reg.size <= bits_per_word
      113 	then if pad = 0 then k = 0;
      114 	     else do;
      115 		k = 1;
      116 		call aq_man$clear_q;
      117 		end;
      118 	else do;
      119 	     if a_reg.length < bits_per_two_words then call expmac((anaq),c_a((a_reg.size),5));
      120 	     k = 2;
      121 	     end;
      122 
      123 store:	if p -> reference.temp_ref
      124 	then do;
      125 	     if p -> reference.shared
      126 	     then do;
      127 		p, pt = copy_temp(p);
      128 		p -> reference.ref_count = 2;
      129 		end;
      130 	     else p -> reference.ref_count = p -> reference.ref_count + 1;
      131 
      132 	     if arith then call expmac(macro,p); else call expmac$one((sta),p,k);
      133 	     end;
      134 
      135 	else do;
      136 	     if arith
      137 		then call expmac(macro,cg_stat$double_temp);
      138 		else call expmac$one((sta),cg_stat$double_temp,k);
      139 
      140 	     string(p -> reference.address) = string(cg_stat$double_temp -> reference.address);
      141 	     p -> reference.relocation = cg_stat$double_temp -> reference.relocation;
      142 	     p -> reference.perm_address = "1"b;
      143 	     p -> reference.even = "1"b;
      144 	     end;
      145 
      146 	p -> reference.value_in.storage = "1"b;
      147 	return;
      148 
      149 aq_man$clear_q: entry;
      150 
      151 	k = bits_per_word;
      152 	goto trim;
      153 
      154 aq_man$trim_aq: entry(n_bits);
      155 
      156 dcl	n_bits fixed bin;
      157 
      158 	k = n_bits;
      159 	call aq_man$check_strings(k);
      160 
      161 	/* check to see if last instruction was also a trimming instruction */
      162 
      163 trim:	p = addrel(cg_stat$text_base,cg_stat$text_pos - 1);
      164 
      165 	if (p -> word & "111000000000000000111111111111111111"b)
      166 		   ^= "000000000000000000011111111001000000"b		/* anaq ap|0 */
      167 	then goto gen;
      168 
      169 	if fixed(substr(p -> word,4,15),15) <= bits_per_four_words
      170 	then do;
      171 	     substr(p -> word,4,15) = bit(fixed(2*k,15),15);
      172 	     goto len;
      173 	     end;
      174 
      175 gen:	if k < bits_per_two_words
      176 	     then call expmac((anaq),c_a(k,5));
      177 	a_reg.length = bits_per_two_words;
      178 
      179 len:	a_reg.size = k - a_reg.offset;
      180 	return;
      181 
      182 aq_man$check_strings: entry(n_bits);
      183 
      184 	/* check to make sure that no bits will get lost from any string
      185*	   currently held in a register.  If bits will be lost, value must
      186*	   be saved if not already in storage */
      187 
      188 	n = a_reg.number;
      189 	do i = 1 by 1 while(i <= n);
      190 check:	     p = a_reg.variable(i);
      191 
      192 	     if p -> reference.data_type >= lbound(convert_size,1)
      193 		then j = p -> reference.c_length * convert_size(p -> reference.data_type);
      194 		else j = p -> reference.c_length;
      195 
      196 	     if n_bits - a_reg.offset < j
      197 	     then do;
      198 		if ^ p -> reference.temp_ref then goto drop;
      199 		if p -> reference.value_in.storage then goto drop;
      200 		if p -> reference.ref_count < 1 then goto drop;
      201 
      202 		/* have to save value */
      203 
      204 		p -> reference.store_ins = bit(cg_stat$text_pos,18);
      205 		p -> reference.ref_count = p -> reference.ref_count + 1;
      206 
      207 		call expmac$one((sta),p,fixed(j > bits_per_word,1));
      208 
      209 		p -> reference.value_in.storage = "1"b;
      210 
      211 drop:		p -> reference.value_in.a = "0"b;
      212 
      213 		n = n - 1;
      214 		a_reg.number = n;
      215 		if n < i then return;
      216 
      217 		do j = i to n;
      218 		     a_reg.variable(j) = a_reg.variable(j+1);
      219 		     end;
      220 
      221 		goto check;
      222 		end;
      223 	     end;
      224 
      225 	return;
      226 
      227 
      228 aq_man$left_shift: entry(amt,long);
      229 
      230 dcl	amt fixed bin(8),		/* amount to shift */
      231 	long bit(1) aligned;	/* forces long shift */
      232 
      233 dcl	nregs fixed bin;		/* number of registers involved */
      234 dcl	amount fixed bin;		/* amount to shift */
      235 
      236 	amount = amt;
      237 
      238 	if long | a_reg.size + a_reg.offset > bits_per_word
      239 	     then nregs = 2;
      240 	     else nregs = 1;
      241 
      242 	call expmac(left_shift(nregs), c_a(amount,1));
      243 
      244 	a_reg.offset = a_reg.offset - amount;
      245 	if a_reg.length < bits_per_words(nregs)
      246 	     then a_reg.length = a_reg.length - amount;
      247 	     else a_reg.length = bits_per_words(nregs);
      248 
      249 	return;
      250 
      251 
      252 aq_man$right_shift: entry(amt,long);
      253 
      254 	amount = amt;
      255 
      256 	if long | a_reg.size + a_reg.offset + amount > bits_per_word
      257 	     then nregs = 2;
      258 	     else nregs = 1;
      259 
      260 	call expmac(right_shift(nregs), c_a(amount,1));
      261 
      262 	a_reg.offset = a_reg.offset + amount;
      263 	a_reg.length = min(a_reg.length + amount, bits_per_words(nregs));
      264 	return;
      265 
      266 
      267 aq_man$fix_scale: entry(pt,scale1,type1);
      268 
      269 dcl	(scale1,type1) fixed bin;
      270 dcl	ptype fixed bin;
      271 
      272 	ptype = pt -> reference.data_type;
      273 	n = scale1 - pt -> reference.symbol -> symbol.scale;
      274 	if n = 0
      275 	then do;
      276 	     if type1 > ptype
      277 		then call expmac$zero((rfb1_to_rfb2));
      278 	     return;
      279 	     end;
      280 
      281 	if type1 > ptype
      282 	then do;
      283 	     if n > bits_per_word
      284 	     then do;
      285 		macro = q_left_shift(2);
      286 		goto shift;
      287 		end;
      288 
      289 	     call expmac((q_left_shift(2)),c_a((bits_per_word),1));
      290 	     n = n - bits_per_word;
      291 
      292 	     if n = 0 then return;
      293 
      294 	     k = 2;
      295 	     end;
      296 
      297 	else k = ptype;
      298 
      299 	if n < 0
      300 	then do;
      301 	     call xr_man$load_const(abs(n),2);
      302 	     call expmac$zero((truncate(k)));
      303 	     end;
      304 
      305 	else do;
      306 	     macro = q_left_shift(k);
      307 shift:	     call expmac(macro,c_a(n,1));
      308 	     end;
      309 
      310 	return;
      311 
      312 /* The following section is called to load string offsets and string lengths into the a or q
      313*   for use by EIS instructions. */
      314 
      315 /* Load variable offset or length into a or q */
      316 
      317 aq_man$load_any_var:	entry(pt,ar,base_offset);
      318 
      319 dcl	ar fixed bin(2),		/* specifies reg to be loaded */
      320 	base_offset fixed bin(24);	/* base offset to add to pt */
      321 
      322 dcl	1 machine_overlay based(m_s_p),
      323 	2 node_type bit(9),
      324 	2 indicators fixed bin,
      325 	2 next,
      326 	2 aq_regs(2) like machine_state.a_reg;
      327 
      328 dcl	c fixed bin(24);
      329 dcl	l fixed bin;
      330 dcl	lock bit(1) aligned;
      331 dcl	cg_stat$cur_statement ptr ext static;
      332 
      333 dcl (	load_aq(2)	init(1,7),	/* lda, ldq */
      334 	add_aq(2)		init(645,19),	/* ada, adq */
      335 	right_shift_aq(2)	init(725,514))	/* ars, qrs */
      336 		fixed bin(15) int static options(constant);
      337 
      338 dcl	adjust_ref_count entry(ptr,fixed bin);
      339 dcl	generate_constant$real_fix_bin_1 entry(fixed bin(24)) returns(ptr);
      340 dcl	get_single_ref entry(ptr) returns(ptr);
      341 dcl	base_man$load_any_var_and_lock entry(fixed bin,ptr,bit(3) aligned);
      342 dcl	base_man$unlock entry (fixed bin);
      343 dcl	xr_man$load_any_var_and_lock entry(ptr,fixed bin(3),fixed bin(18));
      344 dcl	error entry(fixed bin,ptr,ptr);
      345 
      346 	lock = "0"b;
      347 	p = pt;
      348 	c = base_offset;
      349 
      350 search:	j = -1;
      351 	do i = 1 to 2;
      352 		do l = 1 to aq_regs(i).number;
      353 		     if aq_regs(i).variable(l) = p
      354 		     then do;
      355 			j = i;
      356 			if aq_regs(i).constant = c
      357 			then do;
      358 			     if ^ p -> reference.shared
      359 				then call adjust_ref_count(p,-1);
      360 			     go to return_i;
      361 			     end;
      362 			end;
      363 		end;
      364 	end;
      365 
      366 	i = get_free_aq();
      367 	if i ^= 0
      368 	     then call load_aq_var;
      369 
      370 return_i:	ar = i;
      371 	if lock
      372 	then do;
      373 	     aq_regs(i).locked = "1"b;
      374 	     aq_regs(i).number_h_o = 0;
      375 	     end;
      376 	return;
      377 
      378 /* Load constant offset or length into a or q */
      379 
      380 aq_man$load_any_const:	entry(base_offset,ar);
      381 
      382 	lock = "0"b;
      383 	p = generate_constant$real_fix_bin_1(base_offset);
      384 	c = 0;
      385 	go to search;
      386 
      387 aq_man$lock:	entry(pt,ar);
      388 
      389 	i = ar;
      390 
      391 	if pt ^= null & (^ aq_regs(i).locked | aq_regs(i).number_h_o ^= 0)
      392 	then do;
      393 	     j, aq_regs(i).number_h_o = aq_regs(i).number_h_o + 1;
      394 	     aq_regs(i).has_offset(j) = pt;
      395 	     end;
      396 	else aq_regs(i).number_h_o = 0;
      397 
      398 	aq_regs(i).locked = "1"b;
      399 
      400 	return;
      401 
      402 /* Load variable offset or length into a or q and lock */
      403 
      404 aq_man$load_any_var_and_lock:	entry(pt,ar);
      405 
      406 	lock = "1"b;
      407 	p = pt;
      408 	c = 0;
      409 	go to search;
      410 
      411 /* Load item into specified register */
      412 
      413 aq_man$load_var:	entry(pt,ar);
      414 
      415 	p = pt;
      416 	i = ar;
      417 
      418 	if substr(string(p -> reference.value_in),i,1)
      419 	then do;
      420 	     if ^ p -> reference.shared
      421 		then call adjust_ref_count(p,-1);
      422 	     return;
      423 	     end;
      424 
      425 	j = -1;
      426 	c = 0;
      427 	call load_aq_var;
      428 	return;
      429 
      430 /* Find a register in which to load the reference */
      431 
      432 get_free_aq:	proc() returns(fixed bin);
      433 
      434 dcl	(i,k,count(2)) fixed bin;
      435 dcl	q ptr;
      436 dcl	base bit(3) aligned;
      437 dcl	xr fixed bin(3);
      438 dcl	tag bit(6) aligned;
      439 
      440 	if aq_regs(1).locked
      441 	then if aq_regs(2).locked
      442 	     then do;
      443 
      444 		do i = 1 to 2;
      445 		if aq_regs(i).number_h_o ^= 0
      446 		then do;
      447 		     if aq_regs(i).constant = 0 & aq_regs(i).number ^= 0 & ^ aq_regs(i).has_offset(1) -> reference.big_offset
      448 		     then do;
      449 			q = aq_regs(i).variable(1);
      450 
      451 			if ^ q -> reference.shared
      452 			then q -> reference.ref_count = q -> reference.ref_count + 1;
      453 
      454 			call xr_man$load_any_var_and_lock(q,xr,0);
      455 
      456 			tag = "001"b || bit(xr,3);
      457 
      458 			do k = 1 to aq_regs(i).number_h_o;
      459 			aq_regs(i).has_offset(k) -> address.tag = tag;
      460 			end;
      461 
      462 		     end;
      463 
      464 		     else do k = 1 to aq_regs(i).number_h_o;
      465 			q = aq_regs(i).has_offset(k);
      466 
      467 			if k < aq_regs(i).number_h_o | q -> reference.c_f_offset = 0
      468 			then q -> reference.perm_address = "1"b;
      469 			else do;
      470 			     aq_regs(i).locked = "0"b;
      471 			     aq_regs(i).number_h_o = 0;
      472 			     end;
      473 
      474 
      475 			if q -> reference.ext_base
      476 			then if q -> address.base ^= sp
      477 			     then call base_man$unlock(which_base(fixed(q -> address.base,3)));
      478 
      479 			if ^q -> reference.shared
      480 			then q -> reference.ref_count = q -> reference.ref_count + 1;
      481 
      482 			call base_man$load_any_var_and_lock(2,q,base);
      483 
      484 			end;
      485 
      486 		     aq_regs(i).locked = "0"b;
      487 		     aq_regs(i).number_h_o = 0;
      488 		     return(i);
      489 		     end;
      490 		end;
      491 
      492 		call error(329,cg_stat$cur_statement,p);
      493 		lock = "0"b;
      494 		return(0);
      495 		end;
      496 	     else return(2);
      497 	else if aq_regs(2).locked
      498 	     then return(1);
      499 
      500 	if j > 0 then return(j);
      501 
      502 	do i = 1 to 2;
      503 	     if aq_regs(i).number = 0
      504 		then return(i);
      505 	end;
      506 
      507 	do i = 1 to 2;
      508 	     count(i) = 0;
      509 	     do k = 1 to aq_regs(i).number;
      510 		count(i) = count(i) + aq_regs(i).variable(k) -> reference.ref_count;
      511 	     end;
      512 	end;
      513 
      514 	if count(1) < count(2)
      515 	then return(1);
      516 	else if count(2) < count(1)
      517 	     then return(2);
      518 
      519 	if aq_regs(1).changed < aq_regs(2).changed
      520 	     then return(1);
      521 	     else return(2);
      522 end;
      523 
      524 
      525 /* Load the specified register */
      526 
      527 load_aq_var:	proc();
      528 
      529 dcl	(cp,q) ptr;
      530 dcl	c1 fixed bin(24);
      531 
      532 	q = p;
      533 	c1 = c;
      534 
      535 	if p -> reference.data_type = real_fix_bin_2
      536 	     then q = get_single_ref(p);
      537 
      538 	if j = i
      539 	then do;
      540 	     c1 = c - aq_regs(i).constant;
      541 	     if ^ q -> reference.shared
      542 		then call adjust_ref_count(q,-1);
      543 	     end;
      544 
      545 	else do;
      546 	     if q -> reference.temp_ref
      547 	     then if ^ q -> reference.value_in.storage
      548 		then if q -> reference.value_in.q
      549 		     then call aq_man$save_aq(q,0);
      550 
      551 	     call expmac((load_aq(i)),q);
      552 
      553 	     if ^ q -> reference.aligned_ref
      554 	     then if q -> reference.units = word_ & q -> reference.c_length = bits_per_half
      555 		then call expmac(right_shift_aq(i),c_a((bits_per_half),1));
      556 		else call error(367,cg_stat$cur_statement,q);
      557 	     end;
      558 
      559 	if c1 ^= 0
      560 	then do;
      561 	     if c1 > 0 & c1 < 262144
      562 	     then cp = c_a((c1),2);
      563 	     else cp = generate_constant$real_fix_bin_1(c1);
      564 	     call expmac((add_aq(i)),cp);
      565 	     end;
      566 
      567 	if i = 1
      568 	     then aq_regs(1).offset, aq_regs(1).size = 0;
      569 	aq_regs(i).constant = c;
      570 	aq_regs(i).number = 1;
      571 	aq_regs(i).variable(1) = p;
      572 	if c = 0
      573 	     then substr(string(p -> reference.value_in),i,1) = "1"b;
      574 end;
      575 
      576 end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/03/83  1007.8  aq_man.pl1                        >spec>on>pl128d>aq_man.pl1
70           1    10/25/79  1645.8  cgsystem.incl.pl1                 >ldd>include>cgsystem.incl.pl1
71           2    07/21/80  1546.3  cg_reference.incl.pl1             >ldd>include>cg_reference.incl.pl1
72           3    10/02/83  0828.4  symbol.incl.pl1                   >spec>on>pl128d>symbol.incl.pl1
73           4    05/03/76  1320.4  data_types.incl.pl1               >ldd>include>data_types.incl.pl1
74           5    11/13/79  1015.8  machine_state.incl.pl1            >ldd>include>machine_state.incl.pl1
75           6    05/03/76  1320.8  bases.incl.pl1                    >ldd>include>bases.incl.pl1
76           7    10/25/79  1645.8  boundary.incl.pl1                 >ldd>include>boundary.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a                        11(09)        based           bit(1)                   level 4 packed unaligned dcl 2-3 set ref 211*
a_reg                     3            based           structure                level 2 dcl 5-6
abs                                                    builtin function         dcl 58 ref 301 301
add_aq                          000002 constant        fixed bin(15,0)          initial array dcl 333 ref 564
addrel                                                 builtin function         dcl 58 ref 163
address                  10            based           structure                level 2 packed unaligned dcl 2-3 set ref 140* 140
adjust_ref_count                000042 constant        entry                    external dcl 338 ref 358 420 541
aligned_ref              12(07)        based           bit(1)                   level 3 packed unaligned dcl 2-3 ref 553
amount                          000113 automatic       fixed bin(17,0)          dcl 234 set ref 236* 242* 242* 244 245 254* 256 260*
                                                                                  260* 262 263
amt                                    parameter       fixed bin(8,0)           dcl 230 ref 228 236 252 254
anaq                                   constant        fixed bin(15,0)          initial dcl 60 ref 82 89 119 175
aq_man$check_strings            000026 constant        entry                    external dcl 49 ref 159
aq_man$clear_q                  000030 constant        entry                    external dcl 49 ref 116
aq_regs                   3            based           structure                array level 2 unaligned dcl 322
ar                                     parameter       fixed bin(2,0)           dcl 319 set ref 317 370* 380 387 389 404 413 416
arith                           000104 automatic       bit(1)                   unaligned dcl 42 set ref 105* 110* 132 136
base                            000140 automatic       bit(3)                   dcl 436 in procedure "get_free_aq" set ref 482*
base                     10            based           bit(3)                   level 3 in structure "reference" packed unaligned
                                                                                  dcl 2-3 in procedure "aq_man$pad_aq" set ref 475
                                                                                  475
base_man$load_any_var_and_lock  000050 constant        entry                    external dcl 341 ref 482
base_man$unlock                 000052 constant        entry                    external dcl 342 ref 475
base_offset                            parameter       fixed bin(24,0)          dcl 319 set ref 317 348 380 383*
bases                           000016 constant        bit(3)                   initial array dcl 6-1 ref 475 475
big_offset               11(33)        based           bit(1)                   level 4 packed unaligned dcl 2-3 ref 447
bit                                                    builtin function         dcl 58 ref 171 204 456
bit_string                             constant        fixed bin(15,0)          initial dcl 4-1 ref 86
bits                     12(06)        based           structure                level 2 packed unaligned dcl 2-3
bits_per_four_words                    constant        fixed bin(8,0)           initial dcl 1-5 ref 169
bits_per_half                          constant        fixed bin(8,0)           initial dcl 1-5 ref 553 553 553
bits_per_two_words                     constant        fixed bin(8,0)           initial dcl 1-5 ref 83 89 119 175 177
bits_per_word                          constant        fixed bin(8,0)           initial dcl 1-5 ref 112 151 207 207 238 256 283 289
                                                                                  289 290
bits_per_words                  000030 constant        fixed bin(8,0)           initial array dcl 1-5 ref 245 247 263
c                               000115 automatic       fixed bin(24,0)          dcl 328 set ref 348* 356 384* 408* 426* 533 540 569
                                                                                  572
c1                              000160 automatic       fixed bin(24,0)          dcl 530 set ref 533* 540* 559 561 561 561 563*
c_a                             000032 constant        entry                    external dcl 49 ref 82 82 88 88 89 89 119 119 175
                                                                                  175 242 242 260 260 289 289 307 307 553 553 561
c_f_offset                7            based           fixed bin(6,0)           level 2 dcl 2-3 ref 467
c_length                  2            based           fixed bin(24,0)          level 2 dcl 2-3 ref 192 194 553
cg_stat$cur_statement           000040 external static pointer                  dcl 331 set ref 492* 556*
cg_stat$double_temp             000010 external static pointer                  dcl 39 set ref 136* 138* 140 141
cg_stat$text_base               000012 external static pointer                  dcl 39 ref 163
cg_stat$text_pos                000014 external static fixed bin(17,0)          dcl 39 ref 163 204
cg_static_$m_s_p                000036 external static pointer                  dcl 5-3 ref 5-3
changed                  22            based           fixed bin(18,0)          array level 3 dcl 322 ref 519 519
constant                 21            based           fixed bin(24,0)          array level 3 dcl 322 set ref 356 447 540 569*
convert_size                    000026 constant        fixed bin(8,0)           initial array dcl 1-5 ref 192 192
copy_temp                       000034 constant        entry                    external dcl 49 ref 127
count                           000134 automatic       fixed bin(17,0)          array dcl 434 set ref 508* 510* 510 514 514 516 516
cp                              000154 automatic       pointer                  dcl 529 set ref 561* 563* 564*
data_type                12            based           fixed bin(5,0)           level 2 packed unaligned dcl 2-3 ref 102 192 192 272
                                                                                  535
error                           000056 constant        entry                    external dcl 344 ref 492 556
even                     12(17)        based           bit(1)                   level 3 packed unaligned dcl 2-3 set ref 143*
expmac                          000016 constant        entry                    external dcl 49 ref 82 88 89 119 132 136 175 242 260
                                                                                  289 307 551 553 564
expmac$one                      000022 constant        entry                    external dcl 49 ref 132 138 207
expmac$zero                     000020 constant        entry                    external dcl 49 ref 276 302
ext_base                 10(29)        based           bit(1)                   level 3 packed unaligned dcl 2-3 set ref 475
fixed                                                  builtin function         dcl 58 ref 169 171 207 207 475
generate_constant$real_fix_bin_1
                                000044 constant        entry                    external dcl 339 ref 383 563
get_single_ref                  000046 constant        entry                    external dcl 340 ref 535
has_offset               26            based           pointer                  array level 3 packed unaligned dcl 322 set ref 394*
                                                                                  447 459 465
i                               000132 automatic       fixed bin(17,0)          dcl 434 in procedure "get_free_aq" set ref 444* 445
                                                                                  447 447 447 449 458 459 464 465 467 470 471 486
                                                                                  487 488* 502* 503 503* 507* 508 509 510 510 510*
i                               000100 automatic       fixed bin(17,0)          dcl 42 in procedure "aq_man$pad_aq" set ref 189*
                                                                                  189* 190 215 217* 351* 352 353 355 356* 366* 367
                                                                                  370 373 374 389* 391 391 393 393 394 396 398 416*
                                                                                  418 538 540 551 553 564 567 569 570 571 572
info                     11            based           structure                level 2 packed unaligned dcl 2-3
j                               000101 automatic       fixed bin(17,0)          dcl 42 set ref 192* 194* 196 207 207 217* 218 218*
                                                                                  350* 355* 393* 394 425* 500 500 538
k                               000133 automatic       fixed bin(17,0)          dcl 434 in procedure "get_free_aq" set ref 458* 459*
                                                                                  464* 465 467* 509* 510*
k                               000102 automatic       fixed bin(17,0)          dcl 42 in procedure "aq_man$pad_aq" set ref 102* 103
                                                                                  106 112* 115* 120* 132* 138* 151* 158* 159* 171
                                                                                  175 175* 175* 179 294* 297* 302 306
l                               000116 automatic       fixed bin(17,0)          dcl 329 set ref 352* 353*
lbound                                                 builtin function         dcl 58 ref 192
left_shift                      000034 constant        fixed bin(15,0)          initial array dcl 60 set ref 242*
length                   17            based           fixed bin(8,0)           level 3 dcl 5-6 set ref 80 83* 86 119 177* 245 245*
                                                                                  245 247* 263* 263
load_aq                         000004 constant        fixed bin(15,0)          initial array dcl 333 ref 551
lock                            000117 automatic       bit(1)                   dcl 330 set ref 346* 371 382* 406* 493*
locked                   24            based           bit(1)                   array level 3 dcl 322 set ref 373* 391 398* 440 440
                                                                                  470* 486* 497
long                                   parameter       bit(1)                   dcl 230 ref 228 238 252 256
m_s_p                           000110 automatic       pointer                  initial dcl 5-3 set ref 78 80 82 82 83 86 86 88 88
                                                                                  90 112 119 119 119 177 179 179 188 190 196 214 218
                                                                                  218 238 238 244 244 245 245 245 247 256 256 262
                                                                                  262 263 263 352 353 356 373 374 391 391 393 393
                                                                                  394 396 398 5-3* 440 440 445 447 447 447 449 458
                                                                                  459 464 465 467 470 471 486 487 497 503 509 510
                                                                                  519 519 540 567 567 569 570 571
machine_overlay                        based           structure                level 1 unaligned dcl 322
machine_state                          based           structure                level 1 dcl 5-6
macro                           000105 automatic       fixed bin(15,0)          dcl 42 set ref 106* 132* 136* 285* 306* 307*
min                                                    builtin function         dcl 58 ref 263
n                               000103 automatic       fixed bin(17,0)          dcl 42 set ref 188* 189 213* 213 214 215 217 273*
                                                                                  274 283 290* 290 292 299 301 301 307* 307*
n_bits                                 parameter       fixed bin(17,0)          dcl 156 ref 154 158 182 196
nregs                           000112 automatic       fixed bin(17,0)          dcl 233 set ref 238* 240* 242 245 247 256* 258* 260
                                                                                  263
null                                                   builtin function         dcl 58 ref 391
number                   15            based           fixed bin(17,0)          level 3 in structure "machine_state" dcl 5-6
                                                                                  in procedure "aq_man$pad_aq" set ref 188 214*
number                   15            based           fixed bin(17,0)          array level 3 in structure "machine_overlay" dcl 322
                                                                                  in procedure "aq_man$pad_aq" set ref 352 447 503
                                                                                  509 570*
number_h_o               25            based           fixed bin(17,0)          array level 3 dcl 322 set ref 374* 391 393 393* 396*
                                                                                  445 458 464 467 471* 487*
offset                   20            based           fixed bin(8,0)           level 3 in structure "machine_state" dcl 5-6
                                                                                  in procedure "aq_man$pad_aq" set ref 179 196 238
                                                                                  244* 244 256 262* 262
offset                   20            based           fixed bin(8,0)           array level 3 in structure "machine_overlay" dcl 322
                                                                                  in procedure "aq_man$pad_aq" set ref 567*
oraq                                   constant        fixed bin(15,0)          initial dcl 60 ref 88
other                    11(33)        based           structure                level 3 packed unaligned dcl 2-3
p                               000106 automatic       pointer                  dcl 42 set ref 100* 102 123 125 127* 127* 128 130
                                                                                  130 132* 132* 140 141 142 143 146 163* 165 169 171
                                                                                  190* 192 192 192 194 198 199 200 204 205 205 207*
                                                                                  209 211 347* 353 358 358* 383* 407* 415* 418 420
                                                                                  420* 492* 532 535 535* 571 572
pad                                    parameter       fixed bin(17,0)          dcl 97 ref 95 112
perm_address             12(18)        based           bit(1)                   level 3 packed unaligned dcl 2-3 set ref 142* 467*
pt                                     parameter       pointer                  dcl 97 set ref 95 100 127* 267 272 273 317 347 387
                                                                                  391 394 404 407 413 415
ptype                           000114 automatic       fixed bin(17,0)          dcl 270 set ref 272* 276 281 297
q                               000136 automatic       pointer                  dcl 435 in procedure "get_free_aq" set ref 449* 451
                                                                                  451 451 454* 465* 467 467 475 475 475 479 479 479
                                                                                  482*
q                        11(10)        based           bit(1)                   level 4 in structure "reference" packed unaligned
                                                                                  dcl 2-3 in procedure "aq_man$pad_aq" ref 546
q                               000156 automatic       pointer                  dcl 529 in procedure "load_aq_var" set ref 532* 535*
                                                                                  541 541* 546 546 546 546* 551* 553 553 553 556*
q_left_shift                    000036 constant        fixed bin(15,0)          initial array dcl 60 ref 285 289 306
real_fix_bin_2                         constant        fixed bin(15,0)          initial dcl 4-1 ref 535
real_flt_bin_2                         constant        fixed bin(15,0)          initial dcl 4-1 ref 103
ref_count                 0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 2-3 set ref 128* 130*
                                                                                  130 200 205* 205 451* 451 479* 479 510
reference                              based           structure                level 1 dcl 2-3
relocation               12(24)        based           bit(12)                  level 2 packed unaligned dcl 2-3 set ref 141* 141
rfb1_to_rfb2                           constant        fixed bin(15,0)          initial dcl 60 ref 276
right_shift                     000032 constant        fixed bin(15,0)          initial array dcl 60 set ref 260*
right_shift_aq                  000000 constant        fixed bin(15,0)          initial array dcl 333 set ref 553*
scale                     2(28)        based           fixed bin(7,0)           level 2 packed unaligned dcl 3-3 ref 273
scale1                                 parameter       fixed bin(17,0)          dcl 269 ref 267 273
shared                    0(11)        based           bit(1)                   level 2 packed unaligned dcl 2-3 ref 125 358 420 451
                                                                                  479 541
size                     16            based           fixed bin(8,0)           array level 3 in structure "machine_overlay" dcl 322
                                                                                  in procedure "aq_man$pad_aq" set ref 567*
size                     16            based           fixed bin(8,0)           level 3 in structure "machine_state" dcl 5-6
                                                                                  in procedure "aq_man$pad_aq" set ref 78 82 82 86*
                                                                                  88 88 90* 112 119 119 179* 238 256
size                                   parameter       fixed bin(17,0)          dcl 36 in procedure "aq_man$pad_aq" set ref 34 78 80
                                                                                  89 89* 89* 90
sp                                     defined         bit(3)                   dcl 6-4 ref 475
sta                                    constant        fixed bin(15,0)          initial dcl 60 ref 132 138 207
stfx1                                  constant        fixed bin(15,0)          initial dcl 60 ref 106
storage                  11(23)        based           bit(1)                   level 4 packed unaligned dcl 2-3 set ref 146* 199
                                                                                  209* 546
store_ins                13(18)        based           bit(18)                  level 2 packed unaligned dcl 2-3 set ref 204*
string                                                 builtin function         dcl 58 set ref 140* 140 418 572
substr                                                 builtin function         dcl 58 set ref 169 171* 418 572*
symbol                                 based           structure                level 1 dcl 3-3 in procedure "aq_man$pad_aq"
symbol                    3            based           pointer                  level 2 in structure "reference" packed unaligned
                                                                                  dcl 2-3 in procedure "aq_man$pad_aq" ref 273
tag                      10(30)        based           bit(6)                   level 3 in structure "reference" packed unaligned
                                                                                  dcl 2-3 in procedure "aq_man$pad_aq" set ref 459*
tag                             000142 automatic       bit(6)                   dcl 438 in procedure "get_free_aq" set ref 456* 459
temp_ref                 12(11)        based           bit(1)                   level 3 packed unaligned dcl 2-3 ref 123 198 546
truncate                        000040 constant        fixed bin(15,0)          initial array dcl 60 ref 302
type                                   parameter       fixed bin(17,0)          dcl 36 ref 34 86
type1                                  parameter       fixed bin(17,0)          dcl 269 ref 267 276 281
units                     0(14)        based           fixed bin(3,0)           level 2 packed unaligned dcl 2-3 ref 553
value_in                 11(09)        based           structure                level 3 packed unaligned dcl 2-3 set ref 418 572
variable                  3            based           pointer                  array level 3 in structure "machine_state" packed
                                                                                  unaligned dcl 5-6 in procedure "aq_man$pad_aq" set
                                                                                  ref 190 218* 218
variable                  3            based           pointer                  array level 3 in structure "machine_overlay" packed
                                                                                  unaligned dcl 322 in procedure "aq_man$pad_aq" set
                                                                                  ref 353 449 510 571*
which_base                      000006 constant        fixed bin(17,0)          initial array dcl 6-14 set ref 475*
word                                   based           bit(36)                  dcl 47 set ref 165 169 171*
word_                                  constant        fixed bin(3,0)           initial dcl 7-5 ref 553
xr                              000141 automatic       fixed bin(3,0)           dcl 437 set ref 454* 456
xr_man$load_any_var_and_lock    000054 constant        entry                    external dcl 343 ref 454
xr_man$load_const               000024 constant        entry                    external dcl 49 ref 301

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ab                                     defined         bit(3)                   dcl 6-9
ap                                     defined         bit(3)                   dcl 6-4
bb                                     defined         bit(3)                   dcl 6-9
bit_                                   internal static fixed bin(3,0)           initial dcl 7-5
bits_per_char                          internal static fixed bin(8,0)           initial dcl 1-5
bits_per_packed_digit                  internal static fixed bin(8,1)           initial dcl 1-35
bp                                     defined         bit(3)                   dcl 6-4
break_even_bits                        internal static fixed bin(8,0)           initial dcl 1-5
break_even_words                       internal static fixed bin(8,0)           initial dcl 1-5
char_string                            internal static fixed bin(15,0)          initial dcl 4-1
character_                             internal static fixed bin(3,0)           initial dcl 7-5
chars_per_word                         internal static fixed bin(8,0)           initial dcl 1-5
complex_fix_bin_1                      internal static fixed bin(15,0)          initial dcl 4-1
complex_fix_bin_2                      internal static fixed bin(15,0)          initial dcl 4-1
complex_fix_dec                        internal static fixed bin(15,0)          initial dcl 4-1
complex_flt_bin_1                      internal static fixed bin(15,0)          initial dcl 4-1
complex_flt_bin_2                      internal static fixed bin(15,0)          initial dcl 4-1
complex_flt_dec                        internal static fixed bin(15,0)          initial dcl 4-1
convert_offset                         internal static fixed bin(8,1)           initial array dcl 1-35
default_fix_bin_p                      internal static fixed bin(8,0)           initial dcl 1-5
digit_                                 internal static fixed bin(3,0)           initial dcl 7-5
entry_variable                         internal static fixed bin(15,0)          initial dcl 4-1
ext_entry_in                           internal static fixed bin(15,0)          initial dcl 4-1
ext_entry_out                          internal static fixed bin(15,0)          initial dcl 4-1
half_                                  internal static fixed bin(3,0)           initial dcl 7-5
ind_arithmetic                         internal static fixed bin(17,0)          initial dcl 5-68
ind_decimal_reg                        internal static fixed bin(17,0)          initial dcl 5-68
ind_invalid                            internal static fixed bin(17,0)          initial dcl 5-68
ind_known_refs                         internal static fixed bin(17,0)          initial dcl 5-68
ind_logical                            internal static fixed bin(17,0)          initial dcl 5-68
ind_string_aq                          internal static fixed bin(17,0)          initial dcl 5-68
ind_x                                  internal static fixed bin(17,0)          initial array dcl 5-68
int_entry                              internal static fixed bin(15,0)          initial dcl 4-1
int_entry_other                        internal static fixed bin(15,0)          initial dcl 4-1
label_constant                         internal static fixed bin(15,0)          initial dcl 4-1
label_size                             internal static fixed bin(8,0)           initial dcl 1-5
label_variable                         internal static fixed bin(15,0)          initial dcl 4-1
lb                                     defined         bit(3)                   dcl 6-9
local_label_variable                   internal static fixed bin(15,0)          initial dcl 4-1
lp                                     defined         bit(3)                   dcl 6-4
max_dec_scale                          internal static fixed bin(8,0)           initial dcl 1-5
max_index_register_value               internal static fixed bin(31,0)          initial dcl 1-38
max_length_p                           internal static fixed bin(8,0)           initial dcl 1-5
max_offset                             internal static fixed bin(8,0)           initial array dcl 1-5
max_p_fix_bin_1                        internal static fixed bin(8,0)           initial dcl 1-5
max_p_fix_dec                          internal static fixed bin(8,0)           initial dcl 1-5
max_p_flt_bin_1                        internal static fixed bin(8,0)           initial dcl 1-5
max_p_xreg                             internal static fixed bin(8,0)           initial dcl 1-5
max_short_size                         internal static fixed bin(8,0)           initial array dcl 1-5
min_dec_scale                          internal static fixed bin(8,0)           initial dcl 1-5
mod2_                                  internal static fixed bin(3,0)           initial dcl 7-5
mod4_                                  internal static fixed bin(3,0)           initial dcl 7-5
packed_digits_per_char                 internal static fixed bin(8,0)           initial dcl 1-5
packed_digits_per_word                 internal static fixed bin(8,0)           initial dcl 1-5
packed_ptr                             internal static fixed bin(15,0)          initial dcl 4-1
real_fix_bin_1                         internal static fixed bin(15,0)          initial dcl 4-1
real_fix_dec                           internal static fixed bin(15,0)          initial dcl 4-1
real_flt_bin_1                         internal static fixed bin(15,0)          initial dcl 4-1
real_flt_dec                           internal static fixed bin(15,0)          initial dcl 4-1
sb                                     defined         bit(3)                   dcl 6-9
units_per_word                         internal static fixed bin(8,0)           initial array dcl 1-5
unpacked_ptr                           internal static fixed bin(15,0)          initial dcl 4-1

NAMES DECLARED BY EXPLICIT CONTEXT.
aq_man$check_strings            000653 constant        entry                    external dcl 182
aq_man$clear_q                  000517 constant        entry                    external dcl 149
aq_man$fix_scale                001215 constant        entry                    external dcl 267
aq_man$left_shift               001025 constant        entry                    external dcl 228
aq_man$load_any_const           001556 constant        entry                    external dcl 380
aq_man$load_any_var             001425 constant        entry                    external dcl 317
aq_man$load_any_var_and_lock    001655 constant        entry                    external dcl 404
aq_man$load_var                 001675 constant        entry                    external dcl 413
aq_man$lock                     001607 constant        entry                    external dcl 387
aq_man$pad_aq                   000067 constant        entry                    external dcl 34
aq_man$right_shift              001121 constant        entry                    external dcl 252
aq_man$save_aq                  000251 constant        entry                    external dcl 95 ref 546
aq_man$trim_aq                  000533 constant        entry                    external dcl 154
check                           000671 constant        label                    dcl 190 ref 221
drop                            000767 constant        label                    dcl 211 ref 198 199 200
gen                             000607 constant        label                    dcl 175 ref 165
get_free_aq                     001741 constant        entry                    internal dcl 432 ref 366
len                             000644 constant        label                    dcl 179 ref 172
load_aq_var                     002333 constant        entry                    internal dcl 527 ref 367 427
return_i                        001537 constant        label                    dcl 370 ref 360
search                          001445 constant        label                    dcl 350 ref 385 409
shift                           001372 constant        label                    dcl 307 ref 286
store                           000356 constant        label                    dcl 123 ref 107
trim                            000553 constant        label                    dcl 163 ref 152

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3334        3414    2637        3344
Length      4026    2637        60         376     474           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
aq_man$pad_aq                       158 external procedure  is an external procedure.  
get_free_aq                             internal procedure  shares stack frame of external procedure aq_man$pad_aq.  
load_aq_var                             internal procedure  shares stack frame of external procedure aq_man$pad_aq.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
aq_man$pad_aq            000100 i                           aq_man$pad_aq
                         000101 j                           aq_man$pad_aq
                         000102 k                           aq_man$pad_aq
                         000103 n                           aq_man$pad_aq
                         000104 arith                       aq_man$pad_aq
                         000105 macro                       aq_man$pad_aq
                         000106 p                           aq_man$pad_aq
                         000110 m_s_p                       aq_man$pad_aq
                         000112 nregs                       aq_man$pad_aq
                         000113 amount                      aq_man$pad_aq
                         000114 ptype                       aq_man$pad_aq
                         000115 c                           aq_man$pad_aq
                         000116 l                           aq_man$pad_aq
                         000117 lock                        aq_man$pad_aq
                         000132 i                           get_free_aq
                         000133 k                           get_free_aq
                         000134 count                       get_free_aq
                         000136 q                           get_free_aq
                         000140 base                        get_free_aq
                         000141 xr                          get_free_aq
                         000142 tag                         get_free_aq
                         000154 cp                          load_aq_var
                         000156 q                           load_aq_var
                         000160 c1                          load_aq_var

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               unpk_to_pk          call_ext_in         call_ext_out        return              ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
adjust_ref_count              aq_man$check_strings          aq_man$clear_q
base_man$load_any_var_and_lock                              base_man$unlock               c_a
copy_temp                     error                         expmac                        expmac$one
expmac$zero                   generate_constant$real_fix_bin_1                            get_single_ref
xr_man$load_any_var_and_lock  xr_man$load_const

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
cg_stat$cur_statement         cg_stat$double_temp           cg_stat$text_base             cg_stat$text_pos
cg_static_$m_s_p




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 5    3 000055        34 000063        78 000075        80 000102        82 000104        83 000136        86 000141
     88 000151        89 000204        90 000240        93 000244        95 000245       100 000257       102 000263
    103 000266       105 000270       106 000272       107 000275       110 000276       112 000277       115 000307
    116 000311       117 000316       119 000317       120 000354       123 000356       125 000362       127 000365
    128 000402       129 000405       130 000406       132 000413       132 000427       133 000444       136 000445
    138 000461       140 000476       141 000504       142 000506       143 000510       146 000512       147 000515
    149 000516       151 000525       152 000527       154 000530       158 000541       159 000544       163 000553
    165 000562       169 000566       171 000573       172 000606       175 000607       177 000641       179 000644
    180 000650       182 000651       188 000661       189 000664       190 000671       192 000675       194 000707
    196 000711       198 000717       199 000722       200 000725       204 000732       205 000741       207 000743
    209 000764       211 000767       213 000771       214 000773       215 000776       217 001001       218 001007
    219 001013       221 001015       223 001016       225 001020       228 001021       236 001033       238 001036
    240 001051       242 001053       244 001102       245 001105       247 001114       249 001116       252 001117
    254 001127       256 001132       258 001146       260 001150       262 001177       263 001202       264 001210
    267 001211       272 001223       273 001231       274 001241       276 001242       278 001256       281 001257
    283 001262       285 001265       286 001267       289 001270       290 001322       292 001324       294 001326
    295 001330       297 001331       299 001333       301 001335       302 001354       303 001366       306 001367
    307 001372       310 001420       317 001421       346 001436       347 001437       348 001443       350 001445
    351 001447       352 001455       353 001467       355 001501       356 001503       358 001507       360 001525
    363 001526       364 001530       366 001532       367 001534       370 001537       371 001542       373 001544
    374 001550       376 001551       380 001552       382 001567       383 001570       384 001601       385 001602
    387 001603       389 001615       391 001620       393 001634       394 001640       395 001644       396 001645
    398 001650       400 001652       404 001653       406 001663       407 001665       408 001671       409 001672
    413 001673       415 001703       416 001707       418 001711       420 001715       422 001733       425 001734
    426 001736       427 001737       428 001740       432 001741       440 001743       444 001750       445 001755
    447 001762       449 001773       451 001775       454 002005       456 002021       458 002030       459 002041
    460 002051       462 002053       464 002054       465 002063       467 002072       470 002104       471 002105
    475 002106       479 002125       482 002136       484 002153       486 002155       487 002161       488 002162
    490 002166       492 002170       493 002205       494 002206       496 002211       497 002214       500 002221
    502 002225       503 002233       505 002243       507 002245       508 002253       509 002254       510 002265
    511 002277       512 002301       514 002303       516 002312       519 002317       521 002327       527 002333
    532 002334       533 002336       535 002340       538 002355       540 002360       541 002367       543 002405
    546 002406       551 002431       553 002445       556 002513       559 002530       561 002532       563 002554
    564 002565       567 002601       569 002607       570 002614       571 002616       572 002622       574 002630


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
