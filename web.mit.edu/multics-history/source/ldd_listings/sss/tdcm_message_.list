	COMPILATION LISTING OF SEGMENT tdcm_message_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 03/21/86  1703.2 mst Fri
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* format: style4,delnl,insnl,indattr,ifthen,dclind9 */
       12 tdcm_message_:
       13      procedure (arg_tsegp, arg_ws_ptr, arg_reel_name, arg_write_sw, arg_ecode);
       14 
       15 /*	This program implements the tdcm_$tdcm_message entry point.
       16*   *	Created on 02/20/75 by Bill Silver.
       17*   *	Cleanup handler during block added 12/28/76 by Bernard Greenberg.
       18*   *	Modified on 09/19/77 by R.J.C. Kissel to fix bug in call to ipc_$decl_ev_call_chn.
       19*   *	Modified on 12/09/78 by Michael R. Jordan to use version 2 tape_info.
       20*   *	Modified 3/79 by Michael R. Jordan for MR7.0R to stop using rcp_$tape_message and always detach (with retain)
       21*   *	  and re-attach for multiple volumes.
       22*   *	Modified 7/79 by R.J.C. Kissel to use tseg version 1, to correct wrong drive name bug,
       23*   *	     and to ask RCP for the right density.
       24*   *
       25*   *      Modified 8/80 by R.L. Coppola to pass tseg.drive_name to tape_info.device_name.
       26*   *
       27*   *	This program is called to write a mount message on the operator's console.
       28*   *	However, the first time it is called no message is written.  Instead this
       29*   *	first call will actually perform the tape drive attachment.  For at least
       30*   *	a while, subsequent calls will result in a mount message being typed.
       31**/
       32 
       33 /*		ARGUMENTS  DATA		*/
       34 
       35 dcl      arg_ecode		  fixed bin (35);		/* (O) Standard error_table_ code. */
       36 dcl      arg_reel_name	  char (*);		/* (I) Tape reel ID name plus qualifiers. */
       37 dcl      arg_tsegp		  ptr;			/* (I) Pointer to user's tseg. */
       38 dcl      arg_write_sw	  fixed bin (1);		/* (I) 1 => write, 0 => read. */
       39 dcl      arg_ws_ptr		  ptr;			/* (I) Pointer to temporary workspace. */
       40 
       41 
       42 /*		AUTOMATIC  DATA		*/
       43 
       44 dcl      1 tape_info_buffer	  like tape_info;		/* Tape info structure needed by RCP. */
       45 
       46 dcl      temp_idcw		  bit (36) aligned;		/* Used to build read/write IDCW's. */
       47 dcl      system_flag	  bit (1);		/* ON => user wants to be a system process. */
       48 dcl      write_flag		  bit (1);		/* Used to copy arg_write_sw. */
       49 
       50 dcl      comment		  char (64);		/* Comment sent to RCP. */
       51 dcl      reel_name		  char (32);		/* Tape reel ID name. */
       52 dcl      temp_reel_name	  char (64);		/* Used to copy reel name argument. */
       53 
       54 dcl      real_ws_ptr	  ptr;			/* Pointer to actual IOI workspace segment. */
       55 
       56 dcl      delimx		  fixed bin;		/* Used to parse the reel name string. */
       57 dcl      drive_num		  fixed bin;		/* Number of the current drive. */
       58 dcl      ecode		  fixed bin (35);		/* Temporary error code. */
       59 dcl      i		  fixed bin;
       60 dcl      statex		  fixed bin;		/* RCP state index. */
       61 dcl      timeout_max	  fixed bin (71);		/* Maximum time-out interval. */
       62 dcl      workspace_max	  fixed bin (19);		/* Maximum size of IOI workspace. */
       63 dcl      workspace_size	  fixed bin (19);		/* Actual size of IOI workspace. */
       64 
       65 
       66 /*		BASED  DATA		*/
       67 
       68 dcl      based_idcw		  bit (36) based (idcwp) aligned;
       69 
       70 dcl      event_data		  (8) bit (36);		/* Not really used. */
       71 
       72 
       73 /*		INTERNAL STATIC DATA	*/
       74 
       75 dcl      read_idcw_commands	  (0:5) bit (6) internal static init ("000101"b,
       76 						/* Binary */
       77 			  "000100"b,		/* BCD */
       78 			  "000011"b,		/* 9 Track */
       79 			  "010100"b,		/* EBCDIC */
       80 			  "010111"b,		/* ASCII */
       81 			  "010101"b);		/* ASCII/EBCDIC */
       82 
       83 dcl      write_idcw_commands	  (0:5) bit (6) internal static init ("001101"b,
       84 						/* Binary */
       85 			  "001100"b,		/* BCD */
       86 			  "001011"b,		/* 9 Track */
       87 			  "011100"b,		/* EBCDIC */
       88 			  "011111"b,		/* ASCII */
       89 			  "011101"b);		/* ASCII/EBCDIC */
       90 
       91 
       92 /*		EXTERNAL ENTRIES CALLED	*/
       93 
       94 dcl      (addr, after, baseno, bit, decat, fixed, hbound, index, rel, rtrim, size, string, substr, unspec)
       95 			  builtin;
       96 
       97 dcl      error_table_$ionmat	  fixed bin (35) external;
       98 dcl      error_table_$big_ws_req
       99 			  fixed bin (35) external;
      100 dcl      error_table_$unimplemented_version
      101 			  fixed bin (35) external;
      102 
      103 dcl      com_err_		  entry options (variable);
      104 dcl      convert_ipc_code_	  entry (fixed bin (35));
      105 dcl      cv_dec_		  entry (char (*), fixed bin);
      106 dcl      get_process_id_	  entry returns (bit (36) aligned);
      107 dcl      hcs_$wakeup	  entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
      108 dcl      ioi_$set_event	  entry (fixed bin, fixed bin (71), fixed bin (35));
      109 dcl      ioi_$set_status	  entry (fixed bin, fixed bin (18), fixed bin, fixed bin (35));
      110 dcl      ioi_$timeout	  entry (fixed bin, fixed bin (71), fixed bin (35));
      111 dcl      ioi_$workspace	  entry (fixed bin, ptr, fixed bin (19), fixed bin (35));
      112 dcl      ipc_$block		  entry (ptr, ptr, fixed bin (35));
      113 dcl      ipc_$decl_ev_call_chn  entry (fixed bin (71), entry, ptr, fixed bin, fixed bin (35));
      114 dcl      ipc_$decl_ev_wait_chn  entry (fixed bin (71), fixed bin (35));
      115 dcl      rcp_$attach	  entry (char (*), ptr, fixed bin (71), char (*), bit (36) aligned, fixed bin (35));
      116 dcl      rcp_$check_attach	  entry (bit (36) aligned, ptr, char (*), fixed bin, fixed bin (19), fixed bin (71),
      117 			  fixed bin, fixed bin (35));
      118 dcl      rcp_$detach	  entry (bit (36) aligned, bit (*), fixed bin, char (*), fixed bin (35));
      119 dcl      tdcm_$special_handler  entry (ptr);
      120 
      121 /*		CONDITIONS		*/
      122 
      123 dcl      cleanup		  condition;
      124 
  1     1 /* Include segment tseg.incl.pl1 --- declaration for Tape DSM-DCM Interface Segment */
  1     2 /*   Modified 10 July 1973 by MJ Grady */
  1     3 /*   Modified 7/79 by R.J.C. Kissel to add a version number, tracks, density, and drive_name, and get rid of drive_number. */
  1     4 /*   Modified 5 August 1981 by Chris Jones to add speed specification */
  1     5 
  1     6 /* NB:  tape_ansi_cseg.incl.pl1 has a parallel version of this tseg declared in it.  Any changes made here MUST
  1     7*   be made there too. */
  1     8 
  1     9 /* format: style4,delnl,insnl,indattr,ifthen,dclind9 */
  1    10 dcl      (
  1    11          nbuffs		  init (12),		/* # of buffers in structure */
  1    12          max_rec_size	  init (2080)
  1    13          )		  fixed bin (17) int static;	/* Max # of words that may be transmitted (2 * 1040) */
  1    14 
  1    15 dcl      tsegp		  ptr;			/* Used to access Ring-0/Ring-4 shared structure */
  1    16 dcl      tseg_version_2	  fixed bin internal static options (constant) init (2);
  1    17 
  1    18 declare  1 tseg		  based (tsegp) aligned,
  1    19 	 2 version_num	  fixed bin,
  1    20 	 2 areap		  ptr,			/* pointer to DSM area */
  1    21 	 2 ev_chan	  fixed bin (71),		/* event channel number */
  1    22 	 2 write_sw	  fixed bin (1),		/* 0 = read, 1 = write */
  1    23 	 2 sync		  fixed bin (1),		/* non-zero for synchronous i/o */
  1    24 	 2 get_size	  fixed bin (1),		/* ON for record sizes to be returned */
  1    25 	 2 ws_segno	  bit (18),		/* segment number of IOI workspace */
  1    26 	 2 drive_name	  char (32),		/* physical drive name. */
  1    27 	 2 tracks		  fixed bin,		/* 0 = 9-track, 1 = 7-track. */
  1    28 	 2 density	  bit (36),		/* bits are 200, 556, 800 1600, 6250 respectively. */
  1    29 	 2 speed		  bit (36),		/* bits are 75, 125, 200 ips respectively */
  1    30 	 2 pad99 bit (36),				/* so that buffers start on an evenword boundary */
  1    31 	 2 buffer_offset	  fixed bin (12),		/* offset (from 1) of first buffer to be processed */
  1    32 	 2 buffer_count	  fixed bin (12),		/* number of buffers to be processed */
  1    33 	 2 completion_status  fixed bin (2),		/* 0 = no pending i/o or no status */
  1    34 						/* 1 = normal termination of i/o */
  1    35 						/* 2 = non-zero major status from previous i/o */
  1    36 	 2 hardware_status	  bit (36) aligned,		/* major and sub-status */
  1    37 	 2 error_buffer	  fixed bin (12),		/* buffer in which i/o error occurred */
  1    38 	 2 command_count	  fixed bin (12),		/* number of non-data commands to execute */
  1    39 	 2 command_queue	  (10) fixed bin (6) aligned, /* non-data-transfer commands */
  1    40 	 2 bufferptr	  (12) fixed bin (18) aligned,/* relative ptrs to buffers */
  1    41 	 2 buffer_size	  (12) fixed bin (18) aligned,/* size of buffer */
  1    42 	 2 mode		  (12) fixed bin (2) aligned, /* 0 = bin, 1 = bcd, 2 = 9 track */
  1    43 	 2 buffer		  (12) bit (37440) aligned,	/* data buffers - 1040 words */
  1    44 	 2 dsm_area	  area ((100 /* strictly nominal */));
  1    45 						/* DSM workspace */
  1    46 
  1    47 /* End include segment tseg.incl.pl1 */
      125 
      126 
  2     1 /*	Begin  include file ... tdcm_info.incl.pl1
  2     2*   *
  2     3*   *	Created on 02/20/75 by Bill Silver.
  2     4*   *	Modified 5/20/77 by Noel I. Morris for DCC.
  2     5*   *	Modified 3/19/82 by J. A. Bush for Marker interrupt processing
  2     6*   *	This include file defines the IOI workspace used by tdcm_.
  2     7**/
  2     8 dcl  ws_ptr ptr;					/* Pointer to base of tdcm_ IOI workspace. */
  2     9 
  2    10 dcl 1 ws based (ws_ptr) aligned,			/* Starts at base of ioi_ workspace. */
  2    11     2 info like ws_info,				/* See ws_info structure below. */
  2    12     2 ndt_list (10),				/* List of non-data transfer IDCWs. */
  2    13       3 idcw bit (36),				/* IDCWs. */
  2    14     2 rw_list (12),					/* DCW list for reads and writes. */
  2    15       3 idcw bit (36),				/* IDCW. */
  2    16       3 dcw bit (36),				/* DCW.  */
  2    17     2 mark_tdcw bit (36),				/* TDCW to chain the DCW list when processing Markers */
  2    18     2 statq (4) like istat,				/* A queue of IOI status entries. */
  2    19     2 pad_ev ptr,					/* to force buffer to even location */
  2    20     2 buffer (0 refer (ws.info.buf_size)) bit (36) aligned,
  2    21     2 buf_end bit (36);				/* Marks end of data buffer. */
  2    22 
  2    23 dcl 1 ws_info based aligned,				/* Control information. */
  2    24     2 flags,					/* All flags in one word. */
  2    25      (3 attached bit (1),				/* ON => tape drive has been attached. */
  2    26       3 connected bit (1),				/* ON => there is a connect in progress. */
  2    27       3 get_size bit (1),				/* ON => return actual read count. */
  2    28       3 ndtrans bit (1),				/* ON => non-data transfer type connect. */
  2    29       3 reading bit (1),				/* ON => connect issued for reading. */
  2    30       3 large_rec bit (1),				/* ON => transmitting record longer than 4096 words */
  2    31       3 allow_marker bit (1),				/* ON => Set up DCW list for marker interrupt processing */
  2    32       3 good_ws bit (1)) unaligned,			/* ON => can get a workspace big enough to satisfy user. */
  2    33     2 buf_size fixed bin,				/* Current size of tdcm_ I/O buffer. */
  2    34     2 rcp_id bit (36) aligned,			/* ID used to communicate with rcp_. */
  2    35     2 ioix fixed bin,				/* Index used to communicate with ioi_. */
  2    36     2 statqx fixed bin,				/* Index of current status queue entry. */
  2    37     2 process_id bit (36) aligned,			/* User's process ID. */
  2    38     2 tracks fixed bin,				/* Temporary place to save track type. */
  2    39     2 wait_list,					/* Used to block. */
  2    40       3 num_ev_chans fixed bin,			/* Number of channels in list. */
  2    41       3 wait_echan fixed bin (71),			/* Used to wait when blocked. */
  2    42     2 fast_echan fixed bin (71),			/* Fast event channel used to wait. */
  2    43     2 special_echan fixed bin (71),			/* Event call channel for special interrupts. */
  2    44     2 user_echan fixed bin (71),			/* Event channel set up by user in tseg. */
  2    45     2 init_echan fixed bin (71),			/* Event channel to use after drive attached. */
  2    46     2 meters,					/* temporary meters */
  2    47       3 last_io_time fixed bin (71),			/* clock time of last data xfer I/O */
  2    48       3 io_delta fixed bin (71),			/* total delta times */
  2    49       3 low_delta fixed bin (71),			/* lowest time between data xfer i/os */
  2    50       3 high_delta fixed bin (71),			/* longest time between data xfer i/os */
  2    51       3 number_ios fixed bin (35),			/* number of data xfer i/os */
  2    52       3 block fixed bin (35),				/* # of times we went blocked awaiting I/O to complete */
  2    53       3 no_block fixed bin (35),			/* # of times status queue precessed w/o going blocked */
  2    54       3 mark_st fixed bin (35),			/* # of marker interrupts received */
  2    55       3 term_st fixed bin (35),			/* # of term interrupts received */
  2    56       3 term_ne fixed bin (35),			/* # of term interrupts received with no error status */
  2    57       3 most_consec_mark fixed bin (35),		/* longest burst of marker interrupts processed */
  2    58       3 consec_mark fixed bin (35),			/* counter for keeping track of consecutive markers */
  2    59       3 block_count fixed bin,			/* highest number of blocks per I/O call */
  2    60     2 subset_size fixed bin,				/* max block size of data xfer I/O */
  2    61     2 detachx fixed bin,				/* Index that tells what has been set up. */
  2    62     2 disposition bit (1),				/* RCP assignment disposition. */
  2    63     2 read_start fixed bin,				/* First tseg buffer we are reading into. */
  2    64     2 buffer_size (12) fixed bin,			/* Data size in each workspace buffer. */
  2    65     2 ndt_offsetx fixed bin,				/* Offset of non-data transfer DCW list. */
  2    66     2 rw_offsetx fixed bin,				/* Offset of read/write DCW list. */
  2    67     2 mark_offset fixed bin,				/* buffer offset of last marker interrupt */
  2    68     2 error_count fixed bin,				/* Count of errors during attachment. */
  2    69     2 read_idcws (0:5) bit (36) aligned,		/* An array of read and write IDCW's. */
  2    70     2 write_idcws (0:5) bit (36) aligned;		/* One for each possible buffer in 1 connect. */
  2    71 
  2    72 /*	End of include file ... tdcm_info.incl.pl1	*/
      127 
      128 
  3     1 
  3     2 /* Begin include file ...... ioi_stat.incl.pl1 */
  3     3 /* Last modified 3/24/75 by Noel I. Morris */
  3     4 
  3     5 dcl  isp ptr;					/* pointer to status structure */
  3     6 
  3     7 dcl 1 istat based (isp) aligned,			/* I/O Interfacer status structure */
  3     8     2 completion,					/* completion flags */
  3     9      (3 st bit (1),					/* "1"b if status returned */
  3    10       3 er bit (1),					/* "1"b if status indicates error condition */
  3    11       3 run bit (1),				/* "1"b if channel still running */
  3    12       3 time_out bit (1)) unal,			/* "1"b if time-out occurred */
  3    13     2 level fixed bin (3),				/* IOM interrupt level */
  3    14     2 offset fixed bin (18),				/* DCW list offset */
  3    15     2 absaddr fixed bin (24),				/* absolute address of workspace */
  3    16     2 iom_stat bit (72),				/* IOM status */
  3    17     2 lpw bit (72);					/* LPW residue */
  3    18 
  3    19 dcl  imp ptr;					/* pointer to message structure */
  3    20 
  3    21 dcl 1 imess based (imp) aligned,			/* I/O Interfacer event message structure */
  3    22    (2 completion like istat.completion,			/* completion flags */
  3    23     2 pad bit (11),
  3    24     2 level bit (3),				/* interrupt level */
  3    25     2 offset bit (18),				/* DCW list offset */
  3    26     2 status bit (36)) unal;				/* first 36 bits of status */
  3    27 
  3    28 /* End of include file ...... ioi_stat.incl.pl1 */
  3    29 
      129 
      130 
  4     1 /*	Begin  include file rcp_tape_info.incl.pl1
  4     2*   *
  4     3*   *	Created on 12/16/74 by Bill Silver.
  4     4*   *	Modified on 11/17/78 by Michael R. Jordan to add speed qualifier.
  4     5*   *	Modified on 09/30/82 by J. A. Bush for version 3 structure info
  4     6*   *	This include file defines the RCP device info structure for tapes.
  4     7**/
  4     8 /* format: style4 */
  4     9 
  4    10 dcl  tape_info_ptr ptr;				/* Pointer to tape device info structure. */
  4    11 
  4    12 dcl  tape_info_version_2 fixed bin internal static options (constant) init (2);
  4    13 dcl  tape_info_version_3 fixed bin internal static options (constant) init (3);
  4    14 
  4    15 dcl  1 tape_info based (tape_info_ptr) aligned,		/* RCP device info structure for tapes. */
  4    16        2 version_num fixed bin,			/* Version number of this structure. */
  4    17        2 usage_time fixed bin,			/* Number of minutes drive will/may be used. */
  4    18        2 wait_time fixed bin,				/* Number of minutes user will/must wait. */
  4    19        2 system_flag bit (1),				/* ON => user wants to be a system process. */
  4    20        2 device_name char (8),			/* Tape drive name. */
  4    21        2 model fixed bin,				/* Tape drive model number. */
  4    22        2 tracks fixed bin,				/* Track type, 7 or 9. */
  4    23        2 density bit (36),				/* Density capability: 200, 556, 800, 1600, 6250. */
  4    24        2 speed bit (36),				/* Speed: 75, 125, 200. */
  4    25        2 unused_qualifier bit (36),			/* Unused qualifier (must be "0"b). */
  4    26        2 volume_name char (32),			/* Tape reel name. */
  4    27        2 write_flag bit (1),				/* ON => writing on tape reel. */
  4    28        2 position_index fixed bin (35),			/* Counter used to determine tape reel position. */
  4    29 
  4    30 /* Limit of version 2 structure, info below returned if version 3 or greater */
  4    31 
  4    32        2 volume_type fixed bin,			/* Use rcp_volume_formats.incl.pl1 for decodes */
  4    33        2 volume_density fixed bin,			/* 1 - 5 = 200, 556, 800, 1600, or 6250 BPI */
  4    34        2 opr_auth bit (1);				/* "1"b => Operator Authentication was required */
  4    35 
  4    36 /*	End of include file ... rcp_tape_info.incl.pl1	*/
      131 
      132 
  5     1 /*	Begin include file ... rcp_resource_types.incl.pl1
  5     2*   *
  5     3*   *	Created 3/79 by Michael R. Jordan for MR7.0R
  5     4*   *
  5     5*   *	This include file defines the official RCP resource types.
  5     6*   *	The array of names is indexed by the corresponding device type.
  5     7*   *      MOD by RAF for MCA
  5     8**/
  5     9 
  5    10 
  5    11 
  5    12 /****^  HISTORY COMMENTS:
  5    13*  1) change(85-09-09,Fawcett), approve(85-09-09,MCR6979),
  5    14*     audit(85-12-09,CLJones), install(86-03-21,MR12.0-1033):
  5    15*     Support of MCA.
  5    16*                                                   END HISTORY COMMENTS */
  5    17 
  5    18 dcl  DEVICE_TYPE (8) char (32)
  5    19 	internal static options (constant)
  5    20 	init ("tape_drive", "disk_drive", "console", "printer", "punch", "reader", "special", "mca");
  5    21 
  5    22 dcl  NUM_QUALIFIERS (8) fixed bin			/* Number of qualifiers for each device type. */
  5    23 	internal static init (3, 0, 0, 2, 0, 0, 0, 0);
  5    24 
  5    25 dcl  VOLUME_TYPE (8) char (32)
  5    26 	internal static options (constant)
  5    27 	init ("tape_vol", "disk_vol", "", "", "", "", "", "");
  5    28 
  5    29 dcl  TAPE_DRIVE_DTYPEX fixed bin static internal options (constant) init (1);
  5    30 dcl  DISK_DRIVE_DTYPEX fixed bin static internal options (constant) init (2);
  5    31 dcl  CONSOLE_DTYPEX fixed bin static internal options (constant) init (3);
  5    32 dcl  PRINTER_DTYPEX fixed bin static internal options (constant) init (4);
  5    33 dcl  PUNCH_DTYPEX fixed bin static internal options (constant) init (5);
  5    34 dcl  READER_DTYPEX fixed bin static internal options (constant) init (6);
  5    35 dcl  SPECIAL_DTYPEX fixed bin static internal options (constant) init (7);
  5    36 dcl  MCA_DTYPEX fixed bin static internal options (constant) init (8);
  5    37 dcl  TAPE_VOL_VTYPEX fixed bin static internal options (constant) init (1);
  5    38 dcl  DISK_VOL_VTYPEX fixed bin static internal options (constant) init (2);
  5    39 
  5    40 
  5    41 /*	End include file ... rcp_resource_types.incl.pl1 */
      133 
      134 
  6     1 
  6     2 /* Begin include file ...... iom_pcw.incl.pl1 */
  6     3 
  6     4 dcl  pcwp ptr;					/* pointer to PCW */
  6     5 
  6     6 dcl 1 pcw based (pcwp) aligned,			/* Peripheral Control Word */
  6     7      (2 command bit (6),				/* device command */
  6     8       2 device bit (6),				/* device code */
  6     9       2 ext bit (6),				/* address extension */
  6    10       2 code bit (3),				/* should be "111"b for PCW */
  6    11       2 mask bit (1),				/* channel mask bit */
  6    12       2 control bit (2),				/* terminate/proceed and marker control bits */
  6    13       2 chan_cmd bit (6),				/* type of I/O operation */
  6    14       2 count bit (6),				/* record count or control character */
  6    15       2 mbz1 bit (3),
  6    16       2 channel bit (6),				/* channel number */
  6    17       2 mbz2 bit (27)) unal;
  6    18 
  6    19 dcl  idcwp ptr;					/* pointer to IDCW */
  6    20 
  6    21 dcl 1 idcw based (idcwp) aligned,			/* Instruction DCW */
  6    22      (2 command bit (6),				/* device command */
  6    23       2 device bit (6),				/* device code */
  6    24       2 ext bit (6),				/* address extension */
  6    25       2 code bit (3),				/* should be "111"b for PCW */
  6    26       2 ext_ctl bit (1),				/* "1"b if address extension to be used */
  6    27       2 control bit (2),				/* terminate/proceed and marker control bits */
  6    28       2 chan_cmd bit (6),				/* type of I/O operation */
  6    29       2 count bit (6)) unal;				/* record count or control character */
  6    30 
  6    31 /* End include file ...... iom_pcw.incl.pl1 */
  6    32 
      135 
      136 
      137 	tsegp = arg_tsegp;				/* Copy arguments. */
      138 
      139 	if tseg.version_num ^= tseg_version_2 then do;
      140 	     arg_ecode = error_table_$unimplemented_version;
      141 	     return;
      142 	end;
      143 
      144 	ws_ptr = arg_ws_ptr;
      145 	temp_reel_name = arg_reel_name;
      146 	write_flag = bit (arg_write_sw);
      147 	system_flag = "0"b;				/* Assume not a system process. */
      148 
      149 	begin;					/* Necessary for multi-volume switching. */
      150 
      151 dcl      garbage		  (size (ws)) bit (36);
      152 
      153 
      154 
      155 	     if ws.flags.attached			/* Is tape drive already attached. */
      156 	     then do;				/* Yes, actually process the message. */
      157 		unspec (garbage) = unspec (ws);	/* Make temp copy of workspace. */
      158 		tseg.ws_segno = "0"b;		/* No workspace for a while. */
      159 		ws_ptr = addr (garbage);		/* And start to use it. */
      160 		call rcp_$detach (ws.info.rcp_id, "1"b, ws.info.error_count, "", ecode);
      161 		ws.info.error_count = 0;
      162 		call ipc_$decl_ev_wait_chn (ws.info.special_echan, ecode);
      163 		if ecode ^= 0			/* Did we make it a call channel? */
      164 		then do;				/* No. */
      165 		     call convert_ipc_code_ (ecode);
      166 		     goto RETURN;
      167 		end;
      168 	     end;
      169 
      170 /* Now we will parse the reel name string. */
      171 	     delimx = index (temp_reel_name, ",");	/* Look for first comma in reel name. */
      172 	     if delimx = 0				/* Are there other fields in the reel name? */
      173 	     then do;				/* No. */
      174 		reel_name = temp_reel_name;		/* Use the whole reel name. */
      175 		comment = "";			/* No comment. */
      176 	     end;
      177 	     else do;				/* Yes there are other fields in the reel name. */
      178 		reel_name = substr (temp_reel_name, 1, (delimx - 1));
      179 		comment = temp_reel_name;		/* Use whole reel name string as a comment. */
      180 		delimx = index (temp_reel_name, ",sys");
      181 		if delimx ^= 0			/* ",sys" => user wants to be a system process */
      182 		then system_flag = "1"b;
      183 	     end;
      184 
      185 
      186 /*	Now that we know the reel name we will try to attach the tape drive.
      187*   *	RCP will assign a tape drive depending upon the data in tape_info.
      188*   *	RCP will mount the specified reel on the assigned drive as part of
      189*   *	the attachment.  RCP will make sure that the drive is ready and the
      190*   *	reel is at BOT.  It will make sure that the write ring is correct.
      191*   *	First we must fill in the tape_info structure needed by RCP.
      192**/
      193 	     tape_info_ptr = addr (tape_info_buffer);	/* Pointer to tape_info structure. */
      194 	     tape_info.version_num = tape_info_version_2; /* We must always set this. */
      195 	     tape_info.usage_time,			/* These fields not used yet. */
      196 		tape_info.wait_time = 0;
      197 	     tape_info.system_flag = system_flag;
      198 	     tape_info.device_name = tseg.drive_name;	/* Assign the right device. */
      199 	     tape_info.model = 0;			/* We will accept any model. */
      200 	     tape_info.tracks = ws.info.tracks;		/* We want specific track type. */
      201 	     tape_info.density = tseg.density;		/* Ask for what the user requested. */
      202 	     tape_info.speed = tseg.speed;
      203 	     tape_info.unused_qualifier = "0"b;
      204 	     tape_info.volume_name = reel_name;		/* Fill in tape info colume data. */
      205 	     tape_info.write_flag = write_flag;
      206 	     tape_info.position_index = 0;		/* Initialize.  Not really used yet. */
      207 
      208 /* Use regular channel with RCP.  Not a call chan yet. */
      209 	     ws.info.wait_list.wait_echan = ws.info.special_echan;
      210 	     call rcp_$attach (DEVICE_TYPE (TAPE_DRIVE_DTYPEX), tape_info_ptr, ws.info.special_echan, comment,
      211 		ws.info.rcp_id, ecode);
      212 	     if ecode ^= 0 then
      213 		goto RETURN;
      214 
      215 	     reel_name = tape_info.volume_name;		/* remember, these things might have been changed by ring 1 */
      216 
      217 	     if index (temp_reel_name, ",") > 0 then
      218 		temp_reel_name = rtrim (reel_name) || "," || after (temp_reel_name, ",");
      219 	     else temp_reel_name = reel_name;
      220 
      221 	     arg_reel_name = temp_reel_name;
      222 
      223 	     ws.info.detachx = 3;			/* Now we have an RCP ID and must detach. */
      224 
      225 /*	We must check to see if the attachment has completed.  If RCP tells us
      226*   *	that there is a short wait we will block.  We must call RCP again after
      227*   *	each short wait.
      228**/
      229 ATTACH_LOOP:
      230 	     comment = " ";
      231 	     call rcp_$check_attach (ws.info.rcp_id, tape_info_ptr, comment, ws.info.ioix, workspace_max, timeout_max,
      232 		statex, ecode);
      233 	     if comment ^= " "			/* Is there a comment from RCP? */
      234 	     then call com_err_ (0, "tdcm_", "RCP comment: ^a", comment);
      235 	     goto ATTACH_STATE (statex);
      236 
      237 ATTACH_STATE (1):					/* Short wait. */
      238 	     on cleanup call clean_up;
      239 	     call ipc_$block (addr (ws.info.wait_list), addr (event_data), ecode);
      240 	     revert cleanup;
      241 	     if ecode ^= 0 then do;
      242 		call convert_ipc_code_ (ecode);
      243 		goto RETURN;
      244 	     end;
      245 	     goto ATTACH_LOOP;			/* Call RCP again. */
      246 
      247 ATTACH_STATE (2):					/* Long wait. */
      248 	     ecode = error_table_$ionmat;
      249 ATTACH_STATE (3):					/* Fatal error. */
      250 	     goto RETURN;
      251 
      252 /*	The attachment has completed.  We must call IOI to establish the
      253*   *	real IOI workspace buffer.
      254**/
      255 ATTACH_STATE (0):					/* Attachment complete. */
      256 	     call cv_dec_ (substr (tape_info.device_name, 6, 2), drive_num);
      257 	     tseg.drive_name = tape_info.device_name;	/* Return correct drive name. */
      258 
      259 /*	Now we must get a real IOI workspace.  We will ask for a workspace that is
      260*   *	just large enough to contain all of tdcm_info.  If the buffer size is too
      261*   *	large we will have to adjust it so it will fit into the maximum size
      262*   *	workspace that we may allocate.
      263**/
      264 	     workspace_size = fixed (rel (addr (ws.buf_end)), 18) - fixed (rel (addr (ws.info)), 18) + 1;
      265 	     if workspace_size > workspace_max		/* If buffer size too large adjust it. */
      266 	     then do;
      267 		ws.info.flags.good_ws = "0"b;
      268 		ecode = error_table_$big_ws_req;
      269 		goto RETURN;
      270 	     end;
      271 
      272 	     call ioi_$workspace (ws.info.ioix, real_ws_ptr, workspace_size, ecode);
      273 	     if ecode ^= 0 then do;
      274 		ws.info.flags.good_ws = "0"b;
      275 		goto RETURN;
      276 	     end;
      277 
      278 	     ws.info.flags.good_ws = "1"b;
      279 
      280 /*	We now have a real IOI workspace.  We will copy all workspace ws_info
      281*   *	from the temporary workspace into the real workspace.  From then on
      282*   *	we will deal only with the real workspace.
      283**/
      284 	     real_ws_ptr -> ws.info = ws_ptr -> ws.info;	/* Move ws_info to real workspace. */
      285 	     ws_ptr = real_ws_ptr;			/* Use real workspace pointer. */
      286 	     tseg.ws_segno = baseno (ws_ptr);		/* Save workspace segment number. */
      287 
      288 	end;					/* End of the begin block. */
      289 
      290 /*	Now we will complete the initialization of the IOI workspace.
      291*   *	We will call IOI to set the time-out limit to the maximum.
      292*   *	We will convert the special event channel into an event call
      293*   *	channel.  The data pointer for this call channel is the pointer
      294*   *	to the real workspace for this drive.  We must call IOI to set up
      295*   *	the event channel that we want to use when we start I/O processing.
      296*   *	We will initialize all the other data in the workspace including
      297*   *	the DCW lists.
      298**/
      299 	call ioi_$timeout (ws.info.ioix, timeout_max, ecode);
      300 	if ecode ^= 0 then
      301 	     goto RETURN;
      302 
      303 /* Set up our IOI status queue. */
      304 	call ioi_$set_status (ws.info.ioix, fixed (rel (addr (ws.statq)), 18), hbound (ws.statq, 1), ecode);
      305 	if ecode ^= 0 then
      306 	     return;
      307 
      308 	do i = 1 to hbound (ws.statq, 1);		/* Set up all status queue entries. */
      309 	     ws.statq (i).completion.st = "0"b;		/* Make this entry free. */
      310 	end;
      311 	ws.info.statqx = 1;				/* Start with first status queue entry. */
      312 
      313 	call ioi_$set_event (ws.info.ioix, ws.info.init_echan, ecode);
      314 	if ecode ^= 0				/* Did we set up IOI's event channel? */
      315 	then goto RETURN;				/* No. */
      316 
      317 /* From now on always wait on fast channel. */
      318 	ws.info.wait_list.wait_echan = ws.info.fast_echan;
      319 
      320 /* Make special channel an event call channel. */
      321 	call ipc_$decl_ev_call_chn (ws.info.special_echan, tdcm_$special_handler, ws_ptr, 0, ecode);
      322 	if ecode ^= 0				/* Did we make it a call channel? */
      323 	then do;					/* No. */
      324 	     call convert_ipc_code_ (ecode);
      325 	     goto RETURN;
      326 	end;
      327 
      328 	ws.info.disposition = "0"b;			/* Until told otherwise let RCP decide. */
      329 	ws.info.process_id = get_process_id_ ();	/* Need process ID to wakeup user. */
      330 	ws.info.flags.attached = "1"b;		/* Device is now attached. */
      331 
      332 /* Save offset of each DCW list. */
      333 	ws.info.ndt_offsetx = fixed (rel (addr (ws.ndt_list)), 18);
      334 	ws.info.rw_offsetx = fixed (rel (addr (ws.rw_list)), 18);
      335 
      336 	do i = 1 to hbound (ws.ndt_list, 1);		/* Initialize non-data transfer IDCWs. */
      337 	     idcwp = addr (ws.ndt_list (i).idcw);	/* Get pointer to IDCW. */
      338 	     string (idcw) = "0"b;			/* Clear it to all zeros. */
      339 	     idcw.device = bit (fixed (drive_num, 6));	/* Set up device number. */
      340 	     idcw.code = "111"b;			/* This => it is an IDCW. */
      341 	     idcw.chan_cmd = "000010"b;		/* This => it is a non-data transfer IDCW. */
      342 	     idcw.count = "000001"b;			/* Record count = 1. */
      343 	end;
      344 
      345 	do i = 1 to hbound (ws.rw_list, 1);		/* Set up read/write DCW list. */
      346 	     ws.rw_list (i).dcw = "0"b;		/* Clear all DCW's. */
      347 	end;
      348 
      349 	idcwp = addr (temp_idcw);			/* Initialize our work IDCW. */
      350 	string (idcw) = "0"b;			/* Clear it to all zeros. */
      351 	idcw.device = bit (fixed (drive_num, 6));	/* Fill in this drive number. */
      352 	idcw.code = "111"b;				/* This is an IDCW. */
      353 	idcw.control = "10"b;			/* Initialize to continue. */
      354 
      355 	do i = 0 to hbound (ws.info.read_idcws, 1);
      356 	     idcwp = addr (ws.info.read_idcws (i));	/* Set up each read IDCW. */
      357 	     based_idcw = temp_idcw;			/* Copy template with drive number. */
      358 	     idcw.command = read_idcw_commands (i);	/* Fill in corresponding command. */
      359 	end;
      360 
      361 	do i = 0 to hbound (ws.info.write_idcws, 1);
      362 	     idcwp = addr (ws.info.write_idcws (i));	/* Set up each write IDCW. */
      363 	     based_idcw = temp_idcw;
      364 	     idcw.command = write_idcw_commands (i);
      365 	end;
      366 
      367 /*	Now send a wakeup to the user.  He should be waiting for it.
      368*   *	It tells him that the tape drive is now in READY.
      369**/
      370 	call hcs_$wakeup (ws.info.process_id, ws.info.user_echan, 0, ecode);
      371 
      372 RETURN:
      373 	arg_ecode = ecode;				/* Return error code. */
      374 
      375 	return;
      376 
      377 
      378 /* Clean-up procedure during blocking. */
      379 
      380 clean_up:
      381      proc;
      382 
      383 	call rcp_$detach (ws.info.rcp_id, "0"b, (0), "", (0));
      384 
      385      end;
      386      end tdcm_message_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/21/86  1604.2  tdcm_message_.pl1                 >special_ldd>install>MR12.0-1033>tdcm_message_.pl1
125          1    06/10/82  1045.4  tseg.incl.pl1                     >ldd>include>tseg.incl.pl1
127          2    06/09/82  2051.4  tdcm_info.incl.pl1                >ldd>include>tdcm_info.incl.pl1
129          3    08/17/79  2215.0  ioi_stat.incl.pl1                 >ldd>include>ioi_stat.incl.pl1
131          4    04/05/83  0853.0  rcp_tape_info.incl.pl1            >ldd>include>rcp_tape_info.incl.pl1
133          5    03/21/86  1306.7  rcp_resource_types.incl.pl1       >special_ldd>install>MR12.0-1033>rcp_resource_types.incl.pl1
135          6    05/06/74  1742.1  iom_pcw.incl.pl1                  >ldd>include>iom_pcw.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DEVICE_TYPE                     000004 constant        char(32)                 initial array unaligned dcl 5-18 set ref 210*
TAPE_DRIVE_DTYPEX                      constant        fixed bin(17,0)          initial dcl 5-29 ref 210
addr                                                   builtin function         dcl 94 ref 159 193 239 239 239 239 264 264 304 304
                                                                                  333 334 337 349 356 362
after                                                  builtin function         dcl 94 ref 217
arg_ecode                              parameter       fixed bin(35,0)          dcl 35 set ref 12 140* 372*
arg_reel_name                          parameter       char                     unaligned dcl 36 set ref 12 145 221*
arg_tsegp                              parameter       pointer                  dcl 37 ref 12 137
arg_write_sw                           parameter       fixed bin(1,0)           dcl 38 ref 12 146
arg_ws_ptr                             parameter       pointer                  dcl 39 ref 12 144
attached                               based           bit(1)                   level 4 packed unaligned dcl 2-10 set ref 155 330*
based_idcw                             based           bit(36)                  dcl 68 set ref 357* 363*
baseno                                                 builtin function         dcl 94 ref 286
bit                                                    builtin function         dcl 94 ref 146 339 351
buf_end                                based           bit(36)                  level 2 dcl 2-10 set ref 264
buf_size                  1            based           fixed bin(17,0)          level 3 dcl 2-10 set ref 157 264
chan_cmd                  0(24)        based           bit(6)                   level 2 packed unaligned dcl 6-21 set ref 341*
cleanup                         000000 stack reference condition                dcl 123 ref 237 240
code                      0(18)        based           bit(3)                   level 2 packed unaligned dcl 6-21 set ref 340* 352*
com_err_                        000016 constant        entry                    external dcl 103 ref 233
command                                based           bit(6)                   level 2 packed unaligned dcl 6-21 set ref 358* 364*
comment                         000133 automatic       char(64)                 unaligned dcl 50 set ref 175* 179* 210* 229* 231*
                                                                                  233 233*
completion              150            based           structure                array level 3 in structure "ws" dcl 2-10
                                                                                  in procedure "tdcm_message_"
completion                             based           structure                level 2 in structure "istat" dcl 3-7 in procedure
                                                                                  "tdcm_message_"
control                   0(22)        based           bit(2)                   level 2 packed unaligned dcl 6-21 set ref 353*
convert_ipc_code_               000020 constant        entry                    external dcl 104 ref 165 242 324
count                     0(30)        based           bit(6)                   level 2 packed unaligned dcl 6-21 set ref 342*
cv_dec_                         000022 constant        entry                    external dcl 105 ref 255
dcw                     120            based           bit(36)                  array level 3 dcl 2-10 set ref 346*
delimx                          000206 automatic       fixed bin(17,0)          dcl 56 set ref 171* 172 178 180* 181
density                  23            based           bit(36)                  level 2 in structure "tseg" dcl 1-18 in procedure
                                                                                  "tdcm_message_" ref 201
density                  10            based           bit(36)                  level 2 in structure "tape_info" dcl 4-15
                                                                                  in procedure "tdcm_message_" set ref 201*
detachx                  46            based           fixed bin(17,0)          level 3 dcl 2-10 set ref 223*
device                    0(06)        based           bit(6)                   level 2 packed unaligned dcl 6-21 set ref 339* 351*
device_name               4            based           char(8)                  level 2 dcl 4-15 set ref 198* 255 255 257
disposition              47            based           bit(1)                   level 3 dcl 2-10 set ref 328*
drive_name               12            based           char(32)                 level 2 dcl 1-18 set ref 198 257*
drive_num                       000207 automatic       fixed bin(17,0)          dcl 57 set ref 255* 339 351
ecode                           000210 automatic       fixed bin(35,0)          dcl 58 set ref 160* 162* 163 165* 210* 212 231* 239*
                                                                                  241 242* 247* 268* 272* 273 299* 300 304* 305 313*
                                                                                  314 321* 322 324* 370* 372
error_count              70            based           fixed bin(17,0)          level 3 dcl 2-10 set ref 160* 161*
error_table_$big_ws_req         000012 external static fixed bin(35,0)          dcl 98 ref 268
error_table_$ionmat             000010 external static fixed bin(35,0)          dcl 97 ref 247
error_table_$unimplemented_version
                                000014 external static fixed bin(35,0)          dcl 100 ref 140
event_data                      000220 automatic       bit(36)                  array unaligned dcl 70 set ref 239 239
fast_echan               14            based           fixed bin(71,0)          level 3 dcl 2-10 set ref 318
fixed                                                  builtin function         dcl 94 ref 264 264 304 304 333 334 339 351
flags                                  based           structure                level 3 dcl 2-10
garbage                         000100 automatic       bit(36)                  array unaligned dcl 151 set ref 157* 159
get_process_id_                 000024 constant        entry                    external dcl 106 ref 329
good_ws                   0(07)        based           bit(1)                   level 4 packed unaligned dcl 2-10 set ref 267* 274*
                                                                                  278*
hbound                                                 builtin function         dcl 94 ref 304 304 308 336 345 355 361
hcs_$wakeup                     000026 constant        entry                    external dcl 107 ref 370
i                               000211 automatic       fixed bin(17,0)          dcl 59 set ref 308* 309* 336* 337* 345* 346* 355*
                                                                                  356 358* 361* 362 364*
idcw                                   based           structure                level 1 dcl 6-21 in procedure "tdcm_message_" set
                                                                                  ref 338* 350*
idcw                    105            based           bit(36)                  array level 3 in structure "ws" dcl 2-10
                                                                                  in procedure "tdcm_message_" set ref 337
idcwp                           000236 automatic       pointer                  dcl 6-19 set ref 337* 338 339 340 341 342 349* 350
                                                                                  351 352 353 356* 357 358 362* 363 364
index                                                  builtin function         dcl 94 ref 171 180 217
info                                   based           structure                level 2 dcl 2-10 set ref 264 284* 284
init_echan               22            based           fixed bin(71,0)          level 3 dcl 2-10 set ref 313*
ioi_$set_event                  000030 constant        entry                    external dcl 108 ref 313
ioi_$set_status                 000032 constant        entry                    external dcl 109 ref 304
ioi_$timeout                    000034 constant        entry                    external dcl 110 ref 299
ioi_$workspace                  000036 constant        entry                    external dcl 111 ref 272
ioix                      3            based           fixed bin(17,0)          level 3 dcl 2-10 set ref 231* 272* 299* 304* 313*
ipc_$block                      000040 constant        entry                    external dcl 112 ref 239
ipc_$decl_ev_call_chn           000042 constant        entry                    external dcl 113 ref 321
ipc_$decl_ev_wait_chn           000044 constant        entry                    external dcl 114 ref 162
istat                                  based           structure                level 1 dcl 3-7
model                     6            based           fixed bin(17,0)          level 2 dcl 4-15 set ref 199*
ndt_list                105            based           structure                array level 2 dcl 2-10 set ref 333 336
ndt_offsetx              65            based           fixed bin(17,0)          level 3 dcl 2-10 set ref 333*
position_index           24            based           fixed bin(35,0)          level 2 dcl 4-15 set ref 206*
process_id                5            based           bit(36)                  level 3 dcl 2-10 set ref 329* 370*
rcp_$attach                     000046 constant        entry                    external dcl 115 ref 210
rcp_$check_attach               000050 constant        entry                    external dcl 116 ref 231
rcp_$detach                     000052 constant        entry                    external dcl 118 ref 160 383
rcp_id                    2            based           bit(36)                  level 3 dcl 2-10 set ref 160* 210* 231* 383*
read_idcw_commands              000105 constant        bit(6)                   initial array unaligned dcl 75 ref 358
read_idcws               71            based           bit(36)                  array level 3 dcl 2-10 set ref 355 356
real_ws_ptr                     000204 automatic       pointer                  dcl 54 set ref 272* 284 285
reel_name                       000153 automatic       char(32)                 unaligned dcl 51 set ref 174* 178* 204 215* 217 219
rel                                                    builtin function         dcl 94 ref 264 264 304 304 333 334
rtrim                                                  builtin function         dcl 94 ref 217
rw_list                 117            based           structure                array level 2 dcl 2-10 set ref 334 345
rw_offsetx               66            based           fixed bin(17,0)          level 3 dcl 2-10 set ref 334*
size                                                   builtin function         dcl 94 ref 151
special_echan            16            based           fixed bin(71,0)          level 3 dcl 2-10 set ref 162* 209 210* 321*
speed                    24            based           bit(36)                  level 2 in structure "tseg" dcl 1-18 in procedure
                                                                                  "tdcm_message_" ref 202
speed                    11            based           bit(36)                  level 2 in structure "tape_info" dcl 4-15
                                                                                  in procedure "tdcm_message_" set ref 202*
st                      150            based           bit(1)                   array level 4 packed unaligned dcl 2-10 set ref 309*
statex                          000212 automatic       fixed bin(17,0)          dcl 60 set ref 231* 235
statq                   150            based           structure                array level 2 dcl 2-10 set ref 304 304 304 304 308
statqx                    4            based           fixed bin(17,0)          level 3 dcl 2-10 set ref 311*
string                                                 builtin function         dcl 94 set ref 338* 350*
substr                                                 builtin function         dcl 94 ref 178 255 255
system_flag               3            based           bit(1)                   level 2 in structure "tape_info" dcl 4-15
                                                                                  in procedure "tdcm_message_" set ref 197*
system_flag                     000131 automatic       bit(1)                   unaligned dcl 47 in procedure "tdcm_message_" set
                                                                                  ref 147* 181* 197
tape_info                              based           structure                level 1 dcl 4-15
tape_info_buffer                000100 automatic       structure                level 1 unaligned dcl 44 set ref 193
tape_info_ptr                   000234 automatic       pointer                  dcl 4-10 set ref 193* 194 195 195 197 198 199 200
                                                                                  201 202 203 204 205 206 210* 215 231* 255 255 257
tape_info_version_2                    constant        fixed bin(17,0)          initial dcl 4-12 ref 194
tdcm_$special_handler           000054 constant        entry                    external dcl 119 ref 321 321
temp_idcw                       000130 automatic       bit(36)                  dcl 46 set ref 349 357 363
temp_reel_name                  000163 automatic       char(64)                 unaligned dcl 52 set ref 145* 171 174 178 179 180
                                                                                  217 217* 217 219* 221
timeout_max                     000214 automatic       fixed bin(71,0)          dcl 61 set ref 231* 299*
tracks                    6            based           fixed bin(17,0)          level 3 in structure "ws" dcl 2-10 in procedure
                                                                                  "tdcm_message_" set ref 200
tracks                    7            based           fixed bin(17,0)          level 2 in structure "tape_info" dcl 4-15
                                                                                  in procedure "tdcm_message_" set ref 200*
tseg                                   based           structure                level 1 dcl 1-18
tseg_version_2                         constant        fixed bin(17,0)          initial dcl 1-16 ref 139
tsegp                           000230 automatic       pointer                  dcl 1-15 set ref 137* 139 158 198 201 202 257 286
unspec                                                 builtin function         dcl 94 set ref 157* 157
unused_qualifier         12            based           bit(36)                  level 2 dcl 4-15 set ref 203*
usage_time                1            based           fixed bin(17,0)          level 2 dcl 4-15 set ref 195*
user_echan               20            based           fixed bin(71,0)          level 3 dcl 2-10 set ref 370*
version_num                            based           fixed bin(17,0)          level 2 in structure "tape_info" dcl 4-15
                                                                                  in procedure "tdcm_message_" set ref 194*
version_num                            based           fixed bin(17,0)          level 2 in structure "tseg" dcl 1-18 in procedure
                                                                                  "tdcm_message_" ref 139
volume_name              13            based           char(32)                 level 2 dcl 4-15 set ref 204* 215
wait_echan               12            based           fixed bin(71,0)          level 4 dcl 2-10 set ref 209* 318*
wait_list                10            based           structure                level 3 dcl 2-10 set ref 239 239
wait_time                 2            based           fixed bin(17,0)          level 2 dcl 4-15 set ref 195*
workspace_max                   000216 automatic       fixed bin(19,0)          dcl 62 set ref 231* 265
workspace_size                  000217 automatic       fixed bin(19,0)          dcl 63 set ref 264* 265 272*
write_flag               23            based           bit(1)                   level 2 in structure "tape_info" dcl 4-15
                                                                                  in procedure "tdcm_message_" set ref 205*
write_flag                      000132 automatic       bit(1)                   unaligned dcl 48 in procedure "tdcm_message_" set
                                                                                  ref 146* 205
write_idcw_commands             000104 constant        bit(6)                   initial array unaligned dcl 83 ref 364
write_idcws              77            based           bit(36)                  array level 3 dcl 2-10 set ref 361 362
ws                                     based           structure                level 1 dcl 2-10 set ref 151 157
ws_info                                based           structure                level 1 dcl 2-23
ws_ptr                          000232 automatic       pointer                  dcl 2-8 set ref 144* 151 155 157 159* 160 160 161
                                                                                  162 200 209 209 210 210 223 231 231 239 239 264
                                                                                  264 267 272 274 278 284 285* 286 299 304 304 304
                                                                                  304 304 308 309 311 313 313 318 318 321 321* 328
                                                                                  329 330 333 333 334 334 336 337 345 346 355 356
                                                                                  361 362 370 370 383
ws_segno                 11            based           bit(18)                  level 2 dcl 1-18 set ref 158* 286*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
CONSOLE_DTYPEX                         internal static fixed bin(17,0)          initial dcl 5-31
DISK_DRIVE_DTYPEX                      internal static fixed bin(17,0)          initial dcl 5-30
DISK_VOL_VTYPEX                        internal static fixed bin(17,0)          initial dcl 5-38
MCA_DTYPEX                             internal static fixed bin(17,0)          initial dcl 5-36
NUM_QUALIFIERS                         internal static fixed bin(17,0)          initial array dcl 5-22
PRINTER_DTYPEX                         internal static fixed bin(17,0)          initial dcl 5-32
PUNCH_DTYPEX                           internal static fixed bin(17,0)          initial dcl 5-33
READER_DTYPEX                          internal static fixed bin(17,0)          initial dcl 5-34
SPECIAL_DTYPEX                         internal static fixed bin(17,0)          initial dcl 5-35
TAPE_VOL_VTYPEX                        internal static fixed bin(17,0)          initial dcl 5-37
VOLUME_TYPE                            internal static char(32)                 initial array unaligned dcl 5-25
decat                                                  builtin function         dcl 94
imess                                  based           structure                level 1 dcl 3-21
imp                                    automatic       pointer                  dcl 3-19
isp                                    automatic       pointer                  dcl 3-5
max_rec_size                           internal static fixed bin(17,0)          initial dcl 1-10
nbuffs                                 internal static fixed bin(17,0)          initial dcl 1-10
pcw                                    based           structure                level 1 dcl 6-6
pcwp                                   automatic       pointer                  dcl 6-4
tape_info_version_3                    internal static fixed bin(17,0)          initial dcl 4-13

NAMES DECLARED BY EXPLICIT CONTEXT.
ATTACH_LOOP                     000606 constant        label                    dcl 229 ref 245
ATTACH_STATE                    000000 constant        label                    array(0:3) dcl 237 ref 235
RETURN                          001466 constant        label                    dcl 372 ref 166 212 243 249 269 275 300 314 325
clean_up                        001472 constant        entry                    internal dcl 380 ref 237
tdcm_message_                   000147 constant        entry                    external dcl 12

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2002        2060    1542        2012
Length      2412    1542        56         315     240           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
tdcm_message_                       202 external procedure  is an external procedure.  
begin block on line 149             164 begin block         uses auto adjustable storage, and enables or reverts conditions.  
on unit on line 237                  96 on unit               
clean_up                                internal procedure  shares stack frame of on unit on line 237.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 149  000100 garbage                     begin block on line 149
tdcm_message_            000100 tape_info_buffer            tdcm_message_
                         000130 temp_idcw                   tdcm_message_
                         000131 system_flag                 tdcm_message_
                         000132 write_flag                  tdcm_message_
                         000133 comment                     tdcm_message_
                         000153 reel_name                   tdcm_message_
                         000163 temp_reel_name              tdcm_message_
                         000204 real_ws_ptr                 tdcm_message_
                         000206 delimx                      tdcm_message_
                         000207 drive_num                   tdcm_message_
                         000210 ecode                       tdcm_message_
                         000211 i                           tdcm_message_
                         000212 statex                      tdcm_message_
                         000214 timeout_max                 tdcm_message_
                         000216 workspace_max               tdcm_message_
                         000217 workspace_size              tdcm_message_
                         000220 event_data                  tdcm_message_
                         000230 tsegp                       tdcm_message_
                         000232 ws_ptr                      tdcm_message_
                         000234 tape_info_ptr               tdcm_message_
                         000236 idcwp                       tdcm_message_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      enter_begin         leave_begin         call_ext_out_desc   call_ext_out
return              tra_ext             alloc_auto_adj      enable              shorten_stack       ext_entry_desc
int_entry           set_cs_eis          index_cs_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      convert_ipc_code_             cv_dec_                       get_process_id_
hcs_$wakeup                   ioi_$set_event                ioi_$set_status               ioi_$timeout
ioi_$workspace                ipc_$block                    ipc_$decl_ev_call_chn         ipc_$decl_ev_wait_chn
rcp_$attach                   rcp_$check_attach             rcp_$detach                   tdcm_$special_handler

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$big_ws_req       error_table_$ionmat           error_table_$unimplemented_version


CONSTANTS
001534  aa     077777000043
001535  aa     000001000000

001536  aa     377777777777

001537  aa     775777777777

000004  aa  164 141 160 145	tape
000005  aa  137 144 162 151	_dri
000006  aa  166 145 040 040	ve  
000007  aa  040 040 040 040	    
000010  aa  040 040 040 040	    
000011  aa  040 040 040 040	    
000012  aa  040 040 040 040	    
000013  aa  040 040 040 040	    
000014  aa  144 151 163 153	disk
000015  aa  137 144 162 151	_dri
000016  aa  166 145 040 040	ve  
000017  aa  040 040 040 040	    
000020  aa  040 040 040 040	    
000021  aa  040 040 040 040	    
000022  aa  040 040 040 040	    
000023  aa  040 040 040 040	    
000024  aa  143 157 156 163	cons
000025  aa  157 154 145 040	ole 
000026  aa  040 040 040 040	    
000027  aa  040 040 040 040	    
000030  aa  040 040 040 040	    
000031  aa  040 040 040 040	    
000032  aa  040 040 040 040	    
000033  aa  040 040 040 040	    
000034  aa  160 162 151 156	prin
000035  aa  164 145 162 040	ter 
000036  aa  040 040 040 040	    
000037  aa  040 040 040 040	    
000040  aa  040 040 040 040	    
000041  aa  040 040 040 040	    
000042  aa  040 040 040 040	    
000043  aa  040 040 040 040	    
000044  aa  160 165 156 143	punc
000045  aa  150 040 040 040	h   
000046  aa  040 040 040 040	    
000047  aa  040 040 040 040	    
000050  aa  040 040 040 040	    
000051  aa  040 040 040 040	    
000052  aa  040 040 040 040	    
000053  aa  040 040 040 040	    
000054  aa  162 145 141 144	read
000055  aa  145 162 040 040	er  
000056  aa  040 040 040 040	    
000057  aa  040 040 040 040	    
000060  aa  040 040 040 040	    
000061  aa  040 040 040 040	    
000062  aa  040 040 040 040	    
000063  aa  040 040 040 040	    
000064  aa  163 160 145 143	spec
000065  aa  151 141 154 040	ial 
000066  aa  040 040 040 040	    
000067  aa  040 040 040 040	    
000070  aa  040 040 040 040	    
000071  aa  040 040 040 040	    
000072  aa  040 040 040 040	    
000073  aa  040 040 040 040	    
000074  aa  155 143 141 040	mca 
000075  aa  040 040 040 040	    
000076  aa  040 040 040 040	    
000077  aa  040 040 040 040	    
000100  aa  040 040 040 040	    
000101  aa  040 040 040 040	    
000102  aa  040 040 040 040	    
000103  aa  040 040 040 040	    

000104  aa     151413343735

000105  aa     050403242725

000106  aa     524000000002

000107  aa     524000000017

000110  aa     524000000005

000111  aa     404000000005

000112  aa     404000000023

001540  aa  040 000 000 000	 

000113  aa     526000000100

000114  aa     410000000107

000115  aa     526000000040

000116  aa  054 163 171 163	,sys

001541  aa  054 000 000 000	,

000117  aa     524000000000

000120  aa     404000000021

000121  aa     514000000001

000122  aa     514000000044

000123  aa     404000000001

000124  aa     464000000000

000125  aa     526077777777

000126  aa     404000000043

000130  aa  164 144 143 155	tdcm
000131  aa  137 000 000 000	_

000132  aa     000000000000
000133  aa     000000000000

000134  aa  143 154 145 141	clea
000135  aa  156 165 160 000	nup

000136  aa  122 103 120 040	RCP 
000137  aa  143 157 155 155	comm
000140  aa  145 156 164 072	ent:
000141  aa  040 136 141 000	 ^a

LABEL ARRAYS
000000  aa   001011 7100 04	tra  	521,ic		001011
000001  aa   000722 7100 04	tra  	466,ic		000723
000002  aa   001001 7100 04	tra  	513,ic		001003
000003  aa   001003 7100 04	tra  	515,ic		001006

BEGIN PROCEDURE tdcm_message_
ENTRY TO tdcm_message_                                      STATEMENT 1 ON LINE 12
tdcm_message_:
     procedure (arg_tsegp, arg_ws_ptr, arg_reel_name, arg_write_sw, arg_ecode);

000142  at     000005000124
000143  tt     000124000125
000144  tt     000123000126
000145  ta     000142000000
000146  da     000226300000
000147  aa   000320 6270 00	eax7 	208
000150  aa  7 00034 3521 20	epp2 	pr7|28,*
000151  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
000152  aa     000012000000
000153  aa     000000000000
000154  aa  6 00042 3735 20	epp7 	pr6|34,*
000155  aa  7 00004 2361 20	ldq  	pr7|4,*
000156  aa   000002 6040 04	tmi  	2,ic		000160
000157  aa   777777 3760 07	anq  	262143,dl
000160  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000161  aa  6 00240 7561 00	stq  	pr6|160
						STATEMENT 1 ON LINE 137
	tsegp = arg_tsegp;

000162  aa  6 00032 3715 20	epp5 	pr6|26,*
000163  aa  5 00002 3535 20	epp3 	pr5|2,*		arg_tsegp
000164  aa  3 00000 3535 20	epp3 	pr3|0,*		arg_tsegp
000165  aa  6 00230 2535 00	spri3	pr6|152		tsegp
						STATEMENT 1 ON LINE 139
	if tseg.version_num ^= tseg_version_2 then do;

000166  aa  3 00000 2361 00	ldq  	pr3|0		tseg.version_num
000167  aa   000002 1160 07	cmpq 	2,dl
000170  aa   000004 6000 04	tze  	4,ic		000174
						STATEMENT 1 ON LINE 140
	     arg_ecode = error_table_$unimplemented_version;

000171  la  4 00014 2361 20	ldq  	pr4|12,*		error_table_$unimplemented_version
000172  aa  5 00012 7561 20	stq  	pr5|10,*		arg_ecode
						STATEMENT 1 ON LINE 141
	     return;

000173  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 142
	end;

						STATEMENT 1 ON LINE 144
	ws_ptr = arg_ws_ptr;

000174  aa  5 00004 3515 20	epp1 	pr5|4,*		arg_ws_ptr
000175  aa  1 00000 3515 20	epp1 	pr1|0,*		arg_ws_ptr
000176  aa  6 00232 2515 00	spri1	pr6|154		ws_ptr
						STATEMENT 1 ON LINE 145
	temp_reel_name = arg_reel_name;

000177  aa  5 00006 3735 20	epp7 	pr5|6,*
000200  aa  6 00240 2351 00	lda  	pr6|160
000201  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
000202  aa  7 00000 00 0005	desc9a	pr7|0,al		arg_reel_name
000203  aa  6 00163 00 0100	desc9a	pr6|115,64	temp_reel_name
						STATEMENT 1 ON LINE 146
	write_flag = bit (arg_write_sw);

000204  aa  5 00010 2351 20	lda  	pr5|8,*		arg_write_sw
000205  aa   000002 6050 04	tpl  	2,ic		000207
000206  aa   000000 5310 00	neg  	0
000207  aa   000043 7350 00	als  	35
000210  aa  6 00132 7551 00	sta  	pr6|90		write_flag
						STATEMENT 1 ON LINE 147
	system_flag = "0"b;

000211  aa  6 00131 4501 00	stz  	pr6|89		system_flag
						STATEMENT 1 ON LINE 149
	begin;

000212  aa   000260 6270 00	eax7 	176
000213  aa  0 00614 2721 00	tsp2 	pr0|396		enter_begin
000214  aa     000000000000
BEGIN BLOCK  1
PROLOGUE SEQUENCE                                           STATEMENT 1 ON LINE 151
000215  aa   000213 2360 07	ldq  	139,dl
000216  aa  6 00106 7561 00	stq  	pr6|70
000217  aa  0 00661 7001 00	tsx0 	pr0|433		alloc_auto_adj
000220  aa  6 00110 2521 00	spri2	pr6|72
MAIN SEQUENCE                                               STATEMENT 1 ON LINE 155
	     if ws.flags.attached			/* Is tape drive already attached. */
	     then do;

000221  aa  6 00040 3735 20	epp7 	pr6|32,*
000222  aa  7 00232 2351 20	lda  	pr7|154,*		ws.attached
000223  aa   400000 3150 03	cana 	131072,du
000224  aa   000104 6000 04	tze  	68,ic		000330
						STATEMENT 1 ON LINE 157
		unspec (garbage) = unspec (ws);

000225  aa  6 00106 2361 00	ldq  	pr6|70
000226  aa   000044 4020 07	mpy  	36,dl
000227  aa  7 00232 3715 20	epp5 	pr7|154,*		ws_ptr
000230  aa  6 00112 7561 00	stq  	pr6|74
000231  aa  5 00001 2361 00	ldq  	pr5|1		ws.buf_size
000232  aa   000213 0760 07	adq  	139,dl
000233  aa   000044 4020 07	mpy  	36,dl
000234  aa  6 00112 2351 00	lda  	pr6|74
000235  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
000236  aa  5 00000 00 0006	descb	pr5|0,ql
000237  aa  2 00000 00 0005	descb	pr2|0,al
						STATEMENT 1 ON LINE 158
		tseg.ws_segno = "0"b;

000240  aa  7 00230 3535 20	epp3 	pr7|152,*		tsegp
000241  aa  3 00011 4501 00	stz  	pr3|9		tseg.ws_segno
						STATEMENT 1 ON LINE 159
		ws_ptr = addr (garbage);

000242  aa  2 00000 3515 00	epp1 	pr2|0		garbage
000243  aa  7 00232 2515 00	spri1	pr7|154		ws_ptr
						STATEMENT 1 ON LINE 160
		call rcp_$detach (ws.info.rcp_id, "1"b, ws.info.error_count, "", ecode);

000244  aa   400000 2350 03	lda  	131072,du
000245  aa  6 00112 7551 00	sta  	pr6|74
000246  aa  1 00002 3521 00	epp2 	pr1|2		ws.rcp_id
000247  aa  6 00116 2521 00	spri2	pr6|78
000250  aa  6 00112 3521 00	epp2 	pr6|74
000251  aa  6 00120 2521 00	spri2	pr6|80
000252  aa  1 00070 3521 00	epp2 	pr1|56		ws.error_count
000253  aa  6 00122 2521 00	spri2	pr6|82
000254  aa  6 00113 3521 00	epp2 	pr6|75
000255  aa  6 00124 2521 00	spri2	pr6|84
000256  aa  7 00210 3521 00	epp2 	pr7|136		ecode
000257  aa  6 00126 2521 00	spri2	pr6|86
000260  aa   777642 3520 04	epp2 	-94,ic		000122 = 514000000044
000261  aa  6 00130 2521 00	spri2	pr6|88
000262  aa   777637 3520 04	epp2 	-97,ic		000121 = 514000000001
000263  aa  6 00132 2521 00	spri2	pr6|90
000264  aa   777634 3520 04	epp2 	-100,ic		000120 = 404000000021
000265  aa  6 00134 2521 00	spri2	pr6|92
000266  aa   777631 3520 04	epp2 	-103,ic		000117 = 524000000000
000267  aa  6 00136 2521 00	spri2	pr6|94
000270  aa   777636 3520 04	epp2 	-98,ic		000126 = 404000000043
000271  aa  6 00140 2521 00	spri2	pr6|96
000272  aa  6 00114 6211 00	eax1 	pr6|76
000273  aa   024000 4310 07	fld  	10240,dl
000274  aa  6 00044 3701 20	epp4 	pr6|36,*
000275  la  4 00052 3521 20	epp2 	pr4|42,*		rcp_$detach
000276  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 161
		ws.info.error_count = 0;

000277  aa  6 00040 3735 20	epp7 	pr6|32,*
000300  aa  7 00232 3715 20	epp5 	pr7|154,*		ws_ptr
000301  aa  5 00070 4501 00	stz  	pr5|56		ws.error_count
						STATEMENT 1 ON LINE 162
		call ipc_$decl_ev_wait_chn (ws.info.special_echan, ecode);

000302  aa  5 00016 3521 00	epp2 	pr5|14		ws.special_echan
000303  aa  6 00116 2521 00	spri2	pr6|78
000304  aa  7 00210 3521 00	epp2 	pr7|136		ecode
000305  aa  6 00120 2521 00	spri2	pr6|80
000306  aa  6 00114 6211 00	eax1 	pr6|76
000307  aa   010000 4310 07	fld  	4096,dl
000310  aa  6 00044 3701 20	epp4 	pr6|36,*
000311  la  4 00044 3521 20	epp2 	pr4|36,*		ipc_$decl_ev_wait_chn
000312  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 163
		if ecode ^= 0			/* Did we make it a call channel? */
		then do;

000313  aa  6 00040 3735 20	epp7 	pr6|32,*
000314  aa  7 00210 2361 00	ldq  	pr7|136		ecode
000315  aa   000013 6000 04	tze  	11,ic		000330
						STATEMENT 1 ON LINE 165
		     call convert_ipc_code_ (ecode);

000316  aa  7 00210 3521 00	epp2 	pr7|136		ecode
000317  aa  6 00116 2521 00	spri2	pr6|78
000320  aa  6 00114 6211 00	eax1 	pr6|76
000321  aa   004000 4310 07	fld  	2048,dl
000322  aa  6 00044 3701 20	epp4 	pr6|36,*
000323  la  4 00020 3521 20	epp2 	pr4|16,*		convert_ipc_code_
000324  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 166
		     goto RETURN;

000325  aa   001141 3520 04	epp2 	609,ic		001466 = 600210236100
000326  aa   000001 7270 07	lxl7 	1,dl
000327  aa  0 00657 7101 00	tra  	pr0|431		tra_ext
						STATEMENT 1 ON LINE 167
		end;

						STATEMENT 1 ON LINE 168
	     end;

						STATEMENT 1 ON LINE 171
	     delimx = index (temp_reel_name, ",");

000330  aa  000 003 124 500	scm  	(pr),(du),mask(000)
000331  aa  7 00163 00 0100	desc9a	pr7|115,64	temp_reel_name
000332  aa   054000 00 0001	desc9a	22528,1
000333  aa  6 00056 0001 00	arg  	pr6|46
000334  aa  6 00056 2361 00	ldq  	pr6|46
000335  aa   000002 6070 04	ttf  	2,ic		000337
000336  aa   000001 3360 07	lcq  	1,dl
000337  aa   000001 0760 07	adq  	1,dl
000340  aa  7 00206 7561 00	stq  	pr7|134		delimx
						STATEMENT 1 ON LINE 172
	     if delimx = 0				/* Are there other fields in the reel name? */
	     then do;

000341  aa   000010 6010 04	tnz  	8,ic		000351
						STATEMENT 1 ON LINE 174
		reel_name = temp_reel_name;

000342  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000343  aa  7 00163 00 0040	desc9a	pr7|115,32	temp_reel_name
000344  aa  7 00153 00 0040	desc9a	pr7|107,32	reel_name
						STATEMENT 1 ON LINE 175
		comment = "";

000345  aa  040 100 100 400	mlr  	(),(pr),fill(040)
000346  aa   000000 00 0000	desc9a	0,0
000347  aa  7 00133 00 0100	desc9a	pr7|91,64		comment
						STATEMENT 1 ON LINE 176
	     end;

000350  aa   000022 7100 04	tra  	18,ic		000372
						STATEMENT 1 ON LINE 177
	     else do;

						STATEMENT 1 ON LINE 178
		reel_name = substr (temp_reel_name, 1, (delimx - 1));

000351  aa   000001 1760 07	sbq  	1,dl
000352  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
000353  aa  7 00163 00 0006	desc9a	pr7|115,ql	temp_reel_name
000354  aa  7 00153 00 0040	desc9a	pr7|107,32	reel_name
						STATEMENT 1 ON LINE 179
		comment = temp_reel_name;

000355  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000356  aa  7 00163 00 0100	desc9a	pr7|115,64	temp_reel_name
000357  aa  7 00133 00 0100	desc9a	pr7|91,64		comment
						STATEMENT 1 ON LINE 180
		delimx = index (temp_reel_name, ",sys");

000360  aa   000100 2360 07	ldq  	64,dl
000361  aa  7 00163 3521 00	epp2 	pr7|115		temp_reel_name
000362  aa  0 01227 7001 00	tsx0 	pr0|663		set_cs_eis
000363  aa   000004 2360 07	ldq  	4,dl
000364  aa   777532 3520 04	epp2 	-166,ic		000116 = 054163171163
000365  aa  0 01231 7001 00	tsx0 	pr0|665		index_cs_eis
000366  aa  7 00206 7561 00	stq  	pr7|134		delimx
						STATEMENT 1 ON LINE 181
		if delimx ^= 0			/* ",sys" => user wants to be a system process */
		then system_flag = "1"b;

000367  aa   000003 6000 04	tze  	3,ic		000372
000370  aa   400000 2350 03	lda  	131072,du
000371  aa  7 00131 7551 00	sta  	pr7|89		system_flag
						STATEMENT 1 ON LINE 183
	     end;

						STATEMENT 1 ON LINE 193
	     tape_info_ptr = addr (tape_info_buffer);

000372  aa  7 00100 3715 00	epp5 	pr7|64		tape_info_buffer
000373  aa  7 00234 6515 00	spri5	pr7|156		tape_info_ptr
						STATEMENT 1 ON LINE 194
	     tape_info.version_num = tape_info_version_2;

000374  aa   000002 2360 07	ldq  	2,dl
000375  aa  5 00000 7561 00	stq  	pr5|0		tape_info.version_num
						STATEMENT 1 ON LINE 195
	     tape_info.usage_time,			/* These fields not used yet. */
		tape_info.wait_time = 0;

000376  aa  5 00001 4501 00	stz  	pr5|1		tape_info.usage_time
000377  aa  5 00002 4501 00	stz  	pr5|2		tape_info.wait_time
						STATEMENT 1 ON LINE 197
	     tape_info.system_flag = system_flag;

000400  aa  7 00131 2351 00	lda  	pr7|89		system_flag
000401  aa  5 00003 7551 00	sta  	pr5|3		tape_info.system_flag
						STATEMENT 1 ON LINE 198
	     tape_info.device_name = tseg.drive_name;

000402  aa  7 00230 3535 20	epp3 	pr7|152,*		tsegp
000403  aa  3 00012 2351 00	lda  	pr3|10		tseg.drive_name
000404  aa  3 00013 2361 00	ldq  	pr3|11		tseg.drive_name
000405  aa  5 00004 7551 00	sta  	pr5|4		tape_info.device_name
000406  aa  5 00005 7561 00	stq  	pr5|5		tape_info.device_name
						STATEMENT 1 ON LINE 199
	     tape_info.model = 0;

000407  aa  5 00006 4501 00	stz  	pr5|6		tape_info.model
						STATEMENT 1 ON LINE 200
	     tape_info.tracks = ws.info.tracks;

000410  aa  7 00232 3515 20	epp1 	pr7|154,*		ws_ptr
000411  aa  1 00006 2361 00	ldq  	pr1|6		ws.tracks
000412  aa  5 00007 7561 00	stq  	pr5|7		tape_info.tracks
						STATEMENT 1 ON LINE 201
	     tape_info.density = tseg.density;

000413  aa  3 00023 2351 00	lda  	pr3|19		tseg.density
000414  aa  5 00010 7551 00	sta  	pr5|8		tape_info.density
						STATEMENT 1 ON LINE 202
	     tape_info.speed = tseg.speed;

000415  aa  3 00024 2351 00	lda  	pr3|20		tseg.speed
000416  aa  5 00011 7551 00	sta  	pr5|9		tape_info.speed
						STATEMENT 1 ON LINE 203
	     tape_info.unused_qualifier = "0"b;

000417  aa  5 00012 4501 00	stz  	pr5|10		tape_info.unused_qualifier
						STATEMENT 1 ON LINE 204
	     tape_info.volume_name = reel_name;

000420  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000421  aa  7 00153 00 0040	desc9a	pr7|107,32	reel_name
000422  aa  5 00013 00 0040	desc9a	pr5|11,32		tape_info.volume_name
						STATEMENT 1 ON LINE 205
	     tape_info.write_flag = write_flag;

000423  aa  7 00132 2351 00	lda  	pr7|90		write_flag
000424  aa  5 00023 7551 00	sta  	pr5|19		tape_info.write_flag
						STATEMENT 1 ON LINE 206
	     tape_info.position_index = 0;

000425  aa  5 00024 4501 00	stz  	pr5|20		tape_info.position_index
						STATEMENT 1 ON LINE 209
	     ws.info.wait_list.wait_echan = ws.info.special_echan;

000426  aa  1 00016 2371 00	ldaq 	pr1|14		ws.special_echan
000427  aa  1 00012 7571 00	staq 	pr1|10		ws.wait_echan
						STATEMENT 1 ON LINE 210
	     call rcp_$attach (DEVICE_TYPE (TAPE_DRIVE_DTYPEX), tape_info_ptr, ws.info.special_echan, comment,
		ws.info.rcp_id, ecode);

000430  aa   000010 2360 07	ldq  	8,dl
000431  ta   777774 3520 06	epp2 	-4,ql
000432  aa  6 00144 2521 00	spri2	pr6|100
000433  aa  7 00234 3521 00	epp2 	pr7|156		tape_info_ptr
000434  aa  6 00146 2521 00	spri2	pr6|102
000435  aa  1 00016 3521 00	epp2 	pr1|14		ws.special_echan
000436  aa  6 00150 2521 00	spri2	pr6|104
000437  aa  7 00133 3521 00	epp2 	pr7|91		comment
000440  aa  6 00152 2521 00	spri2	pr6|106
000441  aa  1 00002 3521 00	epp2 	pr1|2		ws.rcp_id
000442  aa  6 00154 2521 00	spri2	pr6|108
000443  aa  7 00210 3521 00	epp2 	pr7|136		ecode
000444  aa  6 00156 2521 00	spri2	pr6|110
000445  aa   777450 3520 04	epp2 	-216,ic		000115 = 526000000040
000446  aa  6 00160 2521 00	spri2	pr6|112
000447  aa   777455 3520 04	epp2 	-211,ic		000124 = 464000000000
000450  aa  6 00162 2521 00	spri2	pr6|114
000451  aa   777443 3520 04	epp2 	-221,ic		000114 = 410000000107
000452  aa  6 00164 2521 00	spri2	pr6|116
000453  aa   777440 3520 04	epp2 	-224,ic		000113 = 526000000100
000454  aa  6 00166 2521 00	spri2	pr6|118
000455  aa   777445 3520 04	epp2 	-219,ic		000122 = 514000000044
000456  aa  6 00170 2521 00	spri2	pr6|120
000457  aa   777447 3520 04	epp2 	-217,ic		000126 = 404000000043
000460  aa  6 00172 2521 00	spri2	pr6|122
000461  aa  6 00142 6211 00	eax1 	pr6|98
000462  aa   030000 4310 07	fld  	12288,dl
000463  aa  6 00044 3701 20	epp4 	pr6|36,*
000464  la  4 00046 3521 20	epp2 	pr4|38,*		rcp_$attach
000465  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 212
	     if ecode ^= 0 then
		goto RETURN;

000466  aa  6 00040 3735 20	epp7 	pr6|32,*
000467  aa  7 00210 2361 00	ldq  	pr7|136		ecode
000470  aa   000004 6000 04	tze  	4,ic		000474
000471  aa   000775 3520 04	epp2 	509,ic		001466 = 600210236100
000472  aa   000001 7270 07	lxl7 	1,dl
000473  aa  0 00657 7101 00	tra  	pr0|431		tra_ext
						STATEMENT 1 ON LINE 215
	     reel_name = tape_info.volume_name;

000474  aa  6 00040 3735 20	epp7 	pr6|32,*
000475  aa  7 00234 3715 20	epp5 	pr7|156,*		tape_info_ptr
000476  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000477  aa  5 00013 00 0040	desc9a	pr5|11,32		tape_info.volume_name
000500  aa  7 00153 00 0040	desc9a	pr7|107,32	reel_name
						STATEMENT 1 ON LINE 217
	     if index (temp_reel_name, ",") > 0 then
		temp_reel_name = rtrim (reel_name) || "," || after (temp_reel_name, ",");

000501  aa  000 003 124 500	scm  	(pr),(du),mask(000)
000502  aa  7 00163 00 0100	desc9a	pr7|115,64	temp_reel_name
000503  aa   054000 00 0001	desc9a	22528,1
000504  aa  6 00056 0001 00	arg  	pr6|46
000505  aa  6 00056 2361 00	ldq  	pr6|46
000506  aa   000002 6070 04	ttf  	2,ic		000510
000507  aa   000001 3360 07	lcq  	1,dl
000510  aa   000001 0760 07	adq  	1,dl
000511  aa   000060 6044 04	tmoz 	48,ic		000571
000512  aa  000 003 124 500	scm  	(pr),(du),mask(000)
000513  aa  7 00163 00 0100	desc9a	pr7|115,64	temp_reel_name
000514  aa   054000 00 0001	desc9a	22528,1
000515  aa  6 00056 0001 00	arg  	pr6|46
000516  aa  6 00056 2361 00	ldq  	pr6|46
000517  aa   000002 6064 04	ttn  	2,ic		000521
000520  aa   000001 0760 07	adq  	1,dl
000521  aa  6 00113 7561 00	stq  	pr6|75
000522  aa   000100 2360 07	ldq  	64,dl
000523  aa  6 00113 1761 00	sbq  	pr6|75
000524  aa  6 00112 7561 00	stq  	pr6|74
000525  aa  000 000 165 500	tctr 	(pr)
000526  aa  7 00153 00 0040	desc9a	pr7|107,32	reel_name
000527  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
000530  aa  6 00056 0001 00	arg  	pr6|46
000531  aa  6 00056 2361 00	ldq  	pr6|46
000532  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
000533  aa  6 00174 7561 00	stq  	pr6|124
000534  aa   000040 2360 07	ldq  	32,dl
000535  aa  6 00174 1761 00	sbq  	pr6|124
000536  aa  6 00174 7561 00	stq  	pr6|124
000537  aa   000001 0760 07	adq  	1,dl
000540  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_cs
000541  aa  6 00174 2351 00	lda  	pr6|124
000542  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000543  aa  7 00153 00 0005	desc9a	pr7|107,al	reel_name
000544  aa  2 00000 00 0005	desc9a	pr2|0,al
000545  aa  040 105 100 404	mlr  	(ic),(pr,al),fill(040)
000546  aa   000774 00 0001	desc9a	508,1		001541 = 054000000000
000547  aa  2 00000 00 0001	desc9a	pr2|0,1
000550  aa  6 00174 7561 00	stq  	pr6|124
000551  aa  6 00112 0761 00	adq  	pr6|74
000552  aa  6 00175 7561 00	stq  	pr6|125
000553  aa  0 00606 7001 00	tsx0 	pr0|390		cat_realloc_cs
000554  aa  6 00174 2351 00	lda  	pr6|124
000555  aa  6 00113 2361 00	ldq  	pr6|75
000556  aa  7 00163 3535 00	epp3 	pr7|115		temp_reel_name
000557  aa  3 00000 5005 06	a9bd 	pr3|0,ql
000560  aa  6 00112 2361 00	ldq  	pr6|74
000561  aa  040 145 100 540	mlr  	(pr,rl),(pr,rl,al),fill(040)
000562  aa  3 00000 00 0006	desc9a	pr3|0,ql		temp_reel_name
000563  aa  2 00000 00 0006	desc9a	pr2|0,ql
000564  aa  6 00175 2351 00	lda  	pr6|125
000565  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
000566  aa  2 00000 00 0005	desc9a	pr2|0,al
000567  aa  7 00163 00 0100	desc9a	pr7|115,64	temp_reel_name
000570  aa   000005 7100 04	tra  	5,ic		000575
						STATEMENT 1 ON LINE 219
	     else temp_reel_name = reel_name;

000571  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
000572  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
000573  aa  7 00153 00 0040	desc9a	pr7|107,32	reel_name
000574  aa  7 00163 00 0100	desc9a	pr7|115,64	temp_reel_name
						STATEMENT 1 ON LINE 221
	     arg_reel_name = temp_reel_name;

000575  aa  7 00032 3535 20	epp3 	pr7|26,*
000576  aa  3 00006 3515 20	epp1 	pr3|6,*
000577  aa  7 00240 2351 00	lda  	pr7|160
000600  aa  040 140 100 500	mlr  	(pr),(pr,rl),fill(040)
000601  aa  7 00163 00 0100	desc9a	pr7|115,64	temp_reel_name
000602  aa  1 00000 00 0005	desc9a	pr1|0,al		arg_reel_name
						STATEMENT 1 ON LINE 223
	     ws.info.detachx = 3;

000603  aa   000003 2360 07	ldq  	3,dl
000604  aa  7 00232 3715 20	epp5 	pr7|154,*		ws_ptr
000605  aa  5 00046 7561 00	stq  	pr5|38		ws.detachx
						STATEMENT 1 ON LINE 229
ATTACH_LOOP:
	     comment = " ";

000606  aa  6 00040 3735 20	epp7 	pr6|32,*
000607  aa  040 100 100 400	mlr  	(),(pr),fill(040)
000610  aa   000000 00 0000	desc9a	0,0
000611  aa  7 00133 00 0100	desc9a	pr7|91,64		comment
						STATEMENT 1 ON LINE 231
	     call rcp_$check_attach (ws.info.rcp_id, tape_info_ptr, comment, ws.info.ioix, workspace_max, timeout_max,
		statex, ecode);

000612  aa  7 00232 3715 20	epp5 	pr7|154,*		ws_ptr
000613  aa  5 00002 3521 00	epp2 	pr5|2		ws.rcp_id
000614  aa  6 00200 2521 00	spri2	pr6|128
000615  aa  7 00234 3521 00	epp2 	pr7|156		tape_info_ptr
000616  aa  6 00202 2521 00	spri2	pr6|130
000617  aa  7 00133 3521 00	epp2 	pr7|91		comment
000620  aa  6 00204 2521 00	spri2	pr6|132
000621  aa  5 00003 3521 00	epp2 	pr5|3		ws.ioix
000622  aa  6 00206 2521 00	spri2	pr6|134
000623  aa  7 00216 3521 00	epp2 	pr7|142		workspace_max
000624  aa  6 00210 2521 00	spri2	pr6|136
000625  aa  7 00214 3521 00	epp2 	pr7|140		timeout_max
000626  aa  6 00212 2521 00	spri2	pr6|138
000627  aa  7 00212 3521 00	epp2 	pr7|138		statex
000630  aa  6 00214 2521 00	spri2	pr6|140
000631  aa  7 00210 3521 00	epp2 	pr7|136		ecode
000632  aa  6 00216 2521 00	spri2	pr6|142
000633  aa   777267 3520 04	epp2 	-329,ic		000122 = 514000000044
000634  aa  6 00220 2521 00	spri2	pr6|144
000635  aa   777267 3520 04	epp2 	-329,ic		000124 = 464000000000
000636  aa  6 00222 2521 00	spri2	pr6|146
000637  aa   777254 3520 04	epp2 	-340,ic		000113 = 526000000100
000640  aa  6 00224 2521 00	spri2	pr6|148
000641  aa   777257 3520 04	epp2 	-337,ic		000120 = 404000000021
000642  aa  6 00226 2521 00	spri2	pr6|150
000643  aa  6 00234 2521 00	spri2	pr6|156
000644  aa   777246 3520 04	epp2 	-346,ic		000112 = 404000000023
000645  aa  6 00230 2521 00	spri2	pr6|152
000646  aa   777246 3520 04	epp2 	-346,ic		000114 = 410000000107
000647  aa  6 00232 2521 00	spri2	pr6|154
000650  aa   777256 3520 04	epp2 	-338,ic		000126 = 404000000043
000651  aa  6 00236 2521 00	spri2	pr6|158
000652  aa  6 00176 6211 00	eax1 	pr6|126
000653  aa   040000 4310 07	fld  	16384,dl
000654  aa  6 00044 3701 20	epp4 	pr6|36,*
000655  la  4 00050 3521 20	epp2 	pr4|40,*		rcp_$check_attach
000656  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 233
	     if comment ^= " "			/* Is there a comment from RCP? */
	     then call com_err_ (0, "tdcm_", "RCP comment: ^a", comment);

000657  aa  6 00040 3735 20	epp7 	pr6|32,*
000660  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
000661  aa  7 00133 00 0100	desc9a	pr7|91,64		comment
000662  aa   000660 00 0001	desc9a	432,1		001540 = 040000000000
000663  aa   000035 6000 04	tze  	29,ic		000720
000664  aa  6 00175 4501 00	stz  	pr6|125
000665  aa   777243 2370 04	ldaq 	-349,ic		000130 = 164144143155 137000000000
000666  aa  6 00240 7571 00	staq 	pr6|160
000667  aa   777247 2370 04	ldaq 	-345,ic		000136 = 122103120040 143157155155
000670  aa  6 00114 7571 00	staq 	pr6|76
000671  aa   777247 2370 04	ldaq 	-345,ic		000140 = 145156164072 040136141000
000672  aa  6 00116 7571 00	staq 	pr6|78
000673  aa  6 00175 3521 00	epp2 	pr6|125
000674  aa  6 00144 2521 00	spri2	pr6|100
000675  aa  6 00240 3521 00	epp2 	pr6|160
000676  aa  6 00146 2521 00	spri2	pr6|102
000677  aa  6 00114 3521 00	epp2 	pr6|76
000700  aa  6 00150 2521 00	spri2	pr6|104
000701  aa  7 00133 3521 00	epp2 	pr7|91		comment
000702  aa  6 00152 2521 00	spri2	pr6|106
000703  aa   777206 3520 04	epp2 	-378,ic		000111 = 404000000005
000704  aa  6 00154 2521 00	spri2	pr6|108
000705  aa   777203 3520 04	epp2 	-381,ic		000110 = 524000000005
000706  aa  6 00156 2521 00	spri2	pr6|110
000707  aa   777200 3520 04	epp2 	-384,ic		000107 = 524000000017
000710  aa  6 00160 2521 00	spri2	pr6|112
000711  aa   777202 3520 04	epp2 	-382,ic		000113 = 526000000100
000712  aa  6 00162 2521 00	spri2	pr6|114
000713  aa  6 00142 6211 00	eax1 	pr6|98
000714  aa   020000 4310 07	fld  	8192,dl
000715  aa  6 00044 3701 20	epp4 	pr6|36,*
000716  la  4 00016 3521 20	epp2 	pr4|14,*		com_err_
000717  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 235
	     goto ATTACH_STATE (statex);

000720  aa  6 00040 3735 20	epp7 	pr6|32,*
000721  aa  7 00212 7271 00	lxl7 	pr7|138		statex
000722  ta   000000 7100 17	tra  	0,7
						STATEMENT 1 ON LINE 237
ATTACH_STATE (1):					/* Short wait. */
	     on cleanup call clean_up;

000723  aa   000007 7260 07	lxl6 	7,dl
000724  aa   777210 3520 04	epp2 	-376,ic		000134 = 143154145141
000725  aa  0 00717 7001 00	tsx0 	pr0|463		enable
000726  aa   000004 7100 04	tra  	4,ic		000732
000727  aa     000100000000
000730  aa   000011 7100 04	tra  	9,ic		000741
BEGIN CONDITION cleanup.1
ENTRY TO cleanup.1                                          STATEMENT 1 ON LINE 237
ATTACH_STATE (1):					/* Short wait. */
	     on cleanup call clean_up;

000731  da     000234200000
000732  aa   000140 6270 00	eax7 	96
000733  aa  7 00034 3521 20	epp2 	pr7|28,*
000734  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000735  aa     000000000000
000736  aa     000000000000
000737  aa   000533 6700 04	tsp4 	347,ic		001472
000740  aa  0 00631 7101 00	tra  	pr0|409		return
  END CONDITION cleanup.1
						STATEMENT 1 ON LINE 239
	     call ipc_$block (addr (ws.info.wait_list), addr (event_data), ecode);

000741  aa  6 00040 3735 20	epp7 	pr6|32,*
000742  aa  7 00232 3715 20	epp5 	pr7|154,*		ws_ptr
000743  aa  5 00010 3735 00	epp7 	pr5|8		ws.wait_list
000744  aa  6 00240 6535 00	spri7	pr6|160
000745  aa  6 00040 3535 20	epp3 	pr6|32,*
000746  aa  3 00220 3535 00	epp3 	pr3|144		event_data
000747  aa  6 00242 2535 00	spri3	pr6|162
000750  aa  6 00240 3521 00	epp2 	pr6|160
000751  aa  6 00116 2521 00	spri2	pr6|78
000752  aa  6 00242 3521 00	epp2 	pr6|162
000753  aa  6 00120 2521 00	spri2	pr6|80
000754  aa  6 00040 3515 20	epp1 	pr6|32,*
000755  aa  1 00210 3521 00	epp2 	pr1|136		ecode
000756  aa  6 00122 2521 00	spri2	pr6|82
000757  aa  6 00114 6211 00	eax1 	pr6|76
000760  aa   014000 4310 07	fld  	6144,dl
000761  aa  6 00044 3701 20	epp4 	pr6|36,*
000762  la  4 00040 3521 20	epp2 	pr4|32,*		ipc_$block
000763  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 240
	     revert cleanup;

000764  aa  6 00104 4501 00	stz  	pr6|68
						STATEMENT 1 ON LINE 241
	     if ecode ^= 0 then do;

000765  aa  6 00040 3735 20	epp7 	pr6|32,*
000766  aa  7 00210 2361 00	ldq  	pr7|136		ecode
000767  aa   777617 6000 04	tze  	-113,ic		000606
						STATEMENT 1 ON LINE 242
		call convert_ipc_code_ (ecode);

000770  aa  7 00210 3521 00	epp2 	pr7|136		ecode
000771  aa  6 00116 2521 00	spri2	pr6|78
000772  aa  6 00114 6211 00	eax1 	pr6|76
000773  aa   004000 4310 07	fld  	2048,dl
000774  aa  6 00044 3701 20	epp4 	pr6|36,*
000775  la  4 00020 3521 20	epp2 	pr4|16,*		convert_ipc_code_
000776  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 243
		goto RETURN;

000777  aa   000467 3520 04	epp2 	311,ic		001466 = 600210236100
001000  aa   000001 7270 07	lxl7 	1,dl
001001  aa  0 00657 7101 00	tra  	pr0|431		tra_ext
						STATEMENT 1 ON LINE 244
	     end;

						STATEMENT 1 ON LINE 245
	     goto ATTACH_LOOP;

001002  aa   777604 7100 04	tra  	-124,ic		000606
						STATEMENT 1 ON LINE 247
ATTACH_STATE (2):					/* Long wait. */
	     ecode = error_table_$ionmat;

001003  aa  6 00044 3701 20	epp4 	pr6|36,*
001004  la  4 00010 2361 20	ldq  	pr4|8,*		error_table_$ionmat
001005  aa  7 00210 7561 00	stq  	pr7|136		ecode
						STATEMENT 1 ON LINE 249
ATTACH_STATE (3):					/* Fatal error. */
	     goto RETURN;

001006  aa   000460 3520 04	epp2 	304,ic		001466 = 600210236100
001007  aa   000001 7270 07	lxl7 	1,dl
001010  aa  0 00657 7101 00	tra  	pr0|431		tra_ext
						STATEMENT 1 ON LINE 255
ATTACH_STATE (0):					/* Attachment complete. */
	     call cv_dec_ (substr (tape_info.device_name, 6, 2), drive_num);

001011  aa  7 00234 3715 20	epp5 	pr7|156,*		tape_info_ptr
001012  aa  5 00005 2351 00	lda  	pr5|5		tape_info.device_name
001013  aa   000011 7350 00	als  	9
001014  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
001015  aa  6 00175 7551 00	sta  	pr6|125
001016  aa  6 00175 3521 00	epp2 	pr6|125
001017  aa  6 00116 2521 00	spri2	pr6|78
001020  aa  7 00207 3521 00	epp2 	pr7|135		drive_num
001021  aa  6 00120 2521 00	spri2	pr6|80
001022  aa   777064 3520 04	epp2 	-460,ic		000106 = 524000000002
001023  aa  6 00122 2521 00	spri2	pr6|82
001024  aa   777074 3520 04	epp2 	-452,ic		000120 = 404000000021
001025  aa  6 00124 2521 00	spri2	pr6|84
001026  aa  6 00114 6211 00	eax1 	pr6|76
001027  aa   010000 4310 07	fld  	4096,dl
001030  aa  6 00044 3701 20	epp4 	pr6|36,*
001031  la  4 00022 3521 20	epp2 	pr4|18,*		cv_dec_
001032  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 257
	     tseg.drive_name = tape_info.device_name;

001033  aa  6 00040 3735 20	epp7 	pr6|32,*
001034  aa  7 00230 3715 20	epp5 	pr7|152,*		tsegp
001035  aa  7 00234 3535 20	epp3 	pr7|156,*		tape_info_ptr
001036  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
001037  aa  3 00004 00 0010	desc9a	pr3|4,8		tape_info.device_name
001040  aa  5 00012 00 0040	desc9a	pr5|10,32		tseg.drive_name
						STATEMENT 1 ON LINE 264
	     workspace_size = fixed (rel (addr (ws.buf_end)), 18) - fixed (rel (addr (ws.info)), 18) + 1;

001041  aa  7 00232 3515 20	epp1 	pr7|154,*		ws.info
001042  aa  1 00000 6351 00	eaa  	pr1|0
001043  aa   000066 7730 00	lrl  	54
001044  aa  6 00175 7561 00	stq  	pr6|125
001045  aa  7 00232 3715 20	epp5 	pr7|154,*		ws_ptr
001046  aa  5 00001 7271 00	lxl7 	pr5|1		ws.buf_size
001047  aa  5 00212 3535 17	epp3 	pr5|138,7		ws.buf_end
001050  aa  3 00000 6351 00	eaa  	pr3|0
001051  aa   000066 7730 00	lrl  	54
001052  aa  6 00175 1761 00	sbq  	pr6|125
001053  aa   000001 0760 07	adq  	1,dl
001054  aa  7 00217 7561 00	stq  	pr7|143		workspace_size
						STATEMENT 1 ON LINE 265
	     if workspace_size > workspace_max		/* If buffer size too large adjust it. */
	     then do;

001055  aa  7 00216 1161 00	cmpq 	pr7|142		workspace_max
001056  aa  6 00242 2515 00	spri1	pr6|162
001057  aa  6 00240 2535 00	spri3	pr6|160
001060  aa   000011 6044 04	tmoz 	9,ic		001071
						STATEMENT 1 ON LINE 267
		ws.info.flags.good_ws = "0"b;

001061  aa   000456 2350 04	lda  	302,ic		001537 = 775777777777
001062  aa  5 00000 3551 00	ansa 	pr5|0		ws.good_ws
						STATEMENT 1 ON LINE 268
		ecode = error_table_$big_ws_req;

001063  aa  6 00044 3701 20	epp4 	pr6|36,*
001064  la  4 00012 2361 20	ldq  	pr4|10,*		error_table_$big_ws_req
001065  aa  7 00210 7561 00	stq  	pr7|136		ecode
						STATEMENT 1 ON LINE 269
		goto RETURN;

001066  aa   000400 3520 04	epp2 	256,ic		001466 = 600210236100
001067  aa   000001 7270 07	lxl7 	1,dl
001070  aa  0 00657 7101 00	tra  	pr0|431		tra_ext
						STATEMENT 1 ON LINE 270
	     end;

						STATEMENT 1 ON LINE 272
	     call ioi_$workspace (ws.info.ioix, real_ws_ptr, workspace_size, ecode);

001071  aa  5 00003 3521 00	epp2 	pr5|3		ws.ioix
001072  aa  6 00116 2521 00	spri2	pr6|78
001073  aa  7 00204 3521 00	epp2 	pr7|132		real_ws_ptr
001074  aa  6 00120 2521 00	spri2	pr6|80
001075  aa  7 00217 3521 00	epp2 	pr7|143		workspace_size
001076  aa  6 00122 2521 00	spri2	pr6|82
001077  aa  7 00210 3521 00	epp2 	pr7|136		ecode
001100  aa  6 00124 2521 00	spri2	pr6|84
001101  aa  6 00114 6211 00	eax1 	pr6|76
001102  aa   020000 4310 07	fld  	8192,dl
001103  aa  6 00044 3701 20	epp4 	pr6|36,*
001104  la  4 00036 3521 20	epp2 	pr4|30,*		ioi_$workspace
001105  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 273
	     if ecode ^= 0 then do;

001106  aa  6 00040 3735 20	epp7 	pr6|32,*
001107  aa  7 00210 2361 00	ldq  	pr7|136		ecode
001110  aa   000006 6000 04	tze  	6,ic		001116
						STATEMENT 1 ON LINE 274
		ws.info.flags.good_ws = "0"b;

001111  aa   000426 2350 04	lda  	278,ic		001537 = 775777777777
001112  aa  7 00232 3551 20	ansa 	pr7|154,*		ws.good_ws
						STATEMENT 1 ON LINE 275
		goto RETURN;

001113  aa   000353 3520 04	epp2 	235,ic		001466 = 600210236100
001114  aa   000001 7270 07	lxl7 	1,dl
001115  aa  0 00657 7101 00	tra  	pr0|431		tra_ext
						STATEMENT 1 ON LINE 276
	     end;

						STATEMENT 1 ON LINE 278
	     ws.info.flags.good_ws = "1"b;

001116  aa   002000 2350 03	lda  	1024,du
001117  aa  7 00232 2551 20	orsa 	pr7|154,*		ws.good_ws
						STATEMENT 1 ON LINE 284
	     real_ws_ptr -> ws.info = ws_ptr -> ws.info;

001120  aa  7 00204 3715 20	epp5 	pr7|132,*		real_ws_ptr
001121  aa  7 00232 3535 20	epp3 	pr7|154,*		ws_ptr
001122  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001123  aa  3 00000 00 0424	desc9a	pr3|0,276		ws.info
001124  aa  5 00000 00 0424	desc9a	pr5|0,276		ws.info
						STATEMENT 1 ON LINE 285
	     ws_ptr = real_ws_ptr;

001125  aa  7 00232 6515 00	spri5	pr7|154		ws_ptr
						STATEMENT 1 ON LINE 286
	     tseg.ws_segno = baseno (ws_ptr);

001126  aa  7 00232 2131 20	epaq 	pr7|154,*		ws_ptr
001127  aa   077777 3750 03	ana  	32767,du
001130  aa  7 00230 3715 20	epp5 	pr7|152,*		tsegp
001131  aa  5 00011 7551 00	sta  	pr5|9		tseg.ws_segno
						STATEMENT 1 ON LINE 288
	end;

001132  aa  0 00615 7001 00	tsx0 	pr0|397		leave_begin
  END BLOCK  1
						STATEMENT 1 ON LINE 299
	call ioi_$timeout (ws.info.ioix, timeout_max, ecode);

001133  aa  6 00232 3735 20	epp7 	pr6|154,*		ws_ptr
001134  aa  7 00003 3521 00	epp2 	pr7|3		ws.ioix
001135  aa  6 00244 2521 00	spri2	pr6|164
001136  aa  6 00214 3521 00	epp2 	pr6|140		timeout_max
001137  aa  6 00246 2521 00	spri2	pr6|166
001140  aa  6 00210 3521 00	epp2 	pr6|136		ecode
001141  aa  6 00250 2521 00	spri2	pr6|168
001142  aa  6 00242 6211 00	eax1 	pr6|162
001143  aa   014000 4310 07	fld  	6144,dl
001144  aa  6 00044 3701 20	epp4 	pr6|36,*
001145  la  4 00034 3521 20	epp2 	pr4|28,*		ioi_$timeout
001146  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 300
	if ecode ^= 0 then
	     goto RETURN;

001147  aa  6 00210 2361 00	ldq  	pr6|136		ecode
001150  aa   000316 6010 04	tnz  	206,ic		001466
						STATEMENT 1 ON LINE 304
	call ioi_$set_status (ws.info.ioix, fixed (rel (addr (ws.statq)), 18), hbound (ws.statq, 1), ecode);

001151  aa  6 00232 3735 20	epp7 	pr6|154,*		ws_ptr
001152  aa  7 00150 3735 00	epp7 	pr7|104		ws.statq
001153  aa  7 00000 6351 00	eaa  	pr7|0
001154  aa   000066 7730 00	lrl  	54
001155  aa  6 00241 7561 00	stq  	pr6|161
001156  aa   000004 2360 07	ldq  	4,dl
001157  aa  6 00252 7561 00	stq  	pr6|170
001160  aa  6 00232 3715 20	epp5 	pr6|154,*		ws_ptr
001161  aa  5 00003 3521 00	epp2 	pr5|3		ws.ioix
001162  aa  6 00256 2521 00	spri2	pr6|174
001163  aa  6 00241 3521 00	epp2 	pr6|161
001164  aa  6 00260 2521 00	spri2	pr6|176
001165  aa  6 00252 3521 00	epp2 	pr6|170
001166  aa  6 00262 2521 00	spri2	pr6|178
001167  aa  6 00210 3521 00	epp2 	pr6|136		ecode
001170  aa  6 00264 2521 00	spri2	pr6|180
001171  aa  6 00254 6211 00	eax1 	pr6|172
001172  aa   020000 4310 07	fld  	8192,dl
001173  aa  6 00044 3701 20	epp4 	pr6|36,*
001174  la  4 00032 3521 20	epp2 	pr4|26,*		ioi_$set_status
001175  aa  6 00266 6535 00	spri7	pr6|182
001176  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 305
	if ecode ^= 0 then
	     return;

001177  aa  6 00210 2361 00	ldq  	pr6|136		ecode
001200  aa  0 00631 6011 00	tnz  	pr0|409		return
						STATEMENT 1 ON LINE 308
	do i = 1 to hbound (ws.statq, 1);

001201  aa   000001 2360 07	ldq  	1,dl
001202  aa  6 00211 7561 00	stq  	pr6|137		i
001203  aa   000000 0110 03	nop  	0,du
001204  aa  6 00211 2361 00	ldq  	pr6|137		i
001205  aa   000004 1160 07	cmpq 	4,dl
001206  aa   000007 6054 04	tpnz 	7,ic		001215
						STATEMENT 1 ON LINE 309
	     ws.statq (i).completion.st = "0"b;

001207  aa   000003 7360 00	qls  	3
001210  aa   000326 2350 04	lda  	214,ic		001536 = 377777777777
001211  aa  6 00232 3735 20	epp7 	pr6|154,*		ws_ptr
001212  aa  7 00140 3551 06	ansa 	pr7|96,ql		ws.st
						STATEMENT 1 ON LINE 310
	end;

001213  aa  6 00211 0541 00	aos  	pr6|137		i
001214  aa   777770 7100 04	tra  	-8,ic		001204
						STATEMENT 1 ON LINE 311
	ws.info.statqx = 1;

001215  aa   000001 2360 07	ldq  	1,dl
001216  aa  6 00232 3735 20	epp7 	pr6|154,*		ws_ptr
001217  aa  7 00004 7561 00	stq  	pr7|4		ws.statqx
						STATEMENT 1 ON LINE 313
	call ioi_$set_event (ws.info.ioix, ws.info.init_echan, ecode);

001220  aa  7 00003 3521 00	epp2 	pr7|3		ws.ioix
001221  aa  6 00244 2521 00	spri2	pr6|164
001222  aa  7 00022 3521 00	epp2 	pr7|18		ws.init_echan
001223  aa  6 00246 2521 00	spri2	pr6|166
001224  aa  6 00210 3521 00	epp2 	pr6|136		ecode
001225  aa  6 00250 2521 00	spri2	pr6|168
001226  aa  6 00242 6211 00	eax1 	pr6|162
001227  aa   014000 4310 07	fld  	6144,dl
001230  aa  6 00044 3701 20	epp4 	pr6|36,*
001231  la  4 00030 3521 20	epp2 	pr4|24,*		ioi_$set_event
001232  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 314
	if ecode ^= 0				/* Did we set up IOI's event channel? */
	then goto RETURN;

001233  aa  6 00210 2361 00	ldq  	pr6|136		ecode
001234  aa   000232 6010 04	tnz  	154,ic		001466
						STATEMENT 1 ON LINE 318
	ws.info.wait_list.wait_echan = ws.info.fast_echan;

001235  aa  6 00232 3735 20	epp7 	pr6|154,*		ws_ptr
001236  aa  7 00014 2371 00	ldaq 	pr7|12		ws.fast_echan
001237  aa  7 00012 7571 00	staq 	pr7|10		ws.wait_echan
						STATEMENT 1 ON LINE 321
	call ipc_$decl_ev_call_chn (ws.info.special_echan, tdcm_$special_handler, ws_ptr, 0, ecode);

001240  aa  6 00044 3701 20	epp4 	pr6|36,*
001241  la  4 00054 3521 20	epp2 	pr4|44,*		tdcm_$special_handler
001242  aa  6 00242 2521 00	spri2	pr6|162		cp.155
001243  aa   000271 2370 04	ldaq 	185,ic		001534 = 077777000043 000001000000
001244  aa  6 00244 7571 00	staq 	pr6|164		cp.155
001245  aa  6 00252 4501 00	stz  	pr6|170
001246  aa  7 00016 3521 00	epp2 	pr7|14		ws.special_echan
001247  aa  6 00272 2521 00	spri2	pr6|186
001250  aa  6 00242 3521 00	epp2 	pr6|162		cp.155
001251  aa  6 00274 2521 00	spri2	pr6|188
001252  aa  6 00232 3521 00	epp2 	pr6|154		ws_ptr
001253  aa  6 00276 2521 00	spri2	pr6|190
001254  aa  6 00252 3521 00	epp2 	pr6|170
001255  aa  6 00300 2521 00	spri2	pr6|192
001256  aa  6 00210 3521 00	epp2 	pr6|136		ecode
001257  aa  6 00302 2521 00	spri2	pr6|194
001260  aa  6 00270 6211 00	eax1 	pr6|184
001261  aa   024000 4310 07	fld  	10240,dl
001262  la  4 00042 3521 20	epp2 	pr4|34,*		ipc_$decl_ev_call_chn
001263  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 322
	if ecode ^= 0				/* Did we make it a call channel? */
	then do;

001264  aa  6 00210 2361 00	ldq  	pr6|136		ecode
001265  aa   000011 6000 04	tze  	9,ic		001276
						STATEMENT 1 ON LINE 324
	     call convert_ipc_code_ (ecode);

001266  aa  6 00210 3521 00	epp2 	pr6|136		ecode
001267  aa  6 00244 2521 00	spri2	pr6|164
001270  aa  6 00242 6211 00	eax1 	pr6|162
001271  aa   004000 4310 07	fld  	2048,dl
001272  aa  6 00044 3701 20	epp4 	pr6|36,*
001273  la  4 00020 3521 20	epp2 	pr4|16,*		convert_ipc_code_
001274  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 325
	     goto RETURN;

001275  aa   000171 7100 04	tra  	121,ic		001466
						STATEMENT 1 ON LINE 326
	end;

						STATEMENT 1 ON LINE 328
	ws.info.disposition = "0"b;

001276  aa  6 00232 3735 20	epp7 	pr6|154,*		ws_ptr
001277  aa  7 00047 4501 00	stz  	pr7|39		ws.disposition
						STATEMENT 1 ON LINE 329
	ws.info.process_id = get_process_id_ ();

001300  aa  7 00005 3521 00	epp2 	pr7|5		ws.process_id
001301  aa  6 00244 2521 00	spri2	pr6|164
001302  aa  6 00242 6211 00	eax1 	pr6|162
001303  aa   004000 4310 07	fld  	2048,dl
001304  aa  6 00044 3701 20	epp4 	pr6|36,*
001305  la  4 00024 3521 20	epp2 	pr4|20,*		get_process_id_
001306  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 330
	ws.info.flags.attached = "1"b;

001307  aa   400000 2350 03	lda  	131072,du
001310  aa  6 00232 2551 20	orsa 	pr6|154,*		ws.attached
						STATEMENT 1 ON LINE 333
	ws.info.ndt_offsetx = fixed (rel (addr (ws.ndt_list)), 18);

001311  aa  6 00232 3735 20	epp7 	pr6|154,*		ws_ptr
001312  aa  7 00105 3735 00	epp7 	pr7|69		ws.ndt_list
001313  aa  7 00000 6351 00	eaa  	pr7|0
001314  aa   000066 7730 00	lrl  	54
001315  aa  6 00232 3715 20	epp5 	pr6|154,*		ws_ptr
001316  aa  5 00065 7561 00	stq  	pr5|53		ws.ndt_offsetx
						STATEMENT 1 ON LINE 334
	ws.info.rw_offsetx = fixed (rel (addr (ws.rw_list)), 18);

001317  aa  5 00117 3535 00	epp3 	pr5|79		ws.rw_list
001320  aa  3 00000 6351 00	eaa  	pr3|0
001321  aa   000066 7730 00	lrl  	54
001322  aa  5 00066 7561 00	stq  	pr5|54		ws.rw_offsetx
						STATEMENT 1 ON LINE 336
	do i = 1 to hbound (ws.ndt_list, 1);

001323  aa   000001 2360 07	ldq  	1,dl
001324  aa  6 00211 7561 00	stq  	pr6|137		i
001325  aa   000000 0110 03	nop  	0,du
001326  aa  6 00304 2535 00	spri3	pr6|196
001327  aa  6 00306 6535 00	spri7	pr6|198
001330  aa  6 00211 2361 00	ldq  	pr6|137		i
001331  aa   000012 1160 07	cmpq 	10,dl
001332  aa   000023 6054 04	tpnz 	19,ic		001355
						STATEMENT 1 ON LINE 337
	     idcwp = addr (ws.ndt_list (i).idcw);

001333  aa  6 00232 3735 20	epp7 	pr6|154,*		ws_ptr
001334  aa  7 00104 3735 06	epp7 	pr7|68,ql		ws.idcw
001335  aa  6 00236 6535 00	spri7	pr6|158		idcwp
						STATEMENT 1 ON LINE 338
	     string (idcw) = "0"b;

001336  aa  7 00000 4501 00	stz  	pr7|0
						STATEMENT 1 ON LINE 339
	     idcw.device = bit (fixed (drive_num, 6));

001337  aa  6 00207 2351 00	lda  	pr6|135		drive_num
001340  aa   000002 6050 04	tpl  	2,ic		001342
001341  aa   000000 5310 00	neg  	0
001342  aa   000036 7350 00	als  	30
001343  aa   000006 7710 00	arl  	6
001344  aa  7 00000 7511 20	stca 	pr7|0,20		idcw.device
						STATEMENT 1 ON LINE 340
	     idcw.code = "111"b;

001345  aa   700000 2350 07	lda  	229376,dl
001346  aa  7 00000 2551 00	orsa 	pr7|0		idcw.code
						STATEMENT 1 ON LINE 341
	     idcw.chan_cmd = "000010"b;

001347  aa   000200 2350 07	lda  	128,dl
001350  aa  7 00000 7511 02	stca 	pr7|0,02		idcw.chan_cmd
						STATEMENT 1 ON LINE 342
	     idcw.count = "000001"b;

001351  aa   000001 2350 07	lda  	1,dl
001352  aa  7 00000 7511 01	stca 	pr7|0,01		idcw.count
						STATEMENT 1 ON LINE 343
	end;

001353  aa  6 00211 0541 00	aos  	pr6|137		i
001354  aa   777752 7100 04	tra  	-22,ic		001326
						STATEMENT 1 ON LINE 345
	do i = 1 to hbound (ws.rw_list, 1);

001355  aa   000001 2360 07	ldq  	1,dl
001356  aa  6 00211 7561 00	stq  	pr6|137		i
001357  aa   000000 0110 03	nop  	0,du
001360  aa  6 00211 2361 00	ldq  	pr6|137		i
001361  aa   000014 1160 07	cmpq 	12,dl
001362  aa   000006 6054 04	tpnz 	6,ic		001370
						STATEMENT 1 ON LINE 346
	     ws.rw_list (i).dcw = "0"b;

001363  aa   000001 7360 00	qls  	1
001364  aa  6 00232 3735 20	epp7 	pr6|154,*		ws_ptr
001365  aa  7 00116 4501 06	stz  	pr7|78,ql		ws.dcw
						STATEMENT 1 ON LINE 347
	end;

001366  aa  6 00211 0541 00	aos  	pr6|137		i
001367  aa   777771 7100 04	tra  	-7,ic		001360
						STATEMENT 1 ON LINE 349
	idcwp = addr (temp_idcw);

001370  aa  6 00130 3735 00	epp7 	pr6|88		temp_idcw
001371  aa  6 00236 6535 00	spri7	pr6|158		idcwp
						STATEMENT 1 ON LINE 350
	string (idcw) = "0"b;

001372  aa  7 00000 4501 00	stz  	pr7|0
						STATEMENT 1 ON LINE 351
	idcw.device = bit (fixed (drive_num, 6));

001373  aa  6 00207 2351 00	lda  	pr6|135		drive_num
001374  aa   000002 6050 04	tpl  	2,ic		001376
001375  aa   000000 5310 00	neg  	0
001376  aa   000036 7350 00	als  	30
001377  aa   000006 7710 00	arl  	6
001400  aa  7 00000 7511 20	stca 	pr7|0,20		idcw.device
						STATEMENT 1 ON LINE 352
	idcw.code = "111"b;

001401  aa   700000 2350 07	lda  	229376,dl
001402  aa  7 00000 2551 00	orsa 	pr7|0		idcw.code
						STATEMENT 1 ON LINE 353
	idcw.control = "10"b;

001403  aa   020000 2350 07	lda  	8192,dl
001404  aa  7 00000 6751 00	era  	pr7|0		idcw.control
001405  aa   030000 3750 07	ana  	12288,dl
001406  aa  7 00000 6551 00	ersa 	pr7|0		idcw.control
						STATEMENT 1 ON LINE 355
	do i = 0 to hbound (ws.info.read_idcws, 1);

001407  aa  6 00211 4501 00	stz  	pr6|137		i
001410  aa  6 00211 2361 00	ldq  	pr6|137		i
001411  aa   000005 1160 07	cmpq 	5,dl
001412  aa   000014 6054 04	tpnz 	12,ic		001426
						STATEMENT 1 ON LINE 356
	     idcwp = addr (ws.info.read_idcws (i));

001413  aa  6 00232 3735 20	epp7 	pr6|154,*		ws_ptr
001414  aa  7 00071 3735 06	epp7 	pr7|57,ql		ws.read_idcws
001415  aa  6 00236 6535 00	spri7	pr6|158		idcwp
						STATEMENT 1 ON LINE 357
	     based_idcw = temp_idcw;

001416  aa  6 00130 2351 00	lda  	pr6|88		temp_idcw
001417  aa  7 00000 7551 00	sta  	pr7|0		based_idcw
						STATEMENT 1 ON LINE 358
	     idcw.command = read_idcw_commands (i);

001420  aa   000006 4020 07	mpy  	6,dl
001421  aa  003 100 060 406	csl  	(ql),(pr),fill(0),bool(move)
001422  ta   000105 00 0006	descb	69,6
001423  aa  7 00000 00 0006	descb	pr7|0,6		idcw.command
						STATEMENT 1 ON LINE 359
	end;

001424  aa  6 00211 0541 00	aos  	pr6|137		i
001425  aa   777763 7100 04	tra  	-13,ic		001410
						STATEMENT 1 ON LINE 361
	do i = 0 to hbound (ws.info.write_idcws, 1);

001426  aa  6 00211 4501 00	stz  	pr6|137		i
001427  aa   000000 0110 03	nop  	0,du
001430  aa  6 00211 2361 00	ldq  	pr6|137		i
001431  aa   000005 1160 07	cmpq 	5,dl
001432  aa   000014 6054 04	tpnz 	12,ic		001446
						STATEMENT 1 ON LINE 362
	     idcwp = addr (ws.info.write_idcws (i));

001433  aa  6 00232 3735 20	epp7 	pr6|154,*		ws_ptr
001434  aa  7 00077 3735 06	epp7 	pr7|63,ql		ws.write_idcws
001435  aa  6 00236 6535 00	spri7	pr6|158		idcwp
						STATEMENT 1 ON LINE 363
	     based_idcw = temp_idcw;

001436  aa  6 00130 2351 00	lda  	pr6|88		temp_idcw
001437  aa  7 00000 7551 00	sta  	pr7|0		based_idcw
						STATEMENT 1 ON LINE 364
	     idcw.command = write_idcw_commands (i);

001440  aa   000006 4020 07	mpy  	6,dl
001441  aa  003 100 060 406	csl  	(ql),(pr),fill(0),bool(move)
001442  ta   000104 00 0006	descb	68,6
001443  aa  7 00000 00 0006	descb	pr7|0,6		idcw.command
						STATEMENT 1 ON LINE 365
	end;

001444  aa  6 00211 0541 00	aos  	pr6|137		i
001445  aa   777763 7100 04	tra  	-13,ic		001430
						STATEMENT 1 ON LINE 370
	call hcs_$wakeup (ws.info.process_id, ws.info.user_echan, 0, ecode);

001446  aa   776464 2370 04	ldaq 	-716,ic		000132 = 000000000000 000000000000
001447  aa  6 00310 7571 00	staq 	pr6|200
001450  aa  6 00232 3735 20	epp7 	pr6|154,*		ws_ptr
001451  aa  7 00005 3521 00	epp2 	pr7|5		ws.process_id
001452  aa  6 00256 2521 00	spri2	pr6|174
001453  aa  7 00020 3521 00	epp2 	pr7|16		ws.user_echan
001454  aa  6 00260 2521 00	spri2	pr6|176
001455  aa  6 00310 3521 00	epp2 	pr6|200
001456  aa  6 00262 2521 00	spri2	pr6|178
001457  aa  6 00210 3521 00	epp2 	pr6|136		ecode
001460  aa  6 00264 2521 00	spri2	pr6|180
001461  aa  6 00254 6211 00	eax1 	pr6|172
001462  aa   020000 4310 07	fld  	8192,dl
001463  aa  6 00044 3701 20	epp4 	pr6|36,*
001464  la  4 00026 3521 20	epp2 	pr4|22,*		hcs_$wakeup
001465  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 372
RETURN:
	arg_ecode = ecode;

001466  aa  6 00210 2361 00	ldq  	pr6|136		ecode
001467  aa  6 00032 3735 20	epp7 	pr6|26,*
001470  aa  7 00012 7561 20	stq  	pr7|10,*		arg_ecode
						STATEMENT 1 ON LINE 375
	return;

001471  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 386
     end tdcm_message_;

BEGIN PROCEDURE clean_up
ENTRY TO clean_up                                           STATEMENT 1 ON LINE 380
clean_up:
     proc;

001472  aa  6 00100 6501 00	spri4	pr6|64
						STATEMENT 1 ON LINE 383
	call rcp_$detach (ws.info.rcp_id, "0"b, (0), "", (0));

001473  aa   000000 2350 07	lda  	0,dl
001474  aa  6 00106 7551 00	sta  	pr6|70
001475  aa  6 00107 4501 00	stz  	pr6|71
001476  aa  6 00111 4501 00	stz  	pr6|73
001477  aa  6 00040 3735 20	epp7 	pr6|32,*
001500  aa  7 00040 3735 20	epp7 	pr7|32,*
001501  aa  7 00232 3715 20	epp5 	pr7|154,*		ws_ptr
001502  aa  5 00002 3521 00	epp2 	pr5|2		ws.rcp_id
001503  aa  6 00114 2521 00	spri2	pr6|76
001504  aa  6 00106 3521 00	epp2 	pr6|70
001505  aa  6 00116 2521 00	spri2	pr6|78
001506  aa  6 00107 3521 00	epp2 	pr6|71
001507  aa  6 00120 2521 00	spri2	pr6|80
001510  aa  6 00110 3521 00	epp2 	pr6|72
001511  aa  6 00122 2521 00	spri2	pr6|82
001512  aa  6 00111 3521 00	epp2 	pr6|73
001513  aa  6 00124 2521 00	spri2	pr6|84
001514  aa   776406 3520 04	epp2 	-762,ic		000122 = 514000000044
001515  aa  6 00126 2521 00	spri2	pr6|86
001516  aa   776403 3520 04	epp2 	-765,ic		000121 = 514000000001
001517  aa  6 00130 2521 00	spri2	pr6|88
001520  aa   776400 3520 04	epp2 	-768,ic		000120 = 404000000021
001521  aa  6 00132 2521 00	spri2	pr6|90
001522  aa   776375 3520 04	epp2 	-771,ic		000117 = 524000000000
001523  aa  6 00134 2521 00	spri2	pr6|92
001524  aa   776402 3520 04	epp2 	-766,ic		000126 = 404000000043
001525  aa  6 00136 2521 00	spri2	pr6|94
001526  aa  6 00112 6211 00	eax1 	pr6|74
001527  aa   024000 4310 07	fld  	10240,dl
001530  aa  6 00044 3701 20	epp4 	pr6|36,*
001531  la  4 00052 3521 20	epp2 	pr4|42,*		rcp_$detach
001532  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 385
     end;

001533  aa  6 00100 6101 00	rtcd 	pr6|64
  END PROCEDURE clean_up
  END PROCEDURE tdcm_message_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
