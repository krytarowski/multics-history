	COMPILATION LISTING OF SEGMENT asum_read_delete_ops_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 08/04/87  1329.0 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1985 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(85-06-12,Swenson), approve(86-07-25,MCR7302),
       12*     audit(86-08-13,EJSharpe), install(86-09-04,MR12.0-1147):
       13*     Fixed setting of highest_in_use counter when messages are deleted from db.
       14*  2) change(85-08-01,Swenson), approve(86-07-25,MCR7302),
       15*     audit(86-08-13,EJSharpe), install(86-09-04,MR12.0-1147):
       16*     Fixed to correctly perform access checks for unprivileged read entries.
       17*  3) change(87-05-31,GDixon), approve(87-07-07,MCR7719),
       18*     audit(87-06-24,Hartogs), install(87-08-04,MR12.1-1055):
       19*     Sort destination_am entries by message_id in admin_search, so that entries
       20*     can be read out in successive calls by message_id.
       21*  4) change(87-06-24,GDixon), approve(87-07-07,MCR7719),
       22*     audit(87-06-24,Hartogs), install(87-08-04,MR12.1-1055):
       23*     Change calling sequence of priv_delete_process_id to properly declare
       24*     the process_id as bit(36) aligned.
       25*                                                   END HISTORY COMMENTS */
       26 
       27 
       28 /* asum_read_delete_ops_.pl1 -- all entries that read and/or delete
       29*   messages. */
       30 
       31 /* format: style2 */
       32 
       33 asum_read_delete_ops_:
       34      procedure;
       35 
       36 /***** Modification history:
       37*
       38*       Created 1985-02-11, BIM
       39*       Modified 1985-04, BIM: new mseg_ calling sequence
       40*       Modified 1985-05-17, EJS: Fixed failure to unlock when no message
       41*          is found for a user.
       42**/
       43 
       44 /**** This procedure contains all the entries that have to search
       45*      the database. They are collected here to share internal procedures
       46*      that search the handle/pid associative memory. */
       47 
       48 /**** ENTRIES HERE ARE GATE TARGETS! */
       49 
       50 
  1     1 /* ***********************************************************
  1     2*   *                                                         *
  1     3*   * Copyright, (C) Honeywell Information Systems Inc., 1985 *
  1     4*   *                                                         *
  1     5*   *********************************************************** */
  1     6 /* Begin include file asum_data_.incl.pl1 */
  1     7 /* Definitions in asum_data_ (as_user_message_data_) BIM 1985-01-17 */
  1     8 /* format: style3 */
  1     9 
  1    10 declare	asum_data_$acl_entries
  1    11 			bit (36) aligned ext;	/* base acl array here */
  1    12 declare	asum_data_$db_dir	char (168) ext;
  1    13 declare	asum_data_$db_multiclass
  1    14 			bit (1) aligned ext;
  1    15 declare	asum_data_$n_acl_entries
  1    16 			fixed bin ext;
  1    17 declare	asum_data_$db_cbi	bit (36) aligned ext;	/* No need to declare the whole structure here */
  1    18 declare	asum_data_$db_dir_cbi
  1    19 			bit (36) aligned ext;	/* No need to declare the whole structure here */
  1    20 declare	asum_data_$db_dir_rb
  1    21 			(2) fixed bin (3) ext;
  1    22 declare	asum_data_$db_rb	(3) fixed bin (3) ext;
  1    23 declare	asum_data_$db_locked
  1    24 			bit (1) aligned ext;
  1    25 declare	asum_data_$process_info_ptr
  1    26 			pointer static ext;
  1    27 declare	asum_data_$system_info_ptr
  1    28 			pointer static ext;
  1    29 declare	asum_data_$entry_ring
  1    30 			fixed bin (3) static ext;
  1    31 declare	asum_data_$lock_id	bit (36) aligned ext;
  1    32 declare	asum_data_$process_id
  1    33 			bit (36) aligned ext;
  1    34 
  1    35 /* End include file asum_data_.incl.pl1 */
       51 
       52 
       53 	declare aim_check_$equal	 entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
       54 	declare aim_check_$greater_or_equal
       55 				 entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
       56 	declare asum_find_segment_	 entry (fixed binary, pointer);
       57 	declare asum_error_		 entry () options (variable);
       58 	declare match_star_name_	 entry (character (*), character (*), fixed binary (35));
       59 	declare get_group_id_	 entry () returns (char (32));
       60 	declare get_process_authorization_
       61 				 entry () returns (bit (72) aligned);
       62 	declare get_privileges_	 entry () returns (bit (36) aligned);
       63 	declare set_lock_$lock	 entry (bit (36) aligned, fixed binary, fixed binary (35));
       64 	declare set_lock_$unlock	 entry (bit (36) aligned, fixed binary (35));
       65 
       66 
       67 	declare 1 admin_read_info	 aligned like as_user_message_admin_read_info;
       68 	declare 1 read_info		 aligned like as_user_message_info;
       69 	declare 1 search		 aligned,
       70 		2 process_id	 bit (36) aligned,	/** 777777777777 for ANY */
       71 		2 ring		 fixed bin (3) aligned,
       72 						/** -1 for ANY */
       73 		2 handle		 bit (72) aligned,	/** zero for ANY */
       74 		2 message_id	 bit (72) aligned,
       75 		2 read_this_one	 bit (1) aligned,
       76 		2 read_the_next_one	 bit (1) aligned,
       77 		2 aim_privileged	 bit (1) aligned,
       78 		2 authorization	 bit (72) aligned,
       79 		2 delete		 bit (1) aligned,
       80 		2 group_id	 char (32) unaligned;
       81 
       82 	declare 1 mop		 aligned like mseg_operation;
       83 
       84 	declare g_message_id	 bit (72) aligned;
       85 	declare g_process_id	 bit (36) aligned;
       86 	declare delete_the_message	 bit (1) aligned;
       87 
       88 	declare P_area_ptr		 pointer;
       89 	declare P_admin_read_info_ptr	 pointer;
       90 	declare area_ptr		 pointer;
       91 	declare P_read_info_ptr	 pointer;
       92 	declare read_info_ptr	 pointer;
       93 	declare P_message_id	 bit (72) aligned;
       94 	declare P_process_id	 bit (36) aligned;
       95 	declare P_code		 fixed bin (35);
       96 	declare code		 fixed bin (35);
       97 
       98 	declare sys_info$ring1_privilege
       99 				 bit (36) aligned ext;
      100 	declare error_table_$notalloc	 fixed bin (35) ext static;
      101 	declare error_table_$unimplemented_version
      102 				 fixed bin (35) ext static;
      103 	declare error_table_$bad_arg	 fixed bin (35) ext static;
      104 	declare error_table_$no_message
      105 				 fixed bin (35) ext static;
      106 
      107 	dcl     addr		 builtin;
      108 	dcl     divide		 builtin;
      109 	dcl     max		 builtin;
      110 	dcl     stacq		 builtin;
      111 	dcl     unspec		 builtin;
      112 
      113 
      114 user_read_message:
      115      entry (P_area_ptr, P_read_info_ptr, P_code);
      116 
      117 	code = 0;
      118 
      119 /**** COPY PARAMETERS IN */
      120 
      121 	area_ptr = P_area_ptr;
      122 	read_info_ptr = P_read_info_ptr;
      123 	read_info = read_info_ptr -> as_user_message_info;
      124 
      125 	as_user_message_system_info_ptr = asum_data_$system_info_ptr;
      126 
      127 	if read_info.version ^= AS_USER_MESSAGE_INFO_VERSION_1
      128 	then call error_return (error_table_$unimplemented_version, USER_READ_ERROR);
      129 
      130 
      131 /****+ What search criteria do we have? 
      132*         Process_id         --- this process
      133*         Handle             --- as given (if any)
      134*         Prev_message_id    --- as given (if any)
      135*         Ring               --- as given (if any)
      136*         */
      137 
      138 /**** The structure "search" is used as an implicit parameter by 
      139*      search table to describe the search information. */
      140 
      141 	unspec (search) = ""b;
      142 	search.process_id = asum_data_$process_id;
      143 	search.group_id = get_group_id_ ();
      144 	if read_info.no_handle_given
      145 	then search.handle = ""b;
      146 	else if read_info.message_handle = ""b
      147 	then call error_return (error_table_$bad_arg, USER_READ_ERROR);
      148 	else search.handle = read_info.message_handle;
      149 	if read_info.read_message_id & read_info.read_after_message_id
      150 	then call error_return (error_table_$bad_arg, USER_READ_ERROR);
      151 	if read_info.read_message_id
      152 	then do;
      153 		search.message_id = read_info.message_id;
      154 		search.read_this_one = "1"b;
      155 	     end;
      156 	if read_info.read_after_message_id
      157 	then do;
      158 		search.message_id = read_info.message_id;
      159 		search.read_the_next_one = "1"b;
      160 	     end;
      161 	search.delete = ^read_info.dont_delete;		/* if message is to be deleted, take it out of the list NOW */
      162 	if read_info.ring_given
      163 	then search.ring = max (asum_data_$entry_ring, read_info.message_ring);
      164 	else search.ring = asum_data_$entry_ring;	/*  so that only one process can read it */
      165 	search.authorization = get_process_authorization_ ();
      166 	search.aim_privileged = ((get_privileges_ () & sys_info$ring1_privilege) ^= ""b);
      167 
      168 	call lock_database;				/* This could all be done locklessly, but that efficiency is */
      169 						/*  not neccessary for MR11 */
      170 
      171 	g_message_id = search_table ();		/* Look for a message; delete_message is also set to the index in the table */
      172 
      173 	if g_message_id = ""b
      174 	then do;
      175 		call unlock_database;
      176 		call error_return (error_table_$no_message, USER_READ_ERROR);
      177 	     end;
      178 
      179 /**** we know which message we want by ID. It has not been deleted from the mseg yet, even if it is to be. */
      180 
      181 	call read_out_message (g_message_id, code);	/* sets fields in read_info, allocates in area, deletes as needed */
      182 
      183 	if code ^= 0 & code ^= error_table_$notalloc
      184 	then call asum_error_ (code, "asum_read_delete_ops_", "Message ^.3b missing.", g_message_id);
      185 
      186 	call unlock_database;
      187 
      188 	P_code = code;
      189 	read_info_ptr -> as_user_message_info = read_info;
      190 	return;
      191 
      192 USER_READ_ERROR:
      193 	return;
      194 
      195 
      196 priv_delete_message_id:
      197      entry (P_message_id, P_code);
      198 
      199 	code = 0;
      200 	g_message_id = P_message_id;
      201 
      202 	as_user_message_system_info_ptr = asum_data_$system_info_ptr;
      203 
      204 	call lock_database;
      205 
      206 	call delete$$message_id (code);
      207 
      208 	call unlock_database;
      209 
      210 	P_code = code;
      211 	return;
      212 
      213 
      214 priv_delete_process_id:
      215      entry (P_process_id, P_code);
      216 
      217 	code = 0;
      218 	g_process_id = P_process_id;
      219 
      220 	as_user_message_system_info_ptr = asum_data_$system_info_ptr;
      221 
      222 	call lock_database;
      223 
      224 	call delete$$process_id (code);
      225 
      226 	call unlock_database;
      227 
      228 
      229 	code = P_code;
      230 	return;
      231 
      232 
      233 admin_read:
      234      entry (P_admin_read_info_ptr, P_read_info_ptr, P_area_ptr, P_code);
      235 
      236 	code = 0;
      237 	as_user_message_admin_read_info_ptr = P_admin_read_info_ptr;
      238 	as_user_message_info_ptr = P_read_info_ptr;
      239 	area_ptr = P_area_ptr;
      240 
      241 	admin_read_info = as_user_message_admin_read_info;
      242 	read_info = as_user_message_info;
      243 	as_user_message_system_info_ptr = asum_data_$system_info_ptr;
      244 
      245 	if admin_read_info.version ^= AS_USER_MESSAGE_ADMIN_READ_INFO_VERSION_1
      246 	     | read_info.version ^= AS_USER_MESSAGE_INFO_VERSION_1
      247 	then do;
      248 		P_code = error_table_$unimplemented_version;
      249 		return;
      250 	     end;
      251 
      252 	call lock_database;
      253 	call admin_search;
      254 	call unlock_database;
      255 	P_code = code;
      256 	as_user_message_info = read_info;
      257 	return;
      258 
      259 
      260 
      261 
      262 
      263 
      264 
      265 
      266 
      267 
      268 
      269 
      270 
      271 
      272 
      273 
      274 delete$$message_id:
      275      procedure (code);
      276 
      277 	declare code		 fixed bin (35);
      278 	declare delete_by		 fixed bin (1);
      279 	declare (
      280 	        MID		 init (0),
      281 	        PID		 init (1)
      282 	        )			 fixed bin int static options (constant);
      283 	declare 1 am		 aligned like as_user_message_system_info.destination_am based (amep);
      284 	declare amep		 pointer;
      285 	declare hx		 fixed bin;
      286 
      287 	delete_by = MID;
      288 	go to COMMON;
      289 
      290 delete$$process_id:
      291      entry (code);
      292 
      293 	delete_by = PID;
      294 
      295 COMMON:
      296 	code = error_table_$no_message;
      297 	do hx = 1 to as_user_message_system_info.highest_in_use;
      298 	     amep = addr (as_user_message_system_info.destination_am (hx));
      299 	     if am.process_id = ""b
      300 	     then ;
      301 	     else if delete_by = PID
      302 	     then do;
      303 		     if am.process_id = g_process_id
      304 		     then do;
      305 			     call delete_mseg_msg (am.message_id);
      306 			     call delete_am_entry (hx);
      307 			     code = 0;		/* got one */
      308 			end;
      309 		end;
      310 	     else if delete_by = MID
      311 	     then do;
      312 		     if am.message_id = g_message_id
      313 		     then do;
      314 			     call delete_mseg_msg (am.message_id);
      315 			     call delete_am_entry (hx);
      316 			     code = 0;		/* got one */
      317 			     return;		/* only one per */
      318 			end;
      319 		end;
      320 	end;
      321 	return;					/* no_message */
      322      end delete$$message_id;
      323 
      324 search_table:
      325      procedure returns (bit (72) aligned);
      326 
      327 /**** This procedure searches for destination matches, looking for the
      328*      oldest message that matches. Since this implementation keeps the
      329*      table locked for the duration, this can assume that nothing will
      330*      change. */
      331 
      332 	declare youngest_message_id	 bit (72) aligned;
      333 	declare amep		 pointer;
      334 	declare 1 am		 aligned like as_user_message_system_info.destination_am based (amep);
      335 	declare am_real_message_id	 bit (72) aligned;
      336 	declare search_real_message_id bit (72) aligned;
      337 	declare x			 fixed bin;
      338 	declare message_x		 fixed bin;
      339 
      340 	youngest_message_id = (72)"1"b;
      341 
      342 	delete_the_message = "0"b;
      343 
      344 	unspec (as_user_message_id) = search.message_id;
      345 	as_user_message_id.segment_index = 0;
      346 	search_real_message_id = unspec (as_user_message_id);
      347 
      348 	do x = 1 to as_user_message_system_info.highest_in_use;
      349 	     amep = addr (as_user_message_system_info.destination_am (x));
      350 	     if am.process_id = ""b
      351 	     then go to TRY_NEXT;
      352 
      353 	     if (am.process_id ^= (36)"1"b) & (search.process_id ^= am.process_id)
      354 	     then go to TRY_NEXT;
      355 	     if (am.process_id = (36)"1"b) & ^group_match (am.group_id, search.group_id)
      356 	     then go to TRY_NEXT;
      357 	     if (search.ring >= 0) & (search.ring ^= am.ring)
      358 	     then go to TRY_NEXT;
      359 	     if (search.handle ^= ""b) & (search.handle ^= am.handle)
      360 	     then go to TRY_NEXT;
      361 
      362 	     if ^check_aim ()
      363 	     then goto TRY_NEXT;
      364 
      365 	     else if search.read_this_one
      366 	     then /* No other matching required */
      367 		if am.message_id = search.message_id
      368 		then return (SET_RETURN_INFO_AND_MAYBE_DELETE (x));
      369 		else ;
      370 	     else do;
      371 		     unspec (as_user_message_id) = am.message_id;
      372 		     as_user_message_id.segment_index = 0;
      373 		     am_real_message_id = unspec (as_user_message_id);
      374 
      375 		     if (search.read_the_next_one & am_real_message_id > search_real_message_id)
      376 			| ^search.read_the_next_one
      377 		     then if am_real_message_id < youngest_message_id
      378 			then do;
      379 				youngest_message_id = am_real_message_id;
      380 				message_x = x;
      381 			     end;
      382 		end;
      383 TRY_NEXT:
      384 	end;
      385 
      386 	if youngest_message_id = (72)"1"b
      387 	then return (""b);
      388 	else return (SET_RETURN_INFO_AND_MAYBE_DELETE (message_x));
      389 
      390 check_aim:
      391      procedure returns (bit (1) aligned);
      392 
      393 	if search.aim_privileged
      394 	then return ("1"b);
      395 	if aim_check_$greater_or_equal (search.authorization, am.access_class)
      396 	then return ("1"b);				/* Deletion AIM later on */
      397 	return ("0"b);
      398      end check_aim;
      399 
      400 SET_RETURN_INFO_AND_MAYBE_DELETE:
      401      procedure (P_message_index) returns (bit (72) aligned);
      402 
      403 	dcl     P_message_index	 fixed bin parameter;
      404 	dcl     message_id		 bit (72) aligned automatic;
      405 
      406 	amep = addr (as_user_message_system_info.destination_am (P_message_index));
      407 	read_info.destination_info.group_id = am.group_id;
      408 	read_info.destination_info.process_id = am.process_id;
      409 	read_info.destination_info.ring = am.ring;
      410 	read_info.message_info.message_handle = am.handle;
      411 	message_id = am.message_id;
      412 
      413 	if am.reader_deletes & search.delete
      414 	then do;
      415 		if search.aim_privileged | aim_check_$equal (search.authorization, am.access_class)
      416 		then do;
      417 			call delete_am_entry (P_message_index);
      418 			delete_the_message = "1"b;
      419 		     end;
      420 	     end;
      421 	return (message_id);
      422 
      423      end SET_RETURN_INFO_AND_MAYBE_DELETE;
      424 
      425      end search_table;
      426 
      427 group_match:
      428      procedure (star, try) returns (bit (1) aligned);
      429 
      430 	declare (star, try)		 char (32);
      431 	declare code		 fixed bin (35);
      432 
      433 	if star = ""
      434 	then return ("1"b);
      435 	call match_star_name_ (try, star, code);
      436 	return (code = 0);
      437      end group_match;
      438 
      439 read_out_message:
      440      procedure (a_mid, code);
      441 	declare a_mid		 bit (72) aligned;
      442 	declare code		 fixed bin (35);
      443 	declare fx		 fixed bin;
      444 	declare mseg_ptr		 pointer;
      445 
      446 	unspec (as_user_message_id) = a_mid;
      447 	fx = as_user_message_id.segment_index;
      448 	as_user_message_id.segment_index = 0;
      449 	mop = addr (mseg_data_$template_operation) -> mseg_operation;
      450 	mop.message_info.message_code = MSEG_READ_SPECIFIED;
      451 	mop.message_info.control_flags = ""b;
      452 	mop.message_info.delete = delete_the_message;
      453 	mop.message_info.ms_id = unspec (as_user_message_id);
      454 	mop.suppress_access_checks = "1"b;
      455 	mop.message_info_valid = "1"b;
      456 	call asum_find_segment_ (fx, mseg_ptr);
      457 	mop.mseg_ptr = mseg_ptr;
      458 	mop.mseg_ptr_valid = "1"b;
      459 	call mseg_$read_message (addr (mop), area_ptr, code);
      460 	read_info.message_ptr = mop.message_info.ms_ptr;
      461 	read_info.message_length = divide (mop.message_info.ms_len, 36, 18, 0);
      462 	read_info.message_id = mop.message_info.ms_id;
      463 	read_info.message_info.message_access_class = mop.message_info.ms_access_class;
      464 	read_info.message_info.message_ring = mop.message_info.sender_level;
      465 						/* messages don't have rings */
      466 	read_info.sender_info.group_id = mop.message_info.sender_id;
      467 	read_info.sender_info.process_id = mop.message_info.sender_process_id;
      468 	return;
      469 
      470      end read_out_message;
      471 
      472 delete_mseg_msg:
      473      procedure (a_mid);
      474 
      475 	declare a_mid		 bit (72) aligned;
      476 	declare code		 fixed bin (35);
      477 	declare fx		 fixed bin;
      478 	declare mseg_ptr		 pointer;
      479 
      480 	unspec (as_user_message_id) = a_mid;
      481 	fx = as_user_message_id.segment_index;
      482 	as_user_message_id.segment_index = 0;
      483 	call asum_find_segment_ (fx, mseg_ptr);
      484 	mop = addr (mseg_data_$template_operation) -> mseg_operation;
      485 	mop.message_info.ms_id = unspec (as_user_message_id);
      486 	mop.message_info_valid = "1"b;
      487 	mop.suppress_access_checks = "1"b;
      488 	call asum_find_segment_ (fx, mseg_ptr);
      489 	mop.mseg_ptr = mseg_ptr;
      490 	mop.mseg_ptr_valid = "1"b;
      491 
      492 	call mseg_$delete_message (addr (mop), code);
      493 	if code ^= 0
      494 	then call asum_error_ (code, "asum_read_delete_ops_", "Failed to delete message ^.3b from message segment ^d.",
      495 		a_mid, fx);
      496 	return;
      497      end delete_mseg_msg;
      498 
      499 error_return:
      500      procedure (code, return_label);
      501 	declare code		 fixed bin (35);
      502 	declare return_label	 label;
      503 
      504 	P_code = code;
      505 	go to return_label;
      506      end error_return;
      507 
      508 
      509 admin_search:
      510      procedure;
      511 
      512 /**** DUMB program to search against the admin_search data structure */
      513 
      514 	declare 1 am		 aligned based (amep)
      515 				 like as_user_message_system_info.destination_am;
      516 	declare amep		 pointer;
      517 	declare hx		 fixed bin;
      518 	declare mid_mask		 bit (72) aligned init ("000777777777777777777777"b3) int static
      519 				 options (constant);
      520 	declare 1 min_am		 aligned based (min_amep)
      521 				 like as_user_message_system_info.destination_am;
      522     	declare min_amep		 pointer;
      523           declare minx		 fixed bin;
      524 	declare 1 temp_am		 aligned like as_user_message_system_info.destination_am automatic;
      525 
      526 	if as_user_message_system_info.highest_in_use = 0 then
      527 	code = error_table_$no_message;
      528 
      529 /**** This algorithm depends upon the destination_am being sorted in message_id
      530*      order, so we can step through from one id to the next in successive
      531*      admin_read calls. */
      532 
      533 	do minx = 1 to as_user_message_system_info.highest_in_use-1;
      534 	     min_amep = addr (as_user_message_system_info.destination_am (minx));
      535 	     do hx = minx to as_user_message_system_info.highest_in_use;
      536 		amep = addr (as_user_message_system_info.destination_am (hx));
      537 		if min_am.message_id > am.message_id then do;
      538 		     temp_am = am;
      539 		     am = min_am;
      540 		     min_am = temp_am;
      541 		end;
      542 	     end;
      543 	end;
      544 
      545 	search.authorization = get_process_authorization_ ();
      546 	search.aim_privileged = ((get_privileges_ () & sys_info$ring1_privilege) ^= ""b);
      547 
      548 	do hx = 1 to as_user_message_system_info.highest_in_use;
      549 	     amep = addr (as_user_message_system_info.destination_am (hx));
      550 	     if am.process_id = ""b
      551 	     then go to TRY_NEXT;
      552 	     if admin_read_info.after_message_id ^= ""b
      553 	     then if (am.message_id & mid_mask) <= (admin_read_info.after_message_id & mid_mask)
      554 		then go to TRY_NEXT;
      555 	     if admin_read_info.target_handle ^= ""b
      556 	     then if am.handle ^= admin_read_info.target_handle
      557 		then go to TRY_NEXT;
      558 	     if admin_read_info.target_process_id ^= ""b
      559 	     then if am.process_id ^= admin_read_info.target_process_id
      560 		then go to TRY_NEXT;
      561 	     if admin_read_info.target_group_id ^= ""
      562 	     then if ^group_match (admin_read_info.target_group_id, am.group_id)
      563 		then go to TRY_NEXT;
      564 
      565 	     if ^search.aim_privileged
      566 	     then if ^aim_check_$greater_or_equal (search.authorization, am.access_class)
      567 		then go to TRY_NEXT;
      568 
      569 /**** Well, the target spec matches. If there is a source spec, we have to
      570*      read the message out to see who sent it. Pain, as they say, in the ass.
      571**/
      572 
      573 	     delete_the_message = "0"b;
      574 	     call read_out_message (am.message_id, code);
      575 	     if code ^= 0 & code ^= error_table_$notalloc
      576 	     then call asum_error_ (code, "asum_read_delete_ops_", "Failed to read out message ^.3b", am.message_id);
      577 	     if code ^= 0
      578 	     then return;				/* Caller area too small */
      579 
      580 	     if (admin_read_info.source_group_id ^= ""
      581 		& ^group_match (admin_read_info.source_group_id, mop.message_info.sender_id))
      582 		| (admin_read_info.source_process_id ^= ""b
      583 		& admin_read_info.source_process_id ^= mop.message_info.sender_process_id)
      584 	     then begin;
      585 		     declare to_free	      bit (mop.message_info.ms_len) based (mop.message_info.ms_ptr);
      586 		     free to_free;
      587 		     go to TRY_NEXT;
      588 		end;
      589 
      590 	     read_info.destination_info.group_id = am.group_id;
      591 	     read_info.destination_info.process_id = am.process_id;
      592 	     read_info.destination_info.ring = am.ring;
      593 	     read_info.sender_info.group_id = mop.message_info.sender_id;
      594 	     read_info.sender_info.process_id = mop.message_info.sender_process_id;
      595 	     read_info.message_handle = am.handle;
      596 	     read_info.dont_delete = ^am.reader_deletes;
      597 	     return;
      598 TRY_NEXT:
      599 	end;
      600 	code = error_table_$no_message;
      601 	return;
      602      end admin_search;
      603 
      604 delete_am_entry:
      605      procedure (amx);
      606 
      607 	declare amx		 fixed bin;
      608 	declare hx		 fixed bin;
      609 
      610 	declare q			 bit (1) aligned;
      611 
      612 	q = stacq (as_user_message_system_info.destination_am (amx).process_id, ""b,
      613 	     (as_user_message_system_info.destination_am (amx).process_id));
      614 	if amx = as_user_message_system_info.highest_in_use
      615 	then do;
      616 		do hx = amx to 1 by -1 while (as_user_message_system_info.destination_am (hx).process_id = ""b);
      617 		end;				/* hx is 0 or index of last in use */
      618 		as_user_message_system_info.highest_in_use = hx;
      619 	     end;
      620 	return;
      621      end delete_am_entry;
      622 
      623 lock_database:
      624      procedure;
      625 
      626 	if ^stacq (as_user_message_system_info.lock, asum_data_$lock_id, ""b)
      627 	then call set_lock_$lock (as_user_message_system_info.lock, -1, (0));
      628 	asum_data_$db_locked = "1"b;
      629 	return;
      630      end lock_database;
      631 
      632 unlock_database:
      633      procedure;
      634 
      635 	if ^stacq (as_user_message_system_info.lock, ""b, asum_data_$lock_id)
      636 	then call set_lock_$unlock (as_user_message_system_info.lock, (0));
      637 	asum_data_$db_locked = "0"b;
      638 	return;
      639      end unlock_database;
      640 
      641 /* format: off */
      642  /* Begin include file as_user_message_system.incl.pl1 BIM 1985-01-11 */
  2     2 /* format: style4 */
  2     3 
  2     4 /**** Per-system and per-user information on the as_user_message segments */
  2     5 
  2     6 /**** Declaration used to construct the name of one of the set of segments */
  2     7 
  2     8 declare  1 as_user_message_segment_name unaligned,
  2     9 	 2 constant char (16),			/* as_user_message_ */
  2    10 	 2 index picture "99";
  2    11 
  2    12 declare  AS_USER_MESSAGE_SEGMENT_NAME_CONSTANT char (16) init ("as_user_message_") int static options (constant);
  2    13 
  2    14 /**** as_user_messages (mis)-use the pad bits in a message segment
  2    15*      message ID to identify which of one of a series of segments
  2    16*      to find the message in. */
  2    17 
  2    18 declare  1 as_user_message_id aligned,			/* use UNSPEC, not based (addr) */
  2    19 	 2 segment_index fixed bin (9) unsigned unaligned,
  2    20 	 2 pad bit (11) unaligned,
  2    21 	 2 pad_clock bit (52) unaligned;
  2    22 
  2    23 /**** Data stored in the as_user_message_system segment.
  2    24*      This is the shared overhead database, including the
  2    25*      associative memory of messages and destination processes. */
  2    26 
  2    27 declare  AS_USER_MESSAGE_SYSTEM_NAME char (32) init ("as_user_message_system") int static options (constant);
  2    28 
  2    29 declare  as_user_message_system_info_ptr pointer;
  2    30 declare  1 as_user_message_system_info aligned based (as_user_message_system_info_ptr),
  2    31 	 2 header aligned,
  2    32 	   3 sentinel char (8) aligned,		/* Version, but mostly validity check */
  2    33 	   3 time_of_bootload fixed bin (71),		/* was this segment initialized in this bootload? */
  2    34 	   3 lock bit (36) aligned,			/* on segment creation/deletion */
  2    35 	   3 n_segments fixed bin,			/* total created */
  2    36 
  2    37 	   3 highest_in_use fixed bin (35),		/* update with stacq */
  2    38 	 2 pad (9) bit (36) aligned,
  2    39 	 2 destination_am (16000) aligned, /* each entry is 16 words. Listen UP, compiler */
  2    40 	   3 process_id bit (36) aligned,
  2    41 	   3 ring fixed bin (3) unsigned unaligned,
  2    42 	   3 reader_deletes bit (1) unaligned,
  2    43 	   3 pad bit (32) unaligned,
  2    44 	   3 handle bit (72) aligned,
  2    45 	   3 message_id bit (72) aligned,
  2    46 	   3 group_id char (32) unaligned,
  2    47 	   3 access_class bit (72) aligned;
  2    48 
  2    49 declare  AS_USER_ANY_PROCESS_ID bit (36) aligned init ("777777777777"b3) int static options (constant);
  2    50 
  2    51 
  2    52 /**** + To look for a message, do the following:
  2    53*      initialize the message_id to 72 1's.
  2    54*      loop on the process_id_list, setting px as index;
  2    55*      if the process_id (px) is ANY_PROCESS_ID or the target process id then do;
  2    56*      if handle_list (px) is the desired handle then do;
  2    57*      if the process_id match was exact then
  2    58*      message_id = min (message_id, message_id (px));
  2    59*      otherwise do;
  2    60*      read out the mesage for message_id (px),
  2    61*      determine if it is really for target_process. If so,
  2    62*      message_id = min (message_id, message_id (px));
  2    63*      end;
  2    64*      end;
  2    65*      end;
  2    66*
  2    67*      If message_id = 72 1's, then there is no message destined for this handle
  2    68*      for this process.
  2    69*
  2    70*      Otherwise, message_id is the id of the first message for this handle.
  2    71**/
  2    72 
  2    73 declare  AS_USER_MESSAGE_SYSTEM_SENTINEL char (8) aligned init ("asumsys1") int static options (constant);
  2    74 
  2    75 /**** Data for each user process */
  2    76 
  2    77 /**** *system variable to find this stuff with */
  2    78 
  2    79 declare  as_user_message_perprocess_info_ptr pointer;
  2    80 
  2    81 declare  1 as_user_message_perprocess_info aligned based (as_user_message_perprocess_info_ptr),
  2    82 	 2 sentinel char (8) aligned,
  2    83 	 2 mseg_ptr (0:99) pointer options (packed);	/* for mseg_ */
  2    84 
  2    85 declare  AS_USER_MESSAGE_PROCESS_SENTINEL char (8) aligned init ("asumprc1") int static options (constant);
  2    86 
  2    87 /* End include file as_user_message_system.incl.pl1 */
      642 
      643  /* BEGIN INCLUDE FILE . . . mseg_message_info.incl.pl1 BIM 1984-10-10 */
  3     2 /* format: style3,idind30 */
  3     3 
  3     4 /* structure returned when message is read from a message segment */
  3     5 
  3     6 
  3     7 dcl	mseg_message_info_ptr	pointer;
  3     8 
  3     9 dcl	1 mseg_message_info		based (mseg_message_info_ptr) aligned,
  3    10 	  2 version		char (8) aligned,
  3    11 	  2 message_code		fixed bin,
  3    12 	  2 control_flags		unaligned,
  3    13 	    3 own			bit (1),
  3    14 	    3 delete		bit (1),
  3    15 	    3 pad			bit (34),
  3    16 	  2 ms_ptr		ptr,		/* pointer to message */
  3    17 	  2 ms_len		fixed bin (24),	/* length of message  in bits */
  3    18 	  2 ms_id			bit (72),		/* unique ID of message */
  3    19 						/* input in some cases */
  3    20 	  2 ms_access_class		bit (72),		/* message access class */
  3    21 	  2 sender_id		char (32) unaligned,/* process-group ID of sender */
  3    22 	  2 sender_process_id	bit (36) aligned,	/* if nonzero, process that sent */
  3    23 	  2 sender_level		fixed bin,	/* validation level of sender */
  3    24 	  2 sender_authorization	bit (72),		/* access authorization of message sender */
  3    25 	  2 sender_max_authorization	bit (72),		/* max authorization of sending process */
  3    26 	  2 sender_audit		bit (36) aligned;   /* audit flags */
  3    27 
  3    28 declare	MSEG_MESSAGE_INFO_V1	char (8) aligned init ("msegmi01") int static options (constant);
  3    29 
  3    30 declare	(
  3    31 	MSEG_READ_FIRST		init (1),
  3    32 	MSEG_READ_LAST		init (2),
  3    33 	MSEG_READ_SPECIFIED		init (3),
  3    34 	MSEG_READ_BEFORE_SPECIFIED	init (4),
  3    35 	MSEG_READ_AFTER_SPECIFIED	init (5))
  3    36 	fixed bin int static options (constant);
  3    37 
  3    38 declare  (MSEG_READ_OWN		init ("1"b),
  3    39 	MSEG_READ_DELETE		init ("01"b)
  3    40 	)			bit (36) aligned internal static options (constant);
  3    41 
  3    42 /* END INCLUDE FILE . . . mseg_message_info.incl.pl1 */
      643 
      644  /* Begin include file as_user_message_info.incl.pl1 BIM 1985-01-11 */
  4     2 /* format: style4 */
  4     3 
  4     4 /**** This structure is passed in by a user process to read out
  4     5*      an A.S. user message. */
  4     6 
  4     7 declare  as_user_message_info_ptr pointer;
  4     8 declare  1 as_user_message_info aligned based (as_user_message_info_ptr),
  4     9 	 2 version char (8) aligned,
  4    10 	 2 flags aligned,
  4    11 	   3 read_message_id bit (1) unaligned,		/* message_id specified -- read that one */
  4    12 	   3 read_after_message_id bit (1) unaligned,	/* message_id specified -- read the next one for the handle after that */
  4    13 	   3 no_handle_given bit (1) unaligned,		/* application debugging: look at all messages for us, regardless of handle */
  4    14 	   3 ring_given bit (1) unaligned,		/* application debugging: look at outer ring messages */
  4    15 	   3 dont_delete bit (1) unaligned,		/* application debugging, look at message but don't delete them */
  4    16 	   3 pad bit (31) unaligned,
  4    17 	 2 message_info aligned,			/* Output arguments */
  4    18 	   3 message_ptr pointer,
  4    19 	   3 message_length fixed bin (18),		/* words */
  4    20 	   3 pad bit (36) aligned,
  4    21 	   3 message_id bit (72) aligned,
  4    22 	   3 message_access_class bit (72) aligned,
  4    23 	   3 message_handle bit (72) aligned,	
  4    24 	   3 message_ring fixed bin (3),	
  4    25            2 sender_info aligned,
  4    26 	   3 group_id char (32) unaligned,	
  4    27 	   3 process_id bit (36) aligned,
  4    28            2 destination_info aligned,
  4    29 	   3 group_id char (32) unal,
  4    30 	   3 process_id bit (36) aligned,
  4    31 	   3 ring fixed bin (3) aligned;	   
  4    32 
  4    33 declare  AS_USER_MESSAGE_INFO_VERSION_1 char (8) aligned init ("asum0001") int static options (constant);
  4    34 
  4    35 /* End include file as_user_message_info.incl.pl1 */
      644 
      645  /* Begin include file as_user_message_aread.incl.pl1 BIM 1985-01-12 */
  5     2 /* format: style4 */
  5     3 
  5     4 declare as_user_message_admin_read_info_ptr pointer;
  5     5 declare 1 as_user_message_admin_read_info aligned 
  5     6           based (as_user_message_admin_read_info_ptr),
  5     7           2 version char (8) aligned,
  5     8 	2 source_group_id char (32) unal,
  5     9 	2 source_process_id bit (36) aligned,
  5    10 	2 target_group_id char (32) unal,
  5    11 	2 target_process_id bit (36) aligned,
  5    12 	2 target_handle bit (72) aligned,
  5    13 	2 after_message_id bit (72) aligned;
  5    14 
  5    15 declare AS_USER_MESSAGE_ADMIN_READ_INFO_VERSION_1
  5    16         char (8) init ("aumar001") int static options (constant);
  5    17 
  5    18 /* End include file as_user_message_aread.incl.pl1 */
      645 
      646  /* BEGIN INCLUDE FILE ... mseg_operation.incl.pl1 */
  6     2 
  6     3 /* format: style3,idind30,linecom */
  6     4 
  6     5 /**** Created 1985-04-16, BIM: from Pandolf's  mseg_access_operation */
  6     6 
  6     7 /**** NOTES:
  6     8*      The caller of mseg_ must set mseg_operation.access_operation to record
  6     9*      the type of access checking it has performed and which mseg_ should
  6    10*      perform when needed (i.e., for those entrypoints which operate on
  6    11*      messages like mseg_$read_message).
  6    12*
  6    13*      mseg_operation.operation is reserved explicitly for use by mseg_ and
  6    14*      its underlying modules.
  6    15*
  6    16*      You must also include entry_access_info, mseg_message_info, and
  6    17*      mbx_wakeup_state along with this include file. */
  6    18 
  6    19 dcl	mseg_operation_ptr		pointer;
  6    20 dcl	MSEG_OPERATION_VERSION_1	fixed bin internal static options (constant) init (1);
  6    21 dcl	MSEG_TYPE_MBX		fixed bin init (1) internal static options (constant);
  6    22 dcl	MSEG_TYPE_MS		fixed bin init (2) internal static options (constant);
  6    23 
  6    24 dcl	1 mseg_operation		based (mseg_operation_ptr) aligned,
  6    25 	  2 version		fixed binary,	/* current version is MSEG_OPERATION_VERSION_1 */
  6    26 	  2 type			fixed binary,	/* MBX or MS */
  6    27 	  2 access_operation	fixed binary,	/* type of access checks required for the operation */
  6    28 	  2 operation		bit (36) aligned,	/* for use by mseg_ and underlying modules */
  6    29 	  2 caller		aligned,		/* always collected in gate target */
  6    30 	    3 validation_level	fixed bin (3),
  6    31 	    3 privileges		bit (18) aligned,	/* factored for speed */
  6    32 	    3 pad_align_double	fixed bin (71),	/* just to force alignment */
  6    33 	    3 authorization		bit (72) aligned,	/* must be 2word aligned */
  6    34 	    3 max_authorization	bit (72) aligned,
  6    35 	    3 group_id		char (32) unaligned,
  6    36 	  2 flags			aligned,
  6    37 	    3 mseg_pathname_valid	bit (1) unaligned,
  6    38 	    3 mseg_ptr_valid	bit (1) unaligned,
  6    39 	    3 mseg_index_valid	bit (1) unaligned,
  6    40 	    3 access_info_valid	bit (1) unaligned,
  6    41 	    3 md_ptr_valid		bit (1) unaligned,
  6    42 	    3 message_info_valid	bit (1) unaligned,	/* note -- for some operations not all fields are used */
  6    43 	    3 wakeup_state_valid	bit (1) unaligned,
  6    44 	    3 suppress_access_checks	bit (1) unaligned,	/* set by privileged interfaces, suppresses ALL access checking */
  6    45 	    3 call_admin_gate	bit (1) unaligned,	/* we is in ring 1, boss */
  6    46 	    3 only_own_access	bit (1) unaligned,	/* the user had o rather than r/d */
  6    47 	    3 add_message_info_all_valid
  6    48 				bit (1) unaligned,	/* Believe ALL the fields in message info on an add */
  6    49 	    3 pad			bit (24) unaligned,
  6    50 	  2 dir_name		char (168) unaligned,
  6    51 	  2 entryname		char (32) unaligned,
  6    52 	  2 mseg_ptr		pointer,
  6    53 	  2 md_ptr		pointer,		/* message descriptor */
  6    54 	  2 mseg_index		fixed bin,
  6    55 	  2 access_info		aligned like entry_access_info,
  6    56 	  2 message_info		aligned like mseg_message_info,
  6    57 	  2 wakeup_state		aligned like mseg_wakeup_state;
  6    58 
  6    59 /* END INCLUDE FILE ... mseg_operation.incl.pl1 */
      646 
      647  /* Begin include file mseg_access_operation.incl.pl1 BIM 1098-04-18 */
  7     2 /* format: style3,idind30 */
  7     3 
  7     4 declare	mseg_access_operation_ptr	pointer;
  7     5 declare	1 mseg_access_operation	aligned based (mseg_access_operation_ptr),
  7     6 	  2 access_operation	bit (36) aligned,
  7     7 	  2 required_modes		bit (36) aligned,	/* ""b if no modes required */
  7     8 	  2 flags			unaligned,
  7     9 	    3 dont_audit		bit (1) unaligned,
  7    10 	    3 dont_audit_success	bit (1) unaligned,
  7    11 	    3 non_null_modes	bit (1) unaligned,
  7    12 	    3 no_modes		bit (1) unaligned,
  7    13 	    3 o_for_r		bit (1) unaligned,	/* if no r, o will do */
  7    14 	    3 o_for_d		bit (1) unaligned,	/* if no d, o will do */
  7    15 	    3 admin		bit (1) unaligned,
  7    16 	    3 dir_modes		bit (1) unaligned, /* dir mode is needed */
  7    17 	    3 dir_modes_or_ex_modes   bit (1) unaligned, /* if not ex-mode, dir mode */
  7    18 	    3 pad			bit (9) unaligned,
  7    19             2 required_dir_modes        bit (3) unaligned,
  7    20 	  2 pad1			bit (6) unaligned,
  7    21 	  2 mseg_access_op_index	fixed bin (9) uns unaligned,
  7    22 	  2 pad2			bit (36) aligned;
  7    23 
  7    24 declare	(
  7    25 	MSEG_READ_SEG_ATTR		init (1),		/* any attribute */
  7    26 	MSEG_MODIFY_SEG_ATTR	init (2),		/* any attribute, access or no */
  7    27 	MSEG_COPY_SEG		init (3),		/* reference a segment for copying */
  7    28 	MSEG_CREATE_SEG		init (4),		/* check on candidate parent dir */
  7    29 	MSEG_ADD_MESSAGE		init (5),		/* append */
  7    30 	MSEG_MODIFY_MESSAGE		init (6),		/* update/delete */
  7    31 	MSEG_ACCEPT_WAKEUPS		init (7),		/* what the sign says */
  7    32 	MSEG_READ_MESSAGE		init (8)		/* ditto */
  7    33 	)			fixed bin (9) int static options (constant);
  7    34 
  7    35 dcl	1 mseg_access_operations_$data
  7    36 				(25) external static aligned like mseg_access_operation;
  7    37 
  7    38 /* End include file mseg_access_operation.incl.pl1 */
      647 
      648  /* BEGIN INCLUDE FILE ... mseg_wakeup_state.incl.pl1 */
  8     2 /* Created:  April 1985 by G. Palter */
  8     3 
  8     4 /* format: style3,linecom */
  8     5 
  8     6 /* Description of the wakeup state of a message segment --
  8     7*
  8     8*   The wakeup state defines which process, if any, is willing to receive normal or urgent IPC wakeups when a message which
  8     9*   requests such a wakeup is added to a message segment.  The process is allowed to separately accept or defer normal and
  8    10*   urgent wakeups.  Note that deferring a wakeup is not the same as not accepting wakeups.  A process is not allowed to
  8    11*   stop accepting wakeups once it has accepted them as to do so would introduce a relatively high badnwidth covert
  8    12*   channel.  (In the present implementation, urgent wakeups are really no different from normal wakeups.  Eventually,
  8    13*   urgent wakeups should be implemented using an IPS signal along with the IPC wakeup).
  8    14*
  8    15*   mseg_$get_wakeup_state_seg requires that the caller supply the proper value for mseg_wakeup_state.version in the
  8    16*   mseg_operation.  If there is no wakeup state recorded in the message segment, mseg_$get_wakeup_state_seg will return
  8    17*   the status code error_table_$messages_off.
  8    18*
  8    19*   mseg_$set_wakeup_state_seg ignores the values of the access_class, process_id, and lock_id elements supplied by the
  8    20*   caller in the mseg_operation.  mseg_$set_wakeup_state_seg will, instead, furnish the values of the process making the
  8    21*   call for these elements and will return these values to its caller.  In other words, mseg_$set_wakeup_state_seg can not
  8    22*   be used by one process to accept/defer wakeups on behalf of another process. */
  8    23 
  8    24 declare	1 mseg_wakeup_state aligned based (mseg_wakeup_state_ptr),
  8    25 	  2 version	character (8) unaligned,
  8    26 	  2 flags		aligned,
  8    27 	    3 accepting_normal_wakeups		/* ON => process has accepted normal wakeups */
  8    28 			bit (1) unaligned,		/* OFF => process has deferred normal wakeups */
  8    29 	    3 accepting_urgent_wakeups		/* ON => process has accepted urgent wakeups */
  8    30 			bit (1) unaligned,		/* OFF => process has deferred urgent wakeups */
  8    31 	    3 pad		bit (34) unaligned,
  8    32 	  2 pad		bit (36) aligned,
  8    33 	  2 event_channel	fixed binary (71),		/* IPC event channel on which to send normal/urgent wakeups */
  8    34 	  2 access_class	bit (72) aligned,		/* AIM access class of the process accepting wakeups */
  8    35 	  2 process_id	bit (36) aligned,		/* ID of the process accepting wakeups */
  8    36 	  2 lock_id	bit (36) aligned;		/* lock ID used to test if said process is still alive */
  8    37 
  8    38 declare	mseg_wakeup_state_ptr
  8    39 			pointer;
  8    40 
  8    41 declare	MSEG_WAKEUP_STATE_VERSION_1
  8    42 			character (8) static options (constant) initial ("msegwkp1");
  8    43 
  8    44 /* END INCLUDE FILE ... mseg_wakeup_state.incl.pl1 */
      648 
      649  /* BEGIN INCLUDE FILE ... entry_access_info.incl.pl1 */
  9     2 
  9     3 /*
  9     4*   Written  03/22/85 by M. Pandolf
  9     5*   Modified 1985-04-19, BIM: added parent access class.
  9     6**/
  9     7 
  9     8 dcl  entry_access_info_ptr pointer;
  9     9 dcl  ENTRY_ACCESS_INFO_VERSION_1 char (8) internal static options (constant)
  9    10      init ("eainf001");
  9    11 
  9    12 dcl 1 entry_access_info aligned based (entry_access_info_ptr),
  9    13     2 version char (8),				/* = ENTRY_ACCESS_INFO_VERSION_1 */
  9    14     2 type fixed bin,				/* see status_structures.incl.pl1 */
  9    15     2 dir_name char (168) unaligned,			/* parent of this entry */
  9    16     2 entryname char (32) unaligned,			/* primary name of this entry */
  9    17     2 uid bit (36) aligned,				
  9    18     2 ring_brackets (3) fixed bin (3),			/* for dirs, the dir ring brackets are here */
  9    19     2 extended_ring_brackets (3) fixed bin (3),		/* not-yet-implemented x-rb's */
  9    20     2 effective_access_modes bit (36) aligned,		/* for dirs, dir mode is here */
  9    21     2 extended_access_modes bit (36) aligned,		/* always null for dirs */
  9    22     2 access_class bit (72) aligned,			/* for multiclass, max access class */
  9    23     2 parent_access_class bit (72) aligned,		/* for multiclass, this is effectively the min access class */
  9    24     2 multiclass bit (1) aligned;
  9    25 
  9    26 /* END INCLUDE FILE ... entry_access_info.incl.pl1 */
      649 
      650  /* BEGIN INCLUDE FILE ... mseg_entries.incl.pl1 */
 10     2 /* Created:  April 1985 by G. Palter */
 10     3 
 10     4 /* format: style3,linecom,idind30 */
 10     5 
 10     6 /* Message segment primitive operations --
 10     7*
 10     8*   The first argument of all of these entrypoints is a pointer to the mseg_operation describing the segment and, when
 10     9*   appropriate, the message to be manipulated by the operation.  (See mseg_operation.incl.pl1 for additional information.)
 10    10*
 10    11*   The last argument is always a standard system status code.
 10    12*
 10    13*   For each operation defined below, the fields in the mseg_operation which must be supplied by the caller are listed
 10    14*   along with a brief description of the additional arguments, if any.  For greater detail on the use of these
 10    15*   entrypoints, refer to mseg_mbx_ms_gate_target_.pl1 which is the classic user of these entrypoints. */
 10    16 
 10    17 
 10    18 declare
 10    19      /*** Add (or update) ACL entries -- OP.mseg_pathname; general_extended_acl_ptr (I) */
 10    20 	mseg_$add_acl_entries_seg	entry (pointer, pointer, fixed binary (35));
 10    21 
 10    22 declare
 10    23      /*** Add a message -- OP.mseg_ptr, OP.access_info, OP.message_info */
 10    24 	mseg_$add_message		entry (pointer, fixed binary (35));
 10    25 
 10    26 declare
 10    27      /*** Change the names -- OP.mseg_pathname or OP.mseg_ptr; old_name_to_delete (I), new_name_to_add (I) */
 10    28 	mseg_$chname_seg		entry (pointer, character (*), character (*), fixed binary (35));
 10    29 
 10    30 declare
 10    31      /*** Close the segment -- OP.mseg_ptr (optional), OP.mseg_index (optional); mseg_index_table_ptr (I/O)
 10    32*	     mseg_index_table_ptr must be an internal/external static variable initialized once per-process to null() */
 10    33 	mseg_$close_seg		entry (pointer, pointer, fixed binary (35));
 10    34 
 10    35 declare
 10    36      /*** Compact the segment -- OP.mseg_ptr; compaction_ratio (I) */
 10    37 	mseg_$compact_seg		entry (pointer, float binary, fixed binary (35));
 10    38 
 10    39 declare
 10    40      /*** Copy the segment -- OP.mseg_ptr; target_mseg_operation_ptr (I) (TOP.mseg_ptr), error_on_target (O) */
 10    41 	mseg_$copy_seg		entry (pointer, pointer, bit (1) aligned, fixed binary (35));
 10    42 
 10    43 declare
 10    44      /*** Count the accessible messages -- OP.mseg_ptr, OP.access_info; n_messages (O) */
 10    45 	mseg_$count_messages	entry (pointer, fixed binary, fixed binary (35));
 10    46 
 10    47 declare
 10    48      /*** Create the segment -- OP.mseg_pathname; general_extended_acl_ptr (I) --
 10    49*	     If general_extended_acl_ptr is null, the default ACL for the type of segment to be created will be used */
 10    50 	mseg_$create_seg		entry (pointer, pointer, fixed binary (35));
 10    51 
 10    52 declare
 10    53      /*** Delete ACL entries -- OP.mseg_pathname; general_delete_acl_ptr (I) --
 10    54*	     If general_delete_acl_ptr is null, the entire ACL will be deleted */
 10    55 	mseg_$delete_acl_entries_seg	entry (pointer, pointer, fixed binary (35));
 10    56 
 10    57 declare
 10    58      /*** Delete a message -- OP.mseg_ptr, OP.access_info, OP.message_info */
 10    59 	mseg_$delete_message	entry (pointer, fixed binary (35));
 10    60 
 10    61 declare
 10    62      /*** Delete the segment -- OP.mseg_ptr (surprise); mseg_index_table_ptr (I/O)
 10    63*	     mseg_index_table_ptr must be an internal/external static variable initialized once per-process to null() */
 10    64 	mseg_$delete_seg		entry (pointer, pointer, fixed binary (35));
 10    65 
 10    66 declare
 10    67      /*** Get the salvaged flag -- OP.mseg_ptr; segment_was_salvaged (O) */
 10    68 	mseg_$get_salvaged_flag_seg	entry (pointer, bit (1) aligned, fixed binary (35));
 10    69 
 10    70 declare
 10    71      /*** Get the wakeup acceptance state -- OP.mseg_ptr, OP.wakeup_state.version */
 10    72 	mseg_$get_wakeup_state_seg	entry (pointer, fixed binary (35));
 10    73 
 10    74 declare
 10    75      /*** Initiate the segment -- OP.mseg_pathname */
 10    76 	mseg_$initiate_seg		entry (pointer, fixed binary (35));
 10    77 
 10    78 declare
 10    79      /*** List the entire ACL -- OP.mseg_pathname; general_extended_acl_ptr (O)
 10    80*	     The general_extended_acl is allocated in the system free area */
 10    81 	mseg_$list_acl_seg		entry (pointer, pointer, fixed binary (35));
 10    82 
 10    83 declare
 10    84      /*** List individual ACL entries -- OP.mseg_pathname; general_extended_acl_ptr (I) */
 10    85 	mseg_$list_acl_entries_seg	entry (pointer, pointer, fixed binary (35));
 10    86 
 10    87 declare
 10    88      /*** Open the segment -- OP.mseg_ptr; mseg_index_table_ptr (I/O)
 10    89*	     mseg_index_table_ptr must be an internal/external static variable initialized once per-process to null() */
 10    90 	mseg_$open_seg		entry (pointer, pointer, fixed binary (35));
 10    91 
 10    92 declare
 10    93      /*** Read (and optionally delete) a message -- OP.mseg_ptr, OP.access_info, OP.message_info; users_area_ptr (I) */
 10    94 	mseg_$read_message		entry (pointer, pointer, fixed binary (35));
 10    95 
 10    96 declare
 10    97      /*** Replace the ACL -- OP.mseg_pathname; general_extended_acl_ptr (I) --
 10    98*	     If general_extended_acl_ptr is null, the new ACL will be empty */
 10    99 	mseg_$replace_acl_seg	entry (pointer, pointer, fixed binary (35));
 10   100 
 10   101 declare
 10   102      /*** Reset the salvaged flag -- OP.mseg_ptr, OP.access_info */
 10   103 	mseg_$reset_salvaged_flag_seg entry (pointer, fixed binary (35));
 10   104 
 10   105 declare
 10   106      /*** Reset wakeup acceptance (i.e., turn it off) -- OP.mseg_ptr */
 10   107 	mseg_$reset_wakeup_state_seg	entry (pointer, fixed binary (35));
 10   108 
 10   109 declare
 10   110      /*** Set the max length -- OP.mseg_ptr (surprise); new_max_length (I) */
 10   111 	mseg_$set_max_length_seg	entry (pointer, fixed binary (19), fixed binary (35));
 10   112 
 10   113 declare
 10   114      /*** Set the safety switch -- OP.mseg_pathname or OP.mseg_ptr; new_safety_switch (I) */
 10   115 	mseg_$set_safety_switch_seg	entry (pointer, bit (1) aligned, fixed binary (35));
 10   116 
 10   117 declare
 10   118      /*** Set the wakeup acceptance state -- OP.mseg_ptr, OP.wakeup_state */
 10   119 	mseg_$set_wakeup_state_seg	entry (pointer, fixed binary (35));
 10   120 
 10   121 declare
 10   122      /*** Update a message -- OP.mseg_ptr, OP.access_info, OP.message_info */
 10   123 	mseg_$update_message	entry (pointer, fixed binary (35));
 10   124 
 10   125 /* END INCLUDE FILE ... mseg_entries.incl.pl1 */
      650 
      651  /* Begin include file mseg_data_.incl.pl1 BIM 1985-04-15 */
 11     2 /* format: style4 */
 11     3 
 11     4 declare  mseg_data_$lock_id bit (72) aligned external;
 11     5 declare  mseg_data_$block_size fixed bin (35) ext static;
 11     6 declare  mseg_data_$max_message_size fixed bin (35) ext static;
 11     7 declare  mseg_data_$template_operation bit (36) aligned external static; /* like mseg_operation */
 11     8 declare  mseg_data_$admin_ring fixed binary (3) external;
 11     9 declare  mseg_data_$execution_ring fixed bin (3) ext static;
 11    10 declare  mseg_data_$process_max_authorization bit (72) aligned ext static;
 11    11 declare  mseg_data_$group_id char (32) unaligned external static;
 11    12 
 11    13 /* End include file mseg_data_.incl.pl1 */
      651 
      652 
      653      end asum_read_delete_ops_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/04/87  1221.5  asum_read_delete_ops_.pl1         >special_ldd>install>MR12.1-1054>asum_read_delete_ops_.pl1
51           1    03/19/85  1613.7  asum_data_.incl.pl1               >ldd>include>asum_data_.incl.pl1
642          2    03/08/85  0852.5  as_user_message_system.incl.pl1   >ldd>include>as_user_message_system.incl.pl1
643          3    01/10/85  2002.8  mseg_message_info.incl.pl1        >ldd>include>mseg_message_info.incl.pl1
644          4    03/08/85  0852.7  as_user_message_info.incl.pl1     >ldd>include>as_user_message_info.incl.pl1
645          5    03/08/85  0852.6  as_user_message_aread.incl.pl1    >ldd>include>as_user_message_aread.incl.pl1
646          6    05/17/85  0615.6  mseg_operation.incl.pl1           >ldd>include>mseg_operation.incl.pl1
647          7    05/17/85  0619.0  mseg_access_operation.incl.pl1    >ldd>include>mseg_access_operation.incl.pl1
648          8    05/17/85  0615.7  mseg_wakeup_state.incl.pl1        >ldd>include>mseg_wakeup_state.incl.pl1
649          9    05/17/85  0615.5  entry_access_info.incl.pl1        >ldd>include>entry_access_info.incl.pl1
650         10    05/17/85  0615.6  mseg_entries.incl.pl1             >ldd>include>mseg_entries.incl.pl1
651         11    05/17/85  0619.0  mseg_data_.incl.pl1               >ldd>include>mseg_data_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
AS_USER_MESSAGE_ADMIN_READ_INFO_VERSION_1
                                000002 constant        char(8)                  initial unaligned dcl 5-15 ref 245
AS_USER_MESSAGE_INFO_VERSION_1  000004 constant        char(8)                  initial dcl 4-33 ref 127 245
MID                                    constant        fixed bin(17,0)          initial dcl 279 ref 287 310
MSEG_READ_SPECIFIED                    constant        fixed bin(17,0)          initial dcl 3-30 ref 450
PID                                    constant        fixed bin(17,0)          initial dcl 279 ref 293 301
P_admin_read_info_ptr                  parameter       pointer                  dcl 89 ref 233 237
P_area_ptr                             parameter       pointer                  dcl 88 ref 114 121 233 239
P_code                                 parameter       fixed bin(35,0)          dcl 95 set ref 114 188* 196 210* 214 229 233 248*
                                                                                  255* 504*
P_message_id                           parameter       bit(72)                  dcl 93 ref 196 200
P_message_index                        parameter       fixed bin(17,0)          dcl 403 set ref 400 406 417*
P_process_id                           parameter       bit(36)                  dcl 94 ref 214 218
P_read_info_ptr                        parameter       pointer                  dcl 91 ref 114 122 233 238
a_mid                                  parameter       bit(72)                  dcl 475 in procedure "delete_mseg_msg" set ref 472
                                                                                  480 493*
a_mid                                  parameter       bit(72)                  dcl 441 in procedure "read_out_message" ref 439 446
access_class             16            based           bit(72)                  level 2 in structure "am" dcl 514 in procedure
                                                                                  "admin_search" set ref 565*
access_class             16            based           bit(72)                  level 2 in structure "am" dcl 334 in procedure
                                                                                  "search_table" set ref 395* 415*
addr                                                   builtin function         dcl 107 ref 298 349 406 449 459 459 484 492 492 534
                                                                                  536 549
admin_read_info                 000100 automatic       structure                level 1 dcl 67 set ref 241*
after_message_id         26     000100 automatic       bit(72)                  level 2 dcl 67 set ref 552 552
aim_check_$equal                000022 constant        entry                    external dcl 53 ref 415
aim_check_$greater_or_equal     000024 constant        entry                    external dcl 54 ref 395 565
aim_privileged           10     000172 automatic       bit(1)                   level 2 dcl 69 set ref 166* 393 415 546* 565
am                                     based           structure                level 1 dcl 514 in procedure "admin_search" set ref
                                                                                  538 539*
am                                     based           structure                level 1 dcl 283 in procedure "delete$$message_id"
am                                     based           structure                level 1 dcl 334 in procedure "search_table"
am_real_message_id              000556 automatic       bit(72)                  dcl 335 set ref 373* 375 375 379
amep                            000554 automatic       pointer                  dcl 333 in procedure "search_table" set ref 349* 350
                                                                                  353 353 355 355 357 359 365 371 395 406* 407 408
                                                                                  409 410 411 413 415
amep                            000654 automatic       pointer                  dcl 516 in procedure "admin_search" set ref 536* 537
                                                                                  538 539 549* 550 552 555 558 561 565 574 575 590
                                                                                  591 592 595 596
amep                            000540 automatic       pointer                  dcl 284 in procedure "delete$$message_id" set ref
                                                                                  298* 299 303 305 312 314
amx                                    parameter       fixed bin(17,0)          dcl 607 ref 604 612 612 614 616
area_ptr                        000506 automatic       pointer                  dcl 90 set ref 121* 239* 459*
as_user_message_admin_read_info        based           structure                level 1 dcl 5-5 ref 241
as_user_message_admin_read_info_ptr
                                000522 automatic       pointer                  dcl 5-4 set ref 237* 241
as_user_message_id              000514 automatic       structure                level 1 dcl 2-18 set ref 344* 346 371* 373 446* 453
                                                                                  480* 485
as_user_message_info                   based           structure                level 1 dcl 4-8 set ref 123 189* 242 256*
as_user_message_info_ptr        000520 automatic       pointer                  dcl 4-7 set ref 238* 242 256
as_user_message_system_info            based           structure                level 1 dcl 2-30
as_user_message_system_info_ptr 000516 automatic       pointer                  dcl 2-29 set ref 125* 202* 220* 243* 297 298 348 349
                                                                                  406 526 533 534 535 536 548 549 612 612 614 616
                                                                                  618 626 626 635 635
asum_data_$db_locked            000010 external static bit(1)                   dcl 1-23 set ref 628* 637*
asum_data_$entry_ring           000014 external static fixed bin(3,0)           dcl 1-29 ref 162 164
asum_data_$lock_id              000016 external static bit(36)                  dcl 1-31 ref 626 635
asum_data_$process_id           000020 external static bit(36)                  dcl 1-32 ref 142
asum_data_$system_info_ptr      000012 external static pointer                  dcl 1-27 ref 125 202 220 243
asum_error_                     000030 constant        entry                    external dcl 57 ref 183 493 575
asum_find_segment_              000026 constant        entry                    external dcl 56 ref 456 483 488
authorization            11     000172 automatic       bit(72)                  level 2 dcl 69 set ref 165* 395* 415* 545* 565*
code                                   parameter       fixed bin(35,0)          dcl 501 in procedure "error_return" ref 499 504
code                            000512 automatic       fixed bin(35,0)          dcl 96 in procedure "asum_read_delete_ops_" set ref
                                                                                  117* 181* 183 183 183* 188 199* 206* 210 217* 224*
                                                                                  229* 236* 255 526* 574* 575 575 575* 577 600*
code                                   parameter       fixed bin(35,0)          dcl 442 in procedure "read_out_message" set ref 439
                                                                                  459*
code                                   parameter       fixed bin(35,0)          dcl 277 in procedure "delete$$message_id" set ref
                                                                                  274 290 295* 307* 316*
code                            000612 automatic       fixed bin(35,0)          dcl 431 in procedure "group_match" set ref 435* 436
code                            000634 automatic       fixed bin(35,0)          dcl 476 in procedure "delete_mseg_msg" set ref 492*
                                                                                  493 493*
control_flags           223     000216 automatic       structure                level 3 packed unaligned dcl 82 set ref 451*
delete                   13     000172 automatic       bit(1)                   level 2 in structure "search" dcl 69 in procedure
                                                                                  "asum_read_delete_ops_" set ref 161* 413
delete                  223(01) 000216 automatic       bit(1)                   level 4 in structure "mop" packed unaligned dcl 82
                                                                                  in procedure "asum_read_delete_ops_" set ref 452*
delete_by                       000536 automatic       fixed bin(1,0)           dcl 278 set ref 287* 293* 301 310
delete_the_message              000505 automatic       bit(1)                   dcl 86 set ref 342* 418* 452 573*
destination_am           20            based           structure                array level 2 dcl 2-30 set ref 298 349 406 534 536
                                                                                  549
destination_info         30     000130 automatic       structure                level 2 dcl 68
divide                                                 builtin function         dcl 108 ref 461
dont_delete               2(04) 000130 automatic       bit(1)                   level 3 packed unaligned dcl 68 set ref 161 596*
entry_access_info                      based           structure                level 1 dcl 9-12
error_table_$bad_arg            000054 external static fixed bin(35,0)          dcl 103 set ref 146* 149*
error_table_$no_message         000056 external static fixed bin(35,0)          dcl 104 set ref 176* 295 526 600
error_table_$notalloc           000050 external static fixed bin(35,0)          dcl 100 ref 183 575
error_table_$unimplemented_version
                                000052 external static fixed bin(35,0)          dcl 101 set ref 127* 248
flags                    24     000216 automatic       structure                level 2 in structure "mop" dcl 82 in procedure
                                                                                  "asum_read_delete_ops_"
flags                     2     000130 automatic       structure                level 2 in structure "read_info" dcl 68 in procedure
                                                                                  "asum_read_delete_ops_"
fx                              000622 automatic       fixed bin(17,0)          dcl 443 in procedure "read_out_message" set ref 447*
                                                                                  456*
fx                              000635 automatic       fixed bin(17,0)          dcl 477 in procedure "delete_mseg_msg" set ref 481*
                                                                                  483* 488* 493*
g_message_id                    000502 automatic       bit(72)                  dcl 84 set ref 171* 173 181* 183* 200* 312
g_process_id                    000504 automatic       bit(36)                  dcl 85 set ref 218* 303
get_group_id_                   000034 constant        entry                    external dcl 59 ref 143
get_privileges_                 000040 constant        entry                    external dcl 62 ref 166 546
get_process_authorization_      000036 constant        entry                    external dcl 60 ref 165 545
group_id                 17     000130 automatic       char(32)                 level 3 in structure "read_info" packed unaligned
                                                                                  dcl 68 in procedure "asum_read_delete_ops_" set
                                                                                  ref 466* 593*
group_id                 30     000130 automatic       char(32)                 level 3 in structure "read_info" packed unaligned
                                                                                  dcl 68 in procedure "asum_read_delete_ops_" set
                                                                                  ref 407* 590*
group_id                  6            based           char(32)                 level 2 in structure "am" packed unaligned dcl 514
                                                                                  in procedure "admin_search" set ref 561* 590
group_id                 14     000172 automatic       char(32)                 level 2 in structure "search" packed unaligned
                                                                                  dcl 69 in procedure "asum_read_delete_ops_" set
                                                                                  ref 143* 355*
group_id                  6            based           char(32)                 level 2 in structure "am" packed unaligned dcl 334
                                                                                  in procedure "search_table" set ref 355* 407
handle                    2            based           bit(72)                  level 2 in structure "am" dcl 334 in procedure
                                                                                  "search_table" ref 359 410
handle                    2            based           bit(72)                  level 2 in structure "am" dcl 514 in procedure
                                                                                  "admin_search" set ref 555 595
handle                    2     000172 automatic       bit(72)                  level 2 in structure "search" dcl 69 in procedure
                                                                                  "asum_read_delete_ops_" set ref 144* 148* 359 359
header                                 based           structure                level 2 dcl 2-30
highest_in_use            6            based           fixed bin(35,0)          level 3 dcl 2-30 set ref 297 348 526 533 535 548 614
                                                                                  618*
hx                              000542 automatic       fixed bin(17,0)          dcl 285 in procedure "delete$$message_id" set ref
                                                                                  297* 298 306* 315*
hx                              000656 automatic       fixed bin(17,0)          dcl 517 in procedure "admin_search" set ref 535*
                                                                                  536* 548* 549*
hx                              000716 automatic       fixed bin(17,0)          dcl 608 in procedure "delete_am_entry" set ref 616*
                                                                                  616* 618
lock                      4            based           bit(36)                  level 3 dcl 2-30 set ref 626 626* 635 635*
match_star_name_                000032 constant        entry                    external dcl 58 ref 435
max                                                    builtin function         dcl 109 ref 162
message_access_class     12     000130 automatic       bit(72)                  level 3 dcl 68 set ref 463*
message_code            222     000216 automatic       fixed bin(17,0)          level 3 dcl 82 set ref 450*
message_handle           14     000130 automatic       bit(72)                  level 3 dcl 68 set ref 146 148 410* 595*
message_id                4            based           bit(72)                  level 2 in structure "am" dcl 334 in procedure
                                                                                  "search_table" ref 365 371 411
message_id               10     000130 automatic       bit(72)                  level 3 in structure "read_info" dcl 68 in procedure
                                                                                  "asum_read_delete_ops_" set ref 153 158 462*
message_id                4            based           bit(72)                  level 2 in structure "am" dcl 283 in procedure
                                                                                  "delete$$message_id" set ref 305* 312 314*
message_id                4            based           bit(72)                  level 2 in structure "am" dcl 514 in procedure
                                                                                  "admin_search" set ref 537 552 574* 575*
message_id                4            based           bit(72)                  level 2 in structure "min_am" dcl 520 in procedure
                                                                                  "admin_search" set ref 537
message_id                      000602 automatic       bit(72)                  dcl 404 in procedure
                                                                                  "SET_RETURN_INFO_AND_MAYBE_DELETE" set ref 411*
                                                                                  421
message_id                4     000172 automatic       bit(72)                  level 2 in structure "search" dcl 69 in procedure
                                                                                  "asum_read_delete_ops_" set ref 153* 158* 344 365
message_info              4     000130 automatic       structure                level 2 in structure "read_info" dcl 68 in procedure
                                                                                  "asum_read_delete_ops_"
message_info            220     000216 automatic       structure                level 2 in structure "mop" dcl 82 in procedure
                                                                                  "asum_read_delete_ops_"
message_info_valid       24(05) 000216 automatic       bit(1)                   level 3 packed unaligned dcl 82 set ref 455* 486*
message_length            6     000130 automatic       fixed bin(18,0)          level 3 dcl 68 set ref 461*
message_ptr               4     000130 automatic       pointer                  level 3 dcl 68 set ref 460*
message_ring             16     000130 automatic       fixed bin(3,0)           level 3 dcl 68 set ref 162 464*
message_x                       000563 automatic       fixed bin(17,0)          dcl 338 set ref 380* 388*
mid_mask                        000000 constant        bit(72)                  initial dcl 518 ref 552 552
min_am                                 based           structure                level 1 dcl 520 set ref 539 540*
min_amep                        000660 automatic       pointer                  dcl 522 set ref 534* 537 539 540
minx                            000662 automatic       fixed bin(17,0)          dcl 523 set ref 533* 534 535*
mop                             000216 automatic       structure                level 1 dcl 82 set ref 449* 459 459 484* 492 492
ms_access_class         231     000216 automatic       bit(72)                  level 3 dcl 82 set ref 463
ms_id                   227     000216 automatic       bit(72)                  level 3 dcl 82 set ref 453* 462 485*
ms_len                  226     000216 automatic       fixed bin(24,0)          level 3 dcl 82 set ref 461 586 586
ms_ptr                  224     000216 automatic       pointer                  level 3 dcl 82 set ref 460 586
mseg_$delete_message            000060 constant        entry                    external dcl 10-57 ref 492
mseg_$read_message              000062 constant        entry                    external dcl 10-92 ref 459
mseg_access_operation                  based           structure                level 1 dcl 7-5
mseg_data_$template_operation   000064 external static bit(36)                  dcl 11-7 set ref 449 484
mseg_message_info                      based           structure                level 1 dcl 3-9
mseg_operation                         based           structure                level 1 dcl 6-24 ref 449 484
mseg_ptr                        000636 automatic       pointer                  dcl 478 in procedure "delete_mseg_msg" set ref 483*
                                                                                  488* 489
mseg_ptr                110     000216 automatic       pointer                  level 2 in structure "mop" dcl 82 in procedure
                                                                                  "asum_read_delete_ops_" set ref 457* 489*
mseg_ptr                        000624 automatic       pointer                  dcl 444 in procedure "read_out_message" set ref 456*
                                                                                  457
mseg_ptr_valid           24(01) 000216 automatic       bit(1)                   level 3 packed unaligned dcl 82 set ref 458* 490*
mseg_wakeup_state                      based           structure                level 1 dcl 8-24
no_handle_given           2(02) 000130 automatic       bit(1)                   level 3 packed unaligned dcl 68 set ref 144
process_id                             based           bit(36)                  level 2 in structure "am" dcl 514 in procedure
                                                                                  "admin_search" set ref 550 558 591
process_id               40     000130 automatic       bit(36)                  level 3 in structure "read_info" dcl 68 in procedure
                                                                                  "asum_read_delete_ops_" set ref 408* 591*
process_id                             based           bit(36)                  level 2 in structure "am" dcl 283 in procedure
                                                                                  "delete$$message_id" ref 299 303
process_id                             based           bit(36)                  level 2 in structure "am" dcl 334 in procedure
                                                                                  "search_table" ref 350 353 353 355 408
process_id               27     000130 automatic       bit(36)                  level 3 in structure "read_info" dcl 68 in procedure
                                                                                  "asum_read_delete_ops_" set ref 467* 594*
process_id                      000172 automatic       bit(36)                  level 2 in structure "search" dcl 69 in procedure
                                                                                  "asum_read_delete_ops_" set ref 142* 353
process_id               20            based           bit(36)                  array level 3 in structure
                                                                                  "as_user_message_system_info" dcl 2-30
                                                                                  in procedure "asum_read_delete_ops_" set ref 612
                                                                                  612 616
q                               000717 automatic       bit(1)                   dcl 610 set ref 612*
read_after_message_id
                          2(01) 000130 automatic       bit(1)                   level 3 packed unaligned dcl 68 set ref 149 156
read_info                       000130 automatic       structure                level 1 dcl 68 set ref 123* 189 242* 256
read_info_ptr                   000510 automatic       pointer                  dcl 92 set ref 122* 123 189
read_message_id           2     000130 automatic       bit(1)                   level 3 packed unaligned dcl 68 set ref 149 151
read_the_next_one         7     000172 automatic       bit(1)                   level 2 dcl 69 set ref 159* 375 375
read_this_one             6     000172 automatic       bit(1)                   level 2 dcl 69 set ref 154* 365
reader_deletes            1(03)        based           bit(1)                   level 2 in structure "am" packed unaligned dcl 514
                                                                                  in procedure "admin_search" set ref 596
reader_deletes            1(03)        based           bit(1)                   level 2 in structure "am" packed unaligned dcl 334
                                                                                  in procedure "search_table" ref 413
return_label                           parameter       label variable           dcl 502 ref 499 505
ring                      1            based           fixed bin(3,0)           level 2 in structure "am" packed unsigned unaligned
                                                                                  dcl 334 in procedure "search_table" ref 357 409
ring                      1     000172 automatic       fixed bin(3,0)           level 2 in structure "search" dcl 69 in procedure
                                                                                  "asum_read_delete_ops_" set ref 162* 164* 357 357
ring                      1            based           fixed bin(3,0)           level 2 in structure "am" packed unsigned unaligned
                                                                                  dcl 514 in procedure "admin_search" set ref 592
ring                     41     000130 automatic       fixed bin(3,0)           level 3 in structure "read_info" dcl 68 in procedure
                                                                                  "asum_read_delete_ops_" set ref 409* 592*
ring_given                2(03) 000130 automatic       bit(1)                   level 3 packed unaligned dcl 68 set ref 162
search                          000172 automatic       structure                level 1 dcl 69 set ref 141*
search_real_message_id          000560 automatic       bit(72)                  dcl 336 set ref 346* 375
segment_index                   000514 automatic       fixed bin(9,0)           level 2 packed unsigned unaligned dcl 2-18 set ref
                                                                                  345* 372* 447 448* 481 482*
sender_id               233     000216 automatic       char(32)                 level 3 packed unaligned dcl 82 set ref 466 580* 593
sender_info              17     000130 automatic       structure                level 2 dcl 68
sender_level            244     000216 automatic       fixed bin(17,0)          level 3 dcl 82 set ref 464
sender_process_id       243     000216 automatic       bit(36)                  level 3 dcl 82 set ref 467 580 594
set_lock_$lock                  000042 constant        entry                    external dcl 63 ref 626
set_lock_$unlock                000044 constant        entry                    external dcl 64 ref 635
source_group_id           2     000100 automatic       char(32)                 level 2 packed unaligned dcl 67 set ref 580 580*
source_process_id        12     000100 automatic       bit(36)                  level 2 dcl 67 set ref 580 580
stacq                                                  builtin function         dcl 110 ref 612 626 635
star                                   parameter       char(32)                 unaligned dcl 430 set ref 427 433 435*
suppress_access_checks
                         24(07) 000216 automatic       bit(1)                   level 3 packed unaligned dcl 82 set ref 454* 487*
sys_info$ring1_privilege        000046 external static bit(36)                  dcl 98 ref 166 546
target_group_id          13     000100 automatic       char(32)                 level 2 packed unaligned dcl 67 set ref 561 561*
target_handle            24     000100 automatic       bit(72)                  level 2 dcl 67 set ref 555 555
target_process_id        23     000100 automatic       bit(36)                  level 2 dcl 67 set ref 558 558
temp_am                         000663 automatic       structure                level 1 dcl 524 set ref 538* 540
to_free                                based           bit                      unaligned dcl 585 ref 586
try                                    parameter       char(32)                 unaligned dcl 430 set ref 427 435*
unspec                                                 builtin function         dcl 111 set ref 141* 344* 346 371* 373 446* 453 480*
                                                                                  485
version                         000100 automatic       char(8)                  level 2 in structure "admin_read_info" dcl 67
                                                                                  in procedure "asum_read_delete_ops_" set ref 245
version                         000130 automatic       char(8)                  level 2 in structure "read_info" dcl 68 in procedure
                                                                                  "asum_read_delete_ops_" set ref 127 245
x                               000562 automatic       fixed bin(17,0)          dcl 337 set ref 348* 349 365* 380*
youngest_message_id             000552 automatic       bit(72)                  dcl 332 set ref 340* 375 379* 386

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
AS_USER_ANY_PROCESS_ID                 internal static bit(36)                  initial dcl 2-49
AS_USER_MESSAGE_PROCESS_SENTINEL       internal static char(8)                  initial dcl 2-85
AS_USER_MESSAGE_SEGMENT_NAME_CONSTANT  internal static char(16)                 initial unaligned dcl 2-12
AS_USER_MESSAGE_SYSTEM_NAME            internal static char(32)                 initial unaligned dcl 2-27
AS_USER_MESSAGE_SYSTEM_SENTINEL        internal static char(8)                  initial dcl 2-73
ENTRY_ACCESS_INFO_VERSION_1            internal static char(8)                  initial unaligned dcl 9-9
MSEG_ACCEPT_WAKEUPS                    internal static fixed bin(9,0)           initial dcl 7-24
MSEG_ADD_MESSAGE                       internal static fixed bin(9,0)           initial dcl 7-24
MSEG_COPY_SEG                          internal static fixed bin(9,0)           initial dcl 7-24
MSEG_CREATE_SEG                        internal static fixed bin(9,0)           initial dcl 7-24
MSEG_MESSAGE_INFO_V1                   internal static char(8)                  initial dcl 3-28
MSEG_MODIFY_MESSAGE                    internal static fixed bin(9,0)           initial dcl 7-24
MSEG_MODIFY_SEG_ATTR                   internal static fixed bin(9,0)           initial dcl 7-24
MSEG_OPERATION_VERSION_1               internal static fixed bin(17,0)          initial dcl 6-20
MSEG_READ_AFTER_SPECIFIED              internal static fixed bin(17,0)          initial dcl 3-30
MSEG_READ_BEFORE_SPECIFIED             internal static fixed bin(17,0)          initial dcl 3-30
MSEG_READ_DELETE                       internal static bit(36)                  initial dcl 3-38
MSEG_READ_FIRST                        internal static fixed bin(17,0)          initial dcl 3-30
MSEG_READ_LAST                         internal static fixed bin(17,0)          initial dcl 3-30
MSEG_READ_MESSAGE                      internal static fixed bin(9,0)           initial dcl 7-24
MSEG_READ_OWN                          internal static bit(36)                  initial dcl 3-38
MSEG_READ_SEG_ATTR                     internal static fixed bin(9,0)           initial dcl 7-24
MSEG_TYPE_MBX                          internal static fixed bin(17,0)          initial dcl 6-21
MSEG_TYPE_MS                           internal static fixed bin(17,0)          initial dcl 6-22
MSEG_WAKEUP_STATE_VERSION_1            internal static char(8)                  initial unaligned dcl 8-41
as_user_message_perprocess_info        based           structure                level 1 dcl 2-81
as_user_message_perprocess_info_ptr    automatic       pointer                  dcl 2-79
as_user_message_segment_name           automatic       structure                level 1 packed unaligned dcl 2-8
asum_data_$acl_entries                 external static bit(36)                  dcl 1-10
asum_data_$db_cbi                      external static bit(36)                  dcl 1-17
asum_data_$db_dir                      external static char(168)                unaligned dcl 1-12
asum_data_$db_dir_cbi                  external static bit(36)                  dcl 1-18
asum_data_$db_dir_rb                   external static fixed bin(3,0)           array dcl 1-20
asum_data_$db_multiclass               external static bit(1)                   dcl 1-13
asum_data_$db_rb                       external static fixed bin(3,0)           array dcl 1-22
asum_data_$n_acl_entries               external static fixed bin(17,0)          dcl 1-15
asum_data_$process_info_ptr            external static pointer                  dcl 1-25
entry_access_info_ptr                  automatic       pointer                  dcl 9-8
mseg_$add_acl_entries_seg       000000 constant        entry                    external dcl 10-18
mseg_$add_message               000000 constant        entry                    external dcl 10-22
mseg_$chname_seg                000000 constant        entry                    external dcl 10-26
mseg_$close_seg                 000000 constant        entry                    external dcl 10-30
mseg_$compact_seg               000000 constant        entry                    external dcl 10-35
mseg_$copy_seg                  000000 constant        entry                    external dcl 10-39
mseg_$count_messages            000000 constant        entry                    external dcl 10-43
mseg_$create_seg                000000 constant        entry                    external dcl 10-47
mseg_$delete_acl_entries_seg    000000 constant        entry                    external dcl 10-52
mseg_$delete_seg                000000 constant        entry                    external dcl 10-61
mseg_$get_salvaged_flag_seg     000000 constant        entry                    external dcl 10-66
mseg_$get_wakeup_state_seg      000000 constant        entry                    external dcl 10-70
mseg_$initiate_seg              000000 constant        entry                    external dcl 10-74
mseg_$list_acl_entries_seg      000000 constant        entry                    external dcl 10-83
mseg_$list_acl_seg              000000 constant        entry                    external dcl 10-78
mseg_$open_seg                  000000 constant        entry                    external dcl 10-87
mseg_$replace_acl_seg           000000 constant        entry                    external dcl 10-96
mseg_$reset_salvaged_flag_seg   000000 constant        entry                    external dcl 10-101
mseg_$reset_wakeup_state_seg    000000 constant        entry                    external dcl 10-105
mseg_$set_max_length_seg        000000 constant        entry                    external dcl 10-109
mseg_$set_safety_switch_seg     000000 constant        entry                    external dcl 10-113
mseg_$set_wakeup_state_seg      000000 constant        entry                    external dcl 10-117
mseg_$update_message            000000 constant        entry                    external dcl 10-121
mseg_access_operation_ptr              automatic       pointer                  dcl 7-4
mseg_access_operations_$data           external static structure                array level 1 dcl 7-35
mseg_data_$admin_ring                  external static fixed bin(3,0)           dcl 11-8
mseg_data_$block_size                  external static fixed bin(35,0)          dcl 11-5
mseg_data_$execution_ring              external static fixed bin(3,0)           dcl 11-9
mseg_data_$group_id                    external static char(32)                 unaligned dcl 11-11
mseg_data_$lock_id                     external static bit(72)                  dcl 11-4
mseg_data_$max_message_size            external static fixed bin(35,0)          dcl 11-6
mseg_data_$process_max_authorization   external static bit(72)                  dcl 11-10
mseg_message_info_ptr                  automatic       pointer                  dcl 3-7
mseg_operation_ptr                     automatic       pointer                  dcl 6-19
mseg_wakeup_state_ptr                  automatic       pointer                  dcl 8-38

NAMES DECLARED BY EXPLICIT CONTEXT.
COMMON                          000606 constant        label                    dcl 295 ref 288
SET_RETURN_INFO_AND_MAYBE_DELETE
                                001126 constant        entry                    internal dcl 400 ref 365 388
TRY_NEXT                        002125 constant        label                    dcl 598 in procedure "admin_search" ref 550 552 555
                                                                                  558 561 565 587
TRY_NEXT                        001046 constant        label                    dcl 383 in procedure "search_table" ref 350 353 355
                                                                                  357 359 362
USER_READ_ERROR                 000415 constant        label                    dcl 192 ref 127 127 146 146 149 149 176 176
admin_read                      000513 constant        entry                    external dcl 233
admin_search                    001541 constant        entry                    internal dcl 509 ref 253
asum_read_delete_ops_           000071 constant        entry                    external dcl 33
check_aim                       001071 constant        entry                    internal dcl 390 ref 362
delete$$message_id              000575 constant        entry                    internal dcl 274 ref 206
delete$$process_id              000602 constant        entry                    internal dcl 290 ref 224
delete_am_entry                 002133 constant        entry                    internal dcl 604 ref 306 315 417
delete_mseg_msg                 001376 constant        entry                    internal dcl 472 ref 305 314
error_return                    001533 constant        entry                    internal dcl 499 ref 127 146 149 176
group_match                     001215 constant        entry                    internal dcl 427 ref 355 561 580
lock_database                   002173 constant        entry                    internal dcl 623 ref 168 204 222 252
priv_delete_message_id          000422 constant        entry                    external dcl 196
priv_delete_process_id          000457 constant        entry                    external dcl 214
read_out_message                001255 constant        entry                    internal dcl 439 ref 181 574
search_table                    000675 constant        entry                    internal dcl 324 ref 171
unlock_database                 002224 constant        entry                    internal dcl 632 ref 175 186 208 226 254
user_read_message               000103 constant        entry                    external dcl 114

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2672        2760    2324        2702
Length      3452    2324        66         455     346           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
asum_read_delete_ops_               692 external procedure  is an external procedure.  
delete$$message_id                      internal procedure  shares stack frame of external procedure asum_read_delete_ops_.  
search_table                            internal procedure  shares stack frame of external procedure asum_read_delete_ops_.  
check_aim                               internal procedure  shares stack frame of external procedure asum_read_delete_ops_.  
SET_RETURN_INFO_AND_MAYBE_DELETE
                                        internal procedure  shares stack frame of external procedure asum_read_delete_ops_.  
group_match                             internal procedure  shares stack frame of external procedure asum_read_delete_ops_.  
read_out_message                        internal procedure  shares stack frame of external procedure asum_read_delete_ops_.  
delete_mseg_msg                         internal procedure  shares stack frame of external procedure asum_read_delete_ops_.  
error_return                            internal procedure  shares stack frame of external procedure asum_read_delete_ops_.  
admin_search                            internal procedure  shares stack frame of external procedure asum_read_delete_ops_.  
begin block on line 580                 begin block         shares stack frame of external procedure asum_read_delete_ops_.  
delete_am_entry                         internal procedure  shares stack frame of external procedure asum_read_delete_ops_.  
lock_database                           internal procedure  shares stack frame of external procedure asum_read_delete_ops_.  
unlock_database                         internal procedure  shares stack frame of external procedure asum_read_delete_ops_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
asum_read_delete_ops_    000100 admin_read_info             asum_read_delete_ops_
                         000130 read_info                   asum_read_delete_ops_
                         000172 search                      asum_read_delete_ops_
                         000216 mop                         asum_read_delete_ops_
                         000502 g_message_id                asum_read_delete_ops_
                         000504 g_process_id                asum_read_delete_ops_
                         000505 delete_the_message          asum_read_delete_ops_
                         000506 area_ptr                    asum_read_delete_ops_
                         000510 read_info_ptr               asum_read_delete_ops_
                         000512 code                        asum_read_delete_ops_
                         000514 as_user_message_id          asum_read_delete_ops_
                         000516 as_user_message_system_info_ptr
                                                            asum_read_delete_ops_
                         000520 as_user_message_info_ptr    asum_read_delete_ops_
                         000522 as_user_message_admin_read_info_ptr
                                                            asum_read_delete_ops_
                         000536 delete_by                   delete$$message_id
                         000540 amep                        delete$$message_id
                         000542 hx                          delete$$message_id
                         000552 youngest_message_id         search_table
                         000554 amep                        search_table
                         000556 am_real_message_id          search_table
                         000560 search_real_message_id      search_table
                         000562 x                           search_table
                         000563 message_x                   search_table
                         000602 message_id                  SET_RETURN_INFO_AND_MAYBE_DELETE
                         000612 code                        group_match
                         000622 fx                          read_out_message
                         000624 mseg_ptr                    read_out_message
                         000634 code                        delete_mseg_msg
                         000635 fx                          delete_mseg_msg
                         000636 mseg_ptr                    delete_mseg_msg
                         000654 amep                        admin_search
                         000656 hx                          admin_search
                         000660 min_amep                    admin_search
                         000662 minx                        admin_search
                         000663 temp_am                     admin_search
                         000716 hx                          delete_am_entry
                         000717 q                           delete_am_entry

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             call_ext_out_desc   call_ext_out        return_mac          tra_ext_2
ext_entry           op_freen_           stacq_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
aim_check_$equal              aim_check_$greater_or_equal   asum_error_                   asum_find_segment_
get_group_id_                 get_privileges_               get_process_authorization_    match_star_name_
mseg_$delete_message          mseg_$read_message            set_lock_$lock                set_lock_$unlock

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
asum_data_$db_locked          asum_data_$entry_ring         asum_data_$lock_id            asum_data_$process_id
asum_data_$system_info_ptr    error_table_$bad_arg          error_table_$no_message       error_table_$notalloc
error_table_$unimplemented_version                          mseg_data_$template_operation sys_info$ring1_privilege




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     33 000070       114 000076       117 000115       121 000116       122 000121       123 000125       125 000130
    127 000133       141 000151       142 000154       143 000157       144 000165       146 000173       148 000212
    149 000213       151 000233       153 000236       154 000240       156 000242       158 000245       159 000247
    161 000251       162 000256       164 000270       165 000273       166 000301       168 000315       171 000316
    173 000320       175 000322       176 000323       181 000337       183 000341       186 000405       188 000406
    189 000410       190 000414       192 000415       196 000416       199 000432       200 000433       202 000440
    204 000444       206 000445       208 000447       210 000450       211 000452       214 000453       217 000467
    218 000470       220 000473       222 000477       224 000500       226 000502       229 000503       230 000505
    233 000506       236 000525       237 000526       238 000532       239 000535       241 000540       242 000543
    243 000546       245 000552       248 000560       249 000562       252 000563       253 000564       254 000565
    255 000566       256 000570       257 000574       274 000575       287 000577       288 000601       290 000602
    293 000604       295 000606       297 000612       298 000623       299 000626       301 000631       303 000634
    305 000636       306 000644       307 000646       309 000650       310 000651       312 000653       314 000657
    315 000665       316 000667       317 000671       320 000672       321 000674       324 000675       340 000677
    342 000701       344 000702       345 000704       346 000706       348 000710       349 000721       350 000724
    353 000726       355 000732       357 000755       359 000764       362 000773       365 001000       369 001017
    371 001020       372 001024       373 001026       375 001030       379 001043       380 001044       383 001046
    386 001050       388 001061       390 001071       393 001073       395 001100       397 001123       400 001126
    406 001130       407 001134       408 001137       409 001141       410 001144       411 001147       413 001152
    415 001157       417 001176       418 001205       421 001207       427 001215       433 001217       435 001227
    436 001250       439 001255       446 001257       447 001263       448 001266       449 001270       450 001275
    451 001277       452 001305       453 001312       454 001315       455 001317       456 001321       457 001331
    458 001333       459 001335       460 001353       461 001355       462 001360       463 001363       464 001366
    466 001370       467 001373       468 001375       472 001376       480 001400       481 001404       482 001407
    483 001411       484 001422       485 001427       486 001432       487 001434       488 001436       489 001446
    490 001450       492 001452       493 001465       496 001532       499 001533       504 001535       505 001537
    509 001541       526 001542       533 001550       534 001564       535 001570       536 001601       537 001604
    538 001614       539 001617       540 001622       542 001625       543 001627       545 001631       546 001640
    548 001654       549 001665       550 001670       552 001672       555 001704       558 001712       561 001716
    565 001737       573 001760       574 001761       575 001772       577 002035       580 002040       586 002065
    587 002072       590 002073       591 002077       592 002101       593 002104       594 002107       595 002111
    596 002114       597 002124       598 002125       600 002127       601 002132       604 002133       612 002135
    614 002147       616 002154       617 002164       618 002167       620 002172       623 002173       626 002174
    628 002220       629 002223       632 002224       635 002225       637 002245       638 002247


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
