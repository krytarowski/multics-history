	COMPILATION LISTING OF SEGMENT vfile_io_control
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/04/82  1738.6 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* this routine is used by io_call to support control
       12*   orders issued to vfile_ from command level */
       13 
       14 /* format: style2 */
       15 vfile_io_control:
       16      proc (iocb_ptr, file_base_ptr, io_call_infop, code);
       17 	is_af = "0"b;				/* not active function entry */
       18 mainline:
       19 	brief_sw = "0"b;
       20 	info_ptr = addr (info);
       21 	if (io_call_info.order_name = "get_key") | (io_call_info.order_name = "gk")
       22 	then do;
       23 		substr_sw = "0"b;
       24 		gk_info_ptr = info_ptr;
       25 		unspec (gk_info.flags) = "0"b;
       26 		gk_info.version = gk_info_version_0;
       27 
       28 		do i = 1 to nargs;			/* pick up optional args */
       29 		     if (io_call_info.args (i) = "-substr") | (io_call_info.args (i) = "-su")
       30 		     then if io_call_info.nargs < i + 1
       31 			then go to noarg;
       32 			else do;
       33 				i = i + 1;
       34 				comma_off = index (io_call_info.args (i), ",");
       35 				substr_sw = "1"b;
       36 				if comma_off = 0	/* whole tail wanted */
       37 				then substr_off = fixed (io_call_info.args (i));
       38 				else do;
       39 					substr_off = fixed (substr (io_call_info.args (i), 1, comma_off - 1));
       40 					substr_len = fixed (substr (io_call_info.args (i), comma_off + 1));
       41 				     end;
       42 			     end;
       43 		     else if io_call_info.args (i) = "-head"
       44 						/* next arg is head */
       45 		     then if io_call_info.nargs <= i	/* not enough args */
       46 			then do;
       47 noarg:
       48 				code = error_table_$noarg;
       49 				return;		/* abort */
       50 			     end;
       51 			else do;
       52 				i = i + 1;
       53 handle_head:
       54 				gk_info.input_key = "1"b;
       55 				if gk_info.current
       56 				then go to badarg;	/* -cur_pos and -head conflict */
       57 				gk_info.key_len = length (io_call_info.args (i));
       58 				gk_info.head_size = gk_info.key_len;
       59 				gk_info.key = io_call_info.args (i);
       60 			     end;
       61 		     else if (io_call_info.args (i) = "-desc") | (io_call_info.args (i) = "-ds")
       62 		     then if i = io_call_info.nargs
       63 			then go to noarg;
       64 			else do;
       65 				i = i + 1;
       66 				if gk_info.desc_code = 1
       67 						/* -current descriptor specified */
       68 				then go to badarg;	/* conflicts with given descriptor */
       69 				gk_info.input_desc = "1"b;
       70 				gk_info.descrip = cv_oct_ ((io_call_info.args (i)));
       71 			     end;
       72 		     else if (io_call_info.args (i) = "-reset") | (io_call_info.args (i) = "-rs")
       73 		     then gk_info.reset_pos = "1"b;
       74 		     else if (io_call_info.args (i) = "-current") | (io_call_info.args (i) = "-cur")
       75 		     then if gk_info.input_desc
       76 			then go to badarg;		/* conflicting options */
       77 			else gk_info.desc_code = 1;
       78 		     else if (io_call_info.args (i) = "-rel_type") | (io_call_info.args (i) = "-rel")
       79 		     then if io_call_info.nargs = i
       80 			then go to noarg;
       81 			else do;
       82 				if gk_info.current	/* -cur_pos specified */
       83 				then go to badarg;	/* conflicts */
       84 				i = i + 1;
       85 				gk_info.rel_type = fixed (io_call_info.args (i));
       86 				if (gk_info.rel_type < 0) | (gk_info.rel_type > 2)
       87 				then go to badarg;
       88 			     end;
       89 		     else if io_call_info.args (i) = "-cur_pos"
       90 		     then if gk_info.input_key | (gk_info.rel_type ^= 0)
       91 			then go to badarg;
       92 			else gk_info.current = "1"b;
       93 		     else if (io_call_info.args (i) = "-brief") | (io_call_info.args (i) = "-bf")
       94 		     then brief_sw = "1"b;
       95 		     else if gk_info.input_key	/* head already given */
       96 		     then do;			/* must be an invalid arg */
       97 badarg:
       98 			     code = error_table_$bad_arg;
       99 			     return;
      100 			end;
      101 		     else go to handle_head;
      102 		end;
      103 
      104 		call control ("get_key");
      105 		if substr_sw
      106 		then if comma_off = 0
      107 		     then substr_len = gk_info.key_len + 1 - substr_off;
      108 		     else ;
      109 		else do;
      110 			substr_off = 1;
      111 			substr_len = gk_info.key_len;
      112 		     end;
      113 		substr_len = min (substr_len, gk_info.key_len + 1 - substr_off);
      114 		if is_af
      115 		then if code = 0
      116 		     then do;
      117 			     io_call_af_ret = substr (gk_info.key, substr_off, min (af_returnl, substr_len));
      118 			     return;
      119 			end;
      120 		     else do;
      121 			     io_call_af_ret = "";
      122 			     if brief_sw
      123 			     then do;
      124 brief_ret:
      125 				     if code = 0
      126 				     then return;
      127 				     if (code ^= error_table_$no_operation) & (code ^= error_table_$bad_arg)
      128 				     then code = 0;
      129 				     return;
      130 				end;
      131 			end;
      132 		if brief_sw
      133 		then go to brief_ret;
      134 		if code = 0
      135 		then if substr_sw
      136 		     then call io_call_info.report (substr (gk_info.key, substr_off, substr_len));
      137 		     else call io_call_info.report ("key: ^a
      138 descrip: ^o", gk_info.key, gk_info.descrip);
      139 		return;
      140 	     end;
      141 
      142 	if ((io_call_info.order_name = "read_position") | (io_call_info.order_name = "rp")) & ^is_af
      143 	then do;					/* no input args--just print results */
      144 		call control ("read_position");
      145 		if code = 0
      146 		then call io_call_info.report ("next pos: ^d
      147 end pos: ^d", rp_info.next_pos, rp_info.end_pos);
      148 	     end;
      149 
      150 	else if ((io_call_info.order_name = "record_status") | (io_call_info.order_name = "rs")
      151 		| (io_call_info.order_name = "rsb")) & ^is_af
      152 	then do;
      153 		brief_sw = (io_call_info.order_name = "rsb");
      154 		i = 0;
      155 		if io_call_info.nargs > 0
      156 		then if (io_call_info.args (1) = "-brief") | (io_call_info.args (1) = "-bf")
      157 		     then do;
      158 			     i = 1;
      159 			     brief_sw = "1"b;
      160 			end;
      161 		rs_info_ptr = info_ptr;
      162 		rs_info.version = rs_info_version_2;
      163 		rs_info.record_ptr = null;
      164 		rs_info.ref_count = -1;
      165 		rs_info.modifier = 0;
      166 		rs_info.last_image_modifier = 0;
      167 		if io_call_info.nargs - i >= 1	/* more optional argument given */
      168 		then if io_call_info.args (1 + i) = "-pos"
      169 		     then string (rs_info.flags) = "0000001"b;
      170 						/* locate_pos_sw */
      171 		     else string (rs_info.flags) = substr (bit (io_call_info.args (1 + i)), 1, 7);
      172 		else string (rs_info.flags) = "0"b;
      173 		if rs_info.create_sw		/* two more args required */
      174 		then do;				/* get rec_len and block_size */
      175 			if io_call_info.nargs - i < 2
      176 			then do;
      177 				code = error_table_$noarg;
      178 				return;		/* abort */
      179 			     end;
      180 			rs_info.record_length = fixed (io_call_info.args (2 + i), 21, 0);
      181 						/* length in bytes */
      182 			if nargs = 2 + i		/* max_rec_len not specified, use default */
      183 			then rs_info.max_rec_len = rs_info.record_length;
      184 			else rs_info.max_rec_len = fixed (io_call_info.args (3 + i), 19, 0);
      185 						/* max rec len in bytes */
      186 		     end;
      187 		else if rs_info.locate_sw		/* one additional arg required */
      188 		then if io_call_info.nargs < 2 + i
      189 		     then do;
      190 			     code = error_table_$noarg;
      191 			     return;
      192 			end;
      193 		     else rs_info.descriptor = cv_oct_ ((io_call_info.args (2 + i)));
      194 		else if rs_info.locate_pos_sw
      195 		then if io_call_info.nargs < 2 + i
      196 		     then go to noarg;		/* pos specification required */
      197 		     else do;
      198 			     rs_info.record_length = fixed (io_call_info.args (2 + i));
      199 			     if io_call_info.nargs < 3 + i
      200 			     then rs_info.descriptor = 0;
      201 			     else rs_info.descriptor = cv_oct_ ((io_call_info.args (3 + i)));
      202 			end;
      203 		if rs_info.lock_sw			/* modifier code may be supplied */
      204 		then if rs_info.create_sw & (io_call_info.nargs > 3 + i)
      205 		     then rs_info.modifier = fixed (io_call_info.args (4 + i), 35, 0);
      206 		     else if rs_info.locate_sw & (io_call_info.nargs > 2 + i)
      207 		     then rs_info.modifier = fixed (io_call_info.args (3 + i), 35, 0);
      208 		     else if io_call_info.nargs > 1 + i
      209 		     then rs_info.modifier = fixed (io_call_info.args (2 + i), 35, 0);
      210 		call control ("record_status");
      211 		if brief_sw
      212 		then go to brief_ret;
      213 		if (code ^= 0) & (rs_info.record_ptr = null) & (rs_info.ref_count = -1)
      214 						/* no info returned */
      215 		then return;			/* don't print out a bunch of garbage */
      216 		call io_call_info.report ("record bytes: ^d
      217 max rec bytes: ^d", rs_info.record_length, rs_info.max_rec_len);
      218 		if rs_info.max_rec_len ^= 0		/* block has been allocated */
      219 		then call io_call_info.report ("record ptr: ^p
      220 descriptor: ^o", rs_info.record_ptr, rs_info.descriptor);
      221 		if rs_info.ref_count >= 0		/* more stats to print */
      222 		then do;
      223 			call date_time_ (rs_info.time_last_modified, date_time);
      224 			call io_call_info.report ("ref count: ^d
      225 last changed: ^a", rs_info.ref_count, date_time);
      226 
      227 			if rs_info.modifier ^= 0
      228 			then call io_call_info.report ("modifier: ^d", rs_info.modifier);
      229 			if rs_info.last_image_modifier ^= 0
      230 			then call io_call_info.report ("last modifier: ^d", rs_info.last_image_modifier);
      231 		     end;
      232 	     end;
      233 
      234 	else if ((io_call_info.order_name = "seek_head") | (io_call_info.order_name = "sh")) & ^is_af
      235 	then if io_call_info.nargs < 1		/* one or two are required */
      236 	     then code = error_table_$noarg;
      237 	     else if io_call_info.nargs > 3
      238 	     then code = error_table_$too_many_args;
      239 	     else do;				/* set up info structure */
      240 		     i = 0;
      241 		     if (io_call_info.args (1) = "-brief") | (io_call_info.args (1) = "-bf")
      242 		     then do;
      243 			     i = 1;
      244 			     brief_sw = "1"b;
      245 			end;
      246 		     if io_call_info.nargs = 1 + i	/* use default rel_type=0 */
      247 		     then sh_info.rel_type = 0;
      248 		     else sh_info.rel_type = fixed (io_call_info.args (1 + i), 17, 0);
      249 						/* 0,1, or 2 to
      250*						   indicate =,>=, or > */
      251 		     if (io_call_info.nargs = 3) & ^brief_sw
      252 		     then code = error_table_$bad_arg;
      253 		     else do;
      254 			     sh_info.key_len = length (io_call_info.args (io_call_info.nargs));
      255 						/* length of search key */
      256 			     sh_info.key = io_call_info.args (io_call_info.nargs);
      257 						/* for comparison with key heads */
      258 			     call control ("seek_head");
      259 			end;
      260 		     if brief_sw
      261 		     then go to brief_ret;
      262 		     return;
      263 		end;
      264 
      265 	else if ((io_call_info.order_name = "add_key") | (io_call_info.order_name = "ak")) & ^is_af
      266 	then if io_call_info.nargs < 1		/* one arg required */
      267 	     then code = error_table_$noarg;
      268 	     else do;
      269 		     call get_ak_args;
      270 		     call control ("add_key");
      271 		end;
      272 
      273 	else if ((io_call_info.order_name = "delete_key") | (io_call_info.order_name = "dk")) & ^is_af
      274 	then if io_call_info.nargs >= 1		/* args are optional */
      275 	     then do;
      276 		     call get_ak_args;
      277 		     call control ("delete_key");
      278 		end;
      279 	     else call iox_$control (iocb_ptr, "delete_key", (null), code);
      280 
      281 	else if ((io_call_info.order_name = "reassign_key") | (io_call_info.order_name = "rk")) & ^is_af
      282 	then if io_call_info.nargs < 2		/* two args required */
      283 	     then code = error_table_$noarg;
      284 	     else do;
      285 		     call get_rk_args;
      286 		     call control ("reassign_key");	/* make given key point to current rec */
      287 		end;
      288 
      289 	else if (io_call_info.order_name = "select") | (io_call_info.order_name = "sl")
      290 	then do;
      291 		unspec (common_sl_info.flags) = "0"b;
      292 		common_sl_info.version = sl_info_version_0;
      293 		common_sl_info.desc_arrayp = null;
      294 		if nargs = 0			/* just return status of current subset */
      295 		then do;
      296 			common_sl_info.array_limit = 0;
      297 						/* without tail structure */
      298 			common_sl_info.status_only = "1"b;
      299 		     end;
      300 		else do;
      301 			call process_select_args;
      302 			if code ^= 0
      303 			then go to exit;
      304 			call build_select_info;
      305 		     end;
      306 		call control ("select");
      307 		if is_af
      308 		then do;				/* handle active function reference */
      309 			if (code ^= 0) & (code = error_table_$no_record)
      310 						/* seletion of null set */
      311 			then io_call_af_ret = "-0";	/* special notation for the null set */
      312 			else io_call_af_ret = char (common_sl_info.subset_no);
      313 						/* return the subset number */
      314 			if brief_sw
      315 			then go to brief_ret;	/* see if code should be cleared */
      316 			return;			/* finished with active function evaluation */
      317 		     end;
      318 		if (code = 0) & ^brief_sw
      319 		then call report_subset_status;
      320 		if common_sl_info.output_descriptors & (code = 0)
      321 		then call list_descriptors;		/* frees temporary descriptor array */
      322 		if brief_sw
      323 		then go to brief_ret;
      324 	     end;
      325 
      326 	else if (io_call_info.order_name = "exclude") | (io_call_info.order_name = "ex")
      327 	then if io_call_info.nargs < 1		/* arg required */
      328 	     then code = error_table_$noarg;
      329 	     else do;
      330 		     unspec (common_sl_info.flags) = "0"b;
      331 		     common_sl_info.version = sl_info_version_0;
      332 		     common_sl_info.desc_arrayp = null;
      333 		     call process_select_args;
      334 		     if code ^= 0
      335 		     then go to exit;
      336 		     call build_select_info;
      337 		     call control ("exclude");
      338 		     if is_af
      339 		     then do;
      340 			     if (code ^= 0) & (code = error_table_$no_record)
      341 						/* seletion of null set */
      342 			     then io_call_af_ret = "-0";
      343 						/* special notation for the null set */
      344 			     else io_call_af_ret = char (common_sl_info.subset_no);
      345 						/* return the subset number */
      346 			     if brief_sw
      347 			     then go to brief_ret;
      348 			     return;
      349 			end;
      350 		     if (code = 0) & ^brief_sw
      351 		     then call report_subset_status;
      352 		     if common_sl_info.output_descriptors & (code = 0)
      353 		     then call list_descriptors;
      354 		     if brief_sw
      355 		     then go to brief_ret;
      356 		end;
      357 
      358 	else if is_af				/* called as an active function */
      359 	then do;					/* error -- not permitted for any of the following orders */
      360 		code = error_table_$no_operation;
      361 		return;
      362 	     end;
      363 	else if (io_call_info.order_name = "tr") /* no info struc required */ | (io_call_info.order_name = "tc")
      364 	then call control ("truncate");
      365 
      366 	else if (io_call_info.order_name = "max_rec_len") | (io_call_info.order_name = "mx")
      367 	then do;					/* takes one optional arg */
      368 		if io_call_info.nargs >= 1		/* arg present */
      369 		then mx_info.new_max_recl = fixed (io_call_info.args (1), 21, 0);
      370 		else mx_info.new_max_recl = 0;	/* indicates no chanfge */
      371 		call control ("max_rec_len");
      372 		if code = 0
      373 		then call io_call_info.report ("old max recl: ^d", mx_info.old_max_recl);
      374 	     end;
      375 
      376 	else if (io_call_info.order_name = "error_status") | (io_call_info.order_name = "er")
      377 	then do;					/* no inputs--print results */
      378 		er_info.version = 1;		/* only version supported */
      379 		call control ("error_status");
      380 		if code = 0
      381 		then if er_info.error_type = 0
      382 		     then call io_call_info.error (0, io_call_info.caller_name, "no errors");
      383 		     else call io_call_info.report ("requested: ^d
      384 received: ^d", er_info.requested, er_info.received);
      385 	     end;
      386 
      387 	else if (io_call_info.order_name = "min_block_size") | (io_call_info.order_name = "mb")
      388 	then do;
      389 		if io_call_info.nargs < 1
      390 		then do;
      391 			mb_info.min_cap = 0;
      392 			mb_info.min_res = 0;
      393 		     end;
      394 		else mb_info.min_res = fixed (io_call_info.args (1), 17, 0);
      395 		if io_call_info.nargs < 2
      396 		then mb_info.min_cap = 0;
      397 		else mb_info.min_cap = fixed (io_call_info.args (2), 21, 0);
      398 		call control ("min_block_size");
      399 	     end;
      400 
      401 	else if (io_call_info.order_name = "set_wait_time") | (io_call_info.order_name = "sw")
      402 	then if io_call_info.nargs < 1
      403 	     then code = error_table_$noarg;
      404 	     else do;
      405 		     if io_call_info.nargs = 1
      406 		     then new_wait_time = float (io_call_info.args (1));
      407 		     else if (io_call_info.args (1) = "-cdtm") | (io_call_info.args (1) = "-collection_delay_time")
      408 		     then do;
      409 			     wt_info.version = -2;
      410 			     wt_info.collection_delay_time = float (io_call_info.args (2));
      411 			end;
      412 		     else do;
      413 			     code = error_table_$too_many_args;
      414 			     return;
      415 			end;
      416 		     call control ("set_wait_time");
      417 		end;
      418 
      419 	else if (io_call_info.order_name = "set_file_lock") | (io_call_info.order_name = "sf")
      420 	then if io_call_info.nargs < 1
      421 	     then code = error_table_$noarg;
      422 	     else do;
      423 		     set_lock_flag = bit (io_call_info.args (1), 2);
      424 		     call control ("set_file_lock");
      425 		end;
      426 
      427 	else if (io_call_info.order_name = "file_status") | (io_call_info.order_name = "fs")
      428 	then call vfile_status$print_ (iocb_ptr, file_base_ptr, io_call_info.report, code);
      429 	else call control ((io_call_info.order_name));	/* no info struc */
      430 
      431 	return;					/* end of vfile_io_control main routine */
      432 
      433 af:
      434      entry (iocb_ptr, file_base_ptr, io_call_infop, code);
      435 	is_af = "1"b;
      436 	go to mainline;				/* let each order do it's thing */
      437 
      438 control:
      439      proc (order_arg);				/* passes order call through iox_ */
      440 	call iox_$control (iocb_ptr, (order_arg), addr (info), code);
      441 	dcl     order_arg		 char (24) var;
      442      end control;
      443 
      444 get_ak_args:
      445      proc;					/*  picks up optional key and descrip */
      446 	ak_info_ptr = info_ptr;
      447 	if nargs = 1
      448 	then do;					/* use default switch settings--adding key to current */
      449 		string (ak_info.flags) = "10"b;	/* just input key */
      450 		ak_info.key_len = length (io_call_info.args (1));
      451 		ak_info.key = io_call_info.args (1);
      452 		return;
      453 	     end;
      454 	string (ak_info.flags) = bit (io_call_info.args (1));
      455 	if ak_info.input_key & ak_info.input_desc & (io_call_info.nargs < 3)
      456 	then do;					/* error */
      457 noarg:
      458 		code = error_table_$noarg;
      459 		go to exit;
      460 	     end;
      461 	if ak_info.input_key
      462 	then do;					/* pick up key arg */
      463 		ak_info.key_len = length (io_call_info.args (2));
      464 		ak_info.key = io_call_info.args (2);
      465 		if ak_info.input_desc		/* descrip also given */
      466 		then ak_info.descrip = cv_oct_ ((io_call_info.args (3)));
      467 	     end;
      468 	else ak_info.descrip = cv_oct_ ((io_call_info.args (2)));
      469 	return;					/* end of get_ak_args routine */
      470 
      471 get_rk_args:
      472      entry;					/* picks up optional args for "reassign_key" order */
      473 	rk_info_ptr = info_ptr;
      474 	string (rk_info.flags) = bit (io_call_info.args (1));
      475 	if rk_info.input_key
      476 	then do;					/* pick up key arg */
      477 		rk_info.key_len = length (io_call_info.args (2));
      478 		rk_info.key = io_call_info.args (2);
      479 		if io_call_info.nargs < 3		/* at least one more arg required */
      480 		then go to noarg;			/* error */
      481 		if rk_info.input_old_desc
      482 		then do;				/* may be two more args */
      483 			rk_info.old_descrip = cv_oct_ ((io_call_info.args (3)));
      484 			if rk_info.input_new_desc	/* yes--there is another arg */
      485 			then if io_call_info.nargs < 4
      486 			     then go to noarg;
      487 			     else rk_info.new_descrip = cv_oct_ ((io_call_info.args (4)));
      488 		     end;
      489 		else rk_info.new_descrip = cv_oct_ ((io_call_info.args (3)));
      490 	     end;
      491 	else if rk_info.input_old_desc
      492 	then do;
      493 		rk_info.old_descrip = cv_oct_ ((io_call_info.args (2)));
      494 		if rk_info.input_new_desc
      495 		then if io_call_info.nargs < 3
      496 		     then go to noarg;
      497 		     else rk_info.new_descrip = cv_oct_ ((io_call_info.args (3)));
      498 	     end;
      499 	else rk_info.new_descrip = cv_oct_ ((io_call_info.args (2)));
      500 	return;					/* end of get_rk_args routine */
      501      end get_ak_args;
      502 
      503 process_select_args:
      504      proc;					/* builds info structure elements for "select" order */
      505 	sl_array_limit = 0;
      506 	i = 1;
      507 	if is_bf_or_ls_opt ()
      508 	then do;
      509 		i = 2;
      510 		if io_call_info.nargs = 1
      511 		then do;
      512 			common_sl_info.status_only = "1"b;
      513 			return;
      514 		     end;
      515 	     end;
      516 	common_sl_info.status_only = "0"b;
      517 	if (io_call_info.args (i) = "-reset") | (io_call_info.args (i) = "-rs")
      518 	then do;
      519 		common_sl_info.list_type = 0;		/* indicates re-selection */
      520 		if nargs > i
      521 		then common_sl_info.subset_no = fixed (io_call_info.args (i + 1));
      522 		else common_sl_info.subset_no = 0;	/* default is identity subset */
      523 		common_sl_info.array_limit = 0;	/* smallest info structure supported */
      524 		return;				/* done processing args */
      525 	     end;
      526 	common_sl_info.list_type = 1;
      527 	if io_call_info.args (io_call_info.nargs) = "-delete_old_subsets" | io_call_info.args (io_call_info.nargs) = "-dos"
      528 	then common_sl_info.delete_old_subsets = "1"b;
      529 
      530 	if (io_call_info.args (i) = "-or") | /* wants default delimiter */ (io_call_info.args (i) = "-or_key")
      531 	     | (io_call_info.args (i) = "-ork")
      532 	then do;
      533 		default_delim = io_call_info.args (i);
      534 		if default_delim = "-or_key"
      535 		then default_delim = "-ork";
      536 		i = i + 1;
      537 		if i > nargs
      538 		then go to no_arg;
      539 	     end;
      540 	else default_delim = "";
      541 	if (default_delim = "") & ((io_call_info.args (i) = "-desc") | (io_call_info.args (i) = "-ds"))
      542 	then do;
      543 		call build_array;
      544 		return;
      545 	     end;
      546 	if (default_delim = "") | (default_delim = "-or")
      547 	then if io_call_info.args (i) = "-head"
      548 	     then do;
      549 		     i = i + 1;			/* advance to next arg */
      550 		     head = "1"b;			/* list of intervals representation */
      551 		end;
      552 	     else if io_call_info.args (i) = "-key"
      553 	     then do;
      554 		     i = i + 1;
      555 		     head = "0"b;			/* first interval must match key exactly */
      556 		end;
      557 	     else head = "1"b;
      558 	else head = "0"b;
      559 
      560 	do int = 1 to max_int;			/* for each index interval specified */
      561 	     len = length (io_call_info.args (i));
      562 	     f_head.length (int) = len;
      563 	     f_head.kptr (int) = addrel (addr (io_call_info.args (i)), 1);
      564 	     i = i + 1;
      565 	     if i > nargs - bin (common_sl_info.delete_old_subsets)
      566 	     then do;
      567 		     if head
      568 		     then l_head.length (int) = len;
      569 		     else l_head.length (int) = -1;	/* by convention, indicates exact key match */
      570 		     l_head.kptr (int) = f_head.kptr (int);
      571 		     return;
      572 		end;
      573 	     if (default_delim = "")
      574 		& ((io_call_info.args (i) = "-or") | (io_call_info.args (i) = "-ork")
      575 		| (io_call_info.args (i) = "-or_key"))
      576 	     then do;
      577 		     i = i + 1;
      578 new_int:
      579 		     if head
      580 		     then l_head.length (int) = len;
      581 		     else l_head.length (int) = -1;
      582 		     l_head.kptr (int) = f_head.kptr (int);
      583 		     if (default_delim = "-or") | ((default_delim ^= "-ork") & (io_call_info.args (i - 1) = "-or"))
      584 		     then head = "1"b;
      585 		     else head = "0"b;
      586 		     if i > nargs
      587 		     then do;
      588 no_arg:
      589 			     code = error_table_$noarg;
      590 			     return;
      591 			end;
      592 		end;
      593 	     else if (default_delim ^= "-ork") & ((io_call_info.args (i) = "-thru") | (io_call_info.args (i) = "-to"))
      594 	     then if ^head
      595 		then do;				/* error-- "-thru" not allowed with key match spec */
      596 bad_arg:
      597 			code = error_table_$bad_arg;
      598 			return;			/* abort */
      599 		     end;
      600 		else do;
      601 			i = i + 1;
      602 			if i > nargs
      603 			then go to no_arg;
      604 			len = length (io_call_info.args (i));
      605 			if io_call_info.args (i - 1) = "-to"
      606 						/* open ended interval */
      607 			then l_head.length (int) = -len;
      608 						/* convention for indicating open interval */
      609 			else l_head.length (int) = len;
      610 						/* inclusive interval */
      611 			l_head.kptr (int) = addrel (addr (io_call_info.args (i)), 1);
      612 			i = i + 1;
      613 			if i > nargs
      614 			then return;
      615 			if (default_delim = "")
      616 			     & ((io_call_info.args (i) ^= "-or") & (io_call_info.args (i) ^= "-ork")
      617 			     & (io_call_info.args (i) ^= "-or_key"))
      618 			then go to bad_arg;
      619 			if default_delim = ""
      620 			then i = i + 1;
      621 			if i > nargs
      622 			then go to no_arg;
      623 		     end;
      624 	     else if default_delim = ""
      625 	     then go to bad_arg;
      626 	     else go to new_int;
      627 	end;					/* end of arg pick-up loop */
      628 
      629 	code = error_table_$too_many_args;
      630      end process_select_args;
      631 
      632 report_subset_status:
      633      proc;
      634 	call io_call_info.report ("subset: ^d ,records: ^d", common_sl_info.subset_no, common_sl_info.count);
      635      end report_subset_status;
      636 
      637 list_descriptors:
      638      proc;					/* prints list of octal descriptors and frees list allocation */
      639 
      640 	do i = 1 to common_sl_info.count;		/* loop through array elements */
      641 	     call io_call_info.report ("^o", common_sl_info.desc_arrayp -> desc_array (i));
      642 	end;
      643 
      644 	free common_sl_info.desc_arrayp -> desc_array;
      645      end list_descriptors;
      646 
      647 is_bf_or_ls_opt:
      648      proc returns (bit (1) aligned);
      649 	if (io_call_info.args (i) = "-brief") | (io_call_info.args (i) = "-bf")
      650 	then do;
      651 		brief_sw = "1"b;
      652 		return ("1"b);
      653 	     end;
      654 	if (io_call_info.args (i) = "-list") | (io_call_info.args (i) = "-ls")
      655 	then do;
      656 		common_sl_info.output_descriptors = "1"b;
      657 		return ("1"b);
      658 	     end;
      659 	return ("0"b);
      660      end is_bf_or_ls_opt;
      661 
      662 build_select_info:
      663      proc;					/* prepares info structure for select or exclude */
      664 	if common_sl_info.list_type ^= 1
      665 	then return;				/* no tail structure required */
      666 	common_sl_info.array_limit = int;
      667 	if size (hi_sl_info) > max_info_size
      668 	then do;					/* implementation limit */
      669 		code = error_table_$too_many_args;
      670 		go to exit;
      671 	     end;
      672 
      673 	do i = 1 to int;
      674 	     hi_sl_info.interval (i) = temp_int (i);
      675 	end;
      676 
      677 	dcl     i			 fixed;
      678      end build_select_info;
      679 
      680 build_array:
      681      proc;					/* prepares info structure for descriptor list */
      682 	common_sl_info.list_type = 2;			/* code for descriptor array specification */
      683 	common_sl_info.array_limit = nargs - i;		/* prev arg was -ds or -desc */
      684 	if size (da_sl_info) > max_info_size		/* implementation limit--should do allocation if necessary */
      685 	then do;					/* cop out solution--eventually do this better */
      686 		code = error_table_$too_many_args;
      687 		go to exit;			/* abort */
      688 	     end;
      689 
      690 	do n = i + 1 to nargs;			/* pick up descriptor args */
      691 	     da_sl_info.desc_array (n - i) = cv_oct_ ((io_call_info.args (n)));
      692 	end;
      693 
      694 	dcl     n			 fixed;
      695      end build_array;
      696 
      697 exit:
      698 	return;					/* external exit */
      699 
      700 	dcl     iocb_ptr		 ptr;
      701 	dcl     is_af		 bit (1) aligned;
      702 	dcl     brief_sw		 bit (1) aligned;
      703 	dcl     (i, len)		 fixed;
      704 	dcl     info_ptr		 ptr;
      705 	dcl     vfile_status$print_	 entry (ptr, ptr, entry options (variable), fixed (35));
      706 	dcl     date_time_		 entry (fixed (71), char (*));
      707 	dcl     date_time		 char (24);
      708 	dcl     file_base_ptr	 ptr;
  1     1 /* include file for info structure used with record_status control order
  1     2*   created by M. Asherman 1/6/76 */
  1     3 /* modified 6/15/77 to support stationary type records */
  1     4 
  1     5      dcl	   rs_info_ptr	      ptr;
  1     6      dcl	   1 rs_info	      based (rs_info_ptr) aligned,
  1     7 	     2 version	      fixed,		/* must be set to 1 or 2 (Input) */
  1     8 	     2 flags	      aligned,
  1     9 	       3 lock_sw	      bit (1) unal,		/* Input -- if ="1"b  try to lock record */
  1    10 	       3 unlock_sw	      bit (1) unal,		/* Input -- if ="1"b try to unlock record */
  1    11 	       3 create_sw	      bit (1) unal,		/* Input--if set creat new record */
  1    12 	       3 locate_sw	      bit (1) unal,		/* Input--if set causes current rec to be
  1    13*						   located outside the index by descrip, or created without key */
  1    14 	       3 inc_ref_count    bit (1) unal,		/* Input--bump reference count of record, if stationary */
  1    15 	       3 dec_ref_count    bit (1) unal,		/* Input--decrement ref count if this flag set and record stationary */
  1    16 	       3 locate_pos_sw    bit (1) unal,		/* Input--if set the record_length is taken
  1    17*						   as an input argument specifying the absolute logical record positioni	  to which both the current and next positions will be set */
  1    18 	       3 mbz1	      bit (29) unal,	/* must be set to "0"b, reserved for future use */
  1    19 	     2 record_length      fixed (21),		/* length in bytes, Input if create_sw set */
  1    20 	     2 max_rec_len	      fixed (21),		/* max length of contained record
  1    21*						   Input if create_sw is set--overrides min_block_size in effect */
  1    22 	     2 record_ptr	      ptr,		/* points to first byte of record--will be word aligned */
  1    23 	     2 descriptor	      fixed (35),		/* Input if locate_sw set and create_sw="0"b */
  1    24 	     2 ref_count	      fixed (34),		/* Output--should match number of keys on this record-- = -1 if non-stationary record */
  1    25 	     2 time_last_modified fixed (71),		/* Output */
  1    26 	     2 modifier	      fixed (35),		/* Output--also Input when locking */
  1    27 	     2 block_ptr	      ptr unal,		/* Output */
  1    28 	     2 last_image_modifier
  1    29 			      fixed (35),
  1    30 	     2 mbz2	      fixed;
  1    31 
  1    32      dcl	   1 rs_desc	      based (addr (rs_info.descriptor)),
  1    33 						/* record block descriptor structure */
  1    34 	     2 comp_num	      fixed (17) unal,	/* msf component number */
  1    35 	     2 offset	      bit (18) unal;	/* word offset of record block */
  1    36 
  1    37      dcl	   1 seq_desc	      based (addr (rs_info.descriptor)),
  1    38 						/* for sequential files */
  1    39 	     2 bitno	      bit (6) unal,
  1    40 	     2 comp_num	      fixed (11) unal,	/* msf component number */
  1    41 	     2 wordno	      bit (18) unal;	/* word offset */
  1    42 
  1    43      dcl	   rs_info_version_1      static internal fixed init (1);
  1    44      dcl	   rs_info_version_2      static internal fixed init (2);
  1    45 
      709 
  2     1 /* Begin include file ..... io_call_info.incl.pl1 */
  2     2 
  2     3 /* This include file defines the info_structure used by an I/O module to perform an "io_call" order
  2     4*   on behalf of the io_call command. */
  2     5 /* Coded April 1976 by Larry Johnson */
  2     6 /* Changed June 1977 by Larry Johnson for "io_call_af" order */
  2     7 
  2     8      dcl	   io_call_infop	      ptr;
  2     9 
  2    10      dcl	   1 io_call_info	      aligned based (io_call_infop),
  2    11 	     2 version	      fixed bin,
  2    12 	     2 caller_name	      char (32),		/* Caller name for error messages */
  2    13 	     2 order_name	      char (32),		/* Actual name of the order to be performed */
  2    14 	     2 report	      entry variable options (variable),
  2    15 						/* Entry to ioa_ like procedure to report results */
  2    16 	     2 error	      entry variable options (variable),
  2    17 						/* Entry to com_err_ like procedure to report results */
  2    18 	     2 af_returnp	      ptr,		/* Pointer to return string if "io_call_af"  order */
  2    19 	     2 af_returnl	      fixed bin,		/* Length of string */
  2    20 	     2 fill	      (5) bit (36) aligned,
  2    21 	     2 nargs	      fixed bin,		/* Number of additional command arguments provided */
  2    22 	     2 max_arglen	      fixed bin,		/* Length of longest argument (used to define array) */
  2    23 	     2 args	      (0 refer (io_call_info.nargs)) char (0 refer (io_call_info.max_arglen)) varying;
  2    24 
  2    25      dcl	   io_call_af_ret	      char (io_call_info.af_returnl) based (io_call_info.af_returnp) varying;
  2    26 						/* Return string for active function */
  2    27 
  2    28 /* End include file ..... io_call_info.incl.pl1 */
      710 
      711 	dcl     code		 fixed (35);
      712 	dcl     (char, fixed, unspec, string, length, addr, null, size)
      713 				 builtin;
  3     1 /* Include File of error codes used by vfile_ and related programs */
  3     2 /* Created by M. Asherman 5/20/78 */
  3     3      dcl	   (error_table_$no_key, error_table_$file_busy, error_table_$segknown, error_table_$not_open, error_table_$noentry,
  3     4 	   error_table_$no_file, error_table_$no_record, error_table_$not_detached, error_table_$not_closed,
  3     5 	   error_table_$noarg, error_table_$too_many_args, error_table_$bad_file, error_table_$end_of_info,
  3     6 	   error_table_$invalid_lock_reset, error_table_$lock_wait_time_exceeded, error_table_$last_reference,
  3     7 	   error_table_$higher_inconsistency, error_table_$record_busy, error_table_$no_room_for_lock,
  3     8 	   error_table_$lock_is_invalid, error_table_$unimplemented_version, error_table_$lock_not_locked,
  3     9 	   error_table_$key_duplication, error_table_$bad_processid, error_table_$bad_arg,
  3    10 	   error_table_$locked_by_this_process, error_table_$no_operation, error_table_$asynch_insertion,
  3    11 	   error_table_$asynch_change, error_table_$too_many_refs, error_table_$asynch_deletion, error_table_$long_record,
  3    12 	   error_table_$file_is_full, error_table_$key_order)
  3    13 			      external fixed (35);
  3    14 						/* end of vfile_ error code include file */
      714 
      715 	dcl     iox_$control	 entry (ptr, char (*), ptr, fixed (35));
      716 	dcl     max_info_size	 static fixed internal options (constant) init (200);
      717 	dcl     1 wt_info		 based (addr (info)),
      718 		2 version		 float,
      719 		2 collection_delay_time
      720 				 float;
      721 	dcl     1 info,				/* large enough for any vfile_ supported info struc */
      722 		2 words		 (max_info_size) fixed;
      723 						/* largest info structure */
      724 	dcl     1 sh_info		 based (addr (info)),
      725 						/* for "seek_head" */
      726 		2 rel_type	 fixed,		/* 0,1, or 2 for =,>=, or > */
      727 		2 key_len		 fixed,		/* length of search key below */
      728 		2 key		 char (256);	/* compared with key heads in file */
      729 	dcl     1 rp_info		 based (addr (info)),
      730 						/* for "read_position" */
      731 		2 next_pos	 fixed (34),	/* abs position of next byte or record */
      732 		2 end_pos		 fixed (34);	/* total count of bytes or records in file */
      733 	dcl     1 mx_info		 based (addr (info)),
      734 						/* for "max_rec_len" */
      735 		2 old_max_recl	 fixed (21),	/* output */
      736 		2 new_max_recl	 fixed (21);	/* input--zero indicates no change */
      737 	dcl     1 er_info		 based (addr (info)),
      738 						/* for "error_status" */
      739 		2 version		 fixed,		/* (Input) must=1 */
      740 		2 error_type	 fixed,		/* only one currently supported */
      741 		2 requested	 fixed (34),	/* position skip arg issued on call */
      742 		2 received	 fixed (34);	/* successful skips actually made */
      743 	dcl     1 mb_info		 based (addr (info)),
      744 						/* for "min_block_size" */
      745 		2 min_res		 fixed (21),
      746 		2 min_cap		 fixed (21);	/* minimum allocation for record block */
      747 	dcl     new_wait_time	 float based (addr (info));
      748 	dcl     set_lock_flag	 bit (2) aligned based (addr (info));
      749 	dcl     cv_oct_		 entry (char (*)) returns (fixed (35));
  4     1 /* ak_info -- include file for info structures used by the following vfile_
  4     2*   control orders: "add_key", "delete_key", "get_key", and "reassign_key".
  4     3*   Created by M. Asherman 3/23/76
  4     4*   Modified 5/13/77 to add separate gk_info structure */
  4     5 
  4     6      dcl	   1 ak_info	      based (ak_info_ptr),
  4     7 	     2 header	      like ak_header,
  4     8 	     2 key	      char (ak_key_len refer (ak_info.header.key_len));
  4     9 
  4    10      dcl	   1 ak_header	      based (ak_info_ptr),
  4    11 	     2 flags	      aligned,
  4    12 	       3 input_key	      bit (1) unal,		/* set if key is input arg */
  4    13 	       3 input_desc	      bit (1) unal,		/* set if descriptor is an input arg */
  4    14 	       3 mbz	      bit (34) unal,	/* not used for the present */
  4    15 	     2 descrip	      fixed (35),		/* record designator */
  4    16 	     2 key_len	      fixed;
  4    17 
  4    18      dcl	   ak_info_ptr	      ptr;
  4    19      dcl	   ak_key_len	      fixed;
  4    20 
  4    21 
  4    22      dcl	   1 rk_info	      based (rk_info_ptr),
  4    23 	     2 header	      like rk_header,
  4    24 	     2 key	      char (rk_key_len refer (rk_info.header.key_len));
  4    25 
  4    26      dcl	   1 rk_header	      based (rk_info_ptr),
  4    27 	     2 flags	      aligned,
  4    28 	       3 input_key	      bit (1) unal,		/* same as above */
  4    29 	       3 input_old_desc   bit (1) unal,		/* set if specified entry has initial descrip
  4    30*						   given by old_descrip */
  4    31 	       3 input_new_desc   bit (1) unal,		/* set if new val for descrip is input in this struc */
  4    32 	       3 mbz	      bit (33) unal,
  4    33 	     2 old_descrip	      fixed (35),		/* used if first flag is set */
  4    34 	     2 new_descrip	      fixed (35),		/* used only if second flag is set */
  4    35 	     2 key_len	      fixed;
  4    36 
  4    37      dcl	   rk_info_ptr	      ptr;
  4    38      dcl	   rk_key_len	      fixed;
  4    39 
  4    40 
  4    41      dcl	   1 gk_info	      based (gk_info_ptr),	/* structure for get_key order */
  4    42 	     2 header	      like gk_header,
  4    43 	     2 key	      char (gk_key_len refer (gk_info.header.key_len));
  4    44 						/* may be Input as well as Output */
  4    45 
  4    46      dcl	   1 gk_header	      based (gk_info_ptr),
  4    47 	     2 flags	      aligned,
  4    48 	       3 input_key	      bit (1) unal,		/* if set, use key in this structure */
  4    49 	       3 input_desc	      bit (1) unal,		/* if set, descriptor given in this structure */
  4    50 	       3 desc_code	      fixed (2) unal,	/* 0=any, 1=current -- applies when input_desc="0"b */
  4    51 	       3 position_specification
  4    52 			      unal,
  4    53 	         4 current	      bit (1) unal,		/* otherwise next */
  4    54 	         4 rel_type	      fixed (2) unal,	/* as in seek_head, if input_key = "1"b */
  4    55 	         4 head_size      fixed bin (9) unsigned unaligned,
  4    56 						/* size of head for initial seek */
  4    57 	       3 reset_pos	      bit (1) unal,		/* if set, final position unchanged by this operation */
  4    58 	       3 pad	      bit (8) unal,
  4    59 	       3 version	      fixed (8) unal,
  4    60 	     2 descrip	      fixed (35),		/* Output, except when input_desc="1"b */
  4    61 	     2 key_len	      fixed;		/* Input when input_key="1"b, also Output in all cases */
  4    62 
  4    63      dcl	   gk_info_ptr	      ptr;
  4    64      dcl	   gk_key_len	      fixed;
  4    65 
  4    66      dcl	   gk_info_version_0      internal static fixed options (constant) init (0);
  4    67 
  4    68 /* end ak_info.incl.pl1 */
      750 
  5     1 /* Include file for vfile_ control orders dealing with key ranges in indexed files */
  5     2 /* created by M. Asherman 4/7/77
  5     3*Modified:
  5     4*12/18/80  by  Lindsey Spratt: Add the delete_old_subsets bit.
  5     5**/
  5     6 
  5     7 /* format: style2 */
  5     8      dcl	   1 common_sl_info	      based (info_ptr),	/* info structure for select and exclude orders */
  5     9 	     2 flags	      aligned,		/* Input */
  5    10 	       3 list_type	      fixed (3) unal,	/* code identifies format of tail structure */
  5    11 	       3 status_only      bit (1) unal,		/* if set, subset info is returned, but current subset stays the same */
  5    12 	       3 output_descriptors
  5    13 			      bit (1) unal,		/* if set, resulting descriptor list is returned */
  5    14 	       3 delete_old_subsets
  5    15 			      bit (1) unal,		/* if set, causes all of the existing subsets on this switch to be deleted. */
  5    16 	       3 mbz	      bit (11) unal,	/* must be zero--in case of extensions */
  5    17 	       3 version	      fixed (17) unal,	/* current info version */
  5    18 	     2 array_limit	      fixed,		/* upper bound of array in tail of info structure */
  5    19 	     2 subset_no	      fixed,		/* identifies temporary subset-- Output */
  5    20 	     2 count	      fixed (34),		/* Output--number of distinct descrips */
  5    21 	     2 desc_arrayp	      ptr;		/* pointer to resulting array of descriptors */
  5    22 
  5    23 /* descriptor array generated if requested */
  5    24      dcl	   desc_array	      (1:common_sl_info.count) based (common_sl_info.desc_arrayp);
  5    25 
  5    26 /* this format allows specification in terms of index intervals defined by two heads or one key */
  5    27      dcl	   1 hi_sl_info	      based (info_ptr),	/* structure for list_type = 1 */
  5    28 	     2 common	      like common_sl_info,
  5    29 	     2 interval	      (1:sl_array_limit refer (hi_sl_info.array_limit)),
  5    30 	       3 first_head,
  5    31 	         4 length	      fixed,
  5    32 	         4 kptr	      ptr unal,
  5    33 	       3 last_head,
  5    34 	         4 length	      fixed,		/* if negative, this interval is defined by match with key */
  5    35 	         4 kptr	      ptr unal;
  5    36 
  5    37 /* format for specification in terms of an array of descriptors */
  5    38      dcl	   1 da_sl_info	      based (info_ptr),	/* list_type=2 */
  5    39 	     2 common	      like common_sl_info,
  5    40 	     2 desc_array	      (1:sl_array_limit refer (da_sl_info.array_limit)) fixed (35);
  5    41 
  5    42      dcl	   sl_array_limit	      fixed;
  5    43      dcl	   sl_info_version_0      static options (constant) internal fixed init (0);
  5    44 
  5    45 /* list_type=0 denotes reselection of a single, previously defined subset (no tail structure) */
      751 
      752 	dcl     int		 fixed;
      753 	dcl     1 temp_int		 (1:max_int),
      754 		2 f_head,
      755 		  3 length	 fixed,
      756 		  3 kptr		 ptr,
      757 		2 l_head,
      758 		  3 length	 fixed,
      759 		  3 kptr		 ptr;
      760 	dcl     max_int		 static fixed options (constant) init (50);
      761 	dcl     head		 bit (1) aligned;
      762 	dcl     default_delim	 char (8) aligned;
      763 	dcl     comma_off		 fixed;
      764 	dcl     substr_off		 fixed;
      765 	dcl     substr_len		 fixed;
      766 	dcl     substr_sw		 bit (1) aligned;
      767      end vfile_io_control;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/82  1620.4  vfile_io_control.pl1              >dumps>old>recomp>vfile_io_control.pl1
709          1    07/19/79  1547.0  rs_info.incl.pl1                  >ldd>include>rs_info.incl.pl1
710          2    07/19/79  1547.1  io_call_info.incl.pl1             >ldd>include>io_call_info.incl.pl1
714          3    07/19/79  1547.0  vfile_error_codes.incl.pl1        >ldd>include>vfile_error_codes.incl.pl1
750          4    07/19/79  1547.0  ak_info.incl.pl1                  >ldd>include>ak_info.incl.pl1
751          5    07/31/81  1818.2  select_info.incl.pl1              >ldd>include>select_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
addr                                                   builtin function         dcl 712 ref 20 145 145 246 248 254 256 368 370 372
                                                                                  378 380 383 383 391 392 394 395 397 405 409 410
                                                                                  423 440 440 563 611
af_returnl               34            based           fixed bin(17,0)          level 2 dcl 2-10 ref 117 117 121 309 312 340 344
af_returnp               32            based           pointer                  level 2 dcl 2-10 ref 117 121 309 312 340 344
ak_header                              based           structure                level 1 unaligned dcl 4-10
ak_info                                based           structure                level 1 unaligned dcl 4-6
ak_info_ptr                     000116 automatic       pointer                  dcl 4-18 set ref 446* 449 450 451 454 455 455 461
                                                                                  463 464 465 465 468
args                     44            based           varying char             array level 2 dcl 2-10 set ref 29 29 34 36 39 40 43
                                                                                  57 59 61 61 70 72 72 74 74 78 78 85 89 93 93 155
                                                                                  155 167 171 180 184 193 198 201 203 206 208 241
                                                                                  241 248 254 256 368 394 397 405 407 407 410 423
                                                                                  450 451 454 463 464 465 468 474 477 478 483 487
                                                                                  489 493 497 499 517 517 520 527 527 530 530 530
                                                                                  533 541 541 546 552 561 563 573 573 573 583 593
                                                                                  593 604 605 611 615 615 615 649 649 654 654 691
array_limit               1            based           fixed bin(17,0)          level 2 dcl 5-8 set ref 296* 523* 666* 683*
brief_sw                        000101 automatic       bit(1)                   dcl 702 set ref 18* 93* 122 132 153* 159* 211 244*
                                                                                  251 260 314 318 322 346 350 354 651*
caller_name               1            based           char(32)                 level 2 dcl 2-10 set ref 380*
char                                                   builtin function         dcl 712 ref 312 344
code                                   parameter       fixed bin(35,0)          dcl 711 set ref 15 47* 97* 114 124 127 127 127* 134
                                                                                  145 177* 190* 213 234* 237* 251* 265* 279* 281*
                                                                                  302 309 309 318 320 326* 334 340 340 350 352 360*
                                                                                  372 380 401* 413* 419* 427* 433 440* 457* 588*
                                                                                  596* 629* 669* 686*
collection_delay_time
                          1            based           float bin(27)            level 2 dcl 717 set ref 410*
comma_off                       000132 automatic       fixed bin(17,0)          dcl 763 set ref 34* 36 39 40 105
common_sl_info                         based           structure                level 1 unaligned dcl 5-8
count                     3            based           fixed bin(34,0)          level 2 dcl 5-8 set ref 634* 640 644
create_sw                 1(02)        based           bit(1)                   level 3 packed unaligned dcl 1-6 set ref 173 203
current                   0(05)        based           bit(1)                   level 5 packed unaligned dcl 4-41 set ref 55 82 92*
cv_oct_                         000030 constant        entry                    external dcl 749 ref 70 193 201 465 468 483 487 489
                                                                                  493 497 499 691
da_sl_info                             based           structure                level 1 unaligned dcl 5-38 set ref 684
date_time                       000106 automatic       char(24)                 unaligned dcl 707 set ref 223* 224*
date_time_                      000012 constant        entry                    external dcl 706 ref 223
default_delim                   000130 automatic       char(8)                  dcl 762 set ref 533* 534 534* 540* 541 546 546 573
                                                                                  583 583 593 615 619 624
delete_old_subsets        0(06)        based           bit(1)                   level 3 packed unaligned dcl 5-8 set ref 527* 565
desc_array                             based           fixed bin(17,0)          array dcl 5-24 in procedure "vfile_io_control" set
                                                                                  ref 641* 644
desc_array                6            based           fixed bin(35,0)          array level 2 in structure "da_sl_info" dcl 5-38
                                                                                  in procedure "vfile_io_control" set ref 691*
desc_arrayp               4            based           pointer                  level 2 dcl 5-8 set ref 293* 332* 641 644
desc_code                 0(02)        based           fixed bin(2,0)           level 4 packed unaligned dcl 4-41 set ref 66 77*
descrip                   1            based           fixed bin(35,0)          level 3 in structure "gk_info" dcl 4-41 in procedure
                                                                                  "vfile_io_control" set ref 70* 137*
descrip                   1            based           fixed bin(35,0)          level 3 in structure "ak_info" dcl 4-6 in procedure
                                                                                  "vfile_io_control" set ref 465* 468*
descriptor                6            based           fixed bin(35,0)          level 2 dcl 1-6 set ref 193* 199* 201* 218*
end_pos                   1            based           fixed bin(34,0)          level 2 dcl 729 set ref 145*
er_info                                based           structure                level 1 unaligned dcl 737
error                    26            based           entry variable           level 2 dcl 2-10 ref 380
error_table_$bad_arg            000022 external static fixed bin(35,0)          dcl 3-3 ref 97 127 251 596
error_table_$no_operation       000024 external static fixed bin(35,0)          dcl 3-3 ref 127 360
error_table_$no_record          000014 external static fixed bin(35,0)          dcl 3-3 ref 309 340
error_table_$noarg              000016 external static fixed bin(35,0)          dcl 3-3 ref 47 177 190 234 265 281 326 401 419 457
                                                                                  588
error_table_$too_many_args      000020 external static fixed bin(35,0)          dcl 3-3 ref 237 413 629 669 686
error_type                1            based           fixed bin(17,0)          level 2 dcl 737 ref 380
f_head                          000126 automatic       structure                array level 2 unaligned dcl 753
file_base_ptr                          parameter       pointer                  dcl 708 set ref 15 427* 433
fixed                                                  builtin function         dcl 712 ref 36 39 40 85 180 184 198 203 206 208 248
                                                                                  368 394 397 520
flags                                  based           structure                level 3 in structure "ak_info" dcl 4-6 in procedure
                                                                                  "vfile_io_control" set ref 449* 454*
flags                                  based           structure                level 2 in structure "common_sl_info" dcl 5-8
                                                                                  in procedure "vfile_io_control" set ref 291* 330*
flags                                  based           structure                level 3 in structure "gk_info" dcl 4-41 in procedure
                                                                                  "vfile_io_control" set ref 25*
flags                                  based           structure                level 3 in structure "rk_info" dcl 4-22 in procedure
                                                                                  "vfile_io_control" set ref 474*
flags                     1            based           structure                level 2 in structure "rs_info" dcl 1-6 in procedure
                                                                                  "vfile_io_control" set ref 167* 171* 172*
gk_header                              based           structure                level 1 unaligned dcl 4-46
gk_info                                based           structure                level 1 unaligned dcl 4-41
gk_info_ptr                     000122 automatic       pointer                  dcl 4-63 set ref 24* 25 26 53 55 57 58 58 59 66 69
                                                                                  70 72 74 77 82 85 86 86 89 89 92 95 105 111 113
                                                                                  117 134 134 137 137
gk_info_version_0                      constant        fixed bin(17,0)          initial dcl 4-66 ref 26
head                            000126 automatic       bit(1)                   dcl 761 set ref 550* 555* 557* 558* 567 578 583*
                                                                                  585* 593
head_size                 0(09)        based           fixed bin(9,0)           level 5 packed unsigned unaligned dcl 4-41 set ref
                                                                                  58*
header                                 based           structure                level 2 in structure "rk_info" unaligned dcl 4-22
                                                                                  in procedure "vfile_io_control"
header                                 based           structure                level 2 in structure "ak_info" unaligned dcl 4-6
                                                                                  in procedure "vfile_io_control"
header                                 based           structure                level 2 in structure "gk_info" unaligned dcl 4-41
                                                                                  in procedure "vfile_io_control"
hi_sl_info                             based           structure                level 1 unaligned dcl 5-27 set ref 667
i                               000102 automatic       fixed bin(17,0)          dcl 703 in procedure "vfile_io_control" set ref 28*
                                                                                  29 29 29 33* 33 34 36 39 40 43 43 52* 52 57 59 61
                                                                                  61 61 65* 65 70 72 72 74 74 78 78 78 84* 84 85 89
                                                                                  93 93* 154* 158* 167 167 171 175 180 182 184 187
                                                                                  193 194 198 199 201 203 203 206 206 208 208 240*
                                                                                  243* 246 248 506* 509* 517 517 520 520 530 530 530
                                                                                  533 536* 536 537 541 541 546 549* 549 552 554* 554
                                                                                  561 563 564* 564 565 573 573 573 577* 577 583 586
                                                                                  593 593 601* 601 602 604 605 611 612* 612 613 615
                                                                                  615 615 619* 619 621 640* 641* 649 649 654 654 683
                                                                                  690 691
i                               000222 automatic       fixed bin(17,0)          dcl 677 in procedure "build_select_info" set ref
                                                                                  673* 674 674 674 674 674 674 674 674 674 674 674
                                                                                  674*
info                            000116 automatic       structure                level 1 unaligned dcl 721 set ref 20 145 145 246 248
                                                                                  254 256 368 370 372 378 380 383 383 391 392 394
                                                                                  395 397 405 409 410 423 440 440
info_ptr                        000104 automatic       pointer                  dcl 704 set ref 20* 24 161 291 292 293 296 298 312
                                                                                  320 330 331 332 344 352 446 473 512 516 519 520
                                                                                  522 523 526 527 565 634 634 640 641 644 644 656
                                                                                  664 666 667 674 682 683 684 691
input_desc                0(01)        based           bit(1)                   level 4 in structure "gk_info" packed unaligned
                                                                                  dcl 4-41 in procedure "vfile_io_control" set ref
                                                                                  69* 74
input_desc                0(01)        based           bit(1)                   level 4 in structure "ak_info" packed unaligned
                                                                                  dcl 4-6 in procedure "vfile_io_control" set ref
                                                                                  455 465
input_key                              based           bit(1)                   level 4 in structure "rk_info" packed unaligned
                                                                                  dcl 4-22 in procedure "vfile_io_control" set ref
                                                                                  475
input_key                              based           bit(1)                   level 4 in structure "gk_info" packed unaligned
                                                                                  dcl 4-41 in procedure "vfile_io_control" set ref
                                                                                  53* 89 95
input_key                              based           bit(1)                   level 4 in structure "ak_info" packed unaligned
                                                                                  dcl 4-6 in procedure "vfile_io_control" set ref
                                                                                  455 461
input_new_desc            0(02)        based           bit(1)                   level 4 packed unaligned dcl 4-22 set ref 484 494
input_old_desc            0(01)        based           bit(1)                   level 4 packed unaligned dcl 4-22 set ref 481 491
int                             000125 automatic       fixed bin(17,0)          dcl 752 set ref 560* 562 563 567 569 570 570 578 581
                                                                                  582 582 605 609 611* 666 673
interval                  6            based           structure                array level 2 unaligned dcl 5-27 set ref 674*
io_call_af_ret                         based           varying char             dcl 2-25 set ref 117* 121* 309* 312* 340* 344*
io_call_info                           based           structure                level 1 dcl 2-10
io_call_infop                          parameter       pointer                  dcl 2-8 ref 15 21 21 28 29 29 29 34 36 39 40 43 43
                                                                                  57 59 61 61 61 70 72 72 74 74 78 78 78 85 89 93 93
                                                                                  117 117 117 121 121 134 137 142 142 145 150 150
                                                                                  150 153 155 155 155 167 167 171 175 180 182 184
                                                                                  187 193 194 198 199 201 203 203 206 206 208 208
                                                                                  216 218 224 227 229 234 234 234 237 241 241 246
                                                                                  248 251 254 254 256 256 265 265 265 273 273 273
                                                                                  281 281 281 289 289 294 309 309 312 312 326 326
                                                                                  326 340 340 344 344 363 363 366 366 368 368 372
                                                                                  376 376 380 380 383 387 387 389 394 395 397 401
                                                                                  401 401 405 405 407 407 410 419 419 419 423 427
                                                                                  427 427 429 433 447 450 451 454 455 463 464 465
                                                                                  468 474 477 478 479 483 484 487 489 493 494 497
                                                                                  499 510 517 517 520 520 527 527 527 527 530 530
                                                                                  530 533 537 541 541 546 552 561 563 565 573 573
                                                                                  573 583 586 593 593 602 604 605 611 613 615 615
                                                                                  615 621 634 641 649 649 654 654 683 690 691
iocb_ptr                               parameter       pointer                  dcl 700 set ref 15 279* 427* 433 440*
iox_$control                    000026 constant        entry                    external dcl 715 ref 279 440
is_af                           000100 automatic       bit(1)                   dcl 701 set ref 17* 114 142 150 234 265 273 281 307
                                                                                  338 358 435*
key                       3            based           char                     level 2 in structure "gk_info" packed unaligned
                                                                                  dcl 4-41 in procedure "vfile_io_control" set ref
                                                                                  59* 117 134 134 137*
key                       3            based           char                     level 2 in structure "ak_info" packed unaligned
                                                                                  dcl 4-6 in procedure "vfile_io_control" set ref
                                                                                  451* 464*
key                       2            based           char(256)                level 2 in structure "sh_info" packed unaligned
                                                                                  dcl 724 in procedure "vfile_io_control" set ref
                                                                                  256*
key                       4            based           char                     level 2 in structure "rk_info" packed unaligned
                                                                                  dcl 4-22 in procedure "vfile_io_control" set ref
                                                                                  478*
key_len                   3            based           fixed bin(17,0)          level 3 in structure "rk_info" dcl 4-22 in procedure
                                                                                  "vfile_io_control" set ref 477* 478
key_len                   2            based           fixed bin(17,0)          level 3 in structure "gk_info" dcl 4-41 in procedure
                                                                                  "vfile_io_control" set ref 57* 58 59 105 111 113
                                                                                  117 134 134 137 137
key_len                   1            based           fixed bin(17,0)          level 2 in structure "sh_info" dcl 724 in procedure
                                                                                  "vfile_io_control" set ref 254*
key_len                   2            based           fixed bin(17,0)          level 3 in structure "ak_info" dcl 4-6 in procedure
                                                                                  "vfile_io_control" set ref 450* 451 463* 464
kptr                      2     000126 automatic       pointer                  array level 3 in structure "temp_int" dcl 753
                                                                                  in procedure "vfile_io_control" set ref 563* 570
                                                                                  582
kptr                      6     000126 automatic       pointer                  array level 3 in structure "temp_int" dcl 753
                                                                                  in procedure "vfile_io_control" set ref 570* 582*
                                                                                  611*
l_head                    4     000126 automatic       structure                array level 2 unaligned dcl 753
last_image_modifier      14            based           fixed bin(35,0)          level 2 dcl 1-6 set ref 166* 229 229*
len                             000103 automatic       fixed bin(17,0)          dcl 703 set ref 561* 562 567 578 604* 605 609
length                          000126 automatic       fixed bin(17,0)          array level 3 in structure "temp_int" dcl 753
                                                                                  in procedure "vfile_io_control" set ref 562*
length                    4     000126 automatic       fixed bin(17,0)          array level 3 in structure "temp_int" dcl 753
                                                                                  in procedure "vfile_io_control" set ref 567* 569*
                                                                                  578* 581* 605* 609*
length                                                 builtin function         dcl 712 in procedure "vfile_io_control" ref 57 254
                                                                                  450 463 477 561 604
list_type                              based           fixed bin(3,0)           level 3 packed unaligned dcl 5-8 set ref 519* 526*
                                                                                  664 682*
locate_pos_sw             1(06)        based           bit(1)                   level 3 packed unaligned dcl 1-6 set ref 194
locate_sw                 1(03)        based           bit(1)                   level 3 packed unaligned dcl 1-6 set ref 187 206
lock_sw                   1            based           bit(1)                   level 3 packed unaligned dcl 1-6 set ref 203
max_arglen               43            based           fixed bin(17,0)          level 2 dcl 2-10 ref 29 29 29 29 34 34 36 36 39 39
                                                                                  40 40 43 43 57 57 59 59 61 61 61 61 70 70 72 72 72
                                                                                  72 74 74 74 74 78 78 78 78 85 85 89 89 93 93 93 93
                                                                                  155 155 155 155 167 167 171 171 180 180 184 184
                                                                                  193 193 198 198 201 201 203 203 206 206 208 208
                                                                                  241 241 241 241 248 248 254 254 256 256 368 368
                                                                                  394 394 397 397 405 405 407 407 407 407 410 410
                                                                                  423 423 450 450 451 451 454 454 463 463 464 464
                                                                                  465 465 468 468 474 474 477 477 478 478 483 483
                                                                                  487 487 489 489 493 493 497 497 499 499 517 517
                                                                                  517 517 520 520 527 527 527 527 530 530 530 530
                                                                                  530 530 533 533 541 541 541 541 546 546 552 552
                                                                                  561 561 563 563 573 573 573 573 573 573 583 583
                                                                                  593 593 593 593 604 604 605 605 611 611 615 615
                                                                                  615 615 615 615 649 649 649 649 654 654 654 654
                                                                                  691 691
max_info_size                          constant        fixed bin(17,0)          initial dcl 716 ref 667 684 721
max_int                                constant        fixed bin(17,0)          initial dcl 760 ref 560 753
max_rec_len               3            based           fixed bin(21,0)          level 2 dcl 1-6 set ref 182* 184* 216* 218
mb_info                                based           structure                level 1 unaligned dcl 743
min_cap                   1            based           fixed bin(21,0)          level 2 dcl 743 set ref 391* 395* 397*
min_res                                based           fixed bin(21,0)          level 2 dcl 743 set ref 392* 394*
modifier                 12            based           fixed bin(35,0)          level 2 dcl 1-6 set ref 165* 203* 206* 208* 227 227*
mx_info                                based           structure                level 1 unaligned dcl 733
n                               000232 automatic       fixed bin(17,0)          dcl 694 set ref 690* 691 691*
nargs                    42            based           fixed bin(17,0)          level 2 dcl 2-10 ref 28 29 43 61 78 155 167 175 182
                                                                                  187 194 199 203 206 208 234 237 246 251 254 256
                                                                                  265 273 281 294 326 368 389 395 401 405 419 447
                                                                                  455 479 484 494 510 520 527 527 537 565 586 602
                                                                                  613 621 683 690
new_descrip               2            based           fixed bin(35,0)          level 3 dcl 4-22 set ref 487* 489* 497* 499*
new_max_recl              1            based           fixed bin(21,0)          level 2 dcl 733 set ref 368* 370*
new_wait_time                          based           float bin(27)            dcl 747 set ref 405*
next_pos                               based           fixed bin(34,0)          level 2 dcl 729 set ref 145*
null                                                   builtin function         dcl 712 ref 163 213 279 293 332
old_descrip               1            based           fixed bin(35,0)          level 3 dcl 4-22 set ref 483* 493*
old_max_recl                           based           fixed bin(21,0)          level 2 dcl 733 set ref 372*
order_arg                              parameter       varying char(24)         dcl 441 ref 438 440
order_name               11            based           char(32)                 level 2 dcl 2-10 ref 21 21 142 142 150 150 150 153
                                                                                  234 234 265 265 273 273 281 281 289 289 326 326
                                                                                  363 363 366 366 376 376 387 387 401 401 419 419
                                                                                  427 427 429
output_descriptors        0(05)        based           bit(1)                   level 3 packed unaligned dcl 5-8 set ref 320 352
                                                                                  656*
position_specification
                          0(05)        based           structure                level 4 packed unaligned dcl 4-41
received                  3            based           fixed bin(34,0)          level 2 dcl 737 set ref 383*
record_length             2            based           fixed bin(21,0)          level 2 dcl 1-6 set ref 180* 182 198* 216*
record_ptr                4            based           pointer                  level 2 dcl 1-6 set ref 163* 213 218*
ref_count                 7            based           fixed bin(34,0)          level 2 dcl 1-6 set ref 164* 213 221 224*
rel_type                               based           fixed bin(17,0)          level 2 in structure "sh_info" dcl 724 in procedure
                                                                                  "vfile_io_control" set ref 246* 248*
rel_type                  0(06)        based           fixed bin(2,0)           level 5 in structure "gk_info" packed unaligned
                                                                                  dcl 4-41 in procedure "vfile_io_control" set ref
                                                                                  85* 86 86 89
report                   22            based           entry variable           level 2 dcl 2-10 set ref 134 137 145 216 218 224 227
                                                                                  229 372 383 427* 634 641
requested                 2            based           fixed bin(34,0)          level 2 dcl 737 set ref 383*
reset_pos                 0(18)        based           bit(1)                   level 4 packed unaligned dcl 4-41 set ref 72*
rk_header                              based           structure                level 1 unaligned dcl 4-26
rk_info                                based           structure                level 1 unaligned dcl 4-22
rk_info_ptr                     000120 automatic       pointer                  dcl 4-37 set ref 473* 474 475 477 478 481 483 484
                                                                                  487 489 491 493 494 497 499
rp_info                                based           structure                level 1 unaligned dcl 729
rs_info                                based           structure                level 1 dcl 1-6
rs_info_ptr                     000114 automatic       pointer                  dcl 1-5 set ref 161* 162 163 164 165 166 167 171 172
                                                                                  173 180 182 182 184 187 193 194 198 199 201 203
                                                                                  203 203 206 206 208 213 213 216 216 218 218 218
                                                                                  221 223 224 227 227 229 229
rs_info_version_2                      constant        fixed bin(17,0)          initial dcl 1-44 ref 162
set_lock_flag                          based           bit(2)                   dcl 748 set ref 423*
sh_info                                based           structure                level 1 unaligned dcl 724
size                                                   builtin function         dcl 712 ref 667 684
sl_array_limit                  000124 automatic       fixed bin(17,0)          dcl 5-42 set ref 505* 667 684
sl_info_version_0                      constant        fixed bin(17,0)          initial dcl 5-43 ref 292 331
status_only               0(04)        based           bit(1)                   level 3 packed unaligned dcl 5-8 set ref 298* 512*
                                                                                  516*
string                                                 builtin function         dcl 712 set ref 167* 171* 172* 449* 454* 474*
subset_no                 2            based           fixed bin(17,0)          level 2 dcl 5-8 set ref 312 344 520* 522* 634*
substr_len                      000134 automatic       fixed bin(17,0)          dcl 765 set ref 40* 105* 111* 113* 113 117 134 134
substr_off                      000133 automatic       fixed bin(17,0)          dcl 764 set ref 36* 39* 105 110* 113 117 134 134
substr_sw                       000135 automatic       bit(1)                   dcl 766 set ref 23* 35* 105 134
temp_int                        000126 automatic       structure                array level 1 unaligned dcl 753 set ref 674
time_last_modified       10            based           fixed bin(71,0)          level 2 dcl 1-6 set ref 223*
unspec                                                 builtin function         dcl 712 set ref 25* 291* 330*
version                   0(18)        based           fixed bin(17,0)          level 3 in structure "common_sl_info" packed
                                                                                  unaligned dcl 5-8 in procedure "vfile_io_control"
                                                                                  set ref 292* 331*
version                                based           fixed bin(17,0)          level 2 in structure "rs_info" dcl 1-6 in procedure
                                                                                  "vfile_io_control" set ref 162*
version                                based           float bin(27)            level 2 in structure "wt_info" dcl 717 in procedure
                                                                                  "vfile_io_control" set ref 409*
version                                based           fixed bin(17,0)          level 2 in structure "er_info" dcl 737 in procedure
                                                                                  "vfile_io_control" set ref 378*
version                   0(27)        based           fixed bin(8,0)           level 4 in structure "gk_info" packed unaligned
                                                                                  dcl 4-41 in procedure "vfile_io_control" set ref
                                                                                  26*
vfile_status$print_             000010 constant        entry                    external dcl 705 ref 427
wt_info                                based           structure                level 1 unaligned dcl 717

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ak_key_len                             automatic       fixed bin(17,0)          dcl 4-19
error_table_$asynch_change             external static fixed bin(35,0)          dcl 3-3
error_table_$asynch_deletion           external static fixed bin(35,0)          dcl 3-3
error_table_$asynch_insertion          external static fixed bin(35,0)          dcl 3-3
error_table_$bad_file                  external static fixed bin(35,0)          dcl 3-3
error_table_$bad_processid             external static fixed bin(35,0)          dcl 3-3
error_table_$end_of_info               external static fixed bin(35,0)          dcl 3-3
error_table_$file_busy                 external static fixed bin(35,0)          dcl 3-3
error_table_$file_is_full              external static fixed bin(35,0)          dcl 3-3
error_table_$higher_inconsistency      external static fixed bin(35,0)          dcl 3-3
error_table_$invalid_lock_reset        external static fixed bin(35,0)          dcl 3-3
error_table_$key_duplication           external static fixed bin(35,0)          dcl 3-3
error_table_$key_order                 external static fixed bin(35,0)          dcl 3-3
error_table_$last_reference            external static fixed bin(35,0)          dcl 3-3
error_table_$lock_is_invalid           external static fixed bin(35,0)          dcl 3-3
error_table_$lock_not_locked           external static fixed bin(35,0)          dcl 3-3
error_table_$lock_wait_time_exceeded   external static fixed bin(35,0)          dcl 3-3
error_table_$locked_by_this_process    external static fixed bin(35,0)          dcl 3-3
error_table_$long_record               external static fixed bin(35,0)          dcl 3-3
error_table_$no_file                   external static fixed bin(35,0)          dcl 3-3
error_table_$no_key                    external static fixed bin(35,0)          dcl 3-3
error_table_$no_room_for_lock          external static fixed bin(35,0)          dcl 3-3
error_table_$noentry                   external static fixed bin(35,0)          dcl 3-3
error_table_$not_closed                external static fixed bin(35,0)          dcl 3-3
error_table_$not_detached              external static fixed bin(35,0)          dcl 3-3
error_table_$not_open                  external static fixed bin(35,0)          dcl 3-3
error_table_$record_busy               external static fixed bin(35,0)          dcl 3-3
error_table_$segknown                  external static fixed bin(35,0)          dcl 3-3
error_table_$too_many_refs             external static fixed bin(35,0)          dcl 3-3
error_table_$unimplemented_version     external static fixed bin(35,0)          dcl 3-3
gk_key_len                             automatic       fixed bin(17,0)          dcl 4-64
rk_key_len                             automatic       fixed bin(17,0)          dcl 4-38
rs_desc                                based           structure                level 1 packed unaligned dcl 1-32
rs_info_version_1                      internal static fixed bin(17,0)          initial dcl 1-43
seq_desc                               based           structure                level 1 packed unaligned dcl 1-37

NAMES DECLARED BY EXPLICIT CONTEXT.
af                              003723 constant        entry                    external dcl 433
bad_arg                         005342 constant        label                    dcl 596 ref 615 624
badarg                          001050 constant        label                    dcl 97 ref 55 66 74 82 86 89
brief_ret                       001147 constant        label                    dcl 124 ref 132 211 260 314 322 346 354
build_array                     005716 constant        entry                    internal dcl 680 ref 543
build_select_info               005642 constant        entry                    internal dcl 662 ref 304 336
control                         003735 constant        entry                    internal dcl 438 ref 104 144 210 258 270 277 286 306
                                                                                  337 363 371 379 398 416 424 429
exit                            003734 constant        label                    dcl 697 ref 302 334 459 670 687
get_ak_args                     004001 constant        entry                    internal dcl 444 ref 269 276
get_rk_args                     004220 constant        entry                    internal dcl 471 ref 285
handle_head                     000551 constant        label                    dcl 53 set ref 95
is_bf_or_ls_opt                 005564 constant        entry                    internal dcl 647 ref 507
list_descriptors                005517 constant        entry                    internal dcl 637 ref 320 352
mainline                        000327 constant        label                    dcl 18 ref 436
new_int                         005221 constant        label                    dcl 578 ref 626
no_arg                          005311 constant        label                    dcl 588 ref 537 602 621
noarg                           000543 constant        label                    dcl 47 in procedure "vfile_io_control" ref 29 61 78
                                                                                  194
noarg                           004072 constant        label                    dcl 457 in procedure "get_ak_args" ref 479 484 494
process_select_args             004616 constant        entry                    internal dcl 503 ref 301 333
report_subset_status            005463 constant        entry                    internal dcl 632 ref 318 350
vfile_io_control                000320 constant        entry                    external dcl 15

NAMES DECLARED BY CONTEXT OR IMPLICATION.
addrel                                                 builtin function         ref 563 611
bin                                                    builtin function         ref 565
bit                                                    builtin function         ref 171 423 454 474
float                                                  builtin function         ref 405 410
index                                                  builtin function         ref 34
min                                                    builtin function         ref 113 117
substr                                                 builtin function         ref 39 40 117 134 134 171

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6210        6242    6061        6220
Length      6546    6061        32         267     127           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
vfile_io_control                    918 external procedure  is an external procedure.  
control                                 internal procedure  shares stack frame of external procedure vfile_io_control.  
get_ak_args                             internal procedure  shares stack frame of external procedure vfile_io_control.  
process_select_args                     internal procedure  shares stack frame of external procedure vfile_io_control.  
report_subset_status                    internal procedure  shares stack frame of external procedure vfile_io_control.  
list_descriptors                        internal procedure  shares stack frame of external procedure vfile_io_control.  
is_bf_or_ls_opt                         internal procedure  shares stack frame of external procedure vfile_io_control.  
build_select_info                       internal procedure  shares stack frame of external procedure vfile_io_control.  
build_array                             internal procedure  shares stack frame of external procedure vfile_io_control.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
vfile_io_control         000100 is_af                       vfile_io_control
                         000101 brief_sw                    vfile_io_control
                         000102 i                           vfile_io_control
                         000103 len                         vfile_io_control
                         000104 info_ptr                    vfile_io_control
                         000106 date_time                   vfile_io_control
                         000114 rs_info_ptr                 vfile_io_control
                         000116 info                        vfile_io_control
                         000116 ak_info_ptr                 vfile_io_control
                         000120 rk_info_ptr                 vfile_io_control
                         000122 gk_info_ptr                 vfile_io_control
                         000124 sl_array_limit              vfile_io_control
                         000125 int                         vfile_io_control
                         000126 head                        vfile_io_control
                         000126 temp_int                    vfile_io_control
                         000130 default_delim               vfile_io_control
                         000132 comma_off                   vfile_io_control
                         000133 substr_off                  vfile_io_control
                         000134 substr_len                  vfile_io_control
                         000135 substr_sw                   vfile_io_control
                         000222 i                           build_select_info
                         000232 n                           build_array

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_cs            alloc_bs            call_var_desc       call_ext_out_desc   call_ext_out
return              alloc_auto_adj      shorten_stack       ext_entry           real_to_real_rd     real_to_real_tr
any_to_any_rd       any_to_any_tr       free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cv_oct_                       date_time_                    iox_$control                  vfile_status$print_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$no_operation     error_table_$no_record        error_table_$noarg
error_table_$too_many_args




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    721 000301       753 000304        15 000313        17 000326        18 000327        20 000330        21 000332
     23 000345        24 000346        25 000347        26 000350        28 000353        29 000362        33 000416
     34 000417        35 000436        36 000440        39 000456        40 000505        42 000532        43 000533
     47 000543        49 000547        52 000550        53 000551        55 000553        57 000556        58 000575
     59 000577        60 000612        61 000613        65 000630        66 000631        69 000636        70 000640
     71 000673        72 000675        74 000712        77 000727        78 000734        82 000751        84 000754
     85 000755        86 001002        88 001010        89 001011        92 001025        93 001030        95 001045
     97 001050        99 001054       102 001055       104 001057       105 001066       108 001077       110 001100
    111 001102       113 001105       114 001115       117 001122       118 001141       121 001142       122 001145
    124 001147       127 001152       129 001160       132 001161       134 001163       137 001213       139 001244
    142 001245       144 001261       145 001270       148 001323       150 001324       153 001342       154 001347
    155 001350       158 001364       159 001366       161 001370       162 001371       163 001373       164 001376
    165 001400       166 001401       167 001402       171 001435       172 001472       173 001474       175 001500
    177 001503       178 001507       180 001510       182 001540       184 001552       186 001572       187 001573
    190 001605       191 001610       193 001611       194 001652       198 001665       199 001712       201 001723
    202 001756       203 001757       206 002023       208 002063       210 002117       211 002126       213 002130
    216 002143       218 002170       221 002221       223 002224       224 002241       227 002270       229 002317
    232 002347       234 002350       237 002371       240 002377       241 002400       243 002412       244 002414
    246 002416       248 002424       251 002451       254 002465       256 002500       258 002515       260 002524
    262 002526       263 002527       265 002530       269 002551       270 002552       271 002561       273 002562
    276 002577       277 002600       278 002607       279 002610       281 002644       285 002665       286 002666
    287 002675       289 002676       291 002706       292 002707       293 002711       294 002713       296 002717
    298 002720       299 002722       301 002723       302 002724       304 002727       306 002730       307 002737
    309 002741       312 002763       314 003006       316 003010       318 003011       320 003017       322 003026
    324 003030       326 003031       330 003050       331 003051       332 003053       333 003055       334 003056
    336 003061       337 003062       338 003071       340 003073       344 003115       346 003140       348 003142
    350 003143       352 003151       354 003160       356 003162       358 003163       360 003165       361 003170
    363 003171       366 003211       368 003221       370 003241       371 003243       372 003252       374 003301
    376 003302       378 003312       379 003314       380 003323       383 003363       385 003410       387 003411
    389 003421       391 003424       392 003426       393 003427       394 003430       395 003444       397 003455
    398 003475       399 003504       401 003505       405 003524       407 003546       409 003560       410 003562
    411 003607       413 003610       414 003613       416 003614       417 003623       419 003624       423 003643
    424 003653       425 003662       427 003663       429 003711       431 003720       433 003721       435 003731
    436 003733       697 003734       438 003735       440 003737       442 003777       444 004001       446 004002
    447 004004       449 004012       450 004014       451 004017       452 004023       454 004024       455 004052
    457 004072       459 004076       461 004077       463 004101       464 004111       465 004124       467 004157
    468 004161       469 004216       471 004220       473 004221       474 004223       475 004254       477 004260
    478 004270       479 004303       481 004306       483 004311       484 004342       487 004354       488 004411
    489 004413       490 004444       491 004446       493 004451       494 004506       497 004520       498 004555
    499 004557       500 004614       503 004616       505 004617       506 004620       507 004622       509 004627
    510 004631       512 004637       513 004641       516 004642       517 004644       519 004673       520 004677
    522 004721       523 004723       524 004725       526 004726       527 004732       530 004753       533 004772
    534 004776       536 005004       537 005005       539 005010       540 005011       541 005013       543 005041
    544 005042       546 005043       549 005061       550 005062       551 005064       552 005065       554 005072
    555 005073       556 005074       557 005075       558 005100       560 005101       561 005110       562 005126
    563 005134       564 005140       565 005141       567 005154       569 005161       570 005163       571 005164
    573 005165       577 005220       578 005221       581 005232       582 005240       583 005244       585 005302
    586 005303       588 005311       590 005315       592 005316       593 005317       596 005342       598 005346
    601 005347       602 005350       604 005353       605 005361       609 005375       611 005377       612 005404
    613 005405       615 005411       619 005436       621 005443       623 005446       624 005447       626 005453
    627 005454       629 005456       630 005462       632 005463       634 005464       635 005516       637 005517
    640 005520       641 005530       642 005556       644 005560       645 005563       647 005564       649 005566
    651 005615       652 005617       654 005621       656 005633       657 005635       659 005640       662 005642
    664 005643       666 005650       667 005653       669 005660       670 005664       673 005665       674 005674
    675 005713       678 005715       680 005716       682 005717       683 005723       684 005732       686 005736
    687 005741       690 005742       691 005752       692 006017       695 006022


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
