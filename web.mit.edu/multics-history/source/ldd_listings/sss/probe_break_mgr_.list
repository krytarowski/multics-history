	COMPILATION LISTING OF SEGMENT probe_break_mgr_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1132.23_Tue_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(88-09-30,WAAnderson), approve(88-09-30,MCR7863),
       15*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       16*     Fixed bugs associated with object segments compiled with the -brief_table
       17*     control argument.
       18*  2) change(88-09-30,WAAnderson), approve(88-09-30,MCR7952),
       19*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       20*     Added format control comment to make the source more readable.
       21*  3) change(88-10-21,WAAnderson), approve(88-10-21,MCR7952),
       22*     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
       23*     Modified for C.  The names of C functions were not been printed.
       24*                                                   END HISTORY COMMENTS */
       25 
       26 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       27 
       28 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       29 
       30 probe_break_mgr_:
       31   proc;
       32 
       33   call probe_error_$malfunction ();	/* dummy entry */
       34 
       35   /* Here we have entries to set breaks, to list breaks, and to reset breaks -
       36*   programs here know about how breaks are implemented, and about the various data structures.
       37*   The exact arrangements of procedures is subject to change
       38*
       39*   COMPLETELY NEW CODE - by James R. Davis 25 Sept 79
       40*
       41*   ENTRIES
       42*
       43*   set_break
       44*
       45*   list_breaks_at_line
       46*   list_breaks_in_seg
       47*   list_breaks_in_world
       48*   list_broken_segs
       49*
       50*   reset_break_at_line
       51*   reset_breaks_in_seg
       52*   reset_breaks_in_world
       53*   reset_all_pause_breaks
       54*
       55*   print_instructions	prints code for a stmt, with breaks invisible.
       56*
       57*   Big comment explaining the data structures used - see end, just before include files */
       58   /* Modified 17 August 1981 by Melanie Weaver to handle segs that end on even word. */
       59   /* Changed to initialize break segment when needed (instead of at command time) 09/28/81 S. Herbst */
       60   /* Fixed to always delete break map after last break in seg is reset 11/03/81 S. Herbst */
       61   /* Added $is_temporary_break returns "1"b if after break is "pause" 12/02/81 S. Herbst */
       62   /* Fixed bug when breakmap is deleted 12/29/81 S. Herbst */
       63   /* Fixed to remove added w access when done 03/15/82 S. Herbst */
       64   /* Fixed ACL forcing once more 05/25/82 S. Herbst */
       65   /* Added $print_instructions 09/15/82 S. Herbst */
       66   /* Fixed error message printed when debug breaks are left in break map 08/12/83 S. Herbst */
       67   /* Fixed bug in "r N" that can reset an extra break 03/30/84 S. Herbst */
       68   /* Added $reset_all_pause_breaks, called when exiting probe 04/19/84 S. Herbst */
       69   /* Fixed not to overwrite a real break with one set by "step" 04/19/84 S. Herbst */
       70   /* Fixed to fail gracefully if source_info.instruction_ptr = null 08/02/84 S. Herbst */
       71 
       72 
       73   dcl (
       74       P_probe_info_ptr	ptr parameter,
       75       P_break_type		fixed bin,/* BREAK_AT, BREAK_AFTER, etc. */
       76       P_command_ptr		ptr,	/* to break request list */
       77       P_command_length	fixed bin (21),
       78 				/* how many chars in list */
       79       P_instruction_ptr	ptr,	/* for $print_instructions */
       80       P_len		fixed bin,/* for $print_instructions */
       81       P_long_sw		bit (1) aligned,
       82 				/* verbosity control */
       83       P_source_info_ptr	ptr,	/* to source_info */
       84       P_code		fixed bin (35)
       85       )			parameter;
       86 
       87   dcl (
       88       PRINT		init ("1"b),
       89       NO_PRINT		init ("0"b)
       90       )			bit (1) aligned int static options (constant);
       91   dcl BRIEF		bit (1) aligned int static
       92 			options (constant) init ("0"b);
       93 
       94   dcl seginfop		ptr;	/* to the seg info of some object seg */
       95   dcl code		fixed bin (35);
       96   dcl number		fixed bin;/* the index into Map_array */
       97   dcl happy		bit (1) aligned;
       98 				/* did we find even one break */
       99   dcl breakmap_deleted_sw	bit (1) aligned;
      100   dcl break_type		fixed bin;/* global use: AT AFTER BEFORE */
      101   dcl based_word		bit (36) aligned based;
      102 
      103   dcl first		ptr;	/* in loops, to the first */
      104   dcl next		ptr;	/* in loops, to the next */
      105   dcl long_sw		bit (1) aligned;
      106 				/* copy of P_long, at times */
      107   dcl pauses_entry_sw	bit (1) aligned;
      108 				/* called $reset_all_pause_breaks */
      109 
      110   dcl instruction_ptr	ptr;
      111   dcl slot_ptr		ptr;
      112   dcl slot_offset		bit (18);
      113   dcl saved_instruction	bit (36) aligned;
      114 
      115   dcl added_w_sw		bit (1) aligned;
      116 				/* to remove w access when done if it was added */
      117   dcl after_sw		bit (1) aligned;
      118 				/* ON => temporarily resetting an after break */
      119   dcl saved_mode_sw		bit (1) aligned;
      120 				/* there was already an acl entry for group_id$tag_star */
      121   dcl saved_mode		bit (3);	/* access to restore when removing w */
      122   dcl saved_stp		ptr;	/* saved copy of stp while resetting breaks */
      123   dcl 1 seg_acl		(1) aligned like segment_acl;
      124   dcl acl_dn		char (168);
      125   dcl acl_en		char (32);
      126 
      127   dcl 1 Break_source	aligned like source_info
      128 			based (break_source_info_ptr);
      129   dcl break_source_info_ptr	ptr;
      130 
      131   dcl 1 Map_array		(Map_size) aligned like statement_map
      132 			based (Map_ptr);
      133   dcl Map_size		fixed bin;
      134   dcl Map_ptr		ptr;
      135 
      136   dcl NL			char (1) int static options (constant) init ("
      137 ");
      138   dcl (
      139       probe_map_sequence_$before_code
      140 			bit (36), /* to get its address */
      141       probe_map_sequence_$after_code
      142 			bit (36),
      143       probe_map_sequence_$count
      144 			fixed bin,
      145       probe_map_sequence_$code
      146 			bit (36),
      147       probe_map_sequence_$return
      148 			bit (36),
      149       probe_map_sequence_$old_return
      150 			bit (36)
      151       )			aligned external static;
      152 
      153   dcl probe_seg_mgr_$create_breakseg
      154 			entry (fixed bin (35)) returns (ptr);
      155   dcl probe_seg_mgr_$get_procedure_entry
      156 			entry (ptr, ptr, ptr, ptr, fixed bin (35));
      157   dcl probe_seg_mgr_$first_procedure_ptr
      158 			entry (ptr, fixed bin (35)) returns (ptr);
      159   dcl probe_seg_mgr_$create_procedure_entry
      160 			entry (ptr, ptr, ptr, ptr, fixed bin (35));
      161   dcl probe_seg_mgr_$delete_procedure_entry
      162 			entry (ptr, ptr, fixed bin (35));
      163 
      164   dcl (
      165       probe_error_$malfunction,
      166       probe_error_$record
      167       )			entry options (variable);
      168 
      169   dcl get_group_id_		entry returns (char (32));
      170   dcl inst_length_		entry (ptr, fixed bin) returns (fixed bin);
      171   dcl print_instructions_	entry (ptr, fixed bin, ptr);
      172   dcl relocate_instruction_	entry (ptr, ptr, fixed bin (35));
      173   dcl hcs_$add_acl_entries	entry (char (*), char (*), ptr, fixed bin,
      174 			fixed bin (35));
      175   dcl hcs_$delete_acl_entries entry (char (*), char (*), ptr, fixed bin,
      176 			fixed bin (35));
      177   dcl hcs_$fs_get_path_name	entry (ptr, char (*), fixed bin, char (*),
      178 			fixed bin (35));
      179   dcl hcs_$list_acl		entry (char (*), char (*), ptr, ptr, ptr,
      180 			fixed bin, fixed bin (35));
      181   dcl hcs_$set_bc_seg	entry (ptr, fixed bin (24), fixed bin (35));
      182 
      183 
      184   dcl ioa_$ioa_switch	entry options (variable);
      185 
      186   dcl (
      187       probe_et_$breakless,
      188       probe_et_$no_breaks_set,
      189       probe_et_$no_breaks,
      190       probe_et_$non_standard,
      191       probe_et_$breaks_exist,
      192       probe_et_$old_break_map,
      193       probe_et_$recorded_message
      194       )			fixed bin (35) external static;
      195 
      196   dcl (add, addr, addrel, binary, bit, divide, fixed, hbound,
      197       mod, multiply, null, pointer, ptr, rel, size, substr, subtract, unspec)
      198 			builtin;
      199 
      200 
      201 RECORDED_MESSAGE:
      202   P_code = probe_et_$recorded_message;
      203   return;
      204 
      205 
      206 set_break:
      207   entry (P_probe_info_ptr, P_source_info_ptr, P_break_type, P_command_ptr,
      208        P_command_length, P_code);
      209 
      210 
      211   begin;
      212 
      213     dcl command_ptr		  ptr;
      214     dcl command_length	  fixed bin (21);
      215     dcl command		  char (command_length) based (command_ptr);
      216     dcl map_seq_ptr		  ptr;	/* to map_sequence in this object seg */
      217     dcl place_to_set	  ptr;	/* where to put the break */
      218     dcl next_loc		  ptr;	/* to instruction after the broken one */
      219     dcl copy		  (copy_count) bit (36) based;
      220     dcl copy_count		  fixed bin (21);
      221 
      222 
      223 
      224     /* HOW TO SET BREAKS :
      225*
      226*   Create a break map for the object seg (if one doesn't exist already)
      227*   Ensure sufficient access and that maxlength of seg is reset to big
      228*   create a procedure entry for seg in break_seg (if not one already)
      229*   if there is already a break at the line of same type, reset it
      230*
      231*   if there is no statement entry for the given statement, create it
      232*
      233*   create a break_slot of the right kind
      234*   relocate instruction
      235*
      236*
      237*   An additional hairy feature:
      238*
      239*   It may be that the user sets a break after and before a line, and the line is only one instrcuton
      240*   long.  This is known as a "strange" break.  A "strange" break is implemented by a "tra" to the before code sequence
      241*   (just as for a normal before break).  the before code executes its map sequence, and probe is invoked in the usual way.
      242*   The "moved_instruction" in the before slot, however, is replaced with a "tra" to the after slot sequence.  It is as if
      243*   there has been an "after" break set IN THE BEFORE SEQUENCE ITSELF.
      244*   The after sequence first executes the original "moved" instruction (which completes the execution of all object code
      245*   for the line), then executes the map sequence, and probe is once again invoked.
      246*
      247*   When the "before" break is reset, it copies the "old_instruction" back into the object segment (just as is done for a
      248*   "normal"    before break).  This instruction is a tra to the after code, not the original instruction.
      249*   The original   is still stored in the after slot, since the after break is still in effect..
      250*   If a "strange" after break   is reset, then the saved "old" and "moved" instructions are returned
      251*   to the before slot where they   were copied from, and all is well
      252**/
      253 
      254     probe_info_ptr = P_probe_info_ptr;
      255     P_code = 0;
      256     command_length = P_command_length;
      257     command_ptr = P_command_ptr;
      258     break_type = P_break_type;
      259     break_source_info_ptr = P_source_info_ptr;
      260     code = 0;
      261     seginfop = Break_source.seg_info_ptr;
      262 
      263     if Break_source.instruction_ptr = null then do;
      264         place_to_set = null;
      265         go to CANT_RELOCATE;
      266       end;
      267 
      268     if probe_static_info.break_segment_ptr = null then do;
      269         probe_static_info.break_segment_ptr =
      270 	   probe_seg_mgr_$create_breakseg (code);
      271         if code ^= 0 then do;
      272 	  call probe_error_$record (probe_info_ptr, 0,
      273 	       "Can't initialize break segment.");
      274 	  go to RECORDED_MESSAGE;
      275 	end;
      276       end;
      277 
      278     call probe_seg_mgr_$create_procedure_entry (probe_info_ptr, seginfop, ent,
      279          bmp, P_code);
      280     if P_code ^= 0
      281       then
      282 	 return;
      283 
      284     call ensure_writeable ((Break_source.instruction_ptr));
      285     if bmp = null () then do;
      286         call create_breakmap ();
      287         procedure_entry.break_map = rel (bmp);
      288       end;
      289 
      290     number = Break_source.stmnt_map_entry_index;
      291     stp = search_for_stmt (ent, bmp, number);
      292 
      293     if stp = null ()		/* no previous record for this line */
      294       then stp = create_statement_entry (ent, bmp,
      295 	      Break_source.stmnt_map_entry_index);
      296       else do;
      297         if statement_item.slots (break_type) ^= (18)"0"b
      298 	then
      299 	     if command = "pause"
      300 	       then
      301 		  return;		/* "step" break shouldn't overwrite real one */
      302 	       else call remove_break ((break_type));
      303       end;
      304 
      305 
      306     Map_ptr = seginfop -> seg_info.statement_map_ptr;
      307     Map_size = seginfop -> seg_info.map_size;
      308     place_to_set = pointer (bmp, Map_array (number).location);
      309 
      310     command_list_size = command_length + 1;
      311 				/* for NL */
      312 
      313     map_seq_ptr = addr (break_map.map_sequence);
      314     if break_type = BREAK_BEFORE then do;
      315         next_loc = addrel (place_to_set, inst_length_ (place_to_set, (0)));
      316         if next_loc = place_to_set
      317 	then goto CANT_GET_LENGTH;
      318 
      319         bsp, before_slot_ptr =
      320 	   allocate_in_breakmap (size (break_slot_before));
      321 
      322         /* because we didn't use pl1 allocate we must initialize the slot ourselves */
      323 
      324         call common_break_slot_setup (before_slot_ptr);
      325 				/* size is set by allocate_in_breakmap */
      326         break_slot_before.type = BREAK_BEFORE;
      327 
      328         copy_count = size_of_before_sequence;
      329         unspec (break_slot_before.sequence) =
      330 	   unspec (addr (probe_map_sequence_$before_code) -> copy);
      331         break_slot_before.sequence.map_seq_offset = rel (map_seq_ptr);
      332         break_slot_before.sequence.slot_offset = rel (before_slot_ptr);
      333         break_slot_before.sequence.return.offset = rel (next_loc);
      334 
      335         call relocate_instruction_ (place_to_set,
      336 	   addr (break_slot_before.moved_instruction), code);
      337 
      338         if code ^= 0
      339 	then goto CANT_RELOCATE;
      340         break_slot_before.old_instruction = place_to_set -> based_word;
      341 
      342         place_to_set -> based_word =
      343 	   rel (addr (break_slot_before.sequence)) || TRA_code;
      344 				/* ughh */
      345 
      346       end;			/* break before */
      347       else do;
      348         if number = hbound (Map_array, 1) then do;
      349 	  call probe_error_$record (probe_info_ptr, 0,
      350 	       "Can't set break after last line in program");
      351 	  goto RECORDED_MESSAGE;
      352 	end;
      353         next_loc = place_to_set;
      354 
      355         /* find last inst. in line, and first inst. after it.  this is hard,
      356*   because we can't just look at last word of the line, because it could be
      357*   the descriptor of an EIS.  the only safe way is to look at each instruction, find its length,
      358*   and look where the next inst. is to begin.  I wish the statement map told us.
      359**/
      360 
      361         if statement_item.slots (BREAK_BEFORE) = "0"b
      362 	then before_slot_ptr = null ();
      363 	else do;
      364 
      365 	  /* the instruction there is only a TRA, of length one, the real instruction is in the break_slot */
      366 	  before_slot_ptr =
      367 	       pointer (stp, statement_item.slots (BREAK_BEFORE));
      368 	  next_loc = addrel (next_loc,
      369 	       inst_length_ (addr (break_slot_before.old_instruction), (0)))
      370 	       ;
      371 	end;
      372 
      373         do while (rel (next_loc) < Map_array (number + 1).location);
      374 				/* find last inst. in line */
      375 	place_to_set = next_loc;	/* this one is known good */
      376 	next_loc = addrel (next_loc, inst_length_ (next_loc, (0)));
      377 	if next_loc = place_to_set	/* means the length was 0, i.e. bad */
      378 	  then goto CANT_GET_LENGTH;
      379         end;
      380 
      381         bsp, after_slot_ptr = allocate_in_breakmap (size (break_slot_after));
      382         call common_break_slot_setup (after_slot_ptr);
      383         copy_count = size_of_after_sequence;
      384         unspec (break_slot_after.sequence) =
      385 	   unspec (addr (probe_map_sequence_$after_code) -> copy);
      386 
      387         break_slot_after.sequence.map_seq_offset = rel (map_seq_ptr);
      388         break_slot_after.sequence.slot_offset = rel (after_slot_ptr);
      389         break_slot_after.sequence.return.offset = rel (next_loc);
      390         break_slot_after.type = BREAK_AFTER;
      391 
      392         /* where we really set the break depends on strangeness */
      393 
      394         if strange_casep ()
      395 	then do;
      396 	  call relocate_instruction_ (
      397 	       addr (break_slot_before.moved_instruction),
      398 	       addr (break_slot_after.moved_instruction), code);
      399 	  if code ^= 0
      400 	    then goto CANT_RELOCATE;
      401 	  break_slot_after.old_instruction =
      402 	       break_slot_before.old_instruction;
      403 	  break_slot_before.old_instruction,
      404 	       break_slot_before.moved_instruction =
      405 	       rel (addr (break_slot_after.sequence)) || TRA_code;
      406 
      407 	end;
      408 	else do;
      409 	  break_slot_after.old_instruction = place_to_set -> based_word;
      410 	  call relocate_instruction_
      411 	       (place_to_set, addr (break_slot_after.moved_instruction),
      412 	       code);
      413 	  if code ^= 0
      414 	    then goto CANT_RELOCATE;
      415 	  place_to_set -> based_word =
      416 	       rel (addr (break_slot_after.sequence)) || TRA_code;
      417 
      418 	end;
      419       end;			/* BREAK after code */
      420 
      421     statement_item.slots (break_type) = rel (bsp);
      422 				/* remember the break */
      423 
      424     if added_w_sw
      425       then call restore_readonly ((Break_source.instruction_ptr));
      426     return;
      427 
      428 
      429 
      430 CANT_RELOCATE:
      431     call probe_error_$record (probe_info_ptr, 0,
      432          "Can't set break because can't relocate instruction at ^p",
      433          place_to_set);
      434     goto RECORDED_MESSAGE;
      435 
      436 CANT_GET_LENGTH:
      437     call probe_error_$record (probe_info_ptr, 0,
      438          "Can't set break because can't get length of instruction at ^p",
      439          place_to_set);
      440     goto RECORDED_MESSAGE;
      441 
      442 
      443 
      444 strange_casep:
      445   proc () returns (bit (1) aligned);
      446 
      447   if before_slot_ptr ^= null ()
      448     then if before_slot_ptr -> break_slot_before.location = rel (place_to_set)
      449 	 then return ("1"b);
      450   return ("0"b);
      451   end strange_casep;
      452 
      453 
      454 
      455 
      456 common_break_slot_setup:
      457   proc (P_bsp);
      458 
      459   dcl P_bsp		ptr parameter;
      460   dcl absp		ptr;
      461 
      462   absp = P_bsp;
      463 
      464   absp -> break_slot.item_type = BREAK_ITEM;
      465   absp -> break_slot.breakmap_header_offset = rel (bmp);
      466   absp -> break_slot.statement_item_offset = rel (stp);
      467   if Break_source.block_ptr = null ()
      468     then absp -> break_slot.symbol_block_offset = "0"b;
      469     else absp -> break_slot.symbol_block_offset =
      470 	    rel (Break_source.block_ptr);
      471   absp -> break_slot.location = rel (place_to_set);
      472   absp -> break_slot.count = command_list_size;
      473   absp -> break_slot.command_list = command || NL;
      474   end common_break_slot_setup;
      475   end;				/* set break begin block */
      476 
      477 is_temporary_break:
      478   entry (P_probe_info_ptr, P_source_info_ptr) returns (bit (1));
      479 
      480   /* Returns "1"b if the stmt pointed to has a temporary break (the before break is "pause"), "0"b otherwise */
      481 
      482   probe_info_ptr = P_probe_info_ptr;
      483   break_source_info_ptr = P_source_info_ptr;
      484   seginfop = Break_source.seg_info_ptr;
      485 
      486   number = Break_source.stmnt_map_entry_index;
      487 
      488   call probe_seg_mgr_$get_procedure_entry (probe_info_ptr, seginfop, ent, bmp,
      489        code);
      490   if code ^= 0
      491     then
      492          return ("0"b);
      493 
      494   if ent ^= null & bmp ^= null then do;
      495 
      496       stp = search_for_stmt (ent, bmp, number);
      497       if stp ^= null
      498         then
      499 	   if stp -> statement_item.slots (BREAK_BEFORE) ^= (18)"0"b
      500 	     then do;
      501 	       bsp = pointer (stp, statement_item.slots (BREAK_BEFORE));
      502 	       if bsp -> break_slot.command_list = "pause" || NL
      503 	         then return ("1"b);
      504 				/* a temporary break */
      505 	     end;
      506     end;
      507   return ("0"b);
      508 
      509 
      510 
      511   /* here are the entries to list breaks - we have four flavors
      512*
      513*   list_breaks_at_line
      514*   list_breaks_in_seg
      515*   list_breaks_in_world
      516*   list_broken_segs
      517*
      518**/
      519 
      520 list_breaks_at_line:
      521   entry (P_probe_info_ptr, P_source_info_ptr, P_break_type, P_long_sw, P_code)
      522        ;
      523 
      524   probe_info_ptr = P_probe_info_ptr;
      525   break_source_info_ptr = P_source_info_ptr;
      526   P_code = 0;
      527   long_sw = P_long_sw;
      528 
      529   seginfop = Break_source.seg_info_ptr;
      530   break_type = P_break_type;
      531   happy = "0"b;
      532 
      533   number = Break_source.stmnt_map_entry_index;
      534 
      535   call probe_seg_mgr_$get_procedure_entry (probe_info_ptr, seginfop, ent, bmp,
      536        P_code);
      537   if P_code ^= 0
      538     then
      539          return;
      540 
      541   if ent ^= null () & bmp ^= null () then do;
      542       stp = search_for_stmt (ent, bmp, number);
      543       if stp ^= null then do;
      544 	if stp -> statement_item.slots (BREAK_BEFORE) ^= (18)"0"b &
      545 	     (break_type = BREAK_BEFORE | break_type = BREAK_AT) then do;
      546 	    happy = "1"b;
      547 	    call display_break
      548 	         (ptr (stp, statement_item.slots (BREAK_BEFORE)), "0"b,
      549 	         long_sw);
      550 	  end;
      551 	if stp -> statement_item.slots (BREAK_AFTER) ^= (18)"0"b &
      552 	     (break_type = BREAK_AFTER | break_type = BREAK_AT) then do;
      553 	    happy = "1"b;
      554 	    call display_break
      555 	         (ptr (stp, statement_item.slots (BREAK_AFTER)), "0"b,
      556 	         (long_sw));
      557 	  end;
      558         end;
      559     end;
      560 
      561   if ^happy
      562     then P_code = probe_et_$breakless;
      563   return;
      564 
      565 
      566 list_breaks_in_seg:
      567   entry (P_probe_info_ptr, P_source_info_ptr, P_long_sw, P_code);
      568 
      569   probe_info_ptr = P_probe_info_ptr;
      570   P_code = 0;
      571   break_source_info_ptr = P_source_info_ptr;
      572   happy = "0"b;
      573   long_sw = P_long_sw;
      574 
      575   seginfop = Break_source.seg_info_ptr;
      576   call probe_seg_mgr_$get_procedure_entry (probe_info_ptr, seginfop, ent, bmp,
      577        P_code);
      578   if P_code ^= 0
      579     then
      580          return;
      581 
      582   if ent ^= null () & bmp ^= null ()
      583     then call list_all_in (long_sw, PRINT, happy);
      584   if ^happy
      585     then P_code = probe_et_$no_breaks;
      586   return;
      587 
      588 
      589 list_breaks_in_world:
      590   entry (P_probe_info_ptr, P_long_sw, P_code);
      591 
      592   /* Note similarity to list_broken_segs and reset_breaks_in_world.
      593*   All have exact same control structure (which is right).
      594*   Wish PL/I supported generator-style co-rountines */
      595 
      596   probe_info_ptr = P_probe_info_ptr;
      597   happy = "0"b;
      598   P_code = 0;
      599   long_sw = P_long_sw;
      600   first = probe_seg_mgr_$first_procedure_ptr (probe_info_ptr, P_code);
      601   if P_code ^= 0
      602     then
      603          return;
      604 
      605   if first ^= null ()
      606     then
      607       do ent = first repeat next while (rel (ent) ^= (18)"0"b);
      608       next = pointer (ent, procedure_entry.chain);
      609 				/* might disappear if found obs */
      610       bmp = get_breakmap_ptr ();
      611       if bmp ^= null ()
      612         then call list_all_in (long_sw, PRINT, happy);
      613     end;				/* lop over ents */
      614 
      615   if ^happy
      616     then P_code = probe_et_$no_breaks_set;
      617   return;
      618 
      619 list_broken_segs:
      620   entry (P_probe_info_ptr, P_code);
      621 
      622   probe_info_ptr = P_probe_info_ptr;
      623   P_code = 0;
      624 
      625   first = probe_seg_mgr_$first_procedure_ptr (probe_info_ptr, P_code);
      626   if P_code ^= 0
      627     then
      628          return;
      629 
      630   happy = "0"b;
      631 
      632   if first ^= null ()
      633     then
      634       do ent = first repeat next while (rel (ent) ^= (18)"0"b);
      635 
      636       next = pointer (first, procedure_entry.chain);
      637 				/* might disappear next line */
      638       bmp = get_breakmap_ptr ();	/* this could zap it */
      639       if bmp ^= null () then do;
      640 	if ^happy then do;
      641 	    happy = "1"b;		/* this is the first */
      642 	    call ioa_$ioa_switch (probe_info.output_switch,
      643 	         "Breaks set in:");
      644 	  end;
      645 	call ioa_$ioa_switch (probe_info.output_switch,
      646 	     "   ^a>^a$^a",
      647 	     procedure_entry.directory, procedure_entry.entry,
      648 	     procedure_entry.segname);
      649         end;
      650     end;				/* loop */
      651 
      652   if ^happy
      653     then P_code = probe_et_$no_breaks_set;
      654   return;
      655 
      656   /* entries to reset breaks
      657*
      658*   reset_break_at_line
      659*   reset_breaks_in_seg
      660*   reset_breaks_in_world
      661*
      662**/
      663 
      664 reset_break_at_line:
      665   entry (P_probe_info_ptr, P_source_info_ptr, P_break_type, P_long_sw, P_code)
      666        ;
      667 
      668   probe_info_ptr = P_probe_info_ptr;
      669   break_source_info_ptr = P_source_info_ptr;
      670   seginfop = Break_source.seg_info_ptr;
      671   number = Break_source.stmnt_map_entry_index;
      672   break_type = P_break_type;
      673   long_sw = P_long_sw;
      674   P_code = 0;
      675   happy = "0"b;
      676 
      677   call probe_seg_mgr_$get_procedure_entry (probe_info_ptr, seginfop, ent, bmp,
      678        P_code);
      679   if P_code ^= 0
      680     then
      681          return;
      682   if ent ^= null () & bmp ^= null () then do;
      683       stp = search_for_stmt (ent, bmp, number);
      684       if stp ^= null () then do;
      685 	call ensure_writeable ((bmp));
      686 	saved_stp = stp;
      687 	if stp -> statement_item.slots (BREAK_BEFORE) ^= (18)"0"b &
      688 	     (break_type = BREAK_BEFORE | break_type = BREAK_AT) then do;
      689 	    happy = "1"b;
      690 	    call reset_the_break_at (BREAK_BEFORE, long_sw);
      691 
      692 	    if breakmap_deleted_sw
      693 	      then go to RESET_DONE;
      694 	  end;
      695 	stp = saved_stp;
      696 	if stp -> statement_item.slots (BREAK_AFTER) ^= (18)"0"b &
      697 	     (break_type = BREAK_AFTER | break_type = BREAK_AT) then do;
      698 	    happy = "1"b;
      699 	    call reset_the_break_at (BREAK_AFTER, long_sw);
      700 	  end;
      701 	if added_w_sw
      702 	  then call restore_readonly ((bmp));
      703         end;
      704     end;				/* non -null break map */
      705 
      706 RESET_DONE:
      707   if ^happy
      708     then P_code = probe_et_$breakless;
      709   return;
      710 
      711 reset_breaks_in_seg:
      712   entry (P_probe_info_ptr, P_source_info_ptr, P_long_sw, P_code);
      713 
      714   probe_info_ptr = P_probe_info_ptr;
      715   P_code = 0;
      716   break_source_info_ptr = P_source_info_ptr;
      717   seginfop = Break_source.seg_info_ptr;
      718   happy = "0"b;
      719 
      720   call probe_seg_mgr_$get_procedure_entry (probe_info_ptr, seginfop, ent, bmp,
      721        P_code);
      722   if P_code ^= 0
      723     then
      724          return;
      725   if ent ^= null () & bmp ^= null () then do;
      726       call ensure_writeable ((bmp));
      727       call reset_all_breaks_in (long_sw,
      728 	 "0"b /*reset all types, not just pauses*/, happy);
      729       if added_w_sw
      730         then call restore_readonly ((bmp));
      731     end;
      732   if ^happy
      733     then P_code = probe_et_$no_breaks;
      734   return;
      735 
      736 
      737 reset_breaks_in_world:
      738   entry (P_probe_info_ptr, P_long_sw, P_code);
      739 
      740   probe_info_ptr = P_probe_info_ptr;
      741   long_sw = P_long_sw;
      742   pauses_entry_sw = "0"b;
      743 RESET_ALL:
      744   happy = "0"b;
      745   code = 0;
      746 
      747   first = probe_seg_mgr_$first_procedure_ptr (probe_info_ptr, code);
      748   if code ^= 0 then do;
      749       if ^pauses_entry_sw
      750         then P_code = code;
      751       return;
      752     end;
      753 
      754   if first ^= null ()
      755     then
      756       do ent = first repeat next while (rel (ent) ^= (18)"0"b);
      757       next = pointer (ent, procedure_entry.chain);
      758       bmp = get_breakmap_ptr ();
      759       if bmp ^= null ()
      760         then do;
      761 	call ensure_writeable ((bmp));
      762 	call reset_all_breaks_in (long_sw, pauses_entry_sw, happy);
      763 	if added_w_sw
      764 	  then call restore_readonly ((bmp));
      765         end;
      766     end;
      767 
      768   if ^happy & ^pauses_entry_sw
      769     then P_code = probe_et_$no_breaks_set;
      770   return;
      771 
      772 
      773 reset_all_pause_breaks:
      774   entry (P_probe_info_ptr);
      775 
      776   probe_info_ptr = P_probe_info_ptr;
      777   long_sw = "0"b;
      778   pauses_entry_sw = "1"b;
      779 
      780   go to RESET_ALL;
      781 
      782 print_instructions:
      783   entry (P_probe_info_ptr, P_source_info_ptr, P_instruction_ptr, P_len);
      784 
      785   /* Prints the instructions for a given line, without showing the break instruction */
      786 
      787   probe_info_ptr = P_probe_info_ptr;
      788   break_source_info_ptr = P_source_info_ptr;
      789 
      790   seginfop = Break_source.seg_info_ptr;
      791   number = Break_source.stmnt_map_entry_index;
      792   ent, bmp, slot_ptr = null;
      793 
      794   /* Find out if any breaks are set at this line */
      795 
      796   call probe_seg_mgr_$get_procedure_entry (probe_info_ptr, seginfop, ent, bmp,
      797        0);
      798   if ent ^= null & bmp ^= null then do;
      799 
      800       stp = search_for_stmt (ent, bmp, number);
      801       if stp ^= null then do;
      802 
      803 	after_sw = "0"b;
      804 	slot_offset = stp -> statement_item.slots (BREAK_BEFORE);
      805 	if slot_offset ^= (18)"0"b
      806 	  then slot_ptr = pointer (stp, slot_offset);
      807 	  else do;
      808 	    after_sw = "1"b;
      809 	    slot_offset = stp -> statement_item.slots (BREAK_AFTER);
      810 	    if slot_offset ^= (18)"0"b
      811 	      then slot_ptr = pointer (stp, slot_offset);
      812 	      else slot_ptr = null;
      813 	  end;
      814         end;
      815     end;
      816 
      817   /* If there is one, temporarily replace it with the original instruction */
      818 
      819   if slot_ptr ^= null then do;
      820 
      821       call ensure_writeable ((bmp));
      822 
      823       if after_sw then do;
      824 	instruction_ptr =
      825 	     pointer (P_instruction_ptr,
      826 	     slot_ptr -> break_slot_after.location);
      827 	saved_instruction = instruction_ptr -> based_word;
      828 	instruction_ptr -> based_word =
      829 	     slot_ptr -> break_slot_after.old_instruction;
      830         end;
      831         else do;
      832 	instruction_ptr =
      833 	     pointer (P_instruction_ptr,
      834 	     slot_ptr -> break_slot_before.location);
      835 	saved_instruction = instruction_ptr -> based_word;
      836 	instruction_ptr -> based_word =
      837 	     slot_ptr -> break_slot_before.old_instruction;
      838         end;
      839     end;
      840 
      841   /* Print the instructions for the statement */
      842 
      843   call print_instructions_ (P_instruction_ptr, P_len,
      844        probe_info.output_switch);
      845 
      846   /* Now replace the break if necessary */
      847 
      848   if slot_ptr ^= null then do;
      849 
      850       instruction_ptr -> based_word = saved_instruction;
      851 
      852       if added_w_sw
      853         then call restore_readonly ((bmp));
      854     end;
      855   return;
      856 
      857 
      858   /* ************************ INTERNAL PROCS ********************* */
      859 
      860 
      861 list_all_in:
      862   proc (P_long, P_print, P_exists);
      863 
      864 
      865   dcl P_long		bit (1) aligned parameter;
      866 				/* input: include command list? */
      867   dcl P_print		bit (1) aligned parameter;
      868   dcl P_exists		bit (1) aligned parameter;
      869 
      870   /* GLOBAL imports: ent, bmp,  and sets stp */
      871 
      872   /* Note that P_exists is SET if we FIND a break, but not cleared if we don't
      873*   although the presence of a procedure entry that has no breaks, yet hasn't been
      874*   garbaged collected is a bit frightening */
      875 
      876   do stp = pointer (bmp, procedure_entry.first_statement)
      877        repeat pointer (bmp, statement_item.chain)
      878        while (rel (stp) ^= "0"b);
      879     if statement_item.slots (BREAK_BEFORE) ^= "0"b
      880       then do;
      881         P_exists = "1"b;
      882         if ^P_print
      883 	then
      884 	     return;
      885         call display_break (
      886 	   pointer (stp, statement_item.slots (BREAK_BEFORE)), "1"b,
      887 	   (P_long));
      888       end;
      889     if statement_item.slots (BREAK_AFTER) ^= "0"b then do;
      890         P_exists = "1"b;
      891         if ^P_print
      892 	then
      893 	     return;
      894         call display_break (pointer (stp, statement_item.slots (BREAK_AFTER)),
      895 	   "1"b, (P_long));
      896       end;
      897   end;				/* loop */
      898   end list_all_in;
      899 
      900 
      901 
      902 display_break:
      903   proc (P_bsp, P_want_proc_name, P_long);
      904 
      905   dcl P_bsp		ptr parameter;
      906   dcl P_want_proc_name	bit (1) aligned parameter;
      907   dcl P_long		bit (1) aligned parameter;
      908 
      909   /* GLOBAL! ent stp  *** used by list_break */
      910 
      911   call ioa_$ioa_switch (probe_info.output_switch,
      912        "Break exists ^a ^[ :^a^;^s^]",
      913        formatted_break_line ((ent), (stp), (P_bsp), (P_want_proc_name)),
      914        P_long, P_bsp -> break_slot.command_list);
      915   end display_break;
      916 
      917 formatted_break_line:
      918   proc (P_ent, P_stp, P_bsp, P_proc) returns (char (132) varying);
      919 
      920   dcl P_ent		ptr parameter;
      921   dcl P_stp		ptr parameter;
      922   dcl P_bsp		ptr parameter;
      923   dcl P_proc		bit (1) aligned parameter;
      924   dcl ioa_$rsnnl		entry options (variable);
      925   dcl linestr		char (132) varying;
      926 
      927   dcl 1 map_array		(map_size) like statement_map based (map_ptr);
      928   dcl map_size		fixed bin;
      929   dcl map_ptr		ptr;
      930   dcl number		fixed bin;
      931   dcl file		fixed bin;
      932   dcl line		fixed bin;
      933   dcl stmt		fixed bin;
      934   dcl use_this_name           char(32) unaligned;
      935   
      936 
      937   if (probe_info.language_type ^= C_lang_type) then
      938     use_this_name = P_ent->procedure_entry.segname;
      939   else
      940     use_this_name = P_ent->procedure_entry.entry;
      941 
      942   map_ptr = pointer (P_stp, P_ent -> procedure_entry.statement_map);
      943   map_size = fixed (P_ent -> procedure_entry.statement_map_size, 24);
      944   number = P_stp -> statement_item.number;
      945 
      946   if map_ptr ^= null () & number <= map_size then do;
      947 				/* have legit number */
      948       file = fixed (map_array (number).file, 8);
      949       line = fixed (map_array (number).line, 14);
      950       stmt = fixed (map_array (number).statement, 5);
      951 
      952       call ioa_$rsnnl ("^a line ^[^d-^;^s^]^d^[,^d^;^s^]^[ in ^a^;^s^]",
      953 	 linestr, (0),
      954 	 PLACE (P_bsp -> break_slot.type),
      955 	 file > 0, file,
      956 	 line,
      957 	 stmt > 1, stmt,
      958 	 P_proc, use_this_name);
      959     end;
      960     else do;
      961       call ioa_$rsnnl ("^a|^o", linestr, (0),
      962             use_this_name,
      963 	 fixed (P_bsp -> break_slot.location, 18));
      964     end;
      965 
      966   return (linestr);
      967   end formatted_break_line;
      968 
      969 create_statement_entry:
      970   proc (P_ent, P_bmp, P_number) returns (ptr);
      971 
      972   dcl (
      973       P_ent		ptr,
      974       P_bmp		ptr,
      975       P_number		fixed bin
      976       )			parameter;
      977 
      978   dcl (ent, bmp)		ptr;
      979   dcl new_stmt		ptr;
      980 
      981   ent = P_ent;
      982   bmp = P_bmp;
      983 
      984   new_stmt = allocate_in_breakmap (size (statement_item));
      985   new_stmt -> statement_item.item_type = STATEMENT_ITEM;
      986   new_stmt -> statement_item.number = P_number;
      987   new_stmt -> statement_item.slots = (18)"0"b;
      988   new_stmt -> statement_item.proc_entry = rel (ent);
      989   new_stmt -> statement_item.identifier = ent -> procedure_entry.time_stamp;
      990   new_stmt -> statement_item.chain = ent -> procedure_entry.first_statement;
      991 
      992   ent -> procedure_entry.first_statement = rel (new_stmt);
      993   return (new_stmt);
      994   end create_statement_entry;
      995 
      996 
      997 
      998 delete_statement_entry:
      999   proc ();
     1000 
     1001   /* GLOBAL! bmp ent stp */
     1002 
     1003   /* unthread the statement and delete it */
     1004 
     1005   dcl prev		ptr;	/* to statement item before the one to kill */
     1006 
     1007   if procedure_entry.first_statement = rel (stp)
     1008     then procedure_entry.first_statement = statement_item.chain;
     1009     else do;			/* not first, must search for predecessor */
     1010       do prev = pointer (stp, procedure_entry.first_statement)
     1011 	 repeat pointer (prev, prev -> statement_item.chain)
     1012 	 while (prev -> statement_item.chain ^= rel (stp));
     1013         if prev -> statement_item.chain = "0"b
     1014 				/* NOT FOUND */
     1015 	then call probe_error_$malfunction (probe_info_ptr, 0,
     1016 		"Break statement item ^p not found on chain of proc entry ^p",
     1017 		stp, ent);
     1018       end;			/* search */
     1019       prev -> statement_item.chain = statement_item.chain;
     1020     end;
     1021 
     1022   call release_in_breakmap ((stp));
     1023   end delete_statement_entry;
     1024 
     1025 
     1026 
     1027 
     1028 search_for_stmt:
     1029   proc (P_ent, P_bmp, P_map_number) returns (ptr);
     1030   dcl (
     1031       P_ent		ptr,
     1032       P_bmp		ptr,
     1033       P_map_number		fixed bin
     1034       )			parameter;
     1035 
     1036   dcl bmp			ptr;
     1037   dcl map_number		fixed bin;
     1038   dcl p			ptr;
     1039 
     1040   map_number = P_map_number;
     1041   bmp = P_bmp;
     1042   do p = pointer (bmp, P_ent -> procedure_entry.first_statement)
     1043        repeat (pointer (bmp, p -> statement_item.chain))
     1044        while (rel (p) ^= (18)"0"b);
     1045     if p -> statement_item.number = map_number
     1046       then
     1047 	 return (p);
     1048   end;
     1049   return (null ());
     1050   end search_for_stmt;
     1051 
     1052 
     1053 reset_all_breaks_in:
     1054   proc (P_long, P_pauses_only, P_existed);
     1055 
     1056   /* GLOBAL imports bmp, stp, ent */
     1057 
     1058   dcl P_long		bit (1) aligned parameter;
     1059 				/* shall we tell of them as they go? */
     1060   dcl P_pauses_only		bit (1) aligned parameter;
     1061 				/* ON => reset only breaks set by "step" */
     1062   dcl P_existed		bit (1) aligned parameter;
     1063 				/* set, if we find one - should always happen */
     1064 
     1065   dcl next		ptr;
     1066 
     1067   do stp = pointer (bmp, procedure_entry.first_statement) repeat next
     1068        while (rel (stp) ^= "0"b);
     1069     next = pointer (stp, statement_item.chain);
     1070     if statement_item.slots (BREAK_BEFORE) ^= "0"b then do;
     1071         saved_stp = stp;
     1072         P_existed = "1"b;
     1073         if ^P_pauses_only | ptr (stp, statement_item.slots (BREAK_BEFORE)) ->
     1074 	   break_slot_before.command_list = "pause" || NL
     1075 	then /* a break set by "step" */
     1076 	     call reset_the_break_at (BREAK_BEFORE, (P_long));
     1077 
     1078         if breakmap_deleted_sw
     1079 	then
     1080 	     return;
     1081 
     1082         stp = saved_stp;
     1083       end;
     1084     if statement_item.slots (BREAK_AFTER) ^= "0"b then do;
     1085         saved_stp = stp;
     1086         P_existed = "1"b;
     1087         if ^P_pauses_only | ptr (stp, statement_item.slots (BREAK_AFTER)) ->
     1088 	   break_slot_after.command_list = "pause" || NL
     1089 	then /* a break set by "step" */
     1090 	     /* (shouldn't be any pause breaks after, but) */
     1091 	     call reset_the_break_at (BREAK_AFTER, (P_long));
     1092 
     1093         if breakmap_deleted_sw
     1094 	then
     1095 	     return;
     1096 
     1097         stp = saved_stp;
     1098       end;
     1099   end;				/* stmt loop */
     1100   end reset_all_breaks_in;
     1101 
     1102 
     1103 
     1104 reset_the_break_at:
     1105   proc (P_type, P_long);
     1106 
     1107   dcl P_type		fixed bin parameter;
     1108   dcl P_long		bit (1) aligned parameter;
     1109   dcl other_type		fixed bin;
     1110   dcl breaks_found		bit (1) aligned;
     1111 
     1112   /* GLOBAL! ent bmp stp */
     1113 
     1114   /* Remove the break - replace patched TRA **KLUDGE if active**
     1115*   Free the break slot
     1116*   If statement now empty, then remove it
     1117*   if proc now empty, then remove it
     1118*   if breakmap now empty, then  remove it
     1119*
     1120*   If message desired, give the message
     1121*
     1122*   Note: in version 3 probe, the garbage collecting was only done
     1123*   after an attempt to reset all breaks in a seg.  i suppose that was for efficiency.  In any event,
     1124*   it seems like old proc entries were not pruned.  That bug may have its cause elsewhere, tho.
     1125**/
     1126   breakmap_deleted_sw = "0"b;
     1127 
     1128   if P_long & ^probe_static_info.brief_sw
     1129     then call ioa_$ioa_switch (probe_info.output_switch,
     1130 	    "Break reset ^a",
     1131 	    formatted_break_line ((ent), (stp),
     1132 	    pointer (stp, statement_item.slots (P_type)), "1"b));
     1133 
     1134 
     1135   call remove_break ((P_type));
     1136 
     1137   statement_item.slots (P_type) = "0"b; /* forgotten */
     1138 
     1139   if P_type = BREAK_BEFORE
     1140     then other_type = BREAK_AFTER;
     1141     else other_type = BREAK_BEFORE;
     1142 
     1143   if statement_item.slots (other_type) = "0"b
     1144     then call delete_statement_entry ();
     1145 
     1146   /* Delete the break map if there are no breaks left */
     1147 
     1148   breaks_found = "0"b;
     1149   call list_all_in (BRIEF, NO_PRINT, breaks_found);
     1150   if ^breaks_found then do;
     1151       breakmap_deleted_sw = "1"b;
     1152 
     1153       call delete_breakmap ();
     1154     end;
     1155 
     1156 
     1157   if procedure_entry.first_statement
     1158        = "0"b /* that was last stmt we just deleted */
     1159     then do;
     1160       call restore_readonly ((bmp));
     1161       call probe_seg_mgr_$delete_procedure_entry (probe_info_ptr, ent, code);
     1162 				/* someday, consider macros & symbols */
     1163     end;
     1164 
     1165   end reset_the_break_at;
     1166 
     1167 remove_break:
     1168   proc (P_type);
     1169 
     1170   dcl P_type		fixed bin parameter;
     1171 
     1172   /* GLOBAL bmp, stp */
     1173 
     1174   /* Unset the break. Unlink the slot. Free its storage.
     1175*   it was once thought (judging from the comments) that the way to rese an active break was to set a flag
     1176*   somewhere, then call an entry "release_break" to reset the break when continueing.  After that, somebody
     1177*   changed probe to kludge the probe data structures so that active breaks could be reset.
     1178*   i wonder what happens if the break request list of a break resets the break?????
     1179**/
     1180 
     1181   dcl p			ptr;
     1182   dcl pi_ptr		ptr;	/* to probe_info in past lives */
     1183   dcl patch_place		ptr;	/* where to reset */
     1184   dcl absp		ptr;	/* to slot to kill */
     1185   dcl strange		bit (1) aligned;
     1186 
     1187   dcl based_word		bit (36) aligned based;
     1188 
     1189   absp = pointer (stp, statement_item.slots (P_type));
     1190 
     1191   if P_type = BREAK_AFTER & statement_item.slots (BREAK_BEFORE) ^= "0"b
     1192     then do;			/* may be "strange" */
     1193       p = pointer (stp, statement_item.slots (BREAK_BEFORE));
     1194 				/* pt to break slot for before */
     1195       strange =
     1196 	 p -> break_slot_before.location
     1197 	 = absp -> break_slot_after.location;
     1198     end;
     1199     else strange = "0"b;
     1200 
     1201   patch_place = pointer (absp, absp -> break_slot.location);
     1202 
     1203   if strange then do;
     1204       call relocate_instruction_ (
     1205 	 addr (absp -> break_slot_after.moved_instruction),
     1206 	 addr (p -> break_slot_before.moved_instruction), (0));
     1207       p -> break_slot_before.old_instruction =
     1208 	 absp -> break_slot_after.old_instruction;
     1209       patch_place -> based_word =
     1210 	 rel (addr (p -> break_slot_before.sequence)) || TRA_code;
     1211 				/* ughh */
     1212     end;
     1213     else patch_place -> based_word = absp -> break_slot.old_instruction;
     1214 
     1215   /* KLUDGE TIME - search back through all current invocations of probe for any who were invoked using
     1216*   this break */
     1217 
     1218   if P_type = BREAK_AFTER		/* where to return to */
     1219     then patch_place = addrel (patch_place,
     1220 				/* instruction after broken one */
     1221 	    inst_length_ (addr (absp -> break_slot_after.old_instruction),
     1222 	    (0)));
     1223 
     1224   do pi_ptr = probe_info_ptr
     1225        repeat pi_ptr -> probe_info.listener_info.previous
     1226        while (pi_ptr ^= null ());
     1227     if pi_ptr -> probe_info.break_slot_ptr = absp then do;
     1228         p = pi_ptr -> probe_info.ptr_to_initial_source
     1229 	   -> source_info.stack_ptr -> stack_frame.next_sp;
     1230         break_extension_info_ptr = addrel (p, -size (probe_break_extension));
     1231         probe_break_extension.slot_return_addr = patch_place;
     1232 
     1233         if break_map.version >= 3
     1234 	then pi_ptr -> probe_info.real_break_return_loc =
     1235 		addr (probe_map_sequence_$return);
     1236 	else pi_ptr -> probe_info.real_break_return_loc =
     1237 		addr (probe_map_sequence_$old_return);
     1238       end;
     1239   end;				/* loop */
     1240 
     1241   call release_in_breakmap (absp);
     1242   end remove_break;
     1243 
     1244 create_breakmap:
     1245   proc ();
     1246 
     1247   /* GLOBAL! seginfop SETS! bmp */
     1248 
     1249   dcl segp		ptr;	/* to seg in question */
     1250   dcl correction		fixed bin (24);
     1251   dcl bitcount		fixed bin (24);
     1252   dcl wordcount		fixed bin (35);
     1253   dcl obj_map_ptr		ptr;
     1254 
     1255   dcl 1 last_word_in_seg	aligned based,
     1256        2 map_relp		bit (18) unal,
     1257        2 lower_half		bit (18) unal;
     1258   dcl copy		(copy_count) bit (36) aligned based;
     1259   dcl copy_count		fixed bin;
     1260 
     1261   dcl hcs_$status_mins	entry (ptr, fixed bin (2), fixed bin (24),
     1262 			fixed bin (35));
     1263 
     1264 
     1265   segp = seginfop -> seg_info.symbol_header_ptr;
     1266   call hcs_$status_mins (segp, (0), bitcount, code);
     1267   if code ^= 0
     1268     then goto C_LOSS;
     1269   wordcount = divide (bitcount, 36, 35, 0);
     1270   obj_map_ptr =
     1271        pointer (segp,
     1272        pointer (segp, wordcount - 1) -> last_word_in_seg.map_relp);
     1273 
     1274   bmp = find_breakmap ();
     1275 
     1276   if bmp ^= null ()
     1277     then
     1278          if break_map.name ^= "breakmap" then do;
     1279 	   call probe_error_$record (probe_info_ptr, probe_et_$breaks_exist,
     1280 	        seginfop -> seg_info.segname);
     1281 	   go to RECORDED_MESSAGE;
     1282 	 end;
     1283          else if break_map.version < 3
     1284 	 then code = probe_et_$old_break_map;
     1285   if code ^= 0
     1286     then goto C_LOSS;
     1287 
     1288   if bmp ^= null ()
     1289     then
     1290          return;			/* use existing breakmap */
     1291 
     1292   /* in theory, we are not called if map already existed, so this might be a bug */
     1293 
     1294   /* must create it, aligned for ptr */
     1295 
     1296   wordcount = wordcount + mod (wordcount, 2);
     1297   bmp = pointer (segp, wordcount);
     1298 
     1299   /* may have to extend max length here */
     1300 
     1301   break_map.version = 3;
     1302   break_map.name = "breakmap";
     1303   break_map.identifier = seginfop -> seg_info.bound_create_time;
     1304   break_map.symbol_header = rel (seginfop -> seg_info.bound_sym_header);
     1305 
     1306   /* now copy map_sequence code into break map */
     1307 
     1308   copy_count = probe_map_sequence_$count;
     1309   addr (break_map.map_sequence) -> copy =
     1310        addr (probe_map_sequence_$code) -> copy;
     1311 
     1312   wordcount = wordcount + size (break_map) + copy_count - 2;
     1313 				/* don't count ptr at end of map */
     1314   wordcount = wordcount + mod (wordcount, 2);
     1315   break_map.initial_word_count = wordcount;
     1316   break_map.word_count = bit (binary (wordcount, 18, 0));
     1317 
     1318   /* upper bound is set to fill  page exactly */
     1319   wordcount = fill_to_brim ((wordcount));
     1320   break_map.upper_bound = bit (binary (wordcount, 18, 0));
     1321 
     1322   bitcount = (wordcount + 4) * 36;	/* why the + 4)? */
     1323   call hcs_$set_bc_seg (bmp, bitcount, (0));
     1324 
     1325   pointer (bmp, binary (break_map.upper_bound, 18, 0) + 3)
     1326        -> last_word_in_seg.map_relp = rel (obj_map_ptr);
     1327 
     1328   /* in version 3 probe, a pointer to the break_map was kept in the seg_info for
     1329*   either the bound_seg as  a whole (or the sole seg_info, for unbound).  But we
     1330*   dispense with this as I don't see what use it is (It was used in the break_handler)
     1331**/
     1332 
     1333   if obj_map_ptr -> object_map.decl_vers = object_map_version_2
     1334     then obj_map_ptr -> object_map.break_map_offset = rel (bmp);
     1335     else obj_map_ptr -> old_object_map.break_map_offset = rel (bmp);
     1336   return;
     1337 
     1338 
     1339 
     1340 delete_breakmap:
     1341   entry;
     1342 
     1343   /* GLOBAL bmp! */
     1344 
     1345 
     1346   if addrel (bmp, -1) -> last_word_in_seg.map_relp ^= "0"b
     1347     then correction = 0;
     1348     else correction = -1;		/* break map always begins on even word;
     1349*						   must find real last word */
     1350   obj_map_ptr =
     1351        pointer (bmp,
     1352        addrel (bmp, correction - 1) -> last_word_in_seg.map_relp);
     1353 
     1354   if obj_map_ptr -> object_map.decl_vers = object_map_version_2
     1355     then obj_map_ptr -> object_map.break_map_offset = "0"b;
     1356     else obj_map_ptr -> old_object_map.break_map_offset = "0"b;
     1357 
     1358   copy_count =
     1359        binary (break_map.word_count, 18, 0) - fixed (rel (bmp), 18, 0) + 4;
     1360   bmp -> copy = "0"b;
     1361 
     1362   bitcount = (binary (rel (bmp), 24, 0) + correction) * 36;
     1363 
     1364   call hcs_$set_bc_seg (bmp, bitcount, (0));
     1365   return;
     1366 
     1367 C_LOSS:
     1368   call probe_error_$record (probe_info_ptr, code);
     1369   goto RECORDED_MESSAGE;
     1370 
     1371 
     1372 find_breakmap:
     1373   proc () returns (ptr);
     1374 
     1375   if obj_map_ptr -> object_map.identifier ^= "obj_map "
     1376     then code = probe_et_$non_standard;
     1377 
     1378   else if obj_map_ptr -> object_map.decl_vers = object_map_version_2
     1379     then if obj_map_ptr -> object_map.break_map_offset ^= "0"b
     1380 	 then
     1381 	      return (
     1382 		 pointer (obj_map_ptr,
     1383 		 obj_map_ptr -> object_map.break_map_offset));
     1384 	 else
     1385 	      return (null ());
     1386 
     1387   else if obj_map_ptr -> object_map.decl_vers = 1
     1388     then if obj_map_ptr -> old_object_map.break_map_offset ^= "0"b
     1389 	 then
     1390 	      return (
     1391 		 pointer (obj_map_ptr,
     1392 		 obj_map_ptr -> old_object_map.break_map_offset));
     1393 	 else
     1394 	      return (null ());
     1395 
     1396   else code = probe_et_$non_standard;
     1397   return (null ());
     1398 
     1399   end find_breakmap;
     1400 
     1401   end create_breakmap;		/* and delete_breakmap */
     1402 
     1403 
     1404 
     1405 get_breakmap_ptr:
     1406   proc returns (ptr);
     1407 
     1408   /* GLOBAL! imports ent */
     1409 
     1410   dcl hcs_$initiate		entry (char (*), char (*), char (*),
     1411 			fixed bin (1), fixed bin (2), ptr,
     1412 			fixed bin (35));
     1413   dcl hcs_$terminate_noname	entry (ptr, fixed bin (35));
     1414 
     1415   dcl segp		ptr;
     1416 
     1417 
     1418   call hcs_$initiate (procedure_entry.directory, procedure_entry.entry, "", 0,
     1419        0, segp, (0));
     1420 
     1421   if segp ^= null () then do;		/* still exists, but may be modified */
     1422       segp = pointer (segp, procedure_entry.break_map);
     1423 				/* look where map is spozed to be */
     1424       if segp -> break_map.identifier = procedure_entry.time_stamp
     1425         then
     1426 	   return (segp);
     1427         else call hcs_$terminate_noname (segp, (0));
     1428     end;
     1429 
     1430   /* either seg no longer exists, or has been recompiled.
     1431*   In either case, the procedure entry is obsolete and should be destroyed */
     1432 
     1433   call probe_seg_mgr_$delete_procedure_entry (probe_info_ptr, (ent), (0));
     1434 
     1435   return (null ());
     1436   end get_breakmap_ptr;
     1437 
     1438 ensure_writeable:
     1439   proc (segptr);
     1440 
     1441   dcl segptr		ptr parameter;
     1442 				/* to the seg in question */
     1443 
     1444   dcl hcs_$fs_get_mode	entry (ptr, fixed bin (5), fixed bin (35));
     1445 
     1446   dcl mode		fixed bin (5);
     1447 
     1448 
     1449   call hcs_$fs_get_mode (segptr, mode, code);
     1450   if code ^= 0
     1451     then goto ACL_LOSS;
     1452 
     1453   if divide (mode, 2, 17, 0) < 7 /* we don't have rew */
     1454     then do;
     1455       added_w_sw = "1"b;
     1456       call hcs_$fs_get_path_name (segptr, acl_dn, (0), acl_en, code);
     1457       if code ^= 0 then do;
     1458 ACL_LOSS:
     1459 	call probe_error_$record (probe_info_ptr, code);
     1460 	go to RECORDED_MESSAGE;
     1461         end;
     1462 
     1463       acl_count = 1;
     1464       seg_acl.access_name = get_group_id_ ();
     1465       seg_acl.modes, seg_acl.zero_pad = "0"b;
     1466 
     1467       call hcs_$list_acl (acl_dn, acl_en, null, null, addr (seg_acl), 1, code)
     1468 	 ;
     1469       if seg_acl (1).status_code ^= 0
     1470         then saved_mode_sw = "0"b;
     1471         else do;
     1472 	saved_mode_sw = "1"b;
     1473 	saved_mode = substr (seg_acl (1).modes, 1, 3);
     1474         end;
     1475 
     1476       call set_access ("111"b);	/* force rew */
     1477     end;
     1478 
     1479     else added_w_sw = "0"b;
     1480   return;
     1481 
     1482 
     1483 restore_readonly:
     1484   entry (segptr);
     1485 
     1486 
     1487   if added_w_sw
     1488     then
     1489          if saved_mode_sw
     1490 	 then call set_access (saved_mode);
     1491 	 else call hcs_$delete_acl_entries (acl_dn, acl_en, addr (seg_acl),
     1492 		 1, 0);
     1493 				/* if there was no term for group_id, delete the added one */
     1494   return;
     1495 
     1496 
     1497 set_access:
     1498   proc (new_mode);
     1499 
     1500   dcl new_mode		bit (3) parameter;
     1501 
     1502   seg_acl.modes = new_mode;
     1503 
     1504   call hcs_$add_acl_entries (acl_dn, acl_en, addr (seg_acl), 1, code);
     1505   if code ^= 0
     1506     then goto ACL_LOSS;
     1507   end set_access;
     1508 
     1509   end;				/* ensure_writeable */
     1510 
     1511 
     1512 
     1513 
     1514 
     1515 fill_to_brim:
     1516   proc (wordct) returns (fixed bin (35));
     1517 
     1518   /* given word ct, get next highest word ct that uses its pages to the max. */
     1519 
     1520   dcl wordct		fixed bin (35) parameter;
     1521   dcl wordtp		fixed bin (35);
     1522 
     1523   wordtp = wordct + 1023;		/* make next higher word ct */
     1524   wordtp = divide (wordtp, 1024, 0);	/* number of pages */
     1525   wordtp = multiply (wordtp, 1024, 35, 0);
     1526 				/* restore word ct */
     1527   wordtp = subtract (wordtp, 4, 35, 0); /* dont know why */
     1528 
     1529   return (wordtp);
     1530   end fill_to_brim;
     1531 
     1532 allocate_in_breakmap:
     1533   procedure (required) returns (pointer);
     1534 
     1535   dcl required		fixed bin parameter;
     1536 				/* number of words needed */
     1537 
     1538   dcl needed		fixed bin;/* 0 mod 2 size */
     1539   dcl fip			pointer;
     1540   dcl lfip		pointer;
     1541   dcl word		bit (36) based;
     1542 
     1543   needed = required + mod (required, 2);/* 0 mod 2 size */
     1544   lfip = null ();
     1545   do fip = pointer (bmp, break_map.first_free_item)
     1546        repeat pointer (fip, fip -> free_item.chain)
     1547        while (rel (fip) ^= (18)"0"b);
     1548 
     1549     /* search for a free item that can contain the allocation */
     1550 
     1551     if fip -> free_item.size >= needed then do;
     1552 				/* this one will work */
     1553         if fip -> free_item.size = needed then do;
     1554 				/* occupies entire area */
     1555 	  if lfip ^= null ()
     1556 	    then
     1557 	         lfip -> free_item.chain = fip -> free_item.chain;
     1558 				/* skip this one */
     1559 	    else break_map.first_free_item = fip -> free_item.chain;
     1560 	end;
     1561 	else do;			/* only uses part, let rest remain free */
     1562 	  fip -> free_item.size = fip -> free_item.size - needed;
     1563 	  fip = addrel (fip, fip -> free_item.size);
     1564 				/* use top part */
     1565 	end;
     1566         fip -> item.size = needed;	/* fill in for freeing */
     1567         return (fip);
     1568       end;
     1569 
     1570     lfip = fip;
     1571   end;				/* of loop through chain */
     1572 
     1573   /* if we get here, weither there were no free areas, or there were none large enough, in
     1574*   either case, allocate the space at the end of the segment */
     1575 
     1576   fip = pointer (bmp, break_map.word_count);
     1577   fip -> item.size = needed;
     1578   break_map.word_count =
     1579        bit (add (binary (break_map.word_count, 18, 0), needed, 18, 0));
     1580 
     1581   /* must check if this allocation has overflowed the area, if so we will extend it */
     1582 
     1583   if break_map.word_count > break_map.upper_bound then do;
     1584       break_map.upper_bound =
     1585 	 bit (
     1586 	 subtract (
     1587 	 multiply (divide (add (binary (break_map.word_count, 18, 0),
     1588 	 1023, 18, 0), 1024, 18, 0), 1024, 18, 0), 4, 18, 0));
     1589 
     1590       call hcs_$set_bc_seg (bmp,
     1591 	 multiply (binary (break_map.upper_bound, 18, 0) + 4, 36, 24, 0),
     1592 	 (0));
     1593 				/* an error here will only cause move problems */
     1594       addrel (pointer (bmp, break_map.upper_bound), 3) -> word =
     1595 	 addrel (bmp, -1) -> word;
     1596     end;
     1597   return (fip);
     1598   end allocate_in_breakmap;
     1599 
     1600 
     1601 release_in_breakmap:
     1602   procedure (item_pointer);
     1603 
     1604   dcl item_pointer		pointer,	/* pointer to the item itself */
     1605       ip			pointer,	/* working copies of the above */
     1606       i			fixed bin (35),
     1607 				/* offset of item */
     1608       (p, lp)		pointer;
     1609   dcl copy_overlay		(copy_count) bit (36) aligned based;
     1610 				/* for zeroing */
     1611   dcl copy_count		fixed bin;
     1612 
     1613 
     1614   ip = item_pointer;		/* copy pointers */
     1615   i = binary (rel (ip), 18, 0);
     1616 
     1617   /* first check if item is at the end of the segment */
     1618 
     1619   if i + ip -> item.size
     1620        = binary (break_map.word_count, 18, 0) /* it is at the end */
     1621     then do;
     1622       break_map.word_count = rel (ip);
     1623       copy_count = ip -> item.size;
     1624       ip -> copy_overlay = "0"b;	/* zero out words at the end of a segment */
     1625 
     1626       lp = null ();
     1627       do p = pointer (bmp, break_map.first_free_item)
     1628 	 repeat pointer (p, p -> free_item.chain)
     1629 	 while (rel (p) ^= (18)"0"b); /*  see if this leaves one at the end of the area */
     1630 
     1631         if addrel (p, p -> free_item.size) = ip then do;
     1632 				/* this one is at the end, so remove it */
     1633 	  break_map.word_count = rel (p);
     1634 				/* new length */
     1635 	  if lp ^= null ()		/* remove form chain */
     1636 	    then lp -> free_item.chain = (18)"0"b;
     1637 				/* as items are order, this is the last */
     1638 	    else break_map.first_free_item = (18)"0"b;
     1639 	  copy_count = p -> free_item.size;
     1640 				/* zero it out */
     1641 	  p -> copy_overlay = "0"b;
     1642 	  return;
     1643 	end;
     1644 
     1645       end;
     1646       return;
     1647     end;
     1648 
     1649   /* no, free it within the area */
     1650 
     1651   if break_map.first_free_item then do; /* if this is not the only one, we will have to
     1652*						   check if it is contguous with the others */
     1653       lp = null ();
     1654       do p = pointer (bmp, break_map.first_free_item)
     1655 	 repeat pointer (p, p -> free_item.chain);
     1656 				/* termination condition checked below */
     1657 
     1658         if i < binary (rel (p), 18, 0) then do;
     1659 				/* the item goes here */
     1660 	  if lp ^= null /* if there is a previous item look at it */
     1661 	    then do;
     1662 	      if addrel (lp, lp -> free_item.size)
     1663 		 = ip /* last one and new one touch */
     1664 	        then do;
     1665 		lp -> free_item.size =
     1666 		     lp -> free_item.size + ip -> item.size;
     1667 		ip = lp;		/* we are now interested in the combination */
     1668 	        end;
     1669 	        else do;
     1670 		ip -> free_item.size = ip -> item.size;
     1671 		lp -> free_item.chain = rel (ip);
     1672 	        end;
     1673 	    end;
     1674 	    else do;
     1675 	      ip -> free_item.size = ip -> item.size;
     1676 	      break_map.first_free_item = rel (ip);
     1677 	    end;
     1678 
     1679 	  if addrel (ip, ip -> free_item.size)
     1680 	       = p /* the new one and the next one touch */
     1681 	    then do;
     1682 	      ip -> free_item.size =
     1683 		 ip -> free_item.size + p -> free_item.size;
     1684 	      ip -> free_item.chain = p -> free_item.chain;
     1685 	    end;
     1686 	    else do;
     1687 	      ip -> free_item.chain = rel (p);
     1688 	    end;
     1689 	  return;			/* all done */
     1690 	end;
     1691 
     1692         if p -> free_item.chain
     1693 	   = (18)"0"b /* if this is the end of the chain, put it here */
     1694 	then do;
     1695 	  if addrel (p, p -> free_item.size) = ip
     1696 	    then p -> free_item.size =
     1697 		    p -> free_item.size + ip -> item.size;
     1698 	    else do;
     1699 	      ip -> free_item.size = ip -> item.size;
     1700 	      ip -> free_item.chain = (18)"0"b;
     1701 	      p -> free_item.chain = rel (ip);
     1702 	    end;
     1703 	  return;
     1704 	end;
     1705 
     1706       end;			/* of search through free chain */
     1707 
     1708     end;
     1709 
     1710   /* first free_item, start the chain */
     1711 
     1712   break_map.first_free_item = rel (ip);
     1713   ip -> free_item.chain = (18)"0"b;
     1714   ip -> free_item.size = ip -> item.size;
     1715   return;
     1716 
     1717   end release_in_breakmap;
     1718 
     1719   /* * 			***** DATA STRUCTURES USED IN BREAKS *****
     1720*
     1721*   (also see the probe implementation guide)
     1722*
     1723*   the probe seg (or the break seg) it is in user's homedir and is named [user name].probe
     1724*
     1725*   the object seg containing a break has a section called the breakmap - this begins
     1726*   with a breakmap header.  It is impure object segment.  Only one user may probe (or debug)
     1727*   segment at a time - the results of more than one user attempting to write
     1728*   are undefined
     1729*
     1730*   The break seg begins with a break segment header, which contains the offsets (relative to base of the seg)
     1731*   of the first item of each of the following types:
     1732*
     1733*   PROCEDURE -  a procedure entry describes an object seg that has breaks in it
     1734*   FREE	  - a free item is just some free storage
     1735*   SYMBOL	  - unused today, someday use to hold probe "variables" maybe
     1736*   MACRO	  - unused today, someday can hold request list for probe "macros" maybe
     1737*
     1738*   Note that we do our own allocation and garbage-collection in the probe seg and in the break_map
     1739*   There is no good reason for this! (other than history)  if there were more time, I'd convert them
     1740*   both to be areas.
     1741*
     1742*   In the break map we   have the break map header, and the statement entries (one for each line that has a break)
     1743*   and the break_slots (one for each break).  The last portion of the break_map_header is the "map_sequence",
     1744*   which is object code executed to cause a break.  It is extraordinarily hirsute!
     1745*
     1746*   Statement_items are chained together.  The offset of the first is stored in the corresponding
     1747*   procedure entry in the probe seg.    A statement item has (among other things) the index into the
     1748*   statement_map array for the line it represents, an offset to the procedure entry it is part of
     1749*   (relative to the base of the probe_seg), and the offsets (relative to the base of the object seg) of
     1750*   the break_slots for the breaks before or after its line.
     1751*
     1752*   A break_slot consists of per-break information.  The break request list is stored here
     1753*   (actual characters).  Also the relocated instruction from where the break was.
     1754*
     1755*   Breaks are implemented as a "tra" to a break_slot.  There are eight words of executable code
     1756*   in each break_slot.  The "map_sequence" referred to above is the common code for each type of break.
     1757*   The code in "sequence" for each type of break is:
     1758*
     1759*   * before:  spri	sp|stack_frame.next_sp,*	after:    <instruction>
     1760*   * 	  tsplb	map_sequence			nop	0,du
     1761*   * 	  nop	slot,du				nop	0,du
     1762*   * 	  <instruction>				nop	0,du
     1763*   * 	  nop	0,du				spri	sp|stack_frame.next_sp,*
     1764*   * 	  nop	0,du				tsplb	map_sequence
     1765*   * 	  nop	0,du				nop	slot,du
     1766*   * 	  tra	old_loc+il			tra	old_loc+il
     1767*
     1768*
     1769*   Certain of these instructions are "patched" when the break_slot is created:
     1770*   The offset of the map_sequence, and the location in the object segment to return to.
     1771*   The offset of the break_slot is saved in a "nop" instruction, where the map_sequence code   can get it.
     1772*   The instruction in the object seg is relocated into the break_slot, along with its descriptors if any.
     1773*   The instruction is replaced by a "tra" to the sequence in the break slot.
     1774*
     1775**/
     1776 
  1     1 /*	BEGIN INCLUDE FILE probe_info.incl.pl1		*/
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(88-10-24,WAAnderson), approve(88-10-24,MCR7952),
  1     7*     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
  1     8*     Added field 'retry_using_main' to add new C feature.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* Created: 04/22/79 W. Olin Sibert, from subsystem_info	
  1    13*   Modified: 22 Sept 79 JRd to remove: 	default (ptr & (auto|based)) init (null ());
  1    14*   Added flags.setting_break 08/22/83 Steve Herbst
  1    15*   Added flags.executing_quit_request 01/15/85 Steve Herbst
  1    16**/
  1    17 
  1    18 dcl 1 probe_info aligned based (probe_info_ptr),		/* standard data for a probe invocation */
  1    19     2 probe_info_version fixed bin,			/* version of this structure */
  1    20 
  1    21     2 static_info_ptr pointer unaligned,		/* pointer to static information structure */
  1    22     2 modes_ptr pointer unaligned,			/* pointer to probe_modes structure */
  1    23 
  1    24     2 ptr_to_current_source ptr,			/* current_source is based on this */
  1    25     2 ptr_to_initial_source ptr,			/* initial_source is based on this */
  1    26     2 machine_cond_ptr pointer,			/* pointer to machine conditions, if we faulted to get here */
  1    27 
  1    28     2 token_info aligned,				/* information about token chain currently being processed */
  1    29       3 first_token pointer unaligned,			/* first token in chain */
  1    30       3 ct pointer unaligned, 			/* pointer to current token; updated in MANY places */
  1    31       3 end_token bit (18) aligned,			/* token type at which to stop scanning token chain */
  1    32       3 buffer_ptr pointer unaligned,			/* pointer to input buffer */
  1    33       3 buffer_lth fixed bin (21),			/* and length */
  1    34 
  1    35     2 random_info aligned,
  1    36       3 current_stack_frame pointer unaligned,		/* stack frame pointer for frame in which probe was invoked */
  1    37       3 input_type fixed bin, 			/* current input type */
  1    38       3 language_type fixed bin,			/* current language being processed */
  1    39       3 return_method fixed bin,			/* how we should return after exiting probe */
  1    40       3 entry_method fixed bin,			/* how we got here in the first place */
  1    41       3 pad1 (19) bit (36) aligned,
  1    42 
  1    43     2 break_info,					/* break info -- only interesting if we got here via a break */
  1    44       3 break_slot_ptr pointer,			/* pointer to break slot -- non-null IFF at a break */
  1    45       3 last_break_slot_ptr pointer unaligned,		/* pointer to previous break slot, not presently used */
  1    46       3 break_reset bit (1) aligned,			/* this break has been reset by somebody further on */
  1    47       3 real_break_return_loc pointer,			/* where to REALLY return to, modulo previous bit */
  1    48 
  1    49     2 probe_area_info,				/* information about various probe areas */
  1    50       3 break_segment_ptr pointer unaligned,		/* pointer to Personid.probe */
  1    51       3 break_area_ptr pointer unaligned,		/* pointer to area in break segment */
  1    52       3 scratch_area_ptr pointer unaligned,		/* pointer to probe scratch seg in process dir */
  1    53       3 probe_area_ptr pointer unaligned,		/* This area lasts as long as an invocation of probe. */
  1    54       3 work_area_ptr pointer unaligned,		/* This area lasts as long as the current request line */
  1    55       3 expression_area_ptr pointer unaligned,		/* This area lasts as long as the current command */
  1    56 
  1    57     2 flags aligned,				/* this, in particular, should be saved and restored correctly */
  1    58      (3 execute,					/* "1"b => execute requests, "0"b => just check syntax */
  1    59       3 in_listener,				/* ON => in probe listener loop */
  1    60       3 executing_request,				/* ON => executing a request */
  1    61       3 in_interpret_line,				/* executing in probe_listen_$interpret_line */
  1    62       3 setting_break,				/* executing "after" or "before": check syntax of "if" */
  1    63       3 executing_quit_request,			/* to prevent error looping during "quit" request */
  1    64       3 pad (30)) bit (1) unaligned,
  1    65 
  1    66     2 io_switches,					/* switches probe will do normal I/O on */
  1    67       3 input_switch pointer,
  1    68       3 output_switch pointer,
  1    69 
  1    70     2 error_info,					/* information about the last error saved for later printing */
  1    71       3 error_code fixed bin (35),
  1    72       3 error_message char (300) varying,
  1    73 
  1    74     2 listener_info,				/* internal use by probe listener */
  1    75       3 request_name character (32) varying,		/* primary name of the request being processed */
  1    76       3 abort_probe_label label variable,
  1    77       3 abort_line_label label variable,
  1    78       3 depth fixed binary,				/* count of active invocations of probe */
  1    79       3 previous pointer unaligned,			/* -> previous invocation's info */
  1    80       3 next pointer unaligned,
  1    81 
  1    82     2 end_of_probe_info pointer aligned,
  1    83     2 retry_using_main fixed bin aligned;
  1    84    
  1    85 
  1    86 dcl  probe_info_ptr pointer;
  1    87 
  1    88 dcl  probe_info_version fixed bin static options (constant) initial (1);
  1    89 
  1    90 dcl  probe_info_version_1 fixed bin static options (constant) initial (1);
  1    91 
  1    92 dcl  scratch_area area based (probe_info.scratch_area_ptr);
  1    93 dcl  probe_area area based (probe_info.probe_area_ptr);
  1    94 dcl  work_area area based (probe_info.work_area_ptr);
  1    95 dcl  expression_area area based (probe_info.expression_area_ptr);
  1    96 
  1    97 /*	END INCLUDE FILE probe_info.incl.pl1		*/
     1777 
  2     1 /*	BEGIN INCLUDE FILE probe_static_info.incl.pl1	*/
  2     2 
  2     3 /* *	This include file describes per-process information about probe, such
  2     4*   *	as various options available and the info directories and modes.
  2     5*   *
  2     6*   *	Created: 06/06/79 W. Olin Sibert */
  2     7 
  2     8 dcl 1 probe_static_info aligned based (probe_info.static_info_ptr), /* per-process data about probe */
  2     9     2 probe_info_version fixed bin,			/* same as probe_info.probe_info_version */
  2    10 
  2    11     2 version aligned,
  2    12       3 major_version fixed bin,
  2    13       3 minor_version fixed bin,
  2    14       3 version_string char (32) unaligned,		/* like "4.3f, patch 1" */
  2    15 
  2    16     2 name char (32) unaligned,			/* "probe" */
  2    17     2 prompt character (40) varying,			/* prompt for reading requests */
  2    18     2 switches,
  2    19       3 brief_sw bit (1) unaligned,			/* briefer break messages, no header (default OFF) */
  2    20       3 no_handle_faults_sw bit (1) unaligned,		/* don't handle bad ptr faults (default OFF) */
  2    21       3 recursive_breaks_sw bit (1) unaligned,		/* don't ignore recursive breaks in probe */
  2    22       3 prompt_on_sw bit (1) unaligned,			/* prompt for request lines */
  2    23       3 switch_pad bit (32) unaligned,
  2    24 
  2    25     2 scratch_segment_ptr pointer,			/* pointer to probe_scratch_ -- always valid */
  2    26     2 break_segment_ptr pointer,			/* pointer to Person.breaks -- valid only if needed */
  2    27 
  2    28     2 seg_info_offset_ptr pointer,			/* pointer to seg_info_offset array */
  2    29 
  2    30     2 probe_segno bit (18),				/* segment number of probe itself */
  2    31    2 last_break_segno bit (18),			/* segment number of last interrupted program */
  2    32 
  2    33     2 stack_info aligned,				/* information about the stack trace in probe_scratch_ */
  2    34       3 level_chain pointer unaligned,			/* first level frame entry pointer */
  2    35       3 max_level fixed bin,				/* number of stack levels */
  2    36       3 flags aligned,
  2    37        (4 good_stack,
  2    38         4 traced_with_all,				/* whether the stack trace includes support frames */
  2    39         4 pad1 (34)) bit (1) unaligned,
  2    40 
  2    41     2 modes_ptr pointer unaligned,			/* pointer to modes -- same as probe_info.modes_ptr */
  2    42 
  2    43     2 request_table_info aligned,			/* info for request definitions */
  2    44       3 array_ptr pointer,				/* pointer to array of request table pointers */
  2    45       3 array_size fixed bin, 			/* number of elements in use */
  2    46       3 array_max_size fixed bin,			/* max number of elements in array */
  2    47       3 using_internal_array bit (1) aligned,		/* whether or not we are using the array in probe_static_info */
  2    48 
  2    49     2 io_switches,					/* switches probe does its I/O on */
  2    50       3 input_switch pointer,
  2    51       3 output_switch pointer,
  2    52       3 (private_input_sw, private_output_sw) bit (1) aligned,
  2    53 						/* created by ids, ods and should be destroyed */
  2    54 
  2    55     2 info_directory_info aligned,			/* info about info directories */
  2    56       3 array_ptr pointer,
  2    57       3 array_size fixed bin,
  2    58       3 array_max_size fixed bin,
  2    59       3 using_internal_array bit (1) aligned,
  2    60 
  2    61     2 exclude_name_info aligned,			/* info for exclude array used in printing values */
  2    62       3 array_ptr pointer,
  2    63       3 array_size fixed bin,
  2    64       3 array_max_size fixed bin,
  2    65       3 using_internal_array bit (1) aligned,
  2    66 
  2    67     2 null_seg_info_ptr pointer unaligned,		/* pointer to the "null" seg_info block */
  2    68 
  2    69     2 initial_arrays,				/* initial versions of various arrays */
  2    70       3 request_table_ptr_array (10) pointer aligned,
  2    71       3 info_directory_name_array (3) char (168) unaligned,
  2    72       3 exclude_name_array (6) char (32) unaligned,
  2    73 
  2    74     2 metering_info,					/* last values for "mode meter" */
  2    75       3 last_clock fixed bin (71),
  2    76       3 last_vclock fixed bin (71),
  2    77       3 last_page_faults fixed bin,
  2    78 
  2    79     2 end_of_probe_static_info fixed bin;
  2    80 
  2    81 
  2    82 dcl 1 probe_seg_info_array aligned based (probe_static_info.seg_info_offset_ptr),
  2    83     2 count fixed bin,				/* number of entries in seg_info_offset array */
  2    84     2 seg_info_offset (0 : seg_info_offset_count refer (probe_seg_info_array.count)) bit (18) aligned;
  2    85 
  2    86 dcl  seg_info_offset_count fixed bin;			/* one less than the number of info_offsets */
  2    87 
  2    88 dcl  probe_request_tables (probe_static_info.request_table_info.array_max_size) /* array of request table pointers */
  2    89      pointer aligned based (probe_static_info.request_table_info.array_ptr);
  2    90 
  2    91 dcl  probe_info_directories (probe_static_info.info_directory_info.array_max_size) /* array of info directories */
  2    92      char (168) unaligned based (probe_static_info.info_directory_info.array_ptr);
  2    93 
  2    94 dcl  probe_exclude_names (probe_static_info.exclude_name_info.array_max_size) /* array of exclude names */
  2    95      char (168) unaligned based (probe_static_info.exclude_name_info.array_ptr);
  2    96 
  2    97 /*	END INCLUDE FILE probe_static_info.incl.pl1	*/
     1778 
  3     1 /* BEGIN INCLUDE FILE  ... probe_lang_types.incl.pl1
  3     2*
  3     3*   JRD 26 June 79
  3     4*   MBW 31 July 1981 to add algol68 */
  3     5 
  3     6 
  3     7 /****^  HISTORY COMMENTS:
  3     8*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  3     9*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  3    10*     Added C Language type.
  3    11*                                                   END HISTORY COMMENTS */
  3    12 
  3    13 
  3    14 /*   Modified June 83 JMAthane to add PASCAL language type */
  3    15 /*   Modified April 88 Hinatsu to add C language type */
  3    16 
  3    17      dcl	   (UNKNOWN_lang_type     init (1),
  3    18 	   OTHER_lang_type	      init (2),
  3    19 	   PL1_lang_type	      init (3),
  3    20 	   FORTRAN_lang_type      init (4),
  3    21 	   COBOL_lang_type	      init (5),
  3    22 	   ALM_lang_type	      init (6),
  3    23 	   ALGOL68_lang_type      init (7),
  3    24 	   PASCAL_lang_type	      init (8),
  3    25 	   C_lang_type	      init (9)) fixed bin internal static options (constant);
  3    26 
  3    27      dcl	   official_language_names (9) char (32) internal static options (constant) init
  3    28 			      ("Unknown", "other", "PL/I", "FORTRAN", "COBOL", "ALM", "Algol 68", "Pascal", "C");
  3    29 
  3    30      dcl	   palatable_language_names (9) char (32) internal static options (constant) init
  3    31 			      ("Unknown", "Other", "pl1", "fortran", "cobol", "alm", "algol68", "pascal", "c");
  3    32 
  3    33 /* END INCLUDE FILE ... probe_lang_types.incl.pl1 */
     1779 
  4     1 /* BEGIN INCLUDE FILE ... probe_source_info.incl.pl1
  4     2*
  4     3*  James R. Davis 2 July 79 */
  4     4 
  4     5 dcl 1 source_info based aligned,
  4     6       2 stmnt_map_entry_index fixed bin,		/* index in stmnt map for this stmnt */
  4     7       2 instruction_ptr ptr,				/* to last instruction executed  */
  4     8       2 block_ptr ptr,				/* to runtime_block node */
  4     9       2 stack_ptr ptr,				/* to a stack frame */
  4    10       2 entry_ptr ptr,				/* to entry seq. for this proc */
  4    11       2 seg_info_ptr ptr;				/* to seg_info */
  4    12 
  4    13 dcl 1 current_source aligned like source_info based (probe_info.ptr_to_current_source);
  4    14 dcl 1 initial_source aligned like source_info based (probe_info.ptr_to_initial_source);
  4    15 
  4    16 /* END INCLUDE FILE ... probe_source_info.incl.pl1 */
     1780 
  5     1 /* BEGIN INCLUDE FILE ... probe_seg_info.incl.pl1
  5     2*
  5     3*   25 June 79 JRDavis
  5     4*
  5     5*   Modified  7 April 1983, TO - Add fields for character offset/line
  5     6*	correction per file.
  5     7**/
  5     8 
  5     9 dcl 1 seg_info based aligned,				/* place to remember information about object seg */
  5    10     2 language_type fixed bin,			/* language of source program */
  5    11     2 bits aligned,
  5    12       3 ignore_case bit (1) unal,
  5    13       3 bound_segment bit (1) unaligned,
  5    14       3 component bit (1) unaligned,
  5    15       3 pad bit (33) unal,
  5    16     2 names,					/* where to find it */
  5    17       3 directory_name character (168) unal,		/* what directory */
  5    18       3 entry_name character (32) unal,			/* what segment */
  5    19       3 segname character (32) unal,			/* procedure segname definition */
  5    20     2 identifier fixed bin (71),			/* time of object creation */
  5    21     2 pointers,					/* location of various parts of segment */
  5    22       3 symbol_header_ptr ptr unal,			/* to symbol section */
  5    23       3 original_source_ptr ptr unal,			/* to segment source map */
  5    24       3 statement_map_ptr ptr unal,			/* to segment statement map */
  5    25       3 break_info ptr unal,				/* for unbound segments, and start of chain for
  5    26*						   bound ones, -> break_map !obsolete, I think! */
  5    27       3 chain ptr unal,				/* to entry for next component if bound */
  5    28       3 linkage_ptr ptr unal,				/* to linkage section */
  5    29     2 bounds aligned,				/* structure of bounds information */
  5    30       3 text_bounds,
  5    31         4 start fixed bin (35),
  5    32         4 end fixed bin (35),
  5    33       3 symbol_bounds,
  5    34         4 start fixed bin (35),
  5    35         4 end fixed bin (35),
  5    36     2 map_size fixed bin,				/* size of statement map */
  5    37     2 error_code fixed bin (35),			/* errors encoutered while getting info, are recorded here */
  5    38     2 bound_create_time fixed bin (71),			/* time seg containing was bound or compiled. */
  5    39     2 bound_sym_header ptr unal,			/* to sym. section header for bound seg */
  5    40     2 pad (1) fixed bin (35),
  5    41 
  5    42     2 nfiles fixed bin,
  5    43     2 per_file (seg_info_nfiles refer (seg_info.nfiles)),
  5    44       3 file_pointers ptr unal,
  5    45       3 break_line (0:3) fixed bin (18) unsigned unaligned;
  5    46 
  5    47 dcl  seg_info_nfiles fixed bin;			/* for allocation purposes */
  5    48 
  5    49 
  5    50 /* END INCLUDE FILE ... probe_seg_info.incl.pl1 */
     1781 
  6     1 /* BEGIN INCLUDE FILE ...  probe_break_slot.incl.pl1
  6     2*
  6     3*   This is separate from probe_break_info.incl.pl1 because many programs
  6     4*   need to get at a break_slot, but don't deserve to see the rest of that information
  6     5*
  6     6**/
  6     7 
  6     8 dcl 1 break_slot based (bsp) aligned,			/* describes (and handles) each probe break */
  6     9     2 item_type fixed bin,				/* 0 -> break_slot type code */
  6    10     2 breakmap_header_offset bit (18) unal,		/* to break map header, chain is not used */
  6    11     2 statement_item_offset bit (18) unal,
  6    12     2 size fixed bin,				/* number of words in the break_slot */
  6    13     2 sequence (0:7),				/* "before" or "after" instructions to "trap" the break */
  6    14       3 offset bit (18) unaligned,			/* address portion, some patched */
  6    15       3 skip bit (18) unaligned,			/* op code portion */
  6    16     2 old_instruction bit (36) aligned,			/* instruction that was replaced by break */
  6    17     2 symbol_block_offset bit (18) unal,		/*  for containing block */
  6    18     2 location bit (18) unal,				/* offset of instruction that was replaced by break */
  6    19     2 type fixed bin,				/* 0 -> after, 1 -> before */
  6    20     2 count fixed bin,				/* number of characters in command list */
  6    21     2 command_list character (0 refer (break_slot.count));	/* command list associated with break */
  6    22 
  6    23 dcl bsp ptr;
  6    24 
  6    25 dcl (BREAK_AFTER init (0),
  6    26      BREAK_BEFORE init (1),
  6    27      BREAK_AT init (2)) fixed bin internal static options (constant);
  6    28 
  6    29 dcl  PLACE (0:2) char (8) aligned internal static options (constant) init ("after", "before", "at");
  6    30 
  6    31 /* END INCLUDE FILE ... probe_break_slot.incl.pl1 */
     1782 
  7     1 /* BEGIN INCLUDE FILE ... probe_break_extension.incl.pl1
  7     2*
  7     3*   Written 11 Sept 79 by James R. Davis
  7     4*
  7     5*   When a break occurs, the callers stack is grown to accomidate this structure.
  7     6*   It is used to  restart the break.  The "machine builtins" will use this
  7     7*   structure someday
  7     8*
  7     9**/
  7    10 
  7    11 dcl 1 probe_break_extension aligned based (break_extension_info_ptr),
  7    12     2 prs (0:7) ptr,				/* 0 -15 */
  7    13     2 regs aligned,					/* 16 -23 */
  7    14       3 x (0:7) bit (18) unal,
  7    15       3 a bit (36) aligned,				/* 20 */
  7    16       3 q bit (36) aligned,				/* 21 */
  7    17       3 ext,
  7    18         4 e bit (8) unal,
  7    19         4 pad1 bit (28) unal,
  7    20       3 time_and_ralr,				/* 23 */
  7    21         4 tr bit (27) unal,
  7    22         4 pad2 bit (6) unal,
  7    23         4 ralr bit (3) unal,
  7    24     2 unused1 bit (36),				/* 24 */
  7    25     2 unused2 bit (36),				/* 25 */
  7    26     2 indicators bit (36),				/* 26 */
  7    27     2 unused3 bit (36),				/* 27 */
  7    28     2 slot_return_addr ptr,				/* 28,	 29 */
  7    29     2 old_retptr_value ptr;				/* 30, 31 */
  7    30 
  7    31 dcl  break_extension_info_ptr ptr;
  7    32 
  7    33 /* END INCLUDE FILE  probe_break_extension.incl.pl1 */
  7    34 
     1783 
  8     1 /*	BEGIN INCLUDE FILE probe_break_info.incl.pl1
  8     2*   Removed from probe_break_mgr_, 05/18/79 WOS
  8     3*
  8     4*   Some of these things are found only in the probe segment (the break segment)
  8     5*   such as "break_segment", "procedure_entry".
  8     6*   If "macro_item" or   "symbol_item" were used, they'd go there, too.
  8     7*   If probe_modes were kept in   the probe seg, they'd go there too.
  8     8*   In the break_map of an object seg go "break_map", and "statement_item" and
  8     9*   "break_slot" (there are two flavors of break_slot, one for "before",
  8    10*   and one for "after".  The astute reader will notice that they are both the
  8    11*   same , except in how they arrange the eight words in "sequence".  For cases
  8    12*   where what is of interest is not in those eigth words, the more general "break_slot"
  8    13*   structure may be used.  It may come to pass in the future that before and after will
  8    14*   look different, of course.
  8    15*
  8    16*   James R. Davis 23 Sept 79
  8    17*
  8    18*   "symbol_item" removed, because probe variables are implemented differently
  8    19*   then JMB seemed to envision.  SYMBOL_ITEM is left for compatibility, but not used
  8    20**/
  8    21 
  8    22 dcl 1 break_segment based (break_segp) aligned,		/* declaration of header for break segment */
  8    23     2 version fixed bin initial (2),			/* version number */
  8    24     2 name character (8) initial ("breakseg"),
  8    25     2 upper_bound bit (18) unal,			/* as described above */
  8    26     2 word_count bit (18) unal,
  8    27     2 first_free_item bit (18) unal,
  8    28     2 first_procedure_entry bit (18) unal,		/* the break procedure only has procedure entries */
  8    29     2 first_symbol bit (18) unal,			/* can be deleted */
  8    30     2 first_macro bit (18) unal;
  8    31 
  8    32 dcl  break_segp pointer;
  8    33 
  8    34 dcl 1 break_map based (bmp) aligned,			/* declaration of header for break map */
  8    35     2 version fixed bin initial (2),			/* version number */
  8    36     2 name character (8) initial ("breakmap"),
  8    37     2 upper_bound bit (18) unal,
  8    38     2 word_count bit (18) unal,
  8    39     2 first_free_item bit (18) unal,			/* as above */
  8    40     2 symbol_header bit (18) unal,			/* to symbol section of entire object seg */
  8    41     2 initial_word_count fixed bin (35),		/* low water mark for allocations */
  8    42     2 identifier fixed bin (71),			/* unique id of entire segment */
  8    43     2 map_sequence pointer;				/* beginning of code to call break handler */
  8    44 						/* pointer to align on double word */
  8    45 
  8    46 dcl 1 item based aligned,				/* canonical declaration for all items */
  8    47     2 item_type fixed bin,				/* separates different types */
  8    48     2 unused bit (18) unaligned,
  8    49     2 chain bit (18) unaligned,			/* to next item of same type or (18)"0"b */
  8    50     2 size fixed bin;				/* number of words occupied by this item */
  8    51 
  8    52 dcl 1 free_item based aligned,			/* little bundle of free storage */
  8    53     2 size fixed bin,				/* number free words contained here */
  8    54     2 unused bit (18) unaligned,
  8    55     2 chain bit (18) unaligned,
  8    56     2 zeros bit (0);				/* area to zero out when freed */
  8    57 
  8    58 dcl 1 procedure_entry based (ent) aligned,		/* one entry for each procedure that has breaks */
  8    59     2 item_type fixed bin initial (PROCEDURE_ITEM),	/* as for all other items */
  8    60     2 unused bit (18) unaligned,
  8    61     2 chain bit (18) unaligned,
  8    62     2 size fixed bin,
  8    63     2 directory character (168) unal,			/* directory portion of segment pathname */
  8    64     2 entry character (32) unal,			/* entry portion of pathname */
  8    65     2 segname character (32) unal,			/* name of "main" entry */
  8    66     2 pad fixed bin (71),				/* formerly time of proc. creation */
  8    67     2 time_stamp fixed bin (71),			/* time of creation of containing seg. */
  8    68     2 first_statement bit (18) unal,			/* chain of statements with breaks */
  8    69     2 first_symbol bit (18) unal,			/* not used */
  8    70     2 first_macro bit (18) unal,
  8    71     2 first_debug_break bit (18) unal,			/* chain of debug style breaks (not used yet) */
  8    72     2 break_map bit (18) unal,			/* offset in object seg of break map */
  8    73     2 statement_map bit (18) unal,			/* offset in object seg of map for this proc */
  8    74     2 statement_map_size bit (18) unal,			/* number of entries in map */
  8    75     2 source_map bit (18) unal,			/* offset of source map for proc */
  8    76     2 symbol_header bit (18) unal,			/* offset of symbol section for this proc */
  8    77     2 bounds aligned,				/* structure of bounds information */
  8    78       3 text_bounds,
  8    79         4 start fixed bin (35),
  8    80         4 end fixed bin (35),
  8    81       3 symbol_bounds,
  8    82         4 start fixed bin (35),
  8    83         4 end fixed bin (35),
  8    84     2 language_type fixed bin;			/* code for language of source program */
  8    85 
  8    86 dcl 1 statement_item based (stp) aligned,		/* each statement with a break has a map entry */
  8    87     2 item_type fixed bin initial (STATEMENT_ITEM),
  8    88     2 unused bit (18) unaligned,
  8    89     2 chain bit (18) unaligned,
  8    90     2 size fixed bin,
  8    91     2 identifier fixed bin (71),			/* id of proc this stmt is in */
  8    92     2 proc_entry bit (18) unal,			/* offset of proc entry in break seg */
  8    93     2 number fixed bin,				/* statement number */
  8    94     2 slots (0:1) bit (18);				/* offset of break slots for insert and append */
  8    95 
  8    96 /* unused, here only as indication of what JMB (Amen!) may have had in mind 
  8    97*   for probe macros.  For the record, it looked like he was going to do
  8    98*   probe variables in a similar way, and they are not done the way he seemed
  8    99*  to envision.
  8   100**/
  8   101 
  8   102 dcl 1 macro_item based aligned,			/* definition of a probe macro */
  8   103     2 item_type fixed bin initial (MACRO_ITEM),
  8   104     2 unused bit (18) unaligned,
  8   105     2 chain bit (18) unaligned,
  8   106     2 size fixed bin,
  8   107     2 name character (32),				/* macro name */
  8   108     2 count fixed bin,				/* number of characters in command list */
  8   109     2 command_list character (0);			/* place to put command list */
  8   110 
  8   111 
  8   112 dcl 1 break_slot_before aligned based (before_slot_ptr),
  8   113     2 item_type fixed bin init (BREAK_ITEM),
  8   114     2 breakmap_header_offset bit (18) unal,
  8   115     2 statement_item_offset bit (18) unal,
  8   116     2 size fixed bin,
  8   117     2 sequence,					/* eight words */
  8   118       3 word0 bit (36) init (SPRI_wd),
  8   119       3 word1,
  8   120         4 map_seq_offset bit (18) unal,
  8   121         4 opcode bit (18) unal init (TSPLB_code),
  8   122       3 word2,
  8   123         4 slot_offset bit (18) unal,
  8   124         4 opcode bit (18) unal init (NOP_code),
  8   125       3 moved_instruction bit (36),			/* first instr. of line, executed after break has occured */
  8   126       3 moved_descs (3),				/* descriptors if needed */
  8   127         4 offset bit (18) unal init (0),
  8   128         4 opcode bit (18) unal init (NOP_code),		/* and harmless NOP if not */
  8   129       3 return,
  8   130         4 offset bit (18) unal,			/* patched to be place to return to after break */
  8   131         4 opcode bit (18) unal init (TRA_code),
  8   132     2 old_instruction bit (36),			/* former occupant, sans relocation */
  8   133     2 symbol_block_offset bit (18) unal,
  8   134     2 location bit (18) unal,
  8   135     2 type fixed bin init (BREAK_BEFORE),
  8   136     2 count fixed bin,
  8   137     2 command_list char (command_list_size refer (break_slot_before.count));
  8   138 
  8   139 dcl 1 break_slot_after aligned based (after_slot_ptr),
  8   140     2 item_type fixed bin init (BREAK_ITEM),
  8   141     2 breakmap_header_offset bit (18) unal,
  8   142     2 statement_item_offset bit (18) unal,
  8   143     2 size fixed bin,
  8   144     2 sequence,
  8   145       3 moved_instruction bit (36),			/* happens before the break occurs */
  8   146       3 moved_descs (3),
  8   147         4 offset bit (18) unal init ((3)0),
  8   148         4 opcode bit (18) unal init ((3) NOP_code),
  8   149       3 word4 bit (36) init (SPRI_wd),
  8   150       3 word5,
  8   151         4 map_seq_offset bit (18) unal,
  8   152         4 opcode bit (18) unal init (TSPLB_code),
  8   153       3 word6,
  8   154         4 slot_offset bit (18) unal,
  8   155         4 opcode bit (18) unal init (NOP_code),
  8   156       3 return,
  8   157         4 offset bit (18) unal,
  8   158         4 opcode bit (18) unal init (TRA_code),
  8   159     2 old_instruction bit (36),			/* former occupant, sans relocation */
  8   160     2 symbol_block_offset bit (18) unal,
  8   161     2 location bit (18) unal,
  8   162     2 type fixed bin init (BREAK_AFTER),
  8   163     2 count fixed bin,
  8   164     2 command_list char (command_list_size refer (break_slot_before.count));
  8   165 
  8   166 
  8   167 /* we need these next two because PL/I wont take size(break_slot_before.sequence) */
  8   168 dcl size_of_after_sequence fixed bin internal static init (8) options (constant);
  8   169 dcl size_of_before_sequence fixed bin internal static init (8)  options (constant);
  8   170 
  8   171 
  8   172 dcl (BREAK_ITEM init (0),
  8   173      STATEMENT_ITEM init (1),
  8   174      SYMBOL_ITEM init (2),				/* will never be used */
  8   175      MACRO_ITEM init (3),				/* not used now */
  8   176      PROCEDURE_ITEM init (4)) fixed bin internal static options (constant);
  8   177 
  8   178 dcl  command_list_size fixed bin (21);
  8   179 
  8   180 dcl (ent, bmp, stp, before_slot_ptr, after_slot_ptr) ptr;
  8   181 
  8   182 dcl  SPRI_wd bit (36) init ("600022254120"b3);		/* spri sp|stack_frame.next_sp,* */
  8   183 
  8   184 dcl (NOP_code init ("011003"b3),
  8   185      TSPLB_code init ("671000"b3),
  8   186      TRA_code init ("710000"b3)) internal static options (constant) bit (18) unal;
  8   187 
  8   188 
  8   189 /* END INCLUDE FILE  ... probe_break_info.incl.pl1 */
     1784 
  9     1 /* BEGIN INCLUDE FILE ... object_map.incl.pl1 */
  9     2 /* coded February 8, 1972 by Michael J. Spier */
  9     3 /* Last modified on 05/20/72 at 13:29:38 by R F Mabee. */
  9     4 /* Made to agree with Spier's document on 20 May 1972 by R F Mabee. */
  9     5 /* modified on 6 May 1972 by R F Mabee to add map_ptr at end of object map. */
  9     6 /* modified May, 1972 by M. Weaver */
  9     7 /* modified 5/75 by E. Wiatrowski and 6/75 by M. Weaver */
  9     8 /* modified 5/77 by M. Weaver to add perprocess_static bit */
  9     9 
  9    10  declare	1 object_map aligned based,		/* Structure describing standard object map */
  9    11 
  9    12 	  2 decl_vers fixed bin,		/* Version number of current structure format */
  9    13 	  2 identifier char (8) aligned,	/* Must be the constant "obj_map" */
  9    14 	  2 text_offset bit (18) unaligned,	/* Offset relative to base of object segment of base of text section */
  9    15 	  2 text_length bit (18) unaligned,	/* Length in words of text section */
  9    16 	  2 definition_offset bit (18) unaligned, /* Offset relative to base of object seg of base of definition section */
  9    17 	  2 definition_length bit (18) unaligned, /* Length in words of definition section */
  9    18 	  2 linkage_offset bit (18) unaligned,	/* Offset relative to base of object seg of base of linkage section */
  9    19 	  2 linkage_length bit (18) unaligned,	/* Length in words of linkage section */
  9    20 	  2 static_offset bit (18) unaligned,   /* Offset relative to base of obj seg of static section */
  9    21 	  2 static_length bit (18) unaligned,   /* Length in words of static section */
  9    22 	  2 symbol_offset bit (18) unaligned,	/* Offset relative to base of object seg of base of symbol section */
  9    23 	  2 symbol_length bit (18) unaligned,	/* Length in words of symbol section */
  9    24 	  2 break_map_offset bit (18) unaligned, /* Offset relative to base of object seg of base of break map */
  9    25 	  2 break_map_length bit (18) unaligned, /* Length in words of break map */
  9    26 	  2 entry_bound bit (18) unaligned,	/* Offset in text of last gate entry */
  9    27 	  2 text_link_offset bit (18) unaligned, /* Offset of first text-embedded link */
  9    28 	  2 format aligned,			/* Word containing bit flags about object type */
  9    29 	    3 bound bit (1) unaligned,	/* On if segment is bound */
  9    30 	    3 relocatable bit (1) unaligned,	/* On if segment has relocation info in its first symbol block */
  9    31 	    3 procedure bit (1) unaligned,	/* On if segment is an executable object program */
  9    32 	    3 standard bit (1) unaligned,	/* On if segment is in standard format (more than just standard map) */
  9    33 	    3 separate_static bit(1) unaligned, /* On if static is a separate section from linkage */
  9    34 	    3 links_in_text bit (1) unaligned,	/* On if there are text-embedded links */
  9    35 	    3 perprocess_static bit (1) unaligned, /* On if static is not to be per run unit */
  9    36 	    3 unused bit (29) unaligned;        /* Reserved */
  9    37 
  9    38 declare	map_ptr bit(18) aligned based;	/* Last word of the segment. It points to the base of the object map. */
  9    39 
  9    40 declare	object_map_version_2 fixed bin static init(2);
  9    41 
  9    42 /* END INCLUDE FILE ... object_map.incl.pl1 */
     1785 
 10     1 /*	BEGIN INCLUDE FILE probe_old_object_map.incl.pl1 */
 10     2 /* Extracted from probe_break_mgr_ 05/18/79 WOS		*/
 10     3 
 10     4 /* This declaration of the object map was copied from System 3.0 on 750722.
 10     5*   It describes the (soon to be) obsolete version 1 object map. */
 10     6 
 10     7 dcl 1 old_object_map aligned based,
 10     8 
 10     9     2 decl_vers fixed bin,
 10    10     2 identifier char (8) aligned,
 10    11     2 text_offset bit (18) unaligned,
 10    12     2 text_length bit (18) unaligned,
 10    13     2 definition_offset bit (18) unaligned,
 10    14     2 definition_length bit (18) unaligned,
 10    15     2 linkage_offset bit (18) unaligned,
 10    16     2 linkage_length bit (18) unaligned,
 10    17     2 symbol_offset bit (18) unaligned,
 10    18     2 symbol_length bit (18) unaligned,
 10    19     2 break_map_offset bit (18) unaligned,
 10    20     2 break_map_length bit (18) unaligned,
 10    21     2 format aligned,
 10    22       3 bound bit (1) unaligned,
 10    23       3 relocatable bit (1) unaligned,
 10    24       3 procedure bit (1) unaligned,
 10    25       3 standard bit (1) unaligned,
 10    26       3 unused bit (14) unaligned,
 10    27     2 map_ptr bit (18) aligned;
 10    28 
 10    29 /*	END INCLUDE FILE probe_old_object_map.incl.pl1 */
     1786 
 11     1 
 11     2      declare	/*  Structures used in acl manipulation.  - J.M. Broughton 07/27/73 */
 11     3 
 11     4 
 11     5 	1 segment_acl (acl_count) based (acl_ptr) aligned,
 11     6 	  2 access_name character (32),			/* process to which this entry applies */
 11     7 	  2 modes bit (36),					/* read, execute, and write */
 11     8 	  2 zero_pad bit (36),				/* for extended acl */
 11     9 	  2 status_code fixed bin(35),			/* standard error code for this entry only */
 11    10 
 11    11 
 11    12 	1 dir_acl (acl_count) based (acl_ptr) aligned,
 11    13 	  2 access_name character (32),			/* process to which entry applys */
 11    14 	  2 dir_modes bit (36),				/* status, modify, and append */
 11    15 	  2 status_code fixed bin(35),			/* as above */
 11    16 
 11    17 
 11    18 	acl_count fixed bin,				/* number of entries in these structures */
 11    19 	acl_ptr pointer;					/* pointer to these structures */
 11    20 
 11    21 
     1787 
 12     1 dcl	1 statement_map	aligned based,
 12     2 	2 location	bit(18) unaligned,
 12     3 	2 source_id	unaligned,
 12     4 	  3 file		bit(8),
 12     5 	  3 line		bit(14),
 12     6 	  3 statement	bit(5),
 12     7 	2 source_info	unaligned,
 12     8 	  3 start		bit(18),
 12     9 	  3 length	bit(9);
     1788 
 13     1 /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
 13     2 
 13     3 /* format: off */
 13     4 
 13     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
 13     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
 13     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
 13     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
 13     9 
 13    10 
 13    11 /****^  HISTORY COMMENTS:
 13    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
 13    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
 13    14*     Modified to add constants for the translator_id field in the stack_frame
 13    15*     structure.
 13    16*                                                   END HISTORY COMMENTS */
 13    17 
 13    18 
 13    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
 13    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
 13    21 						/* with indicators (nonzero for Fortran hexfp caller) */
 13    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
 13    23 
 13    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
 13    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
 13    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
 13    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
 13    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
 13    29 
 13    30 
 13    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
 13    32 
 13    33 dcl  stack_frame_min_length fixed bin static init(48);
 13    34 
 13    35 
 13    36 dcl 1 stack_frame based(sp) aligned,
 13    37     2 pointer_registers(0 : 7) ptr,
 13    38     2 prev_sp pointer,
 13    39     2 next_sp pointer,
 13    40     2 return_ptr pointer,
 13    41     2 entry_ptr pointer,
 13    42     2 operator_and_lp_ptr ptr,			/* serves as both */
 13    43     2 arg_ptr pointer,
 13    44     2 static_ptr ptr unaligned,
 13    45     2 support_ptr ptr unal, /* only used by fortran I/O */
 13    46     2 on_unit_relp1 bit(18) unaligned,
 13    47     2 on_unit_relp2 bit(18) unaligned,
 13    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
 13    49*						   0 => PL/I version II
 13    50*						   1 => ALM
 13    51*						   2 => PL/I version I   
 13    52*						   3 => signal caller frame
 13    53*						   4 => signaller frame */
 13    54     2 operator_return_offset bit(18) unaligned,
 13    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
 13    56     2 a bit(36),					/* accumulator */
 13    57     2 q bit(36),					/* q-register */
 13    58     2 e bit(36),					/* exponent */
 13    59     2 timer bit(27) unaligned,				/* timer */
 13    60     2 pad bit(6) unaligned,
 13    61     2 ring_alarm_reg bit(3) unaligned;
 13    62 
 13    63 
 13    64 dcl 1 stack_frame_flags based(sp) aligned,
 13    65     2 pad(0 : 7) bit(72),				/* skip over prs */
 13    66     2 xx0 bit(22) unal,
 13    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
 13    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
 13    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
 13    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
 13    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
 13    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
 13    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
 13    74     2 condition bit(1) unal,				/* on if condition established in this frame */
 13    75     2 xx0a bit(6) unal,
 13    76     2 xx1 fixed bin,
 13    77     2 xx2 fixed bin,
 13    78     2 xx3 bit(25) unal,
 13    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
 13    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
 13    81     2 xx3a bit(9) unaligned,
 13    82     2 xx4(9) bit(72) aligned,
 13    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
 13    84*						*  operator puts a pointer to the base of
 13    85*						*  the calling procedure here. (text base ptr)  */
 13    86     2 xx5 bit(72) aligned,
 13    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
 13    88 
 13    89 /* format: on */
 13    90 
 13    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
     1789 
     1790 
     1791   end probe_break_mgr_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1132.2  probe_break_mgr_.pl1              >udd>sm>ds>w>ml>probe_break_mgr_.pl1
1777         1    10/27/88  1439.2  probe_info.incl.pl1               >ldd>incl>probe_info.incl.pl1
1778         2    11/12/82  1724.3  probe_static_info.incl.pl1        >ldd>incl>probe_static_info.incl.pl1
1779         3    10/26/88  1355.5  probe_lang_types.incl.pl1         >ldd>incl>probe_lang_types.incl.pl1
1780         4    11/26/79  1420.6  probe_source_info.incl.pl1        >ldd>incl>probe_source_info.incl.pl1
1781         5    11/02/83  1945.0  probe_seg_info.incl.pl1           >ldd>incl>probe_seg_info.incl.pl1
1782         6    07/15/80  1828.8  probe_break_slot.incl.pl1         >ldd>incl>probe_break_slot.incl.pl1
1783         7    11/26/79  1421.0  probe_break_extension.incl.pl1    >ldd>incl>probe_break_extension.incl.pl1
1784         8    07/15/80  1828.8  probe_break_info.incl.pl1         >ldd>incl>probe_break_info.incl.pl1
1785         9    08/05/77  1122.5  object_map.incl.pl1               >ldd>incl>object_map.incl.pl1
1786        10    11/26/79  1420.7  probe_old_object_map.incl.pl1     >ldd>incl>probe_old_object_map.incl.pl1
1787        11    02/13/75  1718.9  acls.incl.pl1                     >ldd>incl>acls.incl.pl1
1788        12    05/06/74  1851.6  statement_map.incl.pl1            >ldd>incl>statement_map.incl.pl1
1789        13    11/07/86  1650.3  stack_frame.incl.pl1              >ldd>incl>stack_frame.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BREAK_AFTER                            constant        fixed bin(17,0)          initial dcl 6-25 set ref 8-139 390 551 551 554 554
                                                                                  696 696 699* 809 889 894 894 1084 1087 1087* 1139
                                                                                  1191 1218
BREAK_AT                               constant        fixed bin(17,0)          initial dcl 6-25 ref 544 551 687 696
BREAK_BEFORE                           constant        fixed bin(17,0)          initial dcl 6-25 set ref 8-112 314 326 361 366 497
                                                                                  501 544 544 547 547 687 687 690* 804 879 885 885
                                                                                  1070 1073 1073* 1139 1141 1191 1193
BREAK_ITEM                             constant        fixed bin(17,0)          initial dcl 8-172 ref 464
BRIEF                                  constant        bit(1)                   initial dcl 91 set ref 1149*
Break_source                           based           structure                level 1 dcl 127
C_lang_type                            constant        fixed bin(17,0)          initial dcl 3-17 ref 937
Map_array                              based           structure                array level 1 dcl 131 ref 348
Map_ptr                         000234 automatic       pointer                  dcl 134 set ref 306* 308 348 373
Map_size                        000232 automatic       fixed bin(17,0)          dcl 133 set ref 307* 348
NL                              007072 constant        char(1)                  initial packed unaligned dcl 136 ref 473 502 1073
                                                                                  1087
NO_PRINT                               constant        bit(1)                   initial dcl 87 set ref 1149*
PLACE                           000000 constant        char(8)                  initial array dcl 6-29 set ref 952*
PRINT                                  constant        bit(1)                   initial dcl 87 set ref 582* 611*
P_bmp                                  parameter       pointer                  dcl 972 in procedure "create_statement_entry" ref
                                                                                  969 982
P_bmp                                  parameter       pointer                  dcl 1030 in procedure "search_for_stmt" ref 1028
                                                                                  1041
P_break_type                           parameter       fixed bin(17,0)          dcl 73 ref 206 258 520 530 664 672
P_bsp                                  parameter       pointer                  dcl 905 in procedure "display_break" ref 902 911 911
P_bsp                                  parameter       pointer                  dcl 459 in procedure "common_break_slot_setup" ref
                                                                                  456 462
P_bsp                                  parameter       pointer                  dcl 922 in procedure "formatted_break_line" ref 917
                                                                                  952 961 961
P_code                                 parameter       fixed bin(35,0)          dcl 73 set ref 201* 206 255* 278* 280 520 526* 535*
                                                                                  537 561* 566 570* 576* 578 584* 589 598* 600* 601
                                                                                  615* 619 623* 625* 626 652* 664 674* 677* 679 706*
                                                                                  711 715* 720* 722 732* 737 749* 768*
P_command_length                       parameter       fixed bin(21,0)          dcl 73 ref 206 256
P_command_ptr                          parameter       pointer                  dcl 73 ref 206 257
P_ent                                  parameter       pointer                  dcl 1030 in procedure "search_for_stmt" ref 1028
                                                                                  1042
P_ent                                  parameter       pointer                  dcl 972 in procedure "create_statement_entry" ref
                                                                                  969 981
P_ent                                  parameter       pointer                  dcl 920 in procedure "formatted_break_line" ref 917
                                                                                  937 939 942 943
P_existed                              parameter       bit(1)                   dcl 1062 set ref 1053 1072* 1086*
P_exists                               parameter       bit(1)                   dcl 868 set ref 861 881* 890*
P_instruction_ptr                      parameter       pointer                  dcl 73 set ref 782 824 832 843*
P_len                                  parameter       fixed bin(17,0)          dcl 73 set ref 782 843*
P_long                                 parameter       bit(1)                   dcl 1058 in procedure "reset_all_breaks_in" ref 1053
                                                                                  1073 1087
P_long                                 parameter       bit(1)                   dcl 865 in procedure "list_all_in" ref 861 885 894
P_long                                 parameter       bit(1)                   dcl 1108 in procedure "reset_the_break_at" ref 1104
                                                                                  1128
P_long                                 parameter       bit(1)                   dcl 907 in procedure "display_break" set ref 902
                                                                                  911*
P_long_sw                              parameter       bit(1)                   dcl 73 ref 520 527 566 573 589 599 664 673 711 737
                                                                                  741
P_map_number                           parameter       fixed bin(17,0)          dcl 1030 ref 1028 1040
P_number                               parameter       fixed bin(17,0)          dcl 972 ref 969 986
P_pauses_only                          parameter       bit(1)                   dcl 1060 ref 1053 1073 1087
P_print                                parameter       bit(1)                   dcl 867 ref 861 882 891
P_probe_info_ptr                       parameter       pointer                  dcl 73 ref 206 254 477 482 520 524 566 569 589 596
                                                                                  619 622 664 668 711 714 737 740 773 776 782 787
P_proc                                 parameter       bit(1)                   dcl 923 set ref 917 952*
P_source_info_ptr                      parameter       pointer                  dcl 73 ref 206 259 477 483 520 525 566 571 664 669
                                                                                  711 716 782 788
P_stp                                  parameter       pointer                  dcl 921 ref 917 942 944
P_type                                 parameter       fixed bin(17,0)          dcl 1107 in procedure "reset_the_break_at" ref 1104
                                                                                  1128 1128 1135 1137 1139
P_type                                 parameter       fixed bin(17,0)          dcl 1170 in procedure "remove_break" ref 1167 1189
                                                                                  1191 1218
P_want_proc_name                       parameter       bit(1)                   dcl 906 ref 902 911
SPRI_wd                         000260 automatic       bit(36)                  initial packed unaligned dcl 8-182 set ref 8-182*
STATEMENT_ITEM                         constant        fixed bin(17,0)          initial dcl 8-172 ref 985
TRA_code                               constant        bit(18)                  initial packed unaligned dcl 8-184 ref 342 403 415
                                                                                  1209
absp                            000320 automatic       pointer                  dcl 460 in procedure "common_break_slot_setup" set
                                                                                  ref 462* 464 465 466 467 469 471 472 473
absp                            000524 automatic       pointer                  dcl 1184 in procedure "remove_break" set ref 1189*
                                                                                  1195 1201 1201 1204 1204 1207 1213 1218 1218 1227
                                                                                  1241*
access_name                     000132 automatic       char(32)                 array level 2 dcl 123 set ref 1464*
acl_count                       000261 automatic       fixed bin(17,0)          dcl 11-2 set ref 1463*
acl_dn                          000145 automatic       char(168)                packed unaligned dcl 124 set ref 1456* 1467* 1491*
                                                                                  1504*
acl_en                          000217 automatic       char(32)                 packed unaligned dcl 125 set ref 1456* 1467* 1491*
                                                                                  1504*
add                                                    builtin function         dcl 196 ref 1578 1584
added_w_sw                      000124 automatic       bit(1)                   dcl 115 set ref 424 701 729 763 852 1455* 1479* 1487
addr                                                   builtin function         dcl 196 ref 313 329 335 335 342 368 368 384 396 396
                                                                                  396 396 403 410 410 415 1204 1204 1204 1204 1209
                                                                                  1218 1218 1233 1236 1309 1309 1467 1467 1491 1491
                                                                                  1504 1504
addrel                                                 builtin function         dcl 196 ref 315 368 376 1218 1230 1346 1350 1563
                                                                                  1594 1594 1631 1662 1679 1695
after_slot_ptr                  000256 automatic       pointer                  dcl 8-180 set ref 381 381 381* 382* 384 387 388 388
                                                                                  389 390 396 396 401 403 409 410 410 415
after_sw                        000125 automatic       bit(1)                   dcl 117 set ref 803* 808* 823
based_word                             based           bit(36)                  dcl 101 in procedure "probe_break_mgr_" set ref 340
                                                                                  342* 409 415* 827 828* 835 836* 850*
based_word                             based           bit(36)                  dcl 1187 in procedure "remove_break" set ref 1209*
                                                                                  1213*
before_slot_ptr                 000254 automatic       pointer                  dcl 8-180 set ref 319 319 319* 324* 326 329 331 332
                                                                                  332 333 335 335 340 342 361* 366* 368 368 396 396
                                                                                  401 403 403 447 447
binary                                                 builtin function         dcl 196 ref 1316 1320 1325 1358 1362 1578 1584 1590
                                                                                  1590 1615 1619 1658
bit                                                    builtin function         dcl 196 ref 1316 1320 1578 1584
bitcount                        000541 automatic       fixed bin(24,0)          dcl 1251 set ref 1266* 1269 1322* 1323* 1362* 1364*
block_ptr                 4            based           pointer                  level 2 dcl 127 ref 467 469
bmp                             000436 automatic       pointer                  dcl 978 in procedure "create_statement_entry" set
                                                                                  ref 982*
bmp                             000462 automatic       pointer                  dcl 1036 in procedure "search_for_stmt" set ref
                                                                                  1041* 1042 1048
bmp                             000250 automatic       pointer                  dcl 8-180 in procedure "probe_break_mgr_" set ref
                                                                                  278* 285 287 291* 293* 308 313 465 488* 494 496*
                                                                                  535* 541 542* 576* 582 610* 611 638* 639 677* 682
                                                                                  683* 685 701 720* 725 726 729 758* 759 761 763
                                                                                  792* 796* 798 800* 821 852 876 897 1067 1160 1233
                                                                                  1274* 1276 1276 1283 1288 1297* 1301 1302 1303
                                                                                  1304 1309 1312 1315 1316 1320 1323* 1325 1325 1333
                                                                                  1335 1346 1350 1350 1358 1358 1360 1362 1364* 1545
                                                                                  1545 1559 1576 1576 1578 1578 1583 1583 1584 1584
                                                                                  1590* 1590 1590 1594 1594 1594 1619 1622 1627 1627
                                                                                  1633 1638 1651 1654 1654 1676 1712
bound_create_time       112            based           fixed bin(71,0)          level 2 dcl 5-9 ref 1303
bound_sym_header        114            based           pointer                  level 2 packed packed unaligned dcl 5-9 ref 1304
break_extension_info_ptr        000242 automatic       pointer                  dcl 7-31 set ref 1230* 1230 1231
break_info               50            based           structure                level 2 dcl 1-18
break_map                              based           structure                level 1 dcl 8-34 in procedure "probe_break_mgr_" set
                                                                                  ref 1312
break_map               104            based           bit(18)                  level 2 in structure "procedure_entry" packed packed
                                                                                  unaligned dcl 8-58 in procedure "probe_break_mgr_"
                                                                                  set ref 287* 1422
break_map_offset         10            based           bit(18)                  level 2 in structure "object_map" packed packed
                                                                                  unaligned dcl 9-10 in procedure "probe_break_mgr_"
                                                                                  set ref 1333* 1354* 1378 1378
break_map_offset          7            based           bit(18)                  level 2 in structure "old_object_map" packed packed
                                                                                  unaligned dcl 10-7 in procedure "probe_break_mgr_"
                                                                                  set ref 1335* 1356* 1387 1387
break_segment_ptr        42            based           pointer                  level 2 dcl 2-8 set ref 268 269*
break_slot                             based           structure                level 1 dcl 6-8
break_slot_after                       based           structure                level 1 dcl 8-139 set ref 381 381
break_slot_before                      based           structure                level 1 dcl 8-112 set ref 319 319
break_slot_ptr           50            based           pointer                  level 3 dcl 1-18 ref 1227
break_source_info_ptr           000230 automatic       pointer                  dcl 129 set ref 259* 261 263 284 290 293 424 467 469
                                                                                  483* 484 486 525* 529 533 571* 575 669* 670 671
                                                                                  716* 717 788* 790 791
break_type                      000106 automatic       fixed bin(17,0)          dcl 100 set ref 258* 297 302 314 421 530* 544 544
                                                                                  551 551 672* 687 687 696 696
breakmap_deleted_sw             000105 automatic       bit(1)                   dcl 99 set ref 692 1078 1093 1126* 1151*
breakmap_header_offset
                          1            based           bit(18)                  level 2 packed packed unaligned dcl 6-8 set ref 465*
breaks_found                    000507 automatic       bit(1)                   dcl 1110 set ref 1148* 1149* 1150
brief_sw                 36            based           bit(1)                   level 3 packed packed unaligned dcl 2-8 ref 1128
bsp                             000240 automatic       pointer                  dcl 6-23 set ref 319* 381* 421 501* 502
chain                     1(18)        based           bit(18)                  level 2 in structure "procedure_entry" packed packed
                                                                                  unaligned dcl 8-58 in procedure "probe_break_mgr_"
                                                                                  ref 608 636 757
chain                     1(18)        based           bit(18)                  level 2 in structure "statement_item" packed packed
                                                                                  unaligned dcl 8-86 in procedure "probe_break_mgr_"
                                                                                  set ref 897 990* 1007 1010 1013 1018 1019* 1019
                                                                                  1048 1069
chain                     1(18)        based           bit(18)                  level 2 in structure "free_item" packed packed
                                                                                  unaligned dcl 8-52 in procedure "probe_break_mgr_"
                                                                                  set ref 1555* 1555 1559 1571 1635* 1645 1671*
                                                                                  1684* 1684 1687* 1692 1700* 1701* 1706 1713*
code                            000102 automatic       fixed bin(35,0)          dcl 95 set ref 260* 269* 271 335* 338 396* 399 410*
                                                                                  413 488* 490 745* 747* 748 749 1161* 1266* 1267
                                                                                  1283* 1285 1367* 1375* 1396* 1449* 1450 1456* 1457
                                                                                  1458* 1467* 1504* 1505
command                                based           char                     packed unaligned dcl 215 ref 297 473
command_length                  000272 automatic       fixed bin(21,0)          dcl 214 set ref 256* 297 310 473
command_list             17            based           char                     level 2 in structure "break_slot_before" dcl 8-112
                                                                                  in procedure "probe_break_mgr_" ref 1073
command_list             17            based           char                     level 2 in structure "break_slot_after" dcl 8-139
                                                                                  in procedure "probe_break_mgr_" ref 1087
command_list             17            based           char                     level 2 in structure "break_slot" dcl 6-8
                                                                                  in procedure "probe_break_mgr_" set ref 473* 502
                                                                                  911*
command_list_size               000244 automatic       fixed bin(21,0)          dcl 8-178 set ref 310* 319 319 381 381 472
command_ptr                     000270 automatic       pointer                  dcl 213 set ref 257* 297 473
copy                                   based           bit(36)                  array dcl 1258 in procedure "create_breakmap" set
                                                                                  ref 1309* 1309 1360*
copy                                   based           bit(36)                  array packed unaligned dcl 219
                                                                                  in begin block on line 211 ref 329 384
copy_count                      000302 automatic       fixed bin(21,0)          dcl 220 in begin block on line 211 set ref 328* 329
                                                                                  383* 384
copy_count                      000546 automatic       fixed bin(17,0)          dcl 1259 in procedure "create_breakmap" set ref
                                                                                  1308* 1309 1312 1358* 1360
copy_count                      000650 automatic       fixed bin(17,0)          dcl 1611 in procedure "release_in_breakmap" set ref
                                                                                  1623* 1624 1639* 1641
copy_overlay                           based           bit(36)                  array dcl 1609 set ref 1624* 1641*
correction                      000540 automatic       fixed bin(24,0)          dcl 1250 set ref 1346* 1348* 1350 1362
count                    16            based           fixed bin(17,0)          level 2 in structure "break_slot_before" dcl 8-112
                                                                                  in procedure "probe_break_mgr_" ref 1073 1087
count                    16            based           fixed bin(17,0)          level 2 in structure "break_slot" dcl 6-8
                                                                                  in procedure "probe_break_mgr_" set ref 472* 473
                                                                                  502 911 911
decl_vers                              based           fixed bin(17,0)          level 2 dcl 9-10 ref 1333 1354 1378 1387
directory                 3            based           char(168)                level 2 packed packed unaligned dcl 8-58 set ref
                                                                                  645* 1418*
divide                                                 builtin function         dcl 196 ref 1269 1453 1524 1584
ent                             000434 automatic       pointer                  dcl 978 in procedure "create_statement_entry" set
                                                                                  ref 981* 988 989 990 992
ent                             000246 automatic       pointer                  dcl 8-180 in procedure "probe_break_mgr_" set ref
                                                                                  278* 287 291* 293* 488* 494 496* 535* 541 542*
                                                                                  576* 582 605* 605* 608 608* 632* 632* 636 645 645
                                                                                  645* 677* 682 683* 720* 725 754* 754* 757 757*
                                                                                  792* 796* 798 800* 876 911 1007 1007 1010 1013*
                                                                                  1067 1128 1157 1161* 1418 1418 1422 1424 1433
entry                    55            based           char(32)                 level 2 packed packed unaligned dcl 8-58 set ref
                                                                                  645* 939 1418*
file                            000413 automatic       fixed bin(17,0)          dcl 931 in procedure "formatted_break_line" set ref
                                                                                  948* 952 952*
file                      0(18)        based           bit(8)                   array level 3 in structure "map_array" packed packed
                                                                                  unaligned dcl 927 in procedure
                                                                                  "formatted_break_line" ref 948
fip                             000626 automatic       pointer                  dcl 1539 set ref 1545* 1545* 1551 1553 1555 1559
                                                                                  1562 1562 1563* 1563 1563 1566 1567 1570* 1571
                                                                                  1571 1576* 1577 1597
first                           000110 automatic       pointer                  dcl 103 set ref 600* 605 605 625* 632 632 636 747*
                                                                                  754 754
first_free_item           4            based           bit(18)                  level 2 packed packed unaligned dcl 8-34 set ref
                                                                                  1545 1559* 1627 1638* 1651 1654 1676* 1712*
first_statement         102            based           bit(18)                  level 2 packed packed unaligned dcl 8-58 set ref 876
                                                                                  990 992* 1007 1007* 1010 1042 1067 1157
fixed                                                  builtin function         dcl 196 ref 943 948 949 950 961 961 1358
free_item                              based           structure                level 1 dcl 8-52
get_group_id_                   000042 constant        entry                    external dcl 169 ref 1464
happy                           000104 automatic       bit(1)                   dcl 97 set ref 531* 546* 553* 561 572* 582* 584 597*
                                                                                  611* 615 630* 640 641* 652 675* 689* 698* 706 718*
                                                                                  727* 732 743* 762* 768
hbound                                                 builtin function         dcl 196 ref 348
hcs_$add_acl_entries            000052 constant        entry                    external dcl 173 ref 1504
hcs_$delete_acl_entries         000054 constant        entry                    external dcl 175 ref 1491
hcs_$fs_get_mode                000114 constant        entry                    external dcl 1444 ref 1449
hcs_$fs_get_path_name           000056 constant        entry                    external dcl 177 ref 1456
hcs_$initiate                   000110 constant        entry                    external dcl 1410 ref 1418
hcs_$list_acl                   000060 constant        entry                    external dcl 179 ref 1467
hcs_$set_bc_seg                 000062 constant        entry                    external dcl 181 ref 1323 1364 1590
hcs_$status_mins                000106 constant        entry                    external dcl 1261 ref 1266
hcs_$terminate_noname           000112 constant        entry                    external dcl 1413 ref 1427
i                               000642 automatic       fixed bin(35,0)          dcl 1604 set ref 1615* 1619 1658
identifier                6            based           fixed bin(71,0)          level 2 in structure "break_map" dcl 8-34
                                                                                  in procedure "probe_break_mgr_" set ref 1303* 1424
identifier                4            based           fixed bin(71,0)          level 2 in structure "statement_item" dcl 8-86
                                                                                  in procedure "probe_break_mgr_" set ref 989*
identifier                1            based           char(8)                  level 2 in structure "object_map" dcl 9-10
                                                                                  in procedure "probe_break_mgr_" ref 1375
initial_word_count        5            based           fixed bin(35,0)          level 2 dcl 8-34 set ref 1315*
inst_length_                    000044 constant        entry                    external dcl 170 ref 315 368 376 1218
instruction_ptr           2            based           pointer                  level 2 in structure "Break_source" dcl 127
                                                                                  in procedure "probe_break_mgr_" ref 263 284 424
instruction_ptr                 000116 automatic       pointer                  dcl 110 in procedure "probe_break_mgr_" set ref 824*
                                                                                  827 828 832* 835 836 850
io_switches              66            based           structure                level 2 dcl 1-18
ioa_$ioa_switch                 000064 constant        entry                    external dcl 184 ref 642 645 911 1128
ioa_$rsnnl                      000104 constant        entry                    external dcl 924 ref 952 961
ip                              000640 automatic       pointer                  dcl 1604 set ref 1614* 1615 1619 1622 1623 1624 1631
                                                                                  1662 1665 1667* 1670 1670 1671 1675 1675 1676 1679
                                                                                  1679 1682 1682 1684 1687 1695 1695 1699 1699 1700
                                                                                  1701 1712 1713 1714 1714
item                                   based           structure                level 1 dcl 8-46
item_pointer                           parameter       pointer                  dcl 1604 ref 1601 1614
item_type                              based           fixed bin(17,0)          level 2 in structure "break_slot" dcl 6-8
                                                                                  in procedure "probe_break_mgr_" set ref 464*
item_type                              based           fixed bin(17,0)          initial level 2 in structure "statement_item"
                                                                                  dcl 8-86 in procedure "probe_break_mgr_" set ref
                                                                                  985*
language_type            21            based           fixed bin(17,0)          level 3 dcl 1-18 ref 937
last_word_in_seg                       based           structure                level 1 dcl 1255
lfip                            000630 automatic       pointer                  dcl 1540 set ref 1544* 1555 1555 1570*
line                      0(26)        based           bit(14)                  array level 3 in structure "map_array" packed packed
                                                                                  unaligned dcl 927 in procedure
                                                                                  "formatted_break_line" ref 949
line                            000414 automatic       fixed bin(17,0)          dcl 932 in procedure "formatted_break_line" set ref
                                                                                  949* 952*
linestr                         000344 automatic       varying char(132)        dcl 925 set ref 952* 961* 966
listener_info           210            based           structure                level 2 dcl 1-18
location                               based           bit(18)                  array level 2 in structure "Map_array" packed packed
                                                                                  unaligned dcl 131 in procedure "probe_break_mgr_"
                                                                                  ref 308 373
location                 14(18)        based           bit(18)                  level 2 in structure "break_slot_after" packed
                                                                                  packed unaligned dcl 8-139 in procedure
                                                                                  "probe_break_mgr_" ref 824 1195
location                 14(18)        based           bit(18)                  level 2 in structure "break_slot" packed packed
                                                                                  unaligned dcl 6-8 in procedure "probe_break_mgr_"
                                                                                  set ref 471* 961 961 1201
location                 14(18)        based           bit(18)                  level 2 in structure "break_slot_before" packed
                                                                                  packed unaligned dcl 8-112 in procedure
                                                                                  "probe_break_mgr_" ref 447 832 1195
long_sw                         000114 automatic       bit(1)                   dcl 105 set ref 527* 547* 554 573* 582* 599* 611*
                                                                                  673* 690* 699* 727* 741* 762* 777*
lp                              000646 automatic       pointer                  dcl 1604 set ref 1626* 1635 1635 1653* 1660 1662
                                                                                  1662 1665 1665 1667 1671
map_array                              based           structure                array level 1 packed packed unaligned dcl 927
map_number                      000464 automatic       fixed bin(17,0)          dcl 1037 set ref 1040* 1045
map_ptr                         000410 automatic       pointer                  dcl 929 set ref 942* 946 948 949 950
map_relp                               based           bit(18)                  level 2 packed packed unaligned dcl 1255 set ref
                                                                                  1270 1325* 1346 1350
map_seq_offset            4            based           bit(18)                  level 4 in structure "break_slot_before" packed
                                                                                  packed unaligned dcl 8-112 in procedure
                                                                                  "probe_break_mgr_" set ref 331*
map_seq_offset           10            based           bit(18)                  level 4 in structure "break_slot_after" packed
                                                                                  packed unaligned dcl 8-139 in procedure
                                                                                  "probe_break_mgr_" set ref 387*
map_seq_ptr                     000274 automatic       pointer                  dcl 216 set ref 313* 331 387
map_sequence             10            based           pointer                  level 2 dcl 8-34 set ref 313 1309
map_size                110            based           fixed bin(17,0)          level 2 in structure "seg_info" dcl 5-9 in procedure
                                                                                  "probe_break_mgr_" ref 307
map_size                        000406 automatic       fixed bin(17,0)          dcl 928 in procedure "formatted_break_line" set ref
                                                                                  943* 946
mod                                                    builtin function         dcl 196 ref 1296 1314 1543
mode                            000574 automatic       fixed bin(5,0)           dcl 1446 set ref 1449* 1453
modes                    10     000132 automatic       bit(36)                  array level 2 dcl 123 set ref 1465* 1473 1502*
moved_instruction         6            based           bit(36)                  level 3 in structure "break_slot_before" dcl 8-112
                                                                                  in procedure "probe_break_mgr_" set ref 335 335
                                                                                  396 396 403* 1204 1204
moved_instruction         3            based           bit(36)                  level 3 in structure "break_slot_after" dcl 8-139
                                                                                  in procedure "probe_break_mgr_" set ref 396 396
                                                                                  410 410 1204 1204
multiply                                               builtin function         dcl 196 ref 1525 1584 1590 1590
name                      1            based           char(8)                  initial level 2 dcl 8-34 set ref 1276 1302*
names                     2            based           structure                level 2 dcl 5-9
needed                          000624 automatic       fixed bin(17,0)          dcl 1538 set ref 1543* 1551 1553 1562 1566 1577 1578
new_mode                               parameter       bit(3)                   packed unaligned dcl 1500 ref 1497 1502
new_stmt                        000440 automatic       pointer                  dcl 979 set ref 984* 985 986 987 988 989 990 992 993
next                            000112 automatic       pointer                  dcl 104 in procedure "probe_break_mgr_" set ref 608*
                                                                                  613 636* 650 757* 766
next                            000476 automatic       pointer                  dcl 1065 in procedure "reset_all_breaks_in" set ref
                                                                                  1069* 1099
next_loc                        000300 automatic       pointer                  dcl 218 set ref 315* 316 333 353* 368* 368 373 375
                                                                                  376* 376 376* 377 389
next_sp                  22            based           pointer                  level 2 dcl 13-36 ref 1228
null                                                   builtin function         dcl 196 ref 263 264 268 285 293 361 447 467 494 494
                                                                                  497 541 541 543 582 582 605 611 632 639 682 682
                                                                                  684 725 725 754 759 792 798 798 801 812 819 848
                                                                                  946 1049 1224 1276 1288 1384 1393 1397 1421 1435
                                                                                  1467 1467 1467 1467 1544 1555 1626 1635 1653 1660
number                          000103 automatic       fixed bin(17,0)          dcl 96 in procedure "probe_break_mgr_" set ref 290*
                                                                                  291* 308 348 373 486* 496* 533* 542* 671* 683*
                                                                                  791* 800*
number                    7            based           fixed bin(17,0)          level 2 in structure "statement_item" dcl 8-86
                                                                                  in procedure "probe_break_mgr_" set ref 944 986*
                                                                                  1045
number                          000412 automatic       fixed bin(17,0)          dcl 930 in procedure "formatted_break_line" set ref
                                                                                  944* 946 948 949 950
obj_map_ptr                     000544 automatic       pointer                  dcl 1253 set ref 1270* 1325 1333 1333 1335 1350*
                                                                                  1354 1354 1356 1375 1378 1378 1378 1378 1387 1387
                                                                                  1387 1387
object_map                             based           structure                level 1 dcl 9-10
object_map_version_2                   constant        fixed bin(17,0)          initial dcl 9-40 ref 1333 1354 1378
offset                   12            based           bit(18)                  level 4 in structure "break_slot_after" packed
                                                                                  packed unaligned dcl 8-139 in procedure
                                                                                  "probe_break_mgr_" set ref 389*
offset                   12            based           bit(18)                  level 4 in structure "break_slot_before" packed
                                                                                  packed unaligned dcl 8-112 in procedure
                                                                                  "probe_break_mgr_" set ref 333*
old_instruction          13            based           bit(36)                  level 2 in structure "break_slot_after" dcl 8-139
                                                                                  in procedure "probe_break_mgr_" set ref 401* 409*
                                                                                  828 1207 1218 1218
old_instruction          13            based           bit(36)                  level 2 in structure "break_slot" dcl 6-8
                                                                                  in procedure "probe_break_mgr_" ref 1213
old_instruction          13            based           bit(36)                  level 2 in structure "break_slot_before" dcl 8-112
                                                                                  in procedure "probe_break_mgr_" set ref 340* 368
                                                                                  368 401 403* 836 1207*
old_object_map                         based           structure                level 1 dcl 10-7
other_type                      000506 automatic       fixed bin(17,0)          dcl 1109 set ref 1139* 1141* 1143
output_switch            70            based           pointer                  level 3 dcl 1-18 set ref 642* 645* 843* 911* 1128*
p                               000466 automatic       pointer                  dcl 1038 in procedure "search_for_stmt" set ref
                                                                                  1042* 1042* 1045 1045* 1048
p                               000516 automatic       pointer                  dcl 1181 in procedure "remove_break" set ref 1193*
                                                                                  1195 1204 1204 1207 1209 1228* 1230
p                               000644 automatic       pointer                  dcl 1604 in procedure "release_in_breakmap" set ref
                                                                                  1627* 1627* 1631 1631 1633 1639 1641* 1645 1645
                                                                                  1654* 1658 1679 1682 1684 1687 1692 1695 1695 1695
                                                                                  1695 1701* 1706 1706*
patch_place                     000522 automatic       pointer                  dcl 1183 set ref 1201* 1209 1213 1218* 1218 1231
pauses_entry_sw                 000115 automatic       bit(1)                   dcl 107 set ref 742* 749 762* 768 778*
pi_ptr                          000520 automatic       pointer                  dcl 1182 set ref 1224* 1224* 1227 1228 1233 1236*
                                                                                  1239
place_to_set                    000276 automatic       pointer                  dcl 217 set ref 264* 308* 315 315* 316 335* 340 342
                                                                                  353 375* 377 409 410* 415 430* 436* 447 471
pointer                                                builtin function         dcl 196 ref 308 366 501 608 636 757 805 810 824 832
                                                                                  876 885 885 894 894 897 942 1010 1018 1042 1048
                                                                                  1067 1069 1128 1128 1189 1193 1201 1270 1270 1297
                                                                                  1325 1350 1378 1387 1422 1545 1571 1576 1594 1627
                                                                                  1645 1654 1706
pointers                 76            based           structure                level 2 dcl 5-9
prev                            000452 automatic       pointer                  dcl 1005 set ref 1010* 1010* 1013* 1018 1018 1019
previous                233            based           pointer                  level 3 packed packed unaligned dcl 1-18 ref 1239
print_instructions_             000046 constant        entry                    external dcl 171 ref 843
probe_break_extension                  based           structure                level 1 dcl 7-11 set ref 1230
probe_error_$malfunction        000036 constant        entry                    external dcl 164 ref 33 1013
probe_error_$record             000040 constant        entry                    external dcl 164 ref 272 349 430 436 1279 1367 1458
probe_et_$breakless             000066 external static fixed bin(35,0)          dcl 186 ref 561 706
probe_et_$breaks_exist          000076 external static fixed bin(35,0)          dcl 186 set ref 1279*
probe_et_$no_breaks             000072 external static fixed bin(35,0)          dcl 186 ref 584 732
probe_et_$no_breaks_set         000070 external static fixed bin(35,0)          dcl 186 ref 615 652 768
probe_et_$non_standard          000074 external static fixed bin(35,0)          dcl 186 ref 1375 1396
probe_et_$old_break_map         000100 external static fixed bin(35,0)          dcl 186 ref 1283
probe_et_$recorded_message      000102 external static fixed bin(35,0)          dcl 186 ref 201
probe_info                             based           structure                level 1 dcl 1-18
probe_info_ptr                  000236 automatic       pointer                  dcl 1-86 set ref 254* 268 269 272* 278* 349* 430*
                                                                                  436* 482* 488* 524* 535* 569* 576* 596* 600* 622*
                                                                                  625* 642 645 668* 677* 714* 720* 740* 747* 776*
                                                                                  787* 796* 843 911 937 1013* 1128 1128 1161* 1224
                                                                                  1279* 1367* 1433* 1458*
probe_map_sequence_$after_code  000012 external static bit(36)                  dcl 138 set ref 384
probe_map_sequence_$before_code 000010 external static bit(36)                  dcl 138 set ref 329
probe_map_sequence_$code        000016 external static bit(36)                  dcl 138 set ref 1309
probe_map_sequence_$count       000014 external static fixed bin(17,0)          dcl 138 ref 1308
probe_map_sequence_$old_return  000022 external static bit(36)                  dcl 138 set ref 1236
probe_map_sequence_$return      000020 external static bit(36)                  dcl 138 set ref 1233
probe_seg_mgr_$create_breakseg  000024 constant        entry                    external dcl 153 ref 269
probe_seg_mgr_$create_procedure_entry
                                000032 constant        entry                    external dcl 159 ref 278
probe_seg_mgr_$delete_procedure_entry
                                000034 constant        entry                    external dcl 161 ref 1161 1433
probe_seg_mgr_$first_procedure_ptr
                                000030 constant        entry                    external dcl 157 ref 600 625 747
probe_seg_mgr_$get_procedure_entry
                                000026 constant        entry                    external dcl 155 ref 488 535 576 677 720 796
probe_static_info                      based           structure                level 1 dcl 2-8
proc_entry                6            based           bit(18)                  level 2 packed packed unaligned dcl 8-86 set ref
                                                                                  988*
procedure_entry                        based           structure                level 1 dcl 8-58
ptr                                                    builtin function         dcl 196 ref 547 547 554 554 1073 1087
ptr_to_initial_source
                          6            based           pointer                  level 2 dcl 1-18 ref 1228
random_info              17            based           structure                level 2 dcl 1-18
real_break_return_loc
                         54            based           pointer                  level 3 dcl 1-18 set ref 1233* 1236*
rel                                                    builtin function         dcl 196 ref 287 331 332 333 342 373 387 388 389 403
                                                                                  415 421 447 465 466 469 471 605 632 754 876 988
                                                                                  992 1007 1010 1042 1067 1209 1304 1325 1333 1335
                                                                                  1358 1362 1545 1615 1622 1627 1633 1658 1671 1676
                                                                                  1687 1701 1712
relocate_instruction_           000050 constant        entry                    external dcl 172 ref 335 396 410 1204
required                               parameter       fixed bin(17,0)          dcl 1535 ref 1532 1543 1543
return                   12            based           structure                level 3 in structure "break_slot_after" dcl 8-139
                                                                                  in procedure "probe_break_mgr_"
return                   12            based           structure                level 3 in structure "break_slot_before" dcl 8-112
                                                                                  in procedure "probe_break_mgr_"
saved_instruction               000123 automatic       bit(36)                  dcl 113 set ref 827* 835* 850
saved_mode                      000127 automatic       bit(3)                   packed unaligned dcl 121 set ref 1473* 1487*
saved_mode_sw                   000126 automatic       bit(1)                   dcl 119 set ref 1469* 1472* 1487
saved_stp                       000130 automatic       pointer                  dcl 122 set ref 686* 695 1071* 1082 1085* 1097
seg_acl                         000132 automatic       structure                array level 1 dcl 123 set ref 1467 1467 1491 1491
                                                                                  1504 1504
seg_info                               based           structure                level 1 dcl 5-9
seg_info_ptr             12            based           pointer                  level 2 dcl 127 ref 261 484 529 575 670 717 790
seginfop                        000100 automatic       pointer                  dcl 94 set ref 261* 278* 306 307 484* 488* 529* 535*
                                                                                  575* 576* 670* 677* 717* 720* 790* 796* 1265 1279
                                                                                  1303 1304
segment_acl                            based           structure                array level 1 dcl 11-2
segname                  65            based           char(32)                 level 2 in structure "procedure_entry" packed packed
                                                                                  unaligned dcl 8-58 in procedure "probe_break_mgr_"
                                                                                  set ref 645* 937
segname                  64            based           char(32)                 level 3 in structure "seg_info" packed packed
                                                                                  unaligned dcl 5-9 in procedure "probe_break_mgr_"
                                                                                  set ref 1279*
segp                            000536 automatic       pointer                  dcl 1249 in procedure "create_breakmap" set ref
                                                                                  1265* 1266* 1270 1270 1297
segp                            000564 automatic       pointer                  dcl 1415 in procedure "get_breakmap_ptr" set ref
                                                                                  1418* 1421 1422* 1422 1424 1424 1427*
segptr                                 parameter       pointer                  dcl 1441 set ref 1438 1449* 1456* 1483
sequence                  3            based           structure                level 2 in structure "break_slot_after" dcl 8-139
                                                                                  in procedure "probe_break_mgr_" set ref 384* 403
                                                                                  415
sequence                  3            based           structure                level 2 in structure "break_slot_before" dcl 8-112
                                                                                  in procedure "probe_break_mgr_" set ref 329* 342
                                                                                  1209
size                      2            based           fixed bin(17,0)          level 2 in structure "item" dcl 8-46 in procedure
                                                                                  "probe_break_mgr_" set ref 1566* 1577* 1619 1623
                                                                                  1665 1670 1675 1695 1699 1714
size                                                   builtin function         dcl 196 in procedure "probe_break_mgr_" ref 319 319
                                                                                  381 381 984 984 1230 1312
size                                   based           fixed bin(17,0)          level 2 in structure "free_item" dcl 8-52
                                                                                  in procedure "probe_break_mgr_" set ref 1551 1553
                                                                                  1562* 1562 1563 1631 1639 1662 1665* 1665 1670*
                                                                                  1675* 1679 1682* 1682 1682 1695 1695* 1695 1699*
                                                                                  1714*
size_of_after_sequence                 constant        fixed bin(17,0)          initial dcl 8-168 ref 383
size_of_before_sequence                constant        fixed bin(17,0)          initial dcl 8-169 ref 328
slot_offset               5            based           bit(18)                  level 4 in structure "break_slot_before" packed
                                                                                  packed unaligned dcl 8-112 in procedure
                                                                                  "probe_break_mgr_" set ref 332*
slot_offset                     000122 automatic       bit(18)                  packed unaligned dcl 112 in procedure
                                                                                  "probe_break_mgr_" set ref 804* 805 805 809* 810
                                                                                  810
slot_offset              11            based           bit(18)                  level 4 in structure "break_slot_after" packed
                                                                                  packed unaligned dcl 8-139 in procedure
                                                                                  "probe_break_mgr_" set ref 388*
slot_ptr                        000120 automatic       pointer                  dcl 111 set ref 792* 805* 810* 812* 819 824 828 832
                                                                                  836 848
slot_return_addr         34            based           pointer                  level 2 dcl 7-11 set ref 1231*
slots                    10            based           bit(18)                  array level 2 dcl 8-86 set ref 297 361 366 421* 497
                                                                                  501 544 547 547 551 554 554 687 696 804 809 879
                                                                                  885 885 889 894 894 987* 1070 1073 1084 1087 1128
                                                                                  1128 1137* 1143 1189 1191 1193
source_id                 0(18)        based           structure                array level 2 packed packed unaligned dcl 927
source_info                            based           structure                level 1 dcl 4-5
stack_frame                            based           structure                level 1 dcl 13-36
stack_ptr                 6            based           pointer                  level 2 dcl 4-5 ref 1228
statement                 1(04)        based           bit(5)                   array level 3 packed packed unaligned dcl 927 ref
                                                                                  950
statement_item                         based           structure                level 1 dcl 8-86 set ref 984 984
statement_item_offset
                          1(18)        based           bit(18)                  level 2 packed packed unaligned dcl 6-8 set ref 466*
statement_map                          based           structure                level 1 dcl 12-1 in procedure "probe_break_mgr_"
statement_map           104(18)        based           bit(18)                  level 2 in structure "procedure_entry" packed packed
                                                                                  unaligned dcl 8-58 in procedure "probe_break_mgr_"
                                                                                  ref 942
statement_map_ptr       100            based           pointer                  level 3 packed packed unaligned dcl 5-9 ref 306
statement_map_size      105            based           bit(18)                  level 2 packed packed unaligned dcl 8-58 ref 943
static_info_ptr           1            based           pointer                  level 2 packed packed unaligned dcl 1-18 ref 268 269
                                                                                  1128
status_code              12     000132 automatic       fixed bin(35,0)          array level 2 dcl 123 set ref 1469
stmnt_map_entry_index                  based           fixed bin(17,0)          level 2 dcl 127 set ref 290 293* 486 533 671 791
stmt                            000415 automatic       fixed bin(17,0)          dcl 933 set ref 950* 952 952*
stp                             000252 automatic       pointer                  dcl 8-180 set ref 291* 293 293* 297 361 366 366 421
                                                                                  466 496* 497 497 501 501 542* 543 544 547 547 547
                                                                                  547 551 554 554 554 554 683* 684 686 687 695* 696
                                                                                  800* 801 804 805 809 810 876* 876* 879 885 885 885
                                                                                  885 889 894 894 894 894* 897 911 984 984 1007 1007
                                                                                  1010 1010 1013* 1019 1022 1067* 1067* 1069 1069
                                                                                  1070 1071 1073 1073 1082* 1084 1085 1087 1087
                                                                                  1097* 1128 1128 1128 1128 1128 1137 1143 1189 1189
                                                                                  1191 1193 1193
strange                         000526 automatic       bit(1)                   dcl 1185 set ref 1195* 1199* 1203
substr                                                 builtin function         dcl 196 ref 1473
subtract                                               builtin function         dcl 196 ref 1527 1584
switches                 36            based           structure                level 2 dcl 2-8
symbol_block_offset      14            based           bit(18)                  level 2 packed packed unaligned dcl 6-8 set ref 467*
                                                                                  469*
symbol_header             4(18)        based           bit(18)                  level 2 packed packed unaligned dcl 8-34 set ref
                                                                                  1304*
symbol_header_ptr        76            based           pointer                  level 3 packed packed unaligned dcl 5-9 ref 1265
time_stamp              100            based           fixed bin(71,0)          level 2 dcl 8-58 ref 989 1424
type                     15            based           fixed bin(17,0)          initial level 2 in structure "break_slot_before"
                                                                                  dcl 8-112 in procedure "probe_break_mgr_" set ref
                                                                                  326*
type                     15            based           fixed bin(17,0)          initial level 2 in structure "break_slot_after"
                                                                                  dcl 8-139 in procedure "probe_break_mgr_" set ref
                                                                                  390*
type                     15            based           fixed bin(17,0)          level 2 in structure "break_slot" dcl 6-8
                                                                                  in procedure "probe_break_mgr_" ref 952
unspec                                                 builtin function         dcl 196 set ref 329* 329 384* 384
upper_bound               3            based           bit(18)                  level 2 packed packed unaligned dcl 8-34 set ref
                                                                                  1320* 1325 1583 1584* 1590 1590 1594
use_this_name                   000416 automatic       char(32)                 packed unaligned dcl 934 set ref 937* 939* 952* 961*
version                                based           fixed bin(17,0)          initial level 2 dcl 8-34 set ref 1233 1283 1301*
word                                   based           bit(36)                  packed unaligned dcl 1541 set ref 1594* 1594
word1                     4            based           structure                level 3 dcl 8-112
word2                     5            based           structure                level 3 dcl 8-112
word5                    10            based           structure                level 3 dcl 8-139
word6                    11            based           structure                level 3 dcl 8-139
word_count                3(18)        based           bit(18)                  level 2 packed packed unaligned dcl 8-34 set ref
                                                                                  1316* 1358 1576 1578* 1578 1583 1584 1619 1622*
                                                                                  1633*
wordcount                       000542 automatic       fixed bin(35,0)          dcl 1252 set ref 1269* 1270 1296* 1296 1296 1297
                                                                                  1312* 1312 1314* 1314 1314 1315 1316 1319* 1319
                                                                                  1320 1322
wordct                                 parameter       fixed bin(35,0)          dcl 1520 ref 1515 1523
wordtp                          000614 automatic       fixed bin(35,0)          dcl 1521 set ref 1523* 1524* 1524 1525* 1525 1527*
                                                                                  1527 1529
zero_pad                 11     000132 automatic       bit(36)                  array level 2 dcl 123 set ref 1465*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALGOL68_lang_type                      internal static fixed bin(17,0)          initial dcl 3-17
ALM_lang_type                          internal static fixed bin(17,0)          initial dcl 3-17
COBOL_lang_type                        internal static fixed bin(17,0)          initial dcl 3-17
FORTRAN_lang_type                      internal static fixed bin(17,0)          initial dcl 3-17
MACRO_ITEM                             internal static fixed bin(17,0)          initial dcl 8-172
NOP_code                               internal static bit(18)                  initial packed unaligned dcl 8-184
OTHER_lang_type                        internal static fixed bin(17,0)          initial dcl 3-17
PASCAL_lang_type                       internal static fixed bin(17,0)          initial dcl 3-17
PL1_lang_type                          internal static fixed bin(17,0)          initial dcl 3-17
PROCEDURE_ITEM                         internal static fixed bin(17,0)          initial dcl 8-172
RETURN_PTR_MASK                        internal static bit(72)                  initial packed unaligned dcl 13-19
SYMBOL_ITEM                            internal static fixed bin(17,0)          initial dcl 8-172
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial packed unaligned dcl 13-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial packed unaligned dcl 13-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial packed unaligned dcl 13-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial packed unaligned dcl 13-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial packed unaligned dcl 13-27
TSPLB_code                             internal static bit(18)                  initial packed unaligned dcl 8-184
UNKNOWN_lang_type                      internal static fixed bin(17,0)          initial dcl 3-17
acl_ptr                                automatic       pointer                  dcl 11-2
break_segment                          based           structure                level 1 dcl 8-22
break_segp                             automatic       pointer                  dcl 8-32
current_source                         based           structure                level 1 dcl 4-13
dir_acl                                based           structure                array level 1 dcl 11-2
expression_area                        based           area(1024)               dcl 1-95
initial_source                         based           structure                level 1 dcl 4-14
macro_item                             based           structure                level 1 dcl 8-102
map_ptr                                based           bit(18)                  dcl 9-38
official_language_names                internal static char(32)                 initial array packed unaligned dcl 3-27
palatable_language_names               internal static char(32)                 initial array packed unaligned dcl 3-30
probe_area                             based           area(1024)               dcl 1-93
probe_exclude_names                    based           char(168)                array packed unaligned dcl 2-94
probe_info_directories                 based           char(168)                array packed unaligned dcl 2-91
probe_info_version                     internal static fixed bin(17,0)          initial dcl 1-88
probe_info_version_1                   internal static fixed bin(17,0)          initial dcl 1-90
probe_request_tables                   based           pointer                  array dcl 2-88
probe_seg_info_array                   based           structure                level 1 dcl 2-82
scratch_area                           based           area(1024)               dcl 1-92
seg_info_nfiles                        automatic       fixed bin(17,0)          dcl 5-47
seg_info_offset_count                  automatic       fixed bin(17,0)          dcl 2-86
sp                                     automatic       pointer                  dcl 13-31
stack_frame_flags                      based           structure                level 1 dcl 13-64
stack_frame_min_length                 internal static fixed bin(17,0)          initial dcl 13-33
work_area                              based           area(1024)               dcl 1-94

NAMES DECLARED BY EXPLICIT CONTEXT.
ACL_LOSS                        005540 constant        label                    dcl 1458 ref 1450 1505
CANT_GET_LENGTH                 001220 constant        label                    dcl 436 ref 316 377
CANT_RELOCATE                   001167 constant        label                    dcl 430 set ref 265 338 399 413
C_LOSS                          005241 constant        label                    dcl 1367 ref 1267 1285
RECORDED_MESSAGE                000245 constant        label                    dcl 201 ref 274 351 434 440 1281 1369 1460
RESET_ALL                       002743 constant        label                    dcl 743 ref 780
RESET_DONE                      002552 constant        label                    dcl 706 ref 692
allocate_in_breakmap            006065 constant        entry                    internal dcl 1532 ref 319 381 984
common_break_slot_setup         001274 constant        entry                    internal dcl 456 ref 324 382
create_breakmap                 004661 constant        entry                    internal dcl 1244 ref 286
create_statement_entry          003756 constant        entry                    internal dcl 969 ref 293
delete_breakmap                 005140 constant        entry                    internal dcl 1340 ref 1153
delete_statement_entry          004026 constant        entry                    internal dcl 998 ref 1143
display_break                   003426 constant        entry                    internal dcl 902 ref 547 554 885 894
ensure_writeable                005456 constant        entry                    internal dcl 1438 ref 284 685 726 761 821
fill_to_brim                    006046 constant        entry                    internal dcl 1515 ref 1319
find_breakmap                   005257 constant        entry                    internal dcl 1372 ref 1274
formatted_break_line            003510 constant        entry                    internal dcl 917 ref 911 1128
get_breakmap_ptr                005333 constant        entry                    internal dcl 1405 ref 610 638 758
is_temporary_break              001355 constant        entry                    external dcl 477
list_all_in                     003327 constant        entry                    internal dcl 861 ref 582 611 1149
list_breaks_at_line             001530 constant        entry                    external dcl 520
list_breaks_in_seg              001727 constant        entry                    external dcl 566
list_breaks_in_world            002045 constant        entry                    external dcl 589
list_broken_segs                002172 constant        entry                    external dcl 619
print_instructions              003111 constant        entry                    external dcl 782
probe_break_mgr_                000230 constant        entry                    external dcl 30
release_in_breakmap             006261 constant        entry                    internal dcl 1601 ref 1022 1241
remove_break                    004466 constant        entry                    internal dcl 1167 ref 302 1135
reset_all_breaks_in             004173 constant        entry                    internal dcl 1053 ref 727 762
reset_all_pause_breaks          003064 constant        entry                    external dcl 773
reset_break_at_line             002375 constant        entry                    external dcl 664
reset_breaks_in_seg             002571 constant        entry                    external dcl 711
reset_breaks_in_world           002716 constant        entry                    external dcl 737
reset_the_break_at              004325 constant        entry                    internal dcl 1104 ref 690 699 1073 1087
restore_readonly                005715 constant        entry                    internal dcl 1483 ref 424 701 729 763 852 1160
search_for_stmt                 004131 constant        entry                    internal dcl 1028 ref 291 496 542 683 800
set_access                      005765 constant        entry                    internal dcl 1497 ref 1476 1487
set_break                       000265 constant        entry                    external dcl 206
strange_casep                   001252 constant        entry                    internal dcl 444 ref 394

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      7654        7772    7074        7664
Length     10544    7074       116         535     557           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
probe_break_mgr_                   1008 external procedure  is an external procedure.  
begin block on line 211                 begin block         shares stack frame of external procedure probe_break_mgr_.  
strange_casep                           internal procedure  shares stack frame of external procedure probe_break_mgr_.  
common_break_slot_setup                 internal procedure  shares stack frame of external procedure probe_break_mgr_.  
list_all_in                             internal procedure  shares stack frame of external procedure probe_break_mgr_.  
display_break                           internal procedure  shares stack frame of external procedure probe_break_mgr_.  
formatted_break_line                    internal procedure  shares stack frame of external procedure probe_break_mgr_.  
create_statement_entry                  internal procedure  shares stack frame of external procedure probe_break_mgr_.  
delete_statement_entry                  internal procedure  shares stack frame of external procedure probe_break_mgr_.  
search_for_stmt                         internal procedure  shares stack frame of external procedure probe_break_mgr_.  
reset_all_breaks_in                     internal procedure  shares stack frame of external procedure probe_break_mgr_.  
reset_the_break_at                      internal procedure  shares stack frame of external procedure probe_break_mgr_.  
remove_break                            internal procedure  shares stack frame of external procedure probe_break_mgr_.  
create_breakmap                         internal procedure  shares stack frame of external procedure probe_break_mgr_.  
find_breakmap                           internal procedure  shares stack frame of external procedure probe_break_mgr_.  
get_breakmap_ptr                        internal procedure  shares stack frame of external procedure probe_break_mgr_.  
ensure_writeable                        internal procedure  shares stack frame of external procedure probe_break_mgr_.  
set_access                              internal procedure  shares stack frame of external procedure probe_break_mgr_.  
fill_to_brim                            internal procedure  shares stack frame of external procedure probe_break_mgr_.  
allocate_in_breakmap                    internal procedure  shares stack frame of external procedure probe_break_mgr_.  
release_in_breakmap                     internal procedure  shares stack frame of external procedure probe_break_mgr_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
probe_break_mgr_         000100 seginfop                    probe_break_mgr_
                         000102 code                        probe_break_mgr_
                         000103 number                      probe_break_mgr_
                         000104 happy                       probe_break_mgr_
                         000105 breakmap_deleted_sw         probe_break_mgr_
                         000106 break_type                  probe_break_mgr_
                         000110 first                       probe_break_mgr_
                         000112 next                        probe_break_mgr_
                         000114 long_sw                     probe_break_mgr_
                         000115 pauses_entry_sw             probe_break_mgr_
                         000116 instruction_ptr             probe_break_mgr_
                         000120 slot_ptr                    probe_break_mgr_
                         000122 slot_offset                 probe_break_mgr_
                         000123 saved_instruction           probe_break_mgr_
                         000124 added_w_sw                  probe_break_mgr_
                         000125 after_sw                    probe_break_mgr_
                         000126 saved_mode_sw               probe_break_mgr_
                         000127 saved_mode                  probe_break_mgr_
                         000130 saved_stp                   probe_break_mgr_
                         000132 seg_acl                     probe_break_mgr_
                         000145 acl_dn                      probe_break_mgr_
                         000217 acl_en                      probe_break_mgr_
                         000230 break_source_info_ptr       probe_break_mgr_
                         000232 Map_size                    probe_break_mgr_
                         000234 Map_ptr                     probe_break_mgr_
                         000236 probe_info_ptr              probe_break_mgr_
                         000240 bsp                         probe_break_mgr_
                         000242 break_extension_info_ptr    probe_break_mgr_
                         000244 command_list_size           probe_break_mgr_
                         000246 ent                         probe_break_mgr_
                         000250 bmp                         probe_break_mgr_
                         000252 stp                         probe_break_mgr_
                         000254 before_slot_ptr             probe_break_mgr_
                         000256 after_slot_ptr              probe_break_mgr_
                         000260 SPRI_wd                     probe_break_mgr_
                         000261 acl_count                   probe_break_mgr_
                         000270 command_ptr                 begin block on line 211
                         000272 command_length              begin block on line 211
                         000274 map_seq_ptr                 begin block on line 211
                         000276 place_to_set                begin block on line 211
                         000300 next_loc                    begin block on line 211
                         000302 copy_count                  begin block on line 211
                         000320 absp                        common_break_slot_setup
                         000344 linestr                     formatted_break_line
                         000406 map_size                    formatted_break_line
                         000410 map_ptr                     formatted_break_line
                         000412 number                      formatted_break_line
                         000413 file                        formatted_break_line
                         000414 line                        formatted_break_line
                         000415 stmt                        formatted_break_line
                         000416 use_this_name               formatted_break_line
                         000434 ent                         create_statement_entry
                         000436 bmp                         create_statement_entry
                         000440 new_stmt                    create_statement_entry
                         000452 prev                        delete_statement_entry
                         000462 bmp                         search_for_stmt
                         000464 map_number                  search_for_stmt
                         000466 p                           search_for_stmt
                         000476 next                        reset_all_breaks_in
                         000506 other_type                  reset_the_break_at
                         000507 breaks_found                reset_the_break_at
                         000516 p                           remove_break
                         000520 pi_ptr                      remove_break
                         000522 patch_place                 remove_break
                         000524 absp                        remove_break
                         000526 strange                     remove_break
                         000536 segp                        create_breakmap
                         000540 correction                  create_breakmap
                         000541 bitcount                    create_breakmap
                         000542 wordcount                   create_breakmap
                         000544 obj_map_ptr                 create_breakmap
                         000546 copy_count                  create_breakmap
                         000564 segp                        get_breakmap_ptr
                         000574 mode                        ensure_writeable
                         000614 wordtp                      fill_to_brim
                         000624 needed                      allocate_in_breakmap
                         000626 fip                         allocate_in_breakmap
                         000630 lfip                        allocate_in_breakmap
                         000640 ip                          release_in_breakmap
                         000642 i                           release_in_breakmap
                         000644 p                           release_in_breakmap
                         000646 lp                          release_in_breakmap
                         000650 copy_count                  release_in_breakmap

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              alloc_char_temp     call_ext_out_desc   call_ext_out        begin_return_mac
return_mac          mpfx2               mdfx1               signal_op           shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_group_id_                 hcs_$add_acl_entries          hcs_$delete_acl_entries       hcs_$fs_get_mode
hcs_$fs_get_path_name         hcs_$initiate                 hcs_$list_acl                 hcs_$set_bc_seg
hcs_$status_mins              hcs_$terminate_noname         inst_length_                  ioa_$ioa_switch
ioa_$rsnnl                    print_instructions_           probe_error_$malfunction      probe_error_$record
probe_seg_mgr_$create_breakseg                              probe_seg_mgr_$create_procedure_entry
probe_seg_mgr_$delete_procedure_entry                       probe_seg_mgr_$first_procedure_ptr
probe_seg_mgr_$get_procedure_entry                          relocate_instruction_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
probe_et_$breakless           probe_et_$breaks_exist        probe_et_$no_breaks           probe_et_$no_breaks_set
probe_et_$non_standard        probe_et_$old_break_map       probe_et_$recorded_message
probe_map_sequence_$after_code                              probe_map_sequence_$before_code
probe_map_sequence_$code      probe_map_sequence_$count     probe_map_sequence_$old_return
probe_map_sequence_$return




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 8  182 000223        30 000227        33 000240       201 000245       203 000250       206 000257       254 000300
    255 000304       256 000305       257 000307       258 000312       259 000314       260 000317       261 000320
    263 000322       264 000326       265 000330       268 000331       269 000337       271 000350       272 000352
    274 000377       278 000400       280 000417       284 000432       285 000437       286 000443       287 000444
    290 000447       291 000451       293 000453       297 000474       302 000517       306 000523       307 000526
    308 000531       310 000540       313 000543       314 000546       315 000551       316 000571       319 000575
    324 000607       326 000611       328 000614       329 000616       331 000624       332 000626       333 000630
    335 000632       338 000646       340 000650       342 000653       346 000661       348 000662       349 000665
    351 000712       353 000713       361 000714       366 000723       368 000726       373 000750       375 000761
    376 000763       377 001003       379 001007       381 001010       382 001022       383 001024       384 001026
    387 001035       388 001037       389 001041       390 001043       394 001045       396 001052       399 001073
    401 001075       403 001101       407 001110       409 001111       410 001114       413 001131       415 001133
    418 001142       421 001143       424 001147       426 001156       430 001167       434 001217       436 001220
    440 001250       475 001251       444 001252       447 001254       450 001272       456 001274       462 001276
    464 001301       465 001303       466 001305       467 001310       469 001320       471 001322       472 001325
    473 001327       474 001346       477 001350       482 001364       483 001370       484 001373       486 001375
    488 001377       490 001416       494 001434       496 001444       497 001446       501 001456       502 001461
    507 001507       520 001523       524 001545       525 001551       526 001554       527 001555       529 001560
    530 001562       531 001564       533 001565       535 001567       537 001606       541 001617       542 001627
    543 001631       544 001635       546 001646       547 001650       551 001660       553 001670       554 001672
    561 001705       563 001713       566 001722       569 001744       570 001750       571 001751       572 001754
    573 001755       575 001760       576 001762       578 002001       582 002012       584 002024       586 002032
    589 002041       596 002062       597 002066       598 002067       599 002070       600 002073       601 002106
    605 002117       608 002130       610 002136       611 002140       613 002146       615 002151       617 002157
    619 002166       622 002205       623 002211       625 002212       626 002225       630 002236       632 002237
    636 002250       638 002256       639 002260       640 002264       641 002267       642 002271       645 002315
    650 002353       652 002356       654 002364       664 002373       668 002412       669 002416       670 002421
    671 002423       672 002425       673 002427       674 002432       675 002433       677 002434       679 002453
    682 002464       683 002474       684 002476       685 002502       686 002506       687 002510       689 002520
    690 002522       692 002524       695 002526       696 002530       698 002540       699 002542       701 002544
    706 002552       709 002560       711 002567       714 002606       715 002612       716 002613       717 002616
    718 002620       720 002621       722 002640       725 002651       726 002661       727 002665       729 002671
    732 002677       734 002705       737 002714       740 002733       741 002737       742 002742       743 002743
    745 002744       747 002745       748 002760       749 002762       751 002766       754 002775       757 003006
    758 003014       759 003016       761 003022       762 003026       763 003030       766 003036       768 003041
    770 003052       773 003061       776 003074       777 003100       778 003101       780 003103       782 003104
    787 003121       788 003125       790 003130       791 003132       792 003134       796 003140       798 003160
    800 003170       801 003172       803 003176       804 003177       805 003203       808 003210       809 003212
    810 003215       812 003222       819 003224       821 003230       823 003234       824 003236       827 003246
    828 003250       830 003252       832 003253       835 003263       836 003265       843 003267       848 003304
    850 003310       852 003312       855 003320       861 003327       876 003331       879 003342       881 003346
    882 003351       885 003355       889 003370       890 003374       891 003377       894 003403       897 003416
    898 003425       902 003426       911 003430       915 003507       917 003510       937 003512       939 003524
    942 003531       943 003541       944 003544       946 003550       948 003557       949 003570       950 003577
    952 003606       959 003704       961 003705       966 003746       969 003756       981 003760       982 003763
    984 003766       985 003772       986 003774       987 004000       988 004011       989 004013       990 004016
    992 004021       993 004023       998 004026      1007 004027      1010 004043      1013 004057      1018 004114
   1019 004122      1022 004125      1023 004130      1028 004131      1040 004133      1041 004135      1042 004140
   1045 004152      1048 004161      1049 004167      1053 004173      1067 004175      1069 004206      1070 004214
   1071 004217      1072 004220      1073 004223      1078 004251      1082 004254      1084 004256      1085 004262
   1086 004263      1087 004266      1093 004314      1097 004317      1099 004321      1100 004324      1104 004325
   1126 004327      1128 004330      1135 004405      1137 004412      1139 004416      1141 004424      1143 004426
   1148 004431      1149 004432      1150 004434      1151 004437      1153 004441      1157 004442      1160 004446
   1161 004452      1165 004465      1167 004466      1189 004470      1191 004476      1193 004503      1195 004506
   1198 004516      1199 004517      1201 004520      1203 004525      1204 004527      1207 004550      1209 004554
   1212 004562      1213 004563      1218 004565      1224 004613      1227 004622      1228 004627      1230 004633
   1231 004637      1233 004641      1236 004650      1239 004653      1241 004656      1242 004660      1244 004661
   1265 004662      1266 004665      1267 004703      1269 004705      1270 004710      1274 004724      1276 004726
   1279 004737      1281 004761      1283 004762      1285 004770      1288 004772      1296 004777      1297 005006
   1301 005011      1302 005013      1303 005016      1304 005021      1308 005024      1309 005027      1312 005034
   1314 005044      1315 005051      1316 005052      1319 005057      1320 005063      1322 005071      1323 005101
   1325 005115      1333 005125      1335 005134      1336 005137      1340 005140      1346 005141      1348 005151
   1350 005153      1354 005164      1356 005172      1358 005174      1360 005206      1362 005217      1364 005224
   1365 005240      1367 005241      1369 005256      1372 005257      1375 005261      1378 005272      1384 005305
   1387 005310      1393 005322      1396 005325      1397 005330      1405 005333      1418 005335      1421 005402
   1422 005406      1424 005414      1427 005422      1433 005434      1435 005452      1438 005456      1449 005460
   1450 005473      1453 005475      1455 005501      1456 005503      1457 005536      1458 005540      1460 005555
   1463 005556      1464 005560      1465 005604      1467 005627      1469 005675      1472 005701      1473 005703
   1476 005706      1477 005712      1479 005713      1480 005714      1483 005715      1487 005717      1491 005726
   1494 005764      1497 005765      1502 005767      1504 006006      1505 006043      1507 006045      1515 006046
   1523 006050      1524 006054      1525 006056      1527 006060      1529 006062      1532 006065      1543 006067
   1544 006075      1545 006077      1551 006110      1553 006113      1555 006114      1559 006125      1560 006132
   1562 006133      1563 006135      1566 006141      1567 006144      1570 006147      1571 006151      1576 006156
   1577 006164      1578 006166      1583 006176      1584 006206      1590 006220      1594 006240      1596 006254
   1597 006255      1601 006261      1614 006263      1615 006266      1619 006271      1622 006304      1623 006307
   1624 006311      1626 006323      1627 006325      1631 006336      1633 006346      1635 006352      1638 006362
   1639 006364      1641 006366      1642 006377      1645 006400      1646 006406      1651 006407      1653 006413
   1654 006415      1658 006422      1660 006426      1662 006432      1665 006442      1667 006445      1668 006447
   1670 006450      1671 006453      1673 006457      1675 006460      1676 006463      1679 006466      1682 006476
   1684 006500      1685 006504      1687 006505      1689 006511      1692 006512      1695 006517      1699 006533
   1700 006536      1701 006540      1703 006543      1706 006544      1712 006547      1713 006552      1714 006555
   1715 006557


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
