	COMPILATION LISTING OF SEGMENT im_general_delete
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  0955.9 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION:
        8*
        9*         This module is used to delete a specific key, either a leaf or
       10*     branch.  If the leaf key being deleted is the last key in the node, then
       11*     the node is deleted and im_general_delete is recursively invoked to
       12*     delete its parent key.  If the branch being deleted is not the low branch
       13*     id, then the key is simply deleted and the procedure is done.  If the
       14*     branch being deleted is the low_branch_id and there exist one or more
       15*     keys in the branch node, then the lowest key in the node is deleted and
       16*     its branch is made the low_branch_id, and the procedure is done.  The
       17*     last case is if the branch being deleted is the low_branch_id and there
       18*     are no keys in the branch node (i.e., it is a "degenerate" node).  In
       19*     this situation, the branch node is freed and im_general_delete is
       20*     recursively invoked to delete the parent key.
       21*
       22*     This module does not directly modify the contents of a file.  All 
       23*     modifications are actually made by the support routine im_simple_delete.
       24*     
       25*     This module accesses data via the "direct access" method, which involves
       26*     first getting a pointer to a control interval then getting data from it
       27*     by calling collection_manager_$simple_get_by_ci_ptr or
       28*     $get_portion_from_ci_buffer.
       29*
       30*     ***** This module must not attempt to modify the contents of the   *****
       31*     ***** current node/control interval.  All modification is done     *****
       32*     ***** in the subroutine im_simple_delete.  This includes both      *****
       33*     ***** modifications via collection_manager_ and via direct access. *****
       34**/
       35 
       36 /* HISTORY:
       37*
       38*Written by Lindsey L. Spratt, 08/06/82.
       39*Modified:
       40*10/18/82 by Matthew Pierret:  Added '"s", null, 0' arguments to sub_err_ call
       41*            in check_version.  Updated to use INDEX_CURSOR_VERSION_2 and
       42*            cm_$get_element_portion where appropriate.
       43*11/09/82 by Lindsey Spratt:  Changed calling sequence to remove
       44*	  index_header_ptr.  Changed to set the new root_id via the
       45*	  im_update_opening_info$root_id, rather than doing so directly.
       46*12/10/82 by Lindsey Spratt:  Changed to do a delete_node when deleting the
       47*	  last key in a leaf node, rather than doing a simple_delete.
       48*	  Changed to set the root_id to 0 after deleting the root (leaf)
       49*	  node.  Also, changed to not re-use the ci_header space provided by
       50*	  the  caller when doing a recursive delete on the parent node, but
       51*	  to use a local ci_header.
       52*02/28/83 by Lindsey Spratt:  Changed to use version 3 index_cursor.
       53*04/27/83 by Lindsey L. Spratt:  Fixed to update the parent_id_string of the
       54*            new root node to be "0"b.
       55*04/28/83 by Lindsey L. Spratt:  Fixed to update the parent_id_string of the
       56*            node pointed to by the low_branch_id.
       57*11/07/83 by Lindsey L. Spratt:  CHanged to use the "buffered" technology.
       58*            Also, converted to use the "call ERROR_RETURN(code)" protocol.
       59*03/27/84 by Matthew Pierret:  Changed from the "buffered access" technology
       60*            to the "direct access" technology, in which a pointer to a
       61*            control interval in the file is obtained.  Changed to not
       62*            replace the ci buffer contents after recursively invoking
       63*            itself.  All modifications are actually made by the support
       64*            routine im_simple_delete.
       65*06/07/84 by Matthew Pierret:  Re-named cm_$simple_get_element_ptr to
       66*            cm_$simple_get_by_ci_ptr, cm_$get_element to cm_$get,
       67*            cm_$get_element_portion_buffered to cm_$get_portion_from_ci_buffer,
       68*            cm_$put_element to cm_$modify, PUT_ELEMENT to MODIFY_ELEMENT.
       69*10/28/84 by Lindsey L. Spratt:  Removed dm_im_header.incl.pl1.  Made
       70*            index_opening_info_ptr local to the internal proc which references
       71*            it.
       72**/
       73 
       74 /* format: style2,ind3 */
       75 
       76 im_general_delete:
       77    proc (p_node_ptr, p_index_cursor_ptr, p_common_ci_header_ptr, p_key_id_string, p_deleted_node, p_code);
       78 
       79 
       80 /* START OF DECLARATIONS */
       81 /* Parameter */
       82 
       83       dcl	    p_node_ptr	       ptr parameter;
       84       dcl	    p_index_cursor_ptr     ptr parameter;
       85       dcl	    p_common_ci_header_ptr ptr parameter;
       86       dcl	    p_key_id_string	       bit (36) aligned;
       87       dcl	    p_deleted_node	       bit (1) aligned;
       88       dcl	    p_code	       fixed bin (35) parameter;
       89 
       90 /* Automatic */
       91 
       92       dcl	    local_ci_header_buffer bit (max (LEAF_CI_HEADER_LENGTH_IN_BITS, BRANCH_CI_HEADER_LENGTH_IN_BITS)) aligned;
       93 
       94       dcl	    (node_ptr, parent_node_ptr, parent_branch_ci_header_ptr)
       95 			       ptr init (null);
       96       dcl	    (parent_node_id, new_root_id)
       97 			       fixed bin (24) uns init (0);
       98       dcl	    parent_key_id_string   bit (36) aligned;
       99       dcl	    (new_buffer_was_allocated, deleted_node)
      100 			       bit (1) aligned init ("0"b);
      101       dcl	    local_key_buffer       bit (BRANCH_KEY_HEADER_LENGTH_IN_BITS) aligned;
      102       dcl	    local_node_buffer      bit (CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES * BITS_PER_BYTE) aligned;
      103 
      104 
      105 /* Based */
      106 /* Builtin */
      107 
      108       dcl	    (null, addr, length)   builtin;
      109 
      110 /* Constant */
      111 
      112       dcl	    DEFAULT_AREA_PTR       init (null) ptr internal static options (constant);
      113       dcl	    (
      114 	    DEFAULT_ELEMENT_LENGTH init (-1),
      115 	    BITS_PER_BYTE	       init (9)
      116 	    )		       fixed bin (35) internal static options (constant);
      117 
      118       dcl	    myname	       init ("im_general_delete") char (17) internal static options (constant);
      119 
      120 /* Entry */
      121 
      122       dcl	    im_get_opening_info    entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
      123       dcl	    im_update_opening_info$root_id
      124 			       entry (ptr, uns fixed bin (24), fixed bin (35));
      125       dcl	    im_simple_delete       entry (ptr, ptr, ptr, bit (36) aligned, fixed bin (35));
      126       dcl	    im_delete_node	       entry (ptr, fixed bin (24) unsigned, ptr, fixed bin (35));
      127       dcl	    im_general_delete      entry (ptr, ptr, ptr, bit (36) aligned, bit (1) aligned, fixed bin (35));
      128       dcl	    im_update_branches$single
      129 			       entry (ptr, bit (36) aligned, bit (36) aligned, ptr, uns fixed bin (24) unal,
      130 			       uns fixed bin (12) unal, fixed bin (35));
      131       dcl	    sub_err_	       entry () options (variable);
      132 
      133 /* External */
      134 
      135       dcl	    (
      136 	    dm_error_$wrong_cursor_type,
      137 	    error_table_$unimplemented_version
      138 	    )		       fixed bin (35) ext;
      139 
      140 /* END OF DECLARATIONS */
      141 
      142       p_code = 0;
      143       p_deleted_node = "0"b;
      144       node_ptr = p_node_ptr;
      145       index_cursor_ptr = p_index_cursor_ptr;
      146       if index_cursor.type ^= INDEX_CURSOR_TYPE
      147       then call sub_err_ (dm_error_$wrong_cursor_type, myname, ACTION_CANT_RESTART, null, 0,
      148 	      "^/Expected an ""index"" type cursor (type ^d).  
      149 Received a cursor of type ^d instead.", INDEX_CURSOR_TYPE, index_cursor.type);
      150 
      151       call CHECK_VERSION ((index_cursor.version), (INDEX_CURSOR_VERSION_3), "index_cursor");
      152 
      153       common_ci_header_ptr = p_common_ci_header_ptr;
      154 
      155       if common_ci_header.is_leaf
      156       then
      157          do;
      158 	  leaf_ci_header_ptr = common_ci_header_ptr;
      159 	  if leaf_ci_header.common.key_range.last > leaf_ci_header.common.key_range.first
      160 	  then /* There is more than one key in the ci. */
      161 	     do;
      162 	        call im_simple_delete (node_ptr, index_cursor_ptr, leaf_ci_header_ptr, p_key_id_string, p_code);
      163 	        if p_code ^= 0
      164 	        then call ERROR_RETURN (p_code);
      165 	     end;
      166 	  else
      167 	     do;
      168 	        parent_key_id_string = leaf_ci_header.common.parent_id_string;
      169 
      170 	        call im_delete_node (index_cursor_ptr, (addr (p_key_id_string) -> element_id.control_interval_id),
      171 		   common_ci_header_ptr, p_code);
      172 	        if p_code ^= 0
      173 	        then call ERROR_RETURN (p_code);
      174 
      175 	        common_ci_header.key_range.first, common_ci_header.key_range.last = 0;
      176 	        p_deleted_node = "1"b;		/* To indicate that the current leaf node is empty and gone. */
      177 	        if parent_key_id_string = "0"b
      178 	        then call UPDATE_ROOT_ID (0);
      179 	        else
      180 		 do;
      181 
      182 		    parent_branch_ci_header_ptr = addr (local_ci_header_buffer);
      183 		    call GET_PARENT_NODE ((addr (parent_key_id_string) -> element_id.control_interval_id),
      184 		         parent_node_id, parent_node_ptr);
      185 		    call GET_CI_HEADER_PTR (parent_node_ptr, parent_node_id, parent_branch_ci_header_ptr);
      186 
      187 		    call im_general_delete (parent_node_ptr, index_cursor_ptr, parent_branch_ci_header_ptr,
      188 		         parent_key_id_string, deleted_node, p_code);
      189 		    if p_code ^= 0
      190 		    then call ERROR_RETURN (p_code);
      191 		 end;
      192 	     end;
      193          end;
      194       else if common_ci_header.parent_id_string = "0"b
      195 	      & common_ci_header.key_range.first = common_ci_header.key_range.last
      196 	      & common_ci_header.key_range.first > 0
      197       then
      198          do;					/* Current node is the root node, and the "upcoming" */
      199 						/* deletion will leave it "degenerate".  Rather than */
      200 						/* have a degenerate root node, this root node is deleted */
      201 						/* and the single child of its degenerate form is made */
      202 						/* the new root node. */
      203 	  branch_ci_header_ptr = common_ci_header_ptr;
      204 
      205 	  if addr (p_key_id_string) -> element_id.index > 0
      206 	  then new_root_id = branch_ci_header.low_branch_id;
      207 	  else
      208 	     do;
      209 	        bk_string_length = 0;
      210 	        element_id.control_interval_id = addr (p_key_id_string) -> element_id.control_interval_id;
      211 	        element_id.index = branch_ci_header.common.key_range.first;
      212 	        call collection_manager_$get_portion_from_ci_buffer (node_ptr, index_cursor.file_opening_id,
      213 		   index_cursor.collection_id, element_id_string, addr (local_key_buffer), length (local_key_buffer),
      214 		   null, 1, BRANCH_KEY_HEADER_LENGTH_IN_BITS, new_buffer_was_allocated, branch_key_ptr, (0), p_code);
      215 	        if p_code ^= 0
      216 	        then call ERROR_RETURN (p_code);
      217 	        new_root_id = branch_key.branch_id;
      218 	     end;
      219 	  call im_delete_node (index_cursor_ptr, (addr (p_key_id_string) -> element_id.control_interval_id),
      220 	       common_ci_header_ptr, p_code);
      221 	  if p_code ^= 0
      222 	  then call ERROR_RETURN (p_code);
      223 
      224 	  p_deleted_node = "1"b;
      225 
      226 /* The node which is to become the new root node must have its
      227*parent_id_string updated to be "0"b, indicating it is the root node. */
      228 
      229 	  common_ci_header_ptr = addr (local_ci_header_buffer);
      230 	  call GET_CI_HEADER ((new_root_id), common_ci_header_ptr);
      231 
      232 	  common_ci_header.parent_id_string = "0"b;
      233 
      234 	  call PUT_CI_HEADER ((new_root_id), common_ci_header_ptr);
      235 
      236 /* The root_id values in the index_opening_info and the index header must be
      237*updated. */
      238 
      239 	  call UPDATE_ROOT_ID (new_root_id);
      240          end;
      241       else if addr (p_key_id_string) -> element_id.index > 0
      242       then call im_simple_delete (node_ptr, index_cursor_ptr, common_ci_header_ptr, p_key_id_string, p_code);
      243       else if common_ci_header.key_range.first > 0
      244       then
      245          do;
      246 	  branch_ci_header_ptr = common_ci_header_ptr;
      247 
      248 	  bk_string_length = 0;
      249 	  element_id.control_interval_id = addr (p_key_id_string) -> element_id.control_interval_id;
      250 	  element_id.index = branch_ci_header.common.key_range.first;
      251 	  call collection_manager_$get_portion_from_ci_buffer (node_ptr, index_cursor.file_opening_id,
      252 	       index_cursor.collection_id, element_id_string, addr (local_key_buffer), length (local_key_buffer), null,
      253 	       1, BRANCH_KEY_HEADER_LENGTH_IN_BITS, new_buffer_was_allocated, branch_key_ptr, (0), p_code);
      254 	  if p_code ^= 0
      255 	  then call ERROR_RETURN (p_code);
      256 
      257 	  branch_ci_header.low_branch_id = branch_key.branch_id;
      258 	  call im_simple_delete (node_ptr, index_cursor_ptr, branch_ci_header_ptr, element_id_string, p_code);
      259 	  if p_code ^= 0
      260 	  then call ERROR_RETURN (p_code);
      261 
      262 /* im_simple_delete knows to update the branches grater than or equal to
      263*element_id.index, but the 0'th branch (the low_branch_id) must also be
      264*updated. */
      265 
      266 	  call im_update_branches$single (node_ptr, index_cursor.file_opening_id, index_cursor.collection_id,
      267 	       branch_ci_header_ptr, element_id.control_interval_id, 0, p_code);
      268 	  if p_code ^= 0
      269 	  then call ERROR_RETURN (p_code);
      270 
      271          end;
      272       else
      273          do;
      274 	  parent_key_id_string = common_ci_header.parent_id_string;
      275 
      276 	  call im_delete_node (index_cursor_ptr, (addr (p_key_id_string) -> element_id.control_interval_id),
      277 	       common_ci_header_ptr, p_code);
      278 	  if p_code ^= 0
      279 	  then call ERROR_RETURN (p_code);
      280 
      281 	  p_deleted_node = "1"b;
      282 
      283 	  common_ci_header.key_range.first, common_ci_header.key_range.last = 0;
      284 						/* This indicates that the node in question is empty (gone, as well). */
      285 
      286 	  call GET_PARENT_NODE ((addr (parent_key_id_string) -> element_id.control_interval_id), parent_node_id,
      287 	       parent_node_ptr);
      288 
      289 	  parent_branch_ci_header_ptr = addr (local_ci_header_buffer);
      290 	  call GET_CI_HEADER_PTR (parent_node_ptr, parent_node_id, parent_branch_ci_header_ptr);
      291 
      292 	  call im_general_delete (parent_node_ptr, index_cursor_ptr, parent_branch_ci_header_ptr, parent_key_id_string,
      293 	       deleted_node, p_code);
      294 	  if p_code ^= 0
      295 	  then call ERROR_RETURN (p_code);
      296 
      297          end;
      298 
      299 MAIN_RETURN:
      300       return;
      301 
      302 FINISH:
      303    proc ();
      304    end FINISH;
      305 
      306 ERROR_RETURN:
      307    proc (er_p_code);
      308       dcl	    er_p_code	       fixed bin (35);
      309       call FINISH;
      310       p_code = er_p_code;
      311       goto MAIN_RETURN;
      312    end ERROR_RETURN;
      313 
      314 
      315 CHECK_VERSION:
      316    proc (cv_p_received_version, cv_p_expected_version, cv_p_structure_name);
      317       dcl	    cv_p_received_version  fixed bin (35);
      318       dcl	    cv_p_expected_version  fixed bin (35);
      319       dcl	    cv_p_structure_name    char (*);
      320 
      321       if cv_p_expected_version ^= cv_p_received_version
      322       then call sub_err_ (error_table_$unimplemented_version, myname, "s", null, 0,
      323 	      "^/Expected version ^d of the ^a structure. Received version ^d instead.", cv_p_expected_version,
      324 	      cv_p_structure_name, cv_p_received_version);
      325 
      326    end CHECK_VERSION;
      327 
      328 UPDATE_ROOT_ID:
      329    proc (uri_p_root_id);
      330       dcl	    uri_p_root_id	       fixed bin (24) uns;
      331       dcl	    uri_code	       fixed bin (35) init (0);
      332       dcl	    uri_index_opening_info_ptr
      333 			       ptr init (null);
      334 
      335       call im_get_opening_info (index_cursor.file_opening_id, index_cursor.collection_id, uri_index_opening_info_ptr,
      336 	 uri_code);
      337       if uri_code ^= 0
      338       then call ERROR_RETURN (uri_code);
      339 
      340       call im_update_opening_info$root_id (uri_index_opening_info_ptr, uri_p_root_id, uri_code);
      341       if uri_code ^= 0
      342       then call ERROR_RETURN (uri_code);
      343    end UPDATE_ROOT_ID;
      344 
      345 GET_CI_HEADER:
      346    proc (gch_p_control_interval_id, gch_p_ci_header_ptr);
      347       dcl	    gch_p_control_interval_id
      348 			       fixed bin (24) unsigned;
      349       dcl	    gch_p_ci_header_ptr    ptr;
      350       dcl	    gch_p_node_ptr	       ptr;
      351       dcl	    gch_by_node_ptr	       bit (1) aligned;
      352 
      353       gch_by_node_ptr = "0"b;
      354       goto GCH_JOIN;
      355 
      356 GET_CI_HEADER_PTR:
      357    entry (gch_p_node_ptr, gch_p_control_interval_id, gch_p_ci_header_ptr);
      358       gch_by_node_ptr = "1"b;
      359 GCH_JOIN:
      360       if gch_by_node_ptr
      361       then call GET_ELEMENT_PTR (gch_p_node_ptr, gch_p_control_interval_id, (DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT),
      362 	      gch_p_ci_header_ptr, max (LEAF_CI_HEADER_LENGTH_IN_BITS, BRANCH_CI_HEADER_LENGTH_IN_BITS), (0));
      363       else call GET_ELEMENT (gch_p_control_interval_id, (DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT), gch_p_ci_header_ptr,
      364 	      max (LEAF_CI_HEADER_LENGTH_IN_BITS, BRANCH_CI_HEADER_LENGTH_IN_BITS), (0));
      365    end GET_CI_HEADER;
      366 
      367 
      368 
      369 
      370 PUT_CI_HEADER:
      371    proc (pch_p_control_interval_id, pch_p_ci_header_ptr);
      372       dcl	    pch_p_control_interval_id
      373 			       fixed bin (24) unsigned;
      374       dcl	    pch_p_ci_header_ptr    ptr;
      375       dcl	    pch_p_node_ptr	       ptr;
      376 
      377       call MODIFY_ELEMENT (pch_p_control_interval_id, (DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT),
      378 	 DEFAULT_ELEMENT_LENGTH, pch_p_ci_header_ptr);
      379    end PUT_CI_HEADER;
      380 
      381 GET_ELEMENT:
      382    proc (ge_p_control_interval_id, ge_p_slot_index, ge_p_buffer_ptr, ge_p_buffer_length, ge_p_element_length);
      383 
      384       dcl	    ge_p_control_interval_id
      385 			       fixed bin (24) uns;
      386       dcl	    ge_p_slot_index	       fixed bin (12) uns;
      387       dcl	    ge_p_buffer_ptr	       ptr;
      388       dcl	    ge_p_buffer_length     fixed bin (35);
      389       dcl	    ge_p_element_length    fixed bin (35);
      390       dcl	    ge_p_node_ptr	       ptr;
      391 
      392       dcl	    ge_code	       fixed bin (35) init (0);
      393 
      394       dcl	    1 ge_element_id	       aligned based (addr (ge_element_id_string)) like element_id;
      395       dcl	    ge_element_id_string   bit (36) aligned;
      396       dcl	    ge_by_node_ptr	       bit (1) aligned;
      397 
      398       ge_by_node_ptr = "0"b;
      399       goto GE_JOIN;
      400 
      401 GET_ELEMENT_PTR:
      402    entry (ge_p_node_ptr, ge_p_control_interval_id, ge_p_slot_index, ge_p_buffer_ptr, ge_p_buffer_length,
      403         ge_p_element_length);
      404 
      405       ge_by_node_ptr = "1"b;
      406 GE_JOIN:
      407       ge_element_id.control_interval_id = ge_p_control_interval_id;
      408       ge_element_id.index = ge_p_slot_index;
      409 
      410       if ge_by_node_ptr
      411       then call collection_manager_$simple_get_by_ci_ptr (ge_p_node_ptr, index_cursor.collection_id, ge_element_id_string,
      412 	      ge_p_buffer_ptr, ge_p_buffer_length, ge_p_element_length, ge_code);
      413       else call collection_manager_$get (index_cursor.file_opening_id, index_cursor.collection_id, ge_element_id_string,
      414 	      (0), ge_p_buffer_ptr, ge_p_buffer_length, null, ("0"b), null, ge_p_element_length, ge_code);
      415       if ge_code ^= 0
      416       then call ERROR_RETURN (ge_code);
      417 
      418    end GET_ELEMENT;
      419 
      420 MODIFY_ELEMENT:
      421    proc (me_p_control_interval_id, me_p_slot_index, me_p_element_length, me_p_element_ptr);
      422       dcl	    me_p_control_interval_id
      423 			       fixed bin (24) uns;
      424       dcl	    me_p_slot_index	       fixed bin (12) uns;
      425       dcl	    me_p_element_length    fixed bin (35);
      426       dcl	    me_p_element_ptr       ptr;
      427       dcl	    me_p_node_ptr	       ptr;
      428 
      429       dcl	    me_code	       fixed bin (35) init (0);
      430 
      431       dcl	    1 me_element_id	       aligned based (addr (me_element_id_string)) like element_id;
      432       dcl	    me_element_id_string   bit (36) aligned;
      433 
      434       me_element_id.control_interval_id = me_p_control_interval_id;
      435       me_element_id.index = me_p_slot_index;
      436 
      437       call collection_manager_$modify (index_cursor.file_opening_id, index_cursor.collection_id, me_p_element_ptr,
      438 	 me_p_element_length, me_element_id_string, (0), me_code);
      439       if me_code ^= 0
      440       then call ERROR_RETURN (me_code);
      441 
      442    end MODIFY_ELEMENT;
      443 
      444 GET_PARENT_NODE:
      445    proc (gpn_p_node_id, gpn_p_parent_node_id, gpn_p_parent_node_ptr);
      446 
      447       dcl	    (gpn_p_node_id, gpn_p_parent_node_id)
      448 			       fixed bin (24) unsigned;
      449       dcl	    gpn_p_parent_node_ptr  ptr;
      450 
      451       dcl	    gpn_code	       fixed bin (35) init (0);
      452 
      453       gpn_p_parent_node_id = gpn_p_node_id;
      454 
      455       call collection_manager_$get_control_interval_ptr (index_cursor.file_opening_id, index_cursor.collection_id,
      456 	 gpn_p_parent_node_id, gpn_p_parent_node_ptr, gpn_code);
      457       if gpn_code ^= 0
      458       then call ERROR_RETURN (gpn_code);
      459 
      460    end GET_PARENT_NODE;
      461 
  1     1 /* BEGIN INCLUDE FILE - dm_im_cursor.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*          This structure specifies a DM file, an index collection in that DM
  1     6*file, and a position (key) in that index collection.
  1     7*
  1     8**/
  1     9 
  1    10 /* HISTORY:
  1    11*
  1    12*Written by Lindsey Spratt, 03/29/82
  1    13*Modified:
  1    14*08/09/82 by Matthew Pierret: Changed collection_id from "fixed bin (17)" to
  1    15*            "bit (35) aligned".
  1    16*08/26/82 by Lindsey Spratt:  Changed to version 2.  Added the is_valid and
  1    17*	  is_at_end_of_index flags.  Changed the key_check_value to fixed
  1    18*	  bin (35).  Added the IM_HASH_BIAS, which is used to increment the
  1    19*	  value developed by hash_index_, and IM_HASH_NUMBER_OF_BUCKETS,
  1    20*	  which is a unique number used by hash_index_ to develop the
  1    21*	  key_check_value.
  1    22*02/23/83 by Lindsey Spratt: Changed to keep the current key value in the
  1    23*	  cursor.  Also, implemented the ability to have the cursor
  1    24*	  positioned before or after the index.  
  1    25*10/23/84 by Lindsey L. Spratt:  Added a description section.
  1    26**/
  1    27 
  1    28 /* format: style2,ind3 */
  1    29      dcl	   1 index_cursor	      based (index_cursor_ptr),
  1    30 	     2 type	      fixed bin (17) unaligned,
  1    31 	     2 version	      fixed bin (17) unaligned,
  1    32 	     2 file_opening_id    bit (36) aligned,
  1    33 	     2 collection_id      bit (36) aligned,
  1    34 	     2 key_id_string      bit (36) aligned,	/* Is the location of the current key, */
  1    35 						/* if flags.current_key_exists is on. Is the location */
  1    36 						/* of the end of the index if flags.is_at_end_of_index */
  1    37 						/* is on, which is only available via an operation */
  1    38 						/* requiring the "previous" key.  Is the location of */
  1    39 						/* the "next" key, otherwise. */
  1    40 	     2 area_ptr	      ptr,		/* Area in which the cursor and key_string area allocated. */
  1    41 						/* Must be a freeing area. */
  1    42 	     2 current_key_string_ptr
  1    43 			      ptr,		/* Points to the value of the current key. */
  1    44 	     2 current_key_string_length
  1    45 			      fixed bin (24) unal,	/* Is the length of the current key in bits. */
  1    46 	     2 pad	      bit (12) unal,
  1    47 	     2 flags	      aligned,
  1    48 	       3 is_at_beginning_of_index
  1    49 			      bit (1) unaligned,	/* Only the "next" key is defined. */
  1    50 	       3 is_at_end_of_index
  1    51 			      bit (1) unaligned,	/* Only the "previous" key is defined. */
  1    52 	       3 current_key_exists
  1    53 			      bit (1) unaligned,	/* If on, indicates that the "current" key is identified */
  1    54 						/* by the key_id_string.  If off, the "current" position */
  1    55 						/* is undefined, and the key_id_string identifies the */
  1    56 						/* previous or next key, depending on whether */
  1    57 						/* flags.is_at_end_of_index is off or on, respectively. */
  1    58 	       3 is_valid	      bit (1) unaligned,	/* If off, the index_manager_ was interrupted while */
  1    59 						/* setting the cursor position and the cursor is not */
  1    60 						/* to be trusted for relative position operations. */
  1    61 	       3 pad	      bit (32) unal;
  1    62 
  1    63 
  1    64      dcl	   index_cursor_ptr	      ptr;
  1    65 
  1    66      dcl	   INDEX_CURSOR_VERSION_3 fixed bin (17) init (3) internal static options (constant);
  1    67      dcl	   INDEX_CURSOR_TYPE      init (2) fixed bin (17) internal static options (constant);
  1    68 
  1    69 /* END INCLUDE FILE - dm_im_cursor.incl.pl1 */
      462 
      463 
  2     1 /* BEGIN INCLUDE FILE - dm_im_key.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*          There are two formats for keys, the leaf_key structure and the
  2     6*     branch_key structure. The branch_key has two more pieces of information
  2     7*     than the leaf_key. One is the control interval id of the
  2     8*     node for all keys greater than the value of the branch key.  The other is
  2     9*     the number of fields for which there are values in the "string" portion
  2    10*     of the key.  This allows for the storing of only as much data as is needed
  2    11*     to discriminate between the children being split by the branch key.
  2    12**/
  2    13 
  2    14 /* HISTORY:
  2    15*
  2    16*Written by Lindsey Spratt, 03/29/82.
  2    17*Modified:
  2    18*10/25/84 by Lindsey L. Spratt:  Added history and description sections.
  2    19**/
  2    20 
  2    21 /* format: style2,ind3 */
  2    22      dcl	   key_string	      bit (key_string_length) based (key_string_ptr);
  2    23      dcl	   key_string_length      fixed bin (35);
  2    24      dcl	   key_string_ptr	      ptr;
  2    25 
  2    26      dcl	   1 leaf_key	      based (leaf_key_ptr) unaligned,
  2    27 	     2 string	      bit (lk_string_length) unal;
  2    28 
  2    29      dcl	   lk_string_length	      fixed bin (35);
  2    30      dcl	   leaf_key_ptr	      ptr;
  2    31 
  2    32      dcl	   1 branch_key	      based (branch_key_ptr) unaligned,
  2    33 	     2 branch_id	      fixed bin (24) unsigned unaligned,
  2    34 	     2 last_field_idx     fixed bin (12) unaligned unsigned,
  2    35 	     2 string	      bit (bk_string_length) unal;
  2    36 
  2    37      dcl	   BRANCH_KEY_HEADER_LENGTH_IN_BITS
  2    38 			      init (36) fixed bin (35) internal static options (constant);
  2    39      dcl	   bk_string_length	      fixed bin (35);
  2    40      dcl	   branch_key_ptr	      ptr;
  2    41 
  2    42 /* END INCLUDE FILE - dm_im_key.incl.pl1 */
      464 
      465 
  3     1 /* BEGIN INCLUDE FILE - dm_im_ci_header.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*
  3     5*          Each node (control interval) in the index has a header which
  3     6*     describes the contents of that node.  Although there are two different
  3     7*     kinds of headers, leaf and branch, they have a great deal in common, the
  3     8*     common_ci_header.  The common_ci_header states which slots are used by
  3     9*     the keys (leaf or branch) in the key_range substructure.  There is an
  3    10*     "upward pointer" to the node's parent branch key (parent_id_string).
  3    11*     There are pointers to the previous and next nodes (previous_id and
  3    12*     next_id) on the same level to facilitate rotation of keys, and sequential
  3    13*     searching.  There is also a count of how much space is in use by the keys.
  3    14*
  3    15**/
  3    16 
  3    17 /* HISTORY:
  3    18*
  3    19*Written by Lindsey Spratt, 03/29/82.
  3    20*Modified:
  3    21*10/25/84 by Lindsey L. Spratt:  Added a description and fixed the history
  3    22*            section format.
  3    23**/
  3    24 
  3    25 /* format: style2,ind3 */
  3    26      dcl	   1 common_ci_header     based (common_ci_header_ptr),
  3    27 	     2 flags	      unaligned,
  3    28 	       3 is_leaf	      bit (1) unaligned,	/* ON for leaf_ci, OFF for branch_ci. */
  3    29 	       3 pad	      bit (17) unaligned,	/* Must be zero. */
  3    30 	     2 key_tail_space_used_since_last_prefix_compaction
  3    31 			      fixed bin (18) unsigned unal,
  3    32 	     2 key_range	      unaligned,
  3    33 	       3 first	      fixed bin (18) unsigned,
  3    34 	       3 last	      fixed bin (18) unsigned,
  3    35 	     2 parent_id_string   bit (36) aligned,
  3    36 	     2 previous_id	      fixed bin (24) unsigned unaligned,
  3    37 	     2 next_id	      fixed bin (24) unsigned unaligned,
  3    38 	     2 pad	      bit (24) unaligned;
  3    39 
  3    40 
  3    41      dcl	   common_ci_header_ptr   ptr;
  3    42 
  3    43      dcl	   1 leaf_ci_header	      based (leaf_ci_header_ptr),
  3    44 	     2 common	      like common_ci_header;
  3    45 
  3    46      dcl	   leaf_ci_header_ptr     ptr;
  3    47 
  3    48      dcl	   1 branch_ci_header     based (branch_ci_header_ptr),
  3    49 	     2 common	      like common_ci_header,
  3    50 	     2 low_branch_id      fixed bin (24) unsigned unaligned,
  3    51 	     2 pad	      bit (12) unaligned;
  3    52 
  3    53      dcl	   branch_ci_header_ptr   ptr;
  3    54 
  3    55 
  3    56      dcl	   (
  3    57 	   DEFAULT_INITIAL_KEY_SLOT
  3    58 			      init (2),
  3    59 	   DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT
  3    60 			      init (1),
  3    61 	   LEAF_CI_HEADER_LENGTH_IN_BITS
  3    62 			      init (180),
  3    63 	   BRANCH_CI_HEADER_LENGTH_IN_BITS
  3    64 			      init (216)
  3    65 	   )		      internal static options (constant) fixed bin;
  3    66 
  3    67 /* END INCLUDE FILE - dm_im_ci_header.incl.pl1 */
      466 
      467 
  4     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*        Contains the declaration of an element identifier.  Element
  4     6*   identifiers consist of two parts, the id (number) of the control interval
  4     7*   in which the element resides, and the index into the slot table of
  4     8*   the element in the control interval.  The declaration of the element_id 
  4     9*   structure reflects this division of the element identifier.  The structure 
  4    10*   is based on the automatic bit string element_id_string because programs
  4    11*   generally pass bit strings (element_id_string) to each other, then 
  4    12*   interpret the bit string by overlaying the element_id structure ony if
  4    13*   it is necessary to access the parts of the id.  Basing element_id on
  4    14*   addr(element_id_string) instead of on a pointer removes the necessity
  4    15*   for always setting that pointer explicitly and guarantees that changes
  4    16*   made to the string or structure do not get inconsistent.
  4    17*
  4    18*   Changes made to element_id must also be made to datum_id, declared in 
  4    19*   dm_cm_datum.incl.pl1.
  4    20**/
  4    21 
  4    22 /* HISTORY:
  4    23*Written by Matthew Pierret, 04/01/82.
  4    24*Modified:
  4    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  4    26**/
  4    27 
  4    28 /* format: style2,ind3,ll79 */
  4    29 
  4    30      dcl	   element_id_string      bit (36) aligned;
  4    31 
  4    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  4    33 	     2 control_interval_id
  4    34 			      fixed bin (24) unal unsigned,
  4    35 	     2 index	      fixed bin (12) unal unsigned;
  4    36 
  4    37 
  4    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      468 
      469 
  5     1 /* BEGIN INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*     This include file contains declarations of all collection_manager_ 
  5     5*     entrypoints.
  5     6**/
  5     7 
  5     8 /* HISTORY:
  5     9*Written by Matthew Pierret 
  5    10*Modified:
  5    11*04/14/82 by Lindsey Spratt: Changed the control_interval_id parameter of the
  5    12*	  allocate_control_interval operation to be unaligned, as well as
  5    13*	  unsigned.
  5    14*06/17/82 by Matthew Pierret: Added the put_element_portion opertion and
  5    15*            removed the beginning_location parameter from the put_element
  5    16*            operation. Added the create_page_file_operation.
  5    17*08/09/82 by Matthew Pierret: Changed "fixed bin (17)"s to "bit (36) aligned"s
  5    18*            wherever collection_id was required.
  5    19*            Also changed the control_interval_id parameter of the 
  5    20*            allocate_control_interval operation back to be aligned. So there.
  5    21*10/20/82 by Matthew Pierret: Changed $create_page_file to $create_file,
  5    22*            added the argument file_create_info_ptr to $create_file.
  5    23*12/13/82 by Lindsey Spratt:  Corrected $free_control_interval to
  5    24*	  include the zero_on_free bit.
  5    25*12/17/82 by Matthew Pierret: Added cm_$get_id.
  5    26*01/07/83 by Matthew Pierret: Added cm_$put_element_buffered, 
  5    27*            cm_$allocate_element_buffered, cm_$free_element_buffered.
  5    28*04/27/83 by Matthew Pierret: Added cm_$put_unprotected_element,
  5    29*            cm_$put_unprotected_header.
  5    30*11/07/83 by Matthew Pierret: Added $get_element_portion_buffered,
  5    31*             $simple_get_buffered_element.
  5    32*02/08/84 by Matthew Pierret:  Changed $get_id to have only one bit(1)aligned
  5    33*            parameter for specifying absolute/relative nature of search.
  5    34*03/16/84 by Matthew Pierret:  Added cm_$get_control_interval_ptr,
  5    35*            $get_element_ptr, $get_element_portion_ptr, $simple_get_element_ptr
  5    36*04/03/84 by Matthew Pierret:  Added cm_$compact_control_interval.
  5    37*06/06/84 by Matthew Pierret:  Re-named free_element* to delete and
  5    38*            delete_from_ci_buffer.
  5    39*            Re-named *_buffered_ci to =_ci_buffer.
  5    40*            get entries.
  5    41*            modify entries.
  5    42*            Changed calling sequence of modify entries to have a ptr/length
  5    43*            instead of length/ptr parameter pair.
  5    44*03/11/85 by R. Michael Tague:  Added $postcommit_increments.
  5    45**/
  5    46 
  5    47 /* This include file contains declarations of collection_manager_ entrypoints */
  5    48 
  5    49 /* format: style2,ind3 */
  5    50      dcl	   collection_manager_$allocate_control_interval
  5    51 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  5    52      dcl	   collection_manager_$compact_control_interval
  5    53 			      entry (bit (36) aligned, fixed bin (24) uns, fixed bin (35));
  5    54      dcl	   collection_manager_$create_collection
  5    55 			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  5    56      dcl	   collection_manager_$create_file
  5    57 			      entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
  5    58      dcl	   collection_manager_$destroy_collection
  5    59 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  5    60      dcl	   collection_manager_$free_control_interval
  5    61 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, bit (1) aligned,
  5    62 			      fixed bin (35));
  5    63 
  5    64      dcl	   collection_manager_$delete
  5    65 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  5    66 			      fixed bin (35));
  5    67      dcl	   collection_manager_$delete_from_ci_buffer
  5    68 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  5    69 			      fixed bin (35));
  5    70 
  5    71      dcl	   collection_manager_$get
  5    72 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  5    73 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  5    74      dcl	   collection_manager_$get_control_interval_ptr
  5    75 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, ptr,
  5    76 			      fixed bin (35));
  5    77      dcl	   collection_manager_$get_from_ci_buffer
  5    78 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  5    79 			      ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  5    80      dcl	   collection_manager_$get_by_ci_ptr
  5    81 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  5    82 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), ptr, fixed bin (35));
  5    83      dcl	   collection_manager_$get_header
  5    84 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (17), ptr, bit (1) aligned,
  5    85 			      ptr, fixed bin (35), fixed bin (35));
  5    86      dcl	   collection_manager_$get_id
  5    87 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17),
  5    88 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  5    89      dcl	   collection_manager_$get_portion
  5    90 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  5    91 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  5    92 			      fixed bin (35), fixed bin (35));
  5    93      dcl	   collection_manager_$get_portion_from_ci_buffer
  5    94 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  5    95 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  5    96 			      fixed bin (35));
  5    97      dcl	   collection_manager_$get_portion_by_ci_ptr
  5    98 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  5    99 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  5   100 			      fixed bin (35));
  5   101      dcl	   collection_manager_$modify
  5   102 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   103 			      fixed bin (35), fixed bin (35));
  5   104      dcl	   collection_manager_$modify_unprotected
  5   105 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   106 			      fixed bin (35), fixed bin (35));
  5   107      dcl	   collection_manager_$modify_in_ci_buffer
  5   108 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   109 			      fixed bin (35), fixed bin (35));
  5   110      dcl	   collection_manager_$modify_portion
  5   111 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35), ptr,
  5   112 			      fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  5   113      dcl	   collection_manager_$postcommit_increments
  5   114 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  5   115      dcl	   collection_manager_$put
  5   116 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   117 			      fixed bin (35), fixed bin (35));
  5   118      dcl	   collection_manager_$put_in_ci_buffer
  5   119 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  5   120 			      fixed bin (35), fixed bin (35));
  5   121      dcl	   collection_manager_$put_header
  5   122 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  5   123      dcl	   collection_manager_$put_unprotected_header
  5   124 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  5   125 
  5   126      dcl	   collection_manager_$replace_ci_buffer
  5   127 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  5   128 			      fixed bin (35));
  5   129      dcl	   collection_manager_$setup_ci_buffer
  5   130 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  5   131 			      fixed bin (35));
  5   132      dcl	   collection_manager_$simple_get_by_ci_ptr
  5   133 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  5   134 			      fixed bin (35));
  5   135      dcl	   collection_manager_$simple_get_from_ci_buffer
  5   136 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  5   137 			      fixed bin (35));
  5   138 
  5   139 /* END INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
      470 
      471 
  6     1 /* BEGIN INCLUDE FILE dm_ci_lengths.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*       This include file contains constants which are the length in bytes
  6     5*   of the addressable portion of a control interval.  The addressable portion
  6     6*   is that part of the control interval which callers of file_manager_
  6     7*   may access, specifically, everything between the end of the control
  6     8*   interval header (ci_header) and the control interval trailer (ci_trailer).
  6     9*   Control interval 0 is slightly different, as it also contains an 
  6    10*   unaddressable portion in which it maintains the file attributes.  For
  6    11*   control interval 0 the addressable portion is everything between the end
  6    12*   of the control interval header and the beginning of the file attributes.
  6    13**/
  6    14 
  6    15 /* HISTORY:
  6    16*Written by Matthew Pierret, 11/02/84.
  6    17*Modified:
  6    18**/
  6    19 
  6    20 /* format: style2,ind3 */
  6    21 
  6    22      dcl	   CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
  6    23 			      fixed bin (17) init (4072) int static options (constant);
  6    24 
  6    25      dcl	   CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
  6    26 			      fixed bin (17) init (3176) int static options (constant);
  6    27 
  6    28 
  6    29      dcl	   CI_ADDRESSABLE_LENGTH  fixed bin (17) init (4072) int static options (constant);
  6    30 
  6    31      dcl	   CI_0_ADDRESSABLE_LENGTH
  6    32 			      fixed bin (17) init (3176) int static options (constant);
  6    33 
  6    34 /* END INCLUDE FILE dm_ci_lengths.incl.pl1 */
      472 
      473 
  7     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  7     2 /* format: style3 */
  7     3 
  7     4 /* These constants are to be used for the flags argument of sub_err_ */
  7     5 /* They are just "string (condition_info_header.action_flags)" */
  7     6 
  7     7 declare	(
  7     8 	ACTION_CAN_RESTART	init (""b),
  7     9 	ACTION_CANT_RESTART init ("1"b),
  7    10 	ACTION_DEFAULT_RESTART
  7    11 			init ("01"b),
  7    12 	ACTION_QUIET_RESTART
  7    13 			init ("001"b),
  7    14 	ACTION_SUPPORT_SIGNAL
  7    15 			init ("0001"b)
  7    16 	)		bit (36) aligned internal static options (constant);
  7    17 
  7    18 /* End include file */
      474 
      475    end im_general_delete;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0913.3  im_general_delete.pl1             >spec>on>7192.pbf-04/04/85>im_general_delete.pl1
462          1    01/07/85  0858.9  dm_im_cursor.incl.pl1             >ldd>include>dm_im_cursor.incl.pl1
464          2    01/07/85  0858.9  dm_im_key.incl.pl1                >ldd>include>dm_im_key.incl.pl1
466          3    01/07/85  0858.8  dm_im_ci_header.incl.pl1          >ldd>include>dm_im_ci_header.incl.pl1
468          4    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
470          5    04/04/85  0819.0  dm_collmgr_entry_dcls.incl.pl1    >spec>on>7192.pbf-04/04/85>dm_collmgr_entry_dcls.incl.pl1
472          6    01/07/85  0900.7  dm_ci_lengths.incl.pl1            >ldd>include>dm_ci_lengths.incl.pl1
474          7    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000013 constant        bit(36)                  initial dcl 7-7 set ref 146*
BITS_PER_BYTE                          constant        fixed bin(35,0)          initial dcl 113 ref 102
BRANCH_CI_HEADER_LENGTH_IN_BITS        constant        fixed bin(17,0)          initial dcl 3-56 ref 92 359 359 363 363
BRANCH_KEY_HEADER_LENGTH_IN_BITS
                                000022 constant        fixed bin(35,0)          initial dcl 2-37 set ref 101 212* 251*
CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
                                       constant        fixed bin(17,0)          initial dcl 6-22 ref 102
DEFAULT_ELEMENT_LENGTH          000005 constant        fixed bin(35,0)          initial dcl 113 set ref 377*
DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT
                                       constant        fixed bin(17,0)          initial dcl 3-56 ref 359 363 377
INDEX_CURSOR_TYPE               000026 constant        fixed bin(17,0)          initial dcl 1-67 set ref 146 146*
INDEX_CURSOR_VERSION_3                 constant        fixed bin(17,0)          initial dcl 1-66 ref 151
LEAF_CI_HEADER_LENGTH_IN_BITS          constant        fixed bin(17,0)          initial dcl 3-56 ref 92 359 359 363 363
addr                                                   builtin function         dcl 108 ref 170 182 183 205 210 210 211 212 212 219
                                                                                  229 241 249 249 250 251 251 266 276 286 289 406
                                                                                  408 434 435
bk_string_length                000116 automatic       fixed bin(35,0)          dcl 2-39 set ref 209* 248*
branch_ci_header                       based           structure                level 1 unaligned dcl 3-48
branch_ci_header_ptr            000126 automatic       pointer                  dcl 3-53 set ref 203* 205 211 246* 250 257 258* 266*
branch_id                              based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 2-32 ref 217
                                                                                  257
branch_key                             based           structure                level 1 packed unaligned dcl 2-32
branch_key_ptr                  000120 automatic       pointer                  dcl 2-40 set ref 212* 217 251* 257
collection_id             2            based           bit(36)                  level 2 dcl 1-29 set ref 212* 251* 266* 335* 410*
                                                                                  413* 437* 455*
collection_manager_$get         000032 constant        entry                    external dcl 5-71 ref 413
collection_manager_$get_control_interval_ptr
                                000034 constant        entry                    external dcl 5-74 ref 455
collection_manager_$get_portion_from_ci_buffer
                                000036 constant        entry                    external dcl 5-93 ref 212 251
collection_manager_$modify      000040 constant        entry                    external dcl 5-101 ref 437
collection_manager_$simple_get_by_ci_ptr
                                000042 constant        entry                    external dcl 5-132 ref 410
common                                 based           structure                level 2 in structure "leaf_ci_header" unaligned
                                                                                  dcl 3-43 in procedure "im_general_delete"
common                                 based           structure                level 2 in structure "branch_ci_header" unaligned
                                                                                  dcl 3-48 in procedure "im_general_delete"
common_ci_header                       based           structure                level 1 unaligned dcl 3-26
common_ci_header_ptr            000122 automatic       pointer                  dcl 3-41 set ref 153* 155 158 170* 175 175 194 194
                                                                                  194 194 203 219* 229* 230* 232 234* 241* 243 246
                                                                                  274 276* 283 283
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "element_id" packed unsigned
                                                                                  unaligned dcl 4-32 in procedure
                                                                                  "im_general_delete" set ref 170 183 210* 210 219
                                                                                  249* 249 266* 276 286
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "me_element_id" packed unsigned
                                                                                  unaligned dcl 431 in procedure "MODIFY_ELEMENT"
                                                                                  set ref 434*
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "ge_element_id" packed unsigned
                                                                                  unaligned dcl 394 in procedure "GET_ELEMENT" set
                                                                                  ref 406*
cv_p_expected_version                  parameter       fixed bin(35,0)          dcl 318 set ref 315 321 321*
cv_p_received_version                  parameter       fixed bin(35,0)          dcl 317 set ref 315 321 321*
cv_p_structure_name                    parameter       char                     unaligned dcl 319 set ref 315 321*
deleted_node                    000112 automatic       bit(1)                   initial dcl 99 set ref 99* 187* 292*
dm_error_$wrong_cursor_type     000026 external static fixed bin(35,0)          dcl 135 set ref 146*
element_id                             based           structure                level 1 dcl 4-32
element_id_string               000130 automatic       bit(36)                  dcl 4-30 set ref 210 211 212* 249 250 251* 258* 266
er_p_code                              parameter       fixed bin(35,0)          dcl 308 ref 306 310
error_table_$unimplemented_version
                                000030 external static fixed bin(35,0)          dcl 135 set ref 321*
file_opening_id           1            based           bit(36)                  level 2 dcl 1-29 set ref 212* 251* 266* 335* 413*
                                                                                  437* 455*
first                     1            based           fixed bin(18,0)          level 4 in structure "branch_ci_header" packed
                                                                                  unsigned unaligned dcl 3-48 in procedure
                                                                                  "im_general_delete" ref 211 250
first                     1            based           fixed bin(18,0)          level 3 in structure "common_ci_header" packed
                                                                                  unsigned unaligned dcl 3-26 in procedure
                                                                                  "im_general_delete" set ref 175* 194 194 243 283*
first                     1            based           fixed bin(18,0)          level 4 in structure "leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 3-43 in procedure
                                                                                  "im_general_delete" ref 159
flags                                  based           structure                level 2 packed unaligned dcl 3-26
gch_by_node_ptr                 000210 automatic       bit(1)                   dcl 351 set ref 353* 358* 359
gch_p_ci_header_ptr                    parameter       pointer                  dcl 349 set ref 345 356 359* 363*
gch_p_control_interval_id              parameter       fixed bin(24,0)          unsigned dcl 347 set ref 345 356 359* 363*
gch_p_node_ptr                         parameter       pointer                  dcl 350 set ref 356 359*
ge_by_node_ptr                  000234 automatic       bit(1)                   dcl 396 set ref 398* 405* 410
ge_code                         000232 automatic       fixed bin(35,0)          initial dcl 392 set ref 392* 410* 413* 415 415*
ge_element_id                          based           structure                level 1 dcl 394
ge_element_id_string            000233 automatic       bit(36)                  dcl 395 set ref 406 408 410* 413*
ge_p_buffer_length                     parameter       fixed bin(35,0)          dcl 388 set ref 381 401 410* 413*
ge_p_buffer_ptr                        parameter       pointer                  dcl 387 set ref 381 401 410* 413*
ge_p_control_interval_id               parameter       fixed bin(24,0)          unsigned dcl 384 ref 381 401 406
ge_p_element_length                    parameter       fixed bin(35,0)          dcl 389 set ref 381 401 410* 413*
ge_p_node_ptr                          parameter       pointer                  dcl 390 set ref 401 410*
ge_p_slot_index                        parameter       fixed bin(12,0)          unsigned dcl 386 ref 381 401 408
gpn_code                        000266 automatic       fixed bin(35,0)          initial dcl 451 set ref 451* 455* 457 457*
gpn_p_node_id                          parameter       fixed bin(24,0)          unsigned dcl 447 ref 444 453
gpn_p_parent_node_id                   parameter       fixed bin(24,0)          unsigned dcl 447 set ref 444 453* 455*
gpn_p_parent_node_ptr                  parameter       pointer                  dcl 449 set ref 444 455*
im_delete_node                  000016 constant        entry                    external dcl 126 ref 170 219 276
im_general_delete               000020 constant        entry                    external dcl 127 ref 187 292
im_get_opening_info             000010 constant        entry                    external dcl 122 ref 335
im_simple_delete                000014 constant        entry                    external dcl 125 ref 162 241 258
im_update_branches$single       000022 constant        entry                    external dcl 128 ref 266
im_update_opening_info$root_id  000012 constant        entry                    external dcl 123 ref 340
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "me_element_id" packed unsigned
                                                                                  unaligned dcl 431 in procedure "MODIFY_ELEMENT"
                                                                                  set ref 435*
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "element_id" packed unsigned
                                                                                  unaligned dcl 4-32 in procedure
                                                                                  "im_general_delete" set ref 205 211* 241 250*
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "ge_element_id" packed unsigned
                                                                                  unaligned dcl 394 in procedure "GET_ELEMENT" set
                                                                                  ref 408*
index_cursor                           based           structure                level 1 unaligned dcl 1-29
index_cursor_ptr                000114 automatic       pointer                  dcl 1-64 set ref 145* 146 146 151 162* 170* 187* 212
                                                                                  212 219* 241* 251 251 258* 266 266 276* 292* 335
                                                                                  335 410 413 413 437 437 455 455
is_leaf                                based           bit(1)                   level 3 packed unaligned dcl 3-26 ref 155
key_range                 1            based           structure                level 3 in structure "leaf_ci_header" packed
                                                                                  unaligned dcl 3-43 in procedure
                                                                                  "im_general_delete"
key_range                 1            based           structure                level 3 in structure "branch_ci_header" packed
                                                                                  unaligned dcl 3-48 in procedure
                                                                                  "im_general_delete"
key_range                 1            based           structure                level 2 in structure "common_ci_header" packed
                                                                                  unaligned dcl 3-26 in procedure
                                                                                  "im_general_delete"
last                      1(18)        based           fixed bin(18,0)          level 3 in structure "common_ci_header" packed
                                                                                  unsigned unaligned dcl 3-26 in procedure
                                                                                  "im_general_delete" set ref 175* 194 283*
last                      1(18)        based           fixed bin(18,0)          level 4 in structure "leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 3-43 in procedure
                                                                                  "im_general_delete" ref 159
leaf_ci_header                         based           structure                level 1 unaligned dcl 3-43
leaf_ci_header_ptr              000124 automatic       pointer                  dcl 3-46 set ref 158* 159 159 162* 168
length                                                 builtin function         dcl 108 ref 212 212 251 251
local_ci_header_buffer          000100 automatic       bit                      dcl 92 set ref 182 229 289
local_key_buffer                000113 automatic       bit                      dcl 101 set ref 212 212 212 212 251 251 251 251
low_branch_id             5            based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 3-48 set ref
                                                                                  205 257*
me_code                         000256 automatic       fixed bin(35,0)          initial dcl 429 set ref 429* 437* 439 439*
me_element_id                          based           structure                level 1 dcl 431
me_element_id_string            000257 automatic       bit(36)                  dcl 432 set ref 434 435 437*
me_p_control_interval_id               parameter       fixed bin(24,0)          unsigned dcl 422 ref 420 434
me_p_element_length                    parameter       fixed bin(35,0)          dcl 425 set ref 420 437*
me_p_element_ptr                       parameter       pointer                  dcl 426 set ref 420 437*
me_p_slot_index                        parameter       fixed bin(12,0)          unsigned dcl 424 ref 420 435
myname                          000000 constant        char(17)                 initial unaligned dcl 118 set ref 146* 321*
new_buffer_was_allocated        000111 automatic       bit(1)                   initial dcl 99 set ref 99* 212* 251*
new_root_id                     000107 automatic       fixed bin(24,0)          initial unsigned dcl 96 set ref 96* 205* 217* 230
                                                                                  234 239*
node_ptr                        000100 automatic       pointer                  initial dcl 94 set ref 94* 144* 162* 212* 241* 251*
                                                                                  258* 266*
null                                                   builtin function         dcl 108 ref 94 94 94 146 146 212 212 251 251 321 321
                                                                                  332 413 413 413 413
p_code                                 parameter       fixed bin(35,0)          dcl 88 set ref 76 142* 162* 163 163* 170* 172 172*
                                                                                  187* 189 189* 212* 215 215* 219* 221 221* 241*
                                                                                  251* 254 254* 258* 259 259* 266* 268 268* 276* 278
                                                                                  278* 292* 294 294* 310*
p_common_ci_header_ptr                 parameter       pointer                  dcl 85 ref 76 153
p_deleted_node                         parameter       bit(1)                   dcl 87 set ref 76 143* 176* 224* 281*
p_index_cursor_ptr                     parameter       pointer                  dcl 84 ref 76 145
p_key_id_string                        parameter       bit(36)                  dcl 86 set ref 76 162* 170 205 210 219 241 241* 249
                                                                                  276
p_node_ptr                             parameter       pointer                  dcl 83 ref 76 144
parent_branch_ci_header_ptr     000104 automatic       pointer                  initial dcl 94 set ref 94* 182* 185* 187* 289* 290*
                                                                                  292*
parent_id_string          2            based           bit(36)                  level 2 in structure "common_ci_header" dcl 3-26
                                                                                  in procedure "im_general_delete" set ref 194 232*
                                                                                  274
parent_id_string          2            based           bit(36)                  level 3 in structure "leaf_ci_header" dcl 3-43
                                                                                  in procedure "im_general_delete" ref 168
parent_key_id_string            000110 automatic       bit(36)                  dcl 98 set ref 168* 177 183 187* 274* 286 292*
parent_node_id                  000106 automatic       fixed bin(24,0)          initial unsigned dcl 96 set ref 96* 183* 185* 286*
                                                                                  290*
parent_node_ptr                 000102 automatic       pointer                  initial dcl 94 set ref 94* 183* 185* 187* 286* 290*
                                                                                  292*
pch_p_ci_header_ptr                    parameter       pointer                  dcl 374 set ref 370 377*
pch_p_control_interval_id              parameter       fixed bin(24,0)          unsigned dcl 372 set ref 370 377*
sub_err_                        000024 constant        entry                    external dcl 131 ref 146 321
type                                   based           fixed bin(17,0)          level 2 packed unaligned dcl 1-29 set ref 146 146*
uri_code                        000176 automatic       fixed bin(35,0)          initial dcl 331 set ref 331* 335* 337 337* 340* 341
                                                                                  341*
uri_index_opening_info_ptr      000200 automatic       pointer                  initial dcl 332 set ref 332* 335* 340*
uri_p_root_id                          parameter       fixed bin(24,0)          unsigned dcl 330 set ref 328 340*
version                   0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 1-29 ref 151

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 7-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 7-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 7-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 7-7
CI_0_ADDRESSABLE_LENGTH                internal static fixed bin(17,0)          initial dcl 6-31
CI_ADDRESSABLE_LENGTH                  internal static fixed bin(17,0)          initial dcl 6-29
CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
                                       internal static fixed bin(17,0)          initial dcl 6-25
DEFAULT_AREA_PTR                       internal static pointer                  initial dcl 112
DEFAULT_INITIAL_KEY_SLOT               internal static fixed bin(17,0)          initial dcl 3-56
collection_manager_$allocate_control_interval
                                000000 constant        entry                    external dcl 5-50
collection_manager_$compact_control_interval
                                000000 constant        entry                    external dcl 5-52
collection_manager_$create_collection
                                000000 constant        entry                    external dcl 5-54
collection_manager_$create_file 000000 constant        entry                    external dcl 5-56
collection_manager_$delete      000000 constant        entry                    external dcl 5-64
collection_manager_$delete_from_ci_buffer
                                000000 constant        entry                    external dcl 5-67
collection_manager_$destroy_collection
                                000000 constant        entry                    external dcl 5-58
collection_manager_$free_control_interval
                                000000 constant        entry                    external dcl 5-60
collection_manager_$get_by_ci_ptr
                                000000 constant        entry                    external dcl 5-80
collection_manager_$get_from_ci_buffer
                                000000 constant        entry                    external dcl 5-77
collection_manager_$get_header  000000 constant        entry                    external dcl 5-83
collection_manager_$get_id      000000 constant        entry                    external dcl 5-86
collection_manager_$get_portion 000000 constant        entry                    external dcl 5-89
collection_manager_$get_portion_by_ci_ptr
                                000000 constant        entry                    external dcl 5-97
collection_manager_$modify_in_ci_buffer
                                000000 constant        entry                    external dcl 5-107
collection_manager_$modify_portion
                                000000 constant        entry                    external dcl 5-110
collection_manager_$modify_unprotected
                                000000 constant        entry                    external dcl 5-104
collection_manager_$postcommit_increments
                                000000 constant        entry                    external dcl 5-113
collection_manager_$put         000000 constant        entry                    external dcl 5-115
collection_manager_$put_header  000000 constant        entry                    external dcl 5-121
collection_manager_$put_in_ci_buffer
                                000000 constant        entry                    external dcl 5-118
collection_manager_$put_unprotected_header
                                000000 constant        entry                    external dcl 5-123
collection_manager_$replace_ci_buffer
                                000000 constant        entry                    external dcl 5-126
collection_manager_$setup_ci_buffer
                                000000 constant        entry                    external dcl 5-129
collection_manager_$simple_get_from_ci_buffer
                                000000 constant        entry                    external dcl 5-135
key_string                             based           bit                      unaligned dcl 2-22
key_string_length                      automatic       fixed bin(35,0)          dcl 2-23
key_string_ptr                         automatic       pointer                  dcl 2-24
leaf_key                               based           structure                level 1 packed unaligned dcl 2-26
leaf_key_ptr                           automatic       pointer                  dcl 2-30
lk_string_length                       automatic       fixed bin(35,0)          dcl 2-29
local_node_buffer                      automatic       bit                      dcl 102
me_p_node_ptr                          automatic       pointer                  dcl 427
pch_p_node_ptr                         automatic       pointer                  dcl 375

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   001217 constant        entry                    internal dcl 315 ref 151
ERROR_RETURN                    001207 constant        entry                    internal dcl 306 ref 163 172 189 215 221 254 259 268
                                                                                  278 294 337 341 415 439 457
FINISH                          001205 constant        entry                    internal dcl 302 ref 309
GCH_JOIN                        001405 constant        label                    dcl 359 ref 354
GET_CI_HEADER                   001365 constant        entry                    internal dcl 345 ref 230
GET_CI_HEADER_PTR               001375 constant        entry                    internal dcl 356 ref 185 290
GET_ELEMENT                     001516 constant        entry                    internal dcl 381 ref 363
GET_ELEMENT_PTR                 001535 constant        entry                    internal dcl 401 ref 359
GET_PARENT_NODE                 001723 constant        entry                    internal dcl 444 ref 183 286
GE_JOIN                         001554 constant        label                    dcl 406 ref 399
MAIN_RETURN                     001204 constant        label                    dcl 299 ref 311
MODIFY_ELEMENT                  001660 constant        entry                    internal dcl 420 ref 377
PUT_CI_HEADER                   001470 constant        entry                    internal dcl 370 ref 234
UPDATE_ROOT_ID                  001315 constant        entry                    internal dcl 328 ref 177 239
im_general_delete               000112 constant        entry                    external dcl 76

NAME DECLARED BY CONTEXT OR IMPLICATION.
max                                                    builtin function         ref 92 359 359 363 363

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2300        2344    2062        2310
Length      2706    2062        44         326     216           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
im_general_delete                   430 external procedure  is an external procedure.  
FINISH                                  internal procedure  shares stack frame of external procedure im_general_delete.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure im_general_delete.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure im_general_delete.  
UPDATE_ROOT_ID                          internal procedure  shares stack frame of external procedure im_general_delete.  
GET_CI_HEADER                           internal procedure  shares stack frame of external procedure im_general_delete.  
PUT_CI_HEADER                           internal procedure  shares stack frame of external procedure im_general_delete.  
GET_ELEMENT                             internal procedure  shares stack frame of external procedure im_general_delete.  
MODIFY_ELEMENT                          internal procedure  shares stack frame of external procedure im_general_delete.  
GET_PARENT_NODE                         internal procedure  shares stack frame of external procedure im_general_delete.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
im_general_delete        000100 local_ci_header_buffer      im_general_delete
                         000100 node_ptr                    im_general_delete
                         000102 parent_node_ptr             im_general_delete
                         000104 parent_branch_ci_header_ptr im_general_delete
                         000106 parent_node_id              im_general_delete
                         000107 new_root_id                 im_general_delete
                         000110 parent_key_id_string        im_general_delete
                         000111 new_buffer_was_allocated    im_general_delete
                         000112 deleted_node                im_general_delete
                         000113 local_key_buffer            im_general_delete
                         000114 index_cursor_ptr            im_general_delete
                         000116 bk_string_length            im_general_delete
                         000120 branch_key_ptr              im_general_delete
                         000122 common_ci_header_ptr        im_general_delete
                         000124 leaf_ci_header_ptr          im_general_delete
                         000126 branch_ci_header_ptr        im_general_delete
                         000130 element_id_string           im_general_delete
                         000176 uri_code                    UPDATE_ROOT_ID
                         000200 uri_index_opening_info_ptr  UPDATE_ROOT_ID
                         000210 gch_by_node_ptr             GET_CI_HEADER
                         000232 ge_code                     GET_ELEMENT
                         000233 ge_element_id_string        GET_ELEMENT
                         000234 ge_by_node_ptr              GET_ELEMENT
                         000256 me_code                     MODIFY_ELEMENT
                         000257 me_element_id_string        MODIFY_ELEMENT
                         000266 gpn_code                    GET_PARENT_NODE

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              alloc_auto_adj      ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
collection_manager_$get       collection_manager_$get_control_interval_ptr
collection_manager_$get_portion_from_ci_buffer              collection_manager_$modify
collection_manager_$simple_get_by_ci_ptr                    im_delete_node                im_general_delete
im_get_opening_info           im_simple_delete              im_update_branches$single
im_update_opening_info$root_id                              sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$wrong_cursor_type   error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     76 000104        92 000117        94 000131        96 000135        99 000137       101 000141       102 000150
    142 000160       143 000162       144 000163       145 000166       146 000171       151 000247       153 000264
    155 000270       158 000273       159 000274       162 000304       163 000323       165 000334       168 000335
    170 000337       172 000357       175 000370       176 000375       177 000400       182 000406       183 000410
    185 000415       187 000417       189 000441       193 000452       194 000453       203 000466       205 000467
    209 000501       210 000502       211 000504       212 000510       215 000561       217 000572       219 000601
    221 000622       224 000633       229 000636       230 000640       232 000644       234 000646       239 000652
    240 000654       241 000655       243 000702       246 000704       248 000705       249 000706       250 000710
    251 000714       254 000765       257 000776       258 001003       259 001023       266 001034       268 001063
    271 001074       274 001075       276 001077       278 001117       281 001130       283 001133       286 001140
    289 001145       290 001147       292 001151       294 001173       299 001204       302 001205       304 001206
    306 001207       309 001211       310 001212       311 001216       315 001217       321 001230       326 001314
    328 001315       331 001317       332 001320       335 001322       337 001340       340 001344       341 001360
    343 001364       345 001365       353 001373       354 001374       356 001375       358 001403       359 001405
    363 001441       365 001467       370 001470       377 001472       379 001511       392 001513       381 001516
    398 001533       399 001534       401 001535       405 001552       406 001554       408 001557       410 001561
    413 001611       415 001653       418 001657       420 001660       429 001662       434 001663       435 001666
    437 001670       439 001716       442 001722       444 001723       451 001725       453 001726       455 001730
    457 001751       460 001755


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
