	COMPILATION LISTING OF SEGMENT area_status
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 09/04/86  1306.2 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 /* format: style2,indcomtxt */
       11 
       12 area_status: proc;
       13 
       14 /* 81-09-12.  E. N. Kittlitz. call cv_ptr_$terminate on the segment cv_ptr_ originally got for us. */
       15 
       16 
       17 /****^  HISTORY COMMENTS:
       18*  1) change(86-06-18,Kissel), approve(86-07-31,MCR7465), audit(86-08-01,Wong),
       19*     install(86-09-04,MR12.0-1134):
       20*     Added the get_block_data_info entry so that callers can walk through an
       21*     area and look at each block.
       22*                                                   END HISTORY COMMENTS */
       23 
       24 
       25 /* Parameters */
       26 
       27 dcl  a_area_infop ptr;
       28 dcl  a_code fixed bin (35);
       29 
       30 dcl  P_code fixed bin (35) parameter;
       31 dcl  P_block_allocated_flag bit (1) parameter;
       32 dcl  P_data_size fixed bin (18) parameter;
       33 dcl  P_next_data_ptr ptr parameter;
       34 dcl  P_output_area_ptr ptr parameter;
       35 dcl  P_block_data_ptr ptr parameter;
       36 dcl  P_next_ptr_flag bit (1) parameter;
       37 dcl  P_area_ptr ptr parameter;
       38 
       39 /* Static */
       40 
       41 dcl  my_name char (12) static init ("area_status") options (constant);
       42 
       43 /* Automatic */
       44 
       45 dcl  area_copy_size fixed bin (18);
       46 dcl  given_areap ptr;				/* pointer returned by cv_ptr_ based on command args */
       47 dcl  have_name bit (1);
       48 dcl  n_components fixed bin;
       49 dcl  next_areap ptr;
       50 dcl  ptrs (1) ptr;
       51 dcl  steps fixed bin;
       52 dcl  not_subr bit (1);
       53 dcl  first bit (1);
       54 dcl  free_count1 fixed bin;
       55 dcl  total_free1 fixed bin;
       56 dcl  total_virgin fixed bin;
       57 dcl  used_count1 fixed bin;
       58 dcl  total_used1 fixed bin;
       59 dcl  nextp ptr;
       60 dcl  offset fixed bin;
       61 dcl  total_free fixed bin;
       62 dcl  free_count fixed bin;
       63 dcl  code fixed bin (35);
       64 dcl  bp ptr;
       65 dcl  trace bit (1);
       66 dcl  long bit (1);
       67 dcl  sb_n_allocated fixed bin;
       68 dcl  sb_n_free fixed bin;
       69 dcl  tp ptr;
       70 dcl  tc fixed bin;
       71 dcl  i fixed bin;
       72 
       73 /* Builtins */
       74 
       75 dcl (addrel, bin, hbound, lbound, max, null, ptr, rel, size, string) builtin;
       76 
       77 /* Conditions */
       78 
       79 dcl  cleanup condition;
       80 
       81 /* External */
       82 
       83 dcl ((error_table_$bad_segment,
       84       error_table_$bad_arg,
       85       error_table_$bad_conversion,
       86       error_table_$badopt,
       87       error_table_$end_of_info,
       88       error_table_$unimplemented_version,
       89       error_table_$wrong_no_of_args) fixed bin (35),
       90      sys_info$max_seg_size fixed bin (18),
       91      iox_$user_output ptr
       92      ) external static;
       93 
       94 /* Entries */
       95 
       96 dcl  cu_$arg_count entry returns (fixed bin);
       97 dcl  get_temp_segments_ entry (char (*), (*) ptr, fixed bin (35));
       98 dcl  release_temp_segments_ entry (char (*), (*) ptr, fixed bin (35));
       99 dcl  dump_seg_ entry (ptr, ptr, fixed bin, fixed bin, bit (6) aligned);
      100 dcl  com_err_ entry options (variable);
      101 dcl  cv_oct_check_ entry (char (*), fixed bin (35), fixed bin);
      102 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
      103 dcl  ioa_ entry options (variable);
      104 dcl  cv_ptr_ entry (char (*), fixed bin (35)) returns (ptr);
      105 dcl  cv_ptr_$terminate entry (ptr);
      106 
      107 /* Based */
      108 
      109 dcl  targ char (tc) based (tp);
      110 dcl  copy_area (area_copy_size) fixed bin based (ptrs (1));
      111 
      112 
      113 /*  */
      114 
      115 	tc = 0;
      116 	not_subr = "1"b;
      117 	have_name = "0"b;
      118 	offset = 0;
      119 	areap = null;
      120 	given_areap = null;
      121           on cleanup call clean_up_seg;
      122 	trace = "0"b;
      123 	long = "0"b;
      124 	do i = 1 to cu_$arg_count ();
      125 	     call cu_$arg_ptr (i, tp, tc, code);
      126 	     if targ = "-trace" then trace = "1"b;
      127 	     else if targ = "-long" | targ = "-lg" then trace, long = "1"b;
      128 	     else if targ = "-offset" | targ = "-ofs" then do     /* obsolete control arg */
      129 		i = i + 1;
      130 		call cu_$arg_ptr (i, tp, tc, code);
      131 		if code ^= 0 then do;
      132 		     call com_err_ (code, my_name, "Offset not supplied.");
      133 		     call clean_up_seg;
      134 		     return;
      135 		end;
      136 		call cv_oct_check_ (targ, code, offset);
      137 		if code ^= 0 then do;
      138 		     code = error_table_$bad_conversion;
      139 		     goto err;
      140 		end;
      141 	     end;
      142 	     else if ^have_name then do;
      143                     given_areap = cv_ptr_ (targ, code);
      144 		if code ^= 0 then goto err;
      145 		areap = given_areap;		/* make working copy */
      146 		have_name = "1"b;
      147 	     end;
      148 	     else do;
      149 		call com_err_ (error_table_$badopt, my_name, "^a", targ);
      150 		call clean_up_seg;
      151 		return;
      152 	     end;
      153 	end;
      154 
      155 	if areap = null then do;
      156 	     call com_err_ (error_table_$wrong_no_of_args, my_name, "Usage: area_status virtual_ptr {-control_args}
      157                     control args: -trace, -long (-lg)");
      158 	     return;
      159 	end;
      160 
      161 	if offset ^= 0 then areap = addrel (areap, offset);
      162 
      163 	if area_header.version ^= area_version_1 then do;
      164 	     call com_err_ (error_table_$unimplemented_version, my_name, "^/while referencing the area at ^p.",areap);
      165 	     call clean_up_seg;
      166 	     return;
      167 	end;
      168 
      169 	if area_header.extend then areap = addrel (areap, area_header.extend_info) -> extend_block.first_area;
      170 
      171 /* Now get stats for the area */
      172 
      173 
      174 	if get_statistics () then do;
      175 	     call ioa_ ("Area format error.");
      176 	     call clean_up_seg;
      177 	     return;
      178 	end;
      179 
      180 	if sb_n_allocated ^= used_count1 then if long then
      181 		call ioa_ ("Area header does not agree: blocks allocated is ^d; should be ^d", area_header.n_allocated, used_count1);
      182 	if sb_n_free ^= free_count1 then if long then
      183 		call ioa_ ("Area header does not agree: blocks free is ^d; should be ^d", area_header.n_free, free_count1);
      184 	if total_free1 ^= total_free | free_count1 ^= free_count then do;
      185 	     call ioa_ ("Free list has ^d words in ^d blocks", total_free, free_count);
      186 	     call ioa_ ("Scan of area found ^d words in ^d free blocks", total_free1, free_count1);
      187 	end;
      188 
      189 
      190 	call ioa_ ("^/^16xBusy^6xFree^/");
      191 	call ioa_ ("Blocks^4x^10d^10d", used_count1, free_count1);
      192 	call ioa_ ("Words^5x^10d^10d", total_used1, total_free1);
      193 	call ioa_ ("^d words of virgin storage", total_virgin);
      194 	if string (area_header.flags) then do;		/* some control bits are ON */
      195 	     if area_header.flags.extend then
      196 		call ioa_ ("in ^d components.", n_components);
      197 	     if area_header.flags.zero_on_alloc then call ioa_ ("Zero on allocation in effect.");
      198 	     if area_header.flags.zero_on_free then call ioa_ ("Zero on free in effect.");
      199 	     if area_header.flags.dont_free then call ioa_ ("Freeing disabled.");
      200 	     if area_header.allocation_method = 1 then
      201 		call ioa_ ("Blocks are packed -- no freeing allowed.");
      202 	     call ioa_ (" ");
      203 	end;
      204 	call clean_up_seg;
      205 	return;
      206 
      207 /*  */
      208 
      209 get_statistics: proc returns (bit (1) aligned);
      210 
      211 dcl  save_areap ptr;
      212 dcl print_areap ptr;
      213 
      214 /* This subroutine scans an area and accumulates statistics about the area.
      215*   It makes a copy of the area in a temporary segment since it marks blocks for cross checking.
      216**/
      217 
      218 	     save_areap = areap;
      219 	     sb_n_allocated = 0;
      220 	     sb_n_free = 0;
      221 	     total_virgin = 0;
      222 	     free_count = 0;
      223 	     total_free = 0;
      224 	     total_free1 = 0;
      225 	     free_count1 = 0;
      226 	     total_used1 = 0;
      227 	     used_count1 = 0;
      228 	     steps = 0;
      229 	     n_components = 0;
      230 
      231 	     on cleanup call release_temp_segments_ ("area_status", ptrs, code);
      232 	     call get_temp_segments_ ("area_status", ptrs, code);
      233 
      234 	     next_areap = areap;
      235 	     do areap = areap repeat next_areap while (next_areap ^= null);
      236 		n_components = n_components + 1;
      237 		if area_header.extend then next_areap = addrel (areap, area_header.extend_info) -> extend_block.next_area;
      238 		else next_areap = null;
      239 
      240                     if area_header.allocation_method = NO_FREEING_ALLOCATION_METHOD then go to end_loop;
      241 		total_virgin = total_virgin + bin (area_header.last_usable, 18) - bin (area_header.next_virgin, 18);
      242 		sb_n_allocated = sb_n_allocated + area_header.n_allocated;
      243 		sb_n_free = sb_n_free + area_header.n_free;
      244 
      245 /* First scan the free list */
      246 
      247 		area_copy_size = max (bin (area_header.next_virgin, 18), bin (area_header.last_block, 18));
      248 		if area_copy_size + bin (rel (areap), 18) > sys_info$max_seg_size then
      249 		     area_copy_size = sys_info$max_seg_size - bin (rel (areap), 18);
      250 		copy_area = areap -> copy_area;
      251                     print_areap = areap;
      252 		areap = ptrs (1);
      253 		do i = lbound (areap -> area_header.freep, 1) to hbound (areap -> area_header.freep, 1);
      254 		     bp = addrel (areap, areap -> area_header.freep (i).relp); /* get ptr to first thing on free list */
      255 		     if bp ^= areap then do;
      256 			first = "1"b;
      257 			do blockp = bp repeat addrel (areap, block.fp) while (blockp ^= bp | first);
      258 			     first = "0"b;
      259 			     block.marked = "1"b;
      260 			     total_free = total_free + bin (block.cur_size, 18);
      261 			     free_count = free_count + 1;
      262 			     if block.prev_busy = "0"b & not_subr then
      263 				call ioa_ ("BLOCK AT ^p HAS PREVIOUS FREE", ptr(print_areap, rel(blockp)));
      264 			     if trace & not_subr then call ioa_ ("FREE SIZE ^4o AT ^p", bin (block.cur_size, 18)-2, ptr(print_areap, rel(blockp)));
      265 			     steps = steps + 1;
      266 			     if steps > 50000
      267 			     then do;
      268 				areap = save_areap;
      269 				return ("1"b);
      270 			     end;
      271 			end;
      272 		     end;
      273 		end;
      274 
      275 /* Now scan all blocks in the area */
      276 
      277 
      278 		steps = 0;
      279 
      280 		do blockp = addrel (areap, size (area_header)) repeat addrel (blockp, block.cur_size)
      281 			while (bin (rel (blockp), 18) - bin (rel (areap), 18) < bin (areap -> area_header.next_virgin, 18));
      282 
      283 		     if bin (rel (blockp), 18) = bin (rel (areap), 18) + bin (areap -> area_header.last_block, 18) then do;
      284 is_busy:
      285 			if trace & not_subr then
      286 			     call ioa_ ("BUSY ^6o AT ^p", bin (block.cur_size, 18)-2, ptr(print_areap, rel(blockp)));
      287 			used_count1 = used_count1 + 1;
      288 			total_used1 = total_used1 + bin (block.cur_size, 18);
      289 			if block.marked & not_subr then /* found on free list in first pass */
      290 			     call ioa_ ("BLOCK AT ^p NOT FREE", ptr(print_areap, rel(blockp)));
      291 			if long & not_subr then
      292 			     call dump_seg_ (iox_$user_output, addrel (blockp, 2), bin (rel (blockp), 18)+2,
      293 			     bin (block.cur_size, 18)-2, "110010"b);
      294 		     end;
      295 		     else do;
      296 			nextp = addrel (blockp, block.cur_size);
      297 			if nextp->block.prev_busy
      298 			then go to is_busy;
      299 			if trace & not_subr then
      300 			     call ioa_ ("     ^6o AT ^p", bin (block.cur_size, 18), ptr(print_areap, rel(blockp)));
      301 			free_count1 = free_count1 + 1;
      302 			total_free1 = total_free1 + bin (block.cur_size, 18);
      303 			if block.marked = "0"b & not_subr then /* not on free list */
      304 			     call ioa_ ("FREE BLOCK AT ^p NOT ON FREE LIST", ptr(print_areap, rel(blockp)));
      305 		     end;
      306 		     steps = steps + 1;
      307 		     if steps > 50000
      308 		     then do;
      309 			areap = save_areap;
      310 			return ("1"b);
      311 		     end;
      312 		end;
      313 
      314 
      315 end_loop:
      316 	     end;
      317 
      318 	     call release_temp_segments_ ("area_status", ptrs, code);
      319 	     areap = save_areap;
      320 	     return ("0"b);
      321 
      322 	end get_statistics;
      323 
      324 /*  */
      325 
      326 area_info_: entry (a_area_infop, a_code);
      327 
      328 	area_infop = a_area_infop;
      329 	if area_info.version ^= area_info_version_1 then do;
      330 	     a_code = error_table_$unimplemented_version;
      331 	     area_info.version_of_area = area_header.version;
      332 	     return;
      333 	end;
      334 
      335 	areap = area_info.areap;
      336 
      337 	not_subr = "0"b;
      338 
      339 	if get_statistics () then do;
      340 	     a_code = error_table_$bad_segment;
      341 	     return;
      342 	end;
      343 
      344 
      345 	string (area_info.control) = "0"b;
      346 	area_info.zero_on_alloc = area_header.zero_on_alloc;
      347 	area_info.zero_on_free = area_header.zero_on_free;
      348 	area_info.dont_free = area_header.dont_free;
      349 	area_info.system = area_header.system;
      350 	if area_header.allocation_method = 1 then area_info.no_freeing = "1"b;
      351 	if area_header.extend | area_header.defined_by_call then do;
      352 	     area_info.extend = area_header.extend;
      353 	     extend_blockp = addrel (areap, area_header.extend_info);
      354 	     area_info.owner = extend_block.name;
      355 	     area_info.n_components = n_components;
      356 	end;
      357           else do;
      358                area_info.owner = "";
      359                area_info.n_components = 1;
      360           end;
      361 	area_info.size = bin (area_header.last_usable, 18);
      362 	area_info.version_of_area = area_header.version;
      363 	area_info.allocated_blocks = used_count1;
      364 	area_info.free_blocks = free_count1;
      365 	area_info.allocated_words = total_used1;
      366 	area_info.free_words = total_free1;
      367 
      368 	a_code = 0;
      369 	return;
      370 
      371 /*****************************************************************************/
      372 /*							       */
      373 /*   ENTRY:  get_block_data_info				       */
      374 /*							       */
      375 /*   This entry takes a pointer to an area, a flag, and a pointer to some    */
      376 /*   data in the area.  If the flag is not set, then the size of the block   */
      377 /*   (in words) of the block holding the specified data is returned, along   */
      378 /*   with a flag indicating whether the block is free or allocated.  If the  */
      379 /*   flag is set, then information about the block after the one pointed to  */
      380 /*   by the input pointer is returned.  A pointer to the area in which the   */
      381 /*   returned data block exists is also returned.  This will be the same as  */
      382 /*   the input area pointer, unless the area is extensible and the next      */
      383 /*   block is in the next area.				       */
      384 /*							       */
      385 /*****************************************************************************/
      386 
      387 get_block_data_info:
      388      entry (P_area_ptr, P_next_ptr_flag, P_block_data_ptr, P_output_area_ptr, P_next_data_ptr, P_data_size,
      389 	P_block_allocated_flag, P_code);
      390 
      391 	areap = P_area_ptr;
      392 
      393 /* Initialize the outputs in case of error. */
      394 
      395 	P_output_area_ptr = areap;
      396 	P_next_data_ptr = null ();
      397 	P_data_size = 0;
      398 	P_block_allocated_flag = "0"b;
      399 	P_code = 0;
      400 
      401 	call Set_get_block_data_info_Args (P_code);
      402 
      403 	/*** We should try the next area in some cases. */
      404 
      405 	if code = error_table_$end_of_info & area_header.flags.extend & P_next_ptr_flag
      406 	     then do;
      407 		areap = addwordno (areap, bin (area_header.extend_info, 18));
      408 		call Set_get_block_data_info_Args (P_code);
      409 		end;
      410 
      411 	return;
      412 
      413 clean_up_seg:
      414      proc;
      415 
      416 	if given_areap ^= null then call cv_ptr_$terminate (given_areap);
      417 
      418      end;
      419 
      420 
      421 err:
      422 	call com_err_ (code, my_name, targ);
      423 	return;
      424 
      425 /*****************************************************************************/
      426 /*							       */
      427 /*   PROCEDURE:  Set_get_block_data_info_Args			       */
      428 /*							       */
      429 /*   This procedure uses all of the global variables and parameters of the   */
      430 /*   get_block_data_info entry, except for the return code.  It sets the     */
      431 /*   output parameters if it can and returns a code.  The code is	       */
      432 /*   error_table_$end_of_info if everything is all right, but the block      */
      433 /*   requested is in virgin storage.  Otherwise, the code indicates some     */
      434 /*   problem with the area.					       */
      435 /*							       */
      436 /*****************************************************************************/
      437 
      438 Set_get_block_data_info_Args:
      439      proc (P_code);
      440 
      441 dcl  P_code		       fixed bin (35) parameter;
      442 
      443 /* Make sure the area pointer is OK. */
      444 
      445 	if areap = null ()
      446 	     then P_code = error_table_$bad_arg;
      447 
      448 /* The area pointer is OK. */
      449 
      450 	     else do;
      451 
      452 		/*** Check the area format. */
      453 
      454 		if area_header.version ^= area_version_1
      455 		     | area_header.allocation_method = NO_FREEING_ALLOCATION_METHOD
      456 		     then code = error_table_$unimplemented_version;
      457 
      458 		     /*** The area is OK, keep going. */
      459 
      460 		     else do;
      461 
      462 			/*** Initialize the block pointer. */
      463 
      464 			if P_block_data_ptr = null ()
      465 			     then blockp = addwordno (areap, size (area_header));
      466 			     else blockp = addwordno (P_block_data_ptr, -alloc_blkhdrsz);
      467 
      468 			if P_next_ptr_flag then blockp = addwordno (blockp, bin (block.cur_size, 18));
      469 
      470 			/*** Skip the extend block if we happened to get it. */
      471 
      472 			if wordno (blockp) + alloc_blkhdrsz = bin (area_header.extend_info, 18)
      473 			     then blockp = addwordno (blockp, bin (block.cur_size, 18));
      474 
      475 			/*** Easy case, everything is in this area. */
      476 
      477 			if wordno (blockp) - wordno (areap) < bin (area_header.next_virgin, 18)
      478 			     then do;
      479 				P_next_data_ptr = addwordno (blockp, alloc_blkhdrsz);
      480 				P_data_size = bin (block.cur_size, 18);
      481 
      482 				if wordno (blockp) = wordno (areap) + bin (area_header.last_block, 18)
      483 				     then P_block_allocated_flag = "1"b;
      484 				     else do;
      485 					if addwordno (blockp, bin (block.cur_size, 18)) -> block.prev_busy
      486 					     then P_block_allocated_flag = "1"b;
      487 					     else P_block_allocated_flag = "0"b;
      488 					end;
      489 				end;
      490 
      491 			     /*** No block here, let our caller know. */
      492 
      493 			     else P_code = error_table_$end_of_info;
      494 
      495 			end;
      496 		end;
      497 
      498 /* Output args are either at their initial values, or we set them above. */
      499 
      500 	return;
      501 
      502      end Set_get_block_data_info_Args;
      503 
  1     1 /* BEGIN INCLUDE FILE area_structures.incl.pl1  10/75 */
  1     2 /* Modified September 1981 by J. Bongiovanni for allocation_p_clock */
  1     3 
  1     4 dcl  area_version_1 fixed bin static init (1);		/* version number for this area format */
  1     5 
  1     6 dcl  areap ptr;
  1     7 
  1     8 dcl 1 area_header aligned based (areap),
  1     9     2 version fixed bin (35),				/* 0 for buddy system, 1 for current areas */
  1    10     2 last_usable bit (18),				/* rel pointer to end of area */
  1    11     2 next_virgin bit (18),				/* rel pointer to next slot in virgin territory */
  1    12     2 flags,
  1    13       3 extend bit (1) unal,				/* says area is extensible */
  1    14       3 zero_on_alloc bit (1) unal,			/* says to zero after allocation */
  1    15       3 zero_on_free bit (1) unal,			/* says to zero after freeing */
  1    16       3 dont_free bit (1) unal,			/* dont honor free request -- debugging tool */
  1    17       3 defined_by_call bit (1) unal,			/* says area seg got via define_area_ call */
  1    18       3 system bit (1) unal,				/* ayss area is managed by the system */
  1    19       3 mbz bit (30) unal,
  1    20     2 allocation_method fixed bin,			/* 0 is standard, 1 is no_freeing method */
  1    21     2 last_size bit (18),				/* size of last allocated block before virgin territory */
  1    22     2 last_block bit (18),				/* rel pointer to last allocated block before virgin territory */
  1    23     2 freep (3:16),					/* free list info */
  1    24       3 relp bit (18) unal,				/* pointer to first block on list */
  1    25       3 max_block_size bit (18) unal,			/* size of largest block on list, if known. else zero */
  1    26     2 allocation_p_clock bit (36) aligned,		/* counter to prevent IPS race */
  1    27     2 extend_info bit (18) unal,			/* offset to extend info block */
  1    28     2 recovery_info bit (18) unal,			/* eventually will hold recovery info relp */
  1    29     2 n_allocated fixed bin (17) unal,			/* number of allocated blocks */
  1    30     2 n_free fixed bin (17) unal;			/* number of free blocks */
  1    31 
  1    32 dcl (STANDARD_ALLOCATION_METHOD init (0),
  1    33      NO_FREEING_ALLOCATION_METHOD init (1)
  1    34      ) fixed bin internal static;
  1    35 
  1    36 dcl  extend_blockp ptr;
  1    37 
  1    38 dcl 1 extend_block aligned based (extend_blockp),		/* contents of extend block for extensible areas */
  1    39     2 first_area ptr unal,				/* pointer to first area */
  1    40     2 next_area ptr unal,				/* pointer to next area in chain */
  1    41     2 sequence_no fixed bin,				/* sequence number for this component */
  1    42     2 name char (32),				/* owner of the area */
  1    43     2 pad fixed;					/* brings it to an even, 12 word allocation */
  1    44 
  1    45 dcl alloc_blkhdrsz static internal init(2);
  1    46 dcl 1 no_free_area_header aligned based(areap),		/* overlay for no_free areas */
  1    47     2 pad(4) ptr,
  1    48     2 current_component ptr;				/* points to component from which we are allocating */
  1    49 
  1    50 dcl  blockp ptr;
  1    51 
  1    52 dcl 1 block aligned based (blockp),			/* declaration for block header */
  1    53     2 prev_size bit (18) unal,			/* size of preceding block */
  1    54     2 cur_size bit (18) unal,				/* size of current block */
  1    55     2 buddy_pad bit (8) unal,				/* non_zero for buddy system area */
  1    56     2 prev_busy bit (1) unal,				/* previous-block-is-used flag */
  1    57     2 marked bit (1) unal,
  1    58     2 q_no bit (8) unal,				/* stratum number when in free list */
  1    59     2 header bit (18) unal,				/* pointer to head of area */
  1    60     2 fp bit (18) unal,				/* forward free list thread */
  1    61     2 bp bit (18) unal;				/* backward free list thread */
  1    62 
  1    63 dcl  min_block_size fixed bin static init (8);		/* minimum allowed block size */
  1    64 
  1    65 /* END INCLUDE FILE area_structures.incl.pl1 */
      504 
  2     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  2     2 
  2     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  2     4 
  2     5 dcl  area_infop ptr;
  2     6 
  2     7 dcl 1 area_info aligned based (area_infop),
  2     8     2 version fixed bin,				/* version number for this structure is 1 */
  2     9     2 control aligned like area_control,		/* control bits for the area */
  2    10     2 owner char (32) unal,				/* creator of the area */
  2    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  2    12     2 size fixed bin (18),				/* size of the area in words */
  2    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  2    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  2    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  2    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  2    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  2    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  2    19 
  2    20 dcl 1 area_control aligned based,
  2    21     2 extend bit (1) unal,				/* says area is extensible */
  2    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  2    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  2    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  2    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  2    26     2 system bit (1) unal,				/* says area is managed by system */
  2    27     2 pad bit (30) unal;
  2    28 
  2    29 /* END INCLUDE FILE area_info.incl.pl1 */
      505 
      506 
      507      end area_status;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    09/04/86  1306.3  area_status.pl1                   >spec>install>1134>area_status.pl1
504          1    09/14/81  1347.6  area_structures.incl.pl1          >ldd>include>area_structures.incl.pl1
505          2    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
NO_FREEING_ALLOCATION_METHOD           constant        fixed bin(17,0)          initial dcl 1-32 ref 240 454
P_area_ptr                             parameter       pointer                  dcl 37 ref 387 391
P_block_allocated_flag                 parameter       bit(1)                   unaligned dcl 31 set ref 387 398* 482* 485* 487*
P_block_data_ptr                       parameter       pointer                  dcl 35 ref 387 464 466
P_code                                 parameter       fixed bin(35,0)          dcl 441 in procedure "Set_get_block_data_info_Args"
                                                                                  set ref 438 445* 493*
P_code                                 parameter       fixed bin(35,0)          dcl 30 in procedure "area_status" set ref 387 399*
                                                                                  401* 408*
P_data_size                            parameter       fixed bin(18,0)          dcl 32 set ref 387 397* 480*
P_next_data_ptr                        parameter       pointer                  dcl 33 set ref 387 396* 479*
P_next_ptr_flag                        parameter       bit(1)                   unaligned dcl 36 ref 387 405 468
P_output_area_ptr                      parameter       pointer                  dcl 34 set ref 387 395*
a_area_infop                           parameter       pointer                  dcl 27 ref 326 328
a_code                                 parameter       fixed bin(35,0)          dcl 28 set ref 326 330* 340* 368*
addrel                                                 builtin function         dcl 75 ref 161 169 237 254 271 280 291 291 296 312
                                                                                  353
alloc_blkhdrsz                         constant        fixed bin(17,0)          initial dcl 1-45 ref 466 472 479
allocated_blocks         20            based           fixed bin(17,0)          level 2 dcl 2-7 set ref 363*
allocated_words          22            based           fixed bin(30,0)          level 2 dcl 2-7 set ref 365*
allocation_method         4            based           fixed bin(17,0)          level 2 dcl 1-8 ref 200 240 350 454
area_control                           based           structure                level 1 dcl 2-20
area_copy_size                  000100 automatic       fixed bin(18,0)          dcl 45 set ref 247* 248 248* 250
area_header                            based           structure                level 1 dcl 1-8 set ref 280 464
area_info                              based           structure                level 1 dcl 2-7
area_info_version_1                    constant        fixed bin(17,0)          initial dcl 2-3 ref 329
area_infop                      000156 automatic       pointer                  dcl 2-5 set ref 328* 329 331 335 345 346 347 348 349
                                                                                  350 352 354 355 358 359 361 362 363 364 365 366
area_version_1                         constant        fixed bin(17,0)          initial dcl 1-4 ref 163 454
areap                    16            based           pointer                  level 2 in structure "area_info" dcl 2-7
                                                                                  in procedure "area_status" ref 335
areap                           000150 automatic       pointer                  dcl 1-6 in procedure "area_status" set ref 119* 145*
                                                                                  155 161* 161 163 164* 169 169* 169 169 180 182 194
                                                                                  195 197 198 199 200 218 234 235* 235* 237 237 237
                                                                                  240 241 241 242 243 247 247 248 248 250 251 252*
                                                                                  253 253 254 254 255 268* 271 280 280 280 280 283
                                                                                  283 309* 319* 331 335* 346 347 348 349 350 351 351
                                                                                  352 353 353 361 362 391* 395 405 407* 407 407 445
                                                                                  454 454 464 464 472 477 477 482 482
bin                                                    builtin function         dcl 75 ref 241 241 247 247 248 248 260 264 280 280
                                                                                  280 283 283 283 284 288 291 291 299 299 302 361
                                                                                  407 468 472 472 477 480 482 485
block                                  based           structure                level 1 dcl 1-52
blockp                          000154 automatic       pointer                  dcl 1-50 set ref 257* 257* 259 260 262 262 262 264
                                                                                  264 264* 271 280* 280* 283 284 284 284 288 289 289
                                                                                  289 291 291 291 291 296 296 299 299 299 299 302
                                                                                  303 303 303* 312 312 464* 466* 468* 468 468 472
                                                                                  472* 472 472 477 479 480 482 485 485
bp                              000130 automatic       pointer                  dcl 64 set ref 254* 255 257 257
cleanup                         000142 stack reference condition                dcl 79 ref 121 231
code                            000127 automatic       fixed bin(35,0)          dcl 63 set ref 125* 130* 131 132* 136* 137 138* 143*
                                                                                  144 231* 232* 318* 405 421* 454*
com_err_                        000042 constant        entry                    external dcl 100 ref 132 149 156 164 421
control                   1            based           structure                level 2 dcl 2-7 set ref 345*
copy_area                              based           fixed bin(17,0)          array dcl 110 set ref 250* 250
cu_$arg_count                   000032 constant        entry                    external dcl 96 ref 124
cu_$arg_ptr                     000046 constant        entry                    external dcl 102 ref 125 130
cur_size                  0(18)        based           bit(18)                  level 2 packed unaligned dcl 1-52 ref 260 264 284
                                                                                  288 291 296 299 299 302 312 468 472 480 485
cv_oct_check_                   000044 constant        entry                    external dcl 101 ref 136
cv_ptr_                         000052 constant        entry                    external dcl 104 ref 143
cv_ptr_$terminate               000054 constant        entry                    external dcl 105 ref 416
defined_by_call           3(04)        based           bit(1)                   level 3 packed unaligned dcl 1-8 ref 351
dont_free                 1(03)        based           bit(1)                   level 3 in structure "area_info" packed unaligned
                                                                                  dcl 2-7 in procedure "area_status" set ref 348*
dont_free                 3(03)        based           bit(1)                   level 3 in structure "area_header" packed unaligned
                                                                                  dcl 1-8 in procedure "area_status" ref 199 348
dump_seg_                       000040 constant        entry                    external dcl 99 ref 291
error_table_$bad_arg            000012 external static fixed bin(35,0)          dcl 83 ref 445
error_table_$bad_conversion     000014 external static fixed bin(35,0)          dcl 83 ref 138
error_table_$bad_segment        000010 external static fixed bin(35,0)          dcl 83 ref 340
error_table_$badopt             000016 external static fixed bin(35,0)          dcl 83 set ref 149*
error_table_$end_of_info        000020 external static fixed bin(35,0)          dcl 83 ref 405 493
error_table_$unimplemented_version
                                000022 external static fixed bin(35,0)          dcl 83 set ref 164* 330 454
error_table_$wrong_no_of_args   000024 external static fixed bin(35,0)          dcl 83 set ref 156*
extend                    1            based           bit(1)                   level 3 in structure "area_info" packed unaligned
                                                                                  dcl 2-7 in procedure "area_status" set ref 352*
extend                    3            based           bit(1)                   level 3 in structure "area_header" packed unaligned
                                                                                  dcl 1-8 in procedure "area_status" ref 169 195 237
                                                                                  351 352 405
extend_block                           based           structure                level 1 dcl 1-38
extend_blockp                   000152 automatic       pointer                  dcl 1-36 set ref 353* 354
extend_info              26            based           bit(18)                  level 2 packed unaligned dcl 1-8 ref 169 237 353 407
                                                                                  472
first                           000114 automatic       bit(1)                   unaligned dcl 53 set ref 256* 257 258*
first_area                             based           pointer                  level 2 packed unaligned dcl 1-38 ref 169
flags                     3            based           structure                level 2 dcl 1-8 ref 194
fp                        2            based           bit(18)                  level 2 packed unaligned dcl 1-52 ref 271
free_blocks              21            based           fixed bin(17,0)          level 2 dcl 2-7 set ref 364*
free_count                      000126 automatic       fixed bin(17,0)          dcl 62 set ref 184 185* 222* 261* 261
free_count1                     000115 automatic       fixed bin(17,0)          dcl 54 set ref 182 182* 184 186* 191* 225* 301* 301
                                                                                  364
free_words               23            based           fixed bin(30,0)          level 2 dcl 2-7 set ref 366*
freep                     7            based           structure                array level 2 dcl 1-8 ref 253 253
get_temp_segments_              000034 constant        entry                    external dcl 97 ref 232
given_areap                     000102 automatic       pointer                  dcl 46 set ref 120* 143* 145 416 416*
have_name                       000104 automatic       bit(1)                   unaligned dcl 47 set ref 117* 142 146*
hbound                                                 builtin function         dcl 75 ref 253
i                               000141 automatic       fixed bin(17,0)          dcl 71 set ref 124* 125* 128* 128* 130* 253* 254*
ioa_                            000050 constant        entry                    external dcl 103 ref 175 180 182 185 186 190 191 192
                                                                                  193 195 197 198 199 200 202 262 264 284 289 299
                                                                                  303
iox_$user_output                000030 external static pointer                  dcl 83 set ref 291*
last_block                6            based           bit(18)                  level 2 dcl 1-8 ref 247 283 482
last_usable               1            based           bit(18)                  level 2 dcl 1-8 ref 241 361
lbound                                                 builtin function         dcl 75 ref 253
long                            000133 automatic       bit(1)                   unaligned dcl 66 set ref 123* 127* 180 182 291
marked                    1(09)        based           bit(1)                   level 2 packed unaligned dcl 1-52 set ref 259* 289
                                                                                  303
max                                                    builtin function         dcl 75 ref 247
my_name                         000000 constant        char(12)                 initial unaligned dcl 41 set ref 132* 149* 156* 164*
                                                                                  421*
n_allocated              27            based           fixed bin(17,0)          level 2 packed unaligned dcl 1-8 set ref 180* 242
n_components                    000105 automatic       fixed bin(17,0)          dcl 48 in procedure "area_status" set ref 195* 229*
                                                                                  236* 236 355
n_components             12            based           fixed bin(17,0)          level 2 in structure "area_info" dcl 2-7
                                                                                  in procedure "area_status" set ref 355* 359*
n_free                   27(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 1-8 set ref 182* 243
name                      3            based           char(32)                 level 2 dcl 1-38 ref 354
next_area                 1            based           pointer                  level 2 packed unaligned dcl 1-38 ref 237
next_areap                      000106 automatic       pointer                  dcl 49 set ref 234* 235 237* 238* 315
next_virgin               2            based           bit(18)                  level 2 dcl 1-8 ref 241 247 280 477
nextp                           000122 automatic       pointer                  dcl 59 set ref 296* 297
no_freeing                1(04)        based           bit(1)                   level 3 packed unaligned dcl 2-7 set ref 350*
not_subr                        000113 automatic       bit(1)                   unaligned dcl 52 set ref 116* 262 264 284 289 291
                                                                                  299 303 337*
null                                                   builtin function         dcl 75 ref 119 120 155 235 238 396 416 445 464
offset                          000124 automatic       fixed bin(17,0)          dcl 60 set ref 118* 136* 161 161
owner                     2            based           char(32)                 level 2 packed unaligned dcl 2-7 set ref 354* 358*
prev_busy                 1(08)        based           bit(1)                   level 2 packed unaligned dcl 1-52 ref 262 297 485
print_areap                     000102 automatic       pointer                  dcl 212 set ref 251* 262 262 264 264 284 284 289 289
                                                                                  299 299 303 303
ptr                                                    builtin function         dcl 75 ref 262 262 264 264 284 284 289 289 299 299
                                                                                  303 303
ptrs                            000110 automatic       pointer                  array dcl 50 set ref 231* 232* 250 252 318*
rel                                                    builtin function         dcl 75 ref 248 248 262 262 264 264 280 280 283 283
                                                                                  284 284 289 289 291 299 299 303 303
release_temp_segments_          000036 constant        entry                    external dcl 98 ref 231 318
relp                      7            based           bit(18)                  array level 3 packed unaligned dcl 1-8 ref 254
save_areap                      000100 automatic       pointer                  dcl 211 set ref 218* 268 309 319
sb_n_allocated                  000134 automatic       fixed bin(17,0)          dcl 67 set ref 180 219* 242* 242
sb_n_free                       000135 automatic       fixed bin(17,0)          dcl 68 set ref 182 220* 243* 243
size                                                   builtin function         dcl 75 in procedure "area_status" ref 280 464
size                     13            based           fixed bin(18,0)          level 2 in structure "area_info" dcl 2-7
                                                                                  in procedure "area_status" set ref 361*
steps                           000112 automatic       fixed bin(17,0)          dcl 51 set ref 228* 265* 265 266 278* 306* 306 307
string                                                 builtin function         dcl 75 set ref 194 345*
sys_info$max_seg_size           000026 external static fixed bin(18,0)          dcl 83 ref 248 248
system                    1(05)        based           bit(1)                   level 3 in structure "area_info" packed unaligned
                                                                                  dcl 2-7 in procedure "area_status" set ref 349*
system                    3(05)        based           bit(1)                   level 3 in structure "area_header" packed unaligned
                                                                                  dcl 1-8 in procedure "area_status" ref 349
targ                                   based           char                     unaligned dcl 109 set ref 126 127 127 128 128 136*
                                                                                  143* 149* 421*
tc                              000140 automatic       fixed bin(17,0)          dcl 70 set ref 115* 125* 126 127 127 128 128 130*
                                                                                  136 136 143 143 149 149 421 421
total_free                      000125 automatic       fixed bin(17,0)          dcl 61 set ref 184 185* 223* 260* 260
total_free1                     000116 automatic       fixed bin(17,0)          dcl 55 set ref 184 186* 192* 224* 302* 302 366
total_used1                     000121 automatic       fixed bin(17,0)          dcl 58 set ref 192* 226* 288* 288 365
total_virgin                    000117 automatic       fixed bin(17,0)          dcl 56 set ref 193* 221* 241* 241
tp                              000136 automatic       pointer                  dcl 69 set ref 125* 126 127 127 128 128 130* 136 143
                                                                                  149 421
trace                           000132 automatic       bit(1)                   unaligned dcl 65 set ref 122* 126* 127* 264 284 299
used_count1                     000120 automatic       fixed bin(17,0)          dcl 57 set ref 180 180* 191* 227* 287* 287 363
version                                based           fixed bin(35,0)          level 2 in structure "area_header" dcl 1-8
                                                                                  in procedure "area_status" ref 163 331 362 454
version                                based           fixed bin(17,0)          level 2 in structure "area_info" dcl 2-7
                                                                                  in procedure "area_status" ref 329
version_of_area          14            based           fixed bin(17,0)          level 2 dcl 2-7 set ref 331* 362*
zero_on_alloc             3(01)        based           bit(1)                   level 3 in structure "area_header" packed unaligned
                                                                                  dcl 1-8 in procedure "area_status" ref 197 346
zero_on_alloc             1(01)        based           bit(1)                   level 3 in structure "area_info" packed unaligned
                                                                                  dcl 2-7 in procedure "area_status" set ref 346*
zero_on_free              3(02)        based           bit(1)                   level 3 in structure "area_header" packed unaligned
                                                                                  dcl 1-8 in procedure "area_status" ref 198 347
zero_on_free              1(02)        based           bit(1)                   level 3 in structure "area_info" packed unaligned
                                                                                  dcl 2-7 in procedure "area_status" set ref 347*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
STANDARD_ALLOCATION_METHOD             internal static fixed bin(17,0)          initial dcl 1-32
min_block_size                         internal static fixed bin(17,0)          initial dcl 1-63
no_free_area_header                    based           structure                level 1 dcl 1-46

NAMES DECLARED BY EXPLICIT CONTEXT.
Set_get_block_data_info_Args    003004 constant        entry                    internal dcl 438 ref 401 408
area_info_                      001503 constant        entry                    external dcl 326
area_status                     000356 constant        entry                    external dcl 12
clean_up_seg                    002763 constant        entry                    internal dcl 413 ref 121 133 150 165 176 204
end_loop                        002724 constant        label                    dcl 315 ref 240
err                             001741 constant        label                    dcl 421 ref 139 144
get_block_data_info             001660 constant        entry                    external dcl 387
get_statistics                  001767 constant        entry                    internal dcl 209 ref 174 339
is_busy                         002424 constant        label                    dcl 284 ref 297

NAMES DECLARED BY CONTEXT OR IMPLICATION.
addwordno                                              builtin function         ref 407 464 466 468 472 479 485
wordno                                                 builtin function         ref 472 477 477 482 482

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3464        3542    3163        3474
Length      4024    3163        56         246     300           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
area_status                         196 external procedure  is an external procedure.  
on unit on line 121                  64 on unit               
get_statistics                      107 internal procedure  enables or reverts conditions.  
on unit on line 231                  82 on unit               
clean_up_seg                         68 internal procedure  is called by several nonquick procedures.  
Set_get_block_data_info_Args            internal procedure  shares stack frame of external procedure area_status.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
area_status              000100 area_copy_size              area_status
                         000102 given_areap                 area_status
                         000104 have_name                   area_status
                         000105 n_components                area_status
                         000106 next_areap                  area_status
                         000110 ptrs                        area_status
                         000112 steps                       area_status
                         000113 not_subr                    area_status
                         000114 first                       area_status
                         000115 free_count1                 area_status
                         000116 total_free1                 area_status
                         000117 total_virgin                area_status
                         000120 used_count1                 area_status
                         000121 total_used1                 area_status
                         000122 nextp                       area_status
                         000124 offset                      area_status
                         000125 total_free                  area_status
                         000126 free_count                  area_status
                         000127 code                        area_status
                         000130 bp                          area_status
                         000132 trace                       area_status
                         000133 long                        area_status
                         000134 sb_n_allocated              area_status
                         000135 sb_n_free                   area_status
                         000136 tp                          area_status
                         000140 tc                          area_status
                         000141 i                           area_status
                         000150 areap                       area_status
                         000152 extend_blockp               area_status
                         000154 blockp                      area_status
                         000156 area_infop                  area_status
get_statistics           000100 save_areap                  get_statistics
                         000102 print_areap                 get_statistics

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          enable_op
ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count                 cu_$arg_ptr                   cv_oct_check_
cv_ptr_                       cv_ptr_$terminate             dump_seg_                     get_temp_segments_
ioa_                          release_temp_segments_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$bad_conversion   error_table_$bad_segment      error_table_$badopt
error_table_$end_of_info      error_table_$unimplemented_version                          error_table_$wrong_no_of_args
iox_$user_output              sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 000355       115 000363       116 000364       117 000366       118 000367       119 000370       120 000372
    121 000373       122 000415       123 000416       124 000417       125 000433       126 000450       127 000461
    128 000475       130 000506       131 000523       132 000525       133 000554       134 000560       136 000561
    137 000605       138 000607       139 000612       141 000613       142 000614       143 000616       144 000642
    145 000644       146 000646       147 000650       149 000651       150 000703       151 000707       153 000710
    155 000712       156 000716       158 000742       161 000743       163 000750       164 000753       165 001003
    166 001007       169 001010       174 001022       175 001033       176 001047       177 001053       180 001054
    182 001106       184 001142       185 001150       186 001173       190 001216       191 001235       192 001260
    193 001306       194 001326       195 001331       197 001357       198 001377       199 001417       200 001437
    202 001457       204 001472       205 001476       326 001477       328 001510       329 001514       330 001517
    331 001522       332 001524       335 001525       337 001527       339 001530       340 001541       341 001545
    345 001546       346 001550       347 001555       348 001561       349 001565       350 001571       351 001576
    352 001605       353 001611       354 001616       355 001621       356 001623       358 001624       359 001627
    361 001631       362 001634       363 001636       364 001640       365 001642       366 001644       368 001646
    369 001650       387 001651       391 001665       395 001671       396 001672       397 001674       398 001675
    399 001701       401 001702       405 001710       407 001726       408 001732       411 001740       421 001741
    423 001765       209 001766       218 001774       219 001777       220 002001       221 002002       222 002003
    223 002004       224 002005       225 002006       226 002007       227 002010       228 002011       229 002012
    231 002013       232 002056       234 002104       235 002110       236 002117       237 002120       238 002133
    240 002135       241 002140       242 002150       243 002153       247 002157       248 002165       250 002177
    251 002205       252 002206       253 002207       254 002216       255 002224       256 002230       257 002232
    258 002243       259 002244       260 002247       261 002252       262 002253       264 002304       265 002350
    266 002352       268 002355       269 002357       271 002363       273 002372       278 002374       280 002375
    283 002417       284 002424       287 002470       288 002472       289 002475       291 002527       294 002570
    296 002571       297 002576       299 002602       301 002644       302 002646       303 002651       306 002703
    307 002705       309 002710       310 002712       312 002716       315 002724       318 002727       319 002754
    320 002757       413 002762       416 002770       418 003003       438 003004       445 003006       454 003016
    464 003031       466 003042       468 003047       472 003060       477 003074       479 003110       480 003113
    482 003120       485 003136       487 003152       489 003156       493 003157       500 003162


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
