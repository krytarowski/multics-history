	COMPILATION LISTING OF SEGMENT vrm_create_relation
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/21/84  1429.4 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 vrm_create_relation: create_relation: proc (I_rel_dir, I_rel_name, I_rel_creation_info_ptr, I_typed_vector_array_ptr, O_rel_opening_id, O_record_collection_id, O_code);
        8 
        9 /* .		    BEGIN_DESCRIPTION
       10*
       11*   Create a multi-segment vfile for a database relation. Open the relation
       12*   and return a collection id.  Note that the collection id will always have
       13*   all bits on. If called at the $create_relation entry, a relation description
       14*   record will be written to the relation.
       15*
       16*   .		    END_DESCRIPTON
       17**/
       18 
       19 /*  History:
       20*
       21*    82-09-27  R. Harvey:  Initially written.
       22*    82-11-11  R. Harvey:  Modified to add internal description record
       23*    83-10-04 Roger Lackey : added align_varying_tuple_data procedure  to
       24*                            make sure varying part of tuple was word aligned.
       25**/
       26 
       27 /* vrm_create_relation: proc (I_rel_dir, I_rel_name, I_rel_creation_info_ptr, I_typed_vector_array_ptr, O_rel_opening_id, O_record_collection_id, O_code); */
       28 
       29 /* Parameters */
       30 
       31 	dcl     I_rel_dir		 char (*) parameter;
       32 	dcl     I_rel_name		 char (*) parameter;
       33 	dcl     I_rel_creation_info_ptr ptr parameter;
       34 	dcl     I_typed_vector_array_ptr ptr parameter;
       35 	dcl     O_rel_opening_id	 bit (36) aligned parameter;
       36 	dcl     O_record_collection_id bit (36) aligned parameter;
       37 	dcl     O_code		 fixed bin (35) parameter;
       38 
       39 	MRDS = "0"b;
       40 	goto common;
       41 
       42 
       43 create_MRDS_relation: entry (I_rel_dir, I_rel_name, I_rel_creation_info_ptr, I_typed_vector_array_ptr, O_rel_opening_id, O_record_collection_id, O_code);
       44 
       45 	MRDS = "1"b;
       46 
       47 
       48 
       49 common:
       50 	O_rel_opening_id = "0"b;
       51 	O_record_collection_id = "0"b;
       52 	O_code = 0;
       53 	iocb_ptr = null ();
       54 	vrm_rel_desc_ptr = null ();
       55 
       56 	on cleanup call tidy_up;
       57 
       58 	attach_name = unique_chars_ ("0"b) || ".VRM.new_relation";
       59 	attach_desc = "vfile_ " || rtrim (I_rel_dir) || ">" || I_rel_name;
       60 
       61 	call iox_$attach_name (attach_name, iocb_ptr, attach_desc, null (), code);
       62 	if code ^= 0 then call error (code);
       63 
       64 	call iox_$open (iocb_ptr, KSQU, "0"b, code);
       65 	if code ^= 0 then call error (code);
       66 						/* Init the vfile */
       67 	call iox_$control (iocb_ptr, "record_status", addr (rs_info), code);
       68 	if code ^= 0 then call error (code);
       69 
       70 	if ^MRDS then do;
       71 		call iox_$delete_record (iocb_ptr, code); /* trash the zero length record */
       72 		if code ^= 0 then call error (code);
       73 
       74 		call create_relation_record;		/* put relation info in the relation */
       75 	     end;
       76 
       77 
       78 	call vrm_open (I_rel_dir, I_rel_name, O_rel_opening_id, code); /* Open the relation */
       79 	if code ^= 0 then call error (code);
       80 
       81 	O_record_collection_id = "111111111111111111111111111111111111"b;
       82 
       83 Exit:	call tidy_up;
       84 	return;
       85 
       86 create_relation_record: proc;
       87 
       88 	typed_vector_array_ptr = I_typed_vector_array_ptr;
       89 	if typed_vector_array.version ^= TYPED_VECTOR_ARRAY_VERSION_2 then call error (error_table_$unimplemented_version);
       90 
       91 	vrd_no_of_attrs = typed_vector_array.number_of_dimensions;
       92 	allocate vrm_rel_desc set (vrm_rel_desc_ptr);
       93 
       94 	vrm_rel_desc.record_id = VRM_REL_DESC_RECORD_ID;
       95 	vrm_rel_desc.version = VRM_REL_DESC_VERSION_1;
       96 	vrm_rel_desc.file_id = "0000001"b;
       97 	vrm_rel_desc.rel_id = "000000000001"b;
       98 	string (vrm_rel_desc.switches) = "0"b;
       99 	vrm_rel_desc.var_offset = 1;			/* bit number for substr */
      100 	vrm_rel_desc.maximum_data_length = 0;
      101 	vrm_rel_desc.number_primary_key_attrs = 0;
      102 	vrm_rel_desc.number_sec_indexes = 0;
      103 	vrm_rel_desc.last_var_attr_no = 0;
      104 	vrm_rel_desc.number_var_attrs = 0;
      105 
      106 	do i = 1 to vrd_no_of_attrs;
      107 	     vrm_attr_info_ptr = addr (vrm_rel_desc.attr (i)); /* get pointer to place to store info */
      108 	     char_attr_no = i;
      109 	     vrm_attr_info.name = typed_vector_array.dimension_table (i).name;
      110 	     desc_ptr = typed_vector_array.dimension_table (i).descriptor_ptr;
      111 	     vrm_attr_info.descriptor = desc_ptr -> descriptor_bit_36_ovrly;
      112 	     if desc_ptr -> descriptor.type = VARYING_CHAR_TYPE
      113 		| desc_ptr -> descriptor.type = VARYING_BIT_TYPE
      114 	     then do;				/* varying */
      115 		     vrm_attr_info.varying = "1"b;
      116 		     vrm_rel_desc.switches.stationary_records = "1"b; /* we must do this so records won't move */
      117 		     vrm_rel_desc.number_var_attrs = vrm_rel_desc.number_var_attrs + 1; /* count the varying attributes */
      118 		     vrm_rel_desc.last_var_attr_no = i; /* If this is the last... */
      119 		end;
      120 	     else vrm_attr_info.varying = "0"b;
      121 	     vrm_attr_info.pad = "0"b;
      122 	     call compute_bit_offset_and_length;
      123 	end;
      124 
      125 	if vrm_rel_desc.number_var_attrs ^= 0 then
      126 	     call align_varying_tuple_data;		/* Align varying part of tuple */
      127 
      128 /* convert bit count to char count */
      129 	vrm_rel_desc.maximum_data_length = ceil (divide (vrm_rel_desc.maximum_data_length, 9, 21, 5));
      130 	rel_size = currentsize (vrm_rel_desc) * 4;	/* length of record in bytes */
      131 
      132 	call iox_$seek_key (iocb_ptr, VRM_REL_DESC_KEY, (0), code);
      133 	if code = error_table_$no_record then code = 0;
      134 
      135 	if code = 0 then call iox_$write_record (iocb_ptr, vrm_rel_desc_ptr, rel_size, code);
      136 	if code ^= 0 then call error (code);
      137 
      138      end create_relation_record;
      139 
      140 /*  * * * * * * * * * *      compute_bit_offset_and_length   * * * * * * *   */
      141 
      142 compute_bit_offset_and_length: proc;
      143 
      144 /* routine to convert the attribute's domain descriptor into
      145*   the required tuple offset and space required and update the
      146*   corresponding statistics for the relation information
      147*   NOTE: the padding routines were introduced to make the data stored
      148*   in the tuple(via bit offset/length) relect the pl1 definition
      149*   of storage locations needed for unaligned and aligned data types */
      150 
      151 	vrm_attr_info.bit_length =
      152 	     vrmu_data_length$get_data_bit_length (desc_ptr -> descriptor_bit_36_ovrly);
      153 
      154 /* fixed length attribute/domain handling */
      155 
      156 	if ^vrm_attr_info.varying then do;		/* fixed attributes */
      157 		padding =
      158 		     vrmu_data_align$align_data_item (desc_ptr, vrm_rel_desc.maximum_data_length);
      159 		vrm_attr_info.bit_offset = vrm_rel_desc.var_offset + padding;
      160 						/* set to end of fixed data */
      161 		vrm_rel_desc.var_offset =
      162 		     vrm_rel_desc.var_offset + vrm_attr_info.bit_length + padding;
      163 
      164 /* set new fixed data end */
      165 	     end;
      166 
      167 /* varying string handling */
      168 
      169 	else do;					/* varying strings */
      170 		vrm_attr_info.bit_offset = vrm_rel_desc.number_var_attrs; /* varying array index, not offset */
      171 		padding = pad (WORD, vrm_rel_desc.maximum_data_length); /* varying must start/stop on word boundary */
      172 	     end;
      173 
      174 /* set the maximum tuple and key bit lengths */
      175 
      176 	vrm_rel_desc.maximum_data_length = /* calc in bits for now */
      177 	     vrm_rel_desc.maximum_data_length + vrm_attr_info.bit_length + padding;
      178 
      179 
      180      end compute_bit_offset_and_length;
      181 
      182 /*   * * * * * * * * * * * * * *        pad         * * * * * * * * * * * *  */
      183 
      184 pad: proc (pad_size, pad_base) returns (fixed bin);
      185 
      186 /* routine to return the number of bits necessary to pad a bit count
      187*   out to an alignment boundary of 9(byte), 36(word), or 72(double word) bits
      188*   as determined by the pad size input */
      189 
      190 	if mod (pad_base, pad_size) = 0 then
      191 	     number_of_bits = 0;
      192 	else do;
      193 
      194 		number_of_bits = pad_size - mod (pad_base, pad_size);
      195 
      196 	     end;
      197 
      198 	return (number_of_bits);
      199 
      200 	dcl     pad_size		 fixed bin;	/* either 9 or 36 or 72 */
      201 	dcl     pad_base		 fixed bin (35);	/* current bit length to be padded */
      202 	dcl     number_of_bits	 fixed bin;	/* what has to be added to get to the desired boundary */
      203 
      204      end pad;
      205 
      206 align_varying_tuple_data: procedure ();
      207 
      208 /* varying attributes in the tuple must start on a word boundary,
      209*   this routine makes sure that the end of the fixed data portion of the
      210*   tuple, which is where the varying attributes start, is on that boundary */
      211 
      212 	if vrm_rel_desc.number_var_attrs ^= 0 then do;
      213 
      214 		amount_to_pad = pad (WORD, vrm_rel_desc.var_offset - 1);
      215 		vrm_rel_desc.var_offset = vrm_rel_desc.var_offset + amount_to_pad;
      216 		vrm_rel_desc.maximum_data_length = vrm_rel_desc.maximum_data_length + amount_to_pad;
      217 	     end;
      218 
      219      end align_varying_tuple_data;
      220 
      221 tidy_up: proc;
      222 
      223 	if iocb_ptr ^= null () then do;
      224 		call iox_$close (iocb_ptr, code);	/* Clean up after ourself */
      225 		if code = 0 then call iox_$detach_iocb (iocb_ptr, code);
      226 		if code = 0 then call iox_$destroy_iocb (iocb_ptr, code);
      227 	     end;
      228 
      229 	if vrm_rel_desc_ptr ^= null () then free vrm_rel_desc;
      230 
      231 
      232      end tidy_up;
      233 
      234 
      235 
      236 
      237 error: proc (ecode);
      238 
      239 	dcl     ecode		 fixed bin (35);
      240 
      241 	O_code = ecode;
      242 	go to Exit;
      243 
      244      end error;
      245 
  1     1 /*   BEGIN INCLUDE  vrm_rel_desc.incl.pl1		   */
  1     2 
  1     3 /* 83-05-26 Roger Lackey : Added vrm_attr_info.key_head bit for relation_cursors */
  1     4 
  1     5 dcl 1 vrm_rel_desc based (vrm_rel_desc_ptr),
  1     6     2 record_id bit (12) unal,			/* Distinguish us from tuples and collection records */
  1     7     2 version char (8),				/* Version of this structure */
  1     8     2 file_id bit (7),				/* Value of file id from model */
  1     9     2 rel_id bit (12),				/* Relation id */
  1    10     2 switches,
  1    11       3 MRDS_compatible bit (1) unal,			/* For pre-relation_manager_ MRDS */
  1    12       3 stationary_records
  1    13      bit (1) unal,					/* On = stationary */
  1    14       3 indexed bit (1) unal,				/* This relation has attributes with secondary indices */
  1    15       3 pad bit (33) unal,
  1    16     2 var_offset fixed bin (35),			/* Position of first varying attr */
  1    17     2 maximum_data_length
  1    18      fixed bin (35),				/* Maximum size of tuple in characters */
  1    19     2 number_primary_key_attrs
  1    20      fixed bin,					/* Number of attributes which make up the primary key */
  1    21     2 number_sec_indexes fixed bin,			/* Number of attributes which have a secondary index */
  1    22     2 last_var_attr_no fixed bin,			/* Attr index of last varying attribute */
  1    23     2 number_var_attrs fixed bin,			/* Number of varying attributes */
  1    24     2 number_attrs fixed bin,				/* Number of attribute in rel */
  1    25     2 attr (vrd_no_of_attrs				/* Description of each attribute */
  1    26      refer (vrm_rel_desc.number_attrs)) aligned like vrm_attr_info;
  1    27 
  1    28 dcl 1 vrm_attr_info based (vrm_attr_info_ptr),
  1    29 						/* Attribute specific info */
  1    30     2 name char (32),				/* Name of the attribute */
  1    31     2 descriptor bit (36) aligned,			/* domain descriptor */
  1    32     2 varying bit (1) unal,				/* ON = This is a varying string */
  1    33     2 key_head bit (1) unal,				/* ON = This attr can be a keyhead */
  1    34     2 primary_key_attr bit (1) unal,			/* ON = This is a primary key attribute */
  1    35     2 pad bit (15) unal,				/* unused */
  1    36     2 index_collextion_ix fixed bin (17) unal,		/* Index into vrm_open_info.index_collection array if key_head is on */
  1    37     2 bit_length fixed bin (35),			/* Maximum bit length of tuple */
  1    38     2 bit_offset fixed bin (35);			/* Offset in tuple if fixed, index to offset in tuple if varying */
  1    39 
  1    40 
  1    41 dcl  vrm_rel_desc_ptr pointer;
  1    42 dcl  vrd_no_of_attrs fixed bin;
  1    43 dcl  VRM_REL_DESC_RECORD_ID bit (12) unal int static options (constant) init ("100000000000"b);
  1    44 dcl  VRM_REL_DESC_VERSION_1 char (8) int static options (constant) init ("       1");
  1    45 dcl  vrm_attr_info_ptr pointer;
  1    46 dcl  VRM_REL_DESC_KEY char (256) varying int static options (constant) init ("@relation_description");
  1    47 
  1    48 /*   END INCLUDE  vrm_rel_desc.incl.pl1		   */
      246 
      247 
  2     1 /* ***********************************************************
  2     2*   *                                                         *
  2     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  2     4*   *                                                         *
  2     5*   *********************************************************** */
  2     6 /* BEGIN INCLUDE FILE vu_typed_vector_array.incl.pl1 */
  2     7 
  2     8 /* Written by Lindsey Spratt, 03/04/82.
  2     9*Modified:
  2    10*06/23/82 by Lindsey Spratt: Changed to version 2.  The cv entry declarations
  2    11*	  were altered.  cv_to_typed now takes ptr to the descriptor, ptr to
  2    12*	  the print_vector value (char varying), ptr to the typed_vector
  2    13*	  value location, and a code. cv_to_print now takes ptr to the
  2    14*	  descriptor, ptr to the typed_vector value, the print_vector value
  2    15*	  (char(*) varying), the maximum allowed length for the print_vector
  2    16*	  value, a temp_seg to put the value in if its to big to fit into
  2    17*	  the print_vector, and a code.
  2    18**/
  2    19 
  2    20 /* format: style2,ind3 */
  2    21      dcl	   1 typed_vector_array   based (typed_vector_array_ptr) aligned,
  2    22 	     2 version	      fixed bin (35),
  2    23 	     2 number_of_dimensions
  2    24 			      fixed bin (17),
  2    25 	     2 number_of_vectors  fixed bin (17),
  2    26 	     2 number_of_vector_slots
  2    27 			      fixed bin (17),
  2    28 	     2 maximum_dimension_name_length
  2    29 			      fixed bin (17),
  2    30 	     2 dimension_table    (tva_number_of_dimensions refer (typed_vector_array.number_of_dimensions)),
  2    31 	       3 name	      char (tva_maximum_dimension_name_length
  2    32 			      refer (typed_vector_array.maximum_dimension_name_length)) varying,
  2    33 	       3 descriptor_ptr   ptr,		/* call cv_to_print (descriptor_ptr, typed_value_ptr, */
  2    34 						/* temp_seg_ptr, max_length_for_print_value, */
  2    35 						/* print_value, code) */
  2    36 	       3 cv_to_print      entry (ptr, ptr, ptr, fixed bin (35), char (*) varying, fixed bin (35)),
  2    37 						/* call cv_to_typed (descriptor_ptr, area_ptr, */
  2    38 						/* print_value_ptr, typed_value_ptr, code) */
  2    39 	       3 cv_to_typed      entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  2    40 	     2 vector_slot	      (tva_number_of_vector_slots refer (typed_vector_array.number_of_vector_slots))
  2    41 			      pointer;
  2    42 
  2    43      dcl	   typed_vector_array_ptr ptr;
  2    44      dcl	   tva_number_of_vector_slots
  2    45 			      fixed bin;
  2    46      dcl	   tva_number_of_dimensions
  2    47 			      fixed bin;
  2    48      dcl	   tva_maximum_dimension_name_length
  2    49 			      fixed bin;
  2    50      dcl	   TYPED_VECTOR_ARRAY_VERSION_2
  2    51 			      fixed bin (35) int static options (constant) init (2);
  2    52 
  2    53 /* END INCLUDE FILE vu_typed_vector_array.incl.pl1 */
      248 
      249 
  3     1 /* BEGIN mdbm_descriptor.incl.pl1 -- jaw 5/31/78 */
  3     2 /* modified by Jim Gray - - Nov. 1979, to change type from fixed bin(5) to
  3     3*   unsigned fixed bin(6), so new packed decimal data types could be handled.
  3     4*   also the duplicate mrds_descriptor.incl.pl1 was eliminated. */
  3     5 
  3     6 dcl 1 descriptor based (desc_ptr),			/* map of Multics descriptor */
  3     7     2 version bit (1) unal,				/* DBM handles vers. 1 only */
  3     8     2 type unsigned fixed bin (6) unal,			/* data type */
  3     9     2 packed bit (1) unal,				/* on if data item is packed */
  3    10     2 number_dims bit (4) unal,			/* dimensions */
  3    11     2 size,					/* size for string data */
  3    12       3 scale bit (12) unal,				/* scale for num. data */
  3    13       3 precision bit (12) unal,			/* prec. for num. data */
  3    14     2 array_info (num_dims),
  3    15       3 lower_bound fixed bin (35),			/* lower bound of dimension */
  3    16       3 upper_bound fixed bin (35),			/* upper bound of dimension */
  3    17       3 multiplier fixed bin (35);			/*  element separation */
  3    18 
  3    19 dcl  desc_ptr ptr;
  3    20 dcl  num_dims fixed bin init (0) ;			/* more useful form of number_dims */
  3    21 
  3    22 /* END mdbm_descriptor.incl.pl1 */
  3    23 
  3    24 
      250 
      251 
      252 /* Automatic */
      253 
      254 	dcl     attach_name		 char (40);
      255 	dcl     attach_desc		 char (210);
      256 	dcl     amount_to_pad	 fixed bin;	/* bits needed for word alignment */
      257 	dcl     char_attr_no	 picture "zz9";
      258 	dcl     i			 fixed bin;
      259 	dcl     iocb_ptr		 ptr;
      260 	dcl     code		 fixed bin (35);
      261 	dcl     MRDS		 bit (1) aligned;
      262 	dcl     padding		 fixed bin;
      263 	dcl     rel_size		 fixed bin (21);
      264 
      265 /* Based */
      266 
      267 	dcl     descriptor_bit_36_ovrly bit (36) based;
      268 
      269 /* Builtin */
      270 
      271 	dcl     (addr, ceil, currentsize, divide, mod, null, rtrim, string) builtin;
      272 
      273 /* Condition */
      274 
      275 	dcl     cleanup		 condition;
      276 
      277 /* Entry */
      278 
      279 	dcl     iox_$attach_name	 entry (char (*), ptr, char (*), ptr, fixed bin (35));
      280 	dcl     iox_$close		 entry (ptr, fixed bin (35));
      281 	dcl     iox_$control	 entry (ptr, char (*), ptr, fixed bin (35));
      282 	dcl     iox_$delete_record	 entry (ptr, fixed bin (35));
      283 	dcl     iox_$detach_iocb	 entry (ptr, fixed bin (35));
      284 	dcl     iox_$destroy_iocb	 entry (ptr, fixed bin (35));
      285 	dcl     iox_$open		 entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
      286 	dcl     iox_$seek_key	 entry (ptr, char (256) var, fixed bin (21), fixed bin (35));
      287 	dcl     iox_$write_record	 entry (ptr, ptr, fixed bin (21), fixed bin (35));
      288 	dcl     unique_chars_	 entry (bit (*)) returns (char (15));
      289 	dcl     vrm_open		 entry (char (*), char (*), bit (36) aligned, fixed bin (35));
      290 	dcl     vrmu_data_length$get_data_bit_length entry (bit (36)) returns (fixed bin (35));
      291 	dcl     vrmu_data_align$align_data_item entry (ptr, fixed bin (35)) returns (fixed bin);
      292 
      293 /* External static */
      294 
      295 	dcl     error_table_$unimplemented_version fixed bin (35) ext static;
      296 	dcl     error_table_$no_record fixed bin (35) ext static;
      297 
      298 /* Internal static */
      299 
      300 	dcl     (
      301 	        KSQU		 init (10),
      302 	        VARYING_BIT_TYPE	 init (20),
      303 	        VARYING_CHAR_TYPE	 init (22),
      304 	        WORD		 init (36)
      305 	        )			 fixed bin int static options (constant);
      306 
      307 /* Structure */
      308 
      309 	dcl     1 rs_info		 aligned,
      310 		2 version		 fixed bin init (2),
      311 		2 flags		 aligned,
      312 		  3 lock_sw	 bit (1) unal init ("0"b),
      313 		  3 unlock_sw	 bit (1) unal init ("0"b),
      314 		  3 create_sw	 bit (1) unal init ("1"b),
      315 		  3 locate_sw	 bit (1) unal init ("1"b),
      316 		  3 inc_ref_count	 bit (1) unal init ("0"b),
      317 		  3 dec_ref_count	 bit (1) unal init ("0"b),
      318 		  3 locate_pos_sw	 bit (1) unal init ("0"b),
      319 		  3 mbz		 bit (29) unal init ("0"b),
      320 		2 record_length	 fixed bin (21) init (0),
      321 		2 max_rec_len	 fixed bin (21) init (0),
      322 		2 record_ptr	 ptr init (null),
      323 		2 descriptor	 fixed bin (35) init (0),
      324 		2 ref_count	 fixed bin (34) init (0),
      325 		2 time_last_modified fixed bin (71) init (0),
      326 		2 modifier	 fixed bin (35) init (0),
      327 		2 block_ptr	 ptr unal init (null),
      328 		2 mbz2		 (2) fixed bin init (0, 0);
      329 
      330 
      331      end vrm_create_relation;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/21/84  0933.6  vrm_create_relation.pl1           >special_ldd>online>mrds_install>vrm_create_relation.pl1
246          1    10/14/83  1609.1  vrm_rel_desc.incl.pl1             >ldd>include>vrm_rel_desc.incl.pl1
248          2    10/14/83  1609.1  vu_typed_vector_array.incl.pl1    >ldd>include>vu_typed_vector_array.incl.pl1
250          3    10/14/83  1608.6  mdbm_descriptor.incl.pl1          >ldd>include>mdbm_descriptor.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
I_rel_creation_info_ptr                parameter       pointer                  dcl 33 ref 7 7 43
I_rel_dir                              parameter       char                     unaligned dcl 31 set ref 7 7 43 59 78*
I_rel_name                             parameter       char                     unaligned dcl 32 set ref 7 7 43 59 78*
I_typed_vector_array_ptr               parameter       pointer                  dcl 34 ref 7 7 43 88
KSQU                            000000 constant        fixed bin(17,0)          initial dcl 300 set ref 64*
MRDS                            000221 automatic       bit(1)                   dcl 261 set ref 39* 45* 70
O_code                                 parameter       fixed bin(35,0)          dcl 37 set ref 7 7 43 52* 241*
O_record_collection_id                 parameter       bit(36)                  dcl 36 set ref 7 7 43 51* 81*
O_rel_opening_id                       parameter       bit(36)                  dcl 35 set ref 7 7 43 49* 78*
TYPED_VECTOR_ARRAY_VERSION_2           constant        fixed bin(35,0)          initial dcl 2-50 ref 89
VARYING_BIT_TYPE                       constant        fixed bin(17,0)          initial dcl 300 ref 112
VARYING_CHAR_TYPE                      constant        fixed bin(17,0)          initial dcl 300 ref 112
VRM_REL_DESC_KEY                000001 constant        varying char(256)        initial dcl 1-46 set ref 132*
VRM_REL_DESC_RECORD_ID                 constant        bit(12)                  initial unaligned dcl 1-43 ref 94
VRM_REL_DESC_VERSION_1          000102 constant        char(8)                  initial unaligned dcl 1-44 ref 95
WORD                            000111 constant        fixed bin(17,0)          initial dcl 300 set ref 171* 214*
addr                                                   builtin function         dcl 271 ref 67 67 107
amount_to_pad                   000212 automatic       fixed bin(17,0)          dcl 256 set ref 214* 215 216
attach_desc                     000125 automatic       char(210)                unaligned dcl 255 set ref 59* 61*
attach_name                     000113 automatic       char(40)                 unaligned dcl 254 set ref 58* 61*
attr                     14            based           structure                array level 2 dcl 1-5 set ref 107
bit_length               12            based           fixed bin(35,0)          level 2 dcl 1-28 set ref 151* 161 176
bit_offset               13            based           fixed bin(35,0)          level 2 dcl 1-28 set ref 159* 170*
block_ptr                13     000232 automatic       pointer                  initial level 2 packed unaligned dcl 309 set ref
                                                                                  309*
ceil                                                   builtin function         dcl 271 ref 129
char_attr_no                    000213 automatic       picture(3)               unaligned dcl 257 set ref 108*
cleanup                         000224 stack reference condition                dcl 275 ref 56
code                            000220 automatic       fixed bin(35,0)          dcl 260 set ref 61* 62 62* 64* 65 65* 67* 68 68* 71*
                                                                                  72 72* 78* 79 79* 132* 133 133* 135 135* 136 136*
                                                                                  224* 225 225* 226 226*
create_sw                 1(02) 000232 automatic       bit(1)                   initial level 3 packed unaligned dcl 309 set ref
                                                                                  309*
currentsize                                            builtin function         dcl 271 ref 130
dec_ref_count             1(05) 000232 automatic       bit(1)                   initial level 3 packed unaligned dcl 309 set ref
                                                                                  309*
desc_ptr                        000110 automatic       pointer                  dcl 3-19 set ref 110* 111 112 112 151 157*
descriptor                             based           structure                level 1 unaligned dcl 3-6 in procedure
                                                                                  "create_relation"
descriptor               10            based           bit(36)                  level 2 in structure "vrm_attr_info" dcl 1-28
                                                                                  in procedure "create_relation" set ref 111*
descriptor                6     000232 automatic       fixed bin(35,0)          initial level 2 in structure "rs_info" dcl 309
                                                                                  in procedure "create_relation" set ref 309*
descriptor_bit_36_ovrly                based           bit(36)                  unaligned dcl 267 set ref 111 151*
descriptor_ptr                         based           pointer                  array level 3 dcl 2-21 ref 110
dimension_table           6            based           structure                array level 2 dcl 2-21
divide                                                 builtin function         dcl 271 ref 129
ecode                                  parameter       fixed bin(35,0)          dcl 239 ref 237 241
error_table_$no_record          000044 external static fixed bin(35,0)          dcl 296 ref 133
error_table_$unimplemented_version
                                000042 external static fixed bin(35,0)          dcl 295 set ref 89*
file_id                   2(18)        based           bit(7)                   level 2 packed unaligned dcl 1-5 set ref 96*
flags                     1     000232 automatic       structure                level 2 dcl 309
i                               000214 automatic       fixed bin(17,0)          dcl 258 set ref 106* 107 108 109 110 118*
inc_ref_count             1(04) 000232 automatic       bit(1)                   initial level 3 packed unaligned dcl 309 set ref
                                                                                  309*
iocb_ptr                        000216 automatic       pointer                  dcl 259 set ref 53* 61* 64* 67* 71* 132* 135* 223
                                                                                  224* 225* 226*
iox_$attach_name                000010 constant        entry                    external dcl 279 ref 61
iox_$close                      000012 constant        entry                    external dcl 280 ref 224
iox_$control                    000014 constant        entry                    external dcl 281 ref 67
iox_$delete_record              000016 constant        entry                    external dcl 282 ref 71
iox_$destroy_iocb               000022 constant        entry                    external dcl 284 ref 226
iox_$detach_iocb                000020 constant        entry                    external dcl 283 ref 225
iox_$open                       000024 constant        entry                    external dcl 285 ref 64
iox_$seek_key                   000026 constant        entry                    external dcl 286 ref 132
iox_$write_record               000030 constant        entry                    external dcl 287 ref 135
last_var_attr_no         11            based           fixed bin(17,0)          level 2 dcl 1-5 set ref 103* 118*
locate_pos_sw             1(06) 000232 automatic       bit(1)                   initial level 3 packed unaligned dcl 309 set ref
                                                                                  309*
locate_sw                 1(03) 000232 automatic       bit(1)                   initial level 3 packed unaligned dcl 309 set ref
                                                                                  309*
lock_sw                   1     000232 automatic       bit(1)                   initial level 3 packed unaligned dcl 309 set ref
                                                                                  309*
max_rec_len               3     000232 automatic       fixed bin(21,0)          initial level 2 dcl 309 set ref 309*
maximum_data_length       6            based           fixed bin(35,0)          level 2 dcl 1-5 set ref 100* 129* 129 157* 171* 176*
                                                                                  176 216* 216
maximum_dimension_name_length
                          4            based           fixed bin(17,0)          level 2 dcl 2-21 ref 109 109 110 110 110
mbz                       1(07) 000232 automatic       bit(29)                  initial level 3 packed unaligned dcl 309 set ref
                                                                                  309*
mbz2                     14     000232 automatic       fixed bin(17,0)          initial array level 2 dcl 309 set ref 309* 309*
mod                                                    builtin function         dcl 271 ref 190 194
modifier                 12     000232 automatic       fixed bin(35,0)          initial level 2 dcl 309 set ref 309*
name                                   based           char(32)                 level 2 in structure "vrm_attr_info" packed
                                                                                  unaligned dcl 1-28 in procedure "create_relation"
                                                                                  set ref 109*
name                      6            based           varying char             array level 3 in structure "typed_vector_array"
                                                                                  dcl 2-21 in procedure "create_relation" ref 109
null                                                   builtin function         dcl 271 ref 53 54 61 61 223 229 309 309
num_dims                        000112 automatic       fixed bin(17,0)          initial dcl 3-20 set ref 3-20*
number_attrs             13            based           fixed bin(17,0)          level 2 dcl 1-5 set ref 92* 130 229
number_of_bits                  000276 automatic       fixed bin(17,0)          dcl 202 set ref 190* 194* 198
number_of_dimensions      1            based           fixed bin(17,0)          level 2 dcl 2-21 ref 91
number_primary_key_attrs
                          7            based           fixed bin(17,0)          level 2 dcl 1-5 set ref 101*
number_sec_indexes       10            based           fixed bin(17,0)          level 2 dcl 1-5 set ref 102*
number_var_attrs         12            based           fixed bin(17,0)          level 2 dcl 1-5 set ref 104* 117* 117 125 170 212
pad                      11(03)        based           bit(15)                  level 2 packed unaligned dcl 1-28 set ref 121*
pad_base                               parameter       fixed bin(35,0)          dcl 201 ref 184 190 194
pad_size                               parameter       fixed bin(17,0)          dcl 200 ref 184 190 194 194
padding                         000222 automatic       fixed bin(17,0)          dcl 262 set ref 157* 159 161 171* 176
record_id                              based           bit(12)                  level 2 packed unaligned dcl 1-5 set ref 94*
record_length             2     000232 automatic       fixed bin(21,0)          initial level 2 dcl 309 set ref 309*
record_ptr                4     000232 automatic       pointer                  initial level 2 dcl 309 set ref 309*
ref_count                 7     000232 automatic       fixed bin(34,0)          initial level 2 dcl 309 set ref 309*
rel_id                    2(25)        based           bit(12)                  level 2 packed unaligned dcl 1-5 set ref 97*
rel_size                        000223 automatic       fixed bin(21,0)          dcl 263 set ref 130* 135*
rs_info                         000232 automatic       structure                level 1 dcl 309 set ref 67 67
rtrim                                                  builtin function         dcl 271 ref 59
stationary_records        3(02)        based           bit(1)                   level 3 packed unaligned dcl 1-5 set ref 116*
string                                                 builtin function         dcl 271 set ref 98*
switches                  3(01)        based           structure                level 2 packed unaligned dcl 1-5 set ref 98*
time_last_modified       10     000232 automatic       fixed bin(71,0)          initial level 2 dcl 309 set ref 309*
type                      0(01)        based           fixed bin(6,0)           level 2 packed unsigned unaligned dcl 3-6 ref 112
                                                                                  112
typed_vector_array                     based           structure                level 1 dcl 2-21
typed_vector_array_ptr          000106 automatic       pointer                  dcl 2-43 set ref 88* 89 91 109 110
unique_chars_                   000032 constant        entry                    external dcl 288 ref 58
unlock_sw                 1(01) 000232 automatic       bit(1)                   initial level 3 packed unaligned dcl 309 set ref
                                                                                  309*
var_offset                5            based           fixed bin(35,0)          level 2 dcl 1-5 set ref 99* 159 161* 161 214 215*
                                                                                  215
varying                  11            based           bit(1)                   level 2 packed unaligned dcl 1-28 set ref 115* 120*
                                                                                  156
version                         000232 automatic       fixed bin(17,0)          initial level 2 in structure "rs_info" dcl 309
                                                                                  in procedure "create_relation" set ref 309*
version                                based           fixed bin(35,0)          level 2 in structure "typed_vector_array" dcl 2-21
                                                                                  in procedure "create_relation" ref 89
version                   0(18)        based           char(8)                  level 2 in structure "vrm_rel_desc" packed unaligned
                                                                                  dcl 1-5 in procedure "create_relation" set ref 95*
vrd_no_of_attrs                 000102 automatic       fixed bin(17,0)          dcl 1-42 set ref 91* 92 92 106
vrm_attr_info                          based           structure                level 1 unaligned dcl 1-28
vrm_attr_info_ptr               000104 automatic       pointer                  dcl 1-45 set ref 107* 109 111 115 120 121 151 156
                                                                                  159 161 170 176
vrm_open                        000034 constant        entry                    external dcl 289 ref 78
vrm_rel_desc                           based           structure                level 1 unaligned dcl 1-5 set ref 92 130 229
vrm_rel_desc_ptr                000100 automatic       pointer                  dcl 1-41 set ref 54* 92* 94 95 96 97 98 99 100 101
                                                                                  102 103 104 107 116 117 117 118 125 129 129 130
                                                                                  135* 157 159 161 161 170 171 176 176 212 214 215
                                                                                  215 216 216 229 229
vrmu_data_align$align_data_item 000040 constant        entry                    external dcl 291 ref 157
vrmu_data_length$get_data_bit_length
                                000036 constant        entry                    external dcl 290 ref 151

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
tva_maximum_dimension_name_length      automatic       fixed bin(17,0)          dcl 2-48
tva_number_of_dimensions               automatic       fixed bin(17,0)          dcl 2-46
tva_number_of_vector_slots             automatic       fixed bin(17,0)          dcl 2-44

NAMES DECLARED BY EXPLICIT CONTEXT.
Exit                            000651 constant        label                    dcl 83 ref 242
align_varying_tuple_data        001257 constant        entry                    internal dcl 206 ref 125
common                          000313 constant        label                    dcl 49 ref 40
compute_bit_offset_and_length   001143 constant        entry                    internal dcl 142 ref 122
create_MRDS_relation            000270 constant        entry                    external dcl 43
create_relation                 000217 constant        entry                    external dcl 7
create_relation_record          000656 constant        entry                    internal dcl 86 ref 74
error                           001374 constant        entry                    internal dcl 237 ref 62 65 68 72 79 89 136
pad                             001237 constant        entry                    internal dcl 184 ref 171 214
tidy_up                         001306 constant        entry                    internal dcl 221 ref 56 83
vrm_create_relation             000243 constant        entry                    external dcl 7

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1700        1746    1437        1710
Length      2226    1437        46         244     241           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
create_relation                     292 external procedure  is an external procedure.  
on unit on line 56                   64 on unit               
create_relation_record                  internal procedure  shares stack frame of external procedure create_relation.  
compute_bit_offset_and_length           internal procedure  shares stack frame of external procedure create_relation.  
pad                                     internal procedure  shares stack frame of external procedure create_relation.  
align_varying_tuple_data                internal procedure  shares stack frame of external procedure create_relation.  
tidy_up                              70 internal procedure  is called by several nonquick procedures.  
error                                   internal procedure  shares stack frame of external procedure create_relation.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
create_relation          000100 vrm_rel_desc_ptr            create_relation
                         000102 vrd_no_of_attrs             create_relation
                         000104 vrm_attr_info_ptr           create_relation
                         000106 typed_vector_array_ptr      create_relation
                         000110 desc_ptr                    create_relation
                         000112 num_dims                    create_relation
                         000113 attach_name                 create_relation
                         000125 attach_desc                 create_relation
                         000212 amount_to_pad               create_relation
                         000213 char_attr_no                create_relation
                         000214 i                           create_relation
                         000216 iocb_ptr                    create_relation
                         000220 code                        create_relation
                         000221 MRDS                        create_relation
                         000222 padding                     create_relation
                         000223 rel_size                    create_relation
                         000232 rs_info                     create_relation
                         000276 number_of_bits              pad

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return              mod_fx1             enable              shorten_stack       ext_entry_desc      int_entry
ceil_fx1            divide_fx1          alloc_based_storage free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
iox_$attach_name              iox_$close                    iox_$control                  iox_$delete_record
iox_$destroy_iocb             iox_$detach_iocb              iox_$open                     iox_$seek_key
iox_$write_record             unique_chars_                 vrm_open
vrmu_data_align$align_data_item                             vrmu_data_length$get_data_bit_length

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$no_record        error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 3   20 000142       309 000143         7 000211        39 000264        40 000265        43 000266        45 000311
     49 000313        51 000315        52 000316        53 000317        54 000321        56 000322        58 000344
     59 000376        61 000453        62 000506        64 000512        65 000531        67 000535        68 000567
     70 000573        71 000575        72 000606        74 000612        78 000613        79 000642        81 000646
     83 000651        84 000655        86 000656        88 000657        89 000663        91 000675        92 000700
     94 000710        95 000712        96 000715        97 000721        98 000727        99 000732       100 000734
    101 000735       102 000736       103 000737       104 000740       106 000741       107 000751       108 000754
    109 000764       110 001010       111 001021       112 001024       115 001034       116 001036       117 001041
    118 001042       119 001044       120 001045       121 001047       122 001051       123 001052       125 001054
    129 001060       130 001070       132 001075       133 001113       135 001120       136 001136       138 001142
    142 001143       151 001144       156 001156       157 001162       159 001176       161 001204       165 001211
    170 001212       171 001215       176 001227       180 001236       184 001237       190 001241       194 001250
    198 001253       206 001257       212 001260       214 001263       215 001273       216 001300       219 001304
    221 001305       223 001313       224 001320       225 001330       226 001344       229 001360       232 001373
    237 001374       241 001376       242 001401


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
