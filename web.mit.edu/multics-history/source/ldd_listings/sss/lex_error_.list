	COMPILATION LISTING OF SEGMENT lex_error_
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/04/82  1806.1 mst Thu
	    Options: optimize map

        1 /* ***************************************************************
        2*   *                                                             *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982     *
        4*   *                                                             *
        5*   * Copyright (c) 1975 by Massachusetts Institute of Technology *
        6*   *                                                             *
        7*   * Copyright (c) 1972 by Massachusetts Institute of            *
        8*   * Technology and Honeywell Information Systems, Inc.          *
        9*   *                                                             *
       10*   *************************************************************** */
       11 
       12 
       13 
       14 
       15 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       16 /*									*/
       17 /* N__a_m_e:  lex_error_							*/
       18 /*									*/
       19 /*      This procedure is used by compilers generated by the reduction_compiler.	*/
       20 /* It outputs specially-formatted error messages on the error_output stream.		*/
       21 /*									*/
       22 /* E__n_t_r_y:	 lex_error_							*/
       23 /*									*/
       24 /*      Given an error number, an error-message-already-printed switch, an error severity, */
       25 /* a maximum error severity encountered so far, a pointer to a lex_string_ statement	*/
       26 /* descriptor, an error message (ioa_ control string), a brief error message (a shorter	*/
       27 /* ioa_ control string), and optional arguments to be substituted into the error messages, */
       28 /* this procedure writes out a herald describing the error number and severity,		*/
       29 /* the statement and line number of the source statement in error, the text of the error	*/
       30 /* message (into which optional arguments have been substituted), and the source	*/
       31 /* statement.  The error message and source statement are marked as having been printed	*/
       32 /* and if severity > max_severity, max_severity is boosted to the value of severity.	*/
       33 /* If an attempt is made to print this error message again (ie, the error reoccurs), then	*/
       34 /* a brief form of the message is printed instead.  (This brief form may be as brief as	*/
       35 /* a null character string.)  If an attempt is made to print the source statement in	*/
       36 /* another error message, printing is suppressed.					*/
       37 /*									*/
       38 /* U__s_a_g_e									*/
       39 /*									*/
       40 /*      declare lex_error_ entry options (variable);				*/
       41 /*									*/
       42 /*      call lex_error_ (error_number, Serror_printed, severity, max_severity, Pstmt,	*/
       43 /*		     Ptoken, S, message, brief_msg, arg1_, ... , arg_n);		*/
       44 /*									*/
       45 /* 1) error_number (fixed bin)	number of the error in error_control_table.	*/
       46 /* 2) Serror_printed (bit(1) unal)	switch indicating whether the error message	*/
       47 /*				has been printed.  This will be updated.	*/
       48 /* 3) severity (fixed bin)		severity of this error.			*/
       49 /* 4) max_severity (fixed bin)	severity of the highest-severity error so far.	*/
       50 /*				This will be updated.			*/
       51 /* 5) Pstmt (ptr)			ptr to lex_string_ type statement descriptor of	*/
       52 /*				statement to be output after error message.	*/
       53 /* 6) Ptoken (ptr)			ptr to lex_string_ type token descriptor of token	*/
       54 /*				appearing in line which is in error.  Line number	*/
       55 /*				of this token will be used in error message if	*/
       56 /*				Pstmt is null.				*/
       57 
       58 /* 7) S (bit(*))			control bits:				*/
       59 /*				  substr(S,1,1) = on if brief message are never	*/
       60 /*					        to be used.			*/
       61 /*				  substr(S,2,1) = on if brief message are always	*/
       62 /*					        used, even when long message	*/
       63 /*					        has never been printed.	*/
       64 /* 8) message (char(*) varying)	text of the error message, an ioa_ control string. */
       65 /* 9) brief_msg (char(*) varying)	text of the brief error message.		*/
       66 /* 10) arg_i			substitution arguments for replacing ioa_ control	*/
       67 /*				arguments in the error message.		*/
       68 /*									*/
       69 /* N__o_t_e_s									*/
       70 /*									*/
       71 /*      The severity numbers cause the error message to preceded by one of the following	*/
       72 /* heralds:								*/
       73 /*	0 = COMMENT		- this is a comment.			*/
       74 /*	1 = WARNING		- a possible error has been detected.  The	*/
       75 /*				  compiler will still generate an object segment.	*/
       76 /*	2 = ERROR			- a probable error has been detected.  The	*/
       77 /*				  compiler will still generate an object segment.	*/
       78 /*	3 = FATAL ERROR		- an error has been detected which is so severe 	*/
       79 /*				  that no object segment will be generated.	*/
       80 /*	4 = TRANSLATOR ERROR	- an error has been detected in the operation of	*/
       81 /*				  the compiler or translator.  No object segment	*/
       82 /*				  will be generated.			*/
       83 /*									*/
       84 /*      Error messages are of the form:						*/
       85 /*	FATAL ERROR _e_r_r_o_r__n_u_m_b_e_r, SEVERITY _s_e_v_e_r_i_t_y IN STATEMENT _n of LINE _m		*/
       86 /*	_t_e_x_t__o_f__e_r_r_o_r__m_e_s_s_a_g_e						*/
       87 /*	SOURCE:								*/
       88 /*	_s_o_u_r_c_e__s_t_a_t_e_m_e_n_t							*/
       89 /*									*/
       90 /* If only one statement appears in line _m, then "STATEMENT _n OF" is omitted.		*/
       91 /*									*/
       92 /* S__t_a_t_u_s									*/
       93 /*									*/
       94 /* 0) Created:  April, 1974 by G. C. Dixon					*/
       95 /* 1) Modified: August, 1981 by M. R. Jordan to recover gracefully when severity is bad	*/
       96 /*									*/
       97 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       98 
       99 
      100 lex_error_: procedure (Nerror, SERROR_PRINTED, severity, max_severity, Pstmt, Ptoken, Scontrol,
      101 	     message, brief);
      102 
      103 dcl  Nerror fixed bin,				/* Number of the error which was detected. (In)	*/
      104      SERROR_PRINTED bit (1) unaligned,			/* on if error message text has been printed.	*/
      105      severity fixed bin (17),				/* severity of this error.			*/
      106      max_severity fixed bin,				/* severity of highest-severity error so far.	*/
      107 						/*	Pstmt			ptr,		/* ptr to a lex_string_ statement descriptor.	*/
      108 						/*	Ptoken			ptr,		/* ptr to a lex_string_ token descriptor.	*/
      109      Scontrol bit (*),				/* control bits (see above).			*/
      110      message char (*) varying,			/* long error message.			*/
      111      brief char (*) varying;				/* short error message.			*/
      112 
      113 dcl  Lmsg fixed bin,
      114      1 S aligned,					/* overlay for Scontrol.			*/
      115      2 always_long bit (1) unal,			/*   always use long error message.		*/
      116      2 always_brief bit (1) unal,			/*   always use brief error message.		*/
      117      msg char (256) aligned;
      118 
      119 dcl (addr, fixed, max, min, null, string)
      120      builtin;
      121 
      122 dcl  cu_$arg_list_ptr entry returns (ptr),
      123      ioa_$general_rs entry (ptr, fixed bin, fixed bin, char (*) aligned, fixed bin,
      124      bit (1) aligned, bit (1) aligned),
      125      ioa_$ioa_stream entry options (variable),
      126      ioa_$ioa_stream_nnl entry options (variable),
      127      iox_$put_chars entry (ptr, ptr, fixed bin, fixed bin (35)),
      128      iox_$error_output ptr ext static;
      129 
      130 dcl  herald (-1:4) char (16) aligned int static init (
      131      "TRANSLATOR ERROR", "COMMENT", "WARNING", "ERROR", "FATAL ERROR", "TRANSLATOR ERROR");
      132 
  1     1 	/*  START OF:	lex_descriptors_.incl.pl1	  *  *  *  *  *  *  */
  1     2 	
  1     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     4 	/*							*/
  1     5 	/* Name:  lex_descriptors_.incl.pl1				*/
  1     6 	/*							*/
  1     7 	/*      This include segment defines the structure of the token	*/
  1     8 	/* descriptor, statement descriptor, and comment descriptor created	*/
  1     9 	/* by the lex_string_ program.				*/
  1    10 	/*							*/
  1    11 	/* Status:						*/
  1    12 	/*							*/
  1    13 	/* 0) Created:  Dec, 1973 by G. C. Dixon			*/
  1    14 	/*							*/
  1    15 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    16 	
  1    17 	
  1    18 	
  1    19 	
  1    20      dcl	
  1    21 	1 comment			aligned based (Pcomment),
  1    22 						/* descriptor for a comment.			*/
  1    23 	  2 group1		unaligned,
  1    24 	    3 version		fixed bin(17),	/* comment descriptor version.		*/
  1    25 	    3 size		fixed bin(17),	/* comment descriptor size (in words).		*/
  1    26 	  2 Pnext			ptr unal,		/* ptr to next comment descriptor.		*/
  1    27 	  2 Plast			ptr unal,		/* ptr to last comment descriptor.		*/
  1    28 	  2 Pvalue		ptr unal,		/* ptr to comment.				*/
  1    29 	  2 Lvalue		fixed bin(18),	/* length of comment.			*/
  1    30 	  2 group2		unaligned,
  1    31 	    3 line_no		fixed bin(17),	/* line no of line containing comment.		*/
  1    32 	    3 S,					/* switches:				*/
  1    33 	      4 before_stmt		bit(1),		/* comment is before 1st token of stmt.		*/
  1    34 	      4 contiguous		bit(1),		/* no tokens between this and last comment.	*/
  1    35 	      4 pad		bit(16),
  1    36 	comment_value		char(comment.Lvalue) based (comment.Pvalue),
  1    37 						/* body of comment.				*/
  1    38 	Pcomment			ptr;		/* ptr to comment descriptor.			*/
  1    39 	
  1    40      dcl	
  1    41 	1 stmt			aligned based (Pstmt),
  1    42 						/* descriptor for a statement.		*/
  1    43 	  2 group1		unaligned,
  1    44 	    3 version		fixed bin(17),	/* statement descriptor version.		*/
  1    45 	    3 size		fixed bin(17),	/* statement descriptor size (in words).	*/
  1    46 	  2 Pnext			ptr unal,		/* ptr to next statement descriptor.		*/
  1    47 	  2 Plast			ptr unal,		/* ptr to last statement descriptor.		*/
  1    48 	  2 Pvalue		ptr unal,		/* ptr to statement.			*/
  1    49 	  2 Lvalue		fixed bin(18),	/* length of statement.			*/
  1    50 	  2 Pfirst_token		ptr unal,		/* ptr to 1st token of statement.		*/
  1    51 	  2 Plast_token		ptr unal,		/* ptr to last token of statement.		*/
  1    52 	  2 Pcomments		ptr unal,		/* ptr to comments in statement.		*/
  1    53 	  2 Puser			ptr unal,		/* user-defined ptr.			*/
  1    54 	  2 group2		unaligned,
  1    55 	    3 Ntokens		fixed bin(17),	/* number of tokens in statement.		*/
  1    56 	    3 line_no		fixed bin(17),	/* line no of line on which statement begins.	*/
  1    57 	    3 Istmt_in_line		fixed bin(17),	/* number of stmts in line containing this stmt.	*/
  1    58 						/* (the number includes this stmt.)		*/
  1    59 	    3 semant_type		fixed bin(17),	/* semantic type of the statement.		*/
  1    60 	    3 S,					/* switches:				*/
  1    61 	      4 error_in_stmt	bit(1),		/* stmt contains a syntactic error.		*/
  1    62 	      4 output_in_err_msg	bit(1),		/* stmt has been output in previous error message.*/
  1    63 	      4 pad		bit(34),
  1    64 	stmt_value		char(stmt.Lvalue) based (stmt.Pvalue),
  1    65 						/* text of the statement.			*/
  1    66 	Pstmt			ptr;		/* ptr to a stmt descriptor. 			*/
  1    67 	
  1    68      dcl	
  1    69 	1 token			aligned based (Ptoken),
  1    70 						/* descriptor for a token.			*/
  1    71 	  2 group1		unaligned,
  1    72 	    3 version		fixed bin(17),	/* token descriptor version.			*/
  1    73 	    3 size		fixed bin(17),	/* token descriptor size (in words).		*/
  1    74 	  2 Pnext			ptr unal,		/* ptr to next token descriptor.		*/
  1    75 	  2 Plast			ptr unal,		/* ptr to last token descriptor.		*/
  1    76 	  2 Pvalue		ptr unal,		/* ptr to token.				*/
  1    77 	  2 Lvalue		fixed bin(18),	/* length of token.				*/
  1    78 	  2 Pstmt			ptr unal,		/* ptr to descriptor of stmt containing token.	*/
  1    79 	  2 Psemant		ptr unal,		/* ptr to descriptor(s) of token's semantic value.*/
  1    80 	  2 group2		unaligned,
  1    81 	    3 Itoken_in_stmt	fixed bin(17),	/* position of token within its statement.	*/
  1    82 	    3 line_no		fixed bin(17),	/* line number of the line containing the token.	*/
  1    83 	    3 Nvalue		fixed bin(35),	/* numeric value of decimal-integer tokens.	*/
  1    84 	    3 S,					/* switches:				*/
  1    85 	      4 end_of_stmt		bit(1),		/* token is an end-of-stmt token.		*/
  1    86 	      4 quoted_string	bit(1),		/* token is a quoted string.			*/
  1    87 	      4 quotes_in_string	bit(1),		/* on if quote-close delimiters appear in quoted	*/
  1    88 						/* string (as doubled quotes on input.)		*/
  1    89 	      4 quotes_doubled	bit(1),		/* on if quotes in the string are doubled after	*/
  1    90 						/* string has been lexed into a token.		*/
  1    91 	      4 pad2		bit(32),
  1    92 	token_value		char(token.Lvalue) based (token.Pvalue),
  1    93 						/* value of the token.			*/
  1    94 	Ptoken			ptr;		/* ptr to a token descriptor.			*/
  1    95 
  1    96 	/*  END OF:	lex_descriptors_.incl.pl1	  *  *  *  *  *  *  */
      133 
      134 
      135 	call ioa_$ioa_stream_nnl ("error_output", "^/^a ^d, SEVERITY ^d", herald (min (4, max (-1, severity))),
      136 	     Nerror, fixed (severity, 35));
      137 
      138 	if Pstmt ^= null then do;
      139 	     if stmt.Istmt_in_line > 1 then
      140 		call ioa_$ioa_stream ("error_output", " IN STATEMENT ^d OF LINE ^d",
      141 		fixed (stmt.Istmt_in_line, 35), fixed (stmt.line_no, 35));
      142 	     else if stmt.Pnext ^= null then
      143 		if stmt.Pnext -> stmt.Istmt_in_line > 1 then
      144 		     call ioa_$ioa_stream ("error_output", " IN STATEMENT ^d OF LINE ^d",
      145 		     fixed (stmt.Istmt_in_line, 35), fixed (stmt.line_no, 35));
      146 		else
      147 		call ioa_$ioa_stream ("error_output", " IN LINE ^d", fixed (stmt.line_no, 35));
      148 	     else
      149 	     call ioa_$ioa_stream ("error_output", " IN LINE ^d", fixed (stmt.line_no, 35));
      150 	end;
      151 	else if Ptoken ^= null then
      152 	     call ioa_$ioa_stream ("error_output", " IN LINE ^d", fixed (token.line_no, 35));
      153 	else
      154 	call ioa_$ioa_stream ("error_output", "");
      155 
      156 	string (S) = Scontrol;			/* copy control bits to aligned structure.	*/
      157 	if (SERROR_PRINTED | S.always_brief) & ^S.always_long then
      158 	     if brief = "" then;
      159 	     else do;
      160 		call ioa_$general_rs (cu_$arg_list_ptr (), 9, 10, msg, Lmsg, "0"b, "1"b);
      161 		call iox_$put_chars (iox_$error_output, addr (msg), Lmsg, 0);
      162 	     end;
      163 	else do;
      164 	     SERROR_PRINTED = "1"b;
      165 	     call ioa_$general_rs (cu_$arg_list_ptr (), 8, 10, msg, Lmsg, "0"b, "1"b);
      166 	     call iox_$put_chars (iox_$error_output, addr (msg), Lmsg, 0);
      167 	end;
      168 
      169 	if Pstmt ^= null then do;
      170 	     stmt.error_in_stmt = "1"b;
      171 	     if stmt.output_in_err_msg then;
      172 	     else do;
      173 		stmt.output_in_err_msg = "1"b;
      174 		call ioa_$ioa_stream ("error_output", "SOURCE:");
      175 		call iox_$put_chars (iox_$error_output, (stmt.Pvalue), (stmt.Lvalue), 0);
      176 		call ioa_$ioa_stream ("error_output", "");
      177 	     end;
      178 	end;
      179 
      180 	if severity > max_severity then
      181 	     max_severity = severity;
      182 
      183      end lex_error_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/82  1625.6  lex_error_.pl1                    >dumps>old>recomp>lex_error_.pl1
133          1    04/18/75  1242.4  lex_descriptors_.incl.pl1         >ldd>include>lex_descriptors_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Istmt_in_line            12            based           fixed bin(17,0)          level 3 packed unaligned dcl 1-40 ref 139 139 139
                                                                                  142 142 142
Lmsg                            000100 automatic       fixed bin(17,0)          dcl 113 set ref 160* 161* 165* 166*
Lvalue                    4            based           fixed bin(18,0)          level 2 dcl 1-40 ref 175
Nerror                                 parameter       fixed bin(17,0)          dcl 103 set ref 100 135*
Pnext                     1            based           pointer                  level 2 packed unaligned dcl 1-40 ref 142 142
Pstmt                                  parameter       pointer                  dcl 1-40 ref 100 138 139 139 139 139 139 142 142 142
                                                                                  142 142 142 146 146 148 148 169 170 171 173 175
                                                                                  175
Ptoken                                 parameter       pointer                  dcl 1-68 ref 100 151 151 151
Pvalue                    3            based           pointer                  level 2 packed unaligned dcl 1-40 ref 175
S                        13            based           structure                level 3 in structure "stmt" packed unaligned
                                                                                  dcl 1-40 in procedure "lex_error_"
S                               000101 automatic       structure                level 1 dcl 113 in procedure "lex_error_" set ref
                                                                                  156*
SERROR_PRINTED                         parameter       bit(1)                   unaligned dcl 103 set ref 100 157 164*
Scontrol                               parameter       bit                      unaligned dcl 103 ref 100 156
addr                                                   builtin function         dcl 119 ref 161 161 166 166
always_brief              0(01) 000101 automatic       bit(1)                   level 2 packed unaligned dcl 113 set ref 157
always_long                     000101 automatic       bit(1)                   level 2 packed unaligned dcl 113 set ref 157
brief                                  parameter       varying char             dcl 103 ref 100 157
cu_$arg_list_ptr                000040 constant        entry                    external dcl 122 ref 160 160 165 165
error_in_stmt            13            based           bit(1)                   level 4 packed unaligned dcl 1-40 set ref 170*
fixed                                                  builtin function         dcl 119 ref 135 135 139 139 139 139 142 142 142 142
                                                                                  146 146 148 148 151 151
group2                   11            based           structure                level 2 in structure "stmt" packed unaligned
                                                                                  dcl 1-40 in procedure "lex_error_"
group2                    7            based           structure                level 2 in structure "token" packed unaligned
                                                                                  dcl 1-68 in procedure "lex_error_"
herald                          000010 internal static char(16)                 initial array dcl 130 set ref 135*
ioa_$general_rs                 000042 constant        entry                    external dcl 122 ref 160 165
ioa_$ioa_stream                 000044 constant        entry                    external dcl 122 ref 139 142 146 148 151 153 174 176
ioa_$ioa_stream_nnl             000046 constant        entry                    external dcl 122 ref 135
iox_$error_output               000052 external static pointer                  dcl 122 set ref 161* 166* 175*
iox_$put_chars                  000050 constant        entry                    external dcl 122 ref 161 166 175
line_no                  11(18)        based           fixed bin(17,0)          level 3 in structure "stmt" packed unaligned
                                                                                  dcl 1-40 in procedure "lex_error_" ref 139 139 142
                                                                                  142 146 146 148 148
line_no                   7(18)        based           fixed bin(17,0)          level 3 in structure "token" packed unaligned
                                                                                  dcl 1-68 in procedure "lex_error_" ref 151 151
max                                                    builtin function         dcl 119 ref 135
max_severity                           parameter       fixed bin(17,0)          dcl 103 set ref 100 180 180*
message                                parameter       varying char             dcl 103 ref 100
min                                                    builtin function         dcl 119 ref 135
msg                             000102 automatic       char(256)                dcl 113 set ref 160* 161 161 165* 166 166
null                                                   builtin function         dcl 119 ref 138 142 151 169
output_in_err_msg        13(01)        based           bit(1)                   level 4 packed unaligned dcl 1-40 set ref 171 173*
severity                               parameter       fixed bin(17,0)          dcl 103 ref 100 135 135 135 180 180
stmt                                   based           structure                level 1 dcl 1-40
string                                                 builtin function         dcl 119 set ref 156*
token                                  based           structure                level 1 dcl 1-68

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Pcomment                               automatic       pointer                  dcl 1-20
comment                                based           structure                level 1 dcl 1-20
comment_value                          based           char                     unaligned dcl 1-20
stmt_value                             based           char                     unaligned dcl 1-40
token_value                            based           char                     unaligned dcl 1-68

NAME DECLARED BY EXPLICIT CONTEXT.
lex_error_                      000055 constant        entry                    external dcl 100

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1152        1226    1051        1162
Length      1426    1051        54         163     100          30

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
lex_error_                          218 external procedure  is an external procedure.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 herald                      lex_error_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
lex_error_               000100 Lmsg                        lex_error_
                         000101 S                           lex_error_
                         000102 msg                         lex_error_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              ext_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$arg_list_ptr              ioa_$general_rs               ioa_$ioa_stream               ioa_$ioa_stream_nnl
iox_$put_chars

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
iox_$error_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    100 000046       135 000102       138 000162       139 000167       142 000241       146 000314       148 000353
    150 000411       151 000412       153 000457       156 000501       157 000510       160 000532       161 000607
    162 000627       164 000630       165 000633       166 000710       169 000730       170 000735       171 000741
    173 000745       174 000747       175 000773       176 001020       180 001042       183 001047


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
