	COMPILATION LISTING OF SEGMENT answer
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/16/84  1435.6 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* Provides a canned answer when any question is asked during the execution of a command or request line */
       12 
       13 /* Created:  by THVV after R. Lamson */
       14 /* Rewritten: 20 March 1978 by G. Palter */
       15 /* Partially rewriten: 2 June 1978 by S.Herbst */
       16 /* Modified: July 1978 by J. C. Whitmore to use new command_query_info structure */
       17 /* Modified: 3 October 1979 by S. Herbst to fix usage message */
       18 /* Modified: 18 February 1980 by S. Herbst to add -call */
       19 /* Modified: 5 June 1981 by S. Herbst to add -match/-exclude and a warning for non-yes/no answer */
       20 /* Modified: 16 February 1982 by G. Palter to add ssu_answer_request_ and convert to a standalone invocation */
       21 /* Modified: 8 September 1982 by G. Palter to propogate subsystem/request line aborts */
       22 /* Modified: 27 March 1984 by S. Herbst to fix "Ignoring response FOO" message with -call */
       23 
       24 /* format: style4,delnl,insnl,ifthenstmt,ifthen */
       25 
       26 
       27 answer:
       28      procedure () options (variable);
       29 
       30 
       31 dcl  P_sci_ptr pointer parameter;			/* ssu_answer_request_: -> SCI of the subsystem */
       32 dcl  P_info_ptr pointer parameter;			/* ssu_answer_request_: -> subsystem's internal data */
       33 
       34 dcl  sci_ptr pointer;
       35 
       36 dcl  1 answer_node aligned based (answer_node_ptr),	/* holds one answer */
       37        2 query_sw bit (1),
       38        2 call_sw bit (1),
       39        2 call_ptr pointer,
       40        2 call_len fixed binary (21),
       41        2 times fixed binary,
       42        2 next_ptr pointer,
       43        2 answer_len fixed binary (21),
       44        2 answer character (arg_len refer (answer_node.answer_len));
       45 dcl  answer_node_ptr pointer;
       46 
       47 dcl  1 match_node aligned based (match_node_ptr),
       48        2 exclude_sw bit (1),
       49        2 regexp_sw bit (1),
       50        2 next_ptr pointer,
       51        2 match_len fixed binary (21),
       52        2 match_str character (arg_len refer (match_node.match_len)) unaligned;
       53 dcl  match_node_ptr pointer;
       54 
  1     1 /* BEGIN INCLUDE FILE ... cp_active_string_types.incl.pl1 */
  1     2 /* Created:  5 May 1980 by G. Palter */
  1     3 
  1     4 /* Types of active strings recognized by active string evaluation entries of the Multics command processor */
  1     5 
  1     6 dcl (DEFAULT_ACTIVE_STRING		initial (0),	/* default type: same as NORMAL_ACTIVE_STRING */
  1     7      NORMAL_ACTIVE_STRING		initial (1),	/* normal active string: [...] */
  1     8      TOKENS_ONLY_ACTIVE_STRING	initial (2),	/* rescan active string for whitespace and quotes: |[...] */
  1     9      ATOMIC_ACTIVE_STRING		initial (3))	/* do not rescan anything in value: ||[...] */
  1    10 	fixed binary static options (constant);
  1    11 
  1    12 /* END INCLUDE FILE ... cp_active_string_types.incl.pl1 */
       55 
       56 
       57 dcl  arg character (arg_len) based (arg_ptr) unaligned;
       58 dcl  based_answer character (answer_max_len) based;
       59 
       60 dcl  (arg_ptr, first_match_ptr, first_node_ptr, next_node_ptr, old_node_ptr, temp_ptr) pointer;
       61 
       62 dcl  area area based (area_ptr);
       63 dcl  area_ptr pointer;
       64 
       65 dcl  (standalone_invocation, brief_sw, call_opt_sw, found_first_answer, is_yes_or_no, yes_no) bit (1) aligned;
       66 
       67 dcl  (arg_count, arg_index, n) fixed binary;
       68 dcl  (answer_max_len, arg_len) fixed binary (21);
       69 dcl  code fixed binary (35);
       70 
       71 dcl  error_table_$bad_conversion fixed binary (35) external;
       72 dcl  error_table_$badopt fixed binary (35) external;
       73 dcl  ssu_et_$null_request_line fixed binary (35) external;
       74 dcl  ssu_et_$subsystem_aborted fixed binary (35) external;
       75 
       76 dcl  iox_$user_io pointer external;
       77 dcl  iox_$user_output pointer external;
       78 
       79 dcl  request_sw bit (1) aligned;
       80 dcl  request_line character (request_len) aligned based (request_ptr);
       81 dcl  request_ptr pointer;
       82 dcl  (request_len, request_start, start) fixed binary (21);
       83 
       84 dcl  com_err_ entry () options (variable);
       85 dcl  command_query_ entry () options (variable);
       86 dcl  condition_ entry (character (*), entry);
       87 dcl  cu_$arg_list_ptr entry () returns (pointer);
       88 dcl  cv_dec_check_ entry (character (*), fixed binary (35)) returns (fixed binary (35));
       89 dcl  get_system_free_area_ entry () returns (pointer);
       90 dcl  search_file_
       91 	entry (pointer, fixed binary (21), fixed binary (21), pointer, fixed binary (21), fixed binary (21),
       92 	fixed binary (21), fixed binary (21), fixed binary (35));
       93 dcl  ssu_$abort_line entry () options (variable);
       94 dcl  ssu_$abort_subsystem entry () options (variable);
       95 dcl  ssu_$arg_count entry (pointer, fixed binary);
       96 dcl  ssu_$arg_ptr entry (pointer, fixed binary, pointer, fixed binary (21));
       97 dcl  ssu_$destroy_invocation entry (pointer);
       98 dcl  ssu_$execute_line entry (pointer, pointer, fixed binary (21), fixed binary (35));
       99 dcl  ssu_$evaluate_active_string
      100 	entry (pointer, pointer, character (*), fixed binary, character (*) varying, fixed binary (35));
      101 dcl  ssu_$get_subsystem_and_request_name entry (pointer) returns (character (72) varying);
      102 dcl  ssu_$get_request_name entry (pointer) returns (character (32));
      103 dcl  ssu_$get_temp_segment entry (pointer, character (*), pointer);
      104 dcl  ssu_$print_message entry () options (variable);
      105 dcl  ssu_$release_temp_segment entry (pointer, pointer);
      106 dcl  ssu_$standalone_invocation entry (pointer, character (*), character (*), pointer, entry, fixed binary (35));
      107 
      108 dcl  (addr, binary, index, min, null, substr) builtin;
      109 
      110 dcl  (cleanup, command_question) condition;
      111 
  2     1 /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
  2     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
  2     3 /*	version number changed to 4, 08/10/78 WOS */
  2     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
  2     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
  2     6 
  2     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
  2     8     2 version fixed bin,				/* version of this structure - must be set, see below */
  2     9     2 switches aligned,                                     /* various bit switch values */
  2    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
  2    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
  2    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
  2    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
  2    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
  2    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
  2    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
  2    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
  2    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
  2    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
  2    20 
  2    21 /*  Limit of data defined for version 2 */
  2    22 
  2    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
  2    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
  2    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
  2    26 						/* minimum of 30 seconds required for repeat */
  2    27 						/* otherwise, no repeat will occur */
  2    28 /* Limit of data defined for version 4 */
  2    29 
  2    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
  2    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
  2    32 
  2    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
  2    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
  2    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
  2    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
  2    37 
  2    38 /*	END INCLUDE FILE query_info.incl.pl1 */
      112 
      113 
  3     1 /* BEGIN INCLUDE FILE condition_info_header.incl.pl1 BIM 1981 */
  3     2 /* format: style2 */
  3     3 
  3     4      declare condition_info_header_ptr
  3     5 			      pointer;
  3     6      declare 1 condition_info_header
  3     7 			      aligned based (condition_info_header_ptr),
  3     8 	     2 length	      fixed bin,		/* length in words of this structure */
  3     9 	     2 version	      fixed bin,		/* version number of this structure */
  3    10 	     2 action_flags	      aligned,		/* tell handler how to proceed */
  3    11 	       3 cant_restart     bit (1) unaligned,	/* caller doesn't ever want to be returned to */
  3    12 	       3 default_restart  bit (1) unaligned,	/* caller can be returned to with no further action */
  3    13 	       3 quiet_restart    bit (1) unaligned,	/* return, and print no message */
  3    14 	       3 support_signal   bit (1) unaligned,	/* treat this signal as if the signalling procedure had the support bit set */
  3    15 						/* if the signalling procedure had the support bit set, do the same for its caller */
  3    16 	       3 pad	      bit (32) unaligned,
  3    17 	     2 info_string	      char (256) varying,	/* may contain printable message */
  3    18 	     2 status_code	      fixed bin (35);	/* if^=0, code interpretable by com_err_ */
  3    19 
  3    20 /* END INCLUDE FILE condition_info_header.incl.pl1 */
      114 
  4     1 /* BEGIN INCLUDE FILE:  command_question_info.incl.pl1 */
  4     2 
  4     3 /*	Last modified: 11/02/78 W. Olin Sibert to change to version 5 and make compatible with query_info */
  4     4 /* Added explanation_ptr & explanation_len (Version 6) 05/13/81 S. Herbst */
  4     5 /* switched to condition_info_header June 1981 B. Margulies */
  4     6 
  4     7 /* This include file depends on condition_info_header.incl.pl1 */
  4     8 /* It must be included as well */
  4     9 /* Added interpret_cp_escape, literal_sw, prompt_after_explanation 12/16/82 S. Herbst */
  4    10 /* Changed ("" max_)(question answer)_lth declarations to fixed bin (21) 02/08/84 S. Herbst */
  4    11 
  4    12 
  4    13 dcl 1 command_question_info based (cq_info_ptr) aligned,
  4    14     2 header aligned like condition_info_header,
  4    15     2 query_code fixed bin (35),			/* extra information supplied by caller */
  4    16     2 switches aligned,                                     /* various bit switches */
  4    17       3 question_sw bit (1) unaligned,			/* should command_query_ print the question? */
  4    18       3 yes_or_no_sw bit (1) unaligned,			/* must question be answered yes or no? */
  4    19       3 preset_sw bit (1) unaligned,			/* is handler supplying a canned answer? */
  4    20       3 answer_sw bit (1) unaligned,			/* should canned answer be printed? */
  4    21       3 allow_cp_escape bit (1) unaligned,                  /* whether to allow answers to begin with ".." */
  4    22       3 suppress_spacing bit (1) unaligned,                 /* whether to print extra newline and spaces */
  4    23       3 interpret_cp_escape bit (1) unaligned,		/* whether to treat ".." as a cp escape */
  4    24       3 literal_sw bit (1) unaligned,			/* ON => don't strip whitespace or handle ".." */
  4    25       3 prompt_after_explanation bit (1) unaligned,	/* ON => repeat question after explanation */
  4    26       3 mbz bit (27) unaligned,
  4    27     2 name_ptr pointer,				/* ptr to caller's name */
  4    28     2 name_lth fixed bin,				/* length of caller's name */
  4    29     2 question_ptr pointer,				/* ptr to quetion being asked */
  4    30     2 question_lth fixed bin (21),			/* lentgh of question */
  4    31     2 max_question_lth fixed bin (21),			/* max question lth in case handler alters question */
  4    32     2 answer_ptr pointer,				/* pointer to space to return answer in */
  4    33     2 answer_lth fixed bin (21),			/* length of returned answer */
  4    34     2 max_answer_lth fixed bin (21),			/* max space in answer space */
  4    35     2 question_iocbp ptr,				/* IO switch to ask (write) question on */
  4    36     2 answer_iocbp ptr,				/* IO switch to read the answer from */
  4    37     2 repeat_time fixed bin (71),			/* repeat question every N seconds if no answer */
  4    38     2 explanation_ptr ptr,				/* ptr to string to print if user answers "?" */
  4    39     2 explanation_len fixed bin (21);			/* length of explanation string */
  4    40 						/* if N < 30 no repeat will occur */
  4    41 
  4    42 dcl  cq_info_ptr pointer;
  4    43 
  4    44 dcl  cq_info_version_7 fixed bin internal static options (constant) init (7);
  4    45 
  4    46 /* END INCLUDE FILE:  command_question_info.incl.pl1 */
      115 
      116 
      117 
      118 /* Multics answer command */
      119 
      120 /* answer: entry () options (variable); */
      121 
      122 	standalone_invocation = "1"b;			/* must create a standalone subsystem to do this */
      123 	call ssu_$standalone_invocation (sci_ptr, "answer", "1.0", cu_$arg_list_ptr (), abort_answer_command, code);
      124 	if code ^= 0 then do;
      125 	     call com_err_ (code, "answer", "Can not establish standalone subsystem invocation.");
      126 	     return;
      127 	end;
      128 	go to COMMON;
      129 
      130 
      131 /* Standard subsystem answer request */
      132 
      133 ssu_answer_request_:
      134      entry (P_sci_ptr, P_info_ptr);
      135 
      136 	standalone_invocation = "0"b;			/* caller supplied the subsystem */
      137 	sci_ptr = P_sci_ptr;
      138 	go to COMMON;
      139 
      140 
      141 /* Actual work starts here */
      142 
      143 COMMON:
      144 	area_ptr = get_system_free_area_ ();
      145 	answer_node_ptr, match_node_ptr, request_ptr, first_match_ptr, first_node_ptr, temp_ptr = null ();
      146 
      147 	on condition (cleanup) call clean_up ();
      148 
      149 	call ssu_$arg_count (sci_ptr, arg_count);
      150 	if arg_count = 0 then			/* abort_line never returns */
      151 USAGE:
      152 	     call ssu_$abort_line (sci_ptr, 0, "Usage:  ^a string {-control_args} ^[command^;request^] line",
      153 		ssu_$get_request_name (sci_ptr), standalone_invocation);
      154 
      155 
      156 	call ssu_$arg_ptr (sci_ptr, 1, arg_ptr, arg_len);
      157 
      158 	call add_answer_node ();
      159 	first_node_ptr = answer_node_ptr;
      160 
      161 	brief_sw, call_opt_sw = "0"b;
      162 	found_first_answer = ""b;			/* this will be set when first answer is found */
      163 	request_sw = "0"b;
      164 	request_start = 0;
      165 	request_len = 0;
      166 
      167 	do arg_index = 1 to arg_count;
      168 	     call ssu_$arg_ptr (sci_ptr, arg_index, arg_ptr, arg_len);
      169 	     if ^request_sw then			/* haven't begun imbedded request line yet */
      170 		if substr (arg, 1, 1) = "-" then
      171 		     if arg = "-brief" | arg = "-bf" then brief_sw = "1"b;
      172 						/* don't print question & answer */
      173 		     else if arg = "-times" then do;
      174 			if ^found_first_answer then	/* this is only defined after some answer */
      175 no_first:
      176 			     call ssu_$abort_line (sci_ptr, 0, "First answer missing before ""^a"".", arg);
      177 			arg_index = arg_index + 1;
      178 			if arg_index > arg_count then
      179 NO_CONTROL_VALUE:
      180 			     call ssu_$abort_line (sci_ptr, 0, "No value specified for ""^a"".", arg);
      181 			call ssu_$arg_ptr (sci_ptr, arg_index, arg_ptr, arg_len);
      182 			n = cv_dec_check_ (arg, code);
      183 			if code ^= 0 then
      184 			     call ssu_$abort_line (sci_ptr, error_table_$bad_conversion, "-times ""^a""", arg);
      185 			answer_node.times = n;
      186 		     end;
      187 		     else if arg = "-call" then do;	/* expand active function to get answer */
      188 			call_opt_sw = "1"b;
      189 			arg_index = arg_index + 1;
      190 			if arg_index > arg_count then go to NO_CONTROL_VALUE;
      191 			call ssu_$arg_ptr (sci_ptr, arg_index, arg_ptr, arg_len);
      192 			if found_first_answer then
      193 			     call add_answer_node ();
      194 			else found_first_answer = "1"b;
      195 			answer_node.call_sw = "1"b;
      196 			answer_node.call_ptr = arg_ptr;
      197 			answer_node.call_len = arg_len;
      198 		     end;
      199 		     else if arg = "-exclude" | arg = "-ex" then do;
      200 			arg_index = arg_index + 1;
      201 			if arg_index > arg_count then go to NO_CONTROL_VALUE;
      202 			call ssu_$arg_ptr (sci_ptr, arg_index, arg_ptr, arg_len);
      203 			call add_match_node ();
      204 			match_node.exclude_sw = "1"b;
      205 MATCH_ARG:
      206 			if substr (arg, 1, 1) = "/" & substr (arg, arg_len, 1) = "/" then do;
      207 			     match_node.regexp_sw = "1"b;
      208 			     match_node.match_len = arg_len - 2;
      209 			     match_node.match_str = substr (arg, 2, arg_len - 2);
      210 			end;
      211 			else do;			/* starname */
      212 			     match_node.regexp_sw = "0"b;
      213 			     match_node.match_str = arg;
      214 			end;
      215 		     end;
      216 		     else if arg = "-match" then do;
      217 			arg_index = arg_index + 1;
      218 			if arg_index > arg_count then go to NO_CONTROL_VALUE;
      219 			call ssu_$arg_ptr (sci_ptr, arg_index, arg_ptr, arg_len);
      220 			call add_match_node ();
      221 			match_node.exclude_sw = "0"b;
      222 			go to MATCH_ARG;
      223 		     end;
      224 		     else if arg = "-query" then do;
      225 			if found_first_answer then	/* node is there for first answer */
      226 			     call add_answer_node ();
      227 			answer_node.query_sw = "1"b;
      228 			found_first_answer = "1"b;	/* we have an answer now */
      229 		     end;
      230 		     else if arg = "-then" then do;
      231 			if ^found_first_answer then go to no_first;
      232 			arg_index = arg_index + 1;
      233 			if arg_index > arg_count then go to NO_CONTROL_VALUE;
      234 			call ssu_$arg_ptr (sci_ptr, arg_index, arg_ptr, arg_len);
      235 			call add_answer_node ();
      236 			answer_node.answer = arg;
      237 		     end;
      238 		     else call ssu_$abort_line (sci_ptr, error_table_$badopt, """^a""", arg);
      239 		else do;
      240 		     if ^found_first_answer then do;	/* this must be the first answer */
      241 			answer_node.answer = arg;
      242 			found_first_answer = "1"b;	/* say we got it */
      243 		     end;
      244 		     else do;			/* otherwise this is the start of request line */
      245 			request_sw = "1"b;		/* begin request line */
      246 			request_start = arg_index;	/* remember where it started */
      247 			request_len = arg_len + 1;	/* start computing length */
      248 		     end;
      249 		end;
      250 
      251 	     else request_len = request_len + arg_len + 1;
      252 	end;
      253 
      254 	if request_len = 0 then go to USAGE;
      255 	answer_node_ptr = first_node_ptr;
      256 
      257 	if call_opt_sw then call ssu_$get_temp_segment (sci_ptr, "answer", temp_ptr);
      258 
      259 	call condition_ ("command_question", answer_handler);
      260 						/* setup handler */
      261 
      262 	allocate request_line in (area) set (request_ptr);
      263 	request_line = "";
      264 
      265 	start = 1;				/* build request line */
      266 	do arg_index = request_start to arg_count;
      267 	     call ssu_$arg_ptr (sci_ptr, arg_index, arg_ptr, arg_len);
      268 	     substr (request_line, start, arg_len) = arg;
      269 	     start = start + arg_len + 1;
      270 	end;
      271 
      272 	call ssu_$execute_line (sci_ptr, addr (request_line), start - 2, code);
      273 						/* execute request line */
      274 	if ^standalone_invocation & (code ^= 0) & (code ^= ssu_et_$null_request_line) then
      275 	     if code = ssu_et_$subsystem_aborted then
      276 		call ssu_$abort_subsystem (sci_ptr);
      277 	     else call ssu_$abort_line (sci_ptr);
      278 
      279 RETURN:
      280 	call clean_up ();
      281 
      282 	return;
      283 
      284 
      285 
      286 /* Internal procedure invoked by ssu_$abort_line if answer was invoked as a Multics command (stanalone invocation) */
      287 
      288 abort_answer_command:
      289      procedure ();
      290 
      291 	go to RETURN;				/* message has been printed: now we can punt */
      292 
      293      end abort_answer_command;
      294 
      295 
      296 
      297 /* This internal procedure supplies the answer when command_question is signalled.
      298**/
      299 
      300 answer_handler:
      301      procedure (mcptr, name, coptr, infoptr, continue_sw);
      302 
      303 dcl  (mcptr, coptr, infoptr) pointer parameter;
      304 dcl  name character (*) parameter;
      305 dcl  continue_sw bit (1) aligned parameter;
      306 
  5     1 /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
  5     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
  5     3 /*	version number changed to 4, 08/10/78 WOS */
  5     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
  5     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
  5     6 
  5     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
  5     8     2 version fixed bin,				/* version of this structure - must be set, see below */
  5     9     2 switches aligned,                                     /* various bit switch values */
  5    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
  5    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
  5    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
  5    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
  5    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
  5    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
  5    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
  5    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
  5    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
  5    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
  5    20 
  5    21 /*  Limit of data defined for version 2 */
  5    22 
  5    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
  5    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
  5    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
  5    26 						/* minimum of 30 seconds required for repeat */
  5    27 						/* otherwise, no repeat will occur */
  5    28 /* Limit of data defined for version 4 */
  5    29 
  5    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
  5    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
  5    32 
  5    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
  5    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
  5    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
  5    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
  5    37 
  5    38 /*	END INCLUDE FILE query_info.incl.pl1 */
      307 
      308 
      309 dcl  1 as aligned based (inp),			/* version 2 answer structure */
      310        2 version fixed binary,			/* ... always 2 */
      311        2 status_code fixed binary (35),			/* errorcode */
      312        2 query_code fixed binary,
      313        2 question_sw bit (1) unaligned,			/* 1 to print question */
      314        2 yes_or_no_sw bit (1) unaligned,		/* 1 if must be yes/no */
      315        2 preset_sw bit (1) unaligned,			/* 1 if we answered */
      316        2 answer_sw bit (1) unaligned,			/* 1 if print answer */
      317        2 np pointer,				/* ptr to asker name */
      318        2 nl fixed binary,				/* len */
      319        2 question_ptr pointer,			/* ptr to question */
      320        2 question_len fixed binary (21),		/* len */
      321        2 max_question_len fixed binary (21),
      322        2 answer_ptr pointer,				/* ptr to answer */
      323        2 answer_len fixed binary (21),
      324        2 max_answer_len fixed binary (21);
      325 
      326 declare  1 cqi aligned based (inp) like command_question_info;
      327 						/* version 3 or 4 answer structure */
      328 dcl  inp pointer;
      329 
      330 dcl  temp_answer character (4 * sys_info$max_seg_size - 4) varying based (temp_ptr);
      331 dcl  sys_info$max_seg_size fixed binary (35) external;
      332 dcl  question_string character (question_len) based (question_ptr);
      333 dcl  buffer character (buffer_len) based (buffer_ptr);
      334 dcl  (buffer_ptr, question_ptr) pointer;
      335 dcl  buffer_len fixed binary (21);
      336 dcl  question_len fixed binary (21);
      337 dcl  length builtin;
      338 
      339 	inp = infoptr;
      340 
      341 	if as.version = 2 then do;
      342 	     question_ptr = as.question_ptr;
      343 	     question_len = as.question_len;
      344 	end;
      345 	else do;
      346 	     question_ptr = cqi.question_ptr;
      347 	     question_len = cqi.question_lth;
      348 	end;
      349 
      350 	if first_match_ptr ^= null () then do;		/* some -match or -exclude args specified */
      351 	     call process_selections (continue_sw, question_ptr, question_len);
      352 	     if continue_sw then return;		/* don't answer this question */
      353 	end;
      354 
      355 	if answer_node_ptr = null ()			/* have run out of answers */
      356 	     | (as.version ^= 2 & cqi.version < 3)	/* unsupported answer structure */
      357 	then do;
      358 	     continue_sw = "1"b;
      359 	     return;
      360 	end;
      361 
      362 	if answer_node.call_sw then do;		/* answer -call ACTIVE_STRING */
      363 	     buffer_ptr = answer_node.call_ptr;
      364 	     buffer_len = answer_node.call_len;
      365 	     on command_question system;
      366 	     call ssu_$evaluate_active_string (sci_ptr, null (), buffer, NORMAL_ACTIVE_STRING, temp_answer, code);
      367 	     if code ^= 0 then do;
      368 		call ssu_$print_message (sci_ptr, code, "[^a]", buffer);
      369 		query_info.suppress_name_sw = "1"b;
      370 		if as.version = 2 then
      371 		     query_info.yes_or_no_sw = as.yes_or_no_sw;
      372 		else query_info.yes_or_no_sw = cqi.yes_or_no_sw;
      373 
      374 		call command_query_ (addr (query_info), temp_answer, ssu_$get_subsystem_and_request_name (sci_ptr),
      375 		     "Please type answer to the following question:^/^a", question_string);
      376 	     end;
      377 	     revert command_question;
      378 	     if as.version = 2 then
      379 		yes_no = as.yes_or_no_sw;
      380 	     else yes_no = cqi.yes_or_no_sw;
      381 	     if temp_answer = "true" then temp_answer = "yes";
      382 	     else if temp_answer = "false" then temp_answer = "no";
      383 	     if temp_answer = "yes" | temp_answer = "y" | temp_answer = "no" | temp_answer = "n" then
      384 		is_yes_or_no = "1"b;
      385 	     else is_yes_or_no = "0"b;
      386 	     answer_node.answer_len = length (temp_answer);
      387 	     go to SET_ANSWER;
      388 	end;
      389 
      390 	else if answer_node.query_sw then do;		/* -query */
      391 	     if cqi.version >= 4 then do;		/* iocbp's are defined in version 4 */
      392 		cqi.question_iocbp = iox_$user_io;	/* ask question on user i/o */
      393 		cqi.answer_iocbp = iox_$user_io;	/* and get answer from same place */
      394 	     end;
      395 	     continue_sw = "1"b;
      396 	end;
      397 
      398 	else do;
      399 	     if answer_node.answer = "yes" | answer_node.answer = "y" | answer_node.answer = "no"
      400 		| answer_node.answer = "n" then
      401 		is_yes_or_no = "1"b;
      402 	     else is_yes_or_no = "0"b;
      403 SET_ANSWER:
      404 	     if as.version = 2 then do;		/* old version structure */
      405 		if as.yes_or_no_sw & ^is_yes_or_no then do;
      406 REJECT_NON_YES_NO:
      407 		     if answer_node.call_sw then
      408 			call ssu_$print_message (sci_ptr, 0,
      409 			     "Ignoring response ""^a"" to yes-or-no question:^/^a",
      410 			     temp_answer, question_string);
      411 		     else call ssu_$print_message (sci_ptr, 0,
      412 			     "Ignoring response ""^a"" to yes-or-no question:^/^a",
      413 			     answer_node.answer, question_string);
      414 		     continue_sw = "1"b;		/* continue to signal */
      415 		     return;
      416 		end;
      417 		answer_max_len = as.max_answer_len;
      418 		as.answer_len = min (answer_max_len, answer_node.answer_len);
      419 						/* careful of string lth */
      420 		if answer_node.call_sw then
      421 		     substr (as.answer_ptr -> based_answer, 1, as.answer_len) = temp_answer;
      422 		else substr (as.answer_ptr -> based_answer, 1, as.answer_len) = answer_node.answer;
      423 		as.preset_sw = "1"b;		/* preset answer given */
      424 		as.question_sw, as.answer_sw = ^brief_sw;
      425 	     end;					/* print if ^brief */
      426 
      427 	     else if cqi.version >= 3 then do;
      428 		if cqi.yes_or_no_sw & ^is_yes_or_no then go to REJECT_NON_YES_NO;
      429 		answer_max_len = cqi.max_answer_lth;
      430 		cqi.answer_lth = min (answer_node.answer_len, answer_max_len);
      431 						/* careful of string lth */
      432 		if answer_node.call_sw then
      433 		     substr (cqi.answer_ptr -> based_answer, 1, cqi.answer_lth) = temp_answer;
      434 		else substr (cqi.answer_ptr -> based_answer, 1, cqi.answer_lth) = answer_node.answer;
      435 		cqi.preset_sw = "1"b;		/* preset answer */
      436 		cqi.question_sw, cqi.answer_sw = ^brief_sw;
      437 		if cqi.version > 3 then		/* if iocbp's are defined */
      438 		     cqi.question_iocbp = iox_$user_output;
      439 	     end;					/* print question and answer on user_output */
      440 
      441 	     else do;				/* don't handle other versions */
      442 		continue_sw = "1"b;
      443 		return;
      444 	     end;
      445 	end;
      446 
      447 	answer_node.times = answer_node.times - 1;
      448 	if answer_node.times = 0 then answer_node_ptr = answer_node.next_ptr;
      449 
      450 	return;
      451 
      452      end answer_handler;
      453 
      454 add_answer_node:
      455      procedure ();
      456 
      457 	old_node_ptr = answer_node_ptr;
      458 
      459 	allocate answer_node in (area) set (answer_node_ptr);
      460 
      461 	answer_node.next_ptr = null ();		/* this is the last node in the chain */
      462 
      463 	if old_node_ptr ^= null () then do;		/* chain the nodes together */
      464 	     old_node_ptr -> answer_node.next_ptr = answer_node_ptr;
      465 	     if old_node_ptr -> answer_node.times = -1 then old_node_ptr -> answer_node.times = 1;
      466 						/* if -times not given, assume 1 */
      467 	end;
      468 
      469 	answer_node.query_sw = "0"b;
      470 	answer_node.call_sw = "0"b;
      471 	answer_node.times = -1;			/* mark as not given yet */
      472 
      473      end add_answer_node;
      474 
      475 
      476 
      477 add_match_node:
      478      procedure ();
      479 
      480 	old_node_ptr = match_node_ptr;
      481 
      482 	allocate match_node in (area) set (match_node_ptr);
      483 
      484 	match_node.next_ptr = null ();		/* this is the last node in the chain */
      485 
      486 	if old_node_ptr ^= null () then		/* thread onto last node */
      487 	     old_node_ptr -> match_node.next_ptr = match_node_ptr;
      488 
      489 	if first_match_ptr = null () then first_match_ptr = match_node_ptr;
      490 
      491      end add_match_node;
      492 
      493 
      494 clean_up:
      495      procedure ();
      496 
      497 	if request_ptr ^= null () then free request_line in (area);
      498 
      499 	if temp_ptr ^= null () then call ssu_$release_temp_segment (sci_ptr, temp_ptr);
      500 
      501 	do answer_node_ptr = first_node_ptr repeat next_node_ptr while (answer_node_ptr ^= null ());
      502 	     next_node_ptr = answer_node.next_ptr;
      503 	     free answer_node in (area);
      504 	end;
      505 
      506 	do match_node_ptr = first_match_ptr repeat next_node_ptr while (match_node_ptr ^= null ());
      507 	     next_node_ptr = match_node.next_ptr;
      508 	     free match_node in (area);
      509 	end;
      510 
      511 	if standalone_invocation then			/* we created the invocation for ourselves... */
      512 	     call ssu_$destroy_invocation (sci_ptr);
      513 
      514      end clean_up;
      515 
      516 process_selections:
      517      procedure (P_continue_sw, P_question_ptr, P_question_len);
      518 
      519 dcl  P_continue_sw bit (1) aligned;			/* ON = do not answer this question */
      520 dcl  P_question_ptr pointer;
      521 dcl  P_question_len fixed binary (21);
      522 dcl  (match_node_ptr, mp) pointer;
      523 
      524 	match_node_ptr = first_match_ptr;
      525 
      526 	if match_node_ptr -> match_node.exclude_sw then
      527 	     P_continue_sw = "0"b;			/* excluding first: assume any question matches */
      528 	else P_continue_sw = "1"b;
      529 
      530 	do mp = match_node_ptr repeat (mp -> match_node.next_ptr) while (mp ^= null ());
      531 	     if mp -> match_node.exclude_sw then do;	/* exclude_sw if it matches */
      532 		if ^P_continue_sw then		/* only if still under consideration */
      533 		     if match_one (mp, P_question_ptr, P_question_len) then P_continue_sw = "1"b;
      534 	     end;
      535 	     else if P_continue_sw then		/* -match: include only if already excluded */
      536 		if match_one (mp, P_question_ptr, P_question_len) then P_continue_sw = "0"b;
      537 	end;
      538 
      539 	return;
      540 
      541 
      542 /* Returns "1"b if the question matches the given -match or -exclude string */
      543 
      544 match_one:
      545 	procedure (P_mp, P_ptr, P_len) returns (bit (1));
      546 
      547 dcl  P_mp pointer;					/* ptr to the next match node */
      548 dcl  P_ptr pointer;					/* ptr to the question being considered */
      549 dcl  P_len fixed binary (21);				/* length of the question */
      550 dcl  question_string character (P_len) based (P_ptr);
      551 
      552 	     if P_mp -> match_node.regexp_sw then
      553 		call search_file_ (addr (P_mp -> match_node.match_str), 1, P_mp -> match_node.match_len, P_ptr, 1,
      554 		     P_len, 0, 0, code);
      555 
      556 	     else code = binary ((index (question_string, P_mp -> match_node.match_str) = 0), 35, 0);
      557 						/* yields 1 if matches, 0 otherwise */
      558 
      559 	     return (code = 0);			/* or vice-versa */
      560 
      561 	end match_one;
      562 
      563      end process_selections;
      564 
      565      end answer;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/16/84  1435.6  answer.pl1                        >spec>on>6756>answer.pl1
55           1    09/22/80  1256.7  cp_active_string_types.incl.pl1   >ldd>include>cp_active_string_types.incl.pl1
112          2    03/11/83  1204.3  query_info_.incl.pl1              >ldd>include>query_info.incl.pl1
114          3    03/24/82  1347.2  condition_info_header.incl.pl1    >ldd>include>condition_info_header.incl.pl1
115          4    02/27/84  1141.9  command_question_info.incl.pl1    >ldd>include>command_question_info.incl.pl1
307          5    03/11/83  1204.3  query_info.incl.pl1               >ldd>include>query_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
NORMAL_ACTIVE_STRING            000037 constant        fixed bin(17,0)          initial dcl 1-6 set ref 366*
P_continue_sw                          parameter       bit(1)                   dcl 519 set ref 516 526* 528* 532 532* 535 535*
P_info_ptr                             parameter       pointer                  dcl 32 ref 133
P_len                                  parameter       fixed bin(21,0)          dcl 549 set ref 544 552* 556
P_mp                                   parameter       pointer                  dcl 547 ref 544 552 552 552 552 556
P_ptr                                  parameter       pointer                  dcl 548 set ref 544 552* 556
P_question_len                         parameter       fixed bin(21,0)          dcl 521 set ref 516 532* 535*
P_question_ptr                         parameter       pointer                  dcl 520 set ref 516 532* 535*
P_sci_ptr                              parameter       pointer                  dcl 31 ref 133 137
addr                                                   builtin function         dcl 108 ref 272 272 374 374 552 552
answer                   11            based           char                     level 2 dcl 36 set ref 236* 241* 399 399 399 399
                                                                                  411* 422 434
answer_iocbp              6     000156 automatic       pointer                  initial level 2 in structure "query_info" dcl 2-7
                                                                                  in procedure "answer" set ref 2-7*
answer_iocbp              6     000100 automatic       pointer                  initial level 2 in structure "query_info" dcl 5-7
                                                                                  in procedure "answer_handler" set ref 5-7*
answer_iocbp            126            based           pointer                  level 2 in structure "cqi" dcl 326 in procedure
                                                                                  "answer_handler" set ref 393*
answer_len               10            based           fixed bin(21,0)          level 2 in structure "answer_node" dcl 36
                                                                                  in procedure "answer" set ref 236 241 386* 399 399
                                                                                  399 399 411 411 418 422 430 434 459* 503
answer_len               16            based           fixed bin(21,0)          level 2 in structure "as" dcl 309 in procedure
                                                                                  "answer_handler" set ref 418* 420 422
answer_lth              122            based           fixed bin(21,0)          level 2 dcl 326 set ref 430* 432 434
answer_max_len                  000135 automatic       fixed bin(21,0)          dcl 68 set ref 417* 418 420 422 429* 430 432 434
answer_node                            based           structure                level 1 dcl 36 set ref 459 503
answer_node_ptr                 000102 automatic       pointer                  dcl 45 set ref 145* 159 185 195 196 197 227 236 241
                                                                                  255* 355 362 363 364 386 390 399 399 399 399 406
                                                                                  411 418 420 422 430 432 434 447 447 448 448* 448
                                                                                  457 459* 461 464 469 470 471 501* 501* 502 503*
answer_ptr              120            based           pointer                  level 2 in structure "cqi" dcl 326 in procedure
                                                                                  "answer_handler" ref 432 434
answer_ptr               14            based           pointer                  level 2 in structure "as" dcl 309 in procedure
                                                                                  "answer_handler" ref 420 422
answer_sw                 3(03)        based           bit(1)                   level 2 in structure "as" packed unaligned dcl 309
                                                                                  in procedure "answer_handler" set ref 424*
answer_sw               106(03)        based           bit(1)                   level 3 in structure "cqi" packed unaligned dcl 326
                                                                                  in procedure "answer_handler" set ref 436*
area                                   based           area(1024)               dcl 62 ref 262 459 482 497 503 508
area_ptr                        000122 automatic       pointer                  dcl 63 set ref 143* 262 459 482 497 503 508
arg                                    based           char                     unaligned dcl 57 set ref 169 169 169 173 174* 178*
                                                                                  182* 183* 187 199 199 205 205 209 213 216 224 230
                                                                                  236 238* 241 268
arg_count                       000132 automatic       fixed bin(17,0)          dcl 67 set ref 149* 150 167 178 190 201 218 233 266
arg_index                       000133 automatic       fixed bin(17,0)          dcl 67 set ref 167* 168* 177* 177 178 181* 189* 189
                                                                                  190 191* 200* 200 201 202* 217* 217 218 219* 232*
                                                                                  232 233 234* 246* 266* 267*
arg_len                         000136 automatic       fixed bin(21,0)          dcl 68 set ref 156* 168* 169 169 169 173 174 174 178
                                                                                  178 181* 182 182 183 183 187 191* 197 199 199 202*
                                                                                  205 205 205 208 209 209 213 216 219* 224 230 234*
                                                                                  236 238 238 241 247 251 267* 268 268 269 459 459
                                                                                  482 482
arg_ptr                         000106 automatic       pointer                  dcl 60 set ref 156* 168* 169 169 169 173 174 178
                                                                                  181* 182 183 187 191* 196 199 199 202* 205 205 209
                                                                                  213 216 219* 224 230 234* 236 238 241 267* 268
as                                     based           structure                level 1 dcl 309
based_answer                           based           char                     unaligned dcl 58 set ref 420* 422* 432* 434*
binary                                                 builtin function         dcl 108 ref 556
brief_sw                        000125 automatic       bit(1)                   dcl 65 set ref 161* 169* 424 436
buffer                                 based           char                     unaligned dcl 333 set ref 366* 368*
buffer_len                      000124 automatic       fixed bin(21,0)          dcl 335 set ref 364* 366 366 368 368
buffer_ptr                      000120 automatic       pointer                  dcl 334 set ref 363* 366 368
call_len                  4            based           fixed bin(21,0)          level 2 dcl 36 set ref 197* 364
call_opt_sw                     000126 automatic       bit(1)                   dcl 65 set ref 161* 188* 257
call_ptr                  2            based           pointer                  level 2 dcl 36 set ref 196* 363
call_sw                   1            based           bit(1)                   level 2 dcl 36 set ref 195* 362 406 420 432 470*
cleanup                         000150 stack reference condition                dcl 110 ref 147
code                            000137 automatic       fixed bin(35,0)          dcl 69 set ref 123* 124 125* 182* 183 272* 274 274
                                                                                  274 366* 367 368* 552* 556* 559
com_err_                        000024 constant        entry                    external dcl 84 ref 125
command_query_                  000026 constant        entry                    external dcl 85 ref 374
command_question                000000 stack reference condition                dcl 110 ref 365 377
command_question_info                  based           structure                level 1 dcl 4-13
condition_                      000030 constant        entry                    external dcl 86 ref 259
condition_info_header                  based           structure                level 1 dcl 3-6
continue_sw                            parameter       bit(1)                   dcl 305 set ref 300 351* 352 358* 395* 414* 442*
coptr                                  parameter       pointer                  dcl 303 ref 300
cp_escape_control         1(02) 000100 automatic       bit(2)                   initial level 3 in structure "query_info" packed
                                                                                  unaligned dcl 5-7 in procedure "answer_handler"
                                                                                  set ref 5-7*
cp_escape_control         1(02) 000156 automatic       bit(2)                   initial level 3 in structure "query_info" packed
                                                                                  unaligned dcl 2-7 in procedure "answer" set ref
                                                                                  2-7*
cqi                                    based           structure                level 1 dcl 326
cu_$arg_list_ptr                000032 constant        entry                    external dcl 87 ref 123 123
cv_dec_check_                   000034 constant        entry                    external dcl 88 ref 182
error_table_$bad_conversion     000010 external static fixed bin(35,0)          dcl 71 set ref 183*
error_table_$badopt             000012 external static fixed bin(35,0)          dcl 72 set ref 238*
exclude_sw                             based           bit(1)                   level 2 dcl 47 set ref 204* 221* 526 531
explanation_len          14     000100 automatic       fixed bin(21,0)          initial level 2 in structure "query_info" dcl 5-7
                                                                                  in procedure "answer_handler" set ref 5-7*
explanation_len          14     000156 automatic       fixed bin(21,0)          initial level 2 in structure "query_info" dcl 2-7
                                                                                  in procedure "answer" set ref 2-7*
explanation_ptr          12     000100 automatic       pointer                  initial level 2 in structure "query_info" dcl 5-7
                                                                                  in procedure "answer_handler" set ref 5-7*
explanation_ptr          12     000156 automatic       pointer                  initial level 2 in structure "query_info" dcl 2-7
                                                                                  in procedure "answer" set ref 2-7*
first_match_ptr                 000110 automatic       pointer                  dcl 60 set ref 145* 350 489 489* 506 524
first_node_ptr                  000112 automatic       pointer                  dcl 60 set ref 145* 159* 255 501
found_first_answer              000127 automatic       bit(1)                   dcl 65 set ref 162* 174 192 194* 225 228* 231 240
                                                                                  242*
get_system_free_area_           000036 constant        entry                    external dcl 89 ref 143
header                                 based           structure                level 2 dcl 326
index                                                  builtin function         dcl 108 ref 556
infoptr                                parameter       pointer                  dcl 303 ref 300 339
inp                             000116 automatic       pointer                  dcl 328 set ref 339* 341 342 343 346 347 355 355 370
                                                                                  370 372 378 378 380 391 392 393 403 405 417 418
                                                                                  420 420 422 422 423 424 424 427 428 429 430 432
                                                                                  432 434 434 435 436 436 437 437
iox_$user_io                    000020 external static pointer                  dcl 76 ref 392 393
iox_$user_output                000022 external static pointer                  dcl 77 ref 437
is_yes_or_no                    000130 automatic       bit(1)                   dcl 65 set ref 383* 385* 399* 402* 405 428
length                                                 builtin function         dcl 337 ref 386
literal_sw                1(05) 000100 automatic       bit(1)                   initial level 3 in structure "query_info" packed
                                                                                  unaligned dcl 5-7 in procedure "answer_handler"
                                                                                  set ref 5-7*
literal_sw                1(05) 000156 automatic       bit(1)                   initial level 3 in structure "query_info" packed
                                                                                  unaligned dcl 2-7 in procedure "answer" set ref
                                                                                  2-7*
match_len                 4            based           fixed bin(21,0)          level 2 dcl 47 set ref 208* 209 213 482* 508 552 552
                                                                                  552* 556
match_node                             based           structure                level 1 dcl 47 set ref 482 508
match_node_ptr                  000142 automatic       pointer                  dcl 522 in procedure "process_selections" set ref
                                                                                  524* 526 530
match_node_ptr                  000104 automatic       pointer                  dcl 53 in procedure "answer" set ref 145* 204 207
                                                                                  208 209 212 213 221 480 482* 484 486 489 506* 506*
                                                                                  507 508*
match_str                 5            based           char                     level 2 packed unaligned dcl 47 set ref 209* 213*
                                                                                  552 552 556
max_answer_len           17            based           fixed bin(21,0)          level 2 dcl 309 ref 417
max_answer_lth          123            based           fixed bin(21,0)          level 2 dcl 326 ref 429
mcptr                                  parameter       pointer                  dcl 303 ref 300
min                                                    builtin function         dcl 108 ref 418 430
mp                              000144 automatic       pointer                  dcl 522 set ref 530* 530* 531 532* 535* 537
n                               000134 automatic       fixed bin(17,0)          dcl 67 set ref 182* 185
name                                   parameter       char                     unaligned dcl 304 ref 300
next_node_ptr                   000114 automatic       pointer                  dcl 60 set ref 502* 504 507* 509
next_ptr                  6            based           pointer                  level 2 in structure "answer_node" dcl 36
                                                                                  in procedure "answer" set ref 448 461* 464* 502
next_ptr                  2            based           pointer                  level 2 in structure "match_node" dcl 47
                                                                                  in procedure "answer" set ref 484* 486* 507 537
null                                                   builtin function         dcl 108 ref 145 2-7 2-7 2-7 350 355 366 366 5-7 5-7
                                                                                  5-7 461 463 484 486 489 497 499 501 506 530
old_node_ptr                    000116 automatic       pointer                  dcl 60 set ref 457* 463 464 465 465 480* 486 486
padding                   1(07) 000156 automatic       bit(29)                  initial level 3 in structure "query_info" packed
                                                                                  unaligned dcl 2-7 in procedure "answer" set ref
                                                                                  2-7*
padding                   1(07) 000100 automatic       bit(29)                  initial level 3 in structure "query_info" packed
                                                                                  unaligned dcl 5-7 in procedure "answer_handler"
                                                                                  set ref 5-7*
preset_sw                 3(02)        based           bit(1)                   level 2 in structure "as" packed unaligned dcl 309
                                                                                  in procedure "answer_handler" set ref 423*
preset_sw               106(02)        based           bit(1)                   level 3 in structure "cqi" packed unaligned dcl 326
                                                                                  in procedure "answer_handler" set ref 435*
prompt_after_explanation
                          1(06) 000156 automatic       bit(1)                   initial level 3 in structure "query_info" packed
                                                                                  unaligned dcl 2-7 in procedure "answer" set ref
                                                                                  2-7*
prompt_after_explanation
                          1(06) 000100 automatic       bit(1)                   initial level 3 in structure "query_info" packed
                                                                                  unaligned dcl 5-7 in procedure "answer_handler"
                                                                                  set ref 5-7*
query_code                3     000156 automatic       fixed bin(35,0)          initial level 2 in structure "query_info" dcl 2-7
                                                                                  in procedure "answer" set ref 2-7*
query_code                3     000100 automatic       fixed bin(35,0)          initial level 2 in structure "query_info" dcl 5-7
                                                                                  in procedure "answer_handler" set ref 5-7*
query_info                      000100 automatic       structure                level 1 dcl 5-7 in procedure "answer_handler" set
                                                                                  ref 374 374
query_info                      000156 automatic       structure                level 1 dcl 2-7 in procedure "answer"
query_sw                               based           bit(1)                   level 2 dcl 36 set ref 227* 390 469*
question_iocbp          124            based           pointer                  level 2 in structure "cqi" dcl 326 in procedure
                                                                                  "answer_handler" set ref 392* 437*
question_iocbp            4     000156 automatic       pointer                  initial level 2 in structure "query_info" dcl 2-7
                                                                                  in procedure "answer" set ref 2-7*
question_iocbp            4     000100 automatic       pointer                  initial level 2 in structure "query_info" dcl 5-7
                                                                                  in procedure "answer_handler" set ref 5-7*
question_len             12            based           fixed bin(21,0)          level 2 in structure "as" dcl 309 in procedure
                                                                                  "answer_handler" ref 343
question_len                    000125 automatic       fixed bin(21,0)          dcl 336 in procedure "answer_handler" set ref 343*
                                                                                  347* 351* 374 374 406 406 411 411
question_lth            116            based           fixed bin(21,0)          level 2 dcl 326 ref 347
question_ptr             10            based           pointer                  level 2 in structure "as" dcl 309 in procedure
                                                                                  "answer_handler" ref 342
question_ptr                    000122 automatic       pointer                  dcl 334 in procedure "answer_handler" set ref 342*
                                                                                  346* 351* 374 406 411
question_ptr            114            based           pointer                  level 2 in structure "cqi" dcl 326 in procedure
                                                                                  "answer_handler" ref 346
question_string                        based           char                     unaligned dcl 550 in procedure "match_one" ref 556
question_string                        based           char                     unaligned dcl 332 in procedure "answer_handler" set
                                                                                  ref 374* 406* 411*
question_sw               3            based           bit(1)                   level 2 in structure "as" packed unaligned dcl 309
                                                                                  in procedure "answer_handler" set ref 424*
question_sw             106            based           bit(1)                   level 3 in structure "cqi" packed unaligned dcl 326
                                                                                  in procedure "answer_handler" set ref 436*
regexp_sw                 1            based           bit(1)                   level 2 dcl 47 set ref 207* 212* 552
repeat_time              10     000100 automatic       fixed bin(71,0)          initial level 2 in structure "query_info" dcl 5-7
                                                                                  in procedure "answer_handler" set ref 5-7*
repeat_time              10     000156 automatic       fixed bin(71,0)          initial level 2 in structure "query_info" dcl 2-7
                                                                                  in procedure "answer" set ref 2-7*
request_len                     000144 automatic       fixed bin(21,0)          dcl 82 set ref 165* 247* 251* 251 254 262 262 263
                                                                                  268 272 272 497 497
request_line                           based           char                     dcl 80 set ref 262 263* 268* 272 272 497
request_ptr                     000142 automatic       pointer                  dcl 81 set ref 145* 262* 263 268 272 272 497 497
request_start                   000145 automatic       fixed bin(21,0)          dcl 82 set ref 164* 246* 266
request_sw                      000140 automatic       bit(1)                   dcl 79 set ref 163* 169 245*
sci_ptr                         000100 automatic       pointer                  dcl 34 set ref 123* 137* 149* 150* 150* 150* 156*
                                                                                  168* 174* 178* 181* 183* 191* 202* 219* 234* 238*
                                                                                  257* 267* 272* 274* 277* 366* 368* 374* 406* 411*
                                                                                  499* 511*
search_file_                    000040 constant        entry                    external dcl 90 ref 552
ssu_$abort_line                 000042 constant        entry                    external dcl 93 ref 150 174 178 183 238 277
ssu_$abort_subsystem            000044 constant        entry                    external dcl 94 ref 274
ssu_$arg_count                  000046 constant        entry                    external dcl 95 ref 149
ssu_$arg_ptr                    000050 constant        entry                    external dcl 96 ref 156 168 181 191 202 219 234 267
ssu_$destroy_invocation         000052 constant        entry                    external dcl 97 ref 511
ssu_$evaluate_active_string     000056 constant        entry                    external dcl 99 ref 366
ssu_$execute_line               000054 constant        entry                    external dcl 98 ref 272
ssu_$get_request_name           000062 constant        entry                    external dcl 102 ref 150 150
ssu_$get_subsystem_and_request_name
                                000060 constant        entry                    external dcl 101 ref 374
ssu_$get_temp_segment           000064 constant        entry                    external dcl 103 ref 257
ssu_$print_message              000066 constant        entry                    external dcl 104 ref 368 406 411
ssu_$release_temp_segment       000070 constant        entry                    external dcl 105 ref 499
ssu_$standalone_invocation      000072 constant        entry                    external dcl 106 ref 123
ssu_et_$null_request_line       000014 external static fixed bin(35,0)          dcl 73 ref 274
ssu_et_$subsystem_aborted       000016 external static fixed bin(35,0)          dcl 74 ref 274
standalone_invocation           000124 automatic       bit(1)                   dcl 65 set ref 122* 136* 150* 274 511
start                           000146 automatic       fixed bin(21,0)          dcl 82 set ref 265* 268 269* 269 272
status_code               2     000100 automatic       fixed bin(35,0)          initial level 2 in structure "query_info" dcl 5-7
                                                                                  in procedure "answer_handler" set ref 5-7*
status_code               2     000156 automatic       fixed bin(35,0)          initial level 2 in structure "query_info" dcl 2-7
                                                                                  in procedure "answer" set ref 2-7*
substr                                                 builtin function         dcl 108 set ref 169 205 205 209 268* 420* 422* 432*
                                                                                  434*
suppress_name_sw          1(01) 000100 automatic       bit(1)                   initial level 3 in structure "query_info" packed
                                                                                  unaligned dcl 5-7 in procedure "answer_handler"
                                                                                  set ref 369* 5-7*
suppress_name_sw          1(01) 000156 automatic       bit(1)                   initial level 3 in structure "query_info" packed
                                                                                  unaligned dcl 2-7 in procedure "answer" set ref
                                                                                  2-7*
suppress_spacing          1(04) 000156 automatic       bit(1)                   initial level 3 in structure "query_info" packed
                                                                                  unaligned dcl 2-7 in procedure "answer" set ref
                                                                                  2-7*
suppress_spacing          1(04) 000100 automatic       bit(1)                   initial level 3 in structure "query_info" packed
                                                                                  unaligned dcl 5-7 in procedure "answer_handler"
                                                                                  set ref 5-7*
switches                106            based           structure                level 2 in structure "cqi" dcl 326 in procedure
                                                                                  "answer_handler"
switches                  1     000100 automatic       structure                level 2 in structure "query_info" dcl 5-7
                                                                                  in procedure "answer_handler"
switches                  1     000156 automatic       structure                level 2 in structure "query_info" dcl 2-7
                                                                                  in procedure "answer"
sys_info$max_seg_size           000074 external static fixed bin(35,0)          dcl 331 ref 366 374 381 382 406
temp_answer                            based           varying char             dcl 330 set ref 366* 374* 381 381* 382 382* 383 383
                                                                                  383 383 386 406* 420 432
temp_ptr                        000120 automatic       pointer                  dcl 60 set ref 145* 257* 366 374 381 381 382 382 383
                                                                                  383 383 383 386 406 420 432 499 499*
times                     5            based           fixed bin(17,0)          level 2 dcl 36 set ref 185* 447* 447 448 465 465*
                                                                                  471*
version                                based           fixed bin(17,0)          level 2 in structure "as" dcl 309 in procedure
                                                                                  "answer_handler" ref 341 355 370 378 403
version                   1            based           fixed bin(17,0)          level 3 in structure "cqi" dcl 326 in procedure
                                                                                  "answer_handler" ref 355 391 427 437
yes_no                          000131 automatic       bit(1)                   dcl 65 set ref 378* 380*
yes_or_no_sw              1     000156 automatic       bit(1)                   initial level 3 in structure "query_info" packed
                                                                                  unaligned dcl 2-7 in procedure "answer" set ref
                                                                                  2-7*
yes_or_no_sw            106(01)        based           bit(1)                   level 3 in structure "cqi" packed unaligned dcl 326
                                                                                  in procedure "answer_handler" ref 372 380 428
yes_or_no_sw              3(01)        based           bit(1)                   level 2 in structure "as" packed unaligned dcl 309
                                                                                  in procedure "answer_handler" ref 370 378 405
yes_or_no_sw              1     000100 automatic       bit(1)                   initial level 3 in structure "query_info" packed
                                                                                  unaligned dcl 5-7 in procedure "answer_handler"
                                                                                  set ref 370* 372* 5-7*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ATOMIC_ACTIVE_STRING                   internal static fixed bin(17,0)          initial dcl 1-6
DEFAULT_ACTIVE_STRING                  internal static fixed bin(17,0)          initial dcl 1-6
TOKENS_ONLY_ACTIVE_STRING              internal static fixed bin(17,0)          initial dcl 1-6
condition_info_header_ptr              automatic       pointer                  dcl 3-4
cq_info_ptr                            automatic       pointer                  dcl 4-42
cq_info_version_7                      internal static fixed bin(17,0)          initial dcl 4-44
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 2-33 in procedure "answer"
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 5-33 in procedure "answer_handler"
query_info_version_4                   internal static fixed bin(17,0)          initial dcl 2-34 in procedure "answer"
query_info_version_4                   internal static fixed bin(17,0)          initial dcl 5-34 in procedure "answer_handler"
query_info_version_5                   internal static fixed bin(17,0)          initial dcl 5-35 in procedure "answer_handler"
query_info_version_5                   internal static fixed bin(17,0)          initial dcl 2-35 in procedure "answer"
query_info_version_6                   internal static fixed bin(17,0)          initial dcl 2-36 in procedure "answer"
query_info_version_6                   internal static fixed bin(17,0)          initial dcl 5-36 in procedure "answer_handler"

NAMES DECLARED BY EXPLICIT CONTEXT.
COMMON                          000377 constant        label                    dcl 143 ref 128 138
MATCH_ARG                       001126 constant        label                    dcl 205 ref 222
NO_CONTROL_VALUE                000665 constant        label                    dcl 178 ref 190 201 218 233
REJECT_NON_YES_NO               002400 constant        label                    dcl 406 ref 428
RETURN                          001563 constant        label                    dcl 279 ref 291
SET_ANSWER                      002366 constant        label                    dcl 403 ref 387
USAGE                           000452 constant        label                    dcl 150 ref 254
abort_answer_command            001571 constant        entry                    internal dcl 288 ref 123 123
add_answer_node                 002672 constant        entry                    internal dcl 454 ref 158 192 225 235
add_match_node                  002730 constant        entry                    internal dcl 477 ref 203 220
answer                          000243 constant        entry                    external dcl 27
answer_handler                  001602 constant        entry                    internal dcl 300 ref 259 259
clean_up                        002763 constant        entry                    internal dcl 494 ref 147 279
match_one                       003215 constant        entry                    internal dcl 544 ref 532 535
no_first                        000625 constant        label                    dcl 174 set ref 231
process_selections              003111 constant        entry                    internal dcl 516 ref 351
ssu_answer_request_             000363 constant        entry                    external dcl 133

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3746        4044    3325        3756
Length      4404    3325        76         323     420           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
answer                              217 external procedure  is an external procedure.  
on unit on line 147                  64 on unit               
abort_answer_command                 64 internal procedure  is assigned to an entry variable.  
answer_handler                      226 internal procedure  is assigned to an entry variable, and enables or reverts conditions.  
on unit on line 365                  64 on unit               
add_answer_node                         internal procedure  shares stack frame of external procedure answer.  
add_match_node                          internal procedure  shares stack frame of external procedure answer.  
clean_up                             70 internal procedure  is called by several nonquick procedures.  
process_selections                      internal procedure  shares stack frame of internal procedure answer_handler.  
match_one                               internal procedure  shares stack frame of internal procedure answer_handler.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
answer                   000100 sci_ptr                     answer
                         000102 answer_node_ptr             answer
                         000104 match_node_ptr              answer
                         000106 arg_ptr                     answer
                         000110 first_match_ptr             answer
                         000112 first_node_ptr              answer
                         000114 next_node_ptr               answer
                         000116 old_node_ptr                answer
                         000120 temp_ptr                    answer
                         000122 area_ptr                    answer
                         000124 standalone_invocation       answer
                         000125 brief_sw                    answer
                         000126 call_opt_sw                 answer
                         000127 found_first_answer          answer
                         000130 is_yes_or_no                answer
                         000131 yes_no                      answer
                         000132 arg_count                   answer
                         000133 arg_index                   answer
                         000134 n                           answer
                         000135 answer_max_len              answer
                         000136 arg_len                     answer
                         000137 code                        answer
                         000140 request_sw                  answer
                         000142 request_ptr                 answer
                         000144 request_len                 answer
                         000145 request_start               answer
                         000146 start                       answer
                         000156 query_info                  answer
answer_handler           000100 query_info                  answer_handler
                         000116 inp                         answer_handler
                         000120 buffer_ptr                  answer_handler
                         000122 question_ptr                answer_handler
                         000124 buffer_len                  answer_handler
                         000125 question_len                answer_handler
                         000142 match_node_ptr              process_selections
                         000144 mp                          process_selections

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return
tra_ext             enable              ext_entry           int_entry           int_entry_desc      set_cs_eis
index_cs_eis        alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      command_query_                condition_                    cu_$arg_list_ptr
cv_dec_check_                 get_system_free_area_         search_file_                  ssu_$abort_line
ssu_$abort_subsystem          ssu_$arg_count                ssu_$arg_ptr                  ssu_$destroy_invocation
ssu_$evaluate_active_string   ssu_$execute_line             ssu_$get_request_name
ssu_$get_subsystem_and_request_name                         ssu_$get_temp_segment         ssu_$print_message
ssu_$release_temp_segment     ssu_$standalone_invocation

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_conversion   error_table_$badopt           iox_$user_io                  iox_$user_output
ssu_et_$null_request_line     ssu_et_$subsystem_aborted     sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 2    7 000210        27 000242       122 000251       123 000253       124 000325       125 000327       126 000355
    128 000356       133 000357       136 000371       137 000372       138 000376       143 000377       145 000406
    147 000415       149 000437       150 000450       156 000520       158 000537       159 000540       161 000542
    162 000544       163 000545       164 000546       165 000547       167 000550       168 000557       169 000574
    173 000617       174 000623       177 000661       178 000662       181 000721       182 000736       183 000763
    185 001021       186 001024       187 001025       188 001031       189 001033       190 001034       191 001037
    192 001054       194 001060       195 001062       196 001065       197 001067       198 001071       199 001072
    200 001102       201 001103       202 001106       203 001123       204 001124       205 001126       207 001140
    208 001143       209 001146       210 001154       212 001155       213 001157       215 001164       216 001165
    217 001171       218 001172       219 001175       220 001212       221 001213       222 001214       224 001215
    225 001221       227 001224       228 001226       229 001227       230 001230       231 001234       232 001236
    233 001237       234 001242       235 001257       236 001260       237 001267       238 001270       240 001322
    241 001324       242 001332       243 001334       245 001335       246 001337       247 001341       249 001344
    251 001345       252 001351       254 001353       255 001355       257 001357       259 001403       262 001431
    263 001440       265 001444       266 001446       267 001455       268 001472       269 001501       270 001504
    272 001506       274 001530       277 001553       279 001563       282 001567       288 001570       291 001576
    300 001601    5    7 001615       339 001645       341 001651       342 001654       343 001656       344 001660
    346 001661       347 001663       350 001665       351 001672       352 001704       355 001710       358 001724
    359 001727       362 001730       363 001733       364 001735       365 001737       366 001754       367 002026
    368 002031       369 002063       370 002065       372 002077       374 002105       377 002171       378 002172
    380 002204       381 002212       382 002240       383 002264       385 002313       386 002314       387 002317
    390 002320       391 002322       392 002326       393 002332       395 002335       396 002340       399 002341
    402 002365       403 002366       405 002371       406 002400       411 002455       414 002520       415 002523
    417 002524       418 002527       420 002534       422 002545       423 002552       424 002554       425 002567
    427 002570       428 002574       429 002602       430 002605       432 002612       434 002623       435 002630
    436 002632       437 002645       439 002654       442 002655       443 002660       447 002661       448 002665
    450 002671       454 002672       457 002673       459 002675       461 002707       463 002711       464 002714
    465 002716       469 002723       470 002724       471 002725       473 002727       477 002730       480 002731
    482 002733       484 002745       486 002747       489 002754       491 002761       494 002762       497 002770
    499 003002       501 003020       502 003031       503 003034       504 003043       506 003050       507 003057
    508 003062       509 003071       511 003076       514 003110       516 003111       524 003113       526 003116
    528 003122       530 003124       531 003132       532 003134       534 003162       535 003163       537 003210
    539 003214       544 003215       552 003217       556 003264       559 003277


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
