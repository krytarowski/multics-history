	COMPILATION LISTING OF SEGMENT vrmu_cv_vector_to_tuple
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/21/84  1337.2 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 vrmu_cv_vector_to_tuple:
        8      proc (I_rel_desc_ptr, I_tuple_ptr, I_typed_vector_ptr, I_mod_flag, O_tuple_length, O_code);
        9 
       10 /* NOTES:
       11*
       12*   This  procedure  inserts user values into the supplied tuple.  
       13*
       14*
       15*   HISTORY:
       16*
       17*   82-09-91  R. Harvey:  Lifted from mu_build_tuple.pl1
       18*
       19*   84-08-29  R. Lackey & T. Nguyen: Fixed the out of bound when calculating
       20*   real_bit_len for the unaligned data type.
       21*
       22**/
       23 
       24 /* Parameters     */
       25 
       26 	dcl     I_rel_desc_ptr	 ptr;
       27 	dcl     I_tuple_ptr		 ptr;
       28 	dcl     I_typed_vector_ptr	 ptr;
       29 	dcl     I_mod_flag		 bit (1) aligned;
       30 	dcl     O_tuple_length	 fixed bin (21);
       31 	dcl     O_code		 fixed bin (35);
       32 
       33 
       34 
       35 	vrm_rel_desc_ptr = I_rel_desc_ptr;
       36 	tuple_ptr = I_tuple_ptr;
       37 
       38 /* Determine the type of vector that was passed in */
       39 
       40 	simple_vector, general_vector = ""b;
       41 	simple_typed_vector_ptr, general_typed_vector_ptr = I_typed_vector_ptr;
       42 	if simple_typed_vector.type = SIMPLE_TYPED_VECTOR_TYPE
       43 	then simple_vector = "1"b;
       44 	else do;
       45 		if general_typed_vector.type = GENERAL_TYPED_VECTOR_TYPE
       46 		then general_vector = "1"b;
       47 		else call error (dm_error_$bad_vector_type);
       48 	     end;
       49 
       50 	mod_flag = I_mod_flag;
       51 
       52 
       53 	on conversion go to conversion_error;
       54 
       55 
       56 	data_ptr = addr (tuple.data);
       57 
       58 	if ^mod_flag then do;			/* if creating, init tuple */
       59 		string (tuple.attr_exists) = "0"b;
       60 		data_str = "0"b;
       61 		do i = 1 to vrm_rel_desc.number_var_attrs;
       62 		     tuple.var_offsets (i) = 0;
       63 		end;
       64 		tuple.rel_id = vrm_rel_desc.rel_id;
       65 	     end;					/* tuple initialization */
       66 
       67 	if general_vector
       68 	then num_of_dims = general_typed_vector.number_of_dimensions;
       69 	else num_of_dims = simple_typed_vector.number_of_dimensions;
       70 
       71 	do i = 1 to num_of_dims;			/* beginning of attribute value insertion loop */
       72 
       73 	     if general_vector			/* determine attribute number */
       74 	     then attr_no = general_typed_vector.dimension (i).identifier;
       75 	     else attr_no = i;			/* simple vector */
       76 
       77 	     vrm_attr_info_ptr = addr (vrm_rel_desc.attr (attr_no));
       78 						/* pick up info ptrs */
       79 
       80 	     tuple.attr_exists (attr_no) = "1"b;
       81 						/* turn on exist flag */
       82 	     if general_vector			/* point to user value as given */
       83 	     then db_val_ptr = general_typed_vector.dimension (i).value_ptr;
       84 	     else db_val_ptr = simple_typed_vector.dimension (i).value_ptr;
       85 
       86 	     if vrm_attr_info.varying then do;		/* insertion of varying length attr. value */
       87 
       88 		     char_count =
       89 			(addr (vrm_attr_info.descriptor) -> descriptor.type = VAR_CHAR);
       90 						/* char or bit count */
       91 		     if char_count then
       92 			real_bit_len = 9 * db_val_ptr -> fb35u;
       93 		     else real_bit_len = db_val_ptr -> fb35u;
       94 
       95 		     if mod_flag then do;		/* if updating rather than creating */
       96 			     offset = tuple.var_offsets (vrm_attr_info.bit_offset);
       97 						/* offset will be the same */
       98 			     call word_align (offset);
       99 			     temp_count_word_ptr = add_bit_offset_ (data_ptr, offset - 1);
      100 
      101 
      102 			     temp_count_word = temp_count_word_ptr -> fb35u;
      103 			     if char_count then
      104 				temp_count_word = temp_count_word * 9;
      105 			     call compute_shift /* need to compute how much to shift subsequent attributes */
      106 				(real_bit_len, temp_count_word, shift_delta);
      107 
      108 
      109 			     if shift_delta = 0 then /* no shifting, just move new val in */
      110 				call insert_var_string;
      111 			     else call shift_insert;	/* if shifting required */
      112 			end;			/* if updating */
      113 
      114 		     else do;			/* if creating new tuple */
      115 			     do j = vrm_attr_info.bit_offset + 1 to vrm_rel_desc.number_var_attrs
      116 				/* check if a following attr is stored */
      117 				while (tuple.var_offsets (j) = 0);
      118 			     end;
      119 
      120 			     if j > vrm_rel_desc.number_var_attrs then do; /* if no followers stored */
      121 
      122 				     do j = vrm_attr_info.bit_offset - 1 by -1 to 1
      123 					while (tuple.var_offsets (j) = 0); /* check for stored leaders */
      124 				     end;
      125 
      126 				     if j < 1 then do; /* if first var. attr. stored */
      127 					     offset = vrm_rel_desc.var_offset; /* use initial value */
      128 					end;	/* if first var. attr. */
      129 				     else do;	/* no followers, but leaders */
      130 
      131 /* Find the previous varying attr_no */
      132 
      133 					     do k = attr_no - 1 to 1 by -1;
      134 						if vrm_rel_desc.attr (k).varying &
      135 						     j = vrm_rel_desc.attr (k).bit_offset
      136 						then prev_attr_no = k;
      137 					     end;
      138 
      139 /* check whether previous varying attr is char or bit */
      140 
      141 					     if addr (vrm_rel_desc.attr (prev_attr_no).descriptor) -> descriptor.type = VAR_CHAR then do;
      142 
      143 
      144 						     temp_count_word_ptr =
      145 							add_bit_offset_ (data_ptr, tuple.var_offsets (j) - 1);
      146 						     real_bit_len2 = temp_count_word_ptr -> fb35u * 9;
      147 						end;
      148 					     else do;
      149 						     temp_count_word_ptr =
      150 							add_bit_offset_ (data_ptr, tuple.var_offsets (j) - 1);
      151 						     real_bit_len2 = temp_count_word_ptr -> fb35u;
      152 						end;
      153 					     offset = real_bit_len2 + 36 + tuple.var_offsets (j);
      154 					end;	/* no followers but leaders */
      155 
      156 				     call word_align (offset);
      157 
      158 				     call insert_var_string;
      159 				end;		/* no following attr. */
      160 
      161 			     else do;		/* if there are following attr. */
      162 				     offset = tuple.var_offsets (j); /* use offset of first follower */
      163 				     call word_align (offset);
      164 
      165 
      166 				     call compute_shift (real_bit_len, -36, shift_delta);
      167 						/* shift followers right to make room */
      168 
      169 
      170 				     call shift_insert;
      171 				end;		/* if there were followers */
      172 
      173 			end;			/* if creating */
      174 
      175 		end;				/* insertion of varying attr. val. */
      176 
      177 	     else do;				/* insertion of fixed length attr */
      178 		     if addr (vrm_attr_info.descriptor) -> descriptor.type <= 8 then
      179 			pad_bit_length = 0;		/* non-byte types won't have garbage,
      180*						   and some may be right justified like fixed fin,
      181*						   or split padding like complex */
      182 		     else pad_bit_length =
      183 			     vrmu_data_length$get_data_pad_length
      184 			     ((vrm_attr_info.descriptor));
      185 		     substr (data_str, vrm_attr_info.bit_offset, vrm_attr_info.bit_length)
      186 			=
      187 			substr (value_for_db, 1,
      188 			vrm_attr_info.bit_length - pad_bit_length); /* aligned data may have garbage in padding space */
      189 		end;
      190 
      191 
      192 	end;					/* attribute value insertion loop */
      193 
      194 /* Now calculate length of the tuple */
      195 
      196 	tuple_header_length = 4 * (binary (rel (addr (tuple_ptr -> tuple.data))) -
      197 	     binary (rel (tuple_ptr)));
      198 
      199 	if vrm_rel_desc.number_var_attrs <= 0 then /* if fixed len tuple */
      200 	     tuple_length = tuple_header_length + vrm_rel_desc.maximum_data_length;
      201 	else do;					/* if varying len */
      202 		data_ptr = addr (tuple.data);
      203 		last_len_offset = tuple.var_offsets (vrm_rel_desc.number_var_attrs);
      204 		last_attr_offset = last_len_offset + 36;
      205 		last_attr_size_ptr = add_bit_offset_ (data_ptr, last_len_offset - 1);
      206 		last_attr_len = last_attr_size_ptr -> fb35u;
      207 		attr_type = addr (vrm_rel_desc.attr (last_var_attr_no).descriptor) -> descriptor.type;
      208 		if attr_type = 22			/* type = character varying */
      209 		then last_attr_len = last_attr_len * 9;
      210 		last_bit_offset = last_attr_offset + last_attr_len - 1;
      211 		tuple_length = 4 * (binary (rel (add_bit_offset_ (data_ptr, last_bit_offset - 1))) - binary (rel (tuple_ptr)) + 1);
      212 						/* length in bytes */
      213 	     end;					/* if varying len */
      214 
      215 	O_tuple_length = tuple_length;
      216 
      217 	O_code = 0;
      218 
      219 exit:
      220 	return;
      221 
      222 
      223 
      224 
      225 
      226 conversion_error:
      227 
      228 	O_code = mdbm_error_$conversion_condition;
      229 	go to exit;
      230 
      231 compute_shift:
      232      proc (real_bit_len, old_bit_len, shift_delta);
      233 
      234 /* This routine determines how far right (left for neg values) to shift
      235*   other attributes to make room for the current attribute. */
      236 
      237 	dcl     real_bit_len	 fixed bin (35) parm; /* INPUT: length of attribute being inserted */
      238 	dcl     old_bit_len		 fixed bin (35) parm; /* INPUT: length of attribute being replaced or zero. */
      239 	dcl     shift_delta		 fixed bin (35) parm; /* OUTPUT: amount to shift to make room for new attribute */
      240 	dcl     (r, o)		 fixed bin (35);
      241 	r = real_bit_len + 1;
      242 	o = old_bit_len + 1;
      243 	call word_align (r);
      244 	call word_align (o);
      245 	shift_delta = r - o;
      246 	return;
      247      end compute_shift;
      248 
      249 
      250 
      251 
      252 
      253 word_align:
      254      proc (offset);
      255 
      256 	dcl     offset		 fixed bin (35) parm; /* INPUT-OUTPUT: bit offset within data portion
      257*						   of tuple where attribute will be stored */
      258 	dcl     slop		 fixed bin (35);
      259 	slop = 36 - mod (offset - 1, 36);
      260 	if slop ^= 36 then
      261 	     offset = offset + slop;
      262 	return;
      263      end word_align;
      264 
      265 shift_insert: proc;
      266 
      267 /* Procedure to shift following varying attr. to make room for storing another
      268*   varying field. */
      269 
      270 	dcl     i			 fixed bin;
      271 
      272 	if shift_delta < 0 then /* if shifting left */
      273 	     do i = vrm_attr_info.bit_offset + 1 to vrm_rel_desc.number_var_attrs;
      274 						/* shift guys to my right */
      275 		if tuple.var_offsets (i) > 0 then
      276 		     call shift_attr;
      277 	     end;
      278 	else /* if shifting right */
      279 	     do i = vrm_rel_desc.number_var_attrs by -1 to vrm_attr_info.bit_offset + 1;
      280 		if tuple.var_offsets (i) > 0 then
      281 		     call shift_attr;
      282 	     end;
      283 
      284 	call insert_var_string;
      285 
      286 shift_attr:
      287      proc;
      288 
      289 /* Procedure to shift an attribute */
      290 
      291 	dcl     (new_offset, shift_len) fixed bin (35);
      292 
      293 	temp_count_word_ptr = add_bit_offset_ (data_ptr, tuple.var_offsets (i) - 1);
      294 	shift_len = temp_count_word_ptr -> fb35u;	/* no. bits being shifted */
      295 	if char_count then
      296 	     shift_len = shift_len * 9;		/* convert to bit length */
      297 	shift_len = shift_len + 36;			/* for count field */
      298 	new_offset = tuple.var_offsets (i) + shift_delta; /* place to shift to */
      299 
      300 /* do an in place move, if not overlapping data involved
      301*   if the target starts to the right of the source start,
      302*   and the target start is to the left of the source end we have overlap */
      303 
      304 	if tuple.var_offsets (i) <= new_offset
      305 	     & tuple.var_offsets (i) + shift_len >= new_offset then
      306 	     call use_temp_for_shift ();
      307 	else substr (data_str, new_offset, shift_len) =
      308 		substr (data_str, tuple.var_offsets (i), shift_len);
      309 
      310 use_temp_for_shift:
      311      procedure ();
      312 
      313 /* routine to use a temporary to avoid problems with in place move
      314*   that would overwrite data in the process, and result in incorrect move */
      315 
      316 	dcl     temp_string		 bit (shift_len);
      317 
      318 
      319 	temp_string = substr (data_str, tuple.var_offsets (i), shift_len);
      320 	substr (data_str, new_offset, shift_len) = temp_string;
      321 
      322      end;
      323 
      324 	tuple.var_offsets (i) = new_offset;
      325 
      326      end shift_attr;
      327 
      328      end shift_insert;
      329 
      330 insert_var_string:
      331      proc;
      332 
      333 /* Procedure to insert new varying string */
      334 
      335 	tuple.var_offsets (vrm_attr_info.bit_offset) = offset;
      336 	temp_count_word_ptr = add_bit_offset_ (data_ptr, offset - 1);
      337 	temp_count_word_ptr -> fb35u = db_val_ptr -> fb35u;
      338 	substr (data_str, offset + 36, real_bit_len) =
      339 	     substr (value_for_db, 37, real_bit_len);
      340 
      341      end insert_var_string;
      342 
      343 
      344 
      345 
      346 error:
      347      proc (cd);
      348 
      349 /* Error procedure */
      350 
      351 	dcl     cd		 fixed bin (35);
      352 
      353 	O_code = cd;
      354 	go to exit;
      355 
      356      end error;
      357 
  1     1 /*   BEGIN INCLUDE  vrm_rel_desc.incl.pl1		   */
  1     2 
  1     3 /* 83-05-26 Roger Lackey : Added vrm_attr_info.key_head bit for relation_cursors */
  1     4 
  1     5 dcl 1 vrm_rel_desc based (vrm_rel_desc_ptr),
  1     6     2 record_id bit (12) unal,			/* Distinguish us from tuples and collection records */
  1     7     2 version char (8),				/* Version of this structure */
  1     8     2 file_id bit (7),				/* Value of file id from model */
  1     9     2 rel_id bit (12),				/* Relation id */
  1    10     2 switches,
  1    11       3 MRDS_compatible bit (1) unal,			/* For pre-relation_manager_ MRDS */
  1    12       3 stationary_records
  1    13      bit (1) unal,					/* On = stationary */
  1    14       3 indexed bit (1) unal,				/* This relation has attributes with secondary indices */
  1    15       3 pad bit (33) unal,
  1    16     2 var_offset fixed bin (35),			/* Position of first varying attr */
  1    17     2 maximum_data_length
  1    18      fixed bin (35),				/* Maximum size of tuple in characters */
  1    19     2 number_primary_key_attrs
  1    20      fixed bin,					/* Number of attributes which make up the primary key */
  1    21     2 number_sec_indexes fixed bin,			/* Number of attributes which have a secondary index */
  1    22     2 last_var_attr_no fixed bin,			/* Attr index of last varying attribute */
  1    23     2 number_var_attrs fixed bin,			/* Number of varying attributes */
  1    24     2 number_attrs fixed bin,				/* Number of attribute in rel */
  1    25     2 attr (vrd_no_of_attrs				/* Description of each attribute */
  1    26      refer (vrm_rel_desc.number_attrs)) aligned like vrm_attr_info;
  1    27 
  1    28 dcl 1 vrm_attr_info based (vrm_attr_info_ptr),
  1    29 						/* Attribute specific info */
  1    30     2 name char (32),				/* Name of the attribute */
  1    31     2 descriptor bit (36) aligned,			/* domain descriptor */
  1    32     2 varying bit (1) unal,				/* ON = This is a varying string */
  1    33     2 key_head bit (1) unal,				/* ON = This attr can be a keyhead */
  1    34     2 primary_key_attr bit (1) unal,			/* ON = This is a primary key attribute */
  1    35     2 pad bit (15) unal,				/* unused */
  1    36     2 index_collextion_ix fixed bin (17) unal,		/* Index into vrm_open_info.index_collection array if key_head is on */
  1    37     2 bit_length fixed bin (35),			/* Maximum bit length of tuple */
  1    38     2 bit_offset fixed bin (35);			/* Offset in tuple if fixed, index to offset in tuple if varying */
  1    39 
  1    40 
  1    41 dcl  vrm_rel_desc_ptr pointer;
  1    42 dcl  vrd_no_of_attrs fixed bin;
  1    43 dcl  VRM_REL_DESC_RECORD_ID bit (12) unal int static options (constant) init ("100000000000"b);
  1    44 dcl  VRM_REL_DESC_VERSION_1 char (8) int static options (constant) init ("       1");
  1    45 dcl  vrm_attr_info_ptr pointer;
  1    46 dcl  VRM_REL_DESC_KEY char (256) varying int static options (constant) init ("@relation_description");
  1    47 
  1    48 /*   END INCLUDE  vrm_rel_desc.incl.pl1		   */
      358 
      359 
  2     1 /* ***********************************************************
  2     2*   *                                                         *
  2     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  2     4*   *                                                         *
  2     5*   *********************************************************** */
  2     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
  2     7 
  2     8 /* Written by Lindsey Spratt, 04/02/82.
  2     9*Modified:
  2    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
  2    11*	  unaligned.  Changed the type number of the simple_typed_vector to
  2    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
  2    13*	  type.
  2    14**/
  2    15 
  2    16 /* format: style2,ind3 */
  2    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
  2    18 	     2 type	      fixed bin (17) unal,
  2    19 	     2 number_of_dimensions
  2    20 			      fixed bin (17) unal,
  2    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
  2    22 	       3 value_ptr	      ptr unaligned;
  2    23 
  2    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
  2    25 	     2 type	      fixed bin (17) unal,
  2    26 	     2 number_of_dimensions
  2    27 			      fixed bin (17) unal,
  2    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
  2    29 	       3 identifier	      fixed bin (17) unal,
  2    30 	       3 pad	      bit (18) unal,
  2    31 	       3 value_ptr	      ptr unal;
  2    32 
  2    33      dcl	   simple_typed_vector_ptr
  2    34 			      ptr;
  2    35      dcl	   stv_number_of_dimensions
  2    36 			      fixed bin (17);
  2    37 
  2    38      dcl	   general_typed_vector_ptr
  2    39 			      ptr;
  2    40      dcl	   gtv_number_of_dimensions
  2    41 			      fixed bin (17);
  2    42 
  2    43      dcl	   (
  2    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
  2    45 			      init (1),		/* value_ptr was aligned. */
  2    46 	   GENERAL_TYPED_VECTOR_TYPE
  2    47 			      init (2),
  2    48 	   SIMPLE_TYPED_VECTOR_TYPE
  2    49 			      init (3)
  2    50 	   )		      fixed bin (17) internal static options (constant);
  2    51 
  2    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
      360 
      361 
  3     1 /* BEGIN vrm_tuple.incl.pl1 -- jaw, 7/25/78 */
  3     2 
  3     3 /* 82-08-27 R. Harvey: taken from mdbm_tuple.incl.pl1 for vfile_relmgr_.
  3     4*   Modified dimension references to point to entries in vrm_rel_desc.    */ 
  3     5 
  3     6 
  3     7 dcl 1 tuple aligned based (tuple_ptr),			/* tuple format, all file types */
  3     8     2 rel_id bit (12) unal,				/* relation id */
  3     9     2 attr_exists (vrm_rel_desc.number_attrs) bit (1) unal,	/* existance flags */
  3    10     2 var_offsets (vrm_rel_desc.number_var_attrs) fixed bin (35) unal, /* offsets for variable attr.; stored as len|value */
  3    11     2 force_even_word (tuple_pad_length) fixed bin (71) aligned, /* pad to even word boundary */
  3    12     2 data char (vrm_rel_desc.maximum_data_length) unal;		/* space for data */
  3    13 
  3    14 
  3    15 dcl  tuple_ptr ptr;
  3    16 dcl  tuple_length fixed bin (21);			/* byte count */
  3    17 
  3    18 declare  tuple_pad_length fixed bin internal static init (0) ; /* minimum array size needed for even word padding */
  3    19 
  3    20 
  3    21 
  3    22 /* END vrm_tuple.incl.pl1 */
  3    23 
      362 
      363 
      364 	dcl     (
      365 	        data_ptr,				/* pointer to tuple.data */
      366 	        db_val_ptr,				/* pointer to converted value, ready for tuple */
      367 	        last_attr_size_ptr			/* points to count word of last varying attr */
      368 	        )			 ptr;
      369 
      370 	dcl     (
      371 	        mod_flag,				/* Input: on indicats modify rather than store */
      372 	        simple_vector,
      373 	        general_vector
      374 	        )			 bit (1) aligned;
      375 
      376 	dcl     (i, j)		 fixed bin;	/* internal indexes */
      377 
      378 	dcl     (
      379 	        last_attr_len,			/* bit length of last varying attribute */
      380 	        last_attr_offset,			/* offset in tuple of value of last varying attribute */
      381 	        last_bit_offset,			/* offset in tuple of last bit of data */
      382 	        last_len_offset,			/* offset in tuple of length of last varying attribute */
      383 	        offset,				/* position to insert new attr. */
      384 	        real_bit_len,			/* bit length of used part of var. string */
      385 	        real_bit_len2,			/* bit length of used part of var. string (again) */
      386 	        shift_delta,
      387 	        tuple_header_length			/* length of header portion of tuple */
      388 	        )			 fixed bin (35);	/* bits to shift to make room for new var. attr. */
      389 
      390 
      391 	dcl     data_str		 bit (9 * vrm_rel_desc.maximum_data_length) unal based (data_ptr);
      392 						/* string view of tuple.data */
      393 	dcl     temp_count_word_ptr	 ptr;		/* points to count field portion of varying string */
      394 	dcl     value_for_db	 bit (vrm_attr_info.bit_length) based (db_val_ptr);
      395 						/* converted value, ready for tuple */
      396 /*	dcl     fb35		 fixed bin (35) based;  templates */
      397 	dcl     fb35u		 fixed bin (35) unal based;
      398 
      399 	dcl     1 descriptor	 aligned based,
      400 	        (
      401 		2 flag		 bit (1),
      402 		2 type		 fixed bin (6) unsigned, /* data type */
      403 		2 packed		 bit (1),		/* ON = unaligned */
      404 		2 number_dims	 fixed bin (4) unsigned, /* non-zero for arrays */
      405 		2 size		 fixed bin (24) unsigned
      406 		)		 unaligned,	/* size of data */
      407 		2 array_info	 (0 refer (descriptor.number_dims)),
      408 		  3 lower_bound	 fixed bin (35),
      409 		  3 upper_bound	 fixed bin (35),
      410 		  3 multiplier	 fixed bin (35);
      411 
      412 
      413 	dcl /* interesting data types */
      414 	        VAR_CHAR		 init (22)
      415 				 unsigned binary (6) static options (constant);
      416 
      417 	dcl     dm_error_$bad_vector_type ext fixed bin (35);
      418 	dcl     mdbm_error_$conversion_condition ext fixed bin (35);
      419 
      420 	dcl     conversion		 condition;
      421 
      422 	dcl     (addr, mod, string, substr) builtin;
      423 
      424 	dcl     add_bit_offset_	 entry (ptr, fixed bin (24)) returns (ptr) reducible;
      425 
      426 	dcl     char_count		 bit (1);		/* on => count field of varying string is in chars, else bits */
      427 	dcl     pad_bit_length	 fixed bin (35);	/* number of bits used in padding aligned data */
      428 	dcl     vrmu_data_length$get_data_pad_length entry (bit (36))
      429 				 returns (fixed bin (35)); /* gets padding size for  aligned data */
      430 	dcl     temp_count_word	 fixed bin (35);	/* temporary for varying attr bit length */
      431 	dcl     attr_no		 fixed bin;
      432 	dcl     attr_type		 fixed bin;
      433 	dcl     num_of_dims		 fixed bin;
      434 	dcl     binary		 builtin;
      435 	dcl     rel		 builtin;
      436 	dcl     prev_attr_no	 fixed bin;
      437 	dcl     k			 fixed bin;
      438 
      439      end vrmu_cv_vector_to_tuple;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/21/84  0920.2  vrmu_cv_vector_to_tuple.pl1       >special_ldd>online>mrds_install>vrmu_cv_vector_to_tuple.pl1
358          1    10/14/83  1609.1  vrm_rel_desc.incl.pl1             >ldd>include>vrm_rel_desc.incl.pl1
360          2    10/14/83  1609.1  vu_typed_vector.incl.pl1          >ldd>include>vu_typed_vector.incl.pl1
362          3    10/14/83  1609.1  vrm_tuple.incl.pl1                >ldd>include>vrm_tuple.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
GENERAL_TYPED_VECTOR_TYPE              constant        fixed bin(17,0)          initial dcl 2-43 ref 45
I_mod_flag                             parameter       bit(1)                   dcl 29 ref 7 50
I_rel_desc_ptr                         parameter       pointer                  dcl 26 ref 7 35
I_tuple_ptr                            parameter       pointer                  dcl 27 ref 7 36
I_typed_vector_ptr                     parameter       pointer                  dcl 28 ref 7 41
O_code                                 parameter       fixed bin(35,0)          dcl 31 set ref 7 217* 226* 353*
O_tuple_length                         parameter       fixed bin(21,0)          dcl 30 set ref 7 215*
SIMPLE_TYPED_VECTOR_TYPE               constant        fixed bin(17,0)          initial dcl 2-43 ref 42
VAR_CHAR                               constant        fixed bin(6,0)           initial unsigned dcl 413 ref 88 141
add_bit_offset_                 000014 constant        entry                    external dcl 424 ref 99 144 149 205 211 293 336
addr                                                   builtin function         dcl 422 ref 56 77 88 141 178 196 202 207
attr                     14            based           structure                array level 2 dcl 1-5 set ref 77
attr_exists               0(12)        based           bit(1)                   array level 2 packed unaligned dcl 3-7 set ref 59*
                                                                                  80*
attr_no                         000153 automatic       fixed bin(17,0)          dcl 431 set ref 73* 75* 77 80 133
attr_type                       000154 automatic       fixed bin(17,0)          dcl 432 set ref 207* 208
binary                                                 builtin function         dcl 434 ref 196 196 211 211
bit_length               12            based           fixed bin(35,0)          level 2 dcl 1-28 ref 185 185 185 338
bit_offset               27            based           fixed bin(35,0)          array level 3 in structure "vrm_rel_desc" dcl 1-5
                                                                                  in procedure "vrmu_cv_vector_to_tuple" set ref 134
bit_offset               13            based           fixed bin(35,0)          level 2 in structure "vrm_attr_info" dcl 1-28
                                                                                  in procedure "vrmu_cv_vector_to_tuple" ref 96 115
                                                                                  122 185 272 278 335
cd                                     parameter       fixed bin(35,0)          dcl 351 ref 346 353
char_count                      000150 automatic       bit(1)                   unaligned dcl 426 set ref 88* 91 103 295
conversion                      000142 stack reference condition                dcl 420 ref 53
data                                   based           char                     level 2 packed unaligned dcl 3-7 set ref 56 196 202
data_ptr                        000114 automatic       pointer                  dcl 364 set ref 56* 60 99* 144* 149* 185 202* 205*
                                                                                  211* 293* 307 307 319 320 336* 338
data_str                               based           bit                      unaligned dcl 391 set ref 60* 185* 307* 307 319 320*
                                                                                  338*
db_val_ptr                      000116 automatic       pointer                  dcl 364 set ref 82* 84* 91 93 185 337 338
descriptor               10            based           bit(36)                  level 2 in structure "vrm_attr_info" dcl 1-28
                                                                                  in procedure "vrmu_cv_vector_to_tuple" set ref 88
                                                                                  178 182
descriptor                             based           structure                level 1 dcl 399 in procedure
                                                                                  "vrmu_cv_vector_to_tuple"
descriptor               24            based           bit(36)                  array level 3 in structure "vrm_rel_desc" dcl 1-5
                                                                                  in procedure "vrmu_cv_vector_to_tuple" set ref 141
                                                                                  207
dimension                 1            based           structure                array level 2 in structure "simple_typed_vector"
                                                                                  packed unaligned dcl 2-17 in procedure
                                                                                  "vrmu_cv_vector_to_tuple"
dimension                 1            based           structure                array level 2 in structure "general_typed_vector"
                                                                                  packed unaligned dcl 2-24 in procedure
                                                                                  "vrmu_cv_vector_to_tuple"
dm_error_$bad_vector_type       000010 external static fixed bin(35,0)          dcl 417 set ref 47*
fb35u                                  based           fixed bin(35,0)          unaligned dcl 397 set ref 91 93 102 146 151 206 294
                                                                                  337* 337
general_typed_vector                   based           structure                level 1 packed unaligned dcl 2-24
general_typed_vector_ptr        000106 automatic       pointer                  dcl 2-38 set ref 41* 45 67 73 82
general_vector                  000124 automatic       bit(1)                   dcl 370 set ref 40* 45* 67 73 82
i                               000125 automatic       fixed bin(17,0)          dcl 376 in procedure "vrmu_cv_vector_to_tuple" set
                                                                                  ref 61* 62* 71* 73 75 82 84*
i                               000212 automatic       fixed bin(17,0)          dcl 270 in procedure "shift_insert" set ref 272*
                                                                                  275* 278* 280* 293 298 304 304 307 319 324
identifier                1            based           fixed bin(17,0)          array level 3 packed unaligned dcl 2-24 ref 73
j                               000126 automatic       fixed bin(17,0)          dcl 376 set ref 115* 115* 120 122* 122* 126 134 144
                                                                                  149 153 162
k                               000157 automatic       fixed bin(17,0)          dcl 437 set ref 133* 134 134 134*
last_attr_len                   000127 automatic       fixed bin(35,0)          dcl 378 set ref 206* 208* 208 210
last_attr_offset                000130 automatic       fixed bin(35,0)          dcl 378 set ref 204* 210
last_attr_size_ptr              000120 automatic       pointer                  dcl 364 set ref 205* 206
last_bit_offset                 000131 automatic       fixed bin(35,0)          dcl 378 set ref 210* 211
last_len_offset                 000132 automatic       fixed bin(35,0)          dcl 378 set ref 203* 204 205
last_var_attr_no         11            based           fixed bin(17,0)          level 2 dcl 1-5 ref 207
maximum_data_length       6            based           fixed bin(35,0)          level 2 dcl 1-5 ref 56 60 185 196 199 202 307 307
                                                                                  319 320 338
mdbm_error_$conversion_condition
                                000012 external static fixed bin(35,0)          dcl 418 ref 226
mod                                                    builtin function         dcl 422 ref 259
mod_flag                        000122 automatic       bit(1)                   dcl 370 set ref 50* 58 95
new_offset                      000224 automatic       fixed bin(35,0)          dcl 291 set ref 298* 304 304 307 320 324
num_of_dims                     000155 automatic       fixed bin(17,0)          dcl 433 set ref 67* 69* 71
number_attrs             13            based           fixed bin(17,0)          level 2 dcl 1-5 ref 56 59 62 96 115 122 144 149 153
                                                                                  162 196 202 203 275 280 293 298 304 304 307 319
                                                                                  324 335
number_of_dimensions      0(18)        based           fixed bin(17,0)          level 2 in structure "general_typed_vector" packed
                                                                                  unaligned dcl 2-24 in procedure
                                                                                  "vrmu_cv_vector_to_tuple" ref 67
number_of_dimensions      0(18)        based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  unaligned dcl 2-17 in procedure
                                                                                  "vrmu_cv_vector_to_tuple" ref 69
number_var_attrs         12            based           fixed bin(17,0)          level 2 dcl 1-5 ref 56 61 115 120 196 199 202 203
                                                                                  272 278
o                               000173 automatic       fixed bin(35,0)          dcl 240 set ref 242* 244* 245
offset                                 parameter       fixed bin(35,0)          dcl 256 in procedure "word_align" set ref 253 259
                                                                                  260* 260
offset                          000133 automatic       fixed bin(35,0)          dcl 378 in procedure "vrmu_cv_vector_to_tuple" set
                                                                                  ref 96* 98* 99 127* 153* 156* 162* 163* 335 336
                                                                                  338
old_bit_len                            parameter       fixed bin(35,0)          dcl 238 ref 231 242
pad_bit_length                  000151 automatic       fixed bin(35,0)          dcl 427 set ref 178* 182* 185
prev_attr_no                    000156 automatic       fixed bin(17,0)          dcl 436 set ref 134* 141
r                               000172 automatic       fixed bin(35,0)          dcl 240 set ref 241* 243* 245
real_bit_len                           parameter       fixed bin(35,0)          dcl 237 in procedure "compute_shift" ref 231 241
real_bit_len                    000134 automatic       fixed bin(35,0)          dcl 378 in procedure "vrmu_cv_vector_to_tuple" set
                                                                                  ref 91* 93* 105* 166* 338 338
real_bit_len2                   000135 automatic       fixed bin(35,0)          dcl 378 set ref 146* 151* 153
rel                                                    builtin function         dcl 435 ref 196 196 211 211
rel_id                                 based           bit(12)                  level 2 in structure "tuple" packed unaligned
                                                                                  dcl 3-7 in procedure "vrmu_cv_vector_to_tuple" set
                                                                                  ref 64*
rel_id                    2(25)        based           bit(12)                  level 2 in structure "vrm_rel_desc" packed unaligned
                                                                                  dcl 1-5 in procedure "vrmu_cv_vector_to_tuple" ref
                                                                                  64
shift_delta                            parameter       fixed bin(35,0)          dcl 239 in procedure "compute_shift" set ref 231
                                                                                  245*
shift_delta                     000136 automatic       fixed bin(35,0)          dcl 378 in procedure "vrmu_cv_vector_to_tuple" set
                                                                                  ref 105* 109 166* 272 298
shift_len                       000225 automatic       fixed bin(35,0)          dcl 291 set ref 294* 295* 295 297* 297 304 307 307
                                                                                  316 319 320
simple_typed_vector                    based           structure                level 1 packed unaligned dcl 2-17
simple_typed_vector_ptr         000104 automatic       pointer                  dcl 2-33 set ref 41* 42 69 84
simple_vector                   000123 automatic       bit(1)                   dcl 370 set ref 40* 42*
slop                            000202 automatic       fixed bin(35,0)          dcl 258 set ref 259* 260 260
string                                                 builtin function         dcl 422 set ref 59*
substr                                                 builtin function         dcl 422 set ref 185* 185 307* 307 319 320* 338* 338
temp_count_word                 000152 automatic       fixed bin(35,0)          dcl 430 set ref 102* 103* 103 105*
temp_count_word_ptr             000140 automatic       pointer                  dcl 393 set ref 99* 102 144* 146 149* 151 293* 294
                                                                                  336* 337
temp_string                     000100 automatic       bit                      unaligned dcl 316 set ref 319* 320
tuple                                  based           structure                level 1 dcl 3-7
tuple_header_length             000137 automatic       fixed bin(35,0)          dcl 378 set ref 196* 199
tuple_length                    000112 automatic       fixed bin(21,0)          dcl 3-16 set ref 199* 211* 215
tuple_pad_length                       constant        fixed bin(17,0)          initial dcl 3-18 ref 56 196 202
tuple_ptr                       000110 automatic       pointer                  dcl 3-15 set ref 36* 56 59 62 64 80 96 115 122 144
                                                                                  149 153 162 196 196 202 203 211 275 280 293 298
                                                                                  304 304 307 319 324 335
type                                   based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  unaligned dcl 2-17 in procedure
                                                                                  "vrmu_cv_vector_to_tuple" ref 42
type                                   based           fixed bin(17,0)          level 2 in structure "general_typed_vector" packed
                                                                                  unaligned dcl 2-24 in procedure
                                                                                  "vrmu_cv_vector_to_tuple" ref 45
type                      0(01)        based           fixed bin(6,0)           level 2 in structure "descriptor" packed unsigned
                                                                                  unaligned dcl 399 in procedure
                                                                                  "vrmu_cv_vector_to_tuple" ref 88 141 178 207
value_for_db                           based           bit                      unaligned dcl 394 ref 185 338
value_ptr                 2            based           pointer                  array level 3 in structure "general_typed_vector"
                                                                                  packed unaligned dcl 2-24 in procedure
                                                                                  "vrmu_cv_vector_to_tuple" ref 82
value_ptr                 1            based           pointer                  array level 3 in structure "simple_typed_vector"
                                                                                  packed unaligned dcl 2-17 in procedure
                                                                                  "vrmu_cv_vector_to_tuple" ref 84
var_offset                5            based           fixed bin(35,0)          level 2 dcl 1-5 ref 127
var_offsets                            based           fixed bin(35,0)          array level 2 packed unaligned dcl 3-7 set ref 62*
                                                                                  96 115 122 144 149 153 162 203 275 280 293 298 304
                                                                                  304 307 319 324* 335*
varying                  11            based           bit(1)                   level 2 in structure "vrm_attr_info" packed
                                                                                  unaligned dcl 1-28 in procedure
                                                                                  "vrmu_cv_vector_to_tuple" ref 86
varying                  25            based           bit(1)                   array level 3 in structure "vrm_rel_desc" packed
                                                                                  unaligned dcl 1-5 in procedure
                                                                                  "vrmu_cv_vector_to_tuple" set ref 134
vrm_attr_info                          based           structure                level 1 unaligned dcl 1-28
vrm_attr_info_ptr               000102 automatic       pointer                  dcl 1-45 set ref 77* 86 88 96 115 122 178 182 185
                                                                                  185 185 185 272 278 335 338
vrm_rel_desc                           based           structure                level 1 unaligned dcl 1-5
vrm_rel_desc_ptr                000100 automatic       pointer                  dcl 1-41 set ref 35* 56 56 56 59 60 61 62 64 77 96
                                                                                  115 115 120 122 127 134 134 141 144 149 153 162
                                                                                  185 196 196 196 199 199 202 202 202 203 203 207
                                                                                  207 272 275 278 280 293 298 304 304 307 307 307
                                                                                  319 319 320 324 335 338
vrmu_data_length$get_data_pad_length
                                000016 constant        entry                    external dcl 428 ref 182

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 2-43
VRM_REL_DESC_KEY                       internal static varying char(256)        initial dcl 1-46
VRM_REL_DESC_RECORD_ID                 internal static bit(12)                  initial unaligned dcl 1-43
VRM_REL_DESC_VERSION_1                 internal static char(8)                  initial unaligned dcl 1-44
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 2-40
stv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 2-35
vrd_no_of_attrs                        automatic       fixed bin(17,0)          dcl 1-42

NAMES DECLARED BY EXPLICIT CONTEXT.
compute_shift                   001212 constant        entry                    internal dcl 231 ref 105 166
conversion_error                001205 constant        label                    dcl 226 ref 53
error                           001654 constant        entry                    internal dcl 346 ref 47
exit                            001204 constant        label                    dcl 219 ref 229 354
insert_var_string               001575 constant        entry                    internal dcl 330 ref 109 158 284
shift_attr                      001364 constant        entry                    internal dcl 286 ref 275 280
shift_insert                    001265 constant        entry                    internal dcl 265 ref 111 170
use_temp_for_shift              001521 constant        entry                    internal dcl 310 ref 304
vrmu_cv_vector_to_tuple         000015 constant        entry                    external dcl 7
word_align                      001240 constant        entry                    internal dcl 253 ref 98 156 163 243 244

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2040        2060    1720        2050
Length      2316    1720        20         221     120           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
vrmu_cv_vector_to_tuple             210 external procedure  is an external procedure.  
on unit on line 53                   64 on unit               
compute_shift                           internal procedure  shares stack frame of external procedure vrmu_cv_vector_to_tuple.  
word_align                              internal procedure  shares stack frame of external procedure vrmu_cv_vector_to_tuple.  
shift_insert                            internal procedure  shares stack frame of external procedure vrmu_cv_vector_to_tuple.  
shift_attr                              internal procedure  shares stack frame of external procedure vrmu_cv_vector_to_tuple.  
use_temp_for_shift                   69 internal procedure  uses auto adjustable storage.  
insert_var_string                       internal procedure  shares stack frame of external procedure vrmu_cv_vector_to_tuple.  
error                                   internal procedure  shares stack frame of external procedure vrmu_cv_vector_to_tuple.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
use_temp_for_shift       000100 temp_string                 use_temp_for_shift
vrmu_cv_vector_to_tuple  000100 vrm_rel_desc_ptr            vrmu_cv_vector_to_tuple
                         000102 vrm_attr_info_ptr           vrmu_cv_vector_to_tuple
                         000104 simple_typed_vector_ptr     vrmu_cv_vector_to_tuple
                         000106 general_typed_vector_ptr    vrmu_cv_vector_to_tuple
                         000110 tuple_ptr                   vrmu_cv_vector_to_tuple
                         000112 tuple_length                vrmu_cv_vector_to_tuple
                         000114 data_ptr                    vrmu_cv_vector_to_tuple
                         000116 db_val_ptr                  vrmu_cv_vector_to_tuple
                         000120 last_attr_size_ptr          vrmu_cv_vector_to_tuple
                         000122 mod_flag                    vrmu_cv_vector_to_tuple
                         000123 simple_vector               vrmu_cv_vector_to_tuple
                         000124 general_vector              vrmu_cv_vector_to_tuple
                         000125 i                           vrmu_cv_vector_to_tuple
                         000126 j                           vrmu_cv_vector_to_tuple
                         000127 last_attr_len               vrmu_cv_vector_to_tuple
                         000130 last_attr_offset            vrmu_cv_vector_to_tuple
                         000131 last_bit_offset             vrmu_cv_vector_to_tuple
                         000132 last_len_offset             vrmu_cv_vector_to_tuple
                         000133 offset                      vrmu_cv_vector_to_tuple
                         000134 real_bit_len                vrmu_cv_vector_to_tuple
                         000135 real_bit_len2               vrmu_cv_vector_to_tuple
                         000136 shift_delta                 vrmu_cv_vector_to_tuple
                         000137 tuple_header_length         vrmu_cv_vector_to_tuple
                         000140 temp_count_word_ptr         vrmu_cv_vector_to_tuple
                         000150 char_count                  vrmu_cv_vector_to_tuple
                         000151 pad_bit_length              vrmu_cv_vector_to_tuple
                         000152 temp_count_word             vrmu_cv_vector_to_tuple
                         000153 attr_no                     vrmu_cv_vector_to_tuple
                         000154 attr_type                   vrmu_cv_vector_to_tuple
                         000155 num_of_dims                 vrmu_cv_vector_to_tuple
                         000156 prev_attr_no                vrmu_cv_vector_to_tuple
                         000157 k                           vrmu_cv_vector_to_tuple
                         000172 r                           compute_shift
                         000173 o                           compute_shift
                         000202 slop                        word_align
                         000212 i                           shift_insert
                         000224 new_offset                  shift_attr
                         000225 shift_len                   shift_attr

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out        call_int_this       return              tra_ext             alloc_auto_adj
mpfx2               mod_fx3             enable              ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
add_bit_offset_               vrmu_data_length$get_data_pad_length

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bad_vector_type     mdbm_error_$conversion_condition




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      7 000007        35 000022        36 000026        40 000031        41 000033        42 000037        45 000052
     47 000064        50 000072        53 000076        56 000115        58 000135        59 000137        60 000144
     61 000151        62 000161        63 000173        64 000175        67 000203        69 000215        71 000224
     73 000233        75 000247        77 000250        80 000253        82 000260        84 000273        86 000302
     88 000305        91 000313        93 000324        95 000332        96 000334        98 000351        99 000353
    102 000374       103 000403       105 000407       109 000411       111 000415       112 000416       115 000417
    118 000446       120 000450       122 000454       124 000504       126 000507       127 000512       128 000515
    133 000516       134 000525       137 000541       141 000544       144 000556       146 000615       147 000625
    149 000626       151 000665       153 000674       156 000714       158 000716       159 000717       162 000720
    163 000734       166 000736       170 000742       175 000743       178 000744       182 000753       185 000766
    192 001005       196 001007       199 001043       202 001053       203 001056       204 001066       205 001072
    206 001113       207 001122       208 001133       210 001140       211 001147       215 001201       217 001203
    219 001204       226 001205       229 001211       231 001212       241 001214       242 001220       243 001224
    244 001226       245 001230       246 001237       253 001240       259 001242       260 001255       262 001264
    265 001265       272 001266       275 001303       277 001321       278 001324       280 001340       282 001357
    284 001362       328 001363       286 001364       293 001365       294 001424       295 001433       297 001437
    298 001443       304 001447       307 001466       324 001500       326 001517       310 001520       316 001526
    319 001536       320 001564       322 001574       330 001575       335 001576       336 001616       337 001637
    338 001644       341 001653       346 001654       353 001656       354 001661


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
